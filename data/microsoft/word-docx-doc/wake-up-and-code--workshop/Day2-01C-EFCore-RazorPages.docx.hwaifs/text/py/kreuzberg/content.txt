**ASP.NET Core Razor Pages with EF Core - tutorial series**

Source: [https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp) 

This series of tutorials teaches how to create ASP.NET Core Razor Pages web apps that use Entity Framework (EF) Core for data access.

1. [<u>Get started</u>](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2)
2. [<u>Create, Read, Update, and Delete operations</u>](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/crud?view=aspnetcore-2.2)
3. [<u>Sorting, filtering, paging, and grouping</u>](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/sort-filter-page?view=aspnetcore-2.2)
4. [<u>Migrations</u>](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/migrations?view=aspnetcore-2.2)
5. [<u>Create a complex data model</u>](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2)
6. [<u>Reading related data</u>](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/read-related-data?view=aspnetcore-2.2)
7. [<u>Updating related data</u>](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/update-related-data?view=aspnetcore-2.2)
8. [<u>Handle concurrency conflicts</u>](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/concurrency?view=aspnetcore-2.2)

# Part 1 of 8

The Contoso University sample web app demonstrates how to create an ASP.NET Core Razor Pages app using Entity Framework (EF) Core.

The sample app is a web site for a fictional Contoso University. It includes functionality such as student admission, course creation, and instructor assignments. This page is the first in a series of tutorials that explain how to build the Contoso University sample app.

[Download or view the completed app.](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples) [Download instructions](https://docs.microsoft.com/en-us/aspnet/core/index?view=aspnetcore-2.2).

## Prerequisites

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2&amp;tabs=visual-studio)

[Visual Studio 2017 version 15.7.3 or later](https://visualstudio.microsoft.com/downloads/) with the following workloads:

- ASP.NET and web development
- .NET Core cross-platform development

[.NET Core 2.1 SDK or later](https://www.microsoft.com/net/download/windows)

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2&amp;tabs=visual-studio)
- [<u>.NET Core 2.1 SDK or later</u>](https://www.microsoft.com/net/download/all)

CONTINUE… 

Familiarity with [Razor Pages](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/index?view=aspnetcore-2.2). New programmers should complete [Get started with Razor Pages](https://docs.microsoft.com/en-us/aspnet/core/tutorials/razor-pages/razor-pages-start?view=aspnetcore-2.2) before starting this series.

## Troubleshooting

If you run into a problem you can't resolve, you can generally find the solution by comparing your code to the [completed project](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples). A good way to get help is by posting a question to [StackOverflow.com](https://stackoverflow.com/questions/tagged/asp.net-core) for [ASP.NET Core](https://stackoverflow.com/questions/tagged/asp.net-core) or [EF Core](https://stackoverflow.com/questions/tagged/entity-framework-core).

## The Contoso University web app

The app built in these tutorials is a basic university web site.

Users can view and update student, course, and instructor information. Here are a few of the screens created in the tutorial.

![Students Index page](image_0)

![Students Edit page](image_1)

The UI style of this site is close to what's generated by the built-in templates. The tutorial focus is on EF Core with Razor Pages, not the UI.

## Create the ContosoUniversity Razor Pages web app

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2&amp;tabs=visual-studio)
- From the Visual Studio File menu, select New  Project.
- Create a new ASP.NET Core Web Application. Name the project ContosoUniversity. It's important to name the project ContosoUniversity so the namespaces match when code is copy/pasted.
- Select ASP.NET Core 2.1 in the dropdown, and then select Web Application.

For images of the preceding steps, see [Create a Razor web app](https://docs.microsoft.com/en-us/aspnet/core/tutorials/razor-pages/razor-pages-start?view=aspnetcore-2.2). Run the app.

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2&amp;tabs=visual-studio)

CLICopy

dotnet new webapp -o ContosoUniversity

cd ContosoUniversity

dotnet run

## CONTINUE…

## Set up the site style

A few changes set up the site menu, layout, and home page. Update Pages/Shared/_Layout.cshtml with the following changes:

- Change each occurrence of "ContosoUniversity" to "Contoso University". There are three occurrences.
- Add menu entries for Students, Courses, Instructors, and Departments, and delete the Contact menu entry.

The changes are highlighted. (All the markup is not displayed.)

HTMLCopy

!DOCTYPE html

html

head

    meta charset="utf-8" /

    meta name="viewport" content="width=device-width, initial-scale=1.0" /

    title@ViewData["Title"] : Contoso University/title

    environment include="Development"

        link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.css" /

        link rel="stylesheet" href="~/css/site.css" /

    /environment

    environment exclude="Development"

        link rel="stylesheet" href="https://ajax.aspnetcdn.com/ajax/bootstrap/3.3.7/css/bootstrap.min.css"

              asp-fallback-href="~/lib/bootstrap/dist/css/bootstrap.min.css"

              asp-fallback-test-class="sr-only" asp-fallback-test-property="position" asp-fallback-test-value="absolute" /

        link rel="stylesheet" href="~/css/site.min.css" asp-append-version="true" /

    /environment

/head

body

    nav class="navbar navbar-inverse navbar-fixed-top"

        div class="container"

            div class="navbar-header"

                button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"

                    span class="sr-only"Toggle navigation/span

                    span class="icon-bar"/span

                    span class="icon-bar"/span

                    span class="icon-bar"/span

                /button

                a asp-page="/Index" class="navbar-brand"Contoso University/a

            /div

            div class="navbar-collapse collapse"

                ul class="nav navbar-nav"

                    lia asp-page="/Index"Home/a/li

                    lia asp-page="/About"About/a/li

                    lia asp-page="/Students/Index"Students/a/li

                    lia asp-page="/Courses/Index"Courses/a/li

                    lia asp-page="/Instructors/Index"Instructors/a/li

                    lia asp-page="/Departments/Index"Departments/a/li

                /ul

            /div

        /div

    /nav

    partial name="_CookieConsentPartial" /

    div class="container body-content"

        @RenderBody()

        hr /

        footer

            pcopy; 2018 : Contoso University/p

        /footer

    /div

    @*Remaining markup not shown for brevity.*@

In Pages/Index.cshtml, replace the contents of the file with the following code to replace the text about ASP.NET and MVC with text about this app:

HTMLCopy

@page

@model IndexModel

@{

    ViewData["Title"] = "Home page";

}

div class="jumbotron"

    h1Contoso University/h1

/div

div class="row"

    div class="col-md-4"

        h2Welcome to Contoso University/h2

        p

            Contoso University is a sample application that

            demonstrates how to use Entity Framework Core in an

            ASP.NET Core Razor Pages web app.

        /p

    /div

    div class="col-md-4"

        h2Build it from scratch/h2

        pYou can build the application by following the steps in a series of tutorials./p

        p

            a class="btn btn-default"

               href="https://docs.microsoft.com/aspnet/core/data/ef-rp/intro"

                See the tutorial raquo;

            /a

        /p

    /div

    div class="col-md-4"

        h2Download it/h2

        pYou can download the completed project from GitHub./p

        p

            a class="btn btn-default"

               href="https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples/cu-final"

                See project source code raquo;

            /a

        /p

    /div

/div

## Create the data model

Create entity classes for the Contoso University app. Start with the following three entities:

![Course-Enrollment-Student data model diagram](image_2)

There's a one-to-many relationship between Student and Enrollment entities. There's a one-to-many relationship between Course and Enrollment entities. A student can enroll in any number of courses. A course can have any number of students enrolled in it.

In the following sections, a class for each one of these entities is created.

### The Student entity

![Student entity diagram](image_3)

Create a Models folder. In the Models folder, create a class file named Student.cs with the following code:

C#Copy

using System;

using System.Collections.Generic;

namespace ContosoUniversity.Models

{

    public class Student

    {

        public int ID { get; set; }

        public string LastName { get; set; }

        public string FirstMidName { get; set; }

        public DateTime EnrollmentDate { get; set; }

        public ICollectionEnrollment Enrollments { get; set; }

    }

}

The ID property becomes the primary key column of the database (DB) table that corresponds to this class. By default, EF Core interprets a property that's named ID or classnameID as the primary key. In classnameID, classname is the name of the class. The alternative automatically recognized primary key is StudentID in the preceding example.

The Enrollments property is a [navigation property](https://docs.microsoft.com/ef/core/modeling/relationships). Navigation properties link to other entities that are related to this entity. In this case, the Enrollments property of a Student entity holds all of the Enrollment entities that are related to that Student. For example, if a Student row in the DB has two related Enrollment rows, the Enrollments navigation property contains those two Enrollment entities. A related Enrollment row is a row that contains that student's primary key value in the StudentID column. For example, suppose the student with ID=1 has two rows in the Enrollment table. The Enrollment table has two rows with StudentID = 1. StudentID is a foreign key in the Enrollment table that specifies the student in the Student table.

If a navigation property can hold multiple entities, the navigation property must be a list type, such as ICollectionT. ICollectionT can be specified, or a type such as ListT or HashSetT. When ICollectionT is used, EF Core creates a HashSetT collection by default. Navigation properties that hold multiple entities come from many-to-many and one-to-many relationships.

### The Enrollment entity

![Enrollment entity diagram](image_4)

In the Models folder, create Enrollment.cs with the following code:

C#Copy

namespace ContosoUniversity.Models

{

    public enum Grade

    {

        A, B, C, D, F

    }

    public class Enrollment

    {

        public int EnrollmentID { get; set; }

        public int CourseID { get; set; }

        public int StudentID { get; set; }

        public Grade? Grade { get; set; }

        public Course Course { get; set; }

        public Student Student { get; set; }

    }

}

The EnrollmentID property is the primary key. This entity uses the classnameID pattern instead of ID like the Student entity. Typically developers choose one pattern and use it throughout the data model. In a later tutorial, using ID without classname is shown to make it easier to implement inheritance in the data model.

The Grade property is an enum. The question mark after the Grade type declaration indicates that the Grade property is nullable. A grade that's null is different from a zero grade -- null means a grade isn't known or hasn't been assigned yet.

The StudentID property is a foreign key, and the corresponding navigation property is Student. An Enrollment entity is associated with one Student entity, so the property contains a single Student entity. The Student entity differs from the Student.Enrollments navigation property, which contains multiple Enrollment entities.

The CourseID property is a foreign key, and the corresponding navigation property is Course. An Enrollment entity is associated with one Course entity.

EF Core interprets a property as a foreign key if it's named navigation property nameprimary key property name. For example,StudentID for the Student navigation property, since the Student entity's primary key is ID. Foreign key properties can also be named primary key property name. For example, CourseID since the Course entity's primary key is CourseID.

### The Course entity

![Course entity diagram](image_5)

In the Models folder, create Course.cs with the following code:

C#Copy

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class Course

    {

        [DatabaseGenerated(DatabaseGeneratedOption.None)]

        public int CourseID { get; set; }

        public string Title { get; set; }

        public int Credits { get; set; }

        public ICollectionEnrollment Enrollments { get; set; }

    }

}

The Enrollments property is a navigation property. A Course entity can be related to any number of Enrollment entities.

The DatabaseGenerated attribute allows the app to specify the primary key rather than having the DB generate it.

## Scaffold the student model

In this section, the student model is scaffolded. That is, the scaffolding tool produces pages for Create, Read, Update, and Delete (CRUD) operations for the student model.

- Build the project.
- Create the Pages/Students folder.
- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2&amp;tabs=visual-studio)
- In Solution Explorer, right click on the Pages/Students folder  Add  New Scaffolded Item.
- In the Add Scaffold dialog, select Razor Pages using Entity Framework (CRUD)  ADD.

Complete the Add Razor Pages using Entity Framework (CRUD) dialog:

- In the Model class drop-down, select Student (ContosoUniversity.Models).
- In the Data context class row, select the + (plus) sign and change the generated name to ContosoUniversity.Models.SchoolContext.
- In the Data context class drop-down, select ContosoUniversity.Models.SchoolContext
- Select Add.

![CRUD dialog](image_6)

See [Scaffold the movie model](https://docs.microsoft.com/en-us/aspnet/core/tutorials/razor-pages/model?view=aspnetcore-2.2) if you have a problem with the preceding step.

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2&amp;tabs=visual-studio) 

Run the following commands to scaffold the student model.

consoleCopy

dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 2.1.0

dotnet aspnet-codegenerator razorpage -m Student -dc ContosoUniversity.Models.SchoolContext

CONTINUE… 

The scaffold process created and changed the following files:

### Files created

- Pages/Students Create, Delete, Details, Edit, Index.
- Data/SchoolContext.cs

### File updates

- Startup.cs : Changes to this file are detailed in the next section.
- appsettings.json : The connection string used to connect to a local database is added.

## Examine the context registered with dependency injection

ASP.NET Core is built with [dependency injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2). Services (such as the EF Core DB context) are registered with dependency injection during application startup. Components that require these services (such as Razor Pages) are provided these services via constructor parameters. The constructor code that gets a db context instance is shown later in the tutorial.

The scaffolding tool automatically created a DB Context and registered it with the dependency injection container.

Examine the ConfigureServices method in Startup.cs. The highlighted line was added by the scaffolder:

C#Copy

public void ConfigureServices(IServiceCollection services)

{

    services.ConfigureCookiePolicyOptions(options =

    {

        // This lambda determines whether user consent for 

        //non -essential cookies is needed for a given request.

        options.CheckConsentNeeded = context = true;

        options.MinimumSameSitePolicy = SameSiteMode.None;

    });

    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);

    services.AddDbContextSchoolContext(options =

       options.UseSqlServer(Configuration.GetConnectionString("SchoolContext")));

}

The name of the connection string is passed in to the context by calling a method on a [DbContextOptions](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontextoptions)object. For local development, the [ASP.NET Core configuration system](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/index?view=aspnetcore-2.2) reads the connection string from the appsettings.json file.

## Update main

In Program.cs, modify the Main method to do the following:

- Get a DB context instance from the dependency injection container.
- Call the [EnsureCreated](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.infrastructure.databasefacade.ensurecreated).
- Dispose the context when the EnsureCreated method completes.

The following code shows the updated Program.cs file.

C#Copy

using ContosoUniversity.Models;                   // SchoolContext

using Microsoft.AspNetCore;

using Microsoft.AspNetCore.Hosting;

using Microsoft.Extensions.DependencyInjection;   // CreateScope

using Microsoft.Extensions.Logging;

using System;

namespace ContosoUniversity

{

    public class Program

    {

        public static void Main(string[] args)

        {

            var host = CreateWebHostBuilder(args).Build();

            using (var scope = host.Services.CreateScope())

            {

                var services = scope.ServiceProvider;

                try

                {

                    var context = services.GetRequiredServiceSchoolContext();

                    context.Database.EnsureCreated();

                }

                catch (Exception ex)

                {

                    var logger = services.GetRequiredServiceILoggerProgram();

                    logger.LogError(ex, "An error occurred creating the DB.");

                }

            }

            host.Run();

        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =

            WebHost.CreateDefaultBuilder(args)

                .UseStartupStartup();

    }

}

EnsureCreated ensures that the database for the context exists. If it exists, no action is taken. If it does not exist, then the database and all its schema are created. EnsureCreated does not use migrations to create the database. A database that is created with EnsureCreated cannot be later updated using migrations.

EnsureCreated is called on app start, which allows the following work flow:

- Delete the DB.
- Change the DB schema (for example, add an EmailAddress field).
- Run the app.
- EnsureCreated creates a DB with theEmailAddress column.

EnsureCreated is convenient early in development when the schema is rapidly evolving. Later in the tutorial the DB is deleted and migrations are used.

### Test the app

Run the app and accept the cookie policy. This app doesn't keep personal information. You can read about the cookie policy at [EU General Data Protection Regulation (GDPR) support](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-2.2).

- Select the Students link and then Create New.
- Test the Edit, Details, and Delete links.

## Examine the SchoolContext DB context

The main class that coordinates EF Core functionality for a given data model is the DB context class. The data context is derived from [Microsoft.EntityFrameworkCore.DbContext](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext). The data context specifies which entities are included in the data model. In this project, the class is named SchoolContext.

Update SchoolContext.cs with the following code:

C#Copy

using Microsoft.EntityFrameworkCore;

namespace ContosoUniversity.Models

{

    public class SchoolContext : DbContext

    {

        public SchoolContext(DbContextOptionsSchoolContext options)

            : base(options)

        {

        }

        public DbSetStudent Student { get; set; }

        public DbSetEnrollment Enrollment { get; set; }

        public DbSetCourse Course { get; set; }

    }

}

The highlighted code creates a [DbSetTEntity](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbset-1) property for each entity set. In EF Core terminology:

- An entity set typically corresponds to a DB table.
- An entity corresponds to a row in the table.

DbSetEnrollment and DbSetCourse could be omitted. EF Core includes them implicitly because the Student entity references the Enrollment entity, and the Enrollment entity references the Course entity. For this tutorial, keep DbSetEnrollment and DbSetCourse in the SchoolContext.

### SQL Server Express LocalDB

The connection string specifies [SQL Server LocalDB](https://docs.microsoft.com/sql/database-engine/configure-windows/sql-server-2016-express-localdb). LocalDB is a lightweight version of the SQL Server Express Database Engine and is intended for app development, not production use. LocalDB starts on demand and runs in user mode, so there's no complex configuration. By default, LocalDB creates .mdf DB files in the C:/Users/user directory.

## Add code to initialize the DB with test data

EF Core creates an empty DB. In this section, an Initialize method is written to populate it with test data.

In the Data folder, create a new class file named DbInitializer.cs and add the following code:

C#Copy

using ContosoUniversity.Models;

using System;

using System.Linq;

namespace ContosoUniversity.Models

{

    public static class DbInitializer

    {

        public static void Initialize(SchoolContext context)

        {

            // context.Database.EnsureCreated();

            // Look for any students.

            if (context.Student.Any())

            {

                return;   // DB has been seeded

            }

            var students = new Student[]

            {

            new Student{FirstMidName="Carson",LastName="Alexander",EnrollmentDate=DateTime.Parse("2005-09-01")},

            new Student{FirstMidName="Meredith",LastName="Alonso",EnrollmentDate=DateTime.Parse("2002-09-01")},

            new Student{FirstMidName="Arturo",LastName="Anand",EnrollmentDate=DateTime.Parse("2003-09-01")},

            new Student{FirstMidName="Gytis",LastName="Barzdukas",EnrollmentDate=DateTime.Parse("2002-09-01")},

            new Student{FirstMidName="Yan",LastName="Li",EnrollmentDate=DateTime.Parse("2002-09-01")},

            new Student{FirstMidName="Peggy",LastName="Justice",EnrollmentDate=DateTime.Parse("2001-09-01")},

            new Student{FirstMidName="Laura",LastName="Norman",EnrollmentDate=DateTime.Parse("2003-09-01")},

            new Student{FirstMidName="Nino",LastName="Olivetto",EnrollmentDate=DateTime.Parse("2005-09-01")}

            };

            foreach (Student s in students)

            {

                context.Student.Add(s);

            }

            context.SaveChanges();

            var courses = new Course[]

            {

            new Course{CourseID=1050,Title="Chemistry",Credits=3},

            new Course{CourseID=4022,Title="Microeconomics",Credits=3},

            new Course{CourseID=4041,Title="Macroeconomics",Credits=3},

            new Course{CourseID=1045,Title="Calculus",Credits=4},

            new Course{CourseID=3141,Title="Trigonometry",Credits=4},

            new Course{CourseID=2021,Title="Composition",Credits=3},

            new Course{CourseID=2042,Title="Literature",Credits=4}

            };

            foreach (Course c in courses)

            {

                context.Course.Add(c);

            }

            context.SaveChanges();

            var enrollments = new Enrollment[]

            {

            new Enrollment{StudentID=1,CourseID=1050,Grade=Grade.A},

            new Enrollment{StudentID=1,CourseID=4022,Grade=Grade.C},

            new Enrollment{StudentID=1,CourseID=4041,Grade=Grade.B},

            new Enrollment{StudentID=2,CourseID=1045,Grade=Grade.B},

            new Enrollment{StudentID=2,CourseID=3141,Grade=Grade.F},

            new Enrollment{StudentID=2,CourseID=2021,Grade=Grade.F},

            new Enrollment{StudentID=3,CourseID=1050},

            new Enrollment{StudentID=4,CourseID=1050},

            new Enrollment{StudentID=4,CourseID=4022,Grade=Grade.F},

            new Enrollment{StudentID=5,CourseID=4041,Grade=Grade.C},

            new Enrollment{StudentID=6,CourseID=1045},

            new Enrollment{StudentID=7,CourseID=3141,Grade=Grade.A},

            };

            foreach (Enrollment e in enrollments)

            {

                context.Enrollment.Add(e);

            }

            context.SaveChanges();

        }

    }

}

The code checks if there are any students in the DB. If there are no students in the DB, the DB is initialized with test data. It loads test data into arrays rather than ListT collections to optimize performance.

The EnsureCreated method automatically creates the DB for the DB context. If the DB exists, EnsureCreatedreturns without modifying the DB.

In Program.cs, modify the Main method to call Initialize:

C#Copy

public class Program

{

    public static void Main(string[] args)

    {

        var host = CreateWebHostBuilder(args).Build();

        using (var scope = host.Services.CreateScope())

        {

            var services = scope.ServiceProvider;

            try

            {

                var context = services.GetRequiredServiceSchoolContext();

                // using ContosoUniversity.Data; 

                DbInitializer.Initialize(context);

            }

            catch (Exception ex)

            {

                var logger = services.GetRequiredServiceILoggerProgram();

                logger.LogError(ex, "An error occurred creating the DB.");

            }

        }

        host.Run();

    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =

        WebHost.CreateDefaultBuilder(args)

            .UseStartupStartup();

}

Delete any student records and restart the app. If the DB is not initialized, set a break point in Initialize to diagnose the problem.

## View the DB

Open SQL Server Object Explorer (SSOX) from the View menu in Visual Studio. In SSOX, click (localdb)\MSSQLLocalDB  Databases  ContosoUniversity1.

Expand the Tables node.

Right-click the Student table and click View Data to see the columns created and the rows inserted into the table.

## Asynchronous code

Asynchronous programming is the default mode for ASP.NET Core and EF Core.

A web server has a limited number of threads available, and in high load situations all of the available threads might be in use. When that happens, the server can't process new requests until the threads are freed up. With synchronous code, many threads may be tied up while they aren't actually doing any work because they're waiting for I/O to complete. With asynchronous code, when a process is waiting for I/O to complete, its thread is freed up for the server to use for processing other requests. As a result, asynchronous code enables server resources to be used more efficiently, and the server is enabled to handle more traffic without delays.

Asynchronous code does introduce a small amount of overhead at run time. For low traffic situations, the performance hit is negligible, while for high traffic situations, the potential performance improvement is substantial.

In the following code, the [async](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async) keyword, TaskT return value, await keyword, and ToListAsync method make the code execute asynchronously.

C#Copy

public async Task OnGetAsync()

{

    Student = await _context.Student.ToListAsync();

}

- The async keyword tells the compiler to:
  - Generate callbacks for parts of the method body.
  - Automatically create the [Task](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task) object that's returned. For more information, see [Task Return Type](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/async-return-types).
- The implicit return type Task represents ongoing work.
- The await keyword causes the compiler to split the method into two parts. The first part ends with the operation that's started asynchronously. The second part is put into a callback method that's called when the operation completes.
- ToListAsync is the asynchronous version of the ToList extension method.

Some things to be aware of when writing asynchronous code that uses EF Core:

- Only statements that cause queries or commands to be sent to the DB are executed asynchronously. That includes, ToListAsync, SingleOrDefaultAsync, FirstOrDefaultAsync, and SaveChangesAsync. It doesn't include statements that just change an IQueryable, such as var students = context.Students.Where(s = s.LastName == "Davolio").
- An EF Core context isn't thread safe: don't try to do multiple operations in parallel.
- To take advantage of the performance benefits of async code, verify that library packages (such as for paging) use async if they call EF Core methods that send queries to the DB.

For more information about asynchronous programming in .NET, see [Async Overview](https://docs.microsoft.com/en-us/dotnet/standard/async) and [Asynchronous programming with async and await](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/).

In the next tutorial, basic CRUD (create, read, update, delete) operations are examined.

# Part 2 of 8

The Contoso University web app demonstrates how to create Razor Pages web apps using EF Core and Visual Studio. For information about the tutorial series, see [the first tutorial](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2).

In this tutorial, the scaffolded CRUD (create, read, update, delete) code is reviewed and customized.

To minimize complexity and keep these tutorials focused on EF Core, EF Core code is used in the page models. Some developers use a service layer or repository pattern in to create an abstraction layer between the UI (Razor Pages) and the data access layer.

In this tutorial, the Create, Edit, Delete, and Details Razor Pages in the Students folder are examined.

The scaffolded code uses the following pattern for Create, Edit, and Delete pages:

- Get and display the requested data with the HTTP GET method OnGetAsync.
- Save changes to the data with the HTTP POST method OnPostAsync.

The Index and Details pages get and display the requested data with the HTTP GET method OnGetAsync

## SingleOrDefaultAsync vs. FirstOrDefaultAsync

The generated code uses [FirstOrDefaultAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync), which is generally preferred over [SingleOrDefaultAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.singleordefaultasync).

FirstOrDefaultAsync is more efficient than SingleOrDefaultAsync at fetching one entity:

- Unless the code needs to verify that there's not more than one entity returned from the query.
- SingleOrDefaultAsync fetches more data and does unnecessary work.
- SingleOrDefaultAsync throws an exception if there's more than one entity that fits the filter part.
- FirstOrDefaultAsync doesn't throw if there's more than one entity that fits the filter part.

### FindAsync

In much of the scaffolded code, [FindAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.findasync) can be used in place of FirstOrDefaultAsync.

FindAsync:

- Finds an entity with the primary key (PK). If an entity with the PK is being tracked by the context, it's returned without a request to the DB.
- Is simple and concise.
- Is optimized to look up a single entity.
- Can have perf benefits in some situations, but that rarely happens for typical web apps.
- Implicitly uses [FirstAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstasync) instead of [SingleAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.singleasync).

But if you want to Include other entities, then FindAsync is no longer appropriate. This means that you may need to abandon FindAsync and move to a query as your app progresses.

## Customize the Details page

Browse to Pages/Students page. The Edit, Details, and Delete links are generated by the [Anchor Tag Helper](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/anchor-tag-helper?view=aspnetcore-2.2) in the Pages/Students/Index.cshtml file.

CSHTMLCopy

td

    a asp-page="./Edit" asp-route-id="@item.ID"Edit/a |

    a asp-page="./Details" asp-route-id="@item.ID"Details/a |

    a asp-page="./Delete" asp-route-id="@item.ID"Delete/a

/td

Run the app and select a Details link. The URL is of the form http://localhost:5000/Students/Details?id=2. The Student ID is passed using a query string (?id=2).

Update the Edit, Details, and Delete Razor Pages to use the "{id:int}" route template. Change the page directive for each of these pages from @page to @page "{id:int}".

A request to the page with the "{id:int}" route template that does not include a integer route value returns an HTTP 404 (not found) error. For example, http://localhost:5000/Students/Details returns a 404 error. To make the ID optional, append ? to the route constraint:

CSHTMLCopy

@page "{id:int?}"

Run the app, click on a Details link, and verify the URL is passing the ID as route data (http://localhost:5000/Students/Details/2).

Don't globally change @page to @page "{id:int}", doing so breaks the links to the Home and Create pages.

### Add related data

The scaffolded code for the Students Index page doesn't include the Enrollments property. In this section, the contents of the Enrollments collection is displayed in the Details page.

The OnGetAsync method of Pages/Students/Details.cshtml.cs uses the FirstOrDefaultAsync method to retrieve a single Student entity. Add the following highlighted code:

C#Copy

public async TaskIActionResult OnGetAsync(int? id)

{

    if (id == null)

    {

        return NotFound();

    }

    Student = await _context.Student

                        .Include(s = s.Enrollments)

                            .ThenInclude(e = e.Course)

                        .AsNoTracking()

                        .FirstOrDefaultAsync(m = m.ID == id);

    if (Student == null)

    {

        return NotFound();

    }

    return Page();

}

The [Include](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.include) and [ThenInclude](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.theninclude) methods cause the context to load the Student.Enrollments navigation property, and within each enrollment the Enrollment.Course navigation property. These methods are examined in detail in the reading-related data tutorial.

The [AsNoTracking](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.asnotracking) method improves performance in scenarios when the entities returned are not updated in the current context. AsNoTracking is discussed later in this tutorial.

### Display related enrollments on the Details page

Open Pages/Students/Details.cshtml. Add the following highlighted code to display a list of enrollments:

CSHTMLCopy

@page "{id:int}"

@model ContosoUniversity.Pages.Students.DetailsModel

@{

    ViewData["Title"] = "Details";

}

h2Details/h2

div

    h4Student/h4

    hr /

    dl class="dl-horizontal"

        dt

            @Html.DisplayNameFor(model = model.Student.LastName)

        /dt

        dd

            @Html.DisplayFor(model = model.Student.LastName)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Student.FirstMidName)

        /dt

        dd

            @Html.DisplayFor(model = model.Student.FirstMidName)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Student.EnrollmentDate)

        /dt

        dd

            @Html.DisplayFor(model = model.Student.EnrollmentDate)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Student.Enrollments)

        /dt

        dd

            table class="table"

                tr

                    thCourse Title/th

                    thGrade/th

                /tr

                @foreach (var item in Model.Student.Enrollments)

                {

                    tr

                        td

                            @Html.DisplayFor(modelItem = item.Course.Title)

                        /td

                        td

                            @Html.DisplayFor(modelItem = item.Grade)

                        /td

                    /tr

                }

            /table

        /dd

    /dl

/div

div

    a asp-page="./Edit" asp-route-id="@Model.Student.ID"Edit/a |

    a asp-page="./Index"Back to List/a

/div

If code indentation is wrong after the code is pasted, press CTRL-K-D to correct it.

The preceding code loops through the entities in the Enrollments navigation property. For each enrollment, it displays the course title and the grade. The course title is retrieved from the Course entity that's stored in the Course navigation property of the Enrollments entity.

Run the app, select the Students tab, and click the Details link for a student. The list of courses and grades for the selected student is displayed.

## Update the Create page

Update the OnPostAsync method in Pages/Students/Create.cshtml.cs with the following code:

C#Copy

public async TaskIActionResult OnPostAsync()

{

    if (!ModelState.IsValid)

    {

        return Page();

    }

    var emptyStudent = new Student();

    if (await TryUpdateModelAsyncStudent(

        emptyStudent,

        "student",   // Prefix for form value.

        s = s.FirstMidName, s = s.LastName, s = s.EnrollmentDate))

    {

        _context.Student.Add(emptyStudent);

        await _context.SaveChangesAsync();

        return RedirectToPage("./Index");

    }

    return null;

}

### TryUpdateModelAsync

Examine the [TryUpdateModelAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.tryupdatemodelasync) code:

C#Copy

var emptyStudent = new Student();

if (await TryUpdateModelAsyncStudent(

    emptyStudent,

    "student",   // Prefix for form value.

    s = s.FirstMidName, s = s.LastName, s = s.EnrollmentDate))

{

In the preceding code, TryUpdateModelAsyncStudent tries to update the emptyStudent object using the posted form values from the [PageContext](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.razorpages.pagemodel.pagecontext) property in the [PageModel](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.razorpages.pagemodel). TryUpdateModelAsync only updates the properties listed (s = s.FirstMidName, s = s.LastName, s = s.EnrollmentDate).

In the preceding sample:

- The second argument ("student", // Prefix) is the prefix uses to look up values. It's not case sensitive.
- The posted form values are converted to the types in the Student model using [model binding](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding?view=aspnetcore-2.2).

### Overposting

Using TryUpdateModel to update fields with posted values is a security best practice because it prevents overposting. For example, suppose the Student entity includes a Secret property that this web page shouldn't update or add:

C#Copy

public class Student

{

    public int ID { get; set; }

    public string LastName { get; set; }

    public string FirstMidName { get; set; }

    public DateTime EnrollmentDate { get; set; }

    public string Secret { get; set; }

}

Even if the app doesn't have a Secret field on the create/update Razor Page, a hacker could set the Secretvalue by overposting. A hacker could use a tool such as Fiddler, or write some JavaScript, to post a Secretform value. The original code doesn't limit the fields that the model binder uses when it creates a Student instance.

Whatever value the hacker specified for the Secret form field is updated in the DB. The following image shows the Fiddler tool adding the Secret field (with the value "OverPost") to the posted form values.

![Fiddler adding Secret field](image_7)

The value "OverPost" is successfully added to the Secret property of the inserted row. The app designer never intended the Secret property to be set with the Create page.

### View model

A view model typically contains a subset of the properties included in the model used by the application. The application model is often called the domain model. The domain model typically contains all the properties required by the corresponding entity in the DB. The view model contains only the properties needed for the UI layer (for example, the Create page). In addition to the view model, some apps use a binding model or input model to pass data between the Razor Pages page model class and the browser. Consider the following Student view model:

C#Copy

using System;

namespace ContosoUniversity.Models

{

    public class StudentVM

    {

        public int ID { get; set; }

        public string LastName { get; set; }

        public string FirstMidName { get; set; }

        public DateTime EnrollmentDate { get; set; }

    }

}

View models provide an alternative way to prevent overposting. The view model contains only the properties to view (display) or update.

The following code uses the StudentVM view model to create a new student:

C#Copy

[BindProperty]

public StudentVM StudentVM { get; set; }

public async TaskIActionResult OnPostAsync()

{

    if (!ModelState.IsValid)

    {

        return Page();

    }

    var entry = _context.Add(new Student());

    entry.CurrentValues.SetValues(StudentVM);

    await _context.SaveChangesAsync();

    return RedirectToPage("./Index");

}

The [SetValues](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.changetracking.propertyvalues.setvalues) method sets the values of this object by reading values from another [PropertyValues](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.changetracking.propertyvalues) object. SetValues uses property name matching. The view model type doesn't need to be related to the model type, it just needs to have properties that match.

Using StudentVM requires [CreateVM.cshtml](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples/cu21/Pages/Students/CreateVM.cshtml) be updated to use StudentVM rather than Student.

In Razor Pages, the PageModel derived class is the view model.

## Update the Edit page

Update the page model for the Edit page. The major changes are highlighted:

C#Copy

public class EditModel : PageModel

{

    private readonly SchoolContext _context;

    public EditModel(SchoolContext context)

    {

        _context = context;

    }

    [BindProperty]

    public Student Student { get; set; }

    public async TaskIActionResult OnGetAsync(int? id)

    {

        if (id == null)

        {

            return NotFound();

        }

        Student = await _context.Student.FindAsync(id);

        if (Student == null)

        {

            return NotFound();

        }

        return Page();

    }

    public async TaskIActionResult OnPostAsync(int? id)

    {

        if (!ModelState.IsValid)

        {

            return Page();

        }

        var studentToUpdate = await _context.Student.FindAsync(id);

        if (await TryUpdateModelAsyncStudent(

            studentToUpdate,

            "student",

            s = s.FirstMidName, s = s.LastName, s = s.EnrollmentDate))

        {

            await _context.SaveChangesAsync();

            return RedirectToPage("./Index");

        }

        return Page();

    }

}

The code changes are similar to the Create page with a few exceptions:

- OnPostAsync has an optional id parameter.
- The current student is fetched from the DB, rather than creating an empty student.
- FirstOrDefaultAsync has been replaced with [FindAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbset-1.findasync). FindAsync is a good choice when selecting an entity from the primary key. See [FindAsync](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/crud?view=aspnetcore-2.2) for more information.

### Test the Edit and Create pages

Create and edit a few student entities.

## Entity States

The DB context keeps track of whether entities in memory are in sync with their corresponding rows in the DB. The DB context sync information determines what happens when [SaveChangesAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.savechangesasync) is called. For example, when a new entity is passed to the [AddAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.addasync) method, that entity's state is set to [Added](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entitystate). When SaveChangesAsync is called, the DB context issues a SQL INSERT command.

An entity may be in one of the [following states](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entitystate):

- Added: The entity doesn't yet exist in the DB. The SaveChanges method issues an INSERT statement.
- Unchanged: No changes need to be saved with this entity. An entity has this status when it's read from the DB.
- Modified: Some or all of the entity's property values have been modified. The SaveChanges method issues an UPDATE statement.
- Deleted: The entity has been marked for deletion. The SaveChanges method issues a DELETE statement.
- Detached: The entity isn't being tracked by the DB context.

In a desktop app, state changes are typically set automatically. An entity is read, changes are made, and the entity state to automatically be changed to Modified. Calling SaveChanges generates a SQL UPDATE statement that updates only the changed properties.

In a web app, the DbContext that reads an entity and displays the data is disposed after a page is rendered. When a page's OnPostAsync method is called, a new web request is made and with a new instance of the DbContext. Re-reading the entity in that new context simulates desktop processing.

## Update the Delete page

In this section, code is added to implement a custom error message when the call to SaveChanges fails. Add a string to contain possible error messages:

C#Copy

public class DeleteModel : PageModel

{

    private readonly SchoolContext _context;

    public DeleteModel(SchoolContext context)

    {

        _context = context;

    }

    [BindProperty]

    public Student Student { get; set; }

    public string ErrorMessage { get; set; }

Replace the OnGetAsync method with the following code:

C#Copy

public async TaskIActionResult OnGetAsync(int? id, bool? saveChangesError = false)

{

    if (id == null)

    {

        return NotFound();

    }

    Student = await _context.Student

        .AsNoTracking()

        .FirstOrDefaultAsync(m = m.ID == id);

    if (Student == null)

    {

        return NotFound();

    }

    if (saveChangesError.GetValueOrDefault())

    {

        ErrorMessage = "Delete failed. Try again";

    }

    return Page();

}

The preceding code contains the optional parameter saveChangesError. saveChangesError indicates whether the method was called after a failure to delete the student object. The delete operation might fail because of transient network problems. Transient network errors are more likely in the cloud. saveChangesErroris false when the Delete page OnGetAsync is called from the UI. When OnGetAsync is called by OnPostAsync (because the delete operation failed), the saveChangesError parameter is true.

### The Delete pages OnPostAsync method

Replace the OnPostAsync with the following code:

C#Copy

public async TaskIActionResult OnPostAsync(int? id)

{

    if (id == null)

    {

        return NotFound();

    }

    var student = await _context.Student

                    .AsNoTracking()

                    .FirstOrDefaultAsync(m = m.ID == id);

    if (student == null)

    {

        return NotFound();

    }

    try

    {

        _context.Student.Remove(student);

        await _context.SaveChangesAsync();

        return RedirectToPage("./Index");

    }

    catch (DbUpdateException /* ex */)

    {

        //Log the error (uncomment ex variable name and write a log.)

        return RedirectToAction("./Delete",

                             new { id, saveChangesError = true });

    }

}

The preceding code retrieves the selected entity, then calls the [Remove](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.remove) method to set the entity's status to Deleted. When SaveChanges is called, a SQL DELETE command is generated. If Remove fails:

- The DB exception is caught.
- The Delete pages OnGetAsync method is called with saveChangesError=true.

### Update the Delete Razor Page

Add the following highlighted error message to the Delete Razor Page.

CSHTMLCopy

@page "{id:int}"

@model ContosoUniversity.Pages.Students.DeleteModel

@{

    ViewData["Title"] = "Delete";

}

h2Delete/h2

p class="text-danger"@Model.ErrorMessage/p

h3Are you sure you want to delete this?/h3

div

Test Delete.

## Common errors

Students/Index or other links don't work:

Verify the Razor Page contains the correct @page directive. For example, The Students/Index Razor Page should not contain a route template:

CSHTMLCopy

@page "{id:int}"

Each Razor Page must include the @page directive.

# Part 3 of 8

The Contoso University web app demonstrates how to create Razor Pages web apps using EF Core and Visual Studio. For information about the tutorial series, see [the first tutorial](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2).

In this tutorial, sorting, filtering, grouping, and paging, functionality is added.

The following illustration shows a completed page. The column headings are clickable links to sort the column. Clicking a column heading repeatedly switches between ascending and descending sort order.

![Students index page](image_8)

If you run into problems you can't solve, download the [completed app](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples).

## Add sorting to the Index page

Add strings to the Students/Index.cshtml.cs PageModel to contain the sorting parameters:

C#Copy

public class IndexModel : PageModel

{

    private readonly SchoolContext _context;

    public IndexModel(SchoolContext context)

    {

        _context = context;

    }

    public string NameSort { get; set; }

    public string DateSort { get; set; }

    public string CurrentFilter { get; set; }

    public string CurrentSort { get; set; }

Update the Students/Index.cshtml.cs OnGetAsync with the following code:

C#Copy

public async Task OnGetAsync(string sortOrder)

{

    NameSort = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";

    DateSort = sortOrder == "Date" ? "date_desc" : "Date";

    IQueryableStudent studentIQ = from s in _context.Student

                                    select s;

    switch (sortOrder)

    {

        case "name_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.LastName);

            break;

        case "Date":

            studentIQ = studentIQ.OrderBy(s = s.EnrollmentDate);

            break;

        case "date_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.EnrollmentDate);

            break;

        default:

            studentIQ = studentIQ.OrderBy(s = s.LastName);

            break;

    }

    Student = await studentIQ.AsNoTracking().ToListAsync();

}

The preceding code receives a sortOrder parameter from the query string in the URL. The URL (including the query string) is generated by the [Anchor Tag Helper](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/anchor-tag-helper?view=aspnetcore-2.2)

The sortOrder parameter is either "Name" or "Date." The sortOrder parameter is optionally followed by "_desc" to specify descending order. The default sort order is ascending.

When the Index page is requested from the Students link, there's no query string. The students are displayed in ascending order by last name. Ascending order by last name is the default (fall-through case) in the switchstatement. When the user clicks a column heading link, the appropriate sortOrder value is provided in the query string value.

NameSort and DateSort are used by the Razor Page to configure the column heading hyperlinks with the appropriate query string values:

C#Copy

public async Task OnGetAsync(string sortOrder)

{

    NameSort = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";

    DateSort = sortOrder == "Date" ? "date_desc" : "Date";

    IQueryableStudent studentIQ = from s in _context.Student

                                    select s;

    switch (sortOrder)

    {

        case "name_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.LastName);

            break;

        case "Date":

            studentIQ = studentIQ.OrderBy(s = s.EnrollmentDate);

            break;

        case "date_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.EnrollmentDate);

            break;

        default:

            studentIQ = studentIQ.OrderBy(s = s.LastName);

            break;

    }

    Student = await studentIQ.AsNoTracking().ToListAsync();

}

The following code contains the C# conditional [?: operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator):

C#Copy

NameSort = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";

DateSort = sortOrder == "Date" ? "date_desc" : "Date";

The first line specifies that when sortOrder is null or empty, NameSort is set to "name_desc." If sortOrder is not null or empty, NameSort is set to an empty string.

The ?: operator is also known as the ternary operator.

These two statements enable the page to set the column heading hyperlinks as follows:

| **Current sort order** | **Last Name Hyperlink** | **Date Hyperlink** |
| ---------------------- | ----------------------- | ------------------ |
| Last Name ascending    | descending              | ascending          |
| Last Name descending   | ascending               | ascending          |
| Date ascending         | ascending               | descending         |
| Date descending        | ascending               | ascending          |

The method uses LINQ to Entities to specify the column to sort by. The code initializes an IQueryableStudent before the switch statement, and modifies it in the switch statement:

C#Copy

public async Task OnGetAsync(string sortOrder)

{

    NameSort = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";

    DateSort = sortOrder == "Date" ? "date_desc" : "Date";

    IQueryableStudent studentIQ = from s in _context.Student

                                    select s;

    switch (sortOrder)

    {

        case "name_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.LastName);

            break;

        case "Date":

            studentIQ = studentIQ.OrderBy(s = s.EnrollmentDate);

            break;

        case "date_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.EnrollmentDate);

            break;

        default:

            studentIQ = studentIQ.OrderBy(s = s.LastName);

            break;

    }

    Student = await studentIQ.AsNoTracking().ToListAsync();

}

When anIQueryable is created or modified, no query is sent to the database. The query isn't executed until the IQueryable object is converted into a collection. IQueryable are converted to a collection by calling a method such as ToListAsync. Therefore, the IQueryable code results in a single query that's not executed until the following statement:

C#Copy

Student = await studentIQ.AsNoTracking().ToListAsync();

OnGetAsync could get verbose with a large number of sortable columns.

### Add column heading hyperlinks to the Student Index page

Replace the code in Students/Index.cshtml, with the following highlighted code:

HTMLCopy

@page

@model ContosoUniversity.Pages.Students.IndexModel

@{

    ViewData["Title"] = "Index";

}

h2Index/h2

p

    a asp-page="Create"Create New/a

/p

table class="table"

    thead

        tr

            th

                a asp-page="./Index" asp-route-sortOrder="@Model.NameSort"

                    @Html.DisplayNameFor(model = model.Student[0].LastName)

                /a

            /th

            th

                @Html.DisplayNameFor(model = model.Student[0].FirstMidName)

            /th

            th

                a asp-page="./Index" asp-route-sortOrder="@Model.DateSort"

                    @Html.DisplayNameFor(model = model.Student[0].EnrollmentDate)

                /a

            /th

            th/th

        /tr

    /thead

    tbody

        @foreach (var item in Model.Student)

        {

            tr

                td

                    @Html.DisplayFor(modelItem = item.LastName)

                /td

                td

                    @Html.DisplayFor(modelItem = item.FirstMidName)

                /td

                td

                    @Html.DisplayFor(modelItem = item.EnrollmentDate)

                /td

                td

                    a asp-page="./Edit" asp-route-id="@item.ID"Edit/a |

                    a asp-page="./Details" asp-route-id="@item.ID"Details/a |

                    a asp-page="./Delete" asp-route-id="@item.ID"Delete/a

                /td

            /tr

        }

    /tbody

/table

The preceding code:

- Adds hyperlinks to the LastName and EnrollmentDate column headings.
- Uses the information in NameSort and DateSort to set up hyperlinks with the current sort order values.

To verify that sorting works:

- Run the app and select the Students tab.
- Click Last Name.
- Click Enrollment Date.

To get a better understanding of the code:

- In Students/Index.cshtml.cs, set a breakpoint on switch (sortOrder).
- Add a watch for NameSort and DateSort.
- In Students/Index.cshtml, set a breakpoint on @Html.DisplayNameFor(model = model.Student[0].LastName).

Step through the debugger.

## Add a Search Box to the Students Index page

To add filtering to the Students Index page:

- A text box and a submit button is added to the Razor Page. The text box supplies a search string on the first or last name.
- The page model is updated to use the text box value.

### Add filtering functionality to the Index method

Update the Students/Index.cshtml.cs OnGetAsync with the following code:

C#Copy

public async Task OnGetAsync(string sortOrder, string searchString)

{

    NameSort = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";

    DateSort = sortOrder == "Date" ? "date_desc" : "Date";

    CurrentFilter = searchString;

    IQueryableStudent studentIQ = from s in _context.Student

                                    select s;

    if (!String.IsNullOrEmpty(searchString))

    {

        studentIQ = studentIQ.Where(s = s.LastName.Contains(searchString)

                               || s.FirstMidName.Contains(searchString));

    }

    switch (sortOrder)

    {

        case "name_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.LastName);

            break;

        case "Date":

            studentIQ = studentIQ.OrderBy(s = s.EnrollmentDate);

            break;

        case "date_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.EnrollmentDate);

            break;

        default:

            studentIQ = studentIQ.OrderBy(s = s.LastName);

            break;

    }

    Student = await studentIQ.AsNoTracking().ToListAsync();

}

The preceding code:

- Adds the searchString parameter to the OnGetAsync method. The search string value is received from a text box that's added in the next section.
- Added to the LINQ statement a Where clause. The Where clause selects only students whose first name or last name contains the search string. The LINQ statement is executed only if there's a value to search for.

Note: The preceding code calls the Where method on an IQueryable object, and the filter is processed on the server. In some scenarios, the app might be calling the Where method as an extension method on an in-memory collection. For example, suppose _context.Students changes from EF Core DbSet to a repository method that returns an IEnumerable collection. The result would normally be the same but in some cases may be different.

For example, the .NET Framework implementation of Contains performs a case-sensitive comparison by default. In SQL Server, Contains case-sensitivity is determined by the collation setting of the SQL Server instance. SQL Server defaults to case-insensitive. ToUpper could be called to make the test explicitly case-insensitive:

Where(s = s.LastName.ToUpper().Contains(searchString.ToUpper())

The preceding code would ensure that results are case-insensitive if the code changes to use IEnumerable. When Contains is called on an IEnumerable collection, the .NET Core implementation is used. When Contains is called on an IQueryable object, the database implementation is used. Returning an IEnumerablefrom a repository can have a significant performance penality:

1. All the rows are returned from the DB server.
2. The filter is applied to all the returned rows in the application.

There's a performance penalty for calling ToUpper. The ToUpper code adds a function in the WHERE clause of the TSQL SELECT statement. The added function prevents the optimizer from using an index. Given that SQL is installed as case-insensitive, it's best to avoid the ToUpper call when it's not needed.

### Add a Search Box to the Student Index page

In Pages/Students/Index.cshtml, add the following highlighted code to create a Search button and assorted chrome.

HTMLCopy

@page

@model ContosoUniversity.Pages.Students.IndexModel

@{

    ViewData["Title"] = "Index";

}

h2Index/h2

p

    a asp-page="Create"Create New/a

/p

form asp-page="./Index" method="get"

    div class="form-actions no-color"

        p

            Find by name:

            input type="text" name="SearchString" value="@Model.CurrentFilter" /

            input type="submit" value="Search" class="btn btn-default" / |

            a asp-page="./Index"Back to full List/a

        /p

    /div

/form

table class="table"

The preceding code uses the form [tag helper](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-2.2) to add the search text box and button. By default, the form tag helper submits form data with a POST. With POST, the parameters are passed in the HTTP message body and not in the URL. When HTTP GET is used, the form data is passed in the URL as query strings. Passing the data with query strings enables users to bookmark the URL. The [W3C guidelines](https://www.w3.org/2001/tag/doc/whenToUseGet.html)recommend that GET should be used when the action doesn't result in an update.

Test the app:

- Select the Students tab and enter a search string.
- Select Search.

Notice that the URL contains the search string.

HTMLCopy

http://localhost:5000/Students?SearchString=an

If the page is bookmarked, the bookmark contains the URL to the page and the SearchString query string. The method="get" in the form tag is what caused the query string to be generated.

Currently, when a column heading sort link is selected, the filter value from the Search box is lost. The lost filter value is fixed in the next section.

## Add paging functionality to the Students Index page

In this section, a PaginatedList class is created to support paging. The PaginatedList class uses Skip and Take statements to filter data on the server instead of retrieving all rows of the table. The following illustration shows the paging buttons.

![Students index page with paging links](image_9)

In the project folder, create PaginatedList.cs with the following code:

C#Copy

using System;

using System.Collections.Generic;

using System.Linq;

using System.Threading.Tasks;

using Microsoft.EntityFrameworkCore;

namespace ContosoUniversity

{

    public class PaginatedListT : ListT

    {

        public int PageIndex { get; private set; }

        public int TotalPages { get; private set; }

        public PaginatedList(ListT items, int count, int pageIndex, int pageSize)

        {

            PageIndex = pageIndex;

            TotalPages = (int)Math.Ceiling(count / (double)pageSize);

            this.AddRange(items);

        }

        public bool HasPreviousPage

        {

            get

            {

                return (PageIndex  1);

            }

        }

        public bool HasNextPage

        {

            get

            {

                return (PageIndex  TotalPages);

            }

        }

        public static async TaskPaginatedListT CreateAsync(

            IQueryableT source, int pageIndex, int pageSize)

        {

            var count = await source.CountAsync();

            var items = await source.Skip(

                (pageIndex - 1) * pageSize)

                .Take(pageSize).ToListAsync();

            return new PaginatedListT(items, count, pageIndex, pageSize);

        }

    }

}

The CreateAsync method in the preceding code takes page size and page number and applies the appropriate Skip and Take statements to the IQueryable. When ToListAsync is called on the IQueryable, it returns a List containing only the requested page. The properties HasPreviousPage and HasNextPage are used to enable or disable Previous and Next paging buttons.

The CreateAsync method is used to create the PaginatedListT. A constructor can't create the PaginatedListT object, constructors can't run asynchronous code.

## Add paging functionality to the Index method

In Students/Index.cshtml.cs, update the type of Student from IListStudent to PaginatedListStudent:

C#Copy

public PaginatedListStudent Student { get; set; }

Update the Students/Index.cshtml.cs OnGetAsync with the following code:

C#Copy

public async Task OnGetAsync(string sortOrder,

    string currentFilter, string searchString, int? pageIndex)

{

    CurrentSort = sortOrder;

    NameSort = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";

    DateSort = sortOrder == "Date" ? "date_desc" : "Date";

    if (searchString != null)

    {

        pageIndex = 1;

    }

    else

    {

        searchString = currentFilter;

    }

    CurrentFilter = searchString;

    IQueryableStudent studentIQ = from s in _context.Student

                                    select s;

    if (!String.IsNullOrEmpty(searchString))

    {

        studentIQ = studentIQ.Where(s = s.LastName.Contains(searchString)

                               || s.FirstMidName.Contains(searchString));

    }

    switch (sortOrder)

    {

        case "name_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.LastName);

            break;

        case "Date":

            studentIQ = studentIQ.OrderBy(s = s.EnrollmentDate);

            break;

        case "date_desc":

            studentIQ = studentIQ.OrderByDescending(s = s.EnrollmentDate);

            break;

        default:

            studentIQ = studentIQ.OrderBy(s = s.LastName);

            break;

    }

    int pageSize = 3;

    Student = await PaginatedListStudent.CreateAsync(

        studentIQ.AsNoTracking(), pageIndex ?? 1, pageSize);

}

The preceding code adds the page index, the current sortOrder, and the currentFilter to the method signature.

C#Copy

public async Task OnGetAsync(string sortOrder,

    string currentFilter, string searchString, int? pageIndex)

All the parameters are null when:

- The page is called from the Students link.
- The user hasn't clicked a paging or sorting link.

When a paging link is clicked, the page index variable contains the page number to display.

CurrentSort provides the Razor Page with the current sort order. The current sort order must be included in the paging links to keep the sort order while paging.

CurrentFilter provides the Razor Page with the current filter string. The CurrentFilter value:

- Must be included in the paging links in order to maintain the filter settings during paging.
- Must be restored to the text box when the page is redisplayed.

If the search string is changed while paging, the page is reset to 1. The page has to be reset to 1 because the new filter can result in different data to display. When a search value is entered and Submit is selected:

- The search string is changed.
- The searchString parameter isn't null.

C#Copy

if (searchString != null)

{

    pageIndex = 1;

}

else

{

    searchString = currentFilter;

}

The PaginatedList.CreateAsync method converts the student query to a single page of students in a collection type that supports paging. That single page of students is passed to the Razor Page.

C#Copy

Student = await PaginatedListStudent.CreateAsync(

    studentIQ.AsNoTracking(), pageIndex ?? 1, pageSize);

The two question marks in PaginatedList.CreateAsync represent the [null-coalescing operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operator). The null-coalescing operator defines a default value for a nullable type. The expression (pageIndex ?? 1) means return the value of pageIndex if it has a value. If pageIndex doesn't have a value, return 1.

## Add paging links to the student Razor Page

Update the markup in Students/Index.cshtml. The changes are highlighted:

HTMLCopy

@page

@model ContosoUniversity.Pages.Students.IndexModel

@{

    ViewData["Title"] = "Index";

}

h2Index/h2

p

    a asp-page="Create"Create New/a

/p

form asp-page="./Index" method="get"

    div class="form-actions no-color"

        p

            Find by name: input type="text" name="SearchString" value="@Model.CurrentFilter" /

            input type="submit" value="Search" class="btn btn-default" / |

            a asp-page="./Index"Back to full List/a

        /p

    /div

/form

table class="table"

    thead

        tr

            th

                a asp-page="./Index" asp-route-sortOrder="@Model.NameSort"

                   asp-route-currentFilter="@Model.CurrentFilter"

                    @Html.DisplayNameFor(model = model.Student[0].LastName)

                /a

            /th

            th

                @Html.DisplayNameFor(model = model.Student[0].FirstMidName)

            /th

            th

                a asp-page="./Index" asp-route-sortOrder="@Model.DateSort"

                   asp-route-currentFilter="@Model.CurrentFilter"

                    @Html.DisplayNameFor(model = model.Student[0].EnrollmentDate)

                /a

            /th

            th/th

        /tr

    /thead

    tbody

        @foreach (var item in Model.Student)

        {

            tr

                td

                    @Html.DisplayFor(modelItem = item.LastName)

                /td

                td

                    @Html.DisplayFor(modelItem = item.FirstMidName)

                /td

                td

                    @Html.DisplayFor(modelItem = item.EnrollmentDate)

                /td

                td

                    a asp-page="./Edit" asp-route-id="@item.ID"Edit/a |

                    a asp-page="./Details" asp-route-id="@item.ID"Details/a |

                    a asp-page="./Delete" asp-route-id="@item.ID"Delete/a

                /td

            /tr

        }

    /tbody

/table

@{

    var prevDisabled = !Model.Student.HasPreviousPage ? "disabled" : "";

    var nextDisabled = !Model.Student.HasNextPage ? "disabled" : "";

}

a asp-page="./Index"

   asp-route-sortOrder="@Model.CurrentSort"

   asp-route-pageIndex="@(Model.Student.PageIndex - 1)"

   asp-route-currentFilter="@Model.CurrentFilter"

   class="btn btn-default @prevDisabled"

    Previous

/a

a asp-page="./Index"

   asp-route-sortOrder="@Model.CurrentSort"

   asp-route-pageIndex="@(Model.Student.PageIndex + 1)"

   asp-route-currentFilter="@Model.CurrentFilter"

   class="btn btn-default @nextDisabled"

    Next

/a

The column header links use the query string to pass the current search string to the OnGetAsync method so that the user can sort within filter results:

HTMLCopy

a asp-page="./Index" asp-route-sortOrder="@Model.NameSort"

   asp-route-currentFilter="@Model.CurrentFilter"

    @Html.DisplayNameFor(model = model.Student[0].LastName)

/a

The paging buttons are displayed by tag helpers:

HTMLCopy

a asp-page="./Index"

   asp-route-sortOrder="@Model.CurrentSort"

   asp-route-pageIndex="@(Model.Student.PageIndex - 1)"

   asp-route-currentFilter="@Model.CurrentFilter"

   class="btn btn-default @prevDisabled"

    Previous

/a

a asp-page="./Index"

   asp-route-sortOrder="@Model.CurrentSort"

   asp-route-pageIndex="@(Model.Student.PageIndex + 1)"

   asp-route-currentFilter="@Model.CurrentFilter"

   class="btn btn-default @nextDisabled"

    Next

/a

Run the app and navigate to the students page.

- To make sure paging works, click the paging links in different sort orders.
- To verify that paging works correctly with sorting and filtering, enter a search string and try paging.

![students index page with paging links](image_10)

To get a better understanding of the code:

- In Students/Index.cshtml.cs, set a breakpoint on switch (sortOrder).
- Add a watch for NameSort, DateSort, CurrentSort, and Model.Student.PageIndex.
- In Students/Index.cshtml, set a breakpoint on @Html.DisplayNameFor(model = model.Student[0].LastName).

Step through the debugger.

## Update the About page to show student statistics

In this step, Pages/About.cshtml is updated to display how many students have enrolled for each enrollment date. The update uses grouping and includes the following steps:

- Create a view model for the data used by the About Page.
- Update the About page to use the view model.

### Create the view model

Create a SchoolViewModels folder in the Models folder.

In the SchoolViewModels folder, add a EnrollmentDateGroup.cs with the following code:

C#Copy

using System;

using System.ComponentModel.DataAnnotations;

namespace ContosoUniversity.Models.SchoolViewModels

{

    public class EnrollmentDateGroup

    {

        [DataType(DataType.Date)]

        public DateTime? EnrollmentDate { get; set; }

        public int StudentCount { get; set; }

    }

}

### Update the About page model

Update the Pages/About.cshtml.cs file with the following code:

C#Copy

using ContosoUniversity.Models.SchoolViewModels;

using Microsoft.AspNetCore.Mvc.RazorPages;

using Microsoft.EntityFrameworkCore;

using System.Collections.Generic;

using System.Linq;

using System.Threading.Tasks;

using ContosoUniversity.Models;

using ContosoUniversity.Data;

namespace ContosoUniversity.Pages

{

    public class AboutModel : PageModel

    {

        private readonly SchoolContext _context;

        public AboutModel(SchoolContext context)

        {

            _context = context;

        }

        public IListEnrollmentDateGroup Student { get; set; }

        public async Task OnGetAsync()

        {

            IQueryableEnrollmentDateGroup data =

                from student in _context.Student

                group student by student.EnrollmentDate into dateGroup

                select new EnrollmentDateGroup()

                {

                    EnrollmentDate = dateGroup.Key,

                    StudentCount = dateGroup.Count()

                };

            Student = await data.AsNoTracking().ToListAsync();

        }

    }

}

The LINQ statement groups the student entities by enrollment date, calculates the number of entities in each group, and stores the results in a collection of EnrollmentDateGroup view model objects.

### Modify the About Razor Page

Replace the code in the Pages/About.cshtml file with the following code:

HTMLCopy

@page

@model ContosoUniversity.Pages.AboutModel

@{

    ViewData["Title"] = "Student Body Statistics";

}

h2Student Body Statistics/h2

table

    tr

        th

            Enrollment Date

        /th

        th

            Students

        /th

    /tr

    @foreach (var item in Model.Student)

    {

        tr

            td

                @Html.DisplayFor(modelItem = item.EnrollmentDate)

            /td

            td

                @item.StudentCount

            /td

        /tr

    }

/table

Run the app and navigate to the About page. The count of students for each enrollment date is displayed in a table.

If you run into problems you can't solve, download the [completed app for this stage](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples/StageSnapShots/cu-part3-sorting).

![About page](image_11)

## Additional resources

- [Debugging ASP.NET Core 2.x source](https://github.com/aspnet/Docs/issues/4155)

In the next tutorial, the app uses migrations to update the data model.

# Part 4 of 8

The Contoso University web app demonstrates how to create Razor Pages web apps using EF Core and Visual Studio. For information about the tutorial series, see [the first tutorial](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2).

In this tutorial, the EF Core migrations feature for managing data model changes is used.

If you run into problems you can't solve, download the [completed app](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples).

When a new app is developed, the data model changes frequently. Each time the model changes, the model gets out of sync with the database. This tutorial started by configuring the Entity Framework to create the database if it doesn't exist. Each time the data model changes:

- The DB is dropped.
- EF creates a new one that matches the model.
- The app seeds the DB with test data.

This approach to keeping the DB in sync with the data model works well until you deploy the app to production. When the app is running in production, it's usually storing data that needs to be maintained. The app can't start with a test DB each time a change is made (such as adding a new column). The EF Core Migrations feature solves this problem by enabling EF Core to update the DB schema instead of creating a new DB.

Rather than dropping and recreating the DB when the data model changes, migrations updates the schema and retains existing data.

## Drop the database

Use SQL Server Object Explorer (SSOX) or the database drop command:

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/migrations?view=aspnetcore-2.2&amp;tabs=visual-studio)

In the Package Manager Console (PMC), run the following command:

PMCCopy

Drop-Database

Run Get-Help about_EntityFrameworkCore from the PMC to get help information.

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/migrations?view=aspnetcore-2.2&amp;tabs=visual-studio)

Open a command window and navigate to the project folder. The project folder contains the *Startup.cs*file.

Enter the following in the command window:

consoleCopy

dotnet ef database drop

CONTINUE… 

## Create an initial migration and update the DB

Build the project and create the first migration.

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/migrations?view=aspnetcore-2.2&amp;tabs=visual-studio)

PMCCopy

Add-Migration InitialCreate

Update-Database

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/migrations?view=aspnetcore-2.2&amp;tabs=visual-studio)

consoleCopy

dotnet ef migrations add InitialCreate

dotnet ef database update

CONTINUE… 

### Examine the Up and Down methods

The EF Core migrations add command generated code to create the DB. This migrations code is in the Migrationstimestamp_InitialCreate.cs file. The Up method of the InitialCreate class creates the DB tables that correspond to the data model entity sets. The Down method deletes them, as shown in the following example:

C#Copy

public partial class InitialCreate : Migration

{

    protected override void Up(MigrationBuilder migrationBuilder)

    {

        migrationBuilder.CreateTable(

            name: "Course",

            columns: table = new

            {

                CourseID = table.Columnint(nullable: false),

                Title = table.Columnstring(nullable: true),

                Credits = table.Columnint(nullable: false)

            },

            constraints: table =

            {

                table.PrimaryKey("PK_Course", x = x.CourseID);

            });

        migrationBuilder.CreateTable(

    protected override void Down(MigrationBuilder migrationBuilder)

    {

        migrationBuilder.DropTable(

            name: "Enrollment");

        migrationBuilder.DropTable(

            name: "Course");

        migrationBuilder.DropTable(

            name: "Student");

    }

}

Migrations calls the Up method to implement the data model changes for a migration. When you enter a command to roll back the update, migrations calls the Down method.

The preceding code is for the initial migration. That code was created when the migrations add InitialCreatecommand was run. The migration name parameter ("InitialCreate" in the example) is used for the file name. The migration name can be any valid file name. It's best to choose a word or phrase that summarizes what is being done in the migration. For example, a migration that added a department table might be called "AddDepartmentTable."

If the initial migration is created and the DB exists:

- The DB creation code is generated.
- The DB creation code doesn't need to run because the DB already matches the data model. If the DB creation code is run, it doesn't make any changes because the DB already matches the data model.

When the app is deployed to a new environment, the DB creation code must be run to create the DB.

Previously the DB was dropped and doesn't exist, so migrations creates the new DB.

### The data model snapshot

Migrations create a snapshot of the current database schema in Migrations/SchoolContextModelSnapshot.cs. When you add a migration, EF determines what changed by comparing the data model to the snapshot file.

To delete a migration, use the following command:

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/migrations?view=aspnetcore-2.2&amp;tabs=visual-studio)

Remove-Migration

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/migrations?view=aspnetcore-2.2&amp;tabs=visual-studio)

dotnet ef migrations remove

CONTINUE… 

The remove migrations command deletes the migration and ensures the snapshot is correctly reset.

### Remove EnsureCreated and test the app

For early development, EnsureCreated was used. In this tutorial, migrations are used. EnsureCreated has the following limitations:

- Bypasses migrations and creates the DB and schema.
- Doesn't create a migrations table.
- Can not be used with migrations.
- Is designed for testing or rapid prototyping where the DB is dropped and re-created frequently.

Remove the following line from DbInitializer:

C#Copy

context.Database.EnsureCreated();

Run the app and verify the DB is seeded.

### Inspect the database

Use SQL Server Object Explorer to inspect the DB. Notice the addition of an __EFMigrationsHistory table. The __EFMigrationsHistory table keeps track of which migrations have been applied to the DB. View the data in the __EFMigrationsHistory table, it shows one row for the first migration. The last log in the preceding CLI output example shows the INSERT statement that creates this row.

Run the app and verify that everything works.

## Applying migrations in production

We recommend production apps should not call [Database.Migrate](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.relationaldatabasefacadeextensions.migrate?view=efcore-2.0) at application startup. Migrate shouldn't be called from an app in server farm. For example, if the app has been cloud deployed with scale-out (multiple instances of the app are running).

Database migration should be done as part of deployment, and in a controlled way. Production database migration approaches include:

- Using migrations to create SQL scripts and using the SQL scripts in deployment.
- Running dotnet ef database update from a controlled environment.

EF Core uses the __MigrationsHistory table to see if any migrations need to run. If the DB is up-to-date, no migration is run.

## Troubleshooting

Download the [completed app](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples/StageSnapShots/cu-part4-migrations).

The app generates the following exception:

textCopy

SqlException: Cannot open database "ContosoUniversity" requested by the login.

The login failed.

Login failed for user 'user name'.

Solution: Run dotnet ef database update 

### Additional resources

- [.NET Core CLI](https://docs.microsoft.com/ef/core/miscellaneous/cli/dotnet).
- [Package Manager Console (Visual Studio)](https://docs.microsoft.com/ef/core/miscellaneous/cli/powershell)

# Part 5 of 8

The Contoso University web app demonstrates how to create Razor Pages web apps using EF Core and Visual Studio. For information about the tutorial series, see [the first tutorial](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2).

The previous tutorials worked with a basic data model that was composed of three entities. In this tutorial:

- More entities and relationships are added.
- The data model is customized by specifying formatting, validation, and database mapping rules.

The entity classes for the completed data model is shown in the following illustration:

![Entity diagram](image_12)

If you run into problems you can't solve, download the [completed app](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples).

## Customize the data model with attributes

In this section, the data model is customized using attributes.

### The DataType attribute

The student pages currently displays the time of the enrollment date. Typically, date fields show only the date and not the time.

Update Models/Student.cs with the following highlighted code:

C#Copy

using System;

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

namespace ContosoUniversity.Models

{

    public class Student

    {

        public int ID { get; set; }

        public string LastName { get; set; }

        public string FirstMidName { get; set; }

        [DataType(DataType.Date)]

        [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

        public DateTime EnrollmentDate { get; set; }

        public ICollectionEnrollment Enrollments { get; set; }

    }

}

The [DataType](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.datatypeattribute?view=netframework-4.7.1) attribute specifies a data type that's more specific than the database intrinsic type. In this case only the date should be displayed, not the date and time. The [DataType Enumeration](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.datatype?view=netframework-4.7.1) provides for many data types, such as Date, Time, PhoneNumber, Currency, EmailAddress, etc. The DataType attribute can also enable the app to automatically provide type-specific features. For example:

- The mailto: link is automatically created for DataType.EmailAddress.
- The date selector is provided for DataType.Date in most browsers.

The DataType attribute emits HTML 5 data- (pronounced data dash) attributes that HTML 5 browsers consume. The DataType attributes don't provide validation.

DataType.Date doesn't specify the format of the date that's displayed. By default, the date field is displayed according to the default formats based on the server's [CultureInfo](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-2.2).

The DisplayFormat attribute is used to explicitly specify the date format:

C#Copy

[DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

The ApplyFormatInEditMode setting specifies that the formatting should also be applied to the edit UI. Some fields shouldn't use ApplyFormatInEditMode. For example, the currency symbol should generally not be displayed in an edit text box.

The DisplayFormat attribute can be used by itself. It's generally a good idea to use the DataType attribute with the DisplayFormat attribute. The DataType attribute conveys the semantics of the data as opposed to how to render it on a screen. The DataType attribute provides the following benefits that are not available in DisplayFormat:

- The browser can enable HTML5 features. For example, show a calendar control, the locale-appropriate currency symbol, email links, client-side input validation, etc.
- By default, the browser renders data using the correct format based on the locale.

For more information, see the [input Tag Helper documentation](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/working-with-forms?view=aspnetcore-2.2).

Run the app. Navigate to the Students Index page. Times are no longer displayed. Every view that uses the Student model displays the date without time.

![Students index page showing dates without times](image_13)

### The StringLength attribute

Data validation rules and validation error messages can be specified with attributes. The [StringLength](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.stringlengthattribute?view=netframework-4.7.1) attribute specifies the minimum and maximum length of characters that are allowed in a data field. The StringLengthattribute also provides client-side and server-side validation. The minimum value has no impact on the database schema.

Update the Student model with the following code:

C#Copy

using System;

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

namespace ContosoUniversity.Models

{

    public class Student

    {

        public int ID { get; set; }

        [StringLength(50)]

        public string LastName { get; set; }

        [StringLength(50, ErrorMessage = "First name cannot be longer than 50 characters.")]

        public string FirstMidName { get; set; }

        [DataType(DataType.Date)]

        [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

        public DateTime EnrollmentDate { get; set; }

        public ICollectionEnrollment Enrollments { get; set; }

    }

}

The preceding code limits names to no more than 50 characters. The StringLength attribute doesn't prevent a user from entering white space for a name. The [RegularExpression](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.regularexpressionattribute?view=netframework-4.7.1) attribute is used to apply restrictions to the input. For example, the following code requires the first character to be upper case and the remaining characters to be alphabetical:

C#Copy

[RegularExpression(@"^[A-Z]+[a-zA-Z""'\s-]*$")]

Run the app:

- Navigate to the Students page.
- Select Create New, and enter a name longer than 50 characters.
- Select Create, client-side validation shows an error message.

![Students index page showing string length errors](image_14)

In SQL Server Object Explorer (SSOX), open the Student table designer by double-clicking the Student table.

![Students table in SSOX before migrations](image_15)

The preceding image shows the schema for the Student table. The name fields have type nvarchar(MAX)because migrations has not been run on the DB. When migrations are run later in this tutorial, the name fields become nvarchar(50).

### The Column attribute

Attributes can control how classes and properties are mapped to the database. In this section, the Columnattribute is used to map the name of the FirstMidName property to "FirstName" in the DB.

When the DB is created, property names on the model are used for column names (except when the Columnattribute is used).

The Student model uses FirstMidName for the first-name field because the field might also contain a middle name.

Update the Student.cs file with the following highlighted code:

C#Copy

using System;

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class Student

    {

        public int ID { get; set; }

        [StringLength(50)]

        public string LastName { get; set; }

        [StringLength(50, ErrorMessage = "First name cannot be longer than 50 characters.")]

        [Column("FirstName")]

        public string FirstMidName { get; set; }

        [DataType(DataType.Date)]

        [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

        public DateTime EnrollmentDate { get; set; }

        public ICollectionEnrollment Enrollments { get; set; }

    }

}

With the preceding change, Student.FirstMidName in the app maps to the FirstName column of the Studenttable.

The addition of the Column attribute changes the model backing the SchoolContext. The model backing the SchoolContext no longer matches the database. If the app is run before applying migrations, the following exception is generated:

SQLCopy

SqlException: Invalid column name 'FirstName'.

To update the DB:

- Build the project.
- Open a command window in the project folder. Enter the following commands to create a new migration and update the DB:
- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio)

PMCCopy

Add-Migration ColumnFirstName

Update-Database

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio)

consoleCopy

dotnet ef migrations add ColumnFirstName

dotnet ef database update

CONTINUE… 

The migrations add ColumnFirstName command generates the following warning message:

textCopy

An operation was scaffolded that may result in the loss of data.

Please review the migration for accuracy.

The warning is generated because the name fields are now limited to 50 characters. If a name in the DB had more than 50 characters, the 51 to last character would be lost.

- Test the app.

Open the Student table in SSOX:

![Students table in SSOX after migrations](image_16)

Before migration was applied, the name columns were of type [nvarchar(MAX)](https://docs.microsoft.com/sql/t-sql/data-types/nchar-and-nvarchar-transact-sql). The name columns are now nvarchar(50). The column name has changed from FirstMidName to FirstName.

** Note**

In the following section, building the app at some stages generates compiler errors. The instructions specify when to build the app.

## Student entity update

![Student entity](image_17)

Update Models/Student.cs with the following code:

C#Copy

using System;

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class Student

    {

        public int ID { get; set; }

        [Required]

        [StringLength(50)]

        [Display(Name = "Last Name")]

        public string LastName { get; set; }

        [Required]

        [StringLength(50, ErrorMessage = "First name cannot be longer than 50 characters.")]

        [Column("FirstName")]

        [Display(Name = "First Name")]

        public string FirstMidName { get; set; }

        [DataType(DataType.Date)]

        [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

        [Display(Name = "Enrollment Date")]

        public DateTime EnrollmentDate { get; set; }

        [Display(Name = "Full Name")]

        public string FullName

        {

            get

            {

                return LastName + ", " + FirstMidName;

            }

        }

        public ICollectionEnrollment Enrollments { get; set; }

    }

}

### The Required attribute

The Required attribute makes the name properties required fields. The Required attribute isn't needed for non-nullable types such as value types (DateTime, int, double, etc.). Types that can't be null are automatically treated as required fields.

The Required attribute could be replaced with a minimum length parameter in the StringLength attribute:

C#Copy

[Display(Name = "Last Name")]

[StringLength(50, MinimumLength=1)]

public string LastName { get; set; }

### The Display attribute

The Display attribute specifies that the caption for the text boxes should be "First Name", "Last Name", "Full Name", and "Enrollment Date." The default captions had no space dividing the words, for example "Lastname."

### The FullName calculated property

FullName is a calculated property that returns a value that's created by concatenating two other properties. FullName cannot be set, it has only a get accessor. No FullName column is created in the database.

## Create the Instructor Entity

![Instructor entity](image_18)

Create Models/Instructor.cs with the following code:

C#Copy

using System;

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class Instructor

    {

        public int ID { get; set; }

        [Required]

        [Display(Name = "Last Name")]

        [StringLength(50)]

        public string LastName { get; set; }

        [Required]

        [Column("FirstName")]

        [Display(Name = "First Name")]

        [StringLength(50)]

        public string FirstMidName { get; set; }

        [DataType(DataType.Date)]

        [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

        [Display(Name = "Hire Date")]

        public DateTime HireDate { get; set; }

        [Display(Name = "Full Name")]

        public string FullName

        {

            get { return LastName + ", " + FirstMidName; }

        }

        public ICollectionCourseAssignment CourseAssignments { get; set; }

        public OfficeAssignment OfficeAssignment { get; set; }

    }

}

Multiple attributes can be on one line. The HireDate attributes could be written as follows:

C#Copy

[DataType(DataType.Date),Display(Name = "Hire Date"),DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

### The CourseAssignments and OfficeAssignment navigation properties

The CourseAssignments and OfficeAssignment properties are navigation properties.

An instructor can teach any number of courses, so CourseAssignments is defined as a collection.

C#Copy

public ICollectionCourseAssignment CourseAssignments { get; set; }

If a navigation property holds multiple entities:

- It must be a list type where the entries can be added, deleted, and updated.

Navigation property types include:

- ICollectionT
- ListT
- HashSetT

If ICollectionT is specified, EF Core creates a HashSetT collection by default.

The CourseAssignment entity is explained in the section on many-to-many relationships.

Contoso University business rules state that an instructor can have at most one office. The OfficeAssignmentproperty holds a single OfficeAssignment entity. OfficeAssignment is null if no office is assigned.

C#Copy

public OfficeAssignment OfficeAssignment { get; set; }

## Create the OfficeAssignment entity

![OfficeAssignment entity](image_19)

Create Models/OfficeAssignment.cs with the following code:

C#Copy

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class OfficeAssignment

    {

        [Key]

        public int InstructorID { get; set; }

        [StringLength(50)]

        [Display(Name = "Office Location")]

        public string Location { get; set; }

        public Instructor Instructor { get; set; }

    }

}

### The Key attribute

The [Key] attribute is used to identify a property as the primary key (PK) when the property name is something other than classnameID or ID.

There's a one-to-zero-or-one relationship between the Instructor and OfficeAssignment entities. An office assignment only exists in relation to the instructor it's assigned to. The OfficeAssignment PK is also its foreign key (FK) to the Instructor entity. EF Core can't automatically recognize InstructorID as the PK of OfficeAssignment because:

- InstructorID doesn't follow the ID or classnameID naming convention.

Therefore, the Key attribute is used to identify InstructorID as the PK:

C#Copy

[Key]

public int InstructorID { get; set; }

By default, EF Core treats the key as non-database-generated because the column is for an identifying relationship.

### The Instructor navigation property

The OfficeAssignment navigation property for the Instructor entity is nullable because:

- Reference types (such as classes are nullable).
- An instructor might not have an office assignment.

The OfficeAssignment entity has a non-nullable Instructor navigation property because:

- InstructorID is non-nullable.
- An office assignment can't exist without an instructor.

When an Instructor entity has a related OfficeAssignment entity, each entity has a reference to the other one in its navigation property.

The [Required] attribute could be applied to the Instructor navigation property:

C#Copy

[Required]

public Instructor Instructor { get; set; }

The preceding code specifies that there must be a related instructor. The preceding code is unnecessary because the InstructorID foreign key (which is also the PK) is non-nullable.

## Modify the Course Entity

![Course entity](image_20)

Update Models/Course.cs with the following code:

C#Copy

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class Course

    {

        [DatabaseGenerated(DatabaseGeneratedOption.None)]

        [Display(Name = "Number")]

        public int CourseID { get; set; }

        [StringLength(50, MinimumLength = 3)]

        public string Title { get; set; }

        [Range(0, 5)]

        public int Credits { get; set; }

        public int DepartmentID { get; set; }

        public Department Department { get; set; }

        public ICollectionEnrollment Enrollments { get; set; }

        public ICollectionCourseAssignment CourseAssignments { get; set; }

    }

}

The Course entity has a foreign key (FK) property DepartmentID. DepartmentID points to the related Department entity. The Course entity has a Department navigation property.

EF Core doesn't require a FK property for a data model when the model has a navigation property for a related entity.

EF Core automatically creates FKs in the database wherever they're needed. EF Core creates [shadow properties](https://docs.microsoft.com/ef/core/modeling/shadow-properties)for automatically created FKs. Having the FK in the data model can make updates simpler and more efficient. For example, consider a model where the FK property DepartmentID is not included. When a course entity is fetched to edit:

- The Department entity is null if it's not explicitly loaded.
- To update the course entity, the Department entity must first be fetched.

When the FK property DepartmentID is included in the data model, there's no need to fetch the Departmententity before an update.

### The DatabaseGenerated attribute

The [DatabaseGenerated(DatabaseGeneratedOption.None)] attribute specifies that the PK is provided by the application rather than generated by the database.

C#Copy

[DatabaseGenerated(DatabaseGeneratedOption.None)]

[Display(Name = "Number")]

public int CourseID { get; set; }

By default, EF Core assumes that PK values are generated by the DB. DB generated PK values is generally the best approach. For Course entities, the user specifies the PK. For example, a course number such as a 1000 series for the math department, a 2000 series for the English department.

The DatabaseGenerated attribute can also be used to generate default values. For example, the DB can automatically generate a date field to record the date a row was created or updated. For more information, see [Generated Properties](https://docs.microsoft.com/ef/core/modeling/generated-properties).

### Foreign key and navigation properties

The foreign key (FK) properties and navigation properties in the Course entity reflect the following relationships:

A course is assigned to one department, so there's a DepartmentID FK and a Department navigation property.

C#Copy

public int DepartmentID { get; set; }

public Department Department { get; set; }

A course can have any number of students enrolled in it, so the Enrollments navigation property is a collection:

C#Copy

public ICollectionEnrollment Enrollments { get; set; }

A course may be taught by multiple instructors, so the CourseAssignments navigation property is a collection:

C#Copy

public ICollectionCourseAssignment CourseAssignments { get; set; }

CourseAssignment is explained [later](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio).

## Create the Department entity

![Department entity](image_21)

Create Models/Department.cs with the following code:

C#Copy

using System;

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class Department

    {

        public int DepartmentID { get; set; }

        [StringLength(50, MinimumLength = 3)]

        public string Name { get; set; }

        [DataType(DataType.Currency)]

        [Column(TypeName = "money")]

        public decimal Budget { get; set; }

        [DataType(DataType.Date)]

        [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

        [Display(Name = "Start Date")]

        public DateTime StartDate { get; set; }

        public int? InstructorID { get; set; }

        public Instructor Administrator { get; set; }

        public ICollectionCourse Courses { get; set; }

    }

}

### The Column attribute

Previously the Column attribute was used to change column name mapping. In the code for the Departmententity, the Column attribute is used to change SQL data type mapping. The Budget column is defined using the SQL Server money type in the DB:

C#Copy

[Column(TypeName="money")]

public decimal Budget { get; set; }

Column mapping is generally not required. EF Core generally chooses the appropriate SQL Server data type based on the CLR type for the property. The CLR decimal type maps to a SQL Server decimal type. Budgetis for currency, and the money data type is more appropriate for currency.

### Foreign key and navigation properties

The FK and navigation properties reflect the following relationships:

- A department may or may not have an administrator.
- An administrator is always an instructor. Therefore the InstructorID property is included as the FK to the Instructor entity.

The navigation property is named Administrator but holds an Instructor entity:

C#Copy

public int? InstructorID { get; set; }

public Instructor Administrator { get; set; }

The question mark (?) in the preceding code specifies the property is nullable.

A department may have many courses, so there's a Courses navigation property:

C#Copy

public ICollectionCourse Courses { get; set; }

Note: By convention, EF Core enables cascade delete for non-nullable FKs and for many-to-many relationships. Cascading delete can result in circular cascade delete rules. Circular cascade delete rules causes an exception when a migration is added.

For example, if the Department.InstructorID property wasn't defined as nullable:

- EF Core configures a cascade delete rule to delete the instructor when the department is deleted.
- Deleting the instructor when the department is deleted isn't the intended behavior.

If business rules required the InstructorID property be non-nullable, use the following fluent API statement:

C#Copy

modelBuilder.EntityDepartment()

   .HasOne(d = d.Administrator)

   .WithMany()

   .OnDelete(DeleteBehavior.Restrict)

The preceding code disables cascade delete on the department-instructor relationship.

## Update the Enrollment entity

An enrollment record is for one course taken by one student.

![Enrollment entity](image_22)

Update Models/Enrollment.cs with the following code:

C#Copy

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public enum Grade

    {

        A, B, C, D, F

    }

    public class Enrollment

    {

        public int EnrollmentID { get; set; }

        public int CourseID { get; set; }

        public int StudentID { get; set; }

        [DisplayFormat(NullDisplayText = "No grade")]

        public Grade? Grade { get; set; }

        public Course Course { get; set; }

        public Student Student { get; set; }

    }

}

### Foreign key and navigation properties

The FK properties and navigation properties reflect the following relationships:

An enrollment record is for one course, so there's a CourseID FK property and a Course navigation property:

C#Copy

public int CourseID { get; set; }

public Course Course { get; set; }

An enrollment record is for one student, so there's a StudentID FK property and a Student navigation property:

C#Copy

public int StudentID { get; set; }

public Student Student { get; set; }

## Many-to-Many Relationships

There's a many-to-many relationship between the Student and Course entities. The Enrollment entity functions as a many-to-many join table with payload in the database. "With payload" means that the Enrollment table contains additional data besides FKs for the joined tables (in this case, the PK and Grade).

The following illustration shows what these relationships look like in an entity diagram. (This diagram was generated using [EF Power Tools](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) for EF 6.x. Creating the diagram isn't part of the tutorial.)

![Student-Course many to many relationship](image_23)

Each relationship line has a 1 at one end and an asterisk (*) at the other, indicating a one-to-many relationship.

If the Enrollment table didn't include grade information, it would only need to contain the two FKs (CourseID and StudentID). A many-to-many join table without payload is sometimes called a pure join table (PJT).

The Instructor and Course entities have a many-to-many relationship using a pure join table.

Note: EF 6.x supports implicit join tables for many-to-many relationships, but EF Core doesn't. For more information, see [Many-to-many relationships in EF Core 2.0](https://blog.oneunicorn.com/2017/09/25/many-to-many-relationships-in-ef-core-2-0-part-1-the-basics/).

## The CourseAssignment entity

![CourseAssignment entity](image_24)

Create Models/CourseAssignment.cs with the following code:

C#Copy

using System;

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class CourseAssignment

    {

        public int InstructorID { get; set; }

        public int CourseID { get; set; }

        public Instructor Instructor { get; set; }

        public Course Course { get; set; }

    }

}

### Instructor-to-Courses

![Instructor-to-Courses m:M](image_25)

The Instructor-to-Courses many-to-many relationship:

- Requires a join table that must be represented by an entity set.
- Is a pure join table (table without payload).

It's common to name a join entity EntityName1EntityName2. For example, the Instructor-to-Courses join table using this pattern is CourseInstructor. However, we recommend using a name that describes the relationship.

Data models start out simple and grow. No-payload joins (PJTs) frequently evolve to include payload. By starting with a descriptive entity name, the name doesn't need to change when the join table changes. Ideally, the join entity would have its own natural (possibly single word) name in the business domain. For example, Books and Customers could be linked with a join entity called Ratings. For the Instructor-to-Courses many-to-many relationship, CourseAssignment is preferred over CourseInstructor.

### Composite key

FKs are not nullable. The two FKs in CourseAssignment (InstructorID and CourseID) together uniquely identify each row of the CourseAssignment table. CourseAssignment doesn't require a dedicated PK. The InstructorID and CourseID properties function as a composite PK. The only way to specify composite PKs to EF Core is with the fluent API. The next section shows how to configure the composite PK.

The composite key ensures:

- Multiple rows are allowed for one course.
- Multiple rows are allowed for one instructor.
- Multiple rows for the same instructor and course isn't allowed.

The Enrollment join entity defines its own PK, so duplicates of this sort are possible. To prevent such duplicates:

- Add a unique index on the FK fields, or
- Configure Enrollment with a primary composite key similar to CourseAssignment. For more information, see [Indexes](https://docs.microsoft.com/ef/core/modeling/indexes).

## Update the DB context

Add the following highlighted code to Data/SchoolContext.cs:

C#Copy

using ContosoUniversity.Models;

using Microsoft.EntityFrameworkCore;

namespace ContosoUniversity.Models

{

    public class SchoolContext : DbContext

    {

        public SchoolContext(DbContextOptionsSchoolContext options) : base(options)

        {

        }

        public DbSetCourse Courses { get; set; }

        public DbSetEnrollment Enrollment { get; set; }

        public DbSetStudent Student { get; set; }

        public DbSetDepartment Departments { get; set; }

        public DbSetInstructor Instructors { get; set; }

        public DbSetOfficeAssignment OfficeAssignments { get; set; }

        public DbSetCourseAssignment CourseAssignments { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)

        {

            modelBuilder.EntityCourse().ToTable("Course");

            modelBuilder.EntityEnrollment().ToTable("Enrollment");

            modelBuilder.EntityStudent().ToTable("Student");

            modelBuilder.EntityDepartment().ToTable("Department");

            modelBuilder.EntityInstructor().ToTable("Instructor");

            modelBuilder.EntityOfficeAssignment().ToTable("OfficeAssignment");

            modelBuilder.EntityCourseAssignment().ToTable("CourseAssignment");

            modelBuilder.EntityCourseAssignment()

                .HasKey(c = new { c.CourseID, c.InstructorID });

        }

    }

}

The preceding code adds the new entities and configures the CourseAssignment entity's composite PK.

## Fluent API alternative to attributes

The OnModelCreating method in the preceding code uses the fluent API to configure EF Core behavior. The API is called "fluent" because it's often used by stringing a series of method calls together into a single statement. The [following code](https://docs.microsoft.com/ef/core/modeling/) is an example of the fluent API:

C#Copy

protected override void OnModelCreating(ModelBuilder modelBuilder)

{

    modelBuilder.EntityBlog()

        .Property(b = b.Url)

        .IsRequired();

}

In this tutorial, the fluent API is used only for DB mapping that can't be done with attributes. However, the fluent API can specify most of the formatting, validation, and mapping rules that can be done with attributes.

Some attributes such as MinimumLength can't be applied with the fluent API. MinimumLength doesn't change the schema, it only applies a minimum length validation rule.

Some developers prefer to use the fluent API exclusively so that they can keep their entity classes "clean." Attributes and the fluent API can be mixed. There are some configurations that can only be done with the fluent API (specifying a composite PK). There are some configurations that can only be done with attributes (MinimumLength). The recommended practice for using fluent API or attributes:

- Choose one of these two approaches.
- Use the chosen approach consistently as much as possible.

Some of the attributes used in the this tutorial are used for:

- Validation only (for example, MinimumLength).
- EF Core configuration only (for example, HasKey).
- Validation and EF Core configuration (for example, [StringLength(50)]).

For more information about attributes vs. fluent API, see [Methods of configuration](https://docs.microsoft.com/ef/core/modeling/).

## Entity Diagram Showing Relationships

The following illustration shows the diagram that EF Power Tools create for the completed School model.

![Entity diagram](image_26)

The preceding diagram shows:

- Several one-to-many relationship lines (1 to *).
- The one-to-zero-or-one relationship line (1 to 0..1) between the Instructor and OfficeAssignmententities.
- The zero-or-one-to-many relationship line (0..1 to *) between the Instructor and Departmententities.

## Seed the DB with Test Data

Update the code in Data/DbInitializer.cs:

C#Copy

using System;

using System.Linq;

using Microsoft.EntityFrameworkCore;

using Microsoft.Extensions.DependencyInjection;

using ContosoUniversity.Models;

namespace ContosoUniversity.Data

{

    public static class DbInitializer

    {

        public static void Initialize(SchoolContext context)

        {

            //context.Database.EnsureCreated();

            // Look for any students.

            if (context.Student.Any())

            {

                return;   // DB has been seeded

            }

            var students = new Student[]

            {

                new Student { FirstMidName = "Carson",   LastName = "Alexander",

                    EnrollmentDate = DateTime.Parse("2010-09-01") },

                new Student { FirstMidName = "Meredith", LastName = "Alonso",

                    EnrollmentDate = DateTime.Parse("2012-09-01") },

                new Student { FirstMidName = "Arturo",   LastName = "Anand",

                    EnrollmentDate = DateTime.Parse("2013-09-01") },

                new Student { FirstMidName = "Gytis",    LastName = "Barzdukas",

                    EnrollmentDate = DateTime.Parse("2012-09-01") },

                new Student { FirstMidName = "Yan",      LastName = "Li",

                    EnrollmentDate = DateTime.Parse("2012-09-01") },

                new Student { FirstMidName = "Peggy",    LastName = "Justice",

                    EnrollmentDate = DateTime.Parse("2011-09-01") },

                new Student { FirstMidName = "Laura",    LastName = "Norman",

                    EnrollmentDate = DateTime.Parse("2013-09-01") },

                new Student { FirstMidName = "Nino",     LastName = "Olivetto",

                    EnrollmentDate = DateTime.Parse("2005-09-01") }

            };

            foreach (Student s in students)

            {

                context.Student.Add(s);

            }

            context.SaveChanges();

            var instructors = new Instructor[]

            {

                new Instructor { FirstMidName = "Kim",     LastName = "Abercrombie",

                    HireDate = DateTime.Parse("1995-03-11") },

                new Instructor { FirstMidName = "Fadi",    LastName = "Fakhouri",

                    HireDate = DateTime.Parse("2002-07-06") },

                new Instructor { FirstMidName = "Roger",   LastName = "Harui",

                    HireDate = DateTime.Parse("1998-07-01") },

                new Instructor { FirstMidName = "Candace", LastName = "Kapoor",

                    HireDate = DateTime.Parse("2001-01-15") },

                new Instructor { FirstMidName = "Roger",   LastName = "Zheng",

                    HireDate = DateTime.Parse("2004-02-12") }

            };

            foreach (Instructor i in instructors)

            {

                context.Instructors.Add(i);

            }

            context.SaveChanges();

            var departments = new Department[]

            {

                new Department { Name = "English",     Budget = 350000,

                    StartDate = DateTime.Parse("2007-09-01"),

                    InstructorID  = instructors.Single( i = i.LastName == "Abercrombie").ID },

                new Department { Name = "Mathematics", Budget = 100000,

                    StartDate = DateTime.Parse("2007-09-01"),

                    InstructorID  = instructors.Single( i = i.LastName == "Fakhouri").ID },

                new Department { Name = "Engineering", Budget = 350000,

                    StartDate = DateTime.Parse("2007-09-01"),

                    InstructorID  = instructors.Single( i = i.LastName == "Harui").ID },

                new Department { Name = "Economics",   Budget = 100000,

                    StartDate = DateTime.Parse("2007-09-01"),

                    InstructorID  = instructors.Single( i = i.LastName == "Kapoor").ID }

            };

            foreach (Department d in departments)

            {

                context.Departments.Add(d);

            }

            context.SaveChanges();

            var courses = new Course[]

            {

                new Course {CourseID = 1050, Title = "Chemistry",      Credits = 3,

                    DepartmentID = departments.Single( s = s.Name == "Engineering").DepartmentID

                },

                new Course {CourseID = 4022, Title = "Microeconomics", Credits = 3,

                    DepartmentID = departments.Single( s = s.Name == "Economics").DepartmentID

                },

                new Course {CourseID = 4041, Title = "Macroeconomics", Credits = 3,

                    DepartmentID = departments.Single( s = s.Name == "Economics").DepartmentID

                },

                new Course {CourseID = 1045, Title = "Calculus",       Credits = 4,

                    DepartmentID = departments.Single( s = s.Name == "Mathematics").DepartmentID

                },

                new Course {CourseID = 3141, Title = "Trigonometry",   Credits = 4,

                    DepartmentID = departments.Single( s = s.Name == "Mathematics").DepartmentID

                },

                new Course {CourseID = 2021, Title = "Composition",    Credits = 3,

                    DepartmentID = departments.Single( s = s.Name == "English").DepartmentID

                },

                new Course {CourseID = 2042, Title = "Literature",     Credits = 4,

                    DepartmentID = departments.Single( s = s.Name == "English").DepartmentID

                },

            };

            foreach (Course c in courses)

            {

                context.Courses.Add(c);

            }

            context.SaveChanges();

            var officeAssignments = new OfficeAssignment[]

            {

                new OfficeAssignment {

                    InstructorID = instructors.Single( i = i.LastName == "Fakhouri").ID,

                    Location = "Smith 17" },

                new OfficeAssignment {

                    InstructorID = instructors.Single( i = i.LastName == "Harui").ID,

                    Location = "Gowan 27" },

                new OfficeAssignment {

                    InstructorID = instructors.Single( i = i.LastName == "Kapoor").ID,

                    Location = "Thompson 304" },

            };

            foreach (OfficeAssignment o in officeAssignments)

            {

                context.OfficeAssignments.Add(o);

            }

            context.SaveChanges();

            var courseInstructors = new CourseAssignment[]

            {

                new CourseAssignment {

                    CourseID = courses.Single(c = c.Title == "Chemistry" ).CourseID,

                    InstructorID = instructors.Single(i = i.LastName == "Kapoor").ID

                    },

                new CourseAssignment {

                    CourseID = courses.Single(c = c.Title == "Chemistry" ).CourseID,

                    InstructorID = instructors.Single(i = i.LastName == "Harui").ID

                    },

                new CourseAssignment {

                    CourseID = courses.Single(c = c.Title == "Microeconomics" ).CourseID,

                    InstructorID = instructors.Single(i = i.LastName == "Zheng").ID

                    },

                new CourseAssignment {

                    CourseID = courses.Single(c = c.Title == "Macroeconomics" ).CourseID,

                    InstructorID = instructors.Single(i = i.LastName == "Zheng").ID

                    },

                new CourseAssignment {

                    CourseID = courses.Single(c = c.Title == "Calculus" ).CourseID,

                    InstructorID = instructors.Single(i = i.LastName == "Fakhouri").ID

                    },

                new CourseAssignment {

                    CourseID = courses.Single(c = c.Title == "Trigonometry" ).CourseID,

                    InstructorID = instructors.Single(i = i.LastName == "Harui").ID

                    },

                new CourseAssignment {

                    CourseID = courses.Single(c = c.Title == "Composition" ).CourseID,

                    InstructorID = instructors.Single(i = i.LastName == "Abercrombie").ID

                    },

                new CourseAssignment {

                    CourseID = courses.Single(c = c.Title == "Literature" ).CourseID,

                    InstructorID = instructors.Single(i = i.LastName == "Abercrombie").ID

                    },

            };

            foreach (CourseAssignment ci in courseInstructors)

            {

                context.CourseAssignments.Add(ci);

            }

            context.SaveChanges();

            var enrollments = new Enrollment[]

            {

                new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Alexander").ID,

                    CourseID = courses.Single(c = c.Title == "Chemistry" ).CourseID,

                    Grade = Grade.A

                },

                    new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Alexander").ID,

                    CourseID = courses.Single(c = c.Title == "Microeconomics" ).CourseID,

                    Grade = Grade.C

                    },

                    new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Alexander").ID,

                    CourseID = courses.Single(c = c.Title == "Macroeconomics" ).CourseID,

                    Grade = Grade.B

                    },

                    new Enrollment {

                        StudentID = students.Single(s = s.LastName == "Alonso").ID,

                    CourseID = courses.Single(c = c.Title == "Calculus" ).CourseID,

                    Grade = Grade.B

                    },

                    new Enrollment {

                        StudentID = students.Single(s = s.LastName == "Alonso").ID,

                    CourseID = courses.Single(c = c.Title == "Trigonometry" ).CourseID,

                    Grade = Grade.B

                    },

                    new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Alonso").ID,

                    CourseID = courses.Single(c = c.Title == "Composition" ).CourseID,

                    Grade = Grade.B

                    },

                    new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Anand").ID,

                    CourseID = courses.Single(c = c.Title == "Chemistry" ).CourseID

                    },

                    new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Anand").ID,

                    CourseID = courses.Single(c = c.Title == "Microeconomics").CourseID,

                    Grade = Grade.B

                    },

                new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Barzdukas").ID,

                    CourseID = courses.Single(c = c.Title == "Chemistry").CourseID,

                    Grade = Grade.B

                    },

                    new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Li").ID,

                    CourseID = courses.Single(c = c.Title == "Composition").CourseID,

                    Grade = Grade.B

                    },

                    new Enrollment {

                    StudentID = students.Single(s = s.LastName == "Justice").ID,

                    CourseID = courses.Single(c = c.Title == "Literature").CourseID,

                    Grade = Grade.B

                    }

            };

            foreach (Enrollment e in enrollments)

            {

                var enrollmentInDataBase = context.Enrollment.Where(

                    s =

                            s.Student.ID == e.StudentID 

                            s.Course.CourseID == e.CourseID).SingleOrDefault();

                if (enrollmentInDataBase == null)

                {

                    context.Enrollment.Add(e);

                }

            }

            context.SaveChanges();

        }

    }

}

The preceding code provides seed data for the new entities. Most of this code creates new entity objects and loads sample data. The sample data is used for testing. See Enrollments and CourseAssignments for examples of how many-to-many join tables can be seeded.

## Add a migration

Build the project.

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio)

PMCCopy

Add-Migration ComplexDataModel

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio)

consoleCopy

dotnet ef migrations add ComplexDataModel

CONTINUE… 

The preceding command displays a warning about possible data loss.

textCopy

An operation was scaffolded that may result in the loss of data.

Please review the migration for accuracy.

Done. To undo this action, use 'ef migrations remove'

If the database update command is run, the following error is produced:

textCopy

The ALTER TABLE statement conflicted with the FOREIGN KEY constraint "FK_dbo.Course_dbo.Department_DepartmentID". The conflict occurred in

database "ContosoUniversity", table "dbo.Department", column 'DepartmentID'.

## Apply the migration

Now that you have an existing database, you need to think about how to apply future changes to it. This tutorial shows two approaches:

- [Drop and re-create the database](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio)
- [Apply the migration to the existing database](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio). While this method is more complex and time-consuming, it's the preferred approach for real-world, production environments. Note: This is an optional section of the tutorial. You can do the drop and re-create steps and skip this section. If you do want to follow the steps in this section, don't do the drop and re-create steps.

### Drop and re-create the database

The code in the updated DbInitializer adds seed data for the new entities. To force EF Core to create a new DB, drop and update the DB:

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio)

In the Package Manager Console (PMC), run the following command:

PMCCopy

Drop-Database

Update-Database

Run Get-Help about_EntityFrameworkCore from the PMC to get help information.

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio)

Open a command window and navigate to the project folder. The project folder contains the *Startup.cs*file.

Enter the following in the command window:

consoleCopy

dotnet ef database drop

dotnet ef database update

CONTINUE… 

Run the app. Running the app runs the DbInitializer.Initialize method. The DbInitializer.Initializepopulates the new DB.

Open the DB in SSOX:

- If SSOX was opened previously, click the Refresh button.
- Expand the Tables node. The created tables are displayed.

![Tables in SSOX](image_27)

Examine the CourseAssignment table:

- Right-click the CourseAssignment table and select View Data.
- Verify the CourseAssignment table contains data.

![CourseAssignment data in SSOX](image_28)

### Apply the migration to the existing database

This section is optional. These steps work only if you skipped the preceding [Drop and re-create the database](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-2.2&amp;tabs=visual-studio)section.

When migrations are run with existing data, there may be FK constraints that are not satisfied with the existing data. With production data, steps must be taken to migrate the existing data. This section provides an example of fixing FK constraint violations. Don't make these code changes without a backup. Don't make these code changes if you completed the previous section and updated the database.

The {timestamp}_ComplexDataModel.cs file contains the following code:

C#Copy

migrationBuilder.AddColumnint(

    name: "DepartmentID",

    table: "Course",

    type: "int",

    nullable: false,

    defaultValue: 0);

The preceding code adds a non-nullable DepartmentID FK to the Course table. The DB from the previous tutorial contains rows in Course, so that table cannot be updated by migrations.

To make the ComplexDataModel migration work with existing data:

- Change the code to give the new column (DepartmentID) a default value.
- Create a fake department named "Temp" to act as the default department.

#### Fix the foreign key constraints

Update the ComplexDataModel classes Up method:

- Open the {timestamp}_ComplexDataModel.cs file.
- Comment out the line of code that adds the DepartmentID column to the Course table.

C#Copy

migrationBuilder.AlterColumnstring(

    name: "Title",

    table: "Course",

    maxLength: 50,

    nullable: true,

    oldClrType: typeof(string),

    oldNullable: true);

            

//migrationBuilder.AddColumnint(

//    name: "DepartmentID",

//    table: "Course",

//    nullable: false,

//    defaultValue: 0);

Add the following highlighted code. The new code goes after the .CreateTable( name: "Department" block:

C#Copy

migrationBuilder.CreateTable(

    name: "Department",

    columns: table = new

    {

        DepartmentID = table.Columnint(type: "int", nullable: false)

            .Annotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn),

        Budget = table.Columndecimal(type: "money", nullable: false),

        InstructorID = table.Columnint(type: "int", nullable: true),

        Name = table.Columnstring(type: "nvarchar(50)", maxLength: 50, nullable: true),

        StartDate = table.ColumnDateTime(type: "datetime2", nullable: false)

    },

    constraints: table =

    {

        table.PrimaryKey("PK_Department", x = x.DepartmentID);

        table.ForeignKey(

            name: "FK_Department_Instructor_InstructorID",

            column: x = x.InstructorID,

            principalTable: "Instructor",

            principalColumn: "ID",

            onDelete: ReferentialAction.Restrict);

    });

 migrationBuilder.Sql("INSERT INTO dbo.Department (Name, Budget, StartDate) VALUES ('Temp', 0.00, GETDATE())");

// Default value for FK points to department created above, with

// defaultValue changed to 1 in following AddColumn statement.

migrationBuilder.AddColumnint(

    name: "DepartmentID",

    table: "Course",

    nullable: false,

    defaultValue: 1);

With the preceding changes, existing Course rows will be related to the "Temp" department after the ComplexDataModel Up method runs.

A production app would:

- Include code or scripts to add Department rows and related Course rows to the new Departmentrows.
- Not use the "Temp" department or the default value for Course.DepartmentID.

The next tutorial covers related data.

# Part 6 of 8

The Contoso University web app demonstrates how to create Razor Pages web apps using EF Core and Visual Studio. For information about the tutorial series, see [the first tutorial](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2).

In this tutorial, related data is read and displayed. Related data is data that EF Core loads into navigation properties.

If you run into problems you can't solve, [download or view the completed app.](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples) [Download instructions](https://docs.microsoft.com/en-us/aspnet/core/index?view=aspnetcore-2.2).

The following illustrations show the completed pages for this tutorial:

![Courses Index page](image_29)

![Instructors Index page](image_30)

## Eager, explicit, and lazy Loading of related data

There are several ways that EF Core can load related data into the navigation properties of an entity:

- [Eager loading](https://docs.microsoft.com/ef/core/querying/related-data). Eager loading is when a query for one type of entity also loads related entities. When the entity is read, its related data is retrieved. This typically results in a single join query that retrieves all of the data that's needed. EF Core will issue multiple queries for some types of eager loading. Issuing multiple queries can be more efficient than was the case for some queries in EF6 where there was a single query. Eager loading is specified with the Include and ThenInclude methods.

![Eager loading example](image_31)

Eager loading sends multiple queries when a collection navigation is included:

  - One query for the main query
  - One query for each collection "edge" in the load tree.
- Separate queries with Load: The data can be retrieved in separate queries, and EF Core "fixes up" the navigation properties. "fixes up" means that EF Core automatically populates the navigation properties. Separate queries with Load is more like explict loading than eager loading.

![Separate queries example](image_32)

Note: EF Core automatically fixes up navigation properties to any other entities that were previously loaded into the context instance. Even if the data for a navigation property is not explicitly included, the property may still be populated if some or all of the related entities were previously loaded.

- [Explicit loading](https://docs.microsoft.com/ef/core/querying/related-data). When the entity is first read, related data isn't retrieved. Code must be written to retrieve the related data when it's needed. Explicit loading with separate queries results in multiple queries sent to the DB. With explicit loading, the code specifies the navigation properties to be loaded. Use the Loadmethod to do explicit loading. For example:

![Explicit loading example](image_33)

- [Lazy loading](https://docs.microsoft.com/ef/core/querying/related-data). [Lazy loading was added to EF Core in version 2.1](https://docs.microsoft.com/ef/core/querying/related-data). When the entity is first read, related data isn't retrieved. The first time a navigation property is accessed, the data required for that navigation property is automatically retrieved. A query is sent to the DB each time a navigation property is accessed for the first time.
- The Select operator loads only the related data needed.

## Create a Course page that displays department name

The Course entity includes a navigation property that contains the Department entity. The Department entity contains the department that the course is assigned to.

To display the name of the assigned department in a list of courses:

- Get the Name property from the Department entity.
- The Department entity comes from the Course.Department navigation property.

![ourse.Department](image_34)

### Scaffold the Course model

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/read-related-data?view=aspnetcore-2.2&amp;tabs=visual-studio)

Follow the instructions in [Scaffold the student model](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2) and use Course for the model class.

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/read-related-data?view=aspnetcore-2.2&amp;tabs=visual-studio)

Run the following command:

consoleCopy

dotnet aspnet-codegenerator razorpage -m Course -dc SchoolContext -udl -outDir Pages\Courses --referenceScriptLibraries

CONTINUE… 

The preceding command scaffolds the Course model. Open the project in Visual Studio.

Open Pages/Courses/Index.cshtml.cs and examine the OnGetAsync method. The scaffolding engine specified eager loading for the Department navigation property. The Include method specifies eager loading.

Run the app and select the Courses link. The department column displays the DepartmentID, which isn't useful.

Update the OnGetAsync method with the following code:

C#Copy

public async Task OnGetAsync()

{

    Course = await _context.Courses

        .Include(c = c.Department)

        .AsNoTracking()

        .ToListAsync();

}

The preceding code adds AsNoTracking. AsNoTracking improves performance because the entities returned are not tracked. The entities are not tracked because they're not updated in the current context.

Update Pages/Courses/Index.cshtml with the following highlighted markup:

HTMLCopy

@page

@model ContosoUniversity.Pages.Courses.IndexModel

@{

    ViewData["Title"] = "Courses";

}

h2Courses/h2

p

    a asp-page="Create"Create New/a

/p

table class="table"

    thead

        tr

            th

                @Html.DisplayNameFor(model = model.Course[0].CourseID)

            /th

            th

                @Html.DisplayNameFor(model = model.Course[0].Title)

            /th

            th

                @Html.DisplayNameFor(model = model.Course[0].Credits)

            /th

            th

                @Html.DisplayNameFor(model = model.Course[0].Department)

            /th

            th/th

        /tr

    /thead

    tbody

        @foreach (var item in Model.Course)

        {

            tr

                td

                    @Html.DisplayFor(modelItem = item.CourseID)

                /td

                td

                    @Html.DisplayFor(modelItem = item.Title)

                /td

                td

                    @Html.DisplayFor(modelItem = item.Credits)

                /td

                td

                    @Html.DisplayFor(modelItem = item.Department.Name)

                /td

                td

                    a asp-page="./Edit" asp-route-id="@item.CourseID"Edit/a |

                    a asp-page="./Details" asp-route-id="@item.CourseID"Details/a |

                    a asp-page="./Delete" asp-route-id="@item.CourseID"Delete/a

                /td

            /tr

        }

    /tbody

/table

The following changes have been made to the scaffolded code:

- Changed the heading from Index to Courses.
- Added a Number column that shows the CourseID property value. By default, primary keys aren't scaffolded because normally they're meaningless to end users. However, in this case the primary key is meaningful.
- Changed the Department column to display the department name. The code displays the Nameproperty of the Department entity that's loaded into the Department navigation property:

HTMLCopy

@Html.DisplayFor(modelItem = item.Department.Name)

Run the app and select the Courses tab to see the list with department names.

![Courses Index page](image_35)

### Loading related data with Select

The OnGetAsync method loads related data with the Include method:

C#Copy

public async Task OnGetAsync()

{

    Course = await _context.Courses

        .Include(c = c.Department)

        .AsNoTracking()

        .ToListAsync();

}

The Select operator loads only the related data needed. For single items, like the Department.Name it uses a SQL INNER JOIN. For collections, it uses another database access, but so does the Include operator on collections.

The following code loads related data with the Select method:

C#Copy

public IListCourseViewModel CourseVM { get; set; }

public async Task OnGetAsync()

{

    CourseVM = await _context.Courses

            .Select(p = new CourseViewModel

            {

                CourseID = p.CourseID,

                Title = p.Title,

                Credits = p.Credits,

                DepartmentName = p.Department.Name

            }).ToListAsync();

}

The CourseViewModel:

C#Copy

public class CourseViewModel

{

    public int CourseID { get; set; }

    public string Title { get; set; }

    public int Credits { get; set; }

    public string DepartmentName { get; set; }

}

See [IndexSelect.cshtml](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples/cu/Pages/Courses/IndexSelect.cshtml) and [IndexSelect.cshtml.cs](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples/cu/Pages/Courses/IndexSelect.cshtml.cs) for a complete example.

## Create an Instructors page that shows Courses and Enrollments

In this section, the Instructors page is created.

![Instructors Index page](image_36)

This page reads and displays related data in the following ways:

- The list of instructors displays related data from the OfficeAssignment entity (Office in the preceding image). The Instructor and OfficeAssignment entities are in a one-to-zero-or-one relationship. Eager loading is used for the OfficeAssignment entities. Eager loading is typically more efficient when the related data needs to be displayed. In this case, office assignments for the instructors are displayed.
- When the user selects an instructor (Harui in the preceding image), related Course entities are displayed. The Instructor and Course entities are in a many-to-many relationship. Eager loading is used for the Course entities and their related Department entities. In this case, separate queries might be more efficient because only courses for the selected instructor are needed. This example shows how to use eager loading for navigation properties in entities that are in navigation properties.
- When the user selects a course (Chemistry in the preceding image), related data from the Enrollmentsentity is displayed. In the preceding image, student name and grade are displayed. The Course and Enrollment entities are in a one-to-many relationship.

### Create a view model for the Instructor Index view

The instructors page shows data from three different tables. A view model is created that includes the three entities representing the three tables.

In the SchoolViewModels folder, create InstructorIndexData.cs with the following code:

C#Copy

using System;

using System.Collections.Generic;

using System.Linq;

using System.Threading.Tasks;

namespace ContosoUniversity.Models.SchoolViewModels

{

    public class InstructorIndexData

    {

        public IEnumerableInstructor Instructors { get; set; }

        public IEnumerableCourse Courses { get; set; }

        public IEnumerableEnrollment Enrollments { get; set; }

    }

}

### Scaffold the Instructor model

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/read-related-data?view=aspnetcore-2.2&amp;tabs=visual-studio)

Follow the instructions in [Scaffold the student model](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2) and use Instructor for the model class.

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/read-related-data?view=aspnetcore-2.2&amp;tabs=visual-studio)

Run the following command:

consoleCopy

dotnet aspnet-codegenerator razorpage -m Instructor -dc SchoolContext -udl -outDir Pages\Instructors --referenceScriptLibraries

CONTINUE… 

The preceding command scaffolds the Instructor model. Run the app and navigate to the instructors page.

Replace Pages/Instructors/Index.cshtml.cs with the following code:

C#Copy

using ContosoUniversity.Models;

using ContosoUniversity.Models.SchoolViewModels;  // Add VM

using Microsoft.AspNetCore.Mvc.RazorPages;

using Microsoft.EntityFrameworkCore;

using System.Linq;

using System.Threading.Tasks;

namespace ContosoUniversity.Pages.Instructors

{

    public class IndexModel : PageModel

    {

        private readonly ContosoUniversity.Data.SchoolContext _context;

        public IndexModel(ContosoUniversity.Data.SchoolContext context)

        {

            _context = context;

        }

        public InstructorIndexData Instructor { get; set; }

        public int InstructorID { get; set; }

        public async Task OnGetAsync(int? id)

        {

            Instructor = new InstructorIndexData();

            Instructor.Instructors = await _context.Instructors

                  .Include(i = i.OfficeAssignment)

                  .Include(i = i.CourseAssignments)

                    .ThenInclude(i = i.Course)

                  .AsNoTracking()

                  .OrderBy(i = i.LastName)

                  .ToListAsync();

            if (id != null)

            {

                InstructorID = id.Value;

            }           

        }

    }

}

The OnGetAsync method accepts optional route data for the ID of the selected instructor.

Examine the query in the Pages/Instructors/Index.cshtml.cs file:

C#Copy

Instructor.Instructors = await _context.Instructors

      .Include(i = i.OfficeAssignment)

      .Include(i = i.CourseAssignments)

        .ThenInclude(i = i.Course)

      .AsNoTracking()

      .OrderBy(i = i.LastName)

      .ToListAsync();

The query has two includes:

- OfficeAssignment: Displayed in the [instructors view](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/read-related-data?view=aspnetcore-2.2&amp;tabs=visual-studio).
- CourseAssignments: Which brings in the courses taught.

### Update the instructors Index page

Update Pages/Instructors/Index.cshtml with the following markup:

HTMLCopy

@page "{id:int?}"

@model ContosoUniversity.Pages.Instructors.IndexModel

@{

    ViewData["Title"] = "Instructors";

}

h2Instructors/h2

p

    a asp-page="Create"Create New/a

/p

table class="table"

    thead

        tr

            thLast Name/th

            thFirst Name/th

            thHire Date/th

            thOffice/th

            thCourses/th

            th/th

        /tr

    /thead

    tbody

        @foreach (var item in Model.Instructor.Instructors)

        {

            string selectedRow = "";

            if (item.ID == Model.InstructorID)

            {

                selectedRow = "success";

            }

            tr class="@selectedRow"

                td

                    @Html.DisplayFor(modelItem = item.LastName)

                /td

                td

                    @Html.DisplayFor(modelItem = item.FirstMidName)

                /td

                td

                    @Html.DisplayFor(modelItem = item.HireDate)

                /td

                td

                    @if (item.OfficeAssignment != null)

                    {

                        @item.OfficeAssignment.Location

                    }

                /td

                td

                    @{

                        foreach (var course in item.CourseAssignments)

                        {

                            @course.Course.CourseID @:  @course.Course.Title br /

                        }

                    }

                /td

                td

                    a asp-page="./Index" asp-route-id="@item.ID"Select/a |

                    a asp-page="./Edit" asp-route-id="@item.ID"Edit/a |

                    a asp-page="./Details" asp-route-id="@item.ID"Details/a |

                    a asp-page="./Delete" asp-route-id="@item.ID"Delete/a

                /td

            /tr

        }

    /tbody

/table

The preceding markup makes the following changes:

- Updates the page directive from @page to @page "{id:int?}". "{id:int?}" is a route template. The route template changes integer query strings in the URL to route data. For example, clicking on the Select link for an instructor with only the @page directive produces a URL like the following:

http://localhost:1234/Instructors?id=2

When the page directive is @page "{id:int?}", the previous URL is:

http://localhost:1234/Instructors/2

- Page title is Instructors.
- Added an Office column that displays item.OfficeAssignment.Location only if item.OfficeAssignmentisn't null. Because this is a one-to-zero-or-one relationship, there might not be a related OfficeAssignment entity.

HTMLCopy

@if (item.OfficeAssignment != null)

{

    @item.OfficeAssignment.Location

}

- Added a Courses column that displays courses taught by each instructor. See [Explicit Line Transition with ](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-2.2)[<u>@:</u>](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-2.2) for more about this razor syntax.
- Added code that dynamically adds class="success" to the tr element of the selected instructor. This sets a background color for the selected row using a Bootstrap class.

HTMLCopy

string selectedRow = "";

if (item.CourseID == Model.CourseID)

{

    selectedRow = "success";

}

tr class="@selectedRow"

- Added a new hyperlink labeled Select. This link sends the selected instructor's ID to the Index method and sets a background color.

HTMLCopy

a asp-action="Index" asp-route-id="@item.ID"Select/a |

Run the app and select the Instructors tab. The page displays the Location (office) from the related OfficeAssignment entity. If OfficeAssignment` is null, an empty table cell is displayed.

![Instructors Index page nothing selected](image_37)

Click on the Select link. The row style changes.

### Add courses taught by selected instructor

Update the OnGetAsync method in Pages/Instructors/Index.cshtml.cs with the following code:

C#Copy

public async Task OnGetAsync(int? id, int? courseID)

{

    Instructor = new InstructorIndexData();

    Instructor.Instructors = await _context.Instructors

          .Include(i = i.OfficeAssignment)

          .Include(i = i.CourseAssignments)

            .ThenInclude(i = i.Course)

                .ThenInclude(i = i.Department)

          .AsNoTracking()

          .OrderBy(i = i.LastName)

          .ToListAsync();

    if (id != null)

    {

        InstructorID = id.Value;

        Instructor instructor = Instructor.Instructors.Where(

            i = i.ID == id.Value).Single();

        Instructor.Courses = instructor.CourseAssignments.Select(s = s.Course);

    }

    if (courseID != null)

    {

        CourseID = courseID.Value;

        Instructor.Enrollments = Instructor.Courses.Where(

            x = x.CourseID == courseID).Single().Enrollments;

    }

}

Add public int CourseID { get; set; }

C#Copy

public class IndexModel : PageModel

{

    private readonly ContosoUniversity.Data.SchoolContext _context;

    public IndexModel(ContosoUniversity.Data.SchoolContext context)

    {

        _context = context;

    }

    public InstructorIndexData Instructor { get; set; }

    public int InstructorID { get; set; }

    public int CourseID { get; set; }

    public async Task OnGetAsync(int? id, int? courseID)

    {

        Instructor = new InstructorIndexData();

        Instructor.Instructors = await _context.Instructors

              .Include(i = i.OfficeAssignment)

              .Include(i = i.CourseAssignments)

                .ThenInclude(i = i.Course)

                    .ThenInclude(i = i.Department)

              .AsNoTracking()

              .OrderBy(i = i.LastName)

              .ToListAsync();

        if (id != null)

        {

            InstructorID = id.Value;

            Instructor instructor = Instructor.Instructors.Where(

                i = i.ID == id.Value).Single();

            Instructor.Courses = instructor.CourseAssignments.Select(s = s.Course);

        }

        if (courseID != null)

        {

            CourseID = courseID.Value;

            Instructor.Enrollments = Instructor.Courses.Where(

                x = x.CourseID == courseID).Single().Enrollments;

        }

    }

Examine the updated query:

C#Copy

Instructor.Instructors = await _context.Instructors

      .Include(i = i.OfficeAssignment)

      .Include(i = i.CourseAssignments)

        .ThenInclude(i = i.Course)

            .ThenInclude(i = i.Department)

      .AsNoTracking()

      .OrderBy(i = i.LastName)

      .ToListAsync();

The preceding query adds the Department entities.

The following code executes when an instructor is selected (id != null). The selected instructor is retrieved from the list of instructors in the view model. The view model's Courses property is loaded with the Courseentities from that instructor's CourseAssignments navigation property.

C#Copy

if (id != null)

{

    InstructorID = id.Value;

    Instructor instructor = Instructor.Instructors.Where(

        i = i.ID == id.Value).Single();

    Instructor.Courses = instructor.CourseAssignments.Select(s = s.Course);

}

The Where method returns a collection. In the preceding Where method, only a single Instructor entity is returned. The Single method converts the collection into a single Instructor entity. The Instructor entity provides access to the CourseAssignments property. CourseAssignments provides access to the related Course entities.

![Instructor-to-Courses m:M](image_38)

The Single method is used on a collection when the collection has only one item. The Single method throws an exception if the collection is empty or if there's more than one item. An alternative is SingleOrDefault, which returns a default value (null in this case) if the collection is empty. Using SingleOrDefault on an empty collection:

- Results in an exception (from trying to find a Courses property on a null reference).
- The exception message would less clearly indicate the cause of the problem.

The following code populates the view model's Enrollments property when a course is selected:

C#Copy

if (courseID != null)

{

    CourseID = courseID.Value;

    Instructor.Enrollments = Instructor.Courses.Where(

        x = x.CourseID == courseID).Single().Enrollments;

}

Add the following markup to the end of the Pages/Instructors/Index.cshtml Razor Page:

HTMLCopy

                    a asp-page="./Delete" asp-route-id="@item.ID"Delete/a

                /td

            /tr

        }

    /tbody

/table

@if (Model.Instructor.Courses != null)

{

    h3Courses Taught by Selected Instructor/h3

    table class="table"

        tr

            th/th

            thNumber/th

            thTitle/th

            thDepartment/th

        /tr

        @foreach (var item in Model.Instructor.Courses)

        {

            string selectedRow = "";

            if (item.CourseID == Model.CourseID)

            {

                selectedRow = "success";

            }

            tr class="@selectedRow"

                td

                    a asp-page="./Index" asp-route-courseID="@item.CourseID"Select/a

                /td

                td

                    @item.CourseID

                /td

                td

                    @item.Title

                /td

                td

                    @item.Department.Name

                /td

            /tr

        }

    /table

}

The preceding markup displays a list of courses related to an instructor when an instructor is selected.

Test the app. Click on a Select link on the instructors page.

![Instructors Index page instructor selected](image_39)

### Show student data

In this section, the app is updated to show the student data for a selected course.

Update the query in the OnGetAsync method in Pages/Instructors/Index.cshtml.cs with the following code:

C#Copy

Instructor.Instructors = await _context.Instructors

      .Include(i = i.OfficeAssignment)                 

      .Include(i = i.CourseAssignments)

        .ThenInclude(i = i.Course)

            .ThenInclude(i = i.Department)

        .Include(i = i.CourseAssignments)

            .ThenInclude(i = i.Course)

                .ThenInclude(i = i.Enrollments)

                    .ThenInclude(i = i.Student)

      .AsNoTracking()

      .OrderBy(i = i.LastName)

      .ToListAsync();

Update Pages/Instructors/Index.cshtml. Add the following markup to the end of the file:

HTMLCopy

@if (Model.Instructor.Enrollments != null)

{

    h3

        Students Enrolled in Selected Course

    /h3

    table class="table"

        tr

            thName/th

            thGrade/th

        /tr

        @foreach (var item in Model.Instructor.Enrollments)

        {

            tr

                td

                    @item.Student.FullName

                /td

                td

                    @Html.DisplayFor(modelItem = item.Grade)

                /td

            /tr

        }

    /table

}

The preceding markup displays a list of the students who are enrolled in the selected course.

Refresh the page and select an instructor. Select a course to see the list of enrolled students and their grades.

![Instructors Index page instructor and course selected](image_40)

## Using Single

The Single method can pass in the Where condition instead of calling the Where method separately:

C#Copy

public async Task OnGetAsync(int? id, int? courseID)

{

    Instructor = new InstructorIndexData();

    Instructor.Instructors = await _context.Instructors

          .Include(i = i.OfficeAssignment)

          .Include(i = i.CourseAssignments)

            .ThenInclude(i = i.Course)

                .ThenInclude(i = i.Department)

            .Include(i = i.CourseAssignments)

                .ThenInclude(i = i.Course)

                    .ThenInclude(i = i.Enrollments)

                        .ThenInclude(i = i.Student)

          .AsNoTracking()

          .OrderBy(i = i.LastName)

          .ToListAsync();

    if (id != null)

    {

        InstructorID = id.Value;

        Instructor instructor = Instructor.Instructors.Single(

            i = i.ID == id.Value);

        Instructor.Courses = instructor.CourseAssignments.Select(

            s = s.Course);

    }

    if (courseID != null)

    {

        CourseID = courseID.Value;

        Instructor.Enrollments = Instructor.Courses.Single(

            x = x.CourseID == courseID).Enrollments;

    }

}

The preceding Single approach provides no benefits over using Where. Some developers prefer the Single approach style.

## Explicit loading

The current code specifies eager loading for Enrollments and Students:

C#Copy

Instructor.Instructors = await _context.Instructors

      .Include(i = i.OfficeAssignment)                 

      .Include(i = i.CourseAssignments)

        .ThenInclude(i = i.Course)

            .ThenInclude(i = i.Department)

        .Include(i = i.CourseAssignments)

            .ThenInclude(i = i.Course)

                .ThenInclude(i = i.Enrollments)

                    .ThenInclude(i = i.Student)

      .AsNoTracking()

      .OrderBy(i = i.LastName)

      .ToListAsync();

Suppose users rarely want to see enrollments in a course. In that case, an optimization would be to only load the enrollment data if it's requested. In this section, the OnGetAsync is updated to use explicit loading of Enrollments and Students.

Update the OnGetAsync with the following code:

C#Copy

public async Task OnGetAsync(int? id, int? courseID)

{

    Instructor = new InstructorIndexData();

    Instructor.Instructors = await _context.Instructors

          .Include(i = i.OfficeAssignment)                 

          .Include(i = i.CourseAssignments)

            .ThenInclude(i = i.Course)

                .ThenInclude(i = i.Department)

            //.Include(i = i.CourseAssignments)

            //    .ThenInclude(i = i.Course)

            //        .ThenInclude(i = i.Enrollments)

            //            .ThenInclude(i = i.Student)

         // .AsNoTracking()

          .OrderBy(i = i.LastName)

          .ToListAsync();

    if (id != null)

    {

        InstructorID = id.Value;

        Instructor instructor = Instructor.Instructors.Where(

            i = i.ID == id.Value).Single();

        Instructor.Courses = instructor.CourseAssignments.Select(s = s.Course);

    }

    if (courseID != null)

    {

        CourseID = courseID.Value;

        var selectedCourse = Instructor.Courses.Where(x = x.CourseID == courseID).Single();

        await _context.Entry(selectedCourse).Collection(x = x.Enrollments).LoadAsync();

        foreach (Enrollment enrollment in selectedCourse.Enrollments)

        {

            await _context.Entry(enrollment).Reference(x = x.Student).LoadAsync();

        }

        Instructor.Enrollments = selectedCourse.Enrollments;

    }

}

The preceding code drops the ThenInclude method calls for enrollment and student data. If a course is selected, the highlighted code retrieves:

- The Enrollment entities for the selected course.
- The Student entities for each Enrollment.

Notice the preceding code comments out .AsNoTracking(). Navigation properties can only be explicitly loaded for tracked entities.

Test the app. From a users perspective, the app behaves identically to the previous version.

The next tutorial shows how to update related data.

# Part 7 of 8

The Contoso University web app demonstrates how to create Razor Pages web apps using EF Core and Visual Studio. For information about the tutorial series, see [the first tutorial](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2).

This tutorial demonstrates updating related data. If you run into problems you can't solve, [download or view the completed app.](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples) [Download instructions](https://docs.microsoft.com/en-us/aspnet/core/index?view=aspnetcore-2.2).

The following illustrations shows some of the completed pages.

![Course Edit page](image_41)

![Instructor Edit page](image_42)

 

Examine and test the Create and Edit course pages. Create a new course. The department is selected by its primary key (an integer), not its name. Edit the new course. When you have finished testing, delete the new course.

## Create a base class to share common code

The Courses/Create and Courses/Edit pages each need a list of department names. Create the Pages/Courses/DepartmentNamePageModel.cshtml.cs base class for the Create and Edit pages:

C#Copy

using ContosoUniversity.Data;

using Microsoft.AspNetCore.Mvc.RazorPages;

using Microsoft.AspNetCore.Mvc.Rendering;

using Microsoft.EntityFrameworkCore;

using System.Linq;

namespace ContosoUniversity.Pages.Courses

{

    public class DepartmentNamePageModel : PageModel

    {

        public SelectList DepartmentNameSL { get; set; }

        public void PopulateDepartmentsDropDownList(SchoolContext _context,

            object selectedDepartment = null)

        {

            var departmentsQuery = from d in _context.Departments

                                   orderby d.Name // Sort by name.

                                   select d;

            DepartmentNameSL = new SelectList(departmentsQuery.AsNoTracking(),

                        "DepartmentID", "Name", selectedDepartment);

        }

    }

}

The preceding code creates a [SelectList](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.rendering.selectlist?view=aspnetcore-2.0) to contain the list of department names. If selectedDepartment is specified, that department is selected in the SelectList.

The Create and Edit page model classes will derive from DepartmentNamePageModel.

## Customize the Courses Pages

When a new course entity is created, it must have a relationship to an existing department. To add a department while creating a course, the base class for Create and Edit contains a drop-down list for selecting the department. The drop-down list sets the Course.DepartmentID foreign key (FK) property. EF Core uses the Course.DepartmentID FK to load the Department navigation property.

![Create course](image_43)

Update the Create page model with the following code:

C#Copy

using ContosoUniversity.Models;

using Microsoft.AspNetCore.Mvc;

using System.Threading.Tasks;

namespace ContosoUniversity.Pages.Courses

{

    public class CreateModel : DepartmentNamePageModel

    {

        private readonly ContosoUniversity.Data.SchoolContext _context;

        public CreateModel(ContosoUniversity.Data.SchoolContext context)

        {

            _context = context;

        }

        public IActionResult OnGet()

        {

            PopulateDepartmentsDropDownList(_context);

            return Page();

        }

        [BindProperty]

        public Course Course { get; set; }

        public async TaskIActionResult OnPostAsync()

        {

            if (!ModelState.IsValid)

            {

                return Page();

            }

            var emptyCourse = new Course();

            if (await TryUpdateModelAsyncCourse(

                 emptyCourse,

                 "course",   // Prefix for form value.

                 s = s.CourseID, s = s.DepartmentID, s = s.Title, s = s.Credits))

            {

                _context.Courses.Add(emptyCourse);

                await _context.SaveChangesAsync();

                return RedirectToPage("./Index");

            }

            // Select DepartmentID if TryUpdateModelAsync fails.

            PopulateDepartmentsDropDownList(_context, emptyCourse.DepartmentID);

            return Page();

        }

      }

}

The preceding code:

- Derives from DepartmentNamePageModel.
- Uses TryUpdateModelAsync to prevent [overposting](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/crud?view=aspnetcore-2.2).
- Replaces ViewData["DepartmentID"] with DepartmentNameSL (from the base class).

ViewData["DepartmentID"] is replaced with the strongly typed DepartmentNameSL. Strongly typed models are preferred over weakly typed. For more information, see [Weakly typed data (ViewData and ViewBag)](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/overview?view=aspnetcore-2.2).

### Update the Courses Create page

Update Pages/Courses/Create.cshtml with the following markup:

CSHTMLCopy

@page

@model ContosoUniversity.Pages.Courses.CreateModel

@{

    ViewData["Title"] = "Create Course";

}

h2Create/h2

h4Course/h4

hr /

div class="row"

    div class="col-md-4"

        form method="post"

            div asp-validation-summary="ModelOnly" class="text-danger"/div

            div class="form-group"

                label asp-for="Course.CourseID" class="control-label"/label

                input asp-for="Course.CourseID" class="form-control" /

                span asp-validation-for="Course.CourseID" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Course.Title" class="control-label"/label

                input asp-for="Course.Title" class="form-control" /

                span asp-validation-for="Course.Title" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Course.Credits" class="control-label"/label

                input asp-for="Course.Credits" class="form-control" /

                span asp-validation-for="Course.Credits" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Course.Department" class="control-label"/label

                select asp-for="Course.DepartmentID" class="form-control"

                        asp-items="@Model.DepartmentNameSL"

                    option value=""-- Select Department --/option

                /select

                span asp-validation-for="Course.DepartmentID" class="text-danger" /

            /div

            div class="form-group"

                input type="submit" value="Create" class="btn btn-default" /

            /div

        /form

    /div

/div

div

    a asp-page="Index"Back to List/a

/div

@section Scripts {

    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

}

The preceding markup makes the following changes:

- Changes the caption from DepartmentID to Department.
- Replaces "ViewBag.DepartmentID" with DepartmentNameSL (from the base class).
- Adds the "Select Department" option. This change renders "Select Department" rather than the first department.
- Adds a validation message when the department isn't selected.

The Razor Page uses the [Select Tag Helper](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/working-with-forms?view=aspnetcore-2.2):

CSHTMLCopy

div class="form-group"

    label asp-for="Course.Department" class="control-label"/label

    select asp-for="Course.DepartmentID" class="form-control"

            asp-items="@Model.DepartmentNameSL"

        option value=""-- Select Department --/option

    /select

    span asp-validation-for="Course.DepartmentID" class="text-danger" /

/div

Test the Create page. The Create page displays the department name rather than the department ID.

### Update the Courses Edit page.

Update the edit page model with the following code:

C#Copy

using ContosoUniversity.Models;

using Microsoft.AspNetCore.Mvc;

using Microsoft.EntityFrameworkCore;

using System.Threading.Tasks;

namespace ContosoUniversity.Pages.Courses

{

    public class EditModel : DepartmentNamePageModel

    {

        private readonly ContosoUniversity.Data.SchoolContext _context;

        public EditModel(ContosoUniversity.Data.SchoolContext context)

        {

            _context = context;

        }

        [BindProperty]

        public Course Course { get; set; }

        public async TaskIActionResult OnGetAsync(int? id)

        {

            if (id == null)

            {

                return NotFound();

            }

            Course = await _context.Courses

                .Include(c = c.Department).FirstOrDefaultAsync(m = m.CourseID == id);

            if (Course == null)

            {

                return NotFound();

            }

            // Select current DepartmentID.

            PopulateDepartmentsDropDownList(_context,Course.DepartmentID);

            return Page();

        }

        public async TaskIActionResult OnPostAsync(int? id)

        {

            if (!ModelState.IsValid)

            {

                return Page();

            }

            var courseToUpdate = await _context.Courses.FindAsync(id);

            if (await TryUpdateModelAsyncCourse(

                 courseToUpdate,

                 "course",   // Prefix for form value.

                   c = c.Credits, c = c.DepartmentID, c = c.Title))

            {

                await _context.SaveChangesAsync();

                return RedirectToPage("./Index");

            }

            // Select DepartmentID if TryUpdateModelAsync fails.

            PopulateDepartmentsDropDownList(_context, courseToUpdate.DepartmentID);

            return Page();

        }       

    }

}

The changes are similar to those made in the Create page model. In the preceding code, PopulateDepartmentsDropDownList passes in the department ID, which select the department specified in the drop-down list.

Update Pages/Courses/Edit.cshtml with the following markup:

CSHTMLCopy

@page

@model ContosoUniversity.Pages.Courses.EditModel

@{

    ViewData["Title"] = "Edit";

}

h2Edit/h2

h4Course/h4

hr /

div class="row"

    div class="col-md-4"

        form method="post"

            div asp-validation-summary="ModelOnly" class="text-danger"/div

            input type="hidden" asp-for="Course.CourseID" /

            div class="form-group"

                label asp-for="Course.CourseID" class="control-label"/label

                div@Html.DisplayFor(model = model.Course.CourseID)/div

            /div

            div class="form-group"

                label asp-for="Course.Title" class="control-label"/label

                input asp-for="Course.Title" class="form-control" /

                span asp-validation-for="Course.Title" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Course.Credits" class="control-label"/label

                input asp-for="Course.Credits" class="form-control" /

                span asp-validation-for="Course.Credits" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Course.Department" class="control-label"/label

                select asp-for="Course.DepartmentID" class="form-control" 

                        asp-items="@Model.DepartmentNameSL"/select

                span asp-validation-for="Course.DepartmentID" class="text-danger"/span

            /div

            div class="form-group"

                input type="submit" value="Save" class="btn btn-default" /

            /div

        /form

    /div

/div

div

    a asp-page="./Index"Back to List/a

/div

@section Scripts {

    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

}

The preceding markup makes the following changes:

- Displays the course ID. Generally the Primary Key (PK) of an entity isn't displayed. PKs are usually meaningless to users. In this case, the PK is the course number.
- Changes the caption from DepartmentID to Department.
- Replaces "ViewBag.DepartmentID" with DepartmentNameSL (from the base class).

The page contains a hidden field (input type="hidden") for the course number. Adding a label tag helper with asp-for="Course.CourseID" doesn't eliminate the need for the hidden field. input type="hidden"is required for the course number to be included in the posted data when the user clicks Save.

Test the updated code. Create, edit, and delete a course.

## Add AsNoTracking to the Details and Delete page models

[AsNoTracking](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.asnotracking?view=efcore-2.0) can improve performance when tracking isn't required. Add AsNoTracking to the Delete and Details page model. The following code shows the updated Delete page model:

C#Copy

public class DeleteModel : PageModel

{

    private readonly ContosoUniversity.Data.SchoolContext _context;

    public DeleteModel(ContosoUniversity.Data.SchoolContext context)

    {

        _context = context;

    }

    [BindProperty]

    public Course Course { get; set; }

    public async TaskIActionResult OnGetAsync(int? id)

    {

        if (id == null)

        {

            return NotFound();

        }

        Course = await _context.Courses

            .AsNoTracking()

            .Include(c = c.Department)

            .FirstOrDefaultAsync(m = m.CourseID == id);

        if (Course == null)

        {

            return NotFound();

        }

        return Page();

    }

    public async TaskIActionResult OnPostAsync(int? id)

    {

        if (id == null)

        {

            return NotFound();

        }

        Course = await _context.Courses

            .AsNoTracking()

            .FirstOrDefaultAsync(m = m.CourseID == id);

        if (Course != null)

        {

            _context.Courses.Remove(Course);

            await _context.SaveChangesAsync();

        }

        return RedirectToPage("./Index");

    }

}

Update the OnGetAsync method in the Pages/Courses/Details.cshtml.cs file:

C#Copy

public async TaskIActionResult OnGetAsync(int? id)

{

    if (id == null)

    {

        return NotFound();

    }

    Course = await _context.Courses

         .AsNoTracking()

         .Include(c = c.Department)

         .FirstOrDefaultAsync(m = m.CourseID == id);

    if (Course == null)

    {

        return NotFound();

    }

    return Page();

}

### Modify the Delete and Details pages

Update the Delete Razor page with the following markup:

CSHTMLCopy

@page

@model ContosoUniversity.Pages.Courses.DeleteModel

@{

    ViewData["Title"] = "Delete";

}

h2Delete/h2

h3Are you sure you want to delete this?/h3

div

    h4Course/h4

    hr /

    dl class="dl-horizontal"

        dt

            @Html.DisplayNameFor(model = model.Course.CourseID)

        /dt

        dd

            @Html.DisplayFor(model = model.Course.CourseID)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Course.Title)

        /dt

        dd

            @Html.DisplayFor(model = model.Course.Title)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Course.Credits)

        /dt

        dd

            @Html.DisplayFor(model = model.Course.Credits)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Course.Department)

        /dt

        dd

            @Html.DisplayFor(model = model.Course.Department.DepartmentID)

        /dd

    /dl

    

    form method="post"

        input type="hidden" asp-for="Course.CourseID" /

        input type="submit" value="Delete" class="btn btn-default" / |

        a asp-page="./Index"Back to List/a

    /form

/div

Make the same changes to the Details page.

### Test the Course pages

Test create, edit, details, and delete.

## Update the instructor pages

The following sections update the instructor pages.

### Add office location

When editing an instructor record, you may want to update the instructor's office assignment. The Instructor entity has a one-to-zero-or-one relationship with the OfficeAssignment entity. The instructor code must handle:

- If the user clears the office assignment, delete the OfficeAssignment entity.
- If the user enters an office assignment and it was empty, create a new OfficeAssignment entity.
- If the user changes the office assignment, update the OfficeAssignment entity.

Update the instructors Edit page model with the following code:

C#Copy

public class EditModel : PageModel

{

    private readonly ContosoUniversity.Data.SchoolContext _context;

    public EditModel(ContosoUniversity.Data.SchoolContext context)

    {

        _context = context;

    }

    [BindProperty]

    public Instructor Instructor { get; set; }

    public async TaskIActionResult OnGetAsync(int? id)

    {

        if (id == null)

        {

            return NotFound();

        }

        Instructor = await _context.Instructors

            .Include(i = i.OfficeAssignment)

            .AsNoTracking()

            .FirstOrDefaultAsync(m = m.ID == id);

        if (Instructor == null)

        {

            return NotFound();

        }

        return Page();

    }

    public async TaskIActionResult OnPostAsync(int? id)

    {

        if (!ModelState.IsValid)

        {

            return Page();

        }

        var instructorToUpdate = await _context.Instructors

            .Include(i = i.OfficeAssignment)

            .FirstOrDefaultAsync(s = s.ID == id);

        if (await TryUpdateModelAsyncInstructor(

            instructorToUpdate,

            "Instructor",

            i = i.FirstMidName, i = i.LastName, 

            i = i.HireDate, i = i.OfficeAssignment))

        {

            if (String.IsNullOrWhiteSpace(

                instructorToUpdate.OfficeAssignment?.Location))

            {

                instructorToUpdate.OfficeAssignment = null;

            }

            await _context.SaveChangesAsync();

        }

        return RedirectToPage("./Index");

    }

}

The preceding code:

- Gets the current Instructor entity from the database using eager loading for the OfficeAssignmentnavigation property.
- Updates the retrieved Instructor entity with values from the model binder. TryUpdateModel prevents [overposting](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/crud?view=aspnetcore-2.2).
- If the office location is blank, sets Instructor.OfficeAssignment to null. When Instructor.OfficeAssignment is null, the related row in the OfficeAssignment table is deleted.

### Update the instructor Edit page

Update Pages/Instructors/Edit.cshtml with the office location:

CSHTMLCopy

@page

@model ContosoUniversity.Pages.Instructors.EditModel

@{

    ViewData["Title"] = "Edit";

}

h2Edit/h2

h4Instructor/h4

hr /

div class="row"

    div class="col-md-4"

        form method="post"

            div asp-validation-summary="ModelOnly" class="text-danger"/div

            input type="hidden" asp-for="Instructor.ID" /

            div class="form-group"

                label asp-for="Instructor.LastName" class="control-label"/label

                input asp-for="Instructor.LastName" class="form-control" /

                span asp-validation-for="Instructor.LastName" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Instructor.FirstMidName" class="control-label"/label

                input asp-for="Instructor.FirstMidName" class="form-control" /

                span asp-validation-for="Instructor.FirstMidName" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Instructor.HireDate" class="control-label"/label

                input asp-for="Instructor.HireDate" class="form-control" /

                span asp-validation-for="Instructor.HireDate" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Instructor.OfficeAssignment.Location" class="control-label"/label

                input asp-for="Instructor.OfficeAssignment.Location" class="form-control" /

                span asp-validation-for="Instructor.OfficeAssignment.Location" class="text-danger" /

            /div

            div class="form-group"

                input type="submit" value="Save" class="btn btn-default" /

            /div

        /form

    /div

/div

div

    a asp-page="./Index"Back to List/a

/div

@section Scripts {

    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

}

Verify you can change an instructors office location.

## Add Course assignments to the instructor Edit page

Instructors may teach any number of courses. In this section, you add the ability to change course assignments. The following image shows the updated instructor Edit page:

![Instructor Edit page with courses](image_44)

Course and Instructor has a many-to-many relationship. To add and remove relationships, you add and remove entities from the CourseAssignments join entity set.

Check boxes enable changes to courses an instructor is assigned to. A check box is displayed for every course in the database. Courses that the instructor is assigned to are checked. The user can select or clear check boxes to change course assignments. If the number of courses were much greater:

- You'd probably use a different user interface to display the courses.
- The method of manipulating a join entity to create or delete relationships wouldn't change.

### Add classes to support Create and Edit instructor pages

Create SchoolViewModels/AssignedCourseData.cs with the following code:

C#Copy

namespace ContosoUniversity.Models.SchoolViewModels

{

    public class AssignedCourseData

    {

        public int CourseID { get; set; }

        public string Title { get; set; }

        public bool Assigned { get; set; }

    }

}

The AssignedCourseData class contains data to create the check boxes for assigned courses by an instructor.

Create the Pages/Instructors/InstructorCoursesPageModel.cshtml.cs base class:

C#Copy

using ContosoUniversity.Data;

using ContosoUniversity.Models;

using ContosoUniversity.Models.SchoolViewModels;

using Microsoft.AspNetCore.Mvc.RazorPages;

using System.Collections.Generic;

using System.Linq;

namespace ContosoUniversity.Pages.Instructors

{

    public class InstructorCoursesPageModel : PageModel

    {

        public ListAssignedCourseData AssignedCourseDataList;

        public void PopulateAssignedCourseData(SchoolContext context, 

                                               Instructor instructor)

        {

            var allCourses = context.Courses;

            var instructorCourses = new HashSetint(

                instructor.CourseAssignments.Select(c = c.CourseID));

            AssignedCourseDataList = new ListAssignedCourseData();

            foreach (var course in allCourses)

            {

                AssignedCourseDataList.Add(new AssignedCourseData

                {

                    CourseID = course.CourseID,

                    Title = course.Title,

                    Assigned = instructorCourses.Contains(course.CourseID)

                });

            }

        }

        public void UpdateInstructorCourses(SchoolContext context, 

            string[] selectedCourses, Instructor instructorToUpdate)

        {

            if (selectedCourses == null)

            {

                instructorToUpdate.CourseAssignments = new ListCourseAssignment();

                return;

            }

            var selectedCoursesHS = new HashSetstring(selectedCourses);

            var instructorCourses = new HashSetint

                (instructorToUpdate.CourseAssignments.Select(c = c.Course.CourseID));

            foreach (var course in context.Courses)

            {

                if (selectedCoursesHS.Contains(course.CourseID.ToString()))

                {

                    if (!instructorCourses.Contains(course.CourseID))

                    {

                        instructorToUpdate.CourseAssignments.Add(

                            new CourseAssignment

                            {

                                InstructorID = instructorToUpdate.ID,

                                CourseID = course.CourseID

                            });

                    }

                }

                else

                {

                    if (instructorCourses.Contains(course.CourseID))

                    {

                        CourseAssignment courseToRemove

                            = instructorToUpdate

                                .CourseAssignments

                                .SingleOrDefault(i = i.CourseID == course.CourseID);

                        context.Remove(courseToRemove);

                    }

                }

            }

        }

    }

}

The InstructorCoursesPageModel is the base class you will use for the Edit and Create page models. PopulateAssignedCourseData reads all Course entities to populate AssignedCourseDataList. For each course, the code sets the CourseID, title, and whether or not the instructor is assigned to the course. A [HashSet](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1) is used to create efficient lookups.

### Instructors Edit page model

Update the instructor Edit page model with the following code:

C#Copy

public class EditModel : InstructorCoursesPageModel

{

    private readonly ContosoUniversity.Data.SchoolContext _context;

    public EditModel(ContosoUniversity.Data.SchoolContext context)

    {

        _context = context;

    }

    [BindProperty]

    public Instructor Instructor { get; set; }

    public async TaskIActionResult OnGetAsync(int? id)

    {

        if (id == null)

        {

            return NotFound();

        }

        Instructor = await _context.Instructors

            .Include(i = i.OfficeAssignment)

            .Include(i = i.CourseAssignments).ThenInclude(i = i.Course)

            .AsNoTracking()

            .FirstOrDefaultAsync(m = m.ID == id);

        if (Instructor == null)

        {

            return NotFound();

        }

        PopulateAssignedCourseData(_context, Instructor);

        return Page();

    }

    public async TaskIActionResult OnPostAsync(int? id, string[] selectedCourses)

    {

        if (!ModelState.IsValid)

        {

            return Page();

        }

        var instructorToUpdate = await _context.Instructors

            .Include(i = i.OfficeAssignment)

            .Include(i = i.CourseAssignments)

                .ThenInclude(i = i.Course)

            .FirstOrDefaultAsync(s = s.ID == id);

        if (await TryUpdateModelAsyncInstructor(

            instructorToUpdate,

            "Instructor",

            i = i.FirstMidName, i = i.LastName,

            i = i.HireDate, i = i.OfficeAssignment))

        {

            if (String.IsNullOrWhiteSpace(

                instructorToUpdate.OfficeAssignment?.Location))

            {

                instructorToUpdate.OfficeAssignment = null;

            }

            UpdateInstructorCourses(_context, selectedCourses, instructorToUpdate);

            await _context.SaveChangesAsync();

            return RedirectToPage("./Index");

        }

        UpdateInstructorCourses(_context, selectedCourses, instructorToUpdate);

        PopulateAssignedCourseData(_context, instructorToUpdate);

        return Page();

    }

}

The preceding code handles office assignment changes.

Update the instructor Razor View:

CSHTMLCopy

@page

@model ContosoUniversity.Pages.Instructors.EditModel

@{

    ViewData["Title"] = "Edit";

}

h2Edit/h2

h4Instructor/h4

hr /

div class="row"

    div class="col-md-4"

        form method="post"

            div asp-validation-summary="ModelOnly" class="text-danger"/div

            input type="hidden" asp-for="Instructor.ID" /

            div class="form-group"

                label asp-for="Instructor.LastName" class="control-label"/label

                input asp-for="Instructor.LastName" class="form-control" /

                span asp-validation-for="Instructor.LastName" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Instructor.FirstMidName" class="control-label"/label

                input asp-for="Instructor.FirstMidName" class="form-control" /

                span asp-validation-for="Instructor.FirstMidName" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Instructor.HireDate" class="control-label"/label

                input asp-for="Instructor.HireDate" class="form-control" /

                span asp-validation-for="Instructor.HireDate" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Instructor.OfficeAssignment.Location" class="control-label"/label

                input asp-for="Instructor.OfficeAssignment.Location" class="form-control" /

                span asp-validation-for="Instructor.OfficeAssignment.Location" class="text-danger" /

            /div

            div class="form-group"

                div class="col-md-offset-2 col-md-10"

                    table

                        tr

                            @{

                                int cnt = 0;

                                foreach (var course in Model.AssignedCourseDataList)

                                {

                                    if (cnt++ % 3 == 0)

                                    {

                                        @:/trtr

                                    }

                                    @:td

                                        input type="checkbox"

                                               name="selectedCourses"

                                               value="@course.CourseID"

                                               @(Html.Raw(course.Assigned ? "checked=\"checked\"" : "")) /

                                               @course.CourseID @:  @course.Title

                                    @:/td

                                }

                                @:/tr

                            }

                    /table

                /div

            /div

            div class="form-group"

                input type="submit" value="Save" class="btn btn-default" /

            /div

        /form

    /div

/div

div

    a asp-page="./Index"Back to List/a

/div

@section Scripts {

    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

}

** Note**

When you paste the code in Visual Studio, line breaks are changed in a way that breaks the code. Press Ctrl+Z one time to undo the automatic formatting. Ctrl+Z fixes the line breaks so that they look like what you see here. The indentation doesn't have to be perfect, but the @/trtr, @:td, @:/td, and @:/tr lines must each be on a single line as shown. With the block of new code selected, press Tab three times to line up the new code with the existing code. Vote on or review the status of this bug [**with this link**](https://developercommunity.visualstudio.com/content/problem/147795/razor-editor-malforms-pasted-markup-and-creates-in.html).

The preceding code creates an HTML table that has three columns. Each column has a check box and a caption containing the course number and title. The check boxes all have the same name ("selectedCourses"). Using the same name informs the model binder to treat them as a group. The value attribute of each check box is set to CourseID. When the page is posted, the model binder passes an array that consists of the CourseID values for only the check boxes that are selected.

When the check boxes are initially rendered, courses assigned to the instructor have checked attributes.

Run the app and test the updated instructors Edit page. Change some course assignments. The changes are reflected on the Index page.

Note: The approach taken here to edit instructor course data works well when there's a limited number of courses. For collections that are much larger, a different UI and a different updating method would be more useable and efficient.

### Update the instructors Create page

Update the instructor Create page model with the following code:

C#Copy

using ContosoUniversity.Models;

using Microsoft.AspNetCore.Mvc;

using System.Collections.Generic;

using System.Threading.Tasks;

namespace ContosoUniversity.Pages.Instructors

{

    public class CreateModel : InstructorCoursesPageModel

    {

        private readonly ContosoUniversity.Data.SchoolContext _context;

        public CreateModel(ContosoUniversity.Data.SchoolContext context)

        {

            _context = context;

        }

        public IActionResult OnGet()

        {

            var instructor = new Instructor();

            instructor.CourseAssignments = new ListCourseAssignment();

            // Provides an empty collection for the foreach loop

            // foreach (var course in Model.AssignedCourseDataList)

            // in the Create Razor page.

            PopulateAssignedCourseData(_context, instructor);

            return Page();

        }

        [BindProperty]

        public Instructor Instructor { get; set; }

        public async TaskIActionResult OnPostAsync(string[] selectedCourses)

        {

            if (!ModelState.IsValid)

            {

                return Page();

            }

            var newInstructor = new Instructor();

            if (selectedCourses != null)

            {

                newInstructor.CourseAssignments = new ListCourseAssignment();

                foreach (var course in selectedCourses)

                {

                    var courseToAdd = new CourseAssignment

                    {

                        CourseID = int.Parse(course)

                    };

                    newInstructor.CourseAssignments.Add(courseToAdd);

                }

            }

            if (await TryUpdateModelAsyncInstructor(

                newInstructor,

                "Instructor",

                i = i.FirstMidName, i = i.LastName,

                i = i.HireDate, i = i.OfficeAssignment))

            {

                _context.Instructors.Add(newInstructor);                

                await _context.SaveChangesAsync();

                return RedirectToPage("./Index");

            }

            PopulateAssignedCourseData(_context, newInstructor);

            return Page();

        }

    }

}

The preceding code is similar to the Pages/Instructors/Edit.cshtml.cs code.

Update the instructor Create Razor page with the following markup:

CSHTMLCopy

@page

@model ContosoUniversity.Pages.Instructors.CreateModel

@{

    ViewData["Title"] = "Create";

}

h2Create/h2

h4Instructor/h4

hr /

div class="row"

    div class="col-md-4"

        form method="post"

            div asp-validation-summary="ModelOnly" class="text-danger"/div

            div class="form-group"

                label asp-for="Instructor.LastName" class="control-label"/label

                input asp-for="Instructor.LastName" class="form-control" /

                span asp-validation-for="Instructor.LastName" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Instructor.FirstMidName" class="control-label"/label

                input asp-for="Instructor.FirstMidName" class="form-control" /

                span asp-validation-for="Instructor.FirstMidName" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Instructor.HireDate" class="control-label"/label

                input asp-for="Instructor.HireDate" class="form-control" /

                span asp-validation-for="Instructor.HireDate" class="text-danger"/span

            /div

            

            div class="form-group"

                label asp-for="Instructor.OfficeAssignment.Location" class="control-label"/label

                input asp-for="Instructor.OfficeAssignment.Location" class="form-control" /

                span asp-validation-for="Instructor.OfficeAssignment.Location" class="text-danger" /

            /div

            div class="form-group"

                div class="col-md-offset-2 col-md-10"

                    table

                        tr

                            @{

                                int cnt = 0;

                                foreach (var course in Model.AssignedCourseDataList)

                                {

                                    if (cnt++ % 3 == 0)

                                    {

                                        @:/trtr

                                    }

                                    @:td

                                        input type="checkbox"

                                               name="selectedCourses"

                                               value="@course.CourseID"

                                               @(Html.Raw(course.Assigned ? "checked=\"checked\"" : "")) /

                                               @course.CourseID @:  @course.Title

                                    @:/td

                                }

                                @:/tr

                            }

                    /table

                /div

            /div

            div class="form-group"

                input type="submit" value="Create" class="btn btn-default" /

            /div

        /form

    /div

/div

div

    a asp-page="Index"Back to List/a

/div

@section Scripts {

    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

}

Test the instructor Create page.

## Update the Delete page

Update the Delete page model with the following code:

C#Copy

using ContosoUniversity.Models;

using Microsoft.AspNetCore.Mvc;

using Microsoft.AspNetCore.Mvc.RazorPages;

using Microsoft.EntityFrameworkCore;

using System.Linq;

using System.Threading.Tasks;

namespace ContosoUniversity.Pages.Instructors

{

    public class DeleteModel : PageModel

    {

        private readonly ContosoUniversity.Data.SchoolContext _context;

        public DeleteModel(ContosoUniversity.Data.SchoolContext context)

        {

            _context = context;

        }

        [BindProperty]

        public Instructor Instructor { get; set; }

        public async TaskIActionResult OnGetAsync(int? id)

        {

            if (id == null)

            {

                return NotFound();

            }

            Instructor = await _context.Instructors.SingleAsync(m = m.ID == id);

            if (Instructor == null)

            {

                return NotFound();

            }

            return Page();

        }

        public async TaskIActionResult OnPostAsync(int id)

        {

            Instructor instructor = await _context.Instructors

                .Include(i = i.CourseAssignments)

                .SingleAsync(i = i.ID == id);

            var departments = await _context.Departments

                .Where(d = d.InstructorID == id)

                .ToListAsync();

            departments.ForEach(d = d.InstructorID = null);

            _context.Instructors.Remove(instructor);

            await _context.SaveChangesAsync();

            return RedirectToPage("./Index");

        }

    }

}

The preceding code makes the following changes:

- Uses eager loading for the CourseAssignments navigation property. CourseAssignments must be included or they aren't deleted when the instructor is deleted. To avoid needing to read them, configure cascade delete in the database.
- If the instructor to be deleted is assigned as administrator of any departments, removes the instructor assignment from those departments.

# Part 8 of 8

The Contoso University web app demonstrates how to create Razor Pages web apps using EF Core and Visual Studio. For information about the tutorial series, see [the first tutorial](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2).

This tutorial shows how to handle conflicts when multiple users update an entity concurrently (at the same time). If you run into problems you can't solve, [download or view the completed app.](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-rp/intro/samples) [Download instructions](https://docs.microsoft.com/en-us/aspnet/core/index?view=aspnetcore-2.2).

## Concurrency conflicts

A concurrency conflict occurs when:

- A user navigates to the edit page for an entity.
- Another user updates the same entity before the first user's change is written to the DB.

If concurrency detection isn't enabled, when concurrent updates occur:

- The last update wins. That is, the last update values are saved to the DB.
- The first of the current updates are lost.

### Optimistic concurrency

Optimistic concurrency allows concurrency conflicts to happen, and then reacts appropriately when they do. For example, Jane visits the Department edit page and changes the budget for the English department from $350,000.00 to $0.00.

![Changing budget to 0](image_45)

Before Jane clicks Save, John visits the same page and changes the Start Date field from 9/1/2007 to 9/1/2013.

![Changing start date to 2013](image_46)

Jane clicks Save first and sees her change when the browser displays the Index page.

![Budget changed to zero](image_47)

John clicks Save on an Edit page that still shows a budget of $350,000.00. What happens next is determined by how you handle concurrency conflicts.

Optimistic concurrency includes the following options:

- You can keep track of which property a user has modified and update only the corresponding columns in the DB.

In the scenario, no data would be lost. Different properties were updated by the two users. The next time someone browses the English department, they will see both Jane's and John's changes. This method of updating can reduce the number of conflicts that could result in data loss. This approach:

  - Can't avoid data loss if competing changes are made to the same property.
  - Is generally not practical in a web app. It requires maintaining significant state in order to keep track of all fetched values and new values. Maintaining large amounts of state can affect app performance.
  - Can increase app complexity compared to concurrency detection on an entity.
- You can let John's change overwrite Jane's change.

The next time someone browses the English department, they will see 9/1/2013 and the fetched $350,000.00 value. This approach is called a Client Wins or Last in Wins scenario. (All values from the client take precedence over what's in the data store.) If you don't do any coding for concurrency handling, Client Wins happens automatically.

- You can prevent John's change from being updated in the DB. Typically, the app would:
  - Display an error message.
  - Show the current state of the data.
  - Allow the user to reapply the changes.

This is called a Store Wins scenario. (The data-store values take precedence over the values submitted by the client.) You implement the Store Wins scenario in this tutorial. This method ensures that no changes are overwritten without a user being alerted.

## Handling concurrency

When a property is configured as a [concurrency token](https://docs.microsoft.com/ef/core/modeling/concurrency):

- EF Core verifies that property has not been modified after it was fetched. The check occurs when [SaveChanges](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.savechanges?view=efcore-2.0) or [SaveChangesAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.savechangesasync?view=efcore-2.0) is called.
- If the property has been changed after it was fetched, a [DbUpdateConcurrencyException](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbupdateconcurrencyexception?view=efcore-2.0) is thrown.

The DB and data model must be configured to support throwing DbUpdateConcurrencyException.

### Detecting concurrency conflicts on a property

Concurrency conflicts can be detected at the property level with the [ConcurrencyCheck](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.concurrencycheckattribute?view=netcore-2.0) attribute. The attribute can be applied to multiple properties on the model. For more information, see [Data Annotations-ConcurrencyCheck](https://docs.microsoft.com/ef/core/modeling/concurrency).

The [ConcurrencyCheck] attribute isn't used in this tutorial.

### Detecting concurrency conflicts on a row

To detect concurrency conflicts, a [rowversion](https://docs.microsoft.com/sql/t-sql/data-types/rowversion-transact-sql) tracking column is added to the model. rowversion :

- Is SQL Server specific. Other databases may not provide a similar feature.
- Is used to determine that an entity has not been changed since it was fetched from the DB.

The DB generates a sequential rowversion number that's incremented each time the row is updated. In an Update or Delete command, the Where clause includes the fetched value of rowversion. If the row being updated has changed:

- rowversion doesn't match the fetched value.
- The Update or Delete commands don't find a row because the Where clause includes the fetched rowversion.
- A DbUpdateConcurrencyException is thrown.

In EF Core, when no rows have been updated by an Update or Delete command, a concurrency exception is thrown.

### Add a tracking property to the Department entity

In Models/Department.cs, add a tracking property named RowVersion:

C#Copy

using System;

using System.Collections.Generic;

using System.ComponentModel.DataAnnotations;

using System.ComponentModel.DataAnnotations.Schema;

namespace ContosoUniversity.Models

{

    public class Department

    {

        public int DepartmentID { get; set; }

        [StringLength(50, MinimumLength = 3)]

        public string Name { get; set; }

        [DataType(DataType.Currency)]

        [Column(TypeName = "money")]

        public decimal Budget { get; set; }

        [DataType(DataType.Date)]

        [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]

        [Display(Name = "Start Date")]

        public DateTime StartDate { get; set; }

        public int? InstructorID { get; set; }

        [Timestamp]

        public byte[] RowVersion { get; set; }

        public Instructor Administrator { get; set; }

        public ICollectionCourse Courses { get; set; }

    }

}

The [Timestamp](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.timestampattribute) attribute specifies that this column is included in the Where clause of Update and Deletecommands. The attribute is called Timestamp because previous versions of SQL Server used a SQL timestampdata type before the SQL rowversion type replaced it.

The fluent API can also specify the tracking property:

C#Copy

modelBuilder.EntityDepartment()

  .Propertybyte[]("RowVersion")

  .IsRowVersion();

The following code shows a portion of the T-SQL generated by EF Core when the Department name is updated:

SQLCopy

SET NOCOUNT ON;

UPDATE [Department] SET [Name] = @p0

WHERE [DepartmentID] = @p1 AND [RowVersion] = @p2;

SELECT [RowVersion]

FROM [Department]

WHERE @@ROWCOUNT = 1 AND [DepartmentID] = @p1;

The preceding highlighted code shows the WHERE clause containing RowVersion. If the DB RowVersiondoesn't equal the RowVersion parameter (@p2), no rows are updated.

The following highlighted code shows the T-SQL that verifies exactly one row was updated:

SQLCopy

SET NOCOUNT ON;

UPDATE [Department] SET [Name] = @p0

WHERE [DepartmentID] = @p1 AND [RowVersion] = @p2;

SELECT [RowVersion]

FROM [Department]

WHERE @@ROWCOUNT = 1 AND [DepartmentID] = @p1;

[@@ROWCOUNT](https://docs.microsoft.com/sql/t-sql/functions/rowcount-transact-sql) returns the number of rows affected by the last statement. In no rows are updated, EF Core throws a DbUpdateConcurrencyException.

You can see the T-SQL EF Core generates in the output window of Visual Studio.

### Update the DB

Adding the RowVersion property changes the DB model, which requires a migration.

Build the project. Enter the following in a command window:

consoleCopy

dotnet ef migrations add RowVersion

dotnet ef database update

The preceding commands:

- Adds the Migrations/{time stamp}_RowVersion.cs migration file.
- Updates the Migrations/SchoolContextModelSnapshot.cs file. The update adds the following highlighted code to the BuildModel method:

C#Copy

modelBuilder.Entity("ContosoUniversity.Models.Department", b =

    {

        b.Propertyint("DepartmentID")

            .ValueGeneratedOnAdd();

        b.Propertydecimal("Budget")

            .HasColumnType("money");

        b.Propertyint?("InstructorID");

        b.Propertystring("Name")

            .HasMaxLength(50);

        b.Propertybyte[]("RowVersion")

            .IsConcurrencyToken()

            .ValueGeneratedOnAddOrUpdate();

        b.PropertyDateTime("StartDate");

        b.HasKey("DepartmentID");

        b.HasIndex("InstructorID");

        b.ToTable("Department");

    });

- Runs migrations to update the DB.

## Scaffold the Departments model

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/concurrency?view=aspnetcore-2.2&amp;tabs=visual-studio)

Follow the instructions in [Scaffold the student model](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-2.2) and use Department for the model class.

- [.NET Core CLI](https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/concurrency?view=aspnetcore-2.2&amp;tabs=visual-studio)

Run the following command:

consoleCopy

dotnet aspnet-codegenerator razorpage -m Department -dc SchoolContext -udl -outDir Pages\Departments --referenceScriptLibraries

CONTINUE… 

The preceding command scaffolds the Department model. Open the project in Visual Studio.

Build the project.

### Update the Departments Index page

The scaffolding engine created a RowVersion column for the Index page, but that field shouldn't be displayed. In this tutorial, the last byte of the RowVersion is displayed to help understand concurrency. The last byte isn't guaranteed to be unique. A real app wouldn't display RowVersion or the last byte of RowVersion.

Update the Index page:

- Replace Index with Departments.
- Replace the markup containing RowVersion with the last byte of RowVersion.
- Replace FirstMidName with FullName.

The following markup shows the updated page:

HTMLCopy

@page

@model ContosoUniversity.Pages.Departments.IndexModel

@{

    ViewData["Title"] = "Departments";

}

h2Departments/h2

p

    a asp-page="Create"Create New/a

/p

table class="table"

    thead

        tr

                th

                    @Html.DisplayNameFor(model = model.Department[0].Name)

                /th

                th

                    @Html.DisplayNameFor(model = model.Department[0].Budget)

                /th

                th

                    @Html.DisplayNameFor(model = model.Department[0].StartDate)

                /th

            th

                @Html.DisplayNameFor(model = model.Department[0].Administrator)

            /th

            th

                RowVersion

            /th

            th/th

        /tr

    /thead

    tbody

@foreach (var item in Model.Department) {

        tr

            td

                @Html.DisplayFor(modelItem = item.Name)

            /td

            td

                @Html.DisplayFor(modelItem = item.Budget)

            /td

            td

                @Html.DisplayFor(modelItem = item.StartDate)

            /td

            td

                @Html.DisplayFor(modelItem = item.Administrator.FullName)

            /td

            td

                @item.RowVersion[7]

            /td

            td

                a asp-page="./Edit" asp-route-id="@item.DepartmentID"Edit/a |

                a asp-page="./Details" asp-route-id="@item.DepartmentID"Details/a |

                a asp-page="./Delete" asp-route-id="@item.DepartmentID"Delete/a

            /td

        /tr

}

    /tbody

/table

### Update the Edit page model

Update pages\departments\edit.cshtml.cs with the following code:

C#Copy

using ContosoUniversity.Data;

using ContosoUniversity.Models;

using Microsoft.AspNetCore.Mvc;

using Microsoft.AspNetCore.Mvc.RazorPages;

using Microsoft.AspNetCore.Mvc.Rendering;

using Microsoft.EntityFrameworkCore;

using System.Linq;

using System.Threading.Tasks;

namespace ContosoUniversity.Pages.Departments

{

    public class EditModel : PageModel

    {

        private readonly ContosoUniversity.Data.SchoolContext _context;

        public EditModel(ContosoUniversity.Data.SchoolContext context)

        {

            _context = context;

        }

        [BindProperty]

        public Department Department { get; set; }

        // Replace ViewData["InstructorID"] 

        public SelectList InstructorNameSL { get; set; }

        public async TaskIActionResult OnGetAsync(int id)

        {

            Department = await _context.Departments

                .Include(d = d.Administrator)  // eager loading

                .AsNoTracking()                 // tracking not required

                .FirstOrDefaultAsync(m = m.DepartmentID == id);

            if (Department == null)

            {

                return NotFound();

            }

            // Use strongly typed data rather than ViewData.

            InstructorNameSL = new SelectList(_context.Instructors,

                "ID", "FirstMidName");

            return Page();

        }

        public async TaskIActionResult OnPostAsync(int id)

        {

            if (!ModelState.IsValid)

            {

                return Page();

            }

            var departmentToUpdate = await _context.Departments

                .Include(i = i.Administrator)

                .FirstOrDefaultAsync(m = m.DepartmentID == id);

            // null means Department was deleted by another user.

            if (departmentToUpdate == null)

            {

                return await HandleDeletedDepartment();

            }

            // Update the RowVersion to the value when this entity was

            // fetched. If the entity has been updated after it was

            // fetched, RowVersion won't match the DB RowVersion and

            // a DbUpdateConcurrencyException is thrown.

            // A second postback will make them match, unless a new 

            // concurrency issue happens.

            _context.Entry(departmentToUpdate)

                .Property("RowVersion").OriginalValue = Department.RowVersion;

            if (await TryUpdateModelAsyncDepartment(

                departmentToUpdate,

                "Department",

                s = s.Name, s = s.StartDate, s = s.Budget, s = s.InstructorID))

            {

                try

                {

                    await _context.SaveChangesAsync();

                    return RedirectToPage("./Index");

                }

                catch (DbUpdateConcurrencyException ex)

                {

                    var exceptionEntry = ex.Entries.Single();

                    var clientValues = (Department)exceptionEntry.Entity;

                    var databaseEntry = exceptionEntry.GetDatabaseValues();

                    if (databaseEntry == null)

                    {

                        ModelState.AddModelError(string.Empty, "Unable to save. " +

                            "The department was deleted by another user.");

                        return Page();

                    }

                    var dbValues = (Department)databaseEntry.ToObject();

                    await setDbErrorMessage(dbValues, clientValues, _context);

                    // Save the current RowVersion so next postback

                    // matches unless an new concurrency issue happens.

                    Department.RowVersion = (byte[])dbValues.RowVersion;

                    // Must clear the model error for the next postback.

                    ModelState.Remove("Department.RowVersion");

                }

            }

            InstructorNameSL = new SelectList(_context.Instructors,

                "ID", "FullName", departmentToUpdate.InstructorID);

            return Page();

        }

       private async TaskIActionResult HandleDeletedDepartment()

        {

            Department deletedDepartment = new Department();

            // ModelState contains the posted data because of the deletion error and will overide the Department instance values when displaying Page().

            ModelState.AddModelError(string.Empty,

                "Unable to save. The department was deleted by another user.");

            InstructorNameSL = new SelectList(_context.Instructors, "ID", "FullName", Department.InstructorID); 

            return Page();

        }

        private async Task setDbErrorMessage(Department dbValues,

                Department clientValues, SchoolContext context)

        {

            if (dbValues.Name != clientValues.Name)

            {

                ModelState.AddModelError("Department.Name",

                    $"Current value: {dbValues.Name}");

            }

            if (dbValues.Budget != clientValues.Budget)

            {

                ModelState.AddModelError("Department.Budget",

                    $"Current value: {dbValues.Budget:c}");

            }

            if (dbValues.StartDate != clientValues.StartDate)

            {

                ModelState.AddModelError("Department.StartDate",

                    $"Current value: {dbValues.StartDate:d}");

            }

            if (dbValues.InstructorID != clientValues.InstructorID)

            {

                Instructor dbInstructor = await _context.Instructors

                   .FindAsync(dbValues.InstructorID);

                ModelState.AddModelError("Department.InstructorID",

                    $"Current value: {dbInstructor?.FullName}");

            }

            ModelState.AddModelError(string.Empty,

                "The record you attempted to edit "

              + "was modified by another user after you. The "

              + "edit operation was canceled and the current values in the database "

              + "have been displayed. If you still want to edit this record, click "

              + "the Save button again.");

        }

    }

}

To detect a concurrency issue, the [OriginalValue](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.changetracking.propertyentry.originalvalue?view=efcore-2.0) is updated with the rowVersion value from the entity it was fetched. EF Core generates a SQL UPDATE command with a WHERE clause containing the original RowVersionvalue. If no rows are affected by the UPDATE command (no rows have the original RowVersion value), a DbUpdateConcurrencyException exception is thrown.

C#Copy

public async TaskIActionResult OnPostAsync(int id)

{

    if (!ModelState.IsValid)

    {

        return Page();

    }

    var departmentToUpdate = await _context.Departments

        .Include(i = i.Administrator)

        .FirstOrDefaultAsync(m = m.DepartmentID == id);

    // null means Department was deleted by another user.

    if (departmentToUpdate == null)

    {

        return await HandleDeletedDepartment();

    }

    // Update the RowVersion to the value when this entity was

    // fetched. If the entity has been updated after it was

    // fetched, RowVersion won't match the DB RowVersion and

    // a DbUpdateConcurrencyException is thrown.

    // A second postback will make them match, unless a new 

    // concurrency issue happens.

    _context.Entry(departmentToUpdate)

        .Property("RowVersion").OriginalValue = Department.RowVersion;

In the preceding code, Department.RowVersion is the value when the entity was fetched. OriginalValue is the value in the DB when FirstOrDefaultAsync was called in this method.

The following code gets the client values (the values posted to this method) and the DB values:

C#Copy

try

{

    await _context.SaveChangesAsync();

    return RedirectToPage("./Index");

}

catch (DbUpdateConcurrencyException ex)

{

    var exceptionEntry = ex.Entries.Single();

    var clientValues = (Department)exceptionEntry.Entity;

    var databaseEntry = exceptionEntry.GetDatabaseValues();

    if (databaseEntry == null)

    {

        ModelState.AddModelError(string.Empty, "Unable to save. " +

            "The department was deleted by another user.");

        return Page();

    }

    var dbValues = (Department)databaseEntry.ToObject();

    await setDbErrorMessage(dbValues, clientValues, _context);

    // Save the current RowVersion so next postback

    // matches unless an new concurrency issue happens.

    Department.RowVersion = (byte[])dbValues.RowVersion;

    // Must clear the model error for the next postback.

    ModelState.Remove("Department.RowVersion");

}

The following code adds a custom error message for each column that has DB values different from what was posted to OnPostAsync:

C#Copy

private async Task setDbErrorMessage(Department dbValues,

        Department clientValues, SchoolContext context)

{

    if (dbValues.Name != clientValues.Name)

    {

        ModelState.AddModelError("Department.Name",

            $"Current value: {dbValues.Name}");

    }

    if (dbValues.Budget != clientValues.Budget)

    {

        ModelState.AddModelError("Department.Budget",

            $"Current value: {dbValues.Budget:c}");

    }

    if (dbValues.StartDate != clientValues.StartDate)

    {

        ModelState.AddModelError("Department.StartDate",

            $"Current value: {dbValues.StartDate:d}");

    }

    if (dbValues.InstructorID != clientValues.InstructorID)

    {

        Instructor dbInstructor = await _context.Instructors

           .FindAsync(dbValues.InstructorID);

        ModelState.AddModelError("Department.InstructorID",

            $"Current value: {dbInstructor?.FullName}");

    }

    ModelState.AddModelError(string.Empty,

        "The record you attempted to edit "

      + "was modified by another user after you. The "

      + "edit operation was canceled and the current values in the database "

      + "have been displayed. If you still want to edit this record, click "

      + "the Save button again.");

}

The following highlighted code sets the RowVersion value to the new value retrieved from the DB. The next time the user clicks Save, only concurrency errors that happen since the last display of the Edit page will be caught.

C#Copy

try

{

    await _context.SaveChangesAsync();

    return RedirectToPage("./Index");

}

catch (DbUpdateConcurrencyException ex)

{

    var exceptionEntry = ex.Entries.Single();

    var clientValues = (Department)exceptionEntry.Entity;

    var databaseEntry = exceptionEntry.GetDatabaseValues();

    if (databaseEntry == null)

    {

        ModelState.AddModelError(string.Empty, "Unable to save. " +

            "The department was deleted by another user.");

        return Page();

    }

    var dbValues = (Department)databaseEntry.ToObject();

    await setDbErrorMessage(dbValues, clientValues, _context);

    // Save the current RowVersion so next postback

    // matches unless an new concurrency issue happens.

    Department.RowVersion = (byte[])dbValues.RowVersion;

    // Must clear the model error for the next postback.

    ModelState.Remove("Department.RowVersion");

}

The ModelState.Remove statement is required because ModelState has the old RowVersion value. In the Razor Page, the ModelState value for a field takes precedence over the model property values when both are present.

## Update the Edit page

Update Pages/Departments/Edit.cshtml with the following markup:

HTMLCopy

@page "{id:int}"

@model ContosoUniversity.Pages.Departments.EditModel

@{

    ViewData["Title"] = "Edit";

}

h2Edit/h2

h4Department/h4

hr /

div class="row"

    div class="col-md-4"

        form method="post"

            div asp-validation-summary="ModelOnly" class="text-danger"/div

            input type="hidden" asp-for="Department.DepartmentID" /

            input type="hidden" asp-for="Department.RowVersion" /

            div class="form-group"

                labelRowVersion/label

                @Model.Department.RowVersion[7]

            /div

            div class="form-group"

                label asp-for="Department.Name" class="control-label"/label

                input asp-for="Department.Name" class="form-control" /

                span asp-validation-for="Department.Name" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Department.Budget" class="control-label"/label

                input asp-for="Department.Budget" class="form-control" /

                span asp-validation-for="Department.Budget" class="text-danger"/span

            /div

            div class="form-group"

                label asp-for="Department.StartDate" class="control-label"/label

                input asp-for="Department.StartDate" class="form-control" /

                span asp-validation-for="Department.StartDate" class="text-danger"

                /span

            /div

            div class="form-group"

                label class="control-label"Instructor/label

                select asp-for="Department.InstructorID" class="form-control"

                        asp-items="@Model.InstructorNameSL"/select

                span asp-validation-for="Department.InstructorID" class="text-danger"

                /span

            /div

            div class="form-group"

                input type="submit" value="Save" class="btn btn-default" /

            /div

        /form

    /div

/div

div

    a asp-page="./Index"Back to List/a

/div

@section Scripts {

    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

}

The preceding markup:

- Updates the page directive from @page to @page "{id:int}".
- Adds a hidden row version. RowVersion must be added so post back binds the value.
- Displays the last byte of RowVersion for debugging purposes.
- Replaces ViewData with the strongly-typed InstructorNameSL.

## Test concurrency conflicts with the Edit page

Open two browsers instances of Edit on the English department:

- Run the app and select Departments.
- Right-click the Edit hyperlink for the English department and select Open in new tab.
- In the first tab, click the Edit hyperlink for the English department.

The two browser tabs display the same information.

Change the name in the first browser tab and click Save.

![Department Edit page 1 after change](image_48)

The browser shows the Index page with the changed value and updated rowVersion indicator. Note the updated rowVersion indicator, it's displayed on the second postback in the other tab.

Change a different field in the second browser tab.

![Department Edit page 2 after change](image_49)

Click Save. You see error messages for all fields that don't match the DB values:

![Department Edit page error message](image_50)

This browser window didn't intend to change the Name field. Copy and paste the current value (Languages) into the Name field. Tab out. Client-side validation removes the error message.

![Department Edit page error message](image_51)

Click Save again. The value you entered in the second browser tab is saved. You see the saved values in the Index page.

## Update the Delete page

Update the Delete page model with the following code:

C#Copy

using ContosoUniversity.Models;

using Microsoft.AspNetCore.Mvc;

using Microsoft.AspNetCore.Mvc.RazorPages;

using Microsoft.EntityFrameworkCore;

using System.Threading.Tasks;

namespace ContosoUniversity.Pages.Departments

{

    public class DeleteModel : PageModel

    {

        private readonly ContosoUniversity.Data.SchoolContext _context;

        public DeleteModel(ContosoUniversity.Data.SchoolContext context)

        {

            _context = context;

        }

        [BindProperty]

        public Department Department { get; set; }

        public string ConcurrencyErrorMessage { get; set; }

        public async TaskIActionResult OnGetAsync(int id, bool? concurrencyError)

        {

            Department = await _context.Departments

                .Include(d = d.Administrator)

                .AsNoTracking()

                .FirstOrDefaultAsync(m = m.DepartmentID == id);

            if (Department == null)

            {

                 return NotFound();

            }

            if (concurrencyError.GetValueOrDefault())

            {

                ConcurrencyErrorMessage = "The record you attempted to delete "

                  + "was modified by another user after you selected delete. "

                  + "The delete operation was canceled and the current values in the "

                  + "database have been displayed. If you still want to delete this "

                  + "record, click the Delete button again.";

            }

            return Page();

        }

        public async TaskIActionResult OnPostAsync(int id)

        {

            try

            {

                if (await _context.Departments.AnyAsync(

                    m = m.DepartmentID == id))

                {

                    // Department.rowVersion value is from when the entity

                    // was fetched. If it doesn't match the DB, a

                    // DbUpdateConcurrencyException exception is thrown.

                    _context.Departments.Remove(Department);

                    await _context.SaveChangesAsync();

                }

                return RedirectToPage("./Index");

            }

            catch (DbUpdateConcurrencyException)

            {

                return RedirectToPage("./Delete",

                    new { concurrencyError = true, id = id });

            }

        }

    }

}

The Delete page detects concurrency conflicts when the entity has changed after it was fetched. Department.RowVersion is the row version when the entity was fetched. When EF Core creates the SQL DELETE command, it includes a WHERE clause with RowVersion. If the SQL DELETE command results in zero rows affected:

- The RowVersion in the SQL DELETE command doesn't match RowVersion in the DB.
- A DbUpdateConcurrencyException exception is thrown.
- OnGetAsync is called with the concurrencyError.

### Update the Delete page

Update Pages/Departments/Delete.cshtml with the following code:

HTMLCopy

@page "{id:int}"

@model ContosoUniversity.Pages.Departments.DeleteModel

@{

    ViewData["Title"] = "Delete";

}

h2Delete/h2

p class="text-danger"@Model.ConcurrencyErrorMessage/p

h3Are you sure you want to delete this?/h3

div

    h4Department/h4

    hr /

    dl class="dl-horizontal"

        dt

            @Html.DisplayNameFor(model = model.Department.Name)

        /dt

        dd

            @Html.DisplayFor(model = model.Department.Name)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Department.Budget)

        /dt

        dd

            @Html.DisplayFor(model = model.Department.Budget)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Department.StartDate)

        /dt

        dd

            @Html.DisplayFor(model = model.Department.StartDate)

        /dd

        dt

            @Html.DisplayNameFor(model = model.Department.RowVersion)

        /dt

        dd

            @Html.DisplayFor(model = model.Department.RowVersion[7])

        /dd

        dt

            @Html.DisplayNameFor(model = model.Department.Administrator)

        /dt

        dd

            @Html.DisplayFor(model = model.Department.Administrator.FullName)

        /dd

    /dl

    

    form method="post"

        input type="hidden" asp-for="Department.DepartmentID" /

        input type="hidden" asp-for="Department.RowVersion" /

        div class="form-actions no-color"

            input type="submit" value="Delete" class="btn btn-default" / |

            a asp-page="./Index"Back to List/a

        /div

/form

/div

The preceding markup makes the following changes:

- Updates the page directive from @page to @page "{id:int}".
- Adds an error message.
- Replaces FirstMidName with FullName in the Administrator field.
- Changes RowVersion to display the last byte.
- Adds a hidden row version. RowVersion must be added so post back binds the value.

### Test concurrency conflicts with the Delete page

Create a test department.

Open two browsers instances of Delete on the test department:

- Run the app and select Departments.
- Right-click the Delete hyperlink for the test department and select Open in new tab.
- Click the Edit hyperlink for the test department.

The two browser tabs display the same information.

Change the budget in the first browser tab and click Save.

The browser shows the Index page with the changed value and updated rowVersion indicator. Note the updated rowVersion indicator, it's displayed on the second postback in the other tab.

Delete the test department from the second tab. A concurrency error is display with the current values from the DB. Clicking Delete deletes the entity, unless RowVersion has been updated.department has been deleted.

See [Inheritance](https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/inheritance?view=aspnetcore-2.2) on how to inherit a data model.

### Additional resources

- [Concurrency Tokens in EF Core](https://docs.microsoft.com/ef/core/modeling/concurrency)
- [Handle concurrency in EF Core](https://docs.microsoft.com/ef/core/saving/concurrency)