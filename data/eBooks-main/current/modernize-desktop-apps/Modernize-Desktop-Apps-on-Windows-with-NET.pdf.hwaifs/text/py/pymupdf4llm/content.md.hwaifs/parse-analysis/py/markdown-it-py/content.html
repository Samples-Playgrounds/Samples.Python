<p><strong>EDITION v1.0.3</strong> - Updated to .NET 7</p>
<p><a href="https://aka.ms/desktop-ebook-changelog">Refer to the changelog</a> for the book updates and community contributions.</p>
<p>PUBLISHED BY</p>
<p>Microsoft Developer Division, .NET, and Visual Studio product teams</p>
<p>A division of Microsoft Corporation</p>
<p>One Microsoft Way</p>
<p>Redmond, Washington 98052-6399</p>
<p>Copyright © 2022 by Microsoft Corporation</p>
<p>All rights reserved. No part of the contents of this book may be reproduced or transmitted in any<br />
form or by any means without the written permission of the publisher.</p>
<p>This book is provided “as-is” and expresses the author’s views and opinions. The views, opinions, and<br />
information expressed in this book, including URL and other Internet website references, may change<br />
without notice.</p>
<p>Some examples depicted herein are provided for illustration only and are fictitious. No real association<br />
or connection is intended or should be inferred.</p>
<p><a href="https://www.microsoft.com/">Microsoft and the trademarks listed at https://www.microsoft.com</a> on the “Trademarks” webpage are<br />
trademarks of the Microsoft group of companies.</p>
<p>Mac and macOS are trademarks of Apple Inc.</p>
<p>All other marks and logos are property of their respective owners.</p>
<p>Co-Authors:</p>
<p><strong>Olia Gavrysh</strong>, Program Manager, .NET team, Microsoft</p>
<p><strong>Miguel Angel Castejón Dominguez</strong>, Innovation Architect, Kabel</p>
<p>Participants and reviewers:</p>
<p><strong>Maira Wenzel</strong>, Senior Program Manager, .NET team, Microsoft</p>
<p><strong>Andy De Gorge</strong>, Senior Content Developer, .NET docs team, Microsoft</p>
<p><strong>Miguel Ramos</strong>, Senior Program Manager, Windows Developer Platform team, Microsoft</p>
<p><strong>Adam Braden</strong>, Principal Program Manager, Windows Developer Platform team, Microsoft</p>
<p><strong>Ricardo Minguez Pablos</strong>, Senior Program Manager, Azure IoT team, Microsoft</p>
<p><strong>Nish Anil</strong>, Senior Program Manager, .NET team, Microsoft</p>
<p><strong>Beth Massi</strong>, Senior Product Marketing Manager, Microsoft</p>
<p><strong>Scott Hunter</strong>, Partner Director Program Manager, .NET team, Microsoft</p>
<p><strong>Marta Fuentes Lara</strong>, Kabel</p>
<p><strong>Raúl Fernández de Córdoba</strong>, Kabel</p>
<p><strong>Antonio Manuel Fernández Cantos</strong>, Kabel</p>
<h3>Introduction</h3>
<p>This book is about strategies you can adopt to move your existing desktop applications through the<br />
path of modernization and incorporate the latest runtime, language, and platform features. You’ll<br />
discover that there’s no unique recipe as each application is different, and so are your requirements<br />
and preferences. The good news is that there are common approaches you can apply to add new<br />
features and capabilities to your applications. Some of them won’t even require major modifications<br />
of your code. In this book, we’ll reveal how all those features work behind the scenes and explain the<br />
mechanics of their implementations. Moreover, you’ll find some common scenarios for modernizing<br />
existing desktop applications shown in detail so you can find inspiration for evolving your projects.</p>
<p>Microsoft’s approach to modernizing existing applications is to give you the flexibility to create your<br />
own customized path. All the modernization strategies described in this book are mostly independent.<br />
You can choose ones that are relevant for your application and skip others that aren’t important for<br />
you. In other words, you can mix and match the strategies to best address your application needs.</p>
<h3>Who should use the book</h3>
<p>This book for developers and solution architects who want to modernize existing Windows Forms and<br />
WPF desktop applications to leverage the benefits of .NET and Windows 10.</p>
<p>You might also find this book useful if you’re a technical decision maker, such as an enterprise<br />
architect or a development lead or director who wants an overview of the benefits of updating<br />
existing desktop applications.</p>
<h3>How to use the book</h3>
<p>This book addresses the “why”—why you might want to modernize your existing applications, and the<br />
specific benefits you get from using NET and MSIX to modernize your desktop apps. The content of<br />
the book is designed for architects and technical decision makers who want an overview, but who<br />
don’t need to focus on implementation and technical, step-by-step details.</p>
<p>Along the different chapters, sample implementation code snippets and screenshots are provided,<br />
with chapter 5 devoted to showcase a complete migration process for sample applications.</p>
<h3>What this book doesn’t cover</h3>
<p>This book covers a specific subset of scenarios that are focused on lift-and-shift scenarios, outlining<br />
the way to gain the benefits of modernizing without the effort of rewriting code.</p>
<p>This book isn’t about developing modern applications with .NET from scratch or about getting started<br />
with Windows Forms and WPF. It focuses on how you can update existing desktop applications with<br />
the latest technologies for desktop development.</p>
<h3>Samples used in this book</h3>
<p>To highlight the necessary steps to perform a modernization, we’ll be using a sample application<br />
called eShopModernizing. This application has two flavors, Windows Forms and WPF, and we’ll show a<br />
step-by-step process on how to perform the modernization on both of them to .NET.</p>
<p>Also, on the GitHub repository for this book, you’ll find the results of the process, which you can<br />
consult with if you decide to follow the step-by-step tutorial.</p>
<h2>Contents</h2>
<p><strong>Why modern desktop applications ....................................................................................... 1</strong></p>
<p>Introduction ............................................................................................................................................................................... 1</p>
<p>A story of one company ................................................................................................................................................... 1</p>
<p>Your story ............................................................................................................................................................................... 1</p>
<p>Desktop applications nowadays ........................................................................................................................................ 1</p>
<p>Windows Forms ................................................................................................................................................................... 3</p>
<p>WPF ........................................................................................................................................................................................... 4</p>
<p>UWP .......................................................................................................................................................................................... 4</p>
<p>A tale of two platforms .......................................................................................................................................................... 5</p>
<p>Paths to modernization ......................................................................................................................................................... 8</p>
<p>Modern features .................................................................................................................................................................. 8</p>
<p>Deployment ........................................................................................................................................................................... 8</p>
<p>Installation.............................................................................................................................................................................. 8</p>
<p><strong>What’s new with .NET for Desktop? ...................................................................................... 9</strong></p>
<p>The motivation behind .NET Core ..................................................................................................................................... 9</p>
<p>Introduction to .NET Core ................................................................................................................................................. 11</p>
<p>.NET 5+ is .NET Core vNext ............................................................................................................................................... 11</p>
<p>.NET Framework vs. .NET .................................................................................................................................................... 12</p>
<p>.NET Standard vs. PCL ......................................................................................................................................................... 13</p>
<p>New Desktop features in .NET ......................................................................................................................................... 14</p>
<p>Support for Windows Forms and WPF .................................................................................................................... 14</p>
<p>XAML Islands ...................................................................................................................................................................... 14</p>
<p>Access to all Windows 10 and Windows 11 APIs ................................................................................................ 15</p>
<p>Side-by-side support and self-contained EXEs .................................................................................................... 15</p>
<p>Performance ....................................................................................................................................................................... 15</p>
<p><strong>Migrating Modern Desktop applications ............................................................................ 16</strong></p>
<p>Configuration files ................................................................................................................................................................ 16</p>
<p>Configuration on .NET Framework ............................................................................................................................ 16</p>
<p>i Contents</p>
<p>Configuration on .NET .................................................................................................................................................... 17</p>
<p>Migrating configuration files ....................................................................................................................................... 17</p>
<p>Accessing databases ............................................................................................................................................................ 18</p>
<p>ODBC ..................................................................................................................................................................................... 19</p>
<p>OLE DB .................................................................................................................................................................................. 19</p>
<p>ADO.NET .............................................................................................................................................................................. 19</p>
<p>EF Core vs. EF6 ................................................................................................................................................................... 19</p>
<p>Relational databases ....................................................................................................................................................... 20</p>
<p>Consuming services ............................................................................................................................................................. 20</p>
<p>Consuming a COM Object ................................................................................................................................................ 21</p>
<p>More things to consider ..................................................................................................................................................... 21</p>
<p>AppDomains ...................................................................................................................................................................... 21</p>
<p>Remoting ............................................................................................................................................................................. 21</p>
<p>Code Access Security (CAS) ......................................................................................................................................... 22</p>
<p>Security Transparency .................................................................................................................................................... 22</p>
<p><strong>Windows 10 migration ......................................................................................................... 23</strong></p>
<p>WinRT APIs .............................................................................................................................................................................. 23</p>
<p>Universal Windows Platform (UWP) packages ..................................................................................................... 24</p>
<p>How to add WinRT APIs to your desktop project .................................................................................................... 26</p>
<p>XAML Islands .......................................................................................................................................................................... 34</p>
<p>The road to XAML Islands ............................................................................................................................................. 35</p>
<p>How it works ...................................................................................................................................................................... 35</p>
<p>Do you need XAML Islands .......................................................................................................................................... 38</p>
<p>The road ahead XAML Islands: WinUI 3.0 .............................................................................................................. 38</p>
<p><strong>Example of migrating to the latest .NET............................................................................. 41</strong></p>
<p>Migrating from .NET Core or .NET 5 ............................................................................................................................. 41</p>
<p>Migrating from .NET Framework .................................................................................................................................... 42</p>
<p>Migrating with a tool ...................................................................................................................................................... 42</p>
<p>Migrating by hand ........................................................................................................................................................... 42</p>
<p>Preparation ......................................................................................................................................................................... 43</p>
<p>Fix the code and build .................................................................................................................................................... 45</p>
<p>Run and test ....................................................................................................................................................................... 46</p>
<p>ii Contents</p>
<p>Migrating a Windows Forms application .................................................................................................................... 46</p>
<p>Migrating a WPF application ............................................................................................................................................ 52</p>
<p><strong>Deploying Modern Desktop Applications .......................................................................... 55</strong></p>
<p>The modern application lifecycle .................................................................................................................................... 56</p>
<p>MSIX: The next generation of deployment ................................................................................................................. 58</p>
<p>Benefits of MSIX ............................................................................................................................................................... 59</p>
<p>Tools ...................................................................................................................................................................................... 61</p>
<p>How to create an MSIX package from an existing Win32 desktop application........................................... 62</p>
<p>Auto Updates in MSIX ......................................................................................................................................................... 70</p>
<p>iii Contents</p>
<p><strong>CHAPTER</strong></p>
<h1>1</h1>
<h2>Why modern desktop applications</h2>
<h3>Introduction</h3>
<h4><strong>A story of one company</strong></h4>
<p>Back in the early 2000s, one multinational company started developing a distributed desktop solution<br />
to exchange information between different branches of the company and execute optimized<br />
operations on centralized units. They have chosen a brand-new framework called Windows Forms<br />
(also known as WinForms) for their application development. Over the years, the project evolved into<br />
a mature, well-tested, and time-proven application with hundreds of thousands of lines of code. Time<br />
passed and .NET Framework 2.0 is no longer the hot new technology. The developers who are<br />
working on this application are facing a dilemma. They’d like to use the latest stack of technologies in<br />
their development and have their application look and “feel” modern. At the same time, they don’t<br />
want to throw away the great product they have built over 15 years and rewrite the entire application<br />
from scratch.</p>
<h4><strong>Your story</strong></h4>
<p>You might find yourself in the same boat, where you have mature Windows Forms or Windows<br />
Presentation Foundation (WPF) applications that have proved their reliability over the years. You<br />
probably want to keep using these applications for many more years. At the same time, since those<br />
applications were written some time ago, they might be missing capabilities like modern look,<br />
performance, integration with new devices and platform features, and so on, which gives them a feel<br />
of “old tech”. There’s another problem that might concern you as a developer. While working on the<br />
older .NET Framework versions and maintaining applications that were written a while ago, you might<br />
feel like you aren’t learning new technologies and missing out on building modern technical skills. If<br />
that is your story – this book is for you!</p>
<h3>Desktop applications nowadays</h3>
<p>Before the rise of the Internet, desktop applications were the main approach to building software<br />
systems. Developers could choose any programming language, such as COBOL, Fortran, VB6, or C++.</p>
<p>1 CHAPTER 1 | Why modern desktop applications</p>
<p>But whether they developed small tools or complex distributed architectures, they were all desktop<br />
applications.</p>
<p>Then, Internet technologies started shocking the development world and winning over more<br />
engineers with advantages like easy deployment and simplified distribution processes. The fact that<br />
once a web application was deployed to production all users got automatic updates made a huge<br />
impact on software agility.</p>
<p>However, the Internet infrastructure, underlying protocols, and standards like HTTP and HTML weren’t<br />
designed for building complex applications. In fact, the major development effort back then was<br />
aimed at just one goal: to give web applications the same capabilities that desktop applications have,<br />
such as fast data input and state management.</p>
<p>Even though web and mobile applications have grown at an incredible pace, for certain tasks desktop<br />
applications still hold the number one place in terms of efficiency and performance. That explains why<br />
there are millions of developers who are building their projects with WPF and WinForms and the<br />
amount of those applications is constantly growing.</p>
<p>Here are some reasons for choosing desktop applications in your development:</p>
<ul>
<li>
<p>Desktop apps have better interaction with the user’s PC.</p>
</li>
<li>
<p>The performance of desktop applications for complex calculations is much higher than the<br />
performance of web applications.</p>
</li>
<li>
<p>Running custom logic on the client-side is possible but much harder with a web application.</p>
</li>
<li>
<p>Using multithreading is easier and more efficient in a desktop application.</p>
</li>
<li>
<p>The learning curve for designing user interfaces (UIs) isn’t steep. And for WinForms, it’s<br />
intuitive with the drag-and-drop experience of the Windows Forms designer.</p>
</li>
<li>
<p>It’s easy to start coding and testing your algorithms without the need to set up a server<br />
infrastructure or to care about connectivity problems, firewalls, and browser compatibility.</p>
</li>
<li>
<p>Debugging is powerful as compared to web debugging.</p>
</li>
<li>
<p>Access to hardware devices, such as camera, Bluetooth, or card readers, is easy.</p>
</li>
<li>
<p>Since the technology has been around for a while, there are many experts and a knowledge<br />
base available to develop desktop applications.</p>
</li>
</ul>
<p>So, as you can see, developing for desktop is great for many reasons. The technology is mature and<br />
time-tested, the development cycle is fast, the debugging is powerful and arguably, desktop apps<br />
have less complexity and are easier to get started with.</p>
<p>Microsoft offered many UI desktop technologies throughout the years from Win32 introduced in 1995<br />
to Universal Windows Platform (UWP) released in 2016.</p>
<p>2 CHAPTER 1 | Why modern desktop applications</p>
<p>According to a survey published by Telerik on April 2016, the most popular technologies for building<br />
Windows desktop apps are Windows Forms, WPF, and UWP.</p>
<p>You can develop in any of them using C# and Visual Basic, but let’s take a closer look.</p>
<h4><strong>Windows Forms</strong></h4>
<p>First released in 2002, Windows Forms is a managed framework and is the oldest, most-used desktop<br />
technology built on the Windows graphics device interface (GDI) engine. It offers a smooth drag-anddrop experience for developing user interfaces in Visual Studio. At the same time, Windows Forms<br />
relies on the Visual Studio Designer as the main way you develop your UI, so creating visual<br />
components from code isn’t trivial.</p>
<p>The following list summarizes the main characteristics of Windows Forms:</p>
<ul>
<li>
<p>Mature technology with lots of code samples and documentation.</p>
</li>
<li>
<p>Powerful and productive designer. Not so convenient to design UI “from code”.</p>
</li>
<li>
<p>Easy and intuitive to learn, thanks to the designer’s drag-and-drop experience.</p>
</li>
<li>
<p>Supported on any Windows version.</p>
</li>
<li>
<p>Supported on .NET Core 3.0 and later versions.</p>
</li>
</ul>
<p>3 CHAPTER 1 | Why modern desktop applications</p>
<h4><strong>WPF</strong></h4>
<p>Based on the XAML language specification, WPF favors a clear separation between UI and code. XAML<br />
offers capabilities like templating, styling, and binding, which is suited for building large applications.<br />
Like Windows Forms, it’s a managed framework, but the design is modular and reusable.</p>
<p>Here are the main features of WPF:</p>
<ul>
<li>
<p>Mature technology.</p>
</li>
<li>
<p>Designer is available, but developers usually prefer to create the design from code using<br />
declarative XAML.</p>
</li>
<li>
<p>The learning curve is steeper than Windows Forms.</p>
</li>
<li>
<p>Supported on any Windows version.</p>
</li>
<li>
<p>Supported on .NET Core 3.0 and later versions.</p>
</li>
</ul>
<h4><strong>UWP</strong></h4>
<p>UWP isn’t only a presentation framework like WPF and Windows Forms, but it’s also a platform itself.<br />
This platform has:</p>
<ul>
<li>
<p>Its own API set (the Windows Runtime API).</p>
</li>
<li>
<p>A new deployment system (MSIX)</p>
</li>
<li>
<p>A modern application lifecycle model (for low battery consumption).</p>
</li>
<li>
<p>A new Resource Management System (based on PRI files).</p>
</li>
</ul>
<p>The platform was created to support all kinds of input systems (like ink, touch, gamepad, mouse,<br />
keyboard, gaze, and so on) in all form-factors with performance and low battery consumption in mind.<br />
For these reasons, the shell of the Windows 10 OS uses parts of the UWP platform.</p>
<p>4 CHAPTER 1 | Why modern desktop applications</p>
<p>UWP contains a presentation framework that is XAML-based, like WPF, but it has some important<br />
differences such as:</p>
<ul>
<li>
<p>Applications are executed in app containers. App containers control what resources a UWP<br />
app can access.</p>
</li>
<li>
<p>Supported only on Windows 10 and Windows 11.</p>
</li>
<li>
<p>Apps can be deployed through Microsoft Store for easier deployment.</p>
</li>
<li>
<p>Designed as part of the Windows Runtime API.</p>
</li>
<li>
<p>Contains an extensive set of rich built-in controls and additional controls are available<br />
through the Microsoft UI Library NuGet packages (WinUI library), updated every few months.</p>
</li>
</ul>
<h3>A tale of two platforms</h3>
<p>In the last 20 years, while UI desktop technologies were growing and following the path from<br />
Windows Forms to UWP, the hardware was also evolving from heavyweight PC units with small CRT<br />
monitors to high-DPI monitors and lightweight tablets and phones with different data input<br />
techniques like Touch and Ink. These changes resulted in creating two different concepts: a Desktop<br />
Application and a Modern Application. A Modern Application is one that considers different device<br />
form factors, various input and output methods, and leverages modern desktop features while<br />
running on a sandboxed execution model. The (traditional) Desktop Application, on the other hand, is</p>
<p>5 CHAPTER 1 | Why modern desktop applications</p>
<p>an application that needs a solid UI with a high density of controls that is best operated with a mouse<br />
and a keyboard.</p>
<p>The following table describes the differences between the two concepts:</p>
<table>
<thead>
<tr>
<th>Aspect of comparison</th>
<th>Modern Application</th>
<th>Desktop Application</th>
</tr>
</thead>
<tbody>
<tr>
<td>Security</td>
<td>Contained execution &amp; Great<br>Fundamentals. Designed from<br>the ground up to respect user’s<br>privacy, manage battery life,<br>and focus to keep the device<br>safe.</td>
<td>User &amp; Admin level of security.<br>You have native access to the<br>registry and hard drive folders.</td>
</tr>
<tr>
<td>Deployment</td>
<td>Installation and updates are<br>managed by the platform.</td>
<td>MSI, Custom installers &amp;<br>Updates. Traditionally a source<br>of headaches for developers<br>and IT managers.</td>
</tr>
<tr>
<td>Distribution</td>
<td>Trusted Distribution &amp; Signed<br>Packages. Distribution is<br>performed from a trusted<br>source and never from the<br>web.</td>
<td>Web, SCCM &amp; Custom<br>distribution. No control over<br>what is installed, affects the<br>whole machine.</td>
</tr>
<tr>
<td>UI</td>
<td>Modern UI. Different input<br>mechanisms, ink, touch,<br>gamepad, keyboard, mouse,<br>etc.</td>
<td>Windows Forms, WPF, MFC.<br>Designed for the mouse and<br>keyboard for a dense UI and to<br>get the most productivity from<br>the desktop.</td>
</tr>
<tr>
<td>Data</td>
<td>Cloud First Data with Insights.<br>Source of truth in the cloud.<br>Insights to know what happens<br>with your app and how it’s<br>performing.</td>
<td>Local Data. Traditional desktop<br>applications usually need some<br>local data.</td>
</tr>
<tr>
<td>Design</td>
<td>Designed for reuse. Reuse in<br>mind between different<br>platforms, front end, and back<br>end, running assets in many<br>places as possible.</td>
<td>Designed for Windows<br>Desktop only</td>
</tr>
</tbody>
</table>
<p>As a part of the commitment to provide developers with the best tools to build applications, Microsoft<br />
put forth a great effort to bring these concepts - or we can even say platforms - closer together to<br />
empower developers with the best of both worlds. To do that, Microsoft has performed a bidirectional<br />
effort between the two platforms.</p>
<p>6 CHAPTER 1 | Why modern desktop applications</p>
<ol>
<li>
<p>Move Desktop Application scenarios into Modern Application platform. The traditional<br />
desktop development is still popular because it addresses certain scenarios well. It makes<br />
sense to take these common desktop scenarios and bring them into the modern desktop<br />
platform to make the platform fully capable.</p>
</li>
<li>
<p>Move Modern Application features into Desktop Applications. For existing desktop apps that<br />
need a way to leverage modern capabilities without rewriting from scratch, features from the<br />
Modern Application platform are pushed into the Desktop Application.</p>
</li>
</ol>
<p>7 CHAPTER 1 | Why modern desktop applications</p>
<p>In this book, we’ll focus on the second part and show how you can modernize your existing desktop<br />
applications.</p>
<h3>Paths to modernization</h3>
<p>The structure of this guide reflects three different axes to accomplish modernization: Modern<br />
Features, Deployment, and Installation.</p>
<h4><strong>Modern features</strong></h4>
<p>Say you have a working Windows Forms application that a sales representative of your company uses<br />
to fill in a customer order. A new requirement comes in to enable the customer to sign the order<br />
using a tablet pen. Inking is native in today’s operating systems and technologies, but it wasn’t<br />
available when the app was developed.</p>
<p>This path will show you how you can leverage modern desktop features into your existing desktop<br />
development.</p>
<h4><strong>Deployment</strong></h4>
<p>Modern development cycles have stressed the importance of providing agility with regard to how new<br />
versions of applications are deployed to individual users. Since Windows Forms and WPF applications<br />
are based on a particular version of the .NET Framework that must be present on the machine, they<br />
can’t take advantage of new .NET Framework version features without the intervention of the IT<br />
people with the risk of having side effects for other apps running on the same machine. It has limited<br />
the innovation pace for developers forcing them to stay on outdated versions of the .NET Framework.</p>
<p>Since the launch of .NET Core 3.0, you can leverage a new approach of deploying multiple versions of<br />
.NET side by side and specifying which version of .NET each application should target. This way, you<br />
can use the newest features in one application while being confident you aren’t going to break any<br />
other applications.</p>
<h4><strong>Installation</strong></h4>
<p>Desktop applications always rely on some sort of installation process before the user can start using<br />
them. This fact brought into the game a set of technologies, from MSI and ClickOnce to custom<br />
installers or even XCOPY deployment. Any of these methods deals with delicate problems because<br />
applications need a way to access shared resources on the machine. Sometimes installation needs to<br />
access the Registry to insert or update new Key Values, sometimes to update shared DLLs referenced<br />
by the main application. This behavior causes a continuous headache for users, creating this<br />
perception that once you install some application, your computer will never be the same, even if you<br />
uninstall it afterwards.</p>
<p>In this book, we’ll introduce a new way of installing applications with MSIX that solves the problem<br />
described earlier. You’ll learn how you can easily set up packaging, installation, and updates for your<br />
application.</p>
<p>8 CHAPTER 1 | Why modern desktop applications</p>
<p><strong>CHAPTER</strong></p>
<h1>2</h1>
<h2>What’s new with .NET for Desktop?</h2>
<p>Desktop applications such as Windows Forms and WPF can be built using various .NET<br />
implementations, for example, .NET Framework or .NET 7. In this chapter, we’ll talk about the history<br />
of each implementation, explain the differences, and show what new features await desktop<br />
developers in newer implementations.</p>
<p>If you’ve been developing Windows Forms or WPF applications for a long time, you’re familiar with<br />
.NET Framework. Later, .NET Core (specifically its 3.0 version) started supporting desktop applications.<br />
.NET Core was rebranded to .NET when .NET 5 was released. Just as there are different versions of<br />
.NET Framework, for example, 4.6, 4.7, and 4.8, there are also different versions of .NET Core: .NET<br />
Core 3.0, .NET 5, .NET 6, .NET 7, and so on.</p>
<p>Let’s look into the history of each implementation to understand the differences and benefits of each.</p>
<h3>The motivation behind .NET Core</h3>
<p>Since its launch in 2002, .NET Framework has evolved to support many technologies, like Windows<br />
Forms, ASP.NET, Entity Framework, Windows Store, and many others. All of them are different in<br />
nature. Therefore, Microsoft approached this evolution by taking parts of .NET Framework and<br />
creating a different application stack for each technology. That way, development capabilities could<br />
be customized for the needs of the specific stack, which maximized the potential of every platform.<br />
That led to fragmentation on the versions of .NET Framework maintained by different independent<br />
teams. All of these stacks have a common structure, containing an app model, a framework, and a<br />
runtime, but they differ in the implementation of each of the parts.</p>
<p>If you’re targeting only one of these platforms, you can use this model. However, in many cases you<br />
might need more than one target platform in the same solution. For example, your application may<br />
have a desktop admin part, a customer-facing web site that shares the back-end logic running on a<br />
server, and even a mobile client. In this case, you need a unified coding experience that can span all of<br />
these .NET verticals.</p>
<p>By the time Windows 8 was released, the concept of Portable Class Libraries (PCLs) was born.<br />
Originally, .NET Framework was designed around the assumption that it would always be deployed as<br />
<a href="https://wikipedia.org/wiki/Decomposition_(computer_science)">a single unit, so factoring wasn’t a concern. To face the problem of code sharing between verticals, the</a><br />
driving force was on how to refactor the framework. The idea of contracts is to provide a well-factored</p>
<p>9 CHAPTER 2 | What’s new with .NET for Desktop?</p>
<p>API surface area. Contracts are simply assemblies that you compile against and are designed with<br />
proper factoring in mind taking care of the dependencies between them.</p>
<p>This led to reasoning about the API differences between verticals at the assembly level, as opposed to<br />
at the individual API level like previously. This aspect enabled a class library experience that can target<br />
multiple verticals, also known as portable class libraries.</p>
<p>With PCL, the experience of development is unified across verticals based on the API shape. And the<br />
most pressing need to create libraries running on different verticals is also addressed. But there’s a<br />
great challenge: APIs are only portable when the implementation is moved forward across all the<br />
verticals.</p>
<p>A better approach is to unify the implementations across verticals by providing a well-factored<br />
implementation instead of a well-factored view. It’s a lot simpler to ask each team that owns a specific<br />
component to think about how their APIs work across all verticals than trying to retroactively provide<br />
a consistent API stack on top. This is where .NET Standard comes in.</p>
<p>Another large challenge has to do with how .NET Framework is deployed. .NET Framework is a<br />
machine-wide framework. Any changes made to it affect all applications that take a dependency on it.<br />
Although this deployment model has many advantages, such as reducing disk space and centralized<br />
access to services, it presents some pitfalls.</p>
<p>To start with, it’s difficult for application developers to take a dependency on a recently released<br />
framework. They either have to take a dependency on the latest OS or provide an application installer<br />
that installs .NET Framework along with the application. If you’re a web developer, you might not even<br />
have this option as the IT department establishes the server supported version.</p>
<p>Even if you’re willing to go through the trouble of providing an installer to chain in .NET Framework<br />
setup, you may find that upgrading .NET Framework can break other applications.</p>
<p>Despite the efforts to provide backward compatible versions of the framework, there are compatible<br />
changes that can break applications. For example, adding an interface to an existing type can change<br />
how this type is serialized and cause breaking problems depending on the existing code. Because the<br />
.NET Framework installed base is huge, fighting against these breaking scenarios slows down the pace<br />
of innovations inside .NET Framework.</p>
<p>To solve all these issues, Microsoft developed .NET Core as the evolution of the .NET development<br />
platform.</p>
<p>10 CHAPTER 2 | What’s new with .NET for Desktop?</p>
<h3>Introduction to .NET Core</h3>
<p>.NET Core, which is now referred to as just “.NET”, is the evolution of Microsoft’s .NET technology into<br />
a modular, cross-platform, open source, and cloud-ready platform. It runs on Windows, macOS, and<br />
Linux, and some ARM-based architectures like Android and IoT.</p>
<p>The purpose of .NET Core is to provide a unified platform for all types of applications, which includes<br />
<a href="https://docs.microsoft.com/dotnet/standard/net-standard">Windows, cross-platform, and mobile applications. .NET Standard</a> enabled this by providing shared<br />
base APIs, which every application model needs, and excluding any application model-specific API.</p>
<p>This framework gives applications many benefits in terms of efficiency and performance, simplifying<br />
the packaging and deployment in the different supported platforms.</p>
<p>The benefits of .NET Core come from these three characteristics:</p>
<ul>
<li>
<p><strong>Cross-platform:</strong> It allows application execution on different platforms (Windows, macOS, and<br />
Linux).</p>
</li>
<li>
<p><strong>Open source:</strong> .NET Core platform is open source and available through GitHub, fostering<br />
transparency and community contributions.</p>
</li>
<li>
<p><strong>Supported:</strong> Microsoft officially supports .NET Core.</p>
</li>
</ul>
<p>Starting with .NET Core 3.0, besides the existing support for web and cloud, there’s also support for<br />
desktop, IoT, and AI domains. The goal for this framework is impressive: to target every type of .NET<br />
development present and future.</p>
<h3>.NET 5+ is .NET Core vNext</h3>
<p>.NET 5 was the next step forward with .NET Core. .NET 5 improved .NET in a few key ways:</p>
<ul>
<li>
<p>Produced a single .NET runtime and framework that can be used everywhere and that has<br />
uniform runtime behaviors and developer experiences.</p>
</li>
<li>
<p>Expanded the capabilities of .NET by taking the best of .NET Core, .NET Framework, Xamarin,<br />
and Mono.</p>
</li>
<li>
<p>Built that product out of a single code-base that developers (Microsoft and the community)<br />
can work on and expand together and that improves all scenarios.</p>
</li>
</ul>
<p>.NET 5 was a game-changer for .NET. With .NET 5 and later versions, your code and project files look<br />
and feel the same no matter which type of app you’re building. You have access to the same runtime,<br />
APIs, and language capabilities with each app. This includes new performance improvements that get<br />
committed to the runtime almost daily. .NET 6 and .NET 7 made further improvements in reliability,<br />
<a href="https://docs.microsoft.com/dotnet/core/whats-new/dotnet-5">performance, new APIs, and language features. For more details, see What’s new in .NET 5, What’s</a><br />
<a href="https://docs.microsoft.com/dotnet/core/whats-new/dotnet-6">new in .NET 6, and What’s new in .NET 7.</a></p>
<p>11 CHAPTER 2 | What’s new with .NET for Desktop?</p>
<h3>.NET Framework vs. .NET</h3>
<p>So now that you understand the relevance of .NET, you might be wondering what happens with .NET<br />
Framework. You could be asking questions like: Do I have to abandon it? Is it going to disappear?<br />
What are my choices to modernize the applications I have on .NET Framework?</p>
<p>In 2019, .NET Framework 4.8 was released. It included three major improvements for desktop<br />
applications:</p>
<ul>
<li>
<p><strong>Modern browser and media controls</strong> : New controls were added that take advantage of<br />
Microsoft Edge and newer media players that support the latest standards.</p>
</li>
<li>
<p><strong>Access to UWP controls</strong> : UWP introduced controls that take advantage of the latest<br />
Windows features and touch displays. With .NET Framework 4.8, you don’t have to rewrite<br />
your applications to use these new features and controls, so you can use these new features<br />
in your existing WPF or Windows Forms code.</p>
</li>
<li>
<p><strong>High-DPI improvements</strong> : The resolution of displays increased to 4K and 8K, so, .NET<br />
Framework 4.8 added new HDPI improvements to make sure existing Windows Forms and<br />
WPF applications can look great on these new displays.</p>
</li>
</ul>
<p>Since .NET Framework is installed on millions of machines, Microsoft will continue to support it but<br />
won’t add new features.</p>
<p>.NET (Core) is the open-source, cross-platform, and fast-moving version of the .NET family. Because of<br />
its side-by-side nature, it can take changes without the fear of breaking any application. This means<br />
that .NET will get new APIs and language features over time that .NET Framework won’t. Also, .NET<br />
already has features that were impossible for .NET Framework, such as:</p>
<ul>
<li><strong>Side-by-side versions of .NET supporting Windows Forms and WPF</strong> : This solves the<br />
problem of side effects when updating the machine’s framework version. Multiple versions of<br />
.NET can be installed on the same machine and each application specifies which version of</li>
</ul>
<p>12 CHAPTER 2 | What’s new with .NET for Desktop?</p>
<p>.NET it should use. Even more, now you can develop and run Windows Forms and WPF on top<br />
of .NET.</p>
<ul>
<li>
<p><strong>Embed .NET directly into an application</strong> : You can deploy .NET as part of your application<br />
package. This enables you to take advantage of the latest version, features, and APIs without<br />
having to wait for a specific version to be installed on the machine.</p>
</li>
<li>
<p><strong>Take advantage of .NET features</strong> : .NET is fast-moving and open-source. Its side-by-side<br />
nature enables fast introduction of new innovative APIs and Base Class Library (BCL)<br />
improvements without the risk of breaking compatibility. Now Windows Forms and WPF<br />
applications can take advantage of the latest .NET features, which also includes fundamental<br />
fixes for things like runtime performance and high-DPI support.</p>
</li>
</ul>
<p>.NET Framework will be fully supported and will always be a part of Windows. However, if you want to<br />
use the newest language features and APIs in the future, you’ll need to move your applications to<br />
.NET. For brand-new desktop apps, we recommend starting directly on .NET 6 or a later version. It’s<br />
lightweight and cross-platform, runs side by side, has high performance, and fits perfectly on<br />
containers and microservices architectures.</p>
<h3>.NET Standard vs. PCL</h3>
<p><a href="https://docs.microsoft.com/dotnet/standard/net-standard">.NET Standard</a> is a formal specification of .NET APIs that are intended to be available on all .NET<br />
implementations. The motivation behind .NET Standard was to establish greater uniformity in the .NET<br />
ecosystem. .NET Standard is a specification of .NET APIs that make up a uniform set of contracts to<br />
compile your code against. These contracts are implemented in each .NET flavor, thus enabling<br />
portability across different .NET implementations.</p>
<p>.NET Standard enables the following key scenarios:</p>
<ul>
<li>
<p>Defines uniform set of base class libraries APIs for all .NET implementations to implement,<br />
independent of the workload.</p>
</li>
<li>
<p>Enables developers to produce portable libraries that are usable across .NET implementations,<br />
using this same set of APIs.</p>
</li>
</ul>
<p>13 CHAPTER 2 | What’s new with .NET for Desktop?</p>
<p>.NET Standard is the evolution of PCLs and the following list shows the fundamental differences<br />
between .NET Standard and PCLs:</p>
<ul>
<li>
<p>.NET Standard is a set of curated APIs, picked by Microsoft. PCLs aren’t.</p>
</li>
<li>
<p>The APIs that a PCL contains are dependent on the platforms that you choose to target when<br />
you create it. This makes a PCL only sharable for the specific targets that you choose.</p>
</li>
<li>
<p>.NET Standard is platform-agnostic, so it can run on Windows, macOS, and Linux.</p>
</li>
<li>
<p>PCLs can also run cross-platform, but they can only target a limited set of platforms.</p>
</li>
</ul>
<h3>New Desktop features in .NET</h3>
<h4><strong>Support for Windows Forms and WPF</strong></h4>
<p>Windows Forms and WPF are part of .NET Core since version 3.0. Both presentation frameworks are<br />
for Windows only, so they aren’t cross-platform. You can think of WPF as a rich layer over DirectX and<br />
Windows Forms as a thinner layer over GDI+. WPF and Windows Forms do a great job of exposing<br />
and exercising much of the desktop application functionality in Windows. So Windows Forms and<br />
WPF are available for .NET Core and .NET Framework. Target your new desktop applications to .NET 6<br />
or later, and migrate your existing apps from .NET Framework to .NET 6 or later.</p>
<p>A new version of .NET Standard, version 2.1, was released at the same time as .NET Core 3.0. To see<br />
<a href="https://docs.microsoft.com/dotnet/standard/net-standard#net-standard-versions">which .NET implementations support which .NET Standard versions, see Which .NET Standard version</a><br />
<a href="https://docs.microsoft.com/dotnet/standard/net-standard#net-standard-versions">to target.</a></p>
<p>The .NET (Core) implementations for both Windows Forms and WPF are open source.</p>
<h4><strong>XAML Islands</strong></h4>
<p><a href="https://docs.microsoft.com/windows/apps/desktop/modernize/xaml-islands">XAML Islands</a> is a set of components for developers to use Windows 10 controls (UWP XAML controls)<br />
in their WPF, Windows Forms, and native Win32 apps (like MFC). You can have your “islands” of UWP<br />
XAML controls wherever you want inside your Win32 apps.</p>
<p>These XAML Islands are possible because Windows 10, version 1903 introduced a set of APIs that<br />
allows hosting UWP XAML content in Win32 windows using windows handlers (HWnds). Only apps<br />
running on Windows 10 1903 and later can use XAML Islands.</p>
<p>To make it easier to create XAML Islands for Windows Forms and WPF developers, the Windows<br />
Community Toolkit introduces a set of .NET wrappers in several NuGet packages. Those wrappers are<br />
the wrapped and hosting controls:</p>
<ul>
<li>
<p><a href="https://docs.microsoft.com/windows/communitytoolkit/controls/wpf-winforms/webview">The WebView,</a> <a href="https://docs.microsoft.com/windows/communitytoolkit/controls/wpf-winforms/webviewcompatible">WebViewCompatible, InkCanvas,</a> <a href="https://docs.microsoft.com/windows/communitytoolkit/controls/wpf-winforms/mediaplayerelement">MediaPlayerElement, and MapControl</a><br />
wrapped controls wrap some UWP XAML controls into Windows Forms or WPF controls,<br />
hiding UWP concepts for those developers.</p>
</li>
<li>
<p><a href="https://docs.microsoft.com/windows/communitytoolkit/controls/wpf-winforms/windowsxamlhost">The WindowsXamlHost control for Windows Forms and WPF allows other not-wrapped UWP</a><br />
XAML controls and custom controls to be loaded into a XAML Island.</p>
</li>
</ul>
<p>14 CHAPTER 2 | What’s new with .NET for Desktop?</p>
<h4><strong>Access to all Windows 10 and Windows 11 APIs</strong></h4>
<p>Windows 10 and Windows 11 have a large number of APIs available for developers to work with.<br />
These APIs give access to a wide variety of functionality like authentication, bluetooth, appointments,<br />
and contacts. Now these APIs are exposed through .NET and give Windows developers the chance to<br />
create powerful desktops apps using the capabilities present on Windows 10 and Windows 11.</p>
<h4><strong>Side-by-side support and self-contained EXEs</strong></h4>
<p>The .NET deployment model is one of the biggest benefits that Windows desktop developers will<br />
experience with .NET. The ability to globally install .NET provides much of the same central installation<br />
and servicing benefits of .NET Framework, while not requiring in-place updates.</p>
<p>When a new .NET version is released, you can update each app on a machine as needed without any<br />
concern of affecting other applications. New .NET versions are installed in their own directories and<br />
exist “side-by-side” with each other.</p>
<p>If you need to deploy with isolation, you can deploy .NET with your application. .NET will bundle your<br />
app with the .NET runtime as a single executable. The modular architecture used by .NET makes these<br />
flexible deployment options possible.</p>
<h4><strong>Performance</strong></h4>
<p>Since its start, targeting the web and cloud workloads, .NET has had performance plugged into its<br />
DNA. Server-side code must be performant enough to fulfill high-concurrency scenarios and .NET 7<br />
scores today as the best performance web platform in the market.</p>
<p>Old Windows Forms code has been refactored for .NET, which reduced memory allocations for<br />
drawing Forms and Controls. By simply upgrading from .NET Framework to .NET or later, your<br />
applications become much faster. You can take advantage of these performance improvements when<br />
you use .NET to build your next generation of desktop applications.</p>
<p>15 CHAPTER 2 | What’s new with .NET for Desktop?</p>
<p><strong>CHAPTER</strong></p>
<h1>3</h1>
<h2>Migrating Modern Desktop applications</h2>
<p>In this chapter, we’re exploring the most common issues and challenges you can face when migrating<br />
an existing application from .NET Framework to .NET.</p>
<p>If you just want to update your application to the latest .NET version using a tool and not get into the<br />
details of what’s happening behind the scenes, feel free to skip this chapter and find step-by-step<br />
instructions in the Example of migrating to .NET chapter.</p>
<p>A complex desktop application doesn’t work in isolation and needs some kind of interaction with<br />
subsystems that may reside on the local machine or on a remote server. It will probably need some<br />
kind of database to connect with as a persistence store either locally or remotely. With the rise of<br />
Internet and service-oriented architectures, it’s common to have your application connected to some<br />
sort of service residing on a remote server or in the cloud. You may need to access the machine file<br />
system to implement some functionality. Alternatively, maybe you’re using a piece of functionality<br />
that resides inside a COM object outside your application, which is a common scenario if, for example,<br />
you’re integrating Office assemblies in your app.</p>
<p>Besides, there are differences in the API surface that is exposed by .NET Framework and .NET, and<br />
some features that are available on .NET Framework aren’t available on .NET. It’s important for you to<br />
know and take them into account when planning a migration.</p>
<h3>Configuration files</h3>
<p>Configuration files offer the possibility to store sets of properties that are read at run time and can<br />
affect the behavior of your app, such as where to locate a database or how many times to execute a<br />
loop. The beauty of this technique is that you can modify some aspects of the application without the<br />
need to recode and recompile. This comes in handy when, for example, the same app code runs on a<br />
development environment with a certain set of configuration values and in production environment<br />
with a different set.</p>
<h4><strong>Configuration on .NET Framework</strong></h4>
<p>If you have a working .NET Framework desktop application, chances are you have an <em>app.config</em> file<br />
<a href="https://docs.microsoft.com/dotnet/api/system.configuration.appsettingssection">accessed through the AppSettingsSection class from the System.Configuration namespace.</a></p>
<p>16 CHAPTER 3 | Migrating Modern Desktop applications</p>
<p>Within the .NET Framework infrastructure, there’s a hierarchy of configuration files that inherit<br />
properties from its parents. You can find a <em>machine.config</em> file that defines many properties and<br />
configuration sections that can be used or overridden in any descendant configuration file.</p>
<h4><strong>Configuration on .NET</strong></h4>
<p>In the .NET world, there’s no <em>machine.config</em> file. And even though you can continue to use the old<br />
<a href="https://docs.microsoft.com/dotnet/api/system.configuration">fashioned System.Configuration namespace, you may consider switching to the modern</a><br />
<a href="https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration">Microsoft.Extensions.Configuration, which offers a good number of enhancements.</a></p>
<p>This configuration API supports the concept of a configuration provider, which defines the data source<br />
to be used to load the configuration. There are different kinds of built-in providers, such as:</p>
<ul>
<li>
<p>In-memory .NET objects</p>
</li>
<li>
<p>INI files</p>
</li>
<li>
<p>JSON files</p>
</li>
<li>
<p>XML files</p>
</li>
<li>
<p>Command-line arguments</p>
</li>
<li>
<p>Environment variables</p>
</li>
<li>
<p>Encrypted user store</p>
</li>
</ul>
<p>Or you can build your own.</p>
<p>The new configuration API allows a list of name-value pairs that can be grouped into a multi-level<br />
hierarchy. Any stored value maps to a string, and there’s built-in binding support that allows you to<br />
deserialize settings into a custom plain old CLR object (POCO).</p>
<p><a href="https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.configurationbuilder">The ConfigurationBuilder object lets you add as many configuration providers as you may need for</a><br />
your application. A precedence rule is used to resolve provider preference. So, the last provider you<br />
add in your code overrides the others. This is a great feature for managing different environments for<br />
execution since you can define different configurations for development, testing, and production<br />
environments. And you can manage them in a single function inside your code.</p>
<h4><strong>Migrating configuration files</strong></h4>
<p>You can continue to use your existing app.config XML file. However, you could take this opportunity<br />
to migrate your configuration to benefit from the several enhancements made in .NET.</p>
<p>To migrate from an old-style <em>app.config</em> to a new configuration file, you should choose between an<br />
XML format and a JSON format.</p>
<p>If you choose XML, the conversion is straightforward. Since the content is the same, just save the<br />
<em>app.config</em> file with XML as type. Then, change the code that references AppSettings to use the<br />
<a href="https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.configurationbuilder">ConfigurationBuilder</a> class. This change should be easy.</p>
<p><a href="https://www.nuget.org/packages/dotnet-config2json/">If you want to use a JSON format and you don’t want to migrate by hand, there’s a tool called dotnet-</a><br />
<a href="https://www.nuget.org/packages/dotnet-config2json/">config2json</a> that can convert an <em>app.config</em> file to a JSON configuration file.</p>
<p>You may come across some issues when using configuration sections that were defined in the<br />
<em>machine.config</em> file. For example, consider the following configuration:</p>
<p>17 CHAPTER 3 | Migrating Modern Desktop applications</p>
<p>If you take this configuration to a .NET app, you’ll get an exception:</p>
<p>Unrecognized configuration section System.Diagnostics</p>
<p>This exception occurs because that section and the assembly responsible for handling that section<br />
was defined in the <em>machine.config</em> file, which now doesn’t exist.</p>
<p>To easily fix the issue, you can copy the section definition from your old <em>machine.config</em> to your new<br />
configuration file:</p>
<h3>Accessing databases</h3>
<p>Almost every desktop application needs some kind of database. For desktop, it’s common to find<br />
client-server architectures with a direct connection between the desktop app and the database<br />
engine. These databases can be local or remote depending on the need to share information between<br />
different users.</p>
<p>From the code perspective, there have been many technologies and frameworks to give the developer<br />
the possibility to connect, query, and update a database.</p>
<p>The most common examples of database you can find when talking about Windows Desktop<br />
application are Microsoft Access and Microsoft SQL Server. If you have more than 20 years of<br />
experience programming for the desktop, names like ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ, and<br />
Entity Framework will sound familiar.</p>
<p>18 CHAPTER 3 | Migrating Modern Desktop applications</p>
<h4><strong>ODBC</strong></h4>
<p>You can continue to use ODBC on .NET since Microsoft is providing the System.Data.Odbc library<br />
compatible with .NET Standard 2.0.</p>
<h4><strong>OLE DB</strong></h4>
<p><a href="https://docs.microsoft.com/previous-versions/windows/desktop/ms722784(v=vs.85)">OLE DB</a> has been a great way to access various data sources in a uniform manner. But it was based on<br />
COM, which is a Windows-only technology, and as such wasn’t the best fit for a cross-platform<br />
technology such as .NET. It’s also unsupported in SQL Server versions 2014 and later. For those<br />
reasons, OLE DB won’t be supported by .NET.</p>
<h4><strong>ADO.NET</strong></h4>
<p>You can still use ADO.NET from your existing desktop code on .NET. You just need to update some<br />
NuGet packages.</p>
<h4><strong>EF Core vs. EF6</strong></h4>
<p>There are two currently supported versions of Entity Framework (EF), Entity Framework 6 (EF6) and EF<br />
Core.</p>
<p>The latest technology released as part of the .NET Framework world is Entity Framework, with 6.4<br />
being the latest version. With the launch of .NET Core, Microsoft also released a new data access stack<br />
based on Entity Framework and called Entity Framework Core.</p>
<p>You can use EF 6.4 and EF Core from both .NET Framework and .NET. So, what are the decision drivers<br />
to help to decide between the two?</p>
<p>EF 6.3 is the first version of EF6 that can run on .NET and work cross-platform. In fact, the main goal of<br />
this release was to make it easier to migrate existing applications that use EF6 to .NET.</p>
<p>EF Core was designed to provide a developer experience similar to EF6. Most of the top-level APIs<br />
remain the same, so EF Core will feel familiar to developers who have used EF6.</p>
<p>Although compatible, there are differences on the implementation you should check before making a<br />
<a href="https://docs.microsoft.com/ef/efcore-and-ef6/">decision. For more information, see Compare EF Core &amp; EF6.</a></p>
<p>The recommendation is to use EF Core if:</p>
<ul>
<li>
<p>The app needs the capabilities of .NET.</p>
</li>
<li>
<p>EF Core supports all of the features that the app requires.</p>
</li>
</ul>
<p>Consider using EF6 if both of the following conditions are true:</p>
<ul>
<li>
<p>The app will run on Windows and .NET Framework 4.0 or later.</p>
</li>
<li>
<p>EF6 supports all of the features that the app requires.</p>
</li>
</ul>
<p>19 CHAPTER 3 | Migrating Modern Desktop applications</p>
<h4><strong>Relational databases</strong></h4>
<p><strong>SQL Server</strong></p>
<p>SQL Server has been one of the databases of choice if you were developing for the desktop some<br />
<a href="https://docs.microsoft.com/dotnet/api/system.data.sqlclient">years ago. With the use of System.Data.SqlClient</a> in .NET Framework, you could access versions of SQL<br />
Server, which encapsulates database-specific protocols.</p>
<p>In .NET, you can find a new SqlClient class, fully compatible with the one existing in the .NET<br />
<a href="https://docs.microsoft.com/dotnet/api/microsoft.data.sqlclient">Framework but located in the Microsoft.Data.SqlClient</a> library. You just have to add a reference to the<br />
<a href="https://www.nuget.org/packages/Microsoft.Data.SqlClient/">Microsoft.Data.SqlClient</a> NuGet package and do some renaming for the namespaces and everything<br />
should work as expected.</p>
<p><strong>Microsoft Access</strong></p>
<p>Microsoft Access has been used for years when the sophisticated and more scalable SQL Server wasn’t<br />
<a href="https://docs.microsoft.com/dotnet/api/system.data.odbc">needed. You can still connect to Microsoft Access using the System.Data.Odbc</a> library.</p>
<h3>Consuming services</h3>
<p>With the rise of service-oriented architectures, desktop applications began to evolve from a clientserver model to the three-layer approach. In the client-server approach, a direct database connection<br />
is established from the client holding the business logic, usually inside a single EXE file. On the other<br />
hand, the three-layer approach establishes an intermediate service layer implementing business logic<br />
and database access, allowing for better security, scalability, and reusability. Instead of working<br />
directly with underlying data, the layered approach relies on a set of services implementing contracts<br />
and typed objects for data transfer.</p>
<p>If you have a desktop application using a WCF service and you want to migrate it to .NET, there are<br />
some things to consider.</p>
<p>The first thing is how to resolve the configuration to access the service. Because the configuration is<br />
different on .NET, you’ll need to make some updates in your configuration file.</p>
<p>Second, you’ll need to regenerate the service client with the new tools present on Visual Studio 2019<br />
and Visual Studio 2022. In this step, you must consider activating the generation of the synchronous<br />
operations to make the client compatible with your existing code.</p>
<p>After the migration, if you find that there are libraries you need that aren’t present on .NET, you can<br />
<a href="https://www.nuget.org/packages/Microsoft.Windows.Compatibility">add a reference to the Microsoft.Windows.Compatibility</a> NuGet package and see if the missing<br />
functions are there.</p>
<p><a href="https://docs.microsoft.com/dotnet/api/system.net.webrequest">If you’re using the WebRequest class to perform web service calls, you may find some differences on</a><br />
<a href="https://learn.microsoft.com/dotnet/api/system.net.http.httpclient">.NET. The recommendation is to use HttpClient</a> instead.</p>
<p>20 CHAPTER 3 | Migrating Modern Desktop applications</p>
<h3>Consuming a COM Object</h3>
<p>Currently, there’s no way to add a reference to a COM object from Visual Studio 2019 or Visual Studio<br />
2022 to use with .NET. So, you have to manually modify the project file.</p>
<p>Insert a COMReference structure inside the project file like in the following example:</p>
<h3>More things to consider</h3>
<p>Several technologies available to .NET Framework libraries aren’t available for .NET Core or .NET 7. If<br />
your code relies on some of these technologies, consider the alternative approaches outlined in this<br />
section.</p>
<p><a href="https://docs.microsoft.com/dotnet/core/porting/windows-compat-pack">The Windows Compatibility Pack provides access to APIs that were previously available only for .NET</a><br />
Framework. It can be used on .NET Core and .NET Standard projects.</p>
<p>For more information on API compatibility, you can find documentation about breaking changes and<br />
<a href="https://docs.microsoft.com/dotnet/core/compatibility/fx-core">deprecated/legacy APIs at https://learn.microsoft.com/dotnet/core/compatibility/fx-core.</a></p>
<h4><strong>AppDomains</strong></h4>
<p>Application domains (AppDomains) isolate apps from one another. AppDomains require runtime<br />
support and are expensive. Creating additional app domains isn’t supported. For code isolation, we<br />
recommend separate processes or using containers as an alternative. For the dynamic loading of<br />
<a href="https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext">assemblies, we recommend the new AssemblyLoadContext</a> class.</p>
<p>To make code migration from .NET Framework easier, .NET exposes some of the AppDomain API<br />
<a href="https://docs.microsoft.com/dotnet/api/system.appdomain.unhandledexception">surface. Some of the APIs function normally (for example, AppDomain.UnhandledException), some</a><br />
<a href="https://docs.microsoft.com/dotnet/api/system.appdomain.setcachepath">members do nothing (for example, SetCachePath), and some of them throw</a><br />
<a href="https://docs.microsoft.com/dotnet/api/system.platformnotsupportedexception">PlatformNotSupportedException (for example, CreateDomain).</a></p>
<h4><strong>Remoting</strong></h4>
<p>.NET Remoting was used for cross-AppDomain communication, which is no longer supported. Also,<br />
Remoting requires runtime support, which is expensive to maintain. For these reasons, .NET Remoting<br />
isn’t supported on .NET.</p>
<p>For communication across processes, you should consider inter-process communication (IPC)<br />
<a href="https://docs.microsoft.com/dotnet/api/system.io.memorymappedfiles.memorymappedfile">mechanisms as an alternative to Remoting, such as the or the MemoryMappedFile class.</a></p>
<p>21 CHAPTER 3 | Migrating Modern Desktop applications</p>
<p>Across machines, use a network-based solution as an alternative. Preferably, use a low-overhead<br />
plaintext protocol, such as HTTP. The Kestrel web server, the web server used by ASP.NET Core, is an<br />
option here.</p>
<h4><strong>Code Access Security (CAS)</strong></h4>
<p>Sandboxing, which relies on the runtime or the framework to constrain which resources a managed<br />
application or library uses or runs, isn’t supported on .NET.</p>
<p>Use security boundaries that are provided by the operating system, such as virtualization, containers,<br />
or user accounts, for running processes with the minimum set of privileges.</p>
<h4><strong>Security Transparency</strong></h4>
<p>Similar to CAS, Security Transparency separates sandboxed code from security critical code in a<br />
declarative fashion but is no longer supported as a security boundary.</p>
<p>Use security boundaries that are provided by the operating system, such as virtualization, containers,<br />
or user accounts, for running processes with the least set of privileges.</p>
<p>22 CHAPTER 3 | Migrating Modern Desktop applications</p>
<p><strong>CHAPTER</strong></p>
<h1>4</h1>
<h2>Windows 10 migration</h2>
<p>Consider the following situation: You have a working desktop application that was developed in the<br />
Windows 7 days. It’s using WPF technology available at that time and working fine but it has an<br />
outdated UI and behaviors when you run it on Windows 10 or Windows 11. It is like when you watch a<br />
futuristic movie like Matrix and you see Neo using the Nokia 8110 device. The film works great after<br />
20 years but it would rather benefit from a device modernization.</p>
<p>With the release of Windows 10, Microsoft introduced many innovations to support scenarios like<br />
tablets and touch devices and to provide the best experience for users for a Microsoft operating<br />
system ever. For example, you can:</p>
<ul>
<li>
<p>Sign in with your face using Windows Hello.</p>
</li>
<li>
<p>Use a pen to draw or handwrite text that is automatically recognized and digitalized.</p>
</li>
<li>
<p>Run locally customized AI models built on the cloud using WinML.</p>
</li>
</ul>
<p>All these features are enabled for Windows developers through Windows Runtime (WinRT) libraries.<br />
You can take advantage of these features in your existing desktop apps because the libraries are<br />
exposed to both the .NET Framework and .NET as well. You can even modernize your UI with the use<br />
of XAML Islands and improve the visuals and behavior of your apps according to the times.</p>
<p>One important thing to note here is that you don’t need to abandon .NET Framework technology to<br />
follow this modernization path. You can safely stay on there and have all the benefits of Windows 10<br />
and Windows 11 without the pressure to migrate to .NET. So, you get both the power and the<br />
flexibility to choose your modernization path.</p>
<h3>WinRT APIs</h3>
<p>WinRT APIs are object-oriented, well-structured application programming interfaces (APIs) that give<br />
Windows 10 and Windows 11 developers access to everything the operating system has to offer.<br />
Through WinRT APIs, you can integrate functionalities like Push Notifications, Device APIs, Microsoft<br />
Ink, and WinML, among others on your desktop apps.</p>
<p>In general, WinRT APIs can be called from a classic desktop app. However, two main areas present an<br />
exception to this rule:</p>
<ul>
<li>
<p>APIs that require a package identity.</p>
</li>
<li>
<p>APIs that require visualization like XAML or Composition.</p>
</li>
</ul>
<p>23 CHAPTER 4 | Windows 10 migration</p>
<h4><strong>Universal Windows Platform (UWP) packages</strong></h4>
<p><strong>Application Package Identity</strong></p>
<p>UWP apps have a deployment system where the OS manages the installation and uninstallation of<br />
application. That requires the installation to be declarative, meaning that no user code is executed<br />
during install. Instead, everything the app wants to integrate with the system, such as protocols, file<br />
types, and extensions, is declared in the application manifest. At deployment time, the deployment<br />
pipeline configures those integration points. The only way for the OS to manage all this functionality<br />
and keep track of it is for each ‘package’ to have an identity, a unique identifier for the application.</p>
<p>Some WinRT APIs require this package identity to work as expected. However, classic desktop apps<br />
like native C++ or .NET apps, use different deployment systems that don’t require a package identity.<br />
If you want to use these WinRT APIs in your desktop application, you need to provide them a package<br />
identity.</p>
<p>One way to proceed is to build an additional packaging project. Inside the packaging project, you<br />
point to the original source code project and specify the Identity information you want to provide. If<br />
you install the package and run the installed app, it will automatically get an identify enabling your<br />
code to call all WinRT APIs requiring Identity.</p>
<p>You can check which APIs need a packaged application identity by inspecting if the type that contains<br />
<a href="https://docs.microsoft.com/uwp/api/windows.foundation.metadata.dualapipartitionattribute">the API is marked with the DualApiPartition</a> attribute. If it is, you can call if from an unpackaged<br />
traditional desktop app. Otherwise, you must convert your classic desktop app to a UWP with the help<br />
of a packaging project.</p>
<p><a href="https://docs.microsoft.com/windows/desktop/apiindex/uwp-apis-callable-from-a-classic-desktop-app">https://learn.microsoft.com/windows/desktop/apiindex/uwp-apis-callable-from-a-classic-desktop-app</a></p>
<p><strong>Benefits of packaging</strong></p>
<p>Besides giving you access to these APIs, you get some additional benefits by creating a Windows App<br />
package for your desktop application including:</p>
<ul>
<li>
<p><strong>Streamlined deployment</strong> . Apps have a great deployment experience ensuring that users can<br />
confidently install an application and update it. If a user chooses to uninstall the app, it’s<br />
removed completely with no trace left behind preventing the Windows rot problem.</p>
</li>
<li>
<p><strong>Automatic updates and licensing</strong> . Your application can participate in the Microsoft Store’s<br />
built-in licensing and automatic update facilities. Automatic update is a highly reliable and<br />
efficient mechanism, because only the changed parts of files are downloaded.</p>
</li>
</ul>
<p>24 CHAPTER 4 | Windows 10 migration</p>
<ul>
<li>
<p><strong>Increased reach and simplified monetization</strong> . Maybe not your case but if you choose to<br />
distribute your application through the Microsoft Store you reach millions of Windows 10 and<br />
Windows 11 users.</p>
</li>
<li>
<p><strong>Add UWP features</strong> . You can add UWP features to your app’s package at your own pace.</p>
</li>
</ul>
<p><strong>Prepare for packaging</strong></p>
<p>Before proceeding to package your desktop application, there are some points you have to address<br />
before starting the process. Your application must respect any of the Microsoft Store rules and<br />
policies and run in the UWP application model. For example, it has to run on the .NET Framework 4.6.2<br />
or later and writes to the HKEY_CURRENT_USER registry hive and the AppData folders will be<br />
virtualized to a user-specific app-local location.</p>
<p>The design goal for packaging is to separate the application state from system state while maintaining<br />
compatibility with other apps. Windows 10 and Windows 11 accomplish this goal by placing the<br />
application inside a UWP package. It detects and redirects some changes to the file system and<br />
registry at run time to fulfill the promise of a trusted and clean install and uninstall behavior of an<br />
application provided by packaging.</p>
<p>Packages that you create for your desktop application are desktop-only, full-trust applications that<br />
aren’t sandboxed, although there’s lightweight virtualization applied to the app for writes to HKCU<br />
and AppData. This virtualization allows them to interact with other apps the same way classic desktop<br />
applications do.</p>
<p><strong>Installation</strong></p>
<p>App packages are installed under <em>%ProgramFiles%\WindowsApps\package_name</em>, with the executable<br />
titled app_name.exe. Each package folder contains a manifest (named AppxManifest.xml) that contains<br />
a special XML namespace for packaged apps. Inside that manifest file is an <EntryPoint> element,<br />
which references the full-trust app. When that application is launched, it doesn’t run inside an app<br />
container, but instead it runs as the user as it normally would.</p>
<p>After deployment, package files are marked read-only and heavily locked down by the operating<br />
system. Windows prevents apps from launching if these files are tampered with.</p>
<p><strong>File system</strong></p>
<p>The OS supports different levels of file system operations for packaged desktop applications,<br />
depending on the folder location.</p>
<p>When trying to access the user’s <em>AppData</em> folder, the system creates a private per-user, per-app<br />
location behind the scenes. This creates the illusion that the packaged application is editing the real<br />
<em>AppData</em> when it’s actually modifying a private copy. By redirecting writes this way, the system can<br />
track all file modifications made by the app. It can then clean all those files when uninstalling reducing<br />
system “rot” and providing a better application removal experience for the user.</p>
<p>25 CHAPTER 4 | Windows 10 migration</p>
<p><strong>Registry</strong></p>
<p>App packages contain a registry.dat file, which serves as the logical equivalent of HKLM\Software in<br />
the real registry. At run time, this virtual registry merges the contents of this hive into the native<br />
system hive to provide a singular view of both.</p>
<p>All writes are kept during package upgrade and only deleted when the application is uninstalled.</p>
<p><strong>Uninstallation</strong></p>
<p>When the user uninstalls a package, all files and folders located under C:\Program<br />
Files\WindowsApps\package_name are removed, as well as any redirected writes to AppData or the<br />
registry that were captured during the process.</p>
<p>For details about how a packaged application handles installation, file access, registry, and<br />
<a href="https://docs.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-the-scenes">uninstallation, see https://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-the-</a><br />
<a href="https://docs.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-the-scenes">scenes.</a></p>
<p>You can get a complete list of things to check on<br />
<a href="https://docs.microsoft.com/windows/msix/desktop/desktop-to-uwp-prepare">https://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-prepare.</a></p>
<h3>How to add WinRT APIs to your desktop project</h3>
<p>In this section, you can find a walkthrough on how to integrate Toast Notifications in an existing WPF<br />
application. Although it’s simple from the code perspective, it helps illustrate the whole process.<br />
Notifications are one of the many available WinRT APIs available that you can use in .NET app. In this<br />
case, the API requires a Package Identity. This process is more straightforward if the APIs don’t require<br />
Package Identity.</p>
<p>Let’s take an existing WPF sample app that reads files and shows its contents on the screen. The goal<br />
is to display a Toast Notification when the application starts.</p>
<p>26 CHAPTER 4 | Windows 10 migration</p>
<p>First, you should check in the following link whether the Windows 10 or Windows 11 API that you’ll<br />
use requires a Package Identity:</p>
<p><a href="https://docs.microsoft.com/windows/apps/desktop/modernize/desktop-to-uwp-supported-api">https://learn.microsoft.com/windows/apps/desktop/modernize/desktop-to-uwp-supported-api</a></p>
<p><a href="https://docs.microsoft.com/uwp/api/windows.ui.notifications.notification">Our sample will use the Windows.UI.Notifications.Notification</a> API that requires a packaged identity:</p>
<p>To access the WinRT API, add a reference to the Microsoft.Windows.SDK.Contracts NuGet package<br />
and this package will do the magic behind the scenes (see details at<br />
<a href="https://blogs.windows.com/windowsdeveloper/2019/04/30/calling-windows-10-apis-from-a-desktop-application-just-got-easier/">https://blogs.windows.com/windowsdeveloper/2019/04/30/calling-windows-10-apis-from-a-desktop-</a><br />
<a href="https://blogs.windows.com/windowsdeveloper/2019/04/30/calling-windows-10-apis-from-a-desktop-application-just-got-easier/">application-just-got-easier/).</a></p>
<p>You’re now prepared to start adding some code.</p>
<p>27 CHAPTER 4 | Windows 10 migration</p>
<p>Create a ShowToastNotification method that will be called on application startup. It just builds a toast<br />
notification from an XML pattern:</p>
<p>Although the project builds, there are errors because the Notifications API requires a Package Identity<br />
and you didn’t provide it. Adding a Windows Packaging Project to the solution will fix the issue:</p>
<p>Select the minimum Windows version you want to support and the version you’re targeting. Not all<br />
the WinRT APIs are supported in all Windows 10 and Windows 11 versions. Each Windows 10 or<br />
Windows 11 update adds new APIs that are only available from this version; down-level support isn’t<br />
available.</p>
<p>28 CHAPTER 4 | Windows 10 migration</p>
<p>Next step is to add the WPF application to the Windows Packaging Project by adding a project<br />
reference:</p>
<p>29 CHAPTER 4 | Windows 10 migration</p>
<p>A Windows Packaging Project can package several apps so you should set which one is the Entry<br />
Point:</p>
<p>30 CHAPTER 4 | Windows 10 migration</p>
<p>Next step is to set the WPF Project as the startup Project in the solution configuration. You can press<br />
F5 to compile and build and see the results.</p>
<p>Let’s generate the package so you can install your app. Right click on <strong>Store</strong> - <strong>Create App Packages</strong> .</p>
<p>31 CHAPTER 4 | Windows 10 migration</p>
<p>Select the sideloading option to deploy the app from your machine:</p>
<p>32 CHAPTER 4 | Windows 10 migration</p>
<p>Select the application architecture of your app:</p>
<p>33 CHAPTER 4 | Windows 10 migration</p>
<p>Finally, create the package by clicking on <strong>Create</strong> .</p>
<h3>XAML Islands</h3>
<p>XAML Islands are a set of components that enable Windows desktop developers to use UWP XAML<br />
controls on their existing Win32 applications, including Windows Forms and WPF.</p>
<p>34 CHAPTER 4 | Windows 10 migration</p>
<p>You can image your Win32 app with your standard controls and among them an “island” of UWP UI<br />
containing controls from the modern world. The concept is similar to having an iFrame inside a web<br />
page that shows content from a different page.</p>
<p>Besides adding functionality from the Windows 10 and Windows 11 APIs, you can add pieces of UWP<br />
XAML inside of your app using XAML Islands.</p>
<p>Windows 10 1903 update introduced a set of APIs that allow hosting UWP XAML content in Win32<br />
windows. Only apps running on Windows 10 1903 or later can use XAML Islands.</p>
<h4><strong>The road to XAML Islands</strong></h4>
<p>The road to XAML Islands started in 2012 when Microsoft introduced the WinRT APIs as a framework<br />
to modernize the Win32 apps (Windows Forms, WPF, and native Win32 apps). However, the new UI<br />
controls inside WinRT were available for new applications but not for existing ones.</p>
<p>In 2015, along with Windows 10, UWP was born. UWP allows you to create apps that work across<br />
Windows devices like XBox, Mobile, and Desktop. One year later, Microsoft announced Desktop<br />
Bridge (formerly known as Project Centennial). Desktop Bridge is a set of tools that allowed<br />
developers to bring their existing Win32 apps to the Microsoft Store. More capabilities were added in<br />
2017, allowing developers to enhance their Win32 apps leveraging some of the new Windows 10 APIs,<br />
like live tiles and notifications on the action center. But still, no new UI controls.</p>
<p>At Build 2018, Microsoft announced a way for developers to use the new Windows 10 XAML controls<br />
into their current Win32 apps, without fully migrating their apps to UWP. It was branded as UWP<br />
XAML Islands.</p>
<h4><strong>How it works</strong></h4>
<p>The Windows 10 1903 update introduced several XAML hosting APIs. Two of them are<br />
WindowsXamlManager and DesktopWindowXamlSource.</p>
<p>35 CHAPTER 4 | Windows 10 migration</p>
<p>The WindowsXamlManager class handles the UWP XAML Framework. Its InitializeForCurrentThread<br />
method loads the UWP XAML Framework inside the current thread of the Win32 app.</p>
<p>The DesktopWindowXamlSource is the instance of your XAML Island content. It has the Content<br />
property, which you’re responsible for instantiating and setting. The DesktopWindowXamlSource<br />
renders and gets its input from an HWND. It needs to know to which other HWND it will attach the<br />
XAML Island’s one, and you’re responsible for sizing and positioning the parent’s HWND.</p>
<p>WPF or Windows Forms developers don’t usually deal with HWND inside their code, so it may be hard<br />
to understand and handle HWND pointers and the underlying wiring stuff to communicate Win32 and<br />
UWP worlds.</p>
<p><strong>The XAML Islands .NET Wrappers</strong></p>
<p>The Windows Community Toolkit has a set the XAML Islands .NET wrappers for WPF or Windows<br />
Forms that make easier to use XAML Islands. These wrappers manage the HWNDs, the focus<br />
management, among other things. Windows Forms and WPF developers should use these wrappers.</p>
<p>The Windows Community Toolkit offers two types of controls: Wrapped Controls and Hosting<br />
Controls.</p>
<p><strong>Wrapped Controls</strong></p>
<p>These wrapped controls wrap some UWP controls into Windows Forms or WPF controls, hiding UWP<br />
concepts for those developers. These controls are:</p>
<ul>
<li>
<p>WebView and WebViewCompatible</p>
</li>
<li>
<p>InkCanvas and InkToolbar</p>
</li>
<li>
<p>MediaPlayerElement</p>
</li>
<li>
<p>MapControl</p>
</li>
</ul>
<p>Add the Microsoft.Toolkit.Wpf.UI.Controls package to your project, include the reference to the<br />
namespace, and start using them.</p>
<p><strong>Hosting controls</strong></p>
<p>The power of XAML Islands extends to most first-party controls, third-party controls, and custom<br />
controls developed for UWP, which can be integrated into Windows Forms and WPF as “Islands” with<br />
fully functional UI. The WindowsXamlHost control for WPF and Windows Forms allows doing this.</p>
<p>36 CHAPTER 4 | Windows 10 migration</p>
<p>For example, to use the WindowsXamlHost control in WPF, add a reference to the<br />
Microsoft.Toolkit.Wpf.UI.XamlHost package provided by the Windows Community Toolkit.</p>
<p>Once you’ve placed your WindowsXamlHost into your UI code, specify which UWP type you want to<br />
load. You can choose to use a wrapped control like a Button or a more complex one composed of<br />
several different controls, which are a custom UWP control.</p>
<p>The following example shows how to add a UWP Button:</p>
<p>There’s a clear recommendation on how to approach this and it’s better to have one single and bigger<br />
XAML Island containing a custom composite control than to have several islands with one control on<br />
each.</p>
<p>One of the core features of XAML is binding and it works between your Win32 code and the island.<br />
So, you can bind, for instance, a Win32 Textbox with a UWP Textbox. One important thing to consider<br />
is that these bindings are one-way bindings, from UWP to Win32, so if you update the Textbox inside<br />
the XAML Island the Win32 Textbox will be updated, but not the other way around.</p>
<p>To see a walkthrough about how to use XAML Islands, see:</p>
<p><a href="https://docs.microsoft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml-islands">https://learn.microsoft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml-</a><br />
<a href="https://docs.microsoft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml-islands">islands</a></p>
<p><strong>Adding UWP XAML custom controls</strong></p>
<p>A XAML custom control is a control (or user control) created by you or by third parties (including<br />
WinUI 2.x controls). To host a custom UWP control in a Windows Forms or WPF app, you’ll need:</p>
<ul>
<li>
<p>To use the WindowsXamlHost UWP control in your .NET app.</p>
</li>
<li>
<p>To create a UWP app project that defines a XamlApplication object.</p>
</li>
</ul>
<p>Your WPF or Windows Forms project must have access to an instance of the<br />
Microsoft.Toolkit.Win32.UI.XamlHost.XamlApplication class provided by the Windows Community<br />
Toolkit. This object acts as a root metadata provider for loading metadata for custom UWP XAML<br />
types in assemblies in the current directory of your application. The recommended way to do this is to<br />
add a Blank App (Universal Windows) project to the same solution as your WPF or Windows Forms<br />
project and revise the default App class in this project.</p>
<p>The custom UWP XAML control can be included on this UWP app or in an independent UWP Class<br />
Library project that you reference in the same solution as your WPF or Windows Forms project.</p>
<p>You can check a detailed step-by-step process description at:</p>
<p><a href="https://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-islands">https://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-</a><br />
<a href="https://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-islands">islands</a></p>
<p>37 CHAPTER 4 | Windows 10 migration</p>
<p><strong>The Windows UI Library (WinUI 2)</strong></p>
<p>Besides the inbox Windows 10 controls that comes with the OS, the same UWP XAML team also<br />
delivers additional controls in the Windows UI Library ( <strong>WinUI 2</strong> ). WinUI 2 provides official native<br />
Microsoft UI controls and features for Windows UWP apps and these controls can be used inside of<br />
XAML Islands.</p>
<p><a href="https://github.com/microsoft/microsoft-ui-xaml">WinUI 2 is open source and you can find information at https://github.com/microsoft/microsoft-ui-</a><br />
<a href="https://github.com/microsoft/microsoft-ui-xaml">xaml.</a></p>
<p>The following article demonstrates how to host a UWP XAML control from the WinUI 2 library:<br />
<a href="https://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-islands">https://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-</a><br />
<a href="https://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-islands">islands</a></p>
<h4><strong>Do you need XAML Islands</strong></h4>
<p>XAML Islands are intended for existing Win32 apps that want to improve their user experience by<br />
leveraging new UWP controls and behaviors without a full rewrite of the app. You could already<br />
<a href="https://docs.microsoft.com/windows/uwp/porting/desktop-to-uwp-enhance">leverage Windows 10 and Windows 11 APIs, but up until XAML Islands, only non-UI related APIs.</a></p>
<p><a href="https://docs.microsoft.com/windows/uwp/get-started/universal-application-platform-guide">If you’re developing a new Windows App, a UWP App</a> is probably the right approach.</p>
<h4><strong>The road ahead XAML Islands: WinUI 3.0</strong></h4>
<p>Since Windows 8, the Windows UI platform, including the XAML UI framework, visual composition<br />
layer, and input processing has been shipped as an integral part of Windows. This means that to<br />
benefit from the latest improvements on UI technologies, you must upgrade to the latest version of<br />
the UI, slowing down the pace of innovation when you develop your apps. To decouple these two<br />
evolution cycles and foster innovation, Microsoft is actively working on the WinUI project.</p>
<p>Starting with WinUI 2 in 2018, Microsoft started shipping some new XAML UI controls and features as<br />
separate NuGet packages that build on top of the UWP SDK.</p>
<p>38 CHAPTER 4 | Windows 10 migration</p>
<p>WinUI 3 is under active development and will greatly expand the scope of WinUI to include the full UI<br />
platform, which will be fully decoupled from the UWP SDK:</p>
<p><a href="https://docs.microsoft.com/nuget/what-is-nuget">XAML framework will now be developed on GitHub and shipped out of band as NuGet packages.</a></p>
<p>The existing UWP XAML APIs that ship as part of the OS will no longer receive new feature updates.<br />
They will still receive security updates and critical fixes according to the Windows 10 support lifecycle.</p>
<p>The Universal Windows Platform contains more than just the XAML framework (for example,<br />
application and security model, media pipeline, Xbox and Windows 10 shell integrations, broad device<br />
support) and will continue to evolve. All new XAML features will just be developed and ship as part of<br />
WinUI instead.</p>
<p><strong>WinUI 3 in desktop app and WinUI XAML Islands</strong></p>
<p>As you can see, WinUI 3 is the evolution of UWP XAML and it works naturally within the UWP app<br />
model and all its requirements (MSIX packaged ID, sandbox, CoreWindow, and so on. To use just<br />
WinUI 3 in a Win32 app model, the WinUI content should be hosted by another UI Framework<br />
(Windows Forms, WPF, and so on) using <strong>WinUI XAML Islands</strong> . This is the right path if you want to</p>
<p>39 CHAPTER 4 | Windows 10 migration</p>
<p>evolve your app and mix technologies. However, if you want to replace your entire old UI for WinUI,<br />
your app shouldn’t load UI Frameworks for just hosting WinUI.</p>
<p>WinUI 3 will address this critical feedback adding <strong>WinUI in desktop apps</strong> . This will allow that Win32<br />
apps can use WinUI 3 as standalone UI Framework; no need to load Windows Forms or WPF.</p>
<p>Within this aggregation, WinUI 3 will let developers easily mix and match the right combination of:</p>
<ul>
<li>
<p>App model: UWP, Win32</p>
</li>
<li>
<p>Platform: .NET or Native</p>
</li>
<li>
<p>Language: .NET (C#, Visual Basic), standard C++</p>
</li>
<li>
<p>Packaging: MSIX, AppX for the Microsoft Store, unpackaged</p>
</li>
<li>
<p>Interop: use WinUI 3 to extend existing WPF, WinForms, and MFC apps using WinUI XAML<br />
Islands.</p>
</li>
</ul>
<p>If you want to know more details, Microsoft is sharing this roadmap in<br />
<a href="https://github.com/microsoft/microsoft-ui-xaml/blob/main/docs/roadmap.md">https://github.com/microsoft/microsoft-ui-xaml/blob/main/docs/roadmap.md.</a></p>
<p>40 CHAPTER 4 | Windows 10 migration</p>
<p><strong>CHAPTER</strong></p>
<h1>5</h1>
<h2>Example of migrating to the latest .NET</h2>
<p>In this chapter, we’ll show how to migrate your applications to the latest version of .NET. You can<br />
migrate to .NET 7 from .NET Framework, .NET Core, or .NET 5. We’ll introduce a tool that can do all the<br />
work for you in most cases. If your application has special cases or complicated dependencies, we’ll<br />
also show how to do the whole migration process by hand. Additionally, we’ll cover the most common<br />
issues and challenges you can face when migrating an existing application from .NET Framework to<br />
.NET.</p>
<h3>Migrating from .NET Core or .NET 5</h3>
<p>Updating your applications to target the latest version of .NET is easy if you already are on .NET Core<br />
or .NET 5. If this is the case, then in Visual Studio, simply right-click on your project in <strong>Solution</strong><br />
<strong>Explorer</strong> and choose <strong>Properties</strong> . Under <strong>Application</strong> - <strong>General</strong> - <strong>Target framework</strong>, choose .NET<br />
7.0. Save and rebuild your application. You’re done! Your app now runs on the latest version of .NET.<br />
In the future when new versions become available, you can upgrade in the same way.</p>
<p>41 CHAPTER 5 | Example of migrating to the latest .NET</p>
<h3>Migrating from .NET Framework</h3>
<p>Migrating from .NET Framework is a more complicated process because there are more differences<br />
between .NET Framework and other platforms that were built on top of .NET Core. But the good news<br />
is that there’s a tool that will do all the work for you in most cases.</p>
<h4><strong>Migrating with a tool</strong></h4>
<p><a href="https://dotnet.microsoft.com/platform/upgrade-assistant">The Upgrade Assistant</a> is a migration tool. Using it is easy and there are step-by-step instructions<br />
<a href="https://dotnet.microsoft.com/platform/upgrade-assistant/tutorial/intro">available on the .NET website. In this chapter, we’ll look at what is happening behind the scenes and</a><br />
how to port your application by hand. When the Upgrade Assistant is unable to migrate your<br />
application, you’ll learn the underlying mechanics so that you might be able to migrate manually.</p>
<h4><strong>Migrating by hand</strong></h4>
<p>The migration process consists of four sequential steps:</p>
<ol>
<li>
<p><strong>Preparation</strong> : Understand the dependencies the project has to have an idea of what’s ahead.<br />
In this step, you take the current project into a state that simplifies the startup point for the<br />
migration.</p>
</li>
<li>
<p><strong>Migrate Project File:</strong> .NET projects use the new SDK-style project format. Create a new<br />
project file with this format or update the one you have to use the SDK style.</p>
</li>
<li>
<p><strong>Fix code and build:</strong> Build the code in .NET addressing API-level differences between .NET<br />
Framework and .NET. If needed, update third-party packages to the ones that support .NET.</p>
</li>
</ol>
<p>42 CHAPTER 5 | Example of migrating to the latest .NET</p>
<ol start="4">
<li><strong>Run and test:</strong> There might be differences that don’t show up until run time. So, don’t forget<br />
to run the application and test that everything works as expected.</li>
</ol>
<h4><strong>Preparation</strong></h4>
<p><strong>Migrate packages.config file</strong></p>
<p>In a .NET Framework application, all references to external packages are declared in the<br />
<em>packages.config</em> file. In .NET, there’s no longer the need to use the <em>packages.config</em> file. Instead, use the<br />
<a href="https://docs.microsoft.com/dotnet/core/project-sdk/msbuild-props#packagereference">PackageReference</a> property inside the project file to specify the NuGet packages for your app.</p>
<p>So, you need to transition from one format to another. You can do the update manually, taking the<br />
dependencies contained in the <em>packages.config</em> file and migrating them to the project file with the<br />
PackageReference format. Or, you can let Visual Studio do the work for you: right-click on the<br />
<em>packages.config</em> file and select the <strong>Migrate packages.config to PackageReference</strong> option.</p>
<p><strong>Verify every dependency compatibility in .NET</strong></p>
<p>Once you’ve migrated the package references, you must check each reference for compatibility. You<br />
<a href="https://www.nuget.org/">can explore the dependencies of each NuGet package your application is using on nuget.org. If the</a><br />
<a href="https://docs.microsoft.com/dotnet/standard/net-standard#net-implementation-support">package has .NET Standard dependencies, then it’s going to work on .NET 7 because .NET supports</a> all<br />
versions of .NET Standard. The following image shows the dependencies for the Castle.Windsor<br />
package:</p>
<p><a href="https://fuget.org/">To check the package compatibility, you can use the tool https://fuget.org</a> that offers a more detailed<br />
information about versions and dependencies.</p>
<p>Maybe the project is referencing older package versions that don’t support .NET, but you might find<br />
newer versions that do support it. So, updating packages to newer versions is generally a good</p>
<p>43 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p>recommendation. However, you should consider that updating the package version can introduce<br />
some breaking changes that would force you to update your code.</p>
<p>What happens if you don’t find a compatible version? What if you just don’t want to update the<br />
version of a package because of these breaking changes? Don’t worry because it’s possible to depend<br />
on .NET Framework packages from a .NET application. Don’t forget to test it extensively because it can<br />
cause run-time errors if the external package calls an API that isn’t available on .NET. This is great for<br />
when you’re using an old package that isn’t going to be updated and you can just retarget to work on<br />
.NET.</p>
<p><strong>Check for API compatibility</strong></p>
<p>Since the API surface in .NET Framework and .NET is similar but not identical, you must check which<br />
APIs are available on .NET and which aren’t. You can use the .NET Portability Analyzer tool to surface<br />
APIs used that aren’t present on .NET. It looks at the binary level of your app, extracts all the APIs that<br />
are called, and then lists which APIs aren’t available on your target framework (.NET 7 in this case).</p>
<p>You can find more information about this tool at:</p>
<p><a href="https://docs.microsoft.com/dotnet/standard/analyzers/portability-analyzer">https://learn.microsoft.com/dotnet/standard/analyzers/portability-analyzer</a></p>
<p>An interesting aspect of this tool is that it only surfaces the differences from your own code and not<br />
code from external packages, which you can’t change. Remember you should have updated most of<br />
these packages to make them work with .NET.</p>
<p><strong>Migrate</strong></p>
<ol>
<li>Create the new .NET project</li>
</ol>
<p>In most cases, you’ll want to update your existing project to the new .NET format. However, you can<br />
also create a new project while maintaining the old one. The main drawback from updating the old<br />
project is that you lose designer support, which may be important to you and your development<br />
team. If you want to keep using the designer, you must create a new .NET project in parallel with the<br />
old one and share assets. If you need to modify UI elements in the designer, you can switch to the old<br />
project to do that. And since assets are linked, they’ll be updated in the .NET project as well.</p>
<p><a href="https://docs.microsoft.com/dotnet/core/project-sdk/msbuild-props">The SDK-style project</a> for .NET is a lot simpler than .NET Framework’s project format. Apart from the<br />
previously mentioned PackageReference entries, you won’t need to do much more. The new project<br />
<a href="https://docs.microsoft.com/dotnet/core/project-sdk/overview#default-includes-and-excludes">format includes files with certain extensions by default, such as .cs and .xaml files, without the need to</a><br />
explicitly include them in the project file.</p>
<p><strong>AssemblyInfo considerations</strong></p>
<p>Attributes are autogenerated on .NET projects. If the project contains an <em>AssemblyInfo.cs</em> file, the<br />
definitions will be duplicated, which will cause compilation conflicts. You can delete the older<br />
<em>AssemblyInfo.cs</em> file or disable autogeneration by adding the following entry to the .NET project file:</p>
<p>44 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p><strong>Resources</strong></p>
<p>Embedded resources are included automatically but resources aren’t, so you need to migrate the<br />
resources to the new project file.</p>
<p><strong>Package references</strong></p>
<p>With the <strong>Migrate packages.config to PackageReference</strong> option, you can easily move your external<br />
package references to the new format as previously mentioned.</p>
<p><strong>Update package references</strong></p>
<p>Update the versions of the packages you’ve found to be compatible, as shown in the previous section.</p>
<h4><strong>Fix the code and build</strong></h4>
<p><strong>Microsoft.Windows.Compatibility</strong></p>
<p>If your application depends on APIs that aren’t available on .NET, such as Registry or ACLs, you have<br />
to include a reference to the Microsoft.Windows.Compatibility package to add these Windowsspecific APIs. They work on .NET but aren’t included as they aren’t cross-platform.</p>
<p>There’s a tool called Platform compatibility analyzer<br />
<a href="https://docs.microsoft.com/dotnet/standard/analyzers/platform-compat-analyzer">(https://learn.microsoft.com/dotnet/standard/analyzers/platform-compat-analyzer) that helps you</a><br />
identify APIs that aren’t compatible with your code.</p>
<p><strong>Use #if directives</strong></p>
<p>If you need different execution paths when targeting .NET Framework and .NET, you should use<br />
compilation constants. Add some #if directives to your code to keep the same codebase for both<br />
targets.</p>
<p><strong>Technologies not available on .NET</strong></p>
<p>Some technologies aren’t available on .NET, such as:</p>
<ul>
<li>
<p>AppDomains</p>
</li>
<li>
<p>Remoting</p>
</li>
<li>
<p>Code Access Security</p>
</li>
<li>
<p>Windows Workflow</p>
</li>
</ul>
<p>That’s why you need to find a replacement for these technologies if you’re using them in your<br />
<a href="https://docs.microsoft.com/dotnet/core/porting/net-framework-tech-unavailable">application. For more information, see the .NET Framework technologies unavailable on .NET Core and</a><br />
<a href="https://docs.microsoft.com/dotnet/core/porting/net-framework-tech-unavailable">.NET 5+</a> article.</p>
<p>45 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p><strong>Regenerate autogenerated clients</strong></p>
<p>If your application uses autogenerated code, such as a WCF client, you may need to regenerate this<br />
code to target .NET. Sometimes, you can find some missing references since they may not be included<br />
<a href="https://apisof.net/">as part of the default .NET assemblies set. Using a tool like https://apisof.net/, you can easily locate</a><br />
the assembly the missing reference lives in and add it from NuGet.</p>
<p><strong>Rolling back package versions</strong></p>
<p>As a general rule, we’ve previously stated that you better update every single package version to be<br />
compatible with .NET. However, you can find that targeting an updated and compatible version of an<br />
assembly just doesn’t pay off. If the cost of change isn’t acceptable, you can consider rolling back<br />
package versions keeping the ones you use on .NET Framework. Although they may not be targeting<br />
.NET, they should work well unless they call some unsupported APIs.</p>
<h4><strong>Run and test</strong></h4>
<p>Once you have your application building with no errors, you can start the last step of the migration by<br />
testing every functionality.</p>
<p>In this final step, you can find several different issues depending on the complexity of your application<br />
and the dependencies and APIs you’re using.</p>
<p>For example, if you use configuration files ( <em>app.config</em> ), you may find some errors at run time like<br />
Configuration Sections not present. Using the Microsoft.Extensions.Configuration NuGet package<br />
should fix that error.</p>
<p>Another reason for errors is the use of the BeginInvoke and EndInvoke methods because they aren’t<br />
supported on .NET. They aren’t supported on .NET because they have a dependency on Remoting,<br />
which doesn’t exist on .NET. To solve this issue, try to use the await keyword (when available) or the<br />
<a href="https://docs.microsoft.com/dotnet/api/system.threading.tasks.task.run">Task.Run</a> method.</p>
<p>You can use compatibility analyzers to let you identify APIs and code patterns in your code that can<br />
<a href="https://github.com/dotnet/platform-compat">potentially cause problems at run time with .NET. Go to https://github.com/dotnet/platform-compat</a><br />
and use the .NET API analyzer on your project.</p>
<h3>Migrating a Windows Forms application</h3>
<p>To showcase a complete migration process of a Windows Forms application, we’ve chosen to migrate<br />
the eShop sample application available at https://github.com/dotnet<a href="https://github.com/dotnet-architecture/eShopModernizing/tree/master/eShopLegacyNTier/src/eShopWinForms">architecture/eShopModernizing/tree/master/eShopLegacyNTier/src/eShopWinForms. You can find</a><br />
the complete result of the migration at https://github.com/dotnet<a href="https://github.com/dotnet-architecture/eShopModernizing/tree/master/eShopModernizedNTier/src/eShopWinForms">architecture/eShopModernizing/tree/master/eShopModernizedNTier/src/eShopWinForms.</a></p>
<p>This application shows a product catalog and allows the user to navigate, filter, and search for<br />
products. From an architecture point of view, the app relies on an external WCF service that serves as<br />
a façade to a back-end database.</p>
<p>You can see the main application window in the following picture:</p>
<p>46 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p>If you open the <em>.csproj</em> project file, you can see something like this:</p>
<p>As previously mentioned, a .NET project has a more compact style and you need to migrate the<br />
project structure to the new .NET SDK style.</p>
<p>In Solution Explorer, right-click on the Windows Forms project and select <strong>Unload Project</strong> - <strong>Edit</strong> .</p>
<p>Now you can update the .csproj file. You’ll delete the entire contents and replace it with the following<br />
code:</p>
<p>47 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p>Save and reload the project. You’re now done updating the project file and the project is targeting<br />
.NET 7.</p>
<p>If you compile the project at this point, you’ll find some errors related to the WCF client reference.<br />
Since this code is autogenerated, you must regenerate it to target .NET.</p>
<p>Delete the <em>Reference.cs</em> file and generate a new Service Client.</p>
<p>Right-click on <strong>Connected Services</strong> and select the <strong>Add Connected Service</strong> option.</p>
<p>The Connected Services window opens. Select the <strong>Microsoft WCF Web Service</strong> option.</p>
<p>48 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p>If you have the WCF Service in the same solution as we have in this example, you can select the<br />
<strong>Discover</strong> option instead of specifying a service URL.</p>
<p>Once the service is located, the tool reflects the API contract implemented by the service. Change the<br />
name of the namespace to be eShopServiceReference as shown in the following image:</p>
<p>49 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p>Select the <strong>Finish</strong> button. After a while, you’ll see the generated code.</p>
<p>You should see three autogenerated files:</p>
<ol>
<li>
<p><em>Getting Started</em> : a link to GitHub to provide some information on WCF.</p>
</li>
<li>
<p><em>ConnectedService.json</em> : configuration parameters to connect to the service.</p>
</li>
<li>
<p><em>Reference.cs</em> : the actual WCF client code.</p>
</li>
</ol>
<p>50 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p>If you compile again, you’ll see many errors coming from <em>.cs</em> files inside the <em>Helper</em> folder. This folder<br />
was present in the .NET Framework version but not included in the old <em>.csproj</em> . But with the new SDKstyle project, every code file present underneath the project file location is included by default. That is,<br />
the new .NET Core project tries to compile the files inside the <em>Helper</em> folder. Since that folder isn’t<br />
needed, you can safely delete it.</p>
<p>If you compile the project again and execute it, you won’t see the product images. The problem is that<br />
now the path to the files has slightly changed. To fix this issue, you need to add another level of depth<br />
in the path, updating in the file CatalogView.cs the line:</p>
<p>51 CHAPTER 5 | Example of migrating to the latest .NET</p>
<pre><code>string image_name = Environment.CurrentDirectory +
&quot;\\..\\..\\Assets\\Images\\Catalog\\&quot; + catalogItems.Picturefilename;

</code></pre>
<p>to</p>
<pre><code>string image_name = Environment.CurrentDirectory +
&quot;\\..\\..\\..\\Assets\\Images\\Catalog\\&quot; + catalogItems.Picturefilename;

</code></pre>
<p>After this change, you can check that the application launches and runs as expected on .NET 7.</p>
<h3>Migrating a WPF application</h3>
<p>We’ll use the Shop.ClassicWPF sample application to perform the migration. The following image<br />
shows a screenshot of the app before migration:</p>
<p>This application uses a local SQL Server Express database to hold the product catalog information.<br />
This database is accessed directly from the WPF application.</p>
<p>First, you must update the <em>.csproj</em> file to the new SDK style used by .NET Core applications. You’ll<br />
follow the same steps described in the Windows Forms migration: you’ll unload the project, open the<br />
<em>.csproj</em> file, update its contents, and reload the project.</p>
<p>In this case, delete all the content of the <em>.csproj</em> file and replace it with the following code:</p>
<p>52 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p>If you reload the project and compile it, you’ll get the following error:</p>
<p>Since you’ve deleted all the <em>.csproj</em> contents, you’ve lost a project reference specification present in the<br />
old project. You just need to add this line to the <em>.csproj</em> file to include the project reference back:</p>
<p>You can also let Visual Studio help you by right-clicking on the <strong>Dependencies</strong> node and selecting<br />
<strong>Add Project Reference</strong> . Select the project from the solution and select <strong>OK</strong> :</p>
<p>53 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p>Once you add the missing project reference, the application compiles and runs as expected on .NET.</p>
<p>54 CHAPTER 5 | Example of migrating to the latest .NET</p>
<p><strong>CHAPTER</strong></p>
<h1>6</h1>
<h2>Deploying Modern Desktop Applications</h2>
<p>When you develop desktop applications, one thing to consider is how your application is going to be<br />
packaged and deployed to the users’ machines. The problem with packaging, deployment, and<br />
installation is that it usually falls under the umbrella of the IT professionals, who care about different<br />
things than developers.</p>
<p>These days, we’re all familiar with the DevOps concept, where developers and IT Pros work closely to<br />
move applications to their production environments. But if you’ve been in the desktop battle for more<br />
than 10 years, you might have seen the following story. A team of developers works together hard to<br />
meet the project deadlines. Business people are nervous since they need the system working on many<br />
users’ machines to run the company. On “D-Day”, the project manager checks with every developer<br />
that their code is working well and that everything is fine, so they can ship. Then, the package team<br />
comes in generating the setup for the app, distribute it to every user machine and a set of test users<br />
run the application. Well, they try, because before showing any UI, the application throws an<br />
exception that says “Method ~ of object ~ failed”. Panic starts flowing through the air and a brief<br />
investigation points to a young and tired developer that has introduced a third-party control, that<br />
certainly “worked on the dev machine”.</p>
<p>Installing desktop applications have traditionally been a nightmare for two main reasons:</p>
<ul>
<li>
<p>Lack of close collaboration culture between dev and IT teams.</p>
</li>
<li>
<p>Lack of a solid packaging and deploying technology we can build upon.</p>
</li>
</ul>
<p>In fact, we’ve been living with the fact that sometimes you regret that you installed an app because:</p>
<ul>
<li>
<p>It ends up having some undesired side effects on your machine.</p>
</li>
<li>
<p>Some applications that were previously installed stop working.</p>
</li>
</ul>
<p>Additionally, you can’t just restore the system to its original state by uninstalling the app. We’re so<br />
used to living with this situation that we’ve coined terms like “DLL Hell” or “Winrot”.</p>
<p>In this chapter, we’ll talk about MSIX. MSIX is the new technology from Microsoft that tries to capture<br />
the best of previous technologies to provide a solid foundation for the packaging technology of the<br />
future.</p>
<p>What does a packaging technology have to do with modernization? Well, it turns out that packaging<br />
is fundamental for the enterprise IT with lots of money invested there. Modernization isn’t only related</p>
<p>55 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>to using the latest technologies. It’s also related to reducing time to market from the moment a<br />
business requirement is defined until your company delivers the feature to your client.</p>
<h3>The modern application lifecycle</h3>
<p>Today, developers write and build the code for an app and then pass the generated assets to the IT<br />
Pros. Then, the IT Pros reconfigure the app and repackage it, typically in an MSI or more recently in an<br />
App-V packaging format. The app is then deployed through different channels and tools. One of the<br />
main problems with this approach is commonly known as “packaging paralysis”. The problem is that<br />
this cycle repeats every time there’s an app update or an OS update.</p>
<p>You can see the process reflected on the following picture:</p>
<p>Companies need a way to break this packaging cycle into three independent cycles:</p>
<ul>
<li>
<p>OS updates</p>
</li>
<li>
<p>Application updates</p>
</li>
<li>
<p>Customization</p>
</li>
</ul>
<p>56 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>The previous diagram shows that you can:</p>
<ul>
<li>
<p>Update the underlying OS without having to repackage your apps.</p>
</li>
<li>
<p>Enable customizations from IT without the need to repackage the original developer package.</p>
</li>
</ul>
<p>This radical change leads us to the new and modern IT lifecycle as shown in the following picture:</p>
<p>57 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>Developers create the app and generate an MSIX package that IT Pros can consume and configure<br />
without the need of repackaging. Along with the MSIX technology, Microsoft has created tools to<br />
allow IT to customize and configure packages without repackaging.</p>
<h3>MSIX: The next generation of deployment</h3>
<p>Before MSIX, there were several packaging technologies available like setup wizards, MSI, ClickOnce,<br />
App-V, and scripting. Each of these technologies has their own strengths and Microsoft has decided<br />
to pick the best of all to build MSIX. MSIX is built on the foundations of these existing technologies<br />
picking the best of each:</p>
<ul>
<li>
<p>App-V =&gt; Containerization</p>
</li>
<li>
<p>ClickOnce =&gt; Auto updating</p>
</li>
<li>
<p>MSI =&gt; Easy to distribute</p>
</li>
</ul>
<p>With MSIX, you get one installer technology with all these features.</p>
<p>58 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<h4><strong>Benefits of MSIX</strong></h4>
<p><strong>Never regret installing an app</strong></p>
<p>MSIX provides a predictable, reliable, and safe deployment. The declarative method contained in the<br />
package manifest lets the OS keep track of every asset your application needs. It also provides a true<br />
clean uninstall with no side effects.</p>
<p><strong>Disk space optimization</strong></p>
<p>MSIX is optimized to reduce the footprint that an application has on the user’s machine disk space. It<br />
creates a single instance storage of your files. That is, if you have two different packages with the<br />
same DLL, the DLL isn’t installed twice. The platform takes care of that problem because it knows all<br />
the files that a particular app installed thanks to its declarative nature. It also allows you to have<br />
different versions of a DLL working side by side.</p>
<p>With the use of resource packages, you can easily create multilingual apps and the OS takes care of<br />
installing the ones that are used.</p>
<p><strong>Network optimization</strong></p>
<p>MSIX detects the differences on the files at the byte block level enabling a feature called differential<br />
updates. What this means is that only the updated byte blocks are downloaded on application<br />
updates.</p>
<p>59 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>With streaming installation, the user can quickly start working on your application while other parts of<br />
the app are downloaded on the background. This feature contributes to an engaging experience for<br />
your users.</p>
<p>With the optional packages feature, you achieve componentization on your app deployment, so you<br />
can download them when needed.</p>
<p><strong>Simple packaging and deployment</strong></p>
<p>The AppManifest declares the versioning, device targeting and identity in a standard way for every<br />
application. It also provides a way to sign your assets providing a solid security foundation.</p>
<p><strong>OS managed</strong></p>
<p>The OS handles all the processes for installing, updating, and removing an application. Applications<br />
are installed per user but downloaded only once, minimizing the disk footprint. Microsoft is working<br />
on providing the MSIX experience also on Windows 7.</p>
<p><strong>Windows provides integrity for the app</strong></p>
<p>With the use of digital signatures, you can guarantee that you don’t install an application from<br />
untrusted sources. MSIX also prevents tampering because:</p>
<ul>
<li>
<p>It keeps a record of file hashes.</p>
</li>
<li>
<p>It detects if a file has been modified after installation.</p>
</li>
</ul>
<p>60 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p><strong>Works for the entire App Catalog</strong></p>
<p>One of the coolest things about MSIX is that it works for the entire application catalog, Windows<br />
Forms, WPF, MFC/ATL, Delphi, even if you want to do xCopy deployment, ClickOnce, or going to the<br />
Store, you can use the same MSIX package.</p>
<h4><strong>Tools</strong></h4>
<p><strong>Windows Application Packaging Project</strong></p>
<p>You can use the <strong>Windows Application Packaging Project</strong> project in Visual Studio to generate a<br />
package for your desktop app. Then, you can publish that package to the Microsoft Store or sideload<br />
it onto one or more PCs.</p>
<p><strong>MSIX Packaging Tool</strong></p>
<p>The MSIX Packaging Tool enables you to repackage your existing Win32 applications to the MSIX<br />
format. It offers both an interactive UI and a command line for conversions and gives you the ability to<br />
convert an application without having the source code.</p>
<p>61 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p><strong>Package Support Framework</strong></p>
<p>The Package Support Framework is an open-source kit that helps you apply fixes to your existing<br />
Win32 application when you don’t have access to the source code, so that it can run in an MSIX<br />
container. The Package Support Framework helps your application follow the best practices of the<br />
modern runtime environment.</p>
<p><strong>App Installer</strong></p>
<p>App Installer allows Windows 10 and Windows 11 apps to be installed by double-clicking the app<br />
package. This means that users don’t need to use PowerShell or other developer tools to deploy<br />
Windows 10/Windows 11 apps. The App Installer can also install an app from the web, optional<br />
packages, and related sets.</p>
<h3>How to create an MSIX package from an existing Win32 desktop application</h3>
<p>Let’s go through the process to create an MSIX package from an existing Win32 application. In this<br />
example, we’ll use a Windows Forms app.</p>
<p>62 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>To start, add a new project to your solution, select the Windows Application Packaging Project, and<br />
give it a name.</p>
<p>You’ll see the structure of the packaging project and note a special folder called <em>Applications</em> . Inside<br />
this folder, you can specify which applications you want to include in the package. It can be more than<br />
one.</p>
<p>63 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>Right-click on the <em>Applications</em> folder and select the Windows Forms project you want to package<br />
from the Visual Studio solution.</p>
<p>64 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>At this point, you can compile and generate the package but let’s examine a couple of things. To have<br />
a better user experience, Visual Studio can autogenerate all the visual assets a modern application<br />
needs to handle icons and tile assets for the tile bar and start menu. Open the <em>Package.appxmanifest</em><br />
file to access the Manifest Designer. You can then generate all the visual assets from a given image<br />
present on your project just by clicking <strong>Create</strong> .</p>
<p>If you open the code for the <em>Package.appxmanifest</em> file, you can see a couple of interesting things.</p>
<p>Right under <Package>, there’s an <Identity> node. This is where your packaged application is going<br />
to get its identity, which will be managed by the OS.</p>
<p>65 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>In the <Capabilities> node, you can find all the requirements the application needs, paying special<br />
attention to the &lt;rescap:Capability Name=&quot;runFullTrust&quot; &gt;, which tells the OS to run the app in full<br />
trust mode since it’s a Win32 application.</p>
<p>66 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>Set the packaging project as the startup project for the solution and select <em>Run</em> . This is going to:</p>
<ul>
<li>
<p>Compile the Windows Forms application.</p>
</li>
<li>
<p>Create an MSIX package out of the build results.</p>
</li>
<li>
<p>Deploy the packages.</p>
</li>
<li>
<p>Install it locally on the development machine.</p>
</li>
<li>
<p>Launch the app.</p>
</li>
</ul>
<p>67 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>With this, you have the clean install and uninstall experience that MSIX provides fully integrated into<br />
Windows 10/Windows 11.</p>
<p>The final stage is about how you deploy the MSIX package to another machine.</p>
<p>Right-click on the packaging project, select the <strong>Store</strong> menu, and then select the <strong>Create App</strong><br />
<strong>Packages</strong> option.</p>
<p>Then, you can choose between creating a package to upload to the store or creating packages for<br />
sideloading. In most modernization scenarios, you’ll choose <strong>I want to create packages for</strong><br />
<strong>sideloading</strong> .</p>
<p>68 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>There you can select the different architectures you want to target as you can include as many as you<br />
want into the same MSIX package.</p>
<p>The final step is to declare where you want to deploy the final installation assets.</p>
<p>69 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>You can choose to use a web server or a shared UNC path on your enterprise file servers. Pay<br />
attention to the settings to specify how you want to update your application. We’ll cover application<br />
updates in the next section.</p>
<p><a href="https://docs.microsoft.com/windows/msix/desktop/desktop-to-uwp-packaging-dot-net">For a detailed step-by-step guide, see Package a desktop app from source code using Visual Studio.</a></p>
<h3>Auto Updates in MSIX</h3>
<p>The Windows Store has a great updating mechanism using Windows Update. In most enterprise<br />
scenarios, you don’t use the Store to distribute your desktop apps. So, you need a similar way to<br />
configure updates for your application and pull them to your users.</p>
<p>Using a combination of Windows 10/Windows 11 features and MSIX packages, you can provide a<br />
great updating experience for your users. In fact, the user doesn’t need to be technical at all but still<br />
benefits from a seamless application update experience.</p>
<p>You can configure your updates to interact with the user in two different ways:</p>
<p>70 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<ul>
<li>
<p>User prompted updates: The OS shows some autogenerated nice UI to notify the user about<br />
the application it’s about to install. It builds this UI based on the properties you specify on<br />
your installation files.</p>
</li>
<li>
<p>Silent updates in the background. With this option, your users don’t need to be aware of the<br />
updates.</p>
</li>
</ul>
<p>You can also configure when you want to perform updates: either when the application launches or<br />
on a regular basis. Thanks to the side-loading features, you can even get these updates while the<br />
application is running.</p>
<p>When you use this type of deployment, a special file is created called <em>.appinstaller</em> . This simple file<br />
contains the following sections:</p>
<ul>
<li>
<p>The location of the <em>.appinstaller</em> file</p>
</li>
<li>
<p>The application’s main MSIX package properties</p>
</li>
<li>
<p>The update behavior</p>
</li>
</ul>
<p>In combination with this file, Microsoft has designed a special URL protocol to launch the installation<br />
process from a link:</p>
<pre><code>&lt; a href=&quot;ms-appinstaller:?source=http://mywebservice.azureedge.net/MyApp.msix&quot;&gt;Install
app package &lt;/ a &gt;

</code></pre>
<p>This protocol works on all browsers and launches the installation process with a great user experience<br />
on Windows 10/Windows 11. Since the OS manages the installation process, it’s aware of the location<br />
this application was installed from and tracks all the files affected by the process.</p>
<p>MSIX creates a user interface for installation automatically showing some properties of the package.<br />
This allows for a common installation experience for every app.</p>
<p>71 CHAPTER 6 | Deploying Modern Desktop Applications</p>
<p>Once you’ve generated the new MSIX package and moved it to the deployment server, you just have<br />
to edit the <em>.appinstaller</em> file to reflect these changes: mainly the version and the path to the new MSIX<br />
file. The next time the user launches the application, the system will detect the change and download<br />
the files for the new version in the background. When the download is finished, installation will<br />
execute transparently for your user on new application launch.</p>
<p>72 CHAPTER 6 | Deploying Modern Desktop Applications</p>
