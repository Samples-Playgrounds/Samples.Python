"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\fEDITION v1.0.3 - Updated to .NET 7 \\n\\n\", \"Refer to the changelog for the book updates and community contributions. \\n\\nPUBLISHED BY \\n\\nMicrosoft \", \"Developer Division, .NET, and Visual Studio product teams \\n\\nA division of Microsoft Corporation \\n\\nOn\", \"e Microsoft Way \\n\\nRedmond, Washington 98052-6399 \\n\\nCopyright \\u00a9 2022 by Microsoft Corporation \\n\\nAll r\", \"ights reserved. No part of the contents of this book may be reproduced or transmitted in any \\nform o\", \"r by any means without the written permission of the publisher. \\n\\nThis book is provided \\u201cas-is\\u201d and \", \"expresses the author\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in this b\", \"ook, including URL and other Internet website references, may change \\nwithout notice. \\n\\nSome example\", \"s depicted herein are provided for illustration only and are fictitious. No real association \\nor con\", \"nection is intended or should be inferred. \\n\\nMicrosoft and the trademarks listed at https://www.micr\", \"osoft.com on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies. \\n\\nMac and\", \" macOS are trademarks of Apple Inc. \\n\\nAll other marks and logos are property of their respective own\", \"ers. \\n\\nCo-Authors: \\n\\nOlia Gavrysh, Program Manager, .NET team, Microsoft \\n\\nMiguel Angel Castej\\u00f3n Dom\", \"inguez, Innovation Architect, Kabel \\n\\nParticipants and reviewers: \\n\\nMaira Wenzel, Senior Program Man\", \"ager, .NET team, Microsoft \\n\\nAndy De Gorge, Senior Content Developer, .NET docs team, Microsoft \\n\\nMi\", \"guel Ramos, Senior Program Manager, Windows Developer Platform team, Microsoft \\n\\nAdam Braden, Princi\", \"pal Program Manager, Windows Developer Platform team, Microsoft \\n\\nRicardo Minguez Pablos, Senior Pro\", \"gram Manager, Azure IoT team, Microsoft \\n\\nNish Anil, Senior Program Manager, .NET team, Microsoft \\n\\n\", \"Beth Massi, Senior Product Marketing Manager, Microsoft \\n\\nScott Hunter, Partner Director Program Man\", \"ager, .NET team, Microsoft \\n\\nMarta Fuentes Lara, Kabel \\n\\n \\n\\fRa\\u00fal Fern\\u00e1ndez de C\\u00f3rdoba, Kabel \\n\\nAnton\", \"io Manuel Fern\\u00e1ndez Cantos, Kabel \\n\\nIntroduction \\n\\nThis book is about strategies you can adopt to mo\", \"ve your existing desktop applications through the \\npath of modernization and incorporate the latest \", \"runtime, language, and platform features. You\\u2019ll \\ndiscover that there\\u2019s no unique recipe as each app\", \"lication is different, and so are your requirements \\nand preferences. The good news is that there ar\", \"e common approaches you can apply to add new \\nfeatures and capabilities to your applications. Some o\", \"f them won\\u2019t even require major modifications \\nof your code. In this book, we\\u2019ll reveal how all thos\", \"e features work behind the scenes and explain the \\nmechanics of their implementations. Moreover, you\", \"\\u2019ll find some common scenarios for modernizing \\nexisting desktop applications shown in detail so you\", \" can find inspiration for evolving your projects. \\n\\nMicrosoft\\u2019s approach to modernizing existing app\", \"lications is to give you the flexibility to create your \\nown customized path. All the modernization \", \"strategies described in this book are mostly independent. \\nYou can choose ones that are relevant for\", \" your application and skip others that aren\\u2019t important for \\nyou. In other words, you can mix and ma\", \"tch the strategies to best address your application needs. \\n\\nWho should use the book \\n\\nThis book for\", \" developers and solution architects who want to modernize existing Windows Forms and \\nWPF desktop ap\", \"plications to leverage the benefits of .NET and Windows 10. \\n\\nYou might also find this book useful i\", \"f you\\u2019re a technical decision maker, such as an enterprise \\narchitect or a development lead or direc\", \"tor who wants an overview of the benefits of updating \\nexisting desktop applications. \\n\\nHow to use t\", \"he book \\n\\nThis book addresses the \\u201cwhy\\u201d\\u2014why you might want to modernize your existing applications, \", \"and the \\nspecific benefits you get from using NET and MSIX to modernize your desktop apps. The conte\", \"nt of \\nthe book is designed for architects and technical decision makers who want an overview, but w\", \"ho \\ndon\\u2019t need to focus on implementation and technical, step-by-step details. \\n\\nAlong the different\", \" chapters, sample implementation code snippets and screenshots are provided, \\nwith chapter 5 devoted\", \" to showcase a complete migration process for sample applications. \\n\\nWhat this book doesn\\u2019t cover \\n\\n\", \"This book covers a specific subset of scenarios that are focused on lift-and-shift scenarios, outlin\", \"ing \\nthe way to gain the benefits of modernizing without the effort of rewriting code. \\n\\nThis book i\", \"sn\\u2019t about developing modern applications with .NET from scratch or about getting started \\nwith Wind\", \"ows Forms and WPF. It focuses on how you can update existing desktop applications with \\nthe latest t\", \"echnologies for desktop development. \\n\\n \\n\\fSamples used in this book \\n\\nTo highlight the necessary ste\", \"ps to perform a modernization, we\\u2019ll be using a sample application \\ncalled eShopModernizing. This ap\", \"plication has two flavors, Windows Forms and WPF, and we\\u2019ll show a \\nstep-by-step process on how to p\", \"erform the modernization on both of them to .NET. \\n\\nAlso, on the GitHub repository for this book, yo\", \"u\\u2019ll find the results of the process, which you can \\nconsult with if you decide to follow the step-b\", \"y-step tutorial. \\n\\n \\n\\fContents \\n\\nWhy modern desktop applications ...................................\", \".................................................... 1 \\n\\nIntroduction ..............................\", \"....................................................................................................\", \"............................................. 1 \\n\\nA story of one company ...........................\", \"....................................................................................................\", \".................... 1 \\n\\nYour story ................................................................\", \"....................................................................................................\", \"........... 1 \\n\\nDesktop applications nowadays ......................................................\", \".................................................................................. 1 \\n\\nWindows Forms\", \" ...................................................................................................\", \"................................................................ 3 \\n\\nWPF ...........................\", \"....................................................................................................\", \"............................................................ 4 \\n\\nUWP ...............................\", \"....................................................................................................\", \"....................................................... 4 \\n\\nA tale of two platforms ................\", \"....................................................................................................\", \"...................................... 5 \\n\\nPaths to modernization ..................................\", \"....................................................................................................\", \"................... 8 \\n\\nModern features ............................................................\", \"....................................................................................................\", \".. 8 \\n\\nDeployment ..................................................................................\", \"......................................................................................... 8 \\n\\nInstal\", \"lation..............................................................................................\", \"................................................................................ 8 \\n\\nWhat\\u2019s new with\", \" .NET for Desktop? .................................................................................\", \"..... 9 \\n\\nThe motivation behind .NET Core ..........................................................\", \"........................................................................... 9 \\n\\nIntroduction to .NET\", \" Core ..............................................................................................\", \"................................................... 11 \\n\\n.NET 5+ is .NET Core vNext ................\", \"....................................................................................................\", \"........................... 11 \\n\\n.NET Framework vs. .NET ...........................................\", \"....................................................................................................\", \"..... 12 \\n\\n.NET Standard vs. PCL ...................................................................\", \"...................................................................................... 13 \\n\\nNew Desk\", \"top features in .NET ...............................................................................\", \".......................................................... 14 \\n\\nSupport for Windows Forms and WPF ..\", \"....................................................................................................\", \".............. 14 \\n\\nXAML Islands ...................................................................\", \"................................................................................................... \", \"14 \\n\\nAccess to all Windows 10 and Windows 11 APIs ..................................................\", \".............................................. 15 \\n\\nSide-by-side support and self-contained EXEs ...\", \"................................................................................................. 15\", \" \\n\\nPerformance .....................................................................................\", \".................................................................................. 15 \\n\\nMigrating Mo\", \"dern Desktop applications ..........................................................................\", \".. 16 \\n\\nConfiguration files ........................................................................\", \"........................................................................................ 16 \\n\\nConfig\", \"uration on .NET Framework ..........................................................................\", \".................................................. 16 \\n\\ni \\n\\nContents \\n\\n \\n \\n\\fConfiguration on .NET ..\", \"....................................................................................................\", \".............................................. 17 \\n\\nMigrating configuration files ..................\", \"....................................................................................................\", \"................. 17 \\n\\nAccessing databases .........................................................\", \"................................................................................................... \", \"18 \\n\\nODBC ..........................................................................................\", \"........................................................................................... 19 \\n\\nOLE\", \" DB ................................................................................................\", \".................................................................................. 19 \\n\\nADO.NET ....\", \"....................................................................................................\", \"...................................................................... 19 \\n\\nEF Core vs. EF6 ........\", \"....................................................................................................\", \"....................................................... 19 \\n\\nRelational databases ..................\", \"....................................................................................................\", \"................................. 20 \\n\\nConsuming services ..........................................\", \"....................................................................................................\", \"............... 20 \\n\\nConsuming a COM Object ........................................................\", \"........................................................................................ 21 \\n\\nMore t\", \"hings to consider ..................................................................................\", \"................................................................... 21 \\n\\nAppDomains ................\", \"....................................................................................................\", \".................................................. 21 \\n\\nRemoting ...................................\", \"....................................................................................................\", \"...................................... 21 \\n\\nCode Access Security (CAS) .............................\", \"....................................................................................................\", \"........ 22 \\n\\nSecurity Transparency ................................................................\", \".................................................................................... 22 \\n\\nWindows 10\", \" migration .........................................................................................\", \"................ 23 \\n\\nWinRT APIs ...................................................................\", \"....................................................................................................\", \"....... 23 \\n\\nUniversal Windows Platform (UWP) packages .............................................\", \"........................................................ 24 \\n\\nHow to add WinRT APIs to your desktop \", \"project ............................................................................................\", \"........ 26 \\n\\nXAML Islands .........................................................................\", \"................................................................................................. 34\", \" \\n\\nThe road to XAML Islands ........................................................................\", \"..................................................................... 35 \\n\\nHow it works ............\", \"....................................................................................................\", \"...................................................... 35 \\n\\nDo you need XAML Islands ...............\", \"....................................................................................................\", \"....................... 38 \\n\\nThe road ahead XAML Islands: WinUI 3.0 ................................\", \".............................................................................. 38 \\n\\nExample of migra\", \"ting to the latest .NET.............................................................................\", \" 41 \\n\\nMigrating from .NET Core or .NET 5 ...........................................................\", \".................................................................. 41 \\n\\nMigrating from .NET Framewor\", \"k ..................................................................................................\", \".................................. 42 \\n\\nMigrating with a tool ......................................\", \"....................................................................................................\", \"............ 42 \\n\\nMigrating by hand ................................................................\", \"........................................................................................... 42 \\n\\nPre\", \"paration ...........................................................................................\", \".............................................................................. 43 \\n\\nFix the code and\", \" build .............................................................................................\", \"....................................................... 45 \\n\\nRun and test ..........................\", \"....................................................................................................\", \"......................................... 46 \\n\\nii \\n\\nContents \\n\\n \\n\\fMigrating a Windows Forms applicat\", \"ion ................................................................................................\", \".................... 46 \\n\\nMigrating a WPF application ..............................................\", \".............................................................................................. 52 \\n\\n\", \"Deploying Modern Desktop Applications ..............................................................\", \"............ 55 \\n\\nThe modern application lifecycle .................................................\", \"................................................................................... 56 \\n\\nMSIX: The n\", \"ext generation of deployment .......................................................................\", \".......................................... 58 \\n\\nBenefits of MSIX ...................................\", \"....................................................................................................\", \"........................ 59 \\n\\nTools ................................................................\", \"....................................................................................................\", \".................. 61 \\n\\nHow to create an MSIX package from an existing Win32 desktop application....\", \"....................................... 62 \\n\\nAuto Updates in MSIX ..................................\", \"....................................................................................................\", \"................... 70 \\n\\niii \\n\\nContents \\n\\n \\n\\fCHAPTER  1 \\n\\nWhy modern desktop \\napplications \\n\\nIntrodu\", \"ction \\n\\nA story of one company \\n\\nBack in the early 2000s, one multinational company started developi\", \"ng a distributed desktop solution \\nto exchange information between different branches of the company\", \" and execute optimized \\noperations on centralized units. They have chosen a brand-new framework call\", \"ed Windows Forms \\n(also known as WinForms) for their application development. Over the years, the pr\", \"oject evolved into \\na mature, well-tested, and time-proven application with hundreds of thousands of\", \" lines of code. Time \\npassed and .NET Framework 2.0 is no longer the hot new technology. The develop\", \"ers who are \\nworking on this application are facing a dilemma. They\\u2019d like to use the latest stack o\", \"f technologies in \\ntheir development and have their application look and \\u201cfeel\\u201d modern. At the same \", \"time, they don\\u2019t \\nwant to throw away the great product they have built over 15 years and rewrite the\", \" entire application \\nfrom scratch. \\n\\nYour story \\n\\nYou might find yourself in the same boat, where yo\", \"u have mature Windows Forms or Windows \\nPresentation Foundation (WPF) applications that have proved \", \"their reliability over the years. You \\nprobably want to keep using these applications for many more \", \"years. At the same time, since those \\napplications were written some time ago, they might be missing\", \" capabilities like modern look, \\nperformance, integration with new devices and platform features, an\", \"d so on, which gives them a feel \\nof \\u201cold tech\\u201d. There\\u2019s another problem that might concern you as a\", \" developer. While working on the \\nolder .NET Framework versions and maintaining applications that we\", \"re written a while ago, you might \\nfeel like you aren\\u2019t learning new technologies and missing out on\", \" building modern technical skills. If \\nthat is your story \\u2013 this book is for you! \\n\\nDesktop applicat\", \"ions nowadays \\n\\nBefore the rise of the Internet, desktop applications were the main approach to buil\", \"ding software \\nsystems. Developers could choose any programming language, such as COBOL, Fortran, VB\", \"6, or C++. \\n\\n1 \\n\\nCHAPTER 1 | Why modern desktop applications \\n\\n \\n \\n\\fBut whether they developed small\", \" tools or complex distributed architectures, they were all desktop \\napplications. \\n\\nThen, Internet t\", \"echnologies started shocking the development world and winning over more \\nengineers with advantages \", \"like easy deployment and simplified distribution processes. The fact that \\nonce a web application wa\", \"s deployed to production all users got automatic updates made a huge \\nimpact on software agility. \\n\\n\", \"However, the Internet infrastructure, underlying protocols, and standards like HTTP and HTML weren\\u2019t\", \" \\ndesigned for building complex applications. In fact, the major development effort back then was \\na\", \"imed at just one goal: to give web applications the same capabilities that desktop applications have\", \", \\nsuch as fast data input and state management. \\n\\nEven though web and mobile applications have grow\", \"n at an incredible pace, for certain tasks desktop \\napplications still hold the number one place in \", \"terms of efficiency and performance. That explains why \\nthere are millions of developers who are bui\", \"lding their projects with WPF and WinForms and the \\namount of those applications is constantly growi\", \"ng. \\n\\nHere are some reasons for choosing desktop applications in your development: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\", \"\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDesktop apps have better interaction with the user\\u2019s PC. \\n\\nThe performance of d\", \"esktop applications for complex calculations is much higher than the \\nperformance of web application\", \"s. \\n\\nRunning custom logic on the client-side is possible but much harder with a web application. \\n\\nU\", \"sing multithreading is easier and more efficient in a desktop application. \\n\\nThe learning curve for \", \"designing user interfaces (UIs) isn\\u2019t steep. And for WinForms, it\\u2019s \\nintuitive with the drag-and-dro\", \"p experience of the Windows Forms designer. \\n\\nIt\\u2019s easy to start coding and testing your algorithms \", \"without the need to set up a server \\ninfrastructure or to care about connectivity problems, firewall\", \"s, and browser compatibility. \\n\\nDebugging is powerful as compared to web debugging. \\n\\nAccess to hard\", \"ware devices, such as camera, Bluetooth, or card readers, is easy. \\n\\nSince the technology has been a\", \"round for a while, there are many experts and a knowledge \\nbase available to develop desktop applica\", \"tions. \\n\\nSo, as you can see, developing for desktop is great for many reasons. The technology is mat\", \"ure and \\ntime-tested, the development cycle is fast, the debugging is powerful and arguably, desktop\", \" apps \\nhave less complexity and are easier to get started with. \\n\\nMicrosoft offered many UI desktop \", \"technologies throughout the years from Win32 introduced in 1995 \\nto Universal Windows Platform (UWP)\", \" released in 2016. \\n\\n2 \\n\\nCHAPTER 1 | Why modern desktop applications \\n\\n \\n \\n\\fAccording to a survey pu\", \"blished by Telerik on April 2016, the most popular technologies for building \\nWindows desktop apps a\", \"re Windows Forms, WPF, and UWP. \\n\\nYou can develop in any of them using C# and Visual Basic, but let\\u2019\", \"s take a closer look. \\n\\nWindows Forms \\n\\nFirst released in 2002, Windows Forms is a managed framework\", \" and is the oldest, most-used desktop \\ntechnology built on the Windows graphics device interface (GD\", \"I) engine. It offers a smooth drag-and-\\ndrop experience for developing user interfaces in Visual Stu\", \"dio. At the same time, Windows Forms \\nrelies on the Visual Studio Designer as the main way you devel\", \"op your UI, so creating visual \\ncomponents from code isn\\u2019t trivial. \\n\\nThe following list summarizes \", \"the main characteristics of Windows Forms: \\n\\n\\u2022  Mature technology with lots of code samples and docu\", \"mentation. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n3 \\n\\nPowerful and productive designer. Not so convenient to design UI \\u201cf\", \"rom code\\u201d. \\n\\nEasy and intuitive to learn, thanks to the designer\\u2019s drag-and-drop experience. \\n\\nSuppo\", \"rted on any Windows version. \\n\\nSupported on .NET Core 3.0 and later versions. \\n\\nCHAPTER 1 | Why mode\", \"rn desktop applications \\n\\n \\n \\n \\n \\n\\fWPF \\n\\nBased on the XAML language specification, WPF favors a clea\", \"r separation between UI and code. XAML \\noffers capabilities like templating, styling, and binding, w\", \"hich is suited for building large applications. \\nLike Windows Forms, it\\u2019s a managed framework, but t\", \"he design is modular and reusable. \\n\\nHere are the main features of WPF: \\n\\n\\u2022  Mature technology. \\n\\nDe\", \"signer is available, but developers usually prefer to create the design from code using \\ndeclarative\", \" XAML. \\n\\nThe learning curve is steeper than Windows Forms. \\n\\nSupported on any Windows version. \\n\\nSup\", \"ported on .NET Core 3.0 and later versions. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nUWP \\n\\nUWP isn\\u2019t only a presentation fr\", \"amework like WPF and Windows Forms, but it\\u2019s also a platform itself. \\nThis platform has: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022\", \" \\n\\n\\u2022 \\n\\nIts own API set (the Windows Runtime API). \\n\\nA new deployment system (MSIX) \\n\\nA modern applic\", \"ation lifecycle model (for low battery consumption). \\n\\nA new Resource Management System (based on PR\", \"I files). \\n\\nThe platform was created to support all kinds of input systems (like ink, touch, gamepad\", \", mouse, \\nkeyboard, gaze, and so on) in all form-factors with performance and low battery consumptio\", \"n in mind. \\nFor these reasons, the shell of the Windows 10 OS uses parts of the UWP platform. \\n\\n4 \\n\\n\", \"CHAPTER 1 | Why modern desktop applications \\n\\n \\n \\n\\fUWP contains a presentation framework that is XAM\", \"L-based, like WPF, but it has some important \\ndifferences such as: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nApplication\", \"s are executed in app containers. App containers control what resources a UWP \\napp can access. \\n\\nSup\", \"ported only on Windows 10 and Windows 11. \\n\\nApps can be deployed through Microsoft Store for easier \", \"deployment. \\n\\nDesigned as part of the Windows Runtime API. \\n\\nContains an extensive set of rich built\", \"-in controls and additional controls are available \\nthrough the Microsoft UI Library NuGet packages \", \"(WinUI library), updated every few months. \\n\\nA tale of two platforms \\n\\nIn the last 20 years, while U\", \"I desktop technologies were growing and following the path from \\nWindows Forms to UWP, the hardware \", \"was also evolving from heavyweight PC units with small CRT \\nmonitors to high-DPI monitors and lightw\", \"eight tablets and phones with different data input \\ntechniques like Touch and Ink. These changes res\", \"ulted in creating two different concepts: a Desktop \\nApplication and a Modern Application. A Modern \", \"Application is one that considers different device \\nform factors, various input and output methods, \", \"and leverages modern desktop features while \\nrunning on a sandboxed execution model. The (traditiona\", \"l) Desktop Application, on the other hand, is \\n\\n5 \\n\\nCHAPTER 1 | Why modern desktop applications \\n\\n \\n\", \" \\n \\n\\fan application that needs a solid UI with a high density of controls that is best operated with\", \" a mouse \\nand a keyboard. \\n\\nThe following table describes the differences between the two concepts: \", \"\\n\\nAspect of comparison \\n\\nModern Application \\n\\nDesktop Application \\n\\nSecurity \\n\\nDeployment \\n\\nDistribu\", \"tion \\n\\nUI \\n\\nData \\n\\nDesign \\n\\nContained execution & Great \\nFundamentals. Designed from \\nthe ground up \", \"to respect user\\u2019s \\nprivacy, manage battery life, \\nand focus to keep the device \\nsafe. \\n\\nInstallation\", \" and updates are \\nmanaged by the platform. \\n\\nTrusted Distribution & Signed \\nPackages. Distribution i\", \"s \\nperformed from a trusted \\nsource and never from the \\nweb. \\n\\nModern UI. Different input \\nmechanism\", \"s, ink, touch, \\ngamepad, keyboard, mouse, \\netc. \\n\\nCloud First Data with Insights. \\nSource of truth i\", \"n the cloud. \\nInsights to know what happens \\nwith your app and how it\\u2019s \\nperforming. \\n\\nDesigned for \", \"reuse. Reuse in \\nmind between different \\nplatforms, front end, and back \\nend, running assets in many\", \" \\nplaces as possible. \\n\\nUser & Admin level of security. \\nYou have native access to the \\nregistry and\", \" hard drive folders. \\n\\nMSI, Custom installers & \\nUpdates. Traditionally a source \\nof headaches for d\", \"evelopers \\nand IT managers. \\n\\nWeb, SCCM & Custom \\ndistribution. No control over \\nwhat is installed, \", \"affects the \\nwhole machine. \\n\\nWindows Forms, WPF, MFC. \\nDesigned for the mouse and \\nkeyboard for a d\", \"ense UI and to \\nget the most productivity from \\nthe desktop. \\n\\nLocal Data. Traditional desktop \\nappl\", \"ications usually need some \\nlocal data. \\n\\nDesigned for Windows \\nDesktop only \\n\\nAs a part of the comm\", \"itment to provide developers with the best tools to build applications, Microsoft \\nput forth a great\", \" effort to bring these concepts - or we can even say platforms - closer together to \\nempower develop\", \"ers with the best of both worlds. To do that, Microsoft has performed a bidirectional \\neffort betwee\", \"n the two platforms. \\n\\n6 \\n\\nCHAPTER 1 | Why modern desktop applications \\n\\n \\n \\n\\f1.  Move Desktop Appli\", \"cation scenarios into Modern Application platform. The traditional \\n\\ndesktop development is still po\", \"pular because it addresses certain scenarios well. It makes \\nsense to take these common desktop scen\", \"arios and bring them into the modern desktop \\nplatform to make the platform fully capable. \\n\\n1.  Mov\", \"e Modern Application features into Desktop Applications. For existing desktop apps that \\nneed a way \", \"to leverage modern capabilities without rewriting from scratch, features from the \\nModern Applicatio\", \"n platform are pushed into the Desktop Application. \\n\\n7 \\n\\nCHAPTER 1 | Why modern desktop application\", \"s \\n\\n \\n \\n \\n \\n   \\n \\n \\n   \\n \\n\\fIn this book, we\\u2019ll focus on the second part and show how you can moderni\", \"ze your existing desktop \\napplications. \\n\\nPaths to modernization \\n\\nThe structure of this guide refle\", \"cts three different axes to accomplish modernization: Modern \\nFeatures, Deployment, and Installation\", \". \\n\\nModern features \\n\\nSay you have a working Windows Forms application that a sales representative o\", \"f your company uses \\nto fill in a customer order. A new requirement comes in to enable the customer \", \"to sign the order \\nusing a tablet pen. Inking is native in today\\u2019s operating systems and technologie\", \"s, but it wasn\\u2019t \\navailable when the app was developed. \\n\\nThis path will show you how you can levera\", \"ge modern desktop features into your existing desktop \\ndevelopment. \\n\\nDeployment \\n\\nModern developmen\", \"t cycles have stressed the importance of providing agility with regard to how new \\nversions of appli\", \"cations are deployed to individual users. Since Windows Forms and WPF applications \\nare based on a p\", \"articular version of the .NET Framework that must be present on the machine, they \\ncan\\u2019t take advant\", \"age of new .NET Framework version features without the intervention of the IT \\npeople with the risk \", \"of having side effects for other apps running on the same machine. It has limited \\nthe innovation pa\", \"ce for developers forcing them to stay on outdated versions of the .NET Framework. \\n\\nSince the launc\", \"h of .NET Core 3.0, you can leverage a new approach of deploying multiple versions of \\n.NET side by \", \"side and specifying which version of .NET each application should target. This way, you \\ncan use the\", \" newest features in one application while being confident you aren\\u2019t going to break any \\nother appli\", \"cations. \\n\\nInstallation \\n\\nDesktop applications always rely on some sort of installation process befo\", \"re the user can start using \\nthem. This fact brought into the game a set of technologies, from MSI a\", \"nd ClickOnce to custom \\ninstallers or even XCOPY deployment. Any of these methods deals with delicat\", \"e problems because \\napplications need a way to access shared resources on the machine. Sometimes ins\", \"tallation needs to \\naccess the Registry to insert or update new Key Values, sometimes to update shar\", \"ed DLLs referenced \\nby the main application. This behavior causes a continuous headache for users, c\", \"reating this \\nperception that once you install some application, your computer will never be the sam\", \"e, even if you \\nuninstall it afterwards. \\n\\nIn this book, we\\u2019ll introduce a new way of installing app\", \"lications with MSIX that solves the problem \\ndescribed earlier. You\\u2019ll learn how you can easily set \", \"up packaging, installation, and updates for your \\napplication. \\n\\n8 \\n\\nCHAPTER 1 | Why modern desktop \", \"applications \\n\\n \\n \\n\\fCHAPTER  2 \\n\\nWhat\\u2019s new with .NET for \\nDesktop? \\n\\nDesktop applications such as W\", \"indows Forms and WPF can be built using various .NET \\nimplementations, for example, .NET Framework o\", \"r .NET 7. In this chapter, we\\u2019ll talk about the history \\nof each implementation, explain the differe\", \"nces, and show what new features await desktop \\ndevelopers in newer implementations. \\n\\nIf you\\u2019ve bee\", \"n developing Windows Forms or WPF applications for a long time, you\\u2019re familiar with \\n.NET Framework\", \". Later, .NET Core (specifically its 3.0 version) started supporting desktop applications. \\n.NET Cor\", \"e was rebranded to .NET when .NET 5 was released. Just as there are different versions of \\n.NET Fram\", \"ework, for example, 4.6, 4.7, and 4.8, there are also different versions of .NET Core: .NET \\nCore 3.\", \"0, .NET 5, .NET 6, .NET 7, and so on. \\n\\nLet\\u2019s look into the history of each implementation to unders\", \"tand the differences and benefits of each. \\n\\nThe motivation behind .NET Core \\n\\nSince its launch in 2\", \"002, .NET Framework has evolved to support many technologies, like Windows \\nForms, ASP.NET, Entity F\", \"ramework, Windows Store, and many others. All of them are different in \\nnature. Therefore, Microsoft\", \" approached this evolution by taking parts of .NET Framework and \\ncreating a different application s\", \"tack for each technology. That way, development capabilities could \\nbe customized for the needs of t\", \"he specific stack, which maximized the potential of every platform. \\nThat led to fragmentation on th\", \"e versions of .NET Framework maintained by different independent \\nteams. All of these stacks have a \", \"common structure, containing an app model, a framework, and a \\nruntime, but they differ in the imple\", \"mentation of each of the parts. \\n\\nIf you\\u2019re targeting only one of these platforms, you can use this \", \"model. However, in many cases you \\nmight need more than one target platform in the same solution. Fo\", \"r example, your application may \\nhave a desktop admin part, a customer-facing web site that shares t\", \"he back-end logic running on a \\nserver, and even a mobile client. In this case, you need a unified c\", \"oding experience that can span all of \\nthese .NET verticals. \\n\\nBy the time Windows 8 was released, t\", \"he concept of Portable Class Libraries (PCLs) was born. \\nOriginally, .NET Framework was designed aro\", \"und the assumption that it would always be deployed as \\na single unit, so factoring wasn\\u2019t a concern\", \". To face the problem of code sharing between verticals, the \\ndriving force was on how to refactor t\", \"he framework. The idea of contracts is to provide a well-factored \\n\\n9 \\n\\nCHAPTER 2 | What\\u2019s new with \", \".NET for Desktop? \\n\\n \\n \\n\\fAPI surface area. Contracts are simply assemblies that you compile against \", \"and are designed with \\nproper factoring in mind taking care of the dependencies between them. \\n\\nThis\", \" led to reasoning about the API differences between verticals at the assembly level, as opposed to \\n\", \"at the individual API level like previously. This aspect enabled a class library experience that can\", \" target \\nmultiple verticals, also known as portable class libraries. \\n\\nWith PCL, the experience of d\", \"evelopment is unified across verticals based on the API shape. And the \\nmost pressing need to create\", \" libraries running on different verticals is also addressed. But there\\u2019s a \\ngreat challenge: APIs ar\", \"e only portable when the implementation is moved forward across all the \\nverticals. \\n\\nA better appro\", \"ach is to unify the implementations across verticals by providing a well-factored \\nimplementation in\", \"stead of a well-factored view. It\\u2019s a lot simpler to ask each team that owns a specific \\ncomponent t\", \"o think about how their APIs work across all verticals than trying to retroactively provide \\na consi\", \"stent API stack on top. This is where .NET Standard comes in. \\n\\nAnother large challenge has to do wi\", \"th how .NET Framework is deployed. .NET Framework is a \\nmachine-wide framework. Any changes made to \", \"it affect all applications that take a dependency on it. \\nAlthough this deployment model has many ad\", \"vantages, such as reducing disk space and centralized \\naccess to services, it presents some pitfalls\", \". \\n\\nTo start with, it\\u2019s difficult for application developers to take a dependency on a recently rele\", \"ased \\nframework. They either have to take a dependency on the latest OS or provide an application in\", \"staller \\nthat installs .NET Framework along with the application. If you\\u2019re a web developer, you mig\", \"ht not even \\nhave this option as the IT department establishes the server supported version. \\n\\nEven \", \"if you\\u2019re willing to go through the trouble of providing an installer to chain in .NET Framework \\nse\", \"tup, you may find that upgrading .NET Framework can break other applications. \\n\\nDespite the efforts \", \"to provide backward compatible versions of the framework, there are compatible \\nchanges that can bre\", \"ak applications. For example, adding an interface to an existing type can change \\nhow this type is s\", \"erialized and cause breaking problems depending on the existing code. Because the \\n.NET Framework in\", \"stalled base is huge, fighting against these breaking scenarios slows down the pace \\nof innovations \", \"inside .NET Framework. \\n\\nTo solve all these issues, Microsoft developed .NET Core as the evolution o\", \"f the .NET development \\nplatform. \\n\\n10 \\n\\nCHAPTER 2 | What\\u2019s new with .NET for Desktop? \\n\\n \\n \\n \\n\\fIntr\", \"oduction to .NET Core \\n\\n.NET Core, which is now referred to as just \\u201c.NET\\u201d, is the evolution of Micr\", \"osoft\\u2019s .NET technology into \\na modular, cross-platform, open source, and cloud-ready platform. It r\", \"uns on Windows, macOS, and \\nLinux, and some ARM-based architectures like Android and IoT. \\n\\nThe purp\", \"ose of .NET Core is to provide a unified platform for all types of applications, which includes \\nWin\", \"dows, cross-platform, and mobile applications. .NET Standard enabled this by providing shared \\nbase \", \"APIs, which every application model needs, and excluding any application model-specific API. \\n\\nThis \", \"framework gives applications many benefits in terms of efficiency and performance, simplifying \\nthe \", \"packaging and deployment in the different supported platforms. \\n\\nThe benefits of .NET Core come from\", \" these three characteristics: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nCross-platform: It allows application execution on diffe\", \"rent platforms (Windows, macOS, and \\nLinux). \\n\\nOpen source: .NET Core platform is open source and av\", \"ailable through GitHub, fostering \\ntransparency and community contributions. \\n\\nSupported: Microsoft \", \"officially supports .NET Core. \\n\\nStarting with .NET Core 3.0, besides the existing support for web a\", \"nd cloud, there\\u2019s also support for \\ndesktop, IoT, and AI domains. The goal for this framework is imp\", \"ressive: to target every type of .NET \\ndevelopment present and future. \\n\\n.NET 5+ is .NET Core vNext \", \"\\n\\n.NET 5 was the next step forward with .NET Core. .NET 5 improved .NET in a few key ways: \\n\\n\\u2022 \\n\\n\\u2022 \\n\", \"\\n\\u2022 \\n\\nProduced a single .NET runtime and framework that can be used everywhere and that has \\nuniform \", \"runtime behaviors and developer experiences. \\n\\nExpanded the capabilities of .NET by taking the best \", \"of .NET Core, .NET Framework, Xamarin, \\nand Mono. \\n\\nBuilt that product out of a single code-base tha\", \"t developers (Microsoft and the community) \\ncan work on and expand together and that improves all sc\", \"enarios. \\n\\n.NET 5 was a game-changer for .NET. With .NET 5 and later versions, your code and project\", \" files look \\nand feel the same no matter which type of app you\\u2019re building. You have access to the s\", \"ame runtime, \\nAPIs, and language capabilities with each app. This includes new performance improveme\", \"nts that get \\ncommitted to the runtime almost daily. .NET 6 and .NET 7 made further improvements in \", \"reliability, \\nperformance, new APIs, and language features. For more details, see What\\u2019s new in .NET\", \" 5, What\\u2019s \\nnew in .NET 6, and What\\u2019s new in .NET 7. \\n\\n11 \\n\\nCHAPTER 2 | What\\u2019s new with .NET for Des\", \"ktop? \\n\\n \\n \\n\\f.NET Framework vs. .NET \\n\\nSo now that you understand the relevance of .NET, you might b\", \"e wondering what happens with .NET \\nFramework. You could be asking questions like: Do I have to aban\", \"don it? Is it going to disappear? \\nWhat are my choices to modernize the applications I have on .NET \", \"Framework? \\n\\nIn 2019, .NET Framework 4.8 was released. It included three major improvements for desk\", \"top \\napplications: \\n\\n\\u2022  Modern browser and media controls: New controls were added that take advanta\", \"ge of \\n\\nMicrosoft Edge and newer media players that support the latest standards. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAccess t\", \"o UWP controls: UWP introduced controls that take advantage of the latest \\nWindows features and touc\", \"h displays. With .NET Framework 4.8, you don\\u2019t have to rewrite \\nyour applications to use these new f\", \"eatures and controls, so you can use these new features \\nin your existing WPF or Windows Forms code.\", \" \\n\\nHigh-DPI improvements: The resolution of displays increased to 4K and 8K, so, .NET \\nFramework 4.8\", \" added new HDPI improvements to make sure existing Windows Forms and \\nWPF applications can look grea\", \"t on these new displays. \\n\\nSince .NET Framework is installed on millions of machines, Microsoft will\", \" continue to support it but \\nwon\\u2019t add new features. \\n\\n.NET (Core) is the open-source, cross-platfor\", \"m, and fast-moving version of the .NET family. Because of \\nits side-by-side nature, it can take chan\", \"ges without the fear of breaking any application. This means \\nthat .NET will get new APIs and langua\", \"ge features over time that .NET Framework won\\u2019t. Also, .NET \\nalready has features that were impossib\", \"le for .NET Framework, such as: \\n\\n\\u2022 \\n\\nSide-by-side versions of .NET supporting Windows Forms and WPF\", \": This solves the \\nproblem of side effects when updating the machine\\u2019s framework version. Multiple v\", \"ersions of \\n.NET can be installed on the same machine and each application specifies which version o\", \"f \\n\\n12 \\n\\nCHAPTER 2 | What\\u2019s new with .NET for Desktop? \\n\\n \\n \\n \\n\\f.NET it should use. Even more, now y\", \"ou can develop and run Windows Forms and WPF on top \\nof .NET. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nEmbed .NET directly into an \", \"application: You can deploy .NET as part of your application \\npackage. This enables you to take adva\", \"ntage of the latest version, features, and APIs without \\nhaving to wait for a specific version to be\", \" installed on the machine. \\n\\nTake advantage of .NET features: .NET is fast-moving and open-source. I\", \"ts side-by-side \\nnature enables fast introduction of new innovative APIs and Base Class Library (BCL\", \") \\nimprovements without the risk of breaking compatibility. Now Windows Forms and WPF \\napplications \", \"can take advantage of the latest .NET features, which also includes fundamental \\nfixes for things li\", \"ke runtime performance and high-DPI support. \\n\\n.NET Framework will be fully supported and will alway\", \"s be a part of Windows. However, if you want to \\nuse the newest language features and APIs in the fu\", \"ture, you\\u2019ll need to move your applications to \\n.NET. For brand-new desktop apps, we recommend start\", \"ing directly on .NET 6 or a later version. It\\u2019s \\nlightweight and cross-platform, runs side by side, \", \"has high performance, and fits perfectly on \\ncontainers and microservices architectures. \\n\\n.NET Stan\", \"dard vs. PCL \\n\\n.NET Standard is a formal specification of .NET APIs that are intended to be availabl\", \"e on all .NET \\nimplementations. The motivation behind .NET Standard was to establish greater uniform\", \"ity in the .NET \\necosystem. .NET Standard is a specification of .NET APIs that make up a uniform set\", \" of contracts to \\ncompile your code against. These contracts are implemented in each .NET flavor, th\", \"us enabling \\nportability across different .NET implementations. \\n\\n.NET Standard enables the followin\", \"g key scenarios: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n13 \\n\\nDefines uniform set of base class libraries APIs for all .NET implem\", \"entations to implement, \\nindependent of the workload. \\n\\nEnables developers to produce portable libra\", \"ries that are usable across .NET implementations, \\nusing this same set of APIs. \\n\\nCHAPTER 2 | What\\u2019s\", \" new with .NET for Desktop? \\n\\n \\n \\n \\n\\f.NET Standard is the evolution of PCLs and the following list s\", \"hows the fundamental differences \\nbetween .NET Standard and PCLs: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n.NET Standard is\", \" a set of curated APIs, picked by Microsoft. PCLs aren\\u2019t. \\n\\nThe APIs that a PCL contains are depende\", \"nt on the platforms that you choose to target when \\nyou create it. This makes a PCL only sharable fo\", \"r the specific targets that you choose. \\n\\n.NET Standard is platform-agnostic, so it can run on Windo\", \"ws, macOS, and Linux. \\n\\nPCLs can also run cross-platform, but they can only target a limited set of \", \"platforms. \\n\\nNew Desktop features in .NET \\n\\nSupport for Windows Forms and WPF \\n\\nWindows Forms and WP\", \"F are part of .NET Core since version 3.0. Both presentation frameworks are \\nfor Windows only, so th\", \"ey aren\\u2019t cross-platform. You can think of WPF as a rich layer over DirectX and \\nWindows Forms as a \", \"thinner layer over GDI+. WPF and Windows Forms do a great job of exposing \\nand exercising much of th\", \"e desktop application functionality in Windows. So Windows Forms and \\nWPF are available for .NET Cor\", \"e and .NET Framework. Target your new desktop applications to .NET 6 \\nor later, and migrate your exi\", \"sting apps from .NET Framework to .NET 6 or later. \\n\\nA new version of .NET Standard, version 2.1, wa\", \"s released at the same time as .NET Core 3.0. To see \\nwhich .NET implementations support which .NET \", \"Standard versions, see Which .NET Standard version \\nto target. \\n\\nThe .NET (Core) implementations for\", \" both Windows Forms and WPF are open source. \\n\\nXAML Islands \\n\\nXAML Islands is a set of components fo\", \"r developers to use Windows 10 controls (UWP XAML controls) \\nin their WPF, Windows Forms, and native\", \" Win32 apps (like MFC). You can have your \\u201cislands\\u201d of UWP \\nXAML controls wherever you want inside y\", \"our Win32 apps. \\n\\nThese XAML Islands are possible because Windows 10, version 1903 introduced a set \", \"of APIs that \\nallows hosting UWP XAML content in Win32 windows using windows handlers (HWnds). Only \", \"apps \\nrunning on Windows 10 1903 and later can use XAML Islands. \\n\\nTo make it easier to create XAML \", \"Islands for Windows Forms and WPF developers, the Windows \\nCommunity Toolkit introduces a set of .NE\", \"T wrappers in several NuGet packages. Those wrappers are \\nthe wrapped and hosting controls: \\n\\n\\u2022 \\n\\n\\u2022 \", \"\\n\\n14 \\n\\nThe WebView, WebViewCompatible, InkCanvas, MediaPlayerElement, and MapControl \\nwrapped contro\", \"ls wrap some UWP XAML controls into Windows Forms or WPF controls, \\nhiding UWP concepts for those de\", \"velopers. \\n\\nThe WindowsXamlHost control for Windows Forms and WPF allows other not-wrapped UWP \\nXAML\", \" controls and custom controls to be loaded into a XAML Island. \\n\\nCHAPTER 2 | What\\u2019s new with .NET fo\", \"r Desktop? \\n\\n \\n \\n\\fAccess to all Windows 10 and Windows 11 APIs \\n\\nWindows 10 and Windows 11 have a la\", \"rge number of APIs available for developers to work with. \\nThese APIs give access to a wide variety \", \"of functionality like authentication, bluetooth, appointments, \\nand contacts. Now these APIs are exp\", \"osed through .NET and give Windows developers the chance to \\ncreate powerful desktops apps using the\", \" capabilities present on Windows 10 and Windows 11. \\n\\nSide-by-side support and self-contained EXEs \\n\", \"\\nThe .NET deployment model is one of the biggest benefits that Windows desktop developers will \\nexpe\", \"rience with .NET. The ability to globally install .NET provides much of the same central installatio\", \"n \\nand servicing benefits of .NET Framework, while not requiring in-place updates. \\n\\nWhen a new .NET\", \" version is released, you can update each app on a machine as needed without any \\nconcern of affecti\", \"ng other applications. New .NET versions are installed in their own directories and \\nexist \\u201cside-by-\", \"side\\u201d with each other. \\n\\nIf you need to deploy with isolation, you can deploy .NET with your applica\", \"tion. .NET will bundle your \\napp with the .NET runtime as a single executable. The modular architect\", \"ure used by .NET makes these \\nflexible deployment options possible. \\n\\nPerformance \\n\\nSince its start,\", \" targeting the web and cloud workloads, .NET has had performance plugged into its \\nDNA. Server-side \", \"code must be performant enough to fulfill high-concurrency scenarios and .NET 7 \\nscores today as the\", \" best performance web platform in the market. \\n\\nOld Windows Forms code has been refactored for .NET,\", \" which reduced memory allocations for \\ndrawing Forms and Controls. By simply upgrading from .NET Fra\", \"mework to .NET or later, your \\napplications become much faster. You can take advantage of these perf\", \"ormance improvements when \\nyou use .NET to build your next generation of desktop applications. \\n\\n15 \", \"\\n\\nCHAPTER 2 | What\\u2019s new with .NET for Desktop? \\n\\n \\n \\n\\fCHAPTER  3 \\n\\nMigrating Modern \\nDesktop applic\", \"ations \\n\\nIn this chapter, we\\u2019re exploring the most common issues and challenges you can face when mi\", \"grating \\nan existing application from .NET Framework to .NET. \\n\\nIf you just want to update your appl\", \"ication to the latest .NET version using a tool and not get into the \\ndetails of what\\u2019s happening be\", \"hind the scenes, feel free to skip this chapter and find step-by-step \\ninstructions in the Example o\", \"f migrating to .NET chapter. \\n\\nA complex desktop application doesn\\u2019t work in isolation and needs som\", \"e kind of interaction with \\nsubsystems that may reside on the local machine or on a remote server. I\", \"t will probably need some \\nkind of database to connect with as a persistence store either locally or\", \" remotely. With the rise of \\nInternet and service-oriented architectures, it\\u2019s common to have your a\", \"pplication connected to some \\nsort of service residing on a remote server or in the cloud. You may n\", \"eed to access the machine file \\nsystem to implement some functionality. Alternatively, maybe you\\u2019re \", \"using a piece of functionality \\nthat resides inside a COM object outside your application, which is \", \"a common scenario if, for example, \\nyou\\u2019re integrating Office assemblies in your app. \\n\\nBesides, the\", \"re are differences in the API surface that is exposed by .NET Framework and .NET, and \\nsome features\", \" that are available on .NET Framework aren\\u2019t available on .NET. It\\u2019s important for you to \\nknow and \", \"take them into account when planning a migration. \\n\\nConfiguration files \\n\\nConfiguration files offer \", \"the possibility to store sets of properties that are read at run time and can \\naffect the behavior o\", \"f your app, such as where to locate a database or how many times to execute a \\nloop. The beauty of t\", \"his technique is that you can modify some aspects of the application without the \\nneed to recode and\", \" recompile. This comes in handy when, for example, the same app code runs on a \\ndevelopment environm\", \"ent with a certain set of configuration values and in production environment \\nwith a different set. \", \"\\n\\nConfiguration on .NET Framework \\n\\nIf you have a working .NET Framework desktop application, chance\", \"s are you have an app.config file \\naccessed through the AppSettingsSection class from the System.Con\", \"figuration namespace. \\n\\n16 \\n\\nCHAPTER 3 | Migrating Modern Desktop applications \\n\\n \\n \\n\\fWithin the .NE\", \"T Framework infrastructure, there\\u2019s a hierarchy of configuration files that inherit \\nproperties from\", \" its parents. You can find a machine.config file that defines many properties and \\nconfiguration sec\", \"tions that can be used or overridden in any descendant configuration file. \\n\\nConfiguration on .NET \\n\", \"\\nIn the .NET world, there\\u2019s no machine.config file. And even though you can continue to use the old \", \"\\nfashioned System.Configuration namespace, you may consider switching to the modern \\nMicrosoft.Exten\", \"sions.Configuration, which offers a good number of enhancements. \\n\\nThis configuration API supports t\", \"he concept of a configuration provider, which defines the data source \\nto be used to load the config\", \"uration. There are different kinds of built-in providers, such as: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nIn-\", \"memory .NET objects \\n\\nINI files \\n\\nJSON files \\n\\nXML files \\n\\nCommand-line arguments \\n\\nEnvironment vari\", \"ables \\n\\nEncrypted user store \\n\\nOr you can build your own. \\n\\nThe new configuration API allows a list \", \"of name-value pairs that can be grouped into a multi-level \\nhierarchy. Any stored value maps to a st\", \"ring, and there\\u2019s built-in binding support that allows you to \\ndeserialize settings into a custom pl\", \"ain old CLR object (POCO). \\n\\nThe ConfigurationBuilder object lets you add as many configuration prov\", \"iders as you may need for \\nyour application. A precedence rule is used to resolve provider preferenc\", \"e. So, the last provider you \\nadd in your code overrides the others. This is a great feature for man\", \"aging different environments for \\nexecution since you can define different configurations for develo\", \"pment, testing, and production \\nenvironments. And you can manage them in a single function inside yo\", \"ur code. \\n\\nMigrating configuration files \\n\\nYou can continue to use your existing app.config XML file\", \". However, you could take this opportunity \\nto migrate your configuration to benefit from the severa\", \"l enhancements made in .NET. \\n\\nTo migrate from an old-style app.config to a new configuration file, \", \"you should choose between an \\nXML format and a JSON format. \\n\\nIf you choose XML, the conversion is s\", \"traightforward. Since the content is the same, just save the \\napp.config file with XML as type. Then\", \", change the code that references AppSettings to use the \\nConfigurationBuilder class. This change sh\", \"ould be easy. \\n\\nIf you want to use a JSON format and you don\\u2019t want to migrate by hand, there\\u2019s a to\", \"ol called dotnet-\\nconfig2json that can convert an app.config file to a JSON configuration file. \\n\\nYo\", \"u may come across some issues when using configuration sections that were defined in the \\nmachine.co\", \"nfig file. For example, consider the following configuration: \\n\\n17 \\n\\nCHAPTER 3 | Migrating Modern De\", \"sktop applications \\n\\n \\n \\n\\f<configuration> \\n    <system.diagnostics> \\n        <switches> \\n           \", \" <add name=\\\"General\\\" value=\\\"4\\\" /> \\n        </switches> \\n        <trace autoflush=\\\"true\\\" indentsize=\\\"\", \"2\\\"> \\n            <listeners> \\n                <add name=\\\"myListener\\\" \\n                     type=\\\"Sys\", \"tem.Diagnostics.TextWriterTraceListener, \\n                           System, Version=1.0.3300.0, Cul\", \"ture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\" \\n                     initializeData=\\\"MyListener.log\", \"\\\" \\n                     traceOutputOptions=\\\"ProcessId, LogicalOperationStack, Timestamp, \\nThreadId, \", \"Callstack, DateTime\\\" /> \\n            </listeners> \\n        </trace> \\n    </system.diagnostics> \\n</co\", \"nfiguration> \\n\\nIf you take this configuration to a .NET app, you\\u2019ll get an exception: \\n\\nUnrecognized\", \" configuration section System.Diagnostics \\n\\nThis exception occurs because that section and the assem\", \"bly responsible for handling that section \\nwas defined in the machine.config file, which now doesn\\u2019t\", \" exist. \\n\\nTo easily fix the issue, you can copy the section definition from your old machine.config \", \"to your new \\nconfiguration file: \\n\\n<configSections> \\n    <section name=\\\"system.diagnostics\\\" \\n       \", \"      type=\\\"System.Diagnostics.SystemDiagnosticsSection, \\n                   System, Version=4.0.0.0\", \", Culture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\"/> \\n</configSections> \\n\\nAccessing databases \\n\\nAl\", \"most every desktop application needs some kind of database. For desktop, it\\u2019s common to find \\nclient\", \"-server architectures with a direct connection between the desktop app and the database \\nengine. The\", \"se databases can be local or remote depending on the need to share information between \\ndifferent us\", \"ers. \\n\\nFrom the code perspective, there have been many technologies and frameworks to give the devel\", \"oper \\nthe possibility to connect, query, and update a database. \\n\\nThe most common examples of databa\", \"se you can find when talking about Windows Desktop \\napplication are Microsoft Access and Microsoft S\", \"QL Server. If you have more than 20 years of \\nexperience programming for the desktop, names like ODB\", \"C, OLEDB, RDO, ADO, ADO.NET, LINQ, and \\nEntity Framework will sound familiar. \\n\\n18 \\n\\nCHAPTER 3 | Mig\", \"rating Modern Desktop applications \\n\\n \\n \\n\\fODBC \\n\\nYou can continue to use ODBC on .NET since Microsof\", \"t is providing the System.Data.Odbc library \\ncompatible with .NET Standard 2.0. \\n\\nOLE DB \\n\\nOLE DB ha\", \"s been a great way to access various data sources in a uniform manner. But it was based on \\nCOM, whi\", \"ch is a Windows-only technology, and as such wasn\\u2019t the best fit for a cross-platform \\ntechnology su\", \"ch as .NET. It\\u2019s also unsupported in SQL Server versions 2014 and later. For those \\nreasons, OLE DB \", \"won\\u2019t be supported by .NET. \\n\\nADO.NET \\n\\nYou can still use ADO.NET from your existing desktop code on\", \" .NET. You just need to update some \\nNuGet packages. \\n\\nEF Core vs. EF6 \\n\\nThere are two currently sup\", \"ported versions of Entity Framework (EF), Entity Framework 6 (EF6) and EF \\nCore. \\n\\nThe latest techno\", \"logy released as part of the .NET Framework world is Entity Framework, with 6.4 \\nbeing the latest ve\", \"rsion. With the launch of .NET Core, Microsoft also released a new data access stack \\nbased on Entit\", \"y Framework and called Entity Framework Core. \\n\\nYou can use EF 6.4 and EF Core from both .NET Framew\", \"ork and .NET. So, what are the decision drivers \\nto help to decide between the two? \\n\\nEF 6.3 is the \", \"first version of EF6 that can run on .NET and work cross-platform. In fact, the main goal of \\nthis r\", \"elease was to make it easier to migrate existing applications that use EF6 to .NET. \\n\\nEF Core was de\", \"signed to provide a developer experience similar to EF6. Most of the top-level APIs \\nremain the same\", \", so EF Core will feel familiar to developers who have used EF6. \\n\\nAlthough compatible, there are di\", \"fferences on the implementation you should check before making a \\ndecision. For more information, se\", \"e Compare EF Core & EF6. \\n\\nThe recommendation is to use EF Core if: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nThe app needs the capa\", \"bilities of .NET. \\n\\nEF Core supports all of the features that the app requires. \\n\\nConsider using EF6\", \" if both of the following conditions are true: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n19 \\n\\nThe app will run on Windows and .NET F\", \"ramework 4.0 or later. \\n\\nEF6 supports all of the features that the app requires. \\n\\nCHAPTER 3 | Migra\", \"ting Modern Desktop applications \\n\\n \\n \\n\\fRelational databases \\n\\nSQL Server \\n\\nSQL Server has been one \", \"of the databases of choice if you were developing for the desktop some \\nyears ago. With the use of S\", \"ystem.Data.SqlClient in .NET Framework, you could access versions of SQL \\nServer, which encapsulates\", \" database-specific protocols. \\n\\nIn .NET, you can find a new SqlClient class, fully compatible with t\", \"he one existing in the .NET \\nFramework but located in the Microsoft.Data.SqlClient library. You just\", \" have to add a reference to the \\nMicrosoft.Data.SqlClient NuGet package and do some renaming for the\", \" namespaces and everything \\nshould work as expected. \\n\\nMicrosoft Access \\n\\nMicrosoft Access has been \", \"used for years when the sophisticated and more scalable SQL Server wasn\\u2019t \\nneeded. You can still con\", \"nect to Microsoft Access using the System.Data.Odbc library. \\n\\nConsuming services \\n\\nWith the rise of\", \" service-oriented architectures, desktop applications began to evolve from a client-\\nserver model to\", \" the three-layer approach. In the client-server approach, a direct database connection \\nis establish\", \"ed from the client holding the business logic, usually inside a single EXE file. On the other \\nhand,\", \" the three-layer approach establishes an intermediate service layer implementing business logic \\nand\", \" database access, allowing for better security, scalability, and reusability. Instead of working \\ndi\", \"rectly with underlying data, the layered approach relies on a set of services implementing contracts\", \" \\nand typed objects for data transfer. \\n\\nIf you have a desktop application using a WCF service and y\", \"ou want to migrate it to .NET, there are \\nsome things to consider. \\n\\nThe first thing is how to resol\", \"ve the configuration to access the service. Because the configuration is \\ndifferent on .NET, you\\u2019ll \", \"need to make some updates in your configuration file. \\n\\nSecond, you\\u2019ll need to regenerate the servic\", \"e client with the new tools present on Visual Studio 2019 \\nand Visual Studio 2022. In this step, you\", \" must consider activating the generation of the synchronous \\noperations to make the client compatibl\", \"e with your existing code. \\n\\nAfter the migration, if you find that there are libraries you need that\", \" aren\\u2019t present on .NET, you can \\nadd a reference to the Microsoft.Windows.Compatibility NuGet packa\", \"ge and see if the missing \\nfunctions are there. \\n\\nIf you\\u2019re using the WebRequest class to perform we\", \"b service calls, you may find some differences on \\n.NET. The recommendation is to use HttpClient ins\", \"tead. \\n\\n20 \\n\\nCHAPTER 3 | Migrating Modern Desktop applications \\n\\n \\n \\n\\fConsuming a COM Object \\n\\nCurre\", \"ntly, there\\u2019s no way to add a reference to a COM object from Visual Studio 2019 or Visual Studio \\n20\", \"22 to use with .NET. So, you have to manually modify the project file. \\n\\nInsert a COMReference struc\", \"ture inside the project file like in the following example: \\n\\n<ItemGroup> \\n    <COMReference Include\", \"=\\\"MSHTML\\\"> \\n        <Guid>{3050F1C5-98B5-11CF-BB82-00AA00BDCE0B}\\\\</Guid> \\n        <VersionMajor>4</V\", \"ersionMajor> \\n        <VersionMinor>0</VersionMinor> \\n        <Lcid>0</Lcid> \\n        <WrapperTool>p\", \"rimary</WrapperTool> \\n        <Isolated>false</Isolated> \\n    </COMReference> \\n</ItemGroup> \\n\\nMore t\", \"hings to consider \\n\\nSeveral technologies available to .NET Framework libraries aren\\u2019t available for \", \".NET Core or .NET 7. If \\nyour code relies on some of these technologies, consider the alternative ap\", \"proaches outlined in this \\nsection. \\n\\nThe Windows Compatibility Pack provides access to APIs that we\", \"re previously available only for .NET \\nFramework. It can be used on .NET Core and .NET Standard proj\", \"ects. \\n\\nFor more information on API compatibility, you can find documentation about breaking changes\", \" and \\ndeprecated/legacy APIs at https://learn.microsoft.com/dotnet/core/compatibility/fx-core. \\n\\nApp\", \"Domains \\n\\nApplication domains (AppDomains) isolate apps from one another. AppDomains require runtime\", \" \\nsupport and are expensive. Creating additional app domains isn\\u2019t supported. For code isolation, we\", \" \\nrecommend separate processes or using containers as an alternative. For the dynamic loading of \\nas\", \"semblies, we recommend the new AssemblyLoadContext class. \\n\\nTo make code migration from .NET Framewo\", \"rk easier, .NET exposes some of the AppDomain API \\nsurface. Some of the APIs function normally (for \", \"example, AppDomain.UnhandledException), some \\nmembers do nothing (for example, SetCachePath), and so\", \"me of them throw \\nPlatformNotSupportedException (for example, CreateDomain). \\n\\nRemoting \\n\\n.NET Remot\", \"ing was used for cross-AppDomain communication, which is no longer supported. Also, \\nRemoting requir\", \"es runtime support, which is expensive to maintain. For these reasons, .NET Remoting \\nisn\\u2019t supporte\", \"d on .NET. \\n\\nFor communication across processes, you should consider inter-process communication (IP\", \"C) \\nmechanisms as an alternative to Remoting, such as the  or the MemoryMappedFile class. \\n\\n21 \\n\\nCHA\", \"PTER 3 | Migrating Modern Desktop applications \\n\\n \\n \\n\\fAcross machines, use a network-based solution \", \"as an alternative. Preferably, use a low-overhead \\nplaintext protocol, such as HTTP. The Kestrel web\", \" server, the web server used by ASP.NET Core, is an \\noption here. \\n\\nCode Access Security (CAS) \\n\\nSan\", \"dboxing, which relies on the runtime or the framework to constrain which resources a managed \\napplic\", \"ation or library uses or runs, isn\\u2019t supported on .NET. \\n\\nUse security boundaries that are provided \", \"by the operating system, such as virtualization, containers, \\nor user accounts, for running processe\", \"s with the minimum set of privileges. \\n\\nSecurity Transparency \\n\\nSimilar to CAS, Security Transparenc\", \"y separates sandboxed code from security critical code in a \\ndeclarative fashion but is no longer su\", \"pported as a security boundary. \\n\\nUse security boundaries that are provided by the operating system,\", \" such as virtualization, containers, \\nor user accounts, for running processes with the least set of \", \"privileges. \\n\\n22 \\n\\nCHAPTER 3 | Migrating Modern Desktop applications \\n\\n \\n \\n\\fCHAPTER  4 \\n\\nWindows 10 \", \"migration \\n\\nConsider the following situation: You have a working desktop application that was develo\", \"ped in the \\nWindows 7 days. It\\u2019s using WPF technology available at that time and working fine but it\", \" has an \\noutdated UI and behaviors when you run it on Windows 10 or Windows 11. It is like when you \", \"watch a \\nfuturistic movie like Matrix and you see Neo using the Nokia 8110 device. The film works gr\", \"eat after \\n20 years but it would rather benefit from a device modernization. \\n\\nWith the release of W\", \"indows 10, Microsoft introduced many innovations to support scenarios like \\ntablets and touch device\", \"s and to provide the best experience for users for a Microsoft operating \\nsystem ever. For example, \", \"you can: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nSign in with your face using Windows Hello. \\n\\nUse a pen to draw or handwrite \", \"text that is automatically recognized and digitalized. \\n\\nRun locally customized AI models built on t\", \"he cloud using WinML. \\n\\nAll these features are enabled for Windows developers through Windows Runtim\", \"e (WinRT) libraries. \\nYou can take advantage of these features in your existing desktop apps because\", \" the libraries are \\nexposed to both the .NET Framework and .NET as well. You can even modernize your\", \" UI with the use \\nof XAML Islands and improve the visuals and behavior of your apps according to the\", \" times. \\n\\nOne important thing to note here is that you don\\u2019t need to abandon .NET Framework technolo\", \"gy to \\nfollow this modernization path. You can safely stay on there and have all the benefits of Win\", \"dows 10 \\nand Windows 11 without the pressure to migrate to .NET. So, you get both the power and the \", \"\\nflexibility to choose your modernization path. \\n\\nWinRT APIs \\n\\nWinRT APIs are object-oriented, well-\", \"structured application programming interfaces (APIs) that give \\nWindows 10 and Windows 11 developers\", \" access to everything the operating system has to offer. \\nThrough WinRT APIs, you can integrate func\", \"tionalities like Push Notifications, Device APIs, Microsoft \\nInk, and WinML, among others on your de\", \"sktop apps. \\n\\nIn general, WinRT APIs can be called from a classic desktop app. However, two main are\", \"as present an \\nexception to this rule: \\n\\nAPIs that require a package identity. \\n\\nAPIs that require v\", \"isualization like XAML or Composition. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n23 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n\\fUniver\", \"sal Windows Platform (UWP) packages \\n\\nApplication Package Identity \\n\\nUWP apps have a deployment syst\", \"em where the OS manages the installation and uninstallation of \\napplication. That requires the insta\", \"llation to be declarative, meaning that no user code is executed \\nduring install. Instead, everythin\", \"g the app wants to integrate with the system, such as protocols, file \\ntypes, and extensions, is dec\", \"lared in the application manifest. At deployment time, the deployment \\npipeline configures those int\", \"egration points. The only way for the OS to manage all this functionality \\nand keep track of it is f\", \"or each \\u2018package\\u2019 to have an identity, a unique identifier for the application. \\n\\nSome WinRT APIs re\", \"quire this package identity to work as expected. However, classic desktop apps \\nlike native C++ or .\", \"NET apps, use different deployment systems that don\\u2019t require a package identity. \\nIf you want to us\", \"e these WinRT APIs in your desktop application, you need to provide them a package \\nidentity. \\n\\nOne \", \"way to proceed is to build an additional packaging project. Inside the packaging project, you \\npoint\", \" to the original source code project and specify the Identity information you want to provide. If \\ny\", \"ou install the package and run the installed app, it will automatically get an identify enabling you\", \"r \\ncode to call all WinRT APIs requiring Identity. \\n\\n<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> \\n<Packag\", \"e xmlns=\\\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\\\" \\n         xmlns:uap=\\\"http:\", \"//schemas.microsoft.com/appx/manifest/uap/windows10\\\"> \\n    <Identity Name=\\\"YOUR-APP-GUID \\\" \\n        \", \"      Publisher=\\\"CN=YOUR COMPANY\\\" \\n              Version=\\\"1.x.x.x\\\" /> \\n</Package> \\n\\nYou can check wh\", \"ich APIs need a packaged application identity by inspecting if the type that contains \\nthe API is ma\", \"rked with the DualApiPartition attribute. If it is, you can call if from an unpackaged \\ntraditional \", \"desktop app. Otherwise, you must convert your classic desktop app to a UWP with the help \\nof a packa\", \"ging project. \\n\\nhttps://learn.microsoft.com/windows/desktop/apiindex/uwp-apis-callable-from-a-classi\", \"c-desktop-app \\n\\nBenefits of packaging \\n\\nBesides giving you access to these APIs, you get some additi\", \"onal benefits by creating a Windows App \\npackage for your desktop application including: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n2\", \"4 \\n\\nStreamlined deployment. Apps have a great deployment experience ensuring that users can \\nconfide\", \"ntly install an application and update it. If a user chooses to uninstall the app, it\\u2019s \\nremoved com\", \"pletely with no trace left behind preventing the Windows rot problem. \\n\\nAutomatic updates and licens\", \"ing. Your application can participate in the Microsoft Store\\u2019s \\nbuilt-in licensing and automatic upd\", \"ate facilities. Automatic update is a highly reliable and \\nefficient mechanism, because only the cha\", \"nged parts of files are downloaded. \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n\\f\\u2022 \\n\\nIncreased reach an\", \"d simplified monetization. Maybe not your case but if you choose to \\ndistribute your application thr\", \"ough the Microsoft Store you reach millions of Windows 10 and \\nWindows 11 users. \\n\\n\\u2022 \\n\\nAdd UWP featu\", \"res. You can add UWP features to your app\\u2019s package at your own pace. \\n\\nPrepare for packaging \\n\\nBefo\", \"re proceeding to package your desktop application, there are some points you have to address \\nbefore\", \" starting the process. Your application must respect any of the Microsoft Store rules and \\npolicies \", \"and run in the UWP application model. For example, it has to run on the .NET Framework 4.6.2 \\nor lat\", \"er and writes to the HKEY_CURRENT_USER registry hive and the AppData folders will be \\nvirtualized to\", \" a user-specific app-local location. \\n\\nThe design goal for packaging is to separate the application \", \"state from system state while maintaining \\ncompatibility with other apps. Windows 10 and Windows 11 \", \"accomplish this goal by placing the \\napplication inside a UWP package. It detects and redirects some\", \" changes to the file system and \\nregistry at run time to fulfill the promise of a trusted and clean \", \"install and uninstall behavior of an \\napplication provided by packaging. \\n\\nPackages that you create \", \"for your desktop application are desktop-only, full-trust applications that \\naren\\u2019t sandboxed, altho\", \"ugh there\\u2019s lightweight virtualization applied to the app for writes to HKCU \\nand AppData. This virt\", \"ualization allows them to interact with other apps the same way classic desktop \\napplications do. \\n\\n\", \"Installation \\n\\nApp packages are installed under %ProgramFiles%\\\\WindowsApps\\\\package_name, with the ex\", \"ecutable \\ntitled app_name.exe. Each package folder contains a manifest (named AppxManifest.xml) that\", \" contains \\na special XML namespace for packaged apps. Inside that manifest file is an <EntryPoint> e\", \"lement, \\nwhich references the full-trust app. When that application is launched, it doesn\\u2019t run insi\", \"de an app \\ncontainer, but instead it runs as the user as it normally would. \\n\\nAfter deployment, pack\", \"age files are marked read-only and heavily locked down by the operating \\nsystem. Windows prevents ap\", \"ps from launching if these files are tampered with. \\n\\nFile system \\n\\nThe OS supports different levels\", \" of file system operations for packaged desktop applications, \\ndepending on the folder location. \\n\\nW\", \"hen trying to access the user\\u2019s AppData folder, the system creates a private per-user, per-app \\nloca\", \"tion behind the scenes. This creates the illusion that the packaged application is editing the real \", \"\\nAppData when it\\u2019s actually modifying a private copy. By redirecting writes this way, the system can\", \" \\ntrack all file modifications made by the app. It can then clean all those files when uninstalling \", \"reducing \\nsystem \\u201crot\\u201d and providing a better application removal experience for the user. \\n\\n25 \\n\\nCH\", \"APTER 4 | Windows 10 migration \\n\\n \\n \\n\\fRegistry \\n\\nApp packages contain a registry.dat file, which ser\", \"ves as the logical equivalent of HKLM\\\\Software in \\nthe real registry. At run time, this virtual regi\", \"stry merges the contents of this hive into the native \\nsystem hive to provide a singular view of bot\", \"h. \\n\\nAll writes are kept during package upgrade and only deleted when the application is uninstalled\", \". \\n\\nUninstallation \\n\\nWhen the user uninstalls a package, all files and folders located under C:\\\\Prog\", \"ram \\nFiles\\\\WindowsApps\\\\package_name are removed, as well as any redirected writes to AppData or the \", \"\\nregistry that were captured during the process. \\n\\nFor details about how a packaged application hand\", \"les installation, file access, registry, and \\nuninstallation, see https://learn.microsoft.com/window\", \"s/msix/desktop/desktop-to-uwp-behind-the-\\nscenes. \\n\\nYou can get a complete list of things to check o\", \"n \\nhttps://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-prepare. \\n\\nHow to add WinRT APIs \", \"to your desktop project \\n\\nIn this section, you can find a walkthrough on how to integrate Toast Noti\", \"fications in an existing WPF \\napplication. Although it\\u2019s simple from the code perspective, it helps \", \"illustrate the whole process. \\nNotifications are one of the many available WinRT APIs available that\", \" you can use in .NET app. In this \\ncase, the API requires a Package Identity. This process is more s\", \"traightforward if the APIs don\\u2019t require \\nPackage Identity. \\n\\nLet\\u2019s take an existing WPF sample app \", \"that reads files and shows its contents on the screen. The goal \\nis to display a Toast Notification \", \"when the application starts. \\n\\n26 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n\\fFirst, you should check \", \"in the following link whether the Windows 10 or Windows 11 API that you\\u2019ll \\nuse requires a Package I\", \"dentity: \\n\\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/desktop-to-uwp-supported-api \\n\", \"\\nOur sample will use the Windows.UI.Notifications.Notification API that requires a packaged identity\", \": \\n\\nTo access the WinRT API, add a reference to the Microsoft.Windows.SDK.Contracts NuGet package \\na\", \"nd this package will do the magic behind the scenes (see details at \\nhttps://blogs.windows.com/windo\", \"wsdeveloper/2019/04/30/calling-windows-10-apis-from-a-desktop-\\napplication-just-got-easier/). \\n\\nYou\\u2019\", \"re now prepared to start adding some code. \\n\\n27 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n \\n\\fCreate\", \" a ShowToastNotification method that will be called on application startup. It just builds a toast \\n\", \"notification from an XML pattern: \\n\\nprivate void ShowNotification(string title, string content, stri\", \"ng image) \\n{ \\n    string xmlString = $@\\\"<toast><visual><binding template = \\n'ToastGeneric'><text>{ti\", \"tle}</text><text>{content}</text><image \\nsrc=>'{image}'</image></binding></visual></toast>\\\"; \\n    Xm\", \"lDocument toastXml = new XmlDocument(); \\n    toastXml.LoadXml(xmlString); \\n    ToastNotification toa\", \"st = new ToastNotification(toastXml); \\n    ToastNotificationManager.CreateToastNotifier().Show(toast\", \"); \\n} \\n\\nAlthough the project builds, there are errors because the Notifications API requires a Packa\", \"ge Identity \\nand you didn\\u2019t provide it. Adding a Windows Packaging Project to the solution will fix \", \"the issue: \\n\\nSelect the minimum Windows version you want to support and the version you\\u2019re targeting\", \". Not all \\nthe WinRT APIs are supported in all Windows 10 and Windows 11 versions. Each Windows 10 o\", \"r \\nWindows 11 update adds new APIs that are only available from this version; down-level support isn\", \"\\u2019t \\navailable. \\n\\n28 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n\\fNext step is to add the WPF applicat\", \"ion to the Windows Packaging Project by adding a project \\nreference: \\n\\n29 \\n\\nCHAPTER 4 | Windows 10 m\", \"igration \\n\\n \\n \\n \\n\\fA Windows Packaging Project can package several apps so you should set which one i\", \"s the Entry \\nPoint: \\n\\n30 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n \\n\\fNext step is to set the WPF P\", \"roject as the startup Project in the solution configuration. You can press \\nF5 to compile and build \", \"and see the results. \\n\\nLet\\u2019s generate the package so you can install your app. Right click on Store \", \"> Create App Packages. \\n\\n31 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n \\n\\fSelect the sideloading opt\", \"ion to deploy the app from your machine: \\n\\n32 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n\\fSelect the\", \" application architecture of your app: \\n\\n33 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n\\fFinally, cre\", \"ate the package by clicking on Create. \\n\\nXAML Islands \\n\\nXAML Islands are a set of components that en\", \"able Windows desktop developers to use UWP XAML \\ncontrols on their existing Win32 applications, incl\", \"uding Windows Forms and WPF. \\n\\n34 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n\\fYou can image your Win\", \"32 app with your standard controls and among them an \\u201cisland\\u201d of UWP UI \\ncontaining controls from th\", \"e modern world. The concept is similar to having an iFrame inside a web \\npage that shows content fro\", \"m a different page. \\n\\nBesides adding functionality from the Windows 10 and Windows 11 APIs, you can \", \"add pieces of UWP \\nXAML inside of your app using XAML Islands. \\n\\nWindows 10 1903 update introduced a\", \" set of APIs that allow hosting UWP XAML content in Win32 \\nwindows. Only apps running on Windows 10 \", \"1903 or later can use XAML Islands. \\n\\nThe road to XAML Islands \\n\\nThe road to XAML Islands started in\", \" 2012 when Microsoft introduced the WinRT APIs as a framework \\nto modernize the Win32 apps (Windows \", \"Forms, WPF, and native Win32 apps). However, the new UI \\ncontrols inside WinRT were available for ne\", \"w applications but not for existing ones. \\n\\nIn 2015, along with Windows 10, UWP was born. UWP allows\", \" you to create apps that work across \\nWindows devices like XBox, Mobile, and Desktop. One year later\", \", Microsoft announced Desktop \\nBridge (formerly known as Project Centennial). Desktop Bridge is a se\", \"t of tools that allowed \\ndevelopers to bring their existing Win32 apps to the Microsoft Store. More \", \"capabilities were added in \\n2017, allowing developers to enhance their Win32 apps leveraging some of\", \" the new Windows 10 APIs, \\nlike live tiles and notifications on the action center. But still, no new\", \" UI controls. \\n\\nAt Build 2018, Microsoft announced a way for developers to use the new Windows 10 XA\", \"ML controls \\ninto their current Win32 apps, without fully migrating their apps to UWP. It was brande\", \"d as UWP \\nXAML Islands. \\n\\nHow it works \\n\\nThe Windows 10 1903 update introduced several XAML hosting \", \"APIs. Two of them are \\nWindowsXamlManager and DesktopWindowXamlSource. \\n\\n35 \\n\\nCHAPTER 4 | Windows 10\", \" migration \\n\\n \\n \\n \\n\\fThe WindowsXamlManager class handles the UWP XAML Framework. Its InitializeForCu\", \"rrentThread \\nmethod loads the UWP XAML Framework inside the current thread of the Win32 app. \\n\\nThe D\", \"esktopWindowXamlSource is the instance of your XAML Island content. It has the Content \\nproperty, wh\", \"ich you\\u2019re responsible for instantiating and setting. The DesktopWindowXamlSource \\nrenders and gets \", \"its input from an HWND. It needs to know to which other HWND it will attach the \\nXAML Island\\u2019s one, \", \"and you\\u2019re responsible for sizing and positioning the parent\\u2019s HWND. \\n\\nWPF or Windows Forms develope\", \"rs don\\u2019t usually deal with HWND inside their code, so it may be hard \\nto understand and handle HWND \", \"pointers and the underlying wiring stuff to communicate Win32 and \\nUWP worlds. \\n\\nThe XAML Islands .N\", \"ET Wrappers \\n\\nThe Windows Community Toolkit has a set the XAML Islands .NET wrappers for WPF or Wind\", \"ows \\nForms that make easier to use XAML Islands. These wrappers manage the HWNDs, the focus \\nmanagem\", \"ent, among other things. Windows Forms and WPF developers should use these wrappers. \\n\\nThe Windows C\", \"ommunity Toolkit offers two types of controls: Wrapped Controls and Hosting \\nControls. \\n\\nWrapped Con\", \"trols \\n\\nThese wrapped controls wrap some UWP controls into Windows Forms or WPF controls, hiding UWP\", \" \\nconcepts for those developers. These controls are: \\n\\n\\u2022  WebView and WebViewCompatible \\n\\n\\u2022 \\n\\nInkCan\", \"vas and InkToolbar \\n\\n\\u2022  MediaPlayerElement \\n\\n\\u2022  MapControl \\n\\nAdd the Microsoft.Toolkit.Wpf.UI.Contro\", \"ls package to your project, include the reference to the \\nnamespace, and start using them. \\n\\n<Window\", \" \\n        ... \\n        xmlns:uwpControls=\\\"clr-\\nnamespace:Microsoft.Toolkit.Wpf.UI.Controls;assembly=\", \"Microsoft.Toolkit.Wpf.UI.Controls\\\"> \\n<Grid> \\n    <Grid.RowDefinitions> \\n        <RowDefinition Heigh\", \"t=\\\"Auto\\\"/> \\n        <RowDefinition Height=\\\"\\\\*\\\"/> \\n    </Grid.RowDefinitions> \\n    <uwpControls:InkTo\", \"olbar TargetInkCanvas=\\\"{x:Reference Name=inkCanvas}\\\"/> \\n    <uwpControls:InkCanvas Grid.Row=\\\"1\\\" x:Na\", \"me=\\\"inkCanvas\\\" /> \\n</Grid> \\n\\nHosting controls \\n\\nThe power of XAML Islands extends to most first-part\", \"y controls, third-party controls, and custom \\ncontrols developed for UWP, which can be integrated in\", \"to Windows Forms and WPF as \\u201cIslands\\u201d with \\nfully functional UI. The WindowsXamlHost control for WPF\", \" and Windows Forms allows doing this. \\n\\n36 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n\\fFor example, to\", \" use the WindowsXamlHost control in WPF, add a reference to the \\nMicrosoft.Toolkit.Wpf.UI.XamlHost p\", \"ackage provided by the Windows Community Toolkit. \\n\\nOnce you\\u2019ve placed your WindowsXamlHost into you\", \"r UI code, specify which UWP type you want to \\nload. You can choose to use a wrapped control like a \", \"Button or a more complex one composed of \\nseveral different controls, which are a custom UWP control\", \". \\n\\nThe following example shows how to add a UWP Button: \\n\\n<Window \\n        ... \\n        xmlns:xamlh\", \"ost=\\\"clr-\\nnamespace:Microsoft.Toolkit.Wpf.UI.XamlHost;assembly=Microsoft.Toolkit.Wpf.UI.XamlHost\\\"> \\n\", \"\\n<xamlhost:WindowsXamlHost x:Name=\\\"myUwpButton\\\" \\n                          InitialTypeName=\\\"Windows.\", \"UI.Xaml.Controls.Button\\\" /> \\n\\nThere\\u2019s a clear recommendation on how to approach this and it\\u2019s better\", \" to have one single and bigger \\nXAML Island containing a custom composite control than to have sever\", \"al islands with one control on \\neach. \\n\\nOne of the core features of XAML is binding and it works bet\", \"ween your Win32 code and the island. \\nSo, you can bind, for instance, a Win32 Textbox with a UWP Tex\", \"tbox. One important thing to consider \\nis that these bindings are one-way bindings, from UWP to Win3\", \"2, so if you update the Textbox inside \\nthe XAML Island the Win32 Textbox will be updated, but not t\", \"he other way around. \\n\\nTo see a walkthrough about how to use XAML Islands, see: \\n\\nhttps://learn.micr\", \"osoft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml-\\nislands \\n\\nAdding UWP XAML \", \"custom controls \\n\\nA XAML custom control is a control (or user control) created by you or by third pa\", \"rties (including \\nWinUI 2.x controls). To host a custom UWP control in a Windows Forms or WPF app, y\", \"ou\\u2019ll need: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nTo use the WindowsXamlHost UWP control in your .NET app. \\n\\nTo create a UWP app\", \" project that defines a XamlApplication object. \\n\\nYour WPF or Windows Forms project must have access\", \" to an instance of the \\nMicrosoft.Toolkit.Win32.UI.XamlHost.XamlApplication class provided by the Wi\", \"ndows Community \\nToolkit. This object acts as a root metadata provider for loading metadata for cust\", \"om UWP XAML \\ntypes in assemblies in the current directory of your application. The recommended way t\", \"o do this is to \\nadd a Blank App (Universal Windows) project to the same solution as your WPF or Win\", \"dows Forms \\nproject and revise the default App class in this project. \\n\\nThe custom UWP XAML control \", \"can be included on this UWP app or in an independent UWP Class \\nLibrary project that you reference i\", \"n the same solution as your WPF or Windows Forms project. \\n\\nYou can check a detailed step-by-step pr\", \"ocess description at: \\n\\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-contr\", \"ol-with-xaml-\\nislands \\n\\n37 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n\\fThe Windows UI Library (WinUI\", \" 2) \\n\\nBesides the inbox Windows 10 controls that comes with the OS, the same UWP XAML team also \\ndel\", \"ivers additional controls in the Windows UI Library (WinUI 2). WinUI 2 provides official native \\nMic\", \"rosoft UI controls and features for Windows UWP apps and these controls can be used inside of \\nXAML \", \"Islands. \\n\\nWinUI 2 is open source and you can find information at https://github.com/microsoft/micro\", \"soft-ui-\\nxaml. \\n\\nThe following article demonstrates how to host a UWP XAML control from the WinUI 2 \", \"library: \\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-\\n\", \"islands \\n\\nDo you need XAML Islands \\n\\nXAML Islands are intended for existing Win32 apps that want to \", \"improve their user experience by \\nleveraging new UWP controls and behaviors without a full rewrite o\", \"f the app. You could already \\nleverage Windows 10 and Windows 11 APIs, but up until XAML Islands, on\", \"ly non-UI related APIs. \\n\\nIf you\\u2019re developing a new Windows App, a UWP App is probably the right ap\", \"proach. \\n\\nThe road ahead XAML Islands: WinUI 3.0 \\n\\nSince Windows 8, the Windows UI platform, includi\", \"ng the XAML UI framework, visual composition \\nlayer, and input processing has been shipped as an int\", \"egral part of Windows. This means that to \\nbenefit from the latest improvements on UI technologies, \", \"you must upgrade to the latest version of \\nthe UI, slowing down the pace of innovation when you deve\", \"lop your apps. To decouple these two \\nevolution cycles and foster innovation, Microsoft is actively \", \"working on the WinUI project. \\n\\nStarting with WinUI 2 in 2018, Microsoft started shipping some new X\", \"AML UI controls and features as \\nseparate NuGet packages that build on top of the UWP SDK. \\n\\n38 \\n\\nCH\", \"APTER 4 | Windows 10 migration \\n\\n \\n \\n\\fWinUI 3 is under active development and will greatly expand th\", \"e scope of WinUI to include the full UI \\nplatform, which will be fully decoupled from the UWP SDK: \\n\", \"\\nXAML framework will now be developed on GitHub and shipped out of band as NuGet packages. \\n\\nThe exi\", \"sting UWP XAML APIs that ship as part of the OS will no longer receive new feature updates. \\nThey wi\", \"ll still receive security updates and critical fixes according to the Windows 10 support lifecycle. \", \"\\n\\nThe Universal Windows Platform contains more than just the XAML framework (for example, \\napplicati\", \"on and security model, media pipeline, Xbox and Windows 10 shell integrations, broad device \\nsupport\", \") and will continue to evolve. All new XAML features will just be developed and ship as part of \\nWin\", \"UI instead. \\n\\nWinUI 3 in desktop app and WinUI XAML Islands \\n\\nAs you can see, WinUI 3 is the evoluti\", \"on of UWP XAML and it works naturally within the UWP app \\nmodel and all its requirements (MSIX packa\", \"ged ID, sandbox, CoreWindow, and so on. To use just \\nWinUI 3 in a Win32 app model, the WinUI content\", \" should be hosted by another UI Framework \\n(Windows Forms, WPF, and so on) using WinUI XAML Islands.\", \" This is the right path if you want to \\n\\n39 \\n\\nCHAPTER 4 | Windows 10 migration \\n\\n \\n \\n \\n \\n\\fevolve you\", \"r app and mix technologies. However, if you want to replace your entire old UI for WinUI, \\nyour app \", \"shouldn\\u2019t load UI Frameworks for just hosting WinUI. \\n\\nWinUI 3 will address this critical feedback a\", \"dding WinUI in desktop apps. This will allow that Win32 \\napps can use WinUI 3 as standalone UI Frame\", \"work; no need to load Windows Forms or WPF. \\n\\nWithin this aggregation, WinUI 3 will let developers e\", \"asily mix and match the right combination of: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nApp model: UWP, Win32 \\n\\nPlatform\", \": .NET or Native \\n\\nLanguage: .NET (C#, Visual Basic), standard C++ \\n\\nPackaging: MSIX, AppX for the M\", \"icrosoft Store, unpackaged \\n\\nInterop: use WinUI 3 to extend existing WPF, WinForms, and MFC apps usi\", \"ng WinUI XAML \\nIslands. \\n\\nIf you want to know more details, Microsoft is sharing this roadmap in \\nht\", \"tps://github.com/microsoft/microsoft-ui-xaml/blob/main/docs/roadmap.md. \\n\\n40 \\n\\nCHAPTER 4 | Windows 1\", \"0 migration \\n\\n \\n \\n\\fCHAPTER  5 \\n\\nExample of migrating to \\nthe latest .NET \\n\\nIn this chapter, we\\u2019ll sh\", \"ow how to migrate your applications to the latest version of .NET. You can \\nmigrate to .NET 7 from .\", \"NET Framework, .NET Core, or .NET 5. We\\u2019ll introduce a tool that can do all the \\nwork for you in mos\", \"t cases. If your application has special cases or complicated dependencies, we\\u2019ll \\nalso show how to \", \"do the whole migration process by hand. Additionally, we\\u2019ll cover the most common \\nissues and challe\", \"nges you can face when migrating an existing application from .NET Framework to \\n.NET. \\n\\nMigrating f\", \"rom .NET Core or .NET 5 \\n\\nUpdating your applications to target the latest version of .NET is easy if\", \" you already are on .NET Core \\nor .NET 5. If this is the case, then in Visual Studio, simply right-c\", \"lick on your project in Solution \\nExplorer and choose Properties. Under Application > General > Targ\", \"et framework, choose .NET \\n7.0. Save and rebuild your application. You\\u2019re done! Your app now runs on\", \" the latest version of .NET. \\nIn the future when new versions become available, you can upgrade in t\", \"he same way. \\n\\n41 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n\\fMigrating from .NET F\", \"ramework \\n\\nMigrating from .NET Framework is a more complicated process because there are more differ\", \"ences \\nbetween .NET Framework and other platforms that were built on top of .NET Core. But the good \", \"news \\nis that there\\u2019s a tool that will do all the work for you in most cases. \\n\\nMigrating with a too\", \"l \\n\\nThe Upgrade Assistant is a migration tool. Using it is easy and there are step-by-step instructi\", \"ons \\navailable on the .NET website. In this chapter, we\\u2019ll look at what is happening behind the scen\", \"es and \\nhow to port your application by hand. When the Upgrade Assistant is unable to migrate your \\n\", \"application, you\\u2019ll learn the underlying mechanics so that you might be able to migrate manually. \\n\\n\", \"Migrating by hand \\n\\nThe migration process consists of four sequential steps: \\n\\n1. \\n\\nPreparation: Und\", \"erstand the dependencies the project has to have an idea of what\\u2019s ahead. \\nIn this step, you take th\", \"e current project into a state that simplifies the startup point for the \\nmigration. \\n\\n2.  Migrate P\", \"roject File: .NET projects use the new SDK-style project format. Create a new \\n\\nproject file with th\", \"is format or update the one you have to use the SDK style. \\n\\n3. \\n\\nFix code and build: Build the code\", \" in .NET addressing API-level differences between .NET \\nFramework and .NET. If needed, update third-\", \"party packages to the ones that support .NET. \\n\\n42 \\n\\nCHAPTER 5 | Example of migrating to the latest \", \".NET \\n\\n \\n \\n \\n\\f4. \\n\\nRun and test: There might be differences that don\\u2019t show up until run time. So, d\", \"on\\u2019t forget \\nto run the application and test that everything works as expected. \\n\\nPreparation \\n\\nMigr\", \"ate packages.config file \\n\\nIn a .NET Framework application, all references to external packages are \", \"declared in the \\npackages.config file. In .NET, there\\u2019s no longer the need to use the packages.confi\", \"g file. Instead, use the \\nPackageReference property inside the project file to specify the NuGet pac\", \"kages for your app. \\n\\nSo, you need to transition from one format to another. You can do the update m\", \"anually, taking the \\ndependencies contained in the packages.config file and migrating them to the pr\", \"oject file with the \\nPackageReference format. Or, you can let Visual Studio do the work for you: rig\", \"ht-click on the \\npackages.config file and select the Migrate packages.config to PackageReference opt\", \"ion. \\n\\nVerify every dependency compatibility in .NET \\n\\nOnce you\\u2019ve migrated the package references, \", \"you must check each reference for compatibility. You \\ncan explore the dependencies of each NuGet pac\", \"kage your application is using on nuget.org. If the \\npackage has .NET Standard dependencies, then it\", \"\\u2019s going to work on .NET 7 because .NET supports all \\nversions of .NET Standard. The following image\", \" shows the dependencies for the Castle.Windsor \\npackage: \\n\\nTo check the package compatibility, you c\", \"an use the tool https://fuget.org that offers a more detailed \\ninformation about versions and depend\", \"encies. \\n\\nMaybe the project is referencing older package versions that don\\u2019t support .NET, but you m\", \"ight find \\nnewer versions that do support it. So, updating packages to newer versions is generally a\", \" good \\n\\n43 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n \\n\\frecommendation. However, y\", \"ou should consider that updating the package version can introduce \\nsome breaking changes that would\", \" force you to update your code. \\n\\nWhat happens if you don\\u2019t find a compatible version? What if you j\", \"ust don\\u2019t want to update the \\nversion of a package because of these breaking changes? Don\\u2019t worry be\", \"cause it\\u2019s possible to depend \\non .NET Framework packages from a .NET application. Don\\u2019t forget to t\", \"est it extensively because it can \\ncause run-time errors if the external package calls an API that i\", \"sn\\u2019t available on .NET. This is great for \\nwhen you\\u2019re using an old package that isn\\u2019t going to be u\", \"pdated and you can just retarget to work on \\n.NET. \\n\\nCheck for API compatibility \\n\\nSince the API sur\", \"face in .NET Framework and .NET is similar but not identical, you must check which \\nAPIs are availab\", \"le on .NET and which aren\\u2019t. You can use the .NET Portability Analyzer tool to surface \\nAPIs used th\", \"at aren\\u2019t present on .NET. It looks at the binary level of your app, extracts all the APIs that \\nare\", \" called, and then lists which APIs aren\\u2019t available on your target framework (.NET 7 in this case). \", \"\\n\\nYou can find more information about this tool at: \\n\\nhttps://learn.microsoft.com/dotnet/standard/an\", \"alyzers/portability-analyzer \\n\\nAn interesting aspect of this tool is that it only surfaces the diffe\", \"rences from your own code and not \\ncode from external packages, which you can\\u2019t change. Remember you\", \" should have updated most of \\nthese packages to make them work with .NET. \\n\\nMigrate \\n\\n1. \\n\\nCreate th\", \"e new .NET project \\n\\nIn most cases, you\\u2019ll want to update your existing project to the new .NET form\", \"at. However, you can \\nalso create a new project while maintaining the old one. The main drawback fro\", \"m updating the old \\nproject is that you lose designer support, which may be important to you and you\", \"r development \\nteam. If you want to keep using the designer, you must create a new .NET project in p\", \"arallel with the \\nold one and share assets. If you need to modify UI elements in the designer, you c\", \"an switch to the old \\nproject to do that. And since assets are linked, they\\u2019ll be updated in the .NE\", \"T project as well. \\n\\nThe SDK-style project for .NET is a lot simpler than .NET Framework\\u2019s project f\", \"ormat. Apart from the \\npreviously mentioned PackageReference entries, you won\\u2019t need to do much more\", \". The new project \\nformat includes files with certain extensions by default, such as .cs and .xaml f\", \"iles, without the need to \\nexplicitly include them in the project file. \\n\\nAssemblyInfo consideration\", \"s \\n\\nAttributes are autogenerated on .NET projects. If the project contains an AssemblyInfo.cs file, \", \"the \\ndefinitions will be duplicated, which will cause compilation conflicts. You can delete the olde\", \"r \\nAssemblyInfo.cs file or disable autogeneration by adding the following entry to the .NET project \", \"file: \\n\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\"> \\n  <PropertyGroup> \\n    <GenerateAssemblyInfo>false</Gener\", \"ateAssemblyInfo> \\n\\n44 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n\\f  </PropertyGroup\", \"> \\n</Project> \\n\\nResources \\n\\nEmbedded resources are included automatically but resources aren\\u2019t, so y\", \"ou need to migrate the \\nresources to the new project file. \\n\\nPackage references \\n\\nWith the Migrate p\", \"ackages.config to PackageReference option, you can easily move your external \\npackage references to \", \"the new format as previously mentioned. \\n\\nUpdate package references \\n\\nUpdate the versions of the pac\", \"kages you\\u2019ve found to be compatible, as shown in the previous section. \\n\\nFix the code and build \\n\\nMi\", \"crosoft.Windows.Compatibility \\n\\nIf your application depends on APIs that aren\\u2019t available on .NET, s\", \"uch as Registry or ACLs, you have \\nto include a reference to the Microsoft.Windows.Compatibility pac\", \"kage to add these Windows-\\nspecific APIs. They work on .NET but aren\\u2019t included as they aren\\u2019t cross\", \"-platform. \\n\\nThere\\u2019s a tool called Platform compatibility analyzer \\n(https://learn.microsoft.com/dot\", \"net/standard/analyzers/platform-compat-analyzer) that helps you \\nidentify APIs that aren\\u2019t compatibl\", \"e with your code. \\n\\nUse #if directives \\n\\nIf you need different execution paths when targeting .NET F\", \"ramework and .NET, you should use \\ncompilation constants. Add some #if directives to your code to ke\", \"ep the same codebase for both \\ntargets. \\n\\nTechnologies not available on .NET \\n\\nSome technologies are\", \"n\\u2019t available on .NET, such as: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAppDomains \\n\\nRemoting \\n\\nCode Access Security \\n\\n\\u2022  Wind\", \"ows Workflow \\n\\nThat\\u2019s why you need to find a replacement for these technologies if you\\u2019re using them\", \" in your \\napplication. For more information, see the .NET Framework technologies unavailable on .NET\", \" Core and \\n.NET 5+ article. \\n\\n45 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n\\fRegene\", \"rate autogenerated clients \\n\\nIf your application uses autogenerated code, such as a WCF client, you \", \"may need to regenerate this \\ncode to target .NET. Sometimes, you can find some missing references si\", \"nce they may not be included \\nas part of the default .NET assemblies set. Using a tool like https://\", \"apisof.net/, you can easily locate \\nthe assembly the missing reference lives in and add it from NuGe\", \"t. \\n\\nRolling back package versions \\n\\nAs a general rule, we\\u2019ve previously stated that you better upda\", \"te every single package version to be \\ncompatible with .NET. However, you can find that targeting an\", \" updated and compatible version of an \\nassembly just doesn\\u2019t pay off. If the cost of change isn\\u2019t ac\", \"ceptable, you can consider rolling back \\npackage versions keeping the ones you use on .NET Framework\", \". Although they may not be targeting \\n.NET, they should work well unless they call some unsupported \", \"APIs. \\n\\nRun and test \\n\\nOnce you have your application building with no errors, you can start the las\", \"t step of the migration by \\ntesting every functionality. \\n\\nIn this final step, you can find several \", \"different issues depending on the complexity of your application \\nand the dependencies and APIs you\\u2019\", \"re using. \\n\\nFor example, if you use configuration files (app.config), you may find some errors at ru\", \"n time like \\nConfiguration Sections not present. Using the Microsoft.Extensions.Configuration NuGet \", \"package \\nshould fix that error. \\n\\nAnother reason for errors is the use of the BeginInvoke and EndInv\", \"oke methods because they aren\\u2019t \\nsupported on .NET. They aren\\u2019t supported on .NET because they have \", \"a dependency on Remoting, \\nwhich doesn\\u2019t exist on .NET. To solve this issue, try to use the await ke\", \"yword (when available) or the \\nTask.Run method. \\n\\nYou can use compatibility analyzers to let you ide\", \"ntify APIs and code patterns in your code that can \\npotentially cause problems at run time with .NET\", \". Go to https://github.com/dotnet/platform-compat \\nand use the .NET API analyzer on your project. \\n\\n\", \"Migrating a Windows Forms application \\n\\nTo showcase a complete migration process of a Windows Forms \", \"application, we\\u2019ve chosen to migrate \\nthe eShop sample application available at https://github.com/d\", \"otnet-\\narchitecture/eShopModernizing/tree/master/eShopLegacyNTier/src/eShopWinForms. You can find \\nt\", \"he complete result of the migration at https://github.com/dotnet-\\narchitecture/eShopModernizing/tree\", \"/master/eShopModernizedNTier/src/eShopWinForms. \\n\\nThis application shows a product catalog and allow\", \"s the user to navigate, filter, and search for \\nproducts. From an architecture point of view, the ap\", \"p relies on an external WCF service that serves as \\na fa\\u00e7ade to a back-end database. \\n\\nYou can see t\", \"he main application window in the following picture: \\n\\n46 \\n\\nCHAPTER 5 | Example of migrating to the \", \"latest .NET \\n\\n \\n \\n\\fIf you open the .csproj project file, you can see something like this: \\n\\nAs previ\", \"ously mentioned, a .NET project has a more compact style and you need to migrate the \\nproject struct\", \"ure to the new .NET SDK style. \\n\\nIn Solution Explorer, right-click on the Windows Forms project and \", \"select Unload Project > Edit. \\n\\nNow you can update the .csproj file. You\\u2019ll delete the entire conten\", \"ts and replace it with the following \\ncode: \\n\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\"> \\n  <PropertyGroup> \\n\", \"    <OutputType>WinExe</OutputType> \\n    <TargetFramework>net7.0-windows</TargetFramework> \\n    <Use\", \"WindowsForms>true</UseWindowsForms> \\n    <GenerateAssemblyInfo>false</GenerateAssemblyInfo> \\n\\n47 \\n\\nC\", \"HAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n \\n \\n\\f  </PropertyGroup> \\n</Project> \\n\\nSave \", \"and reload the project. You\\u2019re now done updating the project file and the project is targeting \\n.NET\", \" 7. \\n\\nIf you compile the project at this point, you\\u2019ll find some errors related to the WCF client re\", \"ference. \\nSince this code is autogenerated, you must regenerate it to target .NET. \\n\\nDelete the Refe\", \"rence.cs file and generate a new Service Client. \\n\\nRight-click on Connected Services and select the \", \"Add Connected Service option. \\n\\nThe Connected Services window opens. Select the Microsoft WCF Web Se\", \"rvice option. \\n\\n48 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n \\n \\n\\fIf you have the \", \"WCF Service in the same solution as we have in this example, you can select the \\nDiscover option ins\", \"tead of specifying a service URL. \\n\\nOnce the service is located, the tool reflects the API contract \", \"implemented by the service. Change the \\nname of the namespace to be eShopServiceReference as shown i\", \"n the following image: \\n\\n49 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n \\n \\n\\fSelect \", \"the Finish button. After a while, you\\u2019ll see the generated code. \\n\\nYou should see three autogenerate\", \"d files: \\n\\n1.  Getting Started: a link to GitHub to provide some information on WCF. \\n\\n2. \\n\\n3. \\n\\nCon\", \"nectedService.json: configuration parameters to connect to the service. \\n\\nReference.cs: the actual W\", \"CF client code. \\n\\n50 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n \\n\\fIf you compile a\", \"gain, you\\u2019ll see many errors coming from .cs files inside the Helper folder. This folder \\nwas presen\", \"t in the .NET Framework version but not included in the old .csproj. But with the new SDK-\\nstyle pro\", \"ject, every code file present underneath the project file location is included by default. That is, \", \"\\nthe new .NET Core project tries to compile the files inside the Helper folder. Since that folder is\", \"n\\u2019t \\nneeded, you can safely delete it. \\n\\nIf you compile the project again and execute it, you won\\u2019t \", \"see the product images. The problem is that \\nnow the path to the files has slightly changed. To fix \", \"this issue, you need to add another level of depth \\nin the path, updating in the file CatalogView.cs\", \" the line: \\n\\n51 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n \\n\\fstring image_name = E\", \"nvironment.CurrentDirectory + \\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems.Picturefilename;\", \" \\n\\nto \\n\\nstring image_name = Environment.CurrentDirectory + \\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\", \"\\\" + catalogItems.Picturefilename; \\n\\nAfter this change, you can check that the application launches a\", \"nd runs as expected on .NET 7. \\n\\nMigrating a WPF application \\n\\nWe\\u2019ll use the Shop.ClassicWPF sample \", \"application to perform the migration. The following image \\nshows a screenshot of the app before migr\", \"ation: \\n\\nThis application uses a local SQL Server Express database to hold the product catalog infor\", \"mation. \\nThis database is accessed directly from the WPF application. \\n\\nFirst, you must update the .\", \"csproj file to the new SDK style used by .NET Core applications. You\\u2019ll \\nfollow the same steps descr\", \"ibed in the Windows Forms migration: you\\u2019ll unload the project, open the \\n.csproj file, update its c\", \"ontents, and reload the project. \\n\\nIn this case, delete all the content of the .csproj file and repl\", \"ace it with the following code: \\n\\n52 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n \\n\\f\", \" <Project Sdk=\\\"Microsoft.NET.Sdk\\\"> \\n  <PropertyGroup> \\n    <OutputType>WinExe</OutputType> \\n    <Tar\", \"getFramework>net7.0-windows</TargetFramework> \\n    <UseWpf>true</UseWpf> \\n    <GenerateAssemblyInfo>\", \"false</GenerateAssemblyInfo> \\n  </PropertyGroup> \\n</Project> \\n\\nIf you reload the project and compile\", \" it, you\\u2019ll get the following error: \\n\\nSince you\\u2019ve deleted all the .csproj contents, you\\u2019ve lost a \", \"project reference specification present in the \\nold project. You just need to add this line to the .\", \"csproj file to include the project reference back: \\n\\n<ItemGroup> \\n    <ProjectReference Include=\\\"..\\\\\", \"\\\\eShop.SqlProvider\\\\\\\\eShop.SqlProvider.csproj\\\" /> \\n<ItemGroup> \\n\\nYou can also let Visual Studio help \", \"you by right-clicking on the Dependencies node and selecting \\nAdd Project Reference. Select the proj\", \"ect from the solution and select OK: \\n\\n53 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n\", \" \\n \\n\\fOnce you add the missing project reference, the application compiles and runs as expected on .N\", \"ET. \\n\\n54 \\n\\nCHAPTER 5 | Example of migrating to the latest .NET \\n\\n \\n \\n \\n\\fCHAPTER  6 \\n\\nDeploying Moder\", \"n \\nDesktop Applications \\n\\nWhen you develop desktop applications, one thing to consider is how your a\", \"pplication is going to be \\npackaged and deployed to the users\\u2019 machines. The problem with packaging,\", \" deployment, and \\ninstallation is that it usually falls under the umbrella of the IT professionals, \", \"who care about different \\nthings than developers. \\n\\nThese days, we\\u2019re all familiar with the DevOps c\", \"oncept, where developers and IT Pros work closely to \\nmove applications to their production environm\", \"ents. But if you\\u2019ve been in the desktop battle for more \\nthan 10 years, you might have seen the foll\", \"owing story. A team of developers works together hard to \\nmeet the project deadlines. Business peopl\", \"e are nervous since they need the system working on many \\nusers\\u2019 machines to run the company. On \\u201cD-\", \"Day\\u201d, the project manager checks with every developer \\nthat their code is working well and that ever\", \"ything is fine, so they can ship. Then, the package team \\ncomes in generating the setup for the app,\", \" distribute it to every user machine and a set of test users \\nrun the application. Well, they try, b\", \"ecause before showing any UI, the application throws an \\nexception that says \\u201cMethod ~ of object ~ f\", \"ailed\\u201d. Panic starts flowing through the air and a brief \\ninvestigation points to a young and tired \", \"developer that has introduced a third-party control, that \\ncertainly \\u201cworked on the dev machine\\u201d. \\n\\n\", \"Installing desktop applications have traditionally been a nightmare for two main reasons: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\", \"Lack of close collaboration culture between dev and IT teams. \\n\\nLack of a solid packaging and deploy\", \"ing technology we can build upon. \\n\\nIn fact, we\\u2019ve been living with the fact that sometimes you regr\", \"et that you installed an app because: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nIt ends up having some undesired side effects on you\", \"r machine. \\n\\nSome applications that were previously installed stop working. \\n\\nAdditionally, you can\\u2019\", \"t just restore the system to its original state by uninstalling the app. We\\u2019re so \\nused to living wi\", \"th this situation that we\\u2019ve coined terms like \\u201cDLL Hell\\u201d or \\u201cWinrot\\u201d. \\n\\nIn this chapter, we\\u2019ll talk\", \" about MSIX. MSIX is the new technology from Microsoft that tries to capture \\nthe best of previous t\", \"echnologies to provide a solid foundation for the packaging technology of the \\nfuture. \\n\\nWhat does a\", \" packaging technology have to do with modernization? Well, it turns out that packaging \\nis fundament\", \"al for the enterprise IT with lots of money invested there. Modernization isn\\u2019t only related \\n\\n55 \\n\\n\", \"CHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n\\fto using the latest technologies. It\\u2019s also\", \" related to reducing time to market from the moment a \\nbusiness requirement is defined until your co\", \"mpany delivers the feature to your client. \\n\\nThe modern application lifecycle \\n\\nToday, developers wr\", \"ite and build the code for an app and then pass the generated assets to the IT \\nPros. Then, the IT P\", \"ros reconfigure the app and repackage it, typically in an MSI or more recently in an \\nApp-V packagin\", \"g format. The app is then deployed through different channels and tools. One of the \\nmain problems w\", \"ith this approach is commonly known as \\u201cpackaging paralysis\\u201d. The problem is that \\nthis cycle repeat\", \"s every time there\\u2019s an app update or an OS update. \\n\\nYou can see the process reflected on the follo\", \"wing picture: \\n\\nCompanies need a way to break this packaging cycle into three independent cycles: \\n\\n\", \"\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nOS updates \\n\\nApplication updates \\n\\nCustomization \\n\\n56 \\n\\nCHAPTER 6 | Deploying Modern Des\", \"ktop Applications \\n\\n \\n \\n \\n\\fThe previous diagram shows that you can: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nUpdate the underlying \", \"OS without having to repackage your apps. \\n\\nEnable customizations from IT without the need to repack\", \"age the original developer package. \\n\\nThis radical change leads us to the new and modern IT lifecycl\", \"e as shown in the following picture: \\n\\n57 \\n\\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n\", \" \\n\\fDevelopers create the app and generate an MSIX package that IT Pros can consume and configure \\nwi\", \"thout the need of repackaging. Along with the MSIX technology, Microsoft has created tools to \\nallow\", \" IT to customize and configure packages without repackaging. \\n\\nMSIX: The next generation of deployme\", \"nt \\n\\nBefore MSIX, there were several packaging technologies available like setup wizards, MSI, Click\", \"Once, \\nApp-V, and scripting. Each of these technologies has their own strengths and Microsoft has de\", \"cided \\nto pick the best of all to build MSIX. MSIX is built on the foundations of these existing tec\", \"hnologies \\npicking the best of each: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nApp-V => Containerization \\n\\nClickOnce => Auto updatin\", \"g \\n\\n\\u2022  MSI => Easy to distribute \\n\\nWith MSIX, you get one installer technology with all these featur\", \"es. \\n\\n58 \\n\\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n \\n\\fBenefits of MSIX \\n\\nNever regre\", \"t installing an app \\n\\nMSIX provides a predictable, reliable, and safe deployment. The declarative me\", \"thod contained in the \\npackage manifest lets the OS keep track of every asset your application needs\", \". It also provides a true \\nclean uninstall with no side effects. \\n\\nDisk space optimization \\n\\nMSIX is\", \" optimized to reduce the footprint that an application has on the user\\u2019s machine disk space. It \\ncre\", \"ates a single instance storage of your files. That is, if you have two different packages with the \\n\", \"same DLL, the DLL isn\\u2019t installed twice. The platform takes care of that problem because it knows al\", \"l \\nthe files that a particular app installed thanks to its declarative nature. It also allows you to\", \" have \\ndifferent versions of a DLL working side by side. \\n\\nWith the use of resource packages, you ca\", \"n easily create multilingual apps and the OS takes care of \\ninstalling the ones that are used. \\n\\nNet\", \"work optimization \\n\\nMSIX detects the differences on the files at the byte block level enabling a fea\", \"ture called differential \\nupdates. What this means is that only the updated byte blocks are download\", \"ed on application \\nupdates. \\n\\n59 \\n\\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n \\n\\fWith s\", \"treaming installation, the user can quickly start working on your application while other parts of \\n\", \"the app are downloaded on the background. This feature contributes to an engaging experience for \\nyo\", \"ur users. \\n\\nWith the optional packages feature, you achieve componentization on your app deployment,\", \" so you \\ncan download them when needed. \\n\\nSimple packaging and deployment \\n\\nThe AppManifest declares\", \" the versioning, device targeting and identity in a standard way for every \\napplication. It also pro\", \"vides a way to sign your assets providing a solid security foundation. \\n\\nOS managed \\n\\nThe OS handles\", \" all the processes for installing, updating, and removing an application. Applications \\nare installe\", \"d per user but downloaded only once, minimizing the disk footprint. Microsoft is working \\non providi\", \"ng the MSIX experience also on Windows 7. \\n\\nWindows provides integrity for the app \\n\\nWith the use of\", \" digital signatures, you can guarantee that you don\\u2019t install an application from \\nuntrusted sources\", \". MSIX also prevents tampering because: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n60 \\n\\nIt keeps a record of file hashes. \\n\\nIt detect\", \"s if a file has been modified after installation. \\n\\nCHAPTER 6 | Deploying Modern Desktop Application\", \"s \\n\\n \\n \\n \\n\\fWorks for the entire App Catalog \\n\\nOne of the coolest things about MSIX is that it works \", \"for the entire application catalog, Windows \\nForms, WPF, MFC/ATL, Delphi, even if you want to do xCo\", \"py deployment, ClickOnce, or going to the \\nStore, you can use the same MSIX package. \\n\\nTools \\n\\nWindo\", \"ws Application Packaging Project \\n\\nYou can use the Windows Application Packaging Project project in \", \"Visual Studio to generate a \\npackage for your desktop app. Then, you can publish that package to the\", \" Microsoft Store or sideload \\nit onto one or more PCs. \\n\\nMSIX Packaging Tool \\n\\nThe MSIX Packaging To\", \"ol enables you to repackage your existing Win32 applications to the MSIX \\nformat. It offers both an \", \"interactive UI and a command line for conversions and gives you the ability to \\nconvert an applicati\", \"on without having the source code. \\n\\n61 \\n\\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n\\fP\", \"ackage Support Framework \\n\\nThe Package Support Framework is an open-source kit that helps you apply \", \"fixes to your existing \\nWin32 application when you don\\u2019t have access to the source code, so that it \", \"can run in an MSIX \\ncontainer. The Package Support Framework helps your application follow the best \", \"practices of the \\nmodern runtime environment. \\n\\nApp Installer \\n\\nApp Installer allows Windows 10 and \", \"Windows 11 apps to be installed by double-clicking the app \\npackage. This means that users don\\u2019t nee\", \"d to use PowerShell or other developer tools to deploy \\nWindows 10/Windows 11 apps. The App Installe\", \"r can also install an app from the web, optional \\npackages, and related sets. \\n\\nHow to create an MSI\", \"X package from an existing \\nWin32 desktop application \\n\\nLet\\u2019s go through the process to create an MS\", \"IX package from an existing Win32 application. In this \\nexample, we\\u2019ll use a Windows Forms app. \\n\\n62\", \" \\n\\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n \\n\\fTo start, add a new project to your so\", \"lution, select the Windows Application Packaging Project, and \\ngive it a name. \\n\\nYou\\u2019ll see the stru\", \"cture of the packaging project and note a special folder called Applications. Inside \\nthis folder, y\", \"ou can specify which applications you want to include in the package. It can be more than \\none. \\n\\n63\", \" \\n\\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n \\n\\fRight-click on the Applications folder\", \" and select the Windows Forms project you want to package \\nfrom the Visual Studio solution. \\n\\n64 \\n\\nC\", \"HAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n \\n\\fAt this point, you can compile and generat\", \"e the package but let\\u2019s examine a couple of things. To have \\na better user experience, Visual Studio\", \" can autogenerate all the visual assets a modern application \\nneeds to handle icons and tile assets \", \"for the tile bar and start menu. Open the Package.appxmanifest \\nfile to access the Manifest Designer\", \". You can then generate all the visual assets from a given image \\npresent on your project just by cl\", \"icking Create. \\n\\nIf you open the code for the Package.appxmanifest file, you can see a couple of int\", \"eresting things. \\n\\nRight under <Package>, there\\u2019s an <Identity> node. This is where your packaged ap\", \"plication is going \\nto get its identity, which will be managed by the OS. \\n\\n65 \\n\\nCHAPTER 6 | Deployi\", \"ng Modern Desktop Applications \\n\\n \\n \\n \\n \\n\\fIn the <Capabilities> node, you can find all the requireme\", \"nts the application needs, paying special \\nattention to the <rescap:Capability Name=\\\"runFullTrust\\\" \\\\\", \">, which tells the OS to run the app in full \\ntrust mode since it\\u2019s a Win32 application. \\n\\n66 \\n\\nCHAP\", \"TER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n \\n\\fSet the packaging project as the startup proj\", \"ect for the solution and select Run. This is going to: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nCompile the Windows For\", \"ms application. \\n\\nCreate an MSIX package out of the build results. \\n\\nDeploy the packages. \\n\\nInstall \", \"it locally on the development machine. \\n\\nLaunch the app. \\n\\n67 \\n\\nCHAPTER 6 | Deploying Modern Desktop\", \" Applications \\n\\n \\n \\n \\n\\fWith this, you have the clean install and uninstall experience that MSIX prov\", \"ides fully integrated into \\nWindows 10/Windows 11. \\n\\nThe final stage is about how you deploy the MSI\", \"X package to another machine. \\n\\nRight-click on the packaging project, select the Store menu, and the\", \"n select the Create App \\nPackages option. \\n\\nThen, you can choose between creating a package to uploa\", \"d to the store or creating packages for \\nsideloading. In most modernization scenarios, you\\u2019ll choose\", \" I want to create packages for \\nsideloading. \\n\\n68 \\n\\nCHAPTER 6 | Deploying Modern Desktop Application\", \"s \\n\\n \\n \\n \\n\\fThere you can select the different architectures you want to target as you can include as\", \" many as you \\nwant into the same MSIX package. \\n\\nThe final step is to declare where you want to depl\", \"oy the final installation assets. \\n\\n69 \\n\\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n \\n\\f\", \"You can choose to use a web server or a shared UNC path on your enterprise file servers. Pay \\nattent\", \"ion to the settings to specify how you want to update your application. We\\u2019ll cover application \\nupd\", \"ates in the next section. \\n\\nFor a detailed step-by-step guide, see Package a desktop app from source\", \" code using Visual Studio. \\n\\nAuto Updates in MSIX \\n\\nThe Windows Store has a great updating mechanism\", \" using Windows Update. In most enterprise \\nscenarios, you don\\u2019t use the Store to distribute your des\", \"ktop apps. So, you need a similar way to \\nconfigure updates for your application and pull them to yo\", \"ur users. \\n\\nUsing a combination of Windows 10/Windows 11 features and MSIX packages, you can provide\", \" a \\ngreat updating experience for your users. In fact, the user doesn\\u2019t need to be technical at all \", \"but still \\nbenefits from a seamless application update experience. \\n\\nYou can configure your updates \", \"to interact with the user in two different ways: \\n\\n70 \\n\\nCHAPTER 6 | Deploying Modern Desktop Applica\", \"tions \\n\\n \\n \\n \\n\\f\\u2022 \\n\\n\\u2022 \\n\\nUser prompted updates: The OS shows some autogenerated nice UI to notify the \", \"user about \\nthe application it\\u2019s about to install. It builds this UI based on the properties you spe\", \"cify on \\nyour installation files. \\n\\nSilent updates in the background. With this option, your users d\", \"on\\u2019t need to be aware of the \\nupdates. \\n\\nYou can also configure when you want to perform updates: ei\", \"ther when the application launches or \\non a regular basis. Thanks to the side-loading features, you \", \"can even get these updates while the \\napplication is running. \\n\\nWhen you use this type of deployment\", \", a special file is created called .appinstaller. This simple file \\ncontains the following sections:\", \" \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nThe location of the .appinstaller file \\n\\nThe application\\u2019s main MSIX package properti\", \"es \\n\\nThe update behavior \\n\\nIn combination with this file, Microsoft has designed a special URL proto\", \"col to launch the installation \\nprocess from a link: \\n\\n<a href=\\\"ms-appinstaller:?source=http://myweb\", \"service.azureedge.net/MyApp.msix\\\">Install \\napp package </a> \\n\\nThis protocol works on all browsers an\", \"d launches the installation process with a great user experience \\non Windows 10/Windows 11. Since th\", \"e OS manages the installation process, it\\u2019s aware of the location \\nthis application was installed fr\", \"om and tracks all the files affected by the process. \\n\\nMSIX creates a user interface for installatio\", \"n automatically showing some properties of the package. \\nThis allows for a common installation exper\", \"ience for every app. \\n\\n71 \\n\\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\\n \\n \\n \\n\\fOnce you\\u2019ve g\", \"enerated the new MSIX package and moved it to the deployment server, you just have \\nto edit the .app\", \"installer file to reflect these changes: mainly the version and the path to the new MSIX \\nfile. The \", \"next time the user launches the application, the system will detect the change and download \\nthe fil\", \"es for the new version in the background. When the download is finished, installation will \\nexecute \", \"transparently for your user on new application launch. \\n\\n72 \\n\\nCHAPTER 6 | Deploying Modern Desktop A\", \"pplications \\n\\n \\n \\n\\f\"]"