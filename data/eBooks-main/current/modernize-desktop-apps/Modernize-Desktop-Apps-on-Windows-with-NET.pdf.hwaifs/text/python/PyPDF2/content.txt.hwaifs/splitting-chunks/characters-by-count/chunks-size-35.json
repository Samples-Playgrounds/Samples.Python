"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\nEDITION v1.0.3  - Updated to .NET 7 \", \" \\nRefer to the changelog  for the book updates and community contributions.  \\nPUBLISHED BY  \\nMicroso\", \"ft Developer Division, .NET, and Visual Studio product teams  \\nA division of Microsoft Corporation  \", \"\\nOne Microsoft Way  \\nRedmond, Washington 98052 -6399  \\nCopyright \\u00a9 2022 by Microsoft Corporation  \\nA\", \"ll rights reserved. No part of the contents of this book may be reproduced or transmitted in any \\nfo\", \"rm or by any means without the written permission of the publisher.  \\nThis book is provided \\u201cas -is\\u201d\", \" and expresses the author\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in t\", \"his book, including URL and other Internet website references, may change \\nwithout notice.  \\nSome ex\", \"amples depicted herein are provided for illustration only and are fictitious. No real association \\no\", \"r connection is intended or should be inferred.  \\nMicrosoft and the trademarks listed at https://www\", \".microsoft.com  on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies.  \\nM\", \"ac and macOS are trademarks of Apple Inc.  \\nAll other marks and logos are property of their respecti\", \"ve owners.  \\nCo-Authors:  \\nOlia Gavrysh , Program Manager, .NET team, Microsoft  \\nMiguel Angel Caste\", \"j\\u00f3n Dominguez , Innovation Architect, Kabel  \\nParticipants and reviewers:  \\nMaira Wenzel , Senior Pr\", \"ogram Manager, .NET team, Microsoft  \\nAndy De Gorge , Senior Content Developer, .NET docs team, Micr\", \"osoft  \\nMiguel Ramos , Senior Program Manager, Windows Developer Platform team, Microsoft  \\nAdam Bra\", \"den , Principal Program Manager, Windows Developer Platform team, Microsoft  \\nRicardo Minguez Pablos\", \" , Senior Program Manager, Azure IoT team, Microsoft  \\nNish Anil , Senior Program Manager, .NET team\", \", Microsoft  \\nBeth Massi , Senior Product Marketing Manager, Microsoft  \\nScott Hunter , Partner Dire\", \"ctor Program Manager, .NET team, Microsoft  \\nMarta Fuentes Lara , Kabel   \\nRa\\u00fal Fern\\u00e1ndez de C\\u00f3rdoba\", \" , Kabel  \\nAntonio Manuel Fern\\u00e1ndez Cantos , Kabel  \\nIntroduction  \\nThis book is about strategies yo\", \"u can adopt to move your existing desktop applications through the \\npath of modernization and incorp\", \"orate the latest runtime, language, and platform features. You\\u2019ll \\ndiscover that there\\u2019s no unique r\", \"ecipe as each application is different, and so are your requirements \\nand preferences. The good news\", \" is that there are common approaches you can apply to add new \\nfeatures and capabilities to your app\", \"lications. Some of them won\\u2019t even require major modifications \\nof your code. In this  book, we\\u2019ll r\", \"eveal how all those features work behind the scenes and explain the \\nmechanics of their implementati\", \"ons. Moreover, you\\u2019ll find some common scenarios for modernizing \\nexisting desktop applications show\", \"n in detail so you can find inspiration for evolving your projects.  \\nMicrosoft\\u2019s approach to modern\", \"izing existing applications is to give you the flexibility to create your \\nown customized path. All \", \"the modernization strategies described in this book are mostly independent. \\nYou can choose ones tha\", \"t are relevant for your appl ication and skip others that aren\\u2019t important for \\nyou. In other words,\", \" you can mix and match the strategies to best address your application needs.  \\nWho should use the b\", \"ook  \\nThis book for developers and solution architects who want to modernize existing Windows Forms \", \"and \\nWPF desktop applications to leverage the benefits of .NET and Windows 10.  \\nYou might also find\", \" this book useful if you\\u2019re a technical decision maker, such as an enterprise \\narchitect or a develo\", \"pment lead or director who wants an overview of the benefits of updating \\nexisting desktop applicati\", \"ons.  \\nHow to use the book  \\nThis book addresses the \\u201cwhy\\u201d \\u2014why you might want to modernize your exi\", \"sting applications, and the \\nspecific benefits you get from using NET and MSIX to modernize your des\", \"ktop apps. The content of \\nthe book is designed for architects and technical decision ma kers who wa\", \"nt an overview, but who \\ndon\\u2019t need to focus on implementation and technical, step -by-step details.\", \"  \\nAlong the different chapters, sample implementation code snippets and screenshots are provided, \\n\", \"with chapter 5 devoted to showcase a complete migration process for sample applications.  \\nWhat this\", \" book doesn\\u2019t cover  \\nThis book covers a specific subset of scenarios that are focused on lift -and-\", \"shift scenarios, outlining \\nthe way to gain the benefits of modernizing without the effort of rewrit\", \"ing code.  \\nThis book isn\\u2019t about developing modern applications with .NET from scratch or about get\", \"ting started \\nwith Windows Forms and WPF. It focuses on how you can update existing desktop applicat\", \"ions with \\nthe latest technologies for desktop development.   \\nSamples used in this book  \\nTo highli\", \"ght the necessary steps to perform a modernization, we\\u2019ll be using a sample application \\ncalled eSho\", \"pModernizing. This application has two flavors, Windows Forms and WPF, and we\\u2019ll show a \\nstep-by-ste\", \"p process on how to perform the modernization on both of them to .NET.  \\nAlso, on the GitHub reposit\", \"ory for this book, you\\u2019ll find the results of the process, which you can \\nconsult with if you decide\", \" to follow the step -by-step tutorial.   \\ni Contents   \\nContents  \\nWhy modern desktop applications  \", \"................................ ................................ .......................  1 \\nIntrod\", \"uction  ................................ ................................ ..........................\", \"...... ................................ ................................ ...............  1 \\nA story\", \" of one company  ................................ ................................ .................\", \"............... ................................ ...................  1 \\nYour story  ...............\", \"................. ................................ ................................ ................\", \"................ ................................ ...............  1 \\nDesktop applications nowadays \", \" ................................ ................................ ................................ \", \"................................ ........ 1 \\nWindows Forms  ................................ .......\", \"......................... ................................ ................................ ........\", \"........................ ... 3 \\nWPF ................................ ...............................\", \". ................................ ................................ ................................\", \" ...........................  4 \\nUWP  ................................ .............................\", \"... ................................ ................................ ..............................\", \".. ..........................  4 \\nA tale of two platforms  ................................ ........\", \"........................ ................................ ................................ .........\", \".................  5 \\nPaths to modernization  ................................ .....................\", \"........... ................................ ................................ ......................\", \"...  8 \\nModern features  ................................ ................................ .........\", \"....................... ................................ ................................ .. 8 \\nDepl\", \"oyment  ................................ ................................ ..........................\", \"...... ................................ ................................ ...........  8 \\nInstallatio\", \"n ................................ ................................ ................................\", \" ................................ ................................ ..............  8 \\nWhat\\u2019s new wit\", \"h .NET for Desktop?  ................................ ................................ .............\", \".........  9 \\nThe motivation behind .NET Core  ................................ ....................\", \"............ ................................ ................................ ..... 9 \\nIntroduction\", \" to .NET Core  ................................ ................................ ...................\", \"............. ................................ .................  11 \\n.NET 5+ is .NET Core vNext  ..\", \".............................. ................................ ................................ ...\", \"............................. ...............  11 \\n.NET Framework vs.  .NET ........................\", \"........ ................................ ................................ .........................\", \"....... ....................  12 \\n.NET Standard vs.  PCL ................................ ..........\", \"...................... ................................ ................................ ...........\", \"..............  13 \\nNew Desktop features in .NET  ................................ .................\", \"............... ................................ ................................ ......... 14 \\nSupp\", \"ort for Windows Forms and WPF  ................................ ................................ ...\", \"............................. ....................  14 \\nXAML Islands  ..............................\", \".. ................................ ................................ ...............................\", \". ................................ ...... 14 \\nAccess to all Windows 10 and Windows 11 APIs  ........\", \"........................ ................................ ................................  15 \\nSide\", \"-by-side support and self -contained EXEs  ................................ ........................\", \"........ ................................ .... 15 \\nPerformance  ................................ ...\", \"............................. ................................ ................................ ....\", \"............................ ....... 15 \\nMigrating Modern Desktop applications  ....................\", \"............ ................................ ............  16 \\nConfiguration files  ...............\", \"................. ................................ ................................ ................\", \"................ ................................  16 \\nConfiguration on .NET Framework  ............\", \".................... ................................ ................................ .............\", \"...............  16  \\nii Contents  Configuration on .NET  ................................ .........\", \"....................... ................................ ................................ ..........\", \"..........  17 \\nMigrating configuration files  ................................ ....................\", \"............ ................................ ................................ ....... 17 \\nAccessing\", \" databases  ................................ ................................ ......................\", \".......... ................................ ............................  18 \\nODBC  ................\", \"................ ................................ ................................ .................\", \"............... ................................ .....................  19 \\nOLE DB  ................\", \"................ ................................ ................................ .................\", \"............... ................................ ..................  19 \\nADO.NET  ..................\", \".............. ................................ ................................ ...................\", \"............. ................................ ..............  19 \\nEF Core vs.  EF6 ................\", \"................ ................................ ................................ .................\", \"............... ................................ ... 19 \\nRelational databases  .....................\", \"........... ................................ ................................ ......................\", \".......... .......................  20 \\nConsuming services  ................................ .......\", \"......................... ................................ ................................ ........\", \".....................  20 \\nConsuming a COM Object  ................................ ................\", \"................ ................................ ................................ ................ \", \" 21 \\nMore things to consider  ................................ ................................ ....\", \"............................ ................................ .....................  21 \\nAppDomains \", \" ................................ ................................ ................................ \", \"................................ ................................ ...... 21 \\nRemoting  .............\", \"................... ................................ ................................ ..............\", \".................. ................................ .............  21 \\nCode Access Security (CAS)  .\", \"............................... ................................ ................................ ..\", \".............................. ......... 22 \\nSecurity Transparency  ................................\", \" ................................ ................................ ................................ \", \"....................  22 \\nWindows 10 migration  ................................ ...................\", \"............. ................................ .........  23 \\nWinRT APIs  ..........................\", \"...... ................................ ................................ ...........................\", \"..... ................................ ..............  23 \\nUniversal Windows Platform (UWP) packages\", \"  ................................ ................................ ................................\", \" ..... 24 \\nHow to add WinRT APIs to your desktop project  ................................ .........\", \"....................... ................................ .... 26 \\nXAML Islands  ....................\", \"............ ................................ ................................ .....................\", \"........... ................................ ..........  34 \\nThe road to XAML Islands  .............\", \"................... ................................ ................................ ..............\", \".................. .............  35 \\nHow it works  ................................ ...............\", \"................. ................................ ................................ ................\", \"................ ...... 35 \\nDo you need XAML Islands  ................................ .............\", \"................... ................................ ................................ ..........  38\", \" \\nThe road ahead XAML Islands: WinUI 3.0  ................................ .........................\", \"....... ................................ ..............  38 \\nExample of migrating to the latest .NET\", \" ................................ ................................ .............  41 \\nMigrating from\", \" .NET Core or .NET 5  ................................ ................................ ............\", \".................... .............................  41 \\nMigrating from .NET Framework  .............\", \"................... ................................ ................................ ..............\", \".................. .... 42 \\nMigrating with a tool  ................................ ................\", \"................ ................................ ................................ .................\", \".....  42 \\nMigrating by hand  ................................ ................................ ....\", \"............................ ................................ ...........................  42 \\nPrepa\", \"ration  ................................ ................................ ..........................\", \"...... ................................ ................................ ......... 43 \\nFix the code \", \"and build  ................................ ................................ .......................\", \"......... ................................ ....................  45 \\nRun and test  .................\", \"............... ................................ ................................ ..................\", \".............. ................................ ....... 46  \\niii Contents  Migrating a Windows Forms\", \" application  ................................ ................................ ....................\", \"............ ....................  46 \\nMigrating a WPF application  ................................\", \" ................................ ................................ ................................ \", \"............  52 \\nDeploying Modern Desktop Applications  ................................ ..........\", \"...................... ..........  55 \\nThe modern application lifecycle  ...........................\", \"..... ................................ ................................ ............................\", \".... .... 56 \\nMSIX: The next generation of deployment  ................................ ............\", \".................... ................................ .................  58 \\nBenefits of MSIX  .....\", \"........................... ................................ ................................ ......\", \".......................... ...............................  59 \\nTools  .............................\", \"... ................................ ................................ ..............................\", \".. ................................ ......................  61 \\nHow to create an MSIX package from a\", \"n existing Win32 desktop application ................................ ...........  62 \\nAuto Updates \", \"in MSIX  ................................ ................................ .........................\", \"....... ................................ .........................  70  \\n1 CHAPTER 1 | Why modern de\", \"sktop applications  \\n CHAPTER  1 \\nWhy modern desktop \\napplications  \\nIntroduction  \\nA story of one c\", \"ompany  \\nBack in the early 2000s, one multinational company started developing a distributed desktop\", \" solution \\nto exchange information between different branches of the company and execute optimized \\n\", \"operations on centralized units. They have chosen a brand -new framework called Windows Forms \\n(also\", \" known as WinForms) for their application development. Over the years, the project evolved into \\na m\", \"ature, well -tested, and time -proven application with hundreds of thousands of lines of code. Time \", \"\\npassed and .NET Framework 2.0 is no longer the hot new te chnology. The developers who are \\nworking\", \" on this application are facing a dilemma. They\\u2019d like to use the latest stack of technologies in \\nt\", \"heir development and have their application look and \\u201cfeel\\u201d modern. At the same time, they don\\u2019t \\nwa\", \"nt to throw away t he great product they have built over 15 years and rewrite the entire application\", \" \\nfrom scratch.  \\nYour story  \\nYou might find yourself in the same boat, where you have mature Windo\", \"ws Forms or Windows \\nPresentation Foundation (WPF) applications that have proved their reliability o\", \"ver the years. You \\nprobably want to keep using these applications for many more years. A t the same\", \" time, since those \\napplications were written some time ago, they might be missing capabilities like\", \" modern look, \\nperformance, integration with new devices and platform features, and so on, which giv\", \"es them a feel \\nof \\u201cold tech\\u201d. There\\u2019s another pr oblem that might concern you as a developer. While\", \" working on the \\nolder .NET Framework versions and maintaining applications that were written a whil\", \"e ago, you might \\nfeel like you aren\\u2019t learning new technologies and missing out on building modern \", \"technica l skills. If \\nthat is your story \\u2013 this book is for you!  \\nDesktop applications nowadays  \\n\", \"Before the rise of the Internet, desktop applications were the main approach to building software \\ns\", \"ystems. Developers could choose any programming language, such as COBOL, Fortran, VB6, or C++.  \\n2 C\", \"HAPTER 1 | Why modern desktop applications  \\n But whether they developed small tools or complex dist\", \"ributed architectures, they were all desktop \\napplications.  \\nThen, Internet technologies started sh\", \"ocking the development world and winning over more \\nengineers with advantages like easy deployment a\", \"nd simplified distribution processes. The fact that \\nonce a web application was deployed to producti\", \"on all users got aut omatic updates made a huge \\nimpact on software agility.  \\nHowever, the Internet\", \" infrastructure, underlying protocols, and standards like HTTP and HTML weren\\u2019t \\ndesigned for buildi\", \"ng complex applications. In fact, the major development effort back then was \\naimed at just one goal\", \": to give web applications the same c apabilities that desktop applications have, \\nsuch as fast data\", \" input and state management.  \\nEven though web and mobile applications have grown at an incredible p\", \"ace, for certain tasks desktop \\napplications still hold the number one place in terms of efficiency \", \"and performance. That explains why \\nthere are millions of developers who are building the ir project\", \"s with WPF and WinForms and the \\namount of those applications is constantly growing.  \\nHere are some\", \" reasons for choosing desktop applications in your development:  \\n\\u2022 Desktop apps have better interac\", \"tion with the user\\u2019s PC.  \\n\\u2022 The performance of desktop applications for complex calculations is muc\", \"h higher than the \\nperformance of web applications.  \\n\\u2022 Running custom logic on the client -side is \", \"possible but much harder with a web application.  \\n\\u2022 Using multithreading is easier and more efficie\", \"nt in a desktop application.  \\n\\u2022 The learning curve for designing user interfaces (UIs) isn\\u2019t steep.\", \" And for WinForms, it\\u2019s \\nintuitive with the drag -and-drop experience of the Windows Forms designer.\", \"  \\n\\u2022 It\\u2019s easy to start coding and testing your algorithms without the need to set up a server \\ninfr\", \"astructure or to care about connectivity problems, firewalls, and browser compatibility.  \\n\\u2022 Debuggi\", \"ng is powerful as compared to web debugging.  \\n\\u2022 Access to hardware devices, such as camera, Bluetoo\", \"th, or card readers, is easy.  \\n\\u2022 Since the technology  has been around for a while, there are many \", \"experts and a knowledge \\nbase available to develop desktop applications.  \\nSo, as you can see, devel\", \"oping for desktop is great for many reasons. The technology is mature and \\ntime-tested, the developm\", \"ent cycle is fast, the debugging is powerful and arguably, desktop apps \\nhave less complexity and ar\", \"e easier to get started with.  \\nMicrosoft offered many UI desktop technologies throughout the years \", \"from Win32 introduced in 1995 \\nto Universal Windows Platform (UWP) released in 2016.   \\n3 CHAPTER 1 \", \"| Why modern desktop applications  \\n  \\nAccording to a survey published by Telerik on April 2016, the\", \" most popular technologies for building \\nWindows desktop apps are Windows Forms, WPF, and UWP.  \\n \\nY\", \"ou can develop in any of them using C# and Visual Basic, but let\\u2019s take a closer look.  \\nWindows For\", \"ms  \\nFirst released in 2002, Windows Forms is a managed framework and is the oldest, most -used desk\", \"top \\ntechnology built on the Windows graphics device interface (GDI) engine. It offers a smooth drag\", \" -and-\\ndrop experience for developing user interfaces in Visual S tudio. At the same time, Windows F\", \"orms \\nrelies on the Visual Studio Designer as the main way you develop your UI, so creating visual \\n\", \"components from code isn\\u2019t trivial.  \\nThe following list summarizes the main characteristics of Wind\", \"ows Forms:  \\n\\u2022 Mature technology with lots of code samples and documentation.  \\n\\u2022 Powerful and produ\", \"ctive designer. Not so convenient to design UI \\u201cfrom code\\u201d.  \\n\\u2022 Easy and intuitive to learn, thanks \", \"to the designer\\u2019s drag -and-drop experience.  \\n\\u2022 Supported on any Windows version.  \\n\\u2022 Supported on \", \".NET Core 3.0 and later versions.  \\n \\n4 CHAPTER 1 | Why modern desktop applications  \\n WPF \\nBased on\", \" the XAML language specification, WPF favors a clear separation between UI and code. XAML \\noffers ca\", \"pabilities like templating, styling, and binding, which is suited for building large applications. \\n\", \"Like Windows Forms, it\\u2019s a managed framework, but the design is modular and reusable.  \\nHere are the\", \" main features of WPF:  \\n\\u2022 Mature technology.  \\n\\u2022 Designer is available, but developers usually pref\", \"er to create the design from code using \\ndeclarative XAML.  \\n\\u2022 The learning curve is steeper than Wi\", \"ndows Forms.  \\n\\u2022 Supported on any Windows version.  \\n\\u2022 Supported on .NET Core 3.0 and later versions\", \".  \\nUWP  \\nUWP isn\\u2019t only a presentation framework like WPF and Windows Forms, but it\\u2019s also a platfo\", \"rm itself. \\nThis platform has:  \\n\\u2022 Its own API set (the Windows Runtime API).  \\n\\u2022 A new deployment s\", \"ystem (MSIX)  \\n\\u2022 A modern application lifecycle model (for low battery consumption).  \\n\\u2022 A new Resou\", \"rce Management System (based on PRI files).  \\nThe platform was created to support all kinds of input\", \" systems (like ink, touch, gamepad, mouse, \\nkeyboard, gaze, and so on) in all form -factors with per\", \"formance and low battery consumption in mind. \\nFor these reasons, the shell of the Windows 10 OS use\", \"s parts of the UWP platform.   \\n5 CHAPTER 1 | Why modern desktop applications  \\n  \\nUWP contains a pr\", \"esentation framework that is XAML -based, like WPF, but it has some important \\ndifferences such as: \", \" \\n\\u2022 Applications are executed in app containers. App containers control what resources a UWP \\napp ca\", \"n access.  \\n\\u2022 Supported only on Windows 10 and Windows 11.  \\n\\u2022 Apps can be deployed through Microsof\", \"t Store for easier deployment.  \\n\\u2022 Designed as part of the Windows Runtime API.  \\n\\u2022 Contains an exte\", \"nsive set of rich built -in controls and additional controls are available \\nthrough the Microsoft UI\", \" Library NuGet packages (WinUI library), updated every few months.  \\nA tale of two platforms  \\nIn th\", \"e last 20 years, while UI desktop technologies were growing and following the path from \\nWindows For\", \"ms to UWP, the hardware was also evolving from heavyweight PC units with small CRT \\nmonitors to high\", \" -DPI monitors and lightweight tablets and phones with  different data input \\ntechniques like Touch \", \"and Ink. These changes resulted in creating two different concepts: a Desktop \\nApplication and a Mod\", \"ern Application. A Modern Application is one that considers different device \\nform factors, various \", \"input and outp ut methods, and leverages modern desktop features while \\nrunning on a sandboxed execu\", \"tion model. The (traditional) Desktop Application, on the other hand, is \\n \\n6 CHAPTER 1 | Why modern\", \" desktop applications  \\n an application that needs a solid UI with a high density of controls that i\", \"s best operated with a mouse \\nand a keyboard.  \\nThe following table describes the differences betwee\", \"n the two concepts:  \\nAspect of comparison  Modern Application  Desktop Application  \\nSecurity  Cont\", \"ained execution & Great \\nFundamentals. Designed from \\nthe ground up to respect user\\u2019s \\nprivacy, mana\", \"ge battery life, \\nand focus to keep the device \\nsafe. User & Admin level of security. \\nYou have nati\", \"ve access to the \\nregistry and hard drive folders.  \\nDeployment  Installation and updates are \\nmanag\", \"ed by the platform.  MSI, Custom installers & \\nUpdates. Traditionally a source \\nof headaches for dev\", \"elopers \\nand IT managers.  \\nDistribution  Trusted Distribution & Signed \\nPackages. Distribution is \\n\", \"performed from a trusted \\nsource and never from the \\nweb.  Web, SCCM & Custom \\ndistribution. No cont\", \"rol over \\nwhat is installed, affects the \\nwhole machine.  \\nUI Modern UI. Different input \\nmechanisms\", \", ink, touch, \\ngamepad, keyboard, mouse, \\netc. Windows Forms, WPF, MFC. \\nDesigned for the mouse and \", \"\\nkeyboard for a dense UI and to \\nget the most productivity from \\nthe desktop.  \\nData  Cloud First Da\", \"ta with Insights. \\nSource of truth in the cloud. \\nInsights to know what happens \\nwith your app and h\", \"ow it\\u2019s \\nperforming.  Local Data. Traditional desktop \\napplications usually need some \\nlocal data.  \", \"\\nDesign  Designed for reuse. Reuse in \\nmind between different \\nplatforms, front end, and back \\nend, \", \"running assets in many \\nplaces as possible.  Designed for Windows \\nDesktop only  \\nAs a part of the c\", \"ommitment to provide developers with the best tools to build applications, Microsoft \\nput forth a gr\", \"eat effort to bring these concepts - or we can even say platforms - closer together to \\nempower deve\", \"lopers with the best of both worlds. To do that, Microsoft has performed a bidirectional \\neffort bet\", \"ween the two platforms.   \\n7 CHAPTER 1 | Why modern desktop applications  \\n  \\n1. Move Desktop Applic\", \"ation scenarios into Modern Application platform. The traditional \\ndesktop development is still popu\", \"lar because it addresses certain scenarios well. It makes \\nsense to take these common desktop scenar\", \"ios and bring them into the modern desktop \\nplatform to make the platform fully capable.  \\n \\n    \\n1.\", \" Move Modern Application features into Desktop Applications. For existing desktop apps that \\nneed a \", \"way to leverage modern capabilities without rewriting from scratch, features from the \\nModern Applic\", \"ation platform are pushed into the Desktop Application.  \\n \\n    \\n \\n8 CHAPTER 1 | Why modern desktop \", \"applications  \\n In this book, we\\u2019ll focus on the second part and show how you can modernize your exi\", \"sting desktop \\napplications.  \\nPaths to modernization  \\nThe structure of this guide reflects three d\", \"ifferent axes to accomplish modernization: Modern \\nFeatures, Deployment, and Installation.  \\nModern \", \"features  \\nSay you have a working Windows Forms application that a sales representative of your comp\", \"any uses \\nto fill in a customer order. A new requirement comes in to enable the customer to sign the\", \" order \\nusing a tablet pen. Inking is native in today\\u2019s operating sys tems and technologies, but it \", \"wasn\\u2019t \\navailable when the app was developed.  \\nThis path will show you how you can leverage modern \", \"desktop features into your existing desktop \\ndevelopment.  \\nDeployment  \\nModern development cycles h\", \"ave stressed the importance of providing agility with regard to how new \\nversions of applications ar\", \"e deployed to individual users. Since Windows Forms and WPF applications \\nare based on a particular \", \"version of the .NET Framework t hat must be present on the machine, they \\ncan\\u2019t take advantage of ne\", \"w .NET Framework version features without the intervention of the IT \\npeople with the risk of having\", \" side effects for other apps running on the same machine. It has limited \\nthe innovation pa ce for d\", \"evelopers forcing them to stay on outdated versions of the .NET Framework.  \\nSince the launch of .NE\", \"T Core 3.0, you can leverage a new approach of deploying multiple versions of \\n.NET side by side and\", \" specifying which version of .NET each application should target. This way, you \\ncan use the newest \", \"features in one application while b eing confident you aren\\u2019t going to break any \\nother applications\", \".  \\nInstallation  \\nDesktop applications always rely on some sort of installation process before the \", \"user can start using \\nthem. This fact brought into the game a set of technologies, from MSI and Clic\", \"kOnce to custom \\ninstallers or even XCOPY deployment. Any of these methods de als with delicate prob\", \"lems because \\napplications need a way to access shared resources on the machine. Sometimes installat\", \"ion needs to \\naccess the Registry to insert or update new Key Values, sometimes to update shared DLL\", \"s referenced \\nby the main application . This behavior causes a continuous headache for users, creati\", \"ng this \\nperception that once you install some application, your computer will never be the same, ev\", \"en if you \\nuninstall it afterwards.  \\nIn this book, we\\u2019ll introduce a new way of installing applicat\", \"ions with MSIX that solves the problem \\ndescribed earlier. You\\u2019ll learn how you can easily set up pa\", \"ckaging, installation, and updates for your \\napplication.   \\n9 CHAPTER 2 | What\\u2019s new with .NET for \", \"Desktop?  \\n CHAPTER  2 \\nWhat\\u2019s new with .NET for \\nDesktop?  \\nDesktop applications such as Windows Fo\", \"rms and WPF can be built using various .NET \\nimplementations, for example, .NET Framework or .NET 7.\", \" In this chapter, we\\u2019ll talk about the history \\nof each implementation, explain the differences, and\", \" show what new feat ures await desktop \\ndevelopers in newer implementations.  \\nIf you\\u2019ve been develo\", \"ping Windows Forms or WPF applications for a long time, you\\u2019re familiar with \\n.NET Framework. Later,\", \" .NET Core (specifically its 3.0 version) started supporting desktop applications. \\n.NET Core was re\", \"branded to .NET when .NET 5 was relea sed. Just as there are different versions of \\n.NET Framework, \", \"for example, 4.6, 4.7, and 4.8, there are also different versions of .NET Core: .NET \\nCore 3.0, .NET\", \" 5, .NET 6, .NET 7, and so on.  \\nLet\\u2019s look into the history of each implementation to understand th\", \"e differences and benefits of each.  \\nThe motivation behind .NET Core  \\nSince its launch in 2002, .N\", \"ET Framework has evolved to support many technologies, like Windows \\nForms, ASP.NET, Entity Framewor\", \"k, Windows Store, and many others. All of them are different in \\nnature. Therefore, Microsoft approa\", \"ched this evolution by taking parts of .NET Framework and \\ncreating a different application stack fo\", \"r each technology. That way, development capabilities could \\nbe customized for the needs of the spec\", \"ific stack, which maximized the potential of every platform. \\nThat led to fragmentation o n the vers\", \"ions of .NET Framework maintained by different independent \\nteams. All of these stacks have a common\", \" structure, containing an app model, a framework, and a \\nruntime, but they differ in the implementat\", \"ion of each of the parts.  \\nIf you\\u2019re targeting only one of these platforms, you can use this model.\", \" However, in many cases you \\nmight need more than one target platform in the same solution. For exam\", \"ple, your application may \\nhave a desktop admin part, a customer -facing web site that shares the ba\", \"ck -end logic running on a \\nserver, and even a mobile client. In this case, you need a unified codin\", \"g experience that can span all of \\nthese .NET verticals.  \\nBy the time Windows 8 was released, the c\", \"oncept of Portable Class Libraries (PCLs) was born. \\nOriginally, .NET Framework was designed around \", \"the assumption that it would always be deployed as \\na single unit, so factoring  wasn\\u2019t a concern. T\", \"o face the problem of code sharing between verticals, the \\ndriving force was on how to refactor the \", \"framework. The idea of contracts is to provide a well -factored  \\n10 CHAPTER 2 | What\\u2019s new with .NE\", \"T for Desktop?  \\n API surface area. Contracts are simply assemblies that you compile against and are\", \" designed with \\nproper factoring in mind taking care of the dependencies between them.  \\nThis led to\", \" reasoning about the API differences between verticals at the assembly level, as opposed to \\nat the \", \"individual API level like previously. This aspect enabled a class library experience that can target\", \" \\nmultiple verticals, also known as portable cl ass libraries.  \\n \\nWith PCL, the experience of devel\", \"opment is unified across verticals based on the API shape. And the \\nmost pressing need to create lib\", \"raries running on different verticals is also addressed. But there\\u2019s a \\ngreat challenge: APIs are on\", \"ly portable when the impl ementation is moved forward across all the \\nverticals.  \\nA better approach\", \" is to unify the implementations across verticals by providing a well -factored \\nimplementation inst\", \"ead of a well -factored view. It\\u2019s a lot simpler to ask each team that owns a specific \\ncomponent to\", \" think about how their APIs work across all  verticals than trying to retroactively provide \\na consi\", \"stent API stack on top. This is where .NET Standard comes in.  \\nAnother large challenge has to do wi\", \"th how .NET Framework is deployed. .NET Framework is a \\nmachine -wide framework. Any changes made to\", \" it affect all applications that take a dependency on it. \\nAlthough this deployment model has many a\", \"dvantages, such as redu cing disk space and centralized \\naccess to services, it presents some pitfal\", \"ls.  \\nTo start with, it\\u2019s difficult for application developers to take a dependency on a recently re\", \"leased \\nframework. They either have to take a dependency on the latest OS or provide an application \", \"installer \\nthat installs .NET Framework along with the applicati on. If you\\u2019re a web developer, you \", \"might not even \\nhave this option as the IT department establishes the server supported version.  \\nEv\", \"en if you\\u2019re willing to go through the trouble of providing an installer to chain in .NET Framework \", \"\\nsetup, you may find that upgrading .NET Framework can break other applications.  \\nDespite the effor\", \"ts to provide backward compatible versions of the framework, there are compatible \\nchanges that can \", \"break applications. For example, adding an interface to an existing type can change \\nhow this type i\", \"s serialized and cause breaking problems depending on the existing code. Because the \\n.NET Fr amewor\", \"k installed base is huge, fighting against these breaking scenarios slows down the pace \\nof innovati\", \"ons inside .NET Framework.  \\nTo solve all these issues, Microsoft developed .NET Core as the evoluti\", \"on of the .NET development \\nplatform.  \\n \\n11 CHAPTER 2 | What\\u2019s new with .NET for Desktop?  \\n Introd\", \"uction to .NET Core  \\n.NET Core, which is now referred to as just \\u201c.NET\\u201d, is the evolution of Micros\", \"oft\\u2019s .NET technology into \\na modular, cross -platform, open source, and cloud -ready platform. It r\", \"uns on Windows, macOS, and \\nLinux, and some ARM -based architectures like Android a nd IoT.  \\nThe pu\", \"rpose of .NET Core is to provide a unified platform for all types of applications, which includes \\nW\", \"indows, cross -platform, and mobile applications. .NET Standard  enabled this by providing shared \\nb\", \"ase APIs, which every application model needs, and excluding any application model -specific API.  \\n\", \"This framework gives applications many benefits in terms of efficiency and performance, simplifying \", \"\\nthe packaging and deployment in the different supported platforms.  \\nThe benefits of .NET Core come\", \" from these three characteristics:  \\n\\u2022 Cross -platform:  It allows application execution on differen\", \"t platforms (Windows, macOS, and \\nLinux).  \\n\\u2022 Open source:  .NET Core platform is open source and av\", \"ailable through GitHub, fostering \\ntransparency and community contributions.  \\n\\u2022 Supported:  Microso\", \"ft officially supports .NET Core.  \\nStarting with .NET Core 3.0, besides the existing support for we\", \"b and cloud, there\\u2019s also support for \\ndesktop, IoT, and AI domains. The goal for this framework is \", \"impressive: to target every type of .NET \\ndevelopment present and future.  \\n.NET 5+ is .NET Core vNe\", \"xt  \\n.NET 5 was the next step forward with .NET Core. .NET 5 improved .NET in a few key ways:  \\n\\u2022 Pr\", \"oduced a single .NET runtime and framework that can be used everywhere and that has \\nuniform runtime\", \" behaviors and developer experiences.  \\n\\u2022 Expanded the capabilities of .NET by taking the best of .N\", \"ET Core, .NET Framework, Xamarin, \\nand Mono.  \\n\\u2022 Built that product out of a single code -base that \", \"developers (Microsoft and the community) \\ncan work on and expand together and that improves all scen\", \"arios.  \\n.NET 5 was a game -changer for .NET. With .NET 5 and later versions, your code and project \", \"files look \\nand feel the same no matter which type of app you\\u2019re building. You have access to the sa\", \"me runtime, \\nAPIs, and language capabilities with each app. This inc ludes new performance improveme\", \"nts that get \\ncommitted to the runtime almost daily. .NET 6 and .NET 7 made further improvements in \", \"reliability, \\nperformance, new APIs, and language features. For more details, see What\\u2019s new in .NET\", \" 5 , What\\u2019s \\nnew in .NET 6 , and What\\u2019s new in .NET 7 .  \\n12 CHAPTER 2 | What\\u2019s new with .NET for De\", \"sktop?  \\n  \\n.NET Framework vs.  .NET \\nSo now that you understand the relevance of .NET, you might be\", \" wondering what happens with .NET \\nFramework. You could be asking questions like: Do I have to aband\", \"on it? Is it going to disappear? \\nWhat are my choices to modernize the applications I have on .N ET \", \"Framework?  \\nIn 2019, .NET Framework 4.8 was released. It included three major improvements for desk\", \"top \\napplications:  \\n\\u2022 Modern browser and media controls : New controls were added that take advanta\", \"ge of \\nMicrosoft Edge and newer media players that support the latest standards.  \\n\\u2022 Access to UWP c\", \"ontrols : UWP introduced controls that take advantage of the latest \\nWindows features and touch disp\", \"lays. With .NET Framework 4.8, you don\\u2019t have to rewrite \\nyour applications to use these new feature\", \"s and controls, so you can use these new features \\nin your existing  WPF or Windows Forms code.  \\n\\u2022 \", \"High -DPI improvements : The resolution of displays increased to 4K and 8K, so, .NET \\nFramework 4.8 \", \"added new HDPI improvements to make sure existing Windows Forms and \\nWPF applications can look great\", \" on these new displays.  \\nSince .NET Framework is installed on millions of machines, Microsoft will \", \"continue to support it but \\nwon\\u2019t add new features.  \\n.NET (Core) is the open -source, cross -platfo\", \"rm, and fast -moving version of the .NET family. Because of \\nits side -by-side nature, it can take c\", \"hanges without the fear of breaking any application. This means \\nthat .NET will get new APIs and lan\", \"guage features o ver time that .NET Framework won\\u2019t. Also, .NET \\nalready has features that were impo\", \"ssible for .NET Framework, such as:  \\n\\u2022 Side-by-side versions of .NET supporting Windows Forms and W\", \"PF : This solves the \\nproblem of side effects when updating the machine\\u2019s framework version. Multipl\", \"e versions of \\n.NET can be installed on the same machine and each application specifies which versio\", \"n of \\n \\n13 CHAPTER 2 | What\\u2019s new with .NET for Desktop?  \\n .NET it should use. Even more, now you c\", \"an develop and run Windows Forms and WPF on top \\nof .NET.  \\n\\u2022 Embed .NET directly into an applicatio\", \"n : You can deploy .NET as part of your application \\npackage. This enables you to take advantage of \", \"the latest version, features, and APIs without \\nhaving to wait for a specific version to be installe\", \"d on the machine.  \\n\\u2022 Take advantage of .NET features : .NET is fast -moving and open -source. Its s\", \"ide -by-side \\nnature enables fast introduction of new innovative APIs and Base Class Library (BCL) \\n\", \"improvements without the risk of breaking compatibility. Now Windows Forms and WPF \\napplications can\", \" take advantage of the latest .NET features, which also includes fundamental \\nfixes for things like \", \"runtime performance and high -DPI support.  \\n.NET Framework will be fully supported and will always \", \"be a part of Windows. However, if you want to \\nuse the newest language features and APIs in the futu\", \"re, you\\u2019ll need to move your applications to \\n.NET. For brand -new desktop apps, we recommend starti\", \"ng d irectly on .NET 6 or a later version. It\\u2019s \\nlightweight and cross -platform, runs side by side,\", \" has high performance, and fits perfectly on \\ncontainers and microservices architectures.  \\n \\n.NET S\", \"tandard vs.  PCL \\n.NET Standard  is a formal specification of .NET APIs that are intended to be avai\", \"lable on all .NET \\nimplementations. The motivation behind .NET Standard was to establish greater uni\", \"formity in the .NET \\necosystem. .NET Standard is a specification of .NET APIs that make up  a unifor\", \"m set of contracts to \\ncompile your code against. These contracts are implemented in each .NET flavo\", \"r, thus enabling \\nportability across different .NET implementations.  \\n.NET Standard enables the fol\", \"lowing key scenarios:  \\n\\u2022 Defines uniform set of base class libraries APIs for all .NET implementati\", \"ons to implement, \\nindependent of the workload.  \\n\\u2022 Enables developers to produce portable libraries\", \" that are usable across .NET implementations, \\nusing this same set of APIs.  \\n \\n14 CHAPTER 2 | What\\u2019\", \"s new with .NET for Desktop?  \\n .NET Standard is the evolution of PCLs and the following list shows \", \"the fundamental differences \\nbetween .NET Standard and PCLs:  \\n\\u2022 .NET Standard is a set of curated A\", \"PIs, picked by Microsoft. PCLs aren\\u2019t.  \\n\\u2022 The APIs that a PCL contains are dependent on the platfor\", \"ms that you choose to target when \\nyou create it. This makes a PCL only sharable for the specific ta\", \"rgets that you choose.  \\n\\u2022 .NET Standard is platform -agnostic, so it can run on Windows, macOS, and\", \" Linux.  \\n\\u2022 PCLs can also run cross -platform, but they can only target a limited set of platforms. \", \" \\nNew Desktop features in .NET  \\nSupport for Windows Forms and WPF  \\nWindows Forms and WPF are part \", \"of .NET Core since version 3.0. Both presentation frameworks are \\nfor Windows only, so they aren\\u2019t c\", \"ross -platform. You can think of WPF as a rich layer over DirectX and \\nWindows Forms as a thinner la\", \"yer over GDI+. WPF and Windo ws Forms do a great job of exposing \\nand exercising much of the desktop\", \" application functionality in Windows. So Windows Forms and \\nWPF are available for .NET Core and .NE\", \"T Framework. Target your new desktop applications to .NET 6 \\nor later, and migrate your existing app\", \"s from .NET Framework to .NET 6 or later.  \\nA new version of .NET Standard, version 2.1, was release\", \"d at the same time as .NET Core 3.0. To see \\nwhich .NET implementations support which .NET Standard \", \"versions, see Which .NET Standard version \\nto target . \\nThe .NET (Core) implementations for both Win\", \"dows Forms and WPF are open source.  \\nXAML Islands  \\nXAML Islands  is a set of components for develo\", \"pers to use Windows 10 controls (UWP XAML controls) \\nin their WPF, Windows Forms, and native Win32 a\", \"pps (like MFC). You can have your \\u201cislands\\u201d of UWP \\nXAML controls wherever you want inside your Win3\", \"2 apps.  \\nThese XAML Islands are possible because Windows 10, version 1903 introduced a set of APIs \", \"that \\nallows hosting UWP XAML content in Win32 windows using windows handlers (HWnds). Only apps \\nru\", \"nning on Windows 10 1903 and later can use XAML Islands.  \\nTo make it easier to create XAML Islands \", \"for Windows Forms and WPF developers, the Windows \\nCommunity Toolkit introduces a set of .NET wrappe\", \"rs in several NuGet packages. Those wrappers are \\nthe wrapped and hosting controls:  \\n\\u2022 The WebView \", \", WebViewCompatible , InkCanvas , MediaPlayerElement , and MapControl  \\nwrapped controls wrap some U\", \"WP XAML controls into Windows Forms or WPF controls, \\nhiding UWP concepts for those developers.  \\n\\u2022 \", \"The WindowsXamlHost  control for Windows Forms and WPF allows other not -wrapped UWP \\nXAML controls \", \"and custom controls to be loaded into a XAML Island.   \\n15 CHAPTER 2 | What\\u2019s new with .NET for Desk\", \"top?  \\n Access to all Windows 10 and Windows 11 APIs  \\nWindows 10 and Windows 11 have a large number\", \" of APIs available for developers to work with. \\nThese APIs give access to a wide variety of functio\", \"nality like authentication, bluetooth, appointments, \\nand contacts. Now these APIs are exposed throu\", \"gh .NET and g ive Windows developers the chance to \\ncreate powerful desktops apps using the capabili\", \"ties present on Windows 10 and Windows 11.  \\nSide-by-side support and self -contained EXEs  \\nThe .NE\", \"T deployment model is one of the biggest benefits that Windows desktop developers will \\nexperience w\", \"ith .NET. The ability to globally install .NET provides much of the same central installation \\nand s\", \"ervicing benefits of .NET Framework, while not requ iring in -place updates.  \\nWhen a new .NET versi\", \"on is released, you can update each app on a machine as needed without any \\nconcern of affecting oth\", \"er applications. New .NET versions are installed in their own directories and \\nexist \\u201cside -by-side\\u201d\", \" with each other.  \\nIf you need to deploy with isolation, you can deploy .NET with your application.\", \" .NET will bundle your \\napp with the .NET runtime as a single executable. The modular architecture u\", \"sed by .NET makes these \\nflexible deployment options possible.  \\nPerformance  \\nSince its start, targ\", \"eting the web and cloud workloads, .NET has had performance plugged into its \\nDNA. Server -side code\", \" must be performant enough to fulfill high -concurrency scenarios and .NET 7 \\nscores today as the be\", \"st performance web platform in the mark et. \\nOld Windows Forms code has been refactored for .NET, wh\", \"ich reduced memory allocations for \\ndrawing Forms and Controls. By simply upgrading from .NET Framew\", \"ork to .NET or later, your \\napplications become much faster. You can take advantage of these perform\", \"anc e improvements when \\nyou use .NET to build your next generation of desktop applications.   \\n16 C\", \"HAPTER 3 | Migrating Modern Desktop applications  \\n CHAPTER  3 \\nMigrating Modern \\nDesktop applicatio\", \"ns  \\nIn this chapter, we\\u2019re exploring the most common issues and challenges you can face when migrat\", \"ing \\nan existing application from .NET Framework to .NET.  \\nIf you just want to update your applicat\", \"ion to the latest .NET version using a tool and not get into the \\ndetails of what\\u2019s happening behind\", \" the scenes, feel free to skip this chapter and find step -by-step \\ninstructions in the Example of m\", \"igrating to .NET  chapter.  \\nA complex desktop application doesn\\u2019t work in isolation and needs some \", \"kind of interaction with \\nsubsystems that may reside on the local machine or on a remote server. It \", \"will probably need some \\nkind of database to connect with as a persistence store either  locally or \", \"remotely. With the rise of \\nInternet and service -oriented architectures, it\\u2019s common to have your a\", \"pplication connected to some \\nsort of service residing on a remote server or in the cloud. You may n\", \"eed to access the machine file \\nsystem to implem ent some functionality. Alternatively, maybe you\\u2019re\", \" using a piece of functionality \\nthat resides inside a COM object outside your application, which is\", \" a common scenario if, for example, \\nyou\\u2019re integrating Office assemblies in your app.  \\nBesides, th\", \"ere are differences in the API surface that is exposed by .NET Framework and .NET, and \\nsome feature\", \"s that are available on .NET Framework aren\\u2019t available on .NET. It\\u2019s important for you to \\nknow and\", \" take them into account when planning a migrati on. \\nConfiguration files  \\nConfiguration files offer\", \" the possibility to store sets of properties that are read at run time and can \\naffect the behavior \", \"of your app, such as where to locate a database or how many times to execute a \\nloop. The beauty of \", \"this technique is that you can mo dify some aspects of the application without the \\nneed to recode a\", \"nd recompile. This comes in handy when, for example, the same app code runs on a \\ndevelopment enviro\", \"nment with a certain set of configuration values and in production environment \\nwith a differ ent se\", \"t.  \\nConfiguration on .NET Framework  \\nIf you have a working .NET Framework desktop application, cha\", \"nces are you have an app.config  file \\naccessed through the AppSettingsSection  class from the Syste\", \"m.Configuration namespace.   \\n17 CHAPTER 3 | Migrating Modern Desktop applications  \\n Within the .NE\", \"T Framework infrastructure, there\\u2019s a hierarchy of configuration files that inherit \\nproperties from\", \" its parents. You can find a machine.config  file that defines many properties and \\nconfiguration se\", \"ctions that can be used or overridden in any descendant configuration file.  \\nConfiguration on .NET \", \" \\nIn the .NET world, there\\u2019s no machine.config  file. And even though you can continue to use the ol\", \"d \\nfashioned System.Configuration  namespace, you may consider switching to the modern \\nMicrosoft.Ex\", \"tensions.Configuration , which offers a good number of enhancements.  \\nThis configuration API suppor\", \"ts the concept of a configuration provider, which defines the data source \\nto be used to load the co\", \"nfiguration. There are different kinds of built -in providers, such as:  \\n\\u2022 In-memory .NET objects  \", \"\\n\\u2022 INI files  \\n\\u2022 JSON files  \\n\\u2022 XML files  \\n\\u2022 Command -line arguments  \\n\\u2022 Environment variables  \\n\\u2022 \", \"Encrypted user store  \\nOr you can build your own.  \\nThe new configuration API allows a list of name \", \"-value pairs that can be grouped into a multi -level \\nhierarchy. Any stored value maps to a string, \", \"and there\\u2019s built -in binding support that allows you to \\ndeserialize settings into a custom plain o\", \"ld CLR object  (POCO).  \\nThe ConfigurationBuilder  object lets you add as many configuration provide\", \"rs as you may need for \\nyour application. A precedence rule is used to resolve provider preference. \", \"So, the last provider you \\nadd in your code overrides the others. This is a great feature for managi\", \"ng diffe rent environments for \\nexecution since you can define different configurations for developm\", \"ent, testing, and production \\nenvironments. And you can manage them in a single function inside your\", \" code.  \\nMigrating configuration files  \\nYou can continue to use your existing app.config XML file. \", \"However, you could take this opportunity \\nto migrate your configuration to benefit from the several \", \"enhancements made in .NET.  \\nTo migrate from an old -style app.config  to a new configuration file, \", \"you should choose between an \\nXML format and a JSON format.  \\nIf you choose XML, the conversion is s\", \"traightforward. Since the content is the same, just save the \\napp.config  file with XML as type. The\", \"n, change the code that references AppSettings to use the \\nConfigurationBuilder  class. This change \", \"should be easy.  \\nIf you want to use a JSON format and you don\\u2019t want to migrate by hand, there\\u2019s a \", \"tool called dotnet -\\nconfig2json  that can convert an app.config  file to a JSON configuration file.\", \"  \\nYou may come across some issues when using configuration sections that were defined in the \\nmachi\", \"ne.config  file. For example, consider the following configuration:   \\n18 CHAPTER 3 | Migrating Mode\", \"rn Desktop applications  \\n <configuration > \\n    <system.diagnostics > \\n        <switches > \\n       \", \"     <add name=\\\"General\\\"  value=\\\"4\\\" /> \\n        </switches > \\n        <trace autoflush= \\\"true\\\" inden\", \"tsize= \\\"2\\\"> \\n            <listeners > \\n                <add name=\\\"myListener\\\"  \\n                    \", \" type=\\\"System.Diagnostics.TextWriterTraceListener,  \\n                           System, Version=1.0.\", \"3300.0, Culture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\"  \\n                     initializeData= \\\"M\", \"yListener.log\\\"  \\n                     traceOutputOptions= \\\"ProcessId, LogicalOperationStack, Timesta\", \"mp, \\nThreadId, Callstack, DateTime\\\"  /> \\n            </listeners > \\n        </trace> \\n    </system.d\", \"iagnostics > \\n</configuration > \\nIf you take this configuration to a .NET app, you\\u2019ll get an excepti\", \"on:  \\nUnrecognized configuration section System.Diagnostics  \\nThis exception occurs because that sec\", \"tion and the assembly responsible for handling that section \\nwas defined in the machine.config  file\", \", which now doesn\\u2019t exist.  \\nTo easily fix the issue, you can copy the section definition from your \", \"old machine.config  to your new \\nconfiguration file:  \\n<configSections > \\n    <section name=\\\"system.\", \"diagnostics\\\"  \\n             type=\\\"System.Diagnostics.SystemDiagnosticsSection,  \\n                   \", \"System, Version=4.0.0.0, Culture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\" /> \\n</configSections > \\n\", \"Accessing databases  \\nAlmost every desktop application needs some kind of database. For desktop, it\\u2019\", \"s common to find \\nclient -server architectures with a direct connection between the desktop app and \", \"the database \\nengine. These databases can be local or remote depending on the nee d to share informa\", \"tion between \\ndifferent users.  \\nFrom the code perspective, there have been many technologies and fr\", \"ameworks to give the developer \\nthe possibility to connect, query, and update a database.  \\nThe most\", \" common examples of database you can find when talking about Windows Desktop \\napplication are Micros\", \"oft Access and Microsoft SQL Server. If you have more than 20 years of \\nexperience programming for t\", \"he desktop, names like ODBC, OLEDB, RDO, ADO, ADO. NET, LINQ, and \\nEntity Framework will sound famil\", \"iar.   \\n19 CHAPTER 3 | Migrating Modern Desktop applications  \\n ODBC  \\nYou can continue to use ODBC \", \"on .NET since Microsoft is providing the System.Data.Odbc library \\ncompatible with .NET Standard 2.0\", \".  \\nOLE DB  \\nOLE DB  has been a great way to access various data sources in a uniform manner. But it\", \" was based on \\nCOM, which is a Windows -only technology, and as such wasn\\u2019t the best fit for a cross\", \" -platform \\ntechnology such as .NET. It\\u2019s also unsupported in SQL Server version s 2014 and later. F\", \"or those \\nreasons, OLE DB won\\u2019t be supported by .NET.  \\nADO.NET  \\nYou can still use ADO.NET from you\", \"r existing desktop code on .NET. You just need to update some \\nNuGet packages.  \\nEF Core vs.  EF6 \\nT\", \"here are two currently supported versions of Entity Framework (EF), Entity Framework 6 (EF6) and EF \", \"\\nCore.  \\nThe latest technology released as part of the .NET Framework world is Entity Framework, wit\", \"h 6.4 \\nbeing the latest version. With the launch of .NET Core, Microsoft also released a new data ac\", \"cess stack \\nbased on Entity Framework and called Entity Framework C ore. \\nYou can use EF 6.4 and EF \", \"Core from both .NET Framework and .NET. So, what are the decision drivers \\nto help to decide between\", \" the two?  \\nEF 6.3 is the first version of EF6 that can run on .NET and work cross -platform. In fac\", \"t, the main goal of \\nthis release was to make it easier to migrate existing applications that use EF\", \"6 to .NET.  \\nEF Core was designed to provide a developer experience similar to EF6. Most of the top \", \"-level APIs \\nremain the same, so EF Core will feel familiar to developers who have used EF6.  \\nAltho\", \"ugh compatible, there are differences on the implementation you should check before making a \\ndecisi\", \"on. For more information, see Compare EF Core & EF6 . \\nThe recommendation is to use EF Core if:  \\n\\u2022 \", \"The app needs the capabilities of .NET.  \\n\\u2022 EF Core supports all of  the features that the app requi\", \"res.  \\nConsider using EF6 if both of the following conditions are true:  \\n\\u2022 The app will run on Wind\", \"ows and .NET Framework 4.0 or later.  \\n\\u2022 EF6 supports all of the features that the app requires.   \\n\", \"20 CHAPTER 3 | Migrating Modern Desktop applications  \\n Relational databases  \\nSQL Server  \\nSQL Serv\", \"er has been one of the databases of choice if you were developing for the desktop some \\nyears ago. W\", \"ith the use of System.Data.SqlClient  in .NET Framework, you could access versions of SQL \\nServer, w\", \"hich encapsulates database -specific protocols.  \\nIn .NET, you can find a new SqlClient class, fully\", \" compatible with the one existing in the .NET \\nFramework but located in the Microsoft.Data.SqlClient\", \"  library. You just have to add a reference to the \\nMicrosoft.Data.SqlClient  NuGet package and do s\", \"ome renaming for the namespaces and everything \\nshould work as expected.  \\nMicrosoft Access  \\nMicros\", \"oft Access has been used for years when the sophisticated and more scalable SQL Server wasn\\u2019t \\nneede\", \"d. You can still connect to Microsoft Access using the System.Data.Odbc  library.  \\nConsuming servic\", \"es  \\nWith the rise of service -oriented architectures, desktop applications began to evolve from a c\", \"lient -\\nserver model to the three -layer approach. In the client -server approach, a direct database\", \" connection \\nis established from the client holding the business lo gic, usually inside a single EXE\", \" file. On the other \\nhand, the three -layer approach establishes an intermediate service layer imple\", \"menting business logic \\nand database access, allowing for better security, scalability, and reusabil\", \"ity. Instead of working \\ndirectly with underlying data, the layered approach relies on a set of serv\", \"ices implementing contracts \\nand typed objects for data transfer.  \\nIf you have a desktop applicatio\", \"n using a WCF service and you want to migrate it to .NET, there are \\nsome things to consider.  \\nThe \", \"first thing is how to resolve the configuration to access the service. Because the configuration is \", \"\\ndifferent on .NET, you\\u2019ll need to make some updates in your configuration file.  \\nSecond, you\\u2019ll ne\", \"ed to regenerate the service client with the new tools present on Visual Studio 2019 \\nand Visual Stu\", \"dio 2022. In this step, you must consider activating the generation of the synchronous \\noperations t\", \"o make the client compatible with your ex isting code.  \\nAfter the migration, if you find that there\", \" are libraries you need that aren\\u2019t present on .NET, you can \\nadd a reference to the Microsoft.Windo\", \"ws.Compatibility  NuGet package and see if the missing \\nfunctions are there.  \\nIf you\\u2019re using the W\", \"ebRequest  class to perform web service calls, you may find some differences on \\n.NET. The recommend\", \"ation is to use HttpClient  instead.   \\n21 CHAPTER 3 | Migrating Modern Desktop applications  \\n Cons\", \"uming a COM Object  \\nCurrently, there\\u2019s no way to add a reference to a COM object from Visual Studio\", \" 2019 or Visual Studio \\n2022 to use with .NET. So, you have to manually modify the project file.  \\nI\", \"nsert a COMReference structure inside the project file like in the following example:  \\n<ItemGroup >\", \" \\n    <COMReference  Include= \\\"MSHTML\\\" > \\n        <Guid>{3050F1C5 -98B5-11CF-BB82-00AA00BDCE0B} \\\\</G\", \"uid> \\n        <VersionMajor >4</ VersionMajor > \\n        <VersionMinor >0</ VersionMinor > \\n        \", \"<Lcid>0</ Lcid> \\n        <WrapperTool >primary</ WrapperTool > \\n        <Isolated >false</ Isolated \", \"> \\n    </COMReference > \\n</ItemGroup > \\nMore things to consider  \\nSeveral technologies available to \", \".NET Framework libraries aren\\u2019t available for .NET Core or .NET 7. If \\nyour code relies on some of t\", \"hese technologies, consider the alternative approaches outlined in this \\nsection.  \\nThe Windows Comp\", \"atibility Pack  provides access to APIs that were previously available only for .NET \\nFramework. It \", \"can be used on .NET Core and .NET Standard projects.  \\nFor more information on API compatibility, yo\", \"u can find documentation about breaking changes and \\ndeprecated/legacy APIs at https://learn.microso\", \"ft.com/dotnet/core/compatibility/fx -core. \\nAppDomains  \\nApplication domains (AppDomains) isolate ap\", \"ps from one another. AppDomains require runtime \\nsupport and are expensive. Creating additional app \", \"domains isn\\u2019t supported. For code isolation, we \\nrecommend separate processes or using containers as\", \" an alternative . For the dynamic loading of \\nassemblies, we recommend the new AssemblyLoadContext  \", \"class.  \\nTo make code migration from .NET Framework easier, .NET exposes some of the AppDomain  API \", \"\\nsurface. Some of the APIs function normally (for example, AppDomain.UnhandledException ), some \\nmem\", \"bers do nothing (for example, SetCachePath ), and some of them throw \\nPlatformNotSupportedException \", \" (for example, CreateDomain ). \\nRemoting  \\n.NET Remoting was used for cross -AppDomain communication\", \", which is no longer supported. Also, \\nRemoting requires runtime support, which is expensive to main\", \"tain. For these reasons, .NET Remoting \\nisn\\u2019t supported on .NET.  \\nFor communication across processe\", \"s, you should consider inter -process communication (IPC) \\nmechanisms as an alternative to Remoting,\", \" such as the  or the MemoryMappedFile  class.   \\n22 CHAPTER 3 | Migrating Modern Desktop application\", \"s  \\n Across machines, use a network -based solution as an alternative. Preferably, use a low -overhe\", \"ad \\nplaintext protocol, such as HTTP. The Kestrel web server, the web server used by ASP.NET Core, i\", \"s an \\noption here.  \\nCode Access Security (CAS)  \\nSandboxing, which relies on the runtime or the fra\", \"mework to constrain which resources a managed \\napplication or library uses or runs, isn\\u2019t supported \", \"on .NET.  \\nUse security boundaries that are provided by the operating system, such as virtualization\", \", containers, \\nor user accounts, for running processes with the minimum set of privileges.  \\nSecurit\", \"y Transparency  \\nSimilar to CAS, Security Transparency separates sandboxed code from security critic\", \"al code in a \\ndeclarative fashion but is no longer supported as a security boundary.  \\nUse security \", \"boundaries that are provided by the operating system, such as virtualization, containers, \\nor user a\", \"ccounts, for running processes with the least set of privileges.   \\n23 CHAPTER 4 | Windows 10 migrat\", \"ion  \\n CHAPTER  4 \\nWindows 10 migration  \\nConsider the following situation: You have a working deskt\", \"op application that was developed in the \\nWindows 7 days. It\\u2019s using WPF technology available at tha\", \"t time and working fine but it has an \\noutdated UI and behaviors when you run it on Windows 10 or Wi\", \" ndows 11. It is like when you watch a \\nfuturistic movie like Matrix and you see Neo using the Nokia\", \" 8110 device. The film works great after \\n20 years but it would rather benefit from a device moderni\", \"zation.  \\nWith the release of Windows 10, Microsoft introduced many innovations to support scenarios\", \" like \\ntablets and touch devices and to provide the best experience for users for a Microsoft operat\", \"ing \\nsystem ever. For example, you can:  \\n\\u2022 Sign in with your face using Windows Hello.  \\n\\u2022 Use a pe\", \"n to draw or handwrite text that is automatically recognized and digitalized.  \\n\\u2022 Run locally custom\", \"ized AI models built on the cloud using WinML.  \\nAll these features are enabled for Windows develope\", \"rs through Windows Runtime (WinRT) libraries. \\nYou can take advantage of these features in your exis\", \"ting desktop apps because the libraries are \\nexposed to both the .NET Framework and .NET as well. Yo\", \"u can e ven modernize your UI with the use \\nof XAML Islands and improve the visuals and behavior of \", \"your apps according to the times.  \\nOne important thing to note here is that you don\\u2019t need to aband\", \"on .NET Framework technology to \\nfollow this modernization path. You can safely stay on there and ha\", \"ve all the benefits of Windows 10 \\nand Windows 11 without the pressure to migrate to .NET. So,  you \", \"get both the power and the \\nflexibility to choose your modernization path.  \\nWinRT APIs  \\nWinRT APIs\", \" are object -oriented, well -structured application programming interfaces (APIs) that give \\nWindows\", \" 10 and Windows 11 developers access to everything the operating system has to offer. \\nThrough WinRT\", \" APIs, you can integrate functionalities like Push  Notifications, Device APIs, Microsoft \\nInk, and \", \"WinML, among others on your desktop apps.  \\nIn general, WinRT APIs can be called from a classic desk\", \"top app. However, two main areas present an \\nexception to this rule:  \\n\\u2022 APIs that require a package\", \" identity.  \\n\\u2022 APIs that require visualization like XAML or Composition.   \\n24 CHAPTER 4 | Windows 1\", \"0 migration  \\n Universal Windows Platform (UWP) packages  \\nApplication Package Identity  \\nUWP apps h\", \"ave a deployment system where the OS manages the installation and uninstallation of \\napplication. Th\", \"at requires the installation to be declarative, meaning that no user code is executed \\nduring instal\", \"l. Instead, everything the app wants to integrat e with the system, such as protocols, file \\ntypes, \", \"and extensions, is declared in the application manifest. At deployment time, the deployment \\npipelin\", \"e configures those integration points. The only way for the OS to manage all this functionality \\nand\", \" keep tr ack of it is for each \\u2018package\\u2019 to have an identity, a unique identifier for the applicatio\", \"n.  \\nSome WinRT APIs require this package identity to work as expected. However, classic desktop app\", \"s \\nlike native C++ or .NET apps, use different deployment systems that don\\u2019t require a package ident\", \"ity. \\nIf you want to use these WinRT APIs in your desktop appli cation, you need to provide them a p\", \"ackage \\nidentity.  \\nOne way to proceed is to build an additional packaging project. Inside the packa\", \"ging project, you \\npoint to the original source code project and specify the Identity information yo\", \"u want to provide. If \\nyou install the package and run the installed app, it w ill automatically get\", \" an identify enabling your \\ncode to call all WinRT APIs requiring Identity.  \\n<?xml version= \\\"1.0\\\" e\", \"ncoding= \\\"utf-8\\\"?> \\n<Package xmlns=\\\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\\\"\", \"  \\n         xmlns:uap= \\\"http://schemas.microsoft.com/appx/manifest/uap/windows10\\\" > \\n    <Identity  \", \"Name=\\\"YOUR-APP-GUID \\\" \\n              Publisher= \\\"CN=YOUR COMPANY\\\"  \\n              Version= \\\"1.x.x.x\\\"\", \"  /> \\n</Package> \\nYou can check which APIs need a packaged application identity by inspecting if the\", \" type that contains \\nthe API is marked with the DualApiPartition  attribute. If it is, you can call \", \"if from an unpackaged \\ntraditional desktop app. Otherwise, you must convert your classic desktop app\", \" to a UWP with the help \\nof a packaging project.  \\nhttps://learn.microsoft.com/windows/desktop/apiin\", \"dex/uwp -apis-callable -from -a-classic -desktop -app \\nBenefits of packaging  \\nBesides giving you ac\", \"cess to these APIs,  you get some additional benefits by creating a Windows App \\npackage for your de\", \"sktop application including:  \\n\\u2022 Streamlined deployment . Apps have a great deployment experience en\", \"suring that users can \\nconfidently install an application and update it. If a user chooses to uninst\", \"all the app, it\\u2019s \\nremoved completely with no trace left behind preventing the Windows rot problem. \", \" \\n\\u2022 Automatic updates and licensing . Your application can participate in the Microsoft Store\\u2019s \\nbui\", \"lt-in licensing and automatic update facilities. Automatic update is a highly reliable and \\nefficien\", \"t mechanism, because only the changed parts of files are downloaded.   \\n25 CHAPTER 4 | Windows 10 mi\", \"gration  \\n \\u2022 Increased reach and simplified monetization . Maybe not your case but if you choose to \", \"\\ndistribute your application through the Microsoft Store you reach millions of Windows 10 and \\nWindo\", \"ws 11 users.  \\n\\u2022 Add UWP features . You can add UWP features to your app\\u2019s package at your own pace.\", \"  \\nPrepare for packaging  \\nBefore proceeding to package your desktop application, there are some poi\", \"nts you have to address \\nbefore starting the process. Your application must respect any of the Micro\", \"soft Store rules and \\npolicies and run in the UWP application model. For example, it has to run on t\", \"he .NET Framework 4.6.2 \\nor later and writes to the HKEY_CURRENT_USER registry hive and the AppData \", \"folders will be \\nvirtualized to a user -specific app -local location.  \\nThe design goal for packagin\", \"g is to separate the application state from system state while maintaining \\ncompatibility with other\", \" apps. Windows 10 and Windows 11 accomplish this goal by placing the \\napplication inside a UWP packa\", \"ge. It detects and redirects s ome changes to the file system and \\nregistry at run time to fulfill t\", \"he promise of a trusted and clean install and uninstall behavior of an \\napplication provided by pack\", \"aging.  \\nPackages that you create for your desktop application are desktop -only, full -trust applic\", \"ations that \\naren\\u2019t sandboxed, although there\\u2019s lightweight virtualization applied to the app for wr\", \"ites to HKCU \\nand AppData. This virtualization allows them to interac t with other apps the same way\", \" classic desktop \\napplications do.  \\nInstallation  \\nApp packages are installed under %ProgramFiles% \", \"\\\\WindowsApps \\\\package_name , with the executable \\ntitled app_name.exe. Each package folder contains \", \"a manifest (named AppxManifest.xml) that contains \\na special XML namespace for packaged apps. Inside\", \" that manifest file is an <EntryPoint> element, \\nwhich references the full -trust app. When that app\", \"lication is launched, it doesn\\u2019t run inside an app \\ncontainer, but instead it runs as the user as it\", \" normally would.  \\nAfter deployment, package files are marked read -only and heavily locked down by \", \"the operating \\nsystem. Windows prevents apps from launching if these files are tampered with.  \\nFile\", \" system  \\nThe OS supports different levels of file system operations for packaged desktop applicatio\", \"ns, \\ndepending on the folder location.  \\nWhen trying to access the user\\u2019s AppData  folder, the syste\", \"m creates a private per -user, per -app \\nlocation behind the scenes. This creates the illusion that \", \"the packaged application is editing the real \\nAppData  when it\\u2019s actually modifying a private copy. \", \"By redirecting writes this way, the system can \\ntrack all file modifications made by the app. It can\", \" then clean all those files when uninstalling reducing \\nsystem \\u201crot\\u201d and providing a better applicat\", \"ion removal experience for the user.   \\n26 CHAPTER 4 | Windows 10 migration  \\n Registry  \\nApp packag\", \"es contain a registry.dat file, which serves as the logical equivalent of HKLM \\\\Software in \\nthe rea\", \"l registry. At run time, this virtual registry merges the contents of this hive into the native \\nsys\", \"tem hive to provide a singular view of both.  \\nAll writes are kept during package upgrade and only d\", \"eleted when the application is uninstalled.  \\nUninstallation  \\nWhen the user uninstalls a package, a\", \"ll files and folders located under C: \\\\Program \\nFiles\\\\WindowsApps \\\\package_name are removed, as well\", \" as any redirected writes to AppData or the \\nregistry that were captured during the process.  \\nFor d\", \"etails about how a packaged application handles installation, file access, registry, and \\nuninstalla\", \"tion, see https://learn.microsoft.com/windows/msix/desktop/desktop -to-uwp-behind -the-\\nscenes . \\nYo\", \"u can get a complete list of things to check on \\nhttps://learn.microsoft.com/windows/msix/desktop/de\", \"sktop -to-uwp-prepare . \\nHow to add WinRT APIs to your desktop project  \\nIn this section, you can fi\", \"nd a walkthrough on how to integrate Toast Notifications in an existing WPF \\napplication. Although i\", \"t\\u2019s simple from the code perspective, it helps illustrate the whole process. \\nNotifications are one \", \"of the many available WinRT API s available that you can use in .NET app. In this \\ncase, the API req\", \"uires a Package Identity. This process is more straightforward if the APIs don\\u2019t require \\nPackage Id\", \"entity.  \\nLet\\u2019s take an existing WPF sample app that reads files and shows its contents on the scree\", \"n. The goal \\nis to display a Toast Notification when the application starts.   \\n27 CHAPTER 4 | Windo\", \"ws 10 migration  \\n  \\nFirst, you should check in the following link whether the Windows 10 or Windows\", \" 11 API that you\\u2019ll \\nuse requires a Package Identity:  \\nhttps://learn.microsoft.com/windows/apps/des\", \"ktop/modernize/desktop -to-uwp-supported -api \\nOur sample will use the Windows.UI.Notifications.Noti\", \"fication  API that requires a packaged identity:  \\n \\nTo access the WinRT API, add a reference to the\", \" Microsoft.Windows.SDK.Contracts NuGet package \\nand this package will do the magic behind the scenes\", \" (see details at \\nhttps://blogs.windows.com/windowsdeveloper/2019/04/30/calling -windows -10-apis-fr\", \"om -a-desktop -\\napplication -just-got-easier/ ). \\nYou\\u2019re now prepared to start adding some code.  \\n \", \"\\n28 CHAPTER 4 | Windows 10 migration  \\n Create a ShowToastNotification method that will be called on\", \" application startup. It just builds a toast \\nnotification from an XML pattern:  \\nprivate void ShowN\", \"otification (string title, string content, string image) \\n{ \\n    string xmlString = $@\\\"<toast><visua\", \"l><binding template = \\n'ToastGeneric'><text>{title}</text><text>{content}</text><image \\nsrc=>'{image\", \"}'</image></binding></visual></toast>\\\" ; \\n    XmlDocument toastXml = new XmlDocument (); \\n    toastX\", \"ml .LoadXml(xmlString ); \\n    ToastNotification toast = new ToastNotification (toastXml ); \\n    Toas\", \"tNotificationManager .CreateToastNotifier ().Show(toast); \\n} \\nAlthough the project builds , there ar\", \"e errors because the Notifications API requires a Package Identity \\nand you didn\\u2019t provide it. Addin\", \"g a Windows Packaging Project to the solution will fix the issue:  \\n \\nSelect the minimum Windows ver\", \"sion you want to support and the version you\\u2019re targeting. Not all \\nthe WinRT APIs are supported in \", \"all Windows 10 and Windows 11 versions. Each Windows 10 or \\nWindows 11 update adds new APIs that are\", \" only available from this ve rsion; down -level support isn\\u2019t \\navailable.  \\n \\n29 CHAPTER 4 | Windows\", \" 10 migration  \\n  \\nNext step is to add the WPF application to the Windows Packaging Project by addin\", \"g a project \\nreference:  \\n \\n30 CHAPTER 4 | Windows 10 migration  \\n  \\n \\nA Windows Packaging Project c\", \"an package several apps so you should set which one is the Entry \\nPoint:  \\n \\n31 CHAPTER 4 | Windows \", \"10 migration  \\n  \\nNext step is to set the WPF Project as the startup Project in the solution configu\", \"ration. You can press \\nF5 to compile and build and see the results.  \\n \\nLet\\u2019s generate the package s\", \"o you can install your app. Right click on Store  > Create App Packages . \\n \\n32 CHAPTER 4 | Windows \", \"10 migration  \\n  \\nSelect the sideloading option to deploy the app from your machine:  \\n \\n33 CHAPTER \", \"4 | Windows 10 migration  \\n  \\nSelect the application architecture of your app:  \\n \\n34 CHAPTER 4 | Wi\", \"ndows 10 migration  \\n  \\nFinally, create the package by clicking on Create . \\nXAML Islands  \\nXAML Isl\", \"ands are a set of components that enable Windows desktop developers to use UWP XAML \\ncontrols on the\", \"ir existing Win32 applications, including Windows Forms and WPF.  \\n \\n35 CHAPTER 4 | Windows 10 migra\", \"tion  \\n  \\nYou can image your Win32 app with your standard controls and among them an \\u201cisland\\u201d of UWP\", \" UI \\ncontaining controls from the modern world. The concept is similar to having an iFrame inside a \", \"web \\npage that shows content from a different page.  \\nBesides adding functionality from the Windows \", \"10 and Windows 11 APIs, you can add pieces of UWP \\nXAML inside of your app using XAML Islands.  \\nWin\", \"dows 10 1903 update introduced a set of APIs that allow hosting UWP XAML content in Win32 \\nwindows. \", \"Only apps running on Windows 10 1903 or later can use XAML Islands.  \\nThe road to XAML Islands  \\nThe\", \" road to XAML Islands started in 2012 when Microsoft introduced the WinRT APIs as a framework \\nto mo\", \"dernize the Win32 apps (Windows Forms, WPF, and native Win32 apps). However, the new UI \\ncontrols in\", \"side WinRT were available for new applications but not for existing ones.  \\nIn 2015, along with Wind\", \"ows 10, UWP was born. UWP allows you to create apps that work across \\nWindows devices like XBox, Mob\", \"ile, and Desktop. One year later, Microsoft announced Desktop \\nBridge (formerly known as Project Cen\", \"tennial). Desktop Bridge is a set of tools that allowed \\ndevelopers to bring their existing Win32 ap\", \"ps to the Microsoft Store. More capabilities were added in \\n2017, allowing developers to enhance the\", \"ir Win32 apps leveraging some of the new Windows 10 APIs, \\nlike live tiles and notifications on the \", \"action center. But still, no new UI controls.  \\nAt Build 2018, Microsoft announced a way for develop\", \"ers to use the new Windows 10 XAML controls \\ninto their current Win32 apps, without fully migrating \", \"their apps to UWP. It was branded as UWP \\nXAML Islands.  \\nHow it works  \\nThe Windows 10 1903 update \", \"introduced several XAML hosting APIs. Two of them are \\nWindowsXamlManager and DesktopWindowXamlSourc\", \"e.  \\n \\n36 CHAPTER 4 | Windows 10 migration  \\n The WindowsXamlManager class handles the UWP XAML Fram\", \"ework. Its InitializeForCurrentThread \\nmethod loads the UWP XAML Framework inside the current thread\", \" of the Win32 app.  \\nThe DesktopWindowXamlSource is the instance of your XAML Island content. It has\", \" the Content \\nproperty, which you\\u2019re responsible for instantiating and setting. The DesktopWindowXam\", \"lSource \\nrenders and gets its input from an HWND. It needs to know to which oth er HWND it will atta\", \"ch the \\nXAML Island\\u2019s one, and you\\u2019re responsible for sizing and positioning the parent\\u2019s HWND.  \\nWP\", \"F or Windows Forms developers don\\u2019t usually deal with HWND inside their code, so it may be hard \\nto \", \"understand and handle HWND pointers and the underlying wiring stuff to communicate Win32 and \\nUWP wo\", \"rlds.  \\nThe XAML Islands .NET Wrappers  \\nThe Windows Community Toolkit has a set the XAML Islands .N\", \"ET wrappers for WPF or Windows \\nForms that make easier to use XAML Islands. These wrappers manage th\", \"e HWNDs, the focus \\nmanagement, among other things. Windows Forms and WPF developers should use the \", \"se wrappers.  \\nThe Windows Community Toolkit offers two types of controls: Wrapped Controls and Host\", \"ing \\nControls.  \\nWrapped Controls  \\nThese wrapped controls wrap some UWP controls into Windows Forms\", \" or WPF controls, hiding UWP \\nconcepts for those developers. These controls are:  \\n\\u2022 WebView and Web\", \"ViewCompatible  \\n\\u2022 InkCanvas and InkToolbar  \\n\\u2022 MediaPlayerElement  \\n\\u2022 MapControl  \\nAdd the Microsof\", \"t.Toolkit.Wpf.UI.Controls package to your project, include the reference to the \\nnamespace, and star\", \"t using them.  \\n<Window \\n        ... \\n        xmlns:uwpControls= \\\"clr-\\nnamespace:Microsoft.Toolkit.W\", \"pf.UI.Controls;assembly=Microsoft.Toolkit.Wpf.UI.Controls\\\" > \\n<Grid> \\n    <Grid.RowDefinitions > \\n  \", \"      <RowDefinition  Height=\\\"Auto\\\"/> \\n        <RowDefinition  Height=\\\"\\\\*\\\"/> \\n    </Grid.RowDefiniti\", \"ons > \\n    <uwpControls:InkToolbar  TargetInkCanvas= \\\"{x:Reference Name=inkCanvas}\\\" /> \\n    <uwpCont\", \"rols:InkCanvas  Grid.Row= \\\"1\\\" x:Name=\\\"inkCanvas\\\"  /> \\n</Grid> \\nHosting controls  \\nThe power of XAML \", \"Islands extends to most first -party controls, third -party controls, and custom \\ncontrols developed\", \" for UWP, which can be integrated into Windows Forms and WPF as \\u201cIslands\\u201d with \\nfully functional UI.\", \" The WindowsXamlHost control for WPF and W indows Forms allows doing this.   \\n37 CHAPTER 4 | Windows\", \" 10 migration  \\n For example, to use the WindowsXamlHost control in WPF, add a reference to the \\nMic\", \"rosoft.Toolkit.Wpf.UI.XamlHost package provided by the Windows Community Toolkit.  \\nOnce you\\u2019ve plac\", \"ed your WindowsXamlHost into your UI code, specify which UWP type you want to \\nload. You can choose \", \"to use a wrapped control like a Button or a more complex one composed of \\nseveral different controls\", \", which are a custom UWP control.  \\nThe following example shows how to add a UWP Button:  \\n<Window \\n\", \"        ... \\n        xmlns:xamlhost= \\\"clr-\\nnamespace:Microsoft.Toolkit.Wpf.UI.XamlHost;assembly=Micr\", \"osoft.Toolkit.Wpf.UI.XamlHost\\\" > \\n \\n<xamlhost:WindowsXamlHost  x:Name=\\\"myUwpButton\\\"  \\n              \", \"            InitialTypeName= \\\"Windows.UI.Xaml.Controls.Button\\\"  /> \\nThere\\u2019s a clear recommendation o\", \"n how to approach this and it\\u2019s better to have one single and bigger \\nXAML Island containing a custo\", \"m composite control than to have several islands with one control on \\neach.  \\nOne of the core featur\", \"es of XAML is binding and it works between your Win32 code and the island. \\nSo, you can bind, for in\", \"stance, a Win32 Textbox with a UWP Textbox. One important thing to consider \\nis that these bindings \", \"are one -way bindings, from UWP to Wi n32, so if you update the Textbox inside \\nthe XAML Island the \", \"Win32 Textbox will be updated, but not the other way around.  \\nTo see a walkthrough about how to use\", \" XAML Islands, see:  \\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/host -standard -con\", \"trol -with-xaml -\\nislands  \\nAdding UWP XAML custom controls  \\nA XAML custom control is a control (or\", \" user control) created by you or by third parties (including \\nWinUI 2.x controls). To host a custom \", \"UWP control in a Windows Forms or WPF app, you\\u2019ll need:  \\n\\u2022 To use the WindowsXamlHost UWP control i\", \"n your .NET app.  \\n\\u2022 To create a UWP app project that defines a XamlApplication object.  \\nYour WPF o\", \"r Windows Forms project must have access to an instance of the \\nMicrosoft.Toolkit.Win32.UI.XamlHost.\", \"XamlApplication class provided by the Windows Community \\nToolkit. This object acts as a root metadat\", \"a provider for loading metadata for custom UWP X AML \\ntypes in assemblies in the current directory o\", \"f your application. The recommended way to do this is to \\nadd a Blank App (Universal Windows) projec\", \"t to the same solution as your WPF or Windows Forms \\nproject and revise the default App class in thi\", \"s projec t. \\nThe custom UWP XAML control can be included on this UWP app or in an independent UWP Cl\", \"ass \\nLibrary project that you reference in the same solution as your WPF or Windows Forms project.  \", \"\\nYou can check a detailed step -by-step process description at:  \\nhttps://learn.microsoft.com/window\", \"s/apps/desktop/modernize/host -custom -control -with-xaml -\\nislands   \\n38 CHAPTER 4 | Windows 10 mig\", \"ration  \\n The Windows UI Library (WinUI 2)  \\nBesides the inbox Windows 10 controls that comes with t\", \"he OS, the same UWP XAML team also \\ndelivers additional controls in the Windows UI Library ( WinUI 2\", \" ). WinUI 2 provides official native \\nMicrosoft UI controls and features for Windows UWP apps and th\", \"ese controls can be used inside of \\nXAML Islands.  \\nWinUI 2 is open source and you can find informat\", \"ion at https://github.com/microsoft/microsoft -ui-\\nxaml . \\nThe following article demonstrates how to\", \" host a UWP XAML control from the WinUI 2 library: \\nhttps://learn.microsoft.com/windows/apps/desktop\", \"/modernize/host -custom -control -with-xaml -\\nislands  \\nDo you need XAML Islands  \\nXAML Islands are \", \"intended for existing Win32 apps that want to improve their user experience by \\nleveraging new UWP c\", \"ontrols and behaviors without a full rewrite of the app. You could already \\nleverage Windows 10 and \", \"Windows 11 APIs , but up until XAML Islands, only non -UI related APIs.  \\nIf you\\u2019re developing a new\", \" Windows App, a UWP App  is probably the right approach.  \\nThe road ahead XAML Islands: WinUI 3.0  \\n\", \"Since Windows 8, the Windows UI platform, including the XAML UI framework, visual composition \\nlayer\", \", and input processing has been shipped as an integral part of Windows. This means that to \\nbenefit \", \"from the latest improvements on UI technologies, you must upgrade to the latest version of \\nthe UI, \", \"slowing down the pace of innovation when you develop your apps. To decouple these two \\nevolution cyc\", \"les and foster innovation, Microsoft is actively working on the WinUI project.  \\nStarting with WinUI\", \" 2 in 2018, Microsoft started shipping some new XAML UI controls and features as \\nseparate NuGet pac\", \"kages that build on top of the UWP SDK.   \\n39 CHAPTER 4 | Windows 10 migration  \\n  \\nWinUI 3 is under\", \" active development and will greatly expand the scope of WinUI to include the full UI \\nplatform, whi\", \"ch will be fully decoupled from the UWP SDK:  \\n \\nXAML framework will now be developed on GitHub and \", \"shipped out of band as NuGet  packages.  \\nThe existing UWP XAML APIs that ship as part of the OS wil\", \"l no longer receive new feature updates. \\nThey will still receive security updates and critical fixe\", \"s according to the Windows 10 support lifecycle.  \\nThe Universal Windows Platform contains more than\", \" just the XAML framework (for example, \\napplication and security model, media pipeline, Xbox and Win\", \"dows 10 shell integrations, broad device \\nsupport) and will continue to evolve. All new XAML feature\", \"s will ju st be developed and ship as part of \\nWinUI instead.  \\nWinUI 3 in desktop app and WinUI XAM\", \"L Islands  \\nAs you can see, WinUI 3 is the evolution of UWP XAML and it works naturally within the U\", \"WP app \\nmodel and all its requirements (MSIX packaged ID, sandbox, CoreWindow, and so on. To use jus\", \"t \\nWinUI 3 in a Win32 app model, the WinUI content should be hosted by  another UI Framework \\n(Windo\", \"ws Forms, WPF, and so on) using WinUI XAML Islands . This is the right path if you want to \\n \\n40 CHA\", \"PTER 4 | Windows 10 migration  \\n evolve your app and mix technologies. However, if you want to repla\", \"ce your entire old UI for WinUI, \\nyour app shouldn\\u2019t load UI Frameworks for just hosting WinUI.  \\nWi\", \"nUI 3 will address this critical feedback adding WinUI in desktop apps . This will allow that Win32 \", \"\\napps can use WinUI 3 as standalone UI Framework; no need to load Windows Forms or WPF.  \\nWithin thi\", \"s aggregation, WinUI 3 will let developers easily mix and match the right combination of:  \\n\\u2022 App mo\", \"del: UWP, Win32  \\n\\u2022 Platform: .NET or Native  \\n\\u2022 Language: .NET (C#, Visual Basic), standard C++  \\n\\u2022\", \" Packaging: MSIX, AppX for the Microsoft Store, unpackaged  \\n\\u2022 Interop: use WinUI 3 to extend existi\", \"ng WPF, WinForms, and MFC apps using WinUI XAML \\nIslands.  \\nIf you want to know more details, Micros\", \"oft is sharing this roadmap in \\nhttps://github.com/microsoft/microsoft -ui-xaml/blob/main/docs/roadm\", \"ap.md .  \\n41 CHAPTER 5 | Example of migrating to the latest .NET  \\n CHAPTER  5 \\nExample of migrating\", \" to \\nthe latest .NET  \\nIn this chapter, we\\u2019ll show how to migrate your applications to the latest ve\", \"rsion of .NET. You can \\nmigrate to .NET 7 from .NET Framework, .NET Core, or .NET 5. We\\u2019ll introduce\", \" a tool that can do all the \\nwork for you in most cases. If your application has special cases or co\", \"mplicated dependencies, we\\u2019ll \\nalso show how to do the whole migration process by hand. Additionally\", \", we\\u2019ll co ver the most common \\nissues and challenges you can face when migrating an existing applic\", \"ation from .NET Framework to \\n.NET.  \\nMigrating from .NET Core or .NET 5  \\nUpdating your application\", \"s to target the latest version of .NET is easy if you already are on .NET Core \\nor .NET 5. If this i\", \"s the case, then in Visual Studio, simply right -click on your project in Solution \\nExplorer  and ch\", \"oose Properties . Under Application  > General  > Target framework , choose .NET \\n7.0. Save and rebu\", \"ild your application. You\\u2019re done! Your app now runs on the latest version of .NET. \\nIn the future w\", \"hen new versions become available, you can upgrade in the same way.   \\n42 CHAPTER 5 | Example of mig\", \"rating to the latest .NET  \\n  \\nMigrating from .NET Framework  \\nMigrating from .NET Framework is a mo\", \"re complicated process because there are more differences \\nbetween .NET Framework and other platform\", \"s that were built on top of .NET Core. But the good news \\nis that there\\u2019s a tool that will do all th\", \"e work for you in mos t cases.  \\nMigrating with a tool  \\nThe Upgrade Assistant  is a migration tool.\", \" Using it is easy and there are step -by-step instructions \\navailable on the .NET website . In this \", \"chapter, we\\u2019ll look at what is happening behind the scenes and \\nhow to port your application by hand\", \". When the Upgrade Assistant is unable to migrate your \\napplication, you\\u2019ll learn the underlying mec\", \"hanics so that you might be able to migrate manu ally. \\nMigrating by hand  \\nThe migration process co\", \"nsists of four sequential steps:  \\n1. Preparation : Understand the dependencies the project has to h\", \"ave an idea of what\\u2019s ahead. \\nIn this step, you take the current project into a state that simplifie\", \"s the startup point for the \\nmigration.  \\n2. Migrate Project File:  .NET projects use the new SDK -s\", \"tyle project format. Create a new \\nproject file with this format or update the one you have to use t\", \"he SDK style.  \\n3. Fix code and build:  Build the code in .NET addressing API -level differences bet\", \"ween .NET \\nFramework and .NET. If needed, update third -party packages to the ones that support .NET\", \".  \\n \\n43 CHAPTER 5 | Example of migrating to the latest .NET  \\n 4. Run and test:  There might be dif\", \"ferences that don\\u2019t show up until run time. So, don\\u2019t forget \\nto run the application and test that e\", \"verything works as expected.  \\nPreparation  \\nMigrate packages.config file  \\nIn a .NET Framework appl\", \"ication, all references to external packages are declared in the \\npackages.config  file. In .NET, th\", \"ere\\u2019s no longer the need to use the packages.config  file. Instead, use the \\nPackageReference  prope\", \"rty inside the project file to specify the NuGet packages for your app.  \\nSo, you need to transition\", \" from one format to another. You can do the update manually, taking the \\ndependencies contained in t\", \"he packages.config  file and migrating them to the project file with the \\nPackageReference format. O\", \"r, you can let Visual Studio do the work for you: right -click on the \\npackages.config  file and sel\", \"ect the Migrate packages.config to PackageReference  option.  \\nVerify every dependency compatibility\", \" in .NET  \\nOnce you\\u2019ve migrated the package references, you must check each reference for compatibil\", \"ity. You \\ncan explore the dependencies of each NuGet package your application is using on nuget.org \", \". If the \\npackage has .NET Standard dependencies, then it\\u2019s going to work on .NET 7 because .NET sup\", \"ports  all \\nversions of .NET Standard. The following image shows the dependencies for the Castle.Win\", \"dsor \\npackage:  \\n \\nTo check the package compatibility, you can use the tool https://fuget.org  that \", \"offers a more detailed \\ninformation about versions and dependencies.  \\nMaybe the project is referenc\", \"ing older package versions that don\\u2019t support .NET, but you might find \\nnewer versions that do suppo\", \"rt it. So, updating packages to newer versions is generally a good \\n \\n44 CHAPTER 5 | Example of migr\", \"ating to the latest .NET  \\n recommendation. However, you should consider that updating the package v\", \"ersion can introduce \\nsome breaking changes that would force you to update your code.  \\nWhat happens\", \" if you don\\u2019t find a compatible version? What if you just don\\u2019t want to update the \\nversion of a pac\", \"kage because of these breaking changes? Don\\u2019t worry because it\\u2019s possible to depend \\non .NET Framewo\", \"rk packages from a .NET application. Don\\u2019t for get to test it extensively because it can \\ncause run \", \"-time errors if the external package calls an API that isn\\u2019t available on .NET. This is great for \\nw\", \"hen you\\u2019re using an old package that isn\\u2019t going to be updated and you can just retarget to work on \", \"\\n.NET.  \\nCheck for API compatibility  \\nSince the API surface in .NET Framework and .NET is similar b\", \"ut not identical, you must check which \\nAPIs are available on .NET and which aren\\u2019t. You can use the\", \" .NET Portability Analyzer tool to surface \\nAPIs used that aren\\u2019t present on .NET. It looks at th e \", \"binary level of your app, extracts all the APIs that \\nare called, and then lists which APIs aren\\u2019t a\", \"vailable on your target framework (.NET 7 in this case).  \\nYou can find more information about this \", \"tool at:  \\nhttps://learn.microsoft.com/dotnet/standard/analyzers/portability -analyzer  \\nAn interest\", \"ing aspect of this tool is that it only surfaces the differences from your own code and not \\ncode fr\", \"om external packages, which you can\\u2019t change. Remember you should have updated most of \\nthese packag\", \"es to make them work with .NET.  \\nMigrate  \\n1. Create the new .NET project  \\nIn most cases, you\\u2019ll w\", \"ant to update your existing project to the new .NET format. However, you can \\nalso create a new proj\", \"ect while maintaining the old one. The main drawback from updating the old \\nproject is that you lose\", \" designer support, which may be imp ortant to you and your development \\nteam. If you want to keep us\", \"ing the designer, you must create a new .NET project in parallel with the \\nold one and share assets.\", \" If you need to modify UI elements in the designer, you can switch to the old \\nproject to do th at. \", \"And since assets are linked, they\\u2019ll be updated in the .NET project as well.  \\nThe SDK-style project\", \"  for .NET is a lot simpler than .NET Framework\\u2019s project format. Apart from the \\npreviously mention\", \"ed PackageReference entries, you won\\u2019t need to do much more. The new project \\nformat includes files \", \"with certain extensions by default , such as .cs and .xaml files, without the need to \\nexplicitly in\", \"clude them in the project file.  \\nAssemblyInfo considerations  \\nAttributes are autogenerated on .NET\", \" projects. If the project contains an AssemblyInfo.cs  file, the \\ndefinitions will be duplicated, wh\", \"ich will cause compilation conflicts. You can delete the older \\nAssemblyInfo.cs  file or disable aut\", \"ogeneration by adding the following entry to the .NET project file:  \\n<Project Sdk=\\\"Microsoft.NET.Sd\", \"k\\\" > \\n  <PropertyGroup > \\n    <GenerateAssemblyInfo >false</ GenerateAssemblyInfo >  \\n45 CHAPTER 5 |\", \" Example of migrating to the latest .NET  \\n   </PropertyGroup > \\n</Project> \\nResources  \\nEmbedded re\", \"sources are included automatically but resources aren\\u2019t, so you need to migrate the \\nresources to th\", \"e new project file.  \\nPackage references  \\nWith the Migrate packages.config to PackageReference  opt\", \"ion, you can easily move your external \\npackage references to the new format as previously mentioned\", \".  \\nUpdate package references  \\nUpdate the versions of the packages you\\u2019ve found to be compatible, a\", \"s shown in the previous section.  \\nFix the code and build  \\nMicrosoft.Windows.Compatibility  \\nIf you\", \"r application depends on APIs that aren\\u2019t available on .NET, such as Registry or ACLs, you have \\nto \", \"include a reference to the Microsoft.Windows.Compatibility package to add these Windows -\\nspecific A\", \"PIs. They work on .NET but aren\\u2019t included as they ar en\\u2019t cross -platform.  \\nThere\\u2019s a tool called \", \"Platform compatibility analyzer \\n(https://learn.microsoft.com/dotnet/standard/analyzers/platform -co\", \"mpat -analyzer ) that helps you \\nidentify APIs that aren\\u2019t compatible with your code.  \\nUse #if dire\", \"ctives  \\nIf you need different execution paths when targeting .NET  Framework and .NET, you should u\", \"se \\ncompilation constants. Add some #if directives to your code to keep the same codebase for both \\n\", \"targets.  \\nTechnologies not available on .NET  \\nSome technologies aren\\u2019t available on .NET, such as:\", \"  \\n\\u2022 AppDomains  \\n\\u2022 Remoting  \\n\\u2022 Code Access Security  \\n\\u2022 Windows Workflow  \\nThat\\u2019s why you need to \", \"find a replacement for these technologies if you\\u2019re using them in your \\napplication. For more inform\", \"ation, see the .NET Framework technologies unavailable on .NET Core and \\n.NET 5+  article.   \\n46 CHA\", \"PTER 5 | Example of migrating to the latest .NET  \\n Regenerate autogenerated clients  \\nIf your appli\", \"cation uses autogenerated code, such as a WCF client, you may need to regenerate this \\ncode to targe\", \"t .NET. Sometimes, you can find some missing references since they may not be included \\nas part of t\", \"he default .NET assemblies set. Using a tool like https://apisof.net/ , you can easily locate \\nthe a\", \"ssembly the missing reference lives in and add it from NuGet.  \\nRolling back package versions  \\nAs a\", \" general rule, we\\u2019ve previously stated that you better update every single package version to be \\nco\", \"mpatible with .NET. However, you can find that targeting an updated and compatible version of an \\nas\", \"sembly just doesn\\u2019t pay off. If the cost of change isn \\u2019t acceptable, you can consider rolling back \", \"\\npackage versions keeping the ones you use on .NET Framework. Although they may not be targeting \\n.N\", \"ET, they should work well unless they call some unsupported APIs.  \\nRun and test  \\nOnce you have you\", \"r application building with no errors, you can start the last step of the migration by \\ntesting ever\", \"y functionality.  \\nIn this final step, you can find several different issues depending on the comple\", \"xity of your application \\nand the dependencies and APIs you\\u2019re using.  \\nFor example, if you use conf\", \"iguration files ( app.config ), you may find some errors at run time like \\nConfiguration Sections no\", \"t present. Using the Microsoft.Extensions.Configuration NuGet package \\nshould fix that error.  \\nAnot\", \"her reason for errors is the use of the BeginInvoke and EndInvoke methods because they aren\\u2019t \\nsuppo\", \"rted on .NET. They aren\\u2019t supported on .NET because they have a dependency on Remoting, \\nwhich doesn\", \"\\u2019t exist on .NET. To solve this issue, try to use the await keyword (when available) or the \\nTask.Ru\", \"n  method.  \\nYou can use compatibility analyzers to let you identify APIs and code patterns in your \", \"code that can \\npotentially cause problems at run time with .NET. Go to https://github.com/dotnet/pla\", \"tform -compat  \\nand use the .NET API analyzer on your project.  \\nMigrating a Windows Forms applicati\", \"on  \\nTo showcase a complete migration process of a Windows Forms application, we\\u2019ve chosen to migrat\", \"e \\nthe eShop sample application available at https://github.com/dotnet -\\narchitecture/eShopModernizi\", \"ng/tree/master/eShopLegacyNTier/src/eShopWinForms . You can find \\nthe complete result of the migrati\", \"on at https://github.com/dotnet -\\narchitecture/eShopModernizing/tree/master/eShopModernizedNTier/src\", \"/eShopWinForms . \\nThis application shows a product catalog and allows the user to navigate, filter, \", \"and search for \\nproducts. From an architecture point of view, the app relies on an external WCF serv\", \"ice that serves as \\na fa\\u00e7ade to a back -end database.  \\nYou can see the main application window in t\", \"he following picture:   \\n47 CHAPTER 5 | Example of migrating to the latest .NET  \\n  \\nIf you open the\", \" .csproj  project file, you can see something like this:  \\n \\nAs previously mentioned, a .NET project\", \" has a more compact style and you need to migrate the \\nproject structure to the new .NET SDK style. \", \" \\nIn Solution Explorer, right -click on the Windows Forms project and select Unload Project  > Edit.\", \" \\nNow you can update the .csproj  file. You\\u2019ll delete the entire contents and replace it with the fo\", \"llowing \\ncode:  \\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\" > \\n  <PropertyGroup > \\n    <OutputType >WinExe</ O\", \"utputType > \\n    <TargetFramework >net7.0-windows</ TargetFramework > \\n    <UseWindowsForms >true</ \", \"UseWindowsForms > \\n    <GenerateAssemblyInfo >false</ GenerateAssemblyInfo > \\n \\n48 CHAPTER 5 | Examp\", \"le of migrating to the latest .NET  \\n   </PropertyGroup > \\n</Project> \\nSave and reload the project. \", \"You\\u2019re now done updating the project file and the project is targeting \\n.NET 7.  \\nIf you compile the\", \" project at this point, you\\u2019ll find some errors related to the WCF client reference. \\nSince this cod\", \"e is autogenerated, you must regenerate it to target .NET.  \\n \\nDelete the Reference.cs  file and gen\", \"erate a new Service Client.  \\nRight -click on Connected Services  and select the Add Connected Servi\", \"ce  option.  \\n \\nThe Connected Services window opens. Select the Microsoft WCF Web Service  option.  \", \"\\n \\n49 CHAPTER 5 | Example of migrating to the latest .NET  \\n  \\nIf you have the WCF Service in the sa\", \"me solution as we have in this example, you can select the \\nDiscover  option instead of specifying a\", \" service URL.  \\n \\nOnce the service is located, the tool reflects the API contract implemented by the\", \" service. Change the \\nname of the namespace to be eShopServiceReference as shown in the following im\", \"age:  \\n \\n50 CHAPTER 5 | Example of migrating to the latest .NET  \\n  \\nSelect the Finish  button. Afte\", \"r a while, you\\u2019ll see the generated code.  \\nYou should see three autogenerated files:  \\n1. Getting S\", \"tarted : a link to GitHub to provide some information on WCF.  \\n2. ConnectedService.json : configura\", \"tion parameters to connect to the service.  \\n3. Reference.cs : the actual WCF client code.  \\n \\n51 CH\", \"APTER 5 | Example of migrating to the latest .NET  \\n  \\nIf you compile again, you\\u2019ll see many errors \", \"coming from .cs files inside the Helper  folder. This folder \\nwas present in the .NET Framework vers\", \"ion but not included in the old .csproj . But with the new SDK -\\nstyle project, every code file pres\", \"ent underneath the project file location is included by default. That is, \\nthe new .NET Core project\", \" tries to compile the files inside the Helper  folder. Since that folder isn\\u2019t \\nneeded, you can safe\", \"ly delete it.  \\nIf you compile the project again and execute it, you won\\u2019t see the product images. T\", \"he problem is that \\nnow the path to the files has slightly changed. To fix this issue, you need to a\", \"dd another level of depth \\nin the path, updating in the file CatalogView.c s the line:  \\n \\n52 CHAPTE\", \"R 5 | Example of migrating to the latest .NET  \\n string image_name = Environment .CurrentDirectory  \", \"+ \\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems .Picturefilename ; \\nto \\nstring image_name = \", \"Environment .CurrentDirectory  + \\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems .Picturef\", \"ilename ; \\nAfter this change, you can check that the application launches and runs as expected on .N\", \"ET 7.  \\nMigrating a WPF application  \\nWe\\u2019ll use the Shop.ClassicWPF sample application to perform th\", \"e migration. The following image \\nshows a screenshot of the app before migration:  \\n \\nThis applicati\", \"on uses a local SQL Server Express database to hold the product catalog information. \\nThis database \", \"is accessed directly from the WPF application.  \\nFirst, you must update the .csproj  file to the new\", \" SDK style used by .NET Core applications. You\\u2019ll \\nfollow the same steps described in the Windows Fo\", \"rms migration: you\\u2019ll unload the project, open the \\n.csproj  file, update its contents, and reload t\", \"he project.  \\nIn this case, delete all the content of the .csproj  file and replace it with the foll\", \"owing code:  \\n \\n53 CHAPTER 5 | Example of migrating to the latest .NET  \\n  <Project Sdk=\\\"Microsoft.N\", \"ET.Sdk\\\" > \\n  <PropertyGroup > \\n    <OutputType >WinExe</ OutputType > \\n    <TargetFramework >net7.0-\", \"windows</ TargetFramework > \\n    <UseWpf>true</ UseWpf> \\n    <GenerateAssemblyInfo >false</ Generate\", \"AssemblyInfo > \\n  </PropertyGroup > \\n</Project> \\nIf you reload the project and compile it, you\\u2019ll ge\", \"t the following error:  \\n \\nSince you\\u2019ve deleted all the .csproj  contents, you\\u2019ve lost a project ref\", \"erence specification present in the \\nold project. You just need to add this line to the .csproj  fil\", \"e to include the project reference back:  \\n<ItemGroup > \\n    <ProjectReference  Include= \\\"..\\\\\\\\eShop.\", \"SqlProvider \\\\\\\\eShop.SqlProvider.csproj\\\"  /> \\n<ItemGroup > \\nYou can also let Visual Studio help you b\", \"y right -clicking on the Dependencies  node and selecting \\nAdd Project Reference . Select the projec\", \"t from the solution and select OK: \\n \\n54 CHAPTER 5 | Example of migrating to the latest .NET  \\n  \\nOn\", \"ce you add the missing project reference, the application compiles and runs as expected on .NET.  \\n \", \"\\n55 CHAPTER 6 | Deploying Modern Desktop Applications  \\n CHAPTER  6 \\nDeploying Modern \\nDesktop Appli\", \"cations  \\nWhen you develop desktop applications, one thing to consider is how your application is go\", \"ing to be \\npackaged and deployed to the users\\u2019 machines. The problem with packaging, deployment, and\", \" \\ninstallation is that it usually falls under the umbrella of the IT professionals, w ho care about \", \"different \\nthings than developers.  \\nThese days, we\\u2019re all familiar with the DevOps concept, where d\", \"evelopers and IT Pros work closely to \\nmove applications to their production environments. But if yo\", \"u\\u2019ve been in the desktop battle for more \\nthan 10 years, you might have seen the following stor y. A\", \" team of developers works together hard to \\nmeet the project deadlines. Business people are nervous \", \"since they need the system working on many \\nusers\\u2019 machines to run the company. On \\u201cD -Day\\u201d, the pro\", \"ject manager checks with every developer \\nthat their cod e is working well and that everything is fi\", \"ne, so they can ship. Then, the package team \\ncomes in generating the setup for the app, distribute \", \"it to every user machine and a set of test users \\nrun the application. Well, they try, because befor\", \"e showing any U I, the application throws an \\nexception that says \\u201cMethod ~ of object ~ failed\\u201d. Pan\", \"ic starts flowing through the air and a brief \\ninvestigation points to a young and tired developer t\", \"hat has introduced a third -party control, that \\ncertainly \\u201cworked on the de v machine\\u201d.  \\nInstallin\", \"g desktop applications have traditionally been a nightmare for two main reasons:  \\n\\u2022 Lack of close c\", \"ollaboration culture between dev and IT teams.  \\n\\u2022 Lack of a solid packaging and deploying technolog\", \"y we can build upon.  \\nIn fact, we\\u2019ve been living with the fact that sometimes you regret that you i\", \"nstalled an app because:  \\n\\u2022 It ends up having some undesired side effects on your machine.  \\n\\u2022 Some\", \" applications that were previously installed stop working.  \\nAdditionally, you can\\u2019t just restore th\", \"e system to its original state by uninstalling the app. We\\u2019re so \\nused to living with this situation\", \" that we\\u2019ve coined terms like \\u201cDLL Hell\\u201d or \\u201cWinrot\\u201d.  \\nIn this chapter, we\\u2019ll talk about MSIX. MSIX\", \" is the new technology from Microsoft that tries to capture \\nthe best of previous technologies to pr\", \"ovide a solid foundation for the packaging technology of the \\nfuture.  \\nWhat does a packaging techno\", \"logy have to do with modernization? Well, it turns out that packaging \\nis fundamental for the enterp\", \"rise IT with lots of money invested there. Modernization isn\\u2019t only related  \\n56 CHAPTER 6 | Deployi\", \"ng Modern Desktop Applications  \\n to using the latest technologies. It\\u2019s also related to reducing ti\", \"me to market from the moment a \\nbusiness requirement is defined until your company delivers the feat\", \"ure to your client.  \\nThe modern application lifecycle  \\nToday, developers write and build the code \", \"for an app and then pass the generated assets to the IT \\nPros. Then, the IT Pros reconfigure the app\", \" and repackage it, typically in an MSI or more recently in an \\nApp-V packaging format. The app is th\", \"en deployed thr ough different channels and tools. One of the \\nmain problems with this approach is c\", \"ommonly known as \\u201cpackaging paralysis\\u201d. The problem is that \\nthis cycle repeats every time there\\u2019s a\", \"n app update or an OS update.  \\nYou can see the process reflected on the following picture:  \\n \\nComp\", \"anies need a way to break this packaging cycle into three independent cycles:  \\n\\u2022 OS updates  \\n\\u2022 App\", \"lication updates  \\n\\u2022 Customization  \\n \\n57 CHAPTER 6 | Deploying Modern Desktop Applications  \\n  \\nThe\", \" previous diagram shows that you can:  \\n\\u2022 Update the underlying OS without having to repackage your \", \"apps.  \\n\\u2022 Enable customizations from IT without the need to repackage the original developer package\", \".  \\nThis radical change leads us to the new and modern IT lifecycle as shown in the following pictur\", \"e:  \\n \\n58 CHAPTER 6 | Deploying Modern Desktop Applications  \\n  \\nDevelopers create the app and gener\", \"ate an MSIX package that IT Pros can consume and configure \\nwithout the need of repackaging. Along w\", \"ith the MSIX technology, Microsoft has created tools to \\nallow IT to customize and configure package\", \"s without repackaging.  \\nMSIX: The next generation of deployment  \\nBefore MSIX, there were several p\", \"ackaging technologies available like setup wizards, MSI, ClickOnce, \\nApp-V, and scripting. Each of t\", \"hese technologies has their own strengths and Microsoft has decided \\nto pick the best of all to buil\", \"d MSIX. MSIX is built on the foundations of these existing technologies \\npicking the best of each:  \", \"\\n\\u2022 App-V => Containerization  \\n\\u2022 ClickOnce => Auto updating  \\n\\u2022 MSI => Easy to distribute  \\nWith MSI\", \"X, you get one installer technology with all these features.  \\n \\n59 CHAPTER 6 | Deploying Modern Des\", \"ktop Applications  \\n  \\nBenefits of MSIX  \\nNever regret installing an app  \\nMSIX provides a predictab\", \"le, reliable, and safe deployment. The declarative method contained in the \\npackage manifest lets th\", \"e OS keep track of every asset your application needs. It also provides a true \\nclean uninstall with\", \" no side effects.  \\nDisk space optimization  \\nMSIX is optimized to reduce the footprint that an appl\", \"ication has on the user\\u2019s machine disk space. It \\ncreates a single instance storage of your files. T\", \"hat is, if you have two different packages with the \\nsame DLL, the DLL isn\\u2019t installed twice. The pl\", \"atfo rm takes care of that problem because it knows all \\nthe files that a particular app installed t\", \"hanks to its declarative nature. It also allows you to have \\ndifferent versions of a DLL working sid\", \"e by side.  \\nWith the use of resource packages, you can easily create multilingual apps and the OS t\", \"akes care of \\ninstalling the ones that are used.  \\nNetwork optimization  \\nMSIX detects the differenc\", \"es on the files at the byte block level enabling a feature called differential \\nupdates. What this m\", \"eans is that only the updated byte blocks are downloaded on application \\nupdates.  \\n \\n60 CHAPTER 6 |\", \" Deploying Modern Desktop Applications  \\n  \\nWith streaming installation, the user can quickly start \", \"working on your application while other parts of \\nthe app are downloaded on the background. This fea\", \"ture contributes to an engaging experience for \\nyour users.  \\nWith the optional packages feature, yo\", \"u achieve componentization on your app deployment, so you \\ncan download them when needed.  \\nSimple p\", \"ackaging and deployment  \\nThe AppManifest  declares the versioning, device targeting and identity in\", \" a standard way for every \\napplication. It also provides a way to sign your assets providing a solid\", \" security foundation.  \\nOS managed  \\nThe OS handles all the processes for installing, updating, and \", \"removing an application. Applications \\nare installed per user but downloaded only once, minimizing t\", \"he disk footprint. Microsoft is working \\non providing the MSIX experience also on Windows 7.  \\nWindo\", \"ws provides integrity for the app  \\nWith the use of digital signatures, you can guarantee that you d\", \"on\\u2019t install an application from \\nuntrusted sources. MSIX also prevents tampering because:  \\n\\u2022 It ke\", \"eps a record of file hashes.  \\n\\u2022 It detects if a file has been modified after installation.  \\n \\n61 C\", \"HAPTER 6 | Deploying Modern Desktop Applications  \\n Works for the entire App Catalog  \\nOne of the co\", \"olest things about MSIX is that it works for the entire application catalog, Windows \\nForms, WPF, MF\", \"C/ATL, Delphi, even if you want to do xCopy deployment, ClickOnce, or going to the \\nStore, you can u\", \"se the same MSIX package.  \\nTools  \\nWindows Application Packaging Project  \\nYou can use the  Windows\", \" Application Packaging Project  project in Visual Studio to generate a \\npackage for your desktop app\", \". Then, you can publish that package to the Microsoft Store or sideload \\nit onto one or more PCs.  \\n\", \"MSIX Packaging Tool  \\nThe MSIX Packaging Tool enables you to repackage your existing Win32 applicati\", \"ons to the MSIX \\nformat. It offers both an interactive UI and a command line for conversions and giv\", \"es you the ability to \\nconvert an application without having the source code.   \\n62 CHAPTER 6 | Depl\", \"oying Modern Desktop Applications  \\n  \\nPackage Support Framework  \\nThe Package Support Framework is \", \"an open -source kit that helps you apply fixes to your existing \\nWin32 application when you don\\u2019t ha\", \"ve access to the source code, so that it can run in an MSIX \\ncontainer. The Package Support Framewor\", \"k helps your application f ollow the best practices of the \\nmodern runtime environment.  \\nApp Instal\", \"ler  \\nApp Installer allows Windows 10 and Windows 11 apps to be installed by double -clicking the ap\", \"p \\npackage. This means that users don\\u2019t need to use PowerShell or other developer tools to deploy \\nW\", \"indows 10/Windows 11 apps. The App Installer can also install an app from the web, optional \\npackage\", \"s, and related sets.  \\nHow to create an MSIX package from an existing \\nWin32 desktop application  \\nL\", \"et\\u2019s go through the process to create an MSIX package from an existing Win32 application. In this \\ne\", \"xample, we\\u2019ll use a Windows Forms app.  \\n \\n63 CHAPTER 6 | Deploying Modern Desktop Applications  \\n T\", \"o start, add a new project to your solution, select the Windows Application Packaging Project, and \\n\", \"give it a name.  \\n \\nYou\\u2019ll see the structure of the packaging project and note a special folder call\", \"ed Applications . Inside \\nthis folder, you can specify which applications you want to include in the\", \" package. It can be more than \\none. \\n \\n64 CHAPTER 6 | Deploying Modern Desktop Applications  \\n  \\nRig\", \"ht -click on the Applications  folder and select the Windows Forms project you want to package \\nfrom\", \" the Visual Studio solution.  \\n \\n65 CHAPTER 6 | Deploying Modern Desktop Applications  \\n  \\nAt this p\", \"oint, you can compile and generate the package but let\\u2019s examine a couple of things. To have \\na bett\", \"er user experience, Visual Studio can autogenerate all the visual assets a modern application \\nneeds\", \" to handle icons and tile assets for the tile bar  and start menu. Open the Package.appxmanifest  \\nf\", \"ile to access the Manifest Designer. You can then generate all the visual assets from a given image \", \"\\npresent on your project just by clicking Create . \\n \\nIf you open the code for the Package.appxmanif\", \"est  file, you can see a couple of interesting things.  \\nRight under <Package>, there\\u2019s an <Identity\", \"> node. This is where your packaged application is going \\nto get its identity, which will be managed\", \" by the OS.  \\n \\n66 CHAPTER 6 | Deploying Modern Desktop Applications  \\n  \\nIn the <Capabilities> node\", \", you can find all the requirements the application needs, paying special \\nattention to the <rescap:\", \"Capability Name=\\\"runFullTrust\\\" \\\\>, which tells the OS to run the app in full \\ntrust mode since it\\u2019s \", \"a Win32 application.  \\n \\n67 CHAPTER 6 | Deploying Modern Desktop Applications  \\n  \\nSet the packaging\", \" project as the startup project for the solution and select Run. This is going to:  \\n\\u2022 Compile the W\", \"indows Forms application.  \\n\\u2022 Create an MSIX package out of the build results.  \\n\\u2022 Deploy the packag\", \"es.  \\n\\u2022 Install it locally on the development machine.  \\n\\u2022 Launch the app.  \\n \\n68 CHAPTER 6 | Deploy\", \"ing Modern Desktop Applications  \\n  \\nWith this, you have the clean install and uninstall experience \", \"that MSIX provides fully integrated into \\nWindows 10/Windows 11.  \\nThe final stage is about how you \", \"deploy the MSIX package to another machine.  \\nRight -click on the packaging project, select the Stor\", \"e  menu, and then select the Create App \\nPackages  option.  \\nThen, you can choose between creating a\", \" package to upload to the store or creating packages for \\nsideloading. In most modernization scenari\", \"os, you\\u2019ll choose I want to create packages for \\nsideloading . \\n \\n69 CHAPTER 6 | Deploying Modern De\", \"sktop Applications  \\n  \\nThere you can select the different architectures you want to target as you c\", \"an include as many as you \\nwant into the same MSIX package.  \\nThe final step is to declare where you\", \" want to deploy the final installation assets.  \\n \\n70 CHAPTER 6 | Deploying Modern Desktop Applicati\", \"ons  \\n  \\nYou can choose to use a web server or a shared UNC path on your enterprise file servers. Pa\", \"y \\nattention to the settings to specify how you want to update your application. We\\u2019ll cover applica\", \"tion \\nupdates in the next section.  \\nFor a detailed step -by-step guide, see Package a desktop app f\", \"rom source code using Visual Studio . \\nAuto Updates in MSIX  \\nThe Windows Store has a great updating\", \" mechanism using Windows Update. In most enterprise \\nscenarios, you don\\u2019t use the Store to distribut\", \"e your desktop apps. So, you need a similar way to \\nconfigure updates for your application and pull \", \"them to your users.  \\nUsing a combination of Windows 10/Windows 11 features and MSIX packages, you c\", \"an provide a \\ngreat updating experience for your users. In fact, the user doesn\\u2019t need to be technic\", \"al at all but still \\nbenefits from a seamless application update experience.  \\nYou can configure you\", \"r updates to interact with the user in two different ways:  \\n \\n71 CHAPTER 6 | Deploying Modern Deskt\", \"op Applications  \\n \\u2022 User prompted  updates: The OS shows some autogenerated nice UI to notify the u\", \"ser about \\nthe application it\\u2019s about to install. It builds this UI based on the properties you spec\", \"ify on \\nyour installation files.  \\n\\u2022 Silent updates in the background. With this option, your users \", \"don\\u2019t need to be aware of the \\nupdates.  \\nYou can also configure when you want to perform updates: e\", \"ither when the application launches or \\non a regular basis. Thanks to the side -loading features, yo\", \"u can even get these updates while the \\napplication is running.  \\nWhen you use this type of deployme\", \"nt, a special file is created called .appinstaller . This simple file \\ncontains the following sectio\", \"ns:  \\n\\u2022 The location of the .appinstaller  file \\n\\u2022 The application\\u2019s main MSIX package properties  \\n\", \"\\u2022 The update behavior  \\n \\nIn combination with this file, Microsoft has designed a special URL protoc\", \"ol to launch the installation \\nprocess from a link:  \\n<a href=\\\"ms-appinstaller:?source=http://mywebs\", \"ervice.azureedge.net/MyApp.msix\\\" >Install \\napp package </ a> \\nThis protocol works on all browsers an\", \"d launches the installation process with a great user experience \\non Windows 10/Windows 11. Since th\", \"e OS manages the installation process, it\\u2019s aware of the location \\nthis application was installed fr\", \"om and tracks all th e files affected by the process.  \\nMSIX creates a user interface for installati\", \"on automatically showing some properties of the package. \\nThis allows for a common installation expe\", \"rience for every app.  \\n \\n72 CHAPTER 6 | Deploying Modern Desktop Applications  \\n Once you\\u2019ve genera\", \"ted the new MSIX package and moved it to the deployment server, you just have \\nto edit the .appinsta\", \"ller  file to reflect these changes: mainly the version and the path to the new MSIX \\nfile. The next\", \" time the user launches the application, the system will detect the change and download \\nthe files f\", \"or the new version in the background. When the download is fini shed, installation will \\nexecute tra\", \"nsparently for your user on new application launch.  \"]"