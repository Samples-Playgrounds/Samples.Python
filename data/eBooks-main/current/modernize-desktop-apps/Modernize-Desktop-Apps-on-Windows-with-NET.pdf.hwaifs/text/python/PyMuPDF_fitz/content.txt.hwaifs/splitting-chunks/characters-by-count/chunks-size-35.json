"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\nEDITION v1.0.3 - Updated to .NET 7 \\n\", \"Refer to the changelog for the book updates and community contributions. \\nPUBLISHED BY \\nMicrosoft De\", \"veloper Division, .NET, and Visual Studio product teams \\nA division of Microsoft Corporation \\nOne Mi\", \"crosoft Way \\nRedmond, Washington 98052-6399 \\nCopyright \\u00a9 2022 by Microsoft Corporation \\nAll rights r\", \"eserved. No part of the contents of this book may be reproduced or transmitted in any \\nform or by an\", \"y means without the written permission of the publisher. \\nThis book is provided \\u201cas-is\\u201d and expresse\", \"s the author\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in this book, inc\", \"luding URL and other Internet website references, may change \\nwithout notice. \\nSome examples depicte\", \"d herein are provided for illustration only and are fictitious. No real association \\nor connection i\", \"s intended or should be inferred. \\nMicrosoft and the trademarks listed at https://www.microsoft.com \", \"on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies. \\nMac and macOS are \", \"trademarks of Apple Inc. \\nAll other marks and logos are property of their respective owners. \\nCo-Aut\", \"hors: \\nOlia Gavrysh, Program Manager, .NET team, Microsoft \\nMiguel Angel Castej\\u00f3n Dominguez, Innovat\", \"ion Architect, Kabel \\nParticipants and reviewers: \\nMaira Wenzel, Senior Program Manager, .NET team, \", \"Microsoft \\nAndy De Gorge, Senior Content Developer, .NET docs team, Microsoft \\nMiguel Ramos, Senior \", \"Program Manager, Windows Developer Platform team, Microsoft \\nAdam Braden, Principal Program Manager,\", \" Windows Developer Platform team, Microsoft \\nRicardo Minguez Pablos, Senior Program Manager, Azure I\", \"oT team, Microsoft \\nNish Anil, Senior Program Manager, .NET team, Microsoft \\nBeth Massi, Senior Prod\", \"uct Marketing Manager, Microsoft \\nScott Hunter, Partner Director Program Manager, .NET team, Microso\", \"ft \\nMarta Fuentes Lara, Kabel \\n \\nRa\\u00fal Fern\\u00e1ndez de C\\u00f3rdoba, Kabel \\nAntonio Manuel Fern\\u00e1ndez Cantos, \", \"Kabel \\nIntroduction \\nThis book is about strategies you can adopt to move your existing desktop appli\", \"cations through the \\npath of modernization and incorporate the latest runtime, language, and platfor\", \"m features. You\\u2019ll \\ndiscover that there\\u2019s no unique recipe as each application is different, and so \", \"are your requirements \\nand preferences. The good news is that there are common approaches you can ap\", \"ply to add new \\nfeatures and capabilities to your applications. Some of them won\\u2019t even require majo\", \"r modifications \\nof your code. In this book, we\\u2019ll reveal how all those features work behind the sce\", \"nes and explain the \\nmechanics of their implementations. Moreover, you\\u2019ll find some common scenarios\", \" for modernizing \\nexisting desktop applications shown in detail so you can find inspiration for evol\", \"ving your projects. \\nMicrosoft\\u2019s approach to modernizing existing applications is to give you the fl\", \"exibility to create your \\nown customized path. All the modernization strategies described in this bo\", \"ok are mostly independent. \\nYou can choose ones that are relevant for your application and skip othe\", \"rs that aren\\u2019t important for \\nyou. In other words, you can mix and match the strategies to best addr\", \"ess your application needs. \\nWho should use the book \\nThis book for developers and solution architec\", \"ts who want to modernize existing Windows Forms and \\nWPF desktop applications to leverage the benefi\", \"ts of .NET and Windows 10. \\nYou might also find this book useful if you\\u2019re a technical decision make\", \"r, such as an enterprise \\narchitect or a development lead or director who wants an overview of the b\", \"enefits of updating \\nexisting desktop applications. \\nHow to use the book \\nThis book addresses the \\u201cw\", \"hy\\u201d\\u2014why you might want to modernize your existing applications, and the \\nspecific benefits you get f\", \"rom using NET and MSIX to modernize your desktop apps. The content of \\nthe book is designed for arch\", \"itects and technical decision makers who want an overview, but who \\ndon\\u2019t need to focus on implement\", \"ation and technical, step-by-step details. \\nAlong the different chapters, sample implementation code\", \" snippets and screenshots are provided, \\nwith chapter 5 devoted to showcase a complete migration pro\", \"cess for sample applications. \\nWhat this book doesn\\u2019t cover \\nThis book covers a specific subset of s\", \"cenarios that are focused on lift-and-shift scenarios, outlining \\nthe way to gain the benefits of mo\", \"dernizing without the effort of rewriting code. \\nThis book isn\\u2019t about developing modern application\", \"s with .NET from scratch or about getting started \\nwith Windows Forms and WPF. It focuses on how you\", \" can update existing desktop applications with \\nthe latest technologies for desktop development. \\n \\n\", \"Samples used in this book \\nTo highlight the necessary steps to perform a modernization, we\\u2019ll be usi\", \"ng a sample application \\ncalled eShopModernizing. This application has two flavors, Windows Forms an\", \"d WPF, and we\\u2019ll show a \\nstep-by-step process on how to perform the modernization on both of them to\", \" .NET. \\nAlso, on the GitHub repository for this book, you\\u2019ll find the results of the process, which \", \"you can \\nconsult with if you decide to follow the step-by-step tutorial. \\n \\ni \\nContents \\n \\nContents \", \"\\nWhy modern desktop applications ...................................................................\", \".................... 1 \\nIntroduction ...............................................................\", \"....................................................................................................\", \"............ 1 \\nA story of one company .............................................................\", \"...................................................................................... 1 \\nYour story\", \" ...................................................................................................\", \"............................................................................ 1 \\nDesktop applications\", \" nowadays ..........................................................................................\", \".............................................. 1 \\nWindows Forms ....................................\", \"....................................................................................................\", \"........................... 3 \\nWPF .................................................................\", \"....................................................................................................\", \"...................... 4 \\nUWP ......................................................................\", \"....................................................................................................\", \"................ 4 \\nA tale of two platforms ........................................................\", \".................................................................................................. 5\", \" \\nPaths to modernization ...........................................................................\", \".............................................................................. 8 \\nModern features ..\", \"....................................................................................................\", \"............................................................ 8 \\nDeployment .........................\", \"....................................................................................................\", \".............................................. 8 \\nInstallation......................................\", \"....................................................................................................\", \".................................... 8 \\nWhat\\u2019s new with .NET for Desktop? ..........................\", \"............................................................ 9 \\nThe motivation behind .NET Core ....\", \"....................................................................................................\", \"............................. 9 \\nIntroduction to .NET Core .........................................\", \"....................................................................................................\", \".... 11 \\n.NET 5+ is .NET Core vNext ................................................................\", \"............................................................................... 11 \\n.NET Framework v\", \"s. .NET ............................................................................................\", \"........................................................ 12 \\n.NET Standard vs. PCL .................\", \"....................................................................................................\", \".................................... 13 \\nNew Desktop features in .NET ..............................\", \"....................................................................................................\", \"....... 14 \\nSupport for Windows Forms and WPF ......................................................\", \".............................................................. 14 \\nXAML Islands ....................\", \"....................................................................................................\", \".............................................. 14 \\nAccess to all Windows 10 and Windows 11 APIs ....\", \"............................................................................................ 15 \\nSid\", \"e-by-side support and self-contained EXEs ..........................................................\", \".......................................... 15 \\nPerformance .........................................\", \"....................................................................................................\", \".......................... 15 \\nMigrating Modern Desktop applications ...............................\", \"............................................. 16 \\nConfiguration files ..............................\", \"....................................................................................................\", \".............................. 16 \\nConfiguration on .NET Framework .................................\", \"........................................................................................... 16 \\n \\nii\", \" \\nContents \\nConfiguration on .NET ..................................................................\", \".................................................................................. 17 \\nMigrating con\", \"figuration files ...................................................................................\", \".................................................... 17 \\nAccessing databases .......................\", \"....................................................................................................\", \"................................. 18 \\nODBC .........................................................\", \"....................................................................................................\", \"........................ 19 \\nOLE DB ................................................................\", \"....................................................................................................\", \".............. 19 \\nADO.NET .........................................................................\", \"....................................................................................................\", \". 19 \\nEF Core vs. EF6 ..............................................................................\", \"..................................................................................... 19 \\nRelational\", \" databases .........................................................................................\", \".............................................................. 20 \\nConsuming services ..............\", \"....................................................................................................\", \"........................................... 20 \\nConsuming a COM Object .............................\", \"....................................................................................................\", \"............... 21 \\nMore things to consider ........................................................\", \"............................................................................................. 21 \\nAp\", \"pDomains ...........................................................................................\", \"........................................................................... 21 \\nRemoting ...........\", \"....................................................................................................\", \".............................................................. 21 \\nCode Access Security (CAS) ......\", \"....................................................................................................\", \"............................... 22 \\nSecurity Transparency ..........................................\", \"....................................................................................................\", \"...... 22 \\nWindows 10 migration ....................................................................\", \"..................................... 23 \\nWinRT APIs ...............................................\", \"....................................................................................................\", \"........................... 23 \\nUniversal Windows Platform (UWP) packages ..........................\", \"........................................................................... 24 \\nHow to add WinRT API\", \"s to your desktop project ..........................................................................\", \".......................... 26 \\nXAML Islands ........................................................\", \"....................................................................................................\", \".............. 34 \\nThe road to XAML Islands ........................................................\", \"..................................................................................... 35 \\nHow it wor\", \"ks .................................................................................................\", \"..................................................................... 35 \\nDo you need XAML Islands .\", \"....................................................................................................\", \"..................................... 38 \\nThe road ahead XAML Islands: WinUI 3.0 ...................\", \"........................................................................................... 38 \\nExam\", \"ple of migrating to the latest .NET.................................................................\", \"............ 41 \\nMigrating from .NET Core or .NET 5 ................................................\", \"............................................................................. 41 \\nMigrating from .NE\", \"T Framework ........................................................................................\", \"............................................ 42 \\nMigrating with a tool .............................\", \"....................................................................................................\", \"..................... 42 \\nMigrating by hand ........................................................\", \"................................................................................................... \", \"42 \\nPreparation ....................................................................................\", \"..................................................................................... 43 \\nFix the co\", \"de and build .......................................................................................\", \"............................................................. 45 \\nRun and test .....................\", \"....................................................................................................\", \".............................................. 46 \\n \\niii \\nContents \\nMigrating a Windows Forms applic\", \"ation ..............................................................................................\", \"...................... 46 \\nMigrating a WPF application .............................................\", \"............................................................................................... 52 \\n\", \"Deploying Modern Desktop Applications ..............................................................\", \"............ 55 \\nThe modern application lifecycle ..................................................\", \".................................................................................. 56 \\nMSIX: The nex\", \"t generation of deployment .........................................................................\", \"........................................ 58 \\nBenefits of MSIX ......................................\", \"....................................................................................................\", \"..................... 59 \\nTools ....................................................................\", \"....................................................................................................\", \".............. 61 \\nHow to create an MSIX package from an existing Win32 desktop application.........\", \".................................. 62 \\nAuto Updates in MSIX ........................................\", \"....................................................................................................\", \"............. 70 \\n \\n1 \\nCHAPTER 1 | Why modern desktop applications \\n \\nCHAPTER 1 \\nWhy modern desktop \", \"\\napplications \\nIntroduction \\nA story of one company \\nBack in the early 2000s, one multinational comp\", \"any started developing a distributed desktop solution \\nto exchange information between different bra\", \"nches of the company and execute optimized \\noperations on centralized units. They have chosen a bran\", \"d-new framework called Windows Forms \\n(also known as WinForms) for their application development. Ov\", \"er the years, the project evolved into \\na mature, well-tested, and time-proven application with hund\", \"reds of thousands of lines of code. Time \\npassed and .NET Framework 2.0 is no longer the hot new tec\", \"hnology. The developers who are \\nworking on this application are facing a dilemma. They\\u2019d like to us\", \"e the latest stack of technologies in \\ntheir development and have their application look and \\u201cfeel\\u201d \", \"modern. At the same time, they don\\u2019t \\nwant to throw away the great product they have built over 15 y\", \"ears and rewrite the entire application \\nfrom scratch. \\nYour story \\nYou might find yourself in the s\", \"ame boat, where you have mature Windows Forms or Windows \\nPresentation Foundation (WPF) applications\", \" that have proved their reliability over the years. You \\nprobably want to keep using these applicati\", \"ons for many more years. At the same time, since those \\napplications were written some time ago, the\", \"y might be missing capabilities like modern look, \\nperformance, integration with new devices and pla\", \"tform features, and so on, which gives them a feel \\nof \\u201cold tech\\u201d. There\\u2019s another problem that migh\", \"t concern you as a developer. While working on the \\nolder .NET Framework versions and maintaining ap\", \"plications that were written a while ago, you might \\nfeel like you aren\\u2019t learning new technologies \", \"and missing out on building modern technical skills. If \\nthat is your story \\u2013 this book is for you! \", \"\\nDesktop applications nowadays \\nBefore the rise of the Internet, desktop applications were the main \", \"approach to building software \\nsystems. Developers could choose any programming language, such as CO\", \"BOL, Fortran, VB6, or C++. \\n \\n2 \\nCHAPTER 1 | Why modern desktop applications \\n \\nBut whether they dev\", \"eloped small tools or complex distributed architectures, they were all desktop \\napplications. \\nThen,\", \" Internet technologies started shocking the development world and winning over more \\nengineers with \", \"advantages like easy deployment and simplified distribution processes. The fact that \\nonce a web app\", \"lication was deployed to production all users got automatic updates made a huge \\nimpact on software \", \"agility. \\nHowever, the Internet infrastructure, underlying protocols, and standards like HTTP and HT\", \"ML weren\\u2019t \\ndesigned for building complex applications. In fact, the major development effort back t\", \"hen was \\naimed at just one goal: to give web applications the same capabilities that desktop applica\", \"tions have, \\nsuch as fast data input and state management. \\nEven though web and mobile applications \", \"have grown at an incredible pace, for certain tasks desktop \\napplications still hold the number one \", \"place in terms of efficiency and performance. That explains why \\nthere are millions of developers wh\", \"o are building their projects with WPF and WinForms and the \\namount of those applications is constan\", \"tly growing. \\nHere are some reasons for choosing desktop applications in your development: \\n\\u2022 \\nDeskt\", \"op apps have better interaction with the user\\u2019s PC. \\n\\u2022 \\nThe performance of desktop applications for \", \"complex calculations is much higher than the \\nperformance of web applications. \\n\\u2022 \\nRunning custom lo\", \"gic on the client-side is possible but much harder with a web application. \\n\\u2022 \\nUsing multithreading \", \"is easier and more efficient in a desktop application. \\n\\u2022 \\nThe learning curve for designing user int\", \"erfaces (UIs) isn\\u2019t steep. And for WinForms, it\\u2019s \\nintuitive with the drag-and-drop experience of th\", \"e Windows Forms designer. \\n\\u2022 \\nIt\\u2019s easy to start coding and testing your algorithms without the need\", \" to set up a server \\ninfrastructure or to care about connectivity problems, firewalls, and browser c\", \"ompatibility. \\n\\u2022 \\nDebugging is powerful as compared to web debugging. \\n\\u2022 \\nAccess to hardware devices\", \", such as camera, Bluetooth, or card readers, is easy. \\n\\u2022 \\nSince the technology has been around for \", \"a while, there are many experts and a knowledge \\nbase available to develop desktop applications. \\nSo\", \", as you can see, developing for desktop is great for many reasons. The technology is mature and \\nti\", \"me-tested, the development cycle is fast, the debugging is powerful and arguably, desktop apps \\nhave\", \" less complexity and are easier to get started with. \\nMicrosoft offered many UI desktop technologies\", \" throughout the years from Win32 introduced in 1995 \\nto Universal Windows Platform (UWP) released in\", \" 2016. \\n \\n3 \\nCHAPTER 1 | Why modern desktop applications \\n \\n \\nAccording to a survey published by Tel\", \"erik on April 2016, the most popular technologies for building \\nWindows desktop apps are Windows For\", \"ms, WPF, and UWP. \\n \\nYou can develop in any of them using C# and Visual Basic, but let\\u2019s take a clos\", \"er look. \\nWindows Forms \\nFirst released in 2002, Windows Forms is a managed framework and is the old\", \"est, most-used desktop \\ntechnology built on the Windows graphics device interface (GDI) engine. It o\", \"ffers a smooth drag-and-\\ndrop experience for developing user interfaces in Visual Studio. At the sam\", \"e time, Windows Forms \\nrelies on the Visual Studio Designer as the main way you develop your UI, so \", \"creating visual \\ncomponents from code isn\\u2019t trivial. \\nThe following list summarizes the main charact\", \"eristics of Windows Forms: \\n\\u2022 \\nMature technology with lots of code samples and documentation. \\n\\u2022 \\nPo\", \"werful and productive designer. Not so convenient to design UI \\u201cfrom code\\u201d. \\n\\u2022 \\nEasy and intuitive t\", \"o learn, thanks to the designer\\u2019s drag-and-drop experience. \\n\\u2022 \\nSupported on any Windows version. \\n\\u2022\", \" \\nSupported on .NET Core 3.0 and later versions. \\n \\n4 \\nCHAPTER 1 | Why modern desktop applications \\n\", \" \\nWPF \\nBased on the XAML language specification, WPF favors a clear separation between UI and code. \", \"XAML \\noffers capabilities like templating, styling, and binding, which is suited for building large \", \"applications. \\nLike Windows Forms, it\\u2019s a managed framework, but the design is modular and reusable.\", \" \\nHere are the main features of WPF: \\n\\u2022 \\nMature technology. \\n\\u2022 \\nDesigner is available, but developer\", \"s usually prefer to create the design from code using \\ndeclarative XAML. \\n\\u2022 \\nThe learning curve is s\", \"teeper than Windows Forms. \\n\\u2022 \\nSupported on any Windows version. \\n\\u2022 \\nSupported on .NET Core 3.0 and \", \"later versions. \\nUWP \\nUWP isn\\u2019t only a presentation framework like WPF and Windows Forms, but it\\u2019s a\", \"lso a platform itself. \\nThis platform has: \\n\\u2022 \\nIts own API set (the Windows Runtime API). \\n\\u2022 \\nA new \", \"deployment system (MSIX) \\n\\u2022 \\nA modern application lifecycle model (for low battery consumption). \\n\\u2022 \", \"\\nA new Resource Management System (based on PRI files). \\nThe platform was created to support all kin\", \"ds of input systems (like ink, touch, gamepad, mouse, \\nkeyboard, gaze, and so on) in all form-factor\", \"s with performance and low battery consumption in mind. \\nFor these reasons, the shell of the Windows\", \" 10 OS uses parts of the UWP platform. \\n \\n5 \\nCHAPTER 1 | Why modern desktop applications \\n \\n \\nUWP co\", \"ntains a presentation framework that is XAML-based, like WPF, but it has some important \\ndifferences\", \" such as: \\n\\u2022 \\nApplications are executed in app containers. App containers control what resources a U\", \"WP \\napp can access. \\n\\u2022 \\nSupported only on Windows 10 and Windows 11. \\n\\u2022 \\nApps can be deployed throug\", \"h Microsoft Store for easier deployment. \\n\\u2022 \\nDesigned as part of the Windows Runtime API. \\n\\u2022 \\nContai\", \"ns an extensive set of rich built-in controls and additional controls are available \\nthrough the Mic\", \"rosoft UI Library NuGet packages (WinUI library), updated every few months. \\nA tale of two platforms\", \" \\nIn the last 20 years, while UI desktop technologies were growing and following the path from \\nWind\", \"ows Forms to UWP, the hardware was also evolving from heavyweight PC units with small CRT \\nmonitors \", \"to high-DPI monitors and lightweight tablets and phones with different data input \\ntechniques like T\", \"ouch and Ink. These changes resulted in creating two different concepts: a Desktop \\nApplication and \", \"a Modern Application. A Modern Application is one that considers different device \\nform factors, var\", \"ious input and output methods, and leverages modern desktop features while \\nrunning on a sandboxed e\", \"xecution model. The (traditional) Desktop Application, on the other hand, is \\n \\n6 \\nCHAPTER 1 | Why m\", \"odern desktop applications \\n \\nan application that needs a solid UI with a high density of controls t\", \"hat is best operated with a mouse \\nand a keyboard. \\nThe following table describes the differences be\", \"tween the two concepts: \\nAspect of comparison \\nModern Application \\nDesktop Application \\nSecurity \\nCo\", \"ntained execution & Great \\nFundamentals. Designed from \\nthe ground up to respect user\\u2019s \\nprivacy, ma\", \"nage battery life, \\nand focus to keep the device \\nsafe. \\nUser & Admin level of security. \\nYou have n\", \"ative access to the \\nregistry and hard drive folders. \\nDeployment \\nInstallation and updates are \\nman\", \"aged by the platform. \\nMSI, Custom installers & \\nUpdates. Traditionally a source \\nof headaches for d\", \"evelopers \\nand IT managers. \\nDistribution \\nTrusted Distribution & Signed \\nPackages. Distribution is \", \"\\nperformed from a trusted \\nsource and never from the \\nweb. \\nWeb, SCCM & Custom \\ndistribution. No con\", \"trol over \\nwhat is installed, affects the \\nwhole machine. \\nUI \\nModern UI. Different input \\nmechanism\", \"s, ink, touch, \\ngamepad, keyboard, mouse, \\netc. \\nWindows Forms, WPF, MFC. \\nDesigned for the mouse an\", \"d \\nkeyboard for a dense UI and to \\nget the most productivity from \\nthe desktop. \\nData \\nCloud First D\", \"ata with Insights. \\nSource of truth in the cloud. \\nInsights to know what happens \\nwith your app and \", \"how it\\u2019s \\nperforming. \\nLocal Data. Traditional desktop \\napplications usually need some \\nlocal data. \", \"\\nDesign \\nDesigned for reuse. Reuse in \\nmind between different \\nplatforms, front end, and back \\nend, \", \"running assets in many \\nplaces as possible. \\nDesigned for Windows \\nDesktop only \\nAs a part of the co\", \"mmitment to provide developers with the best tools to build applications, Microsoft \\nput forth a gre\", \"at effort to bring these concepts - or we can even say platforms - closer together to \\nempower devel\", \"opers with the best of both worlds. To do that, Microsoft has performed a bidirectional \\neffort betw\", \"een the two platforms. \\n \\n7 \\nCHAPTER 1 | Why modern desktop applications \\n \\n \\n1. \\nMove Desktop Appli\", \"cation scenarios into Modern Application platform. The traditional \\ndesktop development is still pop\", \"ular because it addresses certain scenarios well. It makes \\nsense to take these common desktop scena\", \"rios and bring them into the modern desktop \\nplatform to make the platform fully capable. \\n \\n   \\n \\n1\", \". \\nMove Modern Application features into Desktop Applications. For existing desktop apps that \\nneed \", \"a way to leverage modern capabilities without rewriting from scratch, features from the \\nModern Appl\", \"ication platform are pushed into the Desktop Application. \\n \\n   \\n \\n \\n8 \\nCHAPTER 1 | Why modern deskt\", \"op applications \\n \\nIn this book, we\\u2019ll focus on the second part and show how you can modernize your \", \"existing desktop \\napplications. \\nPaths to modernization \\nThe structure of this guide reflects three \", \"different axes to accomplish modernization: Modern \\nFeatures, Deployment, and Installation. \\nModern \", \"features \\nSay you have a working Windows Forms application that a sales representative of your compa\", \"ny uses \\nto fill in a customer order. A new requirement comes in to enable the customer to sign the \", \"order \\nusing a tablet pen. Inking is native in today\\u2019s operating systems and technologies, but it wa\", \"sn\\u2019t \\navailable when the app was developed. \\nThis path will show you how you can leverage modern des\", \"ktop features into your existing desktop \\ndevelopment. \\nDeployment \\nModern development cycles have s\", \"tressed the importance of providing agility with regard to how new \\nversions of applications are dep\", \"loyed to individual users. Since Windows Forms and WPF applications \\nare based on a particular versi\", \"on of the .NET Framework that must be present on the machine, they \\ncan\\u2019t take advantage of new .NET\", \" Framework version features without the intervention of the IT \\npeople with the risk of having side \", \"effects for other apps running on the same machine. It has limited \\nthe innovation pace for develope\", \"rs forcing them to stay on outdated versions of the .NET Framework. \\nSince the launch of .NET Core 3\", \".0, you can leverage a new approach of deploying multiple versions of \\n.NET side by side and specify\", \"ing which version of .NET each application should target. This way, you \\ncan use the newest features\", \" in one application while being confident you aren\\u2019t going to break any \\nother applications. \\nInstal\", \"lation \\nDesktop applications always rely on some sort of installation process before the user can st\", \"art using \\nthem. This fact brought into the game a set of technologies, from MSI and ClickOnce to cu\", \"stom \\ninstallers or even XCOPY deployment. Any of these methods deals with delicate problems because\", \" \\napplications need a way to access shared resources on the machine. Sometimes installation needs to\", \" \\naccess the Registry to insert or update new Key Values, sometimes to update shared DLLs referenced\", \" \\nby the main application. This behavior causes a continuous headache for users, creating this \\nperc\", \"eption that once you install some application, your computer will never be the same, even if you \\nun\", \"install it afterwards. \\nIn this book, we\\u2019ll introduce a new way of installing applications with MSIX\", \" that solves the problem \\ndescribed earlier. You\\u2019ll learn how you can easily set up packaging, insta\", \"llation, and updates for your \\napplication. \\n \\n9 \\nCHAPTER 2 | What\\u2019s new with .NET for Desktop? \\n \\nC\", \"HAPTER 2 \\nWhat\\u2019s new with .NET for \\nDesktop? \\nDesktop applications such as Windows Forms and WPF can\", \" be built using various .NET \\nimplementations, for example, .NET Framework or .NET 7. In this chapte\", \"r, we\\u2019ll talk about the history \\nof each implementation, explain the differences, and show what new \", \"features await desktop \\ndevelopers in newer implementations. \\nIf you\\u2019ve been developing Windows Form\", \"s or WPF applications for a long time, you\\u2019re familiar with \\n.NET Framework. Later, .NET Core (speci\", \"fically its 3.0 version) started supporting desktop applications. \\n.NET Core was rebranded to .NET w\", \"hen .NET 5 was released. Just as there are different versions of \\n.NET Framework, for example, 4.6, \", \"4.7, and 4.8, there are also different versions of .NET Core: .NET \\nCore 3.0, .NET 5, .NET 6, .NET 7\", \", and so on. \\nLet\\u2019s look into the history of each implementation to understand the differences and b\", \"enefits of each. \\nThe motivation behind .NET Core \\nSince its launch in 2002, .NET Framework has evol\", \"ved to support many technologies, like Windows \\nForms, ASP.NET, Entity Framework, Windows Store, and\", \" many others. All of them are different in \\nnature. Therefore, Microsoft approached this evolution b\", \"y taking parts of .NET Framework and \\ncreating a different application stack for each technology. Th\", \"at way, development capabilities could \\nbe customized for the needs of the specific stack, which max\", \"imized the potential of every platform. \\nThat led to fragmentation on the versions of .NET Framework\", \" maintained by different independent \\nteams. All of these stacks have a common structure, containing\", \" an app model, a framework, and a \\nruntime, but they differ in the implementation of each of the par\", \"ts. \\nIf you\\u2019re targeting only one of these platforms, you can use this model. However, in many cases\", \" you \\nmight need more than one target platform in the same solution. For example, your application m\", \"ay \\nhave a desktop admin part, a customer-facing web site that shares the back-end logic running on \", \"a \\nserver, and even a mobile client. In this case, you need a unified coding experience that can spa\", \"n all of \\nthese .NET verticals. \\nBy the time Windows 8 was released, the concept of Portable Class L\", \"ibraries (PCLs) was born. \\nOriginally, .NET Framework was designed around the assumption that it wou\", \"ld always be deployed as \\na single unit, so factoring wasn\\u2019t a concern. To face the problem of code \", \"sharing between verticals, the \\ndriving force was on how to refactor the framework. The idea of cont\", \"racts is to provide a well-factored \\n \\n10 \\nCHAPTER 2 | What\\u2019s new with .NET for Desktop? \\n \\nAPI surf\", \"ace area. Contracts are simply assemblies that you compile against and are designed with \\nproper fac\", \"toring in mind taking care of the dependencies between them. \\nThis led to reasoning about the API di\", \"fferences between verticals at the assembly level, as opposed to \\nat the individual API level like p\", \"reviously. This aspect enabled a class library experience that can target \\nmultiple verticals, also \", \"known as portable class libraries. \\n \\nWith PCL, the experience of development is unified across vert\", \"icals based on the API shape. And the \\nmost pressing need to create libraries running on different v\", \"erticals is also addressed. But there\\u2019s a \\ngreat challenge: APIs are only portable when the implemen\", \"tation is moved forward across all the \\nverticals. \\nA better approach is to unify the implementation\", \"s across verticals by providing a well-factored \\nimplementation instead of a well-factored view. It\\u2019\", \"s a lot simpler to ask each team that owns a specific \\ncomponent to think about how their APIs work \", \"across all verticals than trying to retroactively provide \\na consistent API stack on top. This is wh\", \"ere .NET Standard comes in. \\nAnother large challenge has to do with how .NET Framework is deployed. \", \".NET Framework is a \\nmachine-wide framework. Any changes made to it affect all applications that tak\", \"e a dependency on it. \\nAlthough this deployment model has many advantages, such as reducing disk spa\", \"ce and centralized \\naccess to services, it presents some pitfalls. \\nTo start with, it\\u2019s difficult fo\", \"r application developers to take a dependency on a recently released \\nframework. They either have to\", \" take a dependency on the latest OS or provide an application installer \\nthat installs .NET Framewor\", \"k along with the application. If you\\u2019re a web developer, you might not even \\nhave this option as the\", \" IT department establishes the server supported version. \\nEven if you\\u2019re willing to go through the t\", \"rouble of providing an installer to chain in .NET Framework \\nsetup, you may find that upgrading .NET\", \" Framework can break other applications. \\nDespite the efforts to provide backward compatible version\", \"s of the framework, there are compatible \\nchanges that can break applications. For example, adding a\", \"n interface to an existing type can change \\nhow this type is serialized and cause breaking problems \", \"depending on the existing code. Because the \\n.NET Framework installed base is huge, fighting against\", \" these breaking scenarios slows down the pace \\nof innovations inside .NET Framework. \\nTo solve all t\", \"hese issues, Microsoft developed .NET Core as the evolution of the .NET development \\nplatform. \\n \\n11\", \" \\nCHAPTER 2 | What\\u2019s new with .NET for Desktop? \\n \\nIntroduction to .NET Core \\n.NET Core, which is no\", \"w referred to as just \\u201c.NET\\u201d, is the evolution of Microsoft\\u2019s .NET technology into \\na modular, cross\", \"-platform, open source, and cloud-ready platform. It runs on Windows, macOS, and \\nLinux, and some AR\", \"M-based architectures like Android and IoT. \\nThe purpose of .NET Core is to provide a unified platfo\", \"rm for all types of applications, which includes \\nWindows, cross-platform, and mobile applications. \", \".NET Standard enabled this by providing shared \\nbase APIs, which every application model needs, and \", \"excluding any application model-specific API. \\nThis framework gives applications many benefits in te\", \"rms of efficiency and performance, simplifying \\nthe packaging and deployment in the different suppor\", \"ted platforms. \\nThe benefits of .NET Core come from these three characteristics: \\n\\u2022 \\nCross-platform:\", \" It allows application execution on different platforms (Windows, macOS, and \\nLinux). \\n\\u2022 \\nOpen sourc\", \"e: .NET Core platform is open source and available through GitHub, fostering \\ntransparency and commu\", \"nity contributions. \\n\\u2022 \\nSupported: Microsoft officially supports .NET Core. \\nStarting with .NET Core\", \" 3.0, besides the existing support for web and cloud, there\\u2019s also support for \\ndesktop, IoT, and AI\", \" domains. The goal for this framework is impressive: to target every type of .NET \\ndevelopment prese\", \"nt and future. \\n.NET 5+ is .NET Core vNext \\n.NET 5 was the next step forward with .NET Core. .NET 5 \", \"improved .NET in a few key ways: \\n\\u2022 \\nProduced a single .NET runtime and framework that can be used e\", \"verywhere and that has \\nuniform runtime behaviors and developer experiences. \\n\\u2022 \\nExpanded the capabi\", \"lities of .NET by taking the best of .NET Core, .NET Framework, Xamarin, \\nand Mono. \\n\\u2022 \\nBuilt that p\", \"roduct out of a single code-base that developers (Microsoft and the community) \\ncan work on and expa\", \"nd together and that improves all scenarios. \\n.NET 5 was a game-changer for .NET. With .NET 5 and la\", \"ter versions, your code and project files look \\nand feel the same no matter which type of app you\\u2019re\", \" building. You have access to the same runtime, \\nAPIs, and language capabilities with each app. This\", \" includes new performance improvements that get \\ncommitted to the runtime almost daily. .NET 6 and .\", \"NET 7 made further improvements in reliability, \\nperformance, new APIs, and language features. For m\", \"ore details, see What\\u2019s new in .NET 5, What\\u2019s \\nnew in .NET 6, and What\\u2019s new in .NET 7. \\n \\n12 \\nCHAPT\", \"ER 2 | What\\u2019s new with .NET for Desktop? \\n \\n \\n.NET Framework vs. .NET \\nSo now that you understand th\", \"e relevance of .NET, you might be wondering what happens with .NET \\nFramework. You could be asking q\", \"uestions like: Do I have to abandon it? Is it going to disappear? \\nWhat are my choices to modernize \", \"the applications I have on .NET Framework? \\nIn 2019, .NET Framework 4.8 was released. It included th\", \"ree major improvements for desktop \\napplications: \\n\\u2022 \\nModern browser and media controls: New control\", \"s were added that take advantage of \\nMicrosoft Edge and newer media players that support the latest \", \"standards. \\n\\u2022 \\nAccess to UWP controls: UWP introduced controls that take advantage of the latest \\nWi\", \"ndows features and touch displays. With .NET Framework 4.8, you don\\u2019t have to rewrite \\nyour applicat\", \"ions to use these new features and controls, so you can use these new features \\nin your existing WPF\", \" or Windows Forms code. \\n\\u2022 \\nHigh-DPI improvements: The resolution of displays increased to 4K and 8K\", \", so, .NET \\nFramework 4.8 added new HDPI improvements to make sure existing Windows Forms and \\nWPF a\", \"pplications can look great on these new displays. \\nSince .NET Framework is installed on millions of \", \"machines, Microsoft will continue to support it but \\nwon\\u2019t add new features. \\n.NET (Core) is the ope\", \"n-source, cross-platform, and fast-moving version of the .NET family. Because of \\nits side-by-side n\", \"ature, it can take changes without the fear of breaking any application. This means \\nthat .NET will \", \"get new APIs and language features over time that .NET Framework won\\u2019t. Also, .NET \\nalready has feat\", \"ures that were impossible for .NET Framework, such as: \\n\\u2022 \\nSide-by-side versions of .NET supporting \", \"Windows Forms and WPF: This solves the \\nproblem of side effects when updating the machine\\u2019s framewor\", \"k version. Multiple versions of \\n.NET can be installed on the same machine and each application spec\", \"ifies which version of \\n \\n13 \\nCHAPTER 2 | What\\u2019s new with .NET for Desktop? \\n \\n.NET it should use. E\", \"ven more, now you can develop and run Windows Forms and WPF on top \\nof .NET. \\n\\u2022 \\nEmbed .NET directly\", \" into an application: You can deploy .NET as part of your application \\npackage. This enables you to \", \"take advantage of the latest version, features, and APIs without \\nhaving to wait for a specific vers\", \"ion to be installed on the machine. \\n\\u2022 \\nTake advantage of .NET features: .NET is fast-moving and ope\", \"n-source. Its side-by-side \\nnature enables fast introduction of new innovative APIs and Base Class L\", \"ibrary (BCL) \\nimprovements without the risk of breaking compatibility. Now Windows Forms and WPF \\nap\", \"plications can take advantage of the latest .NET features, which also includes fundamental \\nfixes fo\", \"r things like runtime performance and high-DPI support. \\n.NET Framework will be fully supported and \", \"will always be a part of Windows. However, if you want to \\nuse the newest language features and APIs\", \" in the future, you\\u2019ll need to move your applications to \\n.NET. For brand-new desktop apps, we recom\", \"mend starting directly on .NET 6 or a later version. It\\u2019s \\nlightweight and cross-platform, runs side\", \" by side, has high performance, and fits perfectly on \\ncontainers and microservices architectures. \\n\", \" \\n.NET Standard vs. PCL \\n.NET Standard is a formal specification of .NET APIs that are intended to b\", \"e available on all .NET \\nimplementations. The motivation behind .NET Standard was to establish great\", \"er uniformity in the .NET \\necosystem. .NET Standard is a specification of .NET APIs that make up a u\", \"niform set of contracts to \\ncompile your code against. These contracts are implemented in each .NET \", \"flavor, thus enabling \\nportability across different .NET implementations. \\n.NET Standard enables the\", \" following key scenarios: \\n\\u2022 \\nDefines uniform set of base class libraries APIs for all .NET implemen\", \"tations to implement, \\nindependent of the workload. \\n\\u2022 \\nEnables developers to produce portable libra\", \"ries that are usable across .NET implementations, \\nusing this same set of APIs. \\n \\n14 \\nCHAPTER 2 | W\", \"hat\\u2019s new with .NET for Desktop? \\n \\n.NET Standard is the evolution of PCLs and the following list sh\", \"ows the fundamental differences \\nbetween .NET Standard and PCLs: \\n\\u2022 \\n.NET Standard is a set of curat\", \"ed APIs, picked by Microsoft. PCLs aren\\u2019t. \\n\\u2022 \\nThe APIs that a PCL contains are dependent on the pla\", \"tforms that you choose to target when \\nyou create it. This makes a PCL only sharable for the specifi\", \"c targets that you choose. \\n\\u2022 \\n.NET Standard is platform-agnostic, so it can run on Windows, macOS, \", \"and Linux. \\n\\u2022 \\nPCLs can also run cross-platform, but they can only target a limited set of platforms\", \". \\nNew Desktop features in .NET \\nSupport for Windows Forms and WPF \\nWindows Forms and WPF are part o\", \"f .NET Core since version 3.0. Both presentation frameworks are \\nfor Windows only, so they aren\\u2019t cr\", \"oss-platform. You can think of WPF as a rich layer over DirectX and \\nWindows Forms as a thinner laye\", \"r over GDI+. WPF and Windows Forms do a great job of exposing \\nand exercising much of the desktop ap\", \"plication functionality in Windows. So Windows Forms and \\nWPF are available for .NET Core and .NET F\", \"ramework. Target your new desktop applications to .NET 6 \\nor later, and migrate your existing apps f\", \"rom .NET Framework to .NET 6 or later. \\nA new version of .NET Standard, version 2.1, was released at\", \" the same time as .NET Core 3.0. To see \\nwhich .NET implementations support which .NET Standard vers\", \"ions, see Which .NET Standard version \\nto target. \\nThe .NET (Core) implementations for both Windows \", \"Forms and WPF are open source. \\nXAML Islands \\nXAML Islands is a set of components for developers to \", \"use Windows 10 controls (UWP XAML controls) \\nin their WPF, Windows Forms, and native Win32 apps (lik\", \"e MFC). You can have your \\u201cislands\\u201d of UWP \\nXAML controls wherever you want inside your Win32 apps. \", \"\\nThese XAML Islands are possible because Windows 10, version 1903 introduced a set of APIs that \\nall\", \"ows hosting UWP XAML content in Win32 windows using windows handlers (HWnds). Only apps \\nrunning on \", \"Windows 10 1903 and later can use XAML Islands. \\nTo make it easier to create XAML Islands for Window\", \"s Forms and WPF developers, the Windows \\nCommunity Toolkit introduces a set of .NET wrappers in seve\", \"ral NuGet packages. Those wrappers are \\nthe wrapped and hosting controls: \\n\\u2022 \\nThe WebView, WebViewCo\", \"mpatible, InkCanvas, MediaPlayerElement, and MapControl \\nwrapped controls wrap some UWP XAML control\", \"s into Windows Forms or WPF controls, \\nhiding UWP concepts for those developers. \\n\\u2022 \\nThe WindowsXaml\", \"Host control for Windows Forms and WPF allows other not-wrapped UWP \\nXAML controls and custom contro\", \"ls to be loaded into a XAML Island. \\n \\n15 \\nCHAPTER 2 | What\\u2019s new with .NET for Desktop? \\n \\nAccess t\", \"o all Windows 10 and Windows 11 APIs \\nWindows 10 and Windows 11 have a large number of APIs availabl\", \"e for developers to work with. \\nThese APIs give access to a wide variety of functionality like authe\", \"ntication, bluetooth, appointments, \\nand contacts. Now these APIs are exposed through .NET and give \", \"Windows developers the chance to \\ncreate powerful desktops apps using the capabilities present on Wi\", \"ndows 10 and Windows 11. \\nSide-by-side support and self-contained EXEs \\nThe .NET deployment model is\", \" one of the biggest benefits that Windows desktop developers will \\nexperience with .NET. The ability\", \" to globally install .NET provides much of the same central installation \\nand servicing benefits of \", \".NET Framework, while not requiring in-place updates. \\nWhen a new .NET version is released, you can \", \"update each app on a machine as needed without any \\nconcern of affecting other applications. New .NE\", \"T versions are installed in their own directories and \\nexist \\u201cside-by-side\\u201d with each other. \\nIf you\", \" need to deploy with isolation, you can deploy .NET with your application. .NET will bundle your \\nap\", \"p with the .NET runtime as a single executable. The modular architecture used by .NET makes these \\nf\", \"lexible deployment options possible. \\nPerformance \\nSince its start, targeting the web and cloud work\", \"loads, .NET has had performance plugged into its \\nDNA. Server-side code must be performant enough to\", \" fulfill high-concurrency scenarios and .NET 7 \\nscores today as the best performance web platform in\", \" the market. \\nOld Windows Forms code has been refactored for .NET, which reduced memory allocations \", \"for \\ndrawing Forms and Controls. By simply upgrading from .NET Framework to .NET or later, your \\napp\", \"lications become much faster. You can take advantage of these performance improvements when \\nyou use\", \" .NET to build your next generation of desktop applications. \\n \\n16 \\nCHAPTER 3 | Migrating Modern Des\", \"ktop applications \\n \\nCHAPTER 3 \\nMigrating Modern \\nDesktop applications \\nIn this chapter, we\\u2019re explo\", \"ring the most common issues and challenges you can face when migrating \\nan existing application from\", \" .NET Framework to .NET. \\nIf you just want to update your application to the latest .NET version usi\", \"ng a tool and not get into the \\ndetails of what\\u2019s happening behind the scenes, feel free to skip thi\", \"s chapter and find step-by-step \\ninstructions in the Example of migrating to .NET chapter. \\nA comple\", \"x desktop application doesn\\u2019t work in isolation and needs some kind of interaction with \\nsubsystems \", \"that may reside on the local machine or on a remote server. It will probably need some \\nkind of data\", \"base to connect with as a persistence store either locally or remotely. With the rise of \\nInternet a\", \"nd service-oriented architectures, it\\u2019s common to have your application connected to some \\nsort of s\", \"ervice residing on a remote server or in the cloud. You may need to access the machine file \\nsystem \", \"to implement some functionality. Alternatively, maybe you\\u2019re using a piece of functionality \\nthat re\", \"sides inside a COM object outside your application, which is a common scenario if, for example, \\nyou\", \"\\u2019re integrating Office assemblies in your app. \\nBesides, there are differences in the API surface th\", \"at is exposed by .NET Framework and .NET, and \\nsome features that are available on .NET Framework ar\", \"en\\u2019t available on .NET. It\\u2019s important for you to \\nknow and take them into account when planning a m\", \"igration. \\nConfiguration files \\nConfiguration files offer the possibility to store sets of propertie\", \"s that are read at run time and can \\naffect the behavior of your app, such as where to locate a data\", \"base or how many times to execute a \\nloop. The beauty of this technique is that you can modify some \", \"aspects of the application without the \\nneed to recode and recompile. This comes in handy when, for \", \"example, the same app code runs on a \\ndevelopment environment with a certain set of configuration va\", \"lues and in production environment \\nwith a different set. \\nConfiguration on .NET Framework \\nIf you h\", \"ave a working .NET Framework desktop application, chances are you have an app.config file \\naccessed \", \"through the AppSettingsSection class from the System.Configuration namespace. \\n \\n17 \\nCHAPTER 3 | Mig\", \"rating Modern Desktop applications \\n \\nWithin the .NET Framework infrastructure, there\\u2019s a hierarchy \", \"of configuration files that inherit \\nproperties from its parents. You can find a machine.config file\", \" that defines many properties and \\nconfiguration sections that can be used or overridden in any desc\", \"endant configuration file. \\nConfiguration on .NET \\nIn the .NET world, there\\u2019s no machine.config file\", \". And even though you can continue to use the old \\nfashioned System.Configuration namespace, you may\", \" consider switching to the modern \\nMicrosoft.Extensions.Configuration, which offers a good number of\", \" enhancements. \\nThis configuration API supports the concept of a configuration provider, which defin\", \"es the data source \\nto be used to load the configuration. There are different kinds of built-in prov\", \"iders, such as: \\n\\u2022 \\nIn-memory .NET objects \\n\\u2022 \\nINI files \\n\\u2022 \\nJSON files \\n\\u2022 \\nXML files \\n\\u2022 \\nCommand-li\", \"ne arguments \\n\\u2022 \\nEnvironment variables \\n\\u2022 \\nEncrypted user store \\nOr you can build your own. \\nThe new\", \" configuration API allows a list of name-value pairs that can be grouped into a multi-level \\nhierarc\", \"hy. Any stored value maps to a string, and there\\u2019s built-in binding support that allows you to \\ndese\", \"rialize settings into a custom plain old CLR object (POCO). \\nThe ConfigurationBuilder object lets yo\", \"u add as many configuration providers as you may need for \\nyour application. A precedence rule is us\", \"ed to resolve provider preference. So, the last provider you \\nadd in your code overrides the others.\", \" This is a great feature for managing different environments for \\nexecution since you can define dif\", \"ferent configurations for development, testing, and production \\nenvironments. And you can manage the\", \"m in a single function inside your code. \\nMigrating configuration files \\nYou can continue to use you\", \"r existing app.config XML file. However, you could take this opportunity \\nto migrate your configurat\", \"ion to benefit from the several enhancements made in .NET. \\nTo migrate from an old-style app.config \", \"to a new configuration file, you should choose between an \\nXML format and a JSON format. \\nIf you cho\", \"ose XML, the conversion is straightforward. Since the content is the same, just save the \\napp.config\", \" file with XML as type. Then, change the code that references AppSettings to use the \\nConfigurationB\", \"uilder class. This change should be easy. \\nIf you want to use a JSON format and you don\\u2019t want to mi\", \"grate by hand, there\\u2019s a tool called dotnet-\\nconfig2json that can convert an app.config file to a JS\", \"ON configuration file. \\nYou may come across some issues when using configuration sections that were \", \"defined in the \\nmachine.config file. For example, consider the following configuration: \\n \\n18 \\nCHAPT\", \"ER 3 | Migrating Modern Desktop applications \\n \\n<configuration> \\n    <system.diagnostics> \\n        <\", \"switches> \\n            <add name=\\\"General\\\" value=\\\"4\\\" /> \\n        </switches> \\n        <trace autoflu\", \"sh=\\\"true\\\" indentsize=\\\"2\\\"> \\n            <listeners> \\n                <add name=\\\"myListener\\\" \\n        \", \"             type=\\\"System.Diagnostics.TextWriterTraceListener, \\n                           System, V\", \"ersion=1.0.3300.0, Culture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\" \\n                     initiali\", \"zeData=\\\"MyListener.log\\\" \\n                     traceOutputOptions=\\\"ProcessId, LogicalOperationStack, \", \"Timestamp, \\nThreadId, Callstack, DateTime\\\" /> \\n            </listeners> \\n        </trace> \\n    </sys\", \"tem.diagnostics> \\n</configuration> \\nIf you take this configuration to a .NET app, you\\u2019ll get an exce\", \"ption: \\nUnrecognized configuration section System.Diagnostics \\nThis exception occurs because that se\", \"ction and the assembly responsible for handling that section \\nwas defined in the machine.config file\", \", which now doesn\\u2019t exist. \\nTo easily fix the issue, you can copy the section definition from your o\", \"ld machine.config to your new \\nconfiguration file: \\n<configSections> \\n    <section name=\\\"system.diag\", \"nostics\\\" \\n             type=\\\"System.Diagnostics.SystemDiagnosticsSection, \\n                   System\", \", Version=4.0.0.0, Culture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\"/> \\n</configSections> \\nAccessin\", \"g databases \\nAlmost every desktop application needs some kind of database. For desktop, it\\u2019s common \", \"to find \\nclient-server architectures with a direct connection between the desktop app and the databa\", \"se \\nengine. These databases can be local or remote depending on the need to share information betwee\", \"n \\ndifferent users. \\nFrom the code perspective, there have been many technologies and frameworks to \", \"give the developer \\nthe possibility to connect, query, and update a database. \\nThe most common examp\", \"les of database you can find when talking about Windows Desktop \\napplication are Microsoft Access an\", \"d Microsoft SQL Server. If you have more than 20 years of \\nexperience programming for the desktop, n\", \"ames like ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ, and \\nEntity Framework will sound familiar. \\n \\n19 \\nCH\", \"APTER 3 | Migrating Modern Desktop applications \\n \\nODBC \\nYou can continue to use ODBC on .NET since \", \"Microsoft is providing the System.Data.Odbc library \\ncompatible with .NET Standard 2.0. \\nOLE DB \\nOLE\", \" DB has been a great way to access various data sources in a uniform manner. But it was based on \\nCO\", \"M, which is a Windows-only technology, and as such wasn\\u2019t the best fit for a cross-platform \\ntechnol\", \"ogy such as .NET. It\\u2019s also unsupported in SQL Server versions 2014 and later. For those \\nreasons, O\", \"LE DB won\\u2019t be supported by .NET. \\nADO.NET \\nYou can still use ADO.NET from your existing desktop cod\", \"e on .NET. You just need to update some \\nNuGet packages. \\nEF Core vs. EF6 \\nThere are two currently s\", \"upported versions of Entity Framework (EF), Entity Framework 6 (EF6) and EF \\nCore. \\nThe latest techn\", \"ology released as part of the .NET Framework world is Entity Framework, with 6.4 \\nbeing the latest v\", \"ersion. With the launch of .NET Core, Microsoft also released a new data access stack \\nbased on Enti\", \"ty Framework and called Entity Framework Core. \\nYou can use EF 6.4 and EF Core from both .NET Framew\", \"ork and .NET. So, what are the decision drivers \\nto help to decide between the two? \\nEF 6.3 is the f\", \"irst version of EF6 that can run on .NET and work cross-platform. In fact, the main goal of \\nthis re\", \"lease was to make it easier to migrate existing applications that use EF6 to .NET. \\nEF Core was desi\", \"gned to provide a developer experience similar to EF6. Most of the top-level APIs \\nremain the same, \", \"so EF Core will feel familiar to developers who have used EF6. \\nAlthough compatible, there are diffe\", \"rences on the implementation you should check before making a \\ndecision. For more information, see C\", \"ompare EF Core & EF6. \\nThe recommendation is to use EF Core if: \\n\\u2022 \\nThe app needs the capabilities o\", \"f .NET. \\n\\u2022 \\nEF Core supports all of the features that the app requires. \\nConsider using EF6 if both \", \"of the following conditions are true: \\n\\u2022 \\nThe app will run on Windows and .NET Framework 4.0 or late\", \"r. \\n\\u2022 \\nEF6 supports all of the features that the app requires. \\n \\n20 \\nCHAPTER 3 | Migrating Modern D\", \"esktop applications \\n \\nRelational databases \\nSQL Server \\nSQL Server has been one of the databases of\", \" choice if you were developing for the desktop some \\nyears ago. With the use of System.Data.SqlClien\", \"t in .NET Framework, you could access versions of SQL \\nServer, which encapsulates database-specific \", \"protocols. \\nIn .NET, you can find a new SqlClient class, fully compatible with the one existing in t\", \"he .NET \\nFramework but located in the Microsoft.Data.SqlClient library. You just have to add a refer\", \"ence to the \\nMicrosoft.Data.SqlClient NuGet package and do some renaming for the namespaces and ever\", \"ything \\nshould work as expected. \\nMicrosoft Access \\nMicrosoft Access has been used for years when th\", \"e sophisticated and more scalable SQL Server wasn\\u2019t \\nneeded. You can still connect to Microsoft Acce\", \"ss using the System.Data.Odbc library. \\nConsuming services \\nWith the rise of service-oriented archit\", \"ectures, desktop applications began to evolve from a client-\\nserver model to the three-layer approac\", \"h. In the client-server approach, a direct database connection \\nis established from the client holdi\", \"ng the business logic, usually inside a single EXE file. On the other \\nhand, the three-layer approac\", \"h establishes an intermediate service layer implementing business logic \\nand database access, allowi\", \"ng for better security, scalability, and reusability. Instead of working \\ndirectly with underlying d\", \"ata, the layered approach relies on a set of services implementing contracts \\nand typed objects for \", \"data transfer. \\nIf you have a desktop application using a WCF service and you want to migrate it to \", \".NET, there are \\nsome things to consider. \\nThe first thing is how to resolve the configuration to ac\", \"cess the service. Because the configuration is \\ndifferent on .NET, you\\u2019ll need to make some updates \", \"in your configuration file. \\nSecond, you\\u2019ll need to regenerate the service client with the new tools\", \" present on Visual Studio 2019 \\nand Visual Studio 2022. In this step, you must consider activating t\", \"he generation of the synchronous \\noperations to make the client compatible with your existing code. \", \"\\nAfter the migration, if you find that there are libraries you need that aren\\u2019t present on .NET, you\", \" can \\nadd a reference to the Microsoft.Windows.Compatibility NuGet package and see if the missing \\nf\", \"unctions are there. \\nIf you\\u2019re using the WebRequest class to perform web service calls, you may find\", \" some differences on \\n.NET. The recommendation is to use HttpClient instead. \\n \\n21 \\nCHAPTER 3 | Migr\", \"ating Modern Desktop applications \\n \\nConsuming a COM Object \\nCurrently, there\\u2019s no way to add a refe\", \"rence to a COM object from Visual Studio 2019 or Visual Studio \\n2022 to use with .NET. So, you have \", \"to manually modify the project file. \\nInsert a COMReference structure inside the project file like i\", \"n the following example: \\n<ItemGroup> \\n    <COMReference Include=\\\"MSHTML\\\"> \\n        <Guid>{3050F1C5-\", \"98B5-11CF-BB82-00AA00BDCE0B}\\\\</Guid> \\n        <VersionMajor>4</VersionMajor> \\n        <VersionMinor>\", \"0</VersionMinor> \\n        <Lcid>0</Lcid> \\n        <WrapperTool>primary</WrapperTool> \\n        <Isola\", \"ted>false</Isolated> \\n    </COMReference> \\n</ItemGroup> \\nMore things to consider \\nSeveral technologi\", \"es available to .NET Framework libraries aren\\u2019t available for .NET Core or .NET 7. If \\nyour code rel\", \"ies on some of these technologies, consider the alternative approaches outlined in this \\nsection. \\nT\", \"he Windows Compatibility Pack provides access to APIs that were previously available only for .NET \\n\", \"Framework. It can be used on .NET Core and .NET Standard projects. \\nFor more information on API comp\", \"atibility, you can find documentation about breaking changes and \\ndeprecated/legacy APIs at https://\", \"learn.microsoft.com/dotnet/core/compatibility/fx-core. \\nAppDomains \\nApplication domains (AppDomains)\", \" isolate apps from one another. AppDomains require runtime \\nsupport and are expensive. Creating addi\", \"tional app domains isn\\u2019t supported. For code isolation, we \\nrecommend separate processes or using co\", \"ntainers as an alternative. For the dynamic loading of \\nassemblies, we recommend the new AssemblyLoa\", \"dContext class. \\nTo make code migration from .NET Framework easier, .NET exposes some of the AppDoma\", \"in API \\nsurface. Some of the APIs function normally (for example, AppDomain.UnhandledException), som\", \"e \\nmembers do nothing (for example, SetCachePath), and some of them throw \\nPlatformNotSupportedExcep\", \"tion (for example, CreateDomain). \\nRemoting \\n.NET Remoting was used for cross-AppDomain communicatio\", \"n, which is no longer supported. Also, \\nRemoting requires runtime support, which is expensive to mai\", \"ntain. For these reasons, .NET Remoting \\nisn\\u2019t supported on .NET. \\nFor communication across processe\", \"s, you should consider inter-process communication (IPC) \\nmechanisms as an alternative to Remoting, \", \"such as the  or the MemoryMappedFile class. \\n \\n22 \\nCHAPTER 3 | Migrating Modern Desktop applications\", \" \\n \\nAcross machines, use a network-based solution as an alternative. Preferably, use a low-overhead \", \"\\nplaintext protocol, such as HTTP. The Kestrel web server, the web server used by ASP.NET Core, is a\", \"n \\noption here. \\nCode Access Security (CAS) \\nSandboxing, which relies on the runtime or the framewor\", \"k to constrain which resources a managed \\napplication or library uses or runs, isn\\u2019t supported on .N\", \"ET. \\nUse security boundaries that are provided by the operating system, such as virtualization, cont\", \"ainers, \\nor user accounts, for running processes with the minimum set of privileges. \\nSecurity Trans\", \"parency \\nSimilar to CAS, Security Transparency separates sandboxed code from security critical code \", \"in a \\ndeclarative fashion but is no longer supported as a security boundary. \\nUse security boundarie\", \"s that are provided by the operating system, such as virtualization, containers, \\nor user accounts, \", \"for running processes with the least set of privileges. \\n \\n23 \\nCHAPTER 4 | Windows 10 migration \\n \\nC\", \"HAPTER 4 \\nWindows 10 migration \\nConsider the following situation: You have a working desktop applica\", \"tion that was developed in the \\nWindows 7 days. It\\u2019s using WPF technology available at that time and\", \" working fine but it has an \\noutdated UI and behaviors when you run it on Windows 10 or Windows 11. \", \"It is like when you watch a \\nfuturistic movie like Matrix and you see Neo using the Nokia 8110 devic\", \"e. The film works great after \\n20 years but it would rather benefit from a device modernization. \\nWi\", \"th the release of Windows 10, Microsoft introduced many innovations to support scenarios like \\ntable\", \"ts and touch devices and to provide the best experience for users for a Microsoft operating \\nsystem \", \"ever. For example, you can: \\n\\u2022 \\nSign in with your face using Windows Hello. \\n\\u2022 \\nUse a pen to draw or\", \" handwrite text that is automatically recognized and digitalized. \\n\\u2022 \\nRun locally customized AI mode\", \"ls built on the cloud using WinML. \\nAll these features are enabled for Windows developers through Wi\", \"ndows Runtime (WinRT) libraries. \\nYou can take advantage of these features in your existing desktop \", \"apps because the libraries are \\nexposed to both the .NET Framework and .NET as well. You can even mo\", \"dernize your UI with the use \\nof XAML Islands and improve the visuals and behavior of your apps acco\", \"rding to the times. \\nOne important thing to note here is that you don\\u2019t need to abandon .NET Framewo\", \"rk technology to \\nfollow this modernization path. You can safely stay on there and have all the bene\", \"fits of Windows 10 \\nand Windows 11 without the pressure to migrate to .NET. So, you get both the pow\", \"er and the \\nflexibility to choose your modernization path. \\nWinRT APIs \\nWinRT APIs are object-orient\", \"ed, well-structured application programming interfaces (APIs) that give \\nWindows 10 and Windows 11 d\", \"evelopers access to everything the operating system has to offer. \\nThrough WinRT APIs, you can integ\", \"rate functionalities like Push Notifications, Device APIs, Microsoft \\nInk, and WinML, among others o\", \"n your desktop apps. \\nIn general, WinRT APIs can be called from a classic desktop app. However, two \", \"main areas present an \\nexception to this rule: \\n\\u2022 \\nAPIs that require a package identity. \\n\\u2022 \\nAPIs th\", \"at require visualization like XAML or Composition. \\n \\n24 \\nCHAPTER 4 | Windows 10 migration \\n \\nUniver\", \"sal Windows Platform (UWP) packages \\nApplication Package Identity \\nUWP apps have a deployment system\", \" where the OS manages the installation and uninstallation of \\napplication. That requires the install\", \"ation to be declarative, meaning that no user code is executed \\nduring install. Instead, everything \", \"the app wants to integrate with the system, such as protocols, file \\ntypes, and extensions, is decla\", \"red in the application manifest. At deployment time, the deployment \\npipeline configures those integ\", \"ration points. The only way for the OS to manage all this functionality \\nand keep track of it is for\", \" each \\u2018package\\u2019 to have an identity, a unique identifier for the application. \\nSome WinRT APIs requi\", \"re this package identity to work as expected. However, classic desktop apps \\nlike native C++ or .NET\", \" apps, use different deployment systems that don\\u2019t require a package identity. \\nIf you want to use t\", \"hese WinRT APIs in your desktop application, you need to provide them a package \\nidentity. \\nOne way \", \"to proceed is to build an additional packaging project. Inside the packaging project, you \\npoint to \", \"the original source code project and specify the Identity information you want to provide. If \\nyou i\", \"nstall the package and run the installed app, it will automatically get an identify enabling your \\nc\", \"ode to call all WinRT APIs requiring Identity. \\n<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> \\n<Package xml\", \"ns=\\\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\\\" \\n         xmlns:uap=\\\"http://sch\", \"emas.microsoft.com/appx/manifest/uap/windows10\\\"> \\n    <Identity Name=\\\"YOUR-APP-GUID \\\" \\n             \", \" Publisher=\\\"CN=YOUR COMPANY\\\" \\n              Version=\\\"1.x.x.x\\\" /> \\n</Package> \\nYou can check which AP\", \"Is need a packaged application identity by inspecting if the type that contains \\nthe API is marked w\", \"ith the DualApiPartition attribute. If it is, you can call if from an unpackaged \\ntraditional deskto\", \"p app. Otherwise, you must convert your classic desktop app to a UWP with the help \\nof a packaging p\", \"roject. \\nhttps://learn.microsoft.com/windows/desktop/apiindex/uwp-apis-callable-from-a-classic-deskt\", \"op-app \\nBenefits of packaging \\nBesides giving you access to these APIs, you get some additional bene\", \"fits by creating a Windows App \\npackage for your desktop application including: \\n\\u2022 \\nStreamlined depl\", \"oyment. Apps have a great deployment experience ensuring that users can \\nconfidently install an appl\", \"ication and update it. If a user chooses to uninstall the app, it\\u2019s \\nremoved completely with no trac\", \"e left behind preventing the Windows rot problem. \\n\\u2022 \\nAutomatic updates and licensing. Your applicat\", \"ion can participate in the Microsoft Store\\u2019s \\nbuilt-in licensing and automatic update facilities. Au\", \"tomatic update is a highly reliable and \\nefficient mechanism, because only the changed parts of file\", \"s are downloaded. \\n \\n25 \\nCHAPTER 4 | Windows 10 migration \\n \\n\\u2022 \\nIncreased reach and simplified monet\", \"ization. Maybe not your case but if you choose to \\ndistribute your application through the Microsoft\", \" Store you reach millions of Windows 10 and \\nWindows 11 users. \\n\\u2022 \\nAdd UWP features. You can add UWP\", \" features to your app\\u2019s package at your own pace. \\nPrepare for packaging \\nBefore proceeding to packa\", \"ge your desktop application, there are some points you have to address \\nbefore starting the process.\", \" Your application must respect any of the Microsoft Store rules and \\npolicies and run in the UWP app\", \"lication model. For example, it has to run on the .NET Framework 4.6.2 \\nor later and writes to the H\", \"KEY_CURRENT_USER registry hive and the AppData folders will be \\nvirtualized to a user-specific app-l\", \"ocal location. \\nThe design goal for packaging is to separate the application state from system state\", \" while maintaining \\ncompatibility with other apps. Windows 10 and Windows 11 accomplish this goal by\", \" placing the \\napplication inside a UWP package. It detects and redirects some changes to the file sy\", \"stem and \\nregistry at run time to fulfill the promise of a trusted and clean install and uninstall b\", \"ehavior of an \\napplication provided by packaging. \\nPackages that you create for your desktop applica\", \"tion are desktop-only, full-trust applications that \\naren\\u2019t sandboxed, although there\\u2019s lightweight \", \"virtualization applied to the app for writes to HKCU \\nand AppData. This virtualization allows them t\", \"o interact with other apps the same way classic desktop \\napplications do. \\nInstallation \\nApp package\", \"s are installed under %ProgramFiles%\\\\WindowsApps\\\\package_name, with the executable \\ntitled app_name.\", \"exe. Each package folder contains a manifest (named AppxManifest.xml) that contains \\na special XML n\", \"amespace for packaged apps. Inside that manifest file is an <EntryPoint> element, \\nwhich references \", \"the full-trust app. When that application is launched, it doesn\\u2019t run inside an app \\ncontainer, but \", \"instead it runs as the user as it normally would. \\nAfter deployment, package files are marked read-o\", \"nly and heavily locked down by the operating \\nsystem. Windows prevents apps from launching if these \", \"files are tampered with. \\nFile system \\nThe OS supports different levels of file system operations fo\", \"r packaged desktop applications, \\ndepending on the folder location. \\nWhen trying to access the user\\u2019\", \"s AppData folder, the system creates a private per-user, per-app \\nlocation behind the scenes. This c\", \"reates the illusion that the packaged application is editing the real \\nAppData when it\\u2019s actually mo\", \"difying a private copy. By redirecting writes this way, the system can \\ntrack all file modifications\", \" made by the app. It can then clean all those files when uninstalling reducing \\nsystem \\u201crot\\u201d and pro\", \"viding a better application removal experience for the user. \\n \\n26 \\nCHAPTER 4 | Windows 10 migration\", \" \\n \\nRegistry \\nApp packages contain a registry.dat file, which serves as the logical equivalent of HK\", \"LM\\\\Software in \\nthe real registry. At run time, this virtual registry merges the contents of this hi\", \"ve into the native \\nsystem hive to provide a singular view of both. \\nAll writes are kept during pack\", \"age upgrade and only deleted when the application is uninstalled. \\nUninstallation \\nWhen the user uni\", \"nstalls a package, all files and folders located under C:\\\\Program \\nFiles\\\\WindowsApps\\\\package_name ar\", \"e removed, as well as any redirected writes to AppData or the \\nregistry that were captured during th\", \"e process. \\nFor details about how a packaged application handles installation, file access, registry\", \", and \\nuninstallation, see https://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-th\", \"e-\\nscenes. \\nYou can get a complete list of things to check on \\nhttps://learn.microsoft.com/windows/m\", \"six/desktop/desktop-to-uwp-prepare. \\nHow to add WinRT APIs to your desktop project \\nIn this section,\", \" you can find a walkthrough on how to integrate Toast Notifications in an existing WPF \\napplication.\", \" Although it\\u2019s simple from the code perspective, it helps illustrate the whole process. \\nNotificatio\", \"ns are one of the many available WinRT APIs available that you can use in .NET app. In this \\ncase, t\", \"he API requires a Package Identity. This process is more straightforward if the APIs don\\u2019t require \\n\", \"Package Identity. \\nLet\\u2019s take an existing WPF sample app that reads files and shows its contents on \", \"the screen. The goal \\nis to display a Toast Notification when the application starts. \\n \\n27 \\nCHAPTER\", \" 4 | Windows 10 migration \\n \\n \\nFirst, you should check in the following link whether the Windows 10 \", \"or Windows 11 API that you\\u2019ll \\nuse requires a Package Identity: \\nhttps://learn.microsoft.com/windows\", \"/apps/desktop/modernize/desktop-to-uwp-supported-api \\nOur sample will use the Windows.UI.Notificatio\", \"ns.Notification API that requires a packaged identity: \\n \\nTo access the WinRT API, add a reference t\", \"o the Microsoft.Windows.SDK.Contracts NuGet package \\nand this package will do the magic behind the s\", \"cenes (see details at \\nhttps://blogs.windows.com/windowsdeveloper/2019/04/30/calling-windows-10-apis\", \"-from-a-desktop-\\napplication-just-got-easier/). \\nYou\\u2019re now prepared to start adding some code. \\n \\n2\", \"8 \\nCHAPTER 4 | Windows 10 migration \\n \\nCreate a ShowToastNotification method that will be called on \", \"application startup. It just builds a toast \\nnotification from an XML pattern: \\nprivate void ShowNot\", \"ification(string title, string content, string image) \\n{ \\n    string xmlString = $@\\\"<toast><visual><\", \"binding template = \\n'ToastGeneric'><text>{title}</text><text>{content}</text><image \\nsrc=>'{image}'<\", \"/image></binding></visual></toast>\\\"; \\n    XmlDocument toastXml = new XmlDocument(); \\n    toastXml.Lo\", \"adXml(xmlString); \\n    ToastNotification toast = new ToastNotification(toastXml); \\n    ToastNotifica\", \"tionManager.CreateToastNotifier().Show(toast); \\n} \\nAlthough the project builds, there are errors bec\", \"ause the Notifications API requires a Package Identity \\nand you didn\\u2019t provide it. Adding a Windows \", \"Packaging Project to the solution will fix the issue: \\n \\nSelect the minimum Windows version you want\", \" to support and the version you\\u2019re targeting. Not all \\nthe WinRT APIs are supported in all Windows 1\", \"0 and Windows 11 versions. Each Windows 10 or \\nWindows 11 update adds new APIs that are only availab\", \"le from this version; down-level support isn\\u2019t \\navailable. \\n \\n29 \\nCHAPTER 4 | Windows 10 migration \\n\", \" \\n \\nNext step is to add the WPF application to the Windows Packaging Project by adding a project \\nre\", \"ference: \\n \\n30 \\nCHAPTER 4 | Windows 10 migration \\n \\n \\n \\nA Windows Packaging Project can package seve\", \"ral apps so you should set which one is the Entry \\nPoint: \\n \\n31 \\nCHAPTER 4 | Windows 10 migration \\n \", \"\\n \\nNext step is to set the WPF Project as the startup Project in the solution configuration. You can\", \" press \\nF5 to compile and build and see the results. \\n \\nLet\\u2019s generate the package so you can instal\", \"l your app. Right click on Store > Create App Packages. \\n \\n32 \\nCHAPTER 4 | Windows 10 migration \\n \\n \", \"\\nSelect the sideloading option to deploy the app from your machine: \\n \\n33 \\nCHAPTER 4 | Windows 10 mi\", \"gration \\n \\n \\nSelect the application architecture of your app: \\n \\n34 \\nCHAPTER 4 | Windows 10 migratio\", \"n \\n \\n \\nFinally, create the package by clicking on Create. \\nXAML Islands \\nXAML Islands are a set of c\", \"omponents that enable Windows desktop developers to use UWP XAML \\ncontrols on their existing Win32 a\", \"pplications, including Windows Forms and WPF. \\n \\n35 \\nCHAPTER 4 | Windows 10 migration \\n \\n \\nYou can i\", \"mage your Win32 app with your standard controls and among them an \\u201cisland\\u201d of UWP UI \\ncontaining con\", \"trols from the modern world. The concept is similar to having an iFrame inside a web \\npage that show\", \"s content from a different page. \\nBesides adding functionality from the Windows 10 and Windows 11 AP\", \"Is, you can add pieces of UWP \\nXAML inside of your app using XAML Islands. \\nWindows 10 1903 update i\", \"ntroduced a set of APIs that allow hosting UWP XAML content in Win32 \\nwindows. Only apps running on \", \"Windows 10 1903 or later can use XAML Islands. \\nThe road to XAML Islands \\nThe road to XAML Islands s\", \"tarted in 2012 when Microsoft introduced the WinRT APIs as a framework \\nto modernize the Win32 apps \", \"(Windows Forms, WPF, and native Win32 apps). However, the new UI \\ncontrols inside WinRT were availab\", \"le for new applications but not for existing ones. \\nIn 2015, along with Windows 10, UWP was born. UW\", \"P allows you to create apps that work across \\nWindows devices like XBox, Mobile, and Desktop. One ye\", \"ar later, Microsoft announced Desktop \\nBridge (formerly known as Project Centennial). Desktop Bridge\", \" is a set of tools that allowed \\ndevelopers to bring their existing Win32 apps to the Microsoft Stor\", \"e. More capabilities were added in \\n2017, allowing developers to enhance their Win32 apps leveraging\", \" some of the new Windows 10 APIs, \\nlike live tiles and notifications on the action center. But still\", \", no new UI controls. \\nAt Build 2018, Microsoft announced a way for developers to use the new Window\", \"s 10 XAML controls \\ninto their current Win32 apps, without fully migrating their apps to UWP. It was\", \" branded as UWP \\nXAML Islands. \\nHow it works \\nThe Windows 10 1903 update introduced several XAML hos\", \"ting APIs. Two of them are \\nWindowsXamlManager and DesktopWindowXamlSource. \\n \\n36 \\nCHAPTER 4 | Windo\", \"ws 10 migration \\n \\nThe WindowsXamlManager class handles the UWP XAML Framework. Its InitializeForCur\", \"rentThread \\nmethod loads the UWP XAML Framework inside the current thread of the Win32 app. \\nThe Des\", \"ktopWindowXamlSource is the instance of your XAML Island content. It has the Content \\nproperty, whic\", \"h you\\u2019re responsible for instantiating and setting. The DesktopWindowXamlSource \\nrenders and gets it\", \"s input from an HWND. It needs to know to which other HWND it will attach the \\nXAML Island\\u2019s one, an\", \"d you\\u2019re responsible for sizing and positioning the parent\\u2019s HWND. \\nWPF or Windows Forms developers \", \"don\\u2019t usually deal with HWND inside their code, so it may be hard \\nto understand and handle HWND poi\", \"nters and the underlying wiring stuff to communicate Win32 and \\nUWP worlds. \\nThe XAML Islands .NET W\", \"rappers \\nThe Windows Community Toolkit has a set the XAML Islands .NET wrappers for WPF or Windows \\n\", \"Forms that make easier to use XAML Islands. These wrappers manage the HWNDs, the focus \\nmanagement, \", \"among other things. Windows Forms and WPF developers should use these wrappers. \\nThe Windows Communi\", \"ty Toolkit offers two types of controls: Wrapped Controls and Hosting \\nControls. \\nWrapped Controls \\n\", \"These wrapped controls wrap some UWP controls into Windows Forms or WPF controls, hiding UWP \\nconcep\", \"ts for those developers. These controls are: \\n\\u2022 \\nWebView and WebViewCompatible \\n\\u2022 \\nInkCanvas and Ink\", \"Toolbar \\n\\u2022 \\nMediaPlayerElement \\n\\u2022 \\nMapControl \\nAdd the Microsoft.Toolkit.Wpf.UI.Controls package to \", \"your project, include the reference to the \\nnamespace, and start using them. \\n<Window \\n        ... \\n\", \"        xmlns:uwpControls=\\\"clr-\\nnamespace:Microsoft.Toolkit.Wpf.UI.Controls;assembly=Microsoft.Toolk\", \"it.Wpf.UI.Controls\\\"> \\n<Grid> \\n    <Grid.RowDefinitions> \\n        <RowDefinition Height=\\\"Auto\\\"/> \\n   \", \"     <RowDefinition Height=\\\"\\\\*\\\"/> \\n    </Grid.RowDefinitions> \\n    <uwpControls:InkToolbar TargetInk\", \"Canvas=\\\"{x:Reference Name=inkCanvas}\\\"/> \\n    <uwpControls:InkCanvas Grid.Row=\\\"1\\\" x:Name=\\\"inkCanvas\\\" \", \"/> \\n</Grid> \\nHosting controls \\nThe power of XAML Islands extends to most first-party controls, third\", \"-party controls, and custom \\ncontrols developed for UWP, which can be integrated into Windows Forms \", \"and WPF as \\u201cIslands\\u201d with \\nfully functional UI. The WindowsXamlHost control for WPF and Windows Form\", \"s allows doing this. \\n \\n37 \\nCHAPTER 4 | Windows 10 migration \\n \\nFor example, to use the WindowsXamlH\", \"ost control in WPF, add a reference to the \\nMicrosoft.Toolkit.Wpf.UI.XamlHost package provided by th\", \"e Windows Community Toolkit. \\nOnce you\\u2019ve placed your WindowsXamlHost into your UI code, specify whi\", \"ch UWP type you want to \\nload. You can choose to use a wrapped control like a Button or a more compl\", \"ex one composed of \\nseveral different controls, which are a custom UWP control. \\nThe following examp\", \"le shows how to add a UWP Button: \\n<Window \\n        ... \\n        xmlns:xamlhost=\\\"clr-\\nnamespace:Micr\", \"osoft.Toolkit.Wpf.UI.XamlHost;assembly=Microsoft.Toolkit.Wpf.UI.XamlHost\\\"> \\n \\n<xamlhost:WindowsXamlH\", \"ost x:Name=\\\"myUwpButton\\\" \\n                          InitialTypeName=\\\"Windows.UI.Xaml.Controls.Button\", \"\\\" /> \\nThere\\u2019s a clear recommendation on how to approach this and it\\u2019s better to have one single and \", \"bigger \\nXAML Island containing a custom composite control than to have several islands with one cont\", \"rol on \\neach. \\nOne of the core features of XAML is binding and it works between your Win32 code and \", \"the island. \\nSo, you can bind, for instance, a Win32 Textbox with a UWP Textbox. One important thing\", \" to consider \\nis that these bindings are one-way bindings, from UWP to Win32, so if you update the T\", \"extbox inside \\nthe XAML Island the Win32 Textbox will be updated, but not the other way around. \\nTo \", \"see a walkthrough about how to use XAML Islands, see: \\nhttps://learn.microsoft.com/windows/apps/desk\", \"top/modernize/host-standard-control-with-xaml-\\nislands \\nAdding UWP XAML custom controls \\nA XAML cust\", \"om control is a control (or user control) created by you or by third parties (including \\nWinUI 2.x c\", \"ontrols). To host a custom UWP control in a Windows Forms or WPF app, you\\u2019ll need: \\n\\u2022 \\nTo use the Wi\", \"ndowsXamlHost UWP control in your .NET app. \\n\\u2022 \\nTo create a UWP app project that defines a XamlAppli\", \"cation object. \\nYour WPF or Windows Forms project must have access to an instance of the \\nMicrosoft.\", \"Toolkit.Win32.UI.XamlHost.XamlApplication class provided by the Windows Community \\nToolkit. This obj\", \"ect acts as a root metadata provider for loading metadata for custom UWP XAML \\ntypes in assemblies i\", \"n the current directory of your application. The recommended way to do this is to \\nadd a Blank App (\", \"Universal Windows) project to the same solution as your WPF or Windows Forms \\nproject and revise the\", \" default App class in this project. \\nThe custom UWP XAML control can be included on this UWP app or \", \"in an independent UWP Class \\nLibrary project that you reference in the same solution as your WPF or \", \"Windows Forms project. \\nYou can check a detailed step-by-step process description at: \\nhttps://learn\", \".microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-\\nislands \\n \\n38 \\nCHAPTER \", \"4 | Windows 10 migration \\n \\nThe Windows UI Library (WinUI 2) \\nBesides the inbox Windows 10 controls \", \"that comes with the OS, the same UWP XAML team also \\ndelivers additional controls in the Windows UI \", \"Library (WinUI 2). WinUI 2 provides official native \\nMicrosoft UI controls and features for Windows \", \"UWP apps and these controls can be used inside of \\nXAML Islands. \\nWinUI 2 is open source and you can\", \" find information at https://github.com/microsoft/microsoft-ui-\\nxaml. \\nThe following article demonst\", \"rates how to host a UWP XAML control from the WinUI 2 library: \\nhttps://learn.microsoft.com/windows/\", \"apps/desktop/modernize/host-custom-control-with-xaml-\\nislands \\nDo you need XAML Islands \\nXAML Island\", \"s are intended for existing Win32 apps that want to improve their user experience by \\nleveraging new\", \" UWP controls and behaviors without a full rewrite of the app. You could already \\nleverage Windows 1\", \"0 and Windows 11 APIs, but up until XAML Islands, only non-UI related APIs. \\nIf you\\u2019re developing a \", \"new Windows App, a UWP App is probably the right approach. \\nThe road ahead XAML Islands: WinUI 3.0 \\n\", \"Since Windows 8, the Windows UI platform, including the XAML UI framework, visual composition \\nlayer\", \", and input processing has been shipped as an integral part of Windows. This means that to \\nbenefit \", \"from the latest improvements on UI technologies, you must upgrade to the latest version of \\nthe UI, \", \"slowing down the pace of innovation when you develop your apps. To decouple these two \\nevolution cyc\", \"les and foster innovation, Microsoft is actively working on the WinUI project. \\nStarting with WinUI \", \"2 in 2018, Microsoft started shipping some new XAML UI controls and features as \\nseparate NuGet pack\", \"ages that build on top of the UWP SDK. \\n \\n39 \\nCHAPTER 4 | Windows 10 migration \\n \\n \\nWinUI 3 is under\", \" active development and will greatly expand the scope of WinUI to include the full UI \\nplatform, whi\", \"ch will be fully decoupled from the UWP SDK: \\n \\nXAML framework will now be developed on GitHub and s\", \"hipped out of band as NuGet packages. \\nThe existing UWP XAML APIs that ship as part of the OS will n\", \"o longer receive new feature updates. \\nThey will still receive security updates and critical fixes a\", \"ccording to the Windows 10 support lifecycle. \\nThe Universal Windows Platform contains more than jus\", \"t the XAML framework (for example, \\napplication and security model, media pipeline, Xbox and Windows\", \" 10 shell integrations, broad device \\nsupport) and will continue to evolve. All new XAML features wi\", \"ll just be developed and ship as part of \\nWinUI instead. \\nWinUI 3 in desktop app and WinUI XAML Isla\", \"nds \\nAs you can see, WinUI 3 is the evolution of UWP XAML and it works naturally within the UWP app \", \"\\nmodel and all its requirements (MSIX packaged ID, sandbox, CoreWindow, and so on. To use just \\nWinU\", \"I 3 in a Win32 app model, the WinUI content should be hosted by another UI Framework \\n(Windows Forms\", \", WPF, and so on) using WinUI XAML Islands. This is the right path if you want to \\n \\n40 \\nCHAPTER 4 |\", \" Windows 10 migration \\n \\nevolve your app and mix technologies. However, if you want to replace your \", \"entire old UI for WinUI, \\nyour app shouldn\\u2019t load UI Frameworks for just hosting WinUI. \\nWinUI 3 wil\", \"l address this critical feedback adding WinUI in desktop apps. This will allow that Win32 \\napps can \", \"use WinUI 3 as standalone UI Framework; no need to load Windows Forms or WPF. \\nWithin this aggregati\", \"on, WinUI 3 will let developers easily mix and match the right combination of: \\n\\u2022 \\nApp model: UWP, W\", \"in32 \\n\\u2022 \\nPlatform: .NET or Native \\n\\u2022 \\nLanguage: .NET (C#, Visual Basic), standard C++ \\n\\u2022 \\nPackaging:\", \" MSIX, AppX for the Microsoft Store, unpackaged \\n\\u2022 \\nInterop: use WinUI 3 to extend existing WPF, Win\", \"Forms, and MFC apps using WinUI XAML \\nIslands. \\nIf you want to know more details, Microsoft is shari\", \"ng this roadmap in \\nhttps://github.com/microsoft/microsoft-ui-xaml/blob/main/docs/roadmap.md. \\n \\n41 \", \"\\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\nCHAPTER 5 \\nExample of migrating to \\nthe late\", \"st .NET \\nIn this chapter, we\\u2019ll show how to migrate your applications to the latest version of .NET.\", \" You can \\nmigrate to .NET 7 from .NET Framework, .NET Core, or .NET 5. We\\u2019ll introduce a tool that c\", \"an do all the \\nwork for you in most cases. If your application has special cases or complicated depe\", \"ndencies, we\\u2019ll \\nalso show how to do the whole migration process by hand. Additionally, we\\u2019ll cover \", \"the most common \\nissues and challenges you can face when migrating an existing application from .NET\", \" Framework to \\n.NET. \\nMigrating from .NET Core or .NET 5 \\nUpdating your applications to target the l\", \"atest version of .NET is easy if you already are on .NET Core \\nor .NET 5. If this is the case, then \", \"in Visual Studio, simply right-click on your project in Solution \\nExplorer and choose Properties. Un\", \"der Application > General > Target framework, choose .NET \\n7.0. Save and rebuild your application. Y\", \"ou\\u2019re done! Your app now runs on the latest version of .NET. \\nIn the future when new versions become\", \" available, you can upgrade in the same way. \\n \\n42 \\nCHAPTER 5 | Example of migrating to the latest .\", \"NET \\n \\n \\nMigrating from .NET Framework \\nMigrating from .NET Framework is a more complicated process \", \"because there are more differences \\nbetween .NET Framework and other platforms that were built on to\", \"p of .NET Core. But the good news \\nis that there\\u2019s a tool that will do all the work for you in most \", \"cases. \\nMigrating with a tool \\nThe Upgrade Assistant is a migration tool. Using it is easy and there\", \" are step-by-step instructions \\navailable on the .NET website. In this chapter, we\\u2019ll look at what i\", \"s happening behind the scenes and \\nhow to port your application by hand. When the Upgrade Assistant \", \"is unable to migrate your \\napplication, you\\u2019ll learn the underlying mechanics so that you might be a\", \"ble to migrate manually. \\nMigrating by hand \\nThe migration process consists of four sequential steps\", \": \\n1. \\nPreparation: Understand the dependencies the project has to have an idea of what\\u2019s ahead. \\nIn\", \" this step, you take the current project into a state that simplifies the startup point for the \\nmig\", \"ration. \\n2. \\nMigrate Project File: .NET projects use the new SDK-style project format. Create a new \", \"\\nproject file with this format or update the one you have to use the SDK style. \\n3. \\nFix code and bu\", \"ild: Build the code in .NET addressing API-level differences between .NET \\nFramework and .NET. If ne\", \"eded, update third-party packages to the ones that support .NET. \\n \\n43 \\nCHAPTER 5 | Example of migra\", \"ting to the latest .NET \\n \\n4. \\nRun and test: There might be differences that don\\u2019t show up until run\", \" time. So, don\\u2019t forget \\nto run the application and test that everything works as expected. \\nPrepara\", \"tion \\nMigrate packages.config file \\nIn a .NET Framework application, all references to external pack\", \"ages are declared in the \\npackages.config file. In .NET, there\\u2019s no longer the need to use the packa\", \"ges.config file. Instead, use the \\nPackageReference property inside the project file to specify the \", \"NuGet packages for your app. \\nSo, you need to transition from one format to another. You can do the \", \"update manually, taking the \\ndependencies contained in the packages.config file and migrating them t\", \"o the project file with the \\nPackageReference format. Or, you can let Visual Studio do the work for \", \"you: right-click on the \\npackages.config file and select the Migrate packages.config to PackageRefer\", \"ence option. \\nVerify every dependency compatibility in .NET \\nOnce you\\u2019ve migrated the package refere\", \"nces, you must check each reference for compatibility. You \\ncan explore the dependencies of each NuG\", \"et package your application is using on nuget.org. If the \\npackage has .NET Standard dependencies, t\", \"hen it\\u2019s going to work on .NET 7 because .NET supports all \\nversions of .NET Standard. The following\", \" image shows the dependencies for the Castle.Windsor \\npackage: \\n \\nTo check the package compatibility\", \", you can use the tool https://fuget.org that offers a more detailed \\ninformation about versions and\", \" dependencies. \\nMaybe the project is referencing older package versions that don\\u2019t support .NET, but\", \" you might find \\nnewer versions that do support it. So, updating packages to newer versions is gener\", \"ally a good \\n \\n44 \\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\nrecommendation. However, y\", \"ou should consider that updating the package version can introduce \\nsome breaking changes that would\", \" force you to update your code. \\nWhat happens if you don\\u2019t find a compatible version? What if you ju\", \"st don\\u2019t want to update the \\nversion of a package because of these breaking changes? Don\\u2019t worry bec\", \"ause it\\u2019s possible to depend \\non .NET Framework packages from a .NET application. Don\\u2019t forget to te\", \"st it extensively because it can \\ncause run-time errors if the external package calls an API that is\", \"n\\u2019t available on .NET. This is great for \\nwhen you\\u2019re using an old package that isn\\u2019t going to be up\", \"dated and you can just retarget to work on \\n.NET. \\nCheck for API compatibility \\nSince the API surfac\", \"e in .NET Framework and .NET is similar but not identical, you must check which \\nAPIs are available \", \"on .NET and which aren\\u2019t. You can use the .NET Portability Analyzer tool to surface \\nAPIs used that \", \"aren\\u2019t present on .NET. It looks at the binary level of your app, extracts all the APIs that \\nare ca\", \"lled, and then lists which APIs aren\\u2019t available on your target framework (.NET 7 in this case). \\nYo\", \"u can find more information about this tool at: \\nhttps://learn.microsoft.com/dotnet/standard/analyze\", \"rs/portability-analyzer \\nAn interesting aspect of this tool is that it only surfaces the differences\", \" from your own code and not \\ncode from external packages, which you can\\u2019t change. Remember you shoul\", \"d have updated most of \\nthese packages to make them work with .NET. \\nMigrate \\n1. \\nCreate the new .NE\", \"T project \\nIn most cases, you\\u2019ll want to update your existing project to the new .NET format. Howeve\", \"r, you can \\nalso create a new project while maintaining the old one. The main drawback from updating\", \" the old \\nproject is that you lose designer support, which may be important to you and your developm\", \"ent \\nteam. If you want to keep using the designer, you must create a new .NET project in parallel wi\", \"th the \\nold one and share assets. If you need to modify UI elements in the designer, you can switch \", \"to the old \\nproject to do that. And since assets are linked, they\\u2019ll be updated in the .NET project \", \"as well. \\nThe SDK-style project for .NET is a lot simpler than .NET Framework\\u2019s project format. Apar\", \"t from the \\npreviously mentioned PackageReference entries, you won\\u2019t need to do much more. The new p\", \"roject \\nformat includes files with certain extensions by default, such as .cs and .xaml files, witho\", \"ut the need to \\nexplicitly include them in the project file. \\nAssemblyInfo considerations \\nAttribute\", \"s are autogenerated on .NET projects. If the project contains an AssemblyInfo.cs file, the \\ndefiniti\", \"ons will be duplicated, which will cause compilation conflicts. You can delete the older \\nAssemblyIn\", \"fo.cs file or disable autogeneration by adding the following entry to the .NET project file: \\n<Proje\", \"ct Sdk=\\\"Microsoft.NET.Sdk\\\"> \\n  <PropertyGroup> \\n    <GenerateAssemblyInfo>false</GenerateAssemblyInf\", \"o> \\n \\n45 \\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\n  </PropertyGroup> \\n</Project> \\nRes\", \"ources \\nEmbedded resources are included automatically but resources aren\\u2019t, so you need to migrate t\", \"he \\nresources to the new project file. \\nPackage references \\nWith the Migrate packages.config to Pack\", \"ageReference option, you can easily move your external \\npackage references to the new format as prev\", \"iously mentioned. \\nUpdate package references \\nUpdate the versions of the packages you\\u2019ve found to be\", \" compatible, as shown in the previous section. \\nFix the code and build \\nMicrosoft.Windows.Compatibil\", \"ity \\nIf your application depends on APIs that aren\\u2019t available on .NET, such as Registry or ACLs, yo\", \"u have \\nto include a reference to the Microsoft.Windows.Compatibility package to add these Windows-\\n\", \"specific APIs. They work on .NET but aren\\u2019t included as they aren\\u2019t cross-platform. \\nThere\\u2019s a tool \", \"called Platform compatibility analyzer \\n(https://learn.microsoft.com/dotnet/standard/analyzers/platf\", \"orm-compat-analyzer) that helps you \\nidentify APIs that aren\\u2019t compatible with your code. \\nUse #if d\", \"irectives \\nIf you need different execution paths when targeting .NET Framework and .NET, you should \", \"use \\ncompilation constants. Add some #if directives to your code to keep the same codebase for both \", \"\\ntargets. \\nTechnologies not available on .NET \\nSome technologies aren\\u2019t available on .NET, such as: \", \"\\n\\u2022 \\nAppDomains \\n\\u2022 \\nRemoting \\n\\u2022 \\nCode Access Security \\n\\u2022 \\nWindows Workflow \\nThat\\u2019s why you need to fi\", \"nd a replacement for these technologies if you\\u2019re using them in your \\napplication. For more informat\", \"ion, see the .NET Framework technologies unavailable on .NET Core and \\n.NET 5+ article. \\n \\n46 \\nCHAPT\", \"ER 5 | Example of migrating to the latest .NET \\n \\nRegenerate autogenerated clients \\nIf your applicat\", \"ion uses autogenerated code, such as a WCF client, you may need to regenerate this \\ncode to target .\", \"NET. Sometimes, you can find some missing references since they may not be included \\nas part of the \", \"default .NET assemblies set. Using a tool like https://apisof.net/, you can easily locate \\nthe assem\", \"bly the missing reference lives in and add it from NuGet. \\nRolling back package versions \\nAs a gener\", \"al rule, we\\u2019ve previously stated that you better update every single package version to be \\ncompatib\", \"le with .NET. However, you can find that targeting an updated and compatible version of an \\nassembly\", \" just doesn\\u2019t pay off. If the cost of change isn\\u2019t acceptable, you can consider rolling back \\npackag\", \"e versions keeping the ones you use on .NET Framework. Although they may not be targeting \\n.NET, the\", \"y should work well unless they call some unsupported APIs. \\nRun and test \\nOnce you have your applica\", \"tion building with no errors, you can start the last step of the migration by \\ntesting every functio\", \"nality. \\nIn this final step, you can find several different issues depending on the complexity of yo\", \"ur application \\nand the dependencies and APIs you\\u2019re using. \\nFor example, if you use configuration f\", \"iles (app.config), you may find some errors at run time like \\nConfiguration Sections not present. Us\", \"ing the Microsoft.Extensions.Configuration NuGet package \\nshould fix that error. \\nAnother reason for\", \" errors is the use of the BeginInvoke and EndInvoke methods because they aren\\u2019t \\nsupported on .NET. \", \"They aren\\u2019t supported on .NET because they have a dependency on Remoting, \\nwhich doesn\\u2019t exist on .N\", \"ET. To solve this issue, try to use the await keyword (when available) or the \\nTask.Run method. \\nYou\", \" can use compatibility analyzers to let you identify APIs and code patterns in your code that can \\np\", \"otentially cause problems at run time with .NET. Go to https://github.com/dotnet/platform-compat \\nan\", \"d use the .NET API analyzer on your project. \\nMigrating a Windows Forms application \\nTo showcase a c\", \"omplete migration process of a Windows Forms application, we\\u2019ve chosen to migrate \\nthe eShop sample \", \"application available at https://github.com/dotnet-\\narchitecture/eShopModernizing/tree/master/eShopL\", \"egacyNTier/src/eShopWinForms. You can find \\nthe complete result of the migration at https://github.c\", \"om/dotnet-\\narchitecture/eShopModernizing/tree/master/eShopModernizedNTier/src/eShopWinForms. \\nThis a\", \"pplication shows a product catalog and allows the user to navigate, filter, and search for \\nproducts\", \". From an architecture point of view, the app relies on an external WCF service that serves as \\na fa\", \"\\u00e7ade to a back-end database. \\nYou can see the main application window in the following picture: \\n \\n4\", \"7 \\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\n \\nIf you open the .csproj project file, yo\", \"u can see something like this: \\n \\nAs previously mentioned, a .NET project has a more compact style a\", \"nd you need to migrate the \\nproject structure to the new .NET SDK style. \\nIn Solution Explorer, righ\", \"t-click on the Windows Forms project and select Unload Project > Edit. \\nNow you can update the .cspr\", \"oj file. You\\u2019ll delete the entire contents and replace it with the following \\ncode: \\n<Project Sdk=\\\"M\", \"icrosoft.NET.Sdk\\\"> \\n  <PropertyGroup> \\n    <OutputType>WinExe</OutputType> \\n    <TargetFramework>net\", \"7.0-windows</TargetFramework> \\n    <UseWindowsForms>true</UseWindowsForms> \\n    <GenerateAssemblyInf\", \"o>false</GenerateAssemblyInfo> \\n \\n48 \\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\n  </Pro\", \"pertyGroup> \\n</Project> \\nSave and reload the project. You\\u2019re now done updating the project file and \", \"the project is targeting \\n.NET 7. \\nIf you compile the project at this point, you\\u2019ll find some errors\", \" related to the WCF client reference. \\nSince this code is autogenerated, you must regenerate it to t\", \"arget .NET. \\n \\nDelete the Reference.cs file and generate a new Service Client. \\nRight-click on Conne\", \"cted Services and select the Add Connected Service option. \\n \\nThe Connected Services window opens. S\", \"elect the Microsoft WCF Web Service option. \\n \\n49 \\nCHAPTER 5 | Example of migrating to the latest .N\", \"ET \\n \\n \\nIf you have the WCF Service in the same solution as we have in this example, you can select \", \"the \\nDiscover option instead of specifying a service URL. \\n \\nOnce the service is located, the tool r\", \"eflects the API contract implemented by the service. Change the \\nname of the namespace to be eShopSe\", \"rviceReference as shown in the following image: \\n \\n50 \\nCHAPTER 5 | Example of migrating to the lates\", \"t .NET \\n \\n \\nSelect the Finish button. After a while, you\\u2019ll see the generated code. \\nYou should see \", \"three autogenerated files: \\n1. \\nGetting Started: a link to GitHub to provide some information on WCF\", \". \\n2. \\nConnectedService.json: configuration parameters to connect to the service. \\n3. \\nReference.cs:\", \" the actual WCF client code. \\n \\n51 \\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\n \\nIf you \", \"compile again, you\\u2019ll see many errors coming from .cs files inside the Helper folder. This folder \\nw\", \"as present in the .NET Framework version but not included in the old .csproj. But with the new SDK-\\n\", \"style project, every code file present underneath the project file location is included by default. \", \"That is, \\nthe new .NET Core project tries to compile the files inside the Helper folder. Since that \", \"folder isn\\u2019t \\nneeded, you can safely delete it. \\nIf you compile the project again and execute it, yo\", \"u won\\u2019t see the product images. The problem is that \\nnow the path to the files has slightly changed.\", \" To fix this issue, you need to add another level of depth \\nin the path, updating in the file Catalo\", \"gView.cs the line: \\n \\n52 \\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\nstring image_name =\", \" Environment.CurrentDirectory + \\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems.Picturefilenam\", \"e; \\nto \\nstring image_name = Environment.CurrentDirectory + \\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\", \"\\\" + catalogItems.Picturefilename; \\nAfter this change, you can check that the application launches an\", \"d runs as expected on .NET 7. \\nMigrating a WPF application \\nWe\\u2019ll use the Shop.ClassicWPF sample app\", \"lication to perform the migration. The following image \\nshows a screenshot of the app before migrati\", \"on: \\n \\nThis application uses a local SQL Server Express database to hold the product catalog informa\", \"tion. \\nThis database is accessed directly from the WPF application. \\nFirst, you must update the .csp\", \"roj file to the new SDK style used by .NET Core applications. You\\u2019ll \\nfollow the same steps describe\", \"d in the Windows Forms migration: you\\u2019ll unload the project, open the \\n.csproj file, update its cont\", \"ents, and reload the project. \\nIn this case, delete all the content of the .csproj file and replace \", \"it with the following code: \\n \\n53 \\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\n <Project \", \"Sdk=\\\"Microsoft.NET.Sdk\\\"> \\n  <PropertyGroup> \\n    <OutputType>WinExe</OutputType> \\n    <TargetFramewo\", \"rk>net7.0-windows</TargetFramework> \\n    <UseWpf>true</UseWpf> \\n    <GenerateAssemblyInfo>false</Gen\", \"erateAssemblyInfo> \\n  </PropertyGroup> \\n</Project> \\nIf you reload the project and compile it, you\\u2019ll\", \" get the following error: \\n \\nSince you\\u2019ve deleted all the .csproj contents, you\\u2019ve lost a project re\", \"ference specification present in the \\nold project. You just need to add this line to the .csproj fil\", \"e to include the project reference back: \\n<ItemGroup> \\n    <ProjectReference Include=\\\"..\\\\\\\\eShop.SqlP\", \"rovider\\\\\\\\eShop.SqlProvider.csproj\\\" /> \\n<ItemGroup> \\nYou can also let Visual Studio help you by right\", \"-clicking on the Dependencies node and selecting \\nAdd Project Reference. Select the project from the\", \" solution and select OK: \\n \\n54 \\nCHAPTER 5 | Example of migrating to the latest .NET \\n \\n \\nOnce you ad\", \"d the missing project reference, the application compiles and runs as expected on .NET. \\n \\n55 \\nCHAPT\", \"ER 6 | Deploying Modern Desktop Applications \\n \\nCHAPTER 6 \\nDeploying Modern \\nDesktop Applications \\nW\", \"hen you develop desktop applications, one thing to consider is how your application is going to be \\n\", \"packaged and deployed to the users\\u2019 machines. The problem with packaging, deployment, and \\ninstallat\", \"ion is that it usually falls under the umbrella of the IT professionals, who care about different \\nt\", \"hings than developers. \\nThese days, we\\u2019re all familiar with the DevOps concept, where developers and\", \" IT Pros work closely to \\nmove applications to their production environments. But if you\\u2019ve been in \", \"the desktop battle for more \\nthan 10 years, you might have seen the following story. A team of devel\", \"opers works together hard to \\nmeet the project deadlines. Business people are nervous since they nee\", \"d the system working on many \\nusers\\u2019 machines to run the company. On \\u201cD-Day\\u201d, the project manager ch\", \"ecks with every developer \\nthat their code is working well and that everything is fine, so they can \", \"ship. Then, the package team \\ncomes in generating the setup for the app, distribute it to every user\", \" machine and a set of test users \\nrun the application. Well, they try, because before showing any UI\", \", the application throws an \\nexception that says \\u201cMethod ~ of object ~ failed\\u201d. Panic starts flowing\", \" through the air and a brief \\ninvestigation points to a young and tired developer that has introduce\", \"d a third-party control, that \\ncertainly \\u201cworked on the dev machine\\u201d. \\nInstalling desktop applicatio\", \"ns have traditionally been a nightmare for two main reasons: \\n\\u2022 \\nLack of close collaboration culture\", \" between dev and IT teams. \\n\\u2022 \\nLack of a solid packaging and deploying technology we can build upon.\", \" \\nIn fact, we\\u2019ve been living with the fact that sometimes you regret that you installed an app becau\", \"se: \\n\\u2022 \\nIt ends up having some undesired side effects on your machine. \\n\\u2022 \\nSome applications that we\", \"re previously installed stop working. \\nAdditionally, you can\\u2019t just restore the system to its origin\", \"al state by uninstalling the app. We\\u2019re so \\nused to living with this situation that we\\u2019ve coined ter\", \"ms like \\u201cDLL Hell\\u201d or \\u201cWinrot\\u201d. \\nIn this chapter, we\\u2019ll talk about MSIX. MSIX is the new technology \", \"from Microsoft that tries to capture \\nthe best of previous technologies to provide a solid foundatio\", \"n for the packaging technology of the \\nfuture. \\nWhat does a packaging technology have to do with mod\", \"ernization? Well, it turns out that packaging \\nis fundamental for the enterprise IT with lots of mon\", \"ey invested there. Modernization isn\\u2019t only related \\n \\n56 \\nCHAPTER 6 | Deploying Modern Desktop Appl\", \"ications \\n \\nto using the latest technologies. It\\u2019s also related to reducing time to market from the \", \"moment a \\nbusiness requirement is defined until your company delivers the feature to your client. \\nT\", \"he modern application lifecycle \\nToday, developers write and build the code for an app and then pass\", \" the generated assets to the IT \\nPros. Then, the IT Pros reconfigure the app and repackage it, typic\", \"ally in an MSI or more recently in an \\nApp-V packaging format. The app is then deployed through diff\", \"erent channels and tools. One of the \\nmain problems with this approach is commonly known as \\u201cpackagi\", \"ng paralysis\\u201d. The problem is that \\nthis cycle repeats every time there\\u2019s an app update or an OS upd\", \"ate. \\nYou can see the process reflected on the following picture: \\n \\nCompanies need a way to break t\", \"his packaging cycle into three independent cycles: \\n\\u2022 \\nOS updates \\n\\u2022 \\nApplication updates \\n\\u2022 \\nCustom\", \"ization \\n \\n57 \\nCHAPTER 6 | Deploying Modern Desktop Applications \\n \\n \\nThe previous diagram shows tha\", \"t you can: \\n\\u2022 \\nUpdate the underlying OS without having to repackage your apps. \\n\\u2022 \\nEnable customizat\", \"ions from IT without the need to repackage the original developer package. \\nThis radical change lead\", \"s us to the new and modern IT lifecycle as shown in the following picture: \\n \\n58 \\nCHAPTER 6 | Deploy\", \"ing Modern Desktop Applications \\n \\n \\nDevelopers create the app and generate an MSIX package that IT \", \"Pros can consume and configure \\nwithout the need of repackaging. Along with the MSIX technology, Mic\", \"rosoft has created tools to \\nallow IT to customize and configure packages without repackaging. \\nMSIX\", \": The next generation of deployment \\nBefore MSIX, there were several packaging technologies availabl\", \"e like setup wizards, MSI, ClickOnce, \\nApp-V, and scripting. Each of these technologies has their ow\", \"n strengths and Microsoft has decided \\nto pick the best of all to build MSIX. MSIX is built on the f\", \"oundations of these existing technologies \\npicking the best of each: \\n\\u2022 \\nApp-V => Containerization \\n\", \"\\u2022 \\nClickOnce => Auto updating \\n\\u2022 \\nMSI => Easy to distribute \\nWith MSIX, you get one installer techno\", \"logy with all these features. \\n \\n59 \\nCHAPTER 6 | Deploying Modern Desktop Applications \\n \\n \\nBenefits\", \" of MSIX \\nNever regret installing an app \\nMSIX provides a predictable, reliable, and safe deployment\", \". The declarative method contained in the \\npackage manifest lets the OS keep track of every asset yo\", \"ur application needs. It also provides a true \\nclean uninstall with no side effects. \\nDisk space opt\", \"imization \\nMSIX is optimized to reduce the footprint that an application has on the user\\u2019s machine d\", \"isk space. It \\ncreates a single instance storage of your files. That is, if you have two different p\", \"ackages with the \\nsame DLL, the DLL isn\\u2019t installed twice. The platform takes care of that problem b\", \"ecause it knows all \\nthe files that a particular app installed thanks to its declarative nature. It \", \"also allows you to have \\ndifferent versions of a DLL working side by side. \\nWith the use of resource\", \" packages, you can easily create multilingual apps and the OS takes care of \\ninstalling the ones tha\", \"t are used. \\nNetwork optimization \\nMSIX detects the differences on the files at the byte block level\", \" enabling a feature called differential \\nupdates. What this means is that only the updated byte bloc\", \"ks are downloaded on application \\nupdates. \\n \\n60 \\nCHAPTER 6 | Deploying Modern Desktop Applications \", \"\\n \\n \\nWith streaming installation, the user can quickly start working on your application while other\", \" parts of \\nthe app are downloaded on the background. This feature contributes to an engaging experie\", \"nce for \\nyour users. \\nWith the optional packages feature, you achieve componentization on your app d\", \"eployment, so you \\ncan download them when needed. \\nSimple packaging and deployment \\nThe AppManifest \", \"declares the versioning, device targeting and identity in a standard way for every \\napplication. It \", \"also provides a way to sign your assets providing a solid security foundation. \\nOS managed \\nThe OS h\", \"andles all the processes for installing, updating, and removing an application. Applications \\nare in\", \"stalled per user but downloaded only once, minimizing the disk footprint. Microsoft is working \\non p\", \"roviding the MSIX experience also on Windows 7. \\nWindows provides integrity for the app \\nWith the us\", \"e of digital signatures, you can guarantee that you don\\u2019t install an application from \\nuntrusted sou\", \"rces. MSIX also prevents tampering because: \\n\\u2022 \\nIt keeps a record of file hashes. \\n\\u2022 \\nIt detects if \", \"a file has been modified after installation. \\n \\n61 \\nCHAPTER 6 | Deploying Modern Desktop Application\", \"s \\n \\nWorks for the entire App Catalog \\nOne of the coolest things about MSIX is that it works for the\", \" entire application catalog, Windows \\nForms, WPF, MFC/ATL, Delphi, even if you want to do xCopy depl\", \"oyment, ClickOnce, or going to the \\nStore, you can use the same MSIX package. \\nTools \\nWindows Applic\", \"ation Packaging Project \\nYou can use the Windows Application Packaging Project project in Visual Stu\", \"dio to generate a \\npackage for your desktop app. Then, you can publish that package to the Microsoft\", \" Store or sideload \\nit onto one or more PCs. \\nMSIX Packaging Tool \\nThe MSIX Packaging Tool enables y\", \"ou to repackage your existing Win32 applications to the MSIX \\nformat. It offers both an interactive \", \"UI and a command line for conversions and gives you the ability to \\nconvert an application without h\", \"aving the source code. \\n \\n62 \\nCHAPTER 6 | Deploying Modern Desktop Applications \\n \\n \\nPackage Support\", \" Framework \\nThe Package Support Framework is an open-source kit that helps you apply fixes to your e\", \"xisting \\nWin32 application when you don\\u2019t have access to the source code, so that it can run in an M\", \"SIX \\ncontainer. The Package Support Framework helps your application follow the best practices of th\", \"e \\nmodern runtime environment. \\nApp Installer \\nApp Installer allows Windows 10 and Windows 11 apps t\", \"o be installed by double-clicking the app \\npackage. This means that users don\\u2019t need to use PowerShe\", \"ll or other developer tools to deploy \\nWindows 10/Windows 11 apps. The App Installer can also instal\", \"l an app from the web, optional \\npackages, and related sets. \\nHow to create an MSIX package from an \", \"existing \\nWin32 desktop application \\nLet\\u2019s go through the process to create an MSIX package from an \", \"existing Win32 application. In this \\nexample, we\\u2019ll use a Windows Forms app. \\n \\n63 \\nCHAPTER 6 | Depl\", \"oying Modern Desktop Applications \\n \\nTo start, add a new project to your solution, select the Window\", \"s Application Packaging Project, and \\ngive it a name. \\n \\nYou\\u2019ll see the structure of the packaging p\", \"roject and note a special folder called Applications. Inside \\nthis folder, you can specify which app\", \"lications you want to include in the package. It can be more than \\none. \\n \\n64 \\nCHAPTER 6 | Deploying\", \" Modern Desktop Applications \\n \\n \\nRight-click on the Applications folder and select the Windows Form\", \"s project you want to package \\nfrom the Visual Studio solution. \\n \\n65 \\nCHAPTER 6 | Deploying Modern \", \"Desktop Applications \\n \\n \\nAt this point, you can compile and generate the package but let\\u2019s examine \", \"a couple of things. To have \\na better user experience, Visual Studio can autogenerate all the visual\", \" assets a modern application \\nneeds to handle icons and tile assets for the tile bar and start menu.\", \" Open the Package.appxmanifest \\nfile to access the Manifest Designer. You can then generate all the \", \"visual assets from a given image \\npresent on your project just by clicking Create. \\n \\nIf you open th\", \"e code for the Package.appxmanifest file, you can see a couple of interesting things. \\nRight under <\", \"Package>, there\\u2019s an <Identity> node. This is where your packaged application is going \\nto get its i\", \"dentity, which will be managed by the OS. \\n \\n66 \\nCHAPTER 6 | Deploying Modern Desktop Applications \\n\", \" \\n \\nIn the <Capabilities> node, you can find all the requirements the application needs, paying spec\", \"ial \\nattention to the <rescap:Capability Name=\\\"runFullTrust\\\" \\\\>, which tells the OS to run the app i\", \"n full \\ntrust mode since it\\u2019s a Win32 application. \\n \\n67 \\nCHAPTER 6 | Deploying Modern Desktop Appli\", \"cations \\n \\n \\nSet the packaging project as the startup project for the solution and select Run. This \", \"is going to: \\n\\u2022 \\nCompile the Windows Forms application. \\n\\u2022 \\nCreate an MSIX package out of the build \", \"results. \\n\\u2022 \\nDeploy the packages. \\n\\u2022 \\nInstall it locally on the development machine. \\n\\u2022 \\nLaunch the \", \"app. \\n \\n68 \\nCHAPTER 6 | Deploying Modern Desktop Applications \\n \\n \\nWith this, you have the clean ins\", \"tall and uninstall experience that MSIX provides fully integrated into \\nWindows 10/Windows 11. \\nThe \", \"final stage is about how you deploy the MSIX package to another machine. \\nRight-click on the packagi\", \"ng project, select the Store menu, and then select the Create App \\nPackages option. \\nThen, you can c\", \"hoose between creating a package to upload to the store or creating packages for \\nsideloading. In mo\", \"st modernization scenarios, you\\u2019ll choose I want to create packages for \\nsideloading. \\n \\n69 \\nCHAPTER\", \" 6 | Deploying Modern Desktop Applications \\n \\n \\nThere you can select the different architectures you\", \" want to target as you can include as many as you \\nwant into the same MSIX package. \\nThe final step \", \"is to declare where you want to deploy the final installation assets. \\n \\n70 \\nCHAPTER 6 | Deploying M\", \"odern Desktop Applications \\n \\n \\nYou can choose to use a web server or a shared UNC path on your ente\", \"rprise file servers. Pay \\nattention to the settings to specify how you want to update your applicati\", \"on. We\\u2019ll cover application \\nupdates in the next section. \\nFor a detailed step-by-step guide, see Pa\", \"ckage a desktop app from source code using Visual Studio. \\nAuto Updates in MSIX \\nThe Windows Store h\", \"as a great updating mechanism using Windows Update. In most enterprise \\nscenarios, you don\\u2019t use the\", \" Store to distribute your desktop apps. So, you need a similar way to \\nconfigure updates for your ap\", \"plication and pull them to your users. \\nUsing a combination of Windows 10/Windows 11 features and MS\", \"IX packages, you can provide a \\ngreat updating experience for your users. In fact, the user doesn\\u2019t \", \"need to be technical at all but still \\nbenefits from a seamless application update experience. \\nYou \", \"can configure your updates to interact with the user in two different ways: \\n \\n71 \\nCHAPTER 6 | Deplo\", \"ying Modern Desktop Applications \\n \\n\\u2022 \\nUser prompted updates: The OS shows some autogenerated nice U\", \"I to notify the user about \\nthe application it\\u2019s about to install. It builds this UI based on the pr\", \"operties you specify on \\nyour installation files. \\n\\u2022 \\nSilent updates in the background. With this op\", \"tion, your users don\\u2019t need to be aware of the \\nupdates. \\nYou can also configure when you want to pe\", \"rform updates: either when the application launches or \\non a regular basis. Thanks to the side-loadi\", \"ng features, you can even get these updates while the \\napplication is running. \\nWhen you use this ty\", \"pe of deployment, a special file is created called .appinstaller. This simple file \\ncontains the fol\", \"lowing sections: \\n\\u2022 \\nThe location of the .appinstaller file \\n\\u2022 \\nThe application\\u2019s main MSIX package \", \"properties \\n\\u2022 \\nThe update behavior \\n \\nIn combination with this file, Microsoft has designed a specia\", \"l URL protocol to launch the installation \\nprocess from a link: \\n<a href=\\\"ms-appinstaller:?source=ht\", \"tp://mywebservice.azureedge.net/MyApp.msix\\\">Install \\napp package </a> \\nThis protocol works on all br\", \"owsers and launches the installation process with a great user experience \\non Windows 10/Windows 11.\", \" Since the OS manages the installation process, it\\u2019s aware of the location \\nthis application was ins\", \"talled from and tracks all the files affected by the process. \\nMSIX creates a user interface for ins\", \"tallation automatically showing some properties of the package. \\nThis allows for a common installati\", \"on experience for every app. \\n \\n72 \\nCHAPTER 6 | Deploying Modern Desktop Applications \\n \\nOnce you\\u2019ve\", \" generated the new MSIX package and moved it to the deployment server, you just have \\nto edit the .a\", \"ppinstaller file to reflect these changes: mainly the version and the path to the new MSIX \\nfile. Th\", \"e next time the user launches the application, the system will detect the change and download \\nthe f\", \"iles for the new version in the background. When the download is finished, installation will \\nexecut\", \"e transparently for your user on new application launch. \\n\"]"