"[\"EDITION v1.0.3 - Updated to .NET 7\\nRefer to the changelog for the book updates and community contrib\", \"utions.\\nPUBLISHED BY\\nMicrosoft Developer Division, .NET, and Visual Studio product teams\\nA division \", \"of Microsoft Corporation\\nOne Microsoft Way\\nRedmond, Washington 98052-6399\\nCopyright \\u00a9 2022 by Micros\", \"oft Corporation\\nAll rights reserved. No part of the contents of this book may be reproduced or trans\", \"mitted in any \\nform or by any means without the written permission of the publisher.\\nThis book is pr\", \"ovided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions, and \\ninformation \", \"expressed in this book, including URL and other Internet website references, may change \\nwithout not\", \"ice.\\nSome examples depicted herein are provided for illustration only and are fictitious. No real as\", \"sociation \\nor connection is intended or should be inferred.\\nMicrosoft and the trademarks listed at h\", \"ttps://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of compa\", \"nies.\\nMac and macOS are trademarks of Apple Inc.\\nAll other marks and logos are property of their res\", \"pective owners.\\nCo-Authors:\\nOlia Gavrysh, Program Manager, .NET team, Microsoft\\nMiguel Angel Castej\\u00f3\", \"n Dominguez, Innovation Architect, Kabel\\nParticipants and reviewers:\\nMaira Wenzel, Senior Program Ma\", \"nager, .NET team, Microsoft\\nAndy De Gorge, Senior Content Developer, .NET docs team, Microsoft\\nMigue\", \"l Ramos, Senior Program Manager, Windows Developer Platform team, Microsoft\\nAdam Braden, Principal P\", \"rogram Manager, Windows Developer Platform team, Microsoft\\nRicardo Minguez Pablos, Senior Program Ma\", \"nager, Azure IoT team, Microsoft\\nNish Anil, Senior Program Manager, .NET team, Microsoft\\nBeth Massi,\", \" Senior Product Marketing Manager, Microsoft\\nScott Hunter, Partner Director Program Manager, .NET te\", \"am, Microsoft\\nMarta Fuentes Lara, KabelRa\\u00fal Fern\\u00e1ndez de C\\u00f3rdoba, Kabel\\nAntonio Manuel Fern\\u00e1ndez Can\", \"tos, Kabel\\nIntroduction\\nThis book is about strategies you can adopt to move your existing desktop ap\", \"plications through the \\npath of modernization and incorporate the latest runtime, language, and plat\", \"form features. You\\u2019ll \\ndiscover that there\\u2019s no unique recipe as each application is different, and \", \"so are your requirements \\nand preferences. The good news is that there are common approaches you can\", \" apply to add new \\nfeatures and capabilities to your applications. Some of them won\\u2019t even require m\", \"ajor modifications \\nof your code. In this book, we\\u2019ll reveal how all those features work behind the \", \"scenes and explain the \\nmechanics of their implementations. Moreover, you\\u2019ll find some common scenar\", \"ios for modernizing \\nexisting desktop applications shown in detail so you can find inspiration for e\", \"volving your projects.\\nMicrosoft\\u2019s approach to modernizing existing applications is to give you the \", \"flexibility to create your \\nown customized path. All the modernization strategies described in this \", \"book are mostly independent. \\nYou can choose ones that are relevant for your application and skip ot\", \"hers that aren\\u2019t important for \\nyou. In other words, you can mix and match the strategies to best ad\", \"dress your application needs.\\nWho should use the book\\nThis book for developers and solution architec\", \"ts who want to modernize existing Windows Forms and \\nWPF desktop applications to leverage the benefi\", \"ts of .NET and Windows 10.\\nYou might also find this book useful if you\\u2019re a technical decision maker\", \", such as an enterprise \\narchitect or a development lead or director who wants an overview of the be\", \"nefits of updating \\nexisting desktop applications.\\nHow to use the book\\nThis book addresses the \\u201cwhy\\u201d\", \"\\u2014why you might want to modernize your existing applications, and the \\nspecific benefits you get from\", \" using NET and MSIX to modernize your desktop apps. The content of \\nthe book is designed for archite\", \"cts and technical decision makers who want an overview, but who \\ndon\\u2019t need to focus on implementati\", \"on and technical, step-by-step details.\\nAlong the different chapters, sample implementation code sni\", \"ppets and screenshots are provided, \\nwith chapter 5 devoted to showcase a complete migration process\", \" for sample applications.\\nWhat this book doesn\\u2019t cover\\nThis book covers a specific subset of scenari\", \"os that are focused on lift-and-shift scenarios, outlining \\nthe way to gain the benefits of moderniz\", \"ing without the effort of rewriting code.\\nThis book isn\\u2019t about developing modern applications with \", \".NET from scratch or about getting started \\nwith Windows Forms and WPF. It focuses on how you can up\", \"date existing desktop applications with \\nthe latest technologies for desktop development.Samples use\", \"d in this book\\nTo highlight the necessary steps to perform a modernization, we\\u2019ll be using a sample \", \"application \\ncalled eShopModernizing. This application has two flavors, Windows Forms and WPF, and w\", \"e\\u2019ll show a \\nstep-by-step process on how to perform the modernization on both of them to .NET.\\nAlso,\", \" on the GitHub repository for this book, you\\u2019ll find the results of the process, which you can \\ncons\", \"ult with if you decide to follow the step-by-step tutorial.i Contents\\nContents\\nWhy modern desktop ap\", \"plications ....................................................................................... 1\", \"\\nIntroduction ......................................................................................\", \".........................................................................................1\\nA story o\", \"f one company ......................................................................................\", \".............................................................1\\nYour story ..........................\", \"....................................................................................................\", \".................................................1\\nDesktop applications nowadays ...................\", \"....................................................................................................\", \".................1\\nWindows Forms ...................................................................\", \"................................................................................................3\\nWP\", \"F...................................................................................................\", \"........................................................................................4\\nUWP.......\", \"....................................................................................................\", \"...............................................................................4\\nA tale of two platf\", \"orms................................................................................................\", \"..........................................................5\\nPaths to modernization..................\", \"....................................................................................................\", \"...................................8\\nModern features ...............................................\", \"....................................................................................................\", \"...............8\\nDeployment.........................................................................\", \"..................................................................................................8\\n\", \"Installation........................................................................................\", \"......................................................................................8\\nWhat\\u2019s new w\", \"ith .NET for Desktop?...............................................................................\", \"....... 9\\nThe motivation behind .NET Core ..........................................................\", \"...........................................................................9\\nIntroduction to .NET Co\", \"re .................................................................................................\", \"................................................ 11\\n.NET 5+ is .NET Core vNext......................\", \"....................................................................................................\", \"..................... 11\\n.NET Framework vs. .NET....................................................\", \"................................................................................................ 12\\n\", \".NET Standard vs. PCL ..............................................................................\", \"........................................................................... 13\\nNew Desktop features \", \"in .NET.............................................................................................\", \"............................................ 14\\nSupport for Windows Forms and WPF ..................\", \".................................................................................................. 1\", \"4\\nXAML Islands......................................................................................\", \"................................................................................ 14\\nAccess to all Wi\", \"ndows 10 and Windows 11 APIs .......................................................................\", \"......................... 15\\nSide-by-side support and self-contained EXEs ..........................\", \".......................................................................... 15\\nPerformance...........\", \"....................................................................................................\", \"........................................................ 15\\nMigrating Modern Desktop applications...\", \"......................................................................... 16\\nConfiguration files ...\", \"....................................................................................................\", \"......................................................... 16\\nConfiguration on .NET Framework........\", \"....................................................................................................\", \"................ 16ii Contents\\nConfiguration on .NET................................................\", \"....................................................................................................\", \" 17\\nMigrating configuration files...................................................................\", \".................................................................... 17\\nAccessing databases.........\", \"....................................................................................................\", \"............................................... 18\\nODBC.............................................\", \"....................................................................................................\", \".................................... 19\\nOLE DB......................................................\", \"....................................................................................................\", \"........................ 19\\nADO.NET.................................................................\", \"....................................................................................................\", \"......... 19\\nEF Core vs. EF6........................................................................\", \"........................................................................................... 19\\nRelat\", \"ional databases ....................................................................................\", \"................................................................... 20\\nConsuming services ..........\", \"....................................................................................................\", \"............................................... 20\\nConsuming a COM Object ..........................\", \"....................................................................................................\", \".................. 21\\nMore things to consider.......................................................\", \".............................................................................................. 21\\nAp\", \"pDomains ...........................................................................................\", \"........................................................................... 21\\nRemoting.............\", \"....................................................................................................\", \"............................................................ 21\\nCode Access Security (CAS) .........\", \"....................................................................................................\", \"............................ 22\\nSecurity Transparency ..............................................\", \"....................................................................................................\", \".. 22\\nWindows 10 migration .........................................................................\", \"................................ 23\\nWinRT APIs .....................................................\", \"....................................................................................................\", \"..................... 23\\nUniversal Windows Platform (UWP) packages .................................\", \".................................................................... 24\\nHow to add WinRT APIs to you\", \"r desktop project...................................................................................\", \"................. 26\\nXAML Islands ..................................................................\", \"....................................................................................................\", \".... 34\\nThe road to XAML Islands....................................................................\", \"......................................................................... 35\\nHow it works ..........\", \"....................................................................................................\", \"........................................................ 35\\nDo you need XAML Islands ...............\", \"....................................................................................................\", \"....................... 38\\nThe road ahead XAML Islands: WinUI 3.0 ..................................\", \"............................................................................ 38\\nExample of migrating\", \" to the latest .NET............................................................................. 41\\n\", \"Migrating from .NET Core or .NET 5 .................................................................\", \"............................................................ 41\\nMigrating from .NET Framework ......\", \"....................................................................................................\", \".......................... 42\\nMigrating with a tool.................................................\", \"....................................................................................................\", \". 42\\nMigrating by hand..............................................................................\", \"............................................................................. 42\\nPreparation .......\", \"....................................................................................................\", \".............................................................. 43\\nFix the code and build............\", \"....................................................................................................\", \".................................... 45\\nRun and test................................................\", \"....................................................................................................\", \"................... 46iii Contents\\nMigrating a Windows Forms application ...........................\", \"......................................................................................... 46\\nMigrati\", \"ng a WPF application................................................................................\", \"............................................................ 52\\nDeploying Modern Desktop Application\", \"s .......................................................................... 55\\nThe modern applicati\", \"on lifecycle........................................................................................\", \"............................................ 56\\nMSIX: The next generation of deployment.............\", \"....................................................................................................\", \" 58\\nBenefits of MSIX ...............................................................................\", \"................................................................................ 59\\nTools...........\", \"....................................................................................................\", \"....................................................................... 61\\nHow to create an MSIX pac\", \"kage from an existing Win32 desktop application........................................... 62\\nAuto U\", \"pdates in MSIX......................................................................................\", \"................................................................... 701 CHAPTER 1 | Why modern deskt\", \"op applications\\nCHAPTER 1\\nWhy modern desktop \\napplications\\nIntroduction\\nA story of one company\\nBack \", \"in the early 2000s, one multinational company started developing a distributed desktop solution \\nto \", \"exchange information between different branches of the company and execute optimized \\noperations on \", \"centralized units. They have chosen a brand-new framework called Windows Forms \\n(also known as WinFo\", \"rms) for their application development. Over the years, the project evolved into \\na mature, well-tes\", \"ted, and time-proven application with hundreds of thousands of lines of code. Time \\npassed and .NET \", \"Framework 2.0 is no longer the hot new technology. The developers who are \\nworking on this applicati\", \"on are facing a dilemma. They\\u2019d like to use the latest stack of technologies in \\ntheir development a\", \"nd have their application look and \\u201cfeel\\u201d modern. At the same time, they don\\u2019t \\nwant to throw away t\", \"he great product they have built over 15 years and rewrite the entire application \\nfrom scratch.\\nYou\", \"r story\\nYou might find yourself in the same boat, where you have mature Windows Forms or Windows \\nPr\", \"esentation Foundation (WPF) applications that have proved their reliability over the years. You \\npro\", \"bably want to keep using these applications for many more years. At the same time, since those \\nappl\", \"ications were written some time ago, they might be missing capabilities like modern look, \\nperforman\", \"ce, integration with new devices and platform features, and so on, which gives them a feel \\nof \\u201cold \", \"tech\\u201d. There\\u2019s another problem that might concern you as a developer. While working on the \\nolder .N\", \"ET Framework versions and maintaining applications that were written a while ago, you might \\nfeel li\", \"ke you aren\\u2019t learning new technologies and missing out on building modern technical skills. If \\ntha\", \"t is your story \\u2013 this book is for you!\\nDesktop applications nowadays\\nBefore the rise of the Interne\", \"t, desktop applications were the main approach to building software \\nsystems. Developers could choos\", \"e any programming language, such as COBOL, Fortran, VB6, or C++. 2 CHAPTER 1 | Why modern desktop ap\", \"plications\\nBut whether they developed small tools or complex distributed architectures, they were al\", \"l desktop \\napplications.\\nThen, Internet technologies started shocking the development world and winn\", \"ing over more \\nengineers with advantages like easy deployment and simplified distribution processes.\", \" The fact that \\nonce a web application was deployed to production all users got automatic updates ma\", \"de a huge \\nimpact on software agility.\\nHowever, the Internet infrastructure, underlying protocols, a\", \"nd standards like HTTP and HTML weren\\u2019t \\ndesigned for building complex applications. In fact, the ma\", \"jor development effort back then was \\naimed at just one goal: to give web applications the same capa\", \"bilities that desktop applications have, \\nsuch as fast data input and state management.\\nEven though \", \"web and mobile applications have grown at an incredible pace, for certain tasks desktop \\napplication\", \"s still hold the number one place in terms of efficiency and performance. That explains why \\nthere a\", \"re millions of developers who are building their projects with WPF and WinForms and the \\namount of t\", \"hose applications is constantly growing.\\nHere are some reasons for choosing desktop applications in \", \"your development:\\n\\u2022 Desktop apps have better interaction with the user\\u2019s PC.\\n\\u2022 The performance of de\", \"sktop applications for complex calculations is much higher than the \\nperformance of web applications\", \".\\n\\u2022 Running custom logic on the client-side is possible but much harder with a web application.\\n\\u2022 Us\", \"ing multithreading is easier and more efficient in a desktop application.\\n\\u2022 The learning curve for d\", \"esigning user interfaces (UIs) isn\\u2019t steep. And for WinForms, it\\u2019s \\nintuitive with the drag-and-drop\", \" experience of the Windows Forms designer.\\n\\u2022 It\\u2019s easy to start coding and testing your algorithms w\", \"ithout the need to set up a server \\ninfrastructure or to care about connectivity problems, firewalls\", \", and browser compatibility.\\n\\u2022 Debugging is powerful as compared to web debugging.\\n\\u2022 Access to hardw\", \"are devices, such as camera, Bluetooth, or card readers, is easy.\\n\\u2022 Since the technology has been ar\", \"ound for a while, there are many experts and a knowledge \\nbase available to develop desktop applicat\", \"ions.\\nSo, as you can see, developing for desktop is great for many reasons. The technology is mature\", \" and \\ntime-tested, the development cycle is fast, the debugging is powerful and arguably, desktop ap\", \"ps \\nhave less complexity and are easier to get started with.\\nMicrosoft offered many UI desktop techn\", \"ologies throughout the years from Win32 introduced in 1995 \\nto Universal Windows Platform (UWP) rele\", \"ased in 2016.3 CHAPTER 1 | Why modern desktop applications\\nAccording to a survey published by Teleri\", \"k on April 2016, the most popular technologies for building \\nWindows desktop apps are Windows Forms,\", \" WPF, and UWP.\\nYou can develop in any of them using C# and Visual Basic, but let\\u2019s take a closer loo\", \"k.\\nWindows Forms\\nFirst released in 2002, Windows Forms is a managed framework and is the oldest, mos\", \"t-used desktop \\ntechnology built on the Windows graphics device interface (GDI) engine. It offers a \", \"smooth drag-and\\u0002drop experience for developing user interfaces in Visual Studio. At the same time, W\", \"indows Forms \\nrelies on the Visual Studio Designer as the main way you develop your UI, so creating \", \"visual \\ncomponents from code isn\\u2019t trivial.\\nThe following list summarizes the main characteristics o\", \"f Windows Forms:\\n\\u2022 Mature technology with lots of code samples and documentation.\\n\\u2022 Powerful and pro\", \"ductive designer. Not so convenient to design UI \\u201cfrom code\\u201d.\\n\\u2022 Easy and intuitive to learn, thanks \", \"to the designer\\u2019s drag-and-drop experience.\\n\\u2022 Supported on any Windows version.\\n\\u2022 Supported on .NET \", \"Core 3.0 and later versions.4 CHAPTER 1 | Why modern desktop applications\\nWPF\\nBased on the XAML lang\", \"uage specification, WPF favors a clear separation between UI and code. XAML \\noffers capabilities lik\", \"e templating, styling, and binding, which is suited for building large applications. \\nLike Windows F\", \"orms, it\\u2019s a managed framework, but the design is modular and reusable.\\nHere are the main features o\", \"f WPF:\\n\\u2022 Mature technology.\\n\\u2022 Designer is available, but developers usually prefer to create the des\", \"ign from code using \\ndeclarative XAML.\\n\\u2022 The learning curve is steeper than Windows Forms.\\n\\u2022 Support\", \"ed on any Windows version.\\n\\u2022 Supported on .NET Core 3.0 and later versions.\\nUWP\\nUWP isn\\u2019t only a pre\", \"sentation framework like WPF and Windows Forms, but it\\u2019s also a platform itself. \\nThis platform has:\", \"\\n\\u2022 Its own API set (the Windows Runtime API).\\n\\u2022 A new deployment system (MSIX)\\n\\u2022 A modern applicatio\", \"n lifecycle model (for low battery consumption).\\n\\u2022 A new Resource Management System (based on PRI fi\", \"les).\\nThe platform was created to support all kinds of input systems (like ink, touch, gamepad, mous\", \"e, \\nkeyboard, gaze, and so on) in all form-factors with performance and low battery consumption in m\", \"ind. \\nFor these reasons, the shell of the Windows 10 OS uses parts of the UWP platform.5 CHAPTER 1 |\", \" Why modern desktop applications\\nUWP contains a presentation framework that is XAML-based, like WPF,\", \" but it has some important \\ndifferences such as:\\n\\u2022 Applications are executed in app containers. App \", \"containers control what resources a UWP \\napp can access.\\n\\u2022 Supported only on Windows 10 and Windows \", \"11.\\n\\u2022 Apps can be deployed through Microsoft Store for easier deployment.\\n\\u2022 Designed as part of the \", \"Windows Runtime API.\\n\\u2022 Contains an extensive set of rich built-in controls and additional controls a\", \"re available \\nthrough the Microsoft UI Library NuGet packages (WinUI library), updated every few mon\", \"ths.\\nA tale of two platforms\\nIn the last 20 years, while UI desktop technologies were growing and fo\", \"llowing the path from \\nWindows Forms to UWP, the hardware was also evolving from heavyweight PC unit\", \"s with small CRT \\nmonitors to high-DPI monitors and lightweight tablets and phones with different da\", \"ta input \\ntechniques like Touch and Ink. These changes resulted in creating two different concepts: \", \"a Desktop \\nApplication and a Modern Application. A Modern Application is one that considers differen\", \"t device \\nform factors, various input and output methods, and leverages modern desktop features whil\", \"e \\nrunning on a sandboxed execution model. The (traditional) Desktop Application, on the other hand,\", \" is 6 CHAPTER 1 | Why modern desktop applications\\nan application that needs a solid UI with a high d\", \"ensity of controls that is best operated with a mouse \\nand a keyboard.\\nThe following table describes\", \" the differences between the two concepts:\\nAspect of comparison Modern Application Desktop Applicati\", \"on\\nSecurity Contained execution & Great \\nFundamentals. Designed from \\nthe ground up to respect user\\u2019\", \"s \\nprivacy, manage battery life, \\nand focus to keep the device \\nsafe.\\nUser & Admin level of security\", \". \\nYou have native access to the \\nregistry and hard drive folders.\\nDeployment Installation and updat\", \"es are \\nmanaged by the platform.\\nMSI, Custom installers & \\nUpdates. Traditionally a source \\nof heada\", \"ches for developers \\nand IT managers.\\nDistribution Trusted Distribution & Signed \\nPackages. Distribu\", \"tion is \\nperformed from a trusted \\nsource and never from the \\nweb.\\nWeb, SCCM & Custom \\ndistribution.\", \" No control over \\nwhat is installed, affects the \\nwhole machine.\\nUI Modern UI. Different input \\nmech\", \"anisms, ink, touch, \\ngamepad, keyboard, mouse, \\netc.\\nWindows Forms, WPF, MFC. \\nDesigned for the mous\", \"e and \\nkeyboard for a dense UI and to \\nget the most productivity from \\nthe desktop.\\nData Cloud First\", \" Data with Insights. \\nSource of truth in the cloud. \\nInsights to know what happens \\nwith your app an\", \"d how it\\u2019s \\nperforming.\\nLocal Data. Traditional desktop \\napplications usually need some \\nlocal data.\", \"\\nDesign Designed for reuse. Reuse in \\nmind between different \\nplatforms, front end, and back \\nend, r\", \"unning assets in many \\nplaces as possible.\\nDesigned for Windows \\nDesktop only\\nAs a part of the commi\", \"tment to provide developers with the best tools to build applications, Microsoft \\nput forth a great \", \"effort to bring these concepts - or we can even say platforms - closer together to \\nempower develope\", \"rs with the best of both worlds. To do that, Microsoft has performed a bidirectional \\neffort between\", \" the two platforms.7 CHAPTER 1 | Why modern desktop applications\\n1. Move Desktop Application scenari\", \"os into Modern Application platform. The traditional \\ndesktop development is still popular because i\", \"t addresses certain scenarios well. It makes \\nsense to take these common desktop scenarios and bring\", \" them into the modern desktop \\nplatform to make the platform fully capable.\\n \\n1. Move Modern Applica\", \"tion features into Desktop Applications. For existing desktop apps that \\nneed a way to leverage mode\", \"rn capabilities without rewriting from scratch, features from the \\nModern Application platform are p\", \"ushed into the Desktop Application.\\n 8 CHAPTER 1 | Why modern desktop applications\\nIn this book, we\\u2019\", \"ll focus on the second part and show how you can modernize your existing desktop \\napplications.\\nPath\", \"s to modernization\\nThe structure of this guide reflects three different axes to accomplish moderniza\", \"tion: Modern \\nFeatures, Deployment, and Installation.\\nModern features\\nSay you have a working Windows\", \" Forms application that a sales representative of your company uses \\nto fill in a customer order. A \", \"new requirement comes in to enable the customer to sign the order \\nusing a tablet pen. Inking is nat\", \"ive in today\\u2019s operating systems and technologies, but it wasn\\u2019t \\navailable when the app was develop\", \"ed.\\nThis path will show you how you can leverage modern desktop features into your existing desktop \", \"\\ndevelopment.\\nDeployment\\nModern development cycles have stressed the importance of providing agility\", \" with regard to how new \\nversions of applications are deployed to individual users. Since Windows Fo\", \"rms and WPF applications \\nare based on a particular version of the .NET Framework that must be prese\", \"nt on the machine, they \\ncan\\u2019t take advantage of new .NET Framework version features without the int\", \"ervention of the IT \\npeople with the risk of having side effects for other apps running on the same \", \"machine. It has limited \\nthe innovation pace for developers forcing them to stay on outdated version\", \"s of the .NET Framework.\\nSince the launch of .NET Core 3.0, you can leverage a new approach of deplo\", \"ying multiple versions of \\n.NET side by side and specifying which version of .NET each application s\", \"hould target. This way, you \\ncan use the newest features in one application while being confident yo\", \"u aren\\u2019t going to break any \\nother applications.\\nInstallation\\nDesktop applications always rely on so\", \"me sort of installation process before the user can start using \\nthem. This fact brought into the ga\", \"me a set of technologies, from MSI and ClickOnce to custom \\ninstallers or even XCOPY deployment. Any\", \" of these methods deals with delicate problems because \\napplications need a way to access shared res\", \"ources on the machine. Sometimes installation needs to \\naccess the Registry to insert or update new \", \"Key Values, sometimes to update shared DLLs referenced \\nby the main application. This behavior cause\", \"s a continuous headache for users, creating this \\nperception that once you install some application,\", \" your computer will never be the same, even if you \\nuninstall it afterwards.\\nIn this book, we\\u2019ll int\", \"roduce a new way of installing applications with MSIX that solves the problem \\ndescribed earlier. Yo\", \"u\\u2019ll learn how you can easily set up packaging, installation, and updates for your \\napplication.9 CH\", \"APTER 2 | What\\u2019s new with .NET for Desktop?\\nCHAPTER 2\\nWhat\\u2019s new with .NET for \\nDesktop?\\nDesktop app\", \"lications such as Windows Forms and WPF can be built using various .NET \\nimplementations, for exampl\", \"e, .NET Framework or .NET 7. In this chapter, we\\u2019ll talk about the history \\nof each implementation, \", \"explain the differences, and show what new features await desktop \\ndevelopers in newer implementatio\", \"ns.\\nIf you\\u2019ve been developing Windows Forms or WPF applications for a long time, you\\u2019re familiar wit\", \"h \\n.NET Framework. Later, .NET Core (specifically its 3.0 version) started supporting desktop applic\", \"ations. \\n.NET Core was rebranded to .NET when .NET 5 was released. Just as there are different versi\", \"ons of \\n.NET Framework, for example, 4.6, 4.7, and 4.8, there are also different versions of .NET Co\", \"re: .NET \\nCore 3.0, .NET 5, .NET 6, .NET 7, and so on.\\nLet\\u2019s look into the history of each implement\", \"ation to understand the differences and benefits of each.\\nThe motivation behind .NET Core\\nSince its \", \"launch in 2002, .NET Framework has evolved to support many technologies, like Windows \\nForms, ASP.NE\", \"T, Entity Framework, Windows Store, and many others. All of them are different in \\nnature. Therefore\", \", Microsoft approached this evolution by taking parts of .NET Framework and \\ncreating a different ap\", \"plication stack for each technology. That way, development capabilities could \\nbe customized for the\", \" needs of the specific stack, which maximized the potential of every platform. \\nThat led to fragment\", \"ation on the versions of .NET Framework maintained by different independent \\nteams. All of these sta\", \"cks have a common structure, containing an app model, a framework, and a \\nruntime, but they differ i\", \"n the implementation of each of the parts.\\nIf you\\u2019re targeting only one of these platforms, you can \", \"use this model. However, in many cases you \\nmight need more than one target platform in the same sol\", \"ution. For example, your application may \\nhave a desktop admin part, a customer-facing web site that\", \" shares the back-end logic running on a \\nserver, and even a mobile client. In this case, you need a \", \"unified coding experience that can span all of \\nthese .NET verticals.\\nBy the time Windows 8 was rele\", \"ased, the concept of Portable Class Libraries (PCLs) was born. \\nOriginally, .NET Framework was desig\", \"ned around the assumption that it would always be deployed as \\na single unit, so factoring wasn\\u2019t a \", \"concern. To face the problem of code sharing between verticals, the \\ndriving force was on how to ref\", \"actor the framework. The idea of contracts is to provide a well-factored 10 CHAPTER 2 | What\\u2019s new w\", \"ith .NET for Desktop?\\nAPI surface area. Contracts are simply assemblies that you compile against and\", \" are designed with \\nproper factoring in mind taking care of the dependencies between them.\\nThis led \", \"to reasoning about the API differences between verticals at the assembly level, as opposed to \\nat th\", \"e individual API level like previously. This aspect enabled a class library experience that can targ\", \"et \\nmultiple verticals, also known as portable class libraries.\\nWith PCL, the experience of developm\", \"ent is unified across verticals based on the API shape. And the \\nmost pressing need to create librar\", \"ies running on different verticals is also addressed. But there\\u2019s a \\ngreat challenge: APIs are only \", \"portable when the implementation is moved forward across all the \\nverticals.\\nA better approach is to\", \" unify the implementations across verticals by providing a well-factored \\nimplementation instead of \", \"a well-factored view. It\\u2019s a lot simpler to ask each team that owns a specific \\ncomponent to think a\", \"bout how their APIs work across all verticals than trying to retroactively provide \\na consistent API\", \" stack on top. This is where .NET Standard comes in.\\nAnother large challenge has to do with how .NET\", \" Framework is deployed. .NET Framework is a \\nmachine-wide framework. Any changes made to it affect a\", \"ll applications that take a dependency on it. \\nAlthough this deployment model has many advantages, s\", \"uch as reducing disk space and centralized \\naccess to services, it presents some pitfalls.\\nTo start \", \"with, it\\u2019s difficult for application developers to take a dependency on a recently released \\nframewo\", \"rk. They either have to take a dependency on the latest OS or provide an application installer \\nthat\", \" installs .NET Framework along with the application. If you\\u2019re a web developer, you might not even \\n\", \"have this option as the IT department establishes the server supported version.\\nEven if you\\u2019re willi\", \"ng to go through the trouble of providing an installer to chain in .NET Framework \\nsetup, you may fi\", \"nd that upgrading .NET Framework can break other applications.\\nDespite the efforts to provide backwa\", \"rd compatible versions of the framework, there are compatible \\nchanges that can break applications. \", \"For example, adding an interface to an existing type can change \\nhow this type is serialized and cau\", \"se breaking problems depending on the existing code. Because the \\n.NET Framework installed base is h\", \"uge, fighting against these breaking scenarios slows down the pace \\nof innovations inside .NET Frame\", \"work.\\nTo solve all these issues, Microsoft developed .NET Core as the evolution of the .NET developm\", \"ent \\nplatform.11 CHAPTER 2 | What\\u2019s new with .NET for Desktop?\\nIntroduction to .NET Core\\n.NET Core, \", \"which is now referred to as just \\u201c.NET\\u201d, is the evolution of Microsoft\\u2019s .NET technology into \\na mod\", \"ular, cross-platform, open source, and cloud-ready platform. It runs on Windows, macOS, and \\nLinux, \", \"and some ARM-based architectures like Android and IoT.\\nThe purpose of .NET Core is to provide a unif\", \"ied platform for all types of applications, which includes \\nWindows, cross-platform, and mobile appl\", \"ications. .NET Standard enabled this by providing shared \\nbase APIs, which every application model n\", \"eeds, and excluding any application model-specific API.\\nThis framework gives applications many benef\", \"its in terms of efficiency and performance, simplifying \\nthe packaging and deployment in the differe\", \"nt supported platforms.\\nThe benefits of .NET Core come from these three characteristics:\\n\\u2022 Cross-pla\", \"tform: It allows application execution on different platforms (Windows, macOS, and \\nLinux).\\n\\u2022 Open s\", \"ource: .NET Core platform is open source and available through GitHub, fostering \\ntransparency and c\", \"ommunity contributions.\\n\\u2022 Supported: Microsoft officially supports .NET Core.\\nStarting with .NET Cor\", \"e 3.0, besides the existing support for web and cloud, there\\u2019s also support for \\ndesktop, IoT, and A\", \"I domains. The goal for this framework is impressive: to target every type of .NET \\ndevelopment pres\", \"ent and future.\\n.NET 5+ is .NET Core vNext\\n.NET 5 was the next step forward with .NET Core. .NET 5 i\", \"mproved .NET in a few key ways:\\n\\u2022 Produced a single .NET runtime and framework that can be used ever\", \"ywhere and that has \\nuniform runtime behaviors and developer experiences.\\n\\u2022 Expanded the capabilitie\", \"s of .NET by taking the best of .NET Core, .NET Framework, Xamarin, \\nand Mono.\\n\\u2022 Built that product \", \"out of a single code-base that developers (Microsoft and the community) \\ncan work on and expand toge\", \"ther and that improves all scenarios.\\n.NET 5 was a game-changer for .NET. With .NET 5 and later vers\", \"ions, your code and project files look \\nand feel the same no matter which type of app you\\u2019re buildin\", \"g. You have access to the same runtime, \\nAPIs, and language capabilities with each app. This include\", \"s new performance improvements that get \\ncommitted to the runtime almost daily. .NET 6 and .NET 7 ma\", \"de further improvements in reliability, \\nperformance, new APIs, and language features. For more deta\", \"ils, see What\\u2019s new in .NET 5, What\\u2019s \\nnew in .NET 6, and What\\u2019s new in .NET 7.12 CHAPTER 2 | What\\u2019s\", \" new with .NET for Desktop?\\n.NET Framework vs. .NET\\nSo now that you understand the relevance of .NET\", \", you might be wondering what happens with .NET \\nFramework. You could be asking questions like: Do I\", \" have to abandon it? Is it going to disappear? \\nWhat are my choices to modernize the applications I \", \"have on .NET Framework?\\nIn 2019, .NET Framework 4.8 was released. It included three major improvemen\", \"ts for desktop \\napplications:\\n\\u2022 Modern browser and media controls: New controls were added that take\", \" advantage of \\nMicrosoft Edge and newer media players that support the latest standards.\\n\\u2022 Access to\", \" UWP controls: UWP introduced controls that take advantage of the latest \\nWindows features and touch\", \" displays. With .NET Framework 4.8, you don\\u2019t have to rewrite \\nyour applications to use these new fe\", \"atures and controls, so you can use these new features \\nin your existing WPF or Windows Forms code.\\n\", \"\\u2022 High-DPI improvements: The resolution of displays increased to 4K and 8K, so, .NET \\nFramework 4.8 \", \"added new HDPI improvements to make sure existing Windows Forms and \\nWPF applications can look great\", \" on these new displays.\\nSince .NET Framework is installed on millions of machines, Microsoft will co\", \"ntinue to support it but \\nwon\\u2019t add new features.\\n.NET (Core) is the open-source, cross-platform, an\", \"d fast-moving version of the .NET family. Because of \\nits side-by-side nature, it can take changes w\", \"ithout the fear of breaking any application. This means \\nthat .NET will get new APIs and language fe\", \"atures over time that .NET Framework won\\u2019t. Also, .NET \\nalready has features that were impossible fo\", \"r .NET Framework, such as:\\n\\u2022 Side-by-side versions of .NET supporting Windows Forms and WPF: This so\", \"lves the \\nproblem of side effects when updating the machine\\u2019s framework version. Multiple versions o\", \"f \\n.NET can be installed on the same machine and each application specifies which version of 13 CHAP\", \"TER 2 | What\\u2019s new with .NET for Desktop?\\n.NET it should use. Even more, now you can develop and run\", \" Windows Forms and WPF on top \\nof .NET.\\n\\u2022 Embed .NET directly into an application: You can deploy .N\", \"ET as part of your application \\npackage. This enables you to take advantage of the latest version, f\", \"eatures, and APIs without \\nhaving to wait for a specific version to be installed on the machine.\\n\\u2022 T\", \"ake advantage of .NET features: .NET is fast-moving and open-source. Its side-by-side \\nnature enable\", \"s fast introduction of new innovative APIs and Base Class Library (BCL) \\nimprovements without the ri\", \"sk of breaking compatibility. Now Windows Forms and WPF \\napplications can take advantage of the late\", \"st .NET features, which also includes fundamental \\nfixes for things like runtime performance and hig\", \"h-DPI support.\\n.NET Framework will be fully supported and will always be a part of Windows. However,\", \" if you want to \\nuse the newest language features and APIs in the future, you\\u2019ll need to move your a\", \"pplications to \\n.NET. For brand-new desktop apps, we recommend starting directly on .NET 6 or a late\", \"r version. It\\u2019s \\nlightweight and cross-platform, runs side by side, has high performance, and fits p\", \"erfectly on \\ncontainers and microservices architectures.\\n.NET Standard vs. PCL\\n.NET Standard is a fo\", \"rmal specification of .NET APIs that are intended to be available on all .NET \\nimplementations. The \", \"motivation behind .NET Standard was to establish greater uniformity in the .NET \\necosystem. .NET Sta\", \"ndard is a specification of .NET APIs that make up a uniform set of contracts to \\ncompile your code \", \"against. These contracts are implemented in each .NET flavor, thus enabling \\nportability across diff\", \"erent .NET implementations.\\n.NET Standard enables the following key scenarios:\\n\\u2022 Defines uniform set\", \" of base class libraries APIs for all .NET implementations to implement, \\nindependent of the workloa\", \"d.\\n\\u2022 Enables developers to produce portable libraries that are usable across .NET implementations, \\n\", \"using this same set of APIs.14 CHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n.NET Standard is the ev\", \"olution of PCLs and the following list shows the fundamental differences \\nbetween .NET Standard and \", \"PCLs:\\n\\u2022 .NET Standard is a set of curated APIs, picked by Microsoft. PCLs aren\\u2019t.\\n\\u2022 The APIs that a \", \"PCL contains are dependent on the platforms that you choose to target when \\nyou create it. This make\", \"s a PCL only sharable for the specific targets that you choose.\\n\\u2022 .NET Standard is platform-agnostic\", \", so it can run on Windows, macOS, and Linux.\\n\\u2022 PCLs can also run cross-platform, but they can only \", \"target a limited set of platforms.\\nNew Desktop features in .NET\\nSupport for Windows Forms and WPF\\nWi\", \"ndows Forms and WPF are part of .NET Core since version 3.0. Both presentation frameworks are \\nfor W\", \"indows only, so they aren\\u2019t cross-platform. You can think of WPF as a rich layer over DirectX and \\nW\", \"indows Forms as a thinner layer over GDI+. WPF and Windows Forms do a great job of exposing \\nand exe\", \"rcising much of the desktop application functionality in Windows. So Windows Forms and \\nWPF are avai\", \"lable for .NET Core and .NET Framework. Target your new desktop applications to .NET 6 \\nor later, an\", \"d migrate your existing apps from .NET Framework to .NET 6 or later.\\nA new version of .NET Standard,\", \" version 2.1, was released at the same time as .NET Core 3.0. To see \\nwhich .NET implementations sup\", \"port which .NET Standard versions, see Which .NET Standard version \\nto target.\\nThe .NET (Core) imple\", \"mentations for both Windows Forms and WPF are open source.\\nXAML Islands\\nXAML Islands is a set of com\", \"ponents for developers to use Windows 10 controls (UWP XAML controls) \\nin their WPF, Windows Forms, \", \"and native Win32 apps (like MFC). You can have your \\u201cislands\\u201d of UWP \\nXAML controls wherever you wan\", \"t inside your Win32 apps.\\nThese XAML Islands are possible because Windows 10, version 1903 introduce\", \"d a set of APIs that \\nallows hosting UWP XAML content in Win32 windows using windows handlers (HWnds\", \"). Only apps \\nrunning on Windows 10 1903 and later can use XAML Islands.\\nTo make it easier to create\", \" XAML Islands for Windows Forms and WPF developers, the Windows \\nCommunity Toolkit introduces a set \", \"of .NET wrappers in several NuGet packages. Those wrappers are \\nthe wrapped and hosting controls:\\n\\u2022 \", \"The WebView, WebViewCompatible, InkCanvas, MediaPlayerElement, and MapControl\\nwrapped controls wrap \", \"some UWP XAML controls into Windows Forms or WPF controls, \\nhiding UWP concepts for those developers\", \".\\n\\u2022 The WindowsXamlHost control for Windows Forms and WPF allows other not-wrapped UWP \\nXAML control\", \"s and custom controls to be loaded into a XAML Island.15 CHAPTER 2 | What\\u2019s new with .NET for Deskto\", \"p?\\nAccess to all Windows 10 and Windows 11 APIs\\nWindows 10 and Windows 11 have a large number of API\", \"s available for developers to work with. \\nThese APIs give access to a wide variety of functionality \", \"like authentication, bluetooth, appointments, \\nand contacts. Now these APIs are exposed through .NET\", \" and give Windows developers the chance to \\ncreate powerful desktops apps using the capabilities pre\", \"sent on Windows 10 and Windows 11.\\nSide-by-side support and self-contained EXEs\\nThe .NET deployment \", \"model is one of the biggest benefits that Windows desktop developers will \\nexperience with .NET. The\", \" ability to globally install .NET provides much of the same central installation \\nand servicing bene\", \"fits of .NET Framework, while not requiring in-place updates.\\nWhen a new .NET version is released, y\", \"ou can update each app on a machine as needed without any \\nconcern of affecting other applications. \", \"New .NET versions are installed in their own directories and \\nexist \\u201cside-by-side\\u201d with each other.\\n\", \"If you need to deploy with isolation, you can deploy .NET with your application. .NET will bundle yo\", \"ur \\napp with the .NET runtime as a single executable. The modular architecture used by .NET makes th\", \"ese \\nflexible deployment options possible.\\nPerformance\\nSince its start, targeting the web and cloud \", \"workloads, .NET has had performance plugged into its \\nDNA. Server-side code must be performant enoug\", \"h to fulfill high-concurrency scenarios and .NET 7 \\nscores today as the best performance web platfor\", \"m in the market.\\nOld Windows Forms code has been refactored for .NET, which reduced memory allocatio\", \"ns for \\ndrawing Forms and Controls. By simply upgrading from .NET Framework to .NET or later, your \\n\", \"applications become much faster. You can take advantage of these performance improvements when \\nyou \", \"use .NET to build your next generation of desktop applications.16 CHAPTER 3 | Migrating Modern Deskt\", \"op applications\\nCHAPTER 3\\nMigrating Modern \\nDesktop applications\\nIn this chapter, we\\u2019re exploring th\", \"e most common issues and challenges you can face when migrating \\nan existing application from .NET F\", \"ramework to .NET.\\nIf you just want to update your application to the latest .NET version using a too\", \"l and not get into the \\ndetails of what\\u2019s happening behind the scenes, feel free to skip this chapte\", \"r and find step-by-step \\ninstructions in the Example of migrating to .NET chapter.\\nA complex desktop\", \" application doesn\\u2019t work in isolation and needs some kind of interaction with \\nsubsystems that may \", \"reside on the local machine or on a remote server. It will probably need some \\nkind of database to c\", \"onnect with as a persistence store either locally or remotely. With the rise of \\nInternet and servic\", \"e-oriented architectures, it\\u2019s common to have your application connected to some \\nsort of service re\", \"siding on a remote server or in the cloud. You may need to access the machine file \\nsystem to implem\", \"ent some functionality. Alternatively, maybe you\\u2019re using a piece of functionality \\nthat resides ins\", \"ide a COM object outside your application, which is a common scenario if, for example, \\nyou\\u2019re integ\", \"rating Office assemblies in your app.\\nBesides, there are differences in the API surface that is expo\", \"sed by .NET Framework and .NET, and \\nsome features that are available on .NET Framework aren\\u2019t avail\", \"able on .NET. It\\u2019s important for you to \\nknow and take them into account when planning a migration.\\n\", \"Configuration files\\nConfiguration files offer the possibility to store sets of properties that are r\", \"ead at run time and can \\naffect the behavior of your app, such as where to locate a database or how \", \"many times to execute a \\nloop. The beauty of this technique is that you can modify some aspects of t\", \"he application without the \\nneed to recode and recompile. This comes in handy when, for example, the\", \" same app code runs on a \\ndevelopment environment with a certain set of configuration values and in \", \"production environment \\nwith a different set.\\nConfiguration on .NET Framework\\nIf you have a working \", \".NET Framework desktop application, chances are you have an app.config file \\naccessed through the Ap\", \"pSettingsSection class from the System.Configuration namespace.17 CHAPTER 3 | Migrating Modern Deskt\", \"op applications\\nWithin the .NET Framework infrastructure, there\\u2019s a hierarchy of configuration files\", \" that inherit \\nproperties from its parents. You can find a machine.config file that defines many pro\", \"perties and \\nconfiguration sections that can be used or overridden in any descendant configuration f\", \"ile.\\nConfiguration on .NET\\nIn the .NET world, there\\u2019s no machine.config file. And even though you ca\", \"n continue to use the old \\nfashioned System.Configuration namespace, you may consider switching to t\", \"he modern \\nMicrosoft.Extensions.Configuration, which offers a good number of enhancements.\\nThis conf\", \"iguration API supports the concept of a configuration provider, which defines the data source \\nto be\", \" used to load the configuration. There are different kinds of built-in providers, such as:\\n\\u2022 In-memo\", \"ry .NET objects\\n\\u2022 INI files\\n\\u2022 JSON files\\n\\u2022 XML files\\n\\u2022 Command-line arguments\\n\\u2022 Environment variable\", \"s\\n\\u2022 Encrypted user store\\nOr you can build your own.\\nThe new configuration API allows a list of name-\", \"value pairs that can be grouped into a multi-level \\nhierarchy. Any stored value maps to a string, an\", \"d there\\u2019s built-in binding support that allows you to \\ndeserialize settings into a custom plain old \", \"CLR object (POCO).\\nThe ConfigurationBuilder object lets you add as many configuration providers as y\", \"ou may need for \\nyour application. A precedence rule is used to resolve provider preference. So, the\", \" last provider you \\nadd in your code overrides the others. This is a great feature for managing diff\", \"erent environments for \\nexecution since you can define different configurations for development, tes\", \"ting, and production \\nenvironments. And you can manage them in a single function inside your code.\\nM\", \"igrating configuration files\\nYou can continue to use your existing app.config XML file. However, you\", \" could take this opportunity \\nto migrate your configuration to benefit from the several enhancements\", \" made in .NET.\\nTo migrate from an old-style app.config to a new configuration file, you should choos\", \"e between an \\nXML format and a JSON format.\\nIf you choose XML, the conversion is straightforward. Si\", \"nce the content is the same, just save the \\napp.config file with XML as type. Then, change the code \", \"that references AppSettings to use the \\nConfigurationBuilder class. This change should be easy.\\nIf y\", \"ou want to use a JSON format and you don\\u2019t want to migrate by hand, there\\u2019s a tool called dotnet\\u0002con\", \"fig2json that can convert an app.config file to a JSON configuration file.\\nYou may come across some \", \"issues when using configuration sections that were defined in the \\nmachine.config file. For example,\", \" consider the following configuration:18 CHAPTER 3 | Migrating Modern Desktop applications\\n<configur\", \"ation>\\n <system.diagnostics>\\n <switches>\\n <add name=\\\"General\\\" value=\\\"4\\\" />\\n </switches>\\n <trace auto\", \"flush=\\\"true\\\" indentsize=\\\"2\\\">\\n <listeners>\\n <add name=\\\"myListener\\\"\\n type=\\\"System.Diagnostics.TextWrit\", \"erTraceListener,\\n System, Version=1.0.3300.0, Culture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\"\\n in\", \"itializeData=\\\"MyListener.log\\\"\\ntraceOutputOptions=\\\"ProcessId, LogicalOperationStack, Timestamp, \\nThre\", \"adId, Callstack, DateTime\\\" />\\n </listeners>\\n </trace>\\n </system.diagnostics>\\n</configuration>\\nIf you\", \" take this configuration to a .NET app, you\\u2019ll get an exception:\\nUnrecognized configuration section \", \"System.Diagnostics\\nThis exception occurs because that section and the assembly responsible for handl\", \"ing that section \\nwas defined in the machine.config file, which now doesn\\u2019t exist.\\nTo easily fix the\", \" issue, you can copy the section definition from your old machine.config to your new \\nconfiguration \", \"file:\\n<configSections>\\n <section name=\\\"system.diagnostics\\\"\\n type=\\\"System.Diagnostics.SystemDiagnosti\", \"csSection,\\n System, Version=4.0.0.0, Culture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\"/>\\n</configSe\", \"ctions>\\nAccessing databases\\nAlmost every desktop application needs some kind of database. For deskto\", \"p, it\\u2019s common to find \\nclient-server architectures with a direct connection between the desktop app\", \" and the database \\nengine. These databases can be local or remote depending on the need to share inf\", \"ormation between \\ndifferent users.\\nFrom the code perspective, there have been many technologies and \", \"frameworks to give the developer \\nthe possibility to connect, query, and update a database.\\nThe most\", \" common examples of database you can find when talking about Windows Desktop \\napplication are Micros\", \"oft Access and Microsoft SQL Server. If you have more than 20 years of \\nexperience programming for t\", \"he desktop, names like ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ, and \\nEntity Framework will sound famili\", \"ar.19 CHAPTER 3 | Migrating Modern Desktop applications\\nODBC\\nYou can continue to use ODBC on .NET si\", \"nce Microsoft is providing the System.Data.Odbc library \\ncompatible with .NET Standard 2.0.\\nOLE DB\\nO\", \"LE DB has been a great way to access various data sources in a uniform manner. But it was based on \\n\", \"COM, which is a Windows-only technology, and as such wasn\\u2019t the best fit for a cross-platform \\ntechn\", \"ology such as .NET. It\\u2019s also unsupported in SQL Server versions 2014 and later. For those \\nreasons,\", \" OLE DB won\\u2019t be supported by .NET.\\nADO.NET\\nYou can still use ADO.NET from your existing desktop cod\", \"e on .NET. You just need to update some \\nNuGet packages.\\nEF Core vs. EF6\\nThere are two currently sup\", \"ported versions of Entity Framework (EF), Entity Framework 6 (EF6) and EF \\nCore.\\nThe latest technolo\", \"gy released as part of the .NET Framework world is Entity Framework, with 6.4 \\nbeing the latest vers\", \"ion. With the launch of .NET Core, Microsoft also released a new data access stack \\nbased on Entity \", \"Framework and called Entity Framework Core.\\nYou can use EF 6.4 and EF Core from both .NET Framework \", \"and .NET. So, what are the decision drivers \\nto help to decide between the two?\\nEF 6.3 is the first \", \"version of EF6 that can run on .NET and work cross-platform. In fact, the main goal of \\nthis release\", \" was to make it easier to migrate existing applications that use EF6 to .NET.\\nEF Core was designed t\", \"o provide a developer experience similar to EF6. Most of the top-level APIs \\nremain the same, so EF \", \"Core will feel familiar to developers who have used EF6.\\nAlthough compatible, there are differences \", \"on the implementation you should check before making a \\ndecision. For more information, see Compare \", \"EF Core & EF6.\\nThe recommendation is to use EF Core if:\\n\\u2022 The app needs the capabilities of .NET.\\n\\u2022 \", \"EF Core supports all of the features that the app requires.\\nConsider using EF6 if both of the follow\", \"ing conditions are true:\\n\\u2022 The app will run on Windows and .NET Framework 4.0 or later.\\n\\u2022 EF6 suppor\", \"ts all of the features that the app requires.20 CHAPTER 3 | Migrating Modern Desktop applications\\nRe\", \"lational databases\\nSQL Server\\nSQL Server has been one of the databases of choice if you were develop\", \"ing for the desktop some \\nyears ago. With the use of System.Data.SqlClient in .NET Framework, you co\", \"uld access versions of SQL \\nServer, which encapsulates database-specific protocols.\\nIn .NET, you can\", \" find a new SqlClient class, fully compatible with the one existing in the .NET \\nFramework but locat\", \"ed in the Microsoft.Data.SqlClient library. You just have to add a reference to the \\nMicrosoft.Data.\", \"SqlClient NuGet package and do some renaming for the namespaces and everything \\nshould work as expec\", \"ted.\\nMicrosoft Access\\nMicrosoft Access has been used for years when the sophisticated and more scala\", \"ble SQL Server wasn\\u2019t \\nneeded. You can still connect to Microsoft Access using the System.Data.Odbc \", \"library.\\nConsuming services\\nWith the rise of service-oriented architectures, desktop applications be\", \"gan to evolve from a client\\u0002server model to the three-layer approach. In the client-server approach,\", \" a direct database connection \\nis established from the client holding the business logic, usually in\", \"side a single EXE file. On the other \\nhand, the three-layer approach establishes an intermediate ser\", \"vice layer implementing business logic \\nand database access, allowing for better security, scalabili\", \"ty, and reusability. Instead of working \\ndirectly with underlying data, the layered approach relies \", \"on a set of services implementing contracts \\nand typed objects for data transfer.\\nIf you have a desk\", \"top application using a WCF service and you want to migrate it to .NET, there are \\nsome things to co\", \"nsider.\\nThe first thing is how to resolve the configuration to access the service. Because the confi\", \"guration is \\ndifferent on .NET, you\\u2019ll need to make some updates in your configuration file.\\nSecond,\", \" you\\u2019ll need to regenerate the service client with the new tools present on Visual Studio 2019 \\nand \", \"Visual Studio 2022. In this step, you must consider activating the generation of the synchronous \\nop\", \"erations to make the client compatible with your existing code.\\nAfter the migration, if you find tha\", \"t there are libraries you need that aren\\u2019t present on .NET, you can \\nadd a reference to the Microsof\", \"t.Windows.Compatibility NuGet package and see if the missing \\nfunctions are there.\\nIf you\\u2019re using t\", \"he WebRequest class to perform web service calls, you may find some differences on \\n.NET. The recomm\", \"endation is to use HttpClient instead.21 CHAPTER 3 | Migrating Modern Desktop applications\\nConsuming\", \" a COM Object\\nCurrently, there\\u2019s no way to add a reference to a COM object from Visual Studio 2019 o\", \"r Visual Studio \\n2022 to use with .NET. So, you have to manually modify the project file.\\nInsert a C\", \"OMReference structure inside the project file like in the following example:\\n<ItemGroup>\\n <COMRefere\", \"nce Include=\\\"MSHTML\\\">\\n <Guid>{3050F1C5-98B5-11CF-BB82-00AA00BDCE0B}\\\\</Guid>\\n <VersionMajor>4</Versio\", \"nMajor>\\n <VersionMinor>0</VersionMinor>\\n <Lcid>0</Lcid>\\n <WrapperTool>primary</WrapperTool>\\n <Isolat\", \"ed>false</Isolated>\\n </COMReference>\\n</ItemGroup>\\nMore things to consider\\nSeveral technologies avail\", \"able to .NET Framework libraries aren\\u2019t available for .NET Core or .NET 7. If \\nyour code relies on s\", \"ome of these technologies, consider the alternative approaches outlined in this \\nsection.\\nThe Window\", \"s Compatibility Pack provides access to APIs that were previously available only for .NET \\nFramework\", \". It can be used on .NET Core and .NET Standard projects.\\nFor more information on API compatibility,\", \" you can find documentation about breaking changes and \\ndeprecated/legacy APIs at https://learn.micr\", \"osoft.com/dotnet/core/compatibility/fx-core.\\nAppDomains\\nApplication domains (AppDomains) isolate app\", \"s from one another. AppDomains require runtime \\nsupport and are expensive. Creating additional app d\", \"omains isn\\u2019t supported. For code isolation, we \\nrecommend separate processes or using containers as \", \"an alternative. For the dynamic loading of \\nassemblies, we recommend the new AssemblyLoadContext cla\", \"ss.\\nTo make code migration from .NET Framework easier, .NET exposes some of the AppDomain API \\nsurfa\", \"ce. Some of the APIs function normally (for example, AppDomain.UnhandledException), some \\nmembers do\", \" nothing (for example, SetCachePath), and some of them throw \\nPlatformNotSupportedException (for exa\", \"mple, CreateDomain).\\nRemoting\\n.NET Remoting was used for cross-AppDomain communication, which is no \", \"longer supported. Also, \\nRemoting requires runtime support, which is expensive to maintain. For thes\", \"e reasons, .NET Remoting \\nisn\\u2019t supported on .NET.\\nFor communication across processes, you should co\", \"nsider inter-process communication (IPC) \\nmechanisms as an alternative to Remoting, such as the or t\", \"he MemoryMappedFile class.22 CHAPTER 3 | Migrating Modern Desktop applications\\nAcross machines, use \", \"a network-based solution as an alternative. Preferably, use a low-overhead \\nplaintext protocol, such\", \" as HTTP. The Kestrel web server, the web server used by ASP.NET Core, is an \\noption here.\\nCode Acce\", \"ss Security (CAS)\\nSandboxing, which relies on the runtime or the framework to constrain which resour\", \"ces a managed \\napplication or library uses or runs, isn\\u2019t supported on .NET.\\nUse security boundaries\", \" that are provided by the operating system, such as virtualization, containers, \\nor user accounts, f\", \"or running processes with the minimum set of privileges.\\nSecurity Transparency\\nSimilar to CAS, Secur\", \"ity Transparency separates sandboxed code from security critical code in a \\ndeclarative fashion but \", \"is no longer supported as a security boundary.\\nUse security boundaries that are provided by the oper\", \"ating system, such as virtualization, containers, \\nor user accounts, for running processes with the \", \"least set of privileges.23 CHAPTER 4 | Windows 10 migration\\nCHAPTER 4\\nWindows 10 migration\\nConsider \", \"the following situation: You have a working desktop application that was developed in the \\nWindows 7\", \" days. It\\u2019s using WPF technology available at that time and working fine but it has an \\noutdated UI \", \"and behaviors when you run it on Windows 10 or Windows 11. It is like when you watch a \\nfuturistic m\", \"ovie like Matrix and you see Neo using the Nokia 8110 device. The film works great after \\n20 years b\", \"ut it would rather benefit from a device modernization.\\nWith the release of Windows 10, Microsoft in\", \"troduced many innovations to support scenarios like \\ntablets and touch devices and to provide the be\", \"st experience for users for a Microsoft operating \\nsystem ever. For example, you can:\\n\\u2022 Sign in with\", \" your face using Windows Hello.\\n\\u2022 Use a pen to draw or handwrite text that is automatically recogniz\", \"ed and digitalized.\\n\\u2022 Run locally customized AI models built on the cloud using WinML.\\nAll these fea\", \"tures are enabled for Windows developers through Windows Runtime (WinRT) libraries. \\nYou can take ad\", \"vantage of these features in your existing desktop apps because the libraries are \\nexposed to both t\", \"he .NET Framework and .NET as well. You can even modernize your UI with the use \\nof XAML Islands and\", \" improve the visuals and behavior of your apps according to the times.\\nOne important thing to note h\", \"ere is that you don\\u2019t need to abandon .NET Framework technology to \\nfollow this modernization path. \", \"You can safely stay on there and have all the benefits of Windows 10 \\nand Windows 11 without the pre\", \"ssure to migrate to .NET. So, you get both the power and the \\nflexibility to choose your modernizati\", \"on path.\\nWinRT APIs\\nWinRT APIs are object-oriented, well-structured application programming interfac\", \"es (APIs) that give \\nWindows 10 and Windows 11 developers access to everything the operating system \", \"has to offer. \\nThrough WinRT APIs, you can integrate functionalities like Push Notifications, Device\", \" APIs, Microsoft \\nInk, and WinML, among others on your desktop apps.\\nIn general, WinRT APIs can be c\", \"alled from a classic desktop app. However, two main areas present an \\nexception to this rule:\\n\\u2022 APIs\", \" that require a package identity.\\n\\u2022 APIs that require visualization like XAML or Composition.24 CHAP\", \"TER 4 | Windows 10 migration\\nUniversal Windows Platform (UWP) packages\\nApplication Package Identity\\n\", \"UWP apps have a deployment system where the OS manages the installation and uninstallation of \\nappli\", \"cation. That requires the installation to be declarative, meaning that no user code is executed \\ndur\", \"ing install. Instead, everything the app wants to integrate with the system, such as protocols, file\", \" \\ntypes, and extensions, is declared in the application manifest. At deployment time, the deployment\", \" \\npipeline configures those integration points. The only way for the OS to manage all this functiona\", \"lity \\nand keep track of it is for each \\u2018package\\u2019 to have an identity, a unique identifier for the ap\", \"plication.\\nSome WinRT APIs require this package identity to work as expected. However, classic deskt\", \"op apps \\nlike native C++ or .NET apps, use different deployment systems that don\\u2019t require a package\", \" identity. \\nIf you want to use these WinRT APIs in your desktop application, you need to provide the\", \"m a package \\nidentity.\\nOne way to proceed is to build an additional packaging project. Inside the pa\", \"ckaging project, you \\npoint to the original source code project and specify the Identity information\", \" you want to provide. If \\nyou install the package and run the installed app, it will automatically g\", \"et an identify enabling your \\ncode to call all WinRT APIs requiring Identity.\\n<?xml version=\\\"1.0\\\" en\", \"coding=\\\"utf-8\\\"?>\\n<Package xmlns=\\\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\\\"\\n x\", \"mlns:uap=\\\"http://schemas.microsoft.com/appx/manifest/uap/windows10\\\">\\n <Identity Name=\\\"YOUR-APP-GUID \", \"\\\"\\n Publisher=\\\"CN=YOUR COMPANY\\\"\\n Version=\\\"1.x.x.x\\\" />\\n</Package>\\nYou can check which APIs need a pack\", \"aged application identity by inspecting if the type that contains \\nthe API is marked with the DualAp\", \"iPartition attribute. If it is, you can call if from an unpackaged \\ntraditional desktop app. Otherwi\", \"se, you must convert your classic desktop app to a UWP with the help \\nof a packaging project.\\nhttps:\", \"//learn.microsoft.com/windows/desktop/apiindex/uwp-apis-callable-from-a-classic-desktop-app\\nBenefits\", \" of packaging\\nBesides giving you access to these APIs, you get some additional benefits by creating \", \"a Windows App \\npackage for your desktop application including:\\n\\u2022 Streamlined deployment. Apps have a\", \" great deployment experience ensuring that users can \\nconfidently install an application and update \", \"it. If a user chooses to uninstall the app, it\\u2019s \\nremoved completely with no trace left behind preve\", \"nting the Windows rot problem.\\n\\u2022 Automatic updates and licensing. Your application can participate i\", \"n the Microsoft Store\\u2019s \\nbuilt-in licensing and automatic update facilities. Automatic update is a h\", \"ighly reliable and \\nefficient mechanism, because only the changed parts of files are downloaded.25 C\", \"HAPTER 4 | Windows 10 migration\\n\\u2022 Increased reach and simplified monetization. Maybe not your case b\", \"ut if you choose to \\ndistribute your application through the Microsoft Store you reach millions of W\", \"indows 10 and \\nWindows 11 users.\\n\\u2022 Add UWP features. You can add UWP features to your app\\u2019s package \", \"at your own pace.\\nPrepare for packaging\\nBefore proceeding to package your desktop application, there\", \" are some points you have to address \\nbefore starting the process. Your application must respect any\", \" of the Microsoft Store rules and \\npolicies and run in the UWP application model. For example, it ha\", \"s to run on the .NET Framework 4.6.2 \\nor later and writes to the HKEY_CURRENT_USER registry hive and\", \" the AppData folders will be \\nvirtualized to a user-specific app-local location.\\nThe design goal for\", \" packaging is to separate the application state from system state while maintaining \\ncompatibility w\", \"ith other apps. Windows 10 and Windows 11 accomplish this goal by placing the \\napplication inside a \", \"UWP package. It detects and redirects some changes to the file system and \\nregistry at run time to f\", \"ulfill the promise of a trusted and clean install and uninstall behavior of an \\napplication provided\", \" by packaging.\\nPackages that you create for your desktop application are desktop-only, full-trust ap\", \"plications that \\naren\\u2019t sandboxed, although there\\u2019s lightweight virtualization applied to the app fo\", \"r writes to HKCU \\nand AppData. This virtualization allows them to interact with other apps the same \", \"way classic desktop \\napplications do.\\nInstallation\\nApp packages are installed under %ProgramFiles%\\\\W\", \"indowsApps\\\\package_name, with the executable \\ntitled app_name.exe. Each package folder contains a ma\", \"nifest (named AppxManifest.xml) that contains \\na special XML namespace for packaged apps. Inside tha\", \"t manifest file is an <EntryPoint> element, \\nwhich references the full-trust app. When that applicat\", \"ion is launched, it doesn\\u2019t run inside an app \\ncontainer, but instead it runs as the user as it norm\", \"ally would.\\nAfter deployment, package files are marked read-only and heavily locked down by the oper\", \"ating \\nsystem. Windows prevents apps from launching if these files are tampered with.\\nFile system\\nTh\", \"e OS supports different levels of file system operations for packaged desktop applications, \\ndependi\", \"ng on the folder location.\\nWhen trying to access the user\\u2019s AppData folder, the system creates a pri\", \"vate per-user, per-app \\nlocation behind the scenes. This creates the illusion that the packaged appl\", \"ication is editing the real \\nAppData when it\\u2019s actually modifying a private copy. By redirecting wri\", \"tes this way, the system can \\ntrack all file modifications made by the app. It can then clean all th\", \"ose files when uninstalling reducing \\nsystem \\u201crot\\u201d and providing a better application removal experi\", \"ence for the user.26 CHAPTER 4 | Windows 10 migration\\nRegistry\\nApp packages contain a registry.dat f\", \"ile, which serves as the logical equivalent of HKLM\\\\Software in \\nthe real registry. At run time, thi\", \"s virtual registry merges the contents of this hive into the native \\nsystem hive to provide a singul\", \"ar view of both.\\nAll writes are kept during package upgrade and only deleted when the application is\", \" uninstalled.\\nUninstallation\\nWhen the user uninstalls a package, all files and folders located under\", \" C:\\\\Program \\nFiles\\\\WindowsApps\\\\package_name are removed, as well as any redirected writes to AppData\", \" or the \\nregistry that were captured during the process.\\nFor details about how a packaged applicatio\", \"n handles installation, file access, registry, and \\nuninstallation, see https://learn.microsoft.com/\", \"windows/msix/desktop/desktop-to-uwp-behind-the\\u0002scenes.\\nYou can get a complete list of things to chec\", \"k on \\nhttps://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-prepare.\\nHow to add WinRT APIs\", \" to your desktop project\\nIn this section, you can find a walkthrough on how to integrate Toast Notif\", \"ications in an existing WPF \\napplication. Although it\\u2019s simple from the code perspective, it helps i\", \"llustrate the whole process. \\nNotifications are one of the many available WinRT APIs available that \", \"you can use in .NET app. In this \\ncase, the API requires a Package Identity. This process is more st\", \"raightforward if the APIs don\\u2019t require \\nPackage Identity.\\nLet\\u2019s take an existing WPF sample app tha\", \"t reads files and shows its contents on the screen. The goal \\nis to display a Toast Notification whe\", \"n the application starts.27 CHAPTER 4 | Windows 10 migration\\nFirst, you should check in the followin\", \"g link whether the Windows 10 or Windows 11 API that you\\u2019ll \\nuse requires a Package Identity:\\nhttps:\", \"//learn.microsoft.com/windows/apps/desktop/modernize/desktop-to-uwp-supported-api\\nOur sample will us\", \"e the Windows.UI.Notifications.Notification API that requires a packaged identity:\\nTo access the Win\", \"RT API, add a reference to the Microsoft.Windows.SDK.Contracts NuGet package \\nand this package will \", \"do the magic behind the scenes (see details at \\nhttps://blogs.windows.com/windowsdeveloper/2019/04/3\", \"0/calling-windows-10-apis-from-a-desktop\\u0002application-just-got-easier/).\\nYou\\u2019re now prepared to start\", \" adding some code.28 CHAPTER 4 | Windows 10 migration\\nCreate a ShowToastNotification method that wil\", \"l be called on application startup. It just builds a toast \\nnotification from an XML pattern:\\nprivat\", \"e void ShowNotification(string title, string content, string image)\\n{\\n string xmlString = $@\\\"<toast>\", \"<visual><binding template = \\n'ToastGeneric'><text>{title}</text><text>{content}</text><image \\nsrc=>'\", \"{image}'</image></binding></visual></toast>\\\";\\n XmlDocument toastXml = new XmlDocument();\\n toastXml.L\", \"oadXml(xmlString);\\n ToastNotification toast = new ToastNotification(toastXml);\\n ToastNotificationMan\", \"ager.CreateToastNotifier().Show(toast);\\n}\\nAlthough the project builds, there are errors because the \", \"Notifications API requires a Package Identity \\nand you didn\\u2019t provide it. Adding a Windows Packaging\", \" Project to the solution will fix the issue:\\nSelect the minimum Windows version you want to support \", \"and the version you\\u2019re targeting. Not all \\nthe WinRT APIs are supported in all Windows 10 and Window\", \"s 11 versions. Each Windows 10 or \\nWindows 11 update adds new APIs that are only available from this\", \" version; down-level support isn\\u2019t \\navailable.29 CHAPTER 4 | Windows 10 migration\\nNext step is to ad\", \"d the WPF application to the Windows Packaging Project by adding a project \\nreference:30 CHAPTER 4 |\", \" Windows 10 migration\\nA Windows Packaging Project can package several apps so you should set which o\", \"ne is the Entry \\nPoint:31 CHAPTER 4 | Windows 10 migration\\nNext step is to set the WPF Project as th\", \"e startup Project in the solution configuration. You can press \\nF5 to compile and build and see the \", \"results.\\nLet\\u2019s generate the package so you can install your app. Right click on Store > Create App P\", \"ackages.32 CHAPTER 4 | Windows 10 migration\\nSelect the sideloading option to deploy the app from you\", \"r machine:33 CHAPTER 4 | Windows 10 migration\\nSelect the application architecture of your app:34 CHA\", \"PTER 4 | Windows 10 migration\\nFinally, create the package by clicking on Create.\\nXAML Islands\\nXAML I\", \"slands are a set of components that enable Windows desktop developers to use UWP XAML \\ncontrols on t\", \"heir existing Win32 applications, including Windows Forms and WPF.35 CHAPTER 4 | Windows 10 migratio\", \"n\\nYou can image your Win32 app with your standard controls and among them an \\u201cisland\\u201d of UWP UI \\ncon\", \"taining controls from the modern world. The concept is similar to having an iFrame inside a web \\npag\", \"e that shows content from a different page.\\nBesides adding functionality from the Windows 10 and Win\", \"dows 11 APIs, you can add pieces of UWP \\nXAML inside of your app using XAML Islands.\\nWindows 10 1903\", \" update introduced a set of APIs that allow hosting UWP XAML content in Win32 \\nwindows. Only apps ru\", \"nning on Windows 10 1903 or later can use XAML Islands.\\nThe road to XAML Islands\\nThe road to XAML Is\", \"lands started in 2012 when Microsoft introduced the WinRT APIs as a framework \\nto modernize the Win3\", \"2 apps (Windows Forms, WPF, and native Win32 apps). However, the new UI \\ncontrols inside WinRT were \", \"available for new applications but not for existing ones.\\nIn 2015, along with Windows 10, UWP was bo\", \"rn. UWP allows you to create apps that work across \\nWindows devices like XBox, Mobile, and Desktop. \", \"One year later, Microsoft announced Desktop \\nBridge (formerly known as Project Centennial). Desktop \", \"Bridge is a set of tools that allowed \\ndevelopers to bring their existing Win32 apps to the Microsof\", \"t Store. More capabilities were added in \\n2017, allowing developers to enhance their Win32 apps leve\", \"raging some of the new Windows 10 APIs, \\nlike live tiles and notifications on the action center. But\", \" still, no new UI controls.\\nAt Build 2018, Microsoft announced a way for developers to use the new W\", \"indows 10 XAML controls \\ninto their current Win32 apps, without fully migrating their apps to UWP. I\", \"t was branded as UWP \\nXAML Islands.\\nHow it works\\nThe Windows 10 1903 update introduced several XAML \", \"hosting APIs. Two of them are \\nWindowsXamlManager and DesktopWindowXamlSource.36 CHAPTER 4 | Windows\", \" 10 migration\\nThe WindowsXamlManager class handles the UWP XAML Framework. Its InitializeForCurrentT\", \"hread \\nmethod loads the UWP XAML Framework inside the current thread of the Win32 app.\\nThe DesktopWi\", \"ndowXamlSource is the instance of your XAML Island content. It has the Content \\nproperty, which you\\u2019\", \"re responsible for instantiating and setting. The DesktopWindowXamlSource \\nrenders and gets its inpu\", \"t from an HWND. It needs to know to which other HWND it will attach the \\nXAML Island\\u2019s one, and you\\u2019\", \"re responsible for sizing and positioning the parent\\u2019s HWND.\\nWPF or Windows Forms developers don\\u2019t u\", \"sually deal with HWND inside their code, so it may be hard \\nto understand and handle HWND pointers a\", \"nd the underlying wiring stuff to communicate Win32 and \\nUWP worlds.\\nThe XAML Islands .NET Wrappers\\n\", \"The Windows Community Toolkit has a set the XAML Islands .NET wrappers for WPF or Windows \\nForms tha\", \"t make easier to use XAML Islands. These wrappers manage the HWNDs, the focus \\nmanagement, among oth\", \"er things. Windows Forms and WPF developers should use these wrappers.\\nThe Windows Community Toolkit\", \" offers two types of controls: Wrapped Controls and Hosting \\nControls.\\nWrapped Controls\\nThese wrappe\", \"d controls wrap some UWP controls into Windows Forms or WPF controls, hiding UWP \\nconcepts for those\", \" developers. These controls are:\\n\\u2022 WebView and WebViewCompatible\\n\\u2022 InkCanvas and InkToolbar\\n\\u2022 MediaP\", \"layerElement\\n\\u2022 MapControl\\nAdd the Microsoft.Toolkit.Wpf.UI.Controls package to your project, include\", \" the reference to the \\nnamespace, and start using them.\\n<Window\\n ...\\n xmlns:uwpControls=\\\"clr\\u0002namespa\", \"ce:Microsoft.Toolkit.Wpf.UI.Controls;assembly=Microsoft.Toolkit.Wpf.UI.Controls\\\">\\n<Grid>\\n <Grid.RowD\", \"efinitions>\\n <RowDefinition Height=\\\"Auto\\\"/>\\n <RowDefinition Height=\\\"\\\\*\\\"/>\\n </Grid.RowDefinitions>\\n <\", \"uwpControls:InkToolbar TargetInkCanvas=\\\"{x:Reference Name=inkCanvas}\\\"/>\\n <uwpControls:InkCanvas Grid\", \".Row=\\\"1\\\" x:Name=\\\"inkCanvas\\\" />\\n</Grid>\\nHosting controls\\nThe power of XAML Islands extends to most fi\", \"rst-party controls, third-party controls, and custom \\ncontrols developed for UWP, which can be integ\", \"rated into Windows Forms and WPF as \\u201cIslands\\u201d with \\nfully functional UI. The WindowsXamlHost control\", \" for WPF and Windows Forms allows doing this.37 CHAPTER 4 | Windows 10 migration\\nFor example, to use\", \" the WindowsXamlHost control in WPF, add a reference to the \\nMicrosoft.Toolkit.Wpf.UI.XamlHost packa\", \"ge provided by the Windows Community Toolkit.\\nOnce you\\u2019ve placed your WindowsXamlHost into your UI c\", \"ode, specify which UWP type you want to \\nload. You can choose to use a wrapped control like a Button\", \" or a more complex one composed of \\nseveral different controls, which are a custom UWP control.\\nThe \", \"following example shows how to add a UWP Button:\\n<Window\\n ...\\n xmlns:xamlhost=\\\"clr\\u0002namespace:Microso\", \"ft.Toolkit.Wpf.UI.XamlHost;assembly=Microsoft.Toolkit.Wpf.UI.XamlHost\\\">\\n<xamlhost:WindowsXamlHost x:\", \"Name=\\\"myUwpButton\\\"\\n InitialTypeName=\\\"Windows.UI.Xaml.Controls.Button\\\" />\\nThere\\u2019s a clear recommendat\", \"ion on how to approach this and it\\u2019s better to have one single and bigger \\nXAML Island containing a \", \"custom composite control than to have several islands with one control on \\neach.\\nOne of the core fea\", \"tures of XAML is binding and it works between your Win32 code and the island. \\nSo, you can bind, for\", \" instance, a Win32 Textbox with a UWP Textbox. One important thing to consider \\nis that these bindin\", \"gs are one-way bindings, from UWP to Win32, so if you update the Textbox inside \\nthe XAML Island the\", \" Win32 Textbox will be updated, but not the other way around.\\nTo see a walkthrough about how to use \", \"XAML Islands, see:\\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/host-standard-control-\", \"with-xaml\\u0002islands\\nAdding UWP XAML custom controls\\nA XAML custom control is a control (or user contro\", \"l) created by you or by third parties (including \\nWinUI 2.x controls). To host a custom UWP control \", \"in a Windows Forms or WPF app, you\\u2019ll need:\\n\\u2022 To use the WindowsXamlHost UWP control in your .NET ap\", \"p.\\n\\u2022 To create a UWP app project that defines a XamlApplication object.\\nYour WPF or Windows Forms pr\", \"oject must have access to an instance of the \\nMicrosoft.Toolkit.Win32.UI.XamlHost.XamlApplication cl\", \"ass provided by the Windows Community \\nToolkit. This object acts as a root metadata provider for loa\", \"ding metadata for custom UWP XAML \\ntypes in assemblies in the current directory of your application.\", \" The recommended way to do this is to \\nadd a Blank App (Universal Windows) project to the same solut\", \"ion as your WPF or Windows Forms \\nproject and revise the default App class in this project.\\nThe cust\", \"om UWP XAML control can be included on this UWP app or in an independent UWP Class \\nLibrary project \", \"that you reference in the same solution as your WPF or Windows Forms project.\\nYou can check a detail\", \"ed step-by-step process description at:\\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/h\", \"ost-custom-control-with-xaml\\u0002islands38 CHAPTER 4 | Windows 10 migration\\nThe Windows UI Library (WinU\", \"I 2)\\nBesides the inbox Windows 10 controls that comes with the OS, the same UWP XAML team also \\ndeli\", \"vers additional controls in the Windows UI Library (WinUI 2). WinUI 2 provides official native \\nMicr\", \"osoft UI controls and features for Windows UWP apps and these controls can be used inside of \\nXAML I\", \"slands.\\nWinUI 2 is open source and you can find information at https://github.com/microsoft/microsof\", \"t-ui\\u0002xaml.\\nThe following article demonstrates how to host a UWP XAML control from the WinUI 2 librar\", \"y: \\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml\\u0002islands\", \"\\nDo you need XAML Islands\\nXAML Islands are intended for existing Win32 apps that want to improve the\", \"ir user experience by \\nleveraging new UWP controls and behaviors without a full rewrite of the app. \", \"You could already \\nleverage Windows 10 and Windows 11 APIs, but up until XAML Islands, only non-UI r\", \"elated APIs.\\nIf you\\u2019re developing a new Windows App, a UWP App is probably the right approach.\\nThe r\", \"oad ahead XAML Islands: WinUI 3.0\\nSince Windows 8, the Windows UI platform, including the XAML UI fr\", \"amework, visual composition \\nlayer, and input processing has been shipped as an integral part of Win\", \"dows. This means that to \\nbenefit from the latest improvements on UI technologies, you must upgrade \", \"to the latest version of \\nthe UI, slowing down the pace of innovation when you develop your apps. To\", \" decouple these two \\nevolution cycles and foster innovation, Microsoft is actively working on the Wi\", \"nUI project.\\nStarting with WinUI 2 in 2018, Microsoft started shipping some new XAML UI controls and\", \" features as \\nseparate NuGet packages that build on top of the UWP SDK.39 CHAPTER 4 | Windows 10 mig\", \"ration\\nWinUI 3 is under active development and will greatly expand the scope of WinUI to include the\", \" full UI \\nplatform, which will be fully decoupled from the UWP SDK:\\nXAML framework will now be devel\", \"oped on GitHub and shipped out of band as NuGet packages.\\nThe existing UWP XAML APIs that ship as pa\", \"rt of the OS will no longer receive new feature updates. \\nThey will still receive security updates a\", \"nd critical fixes according to the Windows 10 support lifecycle.\\nThe Universal Windows Platform cont\", \"ains more than just the XAML framework (for example, \\napplication and security model, media pipeline\", \", Xbox and Windows 10 shell integrations, broad device \\nsupport) and will continue to evolve. All ne\", \"w XAML features will just be developed and ship as part of \\nWinUI instead.\\nWinUI 3 in desktop app an\", \"d WinUI XAML Islands\\nAs you can see, WinUI 3 is the evolution of UWP XAML and it works naturally wit\", \"hin the UWP app \\nmodel and all its requirements (MSIX packaged ID, sandbox, CoreWindow, and so on. T\", \"o use just \\nWinUI 3 in a Win32 app model, the WinUI content should be hosted by another UI Framework\", \" \\n(Windows Forms, WPF, and so on) using WinUI XAML Islands. This is the right path if you want to 40\", \" CHAPTER 4 | Windows 10 migration\\nevolve your app and mix technologies. However, if you want to repl\", \"ace your entire old UI for WinUI, \\nyour app shouldn\\u2019t load UI Frameworks for just hosting WinUI.\\nWin\", \"UI 3 will address this critical feedback adding WinUI in desktop apps. This will allow that Win32 \\na\", \"pps can use WinUI 3 as standalone UI Framework; no need to load Windows Forms or WPF.\\nWithin this ag\", \"gregation, WinUI 3 will let developers easily mix and match the right combination of:\\n\\u2022 App model: U\", \"WP, Win32\\n\\u2022 Platform: .NET or Native\\n\\u2022 Language: .NET (C#, Visual Basic), standard C++\\n\\u2022 Packaging: \", \"MSIX, AppX for the Microsoft Store, unpackaged\\n\\u2022 Interop: use WinUI 3 to extend existing WPF, WinFor\", \"ms, and MFC apps using WinUI XAML \\nIslands.\\nIf you want to know more details, Microsoft is sharing t\", \"his roadmap in \\nhttps://github.com/microsoft/microsoft-ui-xaml/blob/main/docs/roadmap.md.41 CHAPTER \", \"5 | Example of migrating to the latest .NET\\nCHAPTER 5\\nExample of migrating to \\nthe latest .NET\\nIn th\", \"is chapter, we\\u2019ll show how to migrate your applications to the latest version of .NET. You can \\nmigr\", \"ate to .NET 7 from .NET Framework, .NET Core, or .NET 5. We\\u2019ll introduce a tool that can do all the \", \"\\nwork for you in most cases. If your application has special cases or complicated dependencies, we\\u2019l\", \"l \\nalso show how to do the whole migration process by hand. Additionally, we\\u2019ll cover the most commo\", \"n \\nissues and challenges you can face when migrating an existing application from .NET Framework to \", \"\\n.NET.\\nMigrating from .NET Core or .NET 5\\nUpdating your applications to target the latest version of\", \" .NET is easy if you already are on .NET Core \\nor .NET 5. If this is the case, then in Visual Studio\", \", simply right-click on your project in Solution \\nExplorer and choose Properties. Under Application \", \"> General > Target framework, choose .NET \\n7.0. Save and rebuild your application. You\\u2019re done! Your\", \" app now runs on the latest version of .NET. \\nIn the future when new versions become available, you \", \"can upgrade in the same way.42 CHAPTER 5 | Example of migrating to the latest .NET\\nMigrating from .N\", \"ET Framework\\nMigrating from .NET Framework is a more complicated process because there are more diff\", \"erences \\nbetween .NET Framework and other platforms that were built on top of .NET Core. But the goo\", \"d news \\nis that there\\u2019s a tool that will do all the work for you in most cases.\\nMigrating with a too\", \"l\\nThe Upgrade Assistant is a migration tool. Using it is easy and there are step-by-step instruction\", \"s \\navailable on the .NET website. In this chapter, we\\u2019ll look at what is happening behind the scenes\", \" and \\nhow to port your application by hand. When the Upgrade Assistant is unable to migrate your \\nap\", \"plication, you\\u2019ll learn the underlying mechanics so that you might be able to migrate manually.\\nMigr\", \"ating by hand\\nThe migration process consists of four sequential steps:\\n1. Preparation: Understand th\", \"e dependencies the project has to have an idea of what\\u2019s ahead. \\nIn this step, you take the current \", \"project into a state that simplifies the startup point for the \\nmigration.\\n2. Migrate Project File: \", \".NET projects use the new SDK-style project format. Create a new \\nproject file with this format or u\", \"pdate the one you have to use the SDK style.\\n3. Fix code and build: Build the code in .NET addressin\", \"g API-level differences between .NET \\nFramework and .NET. If needed, update third-party packages to \", \"the ones that support .NET.43 CHAPTER 5 | Example of migrating to the latest .NET\\n4. Run and test: T\", \"here might be differences that don\\u2019t show up until run time. So, don\\u2019t forget \\nto run the applicatio\", \"n and test that everything works as expected.\\nPreparation\\nMigrate packages.config file\\nIn a .NET Fra\", \"mework application, all references to external packages are declared in the \\npackages.config file. I\", \"n .NET, there\\u2019s no longer the need to use the packages.config file. Instead, use the \\nPackageReferen\", \"ce property inside the project file to specify the NuGet packages for your app.\\nSo, you need to tran\", \"sition from one format to another. You can do the update manually, taking the \\ndependencies containe\", \"d in the packages.config file and migrating them to the project file with the \\nPackageReference form\", \"at. Or, you can let Visual Studio do the work for you: right-click on the \\npackages.config file and \", \"select the Migrate packages.config to PackageReference option.\\nVerify every dependency compatibility\", \" in .NET\\nOnce you\\u2019ve migrated the package references, you must check each reference for compatibilit\", \"y. You \\ncan explore the dependencies of each NuGet package your application is using on nuget.org. I\", \"f the \\npackage has .NET Standard dependencies, then it\\u2019s going to work on .NET 7 because .NET suppor\", \"ts all \\nversions of .NET Standard. The following image shows the dependencies for the Castle.Windsor\", \" \\npackage:\\nTo check the package compatibility, you can use the tool https://fuget.org that offers a \", \"more detailed \\ninformation about versions and dependencies.\\nMaybe the project is referencing older p\", \"ackage versions that don\\u2019t support .NET, but you might find \\nnewer versions that do support it. So, \", \"updating packages to newer versions is generally a good 44 CHAPTER 5 | Example of migrating to the l\", \"atest .NET\\nrecommendation. However, you should consider that updating the package version can introd\", \"uce \\nsome breaking changes that would force you to update your code.\\nWhat happens if you don\\u2019t find \", \"a compatible version? What if you just don\\u2019t want to update the \\nversion of a package because of the\", \"se breaking changes? Don\\u2019t worry because it\\u2019s possible to depend \\non .NET Framework packages from a \", \".NET application. Don\\u2019t forget to test it extensively because it can \\ncause run-time errors if the e\", \"xternal package calls an API that isn\\u2019t available on .NET. This is great for \\nwhen you\\u2019re using an o\", \"ld package that isn\\u2019t going to be updated and you can just retarget to work on \\n.NET.\\nCheck for API \", \"compatibility\\nSince the API surface in .NET Framework and .NET is similar but not identical, you mus\", \"t check which \\nAPIs are available on .NET and which aren\\u2019t. You can use the .NET Portability Analyze\", \"r tool to surface \\nAPIs used that aren\\u2019t present on .NET. It looks at the binary level of your app, \", \"extracts all the APIs that \\nare called, and then lists which APIs aren\\u2019t available on your target fr\", \"amework (.NET 7 in this case).\\nYou can find more information about this tool at:\\nhttps://learn.micro\", \"soft.com/dotnet/standard/analyzers/portability-analyzer\\nAn interesting aspect of this tool is that i\", \"t only surfaces the differences from your own code and not \\ncode from external packages, which you c\", \"an\\u2019t change. Remember you should have updated most of \\nthese packages to make them work with .NET.\\nM\", \"igrate\\n1. Create the new .NET project\\nIn most cases, you\\u2019ll want to update your existing project to \", \"the new .NET format. However, you can \\nalso create a new project while maintaining the old one. The \", \"main drawback from updating the old \\nproject is that you lose designer support, which may be importa\", \"nt to you and your development \\nteam. If you want to keep using the designer, you must create a new \", \".NET project in parallel with the \\nold one and share assets. If you need to modify UI elements in th\", \"e designer, you can switch to the old \\nproject to do that. And since assets are linked, they\\u2019ll be u\", \"pdated in the .NET project as well.\\nThe SDK-style project for .NET is a lot simpler than .NET Framew\", \"ork\\u2019s project format. Apart from the \\npreviously mentioned PackageReference entries, you won\\u2019t need \", \"to do much more. The new project \\nformat includes files with certain extensions by default, such as \", \".cs and .xaml files, without the need to \\nexplicitly include them in the project file.\\nAssemblyInfo \", \"considerations\\nAttributes are autogenerated on .NET projects. If the project contains an AssemblyInf\", \"o.cs file, the \\ndefinitions will be duplicated, which will cause compilation conflicts. You can dele\", \"te the older \\nAssemblyInfo.cs file or disable autogeneration by adding the following entry to the .N\", \"ET project file:\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\">\\n <PropertyGroup>\\n <GenerateAssemblyInfo>false</Ge\", \"nerateAssemblyInfo>45 CHAPTER 5 | Example of migrating to the latest .NET\\n </PropertyGroup>\\n</Projec\", \"t>\\nResources\\nEmbedded resources are included automatically but resources aren\\u2019t, so you need to migr\", \"ate the \\nresources to the new project file.\\nPackage references\\nWith the Migrate packages.config to P\", \"ackageReference option, you can easily move your external \\npackage references to the new format as p\", \"reviously mentioned.\\nUpdate package references\\nUpdate the versions of the packages you\\u2019ve found to b\", \"e compatible, as shown in the previous section.\\nFix the code and build\\nMicrosoft.Windows.Compatibili\", \"ty\\nIf your application depends on APIs that aren\\u2019t available on .NET, such as Registry or ACLs, you \", \"have \\nto include a reference to the Microsoft.Windows.Compatibility package to add these Windows\\u0002spe\", \"cific APIs. They work on .NET but aren\\u2019t included as they aren\\u2019t cross-platform.\\nThere\\u2019s a tool call\", \"ed Platform compatibility analyzer \\n(https://learn.microsoft.com/dotnet/standard/analyzers/platform-\", \"compat-analyzer) that helps you \\nidentify APIs that aren\\u2019t compatible with your code.\\nUse #if direct\", \"ives\\nIf you need different execution paths when targeting .NET Framework and .NET, you should use \\nc\", \"ompilation constants. Add some #if directives to your code to keep the same codebase for both \\ntarge\", \"ts.\\nTechnologies not available on .NET\\nSome technologies aren\\u2019t available on .NET, such as:\\n\\u2022 AppDom\", \"ains\\n\\u2022 Remoting\\n\\u2022 Code Access Security\\n\\u2022 Windows Workflow\\nThat\\u2019s why you need to find a replacement \", \"for these technologies if you\\u2019re using them in your \\napplication. For more information, see the .NET\", \" Framework technologies unavailable on .NET Core and \\n.NET 5+ article.46 CHAPTER 5 | Example of migr\", \"ating to the latest .NET\\nRegenerate autogenerated clients\\nIf your application uses autogenerated cod\", \"e, such as a WCF client, you may need to regenerate this \\ncode to target .NET. Sometimes, you can fi\", \"nd some missing references since they may not be included \\nas part of the default .NET assemblies se\", \"t. Using a tool like https://apisof.net/, you can easily locate \\nthe assembly the missing reference \", \"lives in and add it from NuGet.\\nRolling back package versions\\nAs a general rule, we\\u2019ve previously st\", \"ated that you better update every single package version to be \\ncompatible with .NET. However, you c\", \"an find that targeting an updated and compatible version of an \\nassembly just doesn\\u2019t pay off. If th\", \"e cost of change isn\\u2019t acceptable, you can consider rolling back \\npackage versions keeping the ones \", \"you use on .NET Framework. Although they may not be targeting \\n.NET, they should work well unless th\", \"ey call some unsupported APIs.\\nRun and test\\nOnce you have your application building with no errors, \", \"you can start the last step of the migration by \\ntesting every functionality.\\nIn this final step, yo\", \"u can find several different issues depending on the complexity of your application \\nand the depende\", \"ncies and APIs you\\u2019re using.\\nFor example, if you use configuration files (app.config), you may find \", \"some errors at run time like \\nConfiguration Sections not present. Using the Microsoft.Extensions.Con\", \"figuration NuGet package \\nshould fix that error.\\nAnother reason for errors is the use of the BeginIn\", \"voke and EndInvoke methods because they aren\\u2019t \\nsupported on .NET. They aren\\u2019t supported on .NET bec\", \"ause they have a dependency on Remoting, \\nwhich doesn\\u2019t exist on .NET. To solve this issue, try to u\", \"se the await keyword (when available) or the \\nTask.Run method.\\nYou can use compatibility analyzers t\", \"o let you identify APIs and code patterns in your code that can \\npotentially cause problems at run t\", \"ime with .NET. Go to https://github.com/dotnet/platform-compat\\nand use the .NET API analyzer on your\", \" project.\\nMigrating a Windows Forms application\\nTo showcase a complete migration process of a Window\", \"s Forms application, we\\u2019ve chosen to migrate \\nthe eShop sample application available at https://gith\", \"ub.com/dotnet\\u0002architecture/eShopModernizing/tree/master/eShopLegacyNTier/src/eShopWinForms. You can \", \"find \\nthe complete result of the migration at https://github.com/dotnet\\u0002architecture/eShopModernizin\", \"g/tree/master/eShopModernizedNTier/src/eShopWinForms.\\nThis application shows a product catalog and a\", \"llows the user to navigate, filter, and search for \\nproducts. From an architecture point of view, th\", \"e app relies on an external WCF service that serves as \\na fa\\u00e7ade to a back-end database.\\nYou can see\", \" the main application window in the following picture:47 CHAPTER 5 | Example of migrating to the lat\", \"est .NET\\nIf you open the .csproj project file, you can see something like this:\\nAs previously mentio\", \"ned, a .NET project has a more compact style and you need to migrate the \\nproject structure to the n\", \"ew .NET SDK style.\\nIn Solution Explorer, right-click on the Windows Forms project and select Unload \", \"Project > Edit.\\nNow you can update the .csproj file. You\\u2019ll delete the entire contents and replace i\", \"t with the following \\ncode:\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\">\\n <PropertyGroup>\\n <OutputType>WinExe</\", \"OutputType>\\n <TargetFramework>net7.0-windows</TargetFramework>\\n <UseWindowsForms>true</UseWindowsFor\", \"ms>\\n <GenerateAssemblyInfo>false</GenerateAssemblyInfo>48 CHAPTER 5 | Example of migrating to the la\", \"test .NET\\n </PropertyGroup>\\n</Project>\\nSave and reload the project. You\\u2019re now done updating the pro\", \"ject file and the project is targeting \\n.NET 7.\\nIf you compile the project at this point, you\\u2019ll fin\", \"d some errors related to the WCF client reference. \\nSince this code is autogenerated, you must regen\", \"erate it to target .NET.\\nDelete the Reference.cs file and generate a new Service Client.\\nRight-click\", \" on Connected Services and select the Add Connected Service option.\\nThe Connected Services window op\", \"ens. Select the Microsoft WCF Web Service option.49 CHAPTER 5 | Example of migrating to the latest .\", \"NET\\nIf you have the WCF Service in the same solution as we have in this example, you can select the \", \"\\nDiscover option instead of specifying a service URL.\\nOnce the service is located, the tool reflects\", \" the API contract implemented by the service. Change the \\nname of the namespace to be eShopServiceRe\", \"ference as shown in the following image:50 CHAPTER 5 | Example of migrating to the latest .NET\\nSelec\", \"t the Finish button. After a while, you\\u2019ll see the generated code.\\nYou should see three autogenerate\", \"d files:\\n1. Getting Started: a link to GitHub to provide some information on WCF.\\n2. ConnectedServic\", \"e.json: configuration parameters to connect to the service.\\n3. Reference.cs: the actual WCF client c\", \"ode.51 CHAPTER 5 | Example of migrating to the latest .NET\\nIf you compile again, you\\u2019ll see many err\", \"ors coming from .cs files inside the Helper folder. This folder \\nwas present in the .NET Framework v\", \"ersion but not included in the old .csproj. But with the new SDK\\u0002style project, every code file pres\", \"ent underneath the project file location is included by default. That is, \\nthe new .NET Core project\", \" tries to compile the files inside the Helper folder. Since that folder isn\\u2019t \\nneeded, you can safel\", \"y delete it.\\nIf you compile the project again and execute it, you won\\u2019t see the product images. The \", \"problem is that \\nnow the path to the files has slightly changed. To fix this issue, you need to add \", \"another level of depth \\nin the path, updating in the file CatalogView.cs the line:52 CHAPTER 5 | Exa\", \"mple of migrating to the latest .NET\\nstring image_name = Environment.CurrentDirectory +\\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\A\", \"ssets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems.Picturefilename;\\nto\\nstring image_name = Environment.Current\", \"Directory +\\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems.Picturefilename;\\nAfter this cha\", \"nge, you can check that the application launches and runs as expected on .NET 7.\\nMigrating a WPF app\", \"lication\\nWe\\u2019ll use the Shop.ClassicWPF sample application to perform the migration. The following im\", \"age \\nshows a screenshot of the app before migration:\\nThis application uses a local SQL Server Expres\", \"s database to hold the product catalog information. \\nThis database is accessed directly from the WPF\", \" application.\\nFirst, you must update the .csproj file to the new SDK style used by .NET Core applica\", \"tions. You\\u2019ll \\nfollow the same steps described in the Windows Forms migration: you\\u2019ll unload the pro\", \"ject, open the \\n.csproj file, update its contents, and reload the project.\\nIn this case, delete all \", \"the content of the .csproj file and replace it with the following code:53 CHAPTER 5 | Example of mig\", \"rating to the latest .NET\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\">\\n <PropertyGroup>\\n <OutputType>WinExe</Ou\", \"tputType>\\n <TargetFramework>net7.0-windows</TargetFramework>\\n <UseWpf>true</UseWpf>\\n <GenerateAssemb\", \"lyInfo>false</GenerateAssemblyInfo>\\n </PropertyGroup>\\n</Project>\\nIf you reload the project and compi\", \"le it, you\\u2019ll get the following error:\\nSince you\\u2019ve deleted all the .csproj contents, you\\u2019ve lost a \", \"project reference specification present in the \\nold project. You just need to add this line to the .\", \"csproj file to include the project reference back:\\n<ItemGroup>\\n <ProjectReference Include=\\\"..\\\\\\\\eShop\", \".SqlProvider\\\\\\\\eShop.SqlProvider.csproj\\\" />\\n<ItemGroup>\\nYou can also let Visual Studio help you by ri\", \"ght-clicking on the Dependencies node and selecting \\nAdd Project Reference. Select the project from \", \"the solution and select OK:54 CHAPTER 5 | Example of migrating to the latest .NET\\nOnce you add the m\", \"issing project reference, the application compiles and runs as expected on .NET.55 CHAPTER 6 | Deplo\", \"ying Modern Desktop Applications\\nCHAPTER 6\\nDeploying Modern \\nDesktop Applications\\nWhen you develop d\", \"esktop applications, one thing to consider is how your application is going to be \\npackaged and depl\", \"oyed to the users\\u2019 machines. The problem with packaging, deployment, and \\ninstallation is that it us\", \"ually falls under the umbrella of the IT professionals, who care about different \\nthings than develo\", \"pers.\\nThese days, we\\u2019re all familiar with the DevOps concept, where developers and IT Pros work clos\", \"ely to \\nmove applications to their production environments. But if you\\u2019ve been in the desktop battle\", \" for more \\nthan 10 years, you might have seen the following story. A team of developers works togeth\", \"er hard to \\nmeet the project deadlines. Business people are nervous since they need the system worki\", \"ng on many \\nusers\\u2019 machines to run the company. On \\u201cD-Day\\u201d, the project manager checks with every de\", \"veloper \\nthat their code is working well and that everything is fine, so they can ship. Then, the pa\", \"ckage team \\ncomes in generating the setup for the app, distribute it to every user machine and a set\", \" of test users \\nrun the application. Well, they try, because before showing any UI, the application \", \"throws an \\nexception that says \\u201cMethod ~ of object ~ failed\\u201d. Panic starts flowing through the air a\", \"nd a brief \\ninvestigation points to a young and tired developer that has introduced a third-party co\", \"ntrol, that \\ncertainly \\u201cworked on the dev machine\\u201d.\\nInstalling desktop applications have traditional\", \"ly been a nightmare for two main reasons:\\n\\u2022 Lack of close collaboration culture between dev and IT t\", \"eams.\\n\\u2022 Lack of a solid packaging and deploying technology we can build upon.\\nIn fact, we\\u2019ve been li\", \"ving with the fact that sometimes you regret that you installed an app because:\\n\\u2022 It ends up having \", \"some undesired side effects on your machine.\\n\\u2022 Some applications that were previously installed stop\", \" working.\\nAdditionally, you can\\u2019t just restore the system to its original state by uninstalling the \", \"app. We\\u2019re so \\nused to living with this situation that we\\u2019ve coined terms like \\u201cDLL Hell\\u201d or \\u201cWinrot\", \"\\u201d.\\nIn this chapter, we\\u2019ll talk about MSIX. MSIX is the new technology from Microsoft that tries to c\", \"apture \\nthe best of previous technologies to provide a solid foundation for the packaging technology\", \" of the \\nfuture.\\nWhat does a packaging technology have to do with modernization? Well, it turns out \", \"that packaging \\nis fundamental for the enterprise IT with lots of money invested there. Modernizatio\", \"n isn\\u2019t only related 56 CHAPTER 6 | Deploying Modern Desktop Applications\\nto using the latest techno\", \"logies. It\\u2019s also related to reducing time to market from the moment a \\nbusiness requirement is defi\", \"ned until your company delivers the feature to your client.\\nThe modern application lifecycle\\nToday, \", \"developers write and build the code for an app and then pass the generated assets to the IT \\nPros. T\", \"hen, the IT Pros reconfigure the app and repackage it, typically in an MSI or more recently in an \\nA\", \"pp-V packaging format. The app is then deployed through different channels and tools. One of the \\nma\", \"in problems with this approach is commonly known as \\u201cpackaging paralysis\\u201d. The problem is that \\nthis\", \" cycle repeats every time there\\u2019s an app update or an OS update.\\nYou can see the process reflected o\", \"n the following picture:\\nCompanies need a way to break this packaging cycle into three independent c\", \"ycles:\\n\\u2022 OS updates\\n\\u2022 Application updates\\n\\u2022 Customization57 CHAPTER 6 | Deploying Modern Desktop App\", \"lications\\nThe previous diagram shows that you can:\\n\\u2022 Update the underlying OS without having to repa\", \"ckage your apps.\\n\\u2022 Enable customizations from IT without the need to repackage the original develope\", \"r package.\\nThis radical change leads us to the new and modern IT lifecycle as shown in the following\", \" picture:58 CHAPTER 6 | Deploying Modern Desktop Applications\\nDevelopers create the app and generate\", \" an MSIX package that IT Pros can consume and configure \\nwithout the need of repackaging. Along with\", \" the MSIX technology, Microsoft has created tools to \\nallow IT to customize and configure packages w\", \"ithout repackaging.\\nMSIX: The next generation of deployment\\nBefore MSIX, there were several packagin\", \"g technologies available like setup wizards, MSI, ClickOnce, \\nApp-V, and scripting. Each of these te\", \"chnologies has their own strengths and Microsoft has decided \\nto pick the best of all to build MSIX.\", \" MSIX is built on the foundations of these existing technologies \\npicking the best of each:\\n\\u2022 App-V \", \"=> Containerization\\n\\u2022 ClickOnce => Auto updating\\n\\u2022 MSI => Easy to distribute\\nWith MSIX, you get one \", \"installer technology with all these features.59 CHAPTER 6 | Deploying Modern Desktop Applications\\nBe\", \"nefits of MSIX\\nNever regret installing an app\\nMSIX provides a predictable, reliable, and safe deploy\", \"ment. The declarative method contained in the \\npackage manifest lets the OS keep track of every asse\", \"t your application needs. It also provides a true \\nclean uninstall with no side effects.\\nDisk space \", \"optimization\\nMSIX is optimized to reduce the footprint that an application has on the user\\u2019s machine\", \" disk space. It \\ncreates a single instance storage of your files. That is, if you have two different\", \" packages with the \\nsame DLL, the DLL isn\\u2019t installed twice. The platform takes care of that problem\", \" because it knows all \\nthe files that a particular app installed thanks to its declarative nature. I\", \"t also allows you to have \\ndifferent versions of a DLL working side by side.\\nWith the use of resourc\", \"e packages, you can easily create multilingual apps and the OS takes care of \\ninstalling the ones th\", \"at are used.\\nNetwork optimization\\nMSIX detects the differences on the files at the byte block level \", \"enabling a feature called differential \\nupdates. What this means is that only the updated byte block\", \"s are downloaded on application \\nupdates.60 CHAPTER 6 | Deploying Modern Desktop Applications\\nWith s\", \"treaming installation, the user can quickly start working on your application while other parts of \\n\", \"the app are downloaded on the background. This feature contributes to an engaging experience for \\nyo\", \"ur users.\\nWith the optional packages feature, you achieve componentization on your app deployment, s\", \"o you \\ncan download them when needed.\\nSimple packaging and deployment\\nThe AppManifest declares the v\", \"ersioning, device targeting and identity in a standard way for every \\napplication. It also provides \", \"a way to sign your assets providing a solid security foundation.\\nOS managed\\nThe OS handles all the p\", \"rocesses for installing, updating, and removing an application. Applications \\nare installed per user\", \" but downloaded only once, minimizing the disk footprint. Microsoft is working \\non providing the MSI\", \"X experience also on Windows 7.\\nWindows provides integrity for the app\\nWith the use of digital signa\", \"tures, you can guarantee that you don\\u2019t install an application from \\nuntrusted sources. MSIX also pr\", \"events tampering because:\\n\\u2022 It keeps a record of file hashes.\\n\\u2022 It detects if a file has been modifi\", \"ed after installation.61 CHAPTER 6 | Deploying Modern Desktop Applications\\nWorks for the entire App \", \"Catalog\\nOne of the coolest things about MSIX is that it works for the entire application catalog, Wi\", \"ndows \\nForms, WPF, MFC/ATL, Delphi, even if you want to do xCopy deployment, ClickOnce, or going to \", \"the \\nStore, you can use the same MSIX package.\\nTools\\nWindows Application Packaging Project\\nYou can u\", \"se the Windows Application Packaging Project project in Visual Studio to generate a \\npackage for you\", \"r desktop app. Then, you can publish that package to the Microsoft Store or sideload \\nit onto one or\", \" more PCs.\\nMSIX Packaging Tool\\nThe MSIX Packaging Tool enables you to repackage your existing Win32 \", \"applications to the MSIX \\nformat. It offers both an interactive UI and a command line for conversion\", \"s and gives you the ability to \\nconvert an application without having the source code.62 CHAPTER 6 |\", \" Deploying Modern Desktop Applications\\nPackage Support Framework\\nThe Package Support Framework is an\", \" open-source kit that helps you apply fixes to your existing \\nWin32 application when you don\\u2019t have \", \"access to the source code, so that it can run in an MSIX \\ncontainer. The Package Support Framework h\", \"elps your application follow the best practices of the \\nmodern runtime environment.\\nApp Installer\\nAp\", \"p Installer allows Windows 10 and Windows 11 apps to be installed by double-clicking the app \\npackag\", \"e. This means that users don\\u2019t need to use PowerShell or other developer tools to deploy \\nWindows 10\", \"/Windows 11 apps. The App Installer can also install an app from the web, optional \\npackages, and re\", \"lated sets.\\nHow to create an MSIX package from an existing \\nWin32 desktop application\\nLet\\u2019s go throu\", \"gh the process to create an MSIX package from an existing Win32 application. In this \\nexample, we\\u2019ll\", \" use a Windows Forms app.63 CHAPTER 6 | Deploying Modern Desktop Applications\\nTo start, add a new pr\", \"oject to your solution, select the Windows Application Packaging Project, and \\ngive it a name.\\nYou\\u2019l\", \"l see the structure of the packaging project and note a special folder called Applications. Inside \\n\", \"this folder, you can specify which applications you want to include in the package. It can be more t\", \"han \\none.64 CHAPTER 6 | Deploying Modern Desktop Applications\\nRight-click on the Applications folder\", \" and select the Windows Forms project you want to package \\nfrom the Visual Studio solution.65 CHAPTE\", \"R 6 | Deploying Modern Desktop Applications\\nAt this point, you can compile and generate the package \", \"but let\\u2019s examine a couple of things. To have \\na better user experience, Visual Studio can autogener\", \"ate all the visual assets a modern application \\nneeds to handle icons and tile assets for the tile b\", \"ar and start menu. Open the Package.appxmanifest\\nfile to access the Manifest Designer. You can then \", \"generate all the visual assets from a given image \\npresent on your project just by clicking Create.\\n\", \"If you open the code for the Package.appxmanifest file, you can see a couple of interesting things.\\n\", \"Right under <Package>, there\\u2019s an <Identity> node. This is where your packaged application is going \", \"\\nto get its identity, which will be managed by the OS.66 CHAPTER 6 | Deploying Modern Desktop Applic\", \"ations\\nIn the <Capabilities> node, you can find all the requirements the application needs, paying s\", \"pecial \\nattention to the <rescap:Capability Name=\\\"runFullTrust\\\" \\\\>, which tells the OS to run the ap\", \"p in full \\ntrust mode since it\\u2019s a Win32 application.67 CHAPTER 6 | Deploying Modern Desktop Applica\", \"tions\\nSet the packaging project as the startup project for the solution and select Run. This is goin\", \"g to:\\n\\u2022 Compile the Windows Forms application.\\n\\u2022 Create an MSIX package out of the build results.\\n\\u2022 \", \"Deploy the packages.\\n\\u2022 Install it locally on the development machine.\\n\\u2022 Launch the app.68 CHAPTER 6 \", \"| Deploying Modern Desktop Applications\\nWith this, you have the clean install and uninstall experien\", \"ce that MSIX provides fully integrated into \\nWindows 10/Windows 11.\\nThe final stage is about how you\", \" deploy the MSIX package to another machine.\\nRight-click on the packaging project, select the Store \", \"menu, and then select the Create App \\nPackages option.\\nThen, you can choose between creating a packa\", \"ge to upload to the store or creating packages for \\nsideloading. In most modernization scenarios, yo\", \"u\\u2019ll choose I want to create packages for \\nsideloading.69 CHAPTER 6 | Deploying Modern Desktop Appli\", \"cations\\nThere you can select the different architectures you want to target as you can include as ma\", \"ny as you \\nwant into the same MSIX package.\\nThe final step is to declare where you want to deploy th\", \"e final installation assets.70 CHAPTER 6 | Deploying Modern Desktop Applications\\nYou can choose to u\", \"se a web server or a shared UNC path on your enterprise file servers. Pay \\nattention to the settings\", \" to specify how you want to update your application. We\\u2019ll cover application \\nupdates in the next se\", \"ction.\\nFor a detailed step-by-step guide, see Package a desktop app from source code using Visual St\", \"udio.\\nAuto Updates in MSIX\\nThe Windows Store has a great updating mechanism using Windows Update. In\", \" most enterprise \\nscenarios, you don\\u2019t use the Store to distribute your desktop apps. So, you need a\", \" similar way to \\nconfigure updates for your application and pull them to your users.\\nUsing a combina\", \"tion of Windows 10/Windows 11 features and MSIX packages, you can provide a \\ngreat updating experien\", \"ce for your users. In fact, the user doesn\\u2019t need to be technical at all but still \\nbenefits from a \", \"seamless application update experience.\\nYou can configure your updates to interact with the user in \", \"two different ways:71 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\u2022 User prompted updates: The\", \" OS shows some autogenerated nice UI to notify the user about \\nthe application it\\u2019s about to install\", \". It builds this UI based on the properties you specify on \\nyour installation files.\\n\\u2022 Silent update\", \"s in the background. With this option, your users don\\u2019t need to be aware of the \\nupdates.\\nYou can al\", \"so configure when you want to perform updates: either when the application launches or \\non a regular\", \" basis. Thanks to the side-loading features, you can even get these updates while the \\napplication i\", \"s running.\\nWhen you use this type of deployment, a special file is created called .appinstaller. Thi\", \"s simple file \\ncontains the following sections:\\n\\u2022 The location of the .appinstaller file\\n\\u2022 The appli\", \"cation\\u2019s main MSIX package properties\\n\\u2022 The update behavior\\nIn combination with this file, Microsoft\", \" has designed a special URL protocol to launch the installation \\nprocess from a link:\\n<a href=\\\"ms-ap\", \"pinstaller:?source=http://mywebservice.azureedge.net/MyApp.msix\\\">Install \\napp package </a>\\nThis prot\", \"ocol works on all browsers and launches the installation process with a great user experience \\non Wi\", \"ndows 10/Windows 11. Since the OS manages the installation process, it\\u2019s aware of the location \\nthis\", \" application was installed from and tracks all the files affected by the process.\\nMSIX creates a use\", \"r interface for installation automatically showing some properties of the package. \\nThis allows for \", \"a common installation experience for every app.72 CHAPTER 6 | Deploying Modern Desktop Applications\\n\", \"Once you\\u2019ve generated the new MSIX package and moved it to the deployment server, you just have \\nto \", \"edit the .appinstaller file to reflect these changes: mainly the version and the path to the new MSI\", \"X \\nfile. The next time the user launches the application, the system will detect the change and down\", \"load \\nthe files for the new version in the background. When the download is finished, installation w\", \"ill \\nexecute transparently for your user on new application launch.\"]"