"[\"**EDITION v1.0.3** - Updated to .NET 7\\n\\n\\n[Refer to the changelog](https://aka.ms/desktop-ebook-chang\", \"elog) for the book updates and community contributions.\\n\\n\\nPUBLISHED BY\\n\\n\\nMicrosoft Developer Divisio\", \"n, .NET, and Visual Studio product teams\\n\\n\\nA division of Microsoft Corporation\\n\\n\\nOne Microsoft Way\\n\\n\", \"\\nRedmond, Washington 98052-6399\\n\\n\\nCopyright \\u00a9 2022 by Microsoft Corporation\\n\\n\\nAll rights reserved. N\", \"o part of the contents of this book may be reproduced or transmitted in any\\nform or by any means wit\", \"hout the written permission of the publisher.\\n\\n\\nThis book is provided \\u201cas-is\\u201d and expresses the auth\", \"or\\u2019s views and opinions. The views, opinions, and\\ninformation expressed in this book, including URL \", \"and other Internet website references, may change\\nwithout notice.\\n\\n\\nSome examples depicted herein ar\", \"e provided for illustration only and are fictitious. No real association\\nor connection is intended o\", \"r should be inferred.\\n\\n\\n[Microsoft and the trademarks listed at https://www.microsoft.com](https://w\", \"ww.microsoft.com/) on the \\u201cTrademarks\\u201d webpage are\\ntrademarks of the Microsoft group of companies.\\n\\n\", \"\\nMac and macOS are trademarks of Apple Inc.\\n\\n\\nAll other marks and logos are property of their respec\", \"tive owners.\\n\\n\\nCo-Authors:\\n\\n\\n**Olia Gavrysh**, Program Manager, .NET team, Microsoft\\n\\n\\n**Miguel Ange\", \"l Castej\\u00f3n Dominguez**, Innovation Architect, Kabel\\n\\n\\nParticipants and reviewers:\\n\\n\\n**Maira Wenzel**\", \", Senior Program Manager, .NET team, Microsoft\\n\\n\\n**Andy De Gorge**, Senior Content Developer, .NET d\", \"ocs team, Microsoft\\n\\n\\n**Miguel Ramos**, Senior Program Manager, Windows Developer Platform team, Mic\", \"rosoft\\n\\n\\n**Adam Braden**, Principal Program Manager, Windows Developer Platform team, Microsoft\\n\\n\\n**\", \"Ricardo Minguez Pablos**, Senior Program Manager, Azure IoT team, Microsoft\\n\\n\\n**Nish Anil**, Senior \", \"Program Manager, .NET team, Microsoft\\n\\n\\n**Beth Massi**, Senior Product Marketing Manager, Microsoft\\n\", \"\\n\\n**Scott Hunter**, Partner Director Program Manager, .NET team, Microsoft\\n\\n\\n**Marta Fuentes Lara**,\", \" Kabel\\n\\n\\n**Ra\\u00fal Fern\\u00e1ndez de C\\u00f3rdoba**, Kabel\\n\\n\\n**Antonio Manuel Fern\\u00e1ndez Cantos**, Kabel\\n### Intro\", \"duction\\n\\n\\nThis book is about strategies you can adopt to move your existing desktop applications thr\", \"ough the\\npath of modernization and incorporate the latest runtime, language, and platform features. \", \"You\\u2019ll\\ndiscover that there\\u2019s no unique recipe as each application is different, and so are your requ\", \"irements\\nand preferences. The good news is that there are common approaches you can apply to add new\", \"\\nfeatures and capabilities to your applications. Some of them won\\u2019t even require major modifications\", \"\\nof your code. In this book, we\\u2019ll reveal how all those features work behind the scenes and explain \", \"the\\nmechanics of their implementations. Moreover, you\\u2019ll find some common scenarios for modernizing\\n\", \"existing desktop applications shown in detail so you can find inspiration for evolving your projects\", \".\\n\\n\\nMicrosoft\\u2019s approach to modernizing existing applications is to give you the flexibility to crea\", \"te your\\nown customized path. All the modernization strategies described in this book are mostly inde\", \"pendent.\\nYou can choose ones that are relevant for your application and skip others that aren\\u2019t impo\", \"rtant for\\nyou. In other words, you can mix and match the strategies to best address your application\", \" needs.\\n### Who should use the book\\n\\n\\nThis book for developers and solution architects who want to m\", \"odernize existing Windows Forms and\\nWPF desktop applications to leverage the benefits of .NET and Wi\", \"ndows 10.\\n\\n\\nYou might also find this book useful if you\\u2019re a technical decision maker, such as an en\", \"terprise\\narchitect or a development lead or director who wants an overview of the benefits of updati\", \"ng\\nexisting desktop applications.\\n### How to use the book\\n\\n\\nThis book addresses the \\u201cwhy\\u201d\\u2014why you mi\", \"ght want to modernize your existing applications, and the\\nspecific benefits you get from using NET a\", \"nd MSIX to modernize your desktop apps. The content of\\nthe book is designed for architects and techn\", \"ical decision makers who want an overview, but who\\ndon\\u2019t need to focus on implementation and technic\", \"al, step-by-step details.\\n\\n\\nAlong the different chapters, sample implementation code snippets and sc\", \"reenshots are provided,\\nwith chapter 5 devoted to showcase a complete migration process for sample a\", \"pplications.\\n### What this book doesn\\u2019t cover\\n\\n\\nThis book covers a specific subset of scenarios that\", \" are focused on lift-and-shift scenarios, outlining\\nthe way to gain the benefits of modernizing with\", \"out the effort of rewriting code.\\n\\n\\nThis book isn\\u2019t about developing modern applications with .NET f\", \"rom scratch or about getting started\\nwith Windows Forms and WPF. It focuses on how you can update ex\", \"isting desktop applications with\\nthe latest technologies for desktop development.\\n\\n\\n### Samples used\", \" in this book\\n\\nTo highlight the necessary steps to perform a modernization, we\\u2019ll be using a sample \", \"application\\ncalled eShopModernizing. This application has two flavors, Windows Forms and WPF, and we\", \"\\u2019ll show a\\nstep-by-step process on how to perform the modernization on both of them to .NET.\\n\\n\\nAlso,\", \" on the GitHub repository for this book, you\\u2019ll find the results of the process, which you can\\nconsu\", \"lt with if you decide to follow the step-by-step tutorial.\\n\\n\\n## Contents\\n\\n**Why modern desktop appli\", \"cations ....................................................................................... 1**\\n\", \"\\n\\nIntroduction .....................................................................................\", \".......................................................................................... 1\\n\\n\\nA sto\", \"ry of one company ..................................................................................\", \"................................................................. 1\\n\\n\\nYour story ...................\", \"....................................................................................................\", \"........................................................ 1\\n\\n\\nDesktop applications nowadays .........\", \"....................................................................................................\", \"........................... 1\\n\\n\\nWindows Forms ......................................................\", \"....................................................................................................\", \"......... 3\\n\\n\\nWPF ..................................................................................\", \"....................................................................................................\", \"..... 4\\n\\n\\nUWP ......................................................................................\", \"....................................................................................................\", \" 4\\n\\n\\nA tale of two platforms .......................................................................\", \"................................................................................... 5\\n\\n\\nPaths to mod\", \"ernization .........................................................................................\", \"................................................................ 8\\n\\n\\nModern features ...............\", \"....................................................................................................\", \"............................................... 8\\n\\n\\nDeployment .....................................\", \"....................................................................................................\", \".................................. 8\\n\\n\\nInstallation.................................................\", \"....................................................................................................\", \"......................... 8\\n\\n\\n**What\\u2019s new with .NET for Desktop? ..................................\", \".................................................... 9**\\n\\n\\nThe motivation behind .NET Core .........\", \"....................................................................................................\", \"........................ 9\\n\\n\\nIntroduction to .NET Core .............................................\", \"....................................................................................................\", \" 11\\n\\n\\n.NET 5+ is .NET Core vNext ...................................................................\", \"............................................................................ 11\\n\\n\\n.NET Framework vs.\", \" .NET ..............................................................................................\", \"...................................................... 12\\n\\n\\n.NET Standard vs. PCL ..................\", \"....................................................................................................\", \"................................... 13\\n\\n\\nNew Desktop features in .NET ..............................\", \"....................................................................................................\", \"....... 14\\n\\n\\nSupport for Windows Forms and WPF .....................................................\", \"............................................................... 14\\n\\n\\nXAML Islands ..................\", \"....................................................................................................\", \"................................................ 14\\n\\n\\nAccess to all Windows 10 and Windows 11 APIs .\", \"............................................................................................... 15\\n\\n\", \"\\nSide-by-side support and self-contained EXEs ......................................................\", \".............................................. 15\\n\\n\\nPerformance ....................................\", \"....................................................................................................\", \"............................... 15\\n\\n\\n**Migrating Modern Desktop applications .......................\", \"..................................................... 16**\\n\\n\\nConfiguration files ...................\", \"....................................................................................................\", \"......................................... 16\\n\\n\\nConfiguration on .NET Framework .....................\", \"....................................................................................................\", \"... 16\\n\\n\\ni Contents\\n\\n\\nConfiguration on .NET ........................................................\", \"............................................................................................ 17\\n\\n\\nMi\", \"grating configuration files ........................................................................\", \"............................................................... 17\\n\\n\\nAccessing databases ...........\", \"....................................................................................................\", \"............................................. 18\\n\\n\\nODBC ............................................\", \"....................................................................................................\", \"..................................... 19\\n\\n\\nOLE DB ..................................................\", \"....................................................................................................\", \"............................ 19\\n\\n\\nADO.NET ..........................................................\", \"....................................................................................................\", \"................ 19\\n\\n\\nEF Core vs. EF6 ..............................................................\", \"....................................................................................................\", \". 19\\n\\n\\nRelational databases ........................................................................\", \"............................................................................... 20\\n\\n\\nConsuming servi\", \"ces ................................................................................................\", \"............................................................. 20\\n\\n\\nConsuming a COM Object ..........\", \"....................................................................................................\", \".................................. 21\\n\\n\\nMore things to consider ....................................\", \"....................................................................................................\", \"............. 21\\n\\n\\nAppDomains ......................................................................\", \"................................................................................................ 21\\n\", \"\\n\\nRemoting .........................................................................................\", \".................................................................................... 21\\n\\n\\nCode Acces\", \"s Security (CAS) ...................................................................................\", \"...................................................... 22\\n\\n\\nSecurity Transparency ..................\", \"....................................................................................................\", \".............................. 22\\n\\n\\n**Windows 10 migration .........................................\", \"................................................................ 23**\\n\\n\\nWinRT APIs .................\", \"....................................................................................................\", \"......................................................... 23\\n\\n\\nUniversal Windows Platform (UWP) pack\", \"ages ...............................................................................................\", \"...... 24\\n\\n\\nHow to add WinRT APIs to your desktop project ..........................................\", \".......................................................... 26\\n\\n\\nXAML Islands .......................\", \"....................................................................................................\", \"............................................... 34\\n\\n\\nThe road to XAML Islands ......................\", \"....................................................................................................\", \"................... 35\\n\\n\\nHow it works ..............................................................\", \"....................................................................................................\", \".... 35\\n\\n\\nDo you need XAML Islands .................................................................\", \"......................................................................... 38\\n\\n\\nThe road ahead XAML I\", \"slands: WinUI 3.0 ..................................................................................\", \"............................ 38\\n\\n\\n**Example of migrating to the latest .NET.........................\", \".................................................... 41**\\n\\n\\nMigrating from .NET Core or .NET 5 .....\", \"....................................................................................................\", \".................... 41\\n\\n\\nMigrating from .NET Framework ............................................\", \"........................................................................................ 42\\n\\n\\nMigrat\", \"ing with a tool ....................................................................................\", \".................................................................. 42\\n\\n\\nMigrating by hand ..........\", \"....................................................................................................\", \"............................................. 42\\n\\n\\nPreparation .....................................\", \"....................................................................................................\", \"................................ 43\\n\\n\\nFix the code and build .......................................\", \"....................................................................................................\", \"......... 45\\n\\n\\nRun and test ........................................................................\", \"............................................................................................... 46\\n\\n\", \"\\nii Contents\\n\\n\\nMigrating a Windows Forms application ...............................................\", \"..................................................................... 46\\n\\n\\nMigrating a WPF applicati\", \"on .................................................................................................\", \"........................................... 52\\n\\n\\n**Deploying Modern Desktop Applications ...........\", \"............................................................... 55**\\n\\n\\nThe modern application lifecy\", \"cle ................................................................................................\", \".................................... 56\\n\\n\\nMSIX: The next generation of deployment ..................\", \"............................................................................................... 58\\n\\n\", \"\\nBenefits of MSIX ..................................................................................\", \"............................................................................. 59\\n\\n\\nTools ...........\", \"....................................................................................................\", \"....................................................................... 61\\n\\n\\nHow to create an MSIX p\", \"ackage from an existing Win32 desktop application........................................... 62\\n\\n\\nAu\", \"to Updates in MSIX .................................................................................\", \"........................................................................ 70\\n\\n\\niii Contents\\n\\n\\n**CHAPT\", \"ER**\\n# 1\\n\\n## Why modern desktop applications\\n\\n### Introduction\\n\\n#### **A story of one company**\\n\\n\\nBa\", \"ck in the early 2000s, one multinational company started developing a distributed desktop solution\\nt\", \"o exchange information between different branches of the company and execute optimized\\noperations on\", \" centralized units. They have chosen a brand-new framework called Windows Forms\\n(also known as WinFo\", \"rms) for their application development. Over the years, the project evolved into\\na mature, well-test\", \"ed, and time-proven application with hundreds of thousands of lines of code. Time\\npassed and .NET Fr\", \"amework 2.0 is no longer the hot new technology. The developers who are\\nworking on this application \", \"are facing a dilemma. They\\u2019d like to use the latest stack of technologies in\\ntheir development and h\", \"ave their application look and \\u201cfeel\\u201d modern. At the same time, they don\\u2019t\\nwant to throw away the gr\", \"eat product they have built over 15 years and rewrite the entire application\\nfrom scratch.\\n\\n#### **Y\", \"our story**\\n\\n\\nYou might find yourself in the same boat, where you have mature Windows Forms or Windo\", \"ws\\nPresentation Foundation (WPF) applications that have proved their reliability over the years. You\", \"\\nprobably want to keep using these applications for many more years. At the same time, since those\\na\", \"pplications were written some time ago, they might be missing capabilities like modern look,\\nperform\", \"ance, integration with new devices and platform features, and so on, which gives them a feel\\nof \\u201cold\", \" tech\\u201d. There\\u2019s another problem that might concern you as a developer. While working on the\\nolder .N\", \"ET Framework versions and maintaining applications that were written a while ago, you might\\nfeel lik\", \"e you aren\\u2019t learning new technologies and missing out on building modern technical skills. If\\nthat \", \"is your story \\u2013 this book is for you!\\n\\n### Desktop applications nowadays\\n\\n\\nBefore the rise of the In\", \"ternet, desktop applications were the main approach to building software\\nsystems. Developers could c\", \"hoose any programming language, such as COBOL, Fortran, VB6, or C++.\\n\\n\\n1 CHAPTER 1 | Why modern desk\", \"top applications\\n\\n\\nBut whether they developed small tools or complex distributed architectures, they\", \" were all desktop\\napplications.\\n\\n\\nThen, Internet technologies started shocking the development world\", \" and winning over more\\nengineers with advantages like easy deployment and simplified distribution pr\", \"ocesses. The fact that\\nonce a web application was deployed to production all users got automatic upd\", \"ates made a huge\\nimpact on software agility.\\n\\n\\nHowever, the Internet infrastructure, underlying prot\", \"ocols, and standards like HTTP and HTML weren\\u2019t\\ndesigned for building complex applications. In fact,\", \" the major development effort back then was\\naimed at just one goal: to give web applications the sam\", \"e capabilities that desktop applications have,\\nsuch as fast data input and state management.\\n\\n\\nEven \", \"though web and mobile applications have grown at an incredible pace, for certain tasks desktop\\nappli\", \"cations still hold the number one place in terms of efficiency and performance. That explains why\\nth\", \"ere are millions of developers who are building their projects with WPF and WinForms and the\\namount \", \"of those applications is constantly growing.\\n\\n\\nHere are some reasons for choosing desktop applicatio\", \"ns in your development:\\n\\n\\n  - Desktop apps have better interaction with the user\\u2019s PC.\\n\\n  - The perf\", \"ormance of desktop applications for complex calculations is much higher than the\\nperformance of web \", \"applications.\\n\\n  - Running custom logic on the client-side is possible but much harder with a web ap\", \"plication.\\n\\n  - Using multithreading is easier and more efficient in a desktop application.\\n\\n  - The\", \" learning curve for designing user interfaces (UIs) isn\\u2019t steep. And for WinForms, it\\u2019s\\nintuitive wi\", \"th the drag-and-drop experience of the Windows Forms designer.\\n\\n  - It\\u2019s easy to start coding and te\", \"sting your algorithms without the need to set up a server\\ninfrastructure or to care about connectivi\", \"ty problems, firewalls, and browser compatibility.\\n\\n  - Debugging is powerful as compared to web deb\", \"ugging.\\n\\n  - Access to hardware devices, such as camera, Bluetooth, or card readers, is easy.\\n\\n  - S\", \"ince the technology has been around for a while, there are many experts and a knowledge\\nbase availab\", \"le to develop desktop applications.\\n\\n\\nSo, as you can see, developing for desktop is great for many r\", \"easons. The technology is mature and\\ntime-tested, the development cycle is fast, the debugging is po\", \"werful and arguably, desktop apps\\nhave less complexity and are easier to get started with.\\n\\n\\nMicroso\", \"ft offered many UI desktop technologies throughout the years from Win32 introduced in 1995\\nto Univer\", \"sal Windows Platform (UWP) released in 2016.\\n\\n\\n2 CHAPTER 1 | Why modern desktop applications\\n\\n\\nAccor\", \"ding to a survey published by Telerik on April 2016, the most popular technologies for building\\nWind\", \"ows desktop apps are Windows Forms, WPF, and UWP.\\n\\n\\nYou can develop in any of them using C# and Visu\", \"al Basic, but let\\u2019s take a closer look.\\n\\n#### **Windows Forms**\\n\\n\\nFirst released in 2002, Windows Fo\", \"rms is a managed framework and is the oldest, most-used desktop\\ntechnology built on the Windows grap\", \"hics device interface (GDI) engine. It offers a smooth drag-anddrop experience for developing user i\", \"nterfaces in Visual Studio. At the same time, Windows Forms\\nrelies on the Visual Studio Designer as \", \"the main way you develop your UI, so creating visual\\ncomponents from code isn\\u2019t trivial.\\n\\n\\nThe follo\", \"wing list summarizes the main characteristics of Windows Forms:\\n\\n\\n  - Mature technology with lots of\", \" code samples and documentation.\\n\\n  - Powerful and productive designer. Not so convenient to design \", \"UI \\u201cfrom code\\u201d.\\n\\n  - Easy and intuitive to learn, thanks to the designer\\u2019s drag-and-drop experience.\", \"\\n\\n  - Supported on any Windows version.\\n\\n  - Supported on .NET Core 3.0 and later versions.\\n\\n\\n3 CHAP\", \"TER 1 | Why modern desktop applications\\n\\n\\n#### **WPF**\\n\\nBased on the XAML language specification, WP\", \"F favors a clear separation between UI and code. XAML\\noffers capabilities like templating, styling, \", \"and binding, which is suited for building large applications.\\nLike Windows Forms, it\\u2019s a managed fra\", \"mework, but the design is modular and reusable.\\n\\n\\nHere are the main features of WPF:\\n\\n\\n  - Mature te\", \"chnology.\\n\\n  - Designer is available, but developers usually prefer to create the design from code u\", \"sing\\ndeclarative XAML.\\n\\n  - The learning curve is steeper than Windows Forms.\\n\\n  - Supported on any \", \"Windows version.\\n\\n  - Supported on .NET Core 3.0 and later versions.\\n\\n#### **UWP**\\n\\n\\nUWP isn\\u2019t only \", \"a presentation framework like WPF and Windows Forms, but it\\u2019s also a platform itself.\\nThis platform \", \"has:\\n\\n\\n  - Its own API set (the Windows Runtime API).\\n\\n  - A new deployment system (MSIX)\\n\\n  - A mod\", \"ern application lifecycle model (for low battery consumption).\\n\\n  - A new Resource Management System\", \" (based on PRI files).\\n\\n\\nThe platform was created to support all kinds of input systems (like ink, t\", \"ouch, gamepad, mouse,\\nkeyboard, gaze, and so on) in all form-factors with performance and low batter\", \"y consumption in mind.\\nFor these reasons, the shell of the Windows 10 OS uses parts of the UWP platf\", \"orm.\\n\\n\\n4 CHAPTER 1 | Why modern desktop applications\\n\\n\\nUWP contains a presentation framework that is\", \" XAML-based, like WPF, but it has some important\\ndifferences such as:\\n\\n\\n  - Applications are execute\", \"d in app containers. App containers control what resources a UWP\\napp can access.\\n\\n  - Supported only\", \" on Windows 10 and Windows 11.\\n\\n  - Apps can be deployed through Microsoft Store for easier deployme\", \"nt.\\n\\n  - Designed as part of the Windows Runtime API.\\n\\n  - Contains an extensive set of rich built-i\", \"n controls and additional controls are available\\nthrough the Microsoft UI Library NuGet packages (Wi\", \"nUI library), updated every few months.\\n\\n### A tale of two platforms\\n\\n\\nIn the last 20 years, while U\", \"I desktop technologies were growing and following the path from\\nWindows Forms to UWP, the hardware w\", \"as also evolving from heavyweight PC units with small CRT\\nmonitors to high-DPI monitors and lightwei\", \"ght tablets and phones with different data input\\ntechniques like Touch and Ink. These changes result\", \"ed in creating two different concepts: a Desktop\\nApplication and a Modern Application. A Modern Appl\", \"ication is one that considers different device\\nform factors, various input and output methods, and l\", \"everages modern desktop features while\\nrunning on a sandboxed execution model. The (traditional) Des\", \"ktop Application, on the other hand, is\\n\\n\\n5 CHAPTER 1 | Why modern desktop applications\\n\\n\\nan applica\", \"tion that needs a solid UI with a high density of controls that is best operated with a mouse\\nand a \", \"keyboard.\\n\\n\\nThe following table describes the differences between the two concepts:\\n\\n\\n\\n\\n\\n\\n|Aspect of\", \" comparison|Modern Application|Desktop Application|\\n|---|---|---|\\n|Security|Contained execution & Gr\", \"eat<br>Fundamentals. Designed from<br>the ground up to respect user\\u2019s<br>privacy, manage battery lif\", \"e,<br>and focus to keep the device<br>safe.|User & Admin level of security.<br>You have native acces\", \"s to the<br>registry and hard drive folders.|\\n|Deployment|Installation and updates are<br>managed by\", \" the platform.|MSI, Custom installers &<br>Updates. Traditionally a source<br>of headaches for devel\", \"opers<br>and IT managers.|\\n|Distribution|Trusted Distribution & Signed<br>Packages. Distribution is<\", \"br>performed from a trusted<br>source and never from the<br>web.|Web, SCCM & Custom<br>distribution.\", \" No control over<br>what is installed, affects the<br>whole machine.|\\n|UI|Modern UI. Different input\", \"<br>mechanisms, ink, touch,<br>gamepad, keyboard, mouse,<br>etc.|Windows Forms, WPF, MFC.<br>Designe\", \"d for the mouse and<br>keyboard for a dense UI and to<br>get the most productivity from<br>the deskt\", \"op.|\\n|Data|Cloud First Data with Insights.<br>Source of truth in the cloud.<br>Insights to know what\", \" happens<br>with your app and how it\\u2019s<br>performing.|Local Data. Traditional desktop<br>application\", \"s usually need some<br>local data.|\\n|Design|Designed for reuse. Reuse in<br>mind between different<b\", \"r>platforms, front end, and back<br>end, running assets in many<br>places as possible.|Designed for \", \"Windows<br>Desktop only|\\n\\n\\n\\nAs a part of the commitment to provide developers with the best tools to\", \" build applications, Microsoft\\nput forth a great effort to bring these concepts - or we can even say\", \" platforms - closer together to\\nempower developers with the best of both worlds. To do that, Microso\", \"ft has performed a bidirectional\\neffort between the two platforms.\\n\\n\\n6 CHAPTER 1 | Why modern deskto\", \"p applications\\n\\n\\n1. Move Desktop Application scenarios into Modern Application platform. The traditi\", \"onal\\ndesktop development is still popular because it addresses certain scenarios well. It makes\\nsens\", \"e to take these common desktop scenarios and bring them into the modern desktop\\nplatform to make the\", \" platform fully capable.\\n\\n\\n1. Move Modern Application features into Desktop Applications. For existi\", \"ng desktop apps that\\nneed a way to leverage modern capabilities without rewriting from scratch, feat\", \"ures from the\\nModern Application platform are pushed into the Desktop Application.\\n\\n\\n7 CHAPTER 1 | W\", \"hy modern desktop applications\\n\\n\\nIn this book, we\\u2019ll focus on the second part and show how you can m\", \"odernize your existing desktop\\napplications.\\n\\n### Paths to modernization\\n\\n\\nThe structure of this gui\", \"de reflects three different axes to accomplish modernization: Modern\\nFeatures, Deployment, and Insta\", \"llation.\\n\\n#### **Modern features**\\n\\n\\nSay you have a working Windows Forms application that a sales r\", \"epresentative of your company uses\\nto fill in a customer order. A new requirement comes in to enable\", \" the customer to sign the order\\nusing a tablet pen. Inking is native in today\\u2019s operating systems an\", \"d technologies, but it wasn\\u2019t\\navailable when the app was developed.\\n\\n\\nThis path will show you how yo\", \"u can leverage modern desktop features into your existing desktop\\ndevelopment.\\n\\n#### **Deployment**\\n\", \"\\n\\nModern development cycles have stressed the importance of providing agility with regard to how new\", \"\\nversions of applications are deployed to individual users. Since Windows Forms and WPF applications\", \"\\nare based on a particular version of the .NET Framework that must be present on the machine, they\\nc\", \"an\\u2019t take advantage of new .NET Framework version features without the intervention of the IT\\npeople\", \" with the risk of having side effects for other apps running on the same machine. It has limited\\nthe\", \" innovation pace for developers forcing them to stay on outdated versions of the .NET Framework.\\n\\n\\nS\", \"ince the launch of .NET Core 3.0, you can leverage a new approach of deploying multiple versions of\\n\", \".NET side by side and specifying which version of .NET each application should target. This way, you\", \"\\ncan use the newest features in one application while being confident you aren\\u2019t going to break any\\n\", \"other applications.\\n\\n#### **Installation**\\n\\n\\nDesktop applications always rely on some sort of instal\", \"lation process before the user can start using\\nthem. This fact brought into the game a set of techno\", \"logies, from MSI and ClickOnce to custom\\ninstallers or even XCOPY deployment. Any of these methods d\", \"eals with delicate problems because\\napplications need a way to access shared resources on the machin\", \"e. Sometimes installation needs to\\naccess the Registry to insert or update new Key Values, sometimes\", \" to update shared DLLs referenced\\nby the main application. This behavior causes a continuous headach\", \"e for users, creating this\\nperception that once you install some application, your computer will nev\", \"er be the same, even if you\\nuninstall it afterwards.\\n\\n\\nIn this book, we\\u2019ll introduce a new way of in\", \"stalling applications with MSIX that solves the problem\\ndescribed earlier. You\\u2019ll learn how you can \", \"easily set up packaging, installation, and updates for your\\napplication.\\n\\n\\n8 CHAPTER 1 | Why modern \", \"desktop applications\\n\\n\\n**CHAPTER**\\n# 2\\n\\n## What\\u2019s new with .NET for Desktop?\\n\\n\\nDesktop applications \", \"such as Windows Forms and WPF can be built using various .NET\\nimplementations, for example, .NET Fra\", \"mework or .NET 7. In this chapter, we\\u2019ll talk about the history\\nof each implementation, explain the \", \"differences, and show what new features await desktop\\ndevelopers in newer implementations.\\n\\n\\nIf you\\u2019\", \"ve been developing Windows Forms or WPF applications for a long time, you\\u2019re familiar with\\n.NET Fram\", \"ework. Later, .NET Core (specifically its 3.0 version) started supporting desktop applications.\\n.NET\", \" Core was rebranded to .NET when .NET 5 was released. Just as there are different versions of\\n.NET F\", \"ramework, for example, 4.6, 4.7, and 4.8, there are also different versions of .NET Core: .NET\\nCore \", \"3.0, .NET 5, .NET 6, .NET 7, and so on.\\n\\n\\nLet\\u2019s look into the history of each implementation to unde\", \"rstand the differences and benefits of each.\\n\\n### The motivation behind .NET Core\\n\\n\\nSince its launch\", \" in 2002, .NET Framework has evolved to support many technologies, like Windows\\nForms, ASP.NET, Enti\", \"ty Framework, Windows Store, and many others. All of them are different in\\nnature. Therefore, Micros\", \"oft approached this evolution by taking parts of .NET Framework and\\ncreating a different application\", \" stack for each technology. That way, development capabilities could\\nbe customized for the needs of \", \"the specific stack, which maximized the potential of every platform.\\nThat led to fragmentation on th\", \"e versions of .NET Framework maintained by different independent\\nteams. All of these stacks have a c\", \"ommon structure, containing an app model, a framework, and a\\nruntime, but they differ in the impleme\", \"ntation of each of the parts.\\n\\n\\nIf you\\u2019re targeting only one of these platforms, you can use this mo\", \"del. However, in many cases you\\nmight need more than one target platform in the same solution. For e\", \"xample, your application may\\nhave a desktop admin part, a customer-facing web site that shares the b\", \"ack-end logic running on a\\nserver, and even a mobile client. In this case, you need a unified coding\", \" experience that can span all of\\nthese .NET verticals.\\n\\n\\nBy the time Windows 8 was released, the con\", \"cept of Portable Class Libraries (PCLs) was born.\\nOriginally, .NET Framework was designed around the\", \" assumption that it would always be deployed as\\n[a single unit, so factoring wasn\\u2019t a concern. To fa\", \"ce the problem of code sharing between verticals, the](https://wikipedia.org/wiki/Decomposition_(com\", \"puter_science))\\ndriving force was on how to refactor the framework. The idea of contracts is to prov\", \"ide a well-factored\\n\\n\\n9 CHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\n\\nAPI surface area. Contracts \", \"are simply assemblies that you compile against and are designed with\\nproper factoring in mind taking\", \" care of the dependencies between them.\\n\\n\\nThis led to reasoning about the API differences between ve\", \"rticals at the assembly level, as opposed to\\nat the individual API level like previously. This aspec\", \"t enabled a class library experience that can target\\nmultiple verticals, also known as portable clas\", \"s libraries.\\n\\n\\nWith PCL, the experience of development is unified across verticals based on the API \", \"shape. And the\\nmost pressing need to create libraries running on different verticals is also address\", \"ed. But there\\u2019s a\\ngreat challenge: APIs are only portable when the implementation is moved forward a\", \"cross all the\\nverticals.\\n\\n\\nA better approach is to unify the implementations across verticals by pro\", \"viding a well-factored\\nimplementation instead of a well-factored view. It\\u2019s a lot simpler to ask eac\", \"h team that owns a specific\\ncomponent to think about how their APIs work across all verticals than t\", \"rying to retroactively provide\\na consistent API stack on top. This is where .NET Standard comes in.\\n\", \"\\n\\nAnother large challenge has to do with how .NET Framework is deployed. .NET Framework is a\\nmachine\", \"-wide framework. Any changes made to it affect all applications that take a dependency on it.\\nAlthou\", \"gh this deployment model has many advantages, such as reducing disk space and centralized\\naccess to \", \"services, it presents some pitfalls.\\n\\n\\nTo start with, it\\u2019s difficult for application developers to t\", \"ake a dependency on a recently released\\nframework. They either have to take a dependency on the late\", \"st OS or provide an application installer\\nthat installs .NET Framework along with the application. I\", \"f you\\u2019re a web developer, you might not even\\nhave this option as the IT department establishes the s\", \"erver supported version.\\n\\n\\nEven if you\\u2019re willing to go through the trouble of providing an installe\", \"r to chain in .NET Framework\\nsetup, you may find that upgrading .NET Framework can break other appli\", \"cations.\\n\\n\\nDespite the efforts to provide backward compatible versions of the framework, there are c\", \"ompatible\\nchanges that can break applications. For example, adding an interface to an existing type \", \"can change\\nhow this type is serialized and cause breaking problems depending on the existing code. B\", \"ecause the\\n.NET Framework installed base is huge, fighting against these breaking scenarios slows do\", \"wn the pace\\nof innovations inside .NET Framework.\\n\\n\\nTo solve all these issues, Microsoft developed .\", \"NET Core as the evolution of the .NET development\\nplatform.\\n\\n\\n10 CHAPTER 2 | What\\u2019s new with .NET fo\", \"r Desktop?\\n\\n\\n### Introduction to .NET Core\\n\\n.NET Core, which is now referred to as just \\u201c.NET\\u201d, is t\", \"he evolution of Microsoft\\u2019s .NET technology into\\na modular, cross-platform, open source, and cloud-r\", \"eady platform. It runs on Windows, macOS, and\\nLinux, and some ARM-based architectures like Android a\", \"nd IoT.\\n\\n\\nThe purpose of .NET Core is to provide a unified platform for all types of applications, w\", \"hich includes\\n[Windows, cross-platform, and mobile applications. .NET Standard](https://docs.microso\", \"ft.com/dotnet/standard/net-standard) enabled this by providing shared\\nbase APIs, which every applica\", \"tion model needs, and excluding any application model-specific API.\\n\\n\\nThis framework gives applicati\", \"ons many benefits in terms of efficiency and performance, simplifying\\nthe packaging and deployment i\", \"n the different supported platforms.\\n\\n\\nThe benefits of .NET Core come from these three characteristi\", \"cs:\\n\\n\\n  - **Cross-platform:** It allows application execution on different platforms (Windows, macOS\", \", and\\nLinux).\\n\\n  - **Open source:** .NET Core platform is open source and available through GitHub, \", \"fostering\\ntransparency and community contributions.\\n\\n  - **Supported:** Microsoft officially support\", \"s .NET Core.\\n\\n\\nStarting with .NET Core 3.0, besides the existing support for web and cloud, there\\u2019s \", \"also support for\\ndesktop, IoT, and AI domains. The goal for this framework is impressive: to target \", \"every type of .NET\\ndevelopment present and future.\\n\\n### .NET 5+ is .NET Core vNext\\n\\n\\n.NET 5 was the \", \"next step forward with .NET Core. .NET 5 improved .NET in a few key ways:\\n\\n\\n  - Produced a single .N\", \"ET runtime and framework that can be used everywhere and that has\\nuniform runtime behaviors and deve\", \"loper experiences.\\n\\n  - Expanded the capabilities of .NET by taking the best of .NET Core, .NET Fram\", \"ework, Xamarin,\\nand Mono.\\n\\n  - Built that product out of a single code-base that developers (Microso\", \"ft and the community)\\ncan work on and expand together and that improves all scenarios.\\n\\n\\n.NET 5 was \", \"a game-changer for .NET. With .NET 5 and later versions, your code and project files look\\nand feel t\", \"he same no matter which type of app you\\u2019re building. You have access to the same runtime,\\nAPIs, and \", \"language capabilities with each app. This includes new performance improvements that get\\ncommitted t\", \"o the runtime almost daily. .NET 6 and .NET 7 made further improvements in reliability,\\n[performance\", \", new APIs, and language features. For more details, see What\\u2019s new in .NET 5, What\\u2019s](https://docs.\", \"microsoft.com/dotnet/core/whats-new/dotnet-5)\\n[new in .NET 6, and What\\u2019s new in .NET 7.](https://doc\", \"s.microsoft.com/dotnet/core/whats-new/dotnet-6)\\n\\n\\n11 CHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\n\", \"\\n### .NET Framework vs. .NET\\n\\nSo now that you understand the relevance of .NET, you might be wonderi\", \"ng what happens with .NET\\nFramework. You could be asking questions like: Do I have to abandon it? Is\", \" it going to disappear?\\nWhat are my choices to modernize the applications I have on .NET Framework?\\n\", \"\\n\\nIn 2019, .NET Framework 4.8 was released. It included three major improvements for desktop\\napplica\", \"tions:\\n\\n\\n  - **Modern browser and media controls** : New controls were added that take advantage of\\n\", \"Microsoft Edge and newer media players that support the latest standards.\\n\\n  - **Access to UWP contr\", \"ols** : UWP introduced controls that take advantage of the latest\\nWindows features and touch display\", \"s. With .NET Framework 4.8, you don\\u2019t have to rewrite\\nyour applications to use these new features an\", \"d controls, so you can use these new features\\nin your existing WPF or Windows Forms code.\\n\\n  - **Hig\", \"h-DPI improvements** : The resolution of displays increased to 4K and 8K, so, .NET\\nFramework 4.8 add\", \"ed new HDPI improvements to make sure existing Windows Forms and\\nWPF applications can look great on \", \"these new displays.\\n\\n\\nSince .NET Framework is installed on millions of machines, Microsoft will cont\", \"inue to support it but\\nwon\\u2019t add new features.\\n\\n\\n.NET (Core) is the open-source, cross-platform, and\", \" fast-moving version of the .NET family. Because of\\nits side-by-side nature, it can take changes wit\", \"hout the fear of breaking any application. This means\\nthat .NET will get new APIs and language featu\", \"res over time that .NET Framework won\\u2019t. Also, .NET\\nalready has features that were impossible for .N\", \"ET Framework, such as:\\n\\n\\n  - **Side-by-side versions of .NET supporting Windows Forms and WPF** : Th\", \"is solves the\\nproblem of side effects when updating the machine\\u2019s framework version. Multiple versio\", \"ns of\\n.NET can be installed on the same machine and each application specifies which version of\\n\\n\\n12\", \" CHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\n\\n.NET it should use. Even more, now you can develop \", \"and run Windows Forms and WPF on top\\nof .NET.\\n\\n  - **Embed .NET directly into an application** : You\", \" can deploy .NET as part of your application\\npackage. This enables you to take advantage of the late\", \"st version, features, and APIs without\\nhaving to wait for a specific version to be installed on the \", \"machine.\\n\\n  - **Take advantage of .NET features** : .NET is fast-moving and open-source. Its side-by\", \"-side\\nnature enables fast introduction of new innovative APIs and Base Class Library (BCL)\\nimproveme\", \"nts without the risk of breaking compatibility. Now Windows Forms and WPF\\napplications can take adva\", \"ntage of the latest .NET features, which also includes fundamental\\nfixes for things like runtime per\", \"formance and high-DPI support.\\n\\n.NET Framework will be fully supported and will always be a part of \", \"Windows. However, if you want to\\nuse the newest language features and APIs in the future, you\\u2019ll nee\", \"d to move your applications to\\n.NET. For brand-new desktop apps, we recommend starting directly on .\", \"NET 6 or a later version. It\\u2019s\\nlightweight and cross-platform, runs side by side, has high performan\", \"ce, and fits perfectly on\\ncontainers and microservices architectures.\\n\\n### .NET Standard vs. PCL\\n\\n\\n[\", \".NET Standard](https://docs.microsoft.com/dotnet/standard/net-standard) is a formal specification of\", \" .NET APIs that are intended to be available on all .NET\\nimplementations. The motivation behind .NET\", \" Standard was to establish greater uniformity in the .NET\\necosystem. .NET Standard is a specificatio\", \"n of .NET APIs that make up a uniform set of contracts to\\ncompile your code against. These contracts\", \" are implemented in each .NET flavor, thus enabling\\nportability across different .NET implementation\", \"s.\\n\\n\\n.NET Standard enables the following key scenarios:\\n\\n\\n  - Defines uniform set of base class libr\", \"aries APIs for all .NET implementations to implement,\\nindependent of the workload.\\n\\n  - Enables deve\", \"lopers to produce portable libraries that are usable across .NET implementations,\\nusing this same se\", \"t of APIs.\\n\\n\\n13 CHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\n\\n.NET Standard is the evolution of PC\", \"Ls and the following list shows the fundamental differences\\nbetween .NET Standard and PCLs:\\n\\n\\n  - .N\", \"ET Standard is a set of curated APIs, picked by Microsoft. PCLs aren\\u2019t.\\n\\n  - The APIs that a PCL con\", \"tains are dependent on the platforms that you choose to target when\\nyou create it. This makes a PCL \", \"only sharable for the specific targets that you choose.\\n\\n  - .NET Standard is platform-agnostic, so \", \"it can run on Windows, macOS, and Linux.\\n\\n  - PCLs can also run cross-platform, but they can only ta\", \"rget a limited set of platforms.\\n\\n### New Desktop features in .NET\\n\\n#### **Support for Windows Forms\", \" and WPF**\\n\\n\\nWindows Forms and WPF are part of .NET Core since version 3.0. Both presentation framew\", \"orks are\\nfor Windows only, so they aren\\u2019t cross-platform. You can think of WPF as a rich layer over \", \"DirectX and\\nWindows Forms as a thinner layer over GDI+. WPF and Windows Forms do a great job of expo\", \"sing\\nand exercising much of the desktop application functionality in Windows. So Windows Forms and\\nW\", \"PF are available for .NET Core and .NET Framework. Target your new desktop applications to .NET 6\\nor\", \" later, and migrate your existing apps from .NET Framework to .NET 6 or later.\\n\\n\\nA new version of .N\", \"ET Standard, version 2.1, was released at the same time as .NET Core 3.0. To see\\n[which .NET impleme\", \"ntations support which .NET Standard versions, see Which .NET Standard version](https://docs.microso\", \"ft.com/dotnet/standard/net-standard#net-standard-versions)\\n[to target.](https://docs.microsoft.com/d\", \"otnet/standard/net-standard#net-standard-versions)\\n\\n\\nThe .NET (Core) implementations for both Window\", \"s Forms and WPF are open source.\\n\\n#### **XAML Islands**\\n\\n\\n[XAML Islands](https://docs.microsoft.com/\", \"windows/apps/desktop/modernize/xaml-islands) is a set of components for developers to use Windows 10\", \" controls (UWP XAML controls)\\nin their WPF, Windows Forms, and native Win32 apps (like MFC). You can\", \" have your \\u201cislands\\u201d of UWP\\nXAML controls wherever you want inside your Win32 apps.\\n\\n\\nThese XAML Isl\", \"ands are possible because Windows 10, version 1903 introduced a set of APIs that\\nallows hosting UWP \", \"XAML content in Win32 windows using windows handlers (HWnds). Only apps\\nrunning on Windows 10 1903 a\", \"nd later can use XAML Islands.\\n\\n\\nTo make it easier to create XAML Islands for Windows Forms and WPF \", \"developers, the Windows\\nCommunity Toolkit introduces a set of .NET wrappers in several NuGet package\", \"s. Those wrappers are\\nthe wrapped and hosting controls:\\n\\n\\n  - [The WebView,](https://docs.microsoft.\", \"com/windows/communitytoolkit/controls/wpf-winforms/webview) [WebViewCompatible, InkCanvas,](https://\", \"docs.microsoft.com/windows/communitytoolkit/controls/wpf-winforms/webviewcompatible) [MediaPlayerEle\", \"ment, and MapControl](https://docs.microsoft.com/windows/communitytoolkit/controls/wpf-winforms/medi\", \"aplayerelement)\\nwrapped controls wrap some UWP XAML controls into Windows Forms or WPF controls,\\nhid\", \"ing UWP concepts for those developers.\\n\\n  - [The WindowsXamlHost control for Windows Forms and WPF a\", \"llows other not-wrapped UWP](https://docs.microsoft.com/windows/communitytoolkit/controls/wpf-winfor\", \"ms/windowsxamlhost)\\nXAML controls and custom controls to be loaded into a XAML Island.\\n\\n\\n14 CHAPTER \", \"2 | What\\u2019s new with .NET for Desktop?\\n\\n\\n#### **Access to all Windows 10 and Windows 11 APIs**\\n\\nWindo\", \"ws 10 and Windows 11 have a large number of APIs available for developers to work with.\\nThese APIs g\", \"ive access to a wide variety of functionality like authentication, bluetooth, appointments,\\nand cont\", \"acts. Now these APIs are exposed through .NET and give Windows developers the chance to\\ncreate power\", \"ful desktops apps using the capabilities present on Windows 10 and Windows 11.\\n\\n#### **Side-by-side \", \"support and self-contained EXEs**\\n\\n\\nThe .NET deployment model is one of the biggest benefits that Wi\", \"ndows desktop developers will\\nexperience with .NET. The ability to globally install .NET provides mu\", \"ch of the same central installation\\nand servicing benefits of .NET Framework, while not requiring in\", \"-place updates.\\n\\n\\nWhen a new .NET version is released, you can update each app on a machine as neede\", \"d without any\\nconcern of affecting other applications. New .NET versions are installed in their own \", \"directories and\\nexist \\u201cside-by-side\\u201d with each other.\\n\\n\\nIf you need to deploy with isolation, you ca\", \"n deploy .NET with your application. .NET will bundle your\\napp with the .NET runtime as a single exe\", \"cutable. The modular architecture used by .NET makes these\\nflexible deployment options possible.\\n\\n##\", \"## **Performance**\\n\\n\\nSince its start, targeting the web and cloud workloads, .NET has had performanc\", \"e plugged into its\\nDNA. Server-side code must be performant enough to fulfill high-concurrency scena\", \"rios and .NET 7\\nscores today as the best performance web platform in the market.\\n\\n\\nOld Windows Forms\", \" code has been refactored for .NET, which reduced memory allocations for\\ndrawing Forms and Controls.\", \" By simply upgrading from .NET Framework to .NET or later, your\\napplications become much faster. You\", \" can take advantage of these performance improvements when\\nyou use .NET to build your next generatio\", \"n of desktop applications.\\n\\n\\n15 CHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\n\\n**CHAPTER**\\n# 3\\n\\n## \", \"Migrating Modern Desktop applications\\n\\n\\nIn this chapter, we\\u2019re exploring the most common issues and \", \"challenges you can face when migrating\\nan existing application from .NET Framework to .NET.\\n\\n\\nIf you\", \" just want to update your application to the latest .NET version using a tool and not get into the\\nd\", \"etails of what\\u2019s happening behind the scenes, feel free to skip this chapter and find step-by-step\\ni\", \"nstructions in the Example of migrating to .NET chapter.\\n\\n\\nA complex desktop application doesn\\u2019t wor\", \"k in isolation and needs some kind of interaction with\\nsubsystems that may reside on the local machi\", \"ne or on a remote server. It will probably need some\\nkind of database to connect with as a persisten\", \"ce store either locally or remotely. With the rise of\\nInternet and service-oriented architectures, i\", \"t\\u2019s common to have your application connected to some\\nsort of service residing on a remote server or\", \" in the cloud. You may need to access the machine file\\nsystem to implement some functionality. Alter\", \"natively, maybe you\\u2019re using a piece of functionality\\nthat resides inside a COM object outside your \", \"application, which is a common scenario if, for example,\\nyou\\u2019re integrating Office assemblies in you\", \"r app.\\n\\n\\nBesides, there are differences in the API surface that is exposed by .NET Framework and .NE\", \"T, and\\nsome features that are available on .NET Framework aren\\u2019t available on .NET. It\\u2019s important f\", \"or you to\\nknow and take them into account when planning a migration.\\n\\n### Configuration files\\n\\n\\nConf\", \"iguration files offer the possibility to store sets of properties that are read at run time and can\\n\", \"affect the behavior of your app, such as where to locate a database or how many times to execute a\\nl\", \"oop. The beauty of this technique is that you can modify some aspects of the application without the\", \"\\nneed to recode and recompile. This comes in handy when, for example, the same app code runs on a\\nde\", \"velopment environment with a certain set of configuration values and in production environment\\nwith \", \"a different set.\\n\\n#### **Configuration on .NET Framework**\\n\\n\\nIf you have a working .NET Framework de\", \"sktop application, chances are you have an _app.config_ file\\n[accessed through the AppSettingsSectio\", \"n class from the System.Configuration namespace.](https://docs.microsoft.com/dotnet/api/system.confi\", \"guration.appsettingssection)\\n\\n\\n16 CHAPTER 3 | Migrating Modern Desktop applications\\n\\n\\nWithin the .NE\", \"T Framework infrastructure, there\\u2019s a hierarchy of configuration files that inherit\\nproperties from \", \"its parents. You can find a _machine.config_ file that defines many properties and\\nconfiguration sec\", \"tions that can be used or overridden in any descendant configuration file.\\n\\n#### **Configuration on \", \".NET**\\n\\n\\nIn the .NET world, there\\u2019s no _machine.config_ file. And even though you can continue to us\", \"e the old\\n[fashioned System.Configuration namespace, you may consider switching to the modern](https\", \"://docs.microsoft.com/dotnet/api/system.configuration)\\n[Microsoft.Extensions.Configuration, which of\", \"fers a good number of enhancements.](https://docs.microsoft.com/dotnet/api/microsoft.extensions.conf\", \"iguration)\\n\\n\\nThis configuration API supports the concept of a configuration provider, which defines \", \"the data source\\nto be used to load the configuration. There are different kinds of built-in provider\", \"s, such as:\\n\\n\\n  - In-memory .NET objects\\n\\n  - INI files\\n\\n  - JSON files\\n\\n  - XML files\\n\\n  - Command-\", \"line arguments\\n\\n  - Environment variables\\n\\n  - Encrypted user store\\n\\n\\nOr you can build your own.\\n\\n\\nT\", \"he new configuration API allows a list of name-value pairs that can be grouped into a multi-level\\nhi\", \"erarchy. Any stored value maps to a string, and there\\u2019s built-in binding support that allows you to\\n\", \"deserialize settings into a custom plain old CLR object (POCO).\\n\\n\\n[The ConfigurationBuilder object l\", \"ets you add as many configuration providers as you may need for](https://docs.microsoft.com/dotnet/a\", \"pi/microsoft.extensions.configuration.configurationbuilder)\\nyour application. A precedence rule is u\", \"sed to resolve provider preference. So, the last provider you\\nadd in your code overrides the others.\", \" This is a great feature for managing different environments for\\nexecution since you can define diff\", \"erent configurations for development, testing, and production\\nenvironments. And you can manage them \", \"in a single function inside your code.\\n\\n#### **Migrating configuration files**\\n\\n\\nYou can continue to\", \" use your existing app.config XML file. However, you could take this opportunity\\nto migrate your con\", \"figuration to benefit from the several enhancements made in .NET.\\n\\n\\nTo migrate from an old-style _ap\", \"p.config_ to a new configuration file, you should choose between an\\nXML format and a JSON format.\\n\\n\\n\", \"If you choose XML, the conversion is straightforward. Since the content is the same, just save the\\n_\", \"app.config_ file with XML as type. Then, change the code that references AppSettings to use the\\n[Con\", \"figurationBuilder](https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.configur\", \"ationbuilder) class. This change should be easy.\\n\\n\\n[If you want to use a JSON format and you don\\u2019t w\", \"ant to migrate by hand, there\\u2019s a tool called dotnet-](https://www.nuget.org/packages/dotnet-config2\", \"json/)\\n[config2json](https://www.nuget.org/packages/dotnet-config2json/) that can convert an _app.co\", \"nfig_ file to a JSON configuration file.\\n\\n\\nYou may come across some issues when using configuration \", \"sections that were defined in the\\n_machine.config_ file. For example, consider the following configu\", \"ration:\\n\\n\\n17 CHAPTER 3 | Migrating Modern Desktop applications\\n\\n\\nIf you take this configuration to a\", \" .NET app, you\\u2019ll get an exception:\\n\\n\\nUnrecognized configuration section System.Diagnostics\\n\\n\\nThis e\", \"xception occurs because that section and the assembly responsible for handling that section\\nwas defi\", \"ned in the _machine.config_ file, which now doesn\\u2019t exist.\\n\\n\\nTo easily fix the issue, you can copy t\", \"he section definition from your old _machine.config_ to your new\\nconfiguration file:\\n\\n### Accessing \", \"databases\\n\\n\\nAlmost every desktop application needs some kind of database. For desktop, it\\u2019s common t\", \"o find\\nclient-server architectures with a direct connection between the desktop app and the database\", \"\\nengine. These databases can be local or remote depending on the need to share information between\\nd\", \"ifferent users.\\n\\n\\nFrom the code perspective, there have been many technologies and frameworks to giv\", \"e the developer\\nthe possibility to connect, query, and update a database.\\n\\n\\nThe most common examples\", \" of database you can find when talking about Windows Desktop\\napplication are Microsoft Access and Mi\", \"crosoft SQL Server. If you have more than 20 years of\\nexperience programming for the desktop, names \", \"like ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ, and\\nEntity Framework will sound familiar.\\n\\n\\n18 CHAPTER 3 \", \"| Migrating Modern Desktop applications\\n\\n\\n#### **ODBC**\\n\\nYou can continue to use ODBC on .NET since \", \"Microsoft is providing the System.Data.Odbc library\\ncompatible with .NET Standard 2.0.\\n\\n#### **OLE D\", \"B**\\n\\n\\n[OLE DB](https://docs.microsoft.com/previous-versions/windows/desktop/ms722784(v=vs.85)) has b\", \"een a great way to access various data sources in a uniform manner. But it was based on\\nCOM, which i\", \"s a Windows-only technology, and as such wasn\\u2019t the best fit for a cross-platform\\ntechnology such as\", \" .NET. It\\u2019s also unsupported in SQL Server versions 2014 and later. For those\\nreasons, OLE DB won\\u2019t \", \"be supported by .NET.\\n\\n#### **ADO.NET**\\n\\n\\nYou can still use ADO.NET from your existing desktop code \", \"on .NET. You just need to update some\\nNuGet packages.\\n\\n#### **EF Core vs. EF6**\\n\\n\\nThere are two curr\", \"ently supported versions of Entity Framework (EF), Entity Framework 6 (EF6) and EF\\nCore.\\n\\n\\nThe lates\", \"t technology released as part of the .NET Framework world is Entity Framework, with 6.4\\nbeing the la\", \"test version. With the launch of .NET Core, Microsoft also released a new data access stack\\nbased on\", \" Entity Framework and called Entity Framework Core.\\n\\n\\nYou can use EF 6.4 and EF Core from both .NET \", \"Framework and .NET. So, what are the decision drivers\\nto help to decide between the two?\\n\\n\\nEF 6.3 is\", \" the first version of EF6 that can run on .NET and work cross-platform. In fact, the main goal of\\nth\", \"is release was to make it easier to migrate existing applications that use EF6 to .NET.\\n\\n\\nEF Core wa\", \"s designed to provide a developer experience similar to EF6. Most of the top-level APIs\\nremain the s\", \"ame, so EF Core will feel familiar to developers who have used EF6.\\n\\n\\nAlthough compatible, there are\", \" differences on the implementation you should check before making a\\n[decision. For more information,\", \" see Compare EF Core & EF6.](https://docs.microsoft.com/ef/efcore-and-ef6/)\\n\\n\\nThe recommendation is \", \"to use EF Core if:\\n\\n\\n  - The app needs the capabilities of .NET.\\n\\n  - EF Core supports all of the fe\", \"atures that the app requires.\\n\\n\\nConsider using EF6 if both of the following conditions are true:\\n\\n\\n \", \" - The app will run on Windows and .NET Framework 4.0 or later.\\n\\n  - EF6 supports all of the feature\", \"s that the app requires.\\n\\n\\n19 CHAPTER 3 | Migrating Modern Desktop applications\\n\\n\\n#### **Relational \", \"databases**\\n\\n**SQL Server**\\n\\n\\nSQL Server has been one of the databases of choice if you were develop\", \"ing for the desktop some\\n[years ago. With the use of System.Data.SqlClient](https://docs.microsoft.c\", \"om/dotnet/api/system.data.sqlclient) in .NET Framework, you could access versions of SQL\\nServer, whi\", \"ch encapsulates database-specific protocols.\\n\\n\\nIn .NET, you can find a new SqlClient class, fully co\", \"mpatible with the one existing in the .NET\\n[Framework but located in the Microsoft.Data.SqlClient](h\", \"ttps://docs.microsoft.com/dotnet/api/microsoft.data.sqlclient) library. You just have to add a refer\", \"ence to the\\n[Microsoft.Data.SqlClient](https://www.nuget.org/packages/Microsoft.Data.SqlClient/) NuG\", \"et package and do some renaming for the namespaces and everything\\nshould work as expected.\\n\\n\\n**Micro\", \"soft Access**\\n\\n\\nMicrosoft Access has been used for years when the sophisticated and more scalable SQ\", \"L Server wasn\\u2019t\\n[needed. You can still connect to Microsoft Access using the System.Data.Odbc](https\", \"://docs.microsoft.com/dotnet/api/system.data.odbc) library.\\n\\n### Consuming services\\n\\n\\nWith the rise \", \"of service-oriented architectures, desktop applications began to evolve from a clientserver model to\", \" the three-layer approach. In the client-server approach, a direct database connection\\nis establishe\", \"d from the client holding the business logic, usually inside a single EXE file. On the other\\nhand, t\", \"he three-layer approach establishes an intermediate service layer implementing business logic\\nand da\", \"tabase access, allowing for better security, scalability, and reusability. Instead of working\\ndirect\", \"ly with underlying data, the layered approach relies on a set of services implementing contracts\\nand\", \" typed objects for data transfer.\\n\\n\\nIf you have a desktop application using a WCF service and you wa\", \"nt to migrate it to .NET, there are\\nsome things to consider.\\n\\n\\nThe first thing is how to resolve the\", \" configuration to access the service. Because the configuration is\\ndifferent on .NET, you\\u2019ll need to\", \" make some updates in your configuration file.\\n\\n\\nSecond, you\\u2019ll need to regenerate the service clien\", \"t with the new tools present on Visual Studio 2019\\nand Visual Studio 2022. In this step, you must co\", \"nsider activating the generation of the synchronous\\noperations to make the client compatible with yo\", \"ur existing code.\\n\\n\\nAfter the migration, if you find that there are libraries you need that aren\\u2019t p\", \"resent on .NET, you can\\n[add a reference to the Microsoft.Windows.Compatibility](https://www.nuget.o\", \"rg/packages/Microsoft.Windows.Compatibility) NuGet package and see if the missing\\nfunctions are ther\", \"e.\\n\\n\\n[If you\\u2019re using the WebRequest class to perform web service calls, you may find some differenc\", \"es on](https://docs.microsoft.com/dotnet/api/system.net.webrequest)\\n[.NET. The recommendation is to \", \"use HttpClient](https://learn.microsoft.com/dotnet/api/system.net.http.httpclient) instead.\\n\\n\\n20 CHA\", \"PTER 3 | Migrating Modern Desktop applications\\n\\n\\n### Consuming a COM Object\\n\\nCurrently, there\\u2019s no w\", \"ay to add a reference to a COM object from Visual Studio 2019 or Visual Studio\\n2022 to use with .NET\", \". So, you have to manually modify the project file.\\n\\n\\nInsert a COMReference structure inside the pro\", \"ject file like in the following example:\\n\\n### More things to consider\\n\\n\\nSeveral technologies availab\", \"le to .NET Framework libraries aren\\u2019t available for .NET Core or .NET 7. If\\nyour code relies on some\", \" of these technologies, consider the alternative approaches outlined in this\\nsection.\\n\\n\\n[The Windows\", \" Compatibility Pack provides access to APIs that were previously available only for .NET](https://do\", \"cs.microsoft.com/dotnet/core/porting/windows-compat-pack)\\nFramework. It can be used on .NET Core and\", \" .NET Standard projects.\\n\\n\\nFor more information on API compatibility, you can find documentation abo\", \"ut breaking changes and\\n[deprecated/legacy APIs at https://learn.microsoft.com/dotnet/core/compatibi\", \"lity/fx-core.](https://docs.microsoft.com/dotnet/core/compatibility/fx-core)\\n\\n#### **AppDomains**\\n\\n\\n\", \"Application domains (AppDomains) isolate apps from one another. AppDomains require runtime\\nsupport a\", \"nd are expensive. Creating additional app domains isn\\u2019t supported. For code isolation, we\\nrecommend \", \"separate processes or using containers as an alternative. For the dynamic loading of\\n[assemblies, we\", \" recommend the new AssemblyLoadContext](https://docs.microsoft.com/dotnet/api/system.runtime.loader.\", \"assemblyloadcontext) class.\\n\\n\\nTo make code migration from .NET Framework easier, .NET exposes some o\", \"f the AppDomain API\\n[surface. Some of the APIs function normally (for example, AppDomain.UnhandledEx\", \"ception), some](https://docs.microsoft.com/dotnet/api/system.appdomain.unhandledexception)\\n[members \", \"do nothing (for example, SetCachePath), and some of them throw](https://docs.microsoft.com/dotnet/ap\", \"i/system.appdomain.setcachepath)\\n[PlatformNotSupportedException (for example, CreateDomain).](https:\", \"//docs.microsoft.com/dotnet/api/system.platformnotsupportedexception)\\n\\n#### **Remoting**\\n\\n\\n.NET Remo\", \"ting was used for cross-AppDomain communication, which is no longer supported. Also,\\nRemoting requir\", \"es runtime support, which is expensive to maintain. For these reasons, .NET Remoting\\nisn\\u2019t supported\", \" on .NET.\\n\\n\\nFor communication across processes, you should consider inter-process communication (IPC\", \")\\n[mechanisms as an alternative to Remoting, such as the or the MemoryMappedFile class.](https://doc\", \"s.microsoft.com/dotnet/api/system.io.memorymappedfiles.memorymappedfile)\\n\\n\\n21 CHAPTER 3 | Migrating \", \"Modern Desktop applications\\n\\n\\nAcross machines, use a network-based solution as an alternative. Prefe\", \"rably, use a low-overhead\\nplaintext protocol, such as HTTP. The Kestrel web server, the web server u\", \"sed by ASP.NET Core, is an\\noption here.\\n\\n#### **Code Access Security (CAS)**\\n\\n\\nSandboxing, which rel\", \"ies on the runtime or the framework to constrain which resources a managed\\napplication or library us\", \"es or runs, isn\\u2019t supported on .NET.\\n\\n\\nUse security boundaries that are provided by the operating sy\", \"stem, such as virtualization, containers,\\nor user accounts, for running processes with the minimum s\", \"et of privileges.\\n\\n#### **Security Transparency**\\n\\n\\nSimilar to CAS, Security Transparency separates \", \"sandboxed code from security critical code in a\\ndeclarative fashion but is no longer supported as a \", \"security boundary.\\n\\n\\nUse security boundaries that are provided by the operating system, such as virt\", \"ualization, containers,\\nor user accounts, for running processes with the least set of privileges.\\n\\n\\n\", \"22 CHAPTER 3 | Migrating Modern Desktop applications\\n\\n\\n**CHAPTER**\\n# 4\\n\\n## Windows 10 migration\\n\\n\\nCo\", \"nsider the following situation: You have a working desktop application that was developed in the\\nWin\", \"dows 7 days. It\\u2019s using WPF technology available at that time and working fine but it has an\\noutdate\", \"d UI and behaviors when you run it on Windows 10 or Windows 11. It is like when you watch a\\nfuturist\", \"ic movie like Matrix and you see Neo using the Nokia 8110 device. The film works great after\\n20 year\", \"s but it would rather benefit from a device modernization.\\n\\n\\nWith the release of Windows 10, Microso\", \"ft introduced many innovations to support scenarios like\\ntablets and touch devices and to provide th\", \"e best experience for users for a Microsoft operating\\nsystem ever. For example, you can:\\n\\n\\n  - Sign \", \"in with your face using Windows Hello.\\n\\n  - Use a pen to draw or handwrite text that is automaticall\", \"y recognized and digitalized.\\n\\n  - Run locally customized AI models built on the cloud using WinML.\\n\", \"\\n\\nAll these features are enabled for Windows developers through Windows Runtime (WinRT) libraries.\\nY\", \"ou can take advantage of these features in your existing desktop apps because the libraries are\\nexpo\", \"sed to both the .NET Framework and .NET as well. You can even modernize your UI with the use\\nof XAML\", \" Islands and improve the visuals and behavior of your apps according to the times.\\n\\n\\nOne important t\", \"hing to note here is that you don\\u2019t need to abandon .NET Framework technology to\\nfollow this moderni\", \"zation path. You can safely stay on there and have all the benefits of Windows 10\\nand Windows 11 wit\", \"hout the pressure to migrate to .NET. So, you get both the power and the\\nflexibility to choose your \", \"modernization path.\\n\\n### WinRT APIs\\n\\n\\nWinRT APIs are object-oriented, well-structured application pr\", \"ogramming interfaces (APIs) that give\\nWindows 10 and Windows 11 developers access to everything the \", \"operating system has to offer.\\nThrough WinRT APIs, you can integrate functionalities like Push Notif\", \"ications, Device APIs, Microsoft\\nInk, and WinML, among others on your desktop apps.\\n\\n\\nIn general, Wi\", \"nRT APIs can be called from a classic desktop app. However, two main areas present an\\nexception to t\", \"his rule:\\n\\n\\n  - APIs that require a package identity.\\n\\n  - APIs that require visualization like XAML\", \" or Composition.\\n\\n\\n23 CHAPTER 4 | Windows 10 migration\\n\\n\\n#### **Universal Windows Platform (UWP) pac\", \"kages**\\n\\n**Application Package Identity**\\n\\n\\nUWP apps have a deployment system where the OS manages t\", \"he installation and uninstallation of\\napplication. That requires the installation to be declarative,\", \" meaning that no user code is executed\\nduring install. Instead, everything the app wants to integrat\", \"e with the system, such as protocols, file\\ntypes, and extensions, is declared in the application man\", \"ifest. At deployment time, the deployment\\npipeline configures those integration points. The only way\", \" for the OS to manage all this functionality\\nand keep track of it is for each \\u2018package\\u2019 to have an i\", \"dentity, a unique identifier for the application.\\n\\n\\nSome WinRT APIs require this package identity to\", \" work as expected. However, classic desktop apps\\nlike native C++ or .NET apps, use different deploym\", \"ent systems that don\\u2019t require a package identity.\\nIf you want to use these WinRT APIs in your deskt\", \"op application, you need to provide them a package\\nidentity.\\n\\n\\nOne way to proceed is to build an add\", \"itional packaging project. Inside the packaging project, you\\npoint to the original source code proje\", \"ct and specify the Identity information you want to provide. If\\nyou install the package and run the \", \"installed app, it will automatically get an identify enabling your\\ncode to call all WinRT APIs requi\", \"ring Identity.\\n\\n\\nYou can check which APIs need a packaged application identity by inspecting if the \", \"type that contains\\n[the API is marked with the DualApiPartition](https://docs.microsoft.com/uwp/api/\", \"windows.foundation.metadata.dualapipartitionattribute) attribute. If it is, you can call if from an \", \"unpackaged\\ntraditional desktop app. Otherwise, you must convert your classic desktop app to a UWP wi\", \"th the help\\nof a packaging project.\\n\\n\\n[https://learn.microsoft.com/windows/desktop/apiindex/uwp-apis\", \"-callable-from-a-classic-desktop-app](https://docs.microsoft.com/windows/desktop/apiindex/uwp-apis-c\", \"allable-from-a-classic-desktop-app)\\n\\n\\n**Benefits of packaging**\\n\\n\\nBesides giving you access to these\", \" APIs, you get some additional benefits by creating a Windows App\\npackage for your desktop applicati\", \"on including:\\n\\n\\n  - **Streamlined deployment** . Apps have a great deployment experience ensuring th\", \"at users can\\nconfidently install an application and update it. If a user chooses to uninstall the ap\", \"p, it\\u2019s\\nremoved completely with no trace left behind preventing the Windows rot problem.\\n\\n\\n  - **Aut\", \"omatic updates and licensing** . Your application can participate in the Microsoft Store\\u2019s\\nbuilt-in \", \"licensing and automatic update facilities. Automatic update is a highly reliable and\\nefficient mecha\", \"nism, because only the changed parts of files are downloaded.\\n\\n\\n24 CHAPTER 4 | Windows 10 migration\\n\", \"\\n\\n  - **Increased reach and simplified monetization** . Maybe not your case but if you choose to\\ndis\", \"tribute your application through the Microsoft Store you reach millions of Windows 10 and\\nWindows 11\", \" users.\\n\\n\\n  - **Add UWP features** . You can add UWP features to your app\\u2019s package at your own pace\", \".\\n\\n\\n**Prepare for packaging**\\n\\n\\nBefore proceeding to package your desktop application, there are som\", \"e points you have to address\\nbefore starting the process. Your application must respect any of the M\", \"icrosoft Store rules and\\npolicies and run in the UWP application model. For example, it has to run o\", \"n the .NET Framework 4.6.2\\nor later and writes to the HKEY_CURRENT_USER registry hive and the AppDat\", \"a folders will be\\nvirtualized to a user-specific app-local location.\\n\\n\\nThe design goal for packaging\", \" is to separate the application state from system state while maintaining\\ncompatibility with other a\", \"pps. Windows 10 and Windows 11 accomplish this goal by placing the\\napplication inside a UWP package.\", \" It detects and redirects some changes to the file system and\\nregistry at run time to fulfill the pr\", \"omise of a trusted and clean install and uninstall behavior of an\\napplication provided by packaging.\", \"\\n\\n\\nPackages that you create for your desktop application are desktop-only, full-trust applications t\", \"hat\\naren\\u2019t sandboxed, although there\\u2019s lightweight virtualization applied to the app for writes to H\", \"KCU\\nand AppData. This virtualization allows them to interact with other apps the same way classic de\", \"sktop\\napplications do.\\n\\n\\n**Installation**\\n\\n\\nApp packages are installed under _%ProgramFiles%\\\\Windows\", \"Apps\\\\package_name_, with the executable\\ntitled app_name.exe. Each package folder contains a manifest\", \" (named AppxManifest.xml) that contains\\na special XML namespace for packaged apps. Inside that manif\", \"est file is an <EntryPoint> element,\\nwhich references the full-trust app. When that application is l\", \"aunched, it doesn\\u2019t run inside an app\\ncontainer, but instead it runs as the user as it normally woul\", \"d.\\n\\n\\nAfter deployment, package files are marked read-only and heavily locked down by the operating\\ns\", \"ystem. Windows prevents apps from launching if these files are tampered with.\\n\\n\\n**File system**\\n\\n\\nTh\", \"e OS supports different levels of file system operations for packaged desktop applications,\\ndependin\", \"g on the folder location.\\n\\n\\nWhen trying to access the user\\u2019s _AppData_ folder, the system creates a \", \"private per-user, per-app\\nlocation behind the scenes. This creates the illusion that the packaged ap\", \"plication is editing the real\\n_AppData_ when it\\u2019s actually modifying a private copy. By redirecting \", \"writes this way, the system can\\ntrack all file modifications made by the app. It can then clean all \", \"those files when uninstalling reducing\\nsystem \\u201crot\\u201d and providing a better application removal exper\", \"ience for the user.\\n\\n\\n25 CHAPTER 4 | Windows 10 migration\\n\\n\\n**Registry**\\n\\n\\nApp packages contain a re\", \"gistry.dat file, which serves as the logical equivalent of HKLM\\\\Software in\\nthe real registry. At ru\", \"n time, this virtual registry merges the contents of this hive into the native\\nsystem hive to provid\", \"e a singular view of both.\\n\\n\\nAll writes are kept during package upgrade and only deleted when the ap\", \"plication is uninstalled.\\n\\n\\n**Uninstallation**\\n\\n\\nWhen the user uninstalls a package, all files and f\", \"olders located under C:\\\\Program\\nFiles\\\\WindowsApps\\\\package_name are removed, as well as any redirecte\", \"d writes to AppData or the\\nregistry that were captured during the process.\\n\\n\\nFor details about how a\", \" packaged application handles installation, file access, registry, and\\n[uninstallation, see https://\", \"learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-the-](https://docs.microsoft.com/wind\", \"ows/msix/desktop/desktop-to-uwp-behind-the-scenes)\\n[scenes.](https://docs.microsoft.com/windows/msix\", \"/desktop/desktop-to-uwp-behind-the-scenes)\\n\\n\\nYou can get a complete list of things to check on\\n[http\", \"s://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-prepare.](https://docs.microsoft.com/win\", \"dows/msix/desktop/desktop-to-uwp-prepare)\\n\\n### How to add WinRT APIs to your desktop project\\n\\n\\nIn th\", \"is section, you can find a walkthrough on how to integrate Toast Notifications in an existing WPF\\nap\", \"plication. Although it\\u2019s simple from the code perspective, it helps illustrate the whole process.\\nNo\", \"tifications are one of the many available WinRT APIs available that you can use in .NET app. In this\", \"\\ncase, the API requires a Package Identity. This process is more straightforward if the APIs don\\u2019t r\", \"equire\\nPackage Identity.\\n\\n\\nLet\\u2019s take an existing WPF sample app that reads files and shows its cont\", \"ents on the screen. The goal\\nis to display a Toast Notification when the application starts.\\n\\n\\n26 CH\", \"APTER 4 | Windows 10 migration\\n\\n\\nFirst, you should check in the following link whether the Windows 1\", \"0 or Windows 11 API that you\\u2019ll\\nuse requires a Package Identity:\\n\\n\\n[https://learn.microsoft.com/wind\", \"ows/apps/desktop/modernize/desktop-to-uwp-supported-api](https://docs.microsoft.com/windows/apps/des\", \"ktop/modernize/desktop-to-uwp-supported-api)\\n\\n\\n[Our sample will use the Windows.UI.Notifications.Not\", \"ification](https://docs.microsoft.com/uwp/api/windows.ui.notifications.notification) API that requir\", \"es a packaged identity:\\n\\n\\nTo access the WinRT API, add a reference to the Microsoft.Windows.SDK.Cont\", \"racts NuGet package\\nand this package will do the magic behind the scenes (see details at\\n[https://bl\", \"ogs.windows.com/windowsdeveloper/2019/04/30/calling-windows-10-apis-from-a-desktop-](https://blogs.w\", \"indows.com/windowsdeveloper/2019/04/30/calling-windows-10-apis-from-a-desktop-application-just-got-e\", \"asier/)\\n[application-just-got-easier/).](https://blogs.windows.com/windowsdeveloper/2019/04/30/calli\", \"ng-windows-10-apis-from-a-desktop-application-just-got-easier/)\\n\\n\\nYou\\u2019re now prepared to start addin\", \"g some code.\\n\\n\\n27 CHAPTER 4 | Windows 10 migration\\n\\n\\nCreate a ShowToastNotification method that will\", \" be called on application startup. It just builds a toast\\nnotification from an XML pattern:\\n\\n\\nAlthou\", \"gh the project builds, there are errors because the Notifications API requires a Package Identity\\nan\", \"d you didn\\u2019t provide it. Adding a Windows Packaging Project to the solution will fix the issue:\\n\\n\\nSe\", \"lect the minimum Windows version you want to support and the version you\\u2019re targeting. Not all\\nthe W\", \"inRT APIs are supported in all Windows 10 and Windows 11 versions. Each Windows 10 or\\nWindows 11 upd\", \"ate adds new APIs that are only available from this version; down-level support isn\\u2019t\\navailable.\\n\\n\\n2\", \"8 CHAPTER 4 | Windows 10 migration\\n\\n\\nNext step is to add the WPF application to the Windows Packagin\", \"g Project by adding a project\\nreference:\\n\\n\\n29 CHAPTER 4 | Windows 10 migration\\n\\n\\nA Windows Packaging\", \" Project can package several apps so you should set which one is the Entry\\nPoint:\\n\\n\\n30 CHAPTER 4 | W\", \"indows 10 migration\\n\\n\\nNext step is to set the WPF Project as the startup Project in the solution con\", \"figuration. You can press\\nF5 to compile and build and see the results.\\n\\n\\nLet\\u2019s generate the package \", \"so you can install your app. Right click on **Store** - **Create App Packages** .\\n\\n\\n31 CHAPTER 4 | W\", \"indows 10 migration\\n\\n\\nSelect the sideloading option to deploy the app from your machine:\\n\\n\\n32 CHAPTE\", \"R 4 | Windows 10 migration\\n\\n\\nSelect the application architecture of your app:\\n\\n\\n33 CHAPTER 4 | Windo\", \"ws 10 migration\\n\\n\\nFinally, create the package by clicking on **Create** .\\n\\n### XAML Islands\\n\\n\\nXAML I\", \"slands are a set of components that enable Windows desktop developers to use UWP XAML\\ncontrols on th\", \"eir existing Win32 applications, including Windows Forms and WPF.\\n\\n\\n34 CHAPTER 4 | Windows 10 migrat\", \"ion\\n\\n\\nYou can image your Win32 app with your standard controls and among them an \\u201cisland\\u201d of UWP UI\\n\", \"containing controls from the modern world. The concept is similar to having an iFrame inside a web\\np\", \"age that shows content from a different page.\\n\\n\\nBesides adding functionality from the Windows 10 and\", \" Windows 11 APIs, you can add pieces of UWP\\nXAML inside of your app using XAML Islands.\\n\\n\\nWindows 10\", \" 1903 update introduced a set of APIs that allow hosting UWP XAML content in Win32\\nwindows. Only app\", \"s running on Windows 10 1903 or later can use XAML Islands.\\n\\n#### **The road to XAML Islands**\\n\\n\\nThe\", \" road to XAML Islands started in 2012 when Microsoft introduced the WinRT APIs as a framework\\nto mod\", \"ernize the Win32 apps (Windows Forms, WPF, and native Win32 apps). However, the new UI\\ncontrols insi\", \"de WinRT were available for new applications but not for existing ones.\\n\\n\\nIn 2015, along with Window\", \"s 10, UWP was born. UWP allows you to create apps that work across\\nWindows devices like XBox, Mobile\", \", and Desktop. One year later, Microsoft announced Desktop\\nBridge (formerly known as Project Centenn\", \"ial). Desktop Bridge is a set of tools that allowed\\ndevelopers to bring their existing Win32 apps to\", \" the Microsoft Store. More capabilities were added in\\n2017, allowing developers to enhance their Win\", \"32 apps leveraging some of the new Windows 10 APIs,\\nlike live tiles and notifications on the action \", \"center. But still, no new UI controls.\\n\\n\\nAt Build 2018, Microsoft announced a way for developers to \", \"use the new Windows 10 XAML controls\\ninto their current Win32 apps, without fully migrating their ap\", \"ps to UWP. It was branded as UWP\\nXAML Islands.\\n\\n#### **How it works**\\n\\n\\nThe Windows 10 1903 update i\", \"ntroduced several XAML hosting APIs. Two of them are\\nWindowsXamlManager and DesktopWindowXamlSource.\", \"\\n\\n\\n35 CHAPTER 4 | Windows 10 migration\\n\\n\\nThe WindowsXamlManager class handles the UWP XAML Framework\", \". Its InitializeForCurrentThread\\nmethod loads the UWP XAML Framework inside the current thread of th\", \"e Win32 app.\\n\\n\\nThe DesktopWindowXamlSource is the instance of your XAML Island content. It has the C\", \"ontent\\nproperty, which you\\u2019re responsible for instantiating and setting. The DesktopWindowXamlSource\", \"\\nrenders and gets its input from an HWND. It needs to know to which other HWND it will attach the\\nXA\", \"ML Island\\u2019s one, and you\\u2019re responsible for sizing and positioning the parent\\u2019s HWND.\\n\\n\\nWPF or Windo\", \"ws Forms developers don\\u2019t usually deal with HWND inside their code, so it may be hard\\nto understand \", \"and handle HWND pointers and the underlying wiring stuff to communicate Win32 and\\nUWP worlds.\\n\\n\\n**Th\", \"e XAML Islands .NET Wrappers**\\n\\n\\nThe Windows Community Toolkit has a set the XAML Islands .NET wrapp\", \"ers for WPF or Windows\\nForms that make easier to use XAML Islands. These wrappers manage the HWNDs, \", \"the focus\\nmanagement, among other things. Windows Forms and WPF developers should use these wrappers\", \".\\n\\n\\nThe Windows Community Toolkit offers two types of controls: Wrapped Controls and Hosting\\nControl\", \"s.\\n\\n\\n**Wrapped Controls**\\n\\n\\nThese wrapped controls wrap some UWP controls into Windows Forms or WPF \", \"controls, hiding UWP\\nconcepts for those developers. These controls are:\\n\\n\\n  - WebView and WebViewCom\", \"patible\\n\\n  - InkCanvas and InkToolbar\\n\\n  - MediaPlayerElement\\n\\n  - MapControl\\n\\nAdd the Microsoft.Too\", \"lkit.Wpf.UI.Controls package to your project, include the reference to the\\nnamespace, and start usin\", \"g them.\\n\\n\\n**Hosting controls**\\n\\n\\nThe power of XAML Islands extends to most first-party controls, thi\", \"rd-party controls, and custom\\ncontrols developed for UWP, which can be integrated into Windows Forms\", \" and WPF as \\u201cIslands\\u201d with\\nfully functional UI. The WindowsXamlHost control for WPF and Windows Form\", \"s allows doing this.\\n\\n\\n36 CHAPTER 4 | Windows 10 migration\\n\\n\\nFor example, to use the WindowsXamlHost\", \" control in WPF, add a reference to the\\nMicrosoft.Toolkit.Wpf.UI.XamlHost package provided by the Wi\", \"ndows Community Toolkit.\\n\\n\\nOnce you\\u2019ve placed your WindowsXamlHost into your UI code, specify which \", \"UWP type you want to\\nload. You can choose to use a wrapped control like a Button or a more complex o\", \"ne composed of\\nseveral different controls, which are a custom UWP control.\\n\\n\\nThe following example s\", \"hows how to add a UWP Button:\\n\\n\\nThere\\u2019s a clear recommendation on how to approach this and it\\u2019s bett\", \"er to have one single and bigger\\nXAML Island containing a custom composite control than to have seve\", \"ral islands with one control on\\neach.\\n\\n\\nOne of the core features of XAML is binding and it works bet\", \"ween your Win32 code and the island.\\nSo, you can bind, for instance, a Win32 Textbox with a UWP Text\", \"box. One important thing to consider\\nis that these bindings are one-way bindings, from UWP to Win32,\", \" so if you update the Textbox inside\\nthe XAML Island the Win32 Textbox will be updated, but not the \", \"other way around.\\n\\n\\nTo see a walkthrough about how to use XAML Islands, see:\\n\\n\\n[https://learn.micros\", \"oft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml-](https://docs.microsoft.com/\", \"windows/apps/desktop/modernize/host-standard-control-with-xaml-islands)\\n[islands](https://docs.micro\", \"soft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml-islands)\\n\\n\\n**Adding UWP XAML\", \" custom controls**\\n\\n\\nA XAML custom control is a control (or user control) created by you or by third\", \" parties (including\\nWinUI 2.x controls). To host a custom UWP control in a Windows Forms or WPF app,\", \" you\\u2019ll need:\\n\\n\\n  - To use the WindowsXamlHost UWP control in your .NET app.\\n\\n  - To create a UWP ap\", \"p project that defines a XamlApplication object.\\n\\nYour WPF or Windows Forms project must have access\", \" to an instance of the\\nMicrosoft.Toolkit.Win32.UI.XamlHost.XamlApplication class provided by the Win\", \"dows Community\\nToolkit. This object acts as a root metadata provider for loading metadata for custom\", \" UWP XAML\\ntypes in assemblies in the current directory of your application. The recommended way to d\", \"o this is to\\nadd a Blank App (Universal Windows) project to the same solution as your WPF or Windows\", \" Forms\\nproject and revise the default App class in this project.\\n\\n\\nThe custom UWP XAML control can b\", \"e included on this UWP app or in an independent UWP Class\\nLibrary project that you reference in the \", \"same solution as your WPF or Windows Forms project.\\n\\n\\nYou can check a detailed step-by-step process \", \"description at:\\n\\n\\n[https://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-control-wi\", \"th-xaml-](https://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-is\", \"lands)\\n[islands](https://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-\", \"xaml-islands)\\n\\n\\n37 CHAPTER 4 | Windows 10 migration\\n\\n\\n**The Windows UI Library (WinUI 2)**\\n\\n\\nBesides\", \" the inbox Windows 10 controls that comes with the OS, the same UWP XAML team also\\ndelivers addition\", \"al controls in the Windows UI Library ( **WinUI 2** ). WinUI 2 provides official native\\nMicrosoft UI\", \" controls and features for Windows UWP apps and these controls can be used inside of\\nXAML Islands.\\n\\n\", \"\\n[WinUI 2 is open source and you can find information at https://github.com/microsoft/microsoft-ui-]\", \"(https://github.com/microsoft/microsoft-ui-xaml)\\n[xaml.](https://github.com/microsoft/microsoft-ui-x\", \"aml)\\n\\n\\nThe following article demonstrates how to host a UWP XAML control from the WinUI 2 library:\\n[\", \"https://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-](https://d\", \"ocs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-islands)\\n[islands](ht\", \"tps://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-islands)\\n\\n####\", \" **Do you need XAML Islands**\\n\\n\\nXAML Islands are intended for existing Win32 apps that want to impro\", \"ve their user experience by\\nleveraging new UWP controls and behaviors without a full rewrite of the \", \"app. You could already\\n[leverage Windows 10 and Windows 11 APIs, but up until XAML Islands, only non\", \"-UI related APIs.](https://docs.microsoft.com/windows/uwp/porting/desktop-to-uwp-enhance)\\n\\n\\n[If you\\u2019\", \"re developing a new Windows App, a UWP App](https://docs.microsoft.com/windows/uwp/get-started/unive\", \"rsal-application-platform-guide) is probably the right approach.\\n\\n#### **The road ahead XAML Islands\", \": WinUI 3.0**\\n\\n\\nSince Windows 8, the Windows UI platform, including the XAML UI framework, visual co\", \"mposition\\nlayer, and input processing has been shipped as an integral part of Windows. This means th\", \"at to\\nbenefit from the latest improvements on UI technologies, you must upgrade to the latest versio\", \"n of\\nthe UI, slowing down the pace of innovation when you develop your apps. To decouple these two\\ne\", \"volution cycles and foster innovation, Microsoft is actively working on the WinUI project.\\n\\n\\nStartin\", \"g with WinUI 2 in 2018, Microsoft started shipping some new XAML UI controls and features as\\nseparat\", \"e NuGet packages that build on top of the UWP SDK.\\n\\n\\n38 CHAPTER 4 | Windows 10 migration\\n\\n\\nWinUI 3 i\", \"s under active development and will greatly expand the scope of WinUI to include the full UI\\nplatfor\", \"m, which will be fully decoupled from the UWP SDK:\\n\\n\\n[XAML framework will now be developed on GitHub\", \" and shipped out of band as NuGet packages.](https://docs.microsoft.com/nuget/what-is-nuget)\\n\\n\\nThe e\", \"xisting UWP XAML APIs that ship as part of the OS will no longer receive new feature updates.\\nThey w\", \"ill still receive security updates and critical fixes according to the Windows 10 support lifecycle.\", \"\\n\\n\\nThe Universal Windows Platform contains more than just the XAML framework (for example,\\napplicati\", \"on and security model, media pipeline, Xbox and Windows 10 shell integrations, broad device\\nsupport)\", \" and will continue to evolve. All new XAML features will just be developed and ship as part of\\nWinUI\", \" instead.\\n\\n\\n**WinUI 3 in desktop app and WinUI XAML Islands**\\n\\n\\nAs you can see, WinUI 3 is the evolu\", \"tion of UWP XAML and it works naturally within the UWP app\\nmodel and all its requirements (MSIX pack\", \"aged ID, sandbox, CoreWindow, and so on. To use just\\nWinUI 3 in a Win32 app model, the WinUI content\", \" should be hosted by another UI Framework\\n(Windows Forms, WPF, and so on) using **WinUI XAML Islands\", \"** . This is the right path if you want to\\n\\n\\n39 CHAPTER 4 | Windows 10 migration\\n\\n\\nevolve your app a\", \"nd mix technologies. However, if you want to replace your entire old UI for WinUI,\\nyour app shouldn\\u2019\", \"t load UI Frameworks for just hosting WinUI.\\n\\n\\nWinUI 3 will address this critical feedback adding **\", \"WinUI in desktop apps** . This will allow that Win32\\napps can use WinUI 3 as standalone UI Framework\", \"; no need to load Windows Forms or WPF.\\n\\n\\nWithin this aggregation, WinUI 3 will let developers easil\", \"y mix and match the right combination of:\\n\\n\\n  - App model: UWP, Win32\\n\\n  - Platform: .NET or Native\\n\", \"\\n  - Language: .NET (C#, Visual Basic), standard C++\\n\\n  - Packaging: MSIX, AppX for the Microsoft St\", \"ore, unpackaged\\n\\n  - Interop: use WinUI 3 to extend existing WPF, WinForms, and MFC apps using WinUI\", \" XAML\\nIslands.\\n\\n\\nIf you want to know more details, Microsoft is sharing this roadmap in\\n[https://git\", \"hub.com/microsoft/microsoft-ui-xaml/blob/main/docs/roadmap.md.](https://github.com/microsoft/microso\", \"ft-ui-xaml/blob/main/docs/roadmap.md)\\n\\n\\n40 CHAPTER 4 | Windows 10 migration\\n\\n\\n**CHAPTER**\\n# 5\\n\\n## Ex\", \"ample of migrating to the latest .NET\\n\\n\\nIn this chapter, we\\u2019ll show how to migrate your applications\", \" to the latest version of .NET. You can\\nmigrate to .NET 7 from .NET Framework, .NET Core, or .NET 5.\", \" We\\u2019ll introduce a tool that can do all the\\nwork for you in most cases. If your application has spec\", \"ial cases or complicated dependencies, we\\u2019ll\\nalso show how to do the whole migration process by hand\", \". Additionally, we\\u2019ll cover the most common\\nissues and challenges you can face when migrating an exi\", \"sting application from .NET Framework to\\n.NET.\\n\\n### Migrating from .NET Core or .NET 5\\n\\n\\nUpdating yo\", \"ur applications to target the latest version of .NET is easy if you already are on .NET Core\\nor .NET\", \" 5. If this is the case, then in Visual Studio, simply right-click on your project in **Solution**\\n*\", \"*Explorer** and choose **Properties** . Under **Application** - **General** - **Target framework**, \", \"choose .NET\\n7.0. Save and rebuild your application. You\\u2019re done! Your app now runs on the latest ver\", \"sion of .NET.\\nIn the future when new versions become available, you can upgrade in the same way.\\n\\n\\n4\", \"1 CHAPTER 5 | Example of migrating to the latest .NET\\n\\n\\n### Migrating from .NET Framework\\n\\nMigrating\", \" from .NET Framework is a more complicated process because there are more differences\\nbetween .NET F\", \"ramework and other platforms that were built on top of .NET Core. But the good news\\nis that there\\u2019s \", \"a tool that will do all the work for you in most cases.\\n\\n#### **Migrating with a tool**\\n\\n\\n[The Upgra\", \"de Assistant](https://dotnet.microsoft.com/platform/upgrade-assistant) is a migration tool. Using it\", \" is easy and there are step-by-step instructions\\n[available on the .NET website. In this chapter, we\", \"\\u2019ll look at what is happening behind the scenes and](https://dotnet.microsoft.com/platform/upgrade-a\", \"ssistant/tutorial/intro)\\nhow to port your application by hand. When the Upgrade Assistant is unable \", \"to migrate your\\napplication, you\\u2019ll learn the underlying mechanics so that you might be able to migr\", \"ate manually.\\n\\n#### **Migrating by hand**\\n\\n\\nThe migration process consists of four sequential steps:\", \"\\n\\n\\n1. **Preparation** : Understand the dependencies the project has to have an idea of what\\u2019s ahead.\", \"\\nIn this step, you take the current project into a state that simplifies the startup point for the\\nm\", \"igration.\\n\\n\\n2. **Migrate Project File:** .NET projects use the new SDK-style project format. Create \", \"a new\\nproject file with this format or update the one you have to use the SDK style.\\n\\n\\n3. **Fix code\", \" and build:** Build the code in .NET addressing API-level differences between .NET\\nFramework and .NE\", \"T. If needed, update third-party packages to the ones that support .NET.\\n\\n\\n42 CHAPTER 5 | Example of\", \" migrating to the latest .NET\\n\\n\\n4. **Run and test:** There might be differences that don\\u2019t show up u\", \"ntil run time. So, don\\u2019t forget\\nto run the application and test that everything works as expected.\\n\\n\", \"#### **Preparation**\\n\\n\\n**Migrate packages.config file**\\n\\n\\nIn a .NET Framework application, all refer\", \"ences to external packages are declared in the\\n_packages.config_ file. In .NET, there\\u2019s no longer th\", \"e need to use the _packages.config_ file. Instead, use the\\n[PackageReference](https://docs.microsoft\", \".com/dotnet/core/project-sdk/msbuild-props#packagereference) property inside the project file to spe\", \"cify the NuGet packages for your app.\\n\\n\\nSo, you need to transition from one format to another. You c\", \"an do the update manually, taking the\\ndependencies contained in the _packages.config_ file and migra\", \"ting them to the project file with the\\nPackageReference format. Or, you can let Visual Studio do the\", \" work for you: right-click on the\\n_packages.config_ file and select the **Migrate packages.config to\", \" PackageReference** option.\\n\\n\\n**Verify every dependency compatibility in .NET**\\n\\n\\nOnce you\\u2019ve migrat\", \"ed the package references, you must check each reference for compatibility. You\\n[can explore the dep\", \"endencies of each NuGet package your application is using on nuget.org. If the](https://www.nuget.or\", \"g/)\\n[package has .NET Standard dependencies, then it\\u2019s going to work on .NET 7 because .NET supports\", \"](https://docs.microsoft.com/dotnet/standard/net-standard#net-implementation-support) all\\nversions o\", \"f .NET Standard. The following image shows the dependencies for the Castle.Windsor\\npackage:\\n\\n\\n[To ch\", \"eck the package compatibility, you can use the tool https://fuget.org](https://fuget.org/) that offe\", \"rs a more detailed\\ninformation about versions and dependencies.\\n\\n\\nMaybe the project is referencing o\", \"lder package versions that don\\u2019t support .NET, but you might find\\nnewer versions that do support it.\", \" So, updating packages to newer versions is generally a good\\n\\n\\n43 CHAPTER 5 | Example of migrating t\", \"o the latest .NET\\n\\n\\nrecommendation. However, you should consider that updating the package version c\", \"an introduce\\nsome breaking changes that would force you to update your code.\\n\\n\\nWhat happens if you d\", \"on\\u2019t find a compatible version? What if you just don\\u2019t want to update the\\nversion of a package becau\", \"se of these breaking changes? Don\\u2019t worry because it\\u2019s possible to depend\\non .NET Framework packages\", \" from a .NET application. Don\\u2019t forget to test it extensively because it can\\ncause run-time errors i\", \"f the external package calls an API that isn\\u2019t available on .NET. This is great for\\nwhen you\\u2019re usin\", \"g an old package that isn\\u2019t going to be updated and you can just retarget to work on\\n.NET.\\n\\n\\n**Check\", \" for API compatibility**\\n\\n\\nSince the API surface in .NET Framework and .NET is similar but not ident\", \"ical, you must check which\\nAPIs are available on .NET and which aren\\u2019t. You can use the .NET Portabi\", \"lity Analyzer tool to surface\\nAPIs used that aren\\u2019t present on .NET. It looks at the binary level of\", \" your app, extracts all the APIs that\\nare called, and then lists which APIs aren\\u2019t available on your\", \" target framework (.NET 7 in this case).\\n\\n\\nYou can find more information about this tool at:\\n\\n\\n[http\", \"s://learn.microsoft.com/dotnet/standard/analyzers/portability-analyzer](https://docs.microsoft.com/d\", \"otnet/standard/analyzers/portability-analyzer)\\n\\n\\nAn interesting aspect of this tool is that it only \", \"surfaces the differences from your own code and not\\ncode from external packages, which you can\\u2019t cha\", \"nge. Remember you should have updated most of\\nthese packages to make them work with .NET.\\n\\n\\n**Migrat\", \"e**\\n\\n\\n1. Create the new .NET project\\n\\n\\nIn most cases, you\\u2019ll want to update your existing project to\", \" the new .NET format. However, you can\\nalso create a new project while maintaining the old one. The \", \"main drawback from updating the old\\nproject is that you lose designer support, which may be importan\", \"t to you and your development\\nteam. If you want to keep using the designer, you must create a new .N\", \"ET project in parallel with the\\nold one and share assets. If you need to modify UI elements in the d\", \"esigner, you can switch to the old\\nproject to do that. And since assets are linked, they\\u2019ll be updat\", \"ed in the .NET project as well.\\n\\n\\n[The SDK-style project](https://docs.microsoft.com/dotnet/core/pro\", \"ject-sdk/msbuild-props) for .NET is a lot simpler than .NET Framework\\u2019s project format. Apart from t\", \"he\\npreviously mentioned PackageReference entries, you won\\u2019t need to do much more. The new project\\n[f\", \"ormat includes files with certain extensions by default, such as .cs and .xaml files, without the ne\", \"ed to](https://docs.microsoft.com/dotnet/core/project-sdk/overview#default-includes-and-excludes)\\nex\", \"plicitly include them in the project file.\\n\\n\\n**AssemblyInfo considerations**\\n\\n\\nAttributes are autoge\", \"nerated on .NET projects. If the project contains an _AssemblyInfo.cs_ file, the\\ndefinitions will be\", \" duplicated, which will cause compilation conflicts. You can delete the older\\n_AssemblyInfo.cs_ file\", \" or disable autogeneration by adding the following entry to the .NET project file:\\n\\n\\n44 CHAPTER 5 | \", \"Example of migrating to the latest .NET\\n\\n\\n**Resources**\\n\\n\\nEmbedded resources are included automatica\", \"lly but resources aren\\u2019t, so you need to migrate the\\nresources to the new project file.\\n\\n\\n**Package \", \"references**\\n\\n\\nWith the **Migrate packages.config to PackageReference** option, you can easily move \", \"your external\\npackage references to the new format as previously mentioned.\\n\\n\\n**Update package refer\", \"ences**\\n\\n\\nUpdate the versions of the packages you\\u2019ve found to be compatible, as shown in the previou\", \"s section.\\n\\n#### **Fix the code and build**\\n\\n\\n**Microsoft.Windows.Compatibility**\\n\\n\\nIf your applicat\", \"ion depends on APIs that aren\\u2019t available on .NET, such as Registry or ACLs, you have\\nto include a r\", \"eference to the Microsoft.Windows.Compatibility package to add these Windowsspecific APIs. They work\", \" on .NET but aren\\u2019t included as they aren\\u2019t cross-platform.\\n\\n\\nThere\\u2019s a tool called Platform compati\", \"bility analyzer\\n[(https://learn.microsoft.com/dotnet/standard/analyzers/platform-compat-analyzer) th\", \"at helps you](https://docs.microsoft.com/dotnet/standard/analyzers/platform-compat-analyzer)\\nidentif\", \"y APIs that aren\\u2019t compatible with your code.\\n\\n\\n**Use #if directives**\\n\\n\\nIf you need different execu\", \"tion paths when targeting .NET Framework and .NET, you should use\\ncompilation constants. Add some #i\", \"f directives to your code to keep the same codebase for both\\ntargets.\\n\\n\\n**Technologies not available\", \" on .NET**\\n\\n\\nSome technologies aren\\u2019t available on .NET, such as:\\n\\n\\n  - AppDomains\\n\\n  - Remoting\\n\\n  \", \"- Code Access Security\\n\\n  - Windows Workflow\\n\\n\\nThat\\u2019s why you need to find a replacement for these t\", \"echnologies if you\\u2019re using them in your\\n[application. For more information, see the .NET Framework \", \"technologies unavailable on .NET Core and](https://docs.microsoft.com/dotnet/core/porting/net-framew\", \"ork-tech-unavailable)\\n[.NET 5+](https://docs.microsoft.com/dotnet/core/porting/net-framework-tech-un\", \"available) article.\\n\\n\\n45 CHAPTER 5 | Example of migrating to the latest .NET\\n\\n\\n**Regenerate autogene\", \"rated clients**\\n\\n\\nIf your application uses autogenerated code, such as a WCF client, you may need to\", \" regenerate this\\ncode to target .NET. Sometimes, you can find some missing references since they may\", \" not be included\\n[as part of the default .NET assemblies set. Using a tool like https://apisof.net/,\", \" you can easily locate](https://apisof.net/)\\nthe assembly the missing reference lives in and add it \", \"from NuGet.\\n\\n\\n**Rolling back package versions**\\n\\n\\nAs a general rule, we\\u2019ve previously stated that yo\", \"u better update every single package version to be\\ncompatible with .NET. However, you can find that \", \"targeting an updated and compatible version of an\\nassembly just doesn\\u2019t pay off. If the cost of chan\", \"ge isn\\u2019t acceptable, you can consider rolling back\\npackage versions keeping the ones you use on .NET\", \" Framework. Although they may not be targeting\\n.NET, they should work well unless they call some uns\", \"upported APIs.\\n\\n#### **Run and test**\\n\\n\\nOnce you have your application building with no errors, you \", \"can start the last step of the migration by\\ntesting every functionality.\\n\\n\\nIn this final step, you c\", \"an find several different issues depending on the complexity of your application\\nand the dependencie\", \"s and APIs you\\u2019re using.\\n\\n\\nFor example, if you use configuration files ( _app.config_ ), you may fin\", \"d some errors at run time like\\nConfiguration Sections not present. Using the Microsoft.Extensions.Co\", \"nfiguration NuGet package\\nshould fix that error.\\n\\n\\nAnother reason for errors is the use of the Begin\", \"Invoke and EndInvoke methods because they aren\\u2019t\\nsupported on .NET. They aren\\u2019t supported on .NET be\", \"cause they have a dependency on Remoting,\\nwhich doesn\\u2019t exist on .NET. To solve this issue, try to u\", \"se the await keyword (when available) or the\\n[Task.Run](https://docs.microsoft.com/dotnet/api/system\", \".threading.tasks.task.run) method.\\n\\n\\nYou can use compatibility analyzers to let you identify APIs an\", \"d code patterns in your code that can\\n[potentially cause problems at run time with .NET. Go to https\", \"://github.com/dotnet/platform-compat](https://github.com/dotnet/platform-compat)\\nand use the .NET AP\", \"I analyzer on your project.\\n\\n### Migrating a Windows Forms application\\n\\n\\nTo showcase a complete migr\", \"ation process of a Windows Forms application, we\\u2019ve chosen to migrate\\nthe eShop sample application a\", \"vailable at https://github.com/dotnet[architecture/eShopModernizing/tree/master/eShopLegacyNTier/src\", \"/eShopWinForms. You can find](https://github.com/dotnet-architecture/eShopModernizing/tree/master/eS\", \"hopLegacyNTier/src/eShopWinForms)\\nthe complete result of the migration at https://github.com/dotnet[\", \"architecture/eShopModernizing/tree/master/eShopModernizedNTier/src/eShopWinForms.](https://github.co\", \"m/dotnet-architecture/eShopModernizing/tree/master/eShopModernizedNTier/src/eShopWinForms)\\n\\n\\nThis ap\", \"plication shows a product catalog and allows the user to navigate, filter, and search for\\nproducts. \", \"From an architecture point of view, the app relies on an external WCF service that serves as\\na fa\\u00e7ad\", \"e to a back-end database.\\n\\n\\nYou can see the main application window in the following picture:\\n\\n\\n46 C\", \"HAPTER 5 | Example of migrating to the latest .NET\\n\\n\\nIf you open the _.csproj_ project file, you can\", \" see something like this:\\n\\n\\nAs previously mentioned, a .NET project has a more compact style and you\", \" need to migrate the\\nproject structure to the new .NET SDK style.\\n\\n\\nIn Solution Explorer, right-clic\", \"k on the Windows Forms project and select **Unload Project** - **Edit** .\\n\\n\\nNow you can update the .\", \"csproj file. You\\u2019ll delete the entire contents and replace it with the following\\ncode:\\n\\n\\n47 CHAPTER \", \"5 | Example of migrating to the latest .NET\\n\\n\\nSave and reload the project. You\\u2019re now done updating \", \"the project file and the project is targeting\\n.NET 7.\\n\\n\\nIf you compile the project at this point, yo\", \"u\\u2019ll find some errors related to the WCF client reference.\\nSince this code is autogenerated, you mus\", \"t regenerate it to target .NET.\\n\\n\\nDelete the _Reference.cs_ file and generate a new Service Client.\\n\", \"\\n\\nRight-click on **Connected Services** and select the **Add Connected Service** option.\\n\\n\\nThe Conne\", \"cted Services window opens. Select the **Microsoft WCF Web Service** option.\\n\\n\\n48 CHAPTER 5 | Exampl\", \"e of migrating to the latest .NET\\n\\n\\nIf you have the WCF Service in the same solution as we have in t\", \"his example, you can select the\\n**Discover** option instead of specifying a service URL.\\n\\n\\nOnce the \", \"service is located, the tool reflects the API contract implemented by the service. Change the\\nname o\", \"f the namespace to be eShopServiceReference as shown in the following image:\\n\\n\\n49 CHAPTER 5 | Exampl\", \"e of migrating to the latest .NET\\n\\n\\nSelect the **Finish** button. After a while, you\\u2019ll see the gene\", \"rated code.\\n\\n\\nYou should see three autogenerated files:\\n\\n\\n1. _Getting Started_ : a link to GitHub to\", \" provide some information on WCF.\\n\\n2. _ConnectedService.json_ : configuration parameters to connect \", \"to the service.\\n\\n3. _Reference.cs_ : the actual WCF client code.\\n\\n\\n50 CHAPTER 5 | Example of migrati\", \"ng to the latest .NET\\n\\n\\nIf you compile again, you\\u2019ll see many errors coming from _.cs_ files inside \", \"the _Helper_ folder. This folder\\nwas present in the .NET Framework version but not included in the o\", \"ld _.csproj_ . But with the new SDKstyle project, every code file present underneath the project fil\", \"e location is included by default. That is,\\nthe new .NET Core project tries to compile the files ins\", \"ide the _Helper_ folder. Since that folder isn\\u2019t\\nneeded, you can safely delete it.\\n\\n\\nIf you compile \", \"the project again and execute it, you won\\u2019t see the product images. The problem is that\\nnow the path\", \" to the files has slightly changed. To fix this issue, you need to add another level of depth\\nin the\", \" path, updating in the file CatalogView.cs the line:\\n\\n\\n51 CHAPTER 5 | Example of migrating to the la\", \"test .NET\\n\\n\\n```\\nstring image_name = Environment.CurrentDirectory +\\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalo\", \"g\\\\\\\\\\\" + catalogItems.Picturefilename;\\n\\n```\\n\\nto\\n\\n```\\nstring image_name = Environment.CurrentDirectory \", \"+\\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems.Picturefilename;\\n\\n```\\n\\nAfter this change,\", \" you can check that the application launches and runs as expected on .NET 7.\\n\\n### Migrating a WPF ap\", \"plication\\n\\n\\nWe\\u2019ll use the Shop.ClassicWPF sample application to perform the migration. The following\", \" image\\nshows a screenshot of the app before migration:\\n\\n\\nThis application uses a local SQL Server Ex\", \"press database to hold the product catalog information.\\nThis database is accessed directly from the \", \"WPF application.\\n\\n\\nFirst, you must update the _.csproj_ file to the new SDK style used by .NET Core \", \"applications. You\\u2019ll\\nfollow the same steps described in the Windows Forms migration: you\\u2019ll unload t\", \"he project, open the\\n_.csproj_ file, update its contents, and reload the project.\\n\\n\\nIn this case, de\", \"lete all the content of the _.csproj_ file and replace it with the following code:\\n\\n\\n52 CHAPTER 5 | \", \"Example of migrating to the latest .NET\\n\\n\\nIf you reload the project and compile it, you\\u2019ll get the f\", \"ollowing error:\\n\\n\\nSince you\\u2019ve deleted all the _.csproj_ contents, you\\u2019ve lost a project reference s\", \"pecification present in the\\nold project. You just need to add this line to the _.csproj_ file to inc\", \"lude the project reference back:\\n\\n\\nYou can also let Visual Studio help you by right-clicking on the \", \"**Dependencies** node and selecting\\n**Add Project Reference** . Select the project from the solution\", \" and select **OK** :\\n\\n\\n53 CHAPTER 5 | Example of migrating to the latest .NET\\n\\n\\nOnce you add the mis\", \"sing project reference, the application compiles and runs as expected on .NET.\\n\\n\\n54 CHAPTER 5 | Exam\", \"ple of migrating to the latest .NET\\n\\n\\n**CHAPTER**\\n# 6\\n\\n## Deploying Modern Desktop Applications\\n\\n\\nWh\", \"en you develop desktop applications, one thing to consider is how your application is going to be\\npa\", \"ckaged and deployed to the users\\u2019 machines. The problem with packaging, deployment, and\\ninstallation\", \" is that it usually falls under the umbrella of the IT professionals, who care about different\\nthing\", \"s than developers.\\n\\n\\nThese days, we\\u2019re all familiar with the DevOps concept, where developers and IT\", \" Pros work closely to\\nmove applications to their production environments. But if you\\u2019ve been in the \", \"desktop battle for more\\nthan 10 years, you might have seen the following story. A team of developers\", \" works together hard to\\nmeet the project deadlines. Business people are nervous since they need the \", \"system working on many\\nusers\\u2019 machines to run the company. On \\u201cD-Day\\u201d, the project manager checks wi\", \"th every developer\\nthat their code is working well and that everything is fine, so they can ship. Th\", \"en, the package team\\ncomes in generating the setup for the app, distribute it to every user machine \", \"and a set of test users\\nrun the application. Well, they try, because before showing any UI, the appl\", \"ication throws an\\nexception that says \\u201cMethod ~ of object ~ failed\\u201d. Panic starts flowing through th\", \"e air and a brief\\ninvestigation points to a young and tired developer that has introduced a third-pa\", \"rty control, that\\ncertainly \\u201cworked on the dev machine\\u201d.\\n\\n\\nInstalling desktop applications have trad\", \"itionally been a nightmare for two main reasons:\\n\\n\\n  - Lack of close collaboration culture between d\", \"ev and IT teams.\\n\\n  - Lack of a solid packaging and deploying technology we can build upon.\\n\\n\\nIn fac\", \"t, we\\u2019ve been living with the fact that sometimes you regret that you installed an app because:\\n\\n\\n  \", \"- It ends up having some undesired side effects on your machine.\\n\\n  - Some applications that were pr\", \"eviously installed stop working.\\n\\n\\nAdditionally, you can\\u2019t just restore the system to its original s\", \"tate by uninstalling the app. We\\u2019re so\\nused to living with this situation that we\\u2019ve coined terms li\", \"ke \\u201cDLL Hell\\u201d or \\u201cWinrot\\u201d.\\n\\n\\nIn this chapter, we\\u2019ll talk about MSIX. MSIX is the new technology from\", \" Microsoft that tries to capture\\nthe best of previous technologies to provide a solid foundation for\", \" the packaging technology of the\\nfuture.\\n\\n\\nWhat does a packaging technology have to do with moderniz\", \"ation? Well, it turns out that packaging\\nis fundamental for the enterprise IT with lots of money inv\", \"ested there. Modernization isn\\u2019t only related\\n\\n\\n55 CHAPTER 6 | Deploying Modern Desktop Applications\", \"\\n\\n\\nto using the latest technologies. It\\u2019s also related to reducing time to market from the moment a\\n\", \"business requirement is defined until your company delivers the feature to your client.\\n\\n### The mod\", \"ern application lifecycle\\n\\n\\nToday, developers write and build the code for an app and then pass the \", \"generated assets to the IT\\nPros. Then, the IT Pros reconfigure the app and repackage it, typically i\", \"n an MSI or more recently in an\\nApp-V packaging format. The app is then deployed through different c\", \"hannels and tools. One of the\\nmain problems with this approach is commonly known as \\u201cpackaging paral\", \"ysis\\u201d. The problem is that\\nthis cycle repeats every time there\\u2019s an app update or an OS update.\\n\\n\\nYo\", \"u can see the process reflected on the following picture:\\n\\n\\nCompanies need a way to break this packa\", \"ging cycle into three independent cycles:\\n\\n\\n  - OS updates\\n\\n  - Application updates\\n\\n  - Customizati\", \"on\\n\\n\\n56 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\nThe previous diagram shows that you can:\", \"\\n\\n\\n  - Update the underlying OS without having to repackage your apps.\\n\\n  - Enable customizations fr\", \"om IT without the need to repackage the original developer package.\\n\\n\\nThis radical change leads us t\", \"o the new and modern IT lifecycle as shown in the following picture:\\n\\n\\n57 CHAPTER 6 | Deploying Mode\", \"rn Desktop Applications\\n\\n\\nDevelopers create the app and generate an MSIX package that IT Pros can co\", \"nsume and configure\\nwithout the need of repackaging. Along with the MSIX technology, Microsoft has c\", \"reated tools to\\nallow IT to customize and configure packages without repackaging.\\n\\n### MSIX: The nex\", \"t generation of deployment\\n\\n\\nBefore MSIX, there were several packaging technologies available like s\", \"etup wizards, MSI, ClickOnce,\\nApp-V, and scripting. Each of these technologies has their own strengt\", \"hs and Microsoft has decided\\nto pick the best of all to build MSIX. MSIX is built on the foundations\", \" of these existing technologies\\npicking the best of each:\\n\\n\\n  - App-V => Containerization\\n\\n  - Click\", \"Once => Auto updating\\n\\n  - MSI => Easy to distribute\\n\\n\\nWith MSIX, you get one installer technology w\", \"ith all these features.\\n\\n\\n58 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\n#### **Benefits of \", \"MSIX**\\n\\n**Never regret installing an app**\\n\\n\\nMSIX provides a predictable, reliable, and safe deploym\", \"ent. The declarative method contained in the\\npackage manifest lets the OS keep track of every asset \", \"your application needs. It also provides a true\\nclean uninstall with no side effects.\\n\\n\\n**Disk space\", \" optimization**\\n\\n\\nMSIX is optimized to reduce the footprint that an application has on the user\\u2019s ma\", \"chine disk space. It\\ncreates a single instance storage of your files. That is, if you have two diffe\", \"rent packages with the\\nsame DLL, the DLL isn\\u2019t installed twice. The platform takes care of that prob\", \"lem because it knows all\\nthe files that a particular app installed thanks to its declarative nature.\", \" It also allows you to have\\ndifferent versions of a DLL working side by side.\\n\\n\\nWith the use of reso\", \"urce packages, you can easily create multilingual apps and the OS takes care of\\ninstalling the ones \", \"that are used.\\n\\n\\n**Network optimization**\\n\\n\\nMSIX detects the differences on the files at the byte bl\", \"ock level enabling a feature called differential\\nupdates. What this means is that only the updated b\", \"yte blocks are downloaded on application\\nupdates.\\n\\n\\n59 CHAPTER 6 | Deploying Modern Desktop Applicat\", \"ions\\n\\n\\nWith streaming installation, the user can quickly start working on your application while oth\", \"er parts of\\nthe app are downloaded on the background. This feature contributes to an engaging experi\", \"ence for\\nyour users.\\n\\n\\nWith the optional packages feature, you achieve componentization on your app \", \"deployment, so you\\ncan download them when needed.\\n\\n\\n**Simple packaging and deployment**\\n\\n\\nThe AppMan\", \"ifest declares the versioning, device targeting and identity in a standard way for every\\napplication\", \". It also provides a way to sign your assets providing a solid security foundation.\\n\\n\\n**OS managed**\", \"\\n\\n\\nThe OS handles all the processes for installing, updating, and removing an application. Applicati\", \"ons\\nare installed per user but downloaded only once, minimizing the disk footprint. Microsoft is wor\", \"king\\non providing the MSIX experience also on Windows 7.\\n\\n\\n**Windows provides integrity for the app*\", \"*\\n\\n\\nWith the use of digital signatures, you can guarantee that you don\\u2019t install an application from\", \"\\nuntrusted sources. MSIX also prevents tampering because:\\n\\n\\n  - It keeps a record of file hashes.\\n\\n \", \" - It detects if a file has been modified after installation.\\n\\n\\n60 CHAPTER 6 | Deploying Modern Desk\", \"top Applications\\n\\n\\n**Works for the entire App Catalog**\\n\\n\\nOne of the coolest things about MSIX is th\", \"at it works for the entire application catalog, Windows\\nForms, WPF, MFC/ATL, Delphi, even if you wan\", \"t to do xCopy deployment, ClickOnce, or going to the\\nStore, you can use the same MSIX package.\\n\\n####\", \" **Tools**\\n\\n\\n**Windows Application Packaging Project**\\n\\n\\nYou can use the **Windows Application Packa\", \"ging Project** project in Visual Studio to generate a\\npackage for your desktop app. Then, you can pu\", \"blish that package to the Microsoft Store or sideload\\nit onto one or more PCs.\\n\\n\\n**MSIX Packaging To\", \"ol**\\n\\n\\nThe MSIX Packaging Tool enables you to repackage your existing Win32 applications to the MSIX\", \"\\nformat. It offers both an interactive UI and a command line for conversions and gives you the abili\", \"ty to\\nconvert an application without having the source code.\\n\\n\\n61 CHAPTER 6 | Deploying Modern Deskt\", \"op Applications\\n\\n\\n**Package Support Framework**\\n\\n\\nThe Package Support Framework is an open-source ki\", \"t that helps you apply fixes to your existing\\nWin32 application when you don\\u2019t have access to the so\", \"urce code, so that it can run in an MSIX\\ncontainer. The Package Support Framework helps your applica\", \"tion follow the best practices of the\\nmodern runtime environment.\\n\\n\\n**App Installer**\\n\\n\\nApp Installe\", \"r allows Windows 10 and Windows 11 apps to be installed by double-clicking the app\\npackage. This mea\", \"ns that users don\\u2019t need to use PowerShell or other developer tools to deploy\\nWindows 10/Windows 11 \", \"apps. The App Installer can also install an app from the web, optional\\npackages, and related sets.\\n\\n\", \"### How to create an MSIX package from an existing Win32 desktop application\\n\\n\\nLet\\u2019s go through the \", \"process to create an MSIX package from an existing Win32 application. In this\\nexample, we\\u2019ll use a W\", \"indows Forms app.\\n\\n\\n62 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\nTo start, add a new proje\", \"ct to your solution, select the Windows Application Packaging Project, and\\ngive it a name.\\n\\n\\nYou\\u2019ll \", \"see the structure of the packaging project and note a special folder called _Applications_ . Inside\\n\", \"this folder, you can specify which applications you want to include in the package. It can be more t\", \"han\\none.\\n\\n\\n63 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\nRight-click on the _Applications_ \", \"folder and select the Windows Forms project you want to package\\nfrom the Visual Studio solution.\\n\\n\\n6\", \"4 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\nAt this point, you can compile and generate th\", \"e package but let\\u2019s examine a couple of things. To have\\na better user experience, Visual Studio can \", \"autogenerate all the visual assets a modern application\\nneeds to handle icons and tile assets for th\", \"e tile bar and start menu. Open the _Package.appxmanifest_\\nfile to access the Manifest Designer. You\", \" can then generate all the visual assets from a given image\\npresent on your project just by clicking\", \" **Create** .\\n\\n\\nIf you open the code for the _Package.appxmanifest_ file, you can see a couple of in\", \"teresting things.\\n\\n\\nRight under <Package>, there\\u2019s an <Identity> node. This is where your packaged a\", \"pplication is going\\nto get its identity, which will be managed by the OS.\\n\\n\\n65 CHAPTER 6 | Deploying\", \" Modern Desktop Applications\\n\\n\\nIn the <Capabilities> node, you can find all the requirements the app\", \"lication needs, paying special\\nattention to the <rescap:Capability Name=\\\"runFullTrust\\\" \\\\>, which tel\", \"ls the OS to run the app in full\\ntrust mode since it\\u2019s a Win32 application.\\n\\n\\n66 CHAPTER 6 | Deployi\", \"ng Modern Desktop Applications\\n\\n\\nSet the packaging project as the startup project for the solution a\", \"nd select _Run_ . This is going to:\\n\\n\\n  - Compile the Windows Forms application.\\n\\n  - Create an MSIX\", \" package out of the build results.\\n\\n  - Deploy the packages.\\n\\n  - Install it locally on the developm\", \"ent machine.\\n\\n  - Launch the app.\\n\\n\\n67 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\nWith this\", \", you have the clean install and uninstall experience that MSIX provides fully integrated into\\nWindo\", \"ws 10/Windows 11.\\n\\n\\nThe final stage is about how you deploy the MSIX package to another machine.\\n\\n\\nR\", \"ight-click on the packaging project, select the **Store** menu, and then select the **Create App**\\n*\", \"*Packages** option.\\n\\n\\nThen, you can choose between creating a package to upload to the store or crea\", \"ting packages for\\nsideloading. In most modernization scenarios, you\\u2019ll choose **I want to create pac\", \"kages for**\\n**sideloading** .\\n\\n\\n68 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\nThere you can\", \" select the different architectures you want to target as you can include as many as you\\nwant into t\", \"he same MSIX package.\\n\\n\\nThe final step is to declare where you want to deploy the final installation\", \" assets.\\n\\n\\n69 CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\nYou can choose to use a web server\", \" or a shared UNC path on your enterprise file servers. Pay\\nattention to the settings to specify how \", \"you want to update your application. We\\u2019ll cover application\\nupdates in the next section.\\n\\n\\n[For a d\", \"etailed step-by-step guide, see Package a desktop app from source code using Visual Studio.](https:/\", \"/docs.microsoft.com/windows/msix/desktop/desktop-to-uwp-packaging-dot-net)\\n\\n### Auto Updates in MSIX\", \"\\n\\n\\nThe Windows Store has a great updating mechanism using Windows Update. In most enterprise\\nscenari\", \"os, you don\\u2019t use the Store to distribute your desktop apps. So, you need a similar way to\\nconfigure\", \" updates for your application and pull them to your users.\\n\\n\\nUsing a combination of Windows 10/Windo\", \"ws 11 features and MSIX packages, you can provide a\\ngreat updating experience for your users. In fac\", \"t, the user doesn\\u2019t need to be technical at all but still\\nbenefits from a seamless application updat\", \"e experience.\\n\\n\\nYou can configure your updates to interact with the user in two different ways:\\n\\n\\n70\", \" CHAPTER 6 | Deploying Modern Desktop Applications\\n\\n\\n  - User prompted updates: The OS shows some au\", \"togenerated nice UI to notify the user about\\nthe application it\\u2019s about to install. It builds this U\", \"I based on the properties you specify on\\nyour installation files.\\n\\n\\n  - Silent updates in the backgr\", \"ound. With this option, your users don\\u2019t need to be aware of the\\nupdates.\\n\\n\\nYou can also configure w\", \"hen you want to perform updates: either when the application launches or\\non a regular basis. Thanks \", \"to the side-loading features, you can even get these updates while the\\napplication is running.\\n\\n\\nWhe\", \"n you use this type of deployment, a special file is created called _.appinstaller_ . This simple fi\", \"le\\ncontains the following sections:\\n\\n\\n  - The location of the _.appinstaller_ file\\n\\n  - The applicat\", \"ion\\u2019s main MSIX package properties\\n\\n  - The update behavior\\n\\n\\nIn combination with this file, Microso\", \"ft has designed a special URL protocol to launch the installation\\nprocess from a link:\\n\\n```\\n< a href\", \"=\\\"ms-appinstaller:?source=http://mywebservice.azureedge.net/MyApp.msix\\\">Install\\napp package </ a >\\n\\n\", \"```\\n\\nThis protocol works on all browsers and launches the installation process with a great user exp\", \"erience\\non Windows 10/Windows 11. Since the OS manages the installation process, it\\u2019s aware of the l\", \"ocation\\nthis application was installed from and tracks all the files affected by the process.\\n\\n\\nMSIX\", \" creates a user interface for installation automatically showing some properties of the package.\\nThi\", \"s allows for a common installation experience for every app.\\n\\n\\n71 CHAPTER 6 | Deploying Modern Deskt\", \"op Applications\\n\\n\\nOnce you\\u2019ve generated the new MSIX package and moved it to the deployment server, \", \"you just have\\nto edit the _.appinstaller_ file to reflect these changes: mainly the version and the \", \"path to the new MSIX\\nfile. The next time the user launches the application, the system will detect t\", \"he change and download\\nthe files for the new version in the background. When the download is finishe\", \"d, installation will\\nexecute transparently for your user on new application launch.\\n\\n\\n72 CHAPTER 6 |\", \" Deploying Modern Desktop Applications\\n\\n\\n\"]"