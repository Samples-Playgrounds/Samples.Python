"[\"EDITION v1.0.3 - Updated to .NET 7\\n\\nRefer to the changelog for the book updates and community contri\", \"butions.\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Visual Studio product teams\\n\\nA divis\", \"ion of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington 98052-6399\\n\\nCopyright \\u00a9 2022 by\", \" Microsoft Corporation\\n\\nAll rights reserved. No part of the contents of this book may be reproduced \", \"or transmitted in any form or by any means without the written permission of the publisher.\\n\\nThis bo\", \"ok is provided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions, and infor\", \"mation expressed in this book, including URL and other Internet website references, may change witho\", \"ut notice.\\n\\nSome examples depicted herein are provided for illustration only and are fictitious. No \", \"real association or connection is intended or should be inferred.\\n\\nMicrosoft and the trademarks list\", \"ed at https://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are trademarks of the Microsoft group of\", \" companies.\\n\\nMac and macOS are trademarks of Apple Inc.\\n\\nAll other marks and logos are property of t\", \"heir respective owners.\\n\\nCo-Authors:\\n\\nOlia Gavrysh, Program Manager, .NET team, Microsoft\\n\\nMiguel An\", \"gel Castej\\u00f3n Dominguez, Innovation Architect, Kabel\\n\\nParticipants and reviewers:\\n\\nMaira Wenzel, Seni\", \"or Program Manager, .NET team, Microsoft\\n\\nAndy De Gorge, Senior Content Developer, .NET docs team, M\", \"icrosoft\\n\\nMiguel Ramos, Senior Program Manager, Windows Developer Platform team, Microsoft\\n\\nAdam Bra\", \"den, Principal Program Manager, Windows Developer Platform team, Microsoft\\n\\nRicardo Minguez Pablos, \", \"Senior Program Manager, Azure IoT team, Microsoft\\n\\nNish Anil, Senior Program Manager, .NET team, Mic\", \"rosoft\\n\\nBeth Massi, Senior Product Marketing Manager, Microsoft\\n\\nScott Hunter, Partner Director Prog\", \"ram Manager, .NET team, Microsoft\\n\\nMarta Fuentes Lara, Kabel\\n\\nRa\\u00fal Fern\\u00e1ndez de C\\u00f3rdoba, Kabel\\n\\nAnto\", \"nio Manuel Fern\\u00e1ndez Cantos, Kabel\\n\\nIntroduction\\n\\nThis book is about strategies you can adopt to mov\", \"e your existing desktop applications through the path of modernization and incorporate the latest ru\", \"ntime, language, and platform features. You\\u2019ll discover that there\\u2019s no unique recipe as each applic\", \"ation is different, and so are your requirements and preferences. The good news is that there are co\", \"mmon approaches you can apply to add new features and capabilities to your applications. Some of the\", \"m won\\u2019t even require major modifications of your code. In this book, we\\u2019ll reveal how all those feat\", \"ures work behind the scenes and explain the mechanics of their implementations. Moreover, you\\u2019ll fin\", \"d some common scenarios for modernizing existing desktop applications shown in detail so you can fin\", \"d inspiration for evolving your projects.\\n\\nMicrosoft\\u2019s approach to modernizing existing applications\", \" is to give you the flexibility to create your own customized path. All the modernization strategies\", \" described in this book are mostly independent. You can choose ones that are relevant for your appli\", \"cation and skip others that aren\\u2019t important for you. In other words, you can mix and match the stra\", \"tegies to best address your application needs.\\n\\nWho should use the book\\n\\nThis book for developers an\", \"d solution architects who want to modernize existing Windows Forms and WPF desktop applications to l\", \"everage the benefits of .NET and Windows 10.\\n\\nYou might also find this book useful if you\\u2019re a techn\", \"ical decision maker, such as an enterprise architect or a development lead or director who wants an \", \"overview of the benefits of updating existing desktop applications.\\n\\nHow to use the book\\n\\nThis book \", \"addresses the \\u201cwhy\\u201d\\u2014why you might want to modernize your existing applications, and the specific ben\", \"efits you get from using NET and MSIX to modernize your desktop apps. The content of the book is des\", \"igned for architects and technical decision makers who want an overview, but who don\\u2019t need to focus\", \" on implementation and technical, step-by-step details.\\n\\nAlong the different chapters, sample implem\", \"entation code snippets and screenshots are provided, with chapter 5 devoted to showcase a complete m\", \"igration process for sample applications.\\n\\nWhat this book doesn\\u2019t cover\\n\\nThis book covers a specific\", \" subset of scenarios that are focused on lift-and-shift scenarios, outlining the way to gain the ben\", \"efits of modernizing without the effort of rewriting code.\\n\\nThis book isn\\u2019t about developing modern \", \"applications with .NET from scratch or about getting started with Windows Forms and WPF. It focuses \", \"on how you can update existing desktop applications with the latest technologies for desktop develop\", \"ment.\\n\\nSamples used in this book\\n\\nTo highlight the necessary steps to perform a modernization, we\\u2019ll\", \" be using a sample application called eShopModernizing. This application has two flavors, Windows Fo\", \"rms and WPF, and we\\u2019ll show a step-by-step process on how to perform the modernization on both of th\", \"em to .NET.\\n\\nAlso, on the GitHub repository for this book, you\\u2019ll find the results of the process, w\", \"hich you can consult with if you decide to follow the step-by-step tutorial.\\n\\nContents\\n\\nWhy modern d\", \"esktop applications ................................................................................\", \"....... 1\\n\\nIntroduction ............................................................................\", \"................................................................................................... \", \"1\\n\\nA story of one company ..........................................................................\", \"......................................................................... 1\\n\\nYour story ............\", \"....................................................................................................\", \"............................................................... 1\\n\\nDesktop applications nowadays ...\", \"....................................................................................................\", \"................................. 1\\n\\nWindows Forms .................................................\", \"....................................................................................................\", \".............. 3\\n\\nWPF ..............................................................................\", \"....................................................................................................\", \"......... 4\\n\\nUWP ...................................................................................\", \"....................................................................................................\", \"... 4\\n\\nA tale of two platforms .....................................................................\", \"..................................................................................... 5\\n\\nPaths to mo\", \"dernization ........................................................................................\", \"................................................................. 8\\n\\nModern features ...............\", \"....................................................................................................\", \"............................................... 8\\n\\nDeployment ......................................\", \"....................................................................................................\", \"................................. 8\\n\\nInstallation...................................................\", \"....................................................................................................\", \"....................... 8\\n\\nWhat\\u2019s new with .NET for Desktop? .......................................\", \"............................................... 9\\n\\nThe motivation behind .NET Core .................\", \"....................................................................................................\", \"................ 9\\n\\nIntroduction to .NET Core ......................................................\", \"........................................................................................... 11\\n\\n.NET\", \" 5+ is .NET Core vNext .............................................................................\", \".................................................................. 11\\n\\n.NET Framework vs. .NET .....\", \"....................................................................................................\", \"........................................... 12\\n\\n.NET Standard vs. PCL ..............................\", \"....................................................................................................\", \"....................... 13\\n\\nNew Desktop features in .NET ...........................................\", \".............................................................................................. 14\\n\\nS\", \"upport for Windows Forms and WPF ...................................................................\", \"................................................. 14\\n\\nXAML Islands .................................\", \"....................................................................................................\", \"................................. 14\\n\\nAccess to all Windows 10 and Windows 11 APIs .................\", \"............................................................................... 15\\n\\nSide-by-side sup\", \"port and self-contained EXEs .......................................................................\", \"............................. 15\\n\\nPerformance ......................................................\", \"....................................................................................................\", \"............. 15\\n\\nMigrating Modern Desktop applications ............................................\", \"................................ 16\\n\\nConfiguration files ...........................................\", \"....................................................................................................\", \"................. 16\\n\\nConfiguration on .NET Framework ..............................................\", \".............................................................................. 16\\n\\ni\\n\\nContents\\n\\nConf\", \"iguration on .NET ..................................................................................\", \".................................................................. 17\\n\\nMigrating configuration files\", \" ...................................................................................................\", \".................................... 17\\n\\nAccessing databases .......................................\", \"....................................................................................................\", \"................. 18\\n\\nODBC .........................................................................\", \"....................................................................................................\", \"........ 19\\n\\nOLE DB ................................................................................\", \".................................................................................................. 1\", \"9\\n\\nADO.NET .........................................................................................\", \"..................................................................................... 19\\n\\nEF Core vs\", \". EF6 ..............................................................................................\", \"..................................................................... 19\\n\\nRelational databases .....\", \"....................................................................................................\", \".............................................. 20\\n\\nConsuming services ..............................\", \"....................................................................................................\", \"........................... 20\\n\\nConsuming a COM Object .............................................\", \"................................................................................................... \", \"21\\n\\nMore things to consider ........................................................................\", \"............................................................................. 21\\n\\nAppDomains .......\", \"....................................................................................................\", \"........................................................... 21\\n\\nRemoting ...........................\", \"....................................................................................................\", \".............................................. 21\\n\\nCode Access Security (CAS) ......................\", \"....................................................................................................\", \"............... 22\\n\\nSecurity Transparency ..........................................................\", \".......................................................................................... 22\\n\\nWindo\", \"ws 10 migration ....................................................................................\", \"..................... 23\\n\\nWinRT APIs ...............................................................\", \"....................................................................................................\", \"........... 23\\n\\nUniversal Windows Platform (UWP) packages ..........................................\", \"........................................................... 24\\n\\nHow to add WinRT APIs to your deskto\", \"p project ..........................................................................................\", \".......... 26\\n\\nXAML Islands ........................................................................\", \".................................................................................................. 3\", \"4\\n\\nThe road to XAML Islands ........................................................................\", \"..................................................................... 35\\n\\nHow it works .............\", \"....................................................................................................\", \"..................................................... 35\\n\\nDo you need XAML Islands .................\", \"....................................................................................................\", \"..................... 38\\n\\nThe road ahead XAML Islands: WinUI 3.0 ...................................\", \"........................................................................... 38\\n\\nExample of migrating\", \" to the latest .NET............................................................................. 41\\n\", \"\\nMigrating from .NET Core or .NET 5 ................................................................\", \"............................................................. 41\\n\\nMigrating from .NET Framework ....\", \"....................................................................................................\", \"............................ 42\\n\\nMigrating with a tool .............................................\", \"....................................................................................................\", \"..... 42\\n\\nMigrating by hand ........................................................................\", \"................................................................................... 42\\n\\nPreparation \", \"....................................................................................................\", \"..................................................................... 43\\n\\nFix the code and build ...\", \"....................................................................................................\", \"............................................. 45\\n\\nRun and test .....................................\", \"....................................................................................................\", \".............................. 46\\n\\nii\\n\\nContents\\n\\nMigrating a Windows Forms application .............\", \"....................................................................................................\", \"... 46\\n\\nMigrating a WPF application ................................................................\", \"............................................................................ 52\\n\\nDeploying Modern De\", \"sktop Applications .......................................................................... 55\\n\\nTh\", \"e modern application lifecycle .....................................................................\", \"............................................................... 56\\n\\nMSIX: The next generation of dep\", \"loyment ............................................................................................\", \"..................... 58\\n\\nBenefits of MSIX .........................................................\", \"....................................................................................................\", \".. 59\\n\\nTools .......................................................................................\", \"............................................................................................... 61\\n\\n\", \"How to create an MSIX package from an existing Win32 desktop application............................\", \"............... 62\\n\\nAuto Updates in MSIX ...........................................................\", \".............................................................................................. 70\\n\\ni\", \"ii\\n\\nContents\\n\\nCHAPTER 1\\n\\nWhy modern desktop applications\\n\\nIntroduction\\n\\nA story of one company\\n\\nBack\", \" in the early 2000s, one multinational company started developing a distributed desktop solution to \", \"exchange information between different branches of the company and execute optimized operations on c\", \"entralized units. They have chosen a brand-new framework called Windows Forms (also known as WinForm\", \"s) for their application development. Over the years, the project evolved into a mature, well-tested\", \", and time-proven application with hundreds of thousands of lines of code. Time passed and .NET Fram\", \"ework 2.0 is no longer the hot new technology. The developers who are working on this application ar\", \"e facing a dilemma. They\\u2019d like to use the latest stack of technologies in their development and hav\", \"e their application look and \\u201cfeel\\u201d modern. At the same time, they don\\u2019t want to throw away the grea\", \"t product they have built over 15 years and rewrite the entire application from scratch.\\n\\nYour story\", \"\\n\\nYou might find yourself in the same boat, where you have mature Windows Forms or Windows Presentat\", \"ion Foundation (WPF) applications that have proved their reliability over the years. You probably wa\", \"nt to keep using these applications for many more years. At the same time, since those applications \", \"were written some time ago, they might be missing capabilities like modern look, performance, integr\", \"ation with new devices and platform features, and so on, which gives them a feel of \\u201cold tech\\u201d. Ther\", \"e\\u2019s another problem that might concern you as a developer. While working on the older .NET Framework\", \" versions and maintaining applications that were written a while ago, you might feel like you aren\\u2019t\", \" learning new technologies and missing out on building modern technical skills. If that is your stor\", \"y \\u2013 this book is for you!\\n\\nDesktop applications nowadays\\n\\nBefore the rise of the Internet, desktop a\", \"pplications were the main approach to building software systems. Developers could choose any program\", \"ming language, such as COBOL, Fortran, VB6, or C++.\\n\\n1\\n\\nCHAPTER 1 | Why modern desktop applications\\n\", \"\\nBut whether they developed small tools or complex distributed architectures, they were all desktop \", \"applications.\\n\\nThen, Internet technologies started shocking the development world and winning over m\", \"ore engineers with advantages like easy deployment and simplified distribution processes. The fact t\", \"hat once a web application was deployed to production all users got automatic updates made a huge im\", \"pact on software agility.\\n\\nHowever, the Internet infrastructure, underlying protocols, and standards\", \" like HTTP and HTML weren\\u2019t designed for building complex applications. In fact, the major developme\", \"nt effort back then was aimed at just one goal: to give web applications the same capabilities that \", \"desktop applications have, such as fast data input and state management.\\n\\nEven though web and mobile\", \" applications have grown at an incredible pace, for certain tasks desktop applications still hold th\", \"e number one place in terms of efficiency and performance. That explains why there are millions of d\", \"evelopers who are building their projects with WPF and WinForms and the amount of those applications\", \" is constantly growing.\\n\\nHere are some reasons for choosing desktop applications in your development\", \":\\n\\n\\n\\nDesktop apps have better interaction with the user\\u2019s PC.\\n\\n\\n\\nThe performance of desktop applicat\", \"ions for complex calculations is much higher than the performance of web applications.\\n\\n\\n\\nRunning cu\", \"stom logic on the client-side is possible but much harder with a web application.\\n\\n\\n\\nUsing multithre\", \"ading is easier and more efficient in a desktop application.\\n\\n\\n\\nThe learning curve for designing use\", \"r interfaces (UIs) isn\\u2019t steep. And for WinForms, it\\u2019s intuitive with the drag-and-drop experience o\", \"f the Windows Forms designer.\\n\\n\\n\\nIt\\u2019s easy to start coding and testing your algorithms without the n\", \"eed to set up a server infrastructure or to care about connectivity problems, firewalls, and browser\", \" compatibility.\\n\\n\\n\\nDebugging is powerful as compared to web debugging.\\n\\n\\n\\nAccess to hardware devices\", \", such as camera, Bluetooth, or card readers, is easy.\\n\\n\\n\\nSince the technology has been around for a\", \" while, there are many experts and a knowledge base available to develop desktop applications.\\n\\nSo, \", \"as you can see, developing for desktop is great for many reasons. The technology is mature and time-\", \"tested, the development cycle is fast, the debugging is powerful and arguably, desktop apps have les\", \"s complexity and are easier to get started with.\\n\\nMicrosoft offered many UI desktop technologies thr\", \"oughout the years from Win32 introduced in 1995 to Universal Windows Platform (UWP) released in 2016\", \".\\n\\n2\\n\\nCHAPTER 1 | Why modern desktop applications\\n\\nAccording to a survey published by Telerik on Apr\", \"il 2016, the most popular technologies for building Windows desktop apps are Windows Forms, WPF, and\", \" UWP.\\n\\nYou can develop in any of them using C# and Visual Basic, but let\\u2019s take a closer look.\\n\\nWind\", \"ows Forms\\n\\nFirst released in 2002, Windows Forms is a managed framework and is the oldest, most-used\", \" desktop technology built on the Windows graphics device interface (GDI) engine. It offers a smooth \", \"drag-and- drop experience for developing user interfaces in Visual Studio. At the same time, Windows\", \" Forms relies on the Visual Studio Designer as the main way you develop your UI, so creating visual \", \"components from code isn\\u2019t trivial.\\n\\nThe following list summarizes the main characteristics of Windo\", \"ws Forms:\\n\\nMature technology with lots of code samples and documentation.\\n\\n\\n\\nPowerful and productive\", \" designer. Not so convenient to design UI \\u201cfrom code\\u201d.\\n\\n\\n\\nEasy and intuitive to learn, thanks to the\", \" designer\\u2019s drag-and-drop experience.\\n\\n\\n\\nSupported on any Windows version.\\n\\n\\n\\nSupported on .NET Core\", \" 3.0 and later versions.\\n\\n3\\n\\nCHAPTER 1 | Why modern desktop applications\\n\\nWPF\\n\\nBased on the XAML lan\", \"guage specification, WPF favors a clear separation between UI and code. XAML offers capabilities lik\", \"e templating, styling, and binding, which is suited for building large applications. Like Windows Fo\", \"rms, it\\u2019s a managed framework, but the design is modular and reusable.\\n\\nHere are the main features o\", \"f WPF:\\n\\nMature technology.\\n\\n\\n\\nDesigner is available, but developers usually prefer to create the des\", \"ign from code using declarative XAML.\\n\\n\\n\\nThe learning curve is steeper than Windows Forms.\\n\\n\\n\\nSuppor\", \"ted on any Windows version.\\n\\n\\n\\nSupported on .NET Core 3.0 and later versions.\\n\\nUWP\\n\\nUWP isn\\u2019t only a\", \" presentation framework like WPF and Windows Forms, but it\\u2019s also a platform itself. This platform h\", \"as:\\n\\n\\n\\nIts own API set (the Windows Runtime API).\\n\\n\\n\\nA new deployment system (MSIX)\\n\\n\\n\\nA modern appl\", \"ication lifecycle model (for low battery consumption).\\n\\n\\n\\nA new Resource Management System (based on\", \" PRI files).\\n\\nThe platform was created to support all kinds of input systems (like ink, touch, gamep\", \"ad, mouse, keyboard, gaze, and so on) in all form-factors with performance and low battery consumpti\", \"on in mind. For these reasons, the shell of the Windows 10 OS uses parts of the UWP platform.\\n\\n4\\n\\nCH\", \"APTER 1 | Why modern desktop applications\\n\\nUWP contains a presentation framework that is XAML-based,\", \" like WPF, but it has some important differences such as:\\n\\n\\n\\nApplications are executed in app contai\", \"ners. App containers control what resources a UWP app can access.\\n\\n\\n\\nSupported only on Windows 10 an\", \"d Windows 11.\\n\\n\\n\\nApps can be deployed through Microsoft Store for easier deployment.\\n\\n\\n\\nDesigned as \", \"part of the Windows Runtime API.\\n\\n\\n\\nContains an extensive set of rich built-in controls and addition\", \"al controls are available through the Microsoft UI Library NuGet packages (WinUI library), updated e\", \"very few months.\\n\\nA tale of two platforms\\n\\nIn the last 20 years, while UI desktop technologies were \", \"growing and following the path from Windows Forms to UWP, the hardware was also evolving from heavyw\", \"eight PC units with small CRT monitors to high-DPI monitors and lightweight tablets and phones with \", \"different data input techniques like Touch and Ink. These changes resulted in creating two different\", \" concepts: a Desktop Application and a Modern Application. A Modern Application is one that consider\", \"s different device form factors, various input and output methods, and leverages modern desktop feat\", \"ures while running on a sandboxed execution model. The (traditional) Desktop Application, on the oth\", \"er hand, is\\n\\n5\\n\\nCHAPTER 1 | Why modern desktop applications\\n\\nan application that needs a solid UI wi\", \"th a high density of controls that is best operated with a mouse and a keyboard.\\n\\nThe following tabl\", \"e describes the differences between the two concepts:\\n\\nAspect of comparison\\n\\nModern Application\\n\\nDes\", \"ktop Application\\n\\nSecurity\\n\\nContained execution & Great Fundamentals. Designed from the ground up to\", \" respect user\\u2019s privacy, manage battery life, and focus to keep the device safe.\\n\\nUser & Admin level\", \" of security. You have native access to the registry and hard drive folders.\\n\\nDeployment\\n\\nInstallati\", \"on and updates are managed by the platform.\\n\\nMSI, Custom installers & Updates. Traditionally a sourc\", \"e of headaches for developers and IT managers.\\n\\nDistribution\\n\\nTrusted Distribution & Signed Packages\", \". Distribution is performed from a trusted source and never from the web.\\n\\nWeb, SCCM & Custom distri\", \"bution. No control over what is installed, affects the whole machine.\\n\\nUI\\n\\nModern UI. Different inpu\", \"t mechanisms, ink, touch, gamepad, keyboard, mouse, etc.\\n\\nWindows Forms, WPF, MFC. Designed for the \", \"mouse and keyboard for a dense UI and to get the most productivity from the desktop.\\n\\nData\\n\\nCloud Fi\", \"rst Data with Insights. Source of truth in the cloud. Insights to know what happens with your app an\", \"d how it\\u2019s performing.\\n\\nLocal Data. Traditional desktop applications usually need some local data.\\n\\n\", \"Design\\n\\nDesigned for reuse. Reuse in mind between different platforms, front end, and back end, runn\", \"ing assets in many places as possible.\\n\\nDesigned for Windows Desktop only\\n\\nAs a part of the commitme\", \"nt to provide developers with the best tools to build applications, Microsoft put forth a great effo\", \"rt to bring these concepts - or we can even say platforms - closer together to empower developers wi\", \"th the best of both worlds. To do that, Microsoft has performed a bidirectional effort between the t\", \"wo platforms.\\n\\n6\\n\\nCHAPTER 1 | Why modern desktop applications\\n\\n1. Move Desktop Application scenarios\", \" into Modern Application platform. The traditional\\n\\ndesktop development is still popular because it \", \"addresses certain scenarios well. It makes sense to take these common desktop scenarios and bring th\", \"em into the modern desktop platform to make the platform fully capable.\\n\\n1. Move Modern Application \", \"features into Desktop Applications. For existing desktop apps that need a way to leverage modern cap\", \"abilities without rewriting from scratch, features from the Modern Application platform are pushed i\", \"nto the Desktop Application.\\n\\n7\\n\\nCHAPTER 1 | Why modern desktop applications\\n\\nIn this book, we\\u2019ll fo\", \"cus on the second part and show how you can modernize your existing desktop applications.\\n\\nPaths to \", \"modernization\\n\\nThe structure of this guide reflects three different axes to accomplish modernization\", \": Modern Features, Deployment, and Installation.\\n\\nModern features\\n\\nSay you have a working Windows Fo\", \"rms application that a sales representative of your company uses to fill in a customer order. A new \", \"requirement comes in to enable the customer to sign the order using a tablet pen. Inking is native i\", \"n today\\u2019s operating systems and technologies, but it wasn\\u2019t available when the app was developed.\\n\\nT\", \"his path will show you how you can leverage modern desktop features into your existing desktop devel\", \"opment.\\n\\nDeployment\\n\\nModern development cycles have stressed the importance of providing agility wit\", \"h regard to how new versions of applications are deployed to individual users. Since Windows Forms a\", \"nd WPF applications are based on a particular version of the .NET Framework that must be present on \", \"the machine, they can\\u2019t take advantage of new .NET Framework version features without the interventi\", \"on of the IT people with the risk of having side effects for other apps running on the same machine.\", \" It has limited the innovation pace for developers forcing them to stay on outdated versions of the \", \".NET Framework.\\n\\nSince the launch of .NET Core 3.0, you can leverage a new approach of deploying mul\", \"tiple versions of .NET side by side and specifying which version of .NET each application should tar\", \"get. This way, you can use the newest features in one application while being confident you aren\\u2019t g\", \"oing to break any other applications.\\n\\nInstallation\\n\\nDesktop applications always rely on some sort o\", \"f installation process before the user can start using them. This fact brought into the game a set o\", \"f technologies, from MSI and ClickOnce to custom installers or even XCOPY deployment. Any of these m\", \"ethods deals with delicate problems because applications need a way to access shared resources on th\", \"e machine. Sometimes installation needs to access the Registry to insert or update new Key Values, s\", \"ometimes to update shared DLLs referenced by the main application. This behavior causes a continuous\", \" headache for users, creating this perception that once you install some application, your computer \", \"will never be the same, even if you uninstall it afterwards.\\n\\nIn this book, we\\u2019ll introduce a new wa\", \"y of installing applications with MSIX that solves the problem described earlier. You\\u2019ll learn how y\", \"ou can easily set up packaging, installation, and updates for your application.\\n\\n8\\n\\nCHAPTER 1 | Why \", \"modern desktop applications\\n\\nCHAPTER 2\\n\\nWhat\\u2019s new with .NET for Desktop?\\n\\nDesktop applications such\", \" as Windows Forms and WPF can be built using various .NET implementations, for example, .NET Framewo\", \"rk or .NET 7. In this chapter, we\\u2019ll talk about the history of each implementation, explain the diff\", \"erences, and show what new features await desktop developers in newer implementations.\\n\\nIf you\\u2019ve be\", \"en developing Windows Forms or WPF applications for a long time, you\\u2019re familiar with .NET Framework\", \". Later, .NET Core (specifically its 3.0 version) started supporting desktop applications. .NET Core\", \" was rebranded to .NET when .NET 5 was released. Just as there are different versions of .NET Framew\", \"ork, for example, 4.6, 4.7, and 4.8, there are also different versions of .NET Core: .NET Core 3.0, \", \".NET 5, .NET 6, .NET 7, and so on.\\n\\nLet\\u2019s look into the history of each implementation to understand\", \" the differences and benefits of each.\\n\\nThe motivation behind .NET Core\\n\\nSince its launch in 2002, .\", \"NET Framework has evolved to support many technologies, like Windows Forms, ASP.NET, Entity Framewor\", \"k, Windows Store, and many others. All of them are different in nature. Therefore, Microsoft approac\", \"hed this evolution by taking parts of .NET Framework and creating a different application stack for \", \"each technology. That way, development capabilities could be customized for the needs of the specifi\", \"c stack, which maximized the potential of every platform. That led to fragmentation on the versions \", \"of .NET Framework maintained by different independent teams. All of these stacks have a common struc\", \"ture, containing an app model, a framework, and a runtime, but they differ in the implementation of \", \"each of the parts.\\n\\nIf you\\u2019re targeting only one of these platforms, you can use this model. However\", \", in many cases you might need more than one target platform in the same solution. For example, your\", \" application may have a desktop admin part, a customer-facing web site that shares the back-end logi\", \"c running on a server, and even a mobile client. In this case, you need a unified coding experience \", \"that can span all of these .NET verticals.\\n\\nBy the time Windows 8 was released, the concept of Porta\", \"ble Class Libraries (PCLs) was born. Originally, .NET Framework was designed around the assumption t\", \"hat it would always be deployed as a single unit, so factoring wasn\\u2019t a concern. To face the problem\", \" of code sharing between verticals, the driving force was on how to refactor the framework. The idea\", \" of contracts is to provide a well-factored\\n\\n9\\n\\nCHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\nAPI s\", \"urface area. Contracts are simply assemblies that you compile against and are designed with proper f\", \"actoring in mind taking care of the dependencies between them.\\n\\nThis led to reasoning about the API \", \"differences between verticals at the assembly level, as opposed to at the individual API level like \", \"previously. This aspect enabled a class library experience that can target multiple verticals, also \", \"known as portable class libraries.\\n\\nWith PCL, the experience of development is unified across vertic\", \"als based on the API shape. And the most pressing need to create libraries running on different vert\", \"icals is also addressed. But there\\u2019s a great challenge: APIs are only portable when the implementati\", \"on is moved forward across all the verticals.\\n\\nA better approach is to unify the implementations acr\", \"oss verticals by providing a well-factored implementation instead of a well-factored view. It\\u2019s a lo\", \"t simpler to ask each team that owns a specific component to think about how their APIs work across \", \"all verticals than trying to retroactively provide a consistent API stack on top. This is where .NET\", \" Standard comes in.\\n\\nAnother large challenge has to do with how .NET Framework is deployed. .NET Fra\", \"mework is a machine-wide framework. Any changes made to it affect all applications that take a depen\", \"dency on it. Although this deployment model has many advantages, such as reducing disk space and cen\", \"tralized access to services, it presents some pitfalls.\\n\\nTo start with, it\\u2019s difficult for applicati\", \"on developers to take a dependency on a recently released framework. They either have to take a depe\", \"ndency on the latest OS or provide an application installer that installs .NET Framework along with \", \"the application. If you\\u2019re a web developer, you might not even have this option as the IT department\", \" establishes the server supported version.\\n\\nEven if you\\u2019re willing to go through the trouble of prov\", \"iding an installer to chain in .NET Framework setup, you may find that upgrading .NET Framework can \", \"break other applications.\\n\\nDespite the efforts to provide backward compatible versions of the framew\", \"ork, there are compatible changes that can break applications. For example, adding an interface to a\", \"n existing type can change how this type is serialized and cause breaking problems depending on the \", \"existing code. Because the .NET Framework installed base is huge, fighting against these breaking sc\", \"enarios slows down the pace of innovations inside .NET Framework.\\n\\nTo solve all these issues, Micros\", \"oft developed .NET Core as the evolution of the .NET development platform.\\n\\n10\\n\\nCHAPTER 2 | What\\u2019s n\", \"ew with .NET for Desktop?\\n\\nIntroduction to .NET Core\\n\\n.NET Core, which is now referred to as just \\u201c.\", \"NET\\u201d, is the evolution of Microsoft\\u2019s .NET technology into a modular, cross-platform, open source, a\", \"nd cloud-ready platform. It runs on Windows, macOS, and Linux, and some ARM-based architectures like\", \" Android and IoT.\\n\\nThe purpose of .NET Core is to provide a unified platform for all types of applic\", \"ations, which includes Windows, cross-platform, and mobile applications. .NET Standard enabled this \", \"by providing shared base APIs, which every application model needs, and excluding any application mo\", \"del-specific API.\\n\\nThis framework gives applications many benefits in terms of efficiency and perfor\", \"mance, simplifying the packaging and deployment in the different supported platforms.\\n\\nThe benefits \", \"of .NET Core come from these three characteristics:\\n\\n\\n\\nCross-platform: It allows application executi\", \"on on different platforms (Windows, macOS, and Linux).\\n\\n\\n\\nOpen source: .NET Core platform is open so\", \"urce and available through GitHub, fostering transparency and community contributions.\\n\\n\\n\\nSupported:\", \" Microsoft officially supports .NET Core.\\n\\nStarting with .NET Core 3.0, besides the existing support\", \" for web and cloud, there\\u2019s also support for desktop, IoT, and AI domains. The goal for this framewo\", \"rk is impressive: to target every type of .NET development present and future.\\n\\n.NET 5+ is .NET Core\", \" vNext\\n\\n.NET 5 was the next step forward with .NET Core. .NET 5 improved .NET in a few key ways:\\n\\n\\n\\n\", \"Produced a single .NET runtime and framework that can be used everywhere and that has uniform runtim\", \"e behaviors and developer experiences.\\n\\n\\n\\nExpanded the capabilities of .NET by taking the best of .N\", \"ET Core, .NET Framework, Xamarin, and Mono.\\n\\n\\n\\nBuilt that product out of a single code-base that dev\", \"elopers (Microsoft and the community) can work on and expand together and that improves all scenario\", \"s.\\n\\n.NET 5 was a game-changer for .NET. With .NET 5 and later versions, your code and project files \", \"look and feel the same no matter which type of app you\\u2019re building. You have access to the same runt\", \"ime, APIs, and language capabilities with each app. This includes new performance improvements that \", \"get committed to the runtime almost daily. .NET 6 and .NET 7 made further improvements in reliabilit\", \"y, performance, new APIs, and language features. For more details, see What\\u2019s new in .NET 5, What\\u2019s \", \"new in .NET 6, and What\\u2019s new in .NET 7.\\n\\n11\\n\\nCHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\n.NET Fr\", \"amework vs. .NET\\n\\nSo now that you understand the relevance of .NET, you might be wondering what happ\", \"ens with .NET Framework. You could be asking questions like: Do I have to abandon it? Is it going to\", \" disappear? What are my choices to modernize the applications I have on .NET Framework?\\n\\nIn 2019, .N\", \"ET Framework 4.8 was released. It included three major improvements for desktop applications:\\n\\nModer\", \"n browser and media controls: New controls were added that take advantage of\\n\\nMicrosoft Edge and new\", \"er media players that support the latest standards.\\n\\n\\n\\nAccess to UWP controls: UWP introduced contro\", \"ls that take advantage of the latest Windows features and touch displays. With .NET Framework 4.8, y\", \"ou don\\u2019t have to rewrite your applications to use these new features and controls, so you can use th\", \"ese new features in your existing WPF or Windows Forms code.\\n\\n\\n\\nHigh-DPI improvements: The resolutio\", \"n of displays increased to 4K and 8K, so, .NET Framework 4.8 added new HDPI improvements to make sur\", \"e existing Windows Forms and WPF applications can look great on these new displays.\\n\\nSince .NET Fram\", \"ework is installed on millions of machines, Microsoft will continue to support it but won\\u2019t add new \", \"features.\\n\\n.NET (Core) is the open-source, cross-platform, and fast-moving version of the .NET famil\", \"y. Because of its side-by-side nature, it can take changes without the fear of breaking any applicat\", \"ion. This means that .NET will get new APIs and language features over time that .NET Framework won\\u2019\", \"t. Also, .NET already has features that were impossible for .NET Framework, such as:\\n\\n\\n\\nSide-by-side\", \" versions of .NET supporting Windows Forms and WPF: This solves the problem of side effects when upd\", \"ating the machine\\u2019s framework version. Multiple versions of .NET can be installed on the same machin\", \"e and each application specifies which version of\\n\\n12\\n\\nCHAPTER 2 | What\\u2019s new with .NET for Desktop?\", \"\\n\\n.NET it should use. Even more, now you can develop and run Windows Forms and WPF on top of .NET.\\n\\n\", \"\\n\\nEmbed .NET directly into an application: You can deploy .NET as part of your application package. \", \"This enables you to take advantage of the latest version, features, and APIs without having to wait \", \"for a specific version to be installed on the machine.\\n\\n\\n\\nTake advantage of .NET features: .NET is f\", \"ast-moving and open-source. Its side-by-side nature enables fast introduction of new innovative APIs\", \" and Base Class Library (BCL) improvements without the risk of breaking compatibility. Now Windows F\", \"orms and WPF applications can take advantage of the latest .NET features, which also includes fundam\", \"ental fixes for things like runtime performance and high-DPI support.\\n\\n.NET Framework will be fully \", \"supported and will always be a part of Windows. However, if you want to use the newest language feat\", \"ures and APIs in the future, you\\u2019ll need to move your applications to .NET. For brand-new desktop ap\", \"ps, we recommend starting directly on .NET 6 or a later version. It\\u2019s lightweight and cross-platform\", \", runs side by side, has high performance, and fits perfectly on containers and microservices archit\", \"ectures.\\n\\n.NET Standard vs. PCL\\n\\n.NET Standard is a formal specification of .NET APIs that are inten\", \"ded to be available on all .NET implementations. The motivation behind .NET Standard was to establis\", \"h greater uniformity in the .NET ecosystem. .NET Standard is a specification of .NET APIs that make \", \"up a uniform set of contracts to compile your code against. These contracts are implemented in each \", \".NET flavor, thus enabling portability across different .NET implementations.\\n\\n.NET Standard enables\", \" the following key scenarios:\\n\\n\\n\\nDefines uniform set of base class libraries APIs for all .NET imple\", \"mentations to implement, independent of the workload.\\n\\n\\n\\nEnables developers to produce portable libr\", \"aries that are usable across .NET implementations, using this same set of APIs.\\n\\n13\\n\\nCHAPTER 2 | Wha\", \"t\\u2019s new with .NET for Desktop?\\n\\n.NET Standard is the evolution of PCLs and the following list shows \", \"the fundamental differences between .NET Standard and PCLs:\\n\\n\\n\\n.NET Standard is a set of curated API\", \"s, picked by Microsoft. PCLs aren\\u2019t.\\n\\n\\n\\nThe APIs that a PCL contains are dependent on the platforms \", \"that you choose to target when you create it. This makes a PCL only sharable for the specific target\", \"s that you choose.\\n\\n\\n\\n.NET Standard is platform-agnostic, so it can run on Windows, macOS, and Linux\", \".\\n\\n\\n\\nPCLs can also run cross-platform, but they can only target a limited set of platforms.\\n\\nNew Des\", \"ktop features in .NET\\n\\nSupport for Windows Forms and WPF\\n\\nWindows Forms and WPF are part of .NET Cor\", \"e since version 3.0. Both presentation frameworks are for Windows only, so they aren\\u2019t cross-platfor\", \"m. You can think of WPF as a rich layer over DirectX and Windows Forms as a thinner layer over GDI+.\", \" WPF and Windows Forms do a great job of exposing and exercising much of the desktop application fun\", \"ctionality in Windows. So Windows Forms and WPF are available for .NET Core and .NET Framework. Targ\", \"et your new desktop applications to .NET 6 or later, and migrate your existing apps from .NET Framew\", \"ork to .NET 6 or later.\\n\\nA new version of .NET Standard, version 2.1, was released at the same time \", \"as .NET Core 3.0. To see which .NET implementations support which .NET Standard versions, see Which \", \".NET Standard version to target.\\n\\nThe .NET (Core) implementations for both Windows Forms and WPF are\", \" open source.\\n\\nXAML Islands\\n\\nXAML Islands is a set of components for developers to use Windows 10 co\", \"ntrols (UWP XAML controls) in their WPF, Windows Forms, and native Win32 apps (like MFC). You can ha\", \"ve your \\u201cislands\\u201d of UWP XAML controls wherever you want inside your Win32 apps.\\n\\nThese XAML Islands\", \" are possible because Windows 10, version 1903 introduced a set of APIs that allows hosting UWP XAML\", \" content in Win32 windows using windows handlers (HWnds). Only apps running on Windows 10 1903 and l\", \"ater can use XAML Islands.\\n\\nTo make it easier to create XAML Islands for Windows Forms and WPF devel\", \"opers, the Windows Community Toolkit introduces a set of .NET wrappers in several NuGet packages. Th\", \"ose wrappers are the wrapped and hosting controls:\\n\\n\\n\\nThe WebView, WebViewCompatible, InkCanvas, Med\", \"iaPlayerElement, and MapControl wrapped controls wrap some UWP XAML controls into Windows Forms or W\", \"PF controls, hiding UWP concepts for those developers.\\n\\n\\n\\nThe WindowsXamlHost control for Windows Fo\", \"rms and WPF allows other not-wrapped UWP XAML controls and custom controls to be loaded into a XAML \", \"Island.\\n\\n14\\n\\nCHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\nAccess to all Windows 10 and Windows 11 \", \"APIs\\n\\nWindows 10 and Windows 11 have a large number of APIs available for developers to work with. T\", \"hese APIs give access to a wide variety of functionality like authentication, bluetooth, appointment\", \"s, and contacts. Now these APIs are exposed through .NET and give Windows developers the chance to c\", \"reate powerful desktops apps using the capabilities present on Windows 10 and Windows 11.\\n\\nSide-by-s\", \"ide support and self-contained EXEs\\n\\nThe .NET deployment model is one of the biggest benefits that W\", \"indows desktop developers will experience with .NET. The ability to globally install .NET provides m\", \"uch of the same central installation and servicing benefits of .NET Framework, while not requiring i\", \"n-place updates.\\n\\nWhen a new .NET version is released, you can update each app on a machine as neede\", \"d without any concern of affecting other applications. New .NET versions are installed in their own \", \"directories and exist \\u201cside-by-side\\u201d with each other.\\n\\nIf you need to deploy with isolation, you can\", \" deploy .NET with your application. .NET will bundle your app with the .NET runtime as a single exec\", \"utable. The modular architecture used by .NET makes these flexible deployment options possible.\\n\\nPer\", \"formance\\n\\nSince its start, targeting the web and cloud workloads, .NET has had performance plugged i\", \"nto its DNA. Server-side code must be performant enough to fulfill high-concurrency scenarios and .N\", \"ET 7 scores today as the best performance web platform in the market.\\n\\nOld Windows Forms code has be\", \"en refactored for .NET, which reduced memory allocations for drawing Forms and Controls. By simply u\", \"pgrading from .NET Framework to .NET or later, your applications become much faster. You can take ad\", \"vantage of these performance improvements when you use .NET to build your next generation of desktop\", \" applications.\\n\\n15\\n\\nCHAPTER 2 | What\\u2019s new with .NET for Desktop?\\n\\nCHAPTER 3\\n\\nMigrating Modern Deskt\", \"op applications\\n\\nIn this chapter, we\\u2019re exploring the most common issues and challenges you can face\", \" when migrating an existing application from .NET Framework to .NET.\\n\\nIf you just want to update you\", \"r application to the latest .NET version using a tool and not get into the details of what\\u2019s happeni\", \"ng behind the scenes, feel free to skip this chapter and find step-by-step instructions in the Examp\", \"le of migrating to .NET chapter.\\n\\nA complex desktop application doesn\\u2019t work in isolation and needs \", \"some kind of interaction with subsystems that may reside on the local machine or on a remote server.\", \" It will probably need some kind of database to connect with as a persistence store either locally o\", \"r remotely. With the rise of Internet and service-oriented architectures, it\\u2019s common to have your a\", \"pplication connected to some sort of service residing on a remote server or in the cloud. You may ne\", \"ed to access the machine file system to implement some functionality. Alternatively, maybe you\\u2019re us\", \"ing a piece of functionality that resides inside a COM object outside your application, which is a c\", \"ommon scenario if, for example, you\\u2019re integrating Office assemblies in your app.\\n\\nBesides, there ar\", \"e differences in the API surface that is exposed by .NET Framework and .NET, and some features that \", \"are available on .NET Framework aren\\u2019t available on .NET. It\\u2019s important for you to know and take th\", \"em into account when planning a migration.\\n\\nConfiguration files\\n\\nConfiguration files offer the possi\", \"bility to store sets of properties that are read at run time and can affect the behavior of your app\", \", such as where to locate a database or how many times to execute a loop. The beauty of this techniq\", \"ue is that you can modify some aspects of the application without the need to recode and recompile. \", \"This comes in handy when, for example, the same app code runs on a development environment with a ce\", \"rtain set of configuration values and in production environment with a different set.\\n\\nConfiguration\", \" on .NET Framework\\n\\nIf you have a working .NET Framework desktop application, chances are you have a\", \"n app.config file accessed through the AppSettingsSection class from the System.Configuration namesp\", \"ace.\\n\\n16\\n\\nCHAPTER 3 | Migrating Modern Desktop applications\\n\\nWithin the .NET Framework infrastructur\", \"e, there\\u2019s a hierarchy of configuration files that inherit properties from its parents. You can find\", \" a machine.config file that defines many properties and configuration sections that can be used or o\", \"verridden in any descendant configuration file.\\n\\nConfiguration on .NET\\n\\nIn the .NET world, there\\u2019s n\", \"o machine.config file. And even though you can continue to use the old fashioned System.Configuratio\", \"n namespace, you may consider switching to the modern Microsoft.Extensions.Configuration, which offe\", \"rs a good number of enhancements.\\n\\nThis configuration API supports the concept of a configuration pr\", \"ovider, which defines the data source to be used to load the configuration. There are different kind\", \"s of built-in providers, such as:\\n\\n\\n\\nIn-memory .NET objects\\n\\n\\n\\nINI files\\n\\n\\n\\nJSON files\\n\\n\\n\\nXML files\\n\", \"\\n\\n\\nCommand-line arguments\\n\\n\\n\\nEnvironment variables\\n\\n\\n\\nEncrypted user store\\n\\nOr you can build your ow\", \"n.\\n\\nThe new configuration API allows a list of name-value pairs that can be grouped into a multi-lev\", \"el hierarchy. Any stored value maps to a string, and there\\u2019s built-in binding support that allows yo\", \"u to deserialize settings into a custom plain old CLR object (POCO).\\n\\nThe ConfigurationBuilder objec\", \"t lets you add as many configuration providers as you may need for your application. A precedence ru\", \"le is used to resolve provider preference. So, the last provider you add in your code overrides the \", \"others. This is a great feature for managing different environments for execution since you can defi\", \"ne different configurations for development, testing, and production environments. And you can manag\", \"e them in a single function inside your code.\\n\\nMigrating configuration files\\n\\nYou can continue to us\", \"e your existing app.config XML file. However, you could take this opportunity to migrate your config\", \"uration to benefit from the several enhancements made in .NET.\\n\\nTo migrate from an old-style app.con\", \"fig to a new configuration file, you should choose between an XML format and a JSON format.\\n\\nIf you \", \"choose XML, the conversion is straightforward. Since the content is the same, just save the app.conf\", \"ig file with XML as type. Then, change the code that references AppSettings to use the Configuration\", \"Builder class. This change should be easy.\\n\\nIf you want to use a JSON format and you don\\u2019t want to m\", \"igrate by hand, there\\u2019s a tool called dotnet- config2json that can convert an app.config file to a J\", \"SON configuration file.\\n\\nYou may come across some issues when using configuration sections that were\", \" defined in the machine.config file. For example, consider the following configuration:\\n\\n17\\n\\nCHAPTER\", \" 3 | Migrating Modern Desktop applications\\n\\n<configuration> <system.diagnostics> <switches> <add nam\", \"e=\\\"General\\\" value=\\\"4\\\" /> </switches> <trace autoflush=\\\"true\\\" indentsize=\\\"2\\\"> <listeners> <add name=\\\"\", \"myListener\\\" type=\\\"System.Diagnostics.TextWriterTraceListener, System, Version=1.0.3300.0, Culture=ne\", \"utral, PublicKeyToken=b77a5c561934e089\\\" initializeData=\\\"MyListener.log\\\" traceOutputOptions=\\\"ProcessI\", \"d, LogicalOperationStack, Timestamp, ThreadId, Callstack, DateTime\\\" /> </listeners> </trace> </syste\", \"m.diagnostics> </configuration>\\n\\nIf you take this configuration to a .NET app, you\\u2019ll get an excepti\", \"on:\\n\\nUnrecognized configuration section System.Diagnostics\\n\\nThis exception occurs because that secti\", \"on and the assembly responsible for handling that section was defined in the machine.config file, wh\", \"ich now doesn\\u2019t exist.\\n\\nTo easily fix the issue, you can copy the section definition from your old m\", \"achine.config to your new configuration file:\\n\\n<configSections> <section name=\\\"system.diagnostics\\\" t\", \"ype=\\\"System.Diagnostics.SystemDiagnosticsSection, System, Version=4.0.0.0, Culture=neutral, PublicKe\", \"yToken=b77a5c561934e089\\\"/> </configSections>\\n\\nAccessing databases\\n\\nAlmost every desktop application \", \"needs some kind of database. For desktop, it\\u2019s common to find client-server architectures with a dir\", \"ect connection between the desktop app and the database engine. These databases can be local or remo\", \"te depending on the need to share information between different users.\\n\\nFrom the code perspective, t\", \"here have been many technologies and frameworks to give the developer the possibility to connect, qu\", \"ery, and update a database.\\n\\nThe most common examples of database you can find when talking about Wi\", \"ndows Desktop application are Microsoft Access and Microsoft SQL Server. If you have more than 20 ye\", \"ars of experience programming for the desktop, names like ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ, and \", \"Entity Framework will sound familiar.\\n\\n18\\n\\nCHAPTER 3 | Migrating Modern Desktop applications\\n\\nODBC\\n\\n\", \"You can continue to use ODBC on .NET since Microsoft is providing the System.Data.Odbc library compa\", \"tible with .NET Standard 2.0.\\n\\nOLE DB\\n\\nOLE DB has been a great way to access various data sources in\", \" a uniform manner. But it was based on COM, which is a Windows-only technology, and as such wasn\\u2019t t\", \"he best fit for a cross-platform technology such as .NET. It\\u2019s also unsupported in SQL Server versio\", \"ns 2014 and later. For those reasons, OLE DB won\\u2019t be supported by .NET.\\n\\nADO.NET\\n\\nYou can still use\", \" ADO.NET from your existing desktop code on .NET. You just need to update some NuGet packages.\\n\\nEF C\", \"ore vs. EF6\\n\\nThere are two currently supported versions of Entity Framework (EF), Entity Framework 6\", \" (EF6) and EF Core.\\n\\nThe latest technology released as part of the .NET Framework world is Entity Fr\", \"amework, with 6.4 being the latest version. With the launch of .NET Core, Microsoft also released a \", \"new data access stack based on Entity Framework and called Entity Framework Core.\\n\\nYou can use EF 6.\", \"4 and EF Core from both .NET Framework and .NET. So, what are the decision drivers to help to decide\", \" between the two?\\n\\nEF 6.3 is the first version of EF6 that can run on .NET and work cross-platform. \", \"In fact, the main goal of this release was to make it easier to migrate existing applications that u\", \"se EF6 to .NET.\\n\\nEF Core was designed to provide a developer experience similar to EF6. Most of the \", \"top-level APIs remain the same, so EF Core will feel familiar to developers who have used EF6.\\n\\nAlth\", \"ough compatible, there are differences on the implementation you should check before making a decisi\", \"on. For more information, see Compare EF Core & EF6.\\n\\nThe recommendation is to use EF Core if:\\n\\n\\n\\nTh\", \"e app needs the capabilities of .NET.\\n\\n\\n\\nEF Core supports all of the features that the app requires.\", \"\\n\\nConsider using EF6 if both of the following conditions are true:\\n\\n\\n\\nThe app will run on Windows an\", \"d .NET Framework 4.0 or later.\\n\\n\\n\\nEF6 supports all of the features that the app requires.\\n\\n19\\n\\nCHAPT\", \"ER 3 | Migrating Modern Desktop applications\\n\\nRelational databases\\n\\nSQL Server\\n\\nSQL Server has been \", \"one of the databases of choice if you were developing for the desktop some years ago. With the use o\", \"f System.Data.SqlClient in .NET Framework, you could access versions of SQL Server, which encapsulat\", \"es database-specific protocols.\\n\\nIn .NET, you can find a new SqlClient class, fully compatible with \", \"the one existing in the .NET Framework but located in the Microsoft.Data.SqlClient library. You just\", \" have to add a reference to the Microsoft.Data.SqlClient NuGet package and do some renaming for the \", \"namespaces and everything should work as expected.\\n\\nMicrosoft Access\\n\\nMicrosoft Access has been used\", \" for years when the sophisticated and more scalable SQL Server wasn\\u2019t needed. You can still connect \", \"to Microsoft Access using the System.Data.Odbc library.\\n\\nConsuming services\\n\\nWith the rise of servic\", \"e-oriented architectures, desktop applications began to evolve from a client- server model to the th\", \"ree-layer approach. In the client-server approach, a direct database connection is established from \", \"the client holding the business logic, usually inside a single EXE file. On the other hand, the thre\", \"e-layer approach establishes an intermediate service layer implementing business logic and database \", \"access, allowing for better security, scalability, and reusability. Instead of working directly with\", \" underlying data, the layered approach relies on a set of services implementing contracts and typed \", \"objects for data transfer.\\n\\nIf you have a desktop application using a WCF service and you want to mi\", \"grate it to .NET, there are some things to consider.\\n\\nThe first thing is how to resolve the configur\", \"ation to access the service. Because the configuration is different on .NET, you\\u2019ll need to make som\", \"e updates in your configuration file.\\n\\nSecond, you\\u2019ll need to regenerate the service client with the\", \" new tools present on Visual Studio 2019 and Visual Studio 2022. In this step, you must consider act\", \"ivating the generation of the synchronous operations to make the client compatible with your existin\", \"g code.\\n\\nAfter the migration, if you find that there are libraries you need that aren\\u2019t present on .\", \"NET, you can add a reference to the Microsoft.Windows.Compatibility NuGet package and see if the mis\", \"sing functions are there.\\n\\nIf you\\u2019re using the WebRequest class to perform web service calls, you ma\", \"y find some differences on .NET. The recommendation is to use HttpClient instead.\\n\\n20\\n\\nCHAPTER 3 | M\", \"igrating Modern Desktop applications\\n\\nConsuming a COM Object\\n\\nCurrently, there\\u2019s no way to add a ref\", \"erence to a COM object from Visual Studio 2019 or Visual Studio 2022 to use with .NET. So, you have \", \"to manually modify the project file.\\n\\nInsert a COMReference structure inside the project file like i\", \"n the following example:\\n\\n<ItemGroup> <COMReference Include=\\\"MSHTML\\\"> <Guid>{3050F1C5-98B5-11CF-BB82\", \"-00AA00BDCE0B}\\\\</Guid> <VersionMajor>4</VersionMajor> <VersionMinor>0</VersionMinor> <Lcid>0</Lcid> \", \"<WrapperTool>primary</WrapperTool> <Isolated>false</Isolated> </COMReference> </ItemGroup>\\n\\nMore thi\", \"ngs to consider\\n\\nSeveral technologies available to .NET Framework libraries aren\\u2019t available for .NE\", \"T Core or .NET 7. If your code relies on some of these technologies, consider the alternative approa\", \"ches outlined in this section.\\n\\nThe Windows Compatibility Pack provides access to APIs that were pre\", \"viously available only for .NET Framework. It can be used on .NET Core and .NET Standard projects.\\n\\n\", \"For more information on API compatibility, you can find documentation about breaking changes and dep\", \"recated/legacy APIs at https://learn.microsoft.com/dotnet/core/compatibility/fx-core.\\n\\nAppDomains\\n\\nA\", \"pplication domains (AppDomains) isolate apps from one another. AppDomains require runtime support an\", \"d are expensive. Creating additional app domains isn\\u2019t supported. For code isolation, we recommend s\", \"eparate processes or using containers as an alternative. For the dynamic loading of assemblies, we r\", \"ecommend the new AssemblyLoadContext class.\\n\\nTo make code migration from .NET Framework easier, .NET\", \" exposes some of the AppDomain API surface. Some of the APIs function normally (for example, AppDoma\", \"in.UnhandledException), some members do nothing (for example, SetCachePath), and some of them throw \", \"PlatformNotSupportedException (for example, CreateDomain).\\n\\nRemoting\\n\\n.NET Remoting was used for cro\", \"ss-AppDomain communication, which is no longer supported. Also, Remoting requires runtime support, w\", \"hich is expensive to maintain. For these reasons, .NET Remoting isn\\u2019t supported on .NET.\\n\\nFor commun\", \"ication across processes, you should consider inter-process communication (IPC) mechanisms as an alt\", \"ernative to Remoting, such as the or the MemoryMappedFile class.\\n\\n21\\n\\nCHAPTER 3 | Migrating Modern D\", \"esktop applications\\n\\nAcross machines, use a network-based solution as an alternative. Preferably, us\", \"e a low-overhead plaintext protocol, such as HTTP. The Kestrel web server, the web server used by AS\", \"P.NET Core, is an option here.\\n\\nCode Access Security (CAS)\\n\\nSandboxing, which relies on the runtime \", \"or the framework to constrain which resources a managed application or library uses or runs, isn\\u2019t s\", \"upported on .NET.\\n\\nUse security boundaries that are provided by the operating system, such as virtua\", \"lization, containers, or user accounts, for running processes with the minimum set of privileges.\\n\\nS\", \"ecurity Transparency\\n\\nSimilar to CAS, Security Transparency separates sandboxed code from security c\", \"ritical code in a declarative fashion but is no longer supported as a security boundary.\\n\\nUse securi\", \"ty boundaries that are provided by the operating system, such as virtualization, containers, or user\", \" accounts, for running processes with the least set of privileges.\\n\\n22\\n\\nCHAPTER 3 | Migrating Modern\", \" Desktop applications\\n\\nCHAPTER 4\\n\\nWindows 10 migration\\n\\nConsider the following situation: You have a\", \" working desktop application that was developed in the Windows 7 days. It\\u2019s using WPF technology ava\", \"ilable at that time and working fine but it has an outdated UI and behaviors when you run it on Wind\", \"ows 10 or Windows 11. It is like when you watch a futuristic movie like Matrix and you see Neo using\", \" the Nokia 8110 device. The film works great after 20 years but it would rather benefit from a devic\", \"e modernization.\\n\\nWith the release of Windows 10, Microsoft introduced many innovations to support s\", \"cenarios like tablets and touch devices and to provide the best experience for users for a Microsoft\", \" operating system ever. For example, you can:\\n\\n\\n\\nSign in with your face using Windows Hello.\\n\\n\\n\\nUse \", \"a pen to draw or handwrite text that is automatically recognized and digitalized.\\n\\n\\n\\nRun locally cus\", \"tomized AI models built on the cloud using WinML.\\n\\nAll these features are enabled for Windows develo\", \"pers through Windows Runtime (WinRT) libraries. You can take advantage of these features in your exi\", \"sting desktop apps because the libraries are exposed to both the .NET Framework and .NET as well. Yo\", \"u can even modernize your UI with the use of XAML Islands and improve the visuals and behavior of yo\", \"ur apps according to the times.\\n\\nOne important thing to note here is that you don\\u2019t need to abandon \", \".NET Framework technology to follow this modernization path. You can safely stay on there and have a\", \"ll the benefits of Windows 10 and Windows 11 without the pressure to migrate to .NET. So, you get bo\", \"th the power and the flexibility to choose your modernization path.\\n\\nWinRT APIs\\n\\nWinRT APIs are obje\", \"ct-oriented, well-structured application programming interfaces (APIs) that give Windows 10 and Wind\", \"ows 11 developers access to everything the operating system has to offer. Through WinRT APIs, you ca\", \"n integrate functionalities like Push Notifications, Device APIs, Microsoft Ink, and WinML, among ot\", \"hers on your desktop apps.\\n\\nIn general, WinRT APIs can be called from a classic desktop app. However\", \", two main areas present an exception to this rule:\\n\\n\\n\\nAPIs that require a package identity.\\n\\n\\n\\nAPIs\", \" that require visualization like XAML or Composition.\\n\\n23\\n\\nCHAPTER 4 | Windows 10 migration\\n\\nUnivers\", \"al Windows Platform (UWP) packages\\n\\nApplication Package Identity\\n\\nUWP apps have a deployment system \", \"where the OS manages the installation and uninstallation of application. That requires the installat\", \"ion to be declarative, meaning that no user code is executed during install. Instead, everything the\", \" app wants to integrate with the system, such as protocols, file types, and extensions, is declared \", \"in the application manifest. At deployment time, the deployment pipeline configures those integratio\", \"n points. The only way for the OS to manage all this functionality and keep track of it is for each \", \"\\u2018package\\u2019 to have an identity, a unique identifier for the application.\\n\\nSome WinRT APIs require thi\", \"s package identity to work as expected. However, classic desktop apps like native C++ or .NET apps, \", \"use different deployment systems that don\\u2019t require a package identity. If you want to use these Win\", \"RT APIs in your desktop application, you need to provide them a package identity.\\n\\nOne way to procee\", \"d is to build an additional packaging project. Inside the packaging project, you point to the origin\", \"al source code project and specify the Identity information you want to provide. If you install the \", \"package and run the installed app, it will automatically get an identify enabling your code to call \", \"all WinRT APIs requiring Identity.\\n\\n<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <Package xmlns=\\\"http://sc\", \"hemas.microsoft.com/appx/manifest/foundation/windows10\\\" xmlns:uap=\\\"http://schemas.microsoft.com/appx\", \"/manifest/uap/windows10\\\"> <Identity Name=\\\"YOUR-APP-GUID \\\" Publisher=\\\"CN=YOUR COMPANY\\\" Version=\\\"1.x.x\", \".x\\\" /> </Package>\\n\\nYou can check which APIs need a packaged application identity by inspecting if th\", \"e type that contains the API is marked with the DualApiPartition attribute. If it is, you can call i\", \"f from an unpackaged traditional desktop app. Otherwise, you must convert your classic desktop app t\", \"o a UWP with the help of a packaging project.\\n\\nhttps://learn.microsoft.com/windows/desktop/apiindex/\", \"uwp-apis-callable-from-a-classic-desktop-app\\n\\nBenefits of packaging\\n\\nBesides giving you access to th\", \"ese APIs, you get some additional benefits by creating a Windows App package for your desktop applic\", \"ation including:\\n\\n\\n\\nStreamlined deployment. Apps have a great deployment experience ensuring that us\", \"ers can confidently install an application and update it. If a user chooses to uninstall the app, it\", \"\\u2019s removed completely with no trace left behind preventing the Windows rot problem.\\n\\n\\n\\nAutomatic upd\", \"ates and licensing. Your application can participate in the Microsoft Store\\u2019s built-in licensing and\", \" automatic update facilities. Automatic update is a highly reliable and efficient mechanism, because\", \" only the changed parts of files are downloaded.\\n\\n24\\n\\nCHAPTER 4 | Windows 10 migration\\n\\n\\n\\nIncreased \", \"reach and simplified monetization. Maybe not your case but if you choose to distribute your applicat\", \"ion through the Microsoft Store you reach millions of Windows 10 and Windows 11 users.\\n\\n\\n\\nAdd UWP fe\", \"atures. You can add UWP features to your app\\u2019s package at your own pace.\\n\\nPrepare for packaging\\n\\nBef\", \"ore proceeding to package your desktop application, there are some points you have to address before\", \" starting the process. Your application must respect any of the Microsoft Store rules and policies a\", \"nd run in the UWP application model. For example, it has to run on the .NET Framework 4.6.2 or later\", \" and writes to the HKEY_CURRENT_USER registry hive and the AppData folders will be virtualized to a \", \"user-specific app-local location.\\n\\nThe design goal for packaging is to separate the application stat\", \"e from system state while maintaining compatibility with other apps. Windows 10 and Windows 11 accom\", \"plish this goal by placing the application inside a UWP package. It detects and redirects some chang\", \"es to the file system and registry at run time to fulfill the promise of a trusted and clean install\", \" and uninstall behavior of an application provided by packaging.\\n\\nPackages that you create for your \", \"desktop application are desktop-only, full-trust applications that aren\\u2019t sandboxed, although there\\u2019\", \"s lightweight virtualization applied to the app for writes to HKCU and AppData. This virtualization \", \"allows them to interact with other apps the same way classic desktop applications do.\\n\\nInstallation\\n\", \"\\nApp packages are installed under %ProgramFiles%\\\\WindowsApps\\\\package_name, with the executable title\", \"d app_name.exe. Each package folder contains a manifest (named AppxManifest.xml) that contains a spe\", \"cial XML namespace for packaged apps. Inside that manifest file is an <EntryPoint> element, which re\", \"ferences the full-trust app. When that application is launched, it doesn\\u2019t run inside an app contain\", \"er, but instead it runs as the user as it normally would.\\n\\nAfter deployment, package files are marke\", \"d read-only and heavily locked down by the operating system. Windows prevents apps from launching if\", \" these files are tampered with.\\n\\nFile system\\n\\nThe OS supports different levels of file system operat\", \"ions for packaged desktop applications, depending on the folder location.\\n\\nWhen trying to access the\", \" user\\u2019s AppData folder, the system creates a private per-user, per-app location behind the scenes. T\", \"his creates the illusion that the packaged application is editing the real AppData when it\\u2019s actuall\", \"y modifying a private copy. By redirecting writes this way, the system can track all file modificati\", \"ons made by the app. It can then clean all those files when uninstalling reducing system \\u201crot\\u201d and p\", \"roviding a better application removal experience for the user.\\n\\n25\\n\\nCHAPTER 4 | Windows 10 migration\", \"\\n\\nRegistry\\n\\nApp packages contain a registry.dat file, which serves as the logical equivalent of HKLM\", \"\\\\Software in the real registry. At run time, this virtual registry merges the contents of this hive \", \"into the native system hive to provide a singular view of both.\\n\\nAll writes are kept during package \", \"upgrade and only deleted when the application is uninstalled.\\n\\nUninstallation\\n\\nWhen the user uninsta\", \"lls a package, all files and folders located under C:\\\\Program Files\\\\WindowsApps\\\\package_name are rem\", \"oved, as well as any redirected writes to AppData or the registry that were captured during the proc\", \"ess.\\n\\nFor details about how a packaged application handles installation, file access, registry, and \", \"uninstallation, see https://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-the- scen\", \"es.\\n\\nYou can get a complete list of things to check on https://learn.microsoft.com/windows/msix/desk\", \"top/desktop-to-uwp-prepare.\\n\\nHow to add WinRT APIs to your desktop project\\n\\nIn this section, you can\", \" find a walkthrough on how to integrate Toast Notifications in an existing WPF application. Although\", \" it\\u2019s simple from the code perspective, it helps illustrate the whole process. Notifications are one\", \" of the many available WinRT APIs available that you can use in .NET app. In this case, the API requ\", \"ires a Package Identity. This process is more straightforward if the APIs don\\u2019t require Package Iden\", \"tity.\\n\\nLet\\u2019s take an existing WPF sample app that reads files and shows its contents on the screen. \", \"The goal is to display a Toast Notification when the application starts.\\n\\n26\\n\\nCHAPTER 4 | Windows 10\", \" migration\\n\\nFirst, you should check in the following link whether the Windows 10 or Windows 11 API t\", \"hat you\\u2019ll use requires a Package Identity:\\n\\nhttps://learn.microsoft.com/windows/apps/desktop/modern\", \"ize/desktop-to-uwp-supported-api\\n\\nOur sample will use the Windows.UI.Notifications.Notification API \", \"that requires a packaged identity:\\n\\nTo access the WinRT API, add a reference to the Microsoft.Window\", \"s.SDK.Contracts NuGet package and this package will do the magic behind the scenes (see details at h\", \"ttps://blogs.windows.com/windowsdeveloper/2019/04/30/calling-windows-10-apis-from-a-desktop- applica\", \"tion-just-got-easier/).\\n\\nYou\\u2019re now prepared to start adding some code.\\n\\n27\\n\\nCHAPTER 4 | Windows 10 \", \"migration\\n\\nCreate a ShowToastNotification method that will be called on application startup. It just\", \" builds a toast notification from an XML pattern:\\n\\nprivate void ShowNotification(string title, strin\", \"g content, string image) { string xmlString = $@\\\"<toast><visual><binding template = 'ToastGeneric'><\", \"text>{title}</text><text>{content}</text><image src=>'{image}'</image></binding></visual></toast>\\\"; \", \"XmlDocument toastXml = new XmlDocument(); toastXml.LoadXml(xmlString); ToastNotification toast = new\", \" ToastNotification(toastXml); ToastNotificationManager.CreateToastNotifier().Show(toast); }\\n\\nAlthoug\", \"h the project builds, there are errors because the Notifications API requires a Package Identity and\", \" you didn\\u2019t provide it. Adding a Windows Packaging Project to the solution will fix the issue:\\n\\nSele\", \"ct the minimum Windows version you want to support and the version you\\u2019re targeting. Not all the Win\", \"RT APIs are supported in all Windows 10 and Windows 11 versions. Each Windows 10 or Windows 11 updat\", \"e adds new APIs that are only available from this version; down-level support isn\\u2019t available.\\n\\n28\\n\\n\", \"CHAPTER 4 | Windows 10 migration\\n\\nNext step is to add the WPF application to the Windows Packaging P\", \"roject by adding a project reference:\\n\\n29\\n\\nCHAPTER 4 | Windows 10 migration\\n\\nA Windows Packaging Pro\", \"ject can package several apps so you should set which one is the Entry Point:\\n\\n30\\n\\nCHAPTER 4 | Windo\", \"ws 10 migration\\n\\nNext step is to set the WPF Project as the startup Project in the solution configur\", \"ation. You can press F5 to compile and build and see the results.\\n\\nLet\\u2019s generate the package so you\", \" can install your app. Right click on Store > Create App Packages.\\n\\n31\\n\\nCHAPTER 4 | Windows 10 migra\", \"tion\\n\\nSelect the sideloading option to deploy the app from your machine:\\n\\n32\\n\\nCHAPTER 4 | Windows 10\", \" migration\\n\\nSelect the application architecture of your app:\\n\\n33\\n\\nCHAPTER 4 | Windows 10 migration\\n\\n\", \"Finally, create the package by clicking on Create.\\n\\nXAML Islands\\n\\nXAML Islands are a set of componen\", \"ts that enable Windows desktop developers to use UWP XAML controls on their existing Win32 applicati\", \"ons, including Windows Forms and WPF.\\n\\n34\\n\\nCHAPTER 4 | Windows 10 migration\\n\\nYou can image your Win3\", \"2 app with your standard controls and among them an \\u201cisland\\u201d of UWP UI containing controls from the \", \"modern world. The concept is similar to having an iFrame inside a web page that shows content from a\", \" different page.\\n\\nBesides adding functionality from the Windows 10 and Windows 11 APIs, you can add \", \"pieces of UWP XAML inside of your app using XAML Islands.\\n\\nWindows 10 1903 update introduced a set o\", \"f APIs that allow hosting UWP XAML content in Win32 windows. Only apps running on Windows 10 1903 or\", \" later can use XAML Islands.\\n\\nThe road to XAML Islands\\n\\nThe road to XAML Islands started in 2012 whe\", \"n Microsoft introduced the WinRT APIs as a framework to modernize the Win32 apps (Windows Forms, WPF\", \", and native Win32 apps). However, the new UI controls inside WinRT were available for new applicati\", \"ons but not for existing ones.\\n\\nIn 2015, along with Windows 10, UWP was born. UWP allows you to crea\", \"te apps that work across Windows devices like XBox, Mobile, and Desktop. One year later, Microsoft a\", \"nnounced Desktop Bridge (formerly known as Project Centennial). Desktop Bridge is a set of tools tha\", \"t allowed developers to bring their existing Win32 apps to the Microsoft Store. More capabilities we\", \"re added in 2017, allowing developers to enhance their Win32 apps leveraging some of the new Windows\", \" 10 APIs, like live tiles and notifications on the action center. But still, no new UI controls.\\n\\nAt\", \" Build 2018, Microsoft announced a way for developers to use the new Windows 10 XAML controls into t\", \"heir current Win32 apps, without fully migrating their apps to UWP. It was branded as UWP XAML Islan\", \"ds.\\n\\nHow it works\\n\\nThe Windows 10 1903 update introduced several XAML hosting APIs. Two of them are \", \"WindowsXamlManager and DesktopWindowXamlSource.\\n\\n35\\n\\nCHAPTER 4 | Windows 10 migration\\n\\nThe WindowsXa\", \"mlManager class handles the UWP XAML Framework. Its InitializeForCurrentThread method loads the UWP \", \"XAML Framework inside the current thread of the Win32 app.\\n\\nThe DesktopWindowXamlSource is the insta\", \"nce of your XAML Island content. It has the Content property, which you\\u2019re responsible for instantia\", \"ting and setting. The DesktopWindowXamlSource renders and gets its input from an HWND. It needs to k\", \"now to which other HWND it will attach the XAML Island\\u2019s one, and you\\u2019re responsible for sizing and \", \"positioning the parent\\u2019s HWND.\\n\\nWPF or Windows Forms developers don\\u2019t usually deal with HWND inside \", \"their code, so it may be hard to understand and handle HWND pointers and the underlying wiring stuff\", \" to communicate Win32 and UWP worlds.\\n\\nThe XAML Islands .NET Wrappers\\n\\nThe Windows Community Toolkit\", \" has a set the XAML Islands .NET wrappers for WPF or Windows Forms that make easier to use XAML Isla\", \"nds. These wrappers manage the HWNDs, the focus management, among other things. Windows Forms and WP\", \"F developers should use these wrappers.\\n\\nThe Windows Community Toolkit offers two types of controls:\", \" Wrapped Controls and Hosting Controls.\\n\\nWrapped Controls\\n\\nThese wrapped controls wrap some UWP cont\", \"rols into Windows Forms or WPF controls, hiding UWP concepts for those developers. These controls ar\", \"e:\\n\\nWebView and WebViewCompatible\\n\\n\\n\\nInkCanvas and InkToolbar\\n\\nMediaPlayerElement\\n\\nMapControl\\n\\nAdd t\", \"he Microsoft.Toolkit.Wpf.UI.Controls package to your project, include the reference to the namespace\", \", and start using them.\\n\\n<Window ... xmlns:uwpControls=\\\"clr- namespace:Microsoft.Toolkit.Wpf.UI.Cont\", \"rols;assembly=Microsoft.Toolkit.Wpf.UI.Controls\\\"> <Grid> <Grid.RowDefinitions> <RowDefinition Height\", \"=\\\"Auto\\\"/> <RowDefinition Height=\\\"\\\\*\\\"/> </Grid.RowDefinitions> <uwpControls:InkToolbar TargetInkCanva\", \"s=\\\"{x:Reference Name=inkCanvas}\\\"/> <uwpControls:InkCanvas Grid.Row=\\\"1\\\" x:Name=\\\"inkCanvas\\\" /> </Grid>\", \"\\n\\nHosting controls\\n\\nThe power of XAML Islands extends to most first-party controls, third-party cont\", \"rols, and custom controls developed for UWP, which can be integrated into Windows Forms and WPF as \\u201c\", \"Islands\\u201d with fully functional UI. The WindowsXamlHost control for WPF and Windows Forms allows doin\", \"g this.\\n\\n36\\n\\nCHAPTER 4 | Windows 10 migration\\n\\nFor example, to use the WindowsXamlHost control in WP\", \"F, add a reference to the Microsoft.Toolkit.Wpf.UI.XamlHost package provided by the Windows Communit\", \"y Toolkit.\\n\\nOnce you\\u2019ve placed your WindowsXamlHost into your UI code, specify which UWP type you wa\", \"nt to load. You can choose to use a wrapped control like a Button or a more complex one composed of \", \"several different controls, which are a custom UWP control.\\n\\nThe following example shows how to add \", \"a UWP Button:\\n\\n<Window ... xmlns:xamlhost=\\\"clr- namespace:Microsoft.Toolkit.Wpf.UI.XamlHost;assembly\", \"=Microsoft.Toolkit.Wpf.UI.XamlHost\\\">\\n\\n<xamlhost:WindowsXamlHost x:Name=\\\"myUwpButton\\\" InitialTypeName\", \"=\\\"Windows.UI.Xaml.Controls.Button\\\" />\\n\\nThere\\u2019s a clear recommendation on how to approach this and it\", \"\\u2019s better to have one single and bigger XAML Island containing a custom composite control than to ha\", \"ve several islands with one control on each.\\n\\nOne of the core features of XAML is binding and it wor\", \"ks between your Win32 code and the island. So, you can bind, for instance, a Win32 Textbox with a UW\", \"P Textbox. One important thing to consider is that these bindings are one-way bindings, from UWP to \", \"Win32, so if you update the Textbox inside the XAML Island the Win32 Textbox will be updated, but no\", \"t the other way around.\\n\\nTo see a walkthrough about how to use XAML Islands, see:\\n\\nhttps://learn.mic\", \"rosoft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml- islands\\n\\nAdding UWP XAML \", \"custom controls\\n\\nA XAML custom control is a control (or user control) created by you or by third par\", \"ties (including WinUI 2.x controls). To host a custom UWP control in a Windows Forms or WPF app, you\", \"\\u2019ll need:\\n\\n\\n\\nTo use the WindowsXamlHost UWP control in your .NET app.\\n\\n\\n\\nTo create a UWP app project\", \" that defines a XamlApplication object.\\n\\nYour WPF or Windows Forms project must have access to an in\", \"stance of the Microsoft.Toolkit.Win32.UI.XamlHost.XamlApplication class provided by the Windows Comm\", \"unity Toolkit. This object acts as a root metadata provider for loading metadata for custom UWP XAML\", \" types in assemblies in the current directory of your application. The recommended way to do this is\", \" to add a Blank App (Universal Windows) project to the same solution as your WPF or Windows Forms pr\", \"oject and revise the default App class in this project.\\n\\nThe custom UWP XAML control can be included\", \" on this UWP app or in an independent UWP Class Library project that you reference in the same solut\", \"ion as your WPF or Windows Forms project.\\n\\nYou can check a detailed step-by-step process description\", \" at:\\n\\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml- isla\", \"nds\\n\\n37\\n\\nCHAPTER 4 | Windows 10 migration\\n\\nThe Windows UI Library (WinUI 2)\\n\\nBesides the inbox Windo\", \"ws 10 controls that comes with the OS, the same UWP XAML team also delivers additional controls in t\", \"he Windows UI Library (WinUI 2). WinUI 2 provides official native Microsoft UI controls and features\", \" for Windows UWP apps and these controls can be used inside of XAML Islands.\\n\\nWinUI 2 is open source\", \" and you can find information at https://github.com/microsoft/microsoft-ui- xaml.\\n\\nThe following art\", \"icle demonstrates how to host a UWP XAML control from the WinUI 2 library: https://learn.microsoft.c\", \"om/windows/apps/desktop/modernize/host-custom-control-with-xaml- islands\\n\\nDo you need XAML Islands\\n\\n\", \"XAML Islands are intended for existing Win32 apps that want to improve their user experience by leve\", \"raging new UWP controls and behaviors without a full rewrite of the app. You could already leverage \", \"Windows 10 and Windows 11 APIs, but up until XAML Islands, only non-UI related APIs.\\n\\nIf you\\u2019re deve\", \"loping a new Windows App, a UWP App is probably the right approach.\\n\\nThe road ahead XAML Islands: Wi\", \"nUI 3.0\\n\\nSince Windows 8, the Windows UI platform, including the XAML UI framework, visual compositi\", \"on layer, and input processing has been shipped as an integral part of Windows. This means that to b\", \"enefit from the latest improvements on UI technologies, you must upgrade to the latest version of th\", \"e UI, slowing down the pace of innovation when you develop your apps. To decouple these two evolutio\", \"n cycles and foster innovation, Microsoft is actively working on the WinUI project.\\n\\nStarting with W\", \"inUI 2 in 2018, Microsoft started shipping some new XAML UI controls and features as separate NuGet \", \"packages that build on top of the UWP SDK.\\n\\n38\\n\\nCHAPTER 4 | Windows 10 migration\\n\\nWinUI 3 is under a\", \"ctive development and will greatly expand the scope of WinUI to include the full UI platform, which \", \"will be fully decoupled from the UWP SDK:\\n\\nXAML framework will now be developed on GitHub and shippe\", \"d out of band as NuGet packages.\\n\\nThe existing UWP XAML APIs that ship as part of the OS will no lon\", \"ger receive new feature updates. They will still receive security updates and critical fixes accordi\", \"ng to the Windows 10 support lifecycle.\\n\\nThe Universal Windows Platform contains more than just the \", \"XAML framework (for example, application and security model, media pipeline, Xbox and Windows 10 she\", \"ll integrations, broad device support) and will continue to evolve. All new XAML features will just \", \"be developed and ship as part of WinUI instead.\\n\\nWinUI 3 in desktop app and WinUI XAML Islands\\n\\nAs y\", \"ou can see, WinUI 3 is the evolution of UWP XAML and it works naturally within the UWP app model and\", \" all its requirements (MSIX packaged ID, sandbox, CoreWindow, and so on. To use just WinUI 3 in a Wi\", \"n32 app model, the WinUI content should be hosted by another UI Framework (Windows Forms, WPF, and s\", \"o on) using WinUI XAML Islands. This is the right path if you want to\\n\\n39\\n\\nCHAPTER 4 | Windows 10 mi\", \"gration\\n\\nevolve your app and mix technologies. However, if you want to replace your entire old UI fo\", \"r WinUI, your app shouldn\\u2019t load UI Frameworks for just hosting WinUI.\\n\\nWinUI 3 will address this cr\", \"itical feedback adding WinUI in desktop apps. This will allow that Win32 apps can use WinUI 3 as sta\", \"ndalone UI Framework; no need to load Windows Forms or WPF.\\n\\nWithin this aggregation, WinUI 3 will l\", \"et developers easily mix and match the right combination of:\\n\\n\\n\\nApp model: UWP, Win32\\n\\n\\n\\nPlatform: .\", \"NET or Native\\n\\n\\n\\nLanguage: .NET (C#, Visual Basic), standard C++\\n\\n\\n\\nPackaging: MSIX, AppX for the Mi\", \"crosoft Store, unpackaged\\n\\n\\n\\nInterop: use WinUI 3 to extend existing WPF, WinForms, and MFC apps usi\", \"ng WinUI XAML Islands.\\n\\nIf you want to know more details, Microsoft is sharing this roadmap in https\", \"://github.com/microsoft/microsoft-ui-xaml/blob/main/docs/roadmap.md.\\n\\n40\\n\\nCHAPTER 4 | Windows 10 mig\", \"ration\\n\\nCHAPTER 5\\n\\nExample of migrating to the latest .NET\\n\\nIn this chapter, we\\u2019ll show how to migra\", \"te your applications to the latest version of .NET. You can migrate to .NET 7 from .NET Framework, .\", \"NET Core, or .NET 5. We\\u2019ll introduce a tool that can do all the work for you in most cases. If your \", \"application has special cases or complicated dependencies, we\\u2019ll also show how to do the whole migra\", \"tion process by hand. Additionally, we\\u2019ll cover the most common issues and challenges you can face w\", \"hen migrating an existing application from .NET Framework to .NET.\\n\\nMigrating from .NET Core or .NET\", \" 5\\n\\nUpdating your applications to target the latest version of .NET is easy if you already are on .N\", \"ET Core or .NET 5. If this is the case, then in Visual Studio, simply right-click on your project in\", \" Solution Explorer and choose Properties. Under Application > General > Target framework, choose .NE\", \"T 7.0. Save and rebuild your application. You\\u2019re done! Your app now runs on the latest version of .N\", \"ET. In the future when new versions become available, you can upgrade in the same way.\\n\\n41\\n\\nCHAPTER \", \"5 | Example of migrating to the latest .NET\\n\\nMigrating from .NET Framework\\n\\nMigrating from .NET Fram\", \"ework is a more complicated process because there are more differences between .NET Framework and ot\", \"her platforms that were built on top of .NET Core. But the good news is that there\\u2019s a tool that wil\", \"l do all the work for you in most cases.\\n\\nMigrating with a tool\\n\\nThe Upgrade Assistant is a migratio\", \"n tool. Using it is easy and there are step-by-step instructions available on the .NET website. In t\", \"his chapter, we\\u2019ll look at what is happening behind the scenes and how to port your application by h\", \"and. When the Upgrade Assistant is unable to migrate your application, you\\u2019ll learn the underlying m\", \"echanics so that you might be able to migrate manually.\\n\\nMigrating by hand\\n\\nThe migration process co\", \"nsists of four sequential steps:\\n\\n1.\\n\\nPreparation: Understand the dependencies the project has to ha\", \"ve an idea of what\\u2019s ahead. In this step, you take the current project into a state that simplifies \", \"the startup point for the migration.\\n\\n2. Migrate Project File: .NET projects use the new SDK-style p\", \"roject format. Create a new\\n\\nproject file with this format or update the one you have to use the SDK\", \" style.\\n\\n3.\\n\\nFix code and build: Build the code in .NET addressing API-level differences between .NE\", \"T Framework and .NET. If needed, update third-party packages to the ones that support .NET.\\n\\n42\\n\\nCHA\", \"PTER 5 | Example of migrating to the latest .NET\\n\\n4.\\n\\nRun and test: There might be differences that \", \"don\\u2019t show up until run time. So, don\\u2019t forget to run the application and test that everything works\", \" as expected.\\n\\nPreparation\\n\\nMigrate packages.config file\\n\\nIn a .NET Framework application, all refer\", \"ences to external packages are declared in the packages.config file. In .NET, there\\u2019s no longer the \", \"need to use the packages.config file. Instead, use the PackageReference property inside the project \", \"file to specify the NuGet packages for your app.\\n\\nSo, you need to transition from one format to anot\", \"her. You can do the update manually, taking the dependencies contained in the packages.config file a\", \"nd migrating them to the project file with the PackageReference format. Or, you can let Visual Studi\", \"o do the work for you: right-click on the packages.config file and select the Migrate packages.confi\", \"g to PackageReference option.\\n\\nVerify every dependency compatibility in .NET\\n\\nOnce you\\u2019ve migrated t\", \"he package references, you must check each reference for compatibility. You can explore the dependen\", \"cies of each NuGet package your application is using on nuget.org. If the package has .NET Standard \", \"dependencies, then it\\u2019s going to work on .NET 7 because .NET supports all versions of .NET Standard.\", \" The following image shows the dependencies for the Castle.Windsor package:\\n\\nTo check the package co\", \"mpatibility, you can use the tool https://fuget.org that offers a more detailed information about ve\", \"rsions and dependencies.\\n\\nMaybe the project is referencing older package versions that don\\u2019t support\", \" .NET, but you might find newer versions that do support it. So, updating packages to newer versions\", \" is generally a good\\n\\n43\\n\\nCHAPTER 5 | Example of migrating to the latest .NET\\n\\nrecommendation. Howev\", \"er, you should consider that updating the package version can introduce some breaking changes that w\", \"ould force you to update your code.\\n\\nWhat happens if you don\\u2019t find a compatible version? What if yo\", \"u just don\\u2019t want to update the version of a package because of these breaking changes? Don\\u2019t worry \", \"because it\\u2019s possible to depend on .NET Framework packages from a .NET application. Don\\u2019t forget to \", \"test it extensively because it can cause run-time errors if the external package calls an API that i\", \"sn\\u2019t available on .NET. This is great for when you\\u2019re using an old package that isn\\u2019t going to be up\", \"dated and you can just retarget to work on .NET.\\n\\nCheck for API compatibility\\n\\nSince the API surface\", \" in .NET Framework and .NET is similar but not identical, you must check which APIs are available on\", \" .NET and which aren\\u2019t. You can use the .NET Portability Analyzer tool to surface APIs used that are\", \"n\\u2019t present on .NET. It looks at the binary level of your app, extracts all the APIs that are called\", \", and then lists which APIs aren\\u2019t available on your target framework (.NET 7 in this case).\\n\\nYou ca\", \"n find more information about this tool at:\\n\\nhttps://learn.microsoft.com/dotnet/standard/analyzers/p\", \"ortability-analyzer\\n\\nAn interesting aspect of this tool is that it only surfaces the differences fro\", \"m your own code and not code from external packages, which you can\\u2019t change. Remember you should hav\", \"e updated most of these packages to make them work with .NET.\\n\\nMigrate\\n\\n1.\\n\\nCreate the new .NET proj\", \"ect\\n\\nIn most cases, you\\u2019ll want to update your existing project to the new .NET format. However, you\", \" can also create a new project while maintaining the old one. The main drawback from updating the ol\", \"d project is that you lose designer support, which may be important to you and your development team\", \". If you want to keep using the designer, you must create a new .NET project in parallel with the ol\", \"d one and share assets. If you need to modify UI elements in the designer, you can switch to the old\", \" project to do that. And since assets are linked, they\\u2019ll be updated in the .NET project as well.\\n\\nT\", \"he SDK-style project for .NET is a lot simpler than .NET Framework\\u2019s project format. Apart from the \", \"previously mentioned PackageReference entries, you won\\u2019t need to do much more. The new project forma\", \"t includes files with certain extensions by default, such as .cs and .xaml files, without the need t\", \"o explicitly include them in the project file.\\n\\nAssemblyInfo considerations\\n\\nAttributes are autogene\", \"rated on .NET projects. If the project contains an AssemblyInfo.cs file, the definitions will be dup\", \"licated, which will cause compilation conflicts. You can delete the older AssemblyInfo.cs file or di\", \"sable autogeneration by adding the following entry to the .NET project file:\\n\\n<Project Sdk=\\\"Microsof\", \"t.NET.Sdk\\\"> <PropertyGroup> <GenerateAssemblyInfo>false</GenerateAssemblyInfo>\\n\\n44\\n\\nCHAPTER 5 | Exam\", \"ple of migrating to the latest .NET\\n\\n</PropertyGroup> </Project>\\n\\nResources\\n\\nEmbedded resources are \", \"included automatically but resources aren\\u2019t, so you need to migrate the resources to the new project\", \" file.\\n\\nPackage references\\n\\nWith the Migrate packages.config to PackageReference option, you can eas\", \"ily move your external package references to the new format as previously mentioned.\\n\\nUpdate package\", \" references\\n\\nUpdate the versions of the packages you\\u2019ve found to be compatible, as shown in the prev\", \"ious section.\\n\\nFix the code and build\\n\\nMicrosoft.Windows.Compatibility\\n\\nIf your application depends \", \"on APIs that aren\\u2019t available on .NET, such as Registry or ACLs, you have to include a reference to \", \"the Microsoft.Windows.Compatibility package to add these Windows- specific APIs. They work on .NET b\", \"ut aren\\u2019t included as they aren\\u2019t cross-platform.\\n\\nThere\\u2019s a tool called Platform compatibility anal\", \"yzer (https://learn.microsoft.com/dotnet/standard/analyzers/platform-compat-analyzer) that helps you\", \" identify APIs that aren\\u2019t compatible with your code.\\n\\nUse #if directives\\n\\nIf you need different exe\", \"cution paths when targeting .NET Framework and .NET, you should use compilation constants. Add some \", \"#if directives to your code to keep the same codebase for both targets.\\n\\nTechnologies not available \", \"on .NET\\n\\nSome technologies aren\\u2019t available on .NET, such as:\\n\\n\\n\\nAppDomains\\n\\n\\n\\nRemoting\\n\\n\\n\\nCode Acce\", \"ss Security\\n\\nWindows Workflow\\n\\nThat\\u2019s why you need to find a replacement for these technologies if y\", \"ou\\u2019re using them in your application. For more information, see the .NET Framework technologies unav\", \"ailable on .NET Core and .NET 5+ article.\\n\\n45\\n\\nCHAPTER 5 | Example of migrating to the latest .NET\\n\\n\", \"Regenerate autogenerated clients\\n\\nIf your application uses autogenerated code, such as a WCF client,\", \" you may need to regenerate this code to target .NET. Sometimes, you can find some missing reference\", \"s since they may not be included as part of the default .NET assemblies set. Using a tool like https\", \"://apisof.net/, you can easily locate the assembly the missing reference lives in and add it from Nu\", \"Get.\\n\\nRolling back package versions\\n\\nAs a general rule, we\\u2019ve previously stated that you better upda\", \"te every single package version to be compatible with .NET. However, you can find that targeting an \", \"updated and compatible version of an assembly just doesn\\u2019t pay off. If the cost of change isn\\u2019t acce\", \"ptable, you can consider rolling back package versions keeping the ones you use on .NET Framework. A\", \"lthough they may not be targeting .NET, they should work well unless they call some unsupported APIs\", \".\\n\\nRun and test\\n\\nOnce you have your application building with no errors, you can start the last step\", \" of the migration by testing every functionality.\\n\\nIn this final step, you can find several differen\", \"t issues depending on the complexity of your application and the dependencies and APIs you\\u2019re using.\", \"\\n\\nFor example, if you use configuration files (app.config), you may find some errors at run time lik\", \"e Configuration Sections not present. Using the Microsoft.Extensions.Configuration NuGet package sho\", \"uld fix that error.\\n\\nAnother reason for errors is the use of the BeginInvoke and EndInvoke methods b\", \"ecause they aren\\u2019t supported on .NET. They aren\\u2019t supported on .NET because they have a dependency o\", \"n Remoting, which doesn\\u2019t exist on .NET. To solve this issue, try to use the await keyword (when ava\", \"ilable) or the Task.Run method.\\n\\nYou can use compatibility analyzers to let you identify APIs and co\", \"de patterns in your code that can potentially cause problems at run time with .NET. Go to https://gi\", \"thub.com/dotnet/platform-compat and use the .NET API analyzer on your project.\\n\\nMigrating a Windows \", \"Forms application\\n\\nTo showcase a complete migration process of a Windows Forms application, we\\u2019ve ch\", \"osen to migrate the eShop sample application available at https://github.com/dotnet- architecture/eS\", \"hopModernizing/tree/master/eShopLegacyNTier/src/eShopWinForms. You can find the complete result of t\", \"he migration at https://github.com/dotnet- architecture/eShopModernizing/tree/master/eShopModernized\", \"NTier/src/eShopWinForms.\\n\\nThis application shows a product catalog and allows the user to navigate, \", \"filter, and search for products. From an architecture point of view, the app relies on an external W\", \"CF service that serves as a fa\\u00e7ade to a back-end database.\\n\\nYou can see the main application window \", \"in the following picture:\\n\\n46\\n\\nCHAPTER 5 | Example of migrating to the latest .NET\\n\\nIf you open the \", \".csproj project file, you can see something like this:\\n\\nAs previously mentioned, a .NET project has \", \"a more compact style and you need to migrate the project structure to the new .NET SDK style.\\n\\nIn So\", \"lution Explorer, right-click on the Windows Forms project and select Unload Project > Edit.\\n\\nNow you\", \" can update the .csproj file. You\\u2019ll delete the entire contents and replace it with the following co\", \"de:\\n\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\"> <PropertyGroup> <OutputType>WinExe</OutputType> <TargetFramew\", \"ork>net7.0-windows</TargetFramework> <UseWindowsForms>true</UseWindowsForms> <GenerateAssemblyInfo>f\", \"alse</GenerateAssemblyInfo>\\n\\n47\\n\\nCHAPTER 5 | Example of migrating to the latest .NET\\n\\n</PropertyGrou\", \"p> </Project>\\n\\nSave and reload the project. You\\u2019re now done updating the project file and the projec\", \"t is targeting .NET 7.\\n\\nIf you compile the project at this point, you\\u2019ll find some errors related to\", \" the WCF client reference. Since this code is autogenerated, you must regenerate it to target .NET.\\n\", \"\\nDelete the Reference.cs file and generate a new Service Client.\\n\\nRight-click on Connected Services \", \"and select the Add Connected Service option.\\n\\nThe Connected Services window opens. Select the Micros\", \"oft WCF Web Service option.\\n\\n48\\n\\nCHAPTER 5 | Example of migrating to the latest .NET\\n\\nIf you have th\", \"e WCF Service in the same solution as we have in this example, you can select the Discover option in\", \"stead of specifying a service URL.\\n\\nOnce the service is located, the tool reflects the API contract \", \"implemented by the service. Change the name of the namespace to be eShopServiceReference as shown in\", \" the following image:\\n\\n49\\n\\nCHAPTER 5 | Example of migrating to the latest .NET\\n\\nSelect the Finish bu\", \"tton. After a while, you\\u2019ll see the generated code.\\n\\nYou should see three autogenerated files:\\n\\n1. G\", \"etting Started: a link to GitHub to provide some information on WCF.\\n\\n2.\\n\\nConnectedService.json: con\", \"figuration parameters to connect to the service.\\n\\n3.\\n\\nReference.cs: the actual WCF client code.\\n\\n50\\n\", \"\\nCHAPTER 5 | Example of migrating to the latest .NET\\n\\nIf you compile again, you\\u2019ll see many errors c\", \"oming from .cs files inside the Helper folder. This folder was present in the .NET Framework version\", \" but not included in the old .csproj. But with the new SDK- style project, every code file present u\", \"nderneath the project file location is included by default. That is, the new .NET Core project tries\", \" to compile the files inside the Helper folder. Since that folder isn\\u2019t needed, you can safely delet\", \"e it.\\n\\nIf you compile the project again and execute it, you won\\u2019t see the product images. The proble\", \"m is that now the path to the files has slightly changed. To fix this issue, you need to add another\", \" level of depth in the path, updating in the file CatalogView.cs the line:\\n\\n51\\n\\nCHAPTER 5 | Example \", \"of migrating to the latest .NET\\n\\nstring image_name = Environment.CurrentDirectory + \\\"\\\\\\\\..\\\\\\\\..\\\\\\\\Asset\", \"s\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems.Picturefilename;\\n\\nto\\n\\nstring image_name = Environment.CurrentDi\", \"rectory + \\\"\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems.Picturefilename;\\n\\nAfter this chan\", \"ge, you can check that the application launches and runs as expected on .NET 7.\\n\\nMigrating a WPF app\", \"lication\\n\\nWe\\u2019ll use the Shop.ClassicWPF sample application to perform the migration. The following i\", \"mage shows a screenshot of the app before migration:\\n\\nThis application uses a local SQL Server Expre\", \"ss database to hold the product catalog information. This database is accessed directly from the WPF\", \" application.\\n\\nFirst, you must update the .csproj file to the new SDK style used by .NET Core applic\", \"ations. You\\u2019ll follow the same steps described in the Windows Forms migration: you\\u2019ll unload the pro\", \"ject, open the .csproj file, update its contents, and reload the project.\\n\\nIn this case, delete all \", \"the content of the .csproj file and replace it with the following code:\\n\\n52\\n\\nCHAPTER 5 | Example of \", \"migrating to the latest .NET\\n\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\"> <PropertyGroup> <OutputType>WinExe</\", \"OutputType> <TargetFramework>net7.0-windows</TargetFramework> <UseWpf>true</UseWpf> <GenerateAssembl\", \"yInfo>false</GenerateAssemblyInfo> </PropertyGroup> </Project>\\n\\nIf you reload the project and compil\", \"e it, you\\u2019ll get the following error:\\n\\nSince you\\u2019ve deleted all the .csproj contents, you\\u2019ve lost a \", \"project reference specification present in the old project. You just need to add this line to the .c\", \"sproj file to include the project reference back:\\n\\n<ItemGroup> <ProjectReference Include=\\\"..\\\\\\\\eShop.\", \"SqlProvider\\\\\\\\eShop.SqlProvider.csproj\\\" /> <ItemGroup>\\n\\nYou can also let Visual Studio help you by ri\", \"ght-clicking on the Dependencies node and selecting Add Project Reference. Select the project from t\", \"he solution and select OK:\\n\\n53\\n\\nCHAPTER 5 | Example of migrating to the latest .NET\\n\\nOnce you add th\", \"e missing project reference, the application compiles and runs as expected on .NET.\\n\\n54\\n\\nCHAPTER 5 |\", \" Example of migrating to the latest .NET\\n\\nCHAPTER 6\\n\\nDeploying Modern Desktop Applications\\n\\nWhen you\", \" develop desktop applications, one thing to consider is how your application is going to be packaged\", \" and deployed to the users\\u2019 machines. The problem with packaging, deployment, and installation is th\", \"at it usually falls under the umbrella of the IT professionals, who care about different things than\", \" developers.\\n\\nThese days, we\\u2019re all familiar with the DevOps concept, where developers and IT Pros w\", \"ork closely to move applications to their production environments. But if you\\u2019ve been in the desktop\", \" battle for more than 10 years, you might have seen the following story. A team of developers works \", \"together hard to meet the project deadlines. Business people are nervous since they need the system \", \"working on many users\\u2019 machines to run the company. On \\u201cD-Day\\u201d, the project manager checks with ever\", \"y developer that their code is working well and that everything is fine, so they can ship. Then, the\", \" package team comes in generating the setup for the app, distribute it to every user machine and a s\", \"et of test users run the application. Well, they try, because before showing any UI, the application\", \" throws an exception that says \\u201cMethod ~ of object ~ failed\\u201d. Panic starts flowing through the air a\", \"nd a brief investigation points to a young and tired developer that has introduced a third-party con\", \"trol, that certainly \\u201cworked on the dev machine\\u201d.\\n\\nInstalling desktop applications have traditionall\", \"y been a nightmare for two main reasons:\\n\\n\\n\\nLack of close collaboration culture between dev and IT t\", \"eams.\\n\\n\\n\\nLack of a solid packaging and deploying technology we can build upon.\\n\\nIn fact, we\\u2019ve been \", \"living with the fact that sometimes you regret that you installed an app because:\\n\\n\\n\\nIt ends up havi\", \"ng some undesired side effects on your machine.\\n\\n\\n\\nSome applications that were previously installed \", \"stop working.\\n\\nAdditionally, you can\\u2019t just restore the system to its original state by uninstalling\", \" the app. We\\u2019re so used to living with this situation that we\\u2019ve coined terms like \\u201cDLL Hell\\u201d or \\u201cWi\", \"nrot\\u201d.\\n\\nIn this chapter, we\\u2019ll talk about MSIX. MSIX is the new technology from Microsoft that tries\", \" to capture the best of previous technologies to provide a solid foundation for the packaging techno\", \"logy of the future.\\n\\nWhat does a packaging technology have to do with modernization? Well, it turns \", \"out that packaging is fundamental for the enterprise IT with lots of money invested there. Moderniza\", \"tion isn\\u2019t only related\\n\\n55\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\\n\\nto using the latest \", \"technologies. It\\u2019s also related to reducing time to market from the moment a business requirement is\", \" defined until your company delivers the feature to your client.\\n\\nThe modern application lifecycle\\n\\n\", \"Today, developers write and build the code for an app and then pass the generated assets to the IT P\", \"ros. Then, the IT Pros reconfigure the app and repackage it, typically in an MSI or more recently in\", \" an App-V packaging format. The app is then deployed through different channels and tools. One of th\", \"e main problems with this approach is commonly known as \\u201cpackaging paralysis\\u201d. The problem is that t\", \"his cycle repeats every time there\\u2019s an app update or an OS update.\\n\\nYou can see the process reflect\", \"ed on the following picture:\\n\\nCompanies need a way to break this packaging cycle into three independ\", \"ent cycles:\\n\\n\\n\\nOS updates\\n\\n\\n\\nApplication updates\\n\\n\\n\\nCustomization\\n\\n56\\n\\nCHAPTER 6 | Deploying Modern \", \"Desktop Applications\\n\\nThe previous diagram shows that you can:\\n\\n\\n\\nUpdate the underlying OS without h\", \"aving to repackage your apps.\\n\\n\\n\\nEnable customizations from IT without the need to repackage the ori\", \"ginal developer package.\\n\\nThis radical change leads us to the new and modern IT lifecycle as shown i\", \"n the following picture:\\n\\n57\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\\n\\nDevelopers create t\", \"he app and generate an MSIX package that IT Pros can consume and configure without the need of repac\", \"kaging. Along with the MSIX technology, Microsoft has created tools to allow IT to customize and con\", \"figure packages without repackaging.\\n\\nMSIX: The next generation of deployment\\n\\nBefore MSIX, there we\", \"re several packaging technologies available like setup wizards, MSI, ClickOnce, App-V, and scripting\", \". Each of these technologies has their own strengths and Microsoft has decided to pick the best of a\", \"ll to build MSIX. MSIX is built on the foundations of these existing technologies picking the best o\", \"f each:\\n\\n\\n\\nApp-V => Containerization\\n\\n\\n\\nClickOnce => Auto updating\\n\\nMSI => Easy to distribute\\n\\nWith \", \"MSIX, you get one installer technology with all these features.\\n\\n58\\n\\nCHAPTER 6 | Deploying Modern De\", \"sktop Applications\\n\\nBenefits of MSIX\\n\\nNever regret installing an app\\n\\nMSIX provides a predictable, r\", \"eliable, and safe deployment. The declarative method contained in the package manifest lets the OS k\", \"eep track of every asset your application needs. It also provides a true clean uninstall with no sid\", \"e effects.\\n\\nDisk space optimization\\n\\nMSIX is optimized to reduce the footprint that an application h\", \"as on the user\\u2019s machine disk space. It creates a single instance storage of your files. That is, if\", \" you have two different packages with the same DLL, the DLL isn\\u2019t installed twice. The platform take\", \"s care of that problem because it knows all the files that a particular app installed thanks to its \", \"declarative nature. It also allows you to have different versions of a DLL working side by side.\\n\\nWi\", \"th the use of resource packages, you can easily create multilingual apps and the OS takes care of in\", \"stalling the ones that are used.\\n\\nNetwork optimization\\n\\nMSIX detects the differences on the files at\", \" the byte block level enabling a feature called differential updates. What this means is that only t\", \"he updated byte blocks are downloaded on application updates.\\n\\n59\\n\\nCHAPTER 6 | Deploying Modern Desk\", \"top Applications\\n\\nWith streaming installation, the user can quickly start working on your applicatio\", \"n while other parts of the app are downloaded on the background. This feature contributes to an enga\", \"ging experience for your users.\\n\\nWith the optional packages feature, you achieve componentization on\", \" your app deployment, so you can download them when needed.\\n\\nSimple packaging and deployment\\n\\nThe Ap\", \"pManifest declares the versioning, device targeting and identity in a standard way for every applica\", \"tion. It also provides a way to sign your assets providing a solid security foundation.\\n\\nOS managed\\n\", \"\\nThe OS handles all the processes for installing, updating, and removing an application. Application\", \"s are installed per user but downloaded only once, minimizing the disk footprint. Microsoft is worki\", \"ng on providing the MSIX experience also on Windows 7.\\n\\nWindows provides integrity for the app\\n\\nWith\", \" the use of digital signatures, you can guarantee that you don\\u2019t install an application from untrust\", \"ed sources. MSIX also prevents tampering because:\\n\\n\\n\\nIt keeps a record of file hashes.\\n\\n\\n\\nIt detects\", \" if a file has been modified after installation.\\n\\n60\\n\\nCHAPTER 6 | Deploying Modern Desktop Applicati\", \"ons\\n\\nWorks for the entire App Catalog\\n\\nOne of the coolest things about MSIX is that it works for the\", \" entire application catalog, Windows Forms, WPF, MFC/ATL, Delphi, even if you want to do xCopy deplo\", \"yment, ClickOnce, or going to the Store, you can use the same MSIX package.\\n\\nTools\\n\\nWindows Applicat\", \"ion Packaging Project\\n\\nYou can use the Windows Application Packaging Project project in Visual Studi\", \"o to generate a package for your desktop app. Then, you can publish that package to the Microsoft St\", \"ore or sideload it onto one or more PCs.\\n\\nMSIX Packaging Tool\\n\\nThe MSIX Packaging Tool enables you t\", \"o repackage your existing Win32 applications to the MSIX format. It offers both an interactive UI an\", \"d a command line for conversions and gives you the ability to convert an application without having \", \"the source code.\\n\\n61\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\\n\\nPackage Support Framework\\n\\n\", \"The Package Support Framework is an open-source kit that helps you apply fixes to your existing Win3\", \"2 application when you don\\u2019t have access to the source code, so that it can run in an MSIX container\", \". The Package Support Framework helps your application follow the best practices of the modern runti\", \"me environment.\\n\\nApp Installer\\n\\nApp Installer allows Windows 10 and Windows 11 apps to be installed \", \"by double-clicking the app package. This means that users don\\u2019t need to use PowerShell or other deve\", \"loper tools to deploy Windows 10/Windows 11 apps. The App Installer can also install an app from the\", \" web, optional packages, and related sets.\\n\\nHow to create an MSIX package from an existing Win32 des\", \"ktop application\\n\\nLet\\u2019s go through the process to create an MSIX package from an existing Win32 appl\", \"ication. In this example, we\\u2019ll use a Windows Forms app.\\n\\n62\\n\\nCHAPTER 6 | Deploying Modern Desktop A\", \"pplications\\n\\nTo start, add a new project to your solution, select the Windows Application Packaging \", \"Project, and give it a name.\\n\\nYou\\u2019ll see the structure of the packaging project and note a special f\", \"older called Applications. Inside this folder, you can specify which applications you want to includ\", \"e in the package. It can be more than one.\\n\\n63\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\\n\\nR\", \"ight-click on the Applications folder and select the Windows Forms project you want to package from \", \"the Visual Studio solution.\\n\\n64\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\\n\\nAt this point, y\", \"ou can compile and generate the package but let\\u2019s examine a couple of things. To have a better user \", \"experience, Visual Studio can autogenerate all the visual assets a modern application needs to handl\", \"e icons and tile assets for the tile bar and start menu. Open the Package.appxmanifest file to acces\", \"s the Manifest Designer. You can then generate all the visual assets from a given image present on y\", \"our project just by clicking Create.\\n\\nIf you open the code for the Package.appxmanifest file, you ca\", \"n see a couple of interesting things.\\n\\nRight under <Package>, there\\u2019s an <Identity> node. This is wh\", \"ere your packaged application is going to get its identity, which will be managed by the OS.\\n\\n65\\n\\nCH\", \"APTER 6 | Deploying Modern Desktop Applications\\n\\nIn the <Capabilities> node, you can find all the re\", \"quirements the application needs, paying special attention to the <rescap:Capability Name=\\\"runFullTr\", \"ust\\\" \\\\>, which tells the OS to run the app in full trust mode since it\\u2019s a Win32 application.\\n\\n66\\n\\nC\", \"HAPTER 6 | Deploying Modern Desktop Applications\\n\\nSet the packaging project as the startup project f\", \"or the solution and select Run. This is going to:\\n\\n\\n\\nCompile the Windows Forms application.\\n\\n\\n\\nCreat\", \"e an MSIX package out of the build results.\\n\\n\\n\\nDeploy the packages.\\n\\n\\n\\nInstall it locally on the dev\", \"elopment machine.\\n\\n\\n\\nLaunch the app.\\n\\n67\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\\n\\nWith th\", \"is, you have the clean install and uninstall experience that MSIX provides fully integrated into Win\", \"dows 10/Windows 11.\\n\\nThe final stage is about how you deploy the MSIX package to another machine.\\n\\nR\", \"ight-click on the packaging project, select the Store menu, and then select the Create App Packages \", \"option.\\n\\nThen, you can choose between creating a package to upload to the store or creating packages\", \" for sideloading. In most modernization scenarios, you\\u2019ll choose I want to create packages for sidel\", \"oading.\\n\\n68\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\\n\\nThere you can select the different a\", \"rchitectures you want to target as you can include as many as you want into the same MSIX package.\\n\\n\", \"The final step is to declare where you want to deploy the final installation assets.\\n\\n69\\n\\nCHAPTER 6 \", \"| Deploying Modern Desktop Applications\\n\\nYou can choose to use a web server or a shared UNC path on \", \"your enterprise file servers. Pay attention to the settings to specify how you want to update your a\", \"pplication. We\\u2019ll cover application updates in the next section.\\n\\nFor a detailed step-by-step guide,\", \" see Package a desktop app from source code using Visual Studio.\\n\\nAuto Updates in MSIX\\n\\nThe Windows \", \"Store has a great updating mechanism using Windows Update. In most enterprise scenarios, you don\\u2019t u\", \"se the Store to distribute your desktop apps. So, you need a similar way to configure updates for yo\", \"ur application and pull them to your users.\\n\\nUsing a combination of Windows 10/Windows 11 features a\", \"nd MSIX packages, you can provide a great updating experience for your users. In fact, the user does\", \"n\\u2019t need to be technical at all but still benefits from a seamless application update experience.\\n\\nY\", \"ou can configure your updates to interact with the user in two different ways:\\n\\n70\\n\\nCHAPTER 6 | Depl\", \"oying Modern Desktop Applications\\n\\n\\n\\nUser prompted updates: The OS shows some autogenerated nice UI \", \"to notify the user about the application it\\u2019s about to install. It builds this UI based on the prope\", \"rties you specify on your installation files.\\n\\n\\n\\nSilent updates in the background. With this option,\", \" your users don\\u2019t need to be aware of the updates.\\n\\nYou can also configure when you want to perform \", \"updates: either when the application launches or on a regular basis. Thanks to the side-loading feat\", \"ures, you can even get these updates while the application is running.\\n\\nWhen you use this type of de\", \"ployment, a special file is created called .appinstaller. This simple file contains the following se\", \"ctions:\\n\\n\\n\\nThe location of the .appinstaller file\\n\\n\\n\\nThe application\\u2019s main MSIX package properties\\n\", \"\\n\\n\\nThe update behavior\\n\\nIn combination with this file, Microsoft has designed a special URL protocol\", \" to launch the installation process from a link:\\n\\n<a href=\\\"ms-appinstaller:?source=http://mywebservi\", \"ce.azureedge.net/MyApp.msix\\\">Install app package </a>\\n\\nThis protocol works on all browsers and launc\", \"hes the installation process with a great user experience on Windows 10/Windows 11. Since the OS man\", \"ages the installation process, it\\u2019s aware of the location this application was installed from and tr\", \"acks all the files affected by the process.\\n\\nMSIX creates a user interface for installation automati\", \"cally showing some properties of the package. This allows for a common installation experience for e\", \"very app.\\n\\n71\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\\n\\nOnce you\\u2019ve generated the new MSIX\", \" package and moved it to the deployment server, you just have to edit the .appinstaller file to refl\", \"ect these changes: mainly the version and the path to the new MSIX file. The next time the user laun\", \"ches the application, the system will detect the change and download the files for the new version i\", \"n the background. When the download is finished, installation will execute transparently for your us\", \"er on new application launch.\\n\\n72\\n\\nCHAPTER 6 | Deploying Modern Desktop Applications\"]"