"[\"<!-- image -->\\n\\n## Modernizing Desktop Apps on Windows with NET 7\\n\\n<!-- image -->\\n\\nMiguel Angel Cast\", \"ej\\u00f3n Dominguez Olia Gavrysh\\n\\n## EDITION v1.0.3 -Updated to .NET 7\\n\\nRefer to the changelog for the bo\", \"ok updates and community contributions.\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Visua\", \"l Studio product teams\\n\\nA division of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington \", \"98052-6399\\n\\nCopyright \\u00a9 2022 by Microsoft Corporation\\n\\nAll rights reserved. No part of the contents \", \"of this book may be reproduced or transmitted in any form or by any means without the written permis\", \"sion of the publisher.\\n\\nThis book is provided \\\"as-is\\\" and expresses the author's views and opinions.\", \" The views, opinions, and information expressed in this book, including URL and other Internet websi\", \"te references, may change without notice.\\n\\nSome examples depicted herein are provided for illustrati\", \"on only and are fictitious. No real association or connection is intended or should be inferred.\\n\\nMi\", \"crosoft and the trademarks listed at https://www.microsoft.com on the \\\"Trademarks\\\" webpage are trade\", \"marks of the Microsoft group of companies.\\n\\nMac and macOS are trademarks of Apple Inc.\\n\\nAll other ma\", \"rks and logos are property of their respective owners.\\n\\nCo -Authors:\\n\\nOlia Gavrysh, Program Manager,\", \" .NET team, Microsoft\\n\\nMiguel Angel Castej\\u00f3n Dominguez , Innovation Architect, Kabel\\n\\nParticipants a\", \"nd reviewers:\\n\\nMaira Wenzel, Senior Program Manager, .NET team, Microsoft\\n\\nAndy De Gorge, Senior Con\", \"tent Developer, .NET docs team, Microsoft\\n\\nMiguel Ramos, Senior Program Manager, Windows Developer P\", \"latform team, Microsoft\\n\\nAdam Braden, Principal Program Manager, Windows Developer Platform team, Mi\", \"crosoft\\n\\nRicardo Minguez Pablos, Senior Program Manager, Azure IoT team, Microsoft\\n\\nNish Anil, Senio\", \"r Program Manager, .NET team, Microsoft\\n\\nBeth Massi, Senior Product Marketing Manager, Microsoft\\n\\nSc\", \"ott Hunter, Partner Director Program Manager, .NET team, Microsoft\\n\\nMarta Fuentes Lara, Kabel\\n\\n<!-- \", \"image -->\\n\\nRa\\u00fal Fern\\u00e1ndez de C\\u00f3rdoba, Kabel\\n\\nAntonio Manuel Fern\\u00e1ndez Cantos, Kabel\\n\\n## Introduction\", \"\\n\\nThis book is about strategies you can adopt to move your existing desktop applications through the\", \" path of modernization and incorporate the latest runtime, language, and platform features. You'll d\", \"iscover that there's no unique recipe as each application is different, and so are your requirements\", \" and preferences. The good news is that there are common approaches you can apply to add new feature\", \"s and capabilities to your applications. Some of them won't even require major modifications of your\", \" code. In this book, we'll reveal how all those features work behind the scenes and explain the mech\", \"anics of their implementations. Moreover, you'll find some common scenarios for modernizing existing\", \" desktop applications shown in detail so you can find inspiration for evolving your projects.\\n\\nMicro\", \"soft's approach to modernizing existing applications is to give you the flexibility to create your o\", \"wn customized path. All the modernization strategies described in this book are mostly independent. \", \"You can choose ones that are relevant for your application and skip others that aren't important for\", \" you. In other words, you can mix and match the strategies to best address your application needs.\\n\\n\", \"## Who should use the book\\n\\nThis book for developers and solution architects who want to modernize e\", \"xisting Windows Forms and WPF desktop applications to leverage the benefits of .NET and Windows 10.\\n\", \"\\nYou might also find this book useful if you're a technical decision maker, such as an enterprise ar\", \"chitect or a development lead or director who wants an overview of the benefits of updating existing\", \" desktop applications.\\n\\n## How to use the book\\n\\nThis book addresses the \\\"why\\\"\\u2014why you might want to \", \"modernize your existing applications, and the specific benefits you get from using NET and MSIX to m\", \"odernize your desktop apps. The content of the book is designed for architects and technical decisio\", \"n makers who want an overview, but who don't need to focus on implementation and technical, step-by-\", \"step details.\\n\\nAlong the different chapters, sample implementation code snippets and screenshots are\", \" provided, with chapter 5 devoted to showcase a complete migration process for sample applications.\\n\", \"\\n## What this book doesn\\u2019t cover\\n\\nThis book covers a specific subset of scenarios that are focused o\", \"n lift-and-shift scenarios, outlining the way to gain the benefits of modernizing without the effort\", \" of rewriting code.\\n\\nThis book isn't about developing modern applications with .NET from scratch or \", \"about getting started with Windows Forms and WPF. It focuses on how you can update existing desktop \", \"applications with the latest technologies for desktop development.\\n\\n<!-- image -->\\n\\n## Samples used \", \"in this book\\n\\nTo highlight the necessary steps to perform a modernization, we'll be using a sample a\", \"pplication called eShopModernizing. This application has two flavors, Windows Forms and WPF, and we'\", \"ll show a step -by-step process on how to perform the modernization on both of them to .NET.\\n\\nAlso, \", \"on the GitHub repository for this book, you'll find the results of the process, which you can consul\", \"t with if you decide to follow the step-by-step tutorial.\\n\\n<!-- image -->\\n\\n## Contents\\n\\n| Why modern\", \" desktop applications  .............................................................................\", \"..........  1                                                                          |\\n|----------\", \"----------------------------------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------|\\n| Introduc\", \"tion  ................................ .............................................................\", \"... ................................................................ ............... 1   |\\n| A story\", \" of one company  ................................................................ ..................\", \".............................................. ................... 1                      |\\n| Your s\", \"tory  ................................ .............................................................\", \"... ................................................................ ............... 1     |\\n| Deskt\", \"op applications nowadays  ................................................................ .........\", \"....................................................... ........ 1                          |\\n| Wind\", \"ows Forms  ................................ ........................................................\", \"........ ................................ ................................... 3              |\\n| WPF\", \" ................................................................ ................................ .\", \"............................................................... ........................... 4 |\\n| UW\", \"P ................................ ................................................................ \", \"................................................................ .......................... 4  |\\n| A\", \" tale of two platforms ................................................................ ............\", \".................................................... .......................... 5               |\\n| \", \"Paths to modernization ................................................................ ............\", \".................................................... ......................... 8                 |\\n|\", \" Modern features  ................................ .................................................\", \"............... ................................ .................................. 8             |\\n\", \"| Deployment ................................ ......................................................\", \".......... ................................................................ ........... 8          |\", \"\\n| Installation ................................ ...................................................\", \"............. ................................................................ .............. 8     \", \"|\\n| What\\u2019s new with .NET for Desktop? ..............................................................\", \"........................  9                                                                         \", \" |\\n| The motivation behind .NET Core  ..............................................................\", \".. ................................................................ ..... 9                         \", \"  |\\n| Introduction to .NET Core  ................................................................ ..\", \".............................................................. .................  11                \", \"   |\\n| .NET 5+ is .NET Core vNext ................................................................ .\", \"............................................................... ...............  11                 \", \"    |\\n| .NET Framework vs. .NET ................................................................ ...\", \"............................................................. ....................  12              \", \"     |\\n| .NET Standard vs. PCL  ................................ ................................ ..\", \".............................................................. .........................  13        \", \"      |\\n| New Desktop features in .NET .............................................................\", \"... ................................................................ .........  14                  \", \"       |\\n| Support for Windows Forms and WPF  ................................ .....................\", \"........................................... ....................  14                                \", \"        |\\n| XAML Islands ................................ ..........................................\", \"...................... ................................................................ ......  14  \", \"         |\\n| Access to all Windows 10 and Windows 11 APIs  ................................ ........\", \"........................ ................................  15                                       \", \"          |\\n| Side - by-side support and self-contained EXEs  ................................ .....\", \"........................................................... ....  15                                \", \"           |\\n| 15                                                                                   \", \"                                                                                                    \", \"            |\\n| Performance ................................ .......................................\", \"......................... ................................................................ .......  \", \"             |\\n| Migrating Modern Desktop applications .............................................\", \"...............................  16                                                                 \", \"              |\\n| Configuration files  ................................ ............................\", \".................................... ................................ ..............................\", \"..  16         |\\n\\n| Configuration on .NET ..........................................................\", \"...... ................................................................ ....................        \", \"          | 17                                                                           |\\n|--------\", \"----------------------------------------------------------------------------------------------------\", \"-----------------------------------------------------------------------------------|----------------\", \"--------------------------------------------------------------|\\n| Migrating configuration files ....\", \"............................................................ .......................................\", \".........................                               | .......  17                               \", \"                                   |\\n| Accessing databases ................................ ........\", \"........................................................ ................................ ..........\", \"..................           | 18                                                                   \", \"        |\\n| ODBC ................................ ..................................................\", \".............. ................................................................ ....................\", \". | 19                                                                           |\\n| OLE DB ........\", \"........................ ................................................................ ..........\", \"...................................................... ..................  | 19                     \", \"                                                      |\\n| ADO.NET ................................ .\", \"............................................................... ....................................\", \"............................ ..............     | 19                                                \", \"                           |\\n| EF Core vs. EF6 ................................ ....................\", \"............................................ .......................................................\", \".........            | ...  19                                                                      \", \"|\\n| Relational databases  ................................................................ .........\", \"....................................................... .......................               | 20  \", \"                                                                         |\\n| Consuming services  ...\", \"............................. ................................................................ .....\", \"........................... .............................          | 20                             \", \"                                              |\\n| Consuming a COM Object  ..........................\", \"...................................... .............................................................\", \"... ................                    | 21                                                        \", \"                   |\\n| More things to consider .....................................................\", \"........... ................................................................ .....................  \", \"             | 21                                                                           |\\n| AppD\", \"omains  ................................ ...........................................................\", \"..... ................................................................                | ......  21  \", \"                                                                 |\\n| Remoting ......................\", \".......... ................................................................ ........................\", \"........................................ .............     | 21                                     \", \"                                      |\\n| Code Access Security (CAS)  ..............................\", \".................................. ................................................................ \", \"                                | .........  22                                                     \", \"           |\\n| Security Transparency  ..............................................................\", \".. ................................................................ ....................            \", \"     | 22                                                                           |\\n| Windows 10 m\", \"igration  ..........................................................................................\", \"...............                                                               | 23                  \", \"                                                         |\\n| WinRT APIs  ...........................\", \"..... ................................................................ .............................\", \"...................................                | ..............  23                             \", \"                              |\\n| Universal Windows Platform (UWP) packages  .......................\", \"......... ................................................................                          \", \"                        | .....  24                                                                 \", \"   |\\n| How to add WinRT APIs to your desktop project ................................ ..............\", \"..................................................                                               | .\", \"...  26                                                                     |\\n| XAML Islands  ......\", \".......................... ................................................................ ........\", \"........................................................              | ..........  34              \", \"                                                 |\\n| The road to XAML Islands ......................\", \".......................................... .........................................................\", \"....... .............                      | 35                                                     \", \"                      |\\n| How it works  ................................ ...........................\", \"..................................... ..............................................................\", \"..              | ......  35                                                                   |\\n| D\", \"o you need XAML Islands  ................................................................ ..........\", \"......................................................                                   | .........\", \".  38                                                               |\\n| The road ahead XAML Islands:\", \" WinUI 3.0  ................................ .......................................................\", \"......... ..............                                      | 38                                  \", \"                                         |\\n| Example of migrating to the latest .NET ...............\", \"..............................................................                                      \", \"                                   | 41                                                             \", \"              |\\n| Migrating from .NET Core or .NET 5  ..............................................\", \".................. ................................ .............................                   \", \"        | 41                                                                           |\\n| Migrating\", \" from .NET Framework  ................................................................ .............\", \"...................................................                              | ....  42         \", \"                                                            |\\n| Migrating with a tool ..............\", \".................................................. .................................................\", \"............... ......................                | 42                                          \", \"                                 |\\n| Migrating by hand ................................ ............\", \".................... ................................................................ ..............\", \".............              | 42                                                                     \", \"      |\\n| Preparation  ................................ ............................................\", \".................... ................................................................               \", \"| .........  43                                                                |\\n| Fix the code and \", \"build ................................................................ .............................\", \"................................... ....................                 | 45                       \", \"                                                    |\\n| Run and test ...............................\", \". ................................................................                                  \", \"                                              | ....................................................\", \"............ .......  46 |\\n\\n| Migrating a Windows Forms application  ...............................\", \". ................................................................ ....................             \", \"                      |   46 |\\n|--------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"-------------------------|------|\\n| Migrating a WPF application ....................................\", \"............................ ................................................................ ......\", \"......                      |   52 |\\n| Deploying Modern Desktop Applications  ......................\", \"....................................................                                                \", \"                               |   55 |\\n| The modern application lifecycle .........................\", \"....................................... ............................................................\", \".... ....                         |   56 |\\n| MSIX: The next generation of deployment ...............\", \"................. ................................................................ .................\", \"                                     |   58 |\\n| Benefits of MSIX  ................................ .\", \"............................................................... ................................ ...\", \"............................            |   59 |\\n| Tools ................................ ..........\", \"...................................................... .............................................\", \"................... ...................... |   61 |\\n| How to create an MSIX package from an existing\", \" Win32 desktop application ................................ ...........                             \", \"                                              |   62 |\\n| Auto Updates in MSIX ......................\", \".......... ................................ ........................................................\", \"........ .........................               |   70 |\\n\\n## Why modern desktop applications\\n\\n## In\", \"troduction\\n\\n## A story of one company\\n\\nBack in the early 2000s, one multinational company started de\", \"veloping a distributed desktop solution to exchange information between different branches of the co\", \"mpany and execute optimized operations on centralized units. They have chosen a brand-new framework \", \"called Windows Forms (also known as WinForms) for their application development. Over the years, the\", \" project evolved into a mature, well-tested, and time-proven application with hundreds of thousands \", \"of lines of code. Time passed and .NET Framework 2.0 is no longer the hot new technology. The develo\", \"pers who are working on this application are facing a dilemma. They'd like to use the latest stack o\", \"f technologies in their development and have their application look and \\\"feel\\\" modern. At the same t\", \"ime, they don't want to throw away the great product they have built over 15 years and rewrite the e\", \"ntire application from scratch.\\n\\n## Your story\\n\\nYou might find yourself in the same boat, where you \", \"have mature Windows Forms or Windows Presentation Foundation (WPF) applications that have proved the\", \"ir reliability over the years. You probably want to keep using these applications for many more year\", \"s. At the same time, since those applications were written some time ago, they might be missing capa\", \"bilities like modern look, performance, integration with new devices and platform features, and so o\", \"n, which gives them a feel of \\\"old tech\\\". There's another problem that might concern you as a develo\", \"per. While working on the older .NET Framework versions and maintaining applications that were writt\", \"en a while ago, you might feel like you aren't learning new technologies and missing out on building\", \" modern technical skills. If that is your story \\u2013 this book is for you!\\n\\n## Desktop applications now\", \"adays\\n\\nBefore the rise of the Internet, desktop applications were the main approach to building soft\", \"ware systems. Developers could choose any programming language, such as COBOL, Fortran, VB6, or C++.\", \"\\n\\nBut whether they developed small tools or complex distributed architectures, they were all desktop\", \" applications.\\n\\nThen, Internet technologies started shocking the development world and winning over \", \"more engineers with advantages like easy deployment and simplified distribution processes. The fact \", \"that once a web application was deployed to production all users got automatic updates made a huge i\", \"mpact on software agility.\\n\\nHowever, the Internet infrastructure, underlying protocols, and standard\", \"s like HTTP and HTML weren't designed for building complex applications. In fact, the major developm\", \"ent effort back then was aimed at just one goal: to give web applications the same capabilities that\", \" desktop applications have, such as fast data input and state management.\\n\\nEven though web and mobil\", \"e applications have grown at an incredible pace, for certain tasks desktop applications still hold t\", \"he number one place in terms of efficiency and performance. That explains why there are millions of \", \"developers who are building their projects with WPF and WinForms and the amount of those application\", \"s is constantly growing.\\n\\nHere are some reasons for choosing desktop applications in your developmen\", \"t:\\n\\n- Desktop apps have better interaction with the user's PC.\\n- The performance of desktop applicat\", \"ions for complex calculations is much higher than the performance of web applications.\\n- Running cus\", \"tom logic on the client-side is possible but much harder with a web application.\\n- Using multithread\", \"ing is easier and more efficient in a desktop application.\\n- The learning curve for designing user i\", \"nterfaces (UIs) isn't steep. And for WinForms, it's intuitive with the drag-and-drop experience of t\", \"he Windows Forms designer.\\n- It's easy to start coding and testing your algorithms without the need \", \"to set up a server infrastructure or to care about connectivity problems, firewalls, and browser com\", \"patibility.\\n- Debugging is powerful as compared to web debugging.\\n- Access to hardware devices, such\", \" as camera, Bluetooth, or card readers, is easy.\\n- Since the technology has been around for a while,\", \" there are many experts and a knowledge base available to develop desktop applications.\\n\\nSo, as you \", \"can see, developing for desktop is great for many reasons. The technology is mature and time -tested\", \", the development cycle is fast, the debugging is powerful and arguably, desktop apps have less comp\", \"lexity and are easier to get started with.\\n\\nMicrosoft offered many UI desktop technologies throughou\", \"t the years from Win32 introduced in 1995 to Universal Windows Platform (UWP) released in 2016.\\n\\n199\", \"5\\n\\nWPF\\n\\nWinForms\\n\\nUWP\\n\\nElectron\\n\\nConsole\\n\\nOther\\n\\n2002\\n\\nTelerik Survey\\n\\n2006\\n\\nWhat Technology would y\", \"ou choose if building for Windows Desktop?\\n\\nWin32\\n\\nWinForms\\n\\n<!-- image -->\\n\\nAccording to a survey p\", \"ublished by Telerik on April 2016, the most popular technologies for building Windows desktop apps a\", \"re Windows Forms, WPF, and UWP.\\n\\n<!-- image -->\\n\\nYou can develop in any of them using C# and Visual \", \"Basic, but let\\u2019s take a closer look.\\n\\n## Windows Forms\\n\\nFirst released in 2002, Windows Forms is a m\", \"anaged framework and is the oldest, most-used desktop technology built on the Windows graphics devic\", \"e interface (GDI) engine. It offers a smooth drag-anddrop experience for developing user interfaces \", \"in Visual Studio. At the same time, Windows Forms relies on the Visual Studio Designer as the main w\", \"ay you develop your UI, so creating visual components from code isn't trivial.\\n\\nThe following list s\", \"ummarizes the main characteristics of Windows Forms:\\n\\n- Mature technology with lots of code samples \", \"and documentation.\\n- Powerful and productive designer. Not so convenient to design UI \\\"from code\\\".\\n-\", \" Easy and intuitive to learn, thanks to the designer's drag-and-drop experience.\\n- Supported on any \", \"Windows version.\\n- Supported on .NET Core 3.0 and later versions.\\n\\n2016\\n\\n2019\\n\\n## WPF\\n\\nBased on the \", \"XAML language specification, WPF favors a clear separation between UI and code. XAML offers capabili\", \"ties like templating, styling, and binding, which is suited for building large applications. Like Wi\", \"ndows Forms, it's a managed framework, but the design is modular and reusable.\\n\\nHere are the main fe\", \"atures of WPF:\\n\\n- Mature technology.\\n- Designer is available, but developers usually prefer to creat\", \"e the design from code using declarative XAML.\\n- The learning curve is steeper than Windows Forms.\\n-\", \" Supported on any Windows version.\\n- Supported on .NET Core 3.0 and later versions.\\n\\n## UWP\\n\\nUWP isn\", \"'t only a presentation framework like WPF and Windows Forms, but it's also a platform itself. This p\", \"latform has:\\n\\n- Its own API set (the Windows Runtime API).\\n- A new deployment system (MSIX)\\n- A mode\", \"rn application lifecycle model (for low battery consumption).\\n- A new Resource Management System (ba\", \"sed on PRI files).\\n\\nThe platform was created to support all kinds of input systems (like ink, touch,\", \" gamepad, mouse, keyboard, gaze, and so on) in all form-factors with performance and low battery con\", \"sumption in mind. For these reasons, the shell of the Windows 10 OS uses parts of the UWP platform.\\n\", \"\\nPRI\\n\\nResw\\n\\nMRT\\n\\nMSIX\\n\\nPackage ID\\n\\nCertificate\\n\\nUWP\\n\\n<!-- image -->\\n\\nUWP contains a presentation fra\", \"mework that is XAML-based, like WPF, but it has some important differences such as:\\n\\n- Applications \", \"are executed in app containers. App containers control what resources a UWP app can access.\\n- Suppor\", \"ted only on Windows 10 and Windows 11.\\n- Apps can be deployed through Microsoft Store for easier dep\", \"loyment.\\n- Designed as part of the Windows Runtime API.\\n- Contains an extensive set of rich built -i\", \"n controls and additional controls are available through the Microsoft UI Library NuGet packages (Wi\", \"nUI library), updated every few months.\\n\\n## A tale of two platforms\\n\\nIn the last 20 years, while UI \", \"desktop technologies were growing and following the path from Windows Forms to UWP, the hardware was\", \" also evolving from heavyweight PC units with small CRT monitors to high-DPI monitors and lightweigh\", \"t tablets and phones with different data input techniques like Touch and Ink. These changes resulted\", \" in creating two different concepts: a Desktop Application and a Modern Application. A Modern Applic\", \"ation is one that considers different device form factors, various input and output methods, and lev\", \"erages modern desktop features while running on a sandboxed execution model. The (traditional) Deskt\", \"op Application, on the other hand, is\\n\\nan application that needs a solid UI with a high density of c\", \"ontrols that is best operated with a mouse and a keyboard.\\n\\nThe following table describes the differ\", \"ences between the two concepts:\\n\\n| Aspect of comparison   | Modern Application                      \", \"                                                                                                    \", \"                  | Desktop Application                                                             \", \"                                                   |\\n|------------------------|---------------------\", \"----------------------------------------------------------------------------------------------------\", \"--------------------------------------|-------------------------------------------------------------\", \"-----------------------------------------------------------------------|\\n| Security               | \", \"Contained execution & Great  Fundamentals. Designed from  the ground up to respect user\\u2019s  privacy, \", \"manage battery life,  and focus to keep the device  safe. | User & Admin level of security.  You hav\", \"e native access to the  registry and hard drive folders.                                   |\\n| Deplo\", \"yment             | Installation and updates are  managed by the platform.                          \", \"                                                                              | MSI, Custom installe\", \"rs &  Updates. Traditionally a source  of headaches for developers  and IT managers.                \", \"           |\\n| Distribution           | Trusted Distribution & Signed  Packages. Distribution is  pe\", \"rformed from a trusted  source and never from the  web.                                           | \", \"Web, SCCM & Custom  distribution. No control over  what is installed, affects the  whole machine.   \", \"                               |\\n| UI                     | Modern UI. Different input  mechanisms, \", \"ink, touch,  gamepad, keyboard, mouse,  etc.                                                        \", \"                  | Windows Forms, WPF, MFC.  Designed for the mouse and  keyboard for a dense UI an\", \"d to  get the most productivity from  the desktop. |\\n| Data                   | Cloud First Data wit\", \"h Insights.  Source of truth in the cloud.  Insights to know what happens  with your app and how it\\u2019\", \"s  performing.                        | Local Data. Traditional desktop  applications usually need s\", \"ome  local data.                                                       |\\n| Design                 | \", \"Designed for reuse. Reuse in  mind between different  platforms, front end, and back  end, running a\", \"ssets in many  places as possible.                        | Designed for Windows  Desktop only      \", \"                                                                                           |\\n\\nAs a p\", \"art of the commitment to provide developers with the best tools to build applications, Microsoft put\", \" forth a great effort to bring these concepts - or we can even say platforms - closer together to em\", \"power developers with the best of both worlds. To do that, Microsoft has performed a bidirectional e\", \"ffort between the two platforms.\\n\\nModern\\n\\nBring both platforms closer together\\n\\nModern\\n\\nModem\\n\\nDeskt\", \"op\\n\\nDesktop\\n\\nDesktop\\n\\n## Modern Application Platform Desktop Application Scenarios Modern Applicatio\", \"n Desktop Applications\\n\\nModern Application\\n\\nPlatform Features\\n\\nPlatform\\n\\n<!-- image -->\\n\\n1. Move Des\", \"ktop Application scenarios into Modern Application platform. The traditional desktop development is \", \"still popular because it addresses certain scenarios well. It makes sense to take these common deskt\", \"op scenarios and bring them into the modern desktop platform to make the platform fully capable.\\n1. \", \"Move Modern Application features into Desktop Applications. For existing desktop apps that need a wa\", \"y to leverage modern capabilities without rewriting from scratch, features from the Modern Applicati\", \"on platform are pushed into the Desktop Application.\\n\\n<!-- image -->\\n\\n<!-- image -->\\n\\nIn this book, \", \"we'll focus on the second part and show how you can modernize your existing desktop applications.\\n\\n#\", \"# Paths to modernization\\n\\nThe structure of this guide reflects three different axes to accomplish mo\", \"dernization: Modern Features, Deployment, and Installation.\\n\\n## Modern features\\n\\nSay you have a work\", \"ing Windows Forms application that a sales representative of your company uses to fill in a customer\", \" order. A new requirement comes in to enable the customer to sign the order using a tablet pen. Inki\", \"ng is native in today's operating systems and technologies, but it wasn't available when the app was\", \" developed.\\n\\nThis path will show you how you can leverage modern desktop features into your existing\", \" desktop development.\\n\\n## Deployment\\n\\nModern development cycles have stressed the importance of prov\", \"iding agility with regard to how new versions of applications are deployed to individual users. Sinc\", \"e Windows Forms and WPF applications are based on a particular version of the .NET Framework that mu\", \"st be present on the machine, they can't take advantage of new .NET Framework version features witho\", \"ut the intervention of the IT people with the risk of having side effects for other apps running on \", \"the same machine. It has limited the innovation pace for developers forcing them to stay on outdated\", \" versions of the .NET Framework.\\n\\nSince the launch of .NET Core 3.0, you can leverage a new approach\", \" of deploying multiple versions of .NET side by side and specifying which version of .NET each appli\", \"cation should target. This way, you can use the newest features in one application while being confi\", \"dent you aren't going to break any other applications.\\n\\n## Installation\\n\\nDesktop applications always\", \" rely on some sort of installation process before the user can start using them. This fact brought i\", \"nto the game a set of technologies, from MSI and ClickOnce to custom installers or even XCOPY deploy\", \"ment. Any of these methods deals with delicate problems because applications need a way to access sh\", \"ared resources on the machine. Sometimes installation needs to access the Registry to insert or upda\", \"te new Key Values, sometimes to update shared DLLs referenced by the main application. This behavior\", \" causes a continuous headache for users, creating this perception that once you install some applica\", \"tion, your computer will never be the same, even if you uninstall it afterwards.\\n\\nIn this book, we'l\", \"l introduce a new way of installing applications with MSIX that solves the problem described earlier\", \". You'll learn how you can easily set up packaging, installation, and updates for your application.\\n\", \"\\n## What's new with .NET for Desktop?\\n\\nDesktop applications such as Windows Forms and WPF can be bui\", \"lt using various .NET implementations, for example, .NET Framework or .NET 7. In this chapter, we'll\", \" talk about the history of each implementation, explain the differences, and show what new features \", \"await desktop developers in newer implementations.\\n\\nIf you've been developing Windows Forms or WPF a\", \"pplications for a long time, you're familiar with .NET Framework. Later, .NET Core (specifically its\", \" 3.0 version) started supporting desktop applications. .NET Core was rebranded to .NET when .NET 5 w\", \"as released. Just as there are different versions of .NET Framework, for example, 4.6, 4.7, and 4.8,\", \" there are also different versions of .NET Core: .NET Core 3.0, .NET 5, .NET 6, .NET 7, and so on.\\n\\n\", \"Let\\u2019s look into the history of each implementation to understand the differences and benefits of eac\", \"h.\\n\\n## The motivation behind .NET Core\\n\\nSince its launch in 2002, .NET Framework has evolved to supp\", \"ort many technologies, like Windows Forms, ASP.NET, Entity Framework, Windows Store, and many others\", \". All of them are different in nature. Therefore, Microsoft approached this evolution by taking part\", \"s of .NET Framework and creating a different application stack for each technology. That way, develo\", \"pment capabilities could be customized for the needs of the specific stack, which maximized the pote\", \"ntial of every platform. That led to fragmentation on the versions of .NET Framework maintained by d\", \"ifferent independent teams. All of these stacks have a common structure, containing an app model, a \", \"framework, and a runtime, but they differ in the implementation of each of the parts.\\n\\nIf you're tar\", \"geting only one of these platforms, you can use this model. However, in many cases you might need mo\", \"re than one target platform in the same solution. For example, your application may have a desktop a\", \"dmin part, a customer-facing web site that shares the back-end logic running on a server, and even a\", \" mobile client. In this case, you need a unified coding experience that can span all of these .NET v\", \"erticals.\\n\\nBy the time Windows 8 was released, the concept of Portable Class Libraries (PCLs) was bo\", \"rn. Originally, .NET Framework was designed around the assumption that it would always be deployed a\", \"s a single unit, so factoring wasn't a concern. To face the problem of code sharing between vertical\", \"s, the driving force was on how to refactor the framework. The idea of contracts is to provide a wel\", \"l-factored\\n\\nVersion f.1\\n\\nsval Studio 2003\\n\\nVersion 1.D\\n\\nVesool Studio NET\\n\\nVersion 3.0\\n\\nRelease hist\", \"ory of .Net Framework\\n\\nVersion 4.0\\n\\nVoual Studio 2010\\n\\nVersion 451\\n\\nVitual Studio 2013\\n\\nversion af\\n\\n\", \"Nal Studo 2019\\n\\nVersion 4.7\\n\\n(mun Studo 2017)\\n\\nNET Core 20\\n\\nVersion 43\\n\\nVisual Seudo 2019\\n\\nNET Core \", \"3.0\\n\\nAPI surface area. Contracts are simply assemblies that you compile against and are designed wit\", \"h proper factoring in mind taking care of the dependencies between them. Version 472\\n\\nsusi Studio 20\", \"05\\n\\nVisual Studio 2012\\n\\nNET Core 1.0\\n\\nNET Core 218 22\\n\\nThis led to reasoning about the API differenc\", \"es between verticals at the assembly level, as opposed to at the individual API level like previousl\", \"y. This aspect enabled a class library experience that can target multiple verticals, also known as \", \"portable class libraries.\\n\\n<!-- image -->\\n\\nWith PCL, the experience of development is unified across\", \" verticals based on the API shape. And the most pressing need to create libraries running on differe\", \"nt verticals is also addressed. But there's a great challenge: APIs are only portable when the imple\", \"mentation is moved forward across all the verticals.\\n\\nA better approach is to unify the implementati\", \"ons across verticals by providing a well-factored implementation instead of a well-factored view. It\", \"'s a lot simpler to ask each team that owns a specific component to think about how their APIs work \", \"across all verticals than trying to retroactively provide a consistent API stack on top. This is whe\", \"re .NET Standard comes in.\\n\\nAnother large challenge has to do with how .NET Framework is deployed. .\", \"NET Framework is a machine -wide framework. Any changes made to it affect all applications that take\", \" a dependency on it. Although this deployment model has many advantages, such as reducing disk space\", \" and centralized access to services, it presents some pitfalls.\\n\\nTo start with, it's difficult for a\", \"pplication developers to take a dependency on a recently released framework. They either have to tak\", \"e a dependency on the latest OS or provide an application installer that installs .NET Framework alo\", \"ng with the application. If you're a web developer, you might not even have this option as the IT de\", \"partment establishes the server supported version.\\n\\nEven if you're willing to go through the trouble\", \" of providing an installer to chain in .NET Framework setup, you may find that upgrading .NET Framew\", \"ork can break other applications.\\n\\nDespite the efforts to provide backward compatible versions of th\", \"e framework, there are compatible changes that can break applications. For example, adding an interf\", \"ace to an existing type can change how this type is serialized and cause breaking problems depending\", \" on the existing code. Because the .NET Framework installed base is huge, fighting against these bre\", \"aking scenarios slows down the pace of innovations inside .NET Framework.\\n\\nTo solve all these issues\", \", Microsoft developed .NET Core as the evolution of the .NET development platform.\\n\\n## Introduction \", \"to .NET Core\\n\\n.NET Core, which is now referred to as just \\\".NET\\\", is the evolution of Microsoft's .N\", \"ET technology into a modular, cross-platform, open source, and cloud-ready platform. It runs on Wind\", \"ows, macOS, and Linux, and some ARM-based architectures like Android and IoT.\\n\\nThe purpose of .NET C\", \"ore is to provide a unified platform for all types of applications, which includes Windows, cross-pl\", \"atform, and mobile applications. .NET Standard enabled this by providing shared base APIs, which eve\", \"ry application model needs, and excluding any application model-specific API.\\n\\nThis framework gives \", \"applications many benefits in terms of efficiency and performance, simplifying the packaging and dep\", \"loyment in the different supported platforms.\\n\\nThe benefits of .NET Core come from these three chara\", \"cteristics:\\n\\n- Cross -platform: It allows application execution on different platforms (Windows, mac\", \"OS, and Linux).\\n- Open source: .NET Core platform is open source and available through GitHub, foste\", \"ring transparency and community contributions.\\n- Supported: Microsoft officially supports .NET Core.\", \"\\n\\nStarting with .NET Core 3.0, besides the existing support for web and cloud, there's also support \", \"for desktop, IoT, and AI domains. The goal for this framework is impressive: to target every type of\", \" .NET development present and future.\\n\\n## . NET 5+ is .NET Core vNext\\n\\n.NET 5 was the next step forw\", \"ard with .NET Core. .NET 5 improved .NET in a few key ways:\\n\\n- Produced a single .NET runtime and fr\", \"amework that can be used everywhere and that has uniform runtime behaviors and developer experiences\", \".\\n- Expanded the capabilities of .NET by taking the best of .NET Core, .NET Framework, Xamarin, and \", \"Mono.\\n- Built that product out of a single code-base that developers (Microsoft and the community) c\", \"an work on and expand together and that improves all scenarios.\\n\\n.NET 5 was a game -changer for .NET\", \". With .NET 5 and later versions, your code and project files look and feel the same no matter which\", \" type of app you're building. You have access to the same runtime, APIs, and language capabilities w\", \"ith each app. This includes new performance improvements that get committed to the runtime almost da\", \"ily. .NET 6 and .NET 7 made further improvements in reliability, performance, new APIs, and language\", \" features. For more details, see What's new in .NET 5 , What's new in .NET 6, and What's new in .NET\", \" 7 .\\n\\n.NET - A unified platform\\n\\nDESKTOP\\n\\n## WEL CLOUD MOBILE GAMING loT Al\\n\\nWPF\\n\\nWindows Forms\\n\\nUMP\", \"\\n\\nRUNTIME COMPONENTS\\n\\nASP NET\\n\\nXamarin\\n\\nUnity\\n\\nARM32\\n\\nMLNET\\n\\nNET for\\n\\nTOOLS\\n\\nVISUAL STUDIO\\n\\n<!-- ima\", \"ge -->\\n\\n## . NET Framework vs. .NET\\n\\nSo now that you understand the relevance of .NET, you might be \", \"wondering what happens with .NET Framework. You could be asking questions like: Do I have to abandon\", \" it? Is it going to disappear? What are my choices to modernize the applications I have on .NET Fram\", \"ework?\\n\\nIn 2019, .NET Framework 4.8 was released. It included three major improvements for desktop a\", \"pplications:\\n\\n- Modern browser and media controls: New controls were added that take advantage of Mi\", \"crosoft Edge and newer media players that support the latest standards.\\n- Access to UWP controls: UW\", \"P introduced controls that take advantage of the latest Windows features and touch displays. With .N\", \"ET Framework 4.8, you don't have to rewrite your applications to use these new features and controls\", \", so you can use these new features in your existing WPF or Windows Forms code.\\n- High-DPI improveme\", \"nts: The resolution of displays increased to 4K and 8K, so, .NET Framework 4.8 added new HDPI improv\", \"ements to make sure existing Windows Forms and WPF applications can look great on these new displays\", \".\\n\\nSince .NET Framework is installed on millions of machines, Microsoft will continue to support it \", \"but won't add new features.\\n\\n.NET (Core) is the open-source, cross-platform, and fast-moving version\", \" of the .NET family. Because of its side -by-side nature, it can take changes without the fear of br\", \"eaking any application. This means that .NET will get new APIs and language features over time that \", \".NET Framework won't. Also, .NET already has features that were impossible for .NET Framework, such \", \"as:\\n\\n- Side -by-side versions of .NET supporting Windows Forms and WPF: This solves the problem of s\", \"ide effects when updating the machine's framework version. Multiple versions of .NET can be installe\", \"d on the same machine and each application specifies which version of\\n\\nUpdate .NET Framework Apps\\n\\nE\", \"xistind\\n\\nHighly\\n\\nApp compatible\\n\\nupdates\\n\\nModernize Desktop Apps with NET Core 3\\n\\nNET Core\\n\\nDesktop\\n\", \"\\n3.0 with\\n\\nPacks testall NET\\n\\nper your\\n\\nCore updates needs\\n\\n.NET it should use. Even more, now you c\", \"an develop and run Windows Forms and WPF on top of .NET.\\n\\n- Embed .NET directly into an application:\", \" You can deploy .NET as part of your application package. This enables you to take advantage of the \", \"latest version, features, and APIs without having to wait for a specific version to be installed on \", \"the machine. Highly-compatible.\\n- Take advantage of .NET features: .NET is fast-moving and open-sour\", \"ce. Its side-by-side nature enables fast introduction of new innovative APIs and Base Class Library \", \"(BCL) improvements without the risk of breaking compatibility. Now Windows Forms and WPF application\", \"s can take advantage of the latest .NET features, which also includes fundamental fixes for things l\", \"ike runtime performance and high-DPI support. NET STANDARD\\n\\n.NET Framework will be fully supported a\", \"nd will always be a part of Windows. However, if you want to use the newest language features and AP\", \"Is in the future, you'll need to move your applications to .NET. For brand -new desktop apps, we rec\", \"ommend starting directly on .NET 6 or a later version. It's lightweight and cross-platform, runs sid\", \"e by side, has high performance, and fits perfectly on containers and microservices architectures.\\n\\n\", \"<!-- image -->\\n\\n## .NET Standard vs. PCL\\n\\n.NET Standard is a formal specification of .NET APIs that \", \"are intended to be available on all .NET implementations. The motivation behind .NET Standard was to\", \" establish greater uniformity in the .NET ecosystem. .NET Standard is a specification of .NET APIs t\", \"hat make up a uniform set of contracts to compile your code against. These contracts are implemented\", \" in each .NET flavor, thus enabling portability across different .NET implementations.\\n\\n.NET Standar\", \"d enables the following key scenarios:\\n\\n- Defines uniform set of base class libraries APIs for all .\", \"NET implementations to implement, independent of the workload.\\n- Enables developers to produce porta\", \"ble libraries that are usable across .NET implementations, using this same set of APIs.\\n\\n.NET Standa\", \"rd is the evolution of PCLs and the following list shows the fundamental differences between .NET St\", \"andard and PCLs:\\n\\n- .NET Standard is a set of curated APIs, picked by Microsoft. PCLs aren't.\\n- The \", \"APIs that a PCL contains are dependent on the platforms that you choose to target when you create it\", \". This makes a PCL only sharable for the specific targets that you choose.\\n- .NET Standard is platfo\", \"rm-agnostic, so it can run on Windows, macOS, and Linux.\\n- PCLs can also run cross -platform, but th\", \"ey can only target a limited set of platforms.\\n\\n## New Desktop features in .NET\\n\\n## Support for Wind\", \"ows Forms and WPF\\n\\nWindows Forms and WPF are part of .NET Core since version 3.0. Both presentation \", \"frameworks are for Windows only, so they aren't cross-platform. You can think of WPF as a rich layer\", \" over DirectX and Windows Forms as a thinner layer over GDI+. WPF and Windows Forms do a great job o\", \"f exposing and exercising much of the desktop application functionality in Windows. So Windows Forms\", \" and WPF are available for .NET Core and .NET Framework. Target your new desktop applications to .NE\", \"T 6 or later, and migrate your existing apps from .NET Framework to .NET 6 or later.\\n\\nA new version \", \"of .NET Standard, version 2.1, was released at the same time as .NET Core 3.0. To see which .NET imp\", \"lementations support which .NET Standard versions, see Which .NET Standard version to target .\\n\\nThe \", \".NET (Core) implementations for both Windows Forms and WPF are open source.\\n\\n## XAML Islands\\n\\nXAML I\", \"slands is a set of components for developers to use Windows 10 controls (UWP XAML controls) in their\", \" WPF, Windows Forms, and native Win32 apps (like MFC). You can have your \\\"islands\\\" of UWP XAML contr\", \"ols wherever you want inside your Win32 apps.\\n\\nThese XAML Islands are possible because Windows 10, v\", \"ersion 1903 introduced a set of APIs that allows hosting UWP XAML content in Win32 windows using win\", \"dows handlers (HWnds). Only apps running on Windows 10 1903 and later can use XAML Islands.\\n\\nTo make\", \" it easier to create XAML Islands for Windows Forms and WPF developers, the Windows Community Toolki\", \"t introduces a set of .NET wrappers in several NuGet packages. Those wrappers are the wrapped and ho\", \"sting controls:\\n\\n- The WebView , WebViewCompatible , InkCanvas , MediaPlayerElement, and MapControl \", \"wrapped controls wrap some UWP XAML controls into Windows Forms or WPF controls, hiding UWP concepts\", \" for those developers.\\n- The WindowsXamlHost control for Windows Forms and WPF allows other not -wra\", \"pped UWP XAML controls and custom controls to be loaded into a XAML Island.\\n\\n## Access to all Window\", \"s 10 and Windows 11 APIs\\n\\nWindows 10 and Windows 11 have a large number of APIs available for develo\", \"pers to work with. These APIs give access to a wide variety of functionality like authentication, bl\", \"uetooth, appointments, and contacts. Now these APIs are exposed through .NET and give Windows develo\", \"pers the chance to create powerful desktops apps using the capabilities present on Windows 10 and Wi\", \"ndows 11.\\n\\n## Side -by-side support and self-contained EXEs\\n\\nThe .NET deployment model is one of the\", \" biggest benefits that Windows desktop developers will experience with .NET. The ability to globally\", \" install .NET provides much of the same central installation and servicing benefits of .NET Framewor\", \"k, while not requiring in-place updates.\\n\\nWhen a new .NET version is released, you can update each a\", \"pp on a machine as needed without any concern of affecting other applications. New .NET versions are\", \" installed in their own directories and exist \\\"side -by-side\\\" with each other.\\n\\nIf you need to deplo\", \"y with isolation, you can deploy .NET with your application. .NET will bundle your app with the .NET\", \" runtime as a single executable. The modular architecture used by .NET makes these flexible deployme\", \"nt options possible.\\n\\n## Performance\\n\\nSince its start, targeting the web and cloud workloads, .NET h\", \"as had performance plugged into its DNA. Server -side code must be performant enough to fulfill high\", \"-concurrency scenarios and .NET 7 scores today as the best performance web platform in the market.\\n\\n\", \"Old Windows Forms code has been refactored for .NET, which reduced memory allocations for drawing Fo\", \"rms and Controls. By simply upgrading from .NET Framework to .NET or later, your applications become\", \" much faster. You can take advantage of these performance improvements when you use .NET to build yo\", \"ur next generation of desktop applications.\\n\\n## Migrating Modern Desktop applications\\n\\nIn this chapt\", \"er, we're exploring the most common issues and challenges you can face when migrating an existing ap\", \"plication from .NET Framework to .NET.\\n\\nIf you just want to update your application to the latest .N\", \"ET version using a tool and not get into the details of what's happening behind the scenes, feel fre\", \"e to skip this chapter and find step-by-step instructions in the Example of migrating to .NET chapte\", \"r.\\n\\nA complex desktop application doesn't work in isolation and needs some kind of interaction with \", \"subsystems that may reside on the local machine or on a remote server. It will probably need some ki\", \"nd of database to connect with as a persistence store either locally or remotely. With the rise of I\", \"nternet and service -oriented architectures, it's common to have your application connected to some \", \"sort of service residing on a remote server or in the cloud. You may need to access the machine file\", \" system to implement some functionality. Alternatively, maybe you're using a piece of functionality \", \"that resides inside a COM object outside your application, which is a common scenario if, for exampl\", \"e, you're integrating Office assemblies in your app.\\n\\nBesides, there are differences in the API surf\", \"ace that is exposed by .NET Framework and .NET, and some features that are available on .NET Framewo\", \"rk aren't available on .NET. It's important for you to know and take them into account when planning\", \" a migration.\\n\\n## Configuration files\\n\\nConfiguration files offer the possibility to store sets of pr\", \"operties that are read at run time and can affect the behavior of your app, such as where to locate \", \"a database or how many times to execute a loop. The beauty of this technique is that you can modify \", \"some aspects of the application without the need to recode and recompile. This comes in handy when, \", \"for example, the same app code runs on a development environment with a certain set of configuration\", \" values and in production environment with a different set.\\n\\n## Configuration on .NET Framework\\n\\nIf \", \"you have a working .NET Framework desktop application, chances are you have an app.config file acces\", \"sed through the AppSettingsSection class from the System.Configuration namespace.\\n\\nWithin the .NET F\", \"ramework infrastructure, there's a hierarchy of configuration files that inherit properties from its\", \" parents. You can find a machine.config file that defines many properties and configuration sections\", \" that can be used or overridden in any descendant configuration file.\\n\\n## Configuration on .NET\\n\\nIn \", \"the .NET world, there's no machine.config file. And even though you can continue to use the old fash\", \"ioned System.Configuration namespace, you may consider switching to the modern Microsoft.Extensions.\", \"Configuration, which offers a good number of enhancements.\\n\\nThis configuration API supports the conc\", \"ept of a configuration provider, which defines the data source to be used to load the configuration.\", \" There are different kinds of built-in providers, such as:\\n\\n- In -memory .NET objects\\n- INI files\\n- \", \"JSON files\\n- XML files\\n- Command -line arguments\\n- Environment variables\\n- Encrypted user store\\n\\nOr \", \"you can build your own.\\n\\nThe new configuration API allows a list of name-value pairs that can be gro\", \"uped into a multi-level hierarchy. Any stored value maps to a string, and there's built-in binding s\", \"upport that allows you to deserialize settings into a custom plain old CLR object (POCO).\\n\\nThe Confi\", \"gurationBuilder object lets you add as many configuration providers as you may need for your applica\", \"tion. A precedence rule is used to resolve provider preference. So, the last provider you add in you\", \"r code overrides the others. This is a great feature for managing different environments for executi\", \"on since you can define different configurations for development, testing, and production environmen\", \"ts. And you can manage them in a single function inside your code.\\n\\n## Migrating configuration files\", \"\\n\\nYou can continue to use your existing app.config XML file. However, you could take this opportunit\", \"y to migrate your configuration to benefit from the several enhancements made in .NET.\\n\\nTo migrate f\", \"rom an old-style app.config to a new configuration file, you should choose between an XML format and\", \" a JSON format.\\n\\nIf you choose XML, the conversion is straightforward. Since the content is the same\", \", just save the app.config file with XML as type. Then, change the code that references AppSettings \", \"to use the ConfigurationBuilder class. This change should be easy.\\n\\nIf you want to use a JSON format\", \" and you don't want to migrate by hand, there's a tool called dotnetconfig2json that can convert an \", \"app.config file to a JSON configuration file.\\n\\nYou may come across some issues when using configurat\", \"ion sections that were defined in the machine.config file. For example, consider the following confi\", \"guration:\\n\\n```\\n<configuration> <system.diagnostics> <switches> <add name=\\\"General\\\" value=\\\"4\\\" /> </sw\", \"itches> <trace autoflush=\\\"true\\\" indentsize=\\\"2\\\"> <listeners> <add name=\\\"myListener\\\" type=\\\"System.Diag\", \"nostics.TextWriterTraceListener, System, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c5\", \"61934e089\\\" initializeData=\\\"MyListener.log\\\" traceOutputOptions=\\\"ProcessId, LogicalOperationStack, Tim\", \"estamp, ThreadId, Callstack, DateTime\\\" /> </listeners> </trace> </system.diagnostics> </configuratio\", \"n>\\n```\\n\\nIf you take this configuration to a .NET app, you\\u2019ll get an exception:\\n\\nUnrecognized configu\", \"ration section System.Diagnostics\\n\\nThis exception occurs because that section and the assembly respo\", \"nsible for handling that section was defined in the machine.config file, which now doesn't exist.\\n\\nT\", \"o easily fix the issue, you can copy the section definition from your old machine.config to your new\", \" configuration file:\\n\\n```\\n<configSections> <section name=\\\"system.diagnostics\\\" type=\\\"System.Diagnosti\", \"cs.SystemDiagnosticsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e0\", \"89\\\"/> </configSections>\\n```\\n\\n## Accessing databases\\n\\nAlmost every desktop application needs some kin\", \"d of database. For desktop, it's common to find client -server architectures with a direct connectio\", \"n between the desktop app and the database engine. These databases can be local or remote depending \", \"on the need to share information between different users.\\n\\nFrom the code perspective, there have bee\", \"n many technologies and frameworks to give the developer the possibility to connect, query, and upda\", \"te a database.\\n\\nThe most common examples of database you can find when talking about Windows Desktop\", \" application are Microsoft Access and Microsoft SQL Server. If you have more than 20 years of experi\", \"ence programming for the desktop, names like ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ, and Entity Framew\", \"ork will sound familiar.\\n\\n## ODBC\\n\\nYou can continue to use ODBC on .NET since Microsoft is providing\", \" the System.Data.Odbc library compatible with .NET Standard 2.0.\\n\\n## OLE DB\\n\\nOLE DB has been a great\", \" way to access various data sources in a uniform manner. But it was based on COM, which is a Windows\", \"-only technology, and as such wasn't the best fit for a cross-platform technology such as .NET. It's\", \" also unsupported in SQL Server versions 2014 and later. For those reasons, OLE DB won't be supporte\", \"d by .NET.\\n\\n## ADO.NET\\n\\nYou can still use ADO.NET from your existing desktop code on .NET. You just \", \"need to update some NuGet packages.\\n\\n## EF Core vs. EF6\\n\\nThere are two currently supported versions \", \"of Entity Framework (EF), Entity Framework 6 (EF6) and EF Core.\\n\\nThe latest technology released as p\", \"art of the .NET Framework world is Entity Framework, with 6.4 being the latest version. With the lau\", \"nch of .NET Core, Microsoft also released a new data access stack based on Entity Framework and call\", \"ed Entity Framework Core.\\n\\nYou can use EF 6.4 and EF Core from both .NET Framework and .NET. So, wha\", \"t are the decision drivers to help to decide between the two?\\n\\nEF 6.3 is the first version of EF6 th\", \"at can run on .NET and work cross -platform. In fact, the main goal of this release was to make it e\", \"asier to migrate existing applications that use EF6 to .NET.\\n\\nEF Core was designed to provide a deve\", \"loper experience similar to EF6. Most of the top-level APIs remain the same, so EF Core will feel fa\", \"miliar to developers who have used EF6.\\n\\nAlthough compatible, there are differences on the implement\", \"ation you should check before making a decision. For more information, see Compare EF Core &amp; EF6\", \" .\\n\\nThe recommendation is to use EF Core if:\\n\\n- The app needs the capabilities of .NET.\\n- EF Core su\", \"pports all of the features that the app requires.\\n\\nConsider using EF6 if both of the following condi\", \"tions are true:\\n\\n- The app will run on Windows and .NET Framework 4.0 or later.\\n- EF6 supports all o\", \"f the features that the app requires.\\n\\n## Relational databases\\n\\n## SQL Server\\n\\nSQL Server has been o\", \"ne of the databases of choice if you were developing for the desktop some years ago. With the use of\", \" System.Data.SqlClient in .NET Framework, you could access versions of SQL Server, which encapsulate\", \"s database-specific protocols.\\n\\nIn .NET, you can find a new SqlClient class, fully compatible with t\", \"he one existing in the .NET Framework but located in the Microsoft.Data.SqlClient library. You just \", \"have to add a reference to the Microsoft.Data.SqlClient NuGet package and do some renaming for the n\", \"amespaces and everything should work as expected.\\n\\n## Microsoft Access\\n\\nMicrosoft Access has been us\", \"ed for years when the sophisticated and more scalable SQL Server wasn't needed. You can still connec\", \"t to Microsoft Access using the System.Data.Odbc library.\\n\\n## Consuming services\\n\\nWith the rise of s\", \"ervice -oriented architectures, desktop applications began to evolve from a clientserver model to th\", \"e three -layer approach. In the client-server approach, a direct database connection is established \", \"from the client holding the business logic, usually inside a single EXE file. On the other hand, the\", \" three-layer approach establishes an intermediate service layer implementing business logic and data\", \"base access, allowing for better security, scalability, and reusability. Instead of working directly\", \" with underlying data, the layered approach relies on a set of services implementing contracts and t\", \"yped objects for data transfer.\\n\\nIf you have a desktop application using a WCF service and you want \", \"to migrate it to .NET, there are some things to consider.\\n\\nThe first thing is how to resolve the con\", \"figuration to access the service. Because the configuration is different on .NET, you'll need to mak\", \"e some updates in your configuration file.\\n\\nSecond, you'll need to regenerate the service client wit\", \"h the new tools present on Visual Studio 2019 and Visual Studio 2022. In this step, you must conside\", \"r activating the generation of the synchronous operations to make the client compatible with your ex\", \"isting code.\\n\\nAfter the migration, if you find that there are libraries you need that aren't present\", \" on .NET, you can add a reference to the Microsoft.Windows.Compatibility NuGet package and see if th\", \"e missing functions are there.\\n\\nIf you're using the WebRequest class to perform web service calls, y\", \"ou may find some differences on .NET. The recommendation is to use HttpClient instead.\\n\\n## Consuming\", \" a COM Object\\n\\nCurrently, there's no way to add a reference to a COM object from Visual Studio 2019 \", \"or Visual Studio 2022 to use with .NET. So, you have to manually modify the project file.\\n\\nInsert a \", \"COMReference structure inside the project file like in the following example:\\n\\n```\\n<ItemGroup> <COMR\", \"eference Include=\\\"MSHTML\\\"> <Guid>{3050F1C5-98B5-11CF-BB82-00AA00BDCE0B}\\\\</Guid> <VersionMajor>4</Ver\", \"sionMajor> <VersionMinor>0</VersionMinor> <Lcid>0</Lcid> <WrapperTool>primary</WrapperTool> <Isolate\", \"d>false</Isolated> </COMReference> </ItemGroup>\\n```\\n\\n## More things to consider\\n\\nSeveral technologie\", \"s available to .NET Framework libraries aren't available for .NET Core or .NET 7. If your code relie\", \"s on some of these technologies, consider the alternative approaches outlined in this section.\\n\\nThe \", \"Windows Compatibility Pack provides access to APIs that were previously available only for .NET Fram\", \"ework. It can be used on .NET Core and .NET Standard projects.\\n\\nFor more information on API compatib\", \"ility, you can find documentation about breaking changes and deprecated/legacy APIs at https://learn\", \".microsoft.com/dotnet/core/compatibility/fx-core .\\n\\n## AppDomains\\n\\nApplication domains (AppDomains) \", \"isolate apps from one another. AppDomains require runtime support and are expensive. Creating additi\", \"onal app domains isn't supported. For code isolation, we recommend separate processes or using conta\", \"iners as an alternative. For the dynamic loading of assemblies, we recommend the new AssemblyLoadCon\", \"text class.\\n\\nTo make code migration from .NET Framework easier, .NET exposes some of the AppDomain A\", \"PI surface. Some of the APIs function normally (for example, AppDomain.UnhandledException), some mem\", \"bers do nothing (for example, SetCachePath), and some of them throw PlatformNotSupportedException (f\", \"or example, CreateDomain).\\n\\n## Remoting\\n\\n.NET Remoting was used for cross-AppDomain communication, w\", \"hich is no longer supported. Also, Remoting requires runtime support, which is expensive to maintain\", \". For these reasons, .NET Remoting isn't supported on .NET.\\n\\nFor communication across processes, you\", \" should consider inter-process communication (IPC) mechanisms as an alternative to Remoting, such as\", \" the or the MemoryMappedFile class.\\n\\nAcross machines, use a network-based solution as an alternative\", \". Preferably, use a low-overhead plaintext protocol, such as HTTP. The Kestrel web server, the web s\", \"erver used by ASP.NET Core, is an option here.\\n\\n## Code Access Security (CAS)\\n\\nSandboxing, which rel\", \"ies on the runtime or the framework to constrain which resources a managed application or library us\", \"es or runs, isn't supported on .NET.\\n\\nUse security boundaries that are provided by the operating sys\", \"tem, such as virtualization, containers, or user accounts, for running processes with the minimum se\", \"t of privileges.\\n\\n## Security Transparency\\n\\nSimilar to CAS, Security Transparency separates sandboxe\", \"d code from security critical code in a declarative fashion but is no longer supported as a security\", \" boundary.\\n\\nUse security boundaries that are provided by the operating system, such as virtualizatio\", \"n, containers, or user accounts, for running processes with the least set of privileges.\\n\\n## Windows\", \" 10 migration\\n\\nConsider the following situation: You have a working desktop application that was dev\", \"eloped in the Windows 7 days. It's using WPF technology available at that time and working fine but \", \"it has an outdated UI and behaviors when you run it on Windows 10 or Windows 11. It is like when you\", \" watch a futuristic movie like Matrix and you see Neo using the Nokia 8110 device. The film works gr\", \"eat after 20 years but it would rather benefit from a device modernization.\\n\\nWith the release of Win\", \"dows 10, Microsoft introduced many innovations to support scenarios like tablets and touch devices a\", \"nd to provide the best experience for users for a Microsoft operating system ever. For example, you \", \"can:\\n\\n- Sign in with your face using Windows Hello.\\n- Use a pen to draw or handwrite text that is au\", \"tomatically recognized and digitalized.\\n- Run locally customized AI models built on the cloud using \", \"WinML.\\n\\nAll these features are enabled for Windows developers through Windows Runtime (WinRT) librar\", \"ies. You can take advantage of these features in your existing desktop apps because the libraries ar\", \"e exposed to both the .NET Framework and .NET as well. You can even modernize your UI with the use o\", \"f XAML Islands and improve the visuals and behavior of your apps according to the times.\\n\\nOne import\", \"ant thing to note here is that you don't need to abandon .NET Framework technology to follow this mo\", \"dernization path. You can safely stay on there and have all the benefits of Windows 10 and Windows 1\", \"1 without the pressure to migrate to .NET. So, you get both the power and the flexibility to choose \", \"your modernization path.\\n\\n## WinRT APIs\\n\\nWinRT APIs are object-oriented, well-structured application\", \" programming interfaces (APIs) that give Windows 10 and Windows 11 developers access to everything t\", \"he operating system has to offer. Through WinRT APIs, you can integrate functionalities like Push No\", \"tifications, Device APIs, Microsoft Ink, and WinML, among others on your desktop apps.\\n\\nIn general, \", \"WinRT APIs can be called from a classic desktop app. However, two main areas present an exception to\", \" this rule:\\n\\n- APIs that require a package identity.\\n- APIs that require visualization like XAML or \", \"Composition.\\n\\n<!-- image -->\\n\\n## Universal Windows Platform (UWP) packages\\n\\n## Application Package I\", \"dentity\\n\\nUWP apps have a deployment system where the OS manages the installation and uninstallation \", \"of application. That requires the installation to be declarative, meaning that no user code is execu\", \"ted during install. Instead, everything the app wants to integrate with the system, such as protocol\", \"s, file types, and extensions, is declared in the application manifest. At deployment time, the depl\", \"oyment pipeline configures those integration points. The only way for the OS to manage all this func\", \"tionality and keep track of it is for each 'package' to have an identity, a unique identifier for th\", \"e application.\\n\\nSome WinRT APIs require this package identity to work as expected. However, classic \", \"desktop apps like native C++ or .NET apps, use different deployment systems that don't require a pac\", \"kage identity. If you want to use these WinRT APIs in your desktop application, you need to provide \", \"them a package identity.\\n\\nOne way to proceed is to build an additional packaging project. Inside the\", \" packaging project, you point to the original source code project and specify the Identity informati\", \"on you want to provide. If you install the package and run the installed app, it will automatically \", \"get an identify enabling your code to call all WinRT APIs requiring Identity.\\n\\n```\\n<?xml version=\\\"1.\", \"0\\\" encoding=\\\"utf-8\\\"?> <Package xmlns=\\\"http://schemas.microsoft.com/appx/manifest/foundation/windows1\", \"0\\\" xmlns:uap=\\\"http://schemas.microsoft.com/appx/manifest/uap/windows10\\\"> <Identity Name=\\\"YOUR-APP-GU\", \"ID \\\" Publisher=\\\"CN=YOUR COMPANY\\\" Version=\\\"1.x.x.x\\\" /> </Package>\\n```\\n\\nYou can check which APIs need \", \"a packaged application identity by inspecting if the type that contains the API is marked with the D\", \"ualApiPartition attribute. If it is, you can call if from an unpackaged traditional desktop app. Oth\", \"erwise, you must convert your classic desktop app to a UWP with the help of a packaging project.\\n\\nht\", \"tps://learn.microsoft.com/windows/desktop/apiindex/uwp-apis-callable-from-a-classic-desktop-app\\n\\n## \", \"Benefits of packaging\\n\\nBesides giving you access to these APIs, you get some additional benefits by \", \"creating a Windows App package for your desktop application including:\\n\\n- Streamlined deployment. Ap\", \"ps have a great deployment experience ensuring that users can confidently install an application and\", \" update it. If a user chooses to uninstall the app, it's removed completely with no trace left behin\", \"d preventing the Windows rot problem.\\n- Automatic updates and licensing. Your application can partic\", \"ipate in the Microsoft Store's built -in licensing and automatic update facilities. Automatic update\", \" is a highly reliable and efficient mechanism, because only the changed parts of files are downloade\", \"d.\\n\\n- Increased reach and simplified monetization. Maybe not your case but if you choose to distribu\", \"te your application through the Microsoft Store you reach millions of Windows 10 and Windows 11 user\", \"s.\\n- Add UWP features. You can add UWP features to your app's package at your own pace.\\n\\n## Prepare \", \"for packaging\\n\\nBefore proceeding to package your desktop application, there are some points you have\", \" to address before starting the process. Your application must respect any of the Microsoft Store ru\", \"les and policies and run in the UWP application model. For example, it has to run on the .NET Framew\", \"ork 4.6.2 or later and writes to the HKEY\\\\_CURRENT\\\\_USER registry hive and the AppData folders will \", \"be virtualized to a user -specific app-local location.\\n\\nThe design goal for packaging is to separate\", \" the application state from system state while maintaining compatibility with other apps. Windows 10\", \" and Windows 11 accomplish this goal by placing the application inside a UWP package. It detects and\", \" redirects some changes to the file system and registry at run time to fulfill the promise of a trus\", \"ted and clean install and uninstall behavior of an application provided by packaging.\\n\\nPackages that\", \" you create for your desktop application are desktop-only, full-trust applications that aren't sandb\", \"oxed, although there's lightweight virtualization applied to the app for writes to HKCU and AppData.\", \" This virtualization allows them to interact with other apps the same way classic desktop applicatio\", \"ns do.\\n\\n## Installation\\n\\nApp packages are installed under %ProgramFiles%\\\\WindowsApps\\\\package\\\\_name, \", \"with the executable titled app\\\\_name.exe. Each package folder contains a manifest (named AppxManifes\", \"t.xml) that contains a special XML namespace for packaged apps. Inside that manifest file is an &lt;\", \"EntryPoint&gt; element, which references the full -trust app. When that application is launched, it \", \"doesn't run inside an app container, but instead it runs as the user as it normally would.\\n\\nAfter de\", \"ployment, package files are marked read-only and heavily locked down by the operating system. Window\", \"s prevents apps from launching if these files are tampered with.\\n\\n## File system\\n\\nThe OS supports di\", \"fferent levels of file system operations for packaged desktop applications, depending on the folder \", \"location.\\n\\nWhen trying to access the user's AppData folder, the system creates a private per-user, p\", \"er-app location behind the scenes. This creates the illusion that the packaged application is editin\", \"g the real AppData when it's actually modifying a private copy. By redirecting writes this way, the \", \"system can track all file modifications made by the app. It can then clean all those files when unin\", \"stalling reducing system \\\"rot\\\" and providing a better application removal experience for the user.\\n\\n\", \"## Registry\\n\\nApp packages contain a registry.dat file, which serves as the logical equivalent of HKL\", \"M\\\\Software in the real registry. At run time, this virtual registry merges the contents of this hive\", \" into the native system hive to provide a singular view of both.\\n\\nAll writes are kept during package\", \" upgrade and only deleted when the application is uninstalled.\\n\\n## Uninstallation\\n\\nWhen the user uni\", \"nstalls a package, all files and folders located under C:\\\\Program Files\\\\WindowsApps\\\\package\\\\_name ar\", \"e removed, as well as any redirected writes to AppData or the registry that were captured during the\", \" process.\\n\\nFor details about how a packaged application handles installation, file access, registry,\", \" and uninstallation, see https://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-thes\", \"cenes .\\n\\nYou can get a complete list of things to check on https://learn.microsoft.com/windows/msix/\", \"desktop/desktop-to-uwp-prepare .\\n\\n## How to add WinRT APIs to your desktop project\\n\\nIn this section,\", \" you can find a walkthrough on how to integrate Toast Notifications in an existing WPF application. \", \"Although it's simple from the code perspective, it helps illustrate the whole process. Notifications\", \" are one of the many available WinRT APIs available that you can use in .NET app. In this case, the \", \"API requires a Package Identity. This process is more straightforward if the APIs don't require Pack\", \"age Identity.\\n\\nLet's take an existing WPF sample app that reads files and shows its contents on the \", \"screen. The goal is to display a Toast Notification when the application starts.\\n\\nNotification Class\", \" (Winc https://docs.microsoft.com/en-w//Uwp/apv/w\\n\\n\\u2022E File Loaded: C:\\\\Users\\\\martafuentes\\\\Desktop\\\\Tes\", \"tFile.txt\\n\\nMicrosoft\\n\\nClear \\u2022\\n\\nWrao Content indows ut notifications not/fication\\n\\nWindows Dev Center\", \" UP appr\\n\\nDrop a single file below Ep\\n\\nGet started Design Develop Publch Resources -\\n\\nDoc / Windows \", \"/ UWP. / APt reference / WindowUlNotfications / Notification\\n\\nCall Windows 10 APls:\\n\\nFilter by title\", \"\\n\\nTest content file\\n\\nWindow Ul Notifications\\n\\nAdaptiveNotificationContent\\n\\n&gt; AdaptiveNobficationT\", \"est\\n\\n\\u2022 BadgeNotification\\n\\nBadge Template Type\\n\\n&gt; Badgedpdate Manager\\n\\n\\u00bb BadgeLpdateManagerfortise\", \"r\\n\\n&gt; BadgeUpdater\\n\\n\\u2022 AdaptiveNotificationContent\\n\\n\\u2022 KnownAdaptiveNotificationkints\\n\\n*\\n\\n*\\n\\nDashboa\", \"rd\\n\\nMents.\\n\\nCev (Feedback @ Share ** Theme Sign in\\n\\nIn this article\\n\\n[Definition\\n\\nComtructors\\n\\n1029\\n\", \"\\n1044 IS 1100/2019 F\\n\\nFirst, you should check in the following link whether the Windows 10 or Window\", \"s 11 API that you'll use requires a Package Identity:\\n\\nhttps://learn.microsoft.com/windows/apps/desk\", \"top/modernize/desktop-to-uwp-supported-api\\n\\nOur sample will use the Windows.UI.Notifications.Notific\", \"ation API that requires a packaged identity:\\n\\n<!-- image -->\\n\\nTo access the WinRT API, add a referen\", \"ce to the Microsoft.Windows.SDK.Contracts NuGet package and this package will do the magic behind th\", \"e scenes (see details at https://blogs.windows.com/windowsdeveloper/2019/04/30/calling-windows-10-ap\", \"is-from-a-desktopapplication-just-got-easier/).\\n\\nYou\\u2019re now prepared to start adding some code.\\n\\n<!-\", \"- image -->\\n\\n\\u203a KnownAdaptiveNotificationTextStyles\\n\\n\\u2022 Known Notification\\u00aeindings\\n\\n- Notification\\n\\nNo\", \"tification\\n\\n+ Download PDF\\n\\n\\u2022 Escribe aqui para buscar\\n\\nNotification Class\\n\\nWindows 10 requirements\\n\", \"\\nDevice turniy\\n\\nWindows 10 Anniversary Edition fetroduced v10.0.14393 0)\\n\\nA/s contract\\n\\nWindows. Fou\", \"ndation UniversalApiContractintroduced v3)\\n\\nConstructors\\n\\nX\\n\\nAdd New Project\\n\\n\\u2022 Recent\\n\\n4 Installed\\n\", \"\\n\\u2022 Visual C#\\n\\nGet Started\\n\\nWindows Desktop\\n\\n\\u2022 Web\\n\\n\\u2022 Office/SharePoint\\n\\n.NET Core\\n\\n.NET Standard\\n\\nAn\", \"droid\\n\\nApple TV\\n\\nApple Watch\\n\\nCloud\\n\\nCross-Platform\\n\\nExtensibility iOS Extensions\\n\\niPhone &amp; iPad\", \"\\n\\nTest\\n\\nWCF\\n\\nWorkflow\\n\\n\\u2022 Azure Data Lake\\n\\nSort by: Default\\n\\n\\u2022 # E\\n\\nBlank App (Universal Windows)\\n\\nCl\", \"ass Library (Universal Windows)\\n\\nVisual C#\\n\\nVisual C#\\n\\nSearch (CtrI+ E)\\n\\nType: Visual C#\\n\\nA project \", \"that creates packages containing\\n\\nWindows applications for side-loading or\\n\\nCreate a ShowToastNotifi\", \"cation method that will be called on application startup. It just builds a toast notification from a\", \"n XML pattern:\\n\\n```\\nprivate void ShowNotification(string title , string content , string image) { st\", \"ring xmlString = $@\\\"<toast><visual><binding template = 'ToastGeneric'><text>{title}</text><text>{con\", \"tent}</text><image src=>'{image}'</image></binding></visual></toast>\\\"; XmlDocument toastXml = new Xm\", \"lDocument(); toastXml . LoadXml(xmlString); ToastNotification toast = new ToastNotification(toastXml\", \"); ToastNotificationManager . CreateToastNotifier().Show(toast); } Optional Code Package (Universal \", \"Windows) Unit Test App (Universal Windows) Visual C# Visual C#\\n```\\n\\nAlthough the project builds, the\", \"re are errors because the Notifications API requires a Package Identity and you didn't provide it. A\", \"dding a Windows Packaging Project to the solution will fix the issue:\\n\\nOpen Visual Studio Installer\\n\", \"\\nName:\\n\\nLocation:\\n\\n<!-- image -->\\n\\nSelect the minimum Windows version you want to support and the ve\", \"rsion you're targeting. Not all the WinRT APIs are supported in all Windows 10 and Windows 11 versio\", \"ns. Each Windows 10 or Windows 11 update adds new APIs that are only available from this version; do\", \"wn-level support isn't available.\\n\\n?\\n\\nNew Universal Windows Platform Project\\n\\nSelect the target and \", \"minimum platform versions that your UWP application will support.\\n\\nTarget version:\\n\\nMinimum version:\", \"\\n\\nWhich version should I choose?\\n\\n<!-- image -->\\n\\nNext step is to add the WPF application to the Win\", \"dows Packaging Project by adding a project reference:\\n\\nSolution Explorer\\n\\n-\\n\\nSearch Solution Explore\", \"r (Ctrl+\\\")\\n\\na. Solution 'ShowFileWPFApplication' (2 projects)\\n\\nC*\\n\\nShowFileWpf\\n\\n/ Properties\\n\\n\\u2022-\\u2022 Re\", \"ferences\\n\\nApp.config\\n\\nApp.xaml\\n\\n\\u2022 ShowFileWPFApp.Package\\n\\n\\u2022 Apalicatinna\\n\\nIm\\n\\nReference Manager - Sh\", \"owFileWPFApp.Package\\n\\n4 Projects\\n\\nSolution\\n\\n<!-- image -->\\n\\nX\\n\\nP-\\n\\n<!-- image -->\\n\\nA Windows Packagi\", \"ng Project can package several apps so you should set which one is the Entry Point:\\n\\nDiagnostic lool\", \"s Properties\\n\\n?\\n\\n#\\n\\nSolution Explorer\\n\\nDebug\\n\\nTeam\\n\\nTest Acalyse\\n\\nHelp:\\n\\n0 Debugge performance may b\", \"e ingroved by kading fener symbel Symbols options Lemmert Nevershows\\n\\n5. -\\n\\nApplication\\n\\n\\u2022 Wao Conte\", \"ne\\n\\nSearch Solution Explorer (Ctrl+*) |\\n\\nSmall Tie\\n\\nMedium Tie\\n\\n] Solution 'ShowFileWPApplication' (\", \"2 projects)\\n\\nWide Tee\\n\\nLarge Tie\\n\\nApp icon\\n\\nBadge Loge\\n\\nShowFileWpf\\n\\nProperties\\n\\n\\u2022-\\u2022 References\\n\\n+ A\", \"pp.config\\n\\n\\u2022 Display Settings\\n\\nShort name\\n\\n\\u2022 App.xaml\\n\\n\\u2022 \\u20a9 App.xaml.cs\\n\\n\\u2022 \\u2022 MainWindow.xaml\\n\\n\\\"Shoef1\", \"1mpf-exe\\\"\\n\\n.(Hi432): Loaded Ci1Mindows15ysM0/41MSn/etaostaiMind\\n\\n\\u2022 # ShowFileWPFApp.Package show Ste\", \"ief.exe\\n\\nApplications\\n\\n(41432)1 Loades C/145n00515y5400641450\\n\\nmmedate Window\\n\\n\\u2022 Image\\n\\nEscribe aqui\", \" para buscar\\n\\nPacka\\n\\nP - 5 \\u00d7\\n\\nMaita Fuentes Lana - Mil\\n\\nLa Papeti Laplom\\n\\n9 LangeT escale-150 png\\n\\n<\", \"!-- image -->\\n\\nNext step is to set the WPF Project as the startup Project in the solution configurat\", \"ion. You can press F5 to compile and build and see the results.\\n\\n<!-- image -->\\n\\nLet's generate the \", \"package so you can install your app. Right click on Store &gt; Create App Packages .\\n\\nEl LargeTaesca\", \"le-200 pag roperties\\n\\n\\u2022 0 x\\n\\n1627\\n\\n\\u2022\\n\\nP\\n\\n\\u2022 O\\n\\nDiagnostic Tools Properties\\n\\nDick Land (00-2\\n\\nBuild\\n\\nR\", \"ebuild\\n\\nDeploy\\n\\nClean\\n\\nPower Commands\\n\\nOverview\\n\\nScope to This\\n\\nNew Solution Explorer View\\n\\nShow on \", \"Code Map\\n\\nEdit ShowFileWPFApp.Package.wapproj\\n\\nBuild Dependencies\\n\\nAdd\\n\\nStore\\n\\nSet as StartUp Projec\", \"t\\n\\nDebug\\n\\n* Cut\\n\\nX\\n\\nRemove\\n\\nRename\\n\\nUnload Project\\n\\n\\u2022 Open Folder in File Explorer\\n\\nProperties\\n\\nSolu\", \"tion Explorer\\n\\nSearch Solution Explorer (Ctrl+ )\\n\\na] Solution 'ShowFileWPApplication' (2 projects)\\n\\n\", \"<!-- image -->\\n\\nSelect the sideloading option to deploy the app from your machine:\\n\\n- 4 X\\n\\nDiagnosti\", \"c Tools Properties\\n\\nCreate App Packages\\n\\nCreate Your Packages\\n\\nHow do you want to distribute your ap\", \"plication?\\n\\nI want to create packages for sideloading.\\n\\nEnable automatic updates\\n\\nWhat is sideloadin\", \"g?\\n\\n<!-- image -->\\n\\n?\\n\\nX\\n\\nCreate App Packages\\n\\nSelect and Configure Packages\\n\\nOutput location:\\n\\nC:\\\\U\", \"sers\\\\martafuentes\\\\source\\\\repos\\\\ShowFileWPFApplication\\\\ShowFileWPFApp.Package/AppPackages\\\\\\n\\nVersion:\\n\", \"\\n1 0\\n\\n. 0.0\\n\\nV Automatically increment\\n\\nMore information\\n\\nGenerate app bundle:\\n\\nAlways\\n\\nWhat does an\", \" app bundle mean?\\n\\nSelect the packages to create and the solution configuration mappings:\\n\\nArchitect\", \"ure Solution Configuration\\n\\nNeutral x86\\n\\nx64\\n\\nARM\\n\\n\\u2022 Include full PDB symbol files, if any, to enabl\", \"e crash analytics for the app. Learn More\\n\\n<!-- image -->\\n\\nFinally, create the package by clicking o\", \"n Create .\\n\\n## XAML Islands\\n\\nXAML Islands are a set of components that enable Windows desktop develo\", \"pers to use UWP XAML controls on their existing Win32 applications, including Windows Forms and WPF.\", \"\\n\\n?\\n\\nX\\n\\nWin32\\n\\nUWP\\n\\nXAML\\n\\nMSIX\\n\\nUWP\\n\\nWinRT\\n\\n<!-- image -->\\n\\nYou can image your Win32 app with your s\", \"tandard controls and among them an \\\"island\\\" of UWP UI containing controls from the modern world. The\", \" concept is similar to having an iFrame inside a web page that shows content from a different page.\\n\", \"\\nBesides adding functionality from the Windows 10 and Windows 11 APIs, you can add pieces of UWP XAM\", \"L inside of your app using XAML Islands.\\n\\nWindows 10 1903 update introduced a set of APIs that allow\", \" hosting UWP XAML content in Win32 windows. Only apps running on Windows 10 1903 or later can use XA\", \"ML Islands.\\n\\n## The road to XAML Islands\\n\\nThe road to XAML Islands started in 2012 when Microsoft in\", \"troduced the WinRT APIs as a framework to modernize the Win32 apps (Windows Forms, WPF, and native W\", \"in32 apps). However, the new UI controls inside WinRT were available for new applications but not fo\", \"r existing ones.\\n\\nIn 2015, along with Windows 10, UWP was born. UWP allows you to create apps that w\", \"ork across Windows devices like XBox, Mobile, and Desktop. One year later, Microsoft announced Deskt\", \"op Bridge (formerly known as Project Centennial). Desktop Bridge is a set of tools that allowed deve\", \"lopers to bring their existing Win32 apps to the Microsoft Store. More capabilities were added in 20\", \"17, allowing developers to enhance their Win32 apps leveraging some of the new Windows 10 APIs, like\", \" live tiles and notifications on the action center. But still, no new UI controls.\\n\\nAt Build 2018, M\", \"icrosoft announced a way for developers to use the new Windows 10 XAML controls into their current W\", \"in32 apps, without fully migrating their apps to UWP. It was branded as UWP XAML Islands.\\n\\n## How it\", \" works\\n\\nThe Windows 10 1903 update introduced several XAML hosting APIs. Two of them are WindowsXaml\", \"Manager and DesktopWindowXamlSource.\\n\\nThe WindowsXamlManager class handles the UWP XAML Framework. I\", \"ts InitializeForCurrentThread method loads the UWP XAML Framework inside the current thread of the W\", \"in32 app.\\n\\nThe DesktopWindowXamlSource is the instance of your XAML Island content. It has the Conte\", \"nt property, which you're responsible for instantiating and setting. The DesktopWindowXamlSource ren\", \"ders and gets its input from an HWND. It needs to know to which other HWND it will attach the XAML I\", \"sland's one, and you're responsible for sizing and positioning the parent's HWND.\\n\\nWPF or Windows Fo\", \"rms developers don't usually deal with HWND inside their code, so it may be hard to understand and h\", \"andle HWND pointers and the underlying wiring stuff to communicate Win32 and UWP worlds.\\n\\n## The XAM\", \"L Islands .NET Wrappers\\n\\nThe Windows Community Toolkit has a set the XAML Islands .NET wrappers for \", \"WPF or Windows Forms that make easier to use XAML Islands. These wrappers manage the HWNDs, the focu\", \"s management, among other things. Windows Forms and WPF developers should use these wrappers.\\n\\nThe W\", \"indows Community Toolkit offers two types of controls: Wrapped Controls and Hosting Controls.\\n\\n## Wr\", \"apped Controls\\n\\nThese wrapped controls wrap some UWP controls into Windows Forms or WPF controls, hi\", \"ding UWP concepts for those developers. These controls are:\\n\\n- WebView and WebViewCompatible\\n- InkCa\", \"nvas and InkToolbar\\n- MediaPlayerElement\\n- MapControl\\n\\nAdd the Microsoft.Toolkit.Wpf.UI.Controls pac\", \"kage to your project, include the reference to the namespace, and start using them.\\n\\n```\\n<Window ...\", \" xmlns:uwpControls=\\\"clrnamespace:Microsoft.Toolkit.Wpf.UI.Controls;assembly=Microsoft.Toolkit.Wpf.UI\", \".Controls\\\"> <Grid> <Grid.RowDefinitions> <RowDefinition Height=\\\"Auto\\\"/> <RowDefinition Height= \\\" \\\\*\\\"\", \"/> </Grid.RowDefinitions> <uwpControls:InkToolbar TargetInkCanvas=\\\"{x:Reference Name=inkCanvas}\\\"/> <\", \"uwpControls:InkCanvas Grid.Row=\\\"1\\\" x:Name=\\\"inkCanvas\\\" /> </Grid>\\n```\\n\\n## Hosting controls\\n\\nThe power\", \" of XAML Islands extends to most first-party controls, third-party controls, and custom controls dev\", \"eloped for UWP, which can be integrated into Windows Forms and WPF as \\\"Islands\\\" with fully functiona\", \"l UI. The WindowsXamlHost control for WPF and Windows Forms allows doing this.\\n\\nFor example, to use \", \"the WindowsXamlHost control in WPF, add a reference to the Microsoft.Toolkit.Wpf.UI.XamlHost package\", \" provided by the Windows Community Toolkit.\\n\\nOnce you've placed your WindowsXamlHost into your UI co\", \"de, specify which UWP type you want to load. You can choose to use a wrapped control like a Button o\", \"r a more complex one composed of several different controls, which are a custom UWP control.\\n\\nThe fo\", \"llowing example shows how to add a UWP Button:\\n\\n```\\n<Window ... xmlns:xamlhost=\\\"clr -namespace:Micro\", \"soft.Toolkit.Wpf.UI.XamlHost;assembly=Microsoft.Toolkit.Wpf.UI.XamlHost\\\"> <xamlhost:WindowsXamlHost \", \"x:Name=\\\"myUwpButton\\\" InitialTypeName=\\\"Windows.UI.Xaml.Controls.Button\\\" />\\n```\\n\\nThere's a clear recom\", \"mendation on how to approach this and it's better to have one single and bigger XAML Island containi\", \"ng a custom composite control than to have several islands with one control on each.\\n\\nOne of the cor\", \"e features of XAML is binding and it works between your Win32 code and the island. So, you can bind,\", \" for instance, a Win32 Textbox with a UWP Textbox. One important thing to consider is that these bin\", \"dings are one-way bindings, from UWP to Win32, so if you update the Textbox inside the XAML Island t\", \"he Win32 Textbox will be updated, but not the other way around.\\n\\nTo see a walkthrough about how to u\", \"se XAML Islands, see:\\n\\nhttps://learn.microsoft.com/windows/apps/desktop/modernize/host-standard-cont\", \"rol-with-xamlislands\\n\\n## Adding UWP XAML custom controls\\n\\nA XAML custom control is a control (or use\", \"r control) created by you or by third parties (including WinUI 2.x controls). To host a custom UWP c\", \"ontrol in a Windows Forms or WPF app, you'll need:\\n\\n- To use the WindowsXamlHost UWP control in your\", \" .NET app.\\n- To create a UWP app project that defines a XamlApplication object.\\n\\nYour WPF or Windows\", \" Forms project must have access to an instance of the Microsoft.Toolkit.Win32.UI.XamlHost.XamlApplic\", \"ation class provided by the Windows Community Toolkit. This object acts as a root metadata provider \", \"for loading metadata for custom UWP XAML types in assemblies in the current directory of your applic\", \"ation. The recommended way to do this is to add a Blank App (Universal Windows) project to the same \", \"solution as your WPF or Windows Forms project and revise the default App class in this project.\\n\\nThe\", \" custom UWP XAML control can be included on this UWP app or in an independent UWP Class Library proj\", \"ect that you reference in the same solution as your WPF or Windows Forms project.\\n\\nYou can check a d\", \"etailed step-by-step process description at:\\n\\nhttps://learn.microsoft.com/windows/apps/desktop/moder\", \"nize/host-custom-control-with-xamlislands\\n\\n## The Windows UI Library (WinUI 2)\\n\\nBesides the inbox Wi\", \"ndows 10 controls that comes with the OS, the same UWP XAML team also delivers additional controls i\", \"n the Windows UI Library (WinUI 2). WinUI 2 provides official native Microsoft UI controls and featu\", \"res for Windows UWP apps and these controls can be used inside of XAML Islands.\\n\\nWinUI 2 is open sou\", \"rce and you can find information at https://github.com/microsoft/microsoft-uixaml .\\n\\nThe following a\", \"rticle demonstrates how to host a UWP XAML control from the WinUI 2 library: https://learn.microsoft\", \".com/windows/apps/desktop/modernize/host-custom-control-with-xamlislands\\n\\n## Do you need XAML Island\", \"s\\n\\nXAML Islands are intended for existing Win32 apps that want to improve their user experience by l\", \"everaging new UWP controls and behaviors without a full rewrite of the app. You could already levera\", \"ge Windows 10 and Windows 11 APIs, but up until XAML Islands, only non-UI related APIs.\\n\\nIf you\\u2019re d\", \"eveloping a new Windows App, a UWP App is probably the right approach.\\n\\n## The road ahead XAML Islan\", \"ds: WinUI 3.0\\n\\nSince Windows 8, the Windows UI platform, including the XAML UI framework, visual com\", \"position layer, and input processing has been shipped as an integral part of Windows. This means tha\", \"t to benefit from the latest improvements on UI technologies, you must upgrade to the latest version\", \" of the UI, slowing down the pace of innovation when you develop your apps. To decouple these two ev\", \"olution cycles and foster innovation, Microsoft is actively working on the WinUI project.\\n\\nStarting \", \"with WinUI 2 in 2018, Microsoft started shipping some new XAML UI controls and features as separate \", \"NuGet packages that build on top of the UWP SDK.\\n\\nWin32\\n\\nWinUl 2.0: controls + styles\\n\\nWinUl 3.0: th\", \"e Windows Ul platform\\n\\nMicrosoft.Ul.Xaml.*\\n\\nMicrosoft.Ul.Composition.*\\n\\nMicrosoft.Ul.Xaml.Controls\\n\\n\", \"Microsoft.Ul.Input.*\\n\\n<!-- image -->\\n\\nWin32\\n\\nWinUI 3 is under active development and will greatly ex\", \"pand the scope of WinUI to include the full UI platform, which will be fully decoupled from the UWP \", \"SDK:\\n\\nXAML framework will now be developed on GitHub and shipped out of band as NuGet packages.\\n\\n<!-\", \"- image -->\\n\\nThe existing UWP XAML APIs that ship as part of the OS will no longer receive new featu\", \"re updates. They will still receive security updates and critical fixes according to the Windows 10 \", \"support lifecycle.\\n\\nThe Universal Windows Platform contains more than just the XAML framework (for e\", \"xample, application and security model, media pipeline, Xbox and Windows 10 shell integrations, broa\", \"d device support) and will continue to evolve. All new XAML features will just be developed and ship\", \" as part of WinUI instead.\\n\\n## WinUI 3 in desktop app and WinUI XAML Islands\\n\\nAs you can see, WinUI \", \"3 is the evolution of UWP XAML and it works naturally within the UWP app model and all its requireme\", \"nts (MSIX packaged ID, sandbox, CoreWindow, and so on. To use just WinUI 3 in a Win32 app model, the\", \" WinUI content should be hosted by another UI Framework (Windows Forms, WPF, and so on) using WinUI \", \"XAML Islands. This is the right path if you want to\\n\\nevolve your app and mix technologies. However, \", \"if you want to replace your entire old UI for WinUI, your app shouldn't load UI Frameworks for just \", \"hosting WinUI.\\n\\nWinUI 3 will address this critical feedback adding WinUI in desktop apps. This will \", \"allow that Win32 apps can use WinUI 3 as standalone UI Framework; no need to load Windows Forms or W\", \"PF.\\n\\nWithin this aggregation, WinUI 3 will let developers easily mix and match the right combination\", \" of:\\n\\n- App model: UWP, Win32\\n- Platform: .NET or Native\\n- Language: .NET (C#, Visual Basic), standa\", \"rd C++\\n- Packaging: MSIX, AppX for the Microsoft Store, unpackaged\\n- Interop: use WinUI 3 to extend \", \"existing WPF, WinForms, and MFC apps using WinUI XAML Islands.\\n\\nIf you want to know more details, Mi\", \"crosoft is sharing this roadmap in https://github.com/microsoft/microsoft-ui-xaml/blob/main/docs/roa\", \"dmap.md .\\n\\n## Example of migrating to the latest .NET\\n\\nIn this chapter, we'll show how to migrate yo\", \"ur applications to the latest version of .NET. You can migrate to .NET 7 from .NET Framework, .NET C\", \"ore, or .NET 5. We'll introduce a tool that can do all the work for you in most cases. If your appli\", \"cation has special cases or complicated dependencies, we'll also show how to do the whole migration \", \"process by hand. Additionally, we'll cover the most common issues and challenges you can face when m\", \"igrating an existing application from .NET Framework to .NET.\\n\\n## Migrating from .NET Core or .NET 5\", \"\\n\\nUpdating your applications to target the latest version of .NET is easy if you already are on .NET\", \" Core or .NET 5. If this is the case, then in Visual Studio, simply right-click on your project in S\", \"olution Explorer and choose Properties. Under Application &gt; General &gt; Target framework, choose\", \" .NET 7.0. Save and rebuild your application. You're done! Your app now runs on the latest version o\", \"f .NET. In the future when new versions become available, you can upgrade in the same way.\\n\\neShopWin\", \"Forms * X\\n\\nSearch properties\\n\\n4 Application\\n\\nGeneral\\n\\nWin32 Resources\\n\\nPackaging\\n\\n\\u2022 Global Usings\\n\\n\\u2022\", \" Build\\n\\n\\u2022 Package\\n\\n\\u2022 Code Analysis\\n\\n\\u2022 Debug\\n\\n\\u2022 Resources\\n\\n\\u2022 Settings\\n\\nApplication\\n\\n<!-- image -->\\n\\n#\", \"# Migrating from .NET Framework\\n\\nMigrating from .NET Framework is a more complicated process because\", \" there are more differences between .NET Framework and other platforms that were built on top of .NE\", \"T Core. But the good news is that there's a tool that will do all the work for you in most cases.\\n\\n#\", \"# Migrating with a tool\\n\\nThe Upgrade Assistant is a migration tool. Using it is easy and there are s\", \"tep-by-step instructions available on the .NET website. In this chapter, we'll look at what is happe\", \"ning behind the scenes and how to port your application by hand. When the Upgrade Assistant is unabl\", \"e to migrate your application, you'll learn the underlying mechanics so that you might be able to mi\", \"grate manually.\\n\\n## Migrating by hand\\n\\nThe migration process consists of four sequential steps:\\n\\n1. \", \"Preparation: Understand the dependencies the project has to have an idea of what's ahead. In this st\", \"ep, you take the current project into a state that simplifies the startup point for the migration.\\n2\", \". Migrate Project File: .NET projects use the new SDK-style project format. Create a new project fil\", \"e with this format or update the one you have to use the SDK style.\\n3. Fix code and build: Build the\", \" code in .NET addressing API-level differences between .NET Framework and .NET. If needed, update th\", \"ird-party packages to the ones that support .NET.\\n\\nB \\u2022 0 NuGet Gallery | Castle.V X\\n\\n&lt; &gt;\\n\\n\\u2022 No\", \"t secure https://www.nuget.org/packages/Castle.Windsor/\\n\\nSign in\\n\\n4. Run and test: There might be di\", \"fferences that don't show up until run time. So, don't forget to run the application and test that e\", \"verything works as expected.\\n\\nCastle Windsor is best of breed, mature Inversion of Control container\", \" available for .NET.\\n\\n## Preparation Package Manager\\n\\nPaket CU\\n\\n## Migrate packages.config file\\n\\n\\u00a9 P\", \"roject Site\\n\\n\\u2022 Source repository\\n\\n\\u2022 License Info\\n\\n\\u2022 Contact owners fo Report\\n\\n\\u2022 Download package (41\", \"5.32 KB)\\n\\nIn a .NET Framework application, all references to external packages are declared in the p\", \"ackages.config file. In .NET, there's no longer the need to use the packages.config file. Instead, u\", \"se the PackageReference property inside the project file to specify the NuGet packages for your app.\", \"\\n\\nSystem.Runtime.Loader (&gt; = 4.3.0)\\n\\nSystem.Runtime.Serialization.Formatters (&gt; = 4.3.0)\\n\\n\\u1ea9i 1\", \".842 downloads per day (avg)\\n\\nSo, you need to transition from one format to another. You can do the \", \"update manually, taking the dependencies contained in the packages.config file and migrating them to\", \" the project file with the PackageReference format. Or, you can let Visual Studio do the work for yo\", \"u: right-click on the packages.config file and select the Migrate packages.config to PackageReferenc\", \"e option.\\n\\n## Verify every dependency compatibility in .NET\\n\\nOnce you've migrated the package refere\", \"nces, you must check each reference for compatibility. You can explore the dependencies of each NuGe\", \"t package your application is using on nuget.org. If the package has .NET Standard dependencies, the\", \"n it's going to work on .NET 7 because .NET supports all versions of .NET Standard. The following im\", \"age shows the dependencies for the Castle.Windsor package:\\n\\n<!-- image -->\\n\\nTo check the package com\", \"patibility, you can use the tool https://fuget.org that offers a more detailed information about ver\", \"sions and dependencies.\\n\\nMaybe the project is referencing older package versions that don't support \", \".NET, but you might find newer versions that do support it. So, updating packages to newer versions \", \"is generally a good\\n\\n\\u2022 *\\n\\n- OX\\n\\n* 2 \\u00ae ...\\n\\nrecommendation. However, you should consider that updatin\", \"g the package version can introduce some breaking changes that would force you to update your code.\\n\", \"\\nWhat happens if you don't find a compatible version? What if you just don't want to update the vers\", \"ion of a package because of these breaking changes? Don't worry because it's possible to depend on .\", \"NET Framework packages from a .NET application. Don't forget to test it extensively because it can c\", \"ause run-time errors if the external package calls an API that isn't available on .NET. This is grea\", \"t for when you're using an old package that isn't going to be updated and you can just retarget to w\", \"ork on .NET.\\n\\n## Check for API compatibility\\n\\nSince the API surface in .NET Framework and .NET is si\", \"milar but not identical, you must check which APIs are available on .NET and which aren't. You can u\", \"se the .NET Portability Analyzer tool to surface APIs used that aren't present on .NET. It looks at \", \"the binary level of your app, extracts all the APIs that are called, and then lists which APIs aren'\", \"t available on your target framework (.NET 7 in this case).\\n\\nYou can find more information about thi\", \"s tool at:\\n\\nhttps://learn.microsoft.com/dotnet/standard/analyzers/portability-analyzer\\n\\nAn interesti\", \"ng aspect of this tool is that it only surfaces the differences from your own code and not code from\", \" external packages, which you can't change. Remember you should have updated most of these packages \", \"to make them work with .NET.\\n\\n## Migrate\\n\\n1. Create the new .NET project\\n\\nIn most cases, you'll want\", \" to update your existing project to the new .NET format. However, you can also create a new project \", \"while maintaining the old one. The main drawback from updating the old project is that you lose desi\", \"gner support, which may be important to you and your development team. If you want to keep using the\", \" designer, you must create a new .NET project in parallel with the old one and share assets. If you \", \"need to modify UI elements in the designer, you can switch to the old project to do that. And since \", \"assets are linked, they'll be updated in the .NET project as well.\\n\\nThe SDK -style project for .NET \", \"is a lot simpler than .NET Framework's project format. Apart from the previously mentioned PackageRe\", \"ference entries, you won't need to do much more. The new project format includes files with certain \", \"extensions by default, such as .cs and .xaml files, without the need to explicitly include them in t\", \"he project file.\\n\\n## AssemblyInfo considerations\\n\\nAttributes are autogenerated on .NET projects. If \", \"the project contains an AssemblyInfo.cs file, the definitions will be duplicated, which will cause c\", \"ompilation conflicts. You can delete the older AssemblyInfo.cs file or disable autogeneration by add\", \"ing the following entry to the .NET project file:\\n\\n```\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\"> <PropertyGr\", \"oup>\\n```\\n\\n```\\n<GenerateAssemblyInfo>false</GenerateAssemblyInfo>\\n```\\n\\n| </PropertyGroup>   |\\n|------\", \"--------------|\\n| </Project>         |\\n\\n## Resources\\n\\nEmbedded resources are included automatically \", \"but resources aren't, so you need to migrate the resources to the new project file.\\n\\n## Package refe\", \"rences\\n\\nWith the Migrate packages.config to PackageReference option, you can easily move your extern\", \"al package references to the new format as previously mentioned.\\n\\n## Update package references\\n\\nUpda\", \"te the versions of the packages you\\u2019ve found to be compatible, as shown in the previous section.\\n\\n##\", \" Fix the code and build\\n\\n## Microsoft.Windows.Compatibility\\n\\nIf your application depends on APIs tha\", \"t aren't available on .NET, such as Registry or ACLs, you have to include a reference to the Microso\", \"ft.Windows.Compatibility package to add these Windowsspecific APIs. They work on .NET but aren't inc\", \"luded as they aren't cross-platform.\\n\\nThere\\u2019s a tool called Platform compatibility analyzer\\n\\n(https:\", \"//learn.microsoft.com/dotnet/standard/analyzers/platform-compat-analyzer) that helps you identify AP\", \"Is that aren't compatible with your code.\\n\\n## Use #if directives\\n\\nIf you need different execution pa\", \"ths when targeting .NET Framework and .NET, you should use compilation constants. Add some #if direc\", \"tives to your code to keep the same codebase for both targets.\\n\\n## Technologies not available on .NE\", \"T\\n\\nSome technologies aren\\u2019t available on .NET, such as:\\n\\n- AppDomains\\n- Remoting\\n- Code Access Secur\", \"ity\\n- Windows Workflow\\n\\nThat's why you need to find a replacement for these technologies if you're u\", \"sing them in your application. For more information, see the .NET Framework technologies unavailable\", \" on .NET Core and .NET 5+ article.\\n\\n## Regenerate autogenerated clients\\n\\nIf your application uses au\", \"togenerated code, such as a WCF client, you may need to regenerate this code to target .NET. Sometim\", \"es, you can find some missing references since they may not be included as part of the default .NET \", \"assemblies set. Using a tool like https://apisof.net/, you can easily locate the assembly the missin\", \"g reference lives in and add it from NuGet.\\n\\n## Rolling back package versions\\n\\nAs a general rule, we\", \"'ve previously stated that you better update every single package version to be compatible with .NET\", \". However, you can find that targeting an updated and compatible version of an assembly just doesn't\", \" pay off. If the cost of change isn't acceptable, you can consider rolling back package versions kee\", \"ping the ones you use on .NET Framework. Although they may not be targeting .NET, they should work w\", \"ell unless they call some unsupported APIs.\\n\\n## Run and test\\n\\nOnce you have your application buildin\", \"g with no errors, you can start the last step of the migration by testing every functionality.\\n\\nIn t\", \"his final step, you can find several different issues depending on the complexity of your applicatio\", \"n and the dependencies and APIs you're using.\\n\\nFor example, if you use configuration files (app.conf\", \"ig), you may find some errors at run time like Configuration Sections not present. Using the Microso\", \"ft.Extensions.Configuration NuGet package should fix that error.\\n\\nAnother reason for errors is the u\", \"se of the BeginInvoke and EndInvoke methods because they aren't supported on .NET. They aren't suppo\", \"rted on .NET because they have a dependency on Remoting, which doesn't exist on .NET. To solve this \", \"issue, try to use the await keyword (when available) or the Task.Run method.\\n\\nYou can use compatibil\", \"ity analyzers to let you identify APIs and code patterns in your code that can potentially cause pro\", \"blems at run time with .NET. Go to https://github.com/dotnet/platform-compat and use the .NET API an\", \"alyzer on your project.\\n\\n## Migrating a Windows Forms application\\n\\nTo showcase a complete migration \", \"process of a Windows Forms application, we've chosen to migrate the eShop sample application availab\", \"le at https://github.com/dotnetarchitecture/eShopModernizing/tree/master/eShopLegacyNTier/src/eShopW\", \"inForms. You can find the complete result of the migration at https://github.com/dotnetarchitecture/\", \"eShopModernizing/tree/master/eShopModernizedNTier/src/eShopWinForms .\\n\\nThis application shows a prod\", \"uct catalog and allows the user to navigate, filter, and search for products. From an architecture p\", \"oint of view, the app relies on an external WCF service that serves as a fa\\u00e7ade to a back-end databa\", \"se.\\n\\nYou can see the main application window in the following picture:\\n\\neShopWinforms.csproj\\n\\n\\u2022y eSh\", \"op WinForms\\n\\n\\u2039}xm] version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?\\u203a\\n\\neSHOP\\n\\nOnCONTAINERS\\n\\n2 \\u2039Project ToolsVersion=\\\"1\", \"5.0\\\" xmlns=\\\"http://schemas.microsoft.com/developer/msbuild/2003\\\"&gt;\\n\\n\\u2039Import Project=\\\"$(MSBuildExte\", \"nsionsPath) \\\\$(MSBuildToolsVersion) \\\\Microsoft.Common.props\\\" Condition=\\\"Exists('$(MSBuildExtensionsP\", \"ath)|\\n\\n&lt;PropertyGroup&gt;\\n\\n\\u2039Configuration Condition=\\\" '(Configuration)' == '\\u2022 \\\"\\u203aDebug&lt;/Configu\", \"ration&gt;\\n\\n\\u2039Platform Condition=\\\" 'S(Platform)' .. \\\"\\u2022 \\\"\\u203aAnyCPU&lt;/Platform&gt;\\n\\n&lt;ProjectGuid&gt;\", \"(AE32909C-9EE6-4ECE-B407-D23A15A1FEED}&lt;/ProjectGuid&gt;\\n\\n\\u2039OutputType\\u203aWinExe&lt;/OutputType&gt;\\n\\n&\", \"lt;RootNamespace&gt;eShoplinForms&lt;/RootNamespace&gt;\\n\\n&lt;AssemblyName&gt;eShopwinForms&lt;/Assem\", \"blyName&gt;\\n\\n&lt; TargetFrameworkVersion)v4.7\\u2039/TargetFrameworkVersion&gt;\\n\\n&lt;FileAlignment&gt;512&\", \"lt;/FileAlignment&gt;\\n\\n&lt;AutoGenerateBindingRedirects&gt;trues/AutoGenerateBindingRedirects&gt;\\n\\n\\u2039\", \"TargetFrameworkProfile /&gt;\\n\\n&lt;PublishUr1\\u203apublish\\\\&lt;/PublishUrl&gt;\\n\\n\\u2039Install\\u203atrue\\u2039/Install\\u203a\\n\\n\\u2039\", \"InstallFrom&gt;Disk&lt;/InstallFrom&gt;\\n\\n&lt;UpdateEnabled&gt; false\\u2039/UpdateEnabled&gt;\\n\\n\\u2039UpdateMode\", \"&gt; Foreground\\u2039/UpdateMode&gt;\\n\\n&lt;UpdateInterval\\u203a7&lt;/UpdateInterval&gt;\\n\\n&lt;UpdateIntervalUnit\", \"s&gt;Days&lt;/UpdateIntervalUnits&gt;\\n\\n\\u2039UpdatePeriodically&gt;false\\u2039/UpdatePeriodically&gt;\\n\\n\\u2039Update\", \"Required\\u203a false\\u2039/UpdateRequired&gt;\\n\\n\\u2039MapFileExtensions&gt;true\\u2039/MapFileExtensions&gt;\\n\\n(Application\", \"Revision&gt;@\\u2039/ApplicationRevision&gt;\\n\\n&lt;ApplicationVersion&gt;1.0.0.%2a&lt;/ApplicationVersion&g\", \"t;\\n\\n&lt; IsWebBootstrapper&gt;falses/IskebBootstrapper&gt;\\n\\n&lt;UseApplicationTrust&gt;false&lt;/Usc\", \"ApplicationTrust&gt;\\n\\n\\u2039BootstrapperEnabled\\u203atrue\\u2039/BootstrapperEnabled&gt;\\n\\n&lt;/PropertyGroup&gt;\\n\\n\\u2039P\", \"ropertyGroup Condition=\\\" '(Configuration) |$(Platform)' == 'Debug|AnyCPU' \\\"&gt;\\n\\n32\\n\\n34\\n\\n35\\n\\nMain Ca\", \"talog\\n\\n36\\n\\n37\\n\\nType\\n\\n38\\n\\n&lt;PlatformTarget&gt;AnyCPU&lt;/PlatformTarget&gt;\\n\\n\\u2039DebugSymbols&gt;true&\", \"lt;/DebugSymbols&gt;|\\n\\n&lt;DebugType&gt;full&lt;/DebugType&gt;\\n\\n&lt;Optimize\\u203afalse&lt;/Optimize&gt;\\n\", \"\\nInventory\\n\\n&lt;OutputPath\\u203abin\\\\Debug\\\\&lt;/OutputPath&gt;\\n\\n\\u2039DefineConstants&gt;DEBUG; TRACE&lt;/Defin\", \"eConstants&gt;\\n\\n\\u2039ErrorReport\\u203aprompt\\u2039/ErrorReport&gt;\\n\\n39\\n\\nPreview\\n\\n\\u2022 \\u2022 No issues found\\n\\n&lt;WarningL\", \"evel&gt;4&lt;/WarnineLevel&gt;\\n\\nCup &lt;T&gt;\\n\\nEscribe aqu\\u00ed para buscar\\n\\n<!-- image -->\\n\\nIf you open\", \" the .csproj project file, you can see something like this:\\n\\n<!-- image -->\\n\\nAs previously mentioned\", \", a .NET project has a more compact style and you need to migrate the project structure to the new .\", \"NET SDK style.\\n\\nIn Solution Explorer, right-click on the Windows Forms project and select Unload Pro\", \"ject &gt; Edit .\\n\\nNow you can update the .csproj file. You'll delete the entire contents and replace\", \" it with the following code:\\n\\n```\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\"> <PropertyGroup> <OutputType>WinE\", \"xe</OutputType> <TargetFramework>net7.0-windows</TargetFramework> <UseWindowsForms>true</UseWindowsF\", \"orms> <GenerateAssemblyInfo>false</GenerateAssemblyInfo>\\n```\\n\\n100 %\\n\\n11\\n\\n12\\n\\n14\\n\\n16\\n\\n24\\n\\n25\\n\\n26\\n\\n27\\n\", \"\\n28\\n\\n29\\n\\nError List\\n\\nEntire Solution\\n\\nCode\\n\\nSolution Explorer\\n\\nCS0234\\n\\nCS0234\\n\\nCS0246\\n\\nCS0234\\n\\nCS023\", \"4\\n\\nCS1069\\n\\nCS0246\\n\\nCS0234\\n\\nCS0234\\n\\nCS1069\\n\\nCS0246|\\n\\nDescription\\n\\nThe type or namespace name \\\"Service\", \"ContractAttributeAttribute' does not exist in the namespace System ServiceModel\\\" (are you missing an\", \" assembly reference?)\\n\\nThe type or namespace name ServiceContractAttribute' does not exist in the na\", \"mespace 'System.ServiceModel\\\" (are you missing an assembly reference?)\\n\\nThe type or namespace name '\", \"ConfigurationName' could not be found (are you missing a using directive or an assembly reference?)\\n\", \"\\nThe type or namespace name 'OperationContractAttributeAttribute' does not exist in the namespace 'S\", \"ystem ServiceModel\\\" (are you missing an assembly reference?)\\n\\nThe type or namespace name 'OperationC\", \"ontractAttribute does not exist in the namespace 'System ServiceModel\\\" (are you missing an assembly \", \"reference?)\\n\\nThe type name \\\"Action' could not be found in the namespace 'System\\\". This type has been\", \" forwarded to assembly System.Runtime, Version =4.2.1.0, Culture \\u00abneutral,\\n\\nSearch Error List\\n\\nLine\\n\", \"\\nSuppression St....\\n\\n498\\n\\nActive\\n\\n498\\n\\n498\\n\\n501\\n\\n501\\n\\n501\\n\\nActive\\n\\nActive\\n\\nActive\\n\\nActive\\n\\nActive\\n\\n<\", \"!-- image -->\\n\\nThe type name \\\"Action' could not be found in the namespace System. This type has been\", \" forwarded to assembly System.Runtime, Version=4.2.1.0, Culture=neutral,\\n\\nPublicKeyToken= b0315f7f11\", \"d50a3a Consider adding a reference to that assembly.\\n\\nC#\\n\\nProject eShopWinForms\\n\\neShopWinForms eShop\", \"WinForms\\n\\neShopWinForms eShopWinForms\\n\\neShopWinForms eShopWinForms\\n\\nFile\\n\\nReference.cs\\n\\nReference.cs\", \"\\n\\nReference.cs\\n\\nReference.cs\\n\\nReference.cs\\n\\nReference.cs\\n\\nNotifications\\n\\nReference.cs\\n\\n504 Active\\n\\nS\", \"ave and reload the project. You're now done updating the project file and the project is targeting .\", \"NET 7.\\n\\nIf you compile the project at this point, you'll find some errors related to the WCF client \", \"reference. Since this code is autogenerated, you must regenerate it to target .NET.\\n\\n<!-- image -->\\n\", \"\\nProperties\\n\\nAlt+ Enter\\n\\nDelete the Reference.cs file and generate a new Service Client.\\n\\nRight-clic\", \"k on Connected Services and select the Add Connected Service option.\\n\\n<!-- image -->\\n\\nThe Connected \", \"Services window opens. Select the Microsoft WCF Web Service option.\\n\\n*\\n\\n*\\n\\n* 120 Errors\\n\\n0 Warnings\\n\", \"\\n) 0 Messages\\n\\nBuild + IntelliSense\\n\\nY\\n\\nP-\\n\\nFile Edit View Project Build Debug Test Analyze Tools Ex\", \"tensions Window\\n\\n30 - 0\\n\\nHelp\\n\\nSearch Visual Studio (Ctrl+Q)\\n\\nDebug - Any CPU\\n\\neShopWinForms * x\\n\\nCo\", \"nfigure WCF Web Service Reference\\n\\nSpecify the service to add\\n\\nConnected Services\\n\\nPublish\\n\\nService \", \"Endpoint\\n\\nData Type Options\\n\\nClient Options\\n\\nConnected Services\\n\\n<!-- image -->\\n\\nIf you have the WCF\", \" Service in the same solution as we have in this example, you can select the Discover option instead\", \" of specifying a service URL.\\n\\n<!-- image -->\\n\\nOnce the service is located, the tool reflects the AP\", \"I contract implemented by the service. Change the name of the namespace to be eShopServiceReference \", \"as shown in the following image:\\n\\n- \\u2022 IIS Express (Google Chrome) - C - \\u2022 =\\n\\neShopLegacyNTier\\n\\nConfi\", \"gure WCF Web Service Reference\\n\\nSpecify the service to add\\n\\nService Endpoint\\n\\nData Type Options\\n\\nCli\", \"ent Options\\n\\n<!-- image -->\\n\\nSelect the Finish button. After a while, you\\u2019ll see the generated code.\", \"\\n\\nYou should see three autogenerated files:\\n\\n1. Getting Started: a link to GitHub to provide some in\", \"formation on WCF.\\n2. ConnectedService.json: configuration parameters to connect to the service.\\n3. R\", \"eference.cs: the actual WCF client code.\\n\\nSolution Explorer\\n\\n= \\u20ac\\n\\nSearch Solution Explorer (Ctrl+\\\")\\n\", \"\\neShopWinForms\\n\\nD\\n\\nD\\n\\nC# Program.cs\\n\\nSolution Explorer\\n\\n<!-- image -->\\n\\nIf you compile again, you'll\", \" see many errors coming from .cs files inside the Helper folder. This folder was present in the .NET\", \" Framework version but not included in the old .csproj. But with the new SDKstyle project, every cod\", \"e file present underneath the project file location is included by default. That is, the new .NET Co\", \"re project tries to compile the files inside the Helper folder. Since that folder isn't needed, you \", \"can safely delete it.\\n\\nIf you compile the project again and execute it, you won't see the product im\", \"ages. The problem is that now the path to the files has slightly changed. To fix this issue, you nee\", \"d to add another level of depth in the path, updating in the file CatalogView.cs the line:\\n\\nNotifica\", \"tions\\n\\neShop - Classic WPF Sample\\n\\nSearch\\n\\nSearch\\n\\nCatalog Type Fo\\n\\nView All talog Brand\\n\\nriew All\\n\\n\", \"```\\nstring image_name = Environment . CurrentDirectory + \\\" \\\\\\\\ .. \\\\\\\\ .. \\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\ \\\"\", \" + catalogItems . Picturefilename; to string image_name = Environment . CurrentDirectory + \\\" \\\\\\\\ .. \\\\\", \"\\\\ .. \\\\\\\\ .. \\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\ \\\" + catalogItems . Picturefilename; Azure\\n```\\n\\nAfter this cha\", \"nge, you can check that the application launches and runs as expected on .NET 7.\\n\\nMicrosoft Azure Bl\", \"ack T-Shirt\\n\\n## Migrating a WPF application\\n\\nWe'll use the Shop.ClassicWPF sample application to per\", \"form the migration. The following image shows a screenshot of the app before migration:\\n\\nCap\\n\\n<!-- i\", \"mage -->\\n\\nThis application uses a local SQL Server Express database to hold the product catalog info\", \"rmation. This database is accessed directly from the WPF application.\\n\\nFirst, you must update the .c\", \"sproj file to the new SDK style used by .NET Core applications. You'll follow the same steps describ\", \"ed in the Windows Forms migration: you'll unload the project, open the .csproj file, update its cont\", \"ents, and reload the project.\\n\\nIn this case, delete all the content of the .csproj file and replace \", \"it with the following code:\\n\\n\\u2022\\n\\nError List\\n\\nEntire Solution\\n\\n* Code\\n\\n* CS0234\\n\\nDescription\\n\\nThe type\", \" or namespace name 'SqlProvider' does not exist in the namespace 'eShop' (are you missing an assembl\", \"y\\n\\n```\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\"> <PropertyGroup> <OutputType>WinExe</OutputType> <TargetFram\", \"ework>net7.0-windows</TargetFramework> <UseWpf>true</UseWpf> <GenerateAssemblyInfo>false</GenerateAs\", \"semblyInfo> </PropertyGroup> </Project>\\n```\\n\\nIf you reload the project and compile it, you\\u2019ll get th\", \"e following error:\\n\\n<!-- image -->\\n\\nSince you've deleted all the .csproj contents, you've lost a pro\", \"ject reference specification present in the old project. You just need to add this line to the .cspr\", \"oj file to include the project reference back:\\n\\n<!-- image -->\\n\\nYou can also let Visual Studio help \", \"you by right-clicking on the Dependencies node and selecting Add Project Reference. Select the proje\", \"ct from the solution and select OK:\\n\\n1 Error |\\n\\nA O Warnings i O Messages\\n\\n2888000------\\n\\nBuild Only\", \"\\n\\nReference Manager - eShop. ClassicWPF\\n\\n4 Projects\\n\\nSolution\\n\\n\\u2022 Shared Projects\\n\\n\\u2022 Browse\\n\\nName eSh\", \"op.Server\\n\\nPath\\n\\nE: \\\\ModernizeAppsNET...\\n\\n<!-- image -->\\n\\nSearch (Ctrl+E)\\n\\nName:\\n\\neShop.SqlProvider\\n\", \"\\nOnce you add the missing project reference, the application compiles and runs as expected on .NET.\\n\", \"\\n?\\n\\nX\\n\\n8 -\\n\\n## Deploying Modern Desktop Applications\\n\\nWhen you develop desktop applications, one thi\", \"ng to consider is how your application is going to be packaged and deployed to the users' machines. \", \"The problem with packaging, deployment, and installation is that it usually falls under the umbrella\", \" of the IT professionals, who care about different things than developers.\\n\\nThese days, we're all fa\", \"miliar with the DevOps concept, where developers and IT Pros work closely to move applications to th\", \"eir production environments. But if you've been in the desktop battle for more than 10 years, you mi\", \"ght have seen the following story. A team of developers works together hard to meet the project dead\", \"lines. Business people are nervous since they need the system working on many users' machines to run\", \" the company. On \\\"D-Day\\\", the project manager checks with every developer that their code is working\", \" well and that everything is fine, so they can ship. Then, the package team comes in generating the \", \"setup for the app, distribute it to every user machine and a set of test users run the application. \", \"Well, they try, because before showing any UI, the application throws an exception that says \\\"Method\", \" ~ of object ~ failed\\\". Panic starts flowing through the air and a brief investigation points to a y\", \"oung and tired developer that has introduced a third-party control, that certainly \\\"worked on the de\", \"v machine\\\".\\n\\nInstalling desktop applications have traditionally been a nightmare for two main reason\", \"s:\\n\\n- Lack of close collaboration culture between dev and IT teams.\\n- Lack of a solid packaging and \", \"deploying technology we can build upon.\\n\\nIn fact, we\\u2019ve been living with the fact that sometimes you\", \" regret that you installed an app because:\\n\\n- It ends up having some undesired side effects on your \", \"machine.\\n- Some applications that were previously installed stop working.\\n\\nAdditionally, you can't j\", \"ust restore the system to its original state by uninstalling the app. We're so used to living with t\", \"his situation that we've coined terms like \\\"DLL Hell\\\" or \\\"Winrot\\\".\\n\\nIn this chapter, we'll talk abou\", \"t MSIX. MSIX is the new technology from Microsoft that tries to capture the best of previous technol\", \"ogies to provide a solid foundation for the packaging technology of the future.\\n\\nWhat does a packagi\", \"ng technology have to do with modernization? Well, it turns out that packaging is fundamental for th\", \"e enterprise IT with lots of money invested there. Modernization isn't only related\\n\\nModern IT: Appl\", \"ication Lifecycle Today to using the latest technologies. It's also related to reducing time to mark\", \"et from the moment a business requirement is defined until your company delivers the feature to your\", \" client.\\n\\n(Re)Package to\\n\\n## The modern application lifecycle\\n\\nDeploy\\n\\nToday, developers write and b\", \"uild the code for an app and then pass the generated assets to the IT Pros. Then, the IT Pros reconf\", \"igure the app and repackage it, typically in an MSI or more recently in an App -V packaging format. \", \"The app is then deployed through different channels and tools. One of the main problems with this ap\", \"proach is commonly known as \\\"packaging paralysis\\\". The problem is that this cycle repeats every time\", \" there's an app update or an OS update.\\n\\nYou can see the process reflected on the following picture:\", \"\\n\\n<!-- image -->\\n\\nCompanies need a way to break this packaging cycle into three independent cycles:\\n\", \"\\n- OS updates\\n- Application updates\\n- Customization\\n\\nModern IT Virtuous Cycle\\n\\nWindows\\n\\nUpdate\\n\\nMicr\", \"osoft Store or any CDN\\n\\nMicrosoft Store for Business\\n\\n<!-- image -->\\n\\nThe previous diagram shows tha\", \"t you can:\\n\\n- Update the underlying OS without having to repackage your apps.\\n- Enable customization\", \"s from IT without the need to repackage the original developer package.\\n\\nThis radical change leads u\", \"s to the new and modern IT lifecycle as shown in the following picture:\\n\\nModern IT: Application Life\", \"cycle\\n\\nDeveloper\\n\\nCreate\\n\\nApp\\n\\n* Sisdil\\n\\nStudio\\n\\n## Package\\n\\nto MSIX\\n\\nConfigure\\n\\nCustomize\\n\\nIT Pro\\n\\n\", \"Sign\\n\\nDeploy\\n\\n<!-- image -->\\n\\nDevelopers create the app and generate an MSIX package that IT Pros ca\", \"n consume and configure without the need of repackaging. Along with the MSIX technology, Microsoft h\", \"as created tools to allow IT to customize and configure packages without repackaging.\\n\\n## MSIX: The \", \"next generation of deployment\\n\\nBefore MSIX, there were several packaging technologies available like\", \" setup wizards, MSI, ClickOnce, App -V, and scripting. Each of these technologies has their own stre\", \"ngths and Microsoft has decided to pick the best of all to build MSIX. MSIX is built on the foundati\", \"ons of these existing technologies picking the best of each:\\n\\n- App -V =&gt; Containerization\\n- Clic\", \"kOnce =&gt; Auto updating\\n- MSI =&gt; Easy to distribute\\n\\nWith MSIX, you get one installer technolog\", \"y with all these features.\\n\\n\\u203aetup.ex\\n\\nWindows\\n\\nClickOnce\\n\\n<!-- image -->\\n\\n## Benefits of MSIX\\n\\n## Ne\", \"ver regret installing an app\\n\\nMSIX provides a predictable, reliable, and safe deployment. The declar\", \"ative method contained in the package manifest lets the OS keep track of every asset your applicatio\", \"n needs. It also provides a true clean uninstall with no side effects.\\n\\n## Disk space optimization\\n\\n\", \"MSIX is optimized to reduce the footprint that an application has on the user's machine disk space. \", \"It creates a single instance storage of your files. That is, if you have two different packages with\", \" the same DLL, the DLL isn't installed twice. The platform takes care of that problem because it kno\", \"ws all the files that a particular app installed thanks to its declarative nature. It also allows yo\", \"u to have different versions of a DLL working side by side.\\n\\nWith the use of resource packages, you \", \"can easily create multilingual apps and the OS takes care of installing the ones that are used.\\n\\n## \", \"Network optimization\\n\\nMSIX detects the differences on the files at the byte block level enabling a f\", \"eature called differential updates. What this means is that only the updated byte blocks are downloa\", \"ded on application updates.\\n\\nApplicatior\\n\\nDifferential updates\\n\\nHR APP Version 1.0.0.0\\n\\nHRApp.exe\\n\\nS\", \"E\\n\\nHR APP Version 1.2.0.0\\n\\nHRApp.exe\\n\\nEmployeen.dat\\n\\nExpenses di\\n\\n<!-- image -->\\n\\nWith streaming ins\", \"tallation, the user can quickly start working on your application while other parts of the app are d\", \"ownloaded on the background. This feature contributes to an engaging experience for your users.\\n\\nWit\", \"h the optional packages feature, you achieve componentization on your app deployment, so you can dow\", \"nload them when needed.\\n\\n## Simple packaging and deployment\\n\\nThe AppManifest declares the versioning\", \", device targeting and identity in a standard way for every application. It also provides a way to s\", \"ign your assets providing a solid security foundation.\\n\\n## OS managed\\n\\nThe OS handles all the proces\", \"ses for installing, updating, and removing an application. Applications are installed per user but d\", \"ownloaded only once, minimizing the disk footprint. Microsoft is working on providing the MSIX exper\", \"ience also on Windows 7.\\n\\n## Windows provides integrity for the app\\n\\nWith the use of digital signatu\", \"res, you can guarantee that you don't install an application from untrusted sources. MSIX also preve\", \"nts tampering because:\\n\\n- It keeps a record of file hashes.\\n- It detects if a file has been modified\", \" after installation.\\n\\n## Works for the entire App Catalog\\n\\nOne of the coolest things about MSIX is t\", \"hat it works for the entire application catalog, Windows Forms, WPF, MFC/ATL, Delphi, even if you wa\", \"nt to do xCopy deployment, ClickOnce, or going to the Store, you can use the same MSIX package.\\n\\n## \", \"Tools\\n\\n## Windows Application Packaging Project\\n\\nYou can use the Windows Application Packaging Proje\", \"ct project in Visual Studio to generate a package for your desktop app. Then, you can publish that p\", \"ackage to the Microsoft Store or sideload it onto one or more PCs.\\n\\n## MSIX Packaging Tool\\n\\nThe MSIX\", \" Packaging Tool enables you to repackage your existing Win32 applications to the MSIX format. It off\", \"ers both an interactive UI and a command line for conversions and gives you the ability to convert a\", \"n application without having the source code.\\n\\n[7 MSIX Packaging Tool (Preview)\\n\\nCreate new package \", \"Open package editor\\n\\nSelect package type\\n\\nApplication package\\n\\nCreate your app package\\n\\nX\\n\\n203\\n\\n<!--\", \" image -->\\n\\n## Package Support Framework\\n\\nThe Package Support Framework is an open-source kit that h\", \"elps you apply fixes to your existing Win32 application when you don't have access to the source cod\", \"e, so that it can run in an MSIX container. The Package Support Framework helps your application fol\", \"low the best practices of the modern runtime environment.\\n\\n## App Installer\\n\\nApp Installer allows Wi\", \"ndows 10 and Windows 11 apps to be installed by double-clicking the app package. This means that use\", \"rs don't need to use PowerShell or other developer tools to deploy Windows 10/Windows 11 apps. The A\", \"pp Installer can also install an app from the web, optional packages, and related sets.\\n\\n## How to c\", \"reate an MSIX package from an existing Win32 desktop application\\n\\nLet's go through the process to cr\", \"eate an MSIX package from an existing Win32 application. In this example, we'll use a Windows Forms \", \"app.\\n\\nCouponDemo - Microsoft Visual Studio\\n\\nFile\\n\\nToolbox\\n\\nSearch Toolbox\\n\\n\\u2022 Microsoft.Toolkit.Forms\", \".U\\n\\n\\u2022 Microsoft.Toolkit.Forms.U\\n\\nP All Windows Forms\\n\\n\\u2022 Common Controls\\n\\nPointer\\n\\nButton\\n\\nCheckBox\\n\\n\", \"CheckedListBox\\n\\nComboBox\\n\\nDateTimePicker\\n\\nLabel\\n\\nLinkLabel\\n\\nListBox\\n\\nListView\\n\\nMaskedTextBox\\n\\nMonthC\", \"alendar\\n\\nNotifylcon\\n\\nNumericUpDown\\n\\nPictureBox\\n\\nProgressBar\\n\\nRadioButton\\n\\nRichTextBox\\n\\nTextBox type \", \"here to search\\n\\nEdit\\n\\nView\\n\\nProject Build Debug\\n\\nAdd New Project\\n\\n\\u2022 Recent\\n\\n4 Installed\\n\\n4 Visual C#\", \"\\n\\nSearch (Ctri+E)\\n\\nType: Visual C#\\n\\nA project that creates packages\\n\\nTo start, add a new project to \", \"your solution, select the Windows Application Packaging Project, and give it a name. Windows Univers\", \"al Class Library (Universal Windows) Visual C# Windows Store\\n\\n\\u2022 Web\\n\\nName:\\n\\nLocation:\\n\\nVisual C#\\n\\n<!\", \"-- image -->\\n\\nYou'll see the structure of the packaging project and note a special folder called App\", \"lications. Inside this folder, you can specify which applications you want to include in the package\", \". It can be more than one.\\n\\nWindows Runtime Component (Universal Windows)\\n\\n(.).\\n\\n- Team\\n\\nTools\\n\\nWind\", \"ow\\n\\nTest Analyze\\n\\nSort by:\\n\\nHelp\\n\\nDefault\\n\\nBlank App (Universal Windows)\\n\\nVisual C#\\n\\nQuick Launch (C\", \"tri+Q)\\n\\n?\\n\\nX\\n\\nP-\\n\\n50\\n\\nStri+:)\\n\\nP - &amp;\\n\\nAdam Braden *\\n\\n+ 4 \\u00d7\\n\\n\\u2022 P\\n\\nP\\n\\nSolution Explorer\\n\\nSearch So\", \"lution Explorer (Ctrl+;)\\n\\n\\u2022\\n\\nSolution Explorer\\n\\n<!-- image -->\\n\\nRight-click on the Applications fold\", \"er and select the Windows Forms project you want to package from the Visual Studio solution.\\n\\n- Ji\\n\\n\", \"CouponDemo - Microsoft Visual Studio\\n\\nCoupon. Package\\n\\nPackage.appxmanifest \\u2192\\n\\nFile Edit View Projec\", \"t Build Debug Team\\n\\n.. o\\n\\nCoupon.cs\\n\\nNuGet: Coupon.Forms\\n\\nTools Test Analyze Window Help\\n\\nReference \", \"Manager - Coupon.Package\\n\\nDeclarations\\n\\nToolbox\\n\\nSearch Tooll\\n\\n4 General\\n\\nThere are n this group\\n\\nth\", \"is tex!\\n\\nAll Visual Assets\\n\\nSmall Tile\\n\\nMedium Tile\\n\\nWide Tile\\n\\nLarge Tile\\n\\nOutput\\n\\nShow output from\", \": Debug\\n\\nThe thread 0x553c has exited with code \\u2022 (0x0).\\n\\nThe thread 0x2a0 has exited with code 0(0x\", \"0).\\n\\nThe program ' [19988] Coupon. Forms. exe' has exited with code 0(0x0).\\n\\nError List\\n\\n\\u2022 This item\", \" does not support previewing.\\n\\nOutput\\n\\nP Type here to search\\n\\n4 Projects\\n\\nSolution\\n\\nApplication\\n\\nNam\", \"e\\n\\n~ Coupon.Forms\\n\\nContent URIs\\n\\nVisual Assets\\n\\nPath\\n\\nUsers\\\\adambr\\\\source\\\\repos\\\\ talks\\\\Devintersecti\", \"on201...\\n\\n7 P\\n\\nQuick Launch (Ctri+Q)\\n\\nSolution Explorer\\n\\n?\\n\\nSearch Solution Explorer (Ctrl+:)\\n\\nSearc\", \"h (Ctri+ E)\\n\\nc* CouponService.cs\\n\\nForm1.cs\\n\\nName:\\n\\nCoupon.Forms\\n\\nP- 6\\n\\n4 X\\n\\nAdam Braden *\\n\\n\\u0434 -\\n\\nP-\\n\\n\", \"-\\n\\nP\\n\\nPackaging\\n\\nCapabilities\\n\\n<!-- image -->\\n\\nAt this point, you can compile and generate the packa\", \"ge but let's examine a couple of things. To have a better user experience, Visual Studio can autogen\", \"erate all the visual assets a modern application needs to handle icons and tile assets for the tile \", \"bar and start menu. Open the Package.appxmanifest file to access the Manifest Designer. You can then\", \" generate all the visual assets from a given image present on your project just by clicking Create .\", \"\\n\\n<!-- image -->\\n\\nIf you open the code for the Package.appxmanifest file, you can see a couple of in\", \"teresting things.\\n\\nRight under &lt;Package&gt;, there's an &lt;Identity&gt; node. This is where your\", \" packaged application is going to get its identity, which will be managed by the OS.\\n\\nProgram.cs\\n\\nPa\", \"ckage.appxmanifest + x\\n\\nCoupon.Package\\n\\n1\\n\\nCoupon.cs\\n\\n\\u2039?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?&gt;\\n\\n+\\n\\n\", \"E&lt;Package xmlns=\\\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\\\" )\\n\\n&lt;Identity\", \" Name=\\\"7c387b13-ce2b-436b-9b2e-49cb9e853df3\\\" Publisher=\\\"CN=adambr\\\" Vers-\\n\\n&lt;Properties&gt;\\n\\n<!-- i\", \"mage -->\\n\\n3\\n\\n4\\n\\n5\\n\\n6\\n\\n7\\n\\n8\\n\\n9\\n\\n10\\n\\n11\\n\\n12\\n\\n13\\n\\n14\\n\\n15\\n\\n16\\n\\n17\\n\\n18\\n\\n19\\n\\n110 %\\n\\nOutput\\n\\nShow output fr\", \"om: Visual Assets\\n\\nError List\\n\\nOutput\\n\\nIn the &lt;Capabilities&gt; node, you can find all the requir\", \"ements the application needs, paying special attention to the &lt;rescap:Capability Name=\\\"runFullTru\", \"st\\\" \\\\&gt;, which tells the OS to run the app in full trust mode since it's a Win32 application.\\n\\n=\\n\\n\", \"NuGet: Coupon.Forms\\n\\nPackage.appxmanifest + X\\n\\nCoupon. Package\\n\\n16\\n\\n17\\n\\n18\\n\\n19\\n\\n20\\n\\n21\\n\\n22\\n\\n23\\n\\n24\\n\\n\", \"25\\n\\n26\\n\\n27\\n\\n28\\n\\n29\\n\\n110 % = 4\\n\\nOutput\\n\\nShow output from: Visual Assets\\n\\nError List\\n\\n&lt;Applications\", \"&gt;\\n\\n\\u2039Application Id=\\\"App\\\" Executable=\\\"$targetnametoken$.exe\\\" EntryPoint=\\\"$targeter\\n\\n&lt;uap: Visua\", \"lElements DisplayName=\\\"Coupon. Package\\\" Description=\\\"Coupon. Package\\n\\n&lt;uap:DefaultTile Wide310x15\", \"0Logo=\\\"Images\\\\Wide310x150Logo.png\\\" Square310x31\\n\\n&lt;/Package&gt;\\n\\n<!-- image -->\\n\\nOutput\\n\\nSet the p\", \"ackaging project as the startup project for the solution and select Run. This is going to:\\n\\n- Compil\", \"e the Windows Forms application.\\n- Create an MSIX package out of the build results.\\n- Deploy the pac\", \"kages.\\n- Install it locally on the development machine.\\n- Launch the app.\\n\\nCoupon.cs\\n\\nNuGet: Coupon.\", \"Forms\\n\\n+\\n\\nRecently added\\n\\nCoupon.Package\\n\\nMicrosoft Graph !\\n\\nExpand v\\n\\n#\\n\\nA\\n\\nPin to Start\\n\\nMirrosoft\", \" skill with containers at a\\n\\nsernetes on Azure workshop\\n\\n<!-- image -->\\n\\nWith this, you have the cle\", \"an install and uninstall experience that MSIX provides fully integrated into Windows 10/Windows 11.\\n\", \"\\nThe final stage is about how you deploy the MSIX package to another machine.\\n\\nRight-click on the pa\", \"ckaging project, select the Store menu, and then select the Create App Packages option.\\n\\nThen, you c\", \"an choose between creating a package to upload to the store or creating packages for sideloading. In\", \" most modernization scenarios, you'll choose I want to create packages for sideloading .\\n\\nCreate\\n\\nCr\", \"eate App Packages\\n\\nSelect and Configure Packages\\n\\nOutput location:\\n\\nVersion:\\n\\n. 0.0. 0\\n\\n/ Automatica\", \"lly increment\\n\\nMore information\\n\\nGenerate app bundle:\\n\\nAlways\\n\\nWhat does an app bundle mean?\\n\\nSelect\", \" the packages to create and the solution configuration mappings:\\n\\nArchitecture Solution Configuratio\", \"n\\n\\nNeutral x86\\n\\nx64\\n\\nARM\\n\\n<!-- image -->\\n\\nThere you can select the different architectures you want \", \"to target as you can include as many as you want into the same MSIX package.\\n\\nThe final step is to d\", \"eclare where you want to deploy the final installation assets.\\n\\n\\u2022\\n\\n?\\n\\nX\\n\\nCreate App Packages\\n\\nConfig\", \"ure Update Settings\\n\\nInstallation URL: http(s) or UNC path or file share:\\n\\nhttp://apps.contoso.com/M\", \"yUniversalApp\\n\\nHow can I publish my application?\\n\\nSpecify how often the application should check for\", \" updates:\\n\\n\\u2022 Check everytime the application runs\\n\\n\\u2022 Check every: |1\\n\\n<!-- image -->\\n\\nYou can choose\", \" to use a web server or a shared UNC path on your enterprise file servers. Pay attention to the sett\", \"ings to specify how you want to update your application. We'll cover application updates in the next\", \" section.\\n\\nFor a detailed step-by-step guide, see Package a desktop app from source code using Visua\", \"l Studio .\\n\\n## Auto Updates in MSIX\\n\\nThe Windows Store has a great updating mechanism using Windows \", \"Update. In most enterprise scenarios, you don't use the Store to distribute your desktop apps. So, y\", \"ou need a similar way to configure updates for your application and pull them to your users.\\n\\nUsing \", \"a combination of Windows 10/Windows 11 features and MSIX packages, you can provide a great updating \", \"experience for your users. In fact, the user doesn't need to be technical at all but still benefits \", \"from a seamless application update experience.\\n\\nYou can configure your updates to interact with the \", \"user in two different ways:\\n\\n?\\n\\nX\\n\\nHRappinstaller\\n\\n1\\n\\n2\\n\\n3\\n\\n4\\n\\n5\\n\\n6]\\n\\n7\\n\\n8\\n\\n9\\n\\n10\\n\\n11\\n\\n12\\n\\n13\\n\\n14\\n\\n1\", \"5\\n\\n16\\n\\n17\\n\\n18\\n\\n19\\n\\n20\\n\\n21\\n\\n\\u2039?xm1 version=\\\"1.0\\\"- encoding\\n\\nE&lt;AppInstaller-\\n\\n-Uri-\\\"http://sampleapp\", \"packages.azurewebsites.net/MSIX\\\\_HR\\\\_Demo/HR.appinstaller'\\n\\n- User prompted updates: The OS shows so\", \"me autogenerated nice UI to notify the user about the application it's about to install. It builds t\", \"his UI based on the properties you specify on your installation files.\\n\\n\\u2022Version=\\\"2.0.0.0\\\"\\n\\n- Silent\", \" updates in the background. With this option, your users don't need to be aware of the updates. =\\u00b7 \\\"\", \"x86\\\"/&gt;\\n\\nYou can also configure when you want to perform updates: either when the application laun\", \"ches or on a regular basis. Thanks to the side-loading features, you can even get these updates whil\", \"e the application is running.\\n\\nWhen you use this type of deployment, a special file is created calle\", \"d .appinstaller. This simple file contains the following sections:\\n\\n- The location of the .appinstal\", \"ler file\\n- The application's main MSIX package properties\\n- The update behavior\\n\\n<!-- image -->\\n\\nIn \", \"combination with this file, Microsoft has designed a special URL protocol to launch the installation\", \" process from a link:\\n\\n&lt;a href=\\\"ms -appinstaller:?source=http://mywebservice.azureedge.net/MyApp.\", \"msix\\\"&gt;Install app package &lt;/a&gt;\\n\\nThis protocol works on all browsers and launches the instal\", \"lation process with a great user experience on Windows 10/Windows 11. Since the OS manages the insta\", \"llation process, it's aware of the location this application was installed from and tracks all the f\", \"iles affected by the process.\\n\\nMSIX creates a user interface for installation automatically showing \", \"some properties of the package. This allows for a common installation experience for every app.\\n\\n133\", \" %\\n\\n-\\\"UTF-8\\\"?\\u203a\\n\\nOnce you've generated the new MSIX package and moved it to the deployment server, yo\", \"u just have to edit the .appinstaller file to reflect these changes: mainly the version and the path\", \" to the new MSIX file. The next time the user launches the application, the system will detect the c\", \"hange and download the files for the new version in the background. When the download is finished, i\", \"nstallation will execute transparently for your user on new application launch.\"]"