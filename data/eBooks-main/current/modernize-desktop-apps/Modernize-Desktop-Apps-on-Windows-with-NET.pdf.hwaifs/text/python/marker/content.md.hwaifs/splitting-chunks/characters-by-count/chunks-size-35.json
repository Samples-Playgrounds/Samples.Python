"[\"![](_page_0_Picture_0.jpeg)\\n\\n# Modernizing Desktop Apps on Windows with .NET 7\\n\\n![](_page_0_Picture_\", \"2.jpeg)\\n\\nMiguel Angel Castej\\u00f3n Dom\\u00ednguez Olia Gavrysh\\n\\n![](_page_1_Picture_0.jpeg)\\n\\n#### **EDITION v\", \"1.0.3** - Updated to .NET 7\\n\\nRefer to the [changelog](https://aka.ms/desktop-ebook-changelog) for th\", \"e book updates and community contributions.\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and V\", \"isual Studio product teams\\n\\nA division of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washing\", \"ton 98052-6399\\n\\nCopyright \\u00a9 2022 by Microsoft Corporation\\n\\nAll rights reserved. No part of the conte\", \"nts of this book may be reproduced or transmitted in any form or by any means without the written pe\", \"rmission of the publisher.\\n\\nThis book is provided \\\"as-is\\\" and expresses the author's views and opini\", \"ons. The views, opinions, and information expressed in this book, including URL and other Internet w\", \"ebsite references, may change without notice.\\n\\nSome examples depicted herein are provided for illust\", \"ration only and are fictitious. No real association or connection is intended or should be inferred.\", \"\\n\\nMicrosoft and the trademarks listed at [https://www.microsoft.com](https://www.microsoft.com/) on \", \"the \\\"Trademarks\\\" webpage are trademarks of the Microsoft group of companies.\\n\\nMac and macOS are trad\", \"emarks of Apple Inc.\\n\\nAll other marks and logos are property of their respective owners.\\n\\nCo-Authors\", \":\\n\\n**Olia Gavrysh**, Program Manager, .NET team, Microsoft\\n\\n**Miguel Angel Castej\\u00f3n Dominguez**, Inn\", \"ovation Architect, Kabel\\n\\nParticipants and reviewers:\\n\\n**Maira Wenzel**, Senior Program Manager, .NE\", \"T team, Microsoft\\n\\n**Andy De Gorge**, Senior Content Developer, .NET docs team, Microsoft\\n\\n**Miguel \", \"Ramos**, Senior Program Manager, Windows Developer Platform team, Microsoft\\n\\n**Adam Braden**, Princi\", \"pal Program Manager, Windows Developer Platform team, Microsoft\\n\\n**Ricardo Minguez Pablos**, Senior \", \"Program Manager, Azure IoT team, Microsoft\\n\\n**Nish Anil**, Senior Program Manager, .NET team, Micros\", \"oft\\n\\n**Beth Massi**, Senior Product Marketing Manager, Microsoft\\n\\n**Scott Hunter**, Partner Director\", \" Program Manager, .NET team, Microsoft\\n\\n**Marta Fuentes Lara**, Kabel\\n\\n![](_page_2_Picture_0.jpeg)\\n\\n\", \"#### **Ra\\u00fal Fern\\u00e1ndez de C\\u00f3rdoba**, Kabel\\n\\n#### **Antonio Manuel Fern\\u00e1ndez Cantos**, Kabel\\n\\n# Introd\", \"uction\\n\\nThis book is about strategies you can adopt to move your existing desktop applications throu\", \"gh the path of modernization and incorporate the latest runtime, language, and platform features. Yo\", \"u'll discover that there's no unique recipe as each application is different, and so are your requir\", \"ements and preferences. The good news is that there are common approaches you can apply to add new f\", \"eatures and capabilities to your applications. Some of them won't even require major modifications o\", \"f your code. In this book, we'll reveal how all those features work behind the scenes and explain th\", \"e mechanics of their implementations. Moreover, you'll find some common scenarios for modernizing ex\", \"isting desktop applications shown in detail so you can find inspiration for evolving your projects.\\n\", \"\\nMicrosoft's approach to modernizing existing applications is to give you the flexibility to create \", \"your own customized path. All the modernization strategies described in this book are mostly indepen\", \"dent. You can choose ones that are relevant for your application and skip others that aren't importa\", \"nt for you. In other words, you can mix and match the strategies to best address your application ne\", \"eds.\\n\\n# Who should use the book\\n\\nThis book for developers and solution architects who want to modern\", \"ize existing Windows Forms and WPF desktop applications to leverage the benefits of .NET and Windows\", \" 10.\\n\\nYou might also find this book useful if you're a technical decision maker, such as an enterpri\", \"se architect or a development lead or director who wants an overview of the benefits of updating exi\", \"sting desktop applications.\\n\\n# How to use the book\\n\\nThis book addresses the \\\"why\\\"\\u2014why you might want\", \" to modernize your existing applications, and the specific benefits you get from using NET and MSIX \", \"to modernize your desktop apps. The content of the book is designed for architects and technical dec\", \"ision makers who want an overview, but who don't need to focus on implementation and technical, step\", \"-by-step details.\\n\\nAlong the different chapters, sample implementation code snippets and screenshots\", \" are provided, with chapter 5 devoted to showcase a complete migration process for sample applicatio\", \"ns.\\n\\n# What this book doesn't cover\\n\\nThis book covers a specific subset of scenarios that are focuse\", \"d on lift-and-shift scenarios, outlining the way to gain the benefits of modernizing without the eff\", \"ort of rewriting code.\\n\\nThis book isn't about developing modern applications with .NET from scratch \", \"or about getting started with Windows Forms and WPF. It focuses on how you can update existing deskt\", \"op applications with the latest technologies for desktop development.\\n\\n![](_page_3_Picture_0.jpeg)\\n\\n\", \"# Samples used in this book\\n\\nTo highlight the necessary steps to perform a modernization, we'll be u\", \"sing a sample application called eShopModernizing. This application has two flavors, Windows Forms a\", \"nd WPF, and we'll show a step-by-step process on how to perform the modernization on both of them to\", \" .NET.\\n\\nAlso, on the GitHub repository for this book, you'll find the results of the process, which \", \"you can consult with if you decide to follow the step-by-step tutorial.\\n\\n# Contents\\n\\n| Why modern de\", \"sktop applications              | 1  |\\n|----------------------------------------------|----|\\n| Intro\", \"duction                                 | 1  |\\n| A story of one company                       | 1  |\", \"\\n| Your story                                   | 1  |\\n| Desktop applications nowadays              \", \"  | 1  |\\n| Windows Forms                                | 3  |\\n| WPF                                \", \"          | 4  |\\n| UWP                                          | 4  |\\n| A tale of two platforms    \", \"                  | 5  |\\n| Paths to modernization                       | 8  |\\n| Modern features    \", \"                          | 8  |\\n| Deployment                                   | 8  |\\n| Installatio\", \"n                                 | 8  |\\n| What's new with .NET for Desktop?            | 9  |\\n| The\", \" motivation behind .NET Core              | 9  |\\n| Introduction to .NET Core                    | 11\", \" |\\n| .NET 5+ is .NET Core vNext                   | 11 |\\n| .NET Framework vsNET                     \", \"    | 12 |\\n| .NET Standard vs. PCL                        | 13 |\\n| New Desktop features in .NET     \", \"            | 14 |\\n| Support for Windows Forms and WPF            | 14 |\\n| XAML Islands             \", \"                    | 14 |\\n| Access to all Windows 10 and Windows 11 APIs | 15 |\\n| Side-by-side supp\", \"ort and self-contained EXEs | 15 |\\n| Performance                                  | 15 |\\n| Migrating\", \" Modern Desktop applications        | 16 |\\n| Configuration files                          | 16 |\\n| C\", \"onfiguration on .NET Framework              | 16 |\\n\\n| Configuration on .NET                         \", \"|    |\\n|-----------------------------------------------|----|\\n| Migrating configuration files       \", \"          | 17 |\\n| Accessing databases                           |    |\\n| ODBC                      \", \"                    | 19 |\\n| OLE DB                                        | 19 |\\n| ADO.NET         \", \"                              | 19 |\\n| EF Core vs. EF6                               | 19 |\\n| Relati\", \"onal databases                          | 20 |\\n| Consuming services                            | 20 \", \"|\\n| Consuming a COM Object                        | 21 |\\n| More things to consider                  \", \"     | 21 |\\n| AppDomains                                    | 21 |\\n| Remoting                       \", \"               | 21 |\\n| Code Access Security (CAS)                    | 22 |\\n| Security Transparency\", \"                         | 22 |\\n| Windows 10 migration                          | 23 |\\n| WinRT APIs \", \"                                   | 23 |\\n| Universal Windows Platform (UWP) packages     | 24 |\\n| H\", \"ow to add WinRT APIs to your desktop project | 26 |\\n| XAML Islands                                  \", \"| 34 |\\n| The road to XAML Islands                      | 35 |\\n| How it works                        \", \"          | 35 |\\n| Do you need XAML Islands                      | 38 |\\n| The road ahead XAML Island\", \"s: WinUI 3.0        | 38 |\\n| Example of migrating to the latest .NET       | 41 |\\n| Migrating from .\", \"NET Core or .NET 5            | 41 |\\n| Migrating from .NET Framework                 | 42 |\\n| Migrat\", \"ing with a tool                         | 42 |\\n| Migrating by hand                             |    \", \"|\\n| Preparation                                   |    |\\n| Fix the code and build                   \", \"     | 45 |\\n| Run and test                                  | 46 |\\n\\n| Migrating a Windows Forms appl\", \"ication                                    | 46 |\\n|-------------------------------------------------\", \"-------------------------|----|\\n| Migrating a WPF application                                       \", \"       | 52 |\\n| Deploying Modern Desktop Applications                                    | 55 |\\n| Th\", \"e modern application lifecycle                                         | 56 |\\n| MSIX: The next gener\", \"ation of deployment                                  | 58 |\\n| Benefits of MSIX                      \", \"                                   | 59 |\\n| Tools                                                   \", \"                 | 61 |\\n| How to create an MSIX package from an existing Win32 desktop application |\", \" 62 |\\n| Auto Updates in MSIX                                                     | 70 |\\n\\n**CHAPTER**\", \" 1\\n\\n# <span id=\\\"page-7-0\\\"></span>Why modern desktop applications\\n\\n# <span id=\\\"page-7-1\\\"></span>Intro\", \"duction\\n\\n### <span id=\\\"page-7-2\\\"></span>**A story of one company**\\n\\nBack in the early 2000s, one mul\", \"tinational company started developing a distributed desktop solution to exchange information between\", \" different branches of the company and execute optimized operations on centralized units. They have \", \"chosen a brand-new framework called Windows Forms (also known as WinForms) for their application dev\", \"elopment. Over the years, the project evolved into a mature, well-tested, and time-proven applicatio\", \"n with hundreds of thousands of lines of code. Time passed and .NET Framework 2.0 is no longer the h\", \"ot new technology. The developers who are working on this application are facing a dilemma. They'd l\", \"ike to use the latest stack of technologies in their development and have their application look and\", \" \\\"feel\\\" modern. At the same time, they don't want to throw away the great product they have built ov\", \"er 15 years and rewrite the entire application from scratch.\\n\\n## <span id=\\\"page-7-3\\\"></span>**Your s\", \"tory**\\n\\nYou might find yourself in the same boat, where you have mature Windows Forms or Windows Pre\", \"sentation Foundation (WPF) applications that have proved their reliability over the years. You proba\", \"bly want to keep using these applications for many more years. At the same time, since those applica\", \"tions were written some time ago, they might be missing capabilities like modern look, performance, \", \"integration with new devices and platform features, and so on, which gives them a feel of \\\"old tech\\\"\", \". There's another problem that might concern you as a developer. While working on the older .NET Fra\", \"mework versions and maintaining applications that were written a while ago, you might feel like you \", \"aren't learning new technologies and missing out on building modern technical skills. If that is you\", \"r story \\u2013 this book is for you!\\n\\n# <span id=\\\"page-7-4\\\"></span>Desktop applications nowadays\\n\\nBefore \", \"the rise of the Internet, desktop applications were the main approach to building software systems. \", \"Developers could choose any programming language, such as COBOL, Fortran, VB6, or C++. But whether t\", \"hey developed small tools or complex distributed architectures, they were all desktop applications.\\n\", \"\\nThen, Internet technologies started shocking the development world and winning over more engineers \", \"with advantages like easy deployment and simplified distribution processes. The fact that once a web\", \" application was deployed to production all users got automatic updates made a huge impact on softwa\", \"re agility.\\n\\nHowever, the Internet infrastructure, underlying protocols, and standards like HTTP and\", \" HTML weren't designed for building complex applications. In fact, the major development effort back\", \" then was aimed at just one goal: to give web applications the same capabilities that desktop applic\", \"ations have, such as fast data input and state management.\\n\\nEven though web and mobile applications \", \"have grown at an incredible pace, for certain tasks desktop applications still hold the number one p\", \"lace in terms of efficiency and performance. That explains why there are millions of developers who \", \"are building their projects with WPF and WinForms and the amount of those applications is constantly\", \" growing.\\n\\nHere are some reasons for choosing desktop applications in your development:\\n\\n- Desktop a\", \"pps have better interaction with the user's PC.\\n- The performance of desktop applications for comple\", \"x calculations is much higher than the performance of web applications.\\n- Running custom logic on th\", \"e client-side is possible but much harder with a web application.\\n- Using multithreading is easier a\", \"nd more efficient in a desktop application.\\n- The learning curve for designing user interfaces (UIs)\", \" isn't steep. And for WinForms, it's intuitive with the drag-and-drop experience of the Windows Form\", \"s designer.\\n- It's easy to start coding and testing your algorithms without the need to set up a ser\", \"ver infrastructure or to care about connectivity problems, firewalls, and browser compatibility.\\n- D\", \"ebugging is powerful as compared to web debugging.\\n- Access to hardware devices, such as camera, Blu\", \"etooth, or card readers, is easy.\\n- Since the technology has been around for a while, there are many\", \" experts and a knowledge base available to develop desktop applications.\\n\\nSo, as you can see, develo\", \"ping for desktop is great for many reasons. The technology is mature and time-tested, the developmen\", \"t cycle is fast, the debugging is powerful and arguably, desktop apps have less complexity and are e\", \"asier to get started with.\\n\\nMicrosoft offered many UI desktop technologies throughout the years from\", \" Win32 introduced in 1995 to Universal Windows Platform (UWP) released in 2016.\\n\\n![](_page_9_Figure_\", \"0.jpeg)\\n\\nAccording to a survey published by Telerik on April 2016, the most popular technologies for\", \" building Windows desktop apps are Windows Forms, WPF, and UWP.\\n\\n![](_page_9_Figure_2.jpeg)\\n\\nYou can\", \" develop in any of them using C# and Visual Basic, but let's take a closer look.\\n\\n#### <span id=\\\"pag\", \"e-9-0\\\"></span>**Windows Forms**\\n\\nFirst released in 2002, Windows Forms is a managed framework and is\", \" the oldest, most-used desktop technology built on the Windows graphics device interface (GDI) engin\", \"e. It offers a smooth drag-anddrop experience for developing user interfaces in Visual Studio. At th\", \"e same time, Windows Forms relies on the Visual Studio Designer as the main way you develop your UI,\", \" so creating visual components from code isn't trivial.\\n\\nThe following list summarizes the main char\", \"acteristics of Windows Forms:\\n\\n- Mature technology with lots of code samples and documentation.\\n- Po\", \"werful and productive designer. Not so convenient to design UI \\\"from code\\\".\\n- Easy and intuitive to \", \"learn, thanks to the designer's drag-and-drop experience.\\n- Supported on any Windows version.\\n- Supp\", \"orted on .NET Core 3.0 and later versions.\\n\\n#### <span id=\\\"page-10-0\\\"></span>**WPF**\\n\\nBased on the X\", \"AML language specification, WPF favors a clear separation between UI and code. XAML offers capabilit\", \"ies like templating, styling, and binding, which is suited for building large applications. Like Win\", \"dows Forms, it's a managed framework, but the design is modular and reusable.\\n\\nHere are the main fea\", \"tures of WPF:\\n\\n- Mature technology.\\n- Designer is available, but developers usually prefer to create\", \" the design from code using declarative XAML.\\n- The learning curve is steeper than Windows Forms.\\n- \", \"Supported on any Windows version.\\n- Supported on .NET Core 3.0 and later versions.\\n\\n#### <span id=\\\"p\", \"age-10-1\\\"></span>**UWP**\\n\\nUWP isn't only a presentation framework like WPF and Windows Forms, but it\", \"'s also a platform itself. This platform has:\\n\\n- Its own API set (the Windows Runtime API).\\n- A new \", \"deployment system (MSIX)\\n- A modern application lifecycle model (for low battery consumption).\\n- A n\", \"ew Resource Management System (based on PRI files).\\n\\nThe platform was created to support all kinds o\", \"f input systems (like ink, touch, gamepad, mouse, keyboard, gaze, and so on) in all form-factors wit\", \"h performance and low battery consumption in mind. For these reasons, the shell of the Windows 10 OS\", \" uses parts of the UWP platform.\\n\\n![](_page_11_Picture_0.jpeg)\\n\\nUWP contains a presentation framewor\", \"k that is XAML-based, like WPF, but it has some important differences such as:\\n\\n- Applications are e\", \"xecuted in app containers. App containers control what resources a UWP app can access.\\n- Supported o\", \"nly on Windows 10 and Windows 11.\\n- Apps can be deployed through Microsoft Store for easier deployme\", \"nt.\\n- Designed as part of the Windows Runtime API.\\n- Contains an extensive set of rich built-in cont\", \"rols and additional controls are available through the Microsoft UI Library NuGet packages (WinUI li\", \"brary), updated every few months.\\n\\n# <span id=\\\"page-11-0\\\"></span>A tale of two platforms\\n\\nIn the las\", \"t 20 years, while UI desktop technologies were growing and following the path from Windows Forms to \", \"UWP, the hardware was also evolving from heavyweight PC units with small CRT monitors to high-DPI mo\", \"nitors and lightweight tablets and phones with different data input techniques like Touch and Ink. T\", \"hese changes resulted in creating two different concepts: a Desktop Application and a Modern Applica\", \"tion. A Modern Application is one that considers different device form factors, various input and ou\", \"tput methods, and leverages modern desktop features while running on a sandboxed execution model. Th\", \"e (traditional) Desktop Application, on the other hand, is an application that needs a solid UI with\", \" a high density of controls that is best operated with a mouse and a keyboard.\\n\\nThe following table \", \"describes the differences between the two concepts:\\n\\n| Aspect of comparison | Modern Application    \", \"                                                                                                    \", \"                                              | Desktop Application                                 \", \"                                                                                       |\\n|----------\", \"------------|---------------------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------|-----------------\", \"----------------------------------------------------------------------------------------------------\", \"-----------------------|\\n| Security             | Contained execution & Great<br>Fundamentals. Desig\", \"ned from<br>the ground up to respect user's<br>privacy, manage battery life,<br>and focus to keep th\", \"e device<br>safe. | User & Admin level of security.<br>You have native access to the<br>registry and\", \" hard drive folders.                                       |\\n| Deployment           | Installation a\", \"nd updates are<br>managed by the platform.                                                          \", \"                                                      | MSI, Custom installers &<br>Updates. Traditi\", \"onally a source<br>of headaches for developers<br>and IT managers.                             |\\n| D\", \"istribution         | Trusted Distribution & Signed<br>Packages. Distribution is<br>performed from a\", \" trusted<br>source and never from the<br>web.                                             | Web, SCC\", \"M & Custom<br>distribution. No control over<br>what is installed, affects the<br>whole machine.     \", \"                               |\\n| UI                   | Modern UI. Different input<br>mechanisms, \", \"ink, touch,<br>gamepad, keyboard, mouse,<br>etc.                                                    \", \"                          | Windows Forms, WPF, MFC.<br>Designed for the mouse and<br>keyboard for a\", \" dense UI and to<br>get the most productivity from<br>the desktop. |\\n| Data                 | Cloud \", \"First Data with Insights.<br>Source of truth in the cloud.<br>Insights to know what happens<br>with \", \"your app and how it's<br>performing.                          | Local Data. Traditional desktop<br>a\", \"pplications usually need some<br>local data.                                                        \", \"   |\\n| Design               | Designed for reuse. Reuse in<br>mind between different<br>platforms, f\", \"ront end, and back<br>end, running assets in many<br>places as possible.                          | \", \"Designed for Windows<br>Desktop only                                                                \", \"                                       |\\n\\nAs a part of the commitment to provide developers with the\", \" best tools to build applications, Microsoft put forth a great effort to bring these concepts - or w\", \"e can even say platforms - closer together to empower developers with the best of both worlds. To do\", \" that, Microsoft has performed a bidirectional effort between the two platforms.\\n\\n![](_page_13_Pictu\", \"re_1.jpeg)\\n\\n1. Move Desktop Application scenarios into Modern Application platform. The traditional \", \"desktop development is still popular because it addresses certain scenarios well. It makes sense to \", \"take these common desktop scenarios and bring them into the modern desktop platform to make the plat\", \"form fully capable.\\n\\n![](_page_13_Picture_3.jpeg)\\n\\n1. Move Modern Application features into Desktop \", \"Applications. For existing desktop apps that need a way to leverage modern capabilities without rewr\", \"iting from scratch, features from the Modern Application platform are pushed into the Desktop Applic\", \"ation.\\n\\n![](_page_13_Picture_5.jpeg)\\n\\nIn this book, we'll focus on the second part and show how you \", \"can modernize your existing desktop applications.\\n\\n# <span id=\\\"page-14-0\\\"></span>Paths to modernizat\", \"ion\\n\\nThe structure of this guide reflects three different axes to accomplish modernization: Modern F\", \"eatures, Deployment, and Installation.\\n\\n#### <span id=\\\"page-14-1\\\"></span>**Modern features**\\n\\nSay yo\", \"u have a working Windows Forms application that a sales representative of your company uses to fill \", \"in a customer order. A new requirement comes in to enable the customer to sign the order using a tab\", \"let pen. Inking is native in today's operating systems and technologies, but it wasn't available whe\", \"n the app was developed.\\n\\nThis path will show you how you can leverage modern desktop features into \", \"your existing desktop development.\\n\\n## <span id=\\\"page-14-2\\\"></span>**Deployment**\\n\\nModern developmen\", \"t cycles have stressed the importance of providing agility with regard to how new versions of applic\", \"ations are deployed to individual users. Since Windows Forms and WPF applications are based on a par\", \"ticular version of the .NET Framework that must be present on the machine, they can't take advantage\", \" of new .NET Framework version features without the intervention of the IT people with the risk of h\", \"aving side effects for other apps running on the same machine. It has limited the innovation pace fo\", \"r developers forcing them to stay on outdated versions of the .NET Framework.\\n\\nSince the launch of .\", \"NET Core 3.0, you can leverage a new approach of deploying multiple versions of .NET side by side an\", \"d specifying which version of .NET each application should target. This way, you can use the newest \", \"features in one application while being confident you aren't going to break any other applications.\\n\", \"\\n#### <span id=\\\"page-14-3\\\"></span>**Installation**\\n\\nDesktop applications always rely on some sort of\", \" installation process before the user can start using them. This fact brought into the game a set of\", \" technologies, from MSI and ClickOnce to custom installers or even XCOPY deployment. Any of these me\", \"thods deals with delicate problems because applications need a way to access shared resources on the\", \" machine. Sometimes installation needs to access the Registry to insert or update new Key Values, so\", \"metimes to update shared DLLs referenced by the main application. This behavior causes a continuous \", \"headache for users, creating this perception that once you install some application, your computer w\", \"ill never be the same, even if you uninstall it afterwards.\\n\\nIn this book, we'll introduce a new way\", \" of installing applications with MSIX that solves the problem described earlier. You'll learn how yo\", \"u can easily set up packaging, installation, and updates for your application.\\n\\n**CHAPTER** 2\\n\\n# <sp\", \"an id=\\\"page-15-0\\\"></span>What's new with .NET for Desktop?\\n\\nDesktop applications such as Windows For\", \"ms and WPF can be built using various .NET implementations, for example, .NET Framework or .NET 7. I\", \"n this chapter, we'll talk about the history of each implementation, explain the differences, and sh\", \"ow what new features await desktop developers in newer implementations.\\n\\nIf you've been developing W\", \"indows Forms or WPF applications for a long time, you're familiar with .NET Framework. Later, .NET C\", \"ore (specifically its 3.0 version) started supporting desktop applications. .NET Core was rebranded \", \"to .NET when .NET 5 was released. Just as there are different versions of .NET Framework, for exampl\", \"e, 4.6, 4.7, and 4.8, there are also different versions of .NET Core: .NET Core 3.0, .NET 5, .NET 6,\", \" .NET 7, and so on.\\n\\n<span id=\\\"page-15-1\\\"></span>Let's look into the history of each implementation \", \"to understand the differences and benefits of each.\\n\\n# The motivation behind .NET Core\\n\\nSince its la\", \"unch in 2002, .NET Framework has evolved to support many technologies, like Windows Forms, ASP.NET, \", \"Entity Framework, Windows Store, and many others. All of them are different in nature. Therefore, Mi\", \"crosoft approached this evolution by taking parts of .NET Framework and creating a different applica\", \"tion stack for each technology. That way, development capabilities could be customized for the needs\", \" of the specific stack, which maximized the potential of every platform. That led to fragmentation o\", \"n the versions of .NET Framework maintained by different independent teams. All of these stacks have\", \" a common structure, containing an app model, a framework, and a runtime, but they differ in the imp\", \"lementation of each of the parts.\\n\\nIf you're targeting only one of these platforms, you can use this\", \" model. However, in many cases you might need more than one target platform in the same solution. Fo\", \"r example, your application may have a desktop admin part, a customer-facing web site that shares th\", \"e back-end logic running on a server, and even a mobile client. In this case, you need a unified cod\", \"ing experience that can span all of these .NET verticals.\\n\\nBy the time Windows 8 was released, the c\", \"oncept of Portable Class Libraries (PCLs) was born. Originally, .NET Framework was designed around t\", \"he assumption that it would always be deployed as a single unit, so [factoring](https://wikipedia.or\", \"g/wiki/Decomposition_(computer_science)) wasn't a concern. To face the problem of code sharing betwe\", \"en verticals, the driving force was on how to refactor the framework. The idea of contracts is to pr\", \"ovide a well-factored API surface area. Contracts are simply assemblies that you compile against and\", \" are designed with proper factoring in mind taking care of the dependencies between them.\\n\\nThis led \", \"to reasoning about the API differences between verticals at the assembly level, as opposed to at the\", \" individual API level like previously. This aspect enabled a class library experience that can targe\", \"t multiple verticals, also known as portable class libraries.\\n\\n![](_page_16_Figure_2.jpeg)\\n\\nWith PCL\", \", the experience of development is unified across verticals based on the API shape. And the most pre\", \"ssing need to create libraries running on different verticals is also addressed. But there's a great\", \" challenge: APIs are only portable when the implementation is moved forward across all the verticals\", \".\\n\\nA better approach is to unify the implementations across verticals by providing a well-factored i\", \"mplementation instead of a well-factored view. It's a lot simpler to ask each team that owns a speci\", \"fic component to think about how their APIs work across all verticals than trying to retroactively p\", \"rovide a consistent API stack on top. This is where .NET Standard comes in.\\n\\nAnother large challenge\", \" has to do with how .NET Framework is deployed. .NET Framework is a machine-wide framework. Any chan\", \"ges made to it affect all applications that take a dependency on it. Although this deployment model \", \"has many advantages, such as reducing disk space and centralized access to services, it presents som\", \"e pitfalls.\\n\\nTo start with, it's difficult for application developers to take a dependency on a rece\", \"ntly released framework. They either have to take a dependency on the latest OS or provide an applic\", \"ation installer that installs .NET Framework along with the application. If you're a web developer, \", \"you might not even have this option as the IT department establishes the server supported version.\\n\\n\", \"Even if you're willing to go through the trouble of providing an installer to chain in .NET Framewor\", \"k setup, you may find that upgrading .NET Framework can break other applications.\\n\\nDespite the effor\", \"ts to provide backward compatible versions of the framework, there are compatible changes that can b\", \"reak applications. For example, adding an interface to an existing type can change how this type is \", \"serialized and cause breaking problems depending on the existing code. Because the .NET Framework in\", \"stalled base is huge, fighting against these breaking scenarios slows down the pace of innovations i\", \"nside .NET Framework.\\n\\nTo solve all these issues, Microsoft developed .NET Core as the evolution of \", \"the .NET development platform.\\n\\n# <span id=\\\"page-17-0\\\"></span>Introduction to .NET Core\\n\\n.NET Core, \", \"which is now referred to as just \\\".NET\\\", is the evolution of Microsoft's .NET technology into a modu\", \"lar, cross-platform, open source, and cloud-ready platform. It runs on Windows, macOS, and Linux, an\", \"d some ARM-based architectures like Android and IoT.\\n\\nThe purpose of .NET Core is to provide a unifi\", \"ed platform for all types of applications, which includes Windows, cross-platform, and mobile applic\", \"ations. [.NET Standard](https://docs.microsoft.com/dotnet/standard/net-standard) enabled this by pro\", \"viding shared base APIs, which every application model needs, and excluding any application model-sp\", \"ecific API.\\n\\nThis framework gives applications many benefits in terms of efficiency and performance,\", \" simplifying the packaging and deployment in the different supported platforms.\\n\\nThe benefits of .NE\", \"T Core come from these three characteristics:\\n\\n- **Cross-platform:** It allows application execution\", \" on different platforms (Windows, macOS, and Linux).\\n- **Open source:** .NET Core platform is open s\", \"ource and available through GitHub, fostering transparency and community contributions.\\n- **Supporte\", \"d:** Microsoft officially supports .NET Core.\\n\\nStarting with .NET Core 3.0, besides the existing sup\", \"port for web and cloud, there's also support for desktop, IoT, and AI domains. The goal for this fra\", \"mework is impressive: to target every type of .NET development present and future.\\n\\n# <span id=\\\"page\", \"-17-1\\\"></span>.NET 5+ is .NET Core vNext\\n\\n.NET 5 was the next step forward with .NET Core. .NET 5 im\", \"proved .NET in a few key ways:\\n\\n- Produced a single .NET runtime and framework that can be used ever\", \"ywhere and that has uniform runtime behaviors and developer experiences.\\n- Expanded the capabilities\", \" of .NET by taking the best of .NET Core, .NET Framework, Xamarin, and Mono.\\n- Built that product ou\", \"t of a single code-base that developers (Microsoft and the community) can work on and expand togethe\", \"r and that improves all scenarios.\\n\\n.NET 5 was a game-changer for .NET. With .NET 5 and later versio\", \"ns, your code and project files look and feel the same no matter which type of app you're building. \", \"You have access to the same runtime, APIs, and language capabilities with each app. This includes ne\", \"w performance improvements that get committed to the runtime almost daily. .NET 6 and .NET 7 made fu\", \"rther improvements in reliability, performance, new APIs, and language features. For more details, s\", \"ee [What's new in .NET 5](https://docs.microsoft.com/dotnet/core/whats-new/dotnet-5), [What's](https\", \"://docs.microsoft.com/dotnet/core/whats-new/dotnet-6)  [new in .NET 6,](https://docs.microsoft.com/d\", \"otnet/core/whats-new/dotnet-6) and [What's new in .NET 7](https://docs.microsoft.com/dotnet/core/wha\", \"ts-new/dotnet-7).\\n\\n![](_page_18_Figure_1.jpeg)\\n\\n# <span id=\\\"page-18-0\\\"></span>.NET Framework vs. .NE\", \"T\\n\\nSo now that you understand the relevance of .NET, you might be wondering what happens with .NET F\", \"ramework. You could be asking questions like: Do I have to abandon it? Is it going to disappear? Wha\", \"t are my choices to modernize the applications I have on .NET Framework?\\n\\nIn 2019, .NET Framework 4.\", \"8 was released. It included three major improvements for desktop applications:\\n\\n- **Modern browser a\", \"nd media controls**: New controls were added that take advantage of Microsoft Edge and newer media p\", \"layers that support the latest standards.\\n- **Access to UWP controls**: UWP introduced controls that\", \" take advantage of the latest Windows features and touch displays. With .NET Framework 4.8, you don'\", \"t have to rewrite your applications to use these new features and controls, so you can use these new\", \" features in your existing WPF or Windows Forms code.\\n- **High-DPI improvements**: The resolution of\", \" displays increased to 4K and 8K, so, .NET Framework 4.8 added new HDPI improvements to make sure ex\", \"isting Windows Forms and WPF applications can look great on these new displays.\\n\\nSince .NET Framewor\", \"k is installed on millions of machines, Microsoft will continue to support it but won't add new feat\", \"ures.\\n\\n.NET (Core) is the open-source, cross-platform, and fast-moving version of the .NET family. B\", \"ecause of its side-by-side nature, it can take changes without the fear of breaking any application.\", \" This means that .NET will get new APIs and language features over time that .NET Framework won't. A\", \"lso, .NET already has features that were impossible for .NET Framework, such as:\\n\\n\\u2022 **Side-by-side v\", \"ersions of .NET supporting Windows Forms and WPF**: This solves the problem of side effects when upd\", \"ating the machine's framework version. Multiple versions of .NET can be installed on the same machin\", \"e and each application specifies which version of\\n\\n.NET it should use. Even more, now you can develo\", \"p and run Windows Forms and WPF on top of .NET.\\n\\n- **Embed .NET directly into an application**: You \", \"can deploy .NET as part of your application package. This enables you to take advantage of the lates\", \"t version, features, and APIs without having to wait for a specific version to be installed on the m\", \"achine.\\n- **Take advantage of .NET features**: .NET is fast-moving and open-source. Its side-by-side\", \" nature enables fast introduction of new innovative APIs and Base Class Library (BCL) improvements w\", \"ithout the risk of breaking compatibility. Now Windows Forms and WPF applications can take advantage\", \" of the latest .NET features, which also includes fundamental fixes for things like runtime performa\", \"nce and high-DPI support.\\n\\n.NET Framework will be fully supported and will always be a part of Windo\", \"ws. However, if you want to use the newest language features and APIs in the future, you'll need to \", \"move your applications to .NET. For brand-new desktop apps, we recommend starting directly on .NET 6\", \" or a later version. It's lightweight and cross-platform, runs side by side, has high performance, a\", \"nd fits perfectly on containers and microservices architectures.\\n\\n![](_page_19_Figure_4.jpeg)\\n\\n# <sp\", \"an id=\\\"page-19-0\\\"></span>.NET Standard vs. PCL\\n\\n[.NET Standard](https://docs.microsoft.com/dotnet/st\", \"andard/net-standard) is a formal specification of .NET APIs that are intended to be available on all\", \" .NET implementations. The motivation behind .NET Standard was to establish greater uniformity in th\", \"e .NET ecosystem. .NET Standard is a specification of .NET APIs that make up a uniform set of contra\", \"cts to compile your code against. These contracts are implemented in each .NET flavor, thus enabling\", \" portability across different .NET implementations.\\n\\n.NET Standard enables the following key scenari\", \"os:\\n\\n- Defines uniform set of base class libraries APIs for all .NET implementations to implement, i\", \"ndependent of the workload.\\n- Enables developers to produce portable libraries that are usable acros\", \"s .NET implementations, using this same set of APIs.\\n\\n.NET Standard is the evolution of PCLs and the\", \" following list shows the fundamental differences between .NET Standard and PCLs:\\n\\n- .NET Standard i\", \"s a set of curated APIs, picked by Microsoft. PCLs aren't.\\n- The APIs that a PCL contains are depend\", \"ent on the platforms that you choose to target when you create it. This makes a PCL only sharable fo\", \"r the specific targets that you choose.\\n- .NET Standard is platform-agnostic, so it can run on Windo\", \"ws, macOS, and Linux.\\n- PCLs can also run cross-platform, but they can only target a limited set of \", \"platforms.\\n\\n# <span id=\\\"page-20-0\\\"></span>New Desktop features in .NET\\n\\n## <span id=\\\"page-20-1\\\"></sp\", \"an>**Support for Windows Forms and WPF**\\n\\nWindows Forms and WPF are part of .NET Core since version \", \"3.0. Both presentation frameworks are for Windows only, so they aren't cross-platform. You can think\", \" of WPF as a rich layer over DirectX and Windows Forms as a thinner layer over GDI+. WPF and Windows\", \" Forms do a great job of exposing and exercising much of the desktop application functionality in Wi\", \"ndows. So Windows Forms and WPF are available for .NET Core and .NET Framework. Target your new desk\", \"top applications to .NET 6 or later, and migrate your existing apps from .NET Framework to .NET 6 or\", \" later.\\n\\nA new version of .NET Standard, version 2.1, was released at the same time as .NET Core 3.0\", \". To see which .NET implementations support which .NET Standard versions, see [Which .NET Standard v\", \"ersion](https://docs.microsoft.com/dotnet/standard/net-standard#net-standard-versions)  [to target.]\", \"(https://docs.microsoft.com/dotnet/standard/net-standard#net-standard-versions)\\n\\nThe .NET (Core) imp\", \"lementations for both Windows Forms and WPF are open source.\\n\\n#### <span id=\\\"page-20-2\\\"></span>**XAM\", \"L Islands**\\n\\n[XAML Islands](https://docs.microsoft.com/windows/apps/desktop/modernize/xaml-islands) \", \"is a set of components for developers to use Windows 10 controls (UWP XAML controls) in their WPF, W\", \"indows Forms, and native Win32 apps (like MFC). You can have your \\\"islands\\\" of UWP XAML controls whe\", \"rever you want inside your Win32 apps.\\n\\nThese XAML Islands are possible because Windows 10, version \", \"1903 introduced a set of APIs that allows hosting UWP XAML content in Win32 windows using windows ha\", \"ndlers (HWnds). Only apps running on Windows 10 1903 and later can use XAML Islands.\\n\\nTo make it eas\", \"ier to create XAML Islands for Windows Forms and WPF developers, the Windows Community Toolkit intro\", \"duces a set of .NET wrappers in several NuGet packages. Those wrappers are the wrapped and hosting c\", \"ontrols:\\n\\n- The [WebView,](https://docs.microsoft.com/windows/communitytoolkit/controls/wpf-winforms\", \"/webview) [WebViewCompatible,](https://docs.microsoft.com/windows/communitytoolkit/controls/wpf-winf\", \"orms/webviewcompatible) [InkCanvas,](https://docs.microsoft.com/windows/communitytoolkit/controls/wp\", \"f-winforms/inkcanvas) [MediaPlayerElement,](https://docs.microsoft.com/windows/communitytoolkit/cont\", \"rols/wpf-winforms/mediaplayerelement) and [MapControl](https://docs.microsoft.com/windows/communityt\", \"oolkit/controls/wpf-winforms/mapcontrol) wrapped controls wrap some UWP XAML controls into Windows F\", \"orms or WPF controls, hiding UWP concepts for those developers.\\n- The [WindowsXamlHost](https://docs\", \".microsoft.com/windows/communitytoolkit/controls/wpf-winforms/windowsxamlhost) control for Windows F\", \"orms and WPF allows other not-wrapped UWP XAML controls and custom controls to be loaded into a XAML\", \" Island.\\n\\n#### <span id=\\\"page-21-0\\\"></span>**Access to all Windows 10 and Windows 11 APIs**\\n\\nWindows\", \" 10 and Windows 11 have a large number of APIs available for developers to work with. These APIs giv\", \"e access to a wide variety of functionality like authentication, bluetooth, appointments, and contac\", \"ts. Now these APIs are exposed through .NET and give Windows developers the chance to create powerfu\", \"l desktops apps using the capabilities present on Windows 10 and Windows 11.\\n\\n#### <span id=\\\"page-21\", \"-1\\\"></span>**Side-by-side support and self-contained EXEs**\\n\\nThe .NET deployment model is one of the\", \" biggest benefits that Windows desktop developers will experience with .NET. The ability to globally\", \" install .NET provides much of the same central installation and servicing benefits of .NET Framewor\", \"k, while not requiring in-place updates.\\n\\nWhen a new .NET version is released, you can update each a\", \"pp on a machine as needed without any concern of affecting other applications. New .NET versions are\", \" installed in their own directories and exist \\\"side-by-side\\\" with each other.\\n\\nIf you need to deploy\", \" with isolation, you can deploy .NET with your application. .NET will bundle your app with the .NET \", \"runtime as a single executable. The modular architecture used by .NET makes these flexible deploymen\", \"t options possible.\\n\\n## <span id=\\\"page-21-2\\\"></span>**Performance**\\n\\nSince its start, targeting the \", \"web and cloud workloads, .NET has had performance plugged into its DNA. Server-side code must be per\", \"formant enough to fulfill high-concurrency scenarios and .NET 7 scores today as the best performance\", \" web platform in the market.\\n\\nOld Windows Forms code has been refactored for .NET, which reduced mem\", \"ory allocations for drawing Forms and Controls. By simply upgrading from .NET Framework to .NET or l\", \"ater, your applications become much faster. You can take advantage of these performance improvements\", \" when you use .NET to build your next generation of desktop applications.\\n\\n# <span id=\\\"page-22-0\\\"></\", \"span>Migrating Modern Desktop applications\\n\\nIn this chapter, we're exploring the most common issues \", \"and challenges you can face when migrating an existing application from .NET Framework to .NET.\\n\\nIf \", \"you just want to update your application to the latest .NET version using a tool and not get into th\", \"e details of what's happening behind the scenes, feel free to skip this chapter and find step-by-ste\", \"p instructions in the [Example of migrating to .NET](#page-47-0) chapter.\\n\\nA complex desktop applica\", \"tion doesn't work in isolation and needs some kind of interaction with subsystems that may reside on\", \" the local machine or on a remote server. It will probably need some kind of database to connect wit\", \"h as a persistence store either locally or remotely. With the rise of Internet and service-oriented \", \"architectures, it's common to have your application connected to some sort of service residing on a \", \"remote server or in the cloud. You may need to access the machine file system to implement some func\", \"tionality. Alternatively, maybe you're using a piece of functionality that resides inside a COM obje\", \"ct outside your application, which is a common scenario if, for example, you're integrating Office a\", \"ssemblies in your app.\\n\\nBesides, there are differences in the API surface that is exposed by .NET Fr\", \"amework and .NET, and some features that are available on .NET Framework aren't available on .NET. I\", \"t's important for you to know and take them into account when planning a migration.\\n\\n# <span id=\\\"pag\", \"e-22-1\\\"></span>Configuration files\\n\\nConfiguration files offer the possibility to store sets of prope\", \"rties that are read at run time and can affect the behavior of your app, such as where to locate a d\", \"atabase or how many times to execute a loop. The beauty of this technique is that you can modify som\", \"e aspects of the application without the need to recode and recompile. This comes in handy when, for\", \" example, the same app code runs on a development environment with a certain set of configuration va\", \"lues and in production environment with a different set.\\n\\n### <span id=\\\"page-22-2\\\"></span>**Configur\", \"ation on .NET Framework**\\n\\nIf you have a working .NET Framework desktop application, chances are you\", \" have an *app.config* file accessed through the [AppSettingsSection](https://docs.microsoft.com/dotn\", \"et/api/system.configuration.appsettingssection) class from the System.Configuration namespace.\\n\\nWith\", \"in the .NET Framework infrastructure, there's a hierarchy of configuration files that inherit proper\", \"ties from its parents. You can find a *machine.config* file that defines many properties and configu\", \"ration sections that can be used or overridden in any descendant configuration file.\\n\\n## <span id=\\\"p\", \"age-23-0\\\"></span>**Configuration on .NET**\\n\\nIn the .NET world, there's no *machine.config* file. And\", \" even though you can continue to use the old fashioned [System.Configuration](https://docs.microsoft\", \".com/dotnet/api/system.configuration) namespace, you may consider switching to the modern [Microsoft\", \".Extensions.Configuration,](https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration\", \") which offers a good number of enhancements.\\n\\nThis configuration API supports the concept of a conf\", \"iguration provider, which defines the data source to be used to load the configuration. There are di\", \"fferent kinds of built-in providers, such as:\\n\\n- In-memory .NET objects\\n- INI files\\n- JSON files\\n- X\", \"ML files\\n- Command-line arguments\\n- Environment variables\\n- Encrypted user store\\n\\nOr you can build y\", \"our own.\\n\\nThe new configuration API allows a list of name-value pairs that can be grouped into a mul\", \"ti-level hierarchy. Any stored value maps to a string, and there's built-in binding support that all\", \"ows you to deserialize settings into a custom plain old CLR object (POCO).\\n\\nThe [ConfigurationBuilde\", \"r](https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.configurationbuilder) ob\", \"ject lets you add as many configuration providers as you may need for your application. A precedence\", \" rule is used to resolve provider preference. So, the last provider you add in your code overrides t\", \"he others. This is a great feature for managing different environments for execution since you can d\", \"efine different configurations for development, testing, and production environments. And you can ma\", \"nage them in a single function inside your code.\\n\\n## <span id=\\\"page-23-1\\\"></span>**Migrating configu\", \"ration files**\\n\\nYou can continue to use your existing app.config XML file. However, you could take t\", \"his opportunity to migrate your configuration to benefit from the several enhancements made in .NET.\", \"\\n\\nTo migrate from an old-style *app.config* to a new configuration file, you should choose between a\", \"n XML format and a JSON format.\\n\\nIf you choose XML, the conversion is straightforward. Since the con\", \"tent is the same, just save the *app.config* file with XML as type. Then, change the code that refer\", \"ences AppSettings to use the [ConfigurationBuilder](https://docs.microsoft.com/dotnet/api/microsoft.\", \"extensions.configuration.configurationbuilder) class. This change should be easy.\\n\\nIf you want to us\", \"e a JSON format and you don't want to migrate by hand, there's a tool called [dotnet](https://www.nu\", \"get.org/packages/dotnet-config2json/)[config2json](https://www.nuget.org/packages/dotnet-config2json\", \"/) that can convert an *app.config* file to a JSON configuration file.\\n\\nYou may come across some iss\", \"ues when using configuration sections that were defined in the *machine.config* file. For example, c\", \"onsider the following configuration:\\n\\n```\\n<configuration>\\n <system.diagnostics>\\n <switches>\\n <add na\", \"me=\\\"General\\\" value=\\\"4\\\" />\\n </switches>\\n <trace autoflush=\\\"true\\\" indentsize=\\\"2\\\">\\n <listeners>\\n <add n\", \"ame=\\\"myListener\\\"\\n type=\\\"System.Diagnostics.TextWriterTraceListener,\\n System, Version=1.0.3300.0, Cul\", \"ture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\"\\n initializeData=\\\"MyListener.log\\\"\\n                tra\", \"ceOutputOptions=\\\"ProcessId, LogicalOperationStack, Timestamp, \\nThreadId, Callstack, DateTime\\\" />\\n </\", \"listeners>\\n </trace>\\n </system.diagnostics>\\n</configuration>\\n```\\n\\nIf you take this configuration to \", \"a .NET app, you'll get an exception:\\n\\nUnrecognized configuration section System.Diagnostics\\n\\nThis ex\", \"ception occurs because that section and the assembly responsible for handling that section was defin\", \"ed in the *machine.config* file, which now doesn't exist.\\n\\nTo easily fix the issue, you can copy the\", \" section definition from your old *machine.config* to your new configuration file:\\n\\n```\\n<configSecti\", \"ons>\\n <section name=\\\"system.diagnostics\\\"\\n type=\\\"System.Diagnostics.SystemDiagnosticsSection,\\n System\", \", Version=4.0.0.0, Culture=neutral, \\nPublicKeyToken=b77a5c561934e089\\\"/>\\n</configSections>\\n```\\n\\n# <sp\", \"an id=\\\"page-24-0\\\"></span>Accessing databases\\n\\nAlmost every desktop application needs some kind of da\", \"tabase. For desktop, it's common to find client-server architectures with a direct connection betwee\", \"n the desktop app and the database engine. These databases can be local or remote depending on the n\", \"eed to share information between different users.\\n\\nFrom the code perspective, there have been many t\", \"echnologies and frameworks to give the developer the possibility to connect, query, and update a dat\", \"abase.\\n\\nThe most common examples of database you can find when talking about Windows Desktop applica\", \"tion are Microsoft Access and Microsoft SQL Server. If you have more than 20 years of experience pro\", \"gramming for the desktop, names like ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ, and Entity Framework will\", \" sound familiar.\\n\\n#### <span id=\\\"page-25-0\\\"></span>**ODBC**\\n\\nYou can continue to use ODBC on .NET si\", \"nce Microsoft is providing the System.Data.Odbc library compatible with .NET Standard 2.0.\\n\\n#### <sp\", \"an id=\\\"page-25-1\\\"></span>**OLE DB**\\n\\n[OLE DB](https://docs.microsoft.com/previous-versions/windows/d\", \"esktop/ms722784(v=vs.85)) has been a great way to access various data sources in a uniform manner. B\", \"ut it was based on COM, which is a Windows-only technology, and as such wasn't the best fit for a cr\", \"oss-platform technology such as .NET. It's also unsupported in SQL Server versions 2014 and later. F\", \"or those reasons, OLE DB won't be supported by .NET.\\n\\n#### <span id=\\\"page-25-2\\\"></span>**ADO.NET**\\n\\n\", \"You can still use ADO.NET from your existing desktop code on .NET. You just need to update some NuGe\", \"t packages.\\n\\n#### <span id=\\\"page-25-3\\\"></span>**EF Core vs. EF6**\\n\\nThere are two currently supported\", \" versions of Entity Framework (EF), Entity Framework 6 (EF6) and EF Core.\\n\\nThe latest technology rel\", \"eased as part of the .NET Framework world is Entity Framework, with 6.4 being the latest version. Wi\", \"th the launch of .NET Core, Microsoft also released a new data access stack based on Entity Framewor\", \"k and called Entity Framework Core.\\n\\nYou can use EF 6.4 and EF Core from both .NET Framework and .NE\", \"T. So, what are the decision drivers to help to decide between the two?\\n\\nEF 6.3 is the first version\", \" of EF6 that can run on .NET and work cross-platform. In fact, the main goal of this release was to \", \"make it easier to migrate existing applications that use EF6 to .NET.\\n\\nEF Core was designed to provi\", \"de a developer experience similar to EF6. Most of the top-level APIs remain the same, so EF Core wil\", \"l feel familiar to developers who have used EF6.\\n\\nAlthough compatible, there are differences on the \", \"implementation you should check before making a decision. For more information, see [Compare EF Core\", \" & EF6.](https://docs.microsoft.com/ef/efcore-and-ef6/)\\n\\nThe recommendation is to use EF Core if:\\n\\n-\", \" The app needs the capabilities of .NET.\\n- EF Core supports all of the features that the app require\", \"s.\\n\\nConsider using EF6 if both of the following conditions are true:\\n\\n- The app will run on Windows \", \"and .NET Framework 4.0 or later.\\n- EF6 supports all of the features that the app requires.\\n\\n#### <sp\", \"an id=\\\"page-26-0\\\"></span>**Relational databases**\\n\\n#### **SQL Server**\\n\\nSQL Server has been one of t\", \"he databases of choice if you were developing for the desktop some years ago. With the use of [Syste\", \"m.Data.SqlClient](https://docs.microsoft.com/dotnet/api/system.data.sqlclient) in .NET Framework, yo\", \"u could access versions of SQL Server, which encapsulates database-specific protocols.\\n\\nIn .NET, you\", \" can find a new SqlClient class, fully compatible with the one existing in the .NET Framework but lo\", \"cated in the [Microsoft.Data.SqlClient](https://docs.microsoft.com/dotnet/api/microsoft.data.sqlclie\", \"nt) library. You just have to add a reference to the [Microsoft.Data.SqlClient](https://www.nuget.or\", \"g/packages/Microsoft.Data.SqlClient/) NuGet package and do some renaming for the namespaces and ever\", \"ything should work as expected.\\n\\n#### **Microsoft Access**\\n\\nMicrosoft Access has been used for years\", \" when the sophisticated and more scalable SQL Server wasn't needed. You can still connect to Microso\", \"ft Access using the [System.Data.Odbc](https://docs.microsoft.com/dotnet/api/system.data.odbc) libra\", \"ry.\\n\\n# <span id=\\\"page-26-1\\\"></span>Consuming services\\n\\nWith the rise of service-oriented architectur\", \"es, desktop applications began to evolve from a clientserver model to the three-layer approach. In t\", \"he client-server approach, a direct database connection is established from the client holding the b\", \"usiness logic, usually inside a single EXE file. On the other hand, the three-layer approach establi\", \"shes an intermediate service layer implementing business logic and database access, allowing for bet\", \"ter security, scalability, and reusability. Instead of working directly with underlying data, the la\", \"yered approach relies on a set of services implementing contracts and typed objects for data transfe\", \"r.\\n\\nIf you have a desktop application using a WCF service and you want to migrate it to .NET, there \", \"are some things to consider.\\n\\nThe first thing is how to resolve the configuration to access the serv\", \"ice. Because the configuration is different on .NET, you'll need to make some updates in your config\", \"uration file.\\n\\nSecond, you'll need to regenerate the service client with the new tools present on Vi\", \"sual Studio 2019 and Visual Studio 2022. In this step, you must consider activating the generation o\", \"f the synchronous operations to make the client compatible with your existing code.\\n\\nAfter the migra\", \"tion, if you find that there are libraries you need that aren't present on .NET, you can add a refer\", \"ence to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compa\", \"tibility) NuGet package and see if the missing functions are there.\\n\\nIf you're using the [WebRequest\", \"](https://docs.microsoft.com/dotnet/api/system.net.webrequest) class to perform web service calls, y\", \"ou may find some differences on .NET. The recommendation is to use [HttpClient](https://learn.micros\", \"oft.com/dotnet/api/system.net.http.httpclient) instead.\\n\\n# <span id=\\\"page-27-0\\\"></span>Consuming a C\", \"OM Object\\n\\nCurrently, there's no way to add a reference to a COM object from Visual Studio 2019 or V\", \"isual Studio 2022 to use with .NET. So, you have to manually modify the project file.\\n\\nInsert a COMR\", \"eference structure inside the project file like in the following example:\\n\\n```\\n<ItemGroup>\\n <COMRefe\", \"rence Include=\\\"MSHTML\\\">\\n <Guid>{3050F1C5-98B5-11CF-BB82-00AA00BDCE0B}\\\\</Guid>\\n <VersionMajor>4</Vers\", \"ionMajor>\\n <VersionMinor>0</VersionMinor>\\n <Lcid>0</Lcid>\\n <WrapperTool>primary</WrapperTool>\\n <Isol\", \"ated>false</Isolated>\\n </COMReference>\\n</ItemGroup>\\n```\\n\\n# <span id=\\\"page-27-1\\\"></span>More things t\", \"o consider\\n\\nSeveral technologies available to .NET Framework libraries aren't available for .NET Cor\", \"e or .NET 7. If your code relies on some of these technologies, consider the alternative approaches \", \"outlined in this section.\\n\\nThe [Windows Compatibility Pack](https://docs.microsoft.com/dotnet/core/p\", \"orting/windows-compat-pack) provides access to APIs that were previously available only for .NET Fra\", \"mework. It can be used on .NET Core and .NET Standard projects.\\n\\nFor more information on API compati\", \"bility, you can find documentation about breaking changes and deprecated/legacy APIs at [https://lea\", \"rn.microsoft.com/dotnet/core/compatibility/fx-core.](https://docs.microsoft.com/dotnet/core/compatib\", \"ility/fx-core)\\n\\n# <span id=\\\"page-27-2\\\"></span>**AppDomains**\\n\\nApplication domains (AppDomains) isola\", \"te apps from one another. AppDomains require runtime support and are expensive. Creating additional \", \"app domains isn't supported. For code isolation, we recommend separate processes or using containers\", \" as an alternative. For the dynamic loading of assemblies, we recommend the new [AssemblyLoadContext\", \"](https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext) class.\\n\\nTo make c\", \"ode migration from .NET Framework easier, .NET exposes some of the AppDomain API surface. Some of th\", \"e APIs function normally (for example, [AppDomain.UnhandledException\\\\)](https://docs.microsoft.com/d\", \"otnet/api/system.appdomain.unhandledexception), some members do nothing (for example, [SetCachePath\\\\\", \")](https://docs.microsoft.com/dotnet/api/system.appdomain.setcachepath), and some of them throw [Pla\", \"tformNotSupportedException](https://docs.microsoft.com/dotnet/api/system.platformnotsupportedexcepti\", \"on) (for example, [CreateDomain\\\\)](https://docs.microsoft.com/dotnet/api/system.appdomain.createdoma\", \"in).\\n\\n### <span id=\\\"page-27-3\\\"></span>**Remoting**\\n\\n.NET Remoting was used for cross-AppDomain commu\", \"nication, which is no longer supported. Also, Remoting requires runtime support, which is expensive \", \"to maintain. For these reasons, .NET Remoting isn't supported on .NET.\\n\\nFor communication across pro\", \"cesses, you should consider inter-process communication (IPC) mechanisms as an alternative to Remoti\", \"ng, such as the or the [MemoryMappedFile](https://docs.microsoft.com/dotnet/api/system.io.memorymapp\", \"edfiles.memorymappedfile) class.\\n\\nAcross machines, use a network-based solution as an alternative. P\", \"referably, use a low-overhead plaintext protocol, such as HTTP. The Kestrel web server, the web serv\", \"er used by ASP.NET Core, is an option here.\\n\\n## <span id=\\\"page-28-0\\\"></span>**Code Access Security (\", \"CAS)**\\n\\nSandboxing, which relies on the runtime or the framework to constrain which resources a mana\", \"ged application or library uses or runs, isn't supported on .NET.\\n\\nUse security boundaries that are \", \"provided by the operating system, such as virtualization, containers, or user accounts, for running \", \"processes with the minimum set of privileges.\\n\\n#### <span id=\\\"page-28-1\\\"></span>**Security Transpare\", \"ncy**\\n\\nSimilar to CAS, Security Transparency separates sandboxed code from security critical code in\", \" a declarative fashion but is no longer supported as a security boundary.\\n\\nUse security boundaries t\", \"hat are provided by the operating system, such as virtualization, containers, or user accounts, for \", \"running processes with the least set of privileges.\\n\\n**CHAPTER** 4\\n\\n# <span id=\\\"page-29-0\\\"></span>Wi\", \"ndows 10 migration\\n\\nConsider the following situation: You have a working desktop application that wa\", \"s developed in the Windows 7 days. It's using WPF technology available at that time and working fine\", \" but it has an outdated UI and behaviors when you run it on Windows 10 or Windows 11. It is like whe\", \"n you watch a futuristic movie like Matrix and you see Neo using the Nokia 8110 device. The film wor\", \"ks great after 20 years but it would rather benefit from a device modernization.\\n\\nWith the release o\", \"f Windows 10, Microsoft introduced many innovations to support scenarios like tablets and touch devi\", \"ces and to provide the best experience for users for a Microsoft operating system ever. For example,\", \" you can:\\n\\n- Sign in with your face using Windows Hello.\\n- Use a pen to draw or handwrite text that \", \"is automatically recognized and digitalized.\\n- Run locally customized AI models built on the cloud u\", \"sing WinML.\\n\\nAll these features are enabled for Windows developers through Windows Runtime (WinRT) l\", \"ibraries. You can take advantage of these features in your existing desktop apps because the librari\", \"es are exposed to both the .NET Framework and .NET as well. You can even modernize your UI with the \", \"use of XAML Islands and improve the visuals and behavior of your apps according to the times.\\n\\nOne i\", \"mportant thing to note here is that you don't need to abandon .NET Framework technology to follow th\", \"is modernization path. You can safely stay on there and have all the benefits of Windows 10 and Wind\", \"ows 11 without the pressure to migrate to .NET. So, you get both the power and the flexibility to ch\", \"oose your modernization path.\\n\\n# <span id=\\\"page-29-1\\\"></span>WinRT APIs\\n\\nWinRT APIs are object-orien\", \"ted, well-structured application programming interfaces (APIs) that give Windows 10 and Windows 11 d\", \"evelopers access to everything the operating system has to offer. Through WinRT APIs, you can integr\", \"ate functionalities like Push Notifications, Device APIs, Microsoft Ink, and WinML, among others on \", \"your desktop apps.\\n\\nIn general, WinRT APIs can be called from a classic desktop app. However, two ma\", \"in areas present an exception to this rule:\\n\\n- APIs that require a package identity.\\n- APIs that req\", \"uire visualization like XAML or Composition.\\n\\n# <span id=\\\"page-30-0\\\"></span>**Universal Windows Plat\", \"form (UWP) packages**\\n\\n# **Application Package Identity**\\n\\nUWP apps have a deployment system where t\", \"he OS manages the installation and uninstallation of application. That requires the installation to \", \"be declarative, meaning that no user code is executed during install. Instead, everything the app wa\", \"nts to integrate with the system, such as protocols, file types, and extensions, is declared in the \", \"application manifest. At deployment time, the deployment pipeline configures those integration point\", \"s. The only way for the OS to manage all this functionality and keep track of it is for each 'packag\", \"e' to have an identity, a unique identifier for the application.\\n\\nSome WinRT APIs require this packa\", \"ge identity to work as expected. However, classic desktop apps like native C++ or .NET apps, use dif\", \"ferent deployment systems that don't require a package identity. If you want to use these WinRT APIs\", \" in your desktop application, you need to provide them a package identity.\\n\\nOne way to proceed is to\", \" build an additional packaging project. Inside the packaging project, you point to the original sour\", \"ce code project and specify the Identity information you want to provide. If you install the package\", \" and run the installed app, it will automatically get an identify enabling your code to call all Win\", \"RT APIs requiring Identity.\\n\\n```\\n<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n<Package xmlns=\\\"http://schem\", \"as.microsoft.com/appx/manifest/foundation/windows10\\\"\\n xmlns:uap=\\\"http://schemas.microsoft.com/appx/m\", \"anifest/uap/windows10\\\">\\n <Identity Name=\\\"YOUR-APP-GUID \\\"\\n Publisher=\\\"CN=YOUR COMPANY\\\"\\n Version=\\\"1.x.\", \"x.x\\\" />\\n</Package>\\n```\\n\\nYou can check which APIs need a packaged application identity by inspecting \", \"if the type that contains the API is marked with the [DualApiPartition](https://docs.microsoft.com/u\", \"wp/api/windows.foundation.metadata.dualapipartitionattribute) attribute. If it is, you can call if f\", \"rom an unpackaged traditional desktop app. Otherwise, you must convert your classic desktop app to a\", \" UWP with the help of a packaging project.\\n\\n[https://learn.microsoft.com/windows/desktop/apiindex/uw\", \"p-apis-callable-from-a-classic-desktop-app](https://docs.microsoft.com/windows/desktop/apiindex/uwp-\", \"apis-callable-from-a-classic-desktop-app)\\n\\n#### **Benefits of packaging**\\n\\nBesides giving you access\", \" to these APIs, you get some additional benefits by creating a Windows App package for your desktop \", \"application including:\\n\\n- **Streamlined deployment**. Apps have a great deployment experience ensuri\", \"ng that users can confidently install an application and update it. If a user chooses to uninstall t\", \"he app, it's removed completely with no trace left behind preventing the Windows rot problem.\\n- **Au\", \"tomatic updates and licensing**. Your application can participate in the Microsoft Store's built-in \", \"licensing and automatic update facilities. Automatic update is a highly reliable and efficient mecha\", \"nism, because only the changed parts of files are downloaded.\\n\\n- **Increased reach and simplified mo\", \"netization**. Maybe not your case but if you choose to distribute your application through the Micro\", \"soft Store you reach millions of Windows 10 and Windows 11 users.\\n- **Add UWP features**. You can ad\", \"d UWP features to your app's package at your own pace.\\n\\n# **Prepare for packaging**\\n\\nBefore proceedi\", \"ng to package your desktop application, there are some points you have to address before starting th\", \"e process. Your application must respect any of the Microsoft Store rules and policies and run in th\", \"e UWP application model. For example, it has to run on the .NET Framework 4.6.2 or later and writes \", \"to the HKEY\\\\_CURRENT\\\\_USER registry hive and the AppData folders will be virtualized to a user-speci\", \"fic app-local location.\\n\\nThe design goal for packaging is to separate the application state from sys\", \"tem state while maintaining compatibility with other apps. Windows 10 and Windows 11 accomplish this\", \" goal by placing the application inside a UWP package. It detects and redirects some changes to the \", \"file system and registry at run time to fulfill the promise of a trusted and clean install and unins\", \"tall behavior of an application provided by packaging.\\n\\nPackages that you create for your desktop ap\", \"plication are desktop-only, full-trust applications that aren't sandboxed, although there's lightwei\", \"ght virtualization applied to the app for writes to HKCU and AppData. This virtualization allows the\", \"m to interact with other apps the same way classic desktop applications do.\\n\\n#### **Installation**\\n\\n\", \"App packages are installed under *%ProgramFiles%\\\\WindowsApps\\\\package\\\\_name*, with the executable tit\", \"led app\\\\_name.exe. Each package folder contains a manifest (named AppxManifest.xml) that contains a \", \"special XML namespace for packaged apps. Inside that manifest file is an <EntryPoint> element, which\", \" references the full-trust app. When that application is launched, it doesn't run inside an app cont\", \"ainer, but instead it runs as the user as it normally would.\\n\\nAfter deployment, package files are ma\", \"rked read-only and heavily locked down by the operating system. Windows prevents apps from launching\", \" if these files are tampered with.\\n\\n#### **File system**\\n\\nThe OS supports different levels of file s\", \"ystem operations for packaged desktop applications, depending on the folder location.\\n\\nWhen trying t\", \"o access the user's *AppData* folder, the system creates a private per-user, per-app location behind\", \" the scenes. This creates the illusion that the packaged application is editing the real *AppData* w\", \"hen it's actually modifying a private copy. By redirecting writes this way, the system can track all\", \" file modifications made by the app. It can then clean all those files when uninstalling reducing sy\", \"stem \\\"rot\\\" and providing a better application removal experience for the user.\\n\\n# **Registry**\\n\\nApp \", \"packages contain a registry.dat file, which serves as the logical equivalent of HKLM\\\\Software in the\", \" real registry. At run time, this virtual registry merges the contents of this hive into the native \", \"system hive to provide a singular view of both.\\n\\nAll writes are kept during package upgrade and only\", \" deleted when the application is uninstalled.\\n\\n# **Uninstallation**\\n\\nWhen the user uninstalls a pack\", \"age, all files and folders located under C:\\\\Program Files\\\\WindowsApps\\\\package\\\\_name are removed, as \", \"well as any redirected writes to AppData or the registry that were captured during the process.\\n\\nFor\", \" details about how a packaged application handles installation, file access, registry, and uninstall\", \"ation, see [https://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-the](https://docs\", \".microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-the-scenes)[scenes.](https://docs.microsof\", \"t.com/windows/msix/desktop/desktop-to-uwp-behind-the-scenes)\\n\\nYou can get a complete list of things \", \"to check on [https://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-prepare.](https://docs.\", \"microsoft.com/windows/msix/desktop/desktop-to-uwp-prepare)\\n\\n# <span id=\\\"page-32-0\\\"></span>How to add\", \" WinRT APIs to your desktop project\\n\\nIn this section, you can find a walkthrough on how to integrate\", \" Toast Notifications in an existing WPF application. Although it's simple from the code perspective,\", \" it helps illustrate the whole process. Notifications are one of the many available WinRT APIs avail\", \"able that you can use in .NET app. In this case, the API requires a Package Identity. This process i\", \"s more straightforward if the APIs don't require Package Identity.\\n\\nLet's take an existing WPF sampl\", \"e app that reads files and shows its contents on the screen. The goal is to display a Toast Notifica\", \"tion when the application starts.\\n\\n![](_page_33_Figure_0.jpeg)\\n\\nFirst, you should check in the follo\", \"wing link whether the Windows 10 or Windows 11 API that you'll use requires a Package Identity:\\n\\n[ht\", \"tps://learn.microsoft.com/windows/apps/desktop/modernize/desktop-to-uwp-supported-api](https://docs.\", \"microsoft.com/windows/apps/desktop/modernize/desktop-to-uwp-supported-api)\\n\\nOur sample will use the \", \"[Windows.UI.Notifications.Notification](https://docs.microsoft.com/uwp/api/windows.ui.notifications.\", \"notification) API that requires a packaged identity:\\n\\n![](_page_33_Picture_4.jpeg)\\n\\nTo access the Wi\", \"nRT API, add a reference to the Microsoft.Windows.SDK.Contracts NuGet package and this package will \", \"do the magic behind the scenes (see details at [https://blogs.windows.com/windowsdeveloper/2019/04/3\", \"0/calling-windows-10-apis-from-a-desktop](https://blogs.windows.com/windowsdeveloper/2019/04/30/call\", \"ing-windows-10-apis-from-a-desktop-application-just-got-easier/)[application-just-got-easier/\\\\)](htt\", \"ps://blogs.windows.com/windowsdeveloper/2019/04/30/calling-windows-10-apis-from-a-desktop-applicatio\", \"n-just-got-easier/).\\n\\nYou're now prepared to start adding some code.\\n\\nCreate a ShowToastNotification\", \" method that will be called on application startup. It just builds a toast notification from an XML \", \"pattern:\\n\\n```\\nprivate void ShowNotification(string title, string content, string image)\\n{\\n string xm\", \"lString = $@\\\"<toast><visual><binding template = \\n'ToastGeneric'><text>{title}</text><text>{content}<\", \"/text><image \\nsrc=>'{image}'</image></binding></visual></toast>\\\";\\n XmlDocument toastXml = new XmlDoc\", \"ument();\\n toastXml.LoadXml(xmlString);\\n ToastNotification toast = new ToastNotification(toastXml);\\n \", \"ToastNotificationManager.CreateToastNotifier().Show(toast);\\n}\\n```\\n\\nAlthough the project builds, ther\", \"e are errors because the Notifications API requires a Package Identity and you didn't provide it. Ad\", \"ding a Windows Packaging Project to the solution will fix the issue:\\n\\n![](_page_34_Picture_3.jpeg)\\n\\n\", \"Select the minimum Windows version you want to support and the version you're targeting. Not all the\", \" WinRT APIs are supported in all Windows 10 and Windows 11 versions. Each Windows 10 or Windows 11 u\", \"pdate adds new APIs that are only available from this version; down-level support isn't available.\\n\\n\", \"![](_page_35_Figure_0.jpeg)\\n\\nreference:\\n\\n![](_page_36_Figure_0.jpeg)\\n\\n![](_page_36_Figure_1.jpeg)\\n\\nA\", \" Windows Packaging Project can package several apps so you should set which one is the Entry Point:\\n\", \"\\n![](_page_37_Figure_0.jpeg)\\n\\nNext step is to set the WPF Project as the startup Project in the solu\", \"tion configuration. You can press F5 to compile and build and see the results.\\n\\n![](_page_37_Figure_\", \"2.jpeg)\\n\\nLet's generate the package so you can install your app. Right click on **Store** > **Create\", \" App Packages**.\\n\\n![](_page_38_Figure_0.jpeg)\\n\\nSelect the sideloading option to deploy the app from \", \"your machine:\\n\\n![](_page_39_Picture_1.jpeg)\\n\\nSelect the application architecture of your app:\\n\\n![](_\", \"page_40_Picture_0.jpeg)\\n\\n<span id=\\\"page-40-0\\\"></span>Finally, create the package by clicking on **Cr\", \"eate**.\\n\\n# XAML Islands\\n\\nXAML Islands are a set of components that enable Windows desktop developers\", \" to use UWP XAML controls on their existing Win32 applications, including Windows Forms and WPF.\\n\\n![\", \"](_page_41_Picture_0.jpeg)\\n\\nYou can image your Win32 app with your standard controls and among them \", \"an \\\"island\\\" of UWP UI containing controls from the modern world. The concept is similar to having an\", \" iFrame inside a web page that shows content from a different page.\\n\\nBesides adding functionality fr\", \"om the Windows 10 and Windows 11 APIs, you can add pieces of UWP XAML inside of your app using XAML \", \"Islands.\\n\\nWindows 10 1903 update introduced a set of APIs that allow hosting UWP XAML content in Win\", \"32 windows. Only apps running on Windows 10 1903 or later can use XAML Islands.\\n\\n#### <span id=\\\"page\", \"-41-0\\\"></span>**The road to XAML Islands**\\n\\nThe road to XAML Islands started in 2012 when Microsoft \", \"introduced the WinRT APIs as a framework to modernize the Win32 apps (Windows Forms, WPF, and native\", \" Win32 apps). However, the new UI controls inside WinRT were available for new applications but not \", \"for existing ones.\\n\\nIn 2015, along with Windows 10, UWP was born. UWP allows you to create apps that\", \" work across Windows devices like XBox, Mobile, and Desktop. One year later, Microsoft announced Des\", \"ktop Bridge (formerly known as Project Centennial). Desktop Bridge is a set of tools that allowed de\", \"velopers to bring their existing Win32 apps to the Microsoft Store. More capabilities were added in \", \"2017, allowing developers to enhance their Win32 apps leveraging some of the new Windows 10 APIs, li\", \"ke live tiles and notifications on the action center. But still, no new UI controls.\\n\\nAt Build 2018,\", \" Microsoft announced a way for developers to use the new Windows 10 XAML controls into their current\", \" Win32 apps, without fully migrating their apps to UWP. It was branded as UWP XAML Islands.\\n\\n#### <s\", \"pan id=\\\"page-41-1\\\"></span>**How it works**\\n\\nThe Windows 10 1903 update introduced several XAML hosti\", \"ng APIs. Two of them are WindowsXamlManager and DesktopWindowXamlSource.\\n\\nThe WindowsXamlManager cla\", \"ss handles the UWP XAML Framework. Its InitializeForCurrentThread method loads the UWP XAML Framewor\", \"k inside the current thread of the Win32 app.\\n\\nThe DesktopWindowXamlSource is the instance of your X\", \"AML Island content. It has the Content property, which you're responsible for instantiating and sett\", \"ing. The DesktopWindowXamlSource renders and gets its input from an HWND. It needs to know to which \", \"other HWND it will attach the XAML Island's one, and you're responsible for sizing and positioning t\", \"he parent's HWND.\\n\\nWPF or Windows Forms developers don't usually deal with HWND inside their code, s\", \"o it may be hard to understand and handle HWND pointers and the underlying wiring stuff to communica\", \"te Win32 and UWP worlds.\\n\\n# **The XAML Islands .NET Wrappers**\\n\\nThe Windows Community Toolkit has a \", \"set the XAML Islands .NET wrappers for WPF or Windows Forms that make easier to use XAML Islands. Th\", \"ese wrappers manage the HWNDs, the focus management, among other things. Windows Forms and WPF devel\", \"opers should use these wrappers.\\n\\nThe Windows Community Toolkit offers two types of controls: Wrappe\", \"d Controls and Hosting Controls.\\n\\n#### **Wrapped Controls**\\n\\nThese wrapped controls wrap some UWP co\", \"ntrols into Windows Forms or WPF controls, hiding UWP concepts for those developers. These controls \", \"are:\\n\\n- WebView and WebViewCompatible\\n- InkCanvas and InkToolbar\\n- MediaPlayerElement\\n- MapControl\\n\\n\", \"Add the Microsoft.Toolkit.Wpf.UI.Controls package to your project, include the reference to the name\", \"space, and start using them.\\n\\n```\\n<Window\\n ...\\n xmlns:uwpControls=\\\"clr-\\nnamespace:Microsoft.Toolkit.\", \"Wpf.UI.Controls;assembly=Microsoft.Toolkit.Wpf.UI.Controls\\\">\\n<Grid>\\n <Grid.RowDefinitions>\\n <RowDefi\", \"nition Height=\\\"Auto\\\"/>\\n <RowDefinition Height=\\\"\\\\*\\\"/>\\n </Grid.RowDefinitions>\\n <uwpControls:InkToolba\", \"r TargetInkCanvas=\\\"{x:Reference Name=inkCanvas}\\\"/>\\n <uwpControls:InkCanvas Grid.Row=\\\"1\\\" x:Name=\\\"inkC\", \"anvas\\\" />\\n</Grid>\\n```\\n\\n#### **Hosting controls**\\n\\nThe power of XAML Islands extends to most first-pa\", \"rty controls, third-party controls, and custom controls developed for UWP, which can be integrated i\", \"nto Windows Forms and WPF as \\\"Islands\\\" with fully functional UI. The WindowsXamlHost control for WPF\", \" and Windows Forms allows doing this.\\n\\nFor example, to use the WindowsXamlHost control in WPF, add a\", \" reference to the Microsoft.Toolkit.Wpf.UI.XamlHost package provided by the Windows Community Toolki\", \"t.\\n\\nOnce you've placed your WindowsXamlHost into your UI code, specify which UWP type you want to lo\", \"ad. You can choose to use a wrapped control like a Button or a more complex one composed of several \", \"different controls, which are a custom UWP control.\\n\\nThe following example shows how to add a UWP Bu\", \"tton:\\n\\n```\\n<Window\\n ...\\n xmlns:xamlhost=\\\"clr-\\nnamespace:Microsoft.Toolkit.Wpf.UI.XamlHost;assembly=M\", \"icrosoft.Toolkit.Wpf.UI.XamlHost\\\">\\n<xamlhost:WindowsXamlHost x:Name=\\\"myUwpButton\\\"\\n InitialTypeName=\\\"\", \"Windows.UI.Xaml.Controls.Button\\\" />\\n```\\n\\nThere's a clear recommendation on how to approach this and \", \"it's better to have one single and bigger XAML Island containing a custom composite control than to \", \"have several islands with one control on each.\\n\\nOne of the core features of XAML is binding and it w\", \"orks between your Win32 code and the island. So, you can bind, for instance, a Win32 Textbox with a \", \"UWP Textbox. One important thing to consider is that these bindings are one-way bindings, from UWP t\", \"o Win32, so if you update the Textbox inside the XAML Island the Win32 Textbox will be updated, but \", \"not the other way around.\\n\\nTo see a walkthrough about how to use XAML Islands, see:\\n\\n[https://learn.\", \"microsoft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml](https://docs.microsoft\", \".com/windows/apps/desktop/modernize/host-standard-control-with-xaml-islands)[islands](https://docs.m\", \"icrosoft.com/windows/apps/desktop/modernize/host-standard-control-with-xaml-islands)\\n\\n#### **Adding \", \"UWP XAML custom controls**\\n\\nA XAML custom control is a control (or user control) created by you or b\", \"y third parties (including WinUI 2.x controls). To host a custom UWP control in a Windows Forms or W\", \"PF app, you'll need:\\n\\n- To use the WindowsXamlHost UWP control in your .NET app.\\n- To create a UWP a\", \"pp project that defines a XamlApplication object.\\n\\nYour WPF or Windows Forms project must have acces\", \"s to an instance of the Microsoft.Toolkit.Win32.UI.XamlHost.XamlApplication class provided by the Wi\", \"ndows Community Toolkit. This object acts as a root metadata provider for loading metadata for custo\", \"m UWP XAML types in assemblies in the current directory of your application. The recommended way to \", \"do this is to add a Blank App (Universal Windows) project to the same solution as your WPF or Window\", \"s Forms project and revise the default App class in this project.\\n\\nThe custom UWP XAML control can b\", \"e included on this UWP app or in an independent UWP Class Library project that you reference in the \", \"same solution as your WPF or Windows Forms project.\\n\\nYou can check a detailed step-by-step process d\", \"escription at:\\n\\n[https://learn.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with\", \"-xaml](https://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml-islan\", \"ds)[islands](https://docs.microsoft.com/windows/apps/desktop/modernize/host-custom-control-with-xaml\", \"-islands)\\n\\n# **The Windows UI Library (WinUI 2)**\\n\\nBesides the inbox Windows 10 controls that comes \", \"with the OS, the same UWP XAML team also delivers additional controls in the Windows UI Library (**W\", \"inUI 2**). WinUI 2 provides official native Microsoft UI controls and features for Windows UWP apps \", \"and these controls can be used inside of XAML Islands.\\n\\nWinUI 2 is open source and you can find info\", \"rmation at [https://github.com/microsoft/microsoft-ui](https://github.com/microsoft/microsoft-ui-xam\", \"l)[xaml.](https://github.com/microsoft/microsoft-ui-xaml)\\n\\nThe following article demonstrates how to\", \" host a UWP XAML control from the WinUI 2 library: [https://learn.microsoft.com/windows/apps/desktop\", \"/modernize/host-custom-control-with-xaml](https://docs.microsoft.com/windows/apps/desktop/modernize/\", \"host-custom-control-with-xaml-islands)[islands](https://docs.microsoft.com/windows/apps/desktop/mode\", \"rnize/host-custom-control-with-xaml-islands)\\n\\n# <span id=\\\"page-44-0\\\"></span>**Do you need XAML Islan\", \"ds**\\n\\nXAML Islands are intended for existing Win32 apps that want to improve their user experience b\", \"y leveraging new UWP controls and behaviors without a full rewrite of the app. You could already [le\", \"verage Windows 10 and Windows 11 APIs,](https://docs.microsoft.com/windows/uwp/porting/desktop-to-uw\", \"p-enhance) but up until XAML Islands, only non-UI related APIs.\\n\\nIf you're developing a new Windows \", \"App, a [UWP App](https://docs.microsoft.com/windows/uwp/get-started/universal-application-platform-g\", \"uide) is probably the right approach.\\n\\n#### <span id=\\\"page-44-1\\\"></span>**The road ahead XAML Island\", \"s: WinUI 3.0**\\n\\nSince Windows 8, the Windows UI platform, including the XAML UI framework, visual co\", \"mposition layer, and input processing has been shipped as an integral part of Windows. This means th\", \"at to benefit from the latest improvements on UI technologies, you must upgrade to the latest versio\", \"n of the UI, slowing down the pace of innovation when you develop your apps. To decouple these two e\", \"volution cycles and foster innovation, Microsoft is actively working on the WinUI project.\\n\\nStarting\", \" with WinUI 2 in 2018, Microsoft started shipping some new XAML UI controls and features as separate\", \" NuGet packages that build on top of the UWP SDK.\\n\\n![](_page_45_Figure_0.jpeg)\\n\\nWinUI 3 is under act\", \"ive development and will greatly expand the scope of WinUI to include the full UI platform, which wi\", \"ll be fully decoupled from the UWP SDK:\\n\\n![](_page_45_Figure_2.jpeg)\\n\\nXAML framework will now be dev\", \"eloped on GitHub and shipped out of band as [NuGet](https://docs.microsoft.com/nuget/what-is-nuget) \", \"packages.\\n\\nThe existing UWP XAML APIs that ship as part of the OS will no longer receive new feature\", \" updates. They will still receive security updates and critical fixes according to the Windows 10 su\", \"pport lifecycle.\\n\\nThe Universal Windows Platform contains more than just the XAML framework (for exa\", \"mple, application and security model, media pipeline, Xbox and Windows 10 shell integrations, broad \", \"device support) and will continue to evolve. All new XAML features will just be developed and ship a\", \"s part of WinUI instead.\\n\\n#### **WinUI 3 in desktop app and WinUI XAML Islands**\\n\\nAs you can see, Wi\", \"nUI 3 is the evolution of UWP XAML and it works naturally within the UWP app model and all its requi\", \"rements (MSIX packaged ID, sandbox, CoreWindow, and so on. To use just WinUI 3 in a Win32 app model,\", \" the WinUI content should be hosted by another UI Framework (Windows Forms, WPF, and so on) using **\", \"WinUI XAML Islands**. This is the right path if you want to evolve your app and mix technologies. Ho\", \"wever, if you want to replace your entire old UI for WinUI, your app shouldn't load UI Frameworks fo\", \"r just hosting WinUI.\\n\\nWinUI 3 will address this critical feedback adding **WinUI in desktop apps**.\", \" This will allow that Win32 apps can use WinUI 3 as standalone UI Framework; no need to load Windows\", \" Forms or WPF.\\n\\nWithin this aggregation, WinUI 3 will let developers easily mix and match the right \", \"combination of:\\n\\n- App model: UWP, Win32 \\u2022 Platform: .NET or Native\\n- Language: .NET (C#, Visual Bas\", \"ic), standard C++\\n- Packaging: MSIX, AppX for the Microsoft Store, unpackaged\\n- Interop: use WinUI 3\", \" to extend existing WPF, WinForms, and MFC apps using WinUI XAML\\n- Islands.\\n\\nIf you want to know mor\", \"e details, Microsoft is sharing this roadmap in [https://github.com/microsoft/microsoft-ui-xaml/blob\", \"/main/docs/roadmap.md.](https://github.com/microsoft/microsoft-ui-xaml/blob/main/docs/roadmap.md)\\n\\n*\", \"*CHAPTER** 5\\n\\n# <span id=\\\"page-47-0\\\"></span>Example of migrating to the latest .NET\\n\\nIn this chapter\", \", we'll show how to migrate your applications to the latest version of .NET. You can migrate to .NET\", \" 7 from .NET Framework, .NET Core, or .NET 5. We'll introduce a tool that can do all the work for yo\", \"u in most cases. If your application has special cases or complicated dependencies, we'll also show \", \"how to do the whole migration process by hand. Additionally, we'll cover the most common issues and \", \"challenges you can face when migrating an existing application from .NET Framework to .NET.\\n\\n# <span\", \" id=\\\"page-47-1\\\"></span>Migrating from .NET Core or .NET 5\\n\\nUpdating your applications to target the \", \"latest version of .NET is easy if you already are on .NET Core or .NET 5. If this is the case, then \", \"in Visual Studio, simply right-click on your project in **Solution Explorer** and choose **Propertie\", \"s**. Under **Application** > **General** > **Target framework**, choose .NET 7.0. Save and rebuild y\", \"our application. You're done! Your app now runs on the latest version of .NET. In the future when ne\", \"w versions become available, you can upgrade in the same way.\\n\\n![](_page_48_Figure_0.jpeg)\\n\\n# <span \", \"id=\\\"page-48-0\\\"></span>Migrating from .NET Framework\\n\\nMigrating from .NET Framework is a more complic\", \"ated process because there are more differences between .NET Framework and other platforms that were\", \" built on top of .NET Core. But the good news is that there's a tool that will do all the work for y\", \"ou in most cases.\\n\\n### <span id=\\\"page-48-1\\\"></span>**Migrating with a tool**\\n\\nThe [Upgrade Assistant\", \"](https://dotnet.microsoft.com/platform/upgrade-assistant) is a migration tool. Using it is easy and\", \" there are step-by-step instructions available on the [.NET website](https://dotnet.microsoft.com/pl\", \"atform/upgrade-assistant/tutorial/intro). In this chapter, we'll look at what is happening behind th\", \"e scenes and how to port your application by hand. When the Upgrade Assistant is unable to migrate y\", \"our application, you'll learn the underlying mechanics so that you might be able to migrate manually\", \".\\n\\n# <span id=\\\"page-48-2\\\"></span>**Migrating by hand**\\n\\nThe migration process consists of four seque\", \"ntial steps:\\n\\n- 1. **Preparation**: Understand the dependencies the project has to have an idea of w\", \"hat's ahead. In this step, you take the current project into a state that simplifies the startup poi\", \"nt for the migration.\\n- 2. **Migrate Project File:** .NET projects use the new SDK-style project for\", \"mat. Create a new project file with this format or update the one you have to use the SDK style.\\n- 3\", \". **Fix code and build:** Build the code in .NET addressing API-level differences between .NET Frame\", \"work and .NET. If needed, update third-party packages to the ones that support .NET.\\n\\n4. **Run and t\", \"est:** There might be differences that don't show up until run time. So, don't forget to run the app\", \"lication and test that everything works as expected.\\n\\n# <span id=\\\"page-49-0\\\"></span>**Preparation**\\n\", \"\\n# **Migrate packages.config file**\\n\\nIn a .NET Framework application, all references to external pac\", \"kages are declared in the *packages.config* file. In .NET, there's no longer the need to use the *pa\", \"ckages.config* file. Instead, use the [PackageReference](https://docs.microsoft.com/dotnet/core/proj\", \"ect-sdk/msbuild-props#packagereference) property inside the project file to specify the NuGet packag\", \"es for your app.\\n\\nSo, you need to transition from one format to another. You can do the update manua\", \"lly, taking the dependencies contained in the *packages.config* file and migrating them to the proje\", \"ct file with the PackageReference format. Or, you can let Visual Studio do the work for you: right-c\", \"lick on the *packages.config* file and select the **Migrate packages.config to PackageReference** op\", \"tion.\\n\\n# **Verify every dependency compatibility in .NET**\\n\\nOnce you've migrated the package referen\", \"ces, you must check each reference for compatibility. You can explore the dependencies of each NuGet\", \" package your application is using on [nuget.org.](https://www.nuget.org/) If the package has .NET S\", \"tandard dependencies, then it's going to work on .NET 7 because .NET [supports](https://docs.microso\", \"ft.com/dotnet/standard/net-standard#net-implementation-support) all versions of .NET Standard. The f\", \"ollowing image shows the dependencies for the Castle.Windsor package:\\n\\n![](_page_49_Picture_7.jpeg)\\n\", \"\\nTo check the package compatibility, you can use the tool [https://fuget.org](https://fuget.org/) th\", \"at offers a more detailed information about versions and dependencies.\\n\\nMaybe the project is referen\", \"cing older package versions that don't support .NET, but you might find newer versions that do suppo\", \"rt it. So, updating packages to newer versions is generally a good\\n\\nrecommendation. However, you sho\", \"uld consider that updating the package version can introduce some breaking changes that would force \", \"you to update your code.\\n\\nWhat happens if you don't find a compatible version? What if you just don'\", \"t want to update the version of a package because of these breaking changes? Don't worry because it'\", \"s possible to depend on .NET Framework packages from a .NET application. Don't forget to test it ext\", \"ensively because it can cause run-time errors if the external package calls an API that isn't availa\", \"ble on .NET. This is great for when you're using an old package that isn't going to be updated and y\", \"ou can just retarget to work on .NET.\\n\\n# **Check for API compatibility**\\n\\nSince the API surface in .\", \"NET Framework and .NET is similar but not identical, you must check which APIs are available on .NET\", \" and which aren't. You can use the .NET Portability Analyzer tool to surface APIs used that aren't p\", \"resent on .NET. It looks at the binary level of your app, extracts all the APIs that are called, and\", \" then lists which APIs aren't available on your target framework (.NET 7 in this case).\\n\\nYou can fin\", \"d more information about this tool at:\\n\\n## [https://learn.microsoft.com/dotnet/standard/analyzers/po\", \"rtability-analyzer](https://docs.microsoft.com/dotnet/standard/analyzers/portability-analyzer)\\n\\nAn i\", \"nteresting aspect of this tool is that it only surfaces the differences from your own code and not c\", \"ode from external packages, which you can't change. Remember you should have updated most of these p\", \"ackages to make them work with .NET.\\n\\n#### **Migrate**\\n\\n#### 1. Create the new .NET project\\n\\nIn most\", \" cases, you'll want to update your existing project to the new .NET format. However, you can also cr\", \"eate a new project while maintaining the old one. The main drawback from updating the old project is\", \" that you lose designer support, which may be important to you and your development team. If you wan\", \"t to keep using the designer, you must create a new .NET project in parallel with the old one and sh\", \"are assets. If you need to modify UI elements in the designer, you can switch to the old project to \", \"do that. And since assets are linked, they'll be updated in the .NET project as well.\\n\\nThe [SDK-styl\", \"e project](https://docs.microsoft.com/dotnet/core/project-sdk/msbuild-props) for .NET is a lot simpl\", \"er than .NET Framework's project format. Apart from the previously mentioned PackageReference entrie\", \"s, you won't need to do much more. The new project format [includes files with certain extensions by\", \" default,](https://docs.microsoft.com/dotnet/core/project-sdk/overview#default-includes-and-excludes\", \") such as .cs and .xaml files, without the need to explicitly include them in the project file.\\n\\n###\", \"# **AssemblyInfo considerations**\\n\\nAttributes are autogenerated on .NET projects. If the project con\", \"tains an *AssemblyInfo.cs* file, the definitions will be duplicated, which will cause compilation co\", \"nflicts. You can delete the older *AssemblyInfo.cs* file or disable autogeneration by adding the fol\", \"lowing entry to the .NET project file:\\n\\n```\\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\">\\n <PropertyGroup>\\n <Gen\", \"erateAssemblyInfo>false</GenerateAssemblyInfo>\\n```\\n\\n```\\n </PropertyGroup>\\n</Project>\\n```\\n\\n# **Resour\", \"ces**\\n\\nEmbedded resources are included automatically but resources aren't, so you need to migrate th\", \"e resources to the new project file.\\n\\n# **Package references**\\n\\nWith the **Migrate packages.config t\", \"o PackageReference** option, you can easily move your external package references to the new format \", \"as previously mentioned.\\n\\n# **Update package references**\\n\\nUpdate the versions of the packages you'v\", \"e found to be compatible, as shown in the previous section.\\n\\n# <span id=\\\"page-51-0\\\"></span>**Fix the\", \" code and build**\\n\\n# **Microsoft.Windows.Compatibility**\\n\\nIf your application depends on APIs that a\", \"ren't available on .NET, such as Registry or ACLs, you have to include a reference to the Microsoft.\", \"Windows.Compatibility package to add these Windowsspecific APIs. They work on .NET but aren't includ\", \"ed as they aren't cross-platform.\\n\\nThere's a tool called Platform compatibility analyzer\\n\\n[\\\\(https:/\", \"/learn.microsoft.com/dotnet/standard/analyzers/platform-compat-analyzer\\\\)](https://docs.microsoft.co\", \"m/dotnet/standard/analyzers/platform-compat-analyzer) that helps you identify APIs that aren't compa\", \"tible with your code.\\n\\n#### **Use #if directives**\\n\\nIf you need different execution paths when targe\", \"ting .NET Framework and .NET, you should use compilation constants. Add some #if directives to your \", \"code to keep the same codebase for both targets.\\n\\n#### **Technologies not available on .NET**\\n\\nSome \", \"technologies aren't available on .NET, such as:\\n\\n- AppDomains\\n- Remoting\\n- Code Access Security\\n- Wi\", \"ndows Workflow\\n\\nThat's why you need to find a replacement for these technologies if you're using the\", \"m in your application. For more information, see the [.NET Framework technologies unavailable on .NE\", \"T Core and](https://docs.microsoft.com/dotnet/core/porting/net-framework-tech-unavailable)  [.NET 5+\", \"](https://docs.microsoft.com/dotnet/core/porting/net-framework-tech-unavailable) article.\\n\\n# **Regen\", \"erate autogenerated clients**\\n\\nIf your application uses autogenerated code, such as a WCF client, yo\", \"u may need to regenerate this code to target .NET. Sometimes, you can find some missing references s\", \"ince they may not be included as part of the default .NET assemblies set. Using a tool like [https:/\", \"/apisof.net/,](https://apisof.net/) you can easily locate the assembly the missing reference lives i\", \"n and add it from NuGet.\\n\\n# **Rolling back package versions**\\n\\nAs a general rule, we've previously s\", \"tated that you better update every single package version to be compatible with .NET. However, you c\", \"an find that targeting an updated and compatible version of an assembly just doesn't pay off. If the\", \" cost of change isn't acceptable, you can consider rolling back package versions keeping the ones yo\", \"u use on .NET Framework. Although they may not be targeting .NET, they should work well unless they \", \"call some unsupported APIs.\\n\\n# <span id=\\\"page-52-0\\\"></span>**Run and test**\\n\\nOnce you have your appl\", \"ication building with no errors, you can start the last step of the migration by testing every funct\", \"ionality.\\n\\nIn this final step, you can find several different issues depending on the complexity of \", \"your application and the dependencies and APIs you're using.\\n\\nFor example, if you use configuration \", \"files (*app.config*), you may find some errors at run time like Configuration Sections not present. \", \"Using the Microsoft.Extensions.Configuration NuGet package should fix that error.\\n\\nAnother reason fo\", \"r errors is the use of the BeginInvoke and EndInvoke methods because they aren't supported on .NET. \", \"They aren't supported on .NET because they have a dependency on Remoting, which doesn't exist on .NE\", \"T. To solve this issue, try to use the await keyword (when available) or the [Task.Run](https://docs\", \".microsoft.com/dotnet/api/system.threading.tasks.task.run) method.\\n\\nYou can use compatibility analyz\", \"ers to let you identify APIs and code patterns in your code that can potentially cause problems at r\", \"un time with .NET. Go to<https://github.com/dotnet/platform-compat> and use the .NET API analyzer on\", \" your project.\\n\\n# <span id=\\\"page-52-1\\\"></span>Migrating a Windows Forms application\\n\\nTo showcase a c\", \"omplete migration process of a Windows Forms application, we've chosen to migrate the eShop sample a\", \"pplication available at [https://github.com/dotnet-](https://github.com/dotnet-architecture/eShopMod\", \"ernizing/tree/master/eShopLegacyNTier/src/eShopWinForms)\\n\\n[architecture/eShopModernizing/tree/master\", \"/eShopLegacyNTier/src/eShopWinForms.](https://github.com/dotnet-architecture/eShopModernizing/tree/m\", \"aster/eShopLegacyNTier/src/eShopWinForms) You can find the complete result of the migration at [http\", \"s://github.com/dotnet](https://github.com/dotnet-architecture/eShopModernizing/tree/master/eShopMode\", \"rnizedNTier/src/eShopWinForms)[architecture/eShopModernizing/tree/master/eShopModernizedNTier/src/eS\", \"hopWinForms.](https://github.com/dotnet-architecture/eShopModernizing/tree/master/eShopModernizedNTi\", \"er/src/eShopWinForms)\\n\\nThis application shows a product catalog and allows the user to navigate, fil\", \"ter, and search for products. From an architecture point of view, the app relies on an external WCF \", \"service that serves as a fa\\u00e7ade to a back-end database.\\n\\nYou can see the main application window in \", \"the following picture:\\n\\n![](_page_53_Figure_0.jpeg)\\n\\nIf you open the *.csproj* project file, you can\", \" see something like this:\\n\\nAs previously mentioned, a .NET project has a more compact style and you \", \"need to migrate the project structure to the new .NET SDK style.\\n\\nIn Solution Explorer, right-click \", \"on the Windows Forms project and select **Unload Project** > **Edit**.\\n\\nNow you can update the .cspr\", \"oj file. You'll delete the entire contents and replace it with the following code:\\n\\n```\\n<Project Sdk\", \"=\\\"Microsoft.NET.Sdk\\\">\\n <PropertyGroup>\\n <OutputType>WinExe</OutputType>\\n <TargetFramework>net7.0-win\", \"dows</TargetFramework>\\n <UseWindowsForms>true</UseWindowsForms>\\n <GenerateAssemblyInfo>false</Genera\", \"teAssemblyInfo>\\n```\\n\\n```\\n </PropertyGroup>\\n</Project>\\n```\\n\\nSave and reload the project. You're now d\", \"one updating the project file and the project is targeting .NET 7.\\n\\nIf you compile the project at th\", \"is point, you'll find some errors related to the WCF client reference. Since this code is autogenera\", \"ted, you must regenerate it to target .NET.\\n\\n![](_page_54_Picture_3.jpeg)\\n\\nDelete the *Reference.cs*\", \" file and generate a new Service Client.\\n\\nRight-click on **Connected Services** and select the **Add\", \" Connected Service** option.\\n\\n![](_page_54_Picture_6.jpeg)\\n\\nThe Connected Services window opens. Sel\", \"ect the **Microsoft WCF Web Service** option.\\n\\n![](_page_55_Figure_0.jpeg)\\n\\n**Discover** option inst\", \"ead of specifying a service URL.\\n\\n![](_page_55_Picture_2.jpeg)\\n\\nOnce the service is located, the too\", \"l reflects the API contract implemented by the service. Change the name of the namespace to be eShop\", \"ServiceReference as shown in the following image:\\n\\n![](_page_56_Figure_0.jpeg)\\n\\nSelect the **Finish*\", \"* button. After a while, you'll see the generated code.\\n\\nYou should see three autogenerated files:\\n\\n\", \"- 1. *Getting Started*: a link to GitHub to provide some information on WCF.\\n- 2. *ConnectedService.\", \"json*: configuration parameters to connect to the service.\\n- 3. *Reference.cs*: the actual WCF clien\", \"t code.\\n\\n![](_page_57_Figure_0.jpeg)\\n\\nIf you compile again, you'll see many errors coming from *.cs*\", \" files inside the *Helper* folder. This folder was present in the .NET Framework version but not inc\", \"luded in the old *.csproj*. But with the new SDKstyle project, every code file present underneath th\", \"e project file location is included by default. That is, the new .NET Core project tries to compile \", \"the files inside the *Helper* folder. Since that folder isn't needed, you can safely delete it.\\n\\nIf \", \"you compile the project again and execute it, you won't see the product images. The problem is that \", \"now the path to the files has slightly changed. To fix this issue, you need to add another level of \", \"depth in the path, updating in the file CatalogView.cs the line:\\n\\n```\\nstring image_name = Environmen\", \"t.CurrentDirectory +\\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItems.Picturefilename;\\nto\\nstring\", \" image_name = Environment.CurrentDirectory +\\n\\\"\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\Assets\\\\\\\\Images\\\\\\\\Catalog\\\\\\\\\\\" + catalogItem\", \"s.Picturefilename;\\n```\\n\\nAfter this change, you can check that the application launches and runs as e\", \"xpected on .NET 7.\\n\\n# <span id=\\\"page-58-0\\\"></span>Migrating a WPF application\\n\\nWe'll use the Shop.Cl\", \"assicWPF sample application to perform the migration. The following image shows a screenshot of the \", \"app before migration:\\n\\n![](_page_58_Picture_4.jpeg)\\n\\nThis application uses a local SQL Server Expres\", \"s database to hold the product catalog information. This database is accessed directly from the WPF \", \"application.\\n\\nFirst, you must update the *.csproj* file to the new SDK style used by .NET Core appli\", \"cations. You'll follow the same steps described in the Windows Forms migration: you'll unload the pr\", \"oject, open the *.csproj* file, update its contents, and reload the project.\\n\\nIn this case, delete a\", \"ll the content of the *.csproj* file and replace it with the following code:\\n\\n```\\n<Project Sdk=\\\"Micr\", \"osoft.NET.Sdk\\\">\\n <PropertyGroup>\\n <OutputType>WinExe</OutputType>\\n <TargetFramework>net7.0-windows</\", \"TargetFramework>\\n <UseWpf>true</UseWpf>\\n <GenerateAssemblyInfo>false</GenerateAssemblyInfo>\\n </Prope\", \"rtyGroup>\\n</Project>\\n```\\n\\nIf you reload the project and compile it, you'll get the following error:\\n\", \"\\n![](_page_59_Picture_2.jpeg)\\n\\nSince you've deleted all the *.csproj* contents, you've lost a projec\", \"t reference specification present in the old project. You just need to add this line to the *.csproj\", \"* file to include the project reference back:\\n\\n```\\n<ItemGroup>\\n <ProjectReference Include=\\\"..\\\\\\\\eShop\", \".SqlProvider\\\\\\\\eShop.SqlProvider.csproj\\\" />\\n<ItemGroup>\\n```\\n\\nYou can also let Visual Studio help you \", \"by right-clicking on the **Dependencies** node and selecting **Add Project Reference**. Select the p\", \"roject from the solution and select **OK**:\\n\\n![](_page_60_Figure_0.jpeg)\\n\\nOnce you add the missing p\", \"roject reference, the application compiles and runs as expected on .NET.\\n\\n# <span id=\\\"page-61-0\\\"></s\", \"pan>Deploying Modern Desktop Applications\\n\\nWhen you develop desktop applications, one thing to consi\", \"der is how your application is going to be packaged and deployed to the users' machines. The problem\", \" with packaging, deployment, and installation is that it usually falls under the umbrella of the IT \", \"professionals, who care about different things than developers.\\n\\nThese days, we're all familiar with\", \" the DevOps concept, where developers and IT Pros work closely to move applications to their product\", \"ion environments. But if you've been in the desktop battle for more than 10 years, you might have se\", \"en the following story. A team of developers works together hard to meet the project deadlines. Busi\", \"ness people are nervous since they need the system working on many users' machines to run the compan\", \"y. On \\\"D-Day\\\", the project manager checks with every developer that their code is working well and t\", \"hat everything is fine, so they can ship. Then, the package team comes in generating the setup for t\", \"he app, distribute it to every user machine and a set of test users run the application. Well, they \", \"try, because before showing any UI, the application throws an exception that says \\\"Method ~ of objec\", \"t ~ failed\\\". Panic starts flowing through the air and a brief investigation points to a young and ti\", \"red developer that has introduced a third-party control, that certainly \\\"worked on the dev machine\\\".\", \"\\n\\nInstalling desktop applications have traditionally been a nightmare for two main reasons:\\n\\n- Lack \", \"of close collaboration culture between dev and IT teams.\\n- Lack of a solid packaging and deploying t\", \"echnology we can build upon.\\n\\nIn fact, we've been living with the fact that sometimes you regret tha\", \"t you installed an app because:\\n\\n- It ends up having some undesired side effects on your machine.\\n- \", \"Some applications that were previously installed stop working.\\n\\nAdditionally, you can't just restore\", \" the system to its original state by uninstalling the app. We're so used to living with this situati\", \"on that we've coined terms like \\\"DLL Hell\\\" or \\\"Winrot\\\".\\n\\nIn this chapter, we'll talk about MSIX. MSI\", \"X is the new technology from Microsoft that tries to capture the best of previous technologies to pr\", \"ovide a solid foundation for the packaging technology of the future.\\n\\nWhat does a packaging technolo\", \"gy have to do with modernization? Well, it turns out that packaging is fundamental for the enterpris\", \"e IT with lots of money invested there. Modernization isn't only related to using the latest technol\", \"ogies. It's also related to reducing time to market from the moment a business requirement is define\", \"d until your company delivers the feature to your client.\\n\\n# <span id=\\\"page-62-0\\\"></span>The modern \", \"application lifecycle\\n\\nToday, developers write and build the code for an app and then pass the gener\", \"ated assets to the IT Pros. Then, the IT Pros reconfigure the app and repackage it, typically in an \", \"MSI or more recently in an App-V packaging format. The app is then deployed through different channe\", \"ls and tools. One of the main problems with this approach is commonly known as \\\"packaging paralysis\\\"\", \". The problem is that this cycle repeats every time there's an app update or an OS update.\\n\\nYou can \", \"see the process reflected on the following picture:\\n\\n![](_page_62_Figure_5.jpeg)\\n\\nCompanies need a w\", \"ay to break this packaging cycle into three independent cycles:\\n\\n- OS updates\\n- Application updates\\n\", \"- Customization\\n\\n![](_page_63_Figure_0.jpeg)\\n\\nThe previous diagram shows that you can:\\n\\n- Update the\", \" underlying OS without having to repackage your apps.\\n- Enable customizations from IT without the ne\", \"ed to repackage the original developer package.\\n\\nThis radical change leads us to the new and modern \", \"IT lifecycle as shown in the following picture:\\n\\n![](_page_64_Picture_1.jpeg)\\n\\nDevelopers create the\", \" app and generate an MSIX package that IT Pros can consume and configure without the need of repacka\", \"ging. Along with the MSIX technology, Microsoft has created tools to allow IT to customize and confi\", \"gure packages without repackaging.\\n\\n# <span id=\\\"page-64-0\\\"></span>MSIX: The next generation of deplo\", \"yment\\n\\nBefore MSIX, there were several packaging technologies available like setup wizards, MSI, Cli\", \"ckOnce, App-V, and scripting. Each of these technologies has their own strengths and Microsoft has d\", \"ecided to pick the best of all to build MSIX. MSIX is built on the foundations of these existing tec\", \"hnologies picking the best of each:\\n\\n- App-V => Containerization\\n- ClickOnce => Auto updating\\n- MSI \", \"=> Easy to distribute\\n\\nWith MSIX, you get one installer technology with all these features.\\n\\n![](_pa\", \"ge_65_Picture_0.jpeg)\\n\\n#### <span id=\\\"page-65-0\\\"></span>**Benefits of MSIX**\\n\\n#### **Never regret in\", \"stalling an app**\\n\\nMSIX provides a predictable, reliable, and safe deployment. The declarative metho\", \"d contained in the package manifest lets the OS keep track of every asset your application needs. It\", \" also provides a true clean uninstall with no side effects.\\n\\n#### **Disk space optimization**\\n\\nMSIX \", \"is optimized to reduce the footprint that an application has on the user's machine disk space. It cr\", \"eates a single instance storage of your files. That is, if you have two different packages with the \", \"same DLL, the DLL isn't installed twice. The platform takes care of that problem because it knows al\", \"l the files that a particular app installed thanks to its declarative nature. It also allows you to \", \"have different versions of a DLL working side by side.\\n\\nWith the use of resource packages, you can e\", \"asily create multilingual apps and the OS takes care of installing the ones that are used.\\n\\n#### **N\", \"etwork optimization**\\n\\nMSIX detects the differences on the files at the byte block level enabling a \", \"feature called differential updates. What this means is that only the updated byte blocks are downlo\", \"aded on application updates.\\n\\n![](_page_66_Figure_1.jpeg)\\n\\nWith streaming installation, the user can\", \" quickly start working on your application while other parts of the app are downloaded on the backgr\", \"ound. This feature contributes to an engaging experience for your users.\\n\\nWith the optional packages\", \" feature, you achieve componentization on your app deployment, so you can download them when needed.\", \"\\n\\n#### **Simple packaging and deployment**\\n\\nThe AppManifest declares the versioning, device targetin\", \"g and identity in a standard way for every application. It also provides a way to sign your assets p\", \"roviding a solid security foundation.\\n\\n#### **OS managed**\\n\\nThe OS handles all the processes for ins\", \"talling, updating, and removing an application. Applications are installed per user but downloaded o\", \"nly once, minimizing the disk footprint. Microsoft is working on providing the MSIX experience also \", \"on Windows 7.\\n\\n#### **Windows provides integrity for the app**\\n\\nWith the use of digital signatures, \", \"you can guarantee that you don't install an application from untrusted sources. MSIX also prevents t\", \"ampering because:\\n\\n- It keeps a record of file hashes.\\n- It detects if a file has been modified afte\", \"r installation.\\n\\n# **Works for the entire App Catalog**\\n\\nOne of the coolest things about MSIX is tha\", \"t it works for the entire application catalog, Windows Forms, WPF, MFC/ATL, Delphi, even if you want\", \" to do xCopy deployment, ClickOnce, or going to the Store, you can use the same MSIX package.\\n\\n# <sp\", \"an id=\\\"page-67-0\\\"></span>**Tools**\\n\\n# **Windows Application Packaging Project**\\n\\nYou can use the **W\", \"indows Application Packaging Project** project in Visual Studio to generate a package for your deskt\", \"op app. Then, you can publish that package to the Microsoft Store or sideload it onto one or more PC\", \"s.\\n\\n# **MSIX Packaging Tool**\\n\\nThe MSIX Packaging Tool enables you to repackage your existing Win32 \", \"applications to the MSIX format. It offers both an interactive UI and a command line for conversions\", \" and gives you the ability to convert an application without having the source code.\\n\\n![](_page_68_F\", \"igure_3.jpeg)\\n\\n![](_page_68_Figure_5.jpeg)\\n\\n![](_page_68_Figure_6.jpeg)\\n\\n#### **Package Support Fram\", \"ework**\\n\\nThe Package Support Framework is an open-source kit that helps you apply fixes to your exis\", \"ting Win32 application when you don't have access to the source code, so that it can run in an MSIX \", \"container. The Package Support Framework helps your application follow the best practices of the mod\", \"ern runtime environment.\\n\\n#### **App Installer**\\n\\nApp Installer allows Windows 10 and Windows 11 app\", \"s to be installed by double-clicking the app package. This means that users don't need to use PowerS\", \"hell or other developer tools to deploy Windows 10/Windows 11 apps. The App Installer can also insta\", \"ll an app from the web, optional packages, and related sets.\\n\\n# <span id=\\\"page-68-0\\\"></span>How to c\", \"reate an MSIX package from an existing Win32 desktop application\\n\\nLet's go through the process to cr\", \"eate an MSIX package from an existing Win32 application. In this example, we'll use a Windows Forms \", \"app.\\n\\nTo start, add a new project to your solution, select the Windows Application Packaging Project\", \", and give it a name.\\n\\n![](_page_69_Figure_1.jpeg)\\n\\nYou'll see the structure of the packaging projec\", \"t and note a special folder called *Applications*. Inside this folder, you can specify which applica\", \"tions you want to include in the package. It can be more than one.\\n\\n![](_page_70_Figure_0.jpeg)\\n\\nRig\", \"ht-click on the *Applications* folder and select the Windows Forms project you want to package from \", \"the Visual Studio solution.\\n\\n![](_page_71_Picture_0.jpeg)\\n\\nAt this point, you can compile and genera\", \"te the package but let's examine a couple of things. To have a better user experience, Visual Studio\", \" can autogenerate all the visual assets a modern application needs to handle icons and tile assets f\", \"or the tile bar and start menu. Open the *Package.appxmanifest* file to access the Manifest Designer\", \". You can then generate all the visual assets from a given image present on your project just by cli\", \"cking **Create**.\\n\\n![](_page_71_Figure_2.jpeg)\\n\\nIf you open the code for the *Package.appxmanifest* \", \"file, you can see a couple of interesting things.\\n\\nRight under <Package>, there's an <Identity> node\", \". This is where your packaged application is going to get its identity, which will be managed by the\", \" OS.\\n\\nIn the <Capabilities> node, you can find all the requirements the application needs, paying sp\", \"ecial attention to the <rescap:Capability Name=\\\"runFullTrust\\\" \\\\>, which tells the OS to run the app \", \"in full trust mode since it's a Win32 application.\\n\\n![](_page_73_Figure_0.jpeg)\\n\\nSet the packaging p\", \"roject as the startup project for the solution and select *Run*. This is going to:\\n\\n- Compile the Wi\", \"ndows Forms application.\\n- Create an MSIX package out of the build results.\\n- Deploy the packages.\\n-\", \" Install it locally on the development machine.\\n- Launch the app.\\n\\n![](_page_74_Picture_0.jpeg)\\n\\nWit\", \"h this, you have the clean install and uninstall experience that MSIX provides fully integrated into\", \" Windows 10/Windows 11.\\n\\nThe final stage is about how you deploy the MSIX package to another machine\", \".\\n\\nRight-click on the packaging project, select the **Store** menu, and then select the **Create App\", \" Packages** option.\\n\\nThen, you can choose between creating a package to upload to the store or creat\", \"ing packages for sideloading. In most modernization scenarios, you'll choose **I want to create pack\", \"ages for sideloading**.\\n\\n![](_page_75_Figure_0.jpeg)\\n\\nThere you can select the different architectur\", \"es you want to target as you can include as many as you want into the same MSIX package.\\n\\nThe final \", \"step is to declare where you want to deploy the final installation assets.\\n\\n![](_page_76_Picture_0.j\", \"peg)\\n\\nYou can choose to use a web server or a shared UNC path on your enterprise file servers. Pay a\", \"ttention to the settings to specify how you want to update your application. We'll cover application\", \" updates in the next section.\\n\\n<span id=\\\"page-76-0\\\"></span>For a detailed step-by-step guide, see [P\", \"ackage a desktop app from source code using Visual Studio.](https://docs.microsoft.com/windows/msix/\", \"desktop/desktop-to-uwp-packaging-dot-net)\\n\\n# Auto Updates in MSIX\\n\\nThe Windows Store has a great upd\", \"ating mechanism using Windows Update. In most enterprise scenarios, you don't use the Store to distr\", \"ibute your desktop apps. So, you need a similar way to configure updates for your application and pu\", \"ll them to your users.\\n\\nUsing a combination of Windows 10/Windows 11 features and MSIX packages, you\", \" can provide a great updating experience for your users. In fact, the user doesn't need to be techni\", \"cal at all but still benefits from a seamless application update experience.\\n\\nYou can configure your\", \" updates to interact with the user in two different ways:\\n\\n- User prompted updates: The OS shows som\", \"e autogenerated nice UI to notify the user about the application it's about to install. It builds th\", \"is UI based on the properties you specify on your installation files.\\n- Silent updates in the backgr\", \"ound. With this option, your users don't need to be aware of the updates.\\n\\nYou can also configure wh\", \"en you want to perform updates: either when the application launches or on a regular basis. Thanks t\", \"o the side-loading features, you can even get these updates while the application is running.\\n\\nWhen \", \"you use this type of deployment, a special file is created called *.appinstaller*. This simple file \", \"contains the following sections:\\n\\n- The location of the *.appinstaller* file\\n- The application's mai\", \"n MSIX package properties\\n- The update behavior\\n\\nIn combination with this file, Microsoft has design\", \"ed a special URL protocol to launch the installation process from a link:\\n\\n```\\n<a href=\\\"ms-appinstal\", \"ler:?source=http://mywebservice.azureedge.net/MyApp.msix\\\">Install \\napp package </a>\\n```\\n\\nThis protoc\", \"ol works on all browsers and launches the installation process with a great user experience on Windo\", \"ws 10/Windows 11. Since the OS manages the installation process, it's aware of the location this app\", \"lication was installed from and tracks all the files affected by the process.\\n\\nMSIX creates a user i\", \"nterface for installation automatically showing some properties of the package. This allows for a co\", \"mmon installation experience for every app.\\n\\nOnce you've generated the new MSIX package and moved it\", \" to the deployment server, you just have to edit the *.appinstaller* file to reflect these changes: \", \"mainly the version and the path to the new MSIX file. The next time the user launches the applicatio\", \"n, the system will detect the change and download the files for the new version in the background. W\", \"hen the download is finished, installation will execute transparently for your user on new applicati\", \"on launch.\"]"