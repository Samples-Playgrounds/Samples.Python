|    | Factor                  | Explanation                                        |
|---:|:------------------------|:---------------------------------------------------|
|  0 | 5 - Build, Release, Run | Each release must enforce a strict separation      |
|  1 |                         | across the build, release, and run stages. Each    |
|  2 |                         | should be tagged with a unique ID and support      |
|  3 |                         | the ability to roll back. Modern CI/CD systems     |
|  4 |                         | help fulfill this principle.                       |
|  5 | 6 - Processes           | Each microservice should execute in its own        |
|  6 |                         | process, isolated from other running services.     |
|  7 |                         | Externalize required state to a backing service    |
|  8 |                         | such as a distributed cache or data store.         |
|  9 | 7 - Port Binding        | Each microservice should be self-contained with    |
| 10 |                         | its interfaces and functionality exposed on its    |
| 11 |                         | own port. Doing so provides isolation from         |
| 12 |                         | other microservices.                               |
| 13 | 8 - Concurrency         | When capacity needs to increase, scale out         |
| 14 |                         | services horizontally across multiple identical    |
| 15 |                         | processes (copies) as opposed to scaling-up a      |
| 16 |                         | single large instance on the most powerful         |
| 17 |                         | machine available. Develop the application to be   |
| 18 |                         | concurrent making scaling out in cloud             |
| 19 |                         | environments seamless.                             |
| 20 | 9 - Disposability       | Service instances should be disposable. Favor      |
| 21 |                         | fast startup to increase scalability opportunities |
| 22 |                         | and graceful shutdowns to leave the system in a    |
| 23 |                         | correct state. Docker containers along with an     |
| 24 |                         | orchestrator inherently satisfy this requirement.  |
| 25 | 10 - Dev/Prod Parity    | Keep environments across the application           |
| 26 |                         | lifecycle as similar as possible, avoiding costly  |
| 27 |                         | shortcuts. Here, the adoption of containers can    |
| 28 |                         | greatly contribute by promoting the same           |
| 29 |                         | execution environment.                             |
| 30 | 11 - Logging            | Treat logs generated by microservices as event     |
| 31 |                         | streams. Process them with an event                |
| 32 |                         | aggregator. Propagate log data to data-            |
| 33 |                         | mining/log management tools like Azure             |
| 34 |                         | Monitor or Splunk and eventually to long-term      |
| 35 |                         | archival.                                          |
| 36 | 12 - Admin Processes    | Run administrative/management tasks, such as       |
| 37 |                         | data cleanup or computing analytics, as one-off    |
| 38 |                         | processes. Use independent tools to invoke         |
| 39 |                         | these tasks from the production environment,       |
| 40 |                         | but separately from the application.               |