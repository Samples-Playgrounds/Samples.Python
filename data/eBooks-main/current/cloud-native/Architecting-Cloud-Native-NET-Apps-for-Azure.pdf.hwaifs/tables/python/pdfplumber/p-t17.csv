,0,1
0,Factor,Explanation
1,"5 - Build, Release, Run","Each release must enforce a strict separation
across the build, release, and run stages. Each
should be tagged with a unique ID and support
the ability to roll back. Modern CI/CD systems
help fulfill this principle."
2,6 - Processes,"Each microservice should execute in its own
process, isolated from other running services.
Externalize required state to a backing service
such as a distributed cache or data store."
3,7 - Port Binding,"Each microservice should be self-contained with
its interfaces and functionality exposed on its
own port. Doing so provides isolation from
other microservices."
4,8 - Concurrency,"When capacity needs to increase, scale out
services horizontally across multiple identical
processes (copies) as opposed to scaling-up a
single large instance on the most powerful
machine available. Develop the application to be
concurrent making scaling out in cloud
environments seamless."
5,9 - Disposability,"Service instances should be disposable. Favor
fast startup to increase scalability opportunities
and graceful shutdowns to leave the system in a
correct state. Docker containers along with an
orchestrator inherently satisfy this requirement."
6,10 - Dev/Prod Parity,"Keep environments across the application
lifecycle as similar as possible, avoiding costly
shortcuts. Here, the adoption of containers can
greatly contribute by promoting the same
execution environment."
7,11 - Logging,"Treat logs generated by microservices as event
streams. Process them with an event
aggregator. Propagate log data to data-
mining/log management tools like Azure
Monitor or Splunk and eventually to long-term
archival."
8,12 - Admin Processes,"Run administrative/management tasks, such as
data cleanup or computing analytics, as one-off
processes. Use independent tools to invoke
these tasks from the production environment,
but separately from the application."
