"[\"EDITION v7.0 - Updated to ASP.NET Core 7.0\\nRefer changelog for the book updates and community contri\", \"butions.\\nPUBLISHED BY\\nMicrosoft Developer Division, .NET, and Visual Studio product teams\\nA division\", \" of Microsoft Corporation\\nOne Microsoft Way\\nRedmond, Washington 98052-6399\\nCopyright \\u00a9 2023 by Micro\", \"soft Corporation\\nAll rights reserved. No part of the contents of this book may be reproduced or tran\", \"smitted in any\\nform or by any means without the written permission of the publisher.\\nThis book is pr\", \"ovided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions and\\ninformation ex\", \"pressed in this book, including URL and other Internet website references, may change\\nwithout notice\", \".\\nSome examples depicted herein are provided for illustration only and are fictitious. No real assoc\", \"iation\\nor connection is intended or should be inferred.\\nMicrosoft and the trademarks listed at https\", \"://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are\\ntrademarks of the Microsoft group of companies.\", \"\\nThe Docker whale logo is a registered trademark of Docker, Inc. Used by permission.\\nAll other marks\", \" and logos are property of their respective owners.\\nAuthors:\\nMark Rendle - Chief Technical Officer -\", \" Visual Recode\\nMiranda Steiner - Technical Author\\nEditor:\\nMaira Wenzel - Sr. Content Developer - Mic\", \"rosoft\\nIntroduction\\ngRPC is a modern framework for building networked services and distributed appli\", \"cations. Imagine\\nthe performance of Windows Communication Foundation (WCF) NetTCP bindings, combined\", \" with the\\ncross-platform interoperability of SOAP. gRPC builds on HTTP/2 and the Protobuf message-en\", \"coding\\nprotocol to provide high performance, low-bandwidth communication between applications and\\nse\", \"rvices. It supports server and client code generation across most popular programming languages\\nand \", \"platforms, including .NET, Java, Python, Node.js, Go, and C++. With the first-class support for\\ngRPC\", \" in ASP.NET Core 7.0, alongside the existing gRPC tools and libraries for .NET Framework 4.x, it\\u2019s\\na\", \"n excellent alternative to WCF for development teams looking to adopt .NET in their organizations.Wh\", \"o should use this guide\\nThis guide was written for developers working in .NET Framework or .NET who \", \"have previously used\\nWCF, and who are seeking to migrate their applications to a modern RPC environm\", \"ent for .NET Core\\n3.0 and later versions. More generally, if you are upgrading, or considering upgra\", \"ding, to .NET 7, and\\nyou want to use the built-in gRPC tools, this guide is also useful.\\nHow you can\", \" use this guide\\nThis is a short introduction to building gRPC Services in ASP.NET Core 7.0, with par\", \"ticular reference to\\nWCF as an analogous platform. It explains the principles of gRPC, relating each\", \" concept to the\\nequivalent features of WCF, and offers guidance for migrating an existing WCF applic\", \"ation to gRPC.\\nIt\\u2019s also useful for developers who have experience with WCF and are looking to learn\", \" gRPC to build\\nnew services. You can use the sample applications as a template or reference for your\", \" own projects,\\nand you are free to copy and reuse code from the book or its samples.\\nFeel free to fo\", \"rward this guide to your team to help ensure a common understanding of these\\nconsiderations and oppo\", \"rtunities. Having everybody working from a common set of terms and\\nunderlying principles helps ensur\", \"e consistent application of architectural patterns and practices.\\nReferences\\n\\u2022 gRPC website https://\", \"grpc.io\\n\\u2022 Choosing between .NET 5 and .NET Framework for server apps\\nhttps://learn.microsoft.com/dot\", \"net/standard/choosing-core-framework-serverContents\\nIntroduction to gRPC for WCF developers ........\", \"................................................................... 1\\nHistory ......................\", \"....................................................................................................\", \"................................................................ 1\\nMicroservices ...................\", \"....................................................................................................\", \"...................................................... 2\\nAbout this guide ..........................\", \"....................................................................................................\", \"......................................... 3\\nWho this guide is for ..................................\", \"....................................................................................................\", \"........................ 3\\ngRPC overview ...........................................................\", \".............................................................. 4\\nKey principles ....................\", \"....................................................................................................\", \".................................................... 4\\nHow gRPC approaches RPC .....................\", \"....................................................................................................\", \"........................ 5\\nInterface Definition Language ...........................................\", \"................................................................................................. 6\\n\", \"Network protocols ..................................................................................\", \"................................................................................. 7\\nKey features of \", \"HTTP/2 .............................................................................................\", \"........................................................ 7\\nWhy we recommend gRPC for WCF developers \", \"....................................................................................................\", \"..... 8\\nSimilarity to WCF ..........................................................................\", \"....................................................................................... 8\\nBenefits o\", \"f gRPC .............................................................................................\", \"..................................................................... 8\\nComparison with CoreWCF ....\", \"....................................................................................................\", \"..................................... 9\\nProtocol buffers ...........................................\", \".......................................................................... 11\\nHow Protobuf works ...\", \"....................................................................................................\", \"..................................................... 11\\nProtobuf messages .........................\", \"....................................................................................................\", \".................................. 11\\nDeclaring a message ..........................................\", \"....................................................................................................\", \"......... 11\\nField numbers .........................................................................\", \"........................................................................................... 12\\nTypes\", \" ...................................................................................................\", \".................................................................................. 13\\nThe generated \", \"code ...............................................................................................\", \"......................................................... 13\\nProtobuf scalar data types ............\", \"....................................................................................................\", \"................................ 13\\nOther .NET primitive types .....................................\", \"....................................................................................................\", \".. 14\\nDecimals .....................................................................................\", \".......................................................................................... 16\\nProtob\", \"uf nested types ....................................................................................\", \".................................................................... 17\\nRepeated fields for lists an\", \"d arrays ...........................................................................................\", \"..................................... 18\\nProtobuf reserved fields ..................................\", \"....................................................................................................\", \"............... 18\\ni ContentsProtobuf Any and Oneof fields for variant types .......................\", \".............................................................................. 19\\nAny ..............\", \"....................................................................................................\", \"....................................................................... 19\\nOneof ...................\", \"....................................................................................................\", \"............................................................. 20\\nProtobuf enumerations .............\", \"....................................................................................................\", \"..................................... 21\\nProtobuf maps for dictionaries ............................\", \"....................................................................................................\", \"........ 22\\nUsing MapField properties in code ......................................................\", \"..................................................................... 22\\nFurther reading ...........\", \"....................................................................................................\", \".................................................. 23\\nComparing WCF to gRPC ........................\", \".............................................................................. 24\\ngRPC example .....\", \"....................................................................................................\", \"............................................................... 24\\nWCF endpoints and gRPC methods ..\", \"....................................................................................................\", \"........................ 25\\nOperationContract properties ...........................................\", \".......................................................................................... 25\\nWCF bi\", \"ndings and transports ..............................................................................\", \"............................................................ 26\\nNetTCP .............................\", \"....................................................................................................\", \"................................................. 26\\nHTTP ..........................................\", \"....................................................................................................\", \"........................................ 27\\nNamed pipes ............................................\", \"....................................................................................................\", \"...................... 27\\nMSMQ .....................................................................\", \"....................................................................................................\", \".......... 27\\nWebHttpBinding .......................................................................\", \"........................................................................................ 27\\nTypes of\", \" RPC ...............................................................................................\", \"............................................................................ 27\\nRequest/reply.......\", \"....................................................................................................\", \".......................................................... 28\\nWCF duplex, one way to client ........\", \"....................................................................................................\", \"....................... 28\\nWCF one-way operations and gRPC client streaming ........................\", \".............................................................. 30\\nWCF full-duplex services .........\", \"....................................................................................................\", \".................................. 31\\nMetadata .....................................................\", \"....................................................................................................\", \"......................... 32\\nError handling ........................................................\", \"....................................................................................................\", \"............. 33\\nRaise errors in ASP.NET Core gRPC .................................................\", \"......................................................................... 34\\nCatch errors in gRPC cl\", \"ients ..............................................................................................\", \"........................................... 34\\ngRPC richer error model .............................\", \"....................................................................................................\", \"............... 35\\nWS-* protocols...................................................................\", \"....................................................................................................\", \" 35\\nMetadata exchange: WS-Policy, WS-Discovery, and so on ..........................................\", \"................................... 35\\nSecurity: WS-Security, WS-Federation, XML Encryption, and so \", \"on ............................................................ 35\\nWS-ReliableMessaging ............\", \"....................................................................................................\", \".................................. 36\\nWS-Transaction, WS-Coordination ..............................\", \"............................................................................................. 36\\nii \", \"ContentsMigrate a WCF solution to gRPC .............................................................\", \"............................ 37\\nCreate a new ASP.NET Core gRPC project .............................\", \"..................................................................................... 37\\nCreate the \", \"project by using Visual Studio .....................................................................\", \"......................................... 37\\nCreate the project by using the .NET CLI ..............\", \".................................................................................................. 4\", \"0\\nClean up the example code ........................................................................\", \"................................................................. 41\\nMigrate a WCF request-reply ser\", \"vice to a gRPC unary RPC ...........................................................................\", \"..... 42\\nThe WCF solution ..........................................................................\", \"................................................................................... 42\\nThe portfolio\", \"s.proto file .......................................................................................\", \".......................................................... 44\\nConvert the DataContract classes to gR\", \"PC messages ....................................................................................... \", \"44\\nConvert ServiceContract to a gRPC service .......................................................\", \".................................................... 45\\nMigrate the PortfolioData library to .NET ..\", \"....................................................................................................\", \"......... 46\\nUse ASP.NET Core dependency injection .................................................\", \".............................................................. 47\\nImplement the gRPC service........\", \"....................................................................................................\", \"............................ 48\\nGenerate client code ...............................................\", \"....................................................................................................\", \".... 50\\nMigrate WCF duplex services to gRPC ........................................................\", \"................................................................. 53\\nServer streaming RPC ..........\", \"....................................................................................................\", \"....................................... 53\\nBidirectional streaming .................................\", \"....................................................................................................\", \"............. 58\\ngRPC streaming services vs. repeated fields .......................................\", \"....................................................................... 63\\nWhen to use repeated fiel\", \"ds..................................................................................................\", \"...................................... 63\\nWhen to use stream methods ...............................\", \"....................................................................................................\", \".. 64\\nCreate gRPC client libraries .................................................................\", \".............................................................................. 64\\nUseful extensions \", \"....................................................................................................\", \"......................................................... 65\\nSummary ...............................\", \"....................................................................................................\", \"........................................... 67\\nSecurity in gRPC applications .......................\", \"....................................................................... 68\\nWCF authentication and au\", \"thorization ........................................................................................\", \"................................ 68\\ngRPC authentication and authorization ..........................\", \"............................................................................................. 68\\nCal\", \"l credentials ......................................................................................\", \"................................................................................. 69\\nWS-Federation .\", \"....................................................................................................\", \"............................................................. 69\\nJWT Bearer tokens .................\", \"....................................................................................................\", \"...................................... 69\\nAdd authentication and authorization to the server........\", \".................................................................................. 70\\nProvide call c\", \"redentials in the client application ...............................................................\", \".................................. 71\\nChannel credentials ..........................................\", \"....................................................................................................\", \"................ 72\\niii ContentsAdd certificate authentication to the server .......................\", \"................................................................................... 72\\nProvide chann\", \"el credentials in the client application ...........................................................\", \"............................. 73\\nCombine ChannelCredentials and CallCredentials ....................\", \"......................................................................... 74\\nEncryption and network \", \"security ...........................................................................................\", \"......................................... 75\\ngRPC in production ....................................\", \"........................................................................... 77\\nSelf-hosted gRPC appl\", \"ications ...........................................................................................\", \"............................................. 77\\nRun your app as a Windows service .................\", \"....................................................................................................\", \".... 77\\nRun your app as a Linux service with systemd ...............................................\", \"...................................................... 78\\nHTTPS certificates for self-hosted applica\", \"tions ..............................................................................................\", \"...... 80\\nCreate Docker images .....................................................................\", \".................................................................................... 81\\nMicrosoft ba\", \"se images for ASP.NET Core applications ............................................................\", \"......................... 81\\nCreate a Docker image .................................................\", \"................................................................................................. 82\", \"\\nBuild the image ...................................................................................\", \".............................................................................. 84\\nRun the image in a\", \" container on your machine .........................................................................\", \"......................... 84\\nPush the image to a registry ..........................................\", \".............................................................................................. 84\\nKu\", \"bernetes ...........................................................................................\", \".................................................................................... 85\\nKubernetes t\", \"erminology .........................................................................................\", \"....................................................... 85\\nGet started with Kubernetes .............\", \"....................................................................................................\", \"....................... 86\\nRun services on Kubernetes ..............................................\", \"........................................................................................... 87\\nServi\", \"ce meshes ..........................................................................................\", \"............................................................................. 93\\nService mesh option\", \"s ..................................................................................................\", \".................................................... 94\\nExample: Add Linkerd to a deployment .......\", \"....................................................................................................\", \"....... 94\\nLoad balancing gRPC .....................................................................\", \"..................................................................................... 97\\nL4 load bal\", \"ancers .............................................................................................\", \"................................................................ 97\\nL7 load balancers ..............\", \"....................................................................................................\", \"........................................... 97\\nLoad balancing within Kubernetes ....................\", \"....................................................................................................\", \".... 98\\nApplication Performance Management .........................................................\", \".............................................................. 98\\nThe difference between logging and\", \" metrics ...........................................................................................\", \"............ 98\\nLogging in ASP.NET Core gRPC .......................................................\", \".......................................................................... 98\\nMetrics in ASP.NET Cor\", \"e gRPC .............................................................................................\", \"...................................... 99\\nDistributed tracing ......................................\", \"....................................................................................................\", \"............... 101\\nAppendix A - Transactions ......................................................\", \"........................................... 104\\niv Contents1\\nCHAPTER\\nIntroduction to gRPC for\\nWCF de\", \"velopers\\nHelping machines communicate with each other has been one of the primary preoccupations of \", \"the\\ndigital age. In particular, there\\u2019s an ongoing effort to determine the optimal remote communicat\", \"ion\\nmechanism that will suit the interoperability demands of the current infrastructure. As you can\\n\", \"imagine, that mechanism changes as either the demands or the infrastructure evolves.\\nThe release of \", \".NET Core 3.0 marks a shift in the way that Microsoft delivers remote communication\\nsolutions to dev\", \"elopers who want to deliver services across a range of platforms. .NET Core and later\\ndoesn\\u2019t offer \", \"Windows Communication Foundation (WCF) out of the box but, with the release of\\nASP.NET Core 3.0, it \", \"does provide built-in gRPC functionality.\\ngRPC is a popular framework in the wider software communit\", \"y. It\\u2019s used by developers across many\\nprogramming languages for modern RPC scenarios. The community\", \" and the ecosystem are vibrant\\nand active. Support for the gRPC protocol is being added to infrastru\", \"cture components like\\nKubernetes, service meshes, load balancers, and more. These factors, together \", \"with its performance,\\nefficiency, and cross-platform compatibility, make gRPC a natural choice for n\", \"ew apps and WCF apps\\nmoving to .NET.\\nHistory\\nThe fundamental principle of a computer network as noth\", \"ing more than a group of computers\\nexchanging data with each other to achieve a set of interrelated \", \"tasks hasn\\u2019t changed since its\\ninception. But the complexity, scale, and expectations have grown exp\", \"onentially.\\nDuring the 1990s, the emphasis was mainly on improving internal networks that used the s\", \"ame\\nlanguage and platforms. TCP/IP became the gold standard for this type of communication.\\nThe focu\", \"s soon shifted to how best to optimize communication across multiple platforms by\\npromoting a langua\", \"ge-agnostic approach. Service-oriented architecture (SOA) provided a structure\\nfor loosely coupling \", \"a broad collection of services that could be provided to an application.\\nThe development of web serv\", \"ices occurred when all major platforms could access the internet, but\\nthey still couldn\\u2019t interact w\", \"ith each other. Web services have open standards and protocols,\\nincluding:\\n\\u2022 XML to tag and code dat\", \"a.\\n1 CHAPTER 1 | Introduction to gRPC for WCF developers\\u2022 Simple Object Access Protocol (SOAP) to tr\", \"ansfer data.\\n\\u2022 Web Services Definition Language (WSDL) to describe and connect web services to clien\", \"t\\napplications.\\n\\u2022 Universal Description, Discovery, and Integration (UDDI) to make web services disc\", \"overable by\\nother services.\\nSOAP defines the rules by which distributed elements of an application c\", \"an communicate with each\\nother, even if they\\u2019re on different platforms. SOAP is based on XML, so it\\u2019\", \"s human-readable. The\\nsacrifice for making SOAP easily understood is size; SOAP messages are larger \", \"than messages in\\ncomparable protocols. SOAP was designed to break monolithic applications into multi\", \"component\\nform without losing security or control. So WCF was designed to work with that kind of sys\", \"tem, unlike\\ngRPC, which began as a distributed system. WCF addressed some of these limitations by de\", \"veloping\\nand documenting proprietary extension protocols for the SOAP stack, but at the cost of a la\", \"ck of\\nsupport from other platforms.\\nWindows Communication Foundation is a framework for building ser\", \"vices. It was designed in the early\\n2000s to help developers using early SOA to manage the complexit\", \"ies of working with SOAP.\\nAlthough it removes the requirement for the developers to write their own \", \"SOAP protocols, WCF still\\nuses SOAP to enable interoperability with other systems. WCF was also desi\", \"gned to deliver solutions\\nacross multiple protocols (HTTP/1.1, Net.TCP, and so on).\\nMicroservices\\nIn\", \" microservice architectures, large applications are built as a collection of smaller modular service\", \"s.\\nEach component does a specific task or process, and components are designed to work interoperably\", \"\\nbut can be isolated as necessary.\\nAdvantages to microservices include:\\n\\u2022 Changes and upgrades can b\", \"e handled independently.\\n\\u2022 Error handling becomes more efficient because problems can be traced to s\", \"pecific services\\nthat are then isolated, rebuilt, tested, and redeployed independently of the other \", \"services.\\n\\u2022 Scalability can be confined to specific instances or services rather than the whole appl\", \"ication.\\n\\u2022 Development can happen across multiple teams, with less friction than occurs when many\\nte\", \"ams work on a single codebase.\\nThe move towards increasing virtualization, cloud computing, containe\", \"rs, and the Internet of Things\\nhas contributed to the ongoing rise of microservices. But microservic\", \"es aren\\u2019t without their challenges.\\nThe fragmented/decentralized infrastructure put more emphasis on\", \" the need for simplicity and speed\\nwhen communicating between services. This in turn drew attention \", \"to the sometimes laborious and\\ncontorted nature of SOAP.\\nIt was into this environment that gRPC was \", \"launched, 10 years after Microsoft first released WCF.\\nEvolved directly from Google\\u2019s internal infra\", \"structure RPC (Stubby), gRPC was never based on the\\nsame standards and protocols that had informed t\", \"he parameters of many earlier RPCs. And gRPC was\\nonly ever based on HTTP/2. That\\u2019s why it could draw\", \" on the new capabilities that advanced transport\\nprotocol provided. In particular, bidirectional str\", \"eaming, binary messaging, and multiplexing.\\n2 CHAPTER 1 | Introduction to gRPC for WCF developersAbo\", \"ut this guide\\nThis guide covers the key features of gRPC. The early chapters take a high-level look \", \"at the main\\nfeatures of WCF and compare them to those of gRPC. It identifies where there are direct \", \"correlations\\nbetween WCF and gRPC and also where gRPC offers an advantage. When there\\u2019s no correlati\", \"on\\nbetween WCF and gRPC, or when gRPC isn\\u2019t able to offer an equivalent solution to WCF, this guide\\n\", \"will suggest workarounds or where to go for more information.\\nUsing a set of sample WCF applications\", \", Chapter 5 is a deep-dive look at converting the main types of\\nWCF service (simple request-reply, o\", \"ne-way, and streaming) to their equivalents in gRPC.\\nThe final section of the book looks at how to g\", \"et the best from gRPC in practice. This section includes\\ninformation on using additional tools, like\", \" Docker containers or Kubernetes, to take advantage of the\\nefficiency of gRPC. It also includes a de\", \"tailed look at monitoring with logging, metrics, and distributed\\ntracing.\\nWho this guide is for\\nThis\", \" guide was written for developers working in .NET Framework or .NET Core who have used WCF\\nand who a\", \"re seeking to migrate their applications to a modern RPC environment for .NET Core 3.0\\nand later ver\", \"sions. The guide might also be useful more generally for developers upgrading or\\nconsidering upgradi\", \"ng to .NET and who want to use the built-in gRPC tools.\\n3 CHAPTER 1 | Introduction to gRPC for WCF d\", \"evelopers2\\nCHAPTER\\ngRPC overview\\nAfter looking at the genesis of both Windows Communication Foundati\", \"on (WCF) and gRPC in the last\\nchapter, this chapter considers some of the key features of gRPC and h\", \"ow they compare to WCF.\\nASP.NET Core 3.0 is the first release of ASP.NET that natively supports gRPC\", \" as a first-class citizen,\\nwith Microsoft teams contributing to the official .NET implementation of \", \"gRPC. It\\u2019s recommended for\\nbuilding distributed applications with .NET that can interoperate with al\", \"l other major programming\\nlanguages and frameworks.\\nKey principles\\nAs discussed in chapter 1, Google\", \" wanted to use the introduction of HTTP/2 to replace Stubby, its\\ninternal, general purpose RPC infra\", \"structure. gRPC, based on Stubby, now can take advantage of\\nstandardization and would extend its app\", \"licability to mobile computing, the cloud, and the Internet of\\nThings.\\nTo achieve this standardizati\", \"on, the Cloud Native Computing Foundation (CNCF) established a set of\\nprinciples that would govern g\", \"RPC. The following list shows the most relevant ones, which are\\nprimarily concerned with maximizing \", \"accessibility and usability:\\n\\u2022 Free and open \\u2013 All artifacts should be open source, with licensing t\", \"hat doesn\\u2019t constrain\\ndevelopers from adopting gRPC.\\n\\u2022 Coverage and simplicity \\u2013 gRPC should be avai\", \"lable across every popular platform, and\\nsimple enough to build on any platform.\\n\\u2022 Interoperability \", \"and reach \\u2013 It should be possible to use gRPC on any network, regardless of\\nbandwidth or latency, by\", \" using widely available network standards.\\n\\u2022 General purpose and performant \\u2013 The framework should b\", \"e usable by as broad a range of\\nuse-cases as possible, without compromising performance.\\n\\u2022 Streaming\", \" \\u2013 The protocol should provide streaming semantics for large datasets or\\nasynchronous messaging.\\n\\u2022 M\", \"etadata exchange \\u2013 The protocol allows non-business data, such as authentication tokens,\\nto be handl\", \"ed separately from actual business data.\\n\\u2022 Standardized status codes \\u2013 The variability of error code\", \"s should be reduced to make error\\nhandling decisions clearer. Where additional, richer error handlin\", \"g is required, a mechanism\\nshould be provided for managing behavior within the metadata exchange.\\n4 \", \"CHAPTER 2 | gRPC overviewHow gRPC approaches RPC\\nWindows Communication Foundation (WCF) and gRPC are\", \" both implementations of the Remote\\nProcedure Call (RPC) pattern. This pattern aims to make calls to\", \" services that run on a different\\nmachine, or in a different process, work seamlessly, like method c\", \"alls in the client application. While\\nthe aims of WCF and gRPC are the same, the details of the impl\", \"ementation are quite different.\\nThe following table sets out how the key features of WCF relate to g\", \"RPC, and where you can find\\nmore detailed explanations.\\nFeatures WCF gRPC\\nObjective Separate busines\", \"s Separate business code\\ncode from from interface definition\\nnetworking and networking\\nimplementatio\", \"n. implementation.\\nDefine services and messages (chapters 3-4) Service Contract, Uses proto file to\\n\", \"Operation declare services and\\nContract, and messages.\\nData Contract.\\nLanguage (chapters 3-5) Contra\", \"cts written Protocol Buffer\\nin C# or Visual language.\\nBasic.\\nWire format (chapter 3) Configurable, P\", \"rotocol Buffer binary\\nincluding format (although it\\u2019s\\nSOAP/XML, Plain possible to use other\\nXML, JSO\", \"N, and formats).\\n.NET Binary.\\nInteroperability (chapter 4) When using Official support: .NET,\\nSOAP o\", \"ver HTTP. Java, Python, JavaScript,\\nC/C++, Go, Rust, Ruby,\\nSwift, Dart, PHP.\\nUnofficial support for\\n\", \"other languages from\\nthe community.\\nNetworking (chapter 4) Configured at run HTTP/2, currently over\\n\", \"time. Switch TCP only with ASP.NET\\nbetween NetTCP, Core gRPC.\\nHTTP, and\\nMSMQ.\\n5 CHAPTER 2 | gRPC ove\", \"rviewFeatures WCF gRPC\\nApproach (chapter 4) Runtime Build-time generation of\\ngeneration of serializa\", \"tion,\\nserialization, deserialization, and\\ndeserialization, networking code in base\\nand networking cl\", \"asses.\\ncode in base\\nclasses.\\nSecurity (chapter 6) Authentication, Credentials, ASP.NET\\nWS-Security, \", \"Core security, TLS\\nmessage networking.\\nencryption.\\nInterface Definition Language\\nWith Windows Commun\", \"ication Foundation (WCF), services can expose description metadata by using\\nthe Web Service Definiti\", \"on Language (WSDL). WSDL is generated dynamically by using .NET reflection\\nat run time. Developers c\", \"an use this metadata to generate clients for those services, potentially in\\nother languages if they\\u2019\", \"re using a platform-neutral binding such as SOAP over HTTP.\\ngRPC uses the Interface Definition Langu\", \"age (IDL) from Protocol Buffers. The Protocol Buffers IDL is a\\ncustom, platform-neutral language wit\", \"h an open specification. Developers author .proto files to\\ndescribe services, along with their input\", \"s and outputs. These .proto files can then be used to generate\\nlanguage- or platform-specific stubs \", \"for clients and servers, allowing multiple different platforms to\\ncommunicate. By sharing .proto fil\", \"es, teams can generate code to use each others\\u2019 services, without\\nneeding to take a code dependency.\", \"\\nOne of the advantages of the Protobuf IDL is that as a custom language, it enables gRPC to be\\ncompl\", \"etely language and platform agnostic, not favoring any technology over another.\\nThe Protobuf IDL is \", \"also designed for humans to both read and write, whereas WSDL is intended as a\\nmachine-readable/writ\", \"able format. Changing the WSDL of a WCF service typically requires changing\\nthe service, running the\", \" service, and regenerating the WSDL file from the server. By contrast, with a\\n.proto file, changes a\", \"re simple to apply with a text editor, and automatically flow through the\\ngenerated code. Visual Stu\", \"dio 2022 builds .proto files in the background when they are saved. With\\nother editors, such as VS C\", \"ode, the changes are applied when the project is built.\\nWhen compared with XML, and particularly SOA\", \"P, messages encoded by using Protobuf have many\\nadvantages. Protobuf messages tend to be smaller tha\", \"n the same data serialized as SOAP XML, and\\nencoding, decoding, and transmitting them over a network\", \" can be faster.\\nThe potential disadvantage of Protobuf compared to SOAP is that, because the message\", \"s aren\\u2019t\\nreadable by humans, additional tooling is required to debug message content.\\n6 CHAPTER 2 | \", \"gRPC overviewTip\\ngRPC does support server reflection for dynamically accessing services without pre-\", \"compiled stubs,\\nalthough it\\u2019s intended more for general-purpose tools than application-specific clie\", \"nts. For more\\ninformation, see GRPC Server Reflection Protocol on GitHub.\\nNote\\nWCF\\u2019s binary format, \", \"used with the NetTCP binding, is much closer to Protobuf in terms of\\ncompactness and performance. Bu\", \"t NetTCP is only usable between .NET clients and servers, whereas\\nProtobuf is a cross-platform solut\", \"ion.\\nNetwork protocols\\nUnlike Windows Communication Foundation (WCF), gRPC uses HTTP/2 as a base for\", \" its networking.\\nThis protocol offers significant advantages over WCF and SOAP, which operate only o\", \"n HTTP/1.1. For\\ndevelopers wanting to use gRPC, given that there\\u2019s no alternative to HTTP/2, it woul\", \"d seem to be the\\nideal moment to explore HTTP/2 in more detail and identify additional benefits of u\", \"sing gRPC.\\nHTTP/2, released by Internet Engineering Task Force in 2015, was derived from the experim\", \"ental SPDY\\nprotocol, which was already being used by Google. It was specifically designed to be more\", \" efficient,\\nfaster, and more secure than HTTP/1.1.\\nKey features of HTTP/2\\nThis list shows some of th\", \"e key features and advantages of HTTP/2:\\nBinary protocol\\nRequest/response cycles no longer need text\", \" commands. This activity simplifies and speeds up the\\nimplementation of commands. Specifically, pars\", \"ing data is faster and uses less memory, network\\nlatency is reduced with obvious related improvement\", \"s to speed, and there\\u2019s an overall better use of\\nnetwork resources.\\nStreams\\nStreams allow you to cre\", \"ate long-lived connections between sender and receiver, over which multiple\\nmessages or frames can b\", \"e sent asynchronously. Multiple streams can operate independently over a\\nsingle HTTP/2 connection.\\nR\", \"equest multiplexing over a single TCP connection\\nThis feature is one of the most important innovatio\", \"ns of HTTP/2. Because it allows multiple parallel\\nrequests for data, it\\u2019s now possible to download w\", \"eb files concurrently from a single server. Websites\\nload faster, and the need for optimization is r\", \"educed. Head-of-line (HOL) blocking, where responses\\n7 CHAPTER 2 | gRPC overviewthat are ready must \", \"wait to be sent until an earlier request is completed, is also mitigated (although\\nHOL blocking can \", \"still occur at the TCP-transport level).\\nNet.TCP-like performance, cross-platform\\nFundamentally, the\", \" combination of gRPC and HTTP/2 offers developers at least the equivalent speed\\nand efficiency of Ne\", \"t.TCP bindings for WCF, and in some cases even greater speed and efficiency. But,\\nunlike Net.TCP, gR\", \"PC over HTTP/2 isn\\u2019t constrained to .NET applications.\\nWhy we recommend gRPC for WCF developers\\nBefo\", \"re we dive deeply into the language and techniques of gRPC, it\\u2019s worth discussing why gRPC is\\nthe ri\", \"ght solution for Windows Communication Foundation (WCF) developers who want to migrate to\\n.NET.\\nSimi\", \"larity to WCF\\nAlthough the implementation and approach are different for gRPC, the experience of dev\", \"eloping and\\nconsuming services with gRPC should be intuitive for WCF developers. The underlying goal\", \" is the\\nsame: make it possible to code as though the client and server are on the same platform, wit\", \"hout\\nneeding to worry about networking.\\nBoth platforms share the principle of declaring and then imp\", \"lementing an interface, even though the\\nprocess for declaring that interface is different. And as yo\", \"u\\u2019ll see in chapter 5, the different types of\\nRPC calls that gRPC supports map well to the bindings \", \"available to WCF services.\\nBenefits of gRPC\\ngRPC stands above other solutions for the following reas\", \"ons.\\nPerformance\\nUsing HTTP/2 rather than HTTP/1.1 removes the requirement for human-readable messag\", \"es and\\ninstead uses the smaller, faster binary protocol. This is more efficient for computers to par\", \"se. HTTP/2\\nalso supports multiplexing requests over a single connection. This support enables respon\", \"ses to be\\nsent as soon as they\\u2019re ready without the need to wait in a queue. (In HTTP/1.1, this issu\", \"e is known as\\n\\u201chead-of-line (HOL) blocking.\\u201d) You need fewer resources when using gRPC, which makes \", \"it a good\\nsolution to use for mobile devices and over slower networks.\\nInteroperability\\nThere are gR\", \"PC tools and libraries for all major programming languages and platforms, including\\n.NET, Java, Pyth\", \"on, Go, C++, Node.js, Swift, Dart, Ruby, and PHP. Thanks to the Protocol Buffers binary\\nwire format \", \"and the efficient code generation for each platform, developers can build performant\\napps while stil\", \"l enjoying full cross-platform support.\\n8 CHAPTER 2 | gRPC overviewUsability and productivity\\ngRPC i\", \"s a comprehensive RPC solution. It works consistently across multiple languages and platforms.\\nIt al\", \"so provides excellent tooling, with much of the necessary boilerplate code automatically\\ngenerated. \", \"So more developer time is freed up to focus on business logic.\\nStreaming\\ngRPC has full bidirectional\", \" streaming, which provides similar functionality to WCF\\u2019s full-duplex\\nservices. gRPC streaming can o\", \"perate over regular internet connections, load balancers, and service\\nmeshes.\\nDeadline/timeouts and \", \"cancellation\\ngRPC allows clients to specify a maximum time for an RPC to finish. If the specified de\", \"adline is\\nexceeded, the server can cancel the operation independently of the client. Deadlines and c\", \"ancellations\\ncan be propagated through further gRPC calls to help enforce resource usage limits. Cli\", \"ents can also\\nstop operations when a deadline is exceeded, or earlier if necessary (for example, bec\", \"ause of a user\\ninteraction).\\nSecurity\\ngRPC is implicitly secure when it\\u2019s using HTTP/2 over a TLS en\", \"d-to-end encrypted connection. Support\\nfor client certificate authentication (see chapter 6) further\", \" increases security and trust between client\\nand server.\\nComparison with CoreWCF\\nA notable alternati\", \"ve to gRPC for replacing WCF services when migrating to .NET is CoreWCF. Both\\ngRPC and CoreWCF are M\", \"icrosoft endorsed paths forward for WCF applications and each comes with\\nits own benefits and drawba\", \"cks.\\nCoreWCF is a community-owned .NET Foundation project supported by Microsoft that implements\\nWCF\", \" server APIs for .NET. CoreWCF is an effort to allow existing WCF services to work with minimal\\nchan\", \"ges on .NET. Your Data Contracts for WCF are unchanged with CoreWCF, and it supports many of\\nthe bin\", \"dings and APIs from WCF. The main differences are around the patterns for starting WCF\\nservices, and\", \" not all configuration options are available (some configuration must now be done in\\ncode).\\nServices\", \" and interfaces can often migrate with few changes. Because of this, a key benefit of CoreWCF\\nis its\", \" very high compatibility with WCF. Where changes have been made, they are to adapt to the\\nprogrammin\", \"g style of modern .NET, for example hosting now through ASP.NET Core, and APIs now\\nuse the Task base\", \"d async patterns usable with await rather than the older BeginXXX / EndXXX pattern.\\nOn the other han\", \"d, gRPC is a modern remote communication solution with a number of features, as\\ndiscussed previously\", \". Benefits of using gRPC include better interoperability across languages, its\\nrelatively simple mod\", \"ern API, and a broad community ecosystem.\\nWhen deciding whether to use CoreWCF or gRPC to migrate a \", \"WCF application to .NET, CoreWCF is\\ntypically a better fit if the goal is to migrate the application\", \" with minimal changes whereas gRPC may\\n9 CHAPTER 2 | gRPC overviewbe a better fit if the goal is to \", \"modernize the application while retargeting to .NET. The remainder of\\nthis guide focuses on that mod\", \"ernization with gRPC.\\n10 CHAPTER 2 | gRPC overview3\\nCHAPTER\\nProtocol buffers\\ngRPC services send and \", \"receive data as Protocol Buffer (Protobuf) messages, similar to data contracts in\\nWindows Communicat\", \"ion Foundation (WCF). Protobuf is an efficient way of serializing structured data\\nfor machines to re\", \"ad and write, without the overhead that human-readable formats like XML or JSON\\nincur.\\nThis chapter \", \"covers how Protobuf works, and how to define your own Protobuf messages.\\nHow Protobuf works\\nMost .NE\", \"T object serialization techniques, including WCF\\u2019s data contracts, work by using reflection to\\nanaly\", \"ze the object structure at run time. By contrast, most Protobuf libraries require you to define the\\n\", \"structure up front by using a dedicated language (Protocol Buffer Language) in a .proto file. A comp\", \"iler\\nthen uses this file to generate code for any of the supported platforms. Supported platforms in\", \"clude\\n.NET, Java, C/C++, JavaScript, and many more.\\nThe Protobuf compiler, protoc, is maintained by \", \"Google, although alternative implementations are\\navailable. The generated code is efficient and opti\", \"mized for fast serialization and deserialization of\\ndata.\\nThe Protobuf wire format is a binary encod\", \"ing. It uses some clever tricks to minimize the number of\\nbytes used to represent messages. Knowledg\", \"e of the binary encoding format isn\\u2019t necessary to use\\nProtobuf. But if you\\u2019re interested, you can l\", \"earn more about it on the Protocol Buffers website.\\nProtobuf messages\\nThis section covers how to dec\", \"lare Protocol Buffer (Protobuf) messages in .proto files. It explains the\\nfundamental concepts of fi\", \"eld numbers and types, and it looks at the C# code that the protoc\\ncompiler generates.\\nThe rest of t\", \"he chapter will look in more detail at how different types of data are represented in\\nProtobuf.\\nDecl\", \"aring a message\\nIn Windows Communication Foundation (WCF), a Stock class for a stock market trading \", \"application\\nmight be defined like the following example:\\nnamespace TraderSys;\\n11 CHAPTER 3 | Protoco\", \"l buffers[DataContract]\\npublic class Stock\\n{\\n[DataMember]\\npublic int Id { get; set; }\\n[DataMember]\\np\", \"ublic string Symbol { get; set; }\\n[DataMember]\\npublic string DisplayName { get; set; }\\n[DataMember]\\n\", \"public int MarketId { get; set; }\\n}\\nTo implement the equivalent class in Protobuf, you must declare \", \"it in the .proto file. The protoc\\ncompiler will then generate the .NET class as part of the build pr\", \"ocess.\\nsyntax = \\\"proto3\\\";\\noption csharp_namespace = \\\"TraderSys\\\";\\nmessage Stock {\\nint32 id = 1;\\nstrin\", \"g symbol = 2;\\nstring display_name = 3;\\nint32 market_id = 4;\\n}\\nThe first line declares the syntax ver\", \"sion being used. Version 3 of the language was released in 2016.\\nIt\\u2019s the version that we recommend \", \"for gRPC services.\\nThe option csharp_namespace line specifies the namespace to be used for the gener\", \"ated C# types.\\nThis option will be ignored when the .proto file is compiled for other languages. Pro\", \"tobuf files often\\ncontain language-specific options for several languages.\\nThe Stock message definit\", \"ion specifies four fields. Each has a type, a name, and a field number.\\nField numbers\\nField numbers \", \"are an important part of Protobuf. They\\u2019re used to identify fields in the binary encoded\\ndata, which\", \" means they can\\u2019t change from version to version of your service. The advantage is that\\nbackward com\", \"patibility and forward compatibility are possible. Clients and services will ignore field\\nnumbers th\", \"at they don\\u2019t know about, as long as the possibility of missing values is handled.\\nIn the binary for\", \"mat, the field number is combined with a type identifier. Field numbers from 1 to 15\\ncan be encoded \", \"with their type as a single byte. Numbers from 16 to 2,047 take 2 bytes. You can go\\nhigher if you ne\", \"ed more than 2,047 fields on a message for any reason. The single-byte identifiers for\\nfield numbers\", \" 1 to 15 offer better performance, so you should use them for the most basic, frequently\\nused fields\", \".\\n12 CHAPTER 3 | Protocol buffersTypes\\nThe type declarations are using Protobuf\\u2019s native scalar data\", \" types, which are discussed in more detail\\nin the next section. The rest of this chapter will cover \", \"Protobuf\\u2019s built-in types and show how they\\nrelate to common .NET types.\\nNote\\nProtobuf doesn\\u2019t nativ\", \"ely support a decimal type, so double is used instead. For applications that\\nrequire full decimal pr\", \"ecision, refer to the section on decimals in the next part of this chapter.\\nThe generated code\\nWhen \", \"you build your application, Protobuf creates classes for each of your messages, mapping its\\nnative t\", \"ypes to C# types. The generated Stock type would have the following signature:\\npublic class Stock\\n{\\n\", \"public int Id { get; set; }\\npublic string Symbol { get; set; }\\npublic string DisplayName { get; set;\", \" }\\npublic int MarketId { get; set; }\\n}\\nThe actual code that\\u2019s generated is far more complicated than\", \" this. The reason is that each class\\ncontains all the code necessary to serialize and deserialize it\", \"self to the binary wire format.\\nProperty names\\nNote that the Protobuf compiler applied PascalCase to\", \" the property names, although they were\\nsnake_case in the .proto file. The Protobuf style guide reco\", \"mmends using snake_case in your message\\ndefinitions so that the code generation for other platforms \", \"produces the expected case for their\\nconventions.\\nProtobuf scalar data types\\nProtocol Buffer (Protob\", \"uf) supports a range of native scalar value types. The following table lists them\\nall with their equ\", \"ivalent C# type:\\nProtobuf type C# type Notes\\ndouble double\\nFloat float\\nint32 int 1\\nint64 long 1\\nuint\", \"32 uint\\nuint64 ulong\\n13 CHAPTER 3 | Protocol buffersProtobuf type C# type Notes\\nsint32 int 1\\nsint64 \", \"long 1\\nfixed32 uint 2\\nfixed64 ulong 2\\nsfixed32 int 2\\nsfixed64 long 2\\nbool bool\\nstring string 3\\nbytes\", \" ByteString 4\\nNotes:\\n1. The standard encoding for int32 and int64 is inefficient when you\\u2019re working\", \" with signed\\nvalues. If your field is likely to contain negative numbers, use sint32 or sint64 inste\", \"ad. These\\ntypes map to the C# int and long types, respectively.\\n2. The fixed fields always use the s\", \"ame number of bytes no matter what the value is. This\\nbehavior makes serialization and deserializati\", \"on faster for larger values.\\n3. Protobuf strings are UTF-8 (or 7-bit ASCII) encoded. The encoded len\", \"gth can\\u2019t be greater than\\n232.\\n4. The Protobuf runtime provides a ByteString type that maps easily t\", \"o and from C# byte[]\\narrays.\\nOther .NET primitive types\\nDates and times\\nThe native scalar types don\\u2019\", \"t provide for date and time values, equivalent to C#\\u2019s DateTimeOffset,\\nDateTime, and TimeSpan. You c\", \"an specify these types by using some of Google\\u2019s \\u201cWell Known Types\\u201d\\nextensions. These extensions pro\", \"vide code generation and runtime support for complex field types\\nacross the supported platforms.\\nThe\", \" following table shows the date and time types:\\nC# type Protobuf well-known type\\nDateTimeOffset goog\", \"le.protobuf.Timestamp\\nDateTime google.protobuf.Timestamp\\nTimeSpan google.protobuf.Duration\\nsyntax = \", \"\\\"proto3\\\"\\nimport \\\"google/protobuf/duration.proto\\\";\\nimport \\\"google/protobuf/timestamp.proto\\\";\\nmessage \", \"Meeting {\\n14 CHAPTER 3 | Protocol buffersstring subject = 1;\\ngoogle.protobuf.Timestamp time = 2;\\ngoo\", \"gle.protobuf.Duration duration = 3;\\n}\\nThe generated properties in the C# class aren\\u2019t the .NET date \", \"and time types. The properties use the\\nTimestamp and Duration classes in the Google.Protobuf.WellKno\", \"wnTypes namespace. These classes\\nprovide methods for converting to and from DateTimeOffset, DateTime\", \", and TimeSpan.\\n// Create Timestamp and Duration from .NET DateTimeOffset and TimeSpan\\nvar meeting =\", \" new Meeting\\n{\\nTime = Timestamp.FromDateTimeOffset(meetingTime), // also FromDateTime()\\nDuration = D\", \"uration.FromTimeSpan(meetingLength)\\n};\\n// Convert Timestamp and Duration to .NET DateTimeOffset and \", \"TimeSpan\\nDateTimeOffset time = meeting.Time.ToDateTimeOffset();\\nTimeSpan? duration = meeting.Duratio\", \"n?.ToTimeSpan();\\nNote\\nThe Timestamp type works with UTC times. DateTimeOffset values always have an \", \"offset of zero, and\\nthe DateTime.Kind property is always DateTimeKind.Utc.\\nSystem.Guid\\nProtobuf does\", \"n\\u2019t directly support the Guid type, known as UUID on other platforms. There\\u2019s no well-\\nknown type fo\", \"r it.\\nThe best approach is to handle Guid values as a string field, by using the standard 8-4-4-4-12\", \"\\nhexadecimal format (for example, 45a9fda3-bd01-47a9-8460-c1cd7484b0b3). All languages and\\nplatforms\", \" can parse that format.\\nDon\\u2019t use a bytes field for Guid values. Problems with endianness (Wikipedia\", \" definition) can result in\\nerratic behavior when Protobuf is interacting with other platforms, such \", \"as Java.\\nNullable types\\nThe Protobuf code generation for C# uses the native types, such as int for i\", \"nt32. So the values are\\nalways included and can\\u2019t be null.\\nFor values that require explicit null, su\", \"ch as using int? in your C# code, Protobuf\\u2019s \\u201cWell Known Types\\u201d\\ninclude wrappers that are compiled t\", \"o nullable C# types. To use them, import wrappers.proto into\\nyour .proto file, like this:\\nsyntax = \\\"\", \"proto3\\\"\\nimport \\\"google/protobuf/wrappers.proto\\\";\\nmessage Person {\\n15 CHAPTER 3 | Protocol buffers...\", \"\\ngoogle.protobuf.Int32Value age = 5;\\n}\\nProtobuf will use the simple T? (for example, int?) for the g\", \"enerated message property.\\nThe following table shows the complete list of wrapper types with their e\", \"quivalent C# type:\\nC# type Well Known Type wrapper\\ndouble? google.protobuf.DoubleValue\\nfloat? google\", \".protobuf.FloatValue\\nint? google.protobuf.Int32Value\\nlong? google.protobuf.Int64Value\\nuint? google.p\", \"rotobuf.UInt32Value\\nulong? google.protobuf.UInt64Value\\nThe well-known types Timestamp and Duration a\", \"re represented in .NET as classes. In C# 8 and\\nbeyond, you can use nullable reference types. But it\\u2019\", \"s important to check for null on properties of\\nthose types when you\\u2019re converting to DateTimeOffset \", \"or TimeSpan.\\nDecimals\\nProtobuf doesn\\u2019t natively support the .NET decimal type, just double and float\", \". There\\u2019s an ongoing\\ndiscussion in the Protobuf project about the possibility of adding a standard D\", \"ecimal type to the well-\\nknown types, with platform support for languages and frameworks that suppor\", \"t it. Nothing has been\\nimplemented yet.\\nIt\\u2019s possible to create a message definition to represent th\", \"e decimal type that would work for safe\\nserialization between .NET clients and servers. But develope\", \"rs on other platforms would have to\\nunderstand the format being used and implement their own handlin\", \"g for it.\\nCreating a custom decimal type for Protobuf\\nA simple implementation might be similar to th\", \"e nonstandard Money type that some Google APIs\\nuse, without the currency field.\\npackage CustomTypes;\", \"\\n// Example: 12345.6789 -> { units = 12345, nanos = 678900000 }\\nmessage DecimalValue {\\n// Whole unit\", \"s part of the amount\\nint64 units = 1;\\n// Nano units of the amount (10^-9)\\n// Must be same sign as un\", \"its\\nsfixed32 nanos = 2;\\n}\\n16 CHAPTER 3 | Protocol buffersThe nanos field represents values from 0.99\", \"9_999_999 to -0.999_999_999. For example, the decimal\\nvalue 1.5m would be represented as { units = 1\", \", nanos = 500_000_000 }. This is why the nanos field in\\nthis example uses the sfixed32 type, which e\", \"ncodes more efficiently than int32 for larger values. If the\\nunits field is negative, the nanos fiel\", \"d should also be negative.\\nNote\\nThere are multiple other algorithms for encoding decimal values as b\", \"yte strings, but this message is\\neasier to understand than any of them. The values are not affected \", \"by endianness on different\\nplatforms.\\nConversion between this type and the BCL decimal type might be\", \" implemented in C# like this:\\nnamespace CustomTypes;\\npublic partial class DecimalValue\\n{\\nprivate con\", \"st decimal NanoFactor = 1_000_000_000;\\npublic DecimalValue(long units, int nanos)\\n{\\nUnits = units;\\nN\", \"anos = nanos;\\n}\\npublic static implicit operator decimal(CustomTypes.DecimalValue grpcDecimal)\\n{\\nretu\", \"rn grpcDecimal.Units + grpcDecimal.Nanos / NanoFactor;\\n}\\npublic static implicit operator CustomTypes\", \".DecimalValue(decimal value)\\n{\\nvar units = decimal.ToInt64(value);\\nvar nanos = decimal.ToInt32((valu\", \"e - units) * NanoFactor);\\nreturn new CustomTypes.DecimalValue(units, nanos);\\n}\\n}\\nImportant\\nWhenever \", \"you use custom message types like this, you must document them with comments in\\n.proto. Other develo\", \"pers can then implement conversion to and from the equivalent type in their own\\nlanguage or framewor\", \"k.\\nProtobuf nested types\\nJust as C# allows you to declare classes inside other classes, Protocol Buf\", \"fer (Protobuf) allows you to\\nnest message definitions within other messages. The following example s\", \"hows how to create nested\\nmessage types:\\nmessage Outer {\\nmessage Inner {\\nstring text = 1;\\n}\\n17 CHAPT\", \"ER 3 | Protocol buffersInner inner = 1;\\n}\\nIn the generated C# code, the Inner type will be declared \", \"in a nested static Types class within the\\nHelloRequest class:\\nvar inner = new Outer.Types.Inner { Te\", \"xt = \\\"Hello\\\" };\\nRepeated fields for lists and arrays\\nYou specify lists in Protocol Buffer (Protobuf)\", \" by using the repeated prefix keyword. The following\\nexample shows how to create a list:\\nmessage Per\", \"son {\\n// Other fields elided\\nrepeated string aliases = 8;\\n}\\nIn the generated code, repeated fields a\", \"re represented by read-only properties of the\\nGoogle.Protobuf.Collections.RepeatedField<T> type rath\", \"er than any of the built-in .NET collection\\ntypes. This type implements all the standard .NET collec\", \"tion interfaces, such as IList and IEnumerable.\\nSo you can use LINQ queries or convert it to an arra\", \"y or a list easily.\\nThe RepeatedField<T> type includes the code required to serialize and deserializ\", \"e the list to the\\nbinary wire format.\\nProtobuf reserved fields\\nThe backward-compatibility guarantees\", \" in Protocol Buffer (Protobuf) rely on field numbers always\\nrepresenting the same data item. If a fi\", \"eld is removed from a message in a new version of the service,\\nthat field number should never be reu\", \"sed. You can enforce this behavior by using the reserved\\nkeyword.\\nIf the displayName and marketId fi\", \"elds were removed from the Stock message defined earlier, their\\nfield numbers should be reserved as \", \"in the following example.\\nsyntax \\\"proto3\\\";\\nmessage Stock {\\nreserved 3, 4;\\nint32 id = 1;\\nstring symbo\", \"l = 2;\\n}\\nYou can also use the reserved keyword as a placeholder for fields that might be added in th\", \"e future.\\nYou can express contiguous field numbers as a range by using the to keyword.\\nsyntax \\\"proto\", \"3\\\";\\nmessage Info {\\n18 CHAPTER 3 | Protocol buffersreserved 2, 9 to 11, 15;\\n// ...\\n}\\nProtobuf Any and\", \" Oneof fields for variant types\\nHandling dynamic property types (that is, properties of type object)\", \" in Windows Communication\\nFoundation (WCF) is complicated. For example, you must specify serializers\", \" and provide KnownType\\nattributes.\\nProtocol Buffer (Protobuf) provides two simpler options for deali\", \"ng with values that might be of more\\nthan one type. The Any type can represent any known Protobuf me\", \"ssage type. And you can use the\\noneof keyword to specify that only one of a range of fields can be s\", \"et in any message.\\nAny\\nAny is one of Protobuf\\u2019s \\u201cwell-known types\\u201d: a collection of useful, reusable\", \" message types with\\nimplementations in all supported languages. To use the Any type, you must import\", \" the\\ngoogle/protobuf/any.proto definition.\\nsyntax = \\\"proto3\\\";\\nimport \\\"google/protobuf/any.proto\\\";\\nme\", \"ssage Stock {\\n// Stock-specific data\\n}\\nmessage Currency {\\n// Currency-specific data\\n}\\nmessage Change\", \"Notification {\\nint32 id = 1;\\ngoogle.protobuf.Any instrument = 2;\\n}\\nIn the C# code, the Any class pro\", \"vides methods for setting the field, extracting the message, and\\nchecking the type.\\npublic void Form\", \"atChangeNotification(ChangeNotification change)\\n{\\nif (change.Instrument.Is(Stock.Descriptor))\\n{\\nForm\", \"atStock(change.Instrument.Unpack<Stock>());\\n}\\nelse if (change.Instrument.Is(Currency.Descriptor))\\n{\\n\", \"FormatCurrency(change.Instrument.Unpack<Currency>());\\n}\\nelse\\n{\\nthrow new ArgumentException(\\\"Unknown \", \"instrument type\\\");\\n19 CHAPTER 3 | Protocol buffers}\\n}\\nProtobuf\\u2019s internal reflection code uses the D\", \"escriptor static field on each generated type to resolve\\nAny field types. There\\u2019s also a TryUnpack<T\", \"> method, but that creates an uninitialized instance of T\\neven when it fails. It\\u2019s better to use the\", \" Is method as shown earlier.\\nOneof\\nOneof fields are a language feature: the compiler handles the one\", \"of keyword when it generates the\\nmessage class. Using oneof to specify the ChangeNotification messag\", \"e might look like this:\\nmessage Stock {\\n// Stock-specific data\\n}\\nmessage Currency {\\n// Currency-spec\", \"ific data\\n}\\nmessage ChangeNotification {\\nint32 id = 1;\\noneof instrument {\\nStock stock = 2;\\nCurrency \", \"currency = 3;\\n}\\n}\\nFields within the oneof set must have unique field numbers in the overall message \", \"declaration.\\nWhen you use oneof, the generated C# code includes an enum that specifies which of the \", \"fields has\\nbeen set. You can test the enum to find which field is set. Fields that aren\\u2019t set return\", \" null or the\\ndefault value, rather than throwing an exception.\\npublic void FormatChangeNotification(\", \"ChangeNotification change)\\n{\\nswitch (change.InstrumentCase)\\n{\\ncase ChangeNotification.InstrumentOneo\", \"fCase.None:\\nreturn;\\ncase ChangeNotification.InstrumentOneofCase.Stock:\\nFormatStock(change.Stock);\\nbr\", \"eak;\\ncase ChangeNotification.InstrumentOneofCase.Currency:\\nFormatCurrency(change.Currency);\\nbreak;\\nd\", \"efault:\\nthrow new ArgumentException(\\\"Unknown instrument type\\\");\\n}\\n}\\nSetting any field that\\u2019s part of\", \" a oneof set will automatically clear any other fields in the set. You can\\u2019t\\nuse repeated with oneof\", \". Instead, you can create a nested message with either the repeated field or\\nthe oneof set to work a\", \"round this limitation.\\n20 CHAPTER 3 | Protocol buffersProtobuf enumerations\\nProtobuf supports enumer\", \"ation types. You saw this support in the previous section, where an enum\\nwas used to determine the t\", \"ype of a Oneof field. You can define your own enumeration types, and\\nProtobuf will compile them to C\", \"# enum types.\\nBecause you can use Protobuf with various languages, the naming conventions for enumer\", \"ations are\\ndifferent from the C# conventions. However, the code generator converts the names to the \", \"traditional\\nC# case. If the Pascal-case equivalent of the field name starts with the enumeration nam\", \"e, then it\\u2019s\\nremoved.\\nFor example, in the following Protobuf enumeration, the fields are prefixed wi\", \"th ACCOUNT_STATUS.\\nThis prefix is equivalent to the Pascal-case enum name, AccountStatus.\\nenum Accou\", \"ntStatus {\\nACCOUNT_STATUS_UNKNOWN = 0;\\nACCOUNT_STATUS_PENDING = 1;\\nACCOUNT_STATUS_ACTIVE = 2;\\nACCOUN\", \"T_STATUS_SUSPENDED = 3;\\nACCOUNT_STATUS_CLOSED = 4;\\n}\\nThe generator creates a C# enum equivalent to t\", \"he following code:\\npublic enum AccountStatus\\n{\\nUnknown = 0,\\nPending = 1,\\nActive = 2,\\nSuspended = 3,\\n\", \"Closed = 4\\n}\\nProtobuf enumeration definitions must have a zero constant as their first field. As in \", \"C#, you can\\ndeclare multiple fields with the same value. But you must explicitly enable this option \", \"by using the\\nallow_alias option in the enum:\\nenum AccountStatus {\\noption allow_alias = true;\\nACCOUNT\", \"_STATUS_UNKNOWN = 0;\\nACCOUNT_STATUS_PENDING = 1;\\nACCOUNT_STATUS_ACTIVE = 2;\\nACCOUNT_STATUS_SUSPENDED\", \" = 3;\\nACCOUNT_STATUS_CLOSED = 4;\\n}\\nYou can declare enumerations at the top level in a .proto file, o\", \"r nested within a message definition.\\nNested enumerations\\u2014like nested messages\\u2014will be declared with\", \"in the .Types static class in the\\ngenerated message class.\\nThere\\u2019s no way to apply the [Flags] attri\", \"bute to a Protobuf-generated enum, and Protobuf doesn\\u2019t\\nunderstand bitwise enum combinations. Look a\", \"t the following example:\\nenum Region {\\nREGION_NONE = 0;\\n21 CHAPTER 3 | Protocol buffersREGION_NORTH_\", \"AMERICA = 1;\\nREGION_SOUTH_AMERICA = 2;\\nREGION_EMEA = 4;\\nREGION_APAC = 8;\\n}\\nmessage Product {\\nRegion \", \"available_in = 1;\\n}\\nIf you set product.AvailableIn to Region.NorthAmerica | Region.SouthAmerica, it\\u2019\", \"s serialized as the\\ninteger value 3. When a client or server tries to deserialize the value, it won\\u2019\", \"t find a match in the enum\\ndefinition for 3. The result will be Region.None.\\nThe best way to work wi\", \"th multiple enum values in Protobuf is to use a repeated field of the enum\\ntype.\\nProtobuf maps for d\", \"ictionaries\\nIt\\u2019s important to be able to represent arbitrary collections of named values in messages\", \". In .NET, this\\nactivity is commonly handled through dictionary types. The equivalent of the .NET\\nID\", \"ictionary<TKey,TValue> type in Protocol Buffer (Protobuf) is the map<key_type, value_type> type.\\nThi\", \"s section shows how to declare a map type in Protobuf, and how to use the generated code.\\nmessage St\", \"ockPrices {\\nmap<string, double> prices = 1;\\n}\\nIn the generated code, map fields are represented by r\", \"ead-only properties of the\\nGoogle.Protobuf.Collections.MapField<TKey, TValue> type. This type implem\", \"ents the standard .NET\\ncollection interfaces, including IDictionary<TKey,TValue>.\\nMap fields can\\u2019t b\", \"e directly repeated in a message definition. But you can create a nested message\\nthat contains a map\", \" and use repeated on the message type, as in the following example:\\nmessage Order {\\nmessage Attribut\", \"es {\\nmap<string, string> values = 1;\\n}\\nrepeated Attributes attributes = 1;\\n}\\nUsing MapField properti\", \"es in code\\nThe MapField properties generated from map fields are read-only, and will never be null. \", \"To set a map\\nproperty, use the Add(IDictionary<TKey,TValue> values) method on the empty MapField pro\", \"perty to\\ncopy values from any .NET dictionary.\\npublic Order CreateOrder(Dictionary<string, string> a\", \"ttributes)\\n{\\nvar order = new Order();\\norder.Attributes.Add(attributes);\\n22 CHAPTER 3 | Protocol buff\", \"ersreturn order;\\n}\\nFurther reading\\nFor more information about Protobuf, see the official Protobuf do\", \"cumentation.\\n23 CHAPTER 3 | Protocol buffers4\\nCHAPTER\\nComparing WCF to gRPC\\nThe previous chapter gav\", \"e you a good look at Protobuf and how gRPC handles messages. Before you\\nwork through a detailed conv\", \"ersion from Windows Communication Foundation (WCF) to gRPC, it\\u2019s\\nimportant to know how the features \", \"available in WCF are handled in gRPC and what workarounds you\\ncan use when there\\u2019s no gRPC equivalen\", \"t. In particular, this chapter will cover the following subjects:\\n\\u2022 Operations and methods\\n\\u2022 Binding\", \"s and transports\\n\\u2022 RPC types\\n\\u2022 Metadata\\n\\u2022 Error handling\\n\\u2022 WS-* protocols\\ngRPC example\\nWhen you crea\", \"te a new ASP.NET Core 7.0 gRPC project from Visual Studio 2022 or the command line,\\nthe gRPC equival\", \"ent of \\u201cHello World\\u201d is generated for you. It consists of a greeter.proto file that\\ndefines the serv\", \"ice and its messages, and a GreeterService.cs file with an implementation of the\\nservice.\\nsyntax = \\\"\", \"proto3\\\";\\noption csharp_namespace = \\\"HelloGrpc\\\";\\npackage Greet;\\n// The greeting service definition.\\ns\", \"ervice Greeter {\\n// Sends a greeting\\nrpc SayHello (HelloRequest) returns (HelloReply);\\n}\\n// The requ\", \"est message that contains the user's name.\\nmessage HelloRequest {\\nstring name = 1;\\n}\\n// The response\", \" message that contains the greetings.\\nmessage HelloReply {\\nstring message = 1;\\n}\\n24 CHAPTER 4 | Comp\", \"aring WCF to gRPCnamespace HelloGrpc;\\npublic class GreeterService : Greeter.GreeterBase\\n{\\nprivate re\", \"adonly ILogger<GreeterService> _logger;\\npublic GreeterService(ILogger<GreeterService> logger)\\n{\\n_log\", \"ger = logger;\\n}\\npublic override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext\\nco\", \"ntext)\\n{\\nreturn Task.FromResult(new HelloReply\\n{\\nMessage = \\\"Hello \\\" + request.Name\\n});\\n}\\n}\\nThis chap\", \"ter will refer to this example code when explaining different concepts and features of gRPC.\\nWCF end\", \"points and gRPC methods\\nIn Windows Communication Foundation (WCF), when you\\u2019re writing your applicat\", \"ion code, you use\\none of the following methods:\\n\\u2022 You write the application code in a class and deco\", \"rate methods with the OperationContract\\nattribute.\\n\\u2022 You declare an interface for the service and ad\", \"d OperationContract attributes to the interface.\\nFor example, the WCF equivalent of the greet.proto \", \"Greeter service might be written as follows:\\n[ServiceContract]\\npublic interface IGreeterService\\n{\\n[O\", \"perationContract]\\nstring SayHello(string name);\\n}\\nChapter 3 showed that Protobuf message definitions\", \" are used to generate data classes. Service and\\nmethod declarations are used to generate base classe\", \"s that you inherit from to implement the service.\\nYou just declare the methods to be implemented in \", \"the .proto file, and the compiler generates a base\\nclass with virtual methods that you must override\", \".\\nOperationContract properties\\nThe OperationContract attribute has properties to control or refine h\", \"ow it works. gRPC methods don\\u2019t\\noffer this type of control. The following table lists those Operatio\", \"nContract properties and describes\\nhow the functionality that they specify is (or isn\\u2019t) dealt with \", \"in gRPC:\\n25 CHAPTER 4 | Comparing WCF to gRPCOperationContract property gRPC\\nAction A URI identifies\", \" the operation. gRPC uses the name of\\npackage, service, and rpc from the .proto file.\\nAsyncPattern A\", \"ll gRPC service methods return Task objects.\\nIsInitiating See the paragraph after this table.\\nIsOneW\", \"ay One-way gRPC methods return Empty results or use client\\nstreaming.\\nIsTerminating See the paragrap\", \"h after this table.\\nName This property is SOAP related and has no meaning in gRPC.\\nProtectionLevel T\", \"here\\u2019s no message encryption. Network encryption is\\nhandled at the transport layer (TLS over HTTP/2)\", \".\\nReplyAction This property is SOAP related and has no meaning in gRPC.\\nThe IsInitiating property le\", \"ts you indicate that a method within ServiceContract can\\u2019t be the first\\nmethod called as part of a s\", \"ession. The IsTerminating property causes the server to close the session\\nafter an operation is call\", \"ed (or the client, if the property is used on a callback client). In gRPC, streams\\nare created by si\", \"ngle methods and closed explicitly. See gRPC streaming.\\nFor more information on gRPC security and en\", \"cryption, see chapter 6.\\nWCF bindings and transports\\nWindows Communication Foundation (WCF) has buil\", \"t-in bindings that specify different network\\nprotocols, wire formats, and other implementation detai\", \"ls. gRPC effectively has just one network\\nprotocol and one wire format. (Technically you can customi\", \"ze the wire format, but that\\u2019s beyond the\\nscope of this book.) You\\u2019re likely to discover that gRPC o\", \"ffers the best solution in most cases.\\nWhat follows is a short discussion about the most relevant WC\", \"F bindings and how they compare to\\ntheir equivalents in gRPC.\\nNetTCP\\nWCF\\u2019s NetTCP binding allows for\", \" persistent connections, small messages, and two-way messaging.\\nBut it works only between .NET clien\", \"ts and servers. gRPC allows the same functionality but is\\nsupported across multiple programming lang\", \"uages and platforms.\\ngRPC has many features of WCF\\u2019s NetTCP binding, but they\\u2019re not always implemen\", \"ted in the same\\nway. For example, in WCF, encryption is controlled through configuration and handled\", \" in the\\nframework. In gRPC, encryption is achieved at the connection level through HTTP/2 over TLS.\\n\", \"26 CHAPTER 4 | Comparing WCF to gRPCHTTP\\nThe WCF binding called BasicHttpBinding is usually text-bas\", \"ed and uses SOAP as the wire format. It\\u2019s\\nslow compared to the NetTCP binding. It\\u2019s used to provide \", \"cross-platform interoperability, or\\nconnection over internet infrastructure.\\nThe equivalent in gRPC \", \"uses HTTP/2 as the underlying transport layer with the binary Protobuf wire\\nformat for messages. So \", \"it can offer performance at the NetTCP service level and full cross-platform\\ninteroperability with a\", \"ll modern programming languages and frameworks.\\nNamed pipes\\nWCF provided a named pipes binding for c\", \"ommunication between processes on the same physical\\nmachine. ASP.NET Core gRPC doesn\\u2019t support named\", \" pipes. For inter-process communication (IPC)\\nusing gRPC instead supports Unix domain sockets. Unix \", \"domain sockets are supported on Linux and\\nmodern versions of Windows.\\nFor more information, see Inte\", \"r-process communication with gRPC.\\nMSMQ\\nMSMQ is a proprietary Windows message queue. WCF\\u2019s binding t\", \"o MSMQ enables \\u201cfire and forget\\u201d\\nrequests from clients that might be processed at any time in the fu\", \"ture. gRPC doesn\\u2019t natively provide\\nany message queue functionality.\\nThe best alternative is to dire\", \"ctly use a messaging system like Azure Service Bus, RabbitMQ, or Kafka.\\nYou can implement this funct\", \"ionality with the client placing messages directly onto the queue, or a\\ngRPC client streaming servic\", \"e that enqueues the messages.\\nWebHttpBinding\\nWebHttpBinding (also known as WCF REST), with the WebGe\", \"t and WebInvoke attributes, enabled you\\nto develop RESTful APIs that could speak JSON at a time when\", \" this behavior was less common. If you\\nhave a RESTful API built with WCF REST, consider migrating it\", \" to a regular ASP.NET Core MVC Web\\nAPI application. This migration would provide the same functional\", \"ity as a conversion to gRPC.\\nTypes of RPC\\nAs a Windows Communication Foundation (WCF) developer, you\", \"\\u2019re probably used to dealing with the\\nfollowing types of remote procedure call (RPC):\\n\\u2022 Request/repl\", \"y\\n\\u2022 Duplex:\\n\\u2013 One-way duplex with session\\n\\u2013 Full duplex with session\\n\\u2022 One-way\\n27 CHAPTER 4 | Compar\", \"ing WCF to gRPCIt\\u2019s possible to map these RPC types fairly naturally to existing gRPC concepts. This\", \" chapter will look at\\neach of these areas in turn. Chapter 5 will explore similar examples in greate\", \"r depth.\\nWCF gRPC\\nRegular request/reply Unary\\nDuplex service with session using a client Server stre\", \"aming\\ncallback interface\\nFull duplex service with session Bidirectional streaming\\nOne-way operations\", \" Client streaming\\nRequest/reply\\nFor simple request/reply methods that take and return small amounts \", \"of data, use the simplest gRPC\\npattern, the unary RPC.\\nservice Things {\\nrpc Get(GetThingRequest) ret\", \"urns (GetThingResponse);\\n}\\npublic class ThingService : Things.ThingsBase\\n{\\npublic override async Tas\", \"k<GetThingResponse> Get(GetThingRequest request,\\nServerCallContext context)\\n{\\n// Get thing from data\", \"base\\nreturn new GetThingResponse { Thing = thing };\\n}\\n}\\npublic async Task ShowThing(int thingId)\\n{\\nv\", \"ar thing = await _thingsClient.GetAsync(new GetThingRequest { ThingId = thingId });\\nConsole.WriteLin\", \"e($\\\"{thing.Name}\\\");\\n}\\nAs you can see, implementing a gRPC unary RPC service method is similar to imp\", \"lementing a WCF\\noperation. The difference is that with gRPC, you override a base class method instea\", \"d of\\nimplementing an interface. On the server, gRPC base methods always return Task, although the cl\", \"ient\\nprovides both async and blocking methods to call the service.\\nWCF duplex, one way to client\\nWCF\", \" applications (with certain bindings) can create a persistent connection between client and server.\\n\", \"The server can asynchronously send data to the client until the connection is closed, by using a\\ncal\", \"lback interface specified in the ServiceContractAttribute.CallbackContract property.\\ngRPC services p\", \"rovide similar functionality with message streams. Streams don\\u2019t map exactly to WCF\\nduplex services \", \"in terms of implementation, but you can achieve the same results.\\n28 CHAPTER 4 | Comparing WCF to gR\", \"PCgRPC streaming\\ngRPC supports the creation of persistent streams from client to server, and from se\", \"rver to client. Both\\ntypes of stream can be active concurrently. This ability is called bidirectiona\", \"l streaming.\\nYou can use streams for arbitrary, asynchronous messaging over time. Or you can use the\", \"m for\\npassing large datasets that are too big to generate and send in a single request or response.\\n\", \"The following example shows a server-streaming RPC.\\nservice ClockStreamer {\\nrpc Subscribe(ClockSubsc\", \"ribeRequest) returns (stream ClockMessage);\\n}\\npublic class ClockStreamerService : ClockStreamer.Cloc\", \"kStreamerBase\\n{\\npublic override async Task Subscribe(ClockSubscribeRequest request,\\nIServerStreamWri\", \"ter<ClockMessage> responseStream,\\nServerCallContext context)\\n{\\nwhile (!context.CancellationToken.IsC\", \"ancellationRequested)\\n{\\nvar time = DateTimeOffset.UtcNow;\\nawait responseStream.WriteAsync(new ClockM\", \"essage { message = $\\\"The time is\\n{time:t}.\\\" });\\nawait Task.Delay(TimeSpan.FromSeconds(10), context.C\", \"ancellationToken);\\n}\\n}\\n}\\nThis server stream can be consumed from a client application, as shown in t\", \"he following code:\\npublic async Task TellTheTimeAsync(CancellationToken token)\\n{\\nvar channel = GrpcC\", \"hannel.ForAddress(\\\"https://localhost:5001\\\");\\nvar client = new ClockStreamer.ClockStreamerClient(chan\", \"nel);\\nvar request = new ClockSubscribeRequest();\\nvar response = client.Subscribe(request);\\nawait for\", \"each (var update in response.ResponseStream.ReadAllAsync(token))\\n{\\nConsole.WriteLine(update.Message)\", \";\\n}\\n}\\nNote\\nServer-streaming RPCs are useful for subscription-style services. They\\u2019re also useful for\", \" sending large\\ndatasets when it would be inefficient or impossible to build the entire dataset in me\", \"mory. However,\\nstreaming responses isn\\u2019t as fast as sending repeated fields in a single message. As \", \"a rule, streaming\\nshouldn\\u2019t be used for small datasets.\\n29 CHAPTER 4 | Comparing WCF to gRPCDifferen\", \"ces from WCF\\nA WCF duplex service uses a client callback interface that can have multiple methods. A\", \" gRPC server-\\nstreaming service can only send messages over a single stream. If you need multiple me\", \"thods, use a\\nmessage type with either an Any field or a oneof field to send different messages, and \", \"write code in\\nthe client to handle them.\\nIn WCF, the ServiceContract class with the session is kept \", \"alive until the connection is closed. Multiple\\nmethods can be called within the session. In gRPC, th\", \"e Task that the implementation method returns\\nshouldn\\u2019t finish until the connection is closed.\\nWCF o\", \"ne-way operations and gRPC client streaming\\nWCF provides one-way operations (marked with [OperationC\", \"ontract(IsOneWay = true)]) that return a\\ntransport-specific acknowledgment. gRPC service methods alw\", \"ays return a response, even if it\\u2019s\\nempty. The client should always await that response. For the \\u201cfi\", \"re-and-forget\\u201d style of messaging in\\ngRPC, you can create a client streaming service.\\nthing_log.prot\", \"o\\nservice ThingLog {\\nrpc OpenConnection(stream Thing) returns (ConnectionClosedResponse);\\n}\\nThingLog\", \"Service.cs\\npublic class ThingLogService : Protos.ThingLog.ThingLogBase\\n{\\nprivate static readonly Con\", \"nectionClosedResponse EmptyResponse = new\\nConnectionClosedResponse();\\nprivate readonly ILogger<Thing\", \"LogService> _logger;\\npublic ThingLogService(ILogger<ThingLogService> logger)\\n{\\n_logger = logger;\\n}\\np\", \"ublic override async Task<CompletedResponse> OpenConnection(IAsyncStreamReader<Thing>\\nrequestStream,\", \" ServerCallContext context)\\n{\\nwhile (await requestStream.MoveNext(context.CancellationToken))\\n{\\n_log\", \"ger.LogInformation(requestStream.Current.Description);\\n}\\nreturn EmptyResponse;\\n}\\n}\\nThingLog client e\", \"xample\\npublic class ThingLogger : IAsyncDisposable\\n{\\nprivate readonly ThingLog.ThingLogClient _clien\", \"t;\\nprivate readonly AsyncClientStreamingCall<ThingLogRequest, CompletedResponse> _stream;\\npublic Thi\", \"ngLogger(ThingLog.ThingLogClient client)\\n30 CHAPTER 4 | Comparing WCF to gRPC{\\n_client = client;\\n_st\", \"ream = client.OpenConnection();\\n}\\npublic async Task WriteAsync(string description)\\n{\\nawait _stream.R\", \"equestStream.WriteAsync(new Thing\\n{\\nDescription = description,\\nTime = Timestamp.FromDateTimeOffset(D\", \"ateTimeOffset.UtcNow)\\n});\\n}\\npublic async ValueTask DisposeAsync()\\n{\\nawait _stream.RequestStream.Comp\", \"leteAsync();\\n_stream.Dispose();\\n}\\n}\\nYou can use client-streaming RPCs for fire-and-forget messaging,\", \" as shown in the previous example.\\nYou can also use them for sending very large datasets to the serv\", \"er. The same warning about\\nperformance applies: for smaller datasets, use repeated fields in regular\", \" messages.\\nWCF full-duplex services\\nWCF duplex binding supports multiple one-way operations on both \", \"the service interface and the\\nclient callback interface. This support allows ongoing conversations b\", \"etween client and server. gRPC\\nsupports something similar with bidirectional streaming RPCs, where b\", \"oth parameters are marked\\nwith the stream modifier.\\nchat.proto\\nservice Chatter {\\nrpc Connect(stream \", \"IncomingMessage) returns (stream OutgoingMessage);\\n}\\nChatterService.cs\\npublic class ChatterService :\", \" Chatter.ChatterBase\\n{\\nprivate readonly IChatHub _hub;\\npublic ChatterService(IChatHub hub)\\n{\\n_hub = \", \"hub;\\n}\\npublic override async Task Connect(IAsyncStreamReader<MessageRequest> requestStream,\\nIServerS\", \"treamWriter<MessageResponse> responseStream, ServerCallContext context)\\n{\\n_hub.MessageReceived += as\", \"ync (sender, args) =>\\nawait responseStream.WriteAsync(new MessageResponse {Text = args.Message});\\nwh\", \"ile (await requestStream.MoveNext(context.CancellationToken))\\n{\\n31 CHAPTER 4 | Comparing WCF to gRPC\", \"await _hub.SendAsync(requestStream.Current.Text);\\n}\\n}\\n}\\nIn the previous example, you can see that th\", \"e implementation method receives both a request stream\\n(IAsyncStreamReader<MessageRequest>) and a re\", \"sponse stream\\n(IServerStreamWriter<MessageResponse>). The method can read and write messages until t\", \"he\\nconnection is closed.\\nChatter client\\npublic class Chat : IAsyncDisposable\\n{\\nprivate readonly Chat\", \"ter.ChatterClient _client;\\nprivate readonly AsyncDuplexStreamingCall<MessageRequest, MessageResponse\", \"> _stream;\\nprivate readonly CancellationTokenSource _cancellationTokenSource;\\nprivate readonly Task \", \"_readTask;\\npublic Chat(Chatter.ChatterClient client)\\n{\\n_client = client;\\n_stream = _client.Connect()\", \";\\n_cancellationTokenSource = new CancellationTokenSource();\\n_readTask = ReadAsync(_cancellationToken\", \"Source.Token);\\n}\\npublic async Task SendAsync(string message)\\n{\\nawait _stream.RequestStream.WriteAsyn\", \"c(new MessageRequest {Text = message});\\n}\\nprivate async Task ReadAsync(CancellationToken token)\\n{\\nwh\", \"ile (await _stream.ResponseStream.MoveNext(token))\\n{\\nConsole.WriteLine(_stream.ResponseStream.Curren\", \"t.Text);\\n}\\n}\\npublic async ValueTask DisposeAsync()\\n{\\nawait _stream.RequestStream.CompleteAsync();\\naw\", \"ait _readTask;\\n_stream.Dispose();\\n}\\n}\\nMetadata\\nMetadata refers to additional data that might be usef\", \"ul during the processing of requests and\\nresponses but that\\u2019s not part of the actual application dat\", \"a. Metadata might include authentication\\ntokens, request identifiers and tags for monitoring purpose\", \"s, and information about the data, like the\\nnumber of records in a dataset.\\n32 CHAPTER 4 | Comparing\", \" WCF to gRPCIt\\u2019s possible to add generic key/value headers to Windows Communication Foundation (WCF)\", \"\\nmessages by using an OperationContextScope and the OperationContext.OutgoingMessageHeaders\\nproperty\", \" and handle them by using MessageProperties.\\ngRPC calls and responses can also include metadata that\", \"\\u2019s similar to HTTP headers. This metadata is\\nmostly invisible to gRPC itself and is passed through t\", \"o be processed by your application code or\\nmiddleware. Metadata is represented as key/value pairs, w\", \"here the key is a string and the value is\\neither a string or binary data. You don\\u2019t need to specify \", \"metadata in the .proto file.\\nMetadata is handled by the Metadata class of the Grpc.Core.Api NuGet pa\", \"ckage. This class can be\\nused with collection initializer syntax.\\nThis example shows how to add meta\", \"data to a call from a C# client:\\nvar metadata = new Metadata\\n{\\n{ \\\"Requester\\\", _clientName }\\n};\\nvar r\", \"equest = new GetPortfolioRequest\\n{\\nId = portfolioId\\n};\\nvar response = await client.GetPortfolioAsync\", \"(request, metadata);\\ngRPC services can access metadata from the ServerCallContext argument\\u2019s Request\", \"Headers property:\\npublic async Task<GetPortfolioResponse> GetPortfolio(GetPortfolioRequest request,\\n\", \"ServerCallContext context)\\n{\\nvar requesterHeader = context.RequestHeaders.FirstOrDefault(e => e.Key \", \"== \\\"Requester\\\");\\nif (requesterHeader != null)\\n{\\n_logger.LogInformation($\\\"Request from {requesterHead\", \"er.Value}\\\");\\n}\\n// ...\\n}\\nServices can send metadata to clients by using the ResponseTrailers property\", \" of ServerCallContext:\\npublic async Task<GetPortfolioResponse> GetPortfolio(GetPortfolioRequest requ\", \"est,\\nServerCallContext context)\\n{\\n// ...\\ncontext.ResponseTrailers.Add(\\\"Responder\\\", _serverName);\\n// \", \"...\\n}\\nError handling\\nWindows Communication Foundation (WCF) uses FaultException and FaultContract to\", \" provide\\ndetailed error information, including supporting the SOAP Fault standard.\\n33 CHAPTER 4 | Co\", \"mparing WCF to gRPCUnfortunately, the current version of gRPC lacks the sophistication found with WC\", \"F, and only has\\nlimited built-in error handling based on simple status codes and metadata. The follo\", \"wing table is a\\nquick guide to the most commonly used status codes:\\nStatus code Problem\\nGRPC_STATUS_\", \"UNIMPLEMENTED Method hasn\\u2019t been written.\\nGRPC_STATUS_UNAVAILABLE Problem with the whole service.\\nGR\", \"PC_STATUS_UNKNOWN Invalid response.\\nGRPC_STATUS_INTERNAL Problem with encoding/decoding.\\nGRPC_STATUS\", \"_UNAUTHENTICATED Authentication failed.\\nGRPC_STATUS_PERMISSION_DENIED Authorization failed.\\nGRPC_STA\", \"TUS_CANCELLED Call was canceled, usually by the\\ncaller.\\nRaise errors in ASP.NET Core gRPC\\nAn ASP.NET\", \" Core gRPC service can send an error response by throwing an RpcException, which can be\\ncaught by th\", \"e client as if it were in the same process. The RpcException must include a status code\\nand descript\", \"ion, and can optionally include metadata and a longer exception message. The metadata\\ncan be used to\", \" send supporting data, similar to how FaultContract objects can carry additional data\\nfor WCF errors\", \".\\npublic async Task<GetPortfolioResponse> GetPortfolio(GetPortfolioRequest request,\\nServerCallContex\", \"t context)\\n{\\nvar user = context.GetHttpContext().User;\\nif (!ValidateUser(user))\\n{\\nvar metadata = new\", \" Metadata\\n{\\n{ \\\"User\\\", user.Identity.Name }\\n};\\nthrow new RpcException(new Status(StatusCode.Permissio\", \"nDenied, \\\"Permission\\ndenied\\\"), metadata);\\n}\\n}\\nCatch errors in gRPC clients\\nJust like WCF clients can\", \" catch FaultException errors, a gRPC client can catch an RpcException to\\nhandle errors. Because RpcE\", \"xception isn\\u2019t a generic type, you can\\u2019t catch different error types in\\ndifferent blocks. But you ca\", \"n use C#\\u2019s exception filters feature to declare separate catch blocks for\\ndifferent status codes, as\", \" shown in the following example:\\ntry\\n{\\nvar portfolio = await client.GetPortfolioAsync(new GetPortfol\", \"ioRequest { Id = id });\\n}\\ncatch (RpcException ex) when (ex.StatusCode == StatusCode.PermissionDenied\", \")\\n34 CHAPTER 4 | Comparing WCF to gRPC{\\nvar userEntry = ex.Trailers.FirstOrDefault(e => e.Key == \\\"Us\", \"er\\\");\\nConsole.WriteLine($\\\"User '{userEntry.Value}' does not have permission to view this\\nportfolio.\\\"\", \");\\n}\\ncatch (RpcException)\\n{\\n// Handle any other error type ...\\n}\\nImportant\\nWhen you provide addition\", \"al metadata for errors, be sure to document the relevant keys and values\\nin your API documentation, \", \"or in comments in your .proto file.\\ngRPC richer error model\\nGoogle has developed a richer error mode\", \"l that\\u2019s more like WCF\\u2019s FaultContract, but this model isn\\u2019t\\nsupported in C# yet. Currently, it\\u2019s on\", \"ly available for Go, Java, Python, and C++.\\nWS-* protocols\\nOne of the real benefits of working with \", \"Windows Communication Foundation (WCF) was that it\\nsupported many of the existing WS-* standard prot\", \"ocols. This section will briefly cover how gRPC\\nmanages the same WS-* protocols and discuss what opt\", \"ions are available when there\\u2019s no alternative.\\nMetadata exchange: WS-Policy, WS-Discovery, and so o\", \"n\\nSOAP services expose Web Services Description Language (WSDL) schema documents with\\ninformation su\", \"ch as data formats, operations, or communication options. You can use this schema to\\ngenerate the cl\", \"ient code.\\ngRPC works best when servers and clients are generated from the same .proto files, but a \", \"Server\\nReflection optional extension does provide a way to expose dynamic information from a running\", \"\\nserver. For more information, see the Grpc.Reflection NuGet package.\\nThe WS-Discovery protocol is u\", \"sed to locate services on a local network. gRPC services are located\\nthrough DNS or a service regist\", \"ry such as Consul or ZooKeeper.\\nSecurity: WS-Security, WS-Federation, XML Encryption, and so on\\nSecu\", \"rity, authentication, and authorization are covered in much more detail in chapter 6. But it\\u2019s worth\", \"\\nnoting here that, unlike WCF, gRPC doesn\\u2019t support WS-Security, WS-Federation, or XML Encryption.\\nE\", \"ven so, gRPC provides excellent security. All gRPC network traffic is automatically encrypted when i\", \"t\\u2019s\\nusing HTTP/2 over TLS. You can use X509 certificates for mutual client/server authentication.\\n35\", \" CHAPTER 4 | Comparing WCF to gRPCWS-ReliableMessaging\\ngRPC does not provide an equivalent to WS-Rel\", \"iableMessaging. Retry semantics should be handled in\\ncode, possibly with a library like Polly. When \", \"you\\u2019re running in Kubernetes or similar orchestration\\nenvironments, service meshes can also help to \", \"provide reliable messaging between services.\\nWS-Transaction, WS-Coordination\\nWCF\\u2019s implementation of\", \" distributed transactions uses Microsoft Distributed Transaction Coordinator\\n(MSDTC). It works with \", \"resource managers that specifically support it, like SQL Server, MSMQ, or\\nWindows file systems. Ther\", \"e\\u2019s no equivalent yet in the modern microservices world, in part due to the\\nwider range of technolog\", \"ies in use. For a discussion of transactions, see Appendix A.\\n36 CHAPTER 4 | Comparing WCF to gRPC5\\n\", \"CHAPTER\\nMigrate a WCF solution to\\ngRPC\\nThis chapter will describe how to work with ASP.NET Core 7.0 \", \"gRPC projects and demonstrate\\nmigrating different types of Windows Communication Foundation (WCF) se\", \"rvices to the gRPC\\nequivalent:\\n\\u2022 Create an ASP.NET Core 7.0 gRPC project.\\n\\u2022 Simple request-reply ope\", \"rations to gRPC unary RPC.\\n\\u2022 One-way operations to gRPC client streaming RPC.\\n\\u2022 Full-duplex services\", \" to gRPC bidirectional streaming RPC.\\nThere\\u2019s also a comparison of using streaming services versus r\", \"epeated fields for returning datasets,\\nand there\\u2019s a discussion of the use of client libraries at th\", \"e end of the chapter.\\nThe sample WCF application is a minimal stub of a set of stock trading service\", \"s. It uses the open-\\nsource Inversion of Control (IoC) container library called Autofac for dependen\", \"cy injection. It includes\\nthree services, one for each WCF service type. The services will be discus\", \"sed in more detail in the\\nfollowing sections. You can download the solutions from dotnet-architectur\", \"e/grpc-for-wcf-developers\\non GitHub. The services use fake data to minimize external dependencies.\\nT\", \"he samples include the WCF and gRPC implementations of each service.\\nCreate a new ASP.NET Core gRPC \", \"project\\nThe .NET SDK comes with a powerful CLI tool, dotnet, which enables you to create and manage\\n\", \"projects and solutions from the command line. The SDK is closely integrated with Visual Studio, so\\ne\", \"verything is also available through the familiar graphical user interface. This chapter shows both w\", \"ays\\nto create a new ASP.NET Core gRPC project.\\nCreate the project by using Visual Studio\\nImportant\\nT\", \"o develop any ASP.NET Core 7.0 app, you need Visual Studio 2022, with the ASP.NET and web\\ndevelopmen\", \"t workload installed.\\n37 CHAPTER 5 | Migrate a WCF solution to gRPCCreate an empty solution called T\", \"raderSys from the Blank Solution template. Add a solution folder\\ncalled src. Then, right-click on th\", \"e folder and choose Add > New Project. Enter grpc in the template\\nsearch box, and you should see a p\", \"roject template called gRPC Service.\\nSelect Next to continue to the Configure your new project dialo\", \"g box. Name the project\\nTraderSys.Portfolios and add an src subdirectory to the Location.\\n38 CHAPTER\", \" 5 | Migrate a WCF solution to gRPCSelect Next to continue to the Create a new gRPC service dialog b\", \"ox.\\n39 CHAPTER 5 | Migrate a WCF solution to gRPCAt present, you have limited options for the servic\", \"e creation. Docker will be introduced later, so for\\nnow, leave that option unselected. Just select C\", \"reate. Your first ASP.NET Core 7.0 gRPC project is\\ngenerated and added to the solution. If you don\\u2019t\", \" want to know about working with the dotnet CLI,\\nskip to the Clean up the example code section.\\nCrea\", \"te the project by using the .NET CLI\\nThis section covers the creation of solutions and projects from\", \" the command line.\\nCreate the solution as shown in the following command. The -o (or --output) flag \", \"specifies the output\\ndirectory, which is created in the current directory if it doesn\\u2019t already exis\", \"t. The solution has the same\\nname as the directory: TraderSys.sln. You can provide a different name \", \"by using the -n (or --name)\\nflag.\\ndotnet new sln -o TraderSys\\ncd TraderSys\\nASP.NET Core 7.0 comes wi\", \"th a CLI template for gRPC services. Create the new project by using this\\ntemplate, putting it into \", \"an src subdirectory as is conventional for ASP.NET Core projects. The project\\nis named after the dir\", \"ectory (TraderSys.Portfolios.csproj), unless you specify a different name with the\\n-n flag.\\ndotnet n\", \"ew grpc -o src/TraderSys.Portfolios\\nFinally, add the project to the solution by using the dotnet sln\", \" command:\\ndotnet sln add src/TraderSys.Portfolios\\n40 CHAPTER 5 | Migrate a WCF solution to gRPCTip\\nB\", \"ecause the particular directory only contains a single .csproj file, you can specify just the direct\", \"ory, to\\nsave typing.\\nYou can now open this solution in Visual Studio 2022, Visual Studio Code, or wh\", \"atever editor you\\nprefer.\\nClean up the example code\\nYou\\u2019ve now created an example service by using t\", \"he gRPC template, which was reviewed earlier in the\\nbook. This code isn\\u2019t useful in our stock tradin\", \"g context, so we\\u2019ll edit things for our first project.\\nRename and edit the proto file\\nGo ahead and r\", \"ename the Protos/greet.proto file to Protos/portfolios.proto, and open it in your\\neditor. Delete eve\", \"rything after the package line. Then change the option csharp_namespace, package\\nand service names, \", \"and remove the default SayHello service. The code now looks like the following:\\nsyntax = \\\"proto3\\\";\\no\", \"ption csharp_namespace = \\\"TraderSys.Portfolios.Protos\\\";\\npackage PortfolioServer;\\nservice Portfolios \", \"{\\n// RPCs will go here\\n}\\nTip\\nThe template doesn\\u2019t add the Protos namespace part by default, but addi\", \"ng it makes it easier to keep\\ngRPC-generated classes and your own classes clearly separated in your \", \"code.\\nIf you rename the greet.proto file in an integrated development environment (IDE) like Visual \", \"Studio, a\\nreference to this file is automatically updated in the .csproj file. But in some other edi\", \"tor, such as\\nVisual Studio Code, this reference isn\\u2019t updated automatically, so you need to edit the\", \" project file\\nmanually.\\nIn the gRPC build targets, there\\u2019s a Protobuf item element that lets you spe\", \"cify which .proto files\\nshould be compiled, and which form of code generation is required (that is, \", \"\\u201cServer\\u201d or \\u201cClient\\u201d).\\n<ItemGroup>\\n<Protobuf Include=\\\"Protos\\\\portfolios.proto\\\" GrpcServices=\\\"Server\\\"\", \" />\\n</ItemGroup>\\nRename the GreeterService class\\nThe GreeterService class is in the Services folder \", \"and inherits from Greeter.GreeterBase. Rename it to\\nPortfolioService, and change the base class to P\", \"ortfolios.PortfoliosBase. Delete the override methods.\\n41 CHAPTER 5 | Migrate a WCF solution to gRPC\", \"public class PortfolioService : Protos.Portfolios.PortfoliosBase\\n{\\n}\\nThere was a reference to the Gr\", \"eeterService class in the Program.cs. If you used refactoring to rename\\nthe class, this reference sh\", \"ould have been updated automatically. However, if you didn\\u2019t, you need to\\nedit it manually.\\nusing Tr\", \"aderSys.Portfolios.Services;\\nvar builder = WebApplication.CreateBuilder(args);\\n// Add services to th\", \"e container.\\nbuilder.Services.AddGrpc();\\nvar app = builder.Build();\\n// Configure the HTTP request pi\", \"peline.\\napp.MapGrpcService<PortfolioService>();\\napp.MapGet(\\\"/\\\", () => \\\"Communication with gRPC endpo\", \"ints must be made through a gRPC\\nclient. To learn how to create a client, visit:\\nhttps://go.microsof\", \"t.com/fwlink/?linkid=2086909\\\");\\napp.Run();\\nIn the next section, we\\u2019ll add functionality to this new \", \"service.\\nMigrate a WCF request-reply service to a gRPC\\nunary RPC\\nThis section covers how to migrate \", \"a basic request-reply service in WCF to a unary RPC service in\\nASP.NET Core gRPC. These services are\", \" the simplest service types in both Windows Communication\\nFoundation (WCF) and gRPC, so it\\u2019s an exce\", \"llent place to start. After migrating the service, you\\u2019ll learn\\nhow to generate a client library fro\", \"m the same .proto file to consume the service from a .NET client\\napplication.\\nThe WCF solution\\nThe P\", \"ortfoliosSample solution includes a simple request-reply Portfolio service to download either a\\nsing\", \"le portfolio or all portfolios for a given trader. The service is defined in the interface\\nIPortfoli\", \"oService with a ServiceContract attribute:\\n[ServiceContract]\\npublic interface IPortfolioService\\n{\\n[O\", \"perationContract]\\nTask<Portfolio> Get(Guid traderId, int portfolioId);\\n[OperationContract]\\nTask<List\", \"<Portfolio>> GetAll(Guid traderId);\\n}\\n42 CHAPTER 5 | Migrate a WCF solution to gRPCThe Portfolio mod\", \"el is a simple C# class marked with DataContract and including a list of\\nPortfolioItem objects. Thes\", \"e models are defined in the TraderSys.PortfolioData project along with a\\nrepository class that repre\", \"sents a data access abstraction.\\n[DataContract]\\npublic class Portfolio\\n{\\n[DataMember]\\npublic int Id \", \"{ get; set; }\\n[DataMember]\\npublic Guid TraderId { get; set; }\\n[DataMember]\\npublic List<PortfolioItem\", \"> Items { get; set; }\\n}\\n[DataContract]\\npublic class PortfolioItem\\n{\\n[DataMember]\\npublic int Id { get\", \"; set; }\\n[DataMember]\\npublic int ShareId { get; set; }\\n[DataMember]\\npublic int Holding { get; set; }\", \"\\n[DataMember]\\npublic decimal Cost { get; set; }\\n}\\nThe ServiceContract implementation uses a reposito\", \"ry class provided via dependency injection that\\nreturns instances of the DataContract types:\\npublic \", \"class PortfolioService : Protos.Portfolios.PortfoliosBase\\n{\\nprivate readonly IPortfolioRepository _r\", \"epository;\\npublic PortfolioService(IPortfolioRepository repository)\\n{\\n_repository = repository;\\n}\\npu\", \"blic async Task<Portfolio> Get(Guid traderId, int portfolioId)\\n{\\nreturn await _repository.GetAsync(t\", \"raderId, portfolioId);\\n}\\npublic async Task<List<Portfolio>> GetAll(Guid traderId)\\n{\\nreturn await _re\", \"pository.GetAllAsync(traderId);\\n}\\n}\\n43 CHAPTER 5 | Migrate a WCF solution to gRPCThe portfolios.prot\", \"o file\\nIf you followed the instructions in the previous section, you should have a gRPC project with\", \" a\\nportfolios.proto file that looks like this:\\nsyntax = \\\"proto3\\\";\\noption csharp_namespace = \\\"TraderS\", \"ys.Portfolios.Protos\\\";\\npackage PortfolioServer;\\nservice Portfolios {\\n// RPCs will go here\\n}\\nThe firs\", \"t step is to migrate the DataContract classes to their Protobuf equivalents.\\nConvert the DataContrac\", \"t classes to gRPC messages\\nThe PortfolioItem class will be converted to a Protobuf message first, be\", \"cause the Portfolio class\\ndepends on it. The class is simple, and three of the properties map direct\", \"ly to gRPC data types. The\\nCost property, which represents the price paid for the shares at purchase\", \", is a decimal field. gRPC\\nsupports only float or double for real numbers, which aren\\u2019t suitable for\", \" currency. Because share\\nprices vary by a minimum of one cent, the cost can be expressed as an int32\", \" of cents.\\nNote\\nRemember to use snake_case for field names in your .proto file. The C# code generato\", \"r will convert\\nthem to PascalCase for you, and users of other languages will thank you for respectin\", \"g their different\\ncoding standards.\\nmessage PortfolioItem {\\nint32 id = 1;\\nint32 share_id = 2;\\nint32 \", \"holding = 3;\\nint32 cost_cents = 4;\\n}\\nThe Portfolio class is a little more complicated. In the WCF co\", \"de, the developer used a Guid for the\\nTraderId property, and contains a List<PortfolioItem>. In Prot\", \"obuf, which doesn\\u2019t have a first-class\\nUUID type, you should use a string for the traderId field and\", \" parse it in your own code. For the list of\\nitems, use the repeated keyword on the field.\\nmessage Po\", \"rtfolio {\\nint32 id = 1;\\nstring trader_id = 2;\\nrepeated PortfolioItem items = 3;\\n}\\nNow that you have \", \"the data messages, you can declare the service RPC endpoints.\\n44 CHAPTER 5 | Migrate a WCF solution \", \"to gRPCConvert ServiceContract to a gRPC service\\nThe WCF Get method takes two parameters: Guid trade\", \"rId and int portfolioId. gRPC service methods\\ncan take only a single parameter, so you need to creat\", \"e a message to hold the two values. It\\u2019s\\ncommon practice to name these request objects with the same\", \" name as the method followed by the\\nsuffix Request. Again, string is being used for the traderId fie\", \"ld instead of Guid.\\nThe service could just return a Portfolio message directly, but again, this coul\", \"d affect backward\\ncompatibility in the future. It\\u2019s a good practice to define separate Request and R\", \"esponse messages for\\nevery method in a service, even if many of them are the same right now. So decl\", \"are a GetResponse\\nmessage with a single Portfolio field.\\nThis example shows the declaration of the g\", \"RPC service method with the GetRequest message:\\nmessage GetRequest {\\nstring trader_id = 1;\\nint32 por\", \"tfolio_id = 2;\\n}\\nmessage GetResponse {\\nPortfolio portfolio = 1;\\n}\\nservice Portfolios {\\nrpc Get(GetRe\", \"quest) returns (GetResponse);\\n}\\nThe WCF GetAll method takes only a single parameter, traderId, so it\", \" might seem that you could\\nspecify string as the parameter type. But gRPC requires a defined message\", \" type. This requirement\\nhelps to enforce the practice of using custom messages for all inputs and ou\", \"tputs, for future backward\\ncompatibility.\\nThe WCF method also returns a List<Portfolio>, but for the\", \" same reason it doesn\\u2019t allow simple\\nparameter types, gRPC won\\u2019t allow repeated Portfolio as a retur\", \"n type. Instead, create a\\nGetAllResponse type to wrap the list.\\nWarning\\nYou might be tempted to crea\", \"te a PortfolioList message or something similar and use it across\\nmultiple service methods, but you \", \"should resist this temptation. It\\u2019s impossible to know how the\\nvarious methods on a service will evo\", \"lve, so keep their messages specific and cleanly separated.\\nmessage GetAllRequest {\\nstring trader_id\", \" = 1;\\n}\\nmessage GetAllResponse {\\nrepeated Portfolio portfolios = 1;\\n}\\nservice Portfolios {\\nrpc Get(G\", \"etRequest) returns (GetResponse);\\n45 CHAPTER 5 | Migrate a WCF solution to gRPCrpc GetAll(GetAllRequ\", \"est) returns (GetAllResponse);\\n}\\nIf you save your project with these changes, the gRPC build target \", \"will run in the background and\\ngenerate all the Protobuf message types and a base class that you can\", \" inherit to implement the\\nservice.\\nOpen the Services/GreeterService.cs class and delete the example \", \"code. Now you can add the\\nPortfolio service implementation. The generated base class will be in the \", \"Protos namespace and is\\ngenerated as a nested class. gRPC creates a static class with the same name \", \"as the service in the\\n.proto file and a base class with the suffix Base inside that static class, so\", \" the full identifier for the base\\ntype is TraderSys.Portfolios.Protos.Portfolios.PortfoliosBase.\\nnam\", \"espace TraderSys.Portfolios.Services;\\npublic class PortfolioService : Protos.Portfolios.PortfoliosBa\", \"se\\n{\\n}\\nThe base class declares virtual methods for Get and GetAll that can be overridden to implemen\", \"t the\\nservice. The methods are virtual rather than abstract so that if you don\\u2019t implement them, the\", \" service\\ncan return an explicit gRPC Unimplemented status code, much like you might throw a\\nNotImple\", \"mentedException in regular C# code.\\nThe signature for all gRPC unary service methods in ASP.NET Core\", \" is consistent. There are two\\nparameters: the first is the message type declared in the .proto file,\", \" and the second is a\\nServerCallContext that works similarly to the HttpContext from ASP.NET Core. In\", \" fact, there\\u2019s an\\nextension method called GetHttpContext on the ServerCallContext class that you can\", \" use to get the\\nunderlying HttpContext, although you shouldn\\u2019t need to use it often. We\\u2019ll take a lo\", \"ok at\\nServerCallContext later in this chapter, and also in the chapter that discusses authentication\", \".\\nThe method\\u2019s return type is a Task<T>, where T is the response message type. All gRPC service\\nmeth\", \"ods are asynchronous.\\nMigrate the PortfolioData library to .NET\\nAt this point, the project needs the\", \" Portfolio repository and models contained in the\\nTraderSys.PortfolioData class library in the WCF s\", \"olution. The easiest way to bring them across is to\\ncreate a new class library by using either the V\", \"isual Studio New project dialog box with the Class\\nLibrary (.NET Standard) template, or from the com\", \"mand line by using the .NET CLI, running these\\ncommands from the directory that contains the TraderS\", \"ys.sln file:\\ndotnet new classlib -o src/TraderSys.PortfolioData\\ndotnet sln add src/TraderSys.Portfol\", \"ioData\\nAfter you\\u2019ve created the library and added it to the solution, delete the generated Class1.cs\", \" file and\\ncopy the files from the WCF solution\\u2019s library into the new class library\\u2019s folder, keepin\", \"g the folder\\nstructure:\\nModels\\nPortfolio.cs\\nPortfolioItem.cs\\n46 CHAPTER 5 | Migrate a WCF solution t\", \"o gRPCIPortfolioRepository.cs\\nPortfolioRepository.cs\\nSDK-style .NET projects automatically include a\", \"ny .cs files in or under their own directory, so you don\\u2019t\\nneed to explicitly add them to the projec\", \"t. The only step remaining is to remove the DataContract and\\nDataMember attributes from the Portfoli\", \"o and PortfolioItem classes so they\\u2019re plain old C# classes:\\npublic class Portfolio\\n{\\npublic int Id \", \"{ get; set; }\\npublic Guid TraderId { get; set; }\\npublic List<PortfolioItem> Items { get; set; }\\n}\\npu\", \"blic class PortfolioItem\\n{\\npublic int Id { get; set; }\\npublic int ShareId { get; set; }\\npublic int H\", \"olding { get; set; }\\npublic decimal Cost { get; set; }\\n}\\nUse ASP.NET Core dependency injection\\nNow y\", \"ou can add a reference to this library to the gRPC application project and consume the\\nPortfolioRepo\", \"sitory class by using dependency injection in the gRPC service implementation. In the\\nWCF applicatio\", \"n, dependency injection was provided by the Autofac IoC container. ASP.NET Core has\\ndependency injec\", \"tion baked in. You can register the repository in the Program.cs itself:\\nusing TraderSys.Portfolios.\", \"Services;\\nvar builder = WebApplication.CreateBuilder(args);\\n// Register the repository class as a sc\", \"oped service (instance per request)\\nbuilder.Services.AddScoped<IPortfolioRepository, PortfolioReposi\", \"tory>();\\nbuilder.Services.AddGrpc();\\nvar app = builder.Build();\\n// Configure the HTTP request pipeli\", \"ne.\\napp.MapGrpcService<PortfolioService>();\\napp.MapGet(\\\"/\\\", () => \\\"Communication with gRPC endpoints\", \" must be made through a gRPC\\nclient. To learn how to create a client, visit:\\nhttps://go.microsoft.co\", \"m/fwlink/?linkid=2086909\\\");\\napp.Run();\\nThe IPortfolioRepository implementation can now be specified \", \"as a constructor parameter in the\\nPortfolioService class, as follows:\\npublic class PortfolioService \", \": Protos.Portfolios.PortfoliosBase\\n{\\nprivate readonly IPortfolioRepository _repository;\\npublic Portf\", \"olioService(IPortfolioRepository repository)\\n{\\n47 CHAPTER 5 | Migrate a WCF solution to gRPC_reposit\", \"ory = repository;\\n}\\n}\\nImplement the gRPC service\\nNow that you\\u2019ve declared your messages and your ser\", \"vice in the portfolios.proto file, you have to\\nimplement the service methods in the PortfolioService\", \" class that inherits from the gRPC-generated\\nPortfolios.PortfoliosBase class. The methods are declar\", \"ed as virtual in the base class. If you don\\u2019t\\noverride them, they\\u2019ll return a gRPC \\u201cNot Implemented\\u201d\", \" status code by default.\\nStart by implementing the Get method. The default override looks like this \", \"example:\\npublic override Task<GetResponse> Get(GetRequest request, ServerCallContext context)\\n{\\nretu\", \"rn base.Get(request, context);\\n}\\nThe first problem is that request.TraderId is a string, and the ser\", \"vice requires a Guid. Even though the\\nexpected format for the string is UUID, the code has to deal w\", \"ith the possibility that a caller has sent\\nan invalid value and respond appropriately. The service c\", \"an respond with errors by throwing an\\nRpcException and use the standard InvalidArgument status code \", \"to express the problem:\\npublic override Task<GetResponse> Get(GetRequest request, ServerCallContext \", \"context)\\n{\\nif (!Guid.TryParse(request.TraderId, out var traderId))\\n{\\nthrow new RpcException(new Stat\", \"us(StatusCode.InvalidArgument, \\\"traderId must be a\\nUUID\\\"));\\n}\\nreturn base.Get(request, context);\\n}\\nA\", \"fter there\\u2019s a proper Guid value for traderId, you can use the repository to retrieve the Portfolio \", \"and\\nreturn it to the client:\\nvar response = new GetResponse\\n{\\nPortfolio = await _repository.GetAsync\", \"(request.TraderId, request.PortfolioId)\\n};\\nMap internal models to gRPC messages\\nThe previous code do\", \"esn\\u2019t actually work because the repository is returning its own POCO model\\nPortfolio, but gRPC needs\", \" its own Protobuf message Portfolio. As when you map Entity Framework\\ntypes to data transfer types, \", \"the best solution is to provide a conversion between the two. A good\\nplace to put the code for this \", \"conversion is in the Protobuf-generated class, which is declared as a\\npartial class so it can be ext\", \"ended:\\nnamespace TraderSys.Portfolios.Protos;\\npublic partial class PortfolioItem\\n{\\npublic static Por\", \"tfolioItem FromRepositoryModel(PortfolioData.Models.PortfolioItem\\n48 CHAPTER 5 | Migrate a WCF solut\", \"ion to gRPCsource)\\n{\\nif (source is null) return null;\\nreturn new PortfolioItem\\n{\\nId = source.Id,\\nSha\", \"reId = source.ShareId,\\nHolding = source.Holding,\\nCostCents = (int)(source.Cost * 100)\\n};\\n}\\n}\\npublic \", \"partial class Portfolio\\n{\\npublic static Portfolio FromRepositoryModel(PortfolioData.Models.Portfolio\", \" source)\\n{\\nif (source is null) return null;\\nvar target = new Portfolio\\n{\\nId = source.Id,\\nTraderId = \", \"source.TraderId.ToString(),\\n};\\ntarget.Items.AddRange(source.Items.Select(PortfolioItem.FromRepositor\", \"yModel));\\nreturn target;\\n}\\n}\\nNote\\nYou could use a library like AutoMapper to handle this conversion \", \"from internal model classes to\\nProtobuf types, as long as you configure the lower-level type convers\", \"ions like string/Guid or\\ndecimal/double and the list mapping.\\nNow that you have the conversion code \", \"in place, you can complete the Get method implementation:\\npublic override async Task<GetResponse> Ge\", \"t(GetRequest request, ServerCallContext context)\\n{\\nif (!Guid.TryParse(request.TraderId, out var trad\", \"erId))\\n{\\nthrow new RpcException(new Status(StatusCode.InvalidArgument, \\\"traderId must be a\\nUUID\\\"));\\n\", \"}\\nvar portfolio = await _repository.GetAsync(traderId, request.PortfolioId);\\nreturn new GetResponse\\n\", \"{\\nPortfolio = Portfolio.FromRepositoryModel(portfolio)\\n};\\n}\\n49 CHAPTER 5 | Migrate a WCF solution to\", \" gRPCThe implementation of the GetAll method is similar. Note that the repeated fields on Protobuf\\nm\", \"essages are generated as readonly properties of type RepeatedField<T>, so you have to add items\\nto t\", \"hem by using the AddRange method, like in this example:\\npublic override async Task<GetAllResponse> G\", \"etAll(GetAllRequest request, ServerCallContext\\ncontext)\\n{\\nif (!Guid.TryParse(request.TraderId, out v\", \"ar traderId))\\n{\\nthrow new RpcException(new Status(StatusCode.InvalidArgument, \\\"traderId must be a\\nUU\", \"ID\\\"));\\n}\\nvar portfolios = await _repository.GetAllAsync(traderId);\\nvar response = new GetAllResponse\", \"();\\nresponse.Portfolios.AddRange(portfolios.Select(Portfolio.FromRepositoryModel));\\nreturn response;\", \"\\n}\\nHaving successfully migrated the WCF request-reply service to gRPC, let\\u2019s look at creating a clie\", \"nt for\\nit from the .proto file.\\nGenerate client code\\nCreate a .NET Standard class library in the sam\", \"e solution to contain the client. This is primarily an\\nexample of creating client code, but you coul\", \"d package such a library by using NuGet and distribute it\\non an internal repository for other .NET t\", \"eams to consume. Go ahead and add a new .NET Standard\\nclass library called TraderSys.Portfolios.Clie\", \"nt to the solution and delete the Class1.cs file.\\nCaution\\nThe Grpc.Net.Client NuGet package requires\", \" .NET Core 3.0 or later (or another .NET Standard 2.1-\\ncompliant runtime). Earlier versions of .NET \", \"Framework and .NET Core are supported by the Grpc.Core\\nNuGet package.\\nIn Visual Studio 2022, you can\", \" add references to gRPC services in a way that\\u2019s similar to how you\\u2019d\\nadd service references to WCF \", \"projects in earlier versions of Visual Studio. Service references and\\nconnected services are all man\", \"aged under the same UI now. You can access the UI by right-clicking\\nthe Dependencies node in the Tra\", \"derSys.Portfolios.Client project in Solution Explorer and selecting\\nManage Connected Service. In the\", \" tool window that appears, select the Connected Services section,\\nthen select Add a service referenc\", \"e in Service References section, select gRPC and click Next:\\n50 CHAPTER 5 | Migrate a WCF solution t\", \"o gRPCBrowse to the portfolios.proto file in the TraderSys.Portfolios project, leave Client under Se\", \"lect the\\ntype of class to be generated, and then select OK:\\n51 CHAPTER 5 | Migrate a WCF solution to\", \" gRPCTip\\nNotice that this dialog box also provides a URL field. If your organization maintains a web\", \"-accessible\\ndirectory of .proto files, you can create clients just by setting this URL address.\\nWhen\", \" you use the Visual Studio Add Connected Service feature, the portfolios.proto file is added to\\nthe \", \"class library project as a linked file rather than copied, so changes to the file in the service pro\", \"ject\\nwill automatically be applied in the client project. The <Protobuf> element in the csproj file \", \"looks like\\nthis:\\n<Protobuf Include=\\\"..\\\\TraderSys.Portfolios\\\\Protos\\\\portfolios.proto\\\" GrpcServices=\\\"C\", \"lient\\\">\\n<Link>Protos\\\\portfolios.proto</Link>\\n</Protobuf>\\nTip\\nIf you\\u2019re not using Visual Studio or pr\", \"efer to work from the command line, you can use the dotnet-\\ngrpc global tool to manage Protobuf refe\", \"rences in a .NET gRPC project. For more information, see the\\ndotnet-grpc documentation.\\nUse the Port\", \"folios service from a client application\\nThe following code is a brief example of how to use the gen\", \"erated client in a console application. A\\nmore detailed exploration of the gRPC client code is at th\", \"e end of this chapter.\\n52 CHAPTER 5 | Migrate a WCF solution to gRPCpublic class Program\\n{\\npublic as\", \"ync Task Main(string[] args)\\n{\\nGetResponse response;\\nusing (var channel = GrpcChannel.ForAddress(\\\"ht\", \"tps://localhost:5001\\\"))\\n{\\nvar client = new Protos.Portfolios.PortfoliosClient(channel);\\nresponse = a\", \"wait client.GetAsync(new GetRequest\\n{\\nTraderId = args[0],\\nPortfolioId = int.Parse(args[1])\\n});\\n}\\nfor\", \"each (var item in response.Portfolio.Items)\\n{\\nConsole.WriteLine($\\\"Holding {item.Holding} of Share ID\", \" {item.ShareId}.\\\");\\n}\\n}\\n}\\nYou\\u2019ve now migrated a basic WCF application to an ASP.NET Core gRPC servic\", \"e and created a client to\\nconsume the service from a .NET application. The next section will cover t\", \"he more involved duplex\\nservices.\\nMigrate WCF duplex services to gRPC\\nNow that you have a sense of t\", \"he basic concepts, in this section, you\\u2019ll look at the more complicated\\nstreaming gRPC services.\\nThe\", \"re are multiple ways to use duplex services in Windows Communication Foundation (WCF). Some\\nservices\", \" are initiated by the client and then they stream data from the server. Other full-duplex\\nservices m\", \"ight involve more ongoing two-way communication, like the classic Calculator example in\\nthe WCF docu\", \"mentation. This chapter will take two possible WCF stock ticker implementations and\\nmigrate them to \", \"gRPC: one that uses a server streaming RPC and another one that uses a bidirectional\\nstreaming RPC.\\n\", \"Server streaming RPC\\nIn the sample SimpleStockTicker WCF solution, SimpleStockPriceTicker, there\\u2019s a\", \" duplex service for\\nwhich the client starts the connection with a list of stock symbols, and the ser\", \"ver uses the callback\\ninterface to send updates as they become available. The client implements that\", \" interface to respond\\nto calls from the server.\\nThe WCF solution\\nThe WCF solution is implemented as \", \"a self-hosted Net.TCP server in a .NET Framework 4.x console\\napplication.\\n53 CHAPTER 5 | Migrate a W\", \"CF solution to gRPCServiceContract\\n[ServiceContract(SessionMode = SessionMode.Required, CallbackCont\", \"ract =\\ntypeof(ISimpleStockTickerCallback))]\\npublic interface ISimpleStockTickerService\\n{\\n[OperationC\", \"ontract(IsOneWay = true)]\\nvoid Subscribe(string[] symbols);\\n}\\nThe service has a single method with n\", \"o return type because it uses the callback interface\\nISimpleStockTickerCallback to send data to the \", \"client in real time.\\nThe callback interface\\n[ServiceContract]\\npublic interface ISimpleStockTickerCal\", \"lback\\n{\\n[OperationContract(IsOneWay = true)]\\nvoid Update(string symbol, decimal price);\\n}\\nYou can fi\", \"nd the implementations of these interfaces in the solution, along with faked external\\ndependencies t\", \"o provide test data.\\ngRPC streaming\\nThe gRPC process for handling real-time data is different from t\", \"he WCF process. A call from client to\\nserver can create a persistent stream, which can be monitored \", \"for messages that arrive\\nasynchronously. Despite the difference, streams can be a more intuitive way\", \" of dealing with this data\\nand are more relevant in modern programming, which emphasizes LINQ, React\", \"ive Streams, functional\\nprogramming, and so on.\\nThe service definition needs two messages: one for t\", \"he request and one for the stream. The service\\nreturns a stream of the StockTickerUpdate message wit\", \"h the stream keyword in its return declaration.\\nWe recommend that you add a Timestamp to the update \", \"to show the exact time of the price change.\\nsimple_stock_ticker.proto\\nsyntax = \\\"proto3\\\";\\noption csha\", \"rp_namespace = \\\"TraderSys.SimpleStockTickerServer.Protos\\\";\\nimport \\\"google/protobuf/timestamp.proto\\\";\", \"\\npackage SimpleStockTickerServer;\\nservice SimpleStockTicker {\\nrpc Subscribe (SubscribeRequest) retur\", \"ns (stream StockTickerUpdate);\\n}\\nmessage SubscribeRequest {\\nrepeated string symbols = 1;\\n}\\nmessage S\", \"tockTickerUpdate {\\n54 CHAPTER 5 | Migrate a WCF solution to gRPCstring symbol = 1;\\nint32 price_cents\", \" = 2;\\ngoogle.protobuf.Timestamp time = 3;\\n}\\nImplement SimpleStockTicker\\nReuse the fake StockPriceSub\", \"scriber from the WCF project by copying the three classes from the\\nTraderSys.StockMarket class libra\", \"ry into a new .NET Standard class library in the target solution. To\\nbetter follow best practices, a\", \"dd a Factory type to create instances of it, and register the\\nIStockPriceSubscriberFactory with the \", \"ASP.NET Core dependency injection services.\\nThe factory implementation\\npublic interface IStockPriceS\", \"ubscriberFactory\\n{\\nIStockPriceSubscriber GetSubscriber(string[] symbols);\\n}\\npublic class StockPriceS\", \"ubscriberFactory : IStockPriceSubscriberFactory\\n{\\npublic IStockPriceSubscriber GetSubscriber(string[\", \"] symbols)\\n{\\nreturn new StockPriceSubscriber(symbols);\\n}\\n}\\nRegister the factory\\nvar builder = WebApp\", \"lication.CreateBuilder(args);\\n// Additional configuration is required to successfully run gRPC on ma\", \"cOS.\\n// For instructions on how to configure Kestrel and gRPC clients on macOS, visit\\nhttps://go.mic\", \"rosoft.com/fwlink/?linkid=2099682\\n// Add services to the container.\\n// Register the factory\\nbuilder.\", \"Services.AddSingleton<IStockPriceSubscriberFactory, StockPriceSubscriberFactory>();\\nbuilder.Services\", \".AddGrpc();\\nvar app = builder.Build();\\n// Configure the HTTP request pipeline.\\napp.MapGrpcService<St\", \"ockTickerService>();\\napp.MapGet(\\\"/\\\", async context =>\\n{\\nawait context.Response.WriteAsync(\\\"Communica\", \"tion with gRPC endpoints must be made\\nthrough a gRPC client. To learn how to create a client, visit:\", \"\\nhttps://go.microsoft.com/fwlink/?linkid=2086909\\\");\\n});\\napp.Run();\\nThis class can now be used to imp\", \"lement the gRPC StockTickerService.\\n55 CHAPTER 5 | Migrate a WCF solution to gRPCStockTickerService.\", \"cs\\npublic class StockTickerService : Protos.SimpleStockTicker.SimpleStockTickerBase\\n{\\nprivate readon\", \"ly IStockPriceSubscriberFactory _subscriberFactory;\\npublic StockTickerService(IStockPriceSubscriberF\", \"actory subscriberFactory)\\n{\\n_subscriberFactory = subscriberFactory;\\n}\\npublic override async Task Sub\", \"scribe(SubscribeRequest request,\\nIServerStreamWriter<StockTickerUpdate> responseStream, ServerCallCo\", \"ntext context)\\n{\\nvar subscriber = _subscriberFactory.GetSubscriber(request.Symbols.ToArray());\\nsubsc\", \"riber.Update += async (sender, args) =>\\nawait WriteUpdateAsync(responseStream, args.Symbol, args.Pri\", \"ce);\\nawait AwaitCancellation(context.CancellationToken);\\n}\\nprivate async Task WriteUpdateAsync(IServ\", \"erStreamWriter<StockTickerUpdate> stream,\\nstring symbol, decimal price)\\n{\\ntry\\n{\\nawait stream.WriteAs\", \"ync(new StockTickerUpdate\\n{\\nSymbol = symbol,\\nPriceCents = (int)(price * 100),\\nTime = Timestamp.FromD\", \"ateTimeOffset(DateTimeOffset.UtcNow)\\n});\\n}\\ncatch (Exception e)\\n{\\n// Handle any errors caused by brok\", \"en connection, etc.\\n_logger.LogError($\\\"Failed to write message: {e.Message}\\\");\\n}\\n}\\nprivate static Ta\", \"sk AwaitCancellation(CancellationToken token)\\n{\\nvar completion = new TaskCompletionSource<object>();\", \"\\ntoken.Register(() => completion.SetResult(null));\\nreturn completion.Task;\\n}\\n}\\nAs you can see, altho\", \"ugh the declaration in the .proto file says the method returns a stream of\\nStockTickerUpdate message\", \"s, it actually returns a Task. The job of creating the stream is handled by\\nthe generated code and t\", \"he gRPC runtime libraries, which provide the\\nIServerStreamWriter<StockTickerUpdate> response stream,\", \" ready to use.\\nUnlike a WCF duplex service, where the instance of the service class is kept alive wh\", \"ile the connection\\nis open, the gRPC service uses the returned task to keep the service alive. The t\", \"ask shouldn\\u2019t complete\\nuntil the connection is closed.\\n56 CHAPTER 5 | Migrate a WCF solution to gRPC\", \"The service can tell when the client has closed the connection by using the CancellationToken from\\nt\", \"he ServerCallContext. A simple static method, AwaitCancellation, is used to create a task that\\ncompl\", \"etes when the token is canceled.\\nIn the Subscribe method, then, get a StockPriceSubscriber and add a\", \"n event handler that writes to the\\nresponse stream. Then wait for the connection to be closed before\", \" immediately disposing the\\nsubscriber to prevent it from trying to write data to the closed stream.\\n\", \"The WriteUpdateAsync method has a try/catch block to handle any errors that might happen when a\\nmess\", \"age is written to the stream. This consideration is important in persistent connections over\\nnetwork\", \"s, which could be broken at any millisecond, whether intentionally or because of a failure\\nsomewhere\", \".\\nUse StockTickerService from a client application\\nFollow the same steps in the previous section to \", \"create a shareable client class library from the .proto\\nfile. In the sample, there\\u2019s a .NET console \", \"application that demonstrates how to use the client.\\nExample Program.cs\\nclass Program\\n{\\nstatic async\", \" Task Main(string[] args)\\n{\\nusing var channel = GrpcChannel.ForAddress(\\\"https://localhost:5001\\\");\\nva\", \"r client = new SimpleStockTicker.SimpleStockTickerClient(channel);\\nvar request = new SubscribeReques\", \"t();\\nrequest.Symbols.AddRange(args);\\nusing var stream = client.Subscribe(request);\\nvar tokenSource =\", \" new CancellationTokenSource();\\nvar task = DisplayAsync(stream.ResponseStream, tokenSource.Token);\\nW\", \"aitForExitKey();\\ntokenSource.Cancel();\\nawait task;\\n}\\n}\\nIn this case, the Subscribe method on the gen\", \"erated client isn\\u2019t asynchronous. The stream is created\\nand usable right away because its MoveNext m\", \"ethod is asynchronous and the first time it\\u2019s called it\\nwon\\u2019t complete until the connection is alive\", \".\\nThe stream is passed to an asynchronous DisplayAsync method. The application then waits for the\\nus\", \"er to press a key, and then cancels the DisplayAsync method and waits for the task to complete\\nbefor\", \"e exiting.\\n57 CHAPTER 5 | Migrate a WCF solution to gRPCNote\\nThis code uses the new C# 8 using decla\", \"ration syntax to dispose of the stream and the channel when\\nthe Main method exits. It\\u2019s a small chan\", \"ge, but a nice one that reduces indentations and empty lines.\\nConsume the stream\\nWCF uses callback i\", \"nterfaces to allow the server to call methods directly on the client. gRPC streams\\nwork differently.\", \" The client iterates over the returned stream and processes messages, just as though\\nthey were retur\", \"ned from a local method returning an IEnumerable.\\nThe IAsyncStreamReader<T> type works much like an \", \"IEnumerator<T>. There\\u2019s a MoveNext method\\nthat returns true as long as there\\u2019s more data, and a Curr\", \"ent property that returns the latest value. The\\nonly difference is that the MoveNext method returns \", \"a Task<bool> instead of just a bool. The\\nReadAllAsync extension method wraps the stream in a standar\", \"d C# 8 IAsyncEnumerable that can be\\nused with the new await foreach syntax.\\nstatic async Task Displa\", \"yAsync(IAsyncStreamReader<StockTickerUpdate> stream,\\nCancellationToken token)\\n{\\ntry\\n{\\nawait foreach \", \"(var update in stream.ReadAllAsync(token))\\n{\\nConsole.WriteLine($\\\"{update.Symbol}: {update.Price}\\\");\\n\", \"}\\n}\\ncatch (RpcException e) when (e.StatusCode == StatusCode.Cancelled)\\n{\\nreturn;\\n}\\ncatch (OperationC\", \"anceledException)\\n{\\nConsole.WriteLine(\\\"Finished.\\\");\\n}\\n}\\nTip\\nFor developers using reactive programmin\", \"g patterns, the section on client libraries at the end of this\\nchapter shows how to add an extension\", \" method and classes to wrap IAsyncStreamReader<T> in an\\nIObservable<T>.\\nAgain, be sure to catch exce\", \"ptions here because of the possibility of network failure, and because of\\nthe OperationCanceledExcep\", \"tion that will inevitably be thrown because the code is using a\\nCancellationToken to break the loop.\", \" The RpcException type has a lot of useful information about\\ngRPC runtime errors, including the Stat\", \"usCode. For more information, see Error handling in Chapter 4.\\nBidirectional streaming\\nA WCF full-du\", \"plex service allows for asynchronous, real-time messaging in both directions. In the\\nserver streamin\", \"g example, the client starts a request and then receives a stream of updates. A better\\n58 CHAPTER 5 \", \"| Migrate a WCF solution to gRPCversion of that service would allow the client to add and remove sto\", \"cks from the list without having to\\nstop and create a new subscription. That functionality has been \", \"implemented in the FullStockTicker\\nsample solution.\\nThe IFullStockTickerService interface provides t\", \"hree methods:\\n\\u2022 Subscribe starts the connection.\\n\\u2022 AddSymbol adds a stock symbol to watch.\\n\\u2022 RemoveS\", \"ymbol removes a symbol from the watched list.\\n[ServiceContract(SessionMode = SessionMode.Required, C\", \"allbackContract =\\ntypeof(IFullStockTickerCallback))]\\npublic interface IFullStockTickerService\\n{\\n[Ope\", \"rationContract(IsOneWay = true)]\\nvoid Subscribe();\\n[OperationContract(IsOneWay = true)]\\nvoid AddSymb\", \"ol(string symbol);\\n[OperationContract(IsOneWay = true)]\\nvoid RemoveSymbol(string symbol);\\n}\\nThe call\", \"back interface remains the same.\\nImplementing this pattern in gRPC is less straightforward because t\", \"here are now two streams of data\\nwith messages being passed: one from client to server and another f\", \"rom server to client. It isn\\u2019t\\npossible to use multiple methods to implement the add and remove oper\", \"ations, but you can pass\\nmore than one type of message on a single stream by using either the Any ty\", \"pe or the oneof\\nkeyword, which were covered in Chapter 3.\\nIn a case where there\\u2019s a specific set of \", \"types that are acceptable, oneof is a better way to go. Use an\\nActionMessage that can hold either an\", \" AddSymbolRequest or a RemoveSymbolRequest:\\nmessage ActionMessage {\\noneof action {\\nAddSymbolRequest \", \"add = 1;\\nRemoveSymbolRequest remove = 2;\\n}\\n}\\nmessage AddSymbolRequest {\\nstring symbol = 1;\\n}\\nmessage\", \" RemoveSymbolRequest {\\nstring symbol = 1;\\n}\\nDeclare a bidirectional streaming service that takes a s\", \"tream of ActionMessage messages:\\nservice FullStockTicker {\\nrpc Subscribe (stream ActionMessage) retu\", \"rns (stream StockTickerUpdate);\\n}\\n59 CHAPTER 5 | Migrate a WCF solution to gRPCThe implementation fo\", \"r this service is similar to that of the previous example, except the first\\nparameter of the Subscri\", \"be method is now an IAsyncStreamReader<ActionMessage>, which can be\\nused to handle the Add and Remov\", \"e requests:\\npublic override async Task Subscribe(IAsyncStreamReader<ActionMessage> requestStream,\\nIS\", \"erverStreamWriter<StockTickerUpdate> responseStream, ServerCallContext context)\\n{\\nusing var subscrib\", \"er = _subscriberFactory.GetSubscriber();\\nsubscriber.Update += async (sender, args) =>\\nawait WriteUpd\", \"ateAsync(responseStream, args.Symbol, args.Price);\\nvar actionsTask = HandleActions(requestStream, su\", \"bscriber, context.CancellationToken);\\n_logger.LogInformation(\\\"Subscription started.\\\");\\nawait AwaitCa\", \"ncellation(context.CancellationToken);\\ntry { await actionsTask; } catch { /* Ignored */ }\\n_logger.Lo\", \"gInformation(\\\"Subscription finished.\\\");\\n}\\nprivate async Task WriteUpdateAsync(IServerStreamWriter<St\", \"ockTickerUpdate> stream, string\\nsymbol, decimal price)\\n{\\ntry\\n{\\nawait stream.WriteAsync(new StockTick\", \"erUpdate\\n{\\nSymbol = symbol,\\nPriceCents = (int)(price * 100),\\nTime = Timestamp.FromDateTimeOffset(Dat\", \"eTimeOffset.UtcNow)\\n});\\n}\\ncatch (Exception e)\\n{\\n// Handle any errors caused by broken connection, et\", \"c.\\n_logger.LogError($\\\"Failed to write message: {e.Message}\\\");\\n}\\n}\\nprivate static Task AwaitCancellat\", \"ion(CancellationToken token)\\n{\\nvar completion = new TaskCompletionSource<object>();\\ntoken.Register((\", \") => completion.SetResult(null));\\nreturn completion.Task;\\n}\\nThe ActionMessage class that gRPC has ge\", \"nerated guarantees that only one of the Add and Remove\\nproperties can be set. Finding which one isn\\u2019\", \"t null is a valid way to determine which type of message\\nis used, but there\\u2019s a better way. The code\", \" generation also created an enum ActionOneOfCase in the\\nActionMessage class, which looks like this:\\n\", \"public enum ActionOneofCase {\\nNone = 0,\\nAdd = 1,\\nRemove = 2,\\n}\\n60 CHAPTER 5 | Migrate a WCF solution\", \" to gRPCThe property ActionCase on the ActionMessage object can be used with a switch statement to\\nd\", \"etermine which field is set:\\nprivate async Task HandleActions(IAsyncStreamReader<ActionMessage> requ\", \"estStream,\\nIFullStockPriceSubscriber subscriber, CancellationToken token)\\n{\\nawait foreach (var actio\", \"n in requestStream.ReadAllAsync(token))\\n{\\nswitch (action.ActionCase)\\n{\\ncase ActionMessage.ActionOneo\", \"fCase.None:\\n_logger.LogWarning(\\\"No Action specified.\\\");\\nbreak;\\ncase ActionMessage.ActionOneofCase.Ad\", \"d:\\nsubscriber.Add(action.Add.Symbol);\\nbreak;\\ncase ActionMessage.ActionOneofCase.Remove:\\nsubscriber.R\", \"emove(action.Remove.Symbol);\\nbreak;\\ndefault:\\n_logger.LogWarning($\\\"Unknown Action '{action.ActionCase\", \"}'.\\\");\\nbreak;\\n}\\n}\\n}\\nTip\\nThe switch statement has a default case that logs a warning if it encounters\", \" an unknown\\nActionOneOfCase value. This could be useful to indicate that a client is using a later v\", \"ersion of the\\n.proto file that has added more actions. This is one reason why using a switch is bett\", \"er than testing for\\nnull on known fields.\\nUse FullStockTickerService from a client application\\nThere\", \"\\u2019s a simple .NET WPF application that demonstrates the use of this more complex client. You can\\nfind\", \" the full application on GitHub.\\nThe client is used in the MainWindowViewModel class, which gets an \", \"instance of the\\nFullStockTicker.FullStockTickerClient type from dependency injection:\\npublic class M\", \"ainWindowViewModel : IAsyncDisposable, INotifyPropertyChanged\\n{\\nprivate readonly FullStockTicker.Ful\", \"lStockTickerClient _client;\\nprivate readonly AsyncDuplexStreamingCall<ActionMessage, StockTickerUpda\", \"te>\\n_duplexStream;\\nprivate readonly CancellationTokenSource _cancellationTokenSource;\\nprivate readon\", \"ly Task _responseTask;\\nprivate string _addSymbol;\\npublic MainWindowViewModel(FullStockTicker.FullSto\", \"ckTickerClient client)\\n{\\n_cancellationTokenSource = new CancellationTokenSource();\\n_client = client;\", \"\\n_duplexStream = _client.Subscribe();\\n_responseTask = HandleResponsesAsync(_cancellationTokenSource.\", \"Token);\\n61 CHAPTER 5 | Migrate a WCF solution to gRPCAddCommand = new AsyncCommand(Add, CanAdd);\\n}\\nT\", \"he object returned by the client.Subscribe() method is now an instance of the gRPC library type\\nAsyn\", \"cDuplexStreamingCall<TRequest, TResponse>, which provides a RequestStream for sending\\nrequests to th\", \"e server and a ResponseStream for handling responses.\\nThe request stream is used from some WPF IComm\", \"and methods to add and remove symbols. For\\neach operation, set the relevant field on an ActionMessag\", \"e object:\\nprivate async Task Add()\\n{\\nif (CanAdd())\\n{\\nawait _duplexStream.RequestStream.WriteAsync(ne\", \"w ActionMessage {Add = new\\nAddSymbolRequest {Symbol = AddSymbol}});\\n}\\n}\\npublic async Task Remove(Pri\", \"ceViewModel priceViewModel)\\n{\\nawait _duplexStream.RequestStream.WriteAsync(new ActionMessage {Remove\", \" = new\\nRemoveSymbolRequest {Symbol = priceViewModel.Symbol}});\\nPrices.Remove(priceViewModel);\\n}\\nImpo\", \"rtant\\nSetting a oneof field\\u2019s value on a message automatically clears any fields that have been set\\n\", \"previously.\\nThe stream of responses is handled in an async method. The Task it returns is held to be\", \" disposed\\nwhen the window is closed:\\nprivate async Task HandleResponsesAsync(CancellationToken token\", \")\\n{\\nvar stream = _duplexStream.ResponseStream;\\ntry\\n{\\nawait foreach (var update in stream.ReadAllAsyn\", \"c(token))\\n{\\nvar price = Prices.FirstOrDefault(p => p.Symbol.Equals(update.Symbol));\\nif (price == nul\", \"l)\\n{\\nprice = new PriceViewModel(this) {Symbol = update.Symbol, Price =\\nupdate.PriceCents / 100m};\\nPr\", \"ices.Add(price);\\n}\\nelse\\n{\\nprice.Price = update.PriceCents / 100m;\\n}\\n}\\n}\\n62 CHAPTER 5 | Migrate a WCF\", \" solution to gRPCcatch (OperationCancelledException) { }\\n}\\nClient cleanup\\nWhen the window is closed \", \"and the MainWindowViewModel is disposed (from the Closed event of\\nMainWindow), we recommend that you\", \" properly dispose the AsyncDuplexStreamingCall object. In\\nparticular, the CompleteAsync method on th\", \"e RequestStream should be called to gracefully close the\\nstream on the server. This example shows th\", \"e DisposeAsync method from the sample view-model:\\npublic async ValueTask DisposeAsync()\\n{\\ntry\\n{\\nawai\", \"t _duplexStream.RequestStream.CompleteAsync().ConfigureAwait(false);\\nawait _responseTask.ConfigureAw\", \"ait(false);\\n}\\nfinally\\n{\\n_duplexStream.Dispose();\\n}\\n}\\nClosing request streams enables the server to d\", \"ispose of its own resources in a timely way. This\\nimproves the efficiency and scalability of service\", \"s and prevents exceptions.\\ngRPC streaming services vs. repeated fields\\ngRPC services provide two way\", \"s of returning datasets, or lists of objects. The Protocol Buffers message\\nspecification uses the re\", \"peated keyword for declaring lists or arrays of messages within another\\nmessage. The gRPC service sp\", \"ecification uses the stream keyword to declare a long-running persistent\\nconnection. Over that conne\", \"ction, multiple messages are sent, and can be processed, individually.\\nYou can also use the stream f\", \"eature for long-running temporal data such as notifications or log\\nmessages. But this chapter will c\", \"onsider its use for returning a single dataset.\\nWhich you should use depends on factors such as:\\n\\u2022 T\", \"he overall size of the dataset.\\n\\u2022 The time it took to create the dataset at either the client or ser\", \"ver end.\\n\\u2022 Whether the consumer of the dataset can start acting on it as soon as the first item is\\na\", \"vailable, or needs the complete dataset to do anything useful.\\nWhen to use repeated fields\\nFor any d\", \"ataset that\\u2019s constrained in size and that can be generated in its entirety in a short time\\u2014\\nsay, un\", \"der one second\\u2014you should use a repeated field in a regular Protobuf message. For example,\\nin an e-c\", \"ommerce system, to build a list of items within an order is probably quick and the list won\\u2019t\\nbe ver\", \"y large. Returning a single message with a repeated field is an order of magnitude faster than\\nusing\", \" stream and incurs less network overhead.\\n63 CHAPTER 5 | Migrate a WCF solution to gRPCIf the client\", \" needs all the data before starting to process it and the dataset is small enough to\\nconstruct in me\", \"mory, then consider using a repeated field. Consider it even if the creation of the\\ndataset in memor\", \"y on the server is slower.\\nWhen to use stream methods\\nWhen the message objects in your datasets are \", \"potentially very large, it\\u2019s best for you transfer them\\nby using streaming requests or responses. It\", \"\\u2019s more efficient to construct a large object in memory,\\nwrite it to the network, and then free up t\", \"he resources. This approach will improve the scalability of\\nyour service.\\nSimilarly, you should send\", \" datasets of unconstrained size over streams to avoid running out of\\nmemory while constructing them.\", \"\\nFor datasets where the consumer can separately process each item, you should consider using a\\nstrea\", \"m if it means that progress can be indicated to the user. Using a stream can improve the\\nresponsiven\", \"ess of an application, but you should balance it against the overall performance of the\\napplication.\", \"\\nAnother scenario where streams can be useful is where a message is being processed across multiple\\n\", \"services. If each service in a chain returns a stream, then the terminal service (that is, the last \", \"one in\\nthe chain) can start returning messages. These messages can be processed and passed back alon\", \"g the\\nchain to the original requestor. The requestor can either return a stream or aggregate the res\", \"ults into\\na single response message. This approach lends itself well to patterns like MapReduce.\\nCre\", \"ate gRPC client libraries\\nIt isn\\u2019t necessary to distribute client libraries for a gRPC application. \", \"You can create a shared library of\\n.proto files within your organization, and other teams can use th\", \"ose files to generate client code in\\ntheir own projects. But if you have a private NuGet repository \", \"and many other teams are using .NET,\\nyou can create and publish client NuGet packages as part of you\", \"r service project. This approach can\\nbe a good way of sharing and promoting your service.\\nOne advant\", \"age of distributing a client library is that you can enhance the generated gRPC and\\nProtobuf classes\", \" with helpful \\u201cconvenience\\u201d methods and properties. In the client code, as in the\\nserver, all the cl\", \"asses are declared as partial, so you can extend them without editing the generated\\ncode. This behav\", \"ior means it\\u2019s easy to add constructors, methods, and calculated properties to the\\nbasic types.\\nCaut\", \"ion\\nYou shouldn\\u2019t use custom code to provide essential functionality. You don\\u2019t want to restrict tha\", \"t\\nessential functionality to .NET teams that use the shared library, and not provide it to teams tha\", \"t use\\nother languages or platforms, such as Python or Java.\\nEnsure that as many teams as possible ca\", \"n access your gRPC service. The best way to do this\\nfunctionality is to share .proto files so develo\", \"pers can generate their own clients. This approach is\\n64 CHAPTER 5 | Migrate a WCF solution to gRPCp\", \"articularly true in a multi-platform environment, where different teams frequently use different\\npro\", \"gramming languages and frameworks, or where your API is externally accessible.\\nUseful extensions\\nThe\", \"re are two commonly used interfaces in .NET for dealing with streams of objects: IEnumerable and\\nIOb\", \"servable. Starting with .NET Core 3.0 and C# 8.0, there\\u2019s an IAsyncEnumerable interface for\\nprocessi\", \"ng streams asynchronously, and an await foreach syntax for using the interface. This section\\npresent\", \"s reusable code for applying these interfaces to gRPC streams.\\nWith the .NET gRPC client libraries, \", \"there\\u2019s a ReadAllAsync extension method for\\nIAsyncStreamReader<T> that creates an IAsyncEnumerable<T\", \"> interface. For developers using\\nreactive programming, an equivalent extension method to create an \", \"IObservable<T> interface might\\nlook like the example in the following section.\\nIObservable\\nThe IObse\", \"rvable<T> interface is the \\u201creactive\\u201d inverse of IEnumerable<T>. Rather than pulling items\\nfrom a st\", \"ream, the reactive approach lets the stream push items to a subscriber. This behavior is very\\nsimila\", \"r to gRPC streams, and it\\u2019s easy to wrap an IObservable<T> interface around an\\nIAsyncStreamReader<T>\", \" interface.\\nThis code is longer than the IAsyncEnumerable<T> code, because C# doesn\\u2019t have built-in \", \"support for\\nworking with observables. You have to create the implementation class manually. It\\u2019s a g\", \"eneric class,\\nthough, so a single implementation works across all types.\\nnamespace Grpc.Core;\\npublic\", \" class GrpcStreamObservable<T> : IObservable<T>\\n{\\nprivate readonly IAsyncStreamReader<T> _reader;\\npr\", \"ivate readonly CancellationToken _token;\\nprivate int _used;\\npublic GrpcStreamObservable(IAsyncStream\", \"Reader<T> reader, CancellationToken token =\\ndefault)\\n{\\n_reader = reader ?? throw new ArgumentNullExc\", \"eption(nameof(reader));\\n_token = token;\\n_used = 0;\\n}\\npublic IDisposable Subscribe(IObserver<T> obser\", \"ver) =>\\nInterlocked.Exchange(ref _used, 1) == 0\\n? new GrpcStreamSubscription<T>(_reader, observer, _\", \"token)\\n: throw new InvalidOperationException(\\\"Subscribe can only be called once.\\\");\\n}\\n65 CHAPTER 5 |\", \" Migrate a WCF solution to gRPCImportant\\nThis observable implementation allows the Subscribe method \", \"to be called only once, because having\\nmultiple subscribers trying to read from the stream would res\", \"ult in chaos. There are operators, such as\\nReplay in the System.Reactive.Linq, that enable buffering\", \" and repeatable sharing of observables,\\nwhich can be used with this implementation.\\nThe GrpcStreamSu\", \"bscription class handles the enumeration of the IAsyncStreamReader:\\npublic class GrpcStreamSubscript\", \"ion<T> : IDisposable\\n{\\nprivate readonly IAsyncStreamReader<T> _reader;\\nprivate readonly IObserver<T>\", \" _observer;\\nprivate readonly CancellationTokenSource _tokenSource;\\nprivate readonly Task _task;\\npriv\", \"ate bool _completed;\\npublic GrpcStreamSubscription(IAsyncStreamReader<T> reader, IObserver<T> observ\", \"er,\\nCancellationToken token = default)\\n{\\n_reader = reader ?? throw new ArgumentNullException(nameof(\", \"reader));\\n_observer = observer ?? throw new ArgumentNullException(nameof(observer));\\n_tokenSource = \", \"new CancellationTokenSource();\\ntoken.Register(_tokenSource.Cancel);\\n_task = Run(_tokenSource.Token);\", \"\\n}\\nprivate async Task Run(CancellationToken token)\\n{\\nwhile (!token.IsCancellationRequested)\\n{\\ntry\\n{\\n\", \"if (!await _reader.MoveNext(token)) break;\\n}\\ncatch (RpcException e) when (e.StatusCode == Grpc.Core.\", \"StatusCode.NotFound)\\n{\\nbreak;\\n}\\ncatch (OperationCanceledException)\\n{\\nbreak;\\n}\\ncatch (Exception e)\\n{\\n\", \"_observer.OnError(e);\\n_completed = true;\\nreturn;\\n}\\n_observer.OnNext(_reader.Current);\\n}\\n_completed =\", \" true;\\n66 CHAPTER 5 | Migrate a WCF solution to gRPC_observer.OnCompleted();\\n}\\npublic void Dispose()\", \"\\n{\\nif (!_completed && !_tokenSource.IsCancellationRequested)\\n{\\n_tokenSource.Cancel();\\n}\\n_tokenSource\", \".Dispose();\\n_task.Dispose();\\n}\\n}\\nAll that is required now is a simple extension method to create the\", \" observable from the stream reader.\\nnamespace Grpc.Core;\\npublic static class AsyncStreamReaderObserv\", \"ableExtensions\\n{\\npublic static IObservable<T> AsObservable<T>(\\nthis IAsyncStreamReader<T> reader,\\nCa\", \"ncellationToken cancellationToken = default) =>\\nnew GrpcStreamObservable<T>(reader, cancellationToke\", \"n);\\n}\\nSummary\\nThe IAsyncEnumerable and IObservable models are both well-supported and well-documente\", \"d ways\\nof dealing with asynchronous streams of data in .NET. gRPC streams map well to both paradigms\", \",\\noffering close integration with .NET, and reactive and asynchronous programming styles.\\n67 CHAPTER\", \" 5 | Migrate a WCF solution to gRPC6\\nCHAPTER\\nSecurity in gRPC\\napplications\\nIn any real-world scenari\", \"o, securing applications and services are essential. Security covers three key\\nareas:\\n\\u2022 Encrypting n\", \"etwork traffic to prevent malicious hackers from intercepting it.\\n\\u2022 Authenticating clients and serve\", \"rs to establish identity and trust.\\n\\u2022 Authorizing clients to control access to systems and apply per\", \"missions based on identity.\\nNote\\nAuthentication is concerned with establishing the identity of a cli\", \"ent or server. Authorization is\\nconcerned with determining whether a client has permission to access\", \" a resource or issue a command.\\nThis chapter will cover the facilities for authentication and author\", \"ization in gRPC for ASP.NET Core. It\\nwill also discuss network security through TLS encrypted connec\", \"tions.\\nWCF authentication and authorization\\nIn Windows Communication Foundation (WCF), authenticatio\", \"n and authorization were handled in\\ndifferent ways, depending on the transports and bindings being u\", \"sed. WCF supported various WS-*\\nsecurity standards. It also supported Windows authentication for HTT\", \"P services running in IIS or\\nNetTCP services between Windows systems.\\ngRPC authentication and author\", \"ization\\ngRPC authentication and authorization works on two levels:\\n\\u2022 Call-level authentication/autho\", \"rization is usually handled through tokens that are applied in\\nmetadata when the call is made.\\n\\u2022 Cha\", \"nnel-level authentication uses a client certificate that\\u2019s applied at the connection level. It\\ncan a\", \"lso include call-level authentication/authorization credentials to be applied to every call\\non the c\", \"hannel automatically.\\nYou can use either or both of these mechanisms to help secure your service.\\n68\", \" CHAPTER 6 | Security in gRPC applicationsThe ASP.NET Core implementation of gRPC supports authentic\", \"ation and authorization through most\\nof the standard ASP.NET Core mechanisms:\\n\\u2022 Call authentication\\n\", \"\\u2013 Azure Active Directory\\n\\u2013 IdentityServer\\n\\u2013 JWT Bearer Token\\n\\u2013 OAuth 2.0\\n\\u2013 OpenID Connect\\n\\u2013 WS-Feder\", \"ation\\n\\u2022 Channel authentication\\n\\u2013 Client certificate\\nThe call authentication methods are all based on\", \" tokens. The only real difference is how the tokens are\\ngenerated and the libraries that are used to\", \" validate the tokens in the ASP.NET Core service.\\nFor more information, see the Authentication and a\", \"uthorization article.\\nNote\\nWhen you\\u2019re using gRPC over a TLS-encrypted HTTP/2 connection, all traffi\", \"c between clients and\\nservers is encrypted, even if you don\\u2019t use channel-level authentication.\\nThis\", \" chapter will show how to apply call credentials and channel credentials to a gRPC service. It will\\n\", \"also show how to use credentials from a .NET gRPC client to authenticate with the service.\\nCall cred\", \"entials\\nCall credentials are all based on a token passed in metadata with each request.\\nWS-Federatio\", \"n\\nASP.NET Core supports WS-Federation using the WsFederation NuGet package. WS-Federation is the\\nclo\", \"sest available alternative to Windows Authentication, which isn\\u2019t supported over HTTP/2. Users are\\na\", \"uthenticated by using Active Directory Federation Services (AD FS), which provides a token that can\\n\", \"be used to authenticate with ASP.NET Core.\\nFor more information on how to get started with this auth\", \"entication method, see Authenticate users\\nwith WS-Federation in ASP.NET Core.\\nJWT Bearer tokens\\nThe \", \"JSON Web Token (JWT) standard provides a way to encode information about a user and their\\nclaims in \", \"an encoded string. It also provides a way to sign that token, so that the consumer can verify\\nthe in\", \"tegrity of the token by using public key cryptography. You can use various services, such as\\nIdentit\", \"yServer4, to authenticate users and generate OpenID Connect (OIDC) tokens to use with gRPC\\nand HTTP \", \"APIs.\\n69 CHAPTER 6 | Security in gRPC applicationsASP.NET Core 7.0 can handle JWTs by using the JWT \", \"Bearer package. The configuration is exactly the\\nsame for a gRPC application as it is for an ASP.NET\", \" Core MVC application. Here, we\\u2019ll focus on JWT\\nBearer tokens, because they\\u2019re easier to develop wit\", \"h than WS-Federation.\\nAdd authentication and authorization to the server\\nThe JWT Bearer package isn\\u2019\", \"t included in ASP.NET Core 7.0 by default. Install the\\nMicrosoft.AspNetCore.Authentication.JwtBearer\", \" NuGet package in your app.\\nAdd the Authentication service in the Program.cs class, and configure th\", \"e JWT Bearer handler:\\n//\\n//\\nbuilder.Services.AddGrpc();\\nvar signingKey = ObtainSigningKeySomehow();\\n\", \"builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\\n.AddJwtBearer(options =>\\n\", \"{\\noptions.TokenValidationParameters =\\nnew TokenValidationParameters\\n{\\nValidateAudience = false,\\nVali\", \"dateIssuer = false,\\nValidateActor = false,\\nValidateLifetime = true,\\nIssuerSigningKey = signingKey\\n};\", \"\\n});\\n//\\n//\\nThe IssuerSigningKey property requires an implementation of\\nMicrosoft.IdentityModels.Toke\", \"ns.SecurityKey with the cryptographic data necessary to validate the\\nsigned tokens. Store this token\", \" securely in a secrets server, like Azure Key Vault.\\nNext, add the Authorization service, which cont\", \"rols access to the system:\\nservices.AddAuthorization(options =>\\n{\\noptions.AddPolicy(JwtBearerDefault\", \"s.AuthenticationScheme, policy =>\\n{\\npolicy.AddAuthenticationSchemes(JwtBearerDefaults.Authentication\", \"Scheme);\\npolicy.RequireClaim(ClaimTypes.Name);\\n});\\n});\\nTip\\nAuthentication and authorization are two \", \"separate steps. You use authentication to determine the\\nuser\\u2019s identity. You use authorization to de\", \"cide whether that user is allowed to access various parts of\\nthe system.\\n70 CHAPTER 6 | Security in \", \"gRPC applicationsNow add the authentication and authorization middleware to the ASP.NET Core pipelin\", \"e in the\\nProgram.cs:\\n//\\napp.UseRouting();\\n// Authenticate, then Authorize\\napp.UseAuthentication();\\na\", \"pp.UseAuthorization();\\napp.UseEndpoints(endpoints =>\\n{\\nendpoints.MapGrpcService<PortfolioService>();\", \"\\n});\\n}\\nFinally, apply the [Authorize] attribute to any services or methods to be secured, and use th\", \"e User\\nproperty from the underlying HttpContext to verify permissions.\\n[Authorize]\\npublic override a\", \"sync Task<GetResponse> Get(GetRequest request, ServerCallContext context)\\n{\\nif (!TryValidateUser(req\", \"uest.TraderId, context.GetHttpContext().User))\\n{\\nthrow new RpcException(new Status(StatusCode.Permis\", \"sionDenied, \\\"Denied.\\\"));\\n}\\nvar portfolio = await _repository.GetAsync(traderId, request.PortfolioId)\", \";\\nreturn new GetResponse\\n{\\nPortfolio = Portfolio.FromRepositoryModel(portfolio)\\n};\\n}\\nProvide call cr\", \"edentials in the client application\\nAfter you\\u2019ve obtained a JWT token from an identity server, you c\", \"an use it to authenticate gRPC calls\\nfrom the client by adding it as a metadata header on the call, \", \"as follows:\\npublic async Task ShowPortfolioAsync(int portfolioId)\\n{\\nvar headers = new Grpc.Core.Meta\", \"data\\n{\\n{ \\\"Authorization\\\", $\\\"Bearer {_userToken}\\\" }\\n};\\nvar request = new GetRequest\\n{\\nTraderId = _use\", \"rId,\\nPortfolioId = portfolioId\\n};\\nvar response = await _portfoliosClient.GetAsync(request, headers);\", \"\\n// Display portfolio\\n}\\nNow you\\u2019ve secured your gRPC service by using JWT bearer tokens as call cred\", \"entials. A version of the\\nportfolios sample gRPC application with authentication and authorization a\", \"dded is on GitHub.\\n71 CHAPTER 6 | Security in gRPC applicationsChannel credentials\\nAs the name impli\", \"es, channel credentials are attached to the underlying gRPC channel. The standard\\nform of channel cr\", \"edentials uses client certificate authentication. In this process, the client provides a\\nTLS certifi\", \"cate when it\\u2019s making the connection, and then the server verifies this certificate before\\nallowing \", \"any calls to be made.\\nYou can combine channel credentials with call credentials to provide comprehen\", \"sive security for a\\ngRPC service. The channel credentials prove that the client application is allow\", \"ed to access the service,\\nand the call credentials provide information about the person who is using\", \" the client application.\\nClient certificate authentication works for gRPC the same way it works for \", \"ASP.NET Core. For more\\ninformation, see Configure certificate authentication in ASP.NET Core.\\nFor de\", \"velopment purposes you can use a self-signed certificate, but for production you should use a\\nproper\", \" HTTPS certificate signed by a trusted authority.\\nAdd certificate authentication to the server\\nConfi\", \"gure certificate authentication both at the host level (for example, on the Kestrel server), and in\\n\", \"the ASP.NET Core pipeline.\\nConfigure certificate validation on Kestrel\\nYou can configure Kestrel (th\", \"e ASP.NET Core HTTP server) to require a client certificate, and optionally\\nto carry out some valida\", \"tion of the supplied certificate, before accepting incoming connections. You\\nspecify this configurat\", \"ion in the Program.cs:\\nvar builder = WebApplication.CreateBuilder(args);\\nvar serverCert = ObtainServ\", \"erCertificate();\\nbuilder.WebHost.UseKestrel(kestrelServerOptions => {\\nkestrelServerOptions.Configure\", \"HttpsDefaults(opt =>\\n{\\nopt.ClientCertificateMode = ClientCertificateMode.RequireCertificate;\\n// Veri\", \"fy that client certificate was issued by same CA as server certificate\\nopt.ClientCertificateValidati\", \"on = (certificate, chain, errors) =>\\ncertificate.Issuer == serverCert.Issuer;\\n});\\n});\\nThe ClientCert\", \"ificateMode.RequireCertificate setting causes Kestrel to immediately reject any\\nconnection request t\", \"hat doesn\\u2019t provide a client certificate, but this setting by itself won\\u2019t validate a\\ncertificate th\", \"at is provided. Add the ClientCertificateValidation callback to enable Kestrel to validate\\nthe clien\", \"t certificate at the point the connection is made, before the ASP.NET Core pipeline is\\nengaged. (In \", \"this case, the callback ensures that it was issued by the same Certificate Authority as the\\nserver c\", \"ertificate.)\\n72 CHAPTER 6 | Security in gRPC applicationsAdd ASP.NET Core certificate authentication\", \"\\nThe Microsoft.AspNetCore.Authentication.Certificate NuGet package provides certificate\\nauthenticati\", \"on.\\nAdd the certificate authentication service in the Program.cs, and add authentication and authori\", \"zation\\nto the ASP.NET Core pipeline.\\n//\\nbuilder.Services.AddAuthentication(CertificateAuthentication\", \"Defaults.AuthenticationScheme)\\n.AddCertificate(options =>\\n{\\noptions.AllowedCertificateTypes = Certif\", \"icateTypes.Chained;\\noptions.RevocationMode = X509RevocationMode.NoCheck;\\noptions.Events = new Certif\", \"icateAuthenticationEvents\\n{\\nOnCertificateValidated = DevelopmentModeCertificateHelper.Validate\\n};\\n})\", \";\\nbuilder.Services.AddAuthorization();\\nbuilder.Services.AddGrpc();\\nvar app = builder.Build();\\n// Con\", \"figure the HTTP request pipeline.\\napp.UseRouting();\\napp.UseAuthentication();\\napp.UseEndpoints(endpoi\", \"nts => { endpoints.MapGrpcService<GreeterService>(); });\\n//\\nProvide channel credentials in the clien\", \"t application\\nWith the Grpc.Net.Client package, you configure certificates on an HttpClient instance\", \" that is provided\\nto the GrpcChannel used for the connection.\\nLoad a client certificate from a .PFX \", \"file\\nA certificate can be loaded from a .pfx file.\\nclass Program\\n{\\nstatic async Task Main(string[] a\", \"rgs)\\n{\\n// Assume path to a client .pfx file and password are passed from command line\\n// On Windows \", \"this would probably be a reference to the Certificate Store\\nvar cert = new X509Certificate2(args[0],\", \" args[1]);\\nvar handler = new HttpClientHandler();\\nhandler.ClientCertificates.Add(cert);\\nvar httpClie\", \"nt = new HttpClient(handler);\\nvar channel = GrpcChannel.ForAddress(\\\"https://localhost:5001/\\\", new\\nGr\", \"pcChannelOptions\\n{\\nHttpClient = httpClient\\n73 CHAPTER 6 | Security in gRPC applications});\\nvar grpc \", \"= new Greeter.GreeterClient(channel);\\nvar response = await grpc.SayHelloAsync(new HelloRequest { Nam\", \"e = \\\"Bob\\\" });\\nSystem.Console.WriteLine(response.Message);\\n}\\n}\\nLoad a client certificate from certifi\", \"cate and private key .PEM files\\nA certificate can be loaded from a certificate and private key .pem \", \"file.\\nclass Program\\n{\\nstatic async Task Main(string[] args)\\n{\\n// Assume path to a certificate and pr\", \"ivate key .pem files are passed from command\\nline\\nstring certificatePem = File.ReadAllText(args[0]);\", \"\\nstring privateKeyPem = File.ReadAllText(args[1]);\\nvar cert = X509Certificate2.CreateFromPem(certifi\", \"catePem, privateKeyPem);\\nvar handler = new HttpClientHandler();\\nhandler.ClientCertificates.Add(cert)\", \";\\nusing HttpClient httpClient = new(handler);\\nvar channel = GrpcChannel.ForAddress(\\\"https://localhos\", \"t:5001/\\\", new\\nGrpcChannelOptions\\n{\\nHttpClient = httpClient\\n});\\nvar grpc = new Greeter.GreeterClient(\", \"channel);\\nvar response = await grpc.SayHelloAsync(new HelloRequest { Name = \\\"Bob\\\" });\\nSystem.Console\", \".WriteLine(response.Message);\\n}\\n}\\nNote\\nDue to an internal Windows bug as documented here, you\\u2019ll nee\", \"d to apply the following workaround\\nif the certificate is created from a certificate and private key\", \" PEM data.\\n]{custom-style=Code}`csharp X509Certificate2 cert = X509Certificate2.CreateFromPem(certif\", \"icatePem,\\nrsaPrivateKeyPem); if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) { var original\", \"Cert =\\ncert; cert = new X509Certificate2(cert.Export(X509ContentType.Pkcs12)); originalCert.Dispose(\", \"); } [`\\nCombine ChannelCredentials and CallCredentials\\nYou can configure your server to use both cer\", \"tificate and token authentication. To do this, apply the\\ncertificate changes to the Kestrel server, \", \"and use the JWT bearer middleware in ASP.NET Core.\\nTo provide both ChannelCredentials and CallCreden\", \"tials on the client, use the\\nChannelCredentials.Create method to apply the call credentials. You sti\", \"ll need to apply certificate\\nauthentication by using the HttpClient instance. If you pass any argume\", \"nts to the SslCredentials\\n74 CHAPTER 6 | Security in gRPC applicationsconstructor, the internal clie\", \"nt code throws an exception. The SslCredentials parameter is only\\nincluded in the Grpc.Net.Client pa\", \"ckage\\u2019s Create method to maintain compatibility with the Grpc.Core\\npackage.\\nvar handler = new HttpCl\", \"ientHandler();\\nhandler.ClientCertificates.Add(cert);\\nvar httpClient = new HttpClient(handler);\\nvar c\", \"allCredentials = CallCredentials.FromInterceptor(((context, metadata) =>\\n{\\nmetadata.Add(\\\"Authorizati\", \"on\\\", $\\\"Bearer {_token}\\\");\\nreturn Task.CompletedTask;\\n}));\\nvar channelCredentials = ChannelCredential\", \"s.Create(new SslCredentials(), callCredentials);\\nvar channel = GrpcChannel.ForAddress(\\\"https://local\", \"host:5001/\\\", new GrpcChannelOptions\\n{\\nHttpClient = httpClient,\\nCredentials = channelCredentials\\n});\\n\", \"var grpc = new Portfolios.PortfoliosClient(channel);\\nTip\\nYou can use the ChannelCredentials.Create m\", \"ethod for a client without certificate authentication. This\\nis a useful way to pass token credential\", \"s with every call made on the channel.\\nA version of the FullStockTicker sample gRPC application with\", \" certificate authentication added is on\\nGitHub.\\nEncryption and network security\\nThe network security\", \" model for Windows Communication Foundation (WCF) is extensive and complex.\\nIt includes transport-le\", \"vel security by using HTTPS or TLS-over-TCP, and message-level security by\\nusing the WS-Security spe\", \"cification to encrypt individual messages.\\ngRPC leaves secure networking to the underlying HTTP/2 pr\", \"otocol, which you can secure by using TLS\\ncertificates.\\nWeb browsers insist on using TLS connections\", \" for HTTP/2, but most programmatic clients, including\\n.NET\\u2019s HttpClient, can use HTTP/2 over unencry\", \"pted connections.\\nFor public APIs, you should always use TLS connections, and provide valid certific\", \"ates for your services\\nfrom a proper SSL authority. LetsEncrypt provides free, automated SSL certifi\", \"cates, and most hosting\\ninfrastructure today supports the LetsEncrypt standard with common plug-ins \", \"or extensions.\\nFor internal services across a corporate network, you should still consider using TLS\", \" to secure network\\ntraffic to and from your gRPC services.\\n75 CHAPTER 6 | Security in gRPC applicati\", \"onsIf you need to use explicit TLS between services running in Kubernetes, consider using an in-clus\", \"ter\\ncertificate authority and a certificate manager controller like cert-manager. You can then autom\", \"atically\\nassign certificates to services at deployment time.\\n76 CHAPTER 6 | Security in gRPC applica\", \"tions7\\nCHAPTER\\ngRPC in production\\nYou can run ASP.NET Core 7.0 applications, including gRPC services\", \", on Windows, on Linux, and in\\ncontainers using modern platforms like Docker and Kubernetes. This ch\", \"apter explores the various\\noptions for running your gRPC services in production, and looks at monito\", \"ring and logging options to\\nensure the optimal operation of systems.\\nSelf-hosted gRPC applications\\nA\", \"lthough ASP.NET Core 7.0 applications can be hosted in IIS on Windows Server, currently it isn\\u2019t\\npos\", \"sible to host a gRPC application in IIS because some of the HTTP/2 functionality isn\\u2019t supported.\\nTh\", \"is functionality is a goal for a future update to Windows Server.\\nYou can run your application as a \", \"Windows service. Or you can run it as a Linux service controlled by\\nsystemd, because of features int\", \"roduced in the .NET 6 hosting extensions.\\nRun your app as a Windows service\\nTo configure your ASP.NE\", \"T Core application to run as a Windows service, install the\\nMicrosoft.Extensions.Hosting.WindowsServ\", \"ices package from NuGet. Then add a call to\\nUseWindowsService to the CreateHostBuilder method in Pro\", \"gram.cs.\\nHost.CreateDefaultBuilder(args)\\n.UseWindowsService()\\n...\\nNote\\nIf the application isn\\u2019t runn\", \"ing as a Windows service, the UseWindowsService method doesn\\u2019t do\\nanything.\\nNow publish your applica\", \"tion by using one of these methods:\\n\\u2022 From Visual Studio by right-clicking the project and selecting\", \" Publish on the shortcut menu.\\n\\u2022 From the .NET CLI.\\nWhen you publish a .NET application, you can cho\", \"ose to create a framework-dependent deployment\\nor a self-contained deployment. Framework-dependent d\", \"eployments require the .NET Shared Runtime\\nto be installed on the host where they\\u2019re run. Self-conta\", \"ined deployments are published with a\\ncomplete copy of the .NET runtime and framework and can be run\", \" on any host. For more information,\\n77 CHAPTER 7 | gRPC in productionincluding the advantages and di\", \"sadvantages of each approach, see the .NET application deployment\\ndocumentation.\\nTo publish a self-c\", \"ontained build of the application that doesn\\u2019t require the .NET 5 runtime to be\\ninstalled on the hos\", \"t, specify the runtime to be included with the application. Use the -r (or --runtime)\\nflag.\\ndotnet p\", \"ublish -c Release -r win-x64 -o ./publish\\nTo publish a framework-dependent build, omit the -r flag.\\n\", \"dotnet publish -c Release -o ./publish\\nCopy the complete contents of the publish directory to an ins\", \"tallation folder. Then, use the sc tool to\\ncreate a Windows service for the executable file.\\nsc crea\", \"te MyService binPath=C:\\\\MyService\\\\MyService.exe\\nLog to the Windows event log\\nThe UseWindowsService m\", \"ethod automatically adds a logging provider that writes log messages to\\nthe Windows event log. You c\", \"an configure logging for this provider by adding an EventLog entry to\\nthe Logging section of appsett\", \"ings.json or another configuration source.\\nYou can override the source name used in the event log by\", \" setting a SourceName property in these\\nsettings. If you don\\u2019t specify a name, the default applicati\", \"on name (normally the executable assembly\\nname) will be used.\\nMore information on logging is at the \", \"end of this chapter.\\nRun your app as a Linux service with systemd\\nTo configure your ASP.NET Core app\", \"lication to run as a Linux service (or daemon in Linux parlance),\\ninstall the Microsoft.Extensions.H\", \"osting.Systemd package from NuGet. Then add a call to UseSystemd\\nto the CreateHostBuilder method in \", \"Program.cs.\\npublic static IHostBuilder CreateHostBuilder(string[] args) =>\\nHost.CreateDefaultBuilder\", \"(args)\\n.UseSystemd() // Enable running as a Systemd service\\n.ConfigureServices((hostContext, service\", \"s) =>\\n{\\n...\\n});\\nNote\\nIf the application isn\\u2019t running as a Linux service, the UseSystemd method does\", \"n\\u2019t do anything.\\nNow publish your application. The application can be either framework dependent or \", \"self-contained\\nfor the relevant Linux runtime (for example, linux-x64). You can publish by using one\", \" of these\\nmethods:\\n78 CHAPTER 7 | gRPC in production\\u2022 From Visual Studio by right-clicking the proje\", \"ct and selecting Publish on the shortcut menu.\\n\\u2022 From the .NET CLI, by using the following command:\\n\", \"dotnet publish -c Release -r linux-x64 -o ./publish\\nCopy the complete contents of the publish direct\", \"ory to an installation folder on the Linux host.\\nRegistering the service requires a special file, ca\", \"lled a unit file, to be added to the /etc/systemd/system\\ndirectory. You\\u2019ll need root permission to c\", \"reate a file in this folder. Name the file with the identifier\\nthat you want systemd to use and the \", \".service extension. For example, use\\n/etc/systemd/system/myapp.service.\\nThe service file uses INI fo\", \"rmat, as shown in this example:\\n[Unit]\\nDescription=My gRPC Application\\n[Service]\\nType=notify\\nExecSta\", \"rt=/usr/sbin/myapp\\n[Install]\\nWantedBy=multi-user.target\\nThe Type=notify property tells systemd that \", \"the application will notify it on startup and shutdown. The\\nWantedBy=multi-user.target setting will \", \"cause the service to start when the Linux system reaches\\n\\u201crunlevel 2,\\u201d which means a nongraphical, m\", \"ulti-user shell is active.\\nBefore systemd will recognize the service, it needs to reload its configu\", \"ration. You control systemd by\\nusing the systemctl command. After reloading, use the status subcomma\", \"nd to confirm that the\\napplication has registered successfully.\\nsudo systemctl daemon-reload\\nsudo sy\", \"stemctl status myapp\\nIf you\\u2019ve configured the service correctly, you\\u2019ll get the following output:\\nmy\", \"app.service - My gRPC Application\\nLoaded: loaded (/etc/systemd/system/myapp.service; disabled; vendo\", \"r preset: enabled)\\nActive: inactive (dead)\\nUse the start command to start the service.\\nsudo systemct\", \"l start myapp.service\\nTip\\nThe .service extension is optional when you\\u2019re using systemctl start.\\nTo t\", \"ell systemd to start the service automatically on system startup, use the enable command.\\nsudo syste\", \"mctl enable myapp\\n79 CHAPTER 7 | gRPC in productionLog to journald\\nThe Linux equivalent of the Windo\", \"ws event log is journald, a structured logging system service that\\u2019s\\npart of systemd. Log messages w\", \"ritten to the standard output by a Linux daemon are automatically\\nwritten to journald. To configure \", \"logging levels, use the Console section of the logging configuration.\\nThe UseSystemd host builder me\", \"thod automatically configures the console output format to suit the\\njournal.\\nBecause journald is the\", \" standard for Linux logs, a variety of tools integrate with it. You can easily route\\nlogs from journ\", \"ald to an external logging system. Working locally on the host, you can use the\\njournalctl command t\", \"o view logs from the command line.\\nsudo journalctl -u myapp\\nTip\\nIf you have a GUI environment availa\", \"ble on your host, a few graphical log viewers are available for\\nLinux, such as QJournalctl and gnome\", \"-logs.\\nTo learn more about querying the systemd journal from the command line by using journalctl, s\", \"ee the\\nmanpages.\\nHTTPS certificates for self-hosted applications\\nWhen you\\u2019re running a gRPC applicat\", \"ion in production, you should use a TLS certificate from a trusted\\ncertificate authority (CA). This \", \"CA might be a public CA, or an internal one for your organization.\\nOn Windows hosts, you can load th\", \"e certificate from a secure certificate store by using the X509Store\\nclass. You can also use the X50\", \"9Store class with the OpenSSL key store on some Linux hosts.\\nYou can also create certificates by usi\", \"ng one of the X509Certificate2 constructors, from either:\\n\\u2022 A file, such as a .pfx file protected by\", \" a strong password\\n\\u2022 Binary data retrieved from a secure storage service such as Azure Key Vault\\nYou\", \" can configure Kestrel to use a certificate in two ways: from configuration or in code.\\nSet HTTPS ce\", \"rtificates by using configuration\\nThe configuration approach requires setting the password and path \", \"to the certificate .pfx file in the\\nKestrel configuration section. In appsettings.json, that looks l\", \"ike this:\\n{\\n\\\"Kestrel\\\": {\\n\\\"Certificates\\\": {\\n\\\"Default\\\": {\\n\\\"Path\\\": \\\"cert.pfx\\\",\\n\\\"Password\\\": \\\"DO NOT STOR\", \"E PLAINTEXT PASSWORDS IN APPSETTINGS FILES\\\"\\n}\\n}\\n}\\n}\\n80 CHAPTER 7 | gRPC in productionProvide the pas\", \"sword by using a secure configuration source such as Azure Key Vault or Hashicorp\\nVault.\\nImportant\\nD\", \"on\\u2019t store unencrypted passwords in configuration files.\\nSet HTTPS certificates in code\\nTo configure\", \" HTTPS on Kestrel in code, use the ConfigureKestrel method on IWebHostBuilder in the\\nProgram class.\\n\", \"public static IHostBuilder CreateHostBuilder(string[] args) =>\\nHost.CreateDefaultBuilder(args)\\n.Conf\", \"igureWebHostDefaults(webBuilder =>\\n{\\nwebBuilder.ConfigureKestrel(kestrel =>\\n{\\nkestrel.ConfigureHttps\", \"Defaults(https =>\\n{\\nhttps.ServerCertificate = new X509Certificate2(\\\"mycert.pfx\\\",\\n\\\"password\\\");\\n});\\n})\", \";\\n});\\nAgain, be sure to store the password for the .pfx file in, and retrieve it from, a secure conf\", \"iguration\\nsource.\\nCreate Docker images\\nThis section covers the creation of Docker images for ASP.NET\", \" Core gRPC applications, ready to run in\\nDocker, Kubernetes, or other container environments. The sa\", \"mple application used, with an ASP.NET\\nCore MVC web app and a gRPC service, is available on the dotn\", \"et-architecture/grpc-for-wcf-\\ndevelopers repository on GitHub.\\nMicrosoft base images for ASP.NET Cor\", \"e applications\\nMicrosoft provides a range of base images for building and running .NET applications.\", \" To create an\\nASP.NET Core 7.0 image, you use two base images:\\n\\u2022 An SDK image to build and publish t\", \"he application.\\n\\u2022 A runtime image for deployment.\\nImage Description\\nmcr.microsoft.com/dotnet/sd For \", \"building applications with docker build. Not to be used in\\nk production.\\nmcr.microsoft.com/dotnet/as\", \" Contains the runtime and ASP.NET Core dependencies. For\\npnet production.\\nFor each image, there are \", \"four variants based on different Linux distributions, distinguished by tags.\\n81 CHAPTER 7 | gRPC in \", \"productionImage tag(s) Linux Notes\\n7.0-bullseye-slim, 7.0 Debian 11 The default image if no\\nOS varia\", \"nt is specified.\\n7.0-alpine Alpine 3.17 Alpine base images are\\nmuch smaller than\\nDebian or Ubuntu on\", \"es.\\nThe Alpine base image is around 100 MB, compared to 200 MB for the Debian and Ubuntu images.\\nSom\", \"e software packages or libraries might not be available in Alpine\\u2019s package management. If you\\u2019re\\nno\", \"t sure which image to use, you should probably choose the default Debian.\\nImportant\\nMake sure you us\", \"e the same variant of Linux for the build and the runtime. Applications built and\\npublished on one v\", \"ariant might not work on another.\\nCreate a Docker image\\nA Docker image is defined by a Dockerfile. T\", \"his Dockerfile is a text file that contains all the commands\\nneeded to build the application and ins\", \"tall any dependencies that are required for either building or\\nrunning the application. The followin\", \"g example shows the simplest Dockerfile for an ASP.NET Core 7.0\\napplication:\\nFROM mcr.microsoft.com/\", \"dotnet/sdk:7.0 as build\\nWORKDIR /src\\nCOPY ./StockKube.sln .\\nCOPY ./src/StockData/StockData.csproj ./\", \"src/StockData/\\nCOPY ./src/StockWeb/StockWeb.csproj ./src/StockWeb/\\nRUN dotnet restore\\nCOPY . .\\nRUN d\", \"otnet publish --no-restore -c Release -o /published src/StockData/StockData.csproj\\nFROM mcr.microsof\", \"t.com/dotnet/aspnet:7.0 as runtime\\n# Uncomment the line below if running with HTTPS\\n# ENV ASPNETCORE\", \"_URLS=https://+:443\\nWORKDIR /app\\nCOPY --from=build /published .\\nENTRYPOINT [ \\\"dotnet\\\", \\\"StockData.dl\", \"l\\\" ]\\nThe Dockerfile has two parts: the first uses the sdk base image to build and publish the applic\", \"ation;\\nthe second creates a runtime image from the aspnet base. This is because the sdk image is aro\", \"und\\n900 MB, compared to around 200 MB for the runtime image, and most of its contents are unnecessar\", \"y\\nat run time.\\n82 CHAPTER 7 | gRPC in productionThe build steps\\nStep Description\\nFROM ... Declares t\", \"he base image and assigns the builder alias.\\nWORKDIR /src Creates the /src directory and sets it as \", \"the current working directory.\\nCOPY . . Copies everything below the current directory on the host in\", \"to the\\ncurrent directory on the image.\\nRUN dotnet restore Restores any external packages (ASP.NET Co\", \"re 3.0 framework is\\npreinstalled with the SDK).\\nRUN dotnet publish ... Builds and publishes a Releas\", \"e build. The --runtime flag isn\\u2019t required.\\nThe runtime image steps\\nStep Description\\nFROM ... Declar\", \"es a new base image.\\nWORKDIR /app Creates the /app directory and sets it as the current working dire\", \"ctory.\\nCOPY --from=builder ... Copies the published application from the previous image, by using th\", \"e\\nbuilder alias from the first FROM line.\\nENTRYPOINT [ ... ] Sets the command to run when the contai\", \"ner starts. The dotnet\\ncommand in the runtime image can only run DLL files.\\nHTTPS in Docker\\nMicrosof\", \"t base images for Docker set the ASPNETCORE_URLS environment variable to http://+:80,\\nmeaning that K\", \"estrel runs without HTTPS on that port. If you\\u2019re using HTTPS with a custom certificate\\n(as describe\", \"d in Self-hosted gRPC applications), you should override this configuration. Set the\\nenvironment var\", \"iable in the runtime image creation part of your Dockerfile.\\n# Runtime image creation\\nFROM mcr.micro\", \"soft.com/dotnet/aspnet:7.0\\nENV ASPNETCORE_URLS=https://+:443\\nThe .dockerignore file\\nMuch like .gitig\", \"nore files that exclude certain files and directories from source control, the\\n.dockerignore file ca\", \"n be used to exclude files and directories from being copied to the image during\\nbuild. This file no\", \"t only saves time copying, but can also avoid some errors that arise from having the\\nobj directory f\", \"rom your PC copied into the image. At a minimum, you should add entries for bin and\\nobj to your .doc\", \"kerignore file.\\nbin/\\nobj/\\n83 CHAPTER 7 | gRPC in productionBuild the image\\nFor a StockKube.sln solut\", \"ion containing two different applications StockData and StockWeb, it\\u2019s\\nsimplest to put the Dockerfil\", \"e for each one of them in the base directory. In that case, to build the\\nimage, use the following do\", \"cker build command from the same directory where .sln file resides.\\ndocker build -t stockdata:1.0.0 \", \"-f ./src/StockData/Dockerfile .\\nThe confusingly named --tag flag (which can be shortened to -t) spec\", \"ifies the whole name of the\\nimage, including the actual tag if specified. The . at the end specifies\", \" the context in which the build\\nwill be run; the current working directory for the COPY commands in \", \"the Dockerfile.\\nIf you have multiple applications within a single solution, you can keep the Dockerf\", \"ile for each\\napplication in its own folder, beside the .csproj file. You should still run the docker\", \" build command\\nfrom the base directory to ensure that the solution and all the projects are copied i\", \"nto the image. You\\ncan specify a Dockerfile below the current directory by using the --file (or -f) \", \"flag.\\ndocker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .\\nRun the image in a container o\", \"n your machine\\nTo run the image in your local Docker instance, use the docker run command.\\ndocker ru\", \"n -ti -p 5000:80 stockdata:1.0.0\\nThe -ti flag connects your current terminal to the container\\u2019s term\", \"inal, and runs in interactive mode.\\nThe -p 5000:80 publishes (links) port 80 on the container to por\", \"t 5000 on the localhost network\\ninterface.\\nPush the image to a registry\\nAfter you\\u2019ve verified that t\", \"he image works, push it to a Docker registry to make it available on other\\nsystems. Internal network\", \"s will need to provision a Docker registry. This activity can be as simple as\\nrunning Docker\\u2019s own r\", \"egistry image (the Docker registry runs in a Docker container), but there are\\nvarious more comprehen\", \"sive solutions available. For external sharing and cloud use, there are various\\nmanaged registries a\", \"vailable, such as Azure Container Registry or Docker Hub.\\nTo push to Docker Hub, prefix the image na\", \"me with your user or organization name.\\ndocker tag stockdata:1.0.0 <myorg>/stockdata:1.0.0\\ndocker pu\", \"sh <myorg>/stockdata:1.0.0\\nTo push to a private registry, prefix the image name with the registry ho\", \"st name and the organization\\nname.\\ndocker tag stockdata <internal-registry:5000>/<myorg>/stockdata:1\", \".0.0\\ndocker push <internal-registry:5000>/<myorg>/stockdata:1.0.0\\nAfter the image is in a registry, \", \"you can deploy it to individual Docker hosts, or to a container\\norchestration engine like Kubernetes\", \".\\n84 CHAPTER 7 | gRPC in productionKubernetes\\nAlthough it\\u2019s possible to run containers manually on D\", \"ocker hosts, for reliable production systems it\\u2019s\\nbetter to use a container orchestration engine to \", \"manage multiple instances running across several\\nservers in a cluster. There are various container o\", \"rchestration engines available, including Kubernetes,\\nDocker Swarm, and Apache Mesos. But of these e\", \"ngines, Kubernetes is far and away the most widely\\nused, so it will be the focus of this chapter.\\nKu\", \"bernetes includes the following functionality:\\n\\u2022 Scheduling runs containers on multiple nodes within\", \" a cluster, ensuring balanced usage of\\nthe available resource, keeping containers running if there a\", \"re outages, and handling rolling\\nupdates to new versions of images or new configurations.\\n\\u2022 Health c\", \"hecks monitor containers to ensure continued service.\\n\\u2022 DNS & service discovery handles routing betw\", \"een services within a cluster.\\n\\u2022 Ingress exposes selected services externally and generally provides\", \" load-balancing across\\ninstances of those services.\\n\\u2022 Resource management attaches external resource\", \"s like storage to containers.\\nThis chapter will detail how to deploy an ASP.NET Core gRPC service an\", \"d a website that consumes the\\nservice into a Kubernetes cluster. The sample application used is avai\", \"lable in the dotnet-\\narchitecture/grpc-for-wcf-developers repository on GitHub.\\nKubernetes terminolo\", \"gy\\nKubernetes uses desired state configuration: the API is used to describe objects like Pods, Deplo\", \"yments,\\nand Services, and the Control Plane takes care of implementing the desired state across all \", \"the nodes\\nin a cluster. A Kubernetes cluster has a Master node that runs the Kubernetes API, which y\", \"ou can\\ncommunicate with programmatically or by using the kubectl command-line tool. kubectl can crea\", \"te\\nand manage objects through command-line arguments, but it works best with YAML files that contain\", \"\\ndeclaration data for Kubernetes objects.\\nKubernetes YAML files\\nEvery Kubernetes YAML file will have\", \" at least three top-level properties:\\napiVersion: v1\\nkind: Namespace\\nmetadata:\\n# Object properties\\nT\", \"he apiVersion property is used to specify which version (and which API) the file is intended for. Th\", \"e\\nkind property specifies the kind of object the YAML represents. The metadata property contains\\nobj\", \"ect properties like name, namespace, and labels.\\nMost Kubernetes YAML files will also have a spec se\", \"ction that describes the resources and\\nconfiguration necessary to create the object.\\n85 CHAPTER 7 | \", \"gRPC in productionPods\\nPods are the basic units of execution in Kubernetes. They can run multiple co\", \"ntainers, but they\\u2019re also\\nused to run single containers. The pod also includes any storage resource\", \"s required by the containers,\\nand the network IP address.\\nServices\\nServices are meta-objects that de\", \"scribe Pods (or sets of Pods) and provide a way to access them\\nwithin the cluster, such as mapping a\", \" service name to a set of pod IP addresses by using the cluster\\nDNS service.\\nDeployments\\nDeployments\", \" are the desired state objects for Pods. If you create a pod manually, it won\\u2019t be restarted\\nwhen it\", \" terminates. Deployments are used to tell the cluster which Pods, and how many replicas of\\nthose Pod\", \"s, should be running at the present time.\\nOther objects\\nPods, Services, and Deployments are just thr\", \"ee of the most basic object types. There are dozens of\\nother object types that are managed by Kubern\", \"etes clusters. For more information, see the\\nKubernetes Concepts documentation.\\nNamespaces\\nKubernete\", \"s clusters are designed to scale to hundreds or thousands of nodes and to run similar\\nnumbers of ser\", \"vices. To avoid clashes between object names, namespaces are used to group objects\\ntogether as part \", \"of larger applications. Kubernetes\\u2019s own services run in a default namespace. All user\\nobjects shoul\", \"d be created in their own namespaces to avoid potential clashes with default objects or\\nother tenant\", \"s in the cluster.\\nGet started with Kubernetes\\nIf you\\u2019re running Docker Desktop for Windows or Docker\", \" Desktop for Mac, Kubernetes is already\\navailable. Just enable it in the Kubernetes section of the S\", \"ettings window:\\n86 CHAPTER 7 | gRPC in productionTo run a local Kubernetes cluster on Linux, conside\", \"r minikube, or MicroK8s if your Linux distribution\\nsupports snaps.\\nTo confirm that your cluster is r\", \"unning and accessible, run the kubectl version command:\\nkubectl version\\nClient Version: version.Info\", \"{Major:\\\"1\\\", Minor:\\\"19\\\", GitVersion:\\\"v1.19.3\\\",\\nGitCommit:\\\"1e11e4a2108024935ecfcb2912226cedeafd99df\\\", \", \"GitTreeState:\\\"clean\\\",\\nBuildDate:\\\"2020-10-14T12:50:19Z\\\", GoVersion:\\\"go1.15.2\\\", Compiler:\\\"gc\\\",\\nPlatfor\", \"m:\\\"windows/amd64\\\"}\\nServer Version: version.Info{Major:\\\"1\\\", Minor:\\\"19\\\", GitVersion:\\\"v1.19.3\\\",\\nGitComm\", \"it:\\\"1e11e4a2108024935ecfcb2912226cedeafd99df\\\", GitTreeState:\\\"clean\\\",\\nBuildDate:\\\"2020-10-14T12:41:49Z\", \"\\\", GoVersion:\\\"go1.15.2\\\", Compiler:\\\"gc\\\",\\nPlatform:\\\"linux/amd64\\\"}\\nIn this example, both the kubectl CL\", \"I and the Kubernetes server are running version 1.14.6. Each\\nversion of kubectl is supposed to suppo\", \"rt the previous and next version of the server, so kubectl 1.14\\nshould work with server versions 1.1\", \"3 and 1.15 as well.\\nRun services on Kubernetes\\nThe sample application has a kube directory that cont\", \"ains three YAML files. The namespace.yml file\\ndeclares a custom namespace: stocks. The stockdata.yml\", \" file declares the Deployment and the Service\\nfor the gRPC application, and the stockweb.yml file de\", \"clares the Deployment and Service for an\\nASP.NET Core 7.0 MVC web application that consumes the gRPC\", \" service.\\nTo use a YAML file with kubectl, run the apply -f command:\\nkubectl apply -f object.yml\\nThe\", \" apply command will check the validity of the YAML file and display any errors received from the\\nAPI\", \", but doesn\\u2019t wait until all the objects declared in the file have been created because this step ca\", \"n\\n87 CHAPTER 7 | gRPC in productiontake some time. Use the kubectl get command with the relevant obj\", \"ect types to check on object\\ncreation in the cluster.\\nThe namespace declaration\\nNamespace declaratio\", \"n is simple and requires only assigning a name:\\napiVersion: v1\\nkind: Namespace\\nmetadata:\\nname: stock\", \"s\\nUse kubectl to apply the namespace.yml file and to confirm the namespace is created successfully:\\n\", \"> kubectl apply -f namespace.yml\\nnamespace/stocks created\\n> kubectl get namespaces\\nNAME STATUS AGE\\ns\", \"tocks Active 2m53s\\nThe StockData application\\nThe stockdata.yml file declares two objects: a Deployme\", \"nt and a Service.\\nThe StockData Deployment\\nThe Deployment part of the YAML file provides the spec fo\", \"r the deployment itself, including the\\nnumber of replicas required, and a template for the Pod objec\", \"ts to be created and managed by the\\ndeployment. Note that Deployment objects are managed by the apps\", \" API, as specified in apiVersion,\\nrather than the main Kubernetes API.\\napiVersion: apps/v1\\nkind: Dep\", \"loyment\\nmetadata:\\nname: stockdata\\nnamespace: stocks\\nspec:\\nselector:\\nmatchLabels:\\nrun: stockdata\\nrepl\", \"icas: 1\\ntemplate:\\nmetadata:\\nlabels:\\nrun: stockdata\\nspec:\\ncontainers:\\n- name: stockdata\\nimage: stockd\", \"ata:1.0.0\\nimagePullPolicy: Never\\nresources:\\nlimits:\\ncpu: 100m\\nmemory: 100Mi\\nports:\\n- containerPort: \", \"80\\n88 CHAPTER 7 | gRPC in productionThe spec.selector property is used to match running Pods to the \", \"Deployment. The Pod\\u2019s\\nmetadata.labels property must match the matchLabels property or the API call w\", \"ill fail.\\nThe template.spec section declares the container to be run. When you\\u2019re working with a loc\", \"al\\nKubernetes cluster, such as the one provided by Docker Desktop, you can specify images that were\\n\", \"built locally as long as they have a version tag.\\nImportant\\nBy default, Kubernetes will always check\", \" for and try to pull a new image. If it can\\u2019t find the image in\\nany of its known repositories, the P\", \"od creation will fail. To work with local images, set the\\nimagePullPolicy to Never.\\nThe ports proper\", \"ty specifies which container ports should be published on the Pod. The stockservice\\nimage runs the s\", \"ervice on the standard HTTP port, so port 80 is published.\\nThe resources section applies resource li\", \"mits to the container running within the Pod. This is a good\\npractice because it prevents an individ\", \"ual Pod from consuming all the available CPU or memory on a\\nnode.\\nNote\\nASP.NET Core 7.0 has been opt\", \"imized and tuned to run in resource-limited containers. The\\ndotnet/core/aspnet Docker image sets an \", \"environment variable to tell the dotnet runtime that it\\u2019s in a\\ncontainer.\\nThe StockData Service\\nThe \", \"Service part of the YAML file declares the service that provides access to the Pods within the\\nclust\", \"er.\\napiVersion: v1\\nkind: Service\\nmetadata:\\nname: stockdata\\nnamespace: stocks\\nspec:\\nports:\\n- port: 80\", \"\\nselector:\\nrun: stockdata\\nThe Service spec uses the selector property to match running Pods, in this\", \" case looking for Pods that\\nhave a label run: stockdata. The specified port on matching Pods is publ\", \"ished by the named service.\\nOther Pods running in the stocks namespace can access HTTP on this servi\", \"ce by using\\nhttp://stockdata as the address. Pods running in other namespaces can use the http://sto\", \"ckdata.stocks\\nhost name. You can control cross-namespace service access by using Network Policies.\\nD\", \"eploy the StockData application\\nUse kubectl to apply the stockdata.yml file and confirm that the Dep\", \"loyment and Service were\\ncreated:\\n89 CHAPTER 7 | gRPC in production> kubectl apply -f .\\\\stockdata.ym\", \"l\\ndeployment.apps/stockdata created\\nservice/stockdata created\\n> kubectl get deployment stockdata --n\", \"amespace stocks\\nNAME READY UP-TO-DATE AVAILABLE AGE\\nstockdata 1/1 1 1 17s\\n> kubectl get service stoc\", \"kdata --namespace stocks\\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\\nstockdata ClusterIP 10.97.132.\", \"103 <none> 80/TCP 33s\\nThe StockWeb application\\nThe stockweb.yml file declares the Deployment and Ser\", \"vice for the MVC application.\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\nname: stockweb\\nnamespac\", \"e: stocks\\nspec:\\nselector:\\nmatchLabels:\\nrun: stockweb\\nreplicas: 1\\ntemplate:\\nmetadata:\\nlabels:\\nrun: st\", \"ockweb\\nspec:\\ncontainers:\\n- name: stockweb\\nimage: stockweb:1.0.0\\nimagePullPolicy: Never\\nresources:\\nli\", \"mits:\\ncpu: 100m\\nmemory: 100Mi\\nports:\\n- containerPort: 80\\nenv:\\n- name: StockData__Address\\nvalue: \\\"htt\", \"p://stockdata\\\"\\n- name: DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT\\nvalue: \\\"tru\", \"e\\\"\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\nname: stockweb\\nnamespace: stocks\\nspec:\\ntype: NodePort\\n\", \"ports:\\n- port: 80\\nselector:\\nrun: stockweb\\n90 CHAPTER 7 | gRPC in productionEnvironment variables\\nThe\", \" env section of the Deployment object specifies environment variables to be set in the container\\ntha\", \"t\\u2019s running the stockweb:1.0.0 images.\\nThe StockData__Address environment variable will map to the S\", \"tockData:Address configuration\\nsetting thanks to the EnvironmentVariables configuration provider. Th\", \"is setting uses double\\nunderscores between names to separate sections. The address uses the service \", \"name of the stockdata\\nService, which is running in the same Kubernetes namespace.\\nThe DOTNET_SYSTEM_\", \"NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT\\nenvironment variable sets an AppContext switch t\", \"hat enables unencrypted HTTP/2 connections for\\nHttpClient. This environment variable does the same t\", \"hing as setting the switch in code, as shown\\nhere:\\nAppContext.SetSwitch(\\\"System.Net.Http.SocketsHttp\", \"Handler.Http2UnencryptedSupport\\\", true);\\nIf you use an environment variable for the switch, you can \", \"easily change the context depending on the\\ncontext in which the application is running.\\nService type\", \"s\\nThe type: NodePort property is used to make the web application accessible from outside the cluste\", \"r.\\nThis property type causes Kubernetes to publish port 80 on the Service to an arbitrary port on th\", \"e\\ncluster\\u2019s external network sockets. You can find the assigned port by using the kubectl get servic\", \"e\\ncommand.\\nThe stockdata Service shouldn\\u2019t be accessible from outside the cluster, so it uses the de\", \"fault type,\\nClusterIP.\\nProduction systems will most likely use an integrated load balancer to expose\", \" public applications to\\nexternal consumers. Services exposed in this way should use the LoadBalancer\", \" type.\\nFor more information on Service types, see the Kubernetes Publishing Services documentation.\\n\", \"Deploy the StockWeb application\\nUse kubectl to apply the stockweb.yml file and confirm that the Depl\", \"oyment and Service were created:\\n> kubectl apply -f .\\\\stockweb.yml\\ndeployment.apps/stockweb created\\n\", \"service/stockweb created\\n> kubectl get deployment stockweb --namespace stocks\\nNAME READY UP-TO-DATE \", \"AVAILABLE AGE\\nstockweb 1/1 1 1 8s\\n> kubectl get service stockweb --namespace stocks\\nNAME TYPE CLUSTE\", \"R-IP EXTERNAL-IP PORT(S) AGE\\nstockweb NodePort 10.106.141.5 <none> 80:32564/TCP 13s\\nThe output of th\", \"e get service command shows that the HTTP port has been published to port 32564\\non the external netw\", \"ork. For Docker Desktop, this IP address will be localhost. You can access the\\napplication by browsi\", \"ng to http://localhost:32564.\\n91 CHAPTER 7 | gRPC in productionTest the application\\nThe StockWeb app\", \"lication displays a list of NASDAQ stocks that are retrieved from a simple request-\\nreply service. F\", \"or this demonstration, each line also shows the unique ID of the Service instance that\\nreturned it.\\n\", \"If the number of replicas of the stockdata Service were increased, you might expect the Server value\", \"\\nto change from line to line, but in fact all 100 records are always returned from the same instance\", \". If\\nyou refresh the page every few seconds, the server ID remains the same. Why does this happen?\\nT\", \"here are two factors at play here.\\nFirst, the Kubernetes Service discovery system uses round-robin l\", \"oad balancing by default. The first\\ntime the DNS server is queried, it will return the first matchin\", \"g IP address for the Service. The next\\ntime, it will return the next IP address in the list, and so \", \"on, until the end. At that point, it loops back to\\nthe start.\\nSecond, the HttpClient used for the St\", \"ockWeb application\\u2019s gRPC client is created and managed by\\nthe ASP.NET Core HttpClientFactory, and a\", \" single instance of this client is used for every call to the\\npage. The client only does one DNS loo\", \"kup, so all requests are routed to the same IP address. And\\nbecause the HttpClientHandler is cached \", \"for performance reasons, multiple requests in quick\\nsuccession will all use the same IP address, unt\", \"il the cached DNS entry expires or the handler instance\\nis disposed for some reason.\\nThe result is t\", \"hat by default requests to a gRPC Service aren\\u2019t balanced across all instances of that\\nService in th\", \"e cluster. Different consumers will use different instances, but that doesn\\u2019t guarantee a\\ngood distr\", \"ibution of requests or a balanced use of resources.\\nThe next chapter, Service meshes, will address t\", \"his problem.\\n92 CHAPTER 7 | gRPC in productionService meshes\\nA service mesh is an infrastructure com\", \"ponent that takes control of routing service requests within a\\nnetwork. Service meshes can handle al\", \"l kinds of network-level concerns within a Kubernetes cluster,\\nincluding:\\n\\u2022 Service discovery\\n\\u2022 Load\", \" balancing\\n\\u2022 Fault tolerance\\n\\u2022 Encryption\\n\\u2022 Monitoring\\nKubernetes service meshes work by adding an e\", \"xtra container, called a sidecar proxy, to each pod\\nincluded in the mesh. The proxy takes over handl\", \"ing all inbound and outbound network requests. You\\ncan then keep the configuration and management of\", \" networking matters separate from the\\napplication containers. In many cases, this separation doesn\\u2019t\", \" require any changes to the application\\ncode.\\nIn the previous chapter\\u2019s example, the gRPC requests f\", \"rom the web application were all routed to a\\nsingle instance of the gRPC service. This happens becau\", \"se the service\\u2019s host name is resolved to an IP\\naddress, and that IP address is cached for the lifet\", \"ime of the HttpClientHandler instance. It might be\\npossible to work around this behavior by handling\", \" DNS lookups manually or creating multiple clients.\\nBut this workaround would complicate the applica\", \"tion code without adding any business or customer\\nvalue.\\nWhen you use a service mesh, the requests f\", \"rom the application container are sent to the sidecar\\nproxy. The sidecar proxy can then distribute t\", \"hem intelligently across all instances of the other service.\\nThe mesh can also:\\n\\u2022 Respond seamlessly\", \" to failures of individual instances of a service.\\n\\u2022 Handle retry semantics for failed calls or time\", \"outs.\\n\\u2022 Reroute failed requests to an alternate instance without returning to the client application\", \".\\nThe following screenshot shows the StockWeb application running with the Linkerd service mesh.\\nThe\", \"re are no changes to the application code, and the Docker image isn\\u2019t being used. The only\\nchange re\", \"quired was the addition of an annotation to the deployment in the YAML files for the\\nstockdata and s\", \"tockweb services.\\n93 CHAPTER 7 | gRPC in productionYou can see from the Server column that the reque\", \"sts from the StockWeb application have been\\nrouted to both replicas of the StockData service, despit\", \"e originating from a single HttpClient instance\\nin the application code. In fact, if you review the \", \"code, you\\u2019ll see that all 100 requests to the StockData\\nservice are made simultaneously by using the\", \" same HttpClient instance. With the service mesh, those\\nrequests will be balanced across however man\", \"y service instances are available.\\nService meshes apply only to traffic within a cluster. For extern\", \"al clients, see the next chapter, Load\\nBalancing.\\nService mesh options\\nThree general-purpose service\", \" mesh implementations are currently available for use with Kubernetes:\\nIstio, Linkerd, and Consul Co\", \"nnect. All three provide request routing/proxying, traffic encryption,\\nresilience, host-to-host auth\", \"entication, and traffic control.\\nChoosing a service mesh depends on multiple factors:\\n\\u2022 The organiza\", \"tion\\u2019s specific requirements around costs, compliance, paid support plans, and so\\non.\\n\\u2022 The nature o\", \"f the cluster, its size, the number of services deployed, and the volume of traffic\\nwithin the clust\", \"er network.\\n\\u2022 Ease of deploying and managing the mesh and using it with services.\\nExample: Add Linke\", \"rd to a deployment\\nIn this example, you\\u2019ll learn how to use the Linkerd service mesh with the StockK\", \"ube application from\\nthe previous section. To follow this example, you\\u2019ll need to install the Linker\", \"d CLI. You can download\\n94 CHAPTER 7 | gRPC in productionWindows binaries from the section that list\", \"s GitHub releases. Be sure to use the most recent stable\\nrelease and not one of the edge releases.\\nW\", \"ith the Linkerd CLI installed, follow the Getting Started instructions to install the Linkerd\\ncompon\", \"ents on your Kubernetes cluster. The instructions are straightforward, and the installation\\nshould t\", \"ake only a couple of minutes on a local Kubernetes instance.\\nAdd Linkerd to Kubernetes deployments\\nT\", \"he Linkerd CLI provides an inject command to add the necessary sections and properties to\\nKubernetes\", \" files. You can run the command and write the output to a new file.\\nlinkerd inject stockdata.yml > s\", \"tockdata-with-mesh.yml\\nlinkerd inject stockweb.yml > stockweb-with-mesh.yml\\nYou can inspect the new \", \"files to see what changes have been made. For deployment objects, a\\nmetadata annotation is added to \", \"tell Linkerd to inject a sidecar proxy container into the pod when it\\u2019s\\ncreated.\\nIt\\u2019s also possible \", \"to pipe the output of the linkerd inject command to kubectl directly. The following\\ncommands will wo\", \"rk in PowerShell or any Linux shell.\\nlinkerd inject stockdata.yml | kubectl apply -f -\\nlinkerd injec\", \"t stockweb.yml | kubectl apply -f -\\nInspect services in the Linkerd dashboard\\nOpen the Linkerd dashb\", \"oard by using the linkerd CLI.\\nlinkerd dashboard\\nThe dashboard provides detailed information about a\", \"ll services that are connected to the mesh.\\n95 CHAPTER 7 | gRPC in productionIf you increase the num\", \"ber of replicas of the StockData gRPC service as shown in the following\\nexample, and refresh the Sto\", \"ckWeb page in the browser, you should see a mix of IDs in the Server\\ncolumn. This mix indicates that\", \" all the available instances are serving requests.\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\nna\", \"me: stockdata\\nnamespace: stocks\\nspec:\\nselector:\\nmatchLabels:\\nrun: stockdata\\nreplicas: 2 # Increase t\", \"he target number of instances\\ntemplate:\\nmetadata:\\nannotations:\\nlinkerd.io/inject: enabled\\ncreationTi\", \"mestamp: null\\nlabels:\\nrun: stockdata\\nspec:\\ncontainers:\\n- name: stockdata\\nimage: stockdata:1.0.0\\nimag\", \"ePullPolicy: Never\\nresources:\\nlimits:\\ncpu: 100m\\nmemory: 100Mi\\nports:\\n- containerPort: 80\\n96 CHAPTER \", \"7 | gRPC in productionLoad balancing gRPC\\nA typical deployment of a gRPC application includes a numb\", \"er of identical instances of the service,\\nproviding resilience and horizontal scalability. Load bala\", \"ncing distributes incoming requests across\\nthese instances to provide full usage of all available re\", \"sources. To make this load balancing invisible to\\nthe client, it\\u2019s common to use a proxy load balanc\", \"er server to handle requests from clients and route\\nthem to back-end instances.\\nLoad balancers are c\", \"lassified according to the layer they operate on. Layer 4 load balancers work on\\nthe transport level\", \", for example, with TCP sockets, connections, and packets. Layer 7 load balancers\\nwork at the applic\", \"ation level, specifically handling HTTP/2 requests for gRPC applications.\\nL4 load balancers\\nAn L4 lo\", \"ad balancer accepts a TCP connection request from a client, opens another connection to one\\nof the b\", \"ack-end instances, and copies data between the two connections with no real processing. L4\\noffers ex\", \"cellent performance and low latency, but with little control or intelligence. As long as the\\nclient \", \"keeps the connection open, all requests will be directed to the same back-end instance.\\nAzure Load B\", \"alancer is an example of an L4 load balancer.\\nL7 load balancers\\nAn L7 load balancer parses incoming \", \"HTTP/2 requests and passes them on to back-end instances on a\\nrequest-by-request basis, no matter ho\", \"w long the connection is held by the client.\\nExamples of L7 load balancers:\\n\\u2022 NGINX\\n\\u2022 HAProxy\\n\\u2022 Trae\", \"fik\\nAs a rule of thumb, L7 load balancers are the best choice for gRPC and other HTTP/2 applications\", \" (and\\nfor HTTP applications generally, in fact). L4 load balancers will work with gRPC applications,\", \" but\\nthey\\u2019re primarily useful when low latency and low overhead are important.\\nImportant\\nAt the time\", \" of this writing, some L7 load balancers don\\u2019t support all the parts of the HTTP/2\\nspecification tha\", \"t are required by gRPC services, such as trailing headers.\\nIf you\\u2019re using TLS encryption, load bala\", \"ncers can terminate the TLS connection and pass unencrypted\\nrequests to the back-end application, or\", \" they can pass the encrypted request along. Either way, the\\nload balancer will need to be configured\", \" with the server\\u2019s public and private key so it can decrypt\\nrequests for processing.\\nSee to the docu\", \"mentation for your preferred load balancer to find out how to configure it to handle\\nHTTP/2 requests\", \" with your back-end services.\\n97 CHAPTER 7 | gRPC in productionLoad balancing within Kubernetes\\nSee \", \"the section on service meshes for a discussion of load balancing across internal services on\\nKuberne\", \"tes.\\nApplication Performance Management\\nIn production environments like Kubernetes, it\\u2019s important t\", \"o monitor applications to ensure they\\u2019re\\nrunning optimally. Logging and metrics are important in par\", \"ticular. ASP.NET Core, including gRPC,\\nprovides built-in support for producing and managing log mess\", \"ages and metrics data, as well as\\ntracing data.\\nThe difference between logging and metrics\\nLogging i\", \"s concerned with text messages that record detailed information about things that have\\nhappened in t\", \"he system. Log messages might include exception data, like stack traces, or structured\\ndata that pro\", \"vide context about the message. Logging output is commonly written to a searchable\\ntext store.\\nMetri\", \"cs refers to numeric data designed to be aggregated and presented by using charts and graphs\\nin a da\", \"shboard. The dashboard provides a view of the overall health and performance of an\\napplication. Metr\", \"ics data can also be used to trigger automated alerts when a threshold is exceeded.\\nHere are some ex\", \"amples of metrics data:\\n\\u2022 Time taken to process requests.\\n\\u2022 The number of requests per second being \", \"handled by an instance of a service.\\n\\u2022 The number of failed requests on an instance.\\nLogging in ASP.\", \"NET Core gRPC\\nASP.NET Core provides built-in support for logging, in the form of Microsoft.Extension\", \"s.Logging\\nNuGet package. The core parts of this library are included with the Web SDK, so there\\u2019s no\", \" need to\\ninstall it manually. By default, log messages are written to the standard output (the \\u201ccons\", \"ole\\u201d) and to\\nany attached debugger. To write logs to persistent external data stores, you might need\", \" to import\\noptional logging sink packages.\\nThe ASP.NET Core gRPC framework writes detailed diagnosti\", \"c logging messages to this logging\\nframework, so they can be processed and stored along with your ap\", \"plication\\u2019s own messages.\\nProduce log messages\\nThe logging extension is automatically registered wit\", \"h ASP.NET Core\\u2019s dependency injection system,\\nso you can specify loggers as a constructor parameter \", \"on gRPC service types.\\npublic class StockData : Stocks.StocksBase\\n{\\nprivate readonly ILogger<StockDa\", \"ta> _logger;\\npublic StockData(ILogger<StockData> logger)\\n98 CHAPTER 7 | gRPC in production{\\n_logger \", \"= logger;\\n}\\n}\\nMany log messages, such as requests and exceptions, are provided by the ASP.NET Core a\", \"nd gRPC\\nframework components. Add your own log messages to provide detail and context about applicat\", \"ion\\nlogic, rather than lower-level concerns.\\nFor more information about writing log messages and ava\", \"ilable logging sinks and targets, see\\nLogging in .NET Core and ASP.NET Core.\\nMetrics in ASP.NET Core\", \" gRPC\\nThe .NET Core runtime provides a set of components for emitting and observing metrics. These\\ni\", \"nclude APIs such as the EventSource and EventCounter classes. These APIs can emit basic numeric\\ndata\", \" that can be consumed by external processes, like the dotnet-counters global tool, or Event\\nTracing \", \"for Windows. For more information about using EventCounter in your own code, see\\nEventCounter introd\", \"uction.\\nFor more advanced metrics and for writing metric data to a wider range of data stores, you m\", \"ight try\\nan open-source project called App Metrics. This suite of libraries provides an extensive se\", \"t of types to\\ninstrument your code. It also offers packages to write metrics to different kinds of t\", \"argets that include\\ntime-series databases, such as Prometheus and InfluxDB, and Application Insights\", \". The\\nApp.Metrics.AspNetCore.Mvc NuGet package even adds a comprehensive set of basic metrics that a\", \"re\\nautomatically generated via integration with the ASP.NET Core framework. The project website\\nprov\", \"ides templates for displaying those metrics with the Grafana visualization platform.\\nProduce metrics\", \"\\nMost metrics platforms support the following types:\\nMetric type Description\\nCounter Tracks how ofte\", \"n something happens, such as\\nrequests and errors.\\nGauge Records a single value that changes over tim\", \"e,\\nsuch as active connections.\\nHistogram Measures a distribution of values across\\narbitrary limits. \", \"For example, a histogram can\\ntrack dataset size, counting how many\\ncontained <10 records, how many c\", \"ontained\\n11-100 records, how many contained 101-1000\\nrecords, and how many contained >1000\\nrecords.\\n\", \"Meter Measures the rate at which an event occurs in\\nvarious time spans.\\n99 CHAPTER 7 | gRPC in produ\", \"ctionMetric type Description\\nTimer Tracks the duration of events and the rate at\\nwhich it occurs, st\", \"ored as a histogram.\\nBy using App Metrics, an IMetrics interface can be obtained via dependency inje\", \"ction, and used to\\nrecord any of these metrics for a gRPC service. The following example shows how t\", \"o count the\\nnumber of Get requests made over time:\\npublic class StockData : Stocks.StocksBase\\n{\\npriv\", \"ate static readonly CounterOptions GetRequestCounter = new CounterOptions\\n{\\nName = \\\"StockData_Get_Re\", \"quests\\\",\\nMeasurementUnit = Unit.Calls\\n};\\nprivate readonly IStockRepository _repository;\\nprivate read\", \"only IMetrics _metrics;\\npublic StockData(IStockRepository repository, IMetrics metrics)\\n{\\n_repositor\", \"y = repository;\\n_metrics = metrics;\\n}\\npublic override async Task<GetResponse> Get(GetRequest request\", \", ServerCallContext\\ncontext)\\n{\\n_metrics.Measure.Counter.Increment(GetRequestCounter);\\n// Serve reque\", \"st...\\n}\\n}\\nStore and visualize metrics data\\nThe best way to store metrics data is in a time-series da\", \"tabase, a specialized data store designed to\\nrecord numerical data series marked with timestamps. Th\", \"e most popular of these databases are\\nPrometheus and InfluxDB. Microsoft Azure also provides dedicat\", \"ed metrics storage through the Azure\\nMonitor service.\\nThe current go-to solution for visualizing met\", \"rics data is Grafana, which works with a wide range of\\nstorage providers. The following image shows \", \"an example Grafana dashboard that displays metrics\\nfrom the Linkerd service mesh running the StockDa\", \"ta sample:\\n100 CHAPTER 7 | gRPC in productionMetrics-based alerting\\nThe numerical nature of metrics \", \"data means that it\\u2019s ideally suited to drive alerting systems, notifying\\ndevelopers or support engin\", \"eers when a value falls outside of some defined tolerance. The platforms\\nalready mentioned all provi\", \"de support for alerting via a range of options, including emails, text\\nmessages, or in-dashboard vis\", \"ualizations.\\nDistributed tracing\\nDistributed tracing is a relatively recent development in monitorin\", \"g, which has arisen from the\\nincreasing use of microservices and distributed architectures. A single\", \" request from a client browser,\\napplication, or device can be broken down into many steps and sub-re\", \"quests, and involve the use of\\nmany services across a network. This activity makes it difficult to c\", \"orrelate log messages and metrics\\nwith the specific request that triggered them. Distributed tracing\", \" applies identifiers to requests, and\\nallows logs and metrics to be correlated with a particular ope\", \"ration. This tracing is similar to WCF\\u2019s\\nend-to-end tracing, but it\\u2019s applied across multiple platfo\", \"rms.\\nDistributed tracing has grown quickly in popularity and is beginning to standardize. The Cloud \", \"Native\\nComputing Foundation created the Open Tracing standard, attempting to provide vendor-neutral\\n\", \"libraries for working with back ends like Jaeger and Elastic APM. At the same time, Google created t\", \"he\\nOpenCensus project to address the same set of problems. These two projects are merging into a new\", \"\\nproject, OpenTelemetry, which aims to be the industry standard of the future.\\nHow distributed traci\", \"ng works\\nDistributed tracing is based on the concept of spans: named, timed operations that are part\", \" of a single\\ntrace, which can involve processing on multiple nodes of a system. When a new operation\", \" is initiated,\\na trace is created with a unique identifier. For each sub-operation, a span is create\", \"d with its own\\n101 CHAPTER 7 | gRPC in productionidentifier and trace identifier. As the request pas\", \"ses around the system, various components can\\ncreate child spans that include the identifier of thei\", \"r parent. A span has a context, which contains the\\ntrace and span identifiers, as well as useful dat\", \"a in the form of key and value pairs (called baggage).\\nDistributed tracing with DiagnosticSource\\n.NE\", \"T has an internal module that maps well to distributed traces and spans: DiagnosticSource. As well\\na\", \"s providing a simple way to produce and consume diagnostics within a process, the\\nDiagnosticSource m\", \"odule has the concept of an activity. An activity is effectively an implementation of\\na distributed \", \"trace, or a span within a trace. The internals of the module take care of parent/child\\nactivities, i\", \"ncluding allocating identifiers. For more information about using the Activity type, see the\\nActivit\", \"y User Guide on GitHub.\\nBecause DiagnosticSource is a part of the core framework and later, it\\u2019s sup\", \"ported by several core\\ncomponents. These include HttpClient, Entity Framework Core, and ASP.NET Core\", \", including explicit\\nsupport in the gRPC framework. When ASP.NET Core receives a request, it checks \", \"for a pair of HTTP\\nheaders matching the W3C Trace Context standard. If the headers are found, an act\", \"ivity is started by\\nusing the identity values and context from the headers. If no headers are found,\", \" an activity is started\\nwith generated identity values that match the standard format. Any diagnosti\", \"cs generated by the\\nframework or by application code during the lifetime of this activity can be tag\", \"ged with the trace and\\nspan identifiers. The HttpClient support extends this functionality further b\", \"y checking for a current\\nactivity on every request, and automatically adding the trace headers to th\", \"e outgoing request.\\nThe ASP.NET Core gRPC client and server libraries include explicit support for D\", \"iagnosticSource and\\nActivity, and create activities and apply and use header information automatical\", \"ly.\\nNote\\nAll of this happens only if a listener is consuming the diagnostic information. If there\\u2019s \", \"no listener, no\\ndiagnostics are written and no activities are created.\\nAdd your own DiagnosticSource\", \" and Activity\\nTo add your own diagnostics or create explicit spans within your application code, see\", \" the\\nDiagnosticSource User Guide and Activity User Guide.\\nStore distributed trace data\\nAt the time o\", \"f writing, the OpenTelemetry project is still in the early stages, and only alpha-quality\\npackages a\", \"re available for .NET applications. The OpenTracing project currently offers more mature\\nlibraries.\\n\", \"The OpenTracing API is described in the following section. If you want to use the OpenTelemetry API\\n\", \"in your application instead, refer to the OpenTelemetry .NET SDK repository on GitHub.\\nUse the OpenT\", \"racing package to store distributed trace data\\nThe OpenTracing NuGet package supports all OpenTracin\", \"g-compliant back ends (which can be used\\nindependently of DiagnosticSource). There\\u2019s an additional p\", \"ackage from the OpenTracing API\\n102 CHAPTER 7 | gRPC in productionContributions project, OpenTracing\", \".Contrib.NetCore. This package adds a DiagnosticSource listener,\\nand writes events and activities to\", \" a back end automatically. Enabling this package is as simple as\\ninstalling it from NuGet and adding\", \" it as a service in your Program class.\\n//\\nbuilder.Services.AddOpenTracing();\\n//\\nThe OpenTracing pac\", \"kage is an abstraction layer, and as such it requires implementation specific to\\nthe back end. OpenT\", \"racing API implementations are available for the following open source back\\nends.\\nName Package Websi\", \"te\\nJaeger Jaeger jaegertracing.io\\nElastic APM Elastic.Apm.NetCoreAll elastic.co/products/apm\\nFor mor\", \"e information on the OpenTracing API for .NET, see the OpenTracing for C# and the\\nOpenTracing Contri\", \"b C#/.NET Core repositories on GitHub.\\n103 CHAPTER 7 | gRPC in production8\\nCHAPTER\\nAppendix A - Tran\", \"sactions\\nWindows Communication Foundation (WCF) supports distributed transactions, allowing you to\\np\", \"erform atomic operations across multiple services. This functionality is based on the Microsoft\\nDist\", \"ributed Transaction Coordinator.\\nIn the newer microservices landscape, this type of automated distri\", \"buted transaction processing isn\\u2019t\\npossible. There are too many different technologies involved, inc\", \"luding relational databases, NoSQL\\ndata stores, and messaging systems. There might also be a mix of \", \"operating systems, programming\\nlanguages, and frameworks in use in a single environment.\\nWCF distrib\", \"uted transaction is an implementation of what is known as a two-phase commit (2PC). You\\ncan implemen\", \"t 2PC transactions manually by coordinating messages across services, creating open\\ntransactions wit\", \"hin each service, and sending commit or rollback messages, depending upon success\\nor failure. Howeve\", \"r, the complexity involved in managing 2PC can increase exponentially as systems\\nevolve. Open transa\", \"ctions hold database locks that can negatively affect performance, or, worse, cause\\ncross-service de\", \"adlocks.\\nIf possible, it\\u2019s best to avoid distributed transactions altogether. If two items of data a\", \"re so linked as to\\nrequire atomic updates, consider handling them both with the same service. Apply \", \"those atomic\\nchanges by using a single request or message to that service.\\nIf that isn\\u2019t possible, t\", \"hen one alternative is to use the Saga pattern. In a saga, updates are processed\\nsequentially; as ea\", \"ch update succeeds, the next one is triggered. These triggers can be propagated\\nfrom service to serv\", \"ice, or managed by a saga coordinator or orchestrator. If an update fails at any\\npoint during the pr\", \"ocess, the services that have already completed their updates apply specific logic\\nto reverse them.\\n\", \"Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility\\nSegregation (CQ\", \"RS), as described in the .NET Microservices e-book. In particular, using domain events\\nor event sour\", \"cing can help to ensure that updates are consistently, if not immediately, applied.\\n104 CHAPTER 8 | \", \"Appendix A - Transactions\"]"