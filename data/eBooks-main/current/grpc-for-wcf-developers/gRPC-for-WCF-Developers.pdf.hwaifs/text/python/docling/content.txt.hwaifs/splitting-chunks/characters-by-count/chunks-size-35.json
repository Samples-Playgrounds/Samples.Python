"[\"Mark Rendle Miranda Steiner\\n\\nEDITION v7.0 - Updated to ASP.NET Core 7.0\\n\\nRefer changelog for the boo\", \"k updates and community contributions.\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Visual\", \" Studio product teams\\n\\nA division of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington 9\", \"8052-6399\\n\\nCopyright \\u00a9 2023 by Microsoft Corporation\\n\\nAll rights reserved. No part of the contents o\", \"f this book may be reproduced or transmitted in any form or by any means without the written permiss\", \"ion of the publisher.\\n\\nThis book is provided 'as -is' and expresses the author's views and opinions.\", \" The views, opinions and information expressed in this book, including URL and other Internet websit\", \"e references, may change without notice.\\n\\nSome examples depicted herein are provided for illustratio\", \"n only and are fictitious. No real association or connection is intended or should be inferred.\\n\\nMic\", \"rosoft and the trademarks listed at https://www.microsoft.com on the 'Trademarks' webpage are tradem\", \"arks of the Microsoft group of companies.\\n\\nThe Docker whale logo is a registered trademark of Docker\", \", Inc. Used by permission.\\n\\nAll other marks and logos are property of their respective owners.\\n\\nAuth\", \"ors:\\n\\nMark Rendle - Chief Technical Officer - Visual Recode\\n\\nMiranda Steiner - Technical Author\\n\\nEdi\", \"tor:\\n\\nMaira Wenzel - Sr. Content Developer - Microsoft\\n\\n## Introduction\\n\\ngRPC is a modern framework \", \"for building networked services and distributed applications. Imagine the performance of Windows Com\", \"munication Foundation (WCF) NetTCP bindings, combined with the cross-platform interoperability of SO\", \"AP. gRPC builds on HTTP/2 and the Protobuf message-encoding protocol to provide high performance, lo\", \"w-bandwidth communication between applications and services. It supports server and client code gene\", \"ration across most popular programming languages and platforms, including .NET, Java, Python, Node.j\", \"s, Go, and C++. With the first-class support for gRPC in ASP.NET Core 7.0, alongside the existing gR\", \"PC tools and libraries for .NET Framework 4.x, it's an excellent alternative to WCF for development \", \"teams looking to adopt .NET in their organizations.\\n\\n## Who should use this guide\\n\\nThis guide was wr\", \"itten for developers working in .NET Framework or .NET who have previously used WCF, and who are see\", \"king to migrate their applications to a modern RPC environment for .NET Core 3.0 and later versions.\", \" More generally, if you are upgrading, or considering upgrading, to .NET 7, and you want to use the \", \"built-in gRPC tools, this guide is also useful.\\n\\n## How you can use this guide\\n\\nThis is a short intr\", \"oduction to building gRPC Services in ASP.NET Core 7.0, with particular reference to WCF as an analo\", \"gous platform. It explains the principles of gRPC, relating each concept to the equivalent features \", \"of WCF, and offers guidance for migrating an existing WCF application to gRPC. It's also useful for \", \"developers who have experience with WCF and are looking to learn gRPC to build new services. You can\", \" use the sample applications as a template or reference for your own projects, and you are free to c\", \"opy and reuse code from the book or its samples.\\n\\nFeel free to forward this guide to your team to he\", \"lp ensure a common understanding of these considerations and opportunities. Having everybody working\", \" from a common set of terms and underlying principles helps ensure consistent application of archite\", \"ctural patterns and practices.\\n\\n## References\\n\\n- gRPC website https://grpc.io\\n- Choosing between .NE\", \"T 5 and .NET Framework for server apps https://learn.microsoft.com/dotnet/standard/choosing-core-fra\", \"mework-server\\n\\n## Contents\\n\\n| Introduction to gRPC for WCF developers ..............................\", \"............................................. 1                                                     \", \"                         |\\n|------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"------------------------|\\n| History.................................................................\", \"....................................................................................................\", \".....................1 |\\n| Microservices............................................................\", \"....................................................................................................\", \".............2        |\\n| About this guide..........................................................\", \"....................................................................................................\", \".........3           |\\n| Who this guide is for .....................................................\", \"....................................................................................................\", \".....3              |\\n| gRPC overview...............................................................\", \".......................................................... 4                                        \", \"                   |\\n| Key principles ..............................................................\", \"....................................................................................................\", \"..........4       |\\n| How gRPC approaches RPC.......................................................\", \"..........................................................................................5         \", \"                 |\\n| Interface Definition Language..................................................\", \"..........................................................................................6         \", \"                |\\n| Network protocols...............................................................\", \"....................................................................................................\", \"7              |\\n| Key features of HTTP/2...........................................................\", \"..........................................................................................7         \", \"              |\\n| Why we recommend gRPC for WCF developers..........................................\", \"...............................................................8                                    \", \"             |\\n| Similarity to WCF..................................................................\", \"...............................................................................................8    \", \"            |\\n| Benefits of gRPC....................................................................\", \"..............................................................................................8     \", \"           |\\n| Comparison with CoreWCF..............................................................\", \"...............................................................................9                    \", \"          |\\n| buffers...............................................................................\", \"......................................                                                              \", \"         |\\n| Protocol 11                                                                            \", \"                                                                                                    \", \"        |\\n| How Protobuf works......................................................................\", \"...................................................................................... 11           \", \"       |\\n| Declaring a message......................................................................\", \".................................................................................11                 \", \"      |\\n| Field numbers.............................................................................\", \".......................................................................................12           \", \"     |\\n| Types......................................................................................\", \"...............................................................................................13   \", \"    |\\n| The generated code..........................................................................\", \"..............................................................................13                    \", \"   |\\n| Protobuf scalar data types ..................................................................\", \".............................................................................. 13                   \", \"  |\\n| Other .NET primitive types ...................................................................\", \"........................................................................14                          \", \" |\\n| Decimals.......................................................................................\", \"........................................................................................16          \", \"|\\n| Protobuf nested types ..........................................................................\", \".............................................................................. 17                  |\", \"\\n| Repeated fields for lists and arrays.............................................................\", \"................................................................... 18                            |\\n\", \"\\n| Protobuf Any and Oneof fields for variant types .................................................\", \"....................................................                                          | 19  \", \" |\\n|------------------------------------------------------------------------------------------------\", \"------------------------------------------------------------------------------------------------|---\", \"---|\\n| Any..........................................................................................\", \"...............................................................................................19 | \", \"     |\\n| Oneof......................................................................................\", \"..............................................................................................20    \", \"|      |\\n| Protobuf enumerations ...................................................................\", \"...................................................................................                 \", \"  | 21   |\\n| Protobuf maps for dictionaries.........................................................\", \"...............................................................................                     \", \"    | 22   |\\n| Using MapField properties in code....................................................\", \".......................................................................22                           \", \"      |      |\\n| Further reading ...................................................................\", \"..............................................................................................23    \", \"        |      |\\n| Comparing WCF to gRPC............................................................\", \"..........................................                                                          \", \"          | 24   |\\n| gRPC example...................................................................\", \"....................................................................................................\", \".           | 24   |\\n| WCF endpoints and gRPC methods...............................................\", \"...............................................................................                     \", \"              | 25   |\\n| OperationContract properties...............................................\", \"......................................................................................25            \", \"                |      |\\n| WCF bindings and transports .............................................\", \".............................................................................................       \", \"                  | 26   |\\n| NetTCP.................................................................\", \"....................................................................................................\", \".............26     |      |\\n| HTTP.................................................................\", \"....................................................................................................\", \".................27   |      |\\n| Named pipes........................................................\", \"....................................................................................................\", \"..........27            |      |\\n| MSMQ.............................................................\", \"....................................................................................................\", \"..................27      |      |\\n| WebHttpBinding.................................................\", \"....................................................................................................\", \"..........27                |      |\\n| Types of RPC.................................................\", \"....................................................................................................\", \"......................        | 27   |\\n| Request/reply..............................................\", \"....................................................................................................\", \"...................28           |      |\\n| WCF duplex, one way to client ...........................\", \"....................................................................................................\", \"....28                            |      |\\n| WCF one-way operations and gRPC client streaming ......\", \"................................................................................30                  \", \"                                    |      |\\n| WCF full-duplex services ............................\", \"....................................................................................................\", \"...............31                     |      |\\n| Metadata...........................................\", \"....................................................................................................\", \"...................................     | 32   |\\n| Error handling...................................\", \"....................................................................................................\", \"..................................        | 33   |\\n| Raise errors in ASP.NET Core gRPC .............\", \"....................................................................................................\", \".........34                                 |      |\\n| Catch errors in gRPC clients.................\", \"....................................................................................................\", \"....................34                        |      |\\n| gRPC richer error model....................\", \"....................................................................................................\", \"........................35                      |      |\\n| WS-* protocols...........................\", \"....................................................................................................\", \"........................................          | 35   |\\n| Metadata exchange: WS-Policy, WS-Discov\", \"ery, and so on.............................................................................35       \", \"                                                    |      |\\n| Security: WS-Security, WS-Federation,\", \" XML Encryption, and so on............................................................35            \", \"                                                      |      |\\n| WS-ReliableMessaging...............\", \"....................................................................................................\", \"...............................36                       |      |\\n| WS-Transaction, WS-Coordination..\", \"....................................................................................................\", \".....................36                                   |      |\\n\\n| Migrate a WCF solution to gRPC\", \".........................................................................................           \", \"                                                      | 37   |\\n|------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"-------------------------------------------------|------|\\n| Create a new ASP.NET Core gRPC project..\", \"....................................................................................................\", \"............                                | 37   |\\n| Create the project by using Visual Studio....\", \"....................................................................................................\", \"......37                               |      |\\n| Create the project by using the .NET CLI..........\", \"....................................................................................................\", \"..40                              |      |\\n| Clean up the example code .............................\", \"....................................................................................................\", \"........41                   |      |\\n| Migrate a WCF request-reply service to a gRPC unary RPC.....\", \"...........................................................................                         \", \"                        | 42   |\\n| The WCF solution.................................................\", \"....................................................................................................\", \"........42         |      |\\n| The portfolios.proto file.............................................\", \"....................................................................................................\", \"44            |      |\\n| Convert the DataContract classes to gRPC messages..........................\", \".............................................................44                                     \", \"         |      |\\n| Convert ServiceContract to a gRPC service ......................................\", \".....................................................................45                             \", \"    |      |\\n| Migrate the PortfolioData library to .NET............................................\", \"...................................................................46                              |\", \"      |\\n| Use ASP.NET Core dependency injection.....................................................\", \"..........................................................47                                  |     \", \" |\\n| Implement the gRPC service.....................................................................\", \"...................................................................48                    |      |\\n| \", \"Generate client code................................................................................\", \".......................................................................50           |      |\\n| Migra\", \"te WCF duplex services to gRPC......................................................................\", \"...................................................                            | 53   |\\n| Server str\", \"eaming RPC..........................................................................................\", \"...........................................................53             |      |\\n| Bidirectional s\", \"treaming............................................................................................\", \"......................................................58             |      |\\n| gRPC streaming servi\", \"ces vs. repeated fields.............................................................................\", \".................................                               | 63   |\\n| When to use repeated fiel\", \"ds..................................................................................................\", \"......................................63                   |      |\\n| When to use stream methods....\", \"....................................................................................................\", \".............................64                       |      |\\n| Create gRPC client libraries.......\", \"....................................................................................................\", \"....................................             | 64   |\\n| Useful extensions ......................\", \"....................................................................................................\", \"...................................65       |      |\\n| Summary......................................\", \"....................................................................................................\", \"....................................67 |      |\\n| Security in gRPC applications ....................\", \"..........................................................................                          \", \"                                  | 68   |\\n| WCF authentication and authorization ..................\", \"....................................................................................................\", \"..                           | 68   |\\n| gRPC authentication and authorization.......................\", \"................................................................................................    \", \"                        | 68   |\\n| Call credentials.................................................\", \"....................................................................................................\", \".................. | 69   |\\n| WS-Federation ........................................................\", \"....................................................................................................\", \"......69      |      |\\n| JWT Bearer tokens .........................................................\", \"..................................................................................................69\", \"         |      |\\n| Add authentication and authorization to the server..............................\", \"............................................................70                                      \", \"    |      |\\n| Provide call credentials in the client application ..................................\", \"...............................................................71                                  |\", \"      |\\n| Channel credentials.......................................................................\", \".......................................................................................       | 72  \", \" |\\n\\n| Add certificate authentication to the                                                         \", \"                                                                                            | server\", \"....................................................................................................\", \"......72   |\\n|--------------------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"-|--------------------------------------------------------------------------------------------------\", \"--------------------|\\n| Provide channel credentials in the client application.......................\", \".................................................................73                                 \", \"          |                                                                                         \", \"                             |\\n| Combine ChannelCredentials and CallCredentials ....................\", \".........................................................................74                         \", \"                   |                                                                                \", \"                                      |\\n| Encryption and network security ..........................\", \"....................................................................................................\", \"......                      | 75                                                                    \", \"                                               |\\n| gRPC in production...............................\", \"................................................................................                    \", \"                                     | 77                                                           \", \"                                                        |\\n| Self-hosted gRPC applications ..........\", \"....................................................................................................\", \"..........................                    | 77                                                  \", \"                                                                 |\\n| Run your app as a Windows servi\", \"ce..................................................................................................\", \".......................77                              |                                            \", \"                                                                          |\\n| Run your app as a Linu\", \"x service with systemd..............................................................................\", \".......................78                                       |                                   \", \"                                                                                   |\\n| HTTPS certifi\", \"cates for self-hosted applications..................................................................\", \"..................................80                                     |                          \", \"                                                                                            |\\n| Crea\", \"te Docker images....................................................................................\", \".....................................................................             | 81              \", \"                                                                                                    \", \" |\\n| Microsoft base images for ASP.NET Core applications............................................\", \".........................................81                                                |        \", \"                                                                                                    \", \"          |\\n| Create a Docker image ................................................................\", \"..................................................................................82                \", \"|                                                                                                   \", \"                   |\\n| Build the image..............................................................\", \"...................................................................................................8\", \"4        |                                                                                          \", \"                            |\\n| Run the image in a container on your machine .......................\", \"...........................................................................84                       \", \"                  |                                                                                 \", \"                                     |\\n| Push the image to a registry...............................\", \"....................................................................................................\", \".....84                    |                                                                        \", \"                                              |\\n| Kubernetes........................................\", \"....................................................................................................\", \"................................... | 85                                                            \", \"                                                       |\\n| Kubernetes terminology...................\", \"....................................................................................................\", \".........................85                  |                                                      \", \"                                                                |\\n| Get started with Kubernetes.....\", \"....................................................................................................\", \"...............................86                     |                                             \", \"                                                                         |\\n| Run services on Kuberne\", \"tes.................................................................................................\", \"........................................87                     |                                    \", \"                                                                                  |\\n| Service meshes\", \"....................................................................................................\", \"...................................................................     | 93                        \", \"                                                                                           |\\n| Servi\", \"ce mesh options.....................................................................................\", \".................................................................94              |                  \", \"                                                                                                    \", \"|\\n| Example: Add Linkerd to a deployment............................................................\", \"......................................................94                                  |         \", \"                                                                                                    \", \"         |\\n| Load balancing gRPC ...................................................................\", \".......................................................................................            |\", \" 97                                                                                                 \", \"                  |\\n| L4 load balancers ............................................................\", \".................................................................................................97 \", \"        |                                                                                           \", \"                           |\\n| L7 load balancers ...................................................\", \"....................................................................................................\", \"......97         |                                                                                  \", \"                                    |\\n| Load balancing within Kubernetes............................\", \"................................................................................................98  \", \"                          |                                                                         \", \"                                             |\\n| Application Performance Management.................\", \"....................................................................................................\", \"..                                 | 98                                                             \", \"                                                      |\\n| The difference between logging and metrics\", \"....................................................................................................\", \"...98                                       |                                                       \", \"                                                               |\\n| Logging in ASP.NET Core gRPC ....\", \"....................................................................................................\", \".........................98                          |                                              \", \"                                                                        |\\n| Metrics in ASP.NET Core \", \"gRPC................................................................................................\", \"...................................99                         |                                     \", \"                                                                                 |\\n| Distributed tra\", \"cing................................................................................................\", \".........................................................101           |                            \", \"                                                                                          |\\n| Append\", \"ix A - Transactions ................................................................................\", \".................104                                                            |                   \", \"                                                                                                   |\", \"\\n\\n## Introduction to gRPC for WCF developers\\n\\nHelping machines communicate with each other has been \", \"one of the primary preoccupations of the digital age. In particular, there's an ongoing effort to de\", \"termine the optimal remote communication mechanism that will suit the interoperability demands of th\", \"e current infrastructure. As you can imagine, that mechanism changes as either the demands or the in\", \"frastructure evolves.\\n\\nThe release of .NET Core 3.0 marks a shift in the way that Microsoft delivers\", \" remote communication solutions to developers who want to deliver services across a range of platfor\", \"ms. .NET Core and later doesn't offer Windows Communication Foundation (WCF) ou t of the box but, wi\", \"th the release of ASP.NET Core 3.0, it does provide built-in gRPC functionality.\\n\\ngRPC is a popular \", \"framework in the wider software community. It's used by developers across many programming languages\", \" for modern RPC scenarios. The community and the ecosystem are vibrant and active. Support for the g\", \"RPC protocol is being added to infrastructure components like Kubernetes, service meshes, load balan\", \"cers, and more. These factors, together with its performance, efficiency, and cross-platform compati\", \"bility, make gRPC a natural choice for new apps and WCF apps moving to .NET.\\n\\n## History\\n\\nThe fundam\", \"ental principle of a computer network as nothing more than a group of computers exchanging data with\", \" each other to achieve a set of interrelated tasks hasn't changed since its inception. But the compl\", \"exity, scale, and expectations have grown exponentially.\\n\\nDuring the 1990s, the emphasis was mainly \", \"on improving internal networks that used the same language and platforms. TCP/IP became the gold sta\", \"ndard for this type of communication.\\n\\nThe focus soon shifted to how best to optimize communication \", \"across multiple platforms by promoting a language-agnostic approach. Service-oriented architecture (\", \"SOA) provided a structure for loosely coupling a broad collection of services that could be provided\", \" to an application.\\n\\nThe development of web services occurred when all major platforms could access \", \"the internet, but they still couldn't interact with each other. Web services have open standards and\", \" protocols, including:\\n\\n- XML to tag and code data.\\n\\n- Simple Object Access Protocol (SOAP) to trans\", \"fer data.\\n- Web Services Definition Language (WSDL) to describe and connect web services to client a\", \"pplications.\\n- Universal Description, Discovery, and Integration (UDDI) to make web services discove\", \"rable by other services.\\n\\nSOAP defines the rules by which distributed elements of an application can\", \" communicate with each other, even if they're on different platforms. SOAP is based on XML, so it's \", \"human -readable. The sacrifice for making SOAP easily understood is size; SOAP messages are larger t\", \"han messages in comparable protocols. SOAP was designed to break monolithic applications into multic\", \"omponent form without losing security or control. So WCF was designed to work with that kind of syst\", \"em, unlike gRPC, which began as a distributed system. WCF addressed some of these limitations by dev\", \"eloping and documenting proprietary extension protocols for the SOAP stack, but at the cost of a lac\", \"k of support from other platforms.\\n\\nWindows Communication Foundation is a framework for building ser\", \"vices. It was designed in the early 2000s to help developers using early SOA to manage the complexit\", \"ies of working with SOAP. Although it removes the requirement for the developers to write their own \", \"SOAP protocols, WCF still uses SOAP to enable interoperability with other systems. WCF was also desi\", \"gned to deliver solutions across multiple protocols (HTTP/1.1, Net.TCP, and so on).\\n\\n## Microservice\", \"s\\n\\nIn microservice architectures, large applications are built as a collection of smaller modular se\", \"rvices. Each component does a specific task or process, and components are designed to work interope\", \"rably but can be isolated as necessary.\\n\\nAdvantages to microservices include:\\n\\n- Changes and upgrade\", \"s can be handled independently.\\n- Error handling becomes more efficient because problems can be trac\", \"ed to specific services that are then isolated, rebuilt, tested, and redeployed independently of the\", \" other services.\\n- Scalability can be confined to specific instances or services rather than the who\", \"le application.\\n- Development can happen across multiple teams, with less friction than occurs when \", \"many teams work on a single codebase.\\n\\nThe move towards increasing virtualization, cloud computing, \", \"containers, and the Internet of Things has contributed to the ongoing rise of microservices. But mic\", \"roservices aren't without their challenges. The fragmented/decentralized infrastructure put more emp\", \"hasis on the need for simplicity and speed when communicating between services. This in turn drew at\", \"tention to the sometimes laborious and contorted nature of SOAP.\\n\\nIt was into this environment that \", \"gRPC was launched, 10 years after Microsoft first released WCF. Evolved directly from Google's inter\", \"nal infrastructure RPC (Stubby), gRPC was never based on the same standards and protocols that had i\", \"nformed the parameters of many earlier RPCs. And gRPC was only ever based on HTTP/2. That's why it c\", \"ould draw on the new capabilities that advanced transport protocol provided. In particular, bidirect\", \"ional streaming, binary messaging, and multiplexing.\\n\\n## About this guide\\n\\nThis guide covers the key\", \" features of gRPC. The early chapters take a high-level look at the main features of WCF and compare\", \" them to those of gRPC. It identifies where there are direct correlations between WCF and gRPC and a\", \"lso where gRPC offers an advant age. When there's no correlation between WCF and gRPC, or when gRPC \", \"isn't able to offer an equivalent solution to WCF, this guide will suggest workarounds or where to g\", \"o for more information.\\n\\nUsing a set of sample WCF applications, Chapter 5 is a deep-dive look at co\", \"nverting the main types of WCF service (simple request-reply, one-way, and streaming) to their equiv\", \"alents in gRPC.\\n\\nThe final section of the book looks at how to get the best from gRPC in practice. T\", \"his section includes information on using additional tools, like Docker containers or Kubernetes, to\", \" take advantage of the efficiency of gRPC. It also includes a detailed look at monitoring with loggi\", \"ng, metrics, and distributed tracing.\\n\\n## Who this guide is for\\n\\nThis guide was written for develope\", \"rs working in .NET Framework or .NET Core who have used WCF and who are seeking to migrate their app\", \"lications to a modern RPC environment for .NET Core 3.0 and later versions. The guide might also be \", \"useful more generally for developers upgrading or considering upgrading to .NET and who want to use \", \"the built-in gRPC tools.\\n\\n## gRPC overview\\n\\nAfter looking at the genesis of both Windows Communicati\", \"on Foundation (WCF) and gRPC in the last chapter, this chapter considers some of the key features of\", \" gRPC and how they compare to WCF.\\n\\nASP.NET Core 3.0 is the first release of ASP.NET that natively s\", \"upports gRPC as a first-class citizen, with Microsoft teams contributing to the official .NET implem\", \"entation of gRPC. It's recommended for building distributed applications with .NET that can interope\", \"rate with all other major programming languages and frameworks.\\n\\n## Key principles\\n\\nAs discussed in \", \"chapter 1, Google wanted to use the introduction of HTTP/2 to replace Stubby, its internal, general \", \"purpose RPC infrastructure. gRPC, based on Stubby, now can take advantage of standardization and wou\", \"ld extend its applicability to mobile computing, the cloud, and the Internet of Things.\\n\\nTo achieve \", \"this standardization, the Cloud Native Computing Foundation (CNCF) established a set of principles t\", \"hat would govern gRPC. The following list shows the most relevant ones, which are primarily concerne\", \"d with maximizing accessibility and usability:\\n\\n- Free and open -All artifacts should be open source\", \", with licensing that doesn't constrain developers from adopting gRPC.\\n- Coverage and simplicity -gR\", \"PC should be available across every popular platform, and simple enough to build on any platform.\\n- \", \"Interoperability and reach -It should be possible to use gRPC on any network, regardless of bandwidt\", \"h or latency, by using widely available network standards.\\n- General purpose and performant -The fra\", \"mework should be usable by as broad a range of use-cases as possible, without compromising performan\", \"ce.\\n- Streaming -The protocol should provide streaming semantics for large datasets or asynchronous \", \"messaging.\\n- Metadata exchange -The protocol allows non-business data, such as authentication tokens\", \", to be handled separately from actual business data.\\n- Standardized status codes -The variability o\", \"f error codes should be reduced to make error handling decisions clearer. Where additional, richer e\", \"rror handling is required, a mechanism should be provided for managing behavior within the metadata \", \"exchange.\\n\\n## How gRPC approaches RPC\\n\\nWindows Communication Foundation (WCF) and gRPC are both impl\", \"ementations of the Remote Procedure Call (RPC) pattern. This pattern aims to make calls to services \", \"that run on a different machine, or in a different process, work seamlessly, like method calls in th\", \"e client application. While the aims of WCF and gRPC are the same, the details of the implementation\", \" are quite different.\\n\\nThe following table sets out how the key features of WCF relate to gRPC, and \", \"where you can find more detailed explanations.\\n\\n| Features                                    | WCF \", \"                                                                | gRPC                              \", \"                                                                                                    \", \"                |\\n|---------------------------------------------|-----------------------------------\", \"----------------------------------|-----------------------------------------------------------------\", \"--------------------------------------------------------------------------------------|\\n| Objective \", \"                                  | Separate business code from networking implementation.          \", \"    | Separate business code from interface definition and networking implementation.               \", \"                                                        |\\n| Define services and messages (chapters 3\", \"-4) | Service Contract, Operation Contract, and Data Contract.            | Uses proto file to decla\", \"re services and messages.                                                                           \", \"                          |\\n| Language (chapters 3-5)                     | Contracts written in C# \", \"or Visual Basic.                            | Protocol Buffer language.                             \", \"                                                                                                |\\n| \", \"Wire format (chapter 3)                     | Configurable, including SOAP/XML, Plain XML, JSON, and\", \" .NET Binary. | Protocol Buffer binary format (although it's possible to use other formats).        \", \"                                                                  |\\n| Interoperability (chapter 4)  \", \"              | When using SOAP over HTTP.                                          | Official suppo\", \"rt: .NET, Java, Python, JavaScript, C/C++, Go, Rust, Ruby, Swift, Dart, PHP. Unofficial support for \", \"other languages from the community. |\\n| Networking (chapter 4)                      | Configured at \", \"run time. Switch between NetTCP, HTTP, and MSMQ.      | HTTP/2, currently over TCP only with ASP.NET\", \" Core gRPC.                                                                                         \", \"      |\\n\\n| Features             | WCF                                                               \", \"                         | gRPC                                                                     \", \"                     |\\n|----------------------|-----------------------------------------------------\", \"---------------------------------------|------------------------------------------------------------\", \"-----------------------------------|\\n| Approach (chapter 4) | Runtime generation of serialization, d\", \"eserialization, and networking code in base classes. | Build-time generation of serialization, deser\", \"ialization, and networking code in base classes. |\\n| Security (chapter 6) | Authentication, WS-Secur\", \"ity, message encryption.                                           | Credentials, ASP.NET Core secur\", \"ity, TLS networking.                                           |\\n\\n## Interface Definition Language\\n\\n\", \"With Windows Communication Foundation (WCF), services can expose description metadata by using the W\", \"eb Service Definition Language (WSDL). WSDL is generated dynamically by using .NET reflection at run\", \" time. Developers can use this metadata to generate clients for those services, potentially in other\", \" languages if they're using a platform -neutral binding such as SOAP over HTTP.\\n\\ngRPC uses the Inter\", \"face Definition Language (IDL) from Protocol Buffers. The Protocol Buffers IDL is a custom, platform\", \"-neutral language with an open specification. Developers author .proto files to describe services, a\", \"long with their inputs and outputs. These .proto files can then be used to generate language- or pla\", \"tform-specific stubs for clients and servers, allowing multiple different platforms to communicate. \", \"By sharing .proto files, teams can generate code to use each others' services, without needing to ta\", \"ke a code dependency.\\n\\nOne of the advantages of the Protobuf IDL is that as a custom language, it en\", \"ables gRPC to be completely language and platform agnostic, not favoring any technology over another\", \".\\n\\nThe Protobuf IDL is also designed for humans to both read and write, whereas WSDL is intended as \", \"a machine-readable/writable format. Changing the WSDL of a WCF service typically requires changing t\", \"he service, running the service, and regenerating the WSDL file from the server. By contrast, with a\", \" .proto file, changes are simple to apply with a text editor, and automatically flow through the gen\", \"erated code. Visual Studio 2022 builds .proto files in the background when they are saved. With othe\", \"r editors, such as VS Code, the changes are applied when the project is built.\\n\\nWhen compared with X\", \"ML, and particularly SOAP, messages encoded by using Protobuf have many advantages. Protobuf message\", \"s tend to be smaller than the same data serialized as SOAP XML, and encoding, decoding, and transmit\", \"ting them over a network can be faster.\\n\\nThe potential disadvantage of Protobuf compared to SOAP is \", \"that, because the messages aren't readable by humans, additional tooling is required to debug messag\", \"e content.\\n\\n## Tip\\n\\ngRPC does support server reflection for dynamically accessing services without p\", \"re-compiled stubs, although it's intended more for general -purpose tools than application-specific \", \"clients. For more information, see GRPC Server Reflection Protocol on GitHub.\\n\\n## Note\\n\\nWCF's binary\", \" format, used with the NetTCP binding, is much closer to Protobuf in terms of compactness and perfor\", \"mance. But NetTCP is only usable between .NET clients and servers, whereas Protobuf is a cross-platf\", \"orm solution.\\n\\n## Network protocols\\n\\nUnlike Windows Communication Foundation (WCF), gRPC uses HTTP/2\", \" as a base for its networking. This protocol offers significant advantages over WCF and SOAP, which \", \"operate only on HTTP/1.1. For developers wanting to use gRPC, given that there's no alternative to H\", \"TTP/2, it would seem to be the ideal moment to explore HTTP/2 in more detail and identify additional\", \" benefits of using gRPC.\\n\\nHTTP/2, released by Internet Engineering Task Force in 2015, was derived f\", \"rom the experimental SPDY protocol, which was already being used by Google. It was specifically desi\", \"gned to be more efficient, faster, and more secure than HTTP/1.1.\\n\\n## Key features of HTTP/2\\n\\nThis l\", \"ist shows some of the key features and advantages of HTTP/2:\\n\\n## Binary protocol\\n\\nRequest/response c\", \"ycles no longer need text commands. This activity simplifies and speeds up the implementation of com\", \"mands. Specifically, parsing data is faster and uses less memory, network latency is reduced with ob\", \"vious related improvements to speed, and there's an overall better use of network resources.\\n\\n## Str\", \"eams\\n\\nStreams allow you to create long-lived connections between sender and receiver, over which mul\", \"tiple messages or frames can be sent asynchronously. Multiple streams can operate independently over\", \" a single HTTP/2 connection.\\n\\n## Request multiplexing over a single TCP connection\\n\\nThis feature is \", \"one of the most important innovations of HTTP/2. Because it allows multiple parallel requests for da\", \"ta, it's now possible to download web files concurrently from a single server. Websites load faster,\", \" and the need for optimization is reduced. Head-of-line (HOL) blocking, where responses\\n\\nthat are re\", \"ady must wait to be sent until an earlier request is completed, is also mitigated (although HOL bloc\", \"king can still occur at the TCP-transport level).\\n\\n## Net.TCP-like performance, cross-platform\\n\\nFund\", \"amentally, the combination of gRPC and HTTP/2 offers developers at least the equivalent speed and ef\", \"ficiency of Net.TCP bindings for WCF, and in some cases even greater speed and efficiency. But, unli\", \"ke Net.TCP, gRPC over HTTP/2 isn't constrained to .N ET applications.\\n\\n## Why we recommend gRPC for \", \"WCF developers\\n\\nBefore we dive deeply into the language and techniques of gRPC, it's worth discussin\", \"g why gRPC is the right solution for Windows Communication Foundation (WCF) developers who want to m\", \"igrate to .NET.\\n\\n## Similarity to WCF\\n\\nAlthough the implementation and approach are different for gR\", \"PC, the experience of developing and consuming services with gRPC should be intuitive for WCF develo\", \"pers. The underlying goal is the same: make it possible to code as though the client and server are \", \"on the same platform, without needing to worry about networking.\\n\\nBoth platforms share the principle\", \" of declaring and then implementing an interface, even though the process for declaring that interfa\", \"ce is different. And as you'll see in chapter 5, the different types of RPC calls that gRPC supports\", \" map well to the bindings available to WCF services.\\n\\n## Benefits of gRPC\\n\\ngRPC stands above other s\", \"olutions for the following reasons.\\n\\n## Performance\\n\\nUsing HTTP/2 rather than HTTP/1.1 removes the r\", \"equirement for human-readable messages and instead uses the smaller, faster binary protocol. This is\", \" more efficient for computers to parse. HTTP/2 also supports multiplexing requests over a single con\", \"nection. This support enables responses to be sent as soon as they're ready without the need to wait\", \" in a queue. (In HTTP/1.1, this issue is known as 'head -ofline (HOL) blocking.') You need fewer res\", \"ources when using gRPC, which makes it a good solution to use for mobile devices and over slower net\", \"works.\\n\\n## Interoperability\\n\\nThere are gRPC tools and libraries for all major programming languages \", \"and platforms, including .NET, Java, Python, Go, C++, Node.js, Swift, Dart, Ruby, and PHP. Thanks to\", \" the Protocol Buffers binary wire format and the efficient code generation for each platform, develo\", \"pers can build performant apps while still enjoying full cross-platform support.\\n\\n## Usability and p\", \"roductivity\\n\\ngRPC is a comprehensive RPC solution. It works consistently across multiple languages a\", \"nd platforms. It also provides excellent tooling, with much of the necessary boilerplate code automa\", \"tically generated. So more developer time is freed up to focus on business logic.\\n\\n## Streaming\\n\\ngRP\", \"C has full bidirectional streaming, which provides similar functionality to WCF's full -duplex servi\", \"ces. gRPC streaming can operate over regular internet connections, load balancers, and service meshe\", \"s.\\n\\n## Deadline/timeouts and cancellation\\n\\ngRPC allows clients to specify a maximum time for an RPC \", \"to finish. If the specified deadline is exceeded, the server can cancel the operation independently \", \"of the client. Deadlines and cancellations can be propagated through further gRPC calls to help enfo\", \"rce resource usage limits. Clients can also stop operations when a deadline is exceeded, or earlier \", \"if necessary (for example, because of a user interaction).\\n\\n## Security\\n\\ngRPC is implicitly secure w\", \"hen it's using HTTP/2 over a TLS end -to-end encrypted connection. Support for client certificate au\", \"thentication (see chapter 6) further increases security and trust between client and server.\\n\\n## Com\", \"parison with CoreWCF\\n\\nA notable alternative to gRPC for replacing WCF services when migrating to .NE\", \"T is CoreWCF. Both gRPC and CoreWCF are Microsoft endorsed paths forward for WCF applications and ea\", \"ch comes with its own benefits and drawbacks.\\n\\nCoreWCF is a community-owned .NET Foundation project \", \"supported by Microsoft that implements WCF server APIs for .NET. CoreWCF is an effort to allow exist\", \"ing WCF services to work with minimal changes on .NET. Your Data Contracts for WCF are unchanged wit\", \"h CoreWCF, and it supports many of the bindings and APIs from WCF. The main differences are around t\", \"he patterns for starting WCF services, and not all configuration options are available (some configu\", \"ration must now be done in code).\\n\\nServices and interfaces can often migrate with few changes. Becau\", \"se of this, a key benefit of CoreWCF is its very high compatibility with WCF. Where changes have bee\", \"n made, they are to adapt to the programming style of modern .NET, for example hosting now through A\", \"SP.NET Core, and APIs now use the Task based async patterns usable with await rather than the older \", \"BeginXXX / EndXXX pattern.\\n\\nOn the other hand, gRPC is a modern remote communication solution with a\", \" number of features, as discussed previously. Benefits of using gRPC include better interoperability\", \" across languages, its relatively simple modern API, and a broad community ecosystem.\\n\\nWhen deciding\", \" whether to use CoreWCF or gRPC to migrate a WCF application to .NET, CoreWCF is typically a better \", \"fit if the goal is to migrate the application with minimal changes whereas gRPC may\\n\\nbe a better fit\", \" if the goal is to modernize the application while retargeting to .NET. The remainder of this guide \", \"focuses on that modernization with gRPC.\\n\\n## Protocol buffers\\n\\ngRPC services send and receive data a\", \"s Protocol Buffer (Protobuf) messages , similar to data contracts in Windows Communication Foundatio\", \"n (WCF). Protobuf is an efficient way of serializing structured data for machines to read and write,\", \" without the overhead that human-readable formats like XML or JSON incur.\\n\\nThis chapter covers how P\", \"rotobuf works, and how to define your own Protobuf messages.\\n\\n## How Protobuf works\\n\\nMost .NET objec\", \"t serialization techniques, including WCF's data contracts, work by using reflection to analyze the \", \"object structure at run time. By contrast, most Protobuf libraries require you to define the structu\", \"re up front by using a dedicated language ( Protocol Buffer Language ) in a .proto file. A compiler \", \"then uses this file to generate code for any of the supported platforms. Supported platforms include\", \" .NET, Java, C/C++, JavaScript, and many more.\\n\\nThe Protobuf compiler, protoc, is maintained by Goog\", \"le, although alternative implementations are available. The generated code is efficient and optimize\", \"d for fast serialization and deserialization of data.\\n\\nThe Protobuf wire format is a binary encoding\", \". It uses some clever tricks to minimize the number of bytes used to represent messages. Knowledge o\", \"f the binary encoding format isn't necessary to use Protobuf. But if you're interested, you can lear\", \"n more abou t it on the Protocol Buffers website.\\n\\n## Protobuf messages\\n\\nThis section covers how to \", \"declare Protocol Buffer (Protobuf) messages in .proto files. It explains the fundamental concepts of\", \" field numbers and types, and it looks at the C# code that the protoc compiler generates.\\n\\nThe rest \", \"of the chapter will look in more detail at how different types of data are represented in Protobuf.\\n\", \"\\n## Declaring a message\\n\\nIn Windows Communication Foundation (WCF), a Stock class for a stock market\", \" trading application might be defined like the following example:\\n\\n```\\nnamespace TraderSys;\\n```\\n\\n```\", \"\\n[DataContract] public class Stock { [DataMember] public int Id { get ; set ; } [DataMember] public \", \"string Symbol { get ; set ; } [DataMember] public string DisplayName { get ; set ; } [DataMember] pu\", \"blic int MarketId { get ; set ; } }\\n```\\n\\nTo implement the equivalent class in Protobuf, you must dec\", \"lare it in the .proto file. The protoc compiler will then generate the .NET class as part of the bui\", \"ld process.\\n\\n```\\nsyntax = \\\"proto3\\\"; option csharp_namespace = \\\"TraderSys\\\"; message Stock { int32 id \", \"= 1; string symbol = 2; string display_name = 3; int32 market_id = 4; }\\n```\\n\\nThe first line declares\", \" the syntax version being used. Version 3 of the language was released in 2016. It's the version tha\", \"t we recommend for gRPC services.\\n\\nThe option csharp_namespace line specifies the namespace to be us\", \"ed for the generated C# types. This option will be ignored when the .proto file is compiled for othe\", \"r languages. Protobuf files often contain language-specific options for several languages.\\n\\nThe Stoc\", \"k message definition specifies four fields. Each has a type, a name, and a field number.\\n\\n## Field n\", \"umbers\\n\\nField numbers are an important part of Protobuf. They're used to identify fields in the bina\", \"ry encoded data, which means they can't change from version to version of your service. The advantag\", \"e is that backward compatibility and forward compatibility are possible. Clients and services will i\", \"gnore field numbers that they don't know about, as long as the possibility of missing values is hand\", \"led.\\n\\nIn the binary format, the field number is combined with a type identifier. Field numbers from \", \"1 to 15 can be encoded with their type as a single byte. Numbers from 16 to 2,047 take 2 bytes. You \", \"can go higher if you need more than 2,047 fields on a message for any reason. The single-byte identi\", \"fiers for field numbers 1 to 15 offer better performance, so you should use them for the most basic,\", \" frequently used fields.\\n\\n## Types\\n\\nThe type declarations are using Protobuf's native scalar data ty\", \"pes, which are discussed in more detail in the next section . The rest of this chapter will cover Pr\", \"otobuf's built -in types and show how they relate to common .NET types.\\n\\n## Note\\n\\nProtobuf doesn't n\", \"atively support a decimal type, so double is used instead. For applications that require full decima\", \"l precision, refer to the section on decimals in the next part of this chapter.\\n\\n## The generated co\", \"de\\n\\nWhen you build your application, Protobuf creates classes for each of your messages, mapping its\", \" native types to C# types. The generated Stock type would have the following signature:\\n\\n```\\npublic \", \"class Stock { public int Id { get ; set ; } public string Symbol { get ; set ; } public string Displ\", \"ayName { get ; set ; } public int MarketId { get ; set ; } }\\n```\\n\\nThe actual code that's generated i\", \"s far more complicated than this. The reason is that each class contains all the code necessary to s\", \"erialize and deserialize itself to the binary wire format.\\n\\n## Property names\\n\\nNote that the Protobu\", \"f compiler applied PascalCase to the property names, although they were snake_case in the .proto fil\", \"e. The Protobuf style guide recommends using snake_case in your message definitions so that the code\", \" generation for other platforms produces the expected case for their conventions.\\n\\n## Protobuf scala\", \"r data types\\n\\nProtocol Buffer (Protobuf) supports a range of native scalar value types. The followin\", \"g table lists them all with their equivalent C# type:\\n\\n| Protobuf type   | C# type   | Notes   |\\n|--\", \"---------------|-----------|---------|\\n| double          | double    |         |\\n| Float           |\", \" float     |         |\\n| int32           | int       | 1       |\\n| int64           | long      | 1  \", \"     |\\n| uint32          | uint      |         |\\n| uint64          | ulong     |         |\\n\\n| Protob\", \"uf type   | C# type    | Notes   |\\n|-----------------|------------|---------|\\n| sint32          | in\", \"t        | 1       |\\n| sint64          | long       | 1       |\\n| fixed32         | uint       | 2  \", \"     |\\n| fixed64         | ulong      | 2       |\\n| sfixed32        | int        | 2       |\\n| sfixe\", \"d64        | long       | 2       |\\n| bool            | bool       |         |\\n| string          | s\", \"tring     | 3       |\\n| bytes           | ByteString | 4       |\\n\\n## Notes:\\n\\n1. The standard encodin\", \"g for int32 and int64 is inefficient when you're working with signed values. If your field is likely\", \" to contain negative numbers, use sint32 or sint64 instead. These types map to the C# int and long t\", \"ypes, respectively.\\n2. The fixed fields always use the same number of bytes no matter what the value\", \" is. This behavior makes serialization and deserialization faster for larger values.\\n3. Protobuf str\", \"ings are UTF-8 (or 7bit ASCII) encoded. The encoded length can't be greater than 232.\\n4. The Protobu\", \"f runtime provides a ByteString type that maps easily to and from C# byte[] arrays.\\n\\n## Other .NET p\", \"rimitive types\\n\\n## Dates and times\\n\\nThe native scalar types don't provide for date and time values, \", \"equivalent to C#'s DateTimeOffset, DateTime, and TimeSpan . You can specify these types by using som\", \"e of Google's 'Well Known Types' extensions. These extensions provide code generation and runtime su\", \"pport for complex field types across the supported platforms.\\n\\nThe following table shows the date an\", \"d time types:\\n\\n| C# type        | Protobuf well-known type   |\\n|----------------|-------------------\", \"---------|\\n| DateTimeOffset | google.protobuf.Timestamp  |\\n| DateTime       | google.protobuf.Timest\", \"amp  |\\n| TimeSpan       | google.protobuf.Duration   |\\n\\n```\\nsyntax = \\\"proto3\\\" import \\\"google/protobu\", \"f/duration.proto\\\"; import \\\"google/protobuf/timestamp.proto\\\"; message Meeting {\\n```\\n\\n```\\nstring subje\", \"ct = 1; google.protobuf.Timestamp time = 2; google.protobuf.Duration duration = 3; }\\n```\\n\\nThe genera\", \"ted properties in the C# class aren't the .NET date and time types. The properties use the Timestamp\", \" and Duration classes in the Google.Protobuf.WellKnownTypes namespace. These classes provide methods\", \" for converting to and from DateTimeOffset, DateTime, and TimeSpan.\\n\\n```\\n// Create Timestamp and Dur\", \"ation from .NET DateTimeOffset and TimeSpan var meeting = new Meeting { Time = Timestamp.FromDateTim\", \"eOffset(meetingTime), // also FromDateTime() Duration = Duration.FromTimeSpan(meetingLength) }; // C\", \"onvert Timestamp and Duration to .NET DateTimeOffset and TimeSpan DateTimeOffset time = meeting.Time\", \".ToDateTimeOffset(); TimeSpan? duration = meeting.Duration?.ToTimeSpan();\\n```\\n\\n## Note\\n\\nThe Timestam\", \"p type works with UTC times. DateTimeOffset values always have an offset of zero, and the DateTime.K\", \"ind property is always DateTimeKind.Utc.\\n\\n## System.Guid\\n\\nProtobuf doesn't directly support the Guid\", \" type, known as UUID on other platforms. There's no well -known type for it.\\n\\nThe best approach is t\", \"o handle Guid values as a string field, by using the standard 8-4-4-4-12 hexadecimal format (for exa\", \"mple, 45a9fda3-bd01-47a9-8460-c1cd7484b0b3). All languages and platforms can parse that format.\\n\\nDon\", \"'t use a bytes field for Guid values. Problems with endianness (Wikipedia definition) can result in \", \"erratic behavior when Protobuf is interacting with other platforms, such as Java.\\n\\n## Nullable types\", \"\\n\\nThe Protobuf code generation for C# uses the native types, such as int for int32. So the values ar\", \"e always included and can't be null.\\n\\nFor values that require explicit null, such as using int? in y\", \"our C# code, Protobuf's 'Well Known Types' include wrappers that are compiled to nullable C# types. \", \"To use them, import wrappers.proto into your .proto file, like this:\\n\\n```\\nsyntax = \\\"proto3\\\" import \\\"\", \"google/protobuf/wrappers.proto\\\"; message Person {\\n```\\n\\n```\\n... google.protobuf.Int32Value age = 5; }\", \"\\n```\\n\\nProtobuf will use the simple T? (for example, int?) for the generated message property.\\n\\nThe f\", \"ollowing table shows the complete list of wrapper types with their equivalent C# type:\\n\\n| C# type   \", \"| Well Known Type wrapper     |\\n|-----------|-----------------------------|\\n| double?   | google.pro\", \"tobuf.DoubleValue |\\n| float?    | google.protobuf.FloatValue  |\\n| int?      | google.protobuf.Int32V\", \"alue  |\\n| long?     | google.protobuf.Int64Value  |\\n| uint?     | google.protobuf.UInt32Value |\\n| ul\", \"ong?    | google.protobuf.UInt64Value |\\n\\nThe well-known types Timestamp and Duration are represented\", \" in .NET as classes. In C# 8 and beyond, you can use nullable reference types. But it's important to\", \" check for null on properties of those types when you're converting to DateTimeOffset or TimeSpan .\\n\", \"\\n## Decimals\\n\\nProtobuf doesn't natively support the .NET decimal type, just double and float. There'\", \"s an ongoing discussion in the Protobuf project about the possibility of adding a standard Decimal t\", \"ype to the wellknown types, with platform support for languages and frameworks that support it. Noth\", \"ing has been implemented yet.\\n\\nIt's possible to create a message definition to represent the decimal\", \" type that would work for safe serialization between .NET clients and servers. But developers on oth\", \"er platforms would have to understand the format being used and implement their own handling for it.\", \"\\n\\n## Creating a custom decimal type for Protobuf\\n\\nA simple implementation might be similar to the no\", \"nstandard Money type that some Google APIs use, without the currency field.\\n\\n```\\npackage CustomTypes\", \"; // Example: 12345.6789 -> { units = 12345, nanos = 678900000 } message DecimalValue { // Whole uni\", \"ts part of the amount int64 units = 1; // Nano units of the amount (10^-9) // Must be same sign as u\", \"nits sfixed32 nanos = 2; }\\n```\\n\\nThe nanos field represents values from 0.999_999_999 to -0.999_999_9\", \"99. For example, the decimal value 1.5m would be represented as { units = 1, nanos = 500_000_000 }. \", \"This is why the nanos field in this example uses the sfixed32 type, which encodes more efficiently t\", \"han int32 for larger values. If the units field is negative, the nanos field should also be negative\", \".\\n\\n## Note\\n\\nThere are multiple other algorithms for encoding decimal values as byte strings, but thi\", \"s message is easier to understand than any of them. The values are not affected by endianness on dif\", \"ferent platforms.\\n\\nConversion between this type and the BCL decimal type might be implemented in C# \", \"like this:\\n\\n```\\nnamespace CustomTypes; public partial class DecimalValue { private const decimal Nan\", \"oFactor = 1_000_000_000; public DecimalValue(long units, int nanos) { Units = units; Nanos = nanos; \", \"} public static implicit operator decimal(CustomTypes.DecimalValue grpcDecimal) { return grpcDecimal\", \".Units + grpcDecimal.Nanos / NanoFactor; } public static implicit operator CustomTypes.DecimalValue(\", \"decimal value) { var units = decimal.ToInt64(value); var nanos = decimal.ToInt32((value - units) * N\", \"anoFactor); return new CustomTypes.DecimalValue(units, nanos); } }\\n```\\n\\n## Important\\n\\nWhenever you u\", \"se custom message types like this, you must document them with comments in .proto. Other developers \", \"can then implement conversion to and from the equivalent type in their own language or framework.\\n\\n#\", \"# Protobuf nested types\\n\\nJust as C# allows you to declare classes inside other classes, Protocol Buf\", \"fer (Protobuf) allows you to nest message definitions within other messages. The following example s\", \"hows how to create nested message types:\\n\\n```\\nmessage Outer { message Inner { string text = 1; }\\n```\", \"\\n\\n```\\nInner inner = 1; }\\n```\\n\\nIn the generated C# code, the Inner type will be declared in a nested \", \"static Types class within the HelloRequest class:\\n\\n```\\nvar inner = new Outer.Types.Inner { Text = \\\"H\", \"ello\\\" };\\n```\\n\\n## Repeated fields for lists and arrays\\n\\nYou specify lists in Protocol Buffer (Protobu\", \"f) by using the repeated prefix keyword. The following example shows how to create a list:\\n\\n```\\nmess\", \"age Person { // Other fields elided repeated string aliases = 8; }\\n```\\n\\nIn the generated code, repea\", \"ted fields are represented by read-only properties of the Google.Protobuf.Collections.RepeatedField&\", \"lt;T&gt; type rather than any of the built-in .NET collection types. This type implements all the st\", \"andard .NET collection interfaces, such as IList and IEnumerable. So you can use LINQ queries or con\", \"vert it to an array or a list easily.\\n\\nThe RepeatedField&lt;T&gt; type includes the code required to\", \" serialize and deserialize the list to the binary wire format.\\n\\n## Protobuf reserved fields\\n\\nThe bac\", \"kward-compatibility guarantees in Protocol Buffer (Protobuf) rely on field numbers always representi\", \"ng the same data item. If a field is removed from a message in a new version of the service, that fi\", \"eld number should never be reused. You can enforce this behavior by using the reserved keyword.\\n\\nIf \", \"the displayName and marketId fields were removed from the Stock message defined earlier, their field\", \" numbers should be reserved as in the following example.\\n\\n```\\nsyntax \\\"proto3\\\"; message Stock { reser\", \"ved 3, 4; int32 id = 1; string symbol = 2; }\\n```\\n\\nYou can also use the reserved keyword as a placeho\", \"lder for fields that might be added in the future. You can express contiguous field numbers as a ran\", \"ge by using the to keyword.\\n\\n```\\nsyntax \\\"proto3\\\"; message Info {\\n```\\n\\n```\\nreserved 2, 9 to 11, 15; /\", \"/ ... }\\n```\\n\\n## Protobuf Any and Oneof fields for variant types\\n\\nHandling dynamic property types (th\", \"at is, properties of type object) in Windows Communication Foundation (WCF) is complicated. For exam\", \"ple, you must specify serializers and provide KnownType attributes.\\n\\nProtocol Buffer (Protobuf) prov\", \"ides two simpler options for dealing with values that might be of more than one type. The Any type c\", \"an represent any known Protobuf message type. And you can use the oneof keyword to specify that only\", \" one of a range of fields can be set in any message.\\n\\n## Any\\n\\nAny is one of Protobuf's 'well -known \", \"types': a collection of useful, reusable message types with implementations in all supported languag\", \"es. To use the Any type, you must import the google/protobuf/any.proto definition.\\n\\n```\\nsyntax = \\\"pr\", \"oto3\\\"; import \\\"google/protobuf/any.proto\\\"; message Stock { // Stock-specific data } message Currency\", \" { // Currency-specific data } message ChangeNotification { int32 id = 1; google.protobuf.Any instru\", \"ment = 2; }\\n```\\n\\nIn the C# code, the Any class provides methods for setting the field, extracting th\", \"e message, and checking the type.\\n\\n```\\npublic void FormatChangeNotification(ChangeNotification chang\", \"e) { if (change.Instrument.Is(Stock.Descriptor)) { FormatStock(change.Instrument.Unpack<Stock>()); }\", \" else if (change.Instrument.Is(Currency.Descriptor)) { FormatCurrency(change.Instrument.Unpack<Curre\", \"ncy>()); } else { throw new ArgumentException(\\\"Unknown instrument type\\\");\\n```\\n\\n```\\n} }\\n```\\n\\nProtobuf\", \"'s internal reflection code uses the Descriptor static field on each generated type to resolve Any f\", \"ield types. There's also a TryUnpack&lt;T&gt; method, but that creates an uninitialized instance of \", \"T even when it fails. It's better to use the Is method as shown earlier.\\n\\n## Oneof\\n\\nOneof fields are\", \" a language feature: the compiler handles the oneof keyword when it generates the message class. Usi\", \"ng oneof to specify the ChangeNotification message might look like this:\\n\\n```\\nmessage Stock { // Sto\", \"ck-specific data } message Currency { // Currency-specific data } message ChangeNotification { int32\", \" id = 1; oneof instrument { Stock stock = 2; Currency currency = 3; } }\\n```\\n\\nFields within the oneof\", \" set must have unique field numbers in the overall message declaration.\\n\\nWhen you use oneof, the gen\", \"erated C# code includes an enum that specifies which of the fields has been set. You can test the en\", \"um to find which field is set. Fields that aren't set return null or the default value, rather than \", \"throwing an exception.\\n\\n```\\npublic void FormatChangeNotification(ChangeNotification change) { switch\", \" (change.InstrumentCase) { case ChangeNotification.InstrumentOneofCase.None: return ; case ChangeNot\", \"ification.InstrumentOneofCase.Stock: FormatStock(change.Stock); break ; case ChangeNotification.Inst\", \"rumentOneofCase.Currency: FormatCurrency(change.Currency); break ; default : throw new ArgumentExcep\", \"tion(\\\"Unknown instrument type\\\"); } }\\n```\\n\\nSetting any field that's part of a oneof set will automati\", \"cally clear any other fields in the set. You can't use repeated with oneof. Instead, you can create \", \"a nested message with either the repeated field or the oneof set to work around this limitation.\\n\\n##\", \" Protobuf enumerations\\n\\nProtobuf supports enumeration types. You saw this support in the previous se\", \"ction, where an enum was used to determine the type of a Oneof field. You can define your own enumer\", \"ation types, and Protobuf will compile them to C# enum types.\\n\\nBecause you can use Protobuf with var\", \"ious languages, the naming conventions for enumerations are different from the C# conventions. Howev\", \"er, the code generator converts the names to the traditional C# case. If the Pascal-case equivalent \", \"of the field name s tarts with the enumeration name, then it's removed.\\n\\nFor example, in the followi\", \"ng Protobuf enumeration, the fields are prefixed with ACCOUNT_STATUS. This prefix is equivalent to t\", \"he Pascal-case enum name, AccountStatus.\\n\\n```\\nenum AccountStatus { ACCOUNT_STATUS_UNKNOWN = 0; ACCOU\", \"NT_STATUS_PENDING = 1; ACCOUNT_STATUS_ACTIVE = 2; ACCOUNT_STATUS_SUSPENDED = 3; ACCOUNT_STATUS_CLOSE\", \"D = 4; }\\n```\\n\\nThe generator creates a C# enum equivalent to the following code:\\n\\n```\\npublic enum Acc\", \"ountStatus { Unknown = 0, Pending = 1, Active = 2, Suspended = 3, Closed = 4 }\\n```\\n\\nProtobuf enumera\", \"tion definitions must have a zero constant as their first field. As in C#, you can declare multiple \", \"fields with the same value. But you must explicitly enable this option by using the allow_alias opti\", \"on in the enum:\\n\\n```\\nenum AccountStatus { option allow_alias = true; ACCOUNT_STATUS_UNKNOWN = 0; ACC\", \"OUNT_STATUS_PENDING = 1; ACCOUNT_STATUS_ACTIVE = 2; ACCOUNT_STATUS_SUSPENDED = 3; ACCOUNT_STATUS_CLO\", \"SED = 4; }\\n```\\n\\nYou can declare enumerations at the top level in a .proto file, or nested within a m\", \"essage definition. Nested enumerations -like nested messages -will be declared within the .Types sta\", \"tic class in the generated message class.\\n\\nThere's no way to apply the [Flags] attribute to a Protob\", \"ufgenerated enum, and Protobuf doesn't understand bitwise enum combinations. Look at the following e\", \"xample:\\n\\n```\\nenum Region { REGION_NONE = 0;\\n```\\n\\n```\\nREGION_NORTH_AMERICA = 1; REGION_SOUTH_AMERICA \", \"= 2; REGION_EMEA = 4; REGION_APAC = 8; } message Product { Region available_in = 1; }\\n```\\n\\nIf you se\", \"t product.AvailableIn to Region.NorthAmerica | Region.SouthAmerica, it's serialized as the integer v\", \"alue 3. When a client or server tries to deserialize the value, it won't find a match in the enum de\", \"finition for 3. The result will be Region.None.\\n\\nThe best way to work with multiple enum values in P\", \"rotobuf is to use a repeated field of the enum type.\\n\\n## Protobuf maps for dictionaries\\n\\nIt's import\", \"ant to be able to represent arbitrary collections of named values in messages. In .NET, this activit\", \"y is commonly handled through dictionary types. The equivalent of the .NET IDictionary&lt;TKey,TValu\", \"e&gt; type in Protocol Buffer (Protobuf) is the map&lt;key_type, value_type&gt; type. This section s\", \"hows how to declare a map type in Protobuf, and how to use the generated code.\\n\\n```\\nmessage StockPri\", \"ces { map<string, double> prices = 1; }\\n```\\n\\nIn the generated code, map fields are represented by re\", \"ad-only properties of the Google.Protobuf.Collections.MapField&lt;TKey, TValue&gt; type. This type i\", \"mplements the standard .NET collection interfaces, including IDictionary&lt;TKey,TValue&gt;.\\n\\nMap fi\", \"elds can't be directly repeated in a message definition. But you can create a nested message that co\", \"ntains a map and use repeated on the message type, as in the following example:\\n\\n```\\nmessage Order {\", \" message Attributes { map<string, string> values = 1; } repeated Attributes attributes = 1; }\\n```\\n\\n#\", \"# Using MapField properties in code\\n\\nThe MapField properties generated from map fields are read-only\", \", and will never be null. To set a map property, use the Add(IDictionary&lt;TKey,TValue&gt; values) \", \"method on the empty MapField property to copy values from any .NET dictionary.\\n\\n```\\npublic Order Cre\", \"ateOrder(Dictionary<string, string> attributes) { var order = new Order(); order.Attributes.Add(attr\", \"ibutes);\\n```\\n\\n| return order;   |\\n|-----------------|\\n\\n## Further reading\\n\\nFor more information abou\", \"t Protobuf, see the official Protobuf documentation.\\n\\n## Comparing WCF to gRPC\\n\\nThe previous chapter\", \" gave you a good look at Protobuf and how gRPC handles messages. Before you work through a detailed \", \"conversion from Windows Communication Foundation (WCF) to gRPC, it's important to know how the featu\", \"res available in WCF are handled in gRPC and what workarounds you can use when there's no gRPC equiv\", \"alent. In particular, this chapter will cover the following subjects:\\n\\n- Operations and methods\\n- Bi\", \"ndings and transports\\n- RPC types\\n- Metadata\\n- Error handling\\n- WS-* protocols\\n\\n## gRPC example\\n\\nWhe\", \"n you create a new ASP.NET Core 7.0 gRPC project from Visual Studio 2022 or the command line, the gR\", \"PC equivalent of 'Hello World' is generated for you. It consists of a greeter.proto file that define\", \"s the service and its messages, and a GreeterService.cs file with an implementation of the service.\\n\", \"\\n```\\nsyntax = \\\"proto3\\\"; option csharp_namespace = \\\"HelloGrpc\\\"; package Greet; // The greeting servic\", \"e definition. service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply)\", \"; } // The request message that contains the user's name. message HelloRequest { string name = 1; } \", \"// The response message that contains the greetings. message HelloReply { string message = 1; }\\n```\\n\", \"\\n```\\nnamespace HelloGrpc; public class GreeterService : Greeter.GreeterBase { private readonly ILogg\", \"er<GreeterService> _logger; public GreeterService(ILogger<GreeterService> logger) { _logger = logger\", \"; } public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context) { ret\", \"urn Task.FromResult( new HelloReply { Message = \\\"Hello \\\" + request.Name }); } }\\n```\\n\\nThis chapter wi\", \"ll refer to this example code when explaining different concepts and features of gRPC.\\n\\n## WCF endpo\", \"ints and gRPC methods\\n\\nIn Windows Communication Foundation (WCF), when you're writing your applicati\", \"on code, you use one of the following methods:\\n\\n- You write the application code in a class and deco\", \"rate methods with the OperationContract attribute.\\n- You declare an interface for the service and ad\", \"d OperationContract attributes to the interface.\\n\\nFor example, the WCF equivalent of the greet.proto\", \" Greeter service might be written as follows:\\n\\n```\\n[ServiceContract] public interface IGreeterServic\", \"e { [OperationContract] string SayHello(string name); }\\n```\\n\\nChapter 3 showed that Protobuf message \", \"definitions are used to generate data classes. Service and method declarations are used to generate \", \"base classes that you inherit from to implement the service. You just declare the methods to be impl\", \"emented in the .proto file, and the compiler generates a base class with virtual methods that you mu\", \"st override.\\n\\n## OperationContract properties\\n\\nThe OperationContract attribute has properties to con\", \"trol or refine how it works. gRPC methods don't offer this type of control. The following table list\", \"s those OperationContract properties and describes how the functionality that they specify is (or is\", \"n't) dealt with in gRPC:\\n\\n| OperationContract property   | gRPC                                     \", \"                                                              |\\n|------------------------------|----\", \"----------------------------------------------------------------------------------------------------\", \"|\\n| Action                       | A URI identifies the operation. gRPC uses the name of package, se\", \"rvice, and rpc from the .proto file.  |\\n| AsyncPattern                 | All gRPC service methods re\", \"turn Task objects.                                                          |\\n| IsInitiating        \", \"         | See the paragraph after this table.                                                      \", \"              |\\n| IsOneWay                     | One-way gRPC methods return Empty results or use cl\", \"ient streaming.                                     |\\n| IsTerminating                | See the parag\", \"raph after this table.                                                                    |\\n| Name  \", \"                       | This property is SOAP related and has no meaning in gRPC.                  \", \"                            |\\n| ProtectionLevel              | There's no message encryption. Networ\", \"k encryption is handled at the transport layer (TLS over HTTP/2). |\\n| ReplyAction                  |\", \" This property is SOAP related and has no meaning in gRPC.                                          \", \"    |\\n\\nThe IsInitiating property lets you indicate that a method within ServiceContract can't be the\", \" first method called as part of a session. The IsTerminating property causes the server to close the\", \" session after an operation is called (or the client, if the property is used on a callback client).\", \" In gRPC, streams are created by single methods and closed explicitly. See gRPC streaming.\\n\\nFor more\", \" information on gRPC security and encryption, see chapter 6.\\n\\n## WCF bindings and transports\\n\\nWindow\", \"s Communication Foundation (WCF) has built-in bindings that specify different network protocols, wir\", \"e formats, and other implementation details. gRPC effectively has just one network protocol and one \", \"wire format. (Technically you can customize the wire format, but that's beyond the scope of this boo\", \"k.) You're likely to discover that gRPC offers the best solution in most cases.\\n\\nWhat follows is a s\", \"hort discussion about the most relevant WCF bindings and how they compare to their equivalents in gR\", \"PC.\\n\\n## NetTCP\\n\\nWCF's NetTCP binding allows for persistent connections, small messages, and two -way\", \" messaging. But it works only between .NET clients and servers. gRPC allows the same functionality b\", \"ut is supported across multiple programming languages and platforms.\\n\\ngRPC has many features of WCF'\", \"s NetTCP binding, but they're not always implemented in the same way. For example, in WCF, encryptio\", \"n is controlled through configuration and handled in the framework. In gRPC, encryption is achieved \", \"at the connection level through HTTP/2 over TLS.\\n\\n## HTTP\\n\\nThe WCF binding called BasicHttpBinding i\", \"s usually textbased and uses SOAP as the wire format. It's slow compared to the NetTCP binding. It's\", \" used to provide cross -platform interoperability, or connection over internet infrastructure.\\n\\nThe \", \"equivalent in gRPC uses HTTP/2 as the underlying transport layer with the binary Protobuf wire forma\", \"t for messages. So it can offer performance at the NetTCP service level and full cross-platform inte\", \"roperability with all modern programming languages and frameworks.\\n\\n## Named pipes\\n\\nWCF provided a n\", \"amed pipes binding for communication between processes on the same physical machine. ASP.NET Core gR\", \"PC doesn't support named pipes. For inter -process communication (IPC) using gRPC instead supports U\", \"nix domain sockets. Unix domain sockets are supported on Linux and modern versions of Windows.\\n\\nFor \", \"more information, see Inter-process communication with gRPC.\\n\\n## MSMQ\\n\\nMSMQ is a proprietary Windows\", \" message queue. WCF's binding to MSMQ enables 'fire and forget' requests from clients that might be \", \"processed at any time in the future. gRPC doesn't natively provide any message queue functionality.\\n\", \"\\nThe best alternative is to directly use a messaging system like Azure Service Bus, RabbitMQ, or Kaf\", \"ka. You can implement this functionality with the client placing messages directly onto the queue, o\", \"r a gRPC client streaming service that enqueues the messages.\\n\\n## WebHttpBinding\\n\\nWebHttpBinding (al\", \"so known as WCF REST), with the WebGet and WebInvoke attributes, enabled you to develop RESTful APIs\", \" that could speak JSON at a time when this behavior was less common. If you have a RESTful API built\", \" with WCF REST, consider migrating it to a regular ASP.NET Core MVC Web API application. This migrat\", \"ion would provide the same functionality as a conversion to gRPC.\\n\\n## Types of RPC\\n\\nAs a Windows Com\", \"munication Foundation (WCF) developer, you're probably used to dealing with the following types of r\", \"emote procedure call (RPC):\\n\\n- Request/reply\\n- Duplex:\\n- -One-way duplex with session\\n- -Full duplex\", \" with session\\n- One-way\\n\\nIt's possible to map these RPC types fairly naturally to existing gRPC conc\", \"epts. This chapter will look at each of these areas in turn. Chapter 5 will explore similar examples\", \" in greater depth.\\n\\n| WCF                                                           | gRPC          \", \"          |\\n|---------------------------------------------------------------|-----------------------\", \"--|\\n| Regular request/reply                                         | Unary                   |\\n| Du\", \"plex service with session using a client callback interface | Server streaming        |\\n| Full duple\", \"x service with session                              | Bidirectional streaming |\\n| One-way operations\", \"                                            | Client streaming        |\\n\\n## Request/reply\\n\\nFor simpl\", \"e request/reply methods that take and return small amounts of data, use the simplest gRPC pattern, t\", \"he unary RPC.\\n\\n```\\nservice Things { rpc Get(GetThingRequest) returns (GetThingResponse); } public cl\", \"ass ThingService : Things.ThingsBase { public override async Task<GetThingResponse> Get(GetThingRequ\", \"est request, ServerCallContext context) { // Get thing from database return new GetThingResponse { T\", \"hing = thing }; } } public async Task ShowThing(int thingId) { var thing = await _thingsClient.GetAs\", \"ync( new GetThingRequest { ThingId = thingId }); Console.WriteLine($\\\"{thing.Name}\\\"); }\\n```\\n\\nAs you c\", \"an see, implementing a gRPC unary RPC service method is similar to implementing a WCF operation. The\", \" difference is that with gRPC, you override a base class method instead of implementing an interface\", \". On the server, gRPC base methods always return Task, although the client provides both async and b\", \"locking methods to call the service.\\n\\n## WCF duplex, one way to client\\n\\nWCF applications (with certa\", \"in bindings) can create a persistent connection between client and server. The server can asynchrono\", \"usly send data to the client until the connection is closed, by using a callback interface specified\", \" in the ServiceContractAttribute.CallbackContract property.\\n\\ngRPC services provide similar functiona\", \"lity with message streams. Streams don't map exactly to WCF duplex services in terms of implementati\", \"on, but you can achieve the same results.\\n\\n## gRPC streaming\\n\\ngRPC supports the creation of persiste\", \"nt streams from client to server, and from server to client. Both types of stream can be active conc\", \"urrently. This ability is called bidirectional streaming.\\n\\nYou can use streams for arbitrary, asynch\", \"ronous messaging over time. Or you can use them for passing large datasets that are too big to gener\", \"ate and send in a single request or response.\\n\\nThe following example shows a server-streaming RPC.\\n\\n\", \"```\\nservice ClockStreamer { rpc Subscribe(ClockSubscribeRequest) returns (stream ClockMessage); } pu\", \"blic class ClockStreamerService : ClockStreamer.ClockStreamerBase { public override async Task Subsc\", \"ribe(ClockSubscribeRequest request, IServerStreamWriter<ClockMessage> responseStream, ServerCallCont\", \"ext context) { while (!context.CancellationToken.IsCancellationRequested) { var time = DateTimeOffse\", \"t.UtcNow; await responseStream.WriteAsync( new ClockMessage { message = $\\\"The time is {time:t}.\\\" });\", \" await Task.Delay(TimeSpan.FromSeconds(10), context.CancellationToken); } } }\\n```\\n\\nThis server strea\", \"m can be consumed from a client application, as shown in the following code:\\n\\n```\\npublic async Task \", \"TellTheTimeAsync(CancellationToken token) { var channel = GrpcChannel.ForAddress(\\\"https://localhost:\", \"5001\\\"); var client = new ClockStreamer.ClockStreamerClient(channel); var request = new ClockSubscrib\", \"eRequest(); var response = client.Subscribe(request); await foreach (var update in response.Response\", \"Stream.ReadAllAsync(token)) { Console.WriteLine(update.Message); } }\\n```\\n\\n## Note\\n\\nServer-streaming \", \"RPCs are useful for subscriptionstyle services. They're also useful for sending large datasets when \", \"it would be inefficient or impossible to build the entire dataset in memory. However, streaming resp\", \"onses isn't as fast as sending repeate d fields in a single message. As a rule, streaming shouldn't \", \"be used for small datasets.\\n\\n## Differences from WCF\\n\\nA WCF duplex service uses a client callback in\", \"terface that can have multiple methods. A gRPC serverstreaming service can only send messages over a\", \" single stream. If you need multiple methods, use a message type with either an Any field or a oneof\", \" field to send different messages, and write code in the client to handle them.\\n\\nIn WCF, the Service\", \"Contract class with the session is kept alive until the connection is closed. Multiple methods can b\", \"e called within the session. In gRPC, the Task that the implementation method returns shouldn't fini\", \"sh until the connection is closed.\\n\\n## WCF one-way operations and gRPC client streaming\\n\\nWCF provide\", \"s one-way operations (marked with [OperationContract(IsOneWay = true)]) that return a transport-spec\", \"ific acknowledgment. gRPC service methods always return a response, even if it's empty. The client s\", \"hould always await that response. For the 'fire -andforget' style of messaging in gRPC, you can crea\", \"te a client streaming service.\\n\\n## thing_log.proto\\n\\n```\\nservice ThingLog { rpc OpenConnection(stream\", \" Thing) returns (ConnectionClosedResponse); }\\n```\\n\\n## ThingLogService.cs\\n\\n```\\npublic class ThingLogS\", \"ervice : Protos.ThingLog.ThingLogBase { private static readonly ConnectionClosedResponse EmptyRespon\", \"se = new ConnectionClosedResponse(); private readonly ILogger<ThingLogService> _logger; public Thing\", \"LogService(ILogger<ThingLogService> logger) { _logger = logger; } public override async Task<Complet\", \"edResponse> OpenConnection(IAsyncStreamReader<Thing> requestStream, ServerCallContext context) { whi\", \"le (await requestStream.MoveNext(context.CancellationToken)) { _logger.LogInformation(requestStream.\", \"Current.Description); } return EmptyResponse; } }\\n```\\n\\n## ThingLog client example\\n\\n```\\npublic class \", \"ThingLogger : IAsyncDisposable { private readonly ThingLog.ThingLogClient _client; private readonly \", \"AsyncClientStreamingCall<ThingLogRequest, CompletedResponse> _stream; public ThingLogger(ThingLog.Th\", \"ingLogClient client)\\n```\\n\\n```\\n{ _client = client; _stream = client.OpenConnection(); } public async \", \"Task WriteAsync(string description) { await _stream.RequestStream.WriteAsync( new Thing { Descriptio\", \"n = description, Time = Timestamp.FromDateTimeOffset(DateTimeOffset.UtcNow) }); } public async Value\", \"Task DisposeAsync() { await _stream.RequestStream.CompleteAsync(); _stream.Dispose(); } }\\n```\\n\\nYou c\", \"an use client-streaming RPCs for fire-and-forget messaging, as shown in the previous example. You ca\", \"n also use them for sending very large datasets to the server. The same warning about performance ap\", \"plies: for smaller datasets, use repeated fields in regular messages.\\n\\n## WCF full-duplex services\\n\\n\", \"WCF duplex binding supports multiple one-way operations on both the service interface and the client\", \" callback interface. This support allows ongoing conversations between client and server. gRPC suppo\", \"rts something similar with bidirectional streaming RPCs, where both parameters are marked with the s\", \"tream modifier.\\n\\n## chat.proto\\n\\n```\\nservice Chatter { rpc Connect(stream IncomingMessage) returns (s\", \"tream OutgoingMessage); }\\n```\\n\\n## ChatterService.cs\\n\\n```\\npublic class ChatterService : Chatter.Chatt\", \"erBase { private readonly IChatHub _hub; public ChatterService(IChatHub hub) { _hub = hub; } public \", \"override async Task Connect(IAsyncStreamReader<MessageRequest> requestStream, IServerStreamWriter<Me\", \"ssageResponse> responseStream, ServerCallContext context) { _hub.MessageReceived += async (sender, a\", \"rgs) => await responseStream.WriteAsync( new MessageResponse {Text = args.Message}); while (await re\", \"questStream.MoveNext(context.CancellationToken)) {\\n```\\n\\n```\\nawait _hub.SendAsync(requestStream.Curre\", \"nt.Text); } } }\\n```\\n\\nIn the previous example, you can see that the implementation method receives bo\", \"th a request stream (IAsyncStreamReader&lt;MessageRequest&gt;) and a response stream\\n\\n(IServerStream\", \"Writer&lt;MessageResponse&gt;). The method can read and write messages until the connection is close\", \"d.\\n\\n## Chatter client\\n\\n```\\npublic class Chat : IAsyncDisposable { private readonly Chatter.ChatterCl\", \"ient _client; private readonly AsyncDuplexStreamingCall<MessageRequest, MessageResponse> _stream; pr\", \"ivate readonly CancellationTokenSource _cancellationTokenSource; private readonly Task _readTask; pu\", \"blic Chat(Chatter.ChatterClient client) { _client = client; _stream = _client.Connect(); _cancellati\", \"onTokenSource = new CancellationTokenSource(); _readTask = ReadAsync(_cancellationTokenSource.Token)\", \"; } public async Task SendAsync(string message) { await _stream.RequestStream.WriteAsync( new Messag\", \"eRequest {Text = message}); } private async Task ReadAsync(CancellationToken token) { while (await _\", \"stream.ResponseStream.MoveNext(token)) { Console.WriteLine(_stream.ResponseStream.Current.Text); } }\", \" public async ValueTask DisposeAsync() { await _stream.RequestStream.CompleteAsync(); await _readTas\", \"k; _stream.Dispose(); } }\\n```\\n\\n## Metadata\\n\\nMetadata refers to additional data that might be useful \", \"during the processing of requests and responses but that's not part of the actual application data. \", \"Metadata might include authentication tokens, request identifiers and tags for monitoring purposes, \", \"and information about the data, like the number of records in a dataset.\\n\\nIt's possible to add gener\", \"ic key/value headers to Windows Communication Foundation (WCF) messages by using an OperationContext\", \"Scope and the OperationContext.OutgoingMessageHeaders property and handle them by using MessagePrope\", \"rties.\\n\\ngRPC calls and responses can also include metadata that's similar to HTTP headers. This meta\", \"data is mostly invisible to gRPC itself and is passed through to be processed by your application co\", \"de or middleware. Metadata is represented as key/value pairs, where the key is a string and the valu\", \"e is either a string or binary data. You don't need to specify metadata in the .proto file.\\n\\nMetadat\", \"a is handled by the Metadata class of the Grpc.Core.Api NuGet package. This class can be used with c\", \"ollection initializer syntax.\\n\\nThis example shows how to add metadata to a call from a C# client:\\n\\n`\", \"``\\nvar metadata = new Metadata { { \\\"Requester\\\", _clientName } }; var request = new GetPortfolioReque\", \"st { Id = portfolioId }; var response = await client.GetPortfolioAsync(request, metadata);\\n```\\n\\ngRPC\", \" services can access metadata from the ServerCallContext argument's RequestHeaders property:\\n\\n```\\npu\", \"blic async Task<GetPortfolioResponse> GetPortfolio(GetPortfolioRequest request, ServerCallContext co\", \"ntext) { var requesterHeader = context.RequestHeaders.FirstOrDefault(e => e.Key == \\\"Requester\\\"); if \", \"(requesterHeader != null ) { _logger.LogInformation($\\\"Request from {requesterHeader.Value}\\\"); } // .\", \".. }\\n```\\n\\nServices can send metadata to clients by using the ResponseTrailers property of ServerCall\", \"Context:\\n\\n```\\npublic async Task<GetPortfolioResponse> GetPortfolio(GetPortfolioRequest request, Serv\", \"erCallContext context) { // ... context.ResponseTrailers.Add(\\\"Responder\\\", _serverName); // ... }\\n```\", \"\\n\\n## Error handling\\n\\nWindows Communication Foundation (WCF) uses FaultException and FaultContract to\", \" provide detailed error information, including supporting the SOAP Fault standard.\\n\\nUnfortunately, t\", \"he current version of gRPC lacks the sophistication found with WCF, and only has limited built-in er\", \"ror handling based on simple status codes and metadata. The following table is a quick guide to the \", \"most commonly used status codes:\\n\\n| Status code                   | Problem                         \", \"          |\\n|-------------------------------|-------------------------------------------|\\n| GRPC_STA\", \"TUS_UNIMPLEMENTED     | Method hasn't been written.               |\\n| GRPC_STATUS_UNAVAILABLE       \", \"| Problem with the whole service.           |\\n| GRPC_STATUS_UNKNOWN           | Invalid response.   \", \"                      |\\n| GRPC_STATUS_INTERNAL          | Problem with encoding/decoding.           \", \"|\\n| GRPC_STATUS_UNAUTHENTICATED   | Authentication failed.                    |\\n| GRPC_STATUS_PERMIS\", \"SION_DENIED | Authorization failed.                     |\\n| GRPC_STATUS_CANCELLED         | Call was\", \" canceled, usually by the caller. |\\n\\n## Raise errors in ASP.NET Core gRPC\\n\\nAn ASP.NET Core gRPC serv\", \"ice can send an error response by throwing an RpcException, which can be caught by the client as if \", \"it were in the same process. The RpcException must include a status code and description, and can op\", \"tionally include metadata and a longer exception message. The metadata can be used to send supportin\", \"g data, similar to how FaultContract objects can carry additional data for WCF errors.\\n\\n```\\npublic a\", \"sync Task<GetPortfolioResponse> GetPortfolio(GetPortfolioRequest request, ServerCallContext context)\", \" { var user = context.GetHttpContext().User; if (!ValidateUser(user)) { var metadata = new Metadata \", \"{ { \\\"User\\\", user.Identity.Name } }; throw new RpcException( new Status(StatusCode.PermissionDenied, \", \"\\\"Permission denied\\\"), metadata); } }\\n```\\n\\n## Catch errors in gRPC clients\\n\\nJust like WCF clients can\", \" catch FaultException errors, a gRPC client can catch an RpcException to handle errors. Because RpcE\", \"xception isn't a generic type, you can't catch different error types in different blocks. But you ca\", \"n use C#'s exception filters feature to declare separate catch blocks for different status codes, as\", \" shown in the following example:\\n\\n```\\ntry { var portfolio = await client.GetPortfolioAsync( new GetP\", \"ortfolioRequest { Id = id }); } catch (RpcException ex) when (ex.StatusCode == StatusCode.Permission\", \"Denied)\\n```\\n\\n```\\n{ var userEntry = ex.Trailers.FirstOrDefault(e => e.Key == \\\"User\\\"); Console.WriteLi\", \"ne($\\\"User '{userEntry.Value}' does not have permission to view this portfolio.\\\"); } catch (RpcExcept\", \"ion) { // Handle any other error type ... }\\n```\\n\\n## Important\\n\\nWhen you provide additional metadata \", \"for errors, be sure to document the relevant keys and values in your API documentation, or in commen\", \"ts in your .proto file.\\n\\n## gRPC richer error model\\n\\nGoogle has developed a richer error model that'\", \"s more like WCF's FaultContract , but this model isn't supported in C# yet. Currently, it's only ava\", \"ilable for Go, Java, Python, and C++.\\n\\n## WS-* protocols\\n\\nOne of the real benefits of working with W\", \"indows Communication Foundation (WCF) was that it supported many of the existing WS-* standard proto\", \"cols. This section will briefly cover how gRPC manages the same WS* protocols and discuss what optio\", \"ns are available when there's no alternative.\\n\\n## Metadata exchange: WS-Policy, WS-Discovery, and so\", \" on\\n\\nSOAP services expose Web Services Description Language (WSDL) schema documents with information\", \" such as data formats, operations, or communication options. You can use this schema to generate the\", \" client code.\\n\\ngRPC works best when servers and clients are generated from the same .proto files, bu\", \"t a Server Reflection optional extension does provide a way to expose dynamic information from a run\", \"ning server. For more information, see the Grpc.Reflection NuGet package.\\n\\nThe WS-Discovery protocol\", \" is used to locate services on a local network. gRPC services are located through DNS or a service r\", \"egistry such as Consul or ZooKeeper.\\n\\n## Security: WS-Security, WS-Federation, XML Encryption, and s\", \"o on\\n\\nSecurity, authentication, and authorization are covered in much more detail in chapter 6 . But\", \" it's worth noting here that, unlike WCF, gRPC doesn't support WS -Security, WS-Federation, or XML E\", \"ncryption. Even so, gRPC provides excellent security. All gRPC network traffic is automatically encr\", \"ypted when it's using HTTP/2 over TLS. You can use X509 certificates for mutual client/server authen\", \"tication.\\n\\n## WS-ReliableMessaging\\n\\ngRPC does not provide an equivalent to WS-ReliableMessaging. Ret\", \"ry semantics should be handled in code, possibly with a library like Polly . When you're running in \", \"Kubernetes or similar orchestration environments, service meshes can also help to provide reliable m\", \"essaging between services.\\n\\n## WS-Transaction, WS-Coordination\\n\\nWCF's implementation of distributed \", \"transactions uses Microsoft Distributed Transaction Coordinator (MSDTC). It works with resource mana\", \"gers that specifically support it, like SQL Server, MSMQ, or Windows file systems. There's no equiva\", \"lent yet in the mode rn microservices world, in part due to the wider range of technologies in use. \", \"For a discussion of transactions, see Appendix A.\\n\\n## Migrate a WCF solution to gRPC\\n\\nThis chapter w\", \"ill describe how to work with ASP.NET Core 7.0 gRPC projects and demonstrate migrating different typ\", \"es of Windows Communication Foundation (WCF) services to the gRPC equivalent:\\n\\n- Create an ASP.NET C\", \"ore 7.0 gRPC project.\\n- Simple request-reply operations to gRPC unary RPC.\\n- One-way operations to g\", \"RPC client streaming RPC.\\n- Full-duplex services to gRPC bidirectional streaming RPC.\\n\\nThere's also \", \"a comparison of using streaming services versus repeated fields for returning datasets, and there's \", \"a discussion of the use of client libraries at the end of the chapter.\\n\\nThe sample WCF application i\", \"s a minimal stub of a set of stock trading services. It uses the opensource Inversion of Control (Io\", \"C) container library called Autofac for dependency injection. It includes three services, one for ea\", \"ch WCF service type. The services will be discussed in more detail in the following sections. You ca\", \"n download the solutions from dotnet-architecture/grpc-for-wcf-developers on GitHub. The services us\", \"e fake data to minimize external dependencies.\\n\\nThe samples include the WCF and gRPC implementations\", \" of each service.\\n\\n## Create a new ASP.NET Core gRPC project\\n\\nThe .NET SDK comes with a powerful CLI\", \" tool, dotnet, which enables you to create and manage projects and solutions from the command line. \", \"The SDK is closely integrated with Visual Studio, so everything is also available through the famili\", \"ar graphical user interface. This chapter shows both ways to create a new ASP.NET Core gRPC project.\", \"\\n\\n## Create the project by using Visual Studio\\n\\n## Important\\n\\nTo develop any ASP.NET Core 7.0 app, y\", \"ou need Visual Studio 2022, with the ASP.NET and web development workload installed.\\n\\nAdd a new proj\", \"ect\\n\\nRecent project templates displayed here.\\n\\ngrpd\\n\\nAll languages\\n\\n- All platforms\\n\\nAll project typ\", \"es\\n\\nCreate an empty solution called TraderSys from the Blank Solution template. Add a solution folde\", \"r called src. Then, right-click on the folder and choose Add &gt; New Project . Enter grpc in the te\", \"mplate search box, and you should see a project template called gRPC Service.\\n\\nSelect Next to contin\", \"ue to the Configure your new project dialog box. Name the project TraderSys.Portfolios and add an sr\", \"c subdirectory to the Location .\\n\\nClear all\\n\\nConfigure your new project\\n\\nASP.NET Core gRPC Service\\n\\n\", \"Project name\\n\\nTraderSys.Portfolios\\n\\nLocation\\n\\nC:\\\\Code\\\\ TraderSys\\n\\n\\u2022C#\\n\\nLinux macOS\\n\\nWindows\\n\\nCloud\\n\\n\", \"Service\\n\\nWeb\\n\\nSelect Next to continue to the Create a new gRPC service dialog box.\\n\\nAdditional infor\", \"mation\\n\\nASP.NET Core gRPC Service C*\\n\\nFramework i\\n\\n.NET 7.0 (Standard Term Support)\\n\\nEnable Docker O\", \"\\n\\nDocker OS O\\n\\nLinux\\n\\nDo not use top-level statements O\\n\\nWindows\\n\\nService\\n\\nAt present, you have limi\", \"ted options for the service creation. Docker will be introduced later, so for now, leave that option\", \" unselected. Just select Create . Your first ASP.NET Core 7.0 gRPC project is generated and added to\", \" the solution. If you don't want to know about working with the dotnet CLI, skip to the Clean up the\", \" example code section.\\n\\n## Create the project by using the .NET CLI\\n\\nThis section covers the creatio\", \"n of solutions and projects from the command line.\\n\\nCreate the solution as shown in the following co\", \"mmand. The -o (or --output) flag specifies the output directory, which is created in the current dir\", \"ectory if it doesn't already exist. The solution has the same name as the directory: TraderSys.sln. \", \"You can provide a different name by using the -n (or --name) flag.\\n\\n```\\ndotnet new sln -o TraderSys \", \"cd TraderSys\\n```\\n\\nASP.NET Core 7.0 comes with a CLI template for gRPC services. Create the new proje\", \"ct by using this template, putting it into an src subdirectory as is conventional for ASP.NET Core p\", \"rojects. The project is named after the directory (TraderSys.Portfolios.csproj), unless you specify \", \"a different name with the -n flag.\\n\\n```\\ndotnet new grpc -o src/TraderSys.Portfolios\\n```\\n\\nFinally, ad\", \"d the project to the solution by using the dotnet sln command:\\n\\ndotnet sln add src/TraderSys.Portfol\", \"ios\\n\\nX\\n\\n## Tip\\n\\nBecause the particular directory only contains a single .csproj file, you can specif\", \"y just the directory, to save typing.\\n\\nYou can now open this solution in Visual Studio 2022, Visual \", \"Studio Code, or whatever editor you prefer.\\n\\n## Clean up the example code\\n\\nYou've now created an exa\", \"mple service by using the gRPC template, which was reviewed earlier in the book. This code isn't use\", \"ful in our stock trading context, so we'll edit things for our first project.\\n\\n## Rename and edit th\", \"e proto file\\n\\nGo ahead and rename the Protos/greet.proto file to Protos/portfolios.proto, and open i\", \"t in your editor. Delete everything after the package line. Then change the option csharp_namespace,\", \" package and service names, and remove the default SayHello service. The code now looks like the fol\", \"lowing:\\n\\n```\\nsyntax = \\\"proto3\\\"; option csharp_namespace = \\\"TraderSys.Portfolios.Protos\\\"; package Por\", \"tfolioServer; service Portfolios { // RPCs will go here }\\n```\\n\\n## Tip\\n\\nThe template doesn't add the \", \"Protos namespace part by default, but adding it makes it easier to keep gRPC-generated classes and y\", \"our own classes clearly separated in your code.\\n\\nIf you rename the greet.proto file in an integrated\", \" development environment (IDE) like Visual Studio, a reference to this file is automatically updated\", \" in the .csproj file. But in some other editor, such as Visual Studio Code, this reference isn't upd\", \"ated automatically, so you need to edit the project file manually.\\n\\nIn the gRPC build targets, there\", \"'s a Protobuf item element that lets you specify which .proto files should be compiled, and which fo\", \"rm of code generation is required (that is, 'Server' or 'Client').\\n\\n```\\n< ItemGroup > < Protobuf Inc\", \"lude=\\\"Protos\\\\portfolios.proto\\\" GrpcServices=\\\"Server\\\" /> </ ItemGroup >\\n```\\n\\n## Rename the GreeterSer\", \"vice class\\n\\nThe GreeterService class is in the Services folder and inherits from Greeter.GreeterBase\", \". Rename it to PortfolioService, and change the base class to Portfolios.PortfoliosBase. Delete the \", \"override methods.\\n\\n```\\npublic class PortfolioService : Protos.Portfolios.PortfoliosBase { }\\n```\\n\\nThe\", \"re was a reference to the GreeterService class in the Program.cs . If you used refactoring to rename\", \" the class, this reference should have been updated automatically. However, if you didn't, you need \", \"to edit it manually.\\n\\n```\\nusing TraderSys.Portfolios.Services; var builder = WebApplication.CreateBu\", \"ilder(args); // Add services to the container. builder.Services.AddGrpc(); var app = builder.Build()\", \"; // Configure the HTTP request pipeline. app.MapGrpcService<PortfolioService>(); app.MapGet(\\\"/\\\", ()\", \" => \\\"Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a \", \"client, visit: https://go.microsoft.com/fwlink/?linkid=2086909\\\"); app.Run();\\n```\\n\\nIn the next sectio\", \"n, we'll add functionality to this new service.\\n\\n## Migrate a WCF request-reply service to a gRPC un\", \"ary RPC\\n\\nThis section covers how to migrate a basic request-reply service in WCF to a unary RPC serv\", \"ice in ASP.NET Core gRPC. These services are the simplest service types in both Windows Communicatio\", \"n Foundation (WCF) and gRPC, so it's an excellent place to start. After migrating the service, you'l\", \"l learn how to generate a client library from the same .proto file to consume the service from a .NE\", \"T client application.\\n\\n## The WCF solution\\n\\nThe PortfoliosSample solution includes a simple request-\", \"reply Portfolio service to download either a single portfolio or all portfolios for a given trader. \", \"The service is defined in the interface IPortfolioService with a ServiceContract attribute:\\n\\n```\\n[Se\", \"rviceContract] public interface IPortfolioService { [OperationContract] Task<Portfolio> Get(Guid tra\", \"derId, int portfolioId); [OperationContract] Task<List<Portfolio>> GetAll(Guid traderId); }\\n```\\n\\nThe\", \" Portfolio model is a simple C# class marked with DataContract and including a list of PortfolioItem\", \" objects. These models are defined in the TraderSys.PortfolioData project along with a repository cl\", \"ass that represents a data access abstraction.\\n\\n```\\n[DataContract] public class Portfolio { [DataMem\", \"ber] public int Id { get ; set ; } [DataMember] public Guid TraderId { get ; set ; } [DataMember] pu\", \"blic List<PortfolioItem> Items { get ; set ; } } [DataContract] public class PortfolioItem { [DataMe\", \"mber] public int Id { get ; set ; } [DataMember] public int ShareId { get ; set ; } [DataMember] pub\", \"lic int Holding { get ; set ; } [DataMember] public decimal Cost { get ; set ; } }\\n```\\n\\nThe ServiceC\", \"ontract implementation uses a repository class provided via dependency injection that returns instan\", \"ces of the DataContract types:\\n\\n```\\npublic class PortfolioService : Protos.Portfolios.PortfoliosBase\", \" { private readonly IPortfolioRepository _repository; public PortfolioService(IPortfolioRepository r\", \"epository) { _repository = repository; } public async Task<Portfolio> Get(Guid traderId, int portfol\", \"ioId) { return await _repository.GetAsync(traderId, portfolioId); } public async Task<List<Portfolio\", \">> GetAll(Guid traderId) { return await _repository.GetAllAsync(traderId); } }\\n```\\n\\n## The portfolio\", \"s.proto file\\n\\nIf you followed the instructions in the previous section, you should have a gRPC proje\", \"ct with a portfolios.proto file that looks like this:\\n\\n```\\nsyntax = \\\"proto3\\\"; option csharp_namespac\", \"e = \\\"TraderSys.Portfolios.Protos\\\"; package PortfolioServer; service Portfolios { // RPCs will go her\", \"e }\\n```\\n\\nThe first step is to migrate the DataContract classes to their Protobuf equivalents.\\n\\n## Co\", \"nvert the DataContract classes to gRPC messages\\n\\nThe PortfolioItem class will be converted to a Prot\", \"obuf message first, because the Portfolio class depends on it. The class is simple, and three of the\", \" properties map directly to gRPC data types. The Cost property, which represents the price paid for \", \"the shares at purchase, is a decimal field. gRPC supports only float or double for real numbers, whi\", \"ch aren't suitable for currency. Because share prices vary by a minimum of one cent, the cost can be\", \" expressed as an int32 of cents.\\n\\n## Note\\n\\nRemember to use snake_case for field names in your .proto\", \" file. The C# code generator will convert them to PascalCase for you, and users of other languages w\", \"ill thank you for respecting their different coding standards.\\n\\n```\\nmessage PortfolioItem { int32 id\", \" = 1; int32 share_id = 2; int32 holding = 3; int32 cost_cents = 4; }\\n```\\n\\nThe Portfolio class is a l\", \"ittle more complicated. In the WCF code, the developer used a Guid for the TraderId property, and co\", \"ntains a List&lt;PortfolioItem&gt;. In Protobuf, which doesn't have a first -class UUID type, you sh\", \"ould use a string for the traderId field and parse it in your own code. For the list of items, use t\", \"he repeated keyword on the field.\\n\\n```\\nmessage Portfolio { int32 id = 1; string trader_id = 2; repea\", \"ted PortfolioItem items = 3; }\\n```\\n\\nNow that you have the data messages, you can declare the service\", \" RPC endpoints.\\n\\n## Convert ServiceContract to a gRPC service\\n\\nThe WCF Get method takes two paramete\", \"rs: Guid traderId and int portfolioId. gRPC service methods can take only a single parameter, so you\", \" need to create a message to hold the two values. It's common practice to name these request objects\", \" with the same name as the method followed by the suffix Request. Again, string is being used for th\", \"e traderId field instead of Guid.\\n\\nThe service could just return a Portfolio message directly, but a\", \"gain, this could affect backward compatibility in the future. It's a good practice to define separat\", \"e Request and Response messages for every method in a service, even if many of them are the same rig\", \"ht now. So declare a GetResponse message with a single Portfolio field.\\n\\nThis example shows the decl\", \"aration of the gRPC service method with the GetRequest message:\\n\\n```\\nmessage GetRequest { string tra\", \"der_id = 1; int32 portfolio_id = 2; } message GetResponse { Portfolio portfolio = 1; } service Portf\", \"olios { rpc Get(GetRequest) returns (GetResponse); }\\n```\\n\\nThe WCF GetAll method takes only a single \", \"parameter, traderId, so it might seem that you could specify string as the parameter type. But gRPC \", \"requires a defined message type. This requirement helps to enforce the practice of using custom mess\", \"ages for all inputs and outputs, for future backward compatibility.\\n\\nThe WCF method also returns a L\", \"ist&lt;Portfolio&gt;, but for the same reason it doesn't allow simple parameter types, gRPC won't al\", \"low repeated Portfolio as a return type. Instead, create a GetAllResponse type to wrap the list.\\n\\n##\", \" Warning\\n\\nYou might be tempted to create a PortfolioList message or something similar and use it acr\", \"oss multiple service methods, but you should resist this temptation. It's impossible to know how the\", \" various methods on a service will evolve, so keep their messages specific and cleanly separated.\\n\\n`\", \"``\\nmessage GetAllRequest { string trader_id = 1; } message GetAllResponse { repeated Portfolio portf\", \"olios = 1; } service Portfolios { rpc Get(GetRequest) returns (GetResponse);\\n```\\n\\n```\\nrpc GetAll(Get\", \"AllRequest) returns (GetAllResponse); }\\n```\\n\\nIf you save your project with these changes, the gRPC b\", \"uild target will run in the background and generate all the Protobuf message types and a base class \", \"that you can inherit to implement the service.\\n\\nOpen the Services/GreeterService.cs class and delete\", \" the example code. Now you can add the Portfolio service implementation. The generated base class wi\", \"ll be in the Protos namespace and is generated as a nested class. gRPC creates a static class with t\", \"he same name as the service in the .proto file and a base class with the suffix Base inside that sta\", \"tic class, so the full identifier for the base type is TraderSys.Portfolios.Protos.Portfolios.Portfo\", \"liosBase.\\n\\n```\\nnamespace TraderSys.Portfolios.Services; public class PortfolioService : Protos.Portf\", \"olios.PortfoliosBase { }\\n```\\n\\nThe base class declares virtual methods for Get and GetAll that can be\", \" overridden to implement the service. The methods are virtual rather than abstract so that if you do\", \"n't implement them, the service can return an explicit gRPC Unimplemented status code, much like you\", \" might throw a NotImplementedException in regular C# code.\\n\\nThe signature for all gRPC unary service\", \" methods in ASP.NET Core is consistent. There are two parameters: the first is the message type decl\", \"ared in the .proto file, and the second is a ServerCallContext that works similarly to the HttpConte\", \"xt from ASP.NET Core. In fact, there's an extension method called GetHttpContext on the ServerCallCo\", \"ntext class that you can use to get the underlying HttpContext, although you shouldn't need to use i\", \"t often. We'll take a look at ServerCallContext later in this chapter, and also in the chapter that \", \"discusses authentication.\\n\\nThe method's return type is a Task&lt;T&gt;, where T is the response mess\", \"age type. All gRPC service methods are asynchronous.\\n\\n## Migrate the PortfolioData library to .NET\\n\\n\", \"At this point, the project needs the Portfolio repository and models contained in the TraderSys.Port\", \"folioData class library in the WCF solution. The easiest way to bring them across is to create a new\", \" class library by using either the Visual Studio New project dialog box with the Class Library (.NET\", \" Standard) template, or from the command line by using the .NET CLI, running these commands from the\", \" directory that contains the TraderSys.sln file:\\n\\n```\\ndotnet new classlib -o src/TraderSys.Portfolio\", \"Data dotnet sln add src/TraderSys.PortfolioData\\n```\\n\\nAfter you've created the library and added it t\", \"o the solution, delete the generated Class1.cs file and copy the files from the WCF solution's libra\", \"ry into the new class library's folder, keeping the folder structure:\\n\\n```\\nModels Portfolio.cs Portf\", \"olioItem.cs\\n```\\n\\n```\\nIPortfolioRepository.cs PortfolioRepository.cs\\n```\\n\\nSDKstyle .NET projects auto\", \"matically include any .cs files in or under their own directory, so you don't need to explicitly add\", \" them to the project. The only step remaining is to remove the DataContract and DataMember attribute\", \"s from the Portfolio and Por tfolioItem classes so they're plain old C# classes:\\n\\n```\\npublic class P\", \"ortfolio { public int Id { get ; set ; } public Guid TraderId { get ; set ; } public List<PortfolioI\", \"tem> Items { get ; set ; } } public class PortfolioItem { public int Id { get ; set ; } public int S\", \"hareId { get ; set ; } public int Holding { get ; set ; } public decimal Cost { get ; set ; } }\\n```\\n\", \"\\n## Use ASP.NET Core dependency injection\\n\\nNow you can add a reference to this library to the gRPC a\", \"pplication project and consume the PortfolioRepository class by using dependency injection in the gR\", \"PC service implementation. In the WCF application, dependency injection was provided by the Autofac \", \"IoC container. ASP.NET Core has dependency injection baked in. You can register the repository in th\", \"e Program.cs itself:\\n\\n```\\nusing TraderSys.Portfolios.Services; var builder = WebApplication.CreateBu\", \"ilder(args); // Register the repository class as a scoped service (instance per request) builder.Ser\", \"vices.AddScoped<IPortfolioRepository, PortfolioRepository>(); builder.Services.AddGrpc(); var app = \", \"builder.Build(); // Configure the HTTP request pipeline. app.MapGrpcService<PortfolioService>(); app\", \".MapGet(\\\"/\\\", () => \\\"Communication with gRPC endpoints must be made through a gRPC client. To learn h\", \"ow to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909\\\"); app.Run();\\n```\\n\\nThe\", \" IPortfolioRepository implementation can now be specified as a constructor parameter in the Portfoli\", \"oService class, as follows:\\n\\n```\\n47 public class PortfolioService : Protos.Portfolios.PortfoliosBase\", \" { private readonly IPortfolioRepository _repository; public PortfolioService(IPortfolioRepository r\", \"epository) {\\n```\\n\\n```\\n_repository = repository; } }\\n```\\n\\n## Implement the gRPC service\\n\\nNow that you\", \"'ve declared your messages and your service in the portfolios.proto file, you have to implement the \", \"service methods in the PortfolioService class that inherits from the gRPC-generated Portfolios.Portf\", \"oliosBase class. The methods are declared as virtual in the base class. If you don't override them, \", \"they'll return a gRPC 'Not Implemented' status code by default.\\n\\nStart by implementing the Get metho\", \"d. The default override looks like this example:\\n\\n```\\npublic override Task<GetResponse> Get(GetReque\", \"st request, ServerCallContext context) { return base .Get(request, context); }\\n```\\n\\nThe first proble\", \"m is that request.TraderId is a string, and the service requires a Guid. Even though the expected fo\", \"rmat for the string is UUID, the code has to deal with the possibility that a caller has sent an inv\", \"alid value and respond appropriately. The service can respond with errors by throwing an RpcExceptio\", \"n and use the standard InvalidArgument status code to express the problem:\\n\\n```\\npublic override Task\", \"<GetResponse> Get(GetRequest request, ServerCallContext context) { if (!Guid.TryParse(request.Trader\", \"Id, out var traderId)) { throw new RpcException( new Status(StatusCode.InvalidArgument, \\\"traderId mu\", \"st be a UUID\\\")); } return base .Get(request, context); }\\n```\\n\\nAfter there's a proper Guid value for \", \"traderId, you can use the repository to retrieve the Portfolio and return it to the client:\\n\\n```\\nvar\", \" response = new GetResponse { Portfolio = await _repository.GetAsync(request.TraderId, request.Portf\", \"olioId) };\\n```\\n\\n## Map internal models to gRPC messages\\n\\nThe previous code doesn't actually work bec\", \"ause the repository is returning its own POCO model Portfolio, but gRPC needs its own Protobuf messa\", \"ge Portfolio. As when you map Entity Framework types to data transfer types, the best solution is to\", \" provide a conversion between the two. A good place to put the code for this conversion is in the Pr\", \"otobuf-generated class, which is declared as a partial class so it can be extended:\\n\\n```\\nnamespace T\", \"raderSys.Portfolios.Protos; public partial class PortfolioItem { public static PortfolioItem FromRep\", \"ositoryModel(PortfolioData.Models.PortfolioItem\\n```\\n\\n```\\nsource) { if (source is null ) return null \", \"; return new PortfolioItem { Id = source.Id, ShareId = source.ShareId, Holding = source.Holding, Cos\", \"tCents = (int)(source.Cost * 100) }; } } public partial class Portfolio { public static Portfolio Fr\", \"omRepositoryModel(PortfolioData.Models.Portfolio source) { if (source is null ) return null ; var ta\", \"rget = new Portfolio { Id = source.Id, TraderId = source.TraderId.ToString(), }; target.Items.AddRan\", \"ge(source.Items.Select(PortfolioItem.FromRepositoryModel)); return target; } }\\n```\\n\\n## Note\\n\\nYou cou\", \"ld use a library like AutoMapper to handle this conversion from internal model classes to Protobuf t\", \"ypes, as long as you configure the lower-level type conversions like string/Guid or decimal/double a\", \"nd the list mapping.\\n\\nNow that you have the conversion code in place, you can complete the Get metho\", \"d implementation:\\n\\n```\\npublic override async Task<GetResponse> Get(GetRequest request, ServerCallCon\", \"text context) { if (!Guid.TryParse(request.TraderId, out var traderId)) { throw new RpcException( ne\", \"w Status(StatusCode.InvalidArgument, \\\"traderId must be a UUID\\\")); } var portfolio = await _repositor\", \"y.GetAsync(traderId, request.PortfolioId); return new GetResponse { Portfolio = Portfolio.FromReposi\", \"toryModel(portfolio) }; }\\n```\\n\\nThe implementation of the GetAll method is similar. Note that the rep\", \"eated fields on Protobuf messages are generated as readonly properties of type RepeatedField&lt;T&gt\", \";, so you have to add items to them by using the AddRange method, like in this example:\\n\\n```\\npublic \", \"override async Task<GetAllResponse> GetAll(GetAllRequest request, ServerCallContext context) { if (!\", \"Guid.TryParse(request.TraderId, out var traderId)) { throw new RpcException( new Status(StatusCode.I\", \"nvalidArgument, \\\"traderId must be a UUID\\\")); } var portfolios = await _repository.GetAllAsync(trader\", \"Id); var response = new GetAllResponse(); response.Portfolios.AddRange(portfolios.Select(Portfolio.F\", \"romRepositoryModel)); return response; }\\n```\\n\\nHaving successfully migrated the WCF requestreply serv\", \"ice to gRPC, let's look at creating a client for it from the .proto file.\\n\\n## Generate client code\\n\\n\", \"Create a .NET Standard class library in the same solution to contain the client. This is primarily a\", \"n example of creating client code, but you could package such a library by using NuGet and distribut\", \"e it on an internal repository for other .NET teams to consume. Go ahead and add a new .NET Standard\", \" class library called TraderSys.Portfolios.Client to the solution and delete the Class1.cs file.\\n\\n##\", \" Caution\\n\\nThe Grpc.Net.Client NuGet package requires .NET Core 3.0 or later (or another .NET Standar\", \"d 2.1compliant runtime). Earlier versions of .NET Framework and .NET Core are supported by the Grpc.\", \"Core NuGet package.\\n\\nIn Visual Studio 2022, you can add references to gRPC services in a way that's \", \"similar to how you'd add service references to WCF projects in earlier versions of Visual Studio. Se\", \"rvice references and connected services are all managed under the same UI now. You can access the UI\", \" by right-clicking the Dependencies node in the TraderSys.Portfolios.Client project in Solution Expl\", \"orer and selecting Manage Connected Service . In the tool window that appears, select the Connected \", \"Services section, then select Add a service reference in Service References section, select gRPC and\", \" click Next:\\n\\nConnected Services\\n\\nPublish\\n\\nService Dependencies\\n\\nThere are currently no service depe\", \"ndencies configured.\\n\\nAdd a service dependency\\n\\nAdd service reference\\n\\nSelect a service reference to\", \" add to your application\\n\\nOpenAPI\\n\\n+ gRPC\\n\\nWCF Web Service\\n\\nBrowse to the portfolios.proto file in t\", \"he TraderSys.Portfolios project, leave Client under Select the type of class to be generated , and t\", \"hen select OK :\\n\\n+027...\\n\\nAdd new gRPC service reference\\n\\nSelect a file or URL\\n\\n\\u2022 File\\n\\n\\u2022 URL\\n\\nSelec\", \"t the type of class to be generated\\n\\nClient\\n\\nWhen you use the Visual Studio Add Connected Service fe\", \"ature, the portfolios.proto file is added to the class library project as a linked file rather than \", \"copied, so changes to the file in the service project will automatically be applied in the client pr\", \"oject. The &lt;Protobuf&gt; element in the csproj file looks like this:\\n\\n&lt; Protobuf Include=\\\"..\\\\T\", \"raderSys.Portfolios\\\\Protos\\\\portfolios.proto\\\" GrpcServices=\\\"Client\\\"&gt; &lt; Link &gt;Protos\\\\portfoli\", \"os.proto&lt;/ Link &gt; &lt;/ Protobuf &gt;\\n\\n## Use the Portfolios service from a client application\", \"\\n\\nThe following code is a brief example of how to use the generated client in a console application.\", \" A more detailed exploration of the gRPC client code is at the end of this chapter.\\n\\n```\\npublic clas\", \"s Program { public async Task Main(string[] args) { GetResponse response; using (var channel = GrpcC\", \"hannel.ForAddress(\\\"https://localhost:5001\\\")) { var client = new Protos.Portfolios.PortfoliosClient(c\", \"hannel); response = await client.GetAsync( new GetRequest { TraderId = args[0], PortfolioId = int.Pa\", \"rse(args[1]) }); } foreach (var item in response.Portfolio.Items) { Console.WriteLine($\\\"Holding {ite\", \"m.Holding} of Share ID {item.ShareId}.\\\"); } } }\\n```\\n\\nYou've now migrated a basic WCF application to \", \"an ASP.NET Core gRPC service and created a client to consume the service from a .NET application. Th\", \"e next section will cover the more involved duplex services.\\n\\n## Migrate WCF duplex services to gRPC\", \"\\n\\nNow that you have a sense of the basic concepts, in this section, you'll look at the more complica\", \"ted streaming gRPC services.\\n\\nThere are multiple ways to use duplex services in Windows Communicatio\", \"n Foundation (WCF). Some services are initiated by the client and then they stream data from the ser\", \"ver. Other full-duplex services might involve more ongoing two-way communication, like the classic C\", \"alculator example in the WCF documentation. This chapter will take two possible WCF stock ticker imp\", \"lementations and migrate them to gRPC: one that uses a server streaming RPC and another one that use\", \"s a bidirectional streaming RPC.\\n\\n## Server streaming RPC\\n\\nIn the sample SimpleStockTicker WCF solut\", \"ion , SimpleStockPriceTicker, there's a duplex service for which the client starts the connection wi\", \"th a list of stock symbols, and the server uses the callback interface to send updates as they becom\", \"e available. The client implements that interface to respond to calls from the server.\\n\\n## The WCF s\", \"olution\\n\\nThe WCF solution is implemented as a self-hosted Net.TCP server in a .NET Framework 4. x co\", \"nsole application.\\n\\n## ServiceContract\\n\\n```\\n[ServiceContract(SessionMode = SessionMode.Required, Cal\", \"lbackContract = typeof (ISimpleStockTickerCallback))] public interface ISimpleStockTickerService { [\", \"OperationContract(IsOneWay = true )] void Subscribe(string[] symbols); }\\n```\\n\\nThe service has a sing\", \"le method with no return type because it uses the callback interface ISimpleStockTickerCallback to s\", \"end data to the client in real time.\\n\\n## The callback interface\\n\\n```\\n[ServiceContract] public interf\", \"ace ISimpleStockTickerCallback { [OperationContract(IsOneWay = true )] void Update(string symbol, de\", \"cimal price); }\\n```\\n\\nYou can find the implementations of these interfaces in the solution, along wit\", \"h faked external dependencies to provide test data.\\n\\n## gRPC streaming\\n\\nThe gRPC process for handlin\", \"g real-time data is different from the WCF process. A call from client to server can create a persis\", \"tent stream, which can be monitored for messages that arrive asynchronously. Despite the difference,\", \" streams can be a more intuitive way of dealing with this data and are more relevant in modern progr\", \"amming, which emphasizes LINQ, Reactive Streams, functional programming, and so on.\\n\\nThe service def\", \"inition needs two messages: one for the request and one for the stream. The service returns a stream\", \" of the StockTickerUpdate message with the stream keyword in its return declaration. We recommend th\", \"at you add a Timestamp to the update to show the exact time of the price change.\\n\\n## simple_stock_ti\", \"cker.proto\\n\\n```\\nsyntax = \\\"proto3\\\"; option csharp_namespace = \\\"TraderSys.SimpleStockTickerServer.Prot\", \"os\\\"; import \\\"google/protobuf/timestamp.proto\\\"; package SimpleStockTickerServer; service SimpleStockT\", \"icker { rpc Subscribe (SubscribeRequest) returns (stream StockTickerUpdate); } message SubscribeRequ\", \"est { repeated string symbols = 1; } message StockTickerUpdate {\\n```\\n\\n```\\nstring symbol = 1; int32 p\", \"rice_cents = 2; google.protobuf.Timestamp time = 3; }\\n```\\n\\n## Implement SimpleStockTicker\\n\\nReuse the\", \" fake StockPriceSubscriber from the WCF project by copying the three classes from the TraderSys.Stoc\", \"kMarket class library into a new .NET Standard class library in the target solution. To better follo\", \"w best practices, add a Factory type to create instances of it, and register the IStockPriceSubscrib\", \"erFactory with the ASP.NET Core dependency injection services.\\n\\n## The factory implementation\\n\\n```\\np\", \"ublic interface IStockPriceSubscriberFactory { IStockPriceSubscriber GetSubscriber(string[] symbols)\", \"; } public class StockPriceSubscriberFactory : IStockPriceSubscriberFactory { public IStockPriceSubs\", \"criber GetSubscriber(string[] symbols) { return new StockPriceSubscriber(symbols); } }\\n```\\n\\n## Regis\", \"ter the factory\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); // Additional configuration i\", \"s required to successfully run gRPC on macOS. // For instructions on how to configure Kestrel and gR\", \"PC clients on macOS, visit https://go.microsoft.com/fwlink/?linkid=2099682 // Add services to the co\", \"ntainer. // Register the factory builder.Services.AddSingleton<IStockPriceSubscriberFactory, StockPr\", \"iceSubscriberFactory>(); builder.Services.AddGrpc(); var app = builder.Build(); // Configure the HTT\", \"P request pipeline. app.MapGrpcService<StockTickerService>(); app.MapGet(\\\"/\\\", async context => { awa\", \"it context.Response.WriteAsync(\\\"Communication with gRPC endpoints must be made through a gRPC client\", \". To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909\\\"); }); app\", \".Run();\\n```\\n\\nThis class can now be used to implement the gRPC StockTickerService.\\n\\n## StockTickerSer\", \"vice.cs\\n\\n```\\npublic class StockTickerService : Protos.SimpleStockTicker.SimpleStockTickerBase { priv\", \"ate readonly IStockPriceSubscriberFactory _subscriberFactory; public StockTickerService(IStockPriceS\", \"ubscriberFactory subscriberFactory) { _subscriberFactory = subscriberFactory; } public override asyn\", \"c Task Subscribe(SubscribeRequest request, IServerStreamWriter<StockTickerUpdate> responseStream, Se\", \"rverCallContext context) { var subscriber = _subscriberFactory.GetSubscriber(request.Symbols.ToArray\", \"()); subscriber.Update += async (sender, args) => await WriteUpdateAsync(responseStream, args.Symbol\", \", args.Price); await AwaitCancellation(context.CancellationToken); } private async Task WriteUpdateA\", \"sync(IServerStreamWriter<StockTickerUpdate> stream, string symbol, decimal price) { try { await stre\", \"am.WriteAsync( new StockTickerUpdate { Symbol = symbol, PriceCents = (int)(price * 100), Time = Time\", \"stamp.FromDateTimeOffset(DateTimeOffset.UtcNow) }); } catch (Exception e) { // Handle any errors cau\", \"sed by broken connection, etc. _logger.LogError($\\\"Failed to write message: {e.Message}\\\"); } } privat\", \"e static Task AwaitCancellation(CancellationToken token) { var completion = new TaskCompletionSource\", \"<object>(); token.Register(() => completion.SetResult( null )); return completion.Task; } }\\n```\\n\\nAs \", \"you can see, although the declaration in the .proto file says the method returns a stream of StockTi\", \"ckerUpdate messages, it actually returns a Task. The job of creating the stream is handled by the ge\", \"nerated code and the gRPC runtime libraries, which provide the IServerStreamWriter&lt;StockTickerUpd\", \"ate&gt; response stream, ready to use.\\n\\nUnlike a WCF duplex service, where the instance of the servi\", \"ce class is kept alive while the connection is open, the gRPC service uses the returned task to keep\", \" the service alive. The task shouldn't complete until the connection is closed.\\n\\nThe service can tel\", \"l when the client has closed the connection by using the CancellationToken from the ServerCallContex\", \"t. A simple static method, AwaitCancellation, is used to create a task that completes when the token\", \" is canceled.\\n\\nIn the Subscribe method, then, get a StockPriceSubscriber and add an event handler th\", \"at writes to the response stream. Then wait for the connection to be closed before immediately dispo\", \"sing the subscriber to prevent it from trying to write data to the closed stream.\\n\\nThe WriteUpdateAs\", \"ync method has a try/catch block to handle any errors that might happen when a message is written to\", \" the stream. This consideration is important in persistent connections over networks, which could be\", \" broken at any millisecond, whether intentionally or because of a failure somewhere.\\n\\n## Use StockTi\", \"ckerService from a client application\\n\\nFollow the same steps in the previous section to create a sha\", \"reable client class library from the .proto file. In the sample, there's a .NET console application \", \"that demonstrates how to use the client.\\n\\n## Example Program.cs\\n\\n```\\nclass Program { static async Ta\", \"sk Main(string[] args) { using var channel = GrpcChannel.ForAddress(\\\"https://localhost:5001\\\"); var c\", \"lient = new SimpleStockTicker.SimpleStockTickerClient(channel); var request = new SubscribeRequest()\", \"; request.Symbols.AddRange(args); using var stream = client.Subscribe(request); var tokenSource = ne\", \"w CancellationTokenSource(); var task = DisplayAsync(stream.ResponseStream, tokenSource.Token); Wait\", \"ForExitKey(); tokenSource.Cancel(); await task; } }\\n```\\n\\nIn this case, the Subscribe method on the g\", \"enerated client isn't asynchronous. The stream is created and usable right away because its MoveNext\", \" method is asynchronous and the first time it's called it won't complete until the connection is ali\", \"ve.\\n\\nThe stream is passed to an asynchronous DisplayAsync method. The application then waits for the\", \" user to press a key, and then cancels the DisplayAsync method and waits for the task to complete be\", \"fore exiting.\\n\\n## Note\\n\\nThis code uses the new C# 8 using declaration syntax to dispose of the strea\", \"m and the channel when the Main method exits. It's a small change, but a nice one that reduces inden\", \"tations and empty lines.\\n\\n## Consume the stream\\n\\nWCF uses callback interfaces to allow the server to\", \" call methods directly on the client. gRPC streams work differently. The client iterates over the re\", \"turned stream and processes messages, just as though they were returned from a local method returnin\", \"g an IEnumerable.\\n\\nThe IAsyncStreamReader&lt;T&gt; type works much like an IEnumerator&lt;T&gt;. The\", \"re's a MoveNext method that returns true as long as there's more data, and a Current property that r\", \"eturns the latest value. The only difference is that the MoveNext method returns a Task&lt;bool&gt; \", \"instead of just a bool. The ReadAllAsync extension method wraps the stream in a standard C# 8 IAsync\", \"Enumerable that can be used with the new await foreach syntax.\\n\\n```\\nstatic async Task DisplayAsync(I\", \"AsyncStreamReader<StockTickerUpdate> stream, CancellationToken token) { try { await foreach (var upd\", \"ate in stream.ReadAllAsync(token)) { Console.WriteLine($\\\"{update.Symbol}: {update.Price}\\\"); } } catc\", \"h (RpcException e) when (e.StatusCode == StatusCode.Cancelled) { return ; } catch (OperationCanceled\", \"Exception) { Console.WriteLine(\\\"Finished.\\\"); } }\\n```\\n\\n## Tip\\n\\nFor developers using reactive programm\", \"ing patterns, the section on client libraries at the end of this chapter shows how to add an extensi\", \"on method and classes to wrap IAsyncStreamReader&lt;T&gt; in an IObservable&lt;T&gt;.\\n\\nAgain, be sur\", \"e to catch exceptions here because of the possibility of network failure, and because of the Operati\", \"onCanceledException that will inevitably be thrown because the code is using a CancellationToken to \", \"break the loop. The RpcException type has a lot of useful information about gRPC runtime errors, inc\", \"luding the StatusCode. For more information, see Error handling in Chapter 4.\\n\\n## Bidirectional stre\", \"aming\\n\\nA WCF full-duplex service allows for asynchronous, real-time messaging in both directions. In\", \" the server streaming example, the client starts a request and then receives a stream of updates. A \", \"better\\n\\nversion of that service would allow the client to add and remove stocks from the list withou\", \"t having to stop and create a new subscription. That functionality has been implemented in the FullS\", \"tockTicker sample solution.\\n\\nThe IFullStockTickerService interface provides three methods:\\n\\n- Subscr\", \"ibe starts the connection.\\n- AddSymbol adds a stock symbol to watch.\\n- RemoveSymbol removes a symbol\", \" from the watched list.\\n\\n```\\n[ServiceContract(SessionMode = SessionMode.Required, CallbackContract =\", \" typeof (IFullStockTickerCallback))] public interface IFullStockTickerService { [OperationContract(I\", \"sOneWay = true )] void Subscribe(); [OperationContract(IsOneWay = true )] void AddSymbol(string symb\", \"ol); [OperationContract(IsOneWay = true )] void RemoveSymbol(string symbol); }\\n```\\n\\nThe callback int\", \"erface remains the same.\\n\\nImplementing this pattern in gRPC is less straightforward because there ar\", \"e now two streams of data with messages being passed: one from client to server and another from ser\", \"ver to client. It isn't possible to use multiple methods to implement the add and remove operations,\", \" but you can pass more than one type of message on a single stream by using either the Any type or t\", \"he oneof keyword, which were covered in Chapter 3.\\n\\nIn a case where there's a specific set of types \", \"that are acceptable, oneof is a better way to go. Use an ActionMessage that can hold either an AddSy\", \"mbolRequest or a RemoveSymbolRequest:\\n\\n```\\nmessage ActionMessage { oneof action { AddSymbolRequest a\", \"dd = 1; RemoveSymbolRequest remove = 2; } } message AddSymbolRequest { string symbol = 1; } message \", \"RemoveSymbolRequest { string symbol = 1; }\\n```\\n\\nDeclare a bidirectional streaming service that takes\", \" a stream of ActionMessage messages:\\n\\n```\\nservice FullStockTicker { rpc Subscribe (stream ActionMess\", \"age) returns (stream StockTickerUpdate); }\\n```\\n\\nThe implementation for this service is similar to th\", \"at of the previous example, except the first parameter of the Subscribe method is now an IAsyncStrea\", \"mReader&lt;ActionMessage&gt;, which can be used to handle the Add and Remove requests:\\n\\n```\\npublic o\", \"verride async Task Subscribe(IAsyncStreamReader<ActionMessage> requestStream, IServerStreamWriter<St\", \"ockTickerUpdate> responseStream, ServerCallContext context) { using var subscriber = _subscriberFact\", \"ory.GetSubscriber(); subscriber.Update += async (sender, args) => await WriteUpdateAsync(responseStr\", \"eam, args.Symbol, args.Price); var actionsTask = HandleActions(requestStream, subscriber, context.Ca\", \"ncellationToken); _logger.LogInformation(\\\"Subscription started.\\\"); await AwaitCancellation(context.C\", \"ancellationToken); try { await actionsTask; } catch { /* Ignored */ } _logger.LogInformation(\\\"Subscr\", \"iption finished.\\\"); } private async Task WriteUpdateAsync(IServerStreamWriter<StockTickerUpdate> str\", \"eam, string symbol, decimal price) { try { await stream.WriteAsync( new StockTickerUpdate { Symbol =\", \" symbol, PriceCents = (int)(price * 100), Time = Timestamp.FromDateTimeOffset(DateTimeOffset.UtcNow)\", \" }); } catch (Exception e) { // Handle any errors caused by broken connection, etc. _logger.LogError\", \"($\\\"Failed to write message: {e.Message}\\\"); } } private static Task AwaitCancellation(CancellationTok\", \"en token) { var completion = new TaskCompletionSource<object>(); token.Register(() => completion.Set\", \"Result( null )); return completion.Task; }\\n```\\n\\nThe ActionMessage class that gRPC has generated guar\", \"antees that only one of the Add and Remove properties can be set. Finding which one isn't null is a \", \"valid way to determine which type of message is used, but there's a better way. The code generation \", \"also created an enum ActionOneOfCase in the ActionMessage class, which looks like this:\\n\\n```\\npublic \", \"enum ActionOneofCase { None = 0, Add = 1, Remove = 2, }\\n```\\n\\nThe property ActionCase on the ActionMe\", \"ssage object can be used with a switch statement to determine which field is set:\\n\\n```\\nprivate async\", \" Task HandleActions(IAsyncStreamReader<ActionMessage> requestStream, IFullStockPriceSubscriber subsc\", \"riber, CancellationToken token) { await foreach (var action in requestStream.ReadAllAsync(token)) { \", \"switch (action.ActionCase) { case ActionMessage.ActionOneofCase.None: _logger.LogWarning(\\\"No Action \", \"specified.\\\"); break ; case ActionMessage.ActionOneofCase.Add: subscriber.Add(action.Add.Symbol); bre\", \"ak ; case ActionMessage.ActionOneofCase.Remove: subscriber.Remove(action.Remove.Symbol); break ; def\", \"ault : _logger.LogWarning($\\\"Unknown Action '{action.ActionCase}'.\\\"); break ; } } }\\n```\\n\\n## Tip\\n\\nThe \", \"switch statement has a default case that logs a warning if it encounters an unknown ActionOneOfCase \", \"value. This could be useful to indicate that a client is using a later version of the .proto file th\", \"at has added more actions. This is one reason why using a switch is better than testing for null on \", \"known fields.\\n\\n## Use FullStockTickerService from a client application\\n\\nThere's a simple .NET WPF ap\", \"plication that demonstrates the use of this more complex client. You can find the full application o\", \"n GitHub.\\n\\nThe client is used in the MainWindowViewModel class, which gets an instance of the FullSt\", \"ockTicker.FullStockTickerClient type from dependency injection:\\n\\n```\\npublic class MainWindowViewMode\", \"l : IAsyncDisposable, INotifyPropertyChanged { private readonly FullStockTicker.FullStockTickerClien\", \"t _client; private readonly AsyncDuplexStreamingCall<ActionMessage, StockTickerUpdate> _duplexStream\", \"; private readonly CancellationTokenSource _cancellationTokenSource; private readonly Task _response\", \"Task; private string _addSymbol; public MainWindowViewModel(FullStockTicker.FullStockTickerClient cl\", \"ient) { _cancellationTokenSource = new CancellationTokenSource(); _client = client; _duplexStream = \", \"_client.Subscribe(); _responseTask = HandleResponsesAsync(_cancellationTokenSource.Token);\\n```\\n\\n```\\n\", \"AddCommand = new AsyncCommand(Add, CanAdd); }\\n```\\n\\nThe object returned by the client.Subscribe() met\", \"hod is now an instance of the gRPC library type AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;,\", \" which provides a RequestStream for sending requests to the server and a ResponseStream for handling\", \" responses.\\n\\nThe request stream is used from some WPF ICommand methods to add and remove symbols. Fo\", \"r each operation, set the relevant field on an ActionMessage object:\\n\\n```\\nprivate async Task Add() {\", \" if (CanAdd()) { await _duplexStream.RequestStream.WriteAsync( new ActionMessage {Add = new AddSymbo\", \"lRequest {Symbol = AddSymbol}}); } } public async Task Remove(PriceViewModel priceViewModel) { await\", \" _duplexStream.RequestStream.WriteAsync( new ActionMessage {Remove = new RemoveSymbolRequest {Symbol\", \" = priceViewModel.Symbol}}); Prices.Remove(priceViewModel); }\\n```\\n\\n## Important\\n\\nSetting a oneof fie\", \"ld's value on a message automatically clears any fields that have been set previously.\\n\\nThe stream o\", \"f responses is handled in an async method. The Task it returns is held to be disposed when the windo\", \"w is closed:\\n\\n```\\nprivate async Task HandleResponsesAsync(CancellationToken token) { var stream = _d\", \"uplexStream.ResponseStream; try { await foreach (var update in stream.ReadAllAsync(token)) { var pri\", \"ce = Prices.FirstOrDefault(p => p.Symbol.Equals(update.Symbol)); if (price == null ) { price = new P\", \"riceViewModel( this ) {Symbol = update.Symbol, Price = update.PriceCents / 100m}; Prices.Add(price);\", \" } else { price.Price = update.PriceCents / 100m; } } }\\n```\\n\\n```\\ncatch (OperationCancelledException)\", \" { } }\\n```\\n\\n## Client cleanup\\n\\nWhen the window is closed and the MainWindowViewModel is disposed (fr\", \"om the Closed event of MainWindow), we recommend that you properly dispose the AsyncDuplexStreamingC\", \"all object. In particular, the CompleteAsync method on the RequestStream should be called to gracefu\", \"lly close the stream on the server. This example shows the DisposeAsync method from the sample view-\", \"model:\\n\\n```\\npublic async ValueTask DisposeAsync() { try { await _duplexStream.RequestStream.Complete\", \"Async().ConfigureAwait( false ); await _responseTask.ConfigureAwait( false ); } finally { _duplexStr\", \"eam.Dispose(); } }\\n```\\n\\nClosing request streams enables the server to dispose of its own resources i\", \"n a timely way. This improves the efficiency and scalability of services and prevents exceptions.\\n\\n#\", \"# gRPC streaming services vs. repeated fields\\n\\ngRPC services provide two ways of returning datasets,\", \" or lists of objects. The Protocol Buffers message specification uses the repeated keyword for decla\", \"ring lists or arrays of messages within another message. The gRPC service specification uses the str\", \"eam keyword to declare a long-running persistent connection. Over that connection, multiple messages\", \" are sent, and can be processed, individually.\\n\\nYou can also use the stream feature for long-running\", \" temporal data such as notifications or log messages. But this chapter will consider its use for ret\", \"urning a single dataset.\\n\\nWhich you should use depends on factors such as:\\n\\n- The overall size of th\", \"e dataset.\\n- The time it took to create the dataset at either the client or server end.\\n- Whether th\", \"e consumer of the dataset can start acting on it as soon as the first item is available, or needs th\", \"e complete dataset to do anything useful.\\n\\n## When to use repeated fields\\n\\nFor any dataset that's co\", \"nstrained in size and that can be generated in its entirety in a short timesay, under one second -yo\", \"u should use a repeated field in a regular Protobuf message. For example, in an e-commerce system, t\", \"o build a list of items within an order is probably quick and the list won't be very large. Returnin\", \"g a single message with a repeated field is an order of magnitude faster than using stream and incur\", \"s less network overhead.\\n\\nIf the client needs all the data before starting to process it and the dat\", \"aset is small enough to construct in memory, then consider using a repeated field. Consider it even \", \"if the creation of the dataset in memory on the server is slower.\\n\\n## When to use stream methods\\n\\nWh\", \"en the message objects in your datasets are potentially very large, it's best for you transfer them \", \"by using streaming requests or responses. It's more efficient to construct a large object in memory,\", \" write it to the network, and then free up the resources. This approach will improve the scalability\", \" of your service.\\n\\nSimilarly, you should send datasets of unconstrained size over streams to avoid r\", \"unning out of memory while constructing them.\\n\\nFor datasets where the consumer can separately proces\", \"s each item, you should consider using a stream if it means that progress can be indicated to the us\", \"er. Using a stream can improve the responsiveness of an application, but you should balance it again\", \"st the overall performance of the application.\\n\\nAnother scenario where streams can be useful is wher\", \"e a message is being processed across multiple services. If each service in a chain returns a stream\", \", then the terminal service (that is, the last one in the chain) can start returning messages. These\", \" messages can be processed and passed back along the chain to the original requestor. The requestor \", \"can either return a stream or aggregate the results into a single response message. This approach le\", \"nds itself well to patterns like MapReduce.\\n\\n## Create gRPC client libraries\\n\\nIt isn't necessary to \", \"distribute client libraries for a gRPC application. You can create a shared library of .proto files \", \"within your organization, and other teams can use those files to generate client code in their own p\", \"rojects. But if you have a private NuGet repository and many other teams are using .NET, you can cre\", \"ate and publish client NuGet packages as part of your service project. This approach can be a good w\", \"ay of sharing and promoting your service.\\n\\nOne advantage of distributing a client library is that yo\", \"u can enhance the generated gRPC and Protobuf classes with helpful 'convenience' methods and propert\", \"ies. In the client code, as in the server, all the classes are declared as partial, so you can exten\", \"d them without editing the generated code. This behavior means it's easy to add constructors, method\", \"s, and calculated properties to the basic types.\\n\\n| Caution                                         \", \"                                                                                                    \", \"                                                                                                    \", \"        |\\n|-----------------------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"--------------------------------------------------------------------|\\n| You shouldn't use custom cod\", \"e to provide essential functionality. You don't want to restrict that essential functionality to .NE\", \"T teams that use the shared library, and not provide it to teams that use other languages or platfor\", \"ms, such as Python or Java. |\\n\\nEnsure that as many teams as possible can access your gRPC service. T\", \"he best way to do this functionality is to share .proto files so developers can generate their own c\", \"lients. This approach is\\n\\nparticularly true in a multi-platform environment, where different teams f\", \"requently use different programming languages and frameworks, or where your API is externally access\", \"ible.\\n\\n## Useful extensions\\n\\nThere are two commonly used interfaces in .NET for dealing with streams\", \" of objects: IEnumerable and IObservable . Starting with .NET Core 3.0 and C# 8.0, there's an IAsync\", \"Enumerable interface for processing streams asynchronously, and an await foreach syntax for using th\", \"e interface. This section presents reusable code for applying these interfaces to gRPC streams.\\n\\nWit\", \"h the .NET gRPC client libraries, there's a ReadAllAsync extension method for IAsyncStreamReader&lt;\", \"T&gt; that creates an IAsyncEnumerable&lt;T&gt; interface. For developers using reactive programming\", \", an equivalent extension method to create an IObservable&lt;T&gt; interface might look like the exa\", \"mple in the following section.\\n\\n## IObservable\\n\\nThe IObservable&lt;T&gt; interface is the 'reactive'\", \" inverse of IEnumerable&lt;T&gt;. Rather than pulling items from a stream, the reactive approach let\", \"s the stream push items to a subscriber. This behavior is very similar to gRPC streams, and it's eas\", \"y to wrap an IObservable&lt;T&gt; interface around an IAsyncStreamReader&lt;T&gt; interface.\\n\\nThis c\", \"ode is longer than the IAsyncEnumerable&lt;T&gt; code, because C# doesn't have built -in support for\", \" working with observables. You have to create the implementation class manually. It's a generic clas\", \"s, though, so a single implementation works across all types.\\n\\n```\\nnamespace Grpc.Core; public class\", \" GrpcStreamObservable<T> : IObservable<T> { private readonly IAsyncStreamReader<T> _reader; private \", \"readonly CancellationToken _token; private int _used; public GrpcStreamObservable(IAsyncStreamReader\", \"<T> reader, CancellationToken token = default ) { _reader = reader ?? throw new ArgumentNullExceptio\", \"n(nameof(reader)); _token = token; _used = 0; } public IDisposable Subscribe(IObserver<T> observer) \", \"=> Interlocked.Exchange( ref _used, 1) == 0 ? new GrpcStreamSubscription<T>(_reader, observer, _toke\", \"n) : throw new InvalidOperationException(\\\"Subscribe can only be called once.\\\"); }\\n```\\n\\n## Important\\n\", \"\\nThis observable implementation allows the Subscribe method to be called only once, because having m\", \"ultiple subscribers trying to read from the stream would result in chaos. There are operators, such \", \"as Replay in the System.Reactive.Linq, that enable buffering and repeatable sharing of observables, \", \"which can be used with this implementation.\\n\\nThe GrpcStreamSubscription class handles the enumeratio\", \"n of the IAsyncStreamReader:\\n\\n```\\npublic class GrpcStreamSubscription<T> : IDisposable { private rea\", \"donly IAsyncStreamReader<T> _reader; private readonly IObserver<T> _observer; private readonly Cance\", \"llationTokenSource _tokenSource; private readonly Task _task; private bool _completed; public GrpcSt\", \"reamSubscription(IAsyncStreamReader<T> reader, IObserver<T> observer, CancellationToken token = defa\", \"ult ) { _reader = reader ?? throw new ArgumentNullException(nameof(reader)); _observer = observer ??\", \" throw new ArgumentNullException(nameof(observer)); _tokenSource = new CancellationTokenSource(); to\", \"ken.Register(_tokenSource.Cancel); _task = Run(_tokenSource.Token); } private async Task Run(Cancell\", \"ationToken token) { while (!token.IsCancellationRequested) { try { if (!await _reader.MoveNext(token\", \")) break ; } catch (RpcException e) when (e.StatusCode == Grpc.Core.StatusCode.NotFound) { break ; }\", \" catch (OperationCanceledException) { break ; } catch (Exception e) { _observer.OnError(e); _complet\", \"ed = true ; return ; } _observer.OnNext(_reader.Current); } _completed = true ;\\n```\\n\\n```\\n_observer.O\", \"nCompleted(); } public void Dispose() { if (!_completed && !_tokenSource.IsCancellationRequested) { \", \"_tokenSource.Cancel(); } _tokenSource.Dispose(); _task.Dispose(); } }\\n```\\n\\nAll that is required now \", \"is a simple extension method to create the observable from the stream reader.\\n\\n```\\nnamespace Grpc.Co\", \"re; public static class AsyncStreamReaderObservableExtensions { public static IObservable<T> AsObser\", \"vable<T>( this IAsyncStreamReader<T> reader, CancellationToken cancellationToken = default ) => new \", \"GrpcStreamObservable<T>(reader, cancellationToken); }\\n```\\n\\n## Summary\\n\\nThe IAsyncEnumerable and IObs\", \"ervable models are both well-supported and well-documented ways of dealing with asynchronous streams\", \" of data in .NET. gRPC streams map well to both paradigms, offering close integration with .NET, and\", \" reactive and asynchronous programming styles.\\n\\n## Security in gRPC applications\\n\\nIn any real-world \", \"scenario, securing applications and services are essential. Security covers three key areas:\\n\\n- Encr\", \"ypting network traffic to prevent malicious hackers from intercepting it.\\n- Authenticating clients a\", \"nd servers to establish identity and trust.\\n- Authorizing clients to control access to systems and a\", \"pply permissions based on identity.\\n\\n## Note\\n\\nAuthentication is concerned with establishing the iden\", \"tity of a client or server. Authorization is concerned with determining whether a client has permiss\", \"ion to access a resource or issue a command.\\n\\nThis chapter will cover the facilities for authenticat\", \"ion and authorization in gRPC for ASP.NET Core. It will also discuss network security through TLS en\", \"crypted connections.\\n\\n## WCF authentication and authorization\\n\\nIn Windows Communication Foundation (\", \"WCF), authentication and authorization were handled in different ways, depending on the transports a\", \"nd bindings being used. WCF supported various WS-* security standards. It also supported Windows aut\", \"hentication for HTTP services running in IIS or NetTCP services between Windows systems.\\n\\n## gRPC au\", \"thentication and authorization\\n\\ngRPC authentication and authorization works on two levels:\\n\\n- Call-l\", \"evel authentication/authorization is usually handled through tokens that are applied in metadata whe\", \"n the call is made.\\n- Channellevel authentication uses a client certificate that's applied at the co\", \"nnection level. It can also include call-level authentication/authorization credentials to be applie\", \"d to every call on the channel automatically.\\n\\nYou can use either or both of these mechanisms to hel\", \"p secure your service.\\n\\nThe ASP.NET Core implementation of gRPC supports authentication and authoriz\", \"ation through most of the standard ASP.NET Core mechanisms:\\n\\n- Call authentication\\n- -Azure Active D\", \"irectory\\n- -IdentityServer\\n- -JWT Bearer Token\\n- -OAuth 2.0\\n- -OpenID Connect\\n- -WS-Federation\\n- Cha\", \"nnel authentication\\n- -Client certificate\\n\\nThe call authentication methods are all based on tokens .\", \" The only real difference is how the tokens are generated and the libraries that are used to validat\", \"e the tokens in the ASP.NET Core service.\\n\\nFor more information, see the Authentication and authoriz\", \"ation article.\\n\\n| Note                                                                              \", \"                                                                                         |\\n|--------\", \"----------------------------------------------------------------------------------------------------\", \"----------------------------------------------------------------|\\n| When you're using gRPC over a TL\", \"S -encrypted HTTP/2 connection, all traffic between clients and servers is encrypted, even if you do\", \"n't use channel -level authentication. |\\n\\nThis chapter will show how to apply call credentials and c\", \"hannel credentials to a gRPC service. It will also show how to use credentials from a .NET gRPC clie\", \"nt to authenticate with the service.\\n\\n## Call credentials\\n\\nCall credentials are all based on a token\", \" passed in metadata with each request.\\n\\n## WS-Federation\\n\\nASP.NET Core supports WS-Federation using \", \"the WsFederation NuGet package. WS-Federation is the closest available alternative to Windows Authen\", \"tication, which isn't supported over HTTP/2. Users are authenticated by using Active Directory Feder\", \"ation Services (AD FS), which provides a token that can be used to authenticate with ASP.NET Core.\\n\\n\", \"For more information on how to get started with this authentication method, see Authenticate users w\", \"ith WS-Federation in ASP.NET Core.\\n\\n## JWT Bearer tokens\\n\\nThe JSON Web Token (JWT) standard provides\", \" a way to encode information about a user and their claims in an encoded string. It also provides a \", \"way to sign that token, so that the consumer can verify the integrity of the token by using public k\", \"ey cryptography. You can use various services, such as IdentityServer4, to authenticate users and ge\", \"nerate OpenID Connect (OIDC) tokens to use with gRPC and HTTP APIs.\\n\\nASP.NET Core 7.0 can handle JWT\", \"s by using the JWT Bearer package. The configuration is exactly the same for a gRPC application as i\", \"t is for an ASP.NET Core MVC application. Here, we'll focus on JWT Bearer tokens, because they're ea\", \"sier to develop with than WS-Federation.\\n\\n## Add authentication and authorization to the server\\n\\nThe\", \" JWT Bearer package isn't included in ASP.NET Core 7.0 by default. Install the Microsoft.AspNetCore.\", \"Authentication.JwtBearer NuGet package in your app.\\n\\nAdd the Authentication service in the Program.c\", \"s class, and configure the JWT Bearer handler:\\n\\n```\\n// // builder.Services.AddGrpc(); var signingKey\", \" = ObtainSigningKeySomehow(); builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationSch\", \"eme) .AddJwtBearer(options => { options.TokenValidationParameters = new TokenValidationParameters { \", \"ValidateAudience = false , ValidateIssuer = false , ValidateActor = false , ValidateLifetime = true \", \", IssuerSigningKey = signingKey }; }); // //\\n```\\n\\nThe IssuerSigningKey property requires an implemen\", \"tation of\\n\\nMicrosoft.IdentityModels.Tokens.SecurityKey with the cryptographic data necessary to vali\", \"date the signed tokens. Store this token securely in a secrets server , like Azure Key Vault.\\n\\nNext,\", \" add the Authorization service, which controls access to the system:\\n\\n```\\nservices.AddAuthorization(\", \"options => { options.AddPolicy(JwtBearerDefaults.AuthenticationScheme, policy => { policy.AddAuthent\", \"icationSchemes(JwtBearerDefaults.AuthenticationScheme); policy.RequireClaim(ClaimTypes.Name); }); })\", \";\\n```\\n\\n## Tip\\n\\nAuthentication and authorization are two separate steps. You use authentication to de\", \"termine the user's identity. You use authorization to decide whether that user is allowed to access \", \"various parts of the system.\\n\\nNow add the authentication and authorization middleware to the ASP.NET\", \" Core pipeline in the Program.cs :\\n\\n```\\n// app.UseRouting(); // Authenticate, then Authorize app.Use\", \"Authentication(); app.UseAuthorization(); app.UseEndpoints(endpoints => { endpoints.MapGrpcService<P\", \"ortfolioService>(); }); }\\n```\\n\\nFinally, apply the [Authorize] attribute to any services or methods t\", \"o be secured, and use the User property from the underlying HttpContext to verify permissions.\\n\\n```\\n\", \"[Authorize] public override async Task<GetResponse> Get(GetRequest request, ServerCallContext contex\", \"t) { if (!TryValidateUser(request.TraderId, context.GetHttpContext().User)) { throw new RpcException\", \"( new Status(StatusCode.PermissionDenied, \\\"Denied.\\\")); } var portfolio = await _repository.GetAsync(\", \"traderId, request.PortfolioId); return new GetResponse { Portfolio = Portfolio.FromRepositoryModel(p\", \"ortfolio) }; }\\n```\\n\\n## Provide call credentials in the client application\\n\\nAfter you've obtained a J\", \"WT token from an identity server, you can use it to authenticate gRPC calls from the client by addin\", \"g it as a metadata header on the call, as follows:\\n\\n```\\npublic async Task ShowPortfolioAsync(int por\", \"tfolioId) { var headers = new Grpc.Core.Metadata { { \\\"Authorization\\\", $\\\"Bearer {_userToken}\\\" } }; va\", \"r request = new GetRequest { TraderId = _userId, PortfolioId = portfolioId }; var response = await _\", \"portfoliosClient.GetAsync(request, headers); // Display portfolio }\\n```\\n\\nNow you've secured your gRP\", \"C service by using JWT bearer tokens as call credentials. A version of the portfolios sample gRPC ap\", \"plication with authentication and authorization added is on GitHub.\\n\\n## Channel credentials\\n\\nAs the \", \"name implies, channel credentials are attached to the underlying gRPC channel. The standard form of \", \"channel credentials uses client certificate authentication. In this process, the client provides a T\", \"LS certificate when it's making the connection, and then the server verifies this certificate before\", \" allowing any calls to be made.\\n\\nYou can combine channel credentials with call credentials to provid\", \"e comprehensive security for a gRPC service. The channel credentials prove that the client applicati\", \"on is allowed to access the service, and the call credentials provide information about the person w\", \"ho is using the client application.\\n\\nClient certificate authentication works for gRPC the same way i\", \"t works for ASP.NET Core. For more information, see Configure certificate authentication in ASP.NET \", \"Core.\\n\\nFor development purposes you can use a self-signed certificate, but for production you should\", \" use a proper HTTPS certificate signed by a trusted authority.\\n\\n## Add certificate authentication to\", \" the server\\n\\nConfigure certificate authentication both at the host level (for example, on the Kestre\", \"l server), and in the ASP.NET Core pipeline.\\n\\n## Configure certificate validation on Kestrel\\n\\nYou ca\", \"n configure Kestrel (the ASP.NET Core HTTP server) to require a client certificate, and optionally t\", \"o carry out some validation of the supplied certificate, before accepting incoming connections. You \", \"specify this configuration in the Program.cs :\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args)\", \"; var serverCert = ObtainServerCertificate(); builder.WebHost.UseKestrel(kestrelServerOptions => { k\", \"estrelServerOptions.ConfigureHttpsDefaults(opt => { opt.ClientCertificateMode = ClientCertificateMod\", \"e.RequireCertificate; // Verify that client certificate was issued by same CA as server certificate \", \"opt.ClientCertificateValidation = (certificate, chain, errors) => certificate.Issuer == serverCert.I\", \"ssuer; }); });\\n```\\n\\nThe ClientCertificateMode.RequireCertificate setting causes Kestrel to immediate\", \"ly reject any connection request that doesn't provide a client certificate, but this setting by itse\", \"lf won't validate a certificate that is provided. Add the ClientCertificateValidation callback to en\", \"able Kestrel to validate the client certificate at the point the connection is made, before the ASP.\", \"NET Core pipeline is engaged. (In this case, the callback ensures that it was issued by the same Cer\", \"tificate Authority as the server certificate.)\\n\\n## Add ASP.NET Core certificate authentication\\n\\nThe \", \"Microsoft.AspNetCore.Authentication.Certificate NuGet package provides certificate authentication.\\n\\n\", \"Add the certificate authentication service in the Program.cs , and add authentication and authorizat\", \"ion to the ASP.NET Core pipeline.\\n\\n```\\n// builder.Services.AddAuthentication(CertificateAuthenticati\", \"onDefaults.AuthenticationScheme) .AddCertificate(options => { options.AllowedCertificateTypes = Cert\", \"ificateTypes.Chained; options.RevocationMode = X509RevocationMode.NoCheck; options.Events = new Cert\", \"ificateAuthenticationEvents { OnCertificateValidated = DevelopmentModeCertificateHelper.Validate }; \", \"}); builder.Services.AddAuthorization(); builder.Services.AddGrpc(); var app = builder.Build(); // C\", \"onfigure the HTTP request pipeline. app.UseRouting(); app.UseAuthentication(); app.UseEndpoints(endp\", \"oints => { endpoints.MapGrpcService<GreeterService>(); }); //\\n```\\n\\n## Provide channel credentials in\", \" the client application\\n\\nWith the Grpc.Net.Client package, you configure certificates on an HttpClie\", \"nt instance that is provided to the GrpcChannel used for the connection.\\n\\n## Load a client certifica\", \"te from a .PFX file\\n\\nA certificate can be loaded from a .pfx file.\\n\\n```\\nclass Program { static async\", \" Task Main(string[] args) { // Assume path to a client .pfx file and password are passed from comman\", \"d line // On Windows this would probably be a reference to the Certificate Store var cert = new X509\", \"Certificate2(args[0], args[1]); var handler = new HttpClientHandler(); handler.ClientCertificates.Ad\", \"d(cert); var httpClient = new HttpClient(handler); var channel = GrpcChannel.ForAddress(\\\"https://loc\", \"alhost:5001/\\\", new GrpcChannelOptions { HttpClient = httpClient\\n```\\n\\n```\\n}); var grpc = new Greeter.\", \"GreeterClient(channel); var response = await grpc.SayHelloAsync( new HelloRequest { Name = \\\"Bob\\\" });\", \" System.Console.WriteLine(response.Message); } }\\n```\\n\\n## Load a client certificate from certificate \", \"and private key .PEM files\\n\\nA certificate can be loaded from a certificate and private key .pem file\", \".\\n\\n```\\nclass Program { static async Task Main(string[] args) { // Assume path to a certificate and p\", \"rivate key .pem files are passed from command line string certificatePem = File.ReadAllText(args[0])\", \"; string privateKeyPem = File.ReadAllText(args[1]); var cert = X509Certificate2.CreateFromPem(certif\", \"icatePem, privateKeyPem); var handler = new HttpClientHandler(); handler.ClientCertificates.Add(cert\", \"); using HttpClient httpClient = new (handler); var channel = GrpcChannel.ForAddress(\\\"https://localh\", \"ost:5001/\\\", new GrpcChannelOptions { HttpClient = httpClient }); var grpc = new Greeter.GreeterClien\", \"t(channel); var response = await grpc.SayHelloAsync( new HelloRequest { Name = \\\"Bob\\\" }); System.Cons\", \"ole.WriteLine(response.Message); } }\\n```\\n\\n## Note\\n\\nDue to an internal Windows bug as documented here\", \" , you'll need to apply the following workaround if the certificate is created from a certificate an\", \"d private key PEM data.\\n\\n]{custom-style=Code}`csharp X509Certificate2 cert = X509Certificate2.Create\", \"FromPem(certificatePem, rsaPrivateKeyPem); if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) \", \"{ var originalCert = cert; cert = new X509Certificate2(cert.Export(X509ContentType.Pkcs12)); origina\", \"lCert.Dispose(); } [`\\n\\n## Combine ChannelCredentials and CallCredentials\\n\\nYou can configure your ser\", \"ver to use both certificate and token authentication. To do this, apply the certificate changes to t\", \"he Kestrel server, and use the JWT bearer middleware in ASP.NET Core.\\n\\nTo provide both ChannelCreden\", \"tials and CallCredentials on the client, use the ChannelCredentials.Create method to apply the call \", \"credentials. You still need to apply certificate authentication by using the HttpClient instance. If\", \" you pass any arguments to the SslCredentials\\n\\nconstructor, the internal client code throws an excep\", \"tion. The SslCredentials parameter is only included in the Grpc.Net.Client package's Create method t\", \"o maintain compatibility with the Grpc.Core package.\\n\\n```\\nvar handler = new HttpClientHandler(); han\", \"dler.ClientCertificates.Add(cert); var httpClient = new HttpClient(handler); var callCredentials = C\", \"allCredentials.FromInterceptor(((context, metadata) => { metadata.Add(\\\"Authorization\\\", $\\\"Bearer {_to\", \"ken}\\\"); return Task.CompletedTask; })); var channelCredentials = ChannelCredentials.Create( new SslC\", \"redentials(), callCredentials); var channel = GrpcChannel.ForAddress(\\\"https://localhost:5001/\\\", new \", \"GrpcChannelOptions { HttpClient = httpClient, Credentials = channelCredentials }); var grpc = new Po\", \"rtfolios.PortfoliosClient(channel);\\n```\\n\\n## Tip\\n\\nYou can use the ChannelCredentials.Create method fo\", \"r a client without certificate authentication. This is a useful way to pass token credentials with e\", \"very call made on the channel.\\n\\nA version of the FullStockTicker sample gRPC application with certif\", \"icate authentication added is on GitHub.\\n\\n## Encryption and network security\\n\\nThe network security m\", \"odel for Windows Communication Foundation (WCF) is extensive and complex. It includes transport-leve\", \"l security by using HTTPS or TLS-over-TCP, and message-level security by using the WS-Security speci\", \"fication to encrypt individual messages.\\n\\ngRPC leaves secure networking to the underlying HTTP/2 pro\", \"tocol, which you can secure by using TLS certificates.\\n\\nWeb browsers insist on using TLS connections\", \" for HTTP/2, but most programmatic clients, including .NET's HttpClient, can use HTTP/2 over unencry\", \"pted connections.\\n\\nFor public APIs, you should always use TLS connections, and provide valid certifi\", \"cates for your services from a proper SSL authority. LetsEncrypt provides free, automated SSL certif\", \"icates, and most hosting infrastructure today supports the LetsEncrypt standard with common plug-ins\", \" or extensions.\\n\\nFor internal services across a corporate network, you should still consider using T\", \"LS to secure network traffic to and from your gRPC services.\\n\\nIf you need to use explicit TLS betwee\", \"n services running in Kubernetes, consider using an in-cluster certificate authority and a certifica\", \"te manager controller like cert-manager. You can then automatically assign certificates to services \", \"at deployment time.\\n\\n## gRPC in production\\n\\nYou can run ASP.NET Core 7.0 applications, including gRP\", \"C services, on Windows, on Linux, and in containers using modern platforms like Docker and Kubernete\", \"s. This chapter explores the various options for running your gRPC services in production, and looks\", \" at monitoring and logging options to ensure the optimal operation of systems.\\n\\n## Self-hosted gRPC \", \"applications\\n\\nAlthough ASP.NET Core 7.0 applications can be hosted in IIS on Windows Server, current\", \"ly it isn't possible to host a gRPC application in IIS because some of the HTTP/2 functionality isn'\", \"t supported. This functionality is a goal for a future update to Windows Server.\\n\\nYou can run your a\", \"pplication as a Windows service. Or you can run it as a Linux service controlled by systemd, because\", \" of features introduced in the .NET 6 hosting extensions.\\n\\n## Run your app as a Windows service\\n\\nTo \", \"configure your ASP.NET Core application to run as a Windows service, install the Microsoft.Extension\", \"s.Hosting.WindowsServices package from NuGet. Then add a call to UseWindowsService to the CreateHost\", \"Builder method in Program.cs.\\n\\n```\\nHost.CreateDefaultBuilder(args) .UseWindowsService() ...\\n```\\n\\n## \", \"Note\\n\\nIf the application isn't running as a Windows service, the UseWindowsService method doesn't do\", \" anything.\\n\\nNow publish your application by using one of these methods:\\n\\n- From Visual Studio by rig\", \"ht-clicking the project and selecting Publish on the shortcut menu.\\n- From the .NET CLI.\\n\\nWhen you p\", \"ublish a .NET application, you can choose to create a framework-dependent deployment or a self-conta\", \"ined deployment. Framework-dependent deployments require the .NET Shared Runtime to be installed on \", \"the host where they're run. Self -contained deployments are published with a complete copy of the .N\", \"ET runtime and framework and can be run on any host. For more information,\\n\\nincluding the advantages\", \" and disadvantages of each approach, see the .NET application deployment documentation.\\n\\nTo publish \", \"a selfcontained build of the application that doesn't require the .NET 5 runtime to be installed on \", \"the host, specify the runtime to be included with the application. Use the -r (or --runtime) flag.\\n\\n\", \"```\\ndotnet publish -c Release -r win-x64 -o ./publish\\n```\\n\\nTo publish a framework-dependent build, o\", \"mit the -r flag.\\n\\n```\\ndotnet publish -c Release -o ./publish\\n```\\n\\nCopy the complete contents of the \", \"publish directory to an installation folder. Then, use the sc tool to create a Windows service for t\", \"he executable file.\\n\\n```\\nsc create MyService binPath=C:\\\\MyService\\\\MyService.exe\\n```\\n\\n## Log to the W\", \"indows event log\\n\\nThe UseWindowsService method automatically adds a logging provider that writes log\", \" messages to the Windows event log. You can configure logging for this provider by adding an EventLo\", \"g entry to the Logging section of appsettings.json or another configuration source.\\n\\nYou can overrid\", \"e the source name used in the event log by setting a SourceName property in these settings. If you d\", \"on't specify a name, the default application name (normally the executable assembly name) will be us\", \"ed.\\n\\nMore information on logging is at the end of this chapter.\\n\\n## Run your app as a Linux service \", \"with systemd\\n\\nTo configure your ASP.NET Core application to run as a Linux service (or daemon in Lin\", \"ux parlance), install the Microsoft.Extensions.Hosting.Systemd package from NuGet. Then add a call t\", \"o UseSystemd to the CreateHostBuilder method in Program.cs.\\n\\n```\\npublic static IHostBuilder CreateHo\", \"stBuilder(string[] args) => Host.CreateDefaultBuilder(args) .UseSystemd() // Enable running as a Sys\", \"temd service .ConfigureServices((hostContext, services) => { ... });\\n```\\n\\n## Note\\n\\nIf the applicatio\", \"n isn't running as a Linux service, the UseSystemd method doesn't do anything.\\n\\nNow publish your app\", \"lication. The application can be either framework dependent or self-contained for the relevant Linux\", \" runtime (for example, linux-x64). You can publish by using one of these methods:\\n\\n- From Visual Stu\", \"dio by right-clicking the project and selecting Publish on the shortcut menu.\\n- From the .NET CLI, b\", \"y using the following command:\\n\\n```\\ndotnet publish -c Release -r linux-x64 -o ./publish\\n```\\n\\nCopy th\", \"e complete contents of the publish directory to an installation folder on the Linux host. Registerin\", \"g the service requires a special file, called a unit file , to be added to the /etc/systemd/system d\", \"irectory. You'll need root permission to create a file in this folder. Name the file with the identi\", \"fier that you want systemd to use and the .service extension. For example, use /etc/systemd/system/m\", \"yapp.service.\\n\\nThe service file uses INI format, as shown in this example:\\n\\n```\\n[Unit] Description=M\", \"y gRPC Application [Service] Type=notify ExecStart=/usr/sbin/myapp [Install] WantedBy=multi-user.tar\", \"get\\n```\\n\\nThe Type=notify property tells systemd that the application will notify it on startup and s\", \"hutdown. The WantedBy=multi-user.target setting will cause the service to start when the Linux syste\", \"m reaches 'runlevel 2,' which means a nongraphical, multi -user shell is active.\\n\\nBefore systemd wil\", \"l recognize the service, it needs to reload its configuration. You control systemd by using the syst\", \"emctl command. After reloading, use the status subcommand to confirm that the application has regist\", \"ered successfully.\\n\\n```\\nsudo systemctl daemon-reload sudo systemctl status myapp\\n```\\n\\nIf you've conf\", \"igured the service correctly, you'll get the following output:\\n\\n```\\nmyapp.service - My gRPC Applicat\", \"ion\\n```\\n\\n```\\nLoaded: loaded (/etc/systemd/system/myapp.service; disabled; vendor preset: enabled) Ac\", \"tive: inactive (dead)\\n```\\n\\nUse the start command to start the service.\\n\\n```\\nsudo systemctl start mya\", \"pp.service\\n```\\n\\n```\\nTip The .service extension is optional when you're using systemctl start.\\n```\\n\\nT\", \"o tell systemd to start the service automatically on system startup, use the enable command.\\n\\n```\\nsu\", \"do systemctl enable myapp\\n```\\n\\n## Log to journald\\n\\nThe Linux equivalent of the Windows event log is \", \"journald, a structured logging system service that's part of systemd. Log messages written to the st\", \"andard output by a Linux daemon are automatically written to journald. To configure logging levels, \", \"use the Console section of the logging configuration. The UseSystemd host builder method automatical\", \"ly configures the console output format to suit the journal.\\n\\nBecause journald is the standard for L\", \"inux logs, a variety of tools integrate with it. You can easily route logs from journald to an exter\", \"nal logging system. Working locally on the host, you can use the journalctl command to view logs fro\", \"m the command line.\\n\\nsudo journalctl -u myapp\\n\\n## Tip\\n\\nIf you have a GUI environment available on yo\", \"ur host, a few graphical log viewers are available for Linux, such as QJournalctl and gnome-logs .\\n\\n\", \"To learn more about querying the systemd journal from the command line by using journalctl, see the \", \"manpages.\\n\\n## HTTPS certificates for self-hosted applications\\n\\nWhen you're running a gRPC applicatio\", \"n in production, you should use a TLS certificate from a trusted certificate authority (CA). This CA\", \" might be a public CA, or an internal one for your organization.\\n\\nOn Windows hosts, you can load the\", \" certificate from a secure certificate store by using the X509Store class. You can also use the X509\", \"Store class with the OpenSSL key store on some Linux hosts.\\n\\nYou can also create certificates by usi\", \"ng one of the X509Certificate2 constructors, from either:\\n\\n- A file, such as a .pfx file protected b\", \"y a strong password\\n- Binary data retrieved from a secure storage service such as Azure Key Vault\\n\\nY\", \"ou can configure Kestrel to use a certificate in two ways: from configuration or in code.\\n\\n## Set HT\", \"TPS certificates by using configuration\\n\\nThe configuration approach requires setting the password an\", \"d path to the certificate .pfx file in the Kestrel configuration section. In appsettings.json, that \", \"looks like this:\\n\\n```\\n{ \\\"Kestrel\\\": { \\\"Certificates\\\": { \\\"Default\\\": { \\\"Path\\\": \\\"cert.pfx\\\", \\\"Password\\\": \", \"\\\"DO NOT STORE PLAINTEXT PASSWORDS IN APPSETTINGS FILES\\\" } } } }\\n```\\n\\nProvide the password by using a\", \" secure configuration source such as Azure Key Vault or Hashicorp Vault.\\n\\n## Important\\n\\nDon't store \", \"unencrypted passwords in configuration files.\\n\\n## Set HTTPS certificates in code\\n\\nTo configure HTTPS\", \" on Kestrel in code, use the ConfigureKestrel method on IWebHostBuilder in the Program class.\\n\\n```\\np\", \"ublic static IHostBuilder CreateHostBuilder(string[] args) => Host.CreateDefaultBuilder(args) .Confi\", \"gureWebHostDefaults(webBuilder => { webBuilder.ConfigureKestrel(kestrel => { kestrel.ConfigureHttpsD\", \"efaults(https => { https.ServerCertificate = new X509Certificate2(\\\"mycert.pfx\\\", \\\"password\\\"); }); });\", \" });\\n```\\n\\nAgain, be sure to store the password for the .pfx file in, and retrieve it from, a secure \", \"configuration source.\\n\\n## Create Docker images\\n\\nThis section covers the creation of Docker images fo\", \"r ASP.NET Core gRPC applications, ready to run in Docker, Kubernetes, or other container environment\", \"s. The sample application used, with an ASP.NET Core MVC web app and a gRPC service, is available on\", \" the dotnet-architecture/grpc-for-wcfdevelopers repository on GitHub.\\n\\n## Microsoft base images for \", \"ASP.NET Core applications\\n\\nMicrosoft provides a range of base images for building and running .NET a\", \"pplications. To create an ASP.NET Core 7.0 image, you use two base images:\\n\\n- An SDK image to build \", \"and publish the application.\\n- A runtime image for deployment.\\n\\n| Image                            |\", \" Description                                                                |\\n|---------------------\", \"-------------|----------------------------------------------------------------------------|\\n| mcr.mi\", \"crosoft.com/dotnet/sd k    | For building applications with docker build. Not to be used in producti\", \"on. |\\n| mcr.microsoft.com/dotnet/as pnet | Contains the runtime and ASP.NET Core dependencies. For p\", \"roduction.        |\\n\\nFor each image, there are four variants based on different Linux distributions,\", \" distinguished by tags.\\n\\n| Image tag(s)           | Linux       | Notes                             \", \"                              |\\n|------------------------|-------------|----------------------------\", \"-------------------------------------|\\n| 7.0-bullseye-slim, 7.0 | Debian 11   | The default image if\", \" no OS variant is specified.                |\\n| 7.0-alpine             | Alpine 3.17 | Alpine base i\", \"mages are much smaller than Debian or Ubuntu ones. |\\n\\nThe Alpine base image is around 100 MB, compar\", \"ed to 200 MB for the Debian and Ubuntu images. Some software packages or libraries might not be avai\", \"lable in Alpine's package management. If you're not sure which image to use, you should probably cho\", \"ose the default Debian.\\n\\n## Important\\n\\nMake sure you use the same variant of Linux for the build and\", \" the runtime. Applications built and published on one variant might not work on another.\\n\\n## Create \", \"a Docker image\\n\\nA Docker image is defined by a Dockerfile . This Dockerfile is a text file that cont\", \"ains all the commands needed to build the application and install any dependencies that are required\", \" for either building or running the application. The following example shows the simplest Dockerfile\", \" for an ASP.NET Core 7.0 application:\\n\\n```\\nFROM mcr.microsoft.com/dotnet/sdk:7.0 as build WORKDIR /s\", \"rc COPY ./StockKube.sln . COPY ./src/StockData/StockData.csproj ./src/StockData/ COPY ./src/StockWeb\", \"/StockWeb.csproj ./src/StockWeb/ RUN dotnet restore COPY . . RUN dotnet publish --no-restore -c Rele\", \"ase -o /published src/StockData/StockData.csproj FROM mcr.microsoft.com/dotnet/aspnet:7.0 as runtime\", \" # Uncomment the line below if running with HTTPS # ENV ASPNETCORE_URLS=https://+:443 WORKDIR /app C\", \"OPY --from=build /published . ENTRYPOINT [ \\\"dotnet\\\", \\\"StockData.dll\\\" ]\\n```\\n\\nThe Dockerfile has two p\", \"arts: the first uses the sdk base image to build and publish the application; the second creates a r\", \"untime image from the aspnet base. This is because the sdk image is around 900 MB, compared to aroun\", \"d 200 MB for the runtime image, and most of its contents are unnecessary at run time.\\n\\n## The build \", \"steps\\n\\n| Step                   | Description                                                       \", \"                                 |\\n|------------------------|---------------------------------------\", \"-------------------------------------------------------------|\\n| FROM ...               | Declares t\", \"he base image and assigns the builder alias.                                             |\\n| WORKDIR\", \" /src           | Creates the /src directory and sets it as the current working directory.          \", \"                 |\\n| COPY . .               | Copies everything below the current directory on the h\", \"ost into the current directory on the image. |\\n| RUN dotnet restore     | Restores any external pack\", \"ages (ASP.NET Core 3.0 framework is preinstalled with the SDK).          |\\n| RUN dotnet publish ... \", \"| Builds and publishes a Release build. The -- runtime flag isn't required.                         \", \" |\\n\\n## The runtime image steps\\n\\n| Step                    | Description                             \", \"                                                                           |\\n|----------------------\", \"---|------------------------------------------------------------------------------------------------\", \"--------------------|\\n| FROM ...                | Declares a new base image.                        \", \"                                                                 |\\n| WORKDIR /app            | Creat\", \"es the /app directory and sets it as the current working directory.                                 \", \"          |\\n| COPY --from=builder ... | Copies the published application from the previous image, by\", \" using the builder alias from the first FROM line.     |\\n| ENTRYPOINT [ ... ]      | Sets the comman\", \"d to run when the container starts. The dotnet command in the runtime image can only run DLL files. \", \"|\\n\\n## HTTPS in Docker\\n\\nMicrosoft base images for Docker set the ASPNETCORE_URLS environment variable\", \" to http://+:80, meaning that Kestrel runs without HTTPS on that port. If you're using HTTPS with a \", \"custom certificate (as described in Self-hosted gRPC applications), you should override this configu\", \"ration. Set the environment variable in the runtime image creation part of your Dockerfile.\\n\\n# Runti\", \"me image creation FROM mcr.microsoft.com/dotnet/aspnet:7.0 ENV ASPNETCORE_URLS=https://+:443\\n\\n## The\", \" .dockerignore file\\n\\nMuch like .gitignore files that exclude certain files and directories from sour\", \"ce control, the .dockerignore file can be used to exclude files and directories from being copied to\", \" the image during build. This file not only saves time copying, but can also avoid some errors that \", \"arise from having the obj directory from your PC copied into the image. At a minimum, you should add\", \" entries for bin and obj to your .dockerignore file.\\n\\nbin/\\n\\nobj/\\n\\n## Build the image\\n\\nFor a StockKub\", \"e.sln solution containing two different applications StockData and StockWeb, it's simplest to put th\", \"e Dockerfile for each one of them in the base directory. In that case, to build the image, use the f\", \"ollowing docker build command from the same directory where .sln file resides.\\n\\ndocker build -t stoc\", \"kdata:1.0.0 -f ./src/StockData/Dockerfile .\\n\\nThe confusingly named --tag flag (which can be shortene\", \"d to -t) specifies the whole name of the image, including the actual tag if specified. The . at the \", \"end specifies the context in which the build will be run; the current working directory for the COPY\", \" commands in the Dockerfile.\\n\\nIf you have multiple applications within a single solution, you can ke\", \"ep the Dockerfile for each application in its own folder, beside the .csproj file. You should still \", \"run the docker build command from the base directory to ensure that the solution and all the project\", \"s are copied into the image. You can specify a Dockerfile below the current directory by using the -\", \"-file (or -f) flag.\\n\\ndocker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .\\n\\n## Run the ima\", \"ge in a container on your machine\\n\\nTo run the image in your local Docker instance, use the docker ru\", \"n command.\\n\\n```\\ndocker run -ti -p 5000:80 stockdata:1.0.0\\n```\\n\\nThe -ti flag connects your current te\", \"rminal to the container's terminal, and runs in interactive mode. The -p 5000:80 publishes (links) p\", \"ort 80 on the container to port 5000 on the localhost network interface.\\n\\n## Push the image to a reg\", \"istry\\n\\nAfter you've verified that the image works, push it to a Docker registry to make it available\", \" on other systems. Internal networks will need to provision a Docker registry. This activity can be \", \"as simple as running Docker's own registry image (the Docker registry runs in a Docker container), b\", \"ut there are various more comprehensive solutions available. For external sharing and cloud use, the\", \"re are various managed registries available, such as Azure Container Registry or Docker Hub.\\n\\nTo pus\", \"h to Docker Hub, prefix the image name with your user or organization name.\\n\\n```\\ndocker tag stockdat\", \"a:1.0.0 <myorg>/stockdata:1.0.0\\n```\\n\\n```\\ndocker push <myorg>/stockdata:1.0.0\\n```\\n\\nTo push to a priva\", \"te registry, prefix the image name with the registry host name and the organization name.\\n\\n```\\ndocke\", \"r tag stockdata <internal-registry:5000>/<myorg>/stockdata:1.0.0 docker push <internal-registry:5000\", \">/<myorg>/stockdata:1.0.0\\n```\\n\\nAfter the image is in a registry, you can deploy it to individual Doc\", \"ker hosts, or to a container orchestration engine like Kubernetes.\\n\\n## Kubernetes\\n\\nAlthough it's pos\", \"sible to run containers manually on Docker hosts, for reliable production systems it's better to use\", \" a container orchestration engine to manage multiple instances running across several servers in a c\", \"luster. There are various container orchestration engines available, including Kubernetes, Docker Sw\", \"arm, and Apache Mesos. But of these engines, Kubernetes is far and away the most widely used, so it \", \"will be the focus of this chapter.\\n\\nKubernetes includes the following functionality:\\n\\n- Scheduling r\", \"uns containers on multiple nodes within a cluster, ensuring balanced usage of the available resource\", \", keeping containers running if there are outages, and handling rolling updates to new versions of i\", \"mages or new configurations.\\n- Health checks monitor containers to ensure continued service.\\n- DNS &\", \"amp; service discovery handles routing between services within a cluster.\\n- Ingress exposes selected\", \" services externally and generally provides load-balancing across instances of those services.\\n- Res\", \"ource management attaches external resources like storage to containers.\\n\\nThis chapter will detail h\", \"ow to deploy an ASP.NET Core gRPC service and a website that consumes the service into a Kubernetes \", \"cluster. The sample application used is available in the dotnetarchitecture/grpc-for-wcf-developers \", \"repository on GitHub.\\n\\n## Kubernetes terminology\\n\\nKubernetes uses desired state configuration : the \", \"API is used to describe objects like Pods , Deployments , and Services , and the Control Plane takes\", \" care of implementing the desired state across all the nodes in a cluster . A Kubernetes cluster has\", \" a Master node that runs the Kubernetes API , which you can communicate with programmatically or by \", \"using the kubectl command-line tool. kubectl can create and manage objects through command-line argu\", \"ments, but it works best with YAML files that contain declaration data for Kubernetes objects.\\n\\n## K\", \"ubernetes YAML files\\n\\nEvery Kubernetes YAML file will have at least three top-level properties:\\n\\n| a\", \"piVersion : v1     |\\n|---------------------|\\n| kind : Namespace    |\\n| metadata :          |\\n| # Obj\", \"ect properties |\\n\\nThe apiVersion property is used to specify which version (and which API) the file \", \"is intended for. The kind property specifies the kind of object the YAML represents. The metadata pr\", \"operty contains object properties like name, namespace, and labels.\\n\\nMost Kubernetes YAML files will\", \" also have a spec section that describes the resources and configuration necessary to create the obj\", \"ect.\\n\\n## Pods\\n\\nPods are the basic units of execution in Kubernetes. They can run multiple containers\", \", but they're also used to run single containers. The pod also includes any storage resources requir\", \"ed by the containers, and the network IP address.\\n\\n## Services\\n\\nServices are meta-objects that descr\", \"ibe Pods (or sets of Pods) and provide a way to access them within the cluster, such as mapping a se\", \"rvice name to a set of pod IP addresses by using the cluster DNS service.\\n\\n## Deployments\\n\\nDeploymen\", \"ts are the desired state objects for Pods. If you create a pod manually, it won't be restarted when \", \"it terminates. Deployments are used to tell the cluster which Pods, and how many replicas of those P\", \"ods, should be running at the present time.\\n\\n## Other objects\\n\\nPods, Services, and Deployments are j\", \"ust three of the most basic object types. There are dozens of other object types that are managed by\", \" Kubernetes clusters. For more information, see the Kubernetes Concepts documentation.\\n\\n## Namespace\", \"s\\n\\nKubernetes clusters are designed to scale to hundreds or thousands of nodes and to run similar nu\", \"mbers of services. To avoid clashes between object names, namespaces are used to group objects toget\", \"her as part of larger applications. Kubernetes's own servic es run in a default namespace. All user \", \"objects should be created in their own namespaces to avoid potential clashes with default objects or\", \" other tenants in the cluster.\\n\\n## Get started with Kubernetes\\n\\nIf you're running Docker Desktop for\", \" Windows or Docker Desktop for Mac, Kubernetes is already available. Just enable it in the Kubernete\", \"s section of the Settings window:\\n\\nSettings\\n\\n\\u2022 Docker running\\n\\nGeneral\\n\\nX\\n\\nX\\n\\nKubernetes\\n\\nTo run a l\", \"ocal Kubernetes cluster on Linux, consider minikube, or MicroK8s if your Linux distribution supports\", \" snaps.\\n\\nTo confirm that your cluster is running and accessible, run the kubectl version command:\\n\\n`\", \"``\\nkubectl version Client Version: version.Info{Major:\\\"1\\\", Minor:\\\"19\\\", GitVersion:\\\"v1.19.3\\\", GitComm\", \"it:\\\"1e11e4a2108024935ecfcb2912226cedeafd99df\\\", GitTreeState:\\\"clean\\\", BuildDate:\\\"2020-10-14T12:50:19Z\", \"\\\", GoVersion:\\\"go1.15.2\\\", Compiler:\\\"gc\\\", Platform:\\\"windows/amd64\\\"} Server Version: version.Info{Major\", \":\\\"1\\\", Minor:\\\"19\\\", GitVersion:\\\"v1.19.3\\\", GitCommit:\\\"1e11e4a2108024935ecfcb2912226cedeafd99df\\\", GitTre\", \"eState:\\\"clean\\\", BuildDate:\\\"2020-10-14T12:41:49Z\\\", GoVersion:\\\"go1.15.2\\\", Compiler:\\\"gc\\\", Platform:\\\"lin\", \"ux/amd64\\\"}\\n```\\n\\nIn this example, both the kubectl CLI and the Kubernetes server are running version \", \"1.14.6. Each version of kubectl is supposed to support the previous and next version of the server, \", \"so kubectl 1.14 should work with server versions 1.13 and 1.15 as well.\\n\\n## Run services on Kubernet\", \"es\\n\\nThe sample application has a kube directory that contains three YAML files. The namespace.yml fi\", \"le declares a custom namespace: stocks. The stockdata.yml file declares the Deployment and the Servi\", \"ce for the gRPC application, and the stockweb.yml file declares the Deployment and Service for an AS\", \"P.NET Core 7.0 MVC web application that consumes the gRPC service.\\n\\nTo use a YAML file with kubectl,\", \" run the apply -f command:\\n\\n```\\nkubectl apply -f object.yml\\n```\\n\\nThe apply command will check the va\", \"lidity of the YAML file and display any errors received from the API, but doesn't wait until all the\", \" objects declared in the file have been created because this step can sir docker\\n\\n# O sughosnea\\n\\ntak\", \"e some time. Use the kubectl get command with the relevant object types to check on object creation \", \"in the cluster.\\n\\n## The namespace declaration\\n\\nNamespace declaration is simple and requires only ass\", \"igning a name:\\n\\n```\\napiVersion : v1 kind : Namespace metadata : name : stocks\\n```\\n\\nUse kubectl to ap\", \"ply the namespace.yml file and to confirm the namespace is created successfully:\\n\\n```\\n> kubectl appl\", \"y -f namespace.yml namespace/stocks created > kubectl get namespaces NAME              STATUS   AGE \", \"stocks            Active   2m53s\\n```\\n\\n## The StockData application\\n\\nThe stockdata.yml file declares \", \"two objects: a Deployment and a Service.\\n\\n## The StockData Deployment\\n\\nThe Deployment part of the YA\", \"ML file provides the spec for the deployment itself, including the number of replicas required, and \", \"a template for the Pod objects to be created and managed by the deployment. Note that Deployment obj\", \"ects are managed by the apps API, as specified in apiVersion, rather than the main Kubernetes API.\\n\\n\", \"```\\napiVersion : apps/v1 kind : Deployment metadata : name : stockdata namespace : stocks spec : sel\", \"ector : matchLabels : run : stockdata replicas : 1 template : metadata : labels : run : stockdata sp\", \"ec : containers : -name : stockdata image : stockdata:1.0.0 imagePullPolicy : Never resources : limi\", \"ts : cpu : 100m memory : 100Mi ports : -containerPort : 80\\n```\\n\\nThe spec.selector property is used t\", \"o match running Pods to the Deployment. The Pod's metadata.labels property must match the matchLabel\", \"s property or the API call will fail.\\n\\nThe template.spec section declares the container to be run. W\", \"hen you're working with a local Kubernetes cluster, such as the one provided by Docker Desktop, you \", \"can specify images that were built locally as long as they have a version tag.\\n\\n## Important\\n\\nBy def\", \"ault, Kubernetes will always check for and try to pull a new image. If it can't find the image in an\", \"y of its known repositories, the Pod creation will fail. To work with local images, set the imagePul\", \"lPolicy to Never.\\n\\nThe ports property specifies which container ports should be published on the Pod\", \". The stockservice image runs the service on the standard HTTP port, so port 80 is published.\\n\\nThe r\", \"esources section applies resource limits to the container running within the Pod. This is a good pra\", \"ctice because it prevents an individual Pod from consuming all the available CPU or memory on a node\", \".\\n\\n## Note\\n\\nASP.NET Core 7.0 has been optimized and tuned to run in resource-limited containers. The\", \" dotnet/core/aspnet Docker image sets an environment variable to tell the dotnet runtime that it's i\", \"n a container.\\n\\n## The StockData Service\\n\\nThe Service part of the YAML file declares the service tha\", \"t provides access to the Pods within the cluster.\\n\\n```\\napiVersion : v1 kind : Service metadata : nam\", \"e : stockdata namespace : stocks spec : ports : -port : 80 selector : run : stockdata\\n```\\n\\nThe Servi\", \"ce spec uses the selector property to match running Pods, in this case looking for Pods that have a \", \"label run: stockdata. The specified port on matching Pods is published by the named service. Other P\", \"ods running in the stocks namespace can access HTTP on this service by using http://stockdata as the\", \" address. Pods running in other namespaces can use the http://stockdata.stocks host name. You can co\", \"ntrol cross-namespace service access by using Network Policies.\\n\\n## Deploy the StockData application\", \"\\n\\nUse kubectl to apply the stockdata.yml file and confirm that the Deployment and Service were creat\", \"ed:\\n\\n```\\n> kubectl apply -f .\\\\stockdata.yml deployment.apps/stockdata created service/stockdata crea\", \"ted > kubectl get deployment stockdata --namespace stocks NAME        READY   UP-TO-DATE   AVAILABLE\", \"   AGE stockdata   1/1     1            1           17s > kubectl get service stockdata --namespace \", \"stocks NAME        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE stockdata   ClusterIP   1\", \"0.97.132.103   <none>        80/TCP    33s\\n```\\n\\n## The StockWeb application\\n\\nThe stockweb.yml file d\", \"eclares the Deployment and Service for the MVC application.\\n\\n```\\napiVersion : apps/v1 kind : Deploym\", \"ent metadata : name : stockweb namespace : stocks spec : selector : matchLabels : run : stockweb rep\", \"licas : 1 template : metadata : labels : run : stockweb spec : containers : -name : stockweb image :\", \" stockweb:1.0.0 imagePullPolicy : Never resources : limits : cpu : 100m memory : 100Mi ports : -cont\", \"ainerPort : 80 env : -name : StockData__Address value : \\\"http://stockdata\\\" -name : DOTNET_SYSTEM_NET\", \"_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT value : \\\"true\\\" ---apiVersion : v1 kind : Service me\", \"tadata : name : stockweb namespace : stocks spec : type : NodePort ports : -port : 80 selector : run\", \" : stockweb\\n```\\n\\n## Environment variables\\n\\nThe env section of the Deployment object specifies enviro\", \"nment variables to be set in the container that's running the stockweb:1.0.0 images.\\n\\nThe StockData_\", \"_Address environment variable will map to the StockData:Address configuration setting thanks to the \", \"EnvironmentVariables configuration provider. This setting uses double underscores between names to s\", \"eparate sections. The address uses the service name of the stockdata Service, which is running in th\", \"e same Kubernetes namespace.\\n\\nThe DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT \", \"environment variable sets an AppContext switch that enables unencrypted HTTP/2 connections for HttpC\", \"lient. This environment variable does the same thing as setting the switch in code, as shown here:\\n\\n\", \"```\\nAppContext.SetSwitch(\\\"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport\\\", true );\\n```\\n\\n\", \"If you use an environment variable for the switch, you can easily change the context depending on th\", \"e context in which the application is running.\\n\\n## Service types\\n\\nThe type: NodePort property is use\", \"d to make the web application accessible from outside the cluster. This property type causes Kuberne\", \"tes to publish port 80 on the Service to an arbitrary port on the cluster's external network sockets\", \". You can find the assigned port by using the kubectl get service command.\\n\\nThe stockdata Service sh\", \"ouldn't be accessible from outside the cluster, so it uses the default type, ClusterIP.\\n\\nProduction \", \"systems will most likely use an integrated load balancer to expose public applications to external c\", \"onsumers. Services exposed in this way should use the LoadBalancer type.\\n\\nFor more information on Se\", \"rvice types, see the Kubernetes Publishing Services documentation.\\n\\n## Deploy the StockWeb applicati\", \"on\\n\\nUse kubectl to apply the stockweb.yml file and confirm that the Deployment and Service were crea\", \"ted:\\n\\n```\\n> kubectl apply -f .\\\\stockweb.yml deployment.apps/stockweb created service/stockweb create\", \"d > kubectl get deployment stockweb --namespace stocks NAME       READY   UP-TO-DATE   AVAILABLE   A\", \"GE stockweb   1/1     1            1           8s > kubectl get service stockweb --namespace stocks \", \"NAME       TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE stockweb   NodePort   10.106.1\", \"41.5   <none>        80:32564/TCP   13s\\n```\\n\\nThe output of the get service command shows that the HT\", \"TP port has been published to port 32564 on the external network. For Docker Desktop, this IP addres\", \"s will be localhost. You can access the application by browsing to http://localhost:32564.\\n\\nHome Pag\", \"e - StockWeb x+\\n\\n&lt; &gt;\\n\\n\\u2022 localhost:32564\\n\\nStockWeb\\n\\nHome Privacy\\n\\n## Test the application\\n\\nThe \", \"StockWeb application displays a list of NASDAQ stocks that are retrieved from a simple requestreply \", \"service. For this demonstration, each line also shows the unique ID of the Service instance that ret\", \"urned it. American Airlines Group Inc 83345e3b-7b5e-4ad6-aa84-c2c0a1d83495\\n\\nIf the number of replica\", \"s of the stockdata Service were increased, you might expect the Server value to change from line to \", \"line, but in fact all 100 records are always returned from the same instance. If you refresh the pag\", \"e every few seconds, the server ID remains the same. Why does this happen? There are two factors at \", \"play here.\\n\\nFirst, the Kubernetes Service discovery system uses round-robin load balancing by defaul\", \"t. The first time the DNS server is queried, it will return the first matching IP address for the Se\", \"rvice. The next time, it will return the next IP address in the list, and so on, until the end. At t\", \"hat point, it loops back to the start.\\n\\nSecond, the HttpClient used for the StockWeb application's g\", \"RPC client is created and managed by the ASP.NET Core HttpClientFactory, and a single instance of th\", \"is client is used for every call to the page. The client only does one DNS lookup, so all requests a\", \"re routed to the same IP address. And because the HttpClientHandler is cached for performance reason\", \"s, multiple requests in quick succession will all use the same IP address, until the cached DNS entr\", \"y expires or the handler instance is disposed for some reason.\\n\\nThe result is that by default reques\", \"ts to a gRPC Service aren't balanced across all instances of that Service in the cluster. Different \", \"consumers will use different instances, but that doesn't guarantee a good distribution of requests o\", \"r a balanced use of resources.\\n\\nThe next chapter, Service meshes, will address this problem.\\n\\nGuest\\n\", \"\\n-\\n\\n## Service meshes\\n\\nA service mesh is an infrastructure component that takes control of routing s\", \"ervice requests within a network. Service meshes can handle all kinds of network-level concerns with\", \"in a Kubernetes cluster, including:\\n\\n- Service discovery\\n- Load balancing\\n- Fault tolerance\\n- Encryp\", \"tion\\n- Monitoring\\n\\nKubernetes service meshes work by adding an extra container, called a sidecar pro\", \"xy , to each pod included in the mesh. The proxy takes over handling all inbound and outbound networ\", \"k requests. You can then keep the configuration and management of networking matters separate from t\", \"he application containers. In many cases, this separation d oesn't require any changes to the applic\", \"ation code.\\n\\nIn the previous chapter's example , the gRPC requests from the web application were all\", \" routed to a single instance of the gRPC service. This happens because the service's host name is re\", \"solved to an IP address, and that IP address is cached for the lifetime of the HttpClientHandler ins\", \"tance. It might be possible to work around this behavior by handling DNS lookups manually or creatin\", \"g multiple clients. But this workaround would complicate the application code without adding any bus\", \"iness or customer value.\\n\\nWhen you use a service mesh, the requests from the application container a\", \"re sent to the sidecar proxy. The sidecar proxy can then distribute them intelligently across all in\", \"stances of the other service. The mesh can also:\\n\\n- Respond seamlessly to failures of individual ins\", \"tances of a service.\\n- Handle retry semantics for failed calls or timeouts.\\n- Reroute failed request\", \"s to an alternate instance without returning to the client application.\\n\\nThe following screenshot sh\", \"ows the StockWeb application running with the Linkerd service mesh. There are no changes to the appl\", \"ication code, and the Docker image isn't being used. The only change required was the addition of an\", \" annotation to the deployment in the YAML files for the stockdata and stockweb services.\\n\\nE Home Pag\", \"e - StockWeb\\n\\n&lt; \\u2192\\n\\nStockWeb\\n\\n+\\n\\nlocalhost:31700\\n\\nHome Privacy\\n\\nYou can see from the Server column\", \" that the requests from the StockWeb application have been routed to both replicas of the StockData \", \"service, despite originating from a single HttpClient instance in the application code. In fact, if \", \"you review the code, you'll see that all 100 requ ests to the StockData service are made simultaneou\", \"sly by using the same HttpClient instance. With the service mesh, those requests will be balanced ac\", \"ross however many service instances are available.\\n\\nService meshes apply only to traffic within a cl\", \"uster. For external clients, see the next chapter, Load Balancing.\\n\\n## Service mesh options\\n\\nThree g\", \"eneral-purpose service mesh implementations are currently available for use with Kubernetes: Istio, \", \"Linkerd, and Consul Connect. All three provide request routing/proxying, traffic encryption, resilie\", \"nce, host-to-host authentication, and traffic control.\\n\\nChoosing a service mesh depends on multiple \", \"factors:\\n\\n- The organization's specific requirements around costs, compliance, paid support plans, a\", \"nd so on.\\n- The nature of the cluster, its size, the number of services deployed, and the volume of \", \"traffic within the cluster network.\\n- Ease of deploying and managing the mesh and using it with serv\", \"ices.\\n\\n## Example: Add Linkerd to a deployment\\n\\nIn this example, you'll learn how to use the Linkerd\", \" service mesh with the StockKube application from the previous section . To follow this example, you\", \"'ll need to install the Linkerd CLI. You can download\\n\\nGuest 8)\\n\\no a ..\\n\\nWindows binaries from the s\", \"ection that lists GitHub releases. Be sure to use the most recent stable release and not one of the \", \"edge releases.\\n\\nWith the Linkerd CLI installed, follow the Getting Started instructions to install t\", \"he Linkerd components on your Kubernetes cluster. The instructions are straightforward, and the inst\", \"allation should take only a couple of minutes on a local Kubernetes instance.\\n\\n## Add Linkerd to Kub\", \"ernetes deployments\\n\\nThe Linkerd CLI provides an inject command to add the necessary sections and pr\", \"operties to Kubernetes files. You can run the command and write the output to a new file.\\n\\n```\\nlinke\", \"rd inject stockdata.yml > stockdata-with-mesh.yml linkerd inject stockweb.yml > stockweb-with-mesh.y\", \"ml\\n```\\n\\nYou can inspect the new files to see what changes have been made. For deployment objects, a \", \"metadata annotation is added to tell Linkerd to inject a sidecar proxy container into the pod when i\", \"t's created.\\n\\nIt's also possible to pipe the output of the linkerd inject command to kubectl directl\", \"y. The following commands will work in PowerShell or any Linux shell.\\n\\n| linkerd inject stockdata.ym\", \"l |   | kubectl apply -f -   |\\n|----------------------------------|----------------------|\\n| linkerd\", \" inject stockweb.yml      | | kubectl apply -f - |\\n\\n## Inspect services in the Linkerd dashboard\\n\\nOp\", \"en the Linkerd dashboard by using the linkerd CLI.\\n\\nlinkerd dashboard\\n\\nThe dashboard provides detail\", \"ed information about all services that are connected to the mesh.\\n\\nLINKERD &lt;\\n\\nOverview\\n\\nTap\\n\\nTop\\n\", \"\\n=\\n\\nTop Routes\\n\\nService Mesh\\n\\nResources\\n\\nDocumentation\\n\\nCommunity\\n\\nJoin the Mailing List\\n\\nJoin us on\", \" Slack\\n\\nFile an Issue\\n\\nRunning Linkerd 2.5.0 (stable).\\n\\nLinkerd is up to date.\\n\\nstocks\\n\\nNamespace: s\", \"tocks\\n\\nIf you increase the number of replicas of the StockData gRPC service as shown in the followin\", \"g example, and refresh the StockWeb page in the browser, you should see a mix of IDs in the Server c\", \"olumn. This mix indicates that all the available instances are serving requests.\\n\\n```\\napiVersion : a\", \"pps/v1 kind : Deployment metadata : name : stockdata namespace : stocks spec : selector : matchLabel\", \"s : run : stockdata replicas : 2 # Increase the target number of instances template : metadata : ann\", \"otations : linkerd.io/inject : enabled creationTimestamp : null labels : run : stockdata spec : cont\", \"ainers : -name : stockdata image : stockdata:1.0.0 imagePullPolicy : Never resources : limits : cpu \", \": 100m memory : 100Mi ports : -containerPort : 80\\n```\\n\\nmeshed\\n\\n## Load balancing gRPC\\n\\nA typical dep\", \"loyment of a gRPC application includes a number of identical instances of the service, providing res\", \"ilience and horizontal scalability. Load balancing distributes incoming requests across these instan\", \"ces to provide full usage of all available resources. To make this load balancing invisible to the c\", \"lient, it's common to use a proxy load balancer server to handle requests from clients and route the\", \"m to back-end instances.\\n\\nLoad balancers are classified according to the layer they operate on. Laye\", \"r 4 load balancers work on the transport level, for example, with TCP sockets, connections, and pack\", \"ets. Layer 7 load balancers work at the application level, specifically handling HTTP/2 requests for\", \" gRPC applications.\\n\\n## L4 load balancers\\n\\nAn L4 load balancer accepts a TCP connection request from\", \" a client, opens another connection to one of the back-end instances, and copies data between the tw\", \"o connections with no real processing. L4 offers excellent performance and low latency, but with lit\", \"tle control or intelligence. As long as the client keeps the connection open, all requests will be d\", \"irected to the same back-end instance.\\n\\nAzure Load Balancer is an example of an L4 load balancer.\\n\\n#\", \"# L7 load balancers\\n\\nAn L7 load balancer parses incoming HTTP/2 requests and passes them on to back-\", \"end instances on a request-by-request basis, no matter how long the connection is held by the client\", \".\\n\\nExamples of L7 load balancers:\\n\\n- NGINX\\n- HAProxy\\n- Traefik\\n\\nAs a rule of thumb, L7 load balancer\", \"s are the best choice for gRPC and other HTTP/2 applications (and for HTTP applications generally, i\", \"n fact). L4 load balancers will work with gRPC applications, but they're primarily useful when low l\", \"atency and low overhead are important.\\n\\n| Important                                                 \", \"                                                                                                    \", \"            |\\n|-------------------------------------------------------------------------------------\", \"--------------------------------------------------------------------------------------|\\n| At the tim\", \"e of this writing, some L7 load balancers don't support all the parts of the HTTP/2 specification th\", \"at are required by gRPC services, such as trailing headers. |\\n\\nIf you're using TLS encryption, load \", \"balancers can terminate the TLS connection and pass unencrypted requests to the back-end application\", \", or they can pass the encrypted request along. Either way, the load balancer will need to be config\", \"ured with the serve r's public and private key so it can decrypt requests for processing.\\n\\nSee to th\", \"e documentation for your preferred load balancer to find out how to configure it to handle HTTP/2 re\", \"quests with your back-end services.\\n\\n## Load balancing within Kubernetes\\n\\nSee the section on service\", \" meshes for a discussion of load balancing across internal services on Kubernetes.\\n\\n## Application P\", \"erformance Management\\n\\nIn production environments like Kubernetes, it's important to monitor applica\", \"tions to ensure they're running optimally. Logging and metrics are important in particular. ASP.NET \", \"Core, including gRPC, provides built-in support for producing and managing log messages and metrics \", \"data, as well as tracing data.\\n\\n## The difference between logging and metrics\\n\\nLogging is concerned \", \"with text messages that record detailed information about things that have happened in the system. L\", \"og messages might include exception data, like stack traces, or structured data that provide context\", \" about the message. Logging output is commonly written to a searchable text store.\\n\\nMetrics refers t\", \"o numeric data designed to be aggregated and presented by using charts and graphs in a dashboard. Th\", \"e dashboard provides a view of the overall health and performance of an application. Metrics data ca\", \"n also be used to trigger automated alerts when a threshold is exceeded. Here are some examples of m\", \"etrics data:\\n\\n- Time taken to process requests.\\n- The number of requests per second being handled by\", \" an instance of a service.\\n- The number of failed requests on an instance.\\n\\n## Logging in ASP.NET Co\", \"re gRPC\\n\\nASP.NET Core provides built-in support for logging, in the form of Microsoft.Extensions.Log\", \"ging NuGet package. The core parts of this library are included with the Web SDK, so there's no need\", \" to install it manually. By default, log messages are written to the standard output (the 'console')\", \" and to any attached debugger. To write logs to persistent external data stores, you might need to i\", \"mport optional logging sink packages.\\n\\nThe ASP.NET Core gRPC framework writes detailed diagnostic lo\", \"gging messages to this logging framework, so they can be processed and stored along with your applic\", \"ation's own messages.\\n\\n## Produce log messages\\n\\nThe logging extension is automatically registered wi\", \"th ASP.NET Core's dependency injection system, so you can specify loggers as a constructor parameter\", \" on gRPC service types.\\n\\n```\\npublic class StockData : Stocks.StocksBase { private readonly ILogger<S\", \"tockData> _logger; public StockData(ILogger<StockData> logger)\\n```\\n\\n```\\n{ _logger = logger; } }\\n```\\n\", \"\\nMany log messages, such as requests and exceptions, are provided by the ASP.NET Core and gRPC frame\", \"work components. Add your own log messages to provide detail and context about application logic, ra\", \"ther than lower-level concerns.\\n\\nFor more information about writing log messages and available loggi\", \"ng sinks and targets, see Logging in .NET Core and ASP.NET Core.\\n\\n## Metrics in ASP.NET Core gRPC\\n\\nT\", \"he .NET Core runtime provides a set of components for emitting and observing metrics. These include \", \"APIs such as the EventSource and EventCounter classes. These APIs can emit basic numeric data that c\", \"an be consumed by external processes, like the dotnet-counters global tool, or Event Tracing for Win\", \"dows. For more information about using EventCounter in your own code, see EventCounter introduction.\", \"\\n\\nFor more advanced metrics and for writing metric data to a wider range of data stores, you might t\", \"ry an open-source project called App Metrics. This suite of libraries provides an extensive set of t\", \"ypes to instrument your code. It also offers packages to write metrics to different kinds of targets\", \" that include time-series databases, such as Prometheus and InfluxDB, and Application Insights. The \", \"App.Metrics.AspNetCore.Mvc NuGet package even adds a comprehensive set of basic metrics that are aut\", \"omatically generated via integration with the ASP.NET Core framework. The project website provides t\", \"emplates for displaying those metrics with the Grafana visualization platform.\\n\\n## Produce metrics\\n\\n\", \"Most metrics platforms support the following types:\\n\\n| Metric type   | Description                  \", \"                                                                                                    \", \"                                                                                                    \", \"                              |\\n|---------------|---------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"---------|\\n| Counter       | Tracks how often something happens, such as requests and errors.       \", \"                                                                                                    \", \"                                                                                        |\\n| Gauge   \", \"      | Records a single value that changes over time, such as active connections.                  \", \"                                                                                                    \", \"                                                                   |\\n| Histogram     | Measures a di\", \"stribution of values across arbitrary limits. For example, a histogram can track dataset size, count\", \"ing how many contained <10 records, how many contained 11-100 records, how many contained 101-1000 r\", \"ecords, and how many contained >1000 records. |\\n| Meter         | Measures the rate at which an even\", \"t occurs in various time spans.                                                                     \", \"                                                                                                    \", \"                         |\\n\\n| Metric type   | Description                                           \", \"                                |\\n|---------------|-------------------------------------------------\", \"--------------------------------------|\\n| Timer         | Tracks the duration of events and the rate\", \" at which it occurs, stored as a histogram. |\\n\\nBy using App Metrics , an IMetrics interface can be o\", \"btained via dependency injection, and used to record any of these metrics for a gRPC service. The fo\", \"llowing example shows how to count the number of Get requests made over time:\\n\\n```\\npublic class Stoc\", \"kData : Stocks.StocksBase { private static readonly CounterOptions GetRequestCounter = new CounterOp\", \"tions { Name = \\\"StockData_Get_Requests\\\", MeasurementUnit = Unit.Calls }; private readonly IStockRepo\", \"sitory _repository; private readonly IMetrics _metrics; public StockData(IStockRepository repository\", \", IMetrics metrics) { _repository = repository; _metrics = metrics; } public override async Task<Get\", \"Response> Get(GetRequest request, ServerCallContext context) { _metrics.Measure.Counter.Increment(Ge\", \"tRequestCounter); // Serve request... } }\\n```\\n\\n## Store and visualize metrics data\\n\\nThe best way to \", \"store metrics data is in a time-series database , a specialized data store designed to record numeri\", \"cal data series marked with timestamps. The most popular of these databases are Prometheus and Influ\", \"xDB. Microsoft Azure also provides dedicated metrics storage through the Azure Monitor service.\\n\\nThe\", \" current go-to solution for visualizing metrics data is Grafana, which works with a wide range of st\", \"orage providers. The following image shows an example Grafana dashboard that displays metrics from t\", \"he Linkerd service mesh running the StockData sample:\\n\\n+\\n\\n88 Linkerd Deployment - ral deploy/stockda\", \"ta\\n\\nSUCCESS RATE\\n\\nREQUEST RATE\\n\\nthit\\n\\nINBOUND DEPLOYMENTS\\n\\n\\u00a9 Last 5 minutes\\n\\nOUTBOUND DEPLOYMENTS\\n\\n1\", \"00.00%\\n\\n75.00%\\n\\n50.00%\\n\\n25.00%\\n\\no%\\n\\n17:43\\n\\n17:44\\n\\n&gt; Inbound TCP Metrics (panels)\\n\\n&gt; deploy/sto\", \"ckweb (4 panels)\\n\\n## Metrics-based alerting\\n\\nThe numerical nature of metrics data means that it's id\", \"eally suited to drive alerting systems, notifying developers or support engineers when a value falls\", \" outside of some defined tolerance. The platforms already mentioned all provide support for alerting\", \" via a range of options, including emails, text messages, or in-dashboard visualizations.\\n\\n## Distri\", \"buted tracing\\n\\nDistributed tracing is a relatively recent development in monitoring, which has arise\", \"n from the increasing use of microservices and distributed architectures. A single request from a cl\", \"ient browser, application, or device can be broken down into many steps and sub-requests, and involv\", \"e the use of many services across a network. This activity makes it difficult to correlate log messa\", \"ges and metrics with the specific request that triggered them. Distributed tracing applies identifie\", \"rs to requests, and allows logs and metrics to be correlated with a particular operation. This traci\", \"ng is similar to WCF's end-to-end tracing , but it's applied across multiple platforms.\\n\\nDistributed\", \" tracing has grown quickly in popularity and is beginning to standardize. The Cloud Native Computing\", \" Foundation created the Open Tracing standard, attempting to provide vendor-neutral libraries for wo\", \"rking with back ends like Jaeger and Elastic APM. At the same time, Google created the OpenCensus pr\", \"oject to address the same set of problems. These two projects are merging into a new project, OpenTe\", \"lemetry, which aims to be the industry standard of the future.\\n\\n## How distributed tracing works\\n\\nDi\", \"stributed tracing is based on the concept of spans : named, timed operations that are part of a sing\", \"le trace , which can involve processing on multiple nodes of a system. When a new operation is initi\", \"ated, a trace is created with a unique identifier. For each sub-operation, a span is created with it\", \"s own\\n\\nidentifier and trace identifier. As the request passes around the system, various components \", \"can create child spans that include the identifier of their parent . A span has a context , which co\", \"ntains the trace and span identifiers, as well as useful data in the form of key and value pairs (ca\", \"lled baggage ).\\n\\n## Distributed tracing with DiagnosticSource\\n\\n.NET has an internal module that maps\", \" well to distributed traces and spans: DiagnosticSource. As well as providing a simple way to produc\", \"e and consume diagnostics within a process, the DiagnosticSource module has the concept of an activi\", \"ty . An activity is effectively an implementation of a distributed trace, or a span within a trace. \", \"The internals of the module take care of parent/child activities, including allocating identifiers. \", \"For more information about using the Activity type, see the Activity User Guide on GitHub.\\n\\nBecause \", \"DiagnosticSource is a part of the core framework and later, it's supported by several core component\", \"s. These include HttpClient, Entity Framework Core, and ASP.NET Core, including explicit support in \", \"the gRPC framework. When ASP.NET Core receives a request, it checks for a pair of HTTP headers match\", \"ing the W3C Trace Context standard. If the headers are found, an activity is started by using the id\", \"entity values and context from the headers. If no headers are found, an activity is started with gen\", \"erated identity values that match the standard format. Any diagnostics generated by the framework or\", \" by application code during the lifetime of this activity can be tagged with the trace and span iden\", \"tifiers. The HttpClient support extends this functionality further by checking for a current activit\", \"y on every request, and automatically adding the trace headers to the outgoing request.\\n\\nThe ASP.NET\", \" Core gRPC client and server libraries include explicit support for DiagnosticSource and Activity, a\", \"nd create activities and apply and use header information automatically.\\n\\n## Note\\n\\nAll of this happe\", \"ns only if a listener is consuming the diagnostic information. If there's no listener, no diagnostic\", \"s are written and no activities are created.\\n\\n## Add your own DiagnosticSource and Activity\\n\\nTo add \", \"your own diagnostics or create explicit spans within your application code, see the DiagnosticSource\", \" User Guide and Activity User Guide.\\n\\n## Store distributed trace data\\n\\nAt the time of writing, the O\", \"penTelemetry project is still in the early stages, and only alpha-quality packages are available for\", \" .NET applications. The OpenTracing project currently offers more mature libraries.\\n\\nThe OpenTracing\", \" API is described in the following section. If you want to use the OpenTelemetry API in your applica\", \"tion instead, refer to the OpenTelemetry .NET SDK repository on GitHub.\\n\\n## Use the OpenTracing pack\", \"age to store distributed trace data\\n\\nThe OpenTracing NuGet package supports all OpenTracing-complian\", \"t back ends (which can be used independently of DiagnosticSource). There's an additional package fro\", \"m the OpenTracing API\\n\\nContributions project, OpenTracing.Contrib.NetCore. This package adds a Diagn\", \"osticSource listener, and writes events and activities to a back end automatically. Enabling this pa\", \"ckage is as simple as installing it from NuGet and adding it as a service in your Program class.\\n\\n``\", \"`\\n// builder.Services.AddOpenTracing(); //\\n```\\n\\nThe OpenTracing package is an abstraction layer, and\", \" as such it requires implementation specific to the back end. OpenTracing API implementations are av\", \"ailable for the following open source back ends.\\n\\n| Name        | Package                | Website  \", \"               |\\n|-------------|------------------------|-------------------------|\\n| Jaeger      | \", \"Jaeger                 | jaegertracing.io        |\\n| Elastic APM | Elastic.Apm.NetCoreAll | elastic.\", \"co/products/apm |\\n\\nFor more information on the OpenTracing API for .NET, see the OpenTracing for C# \", \"and the OpenTracing Contrib C#/.NET Core repositories on GitHub.\\n\\n## Appendix A - Transactions\\n\\nWind\", \"ows Communication Foundation (WCF) supports distributed transactions, allowing you to perform atomic\", \" operations across multiple services. This functionality is based on the Microsoft Distributed Trans\", \"action Coordinator.\\n\\nIn the newer microservices landscape, this type of automated distributed transa\", \"ction processing isn't possible. There are too many different technologies involved, including relat\", \"ional databases, NoSQL data stores, and messaging systems. There might also be a mix of operating sy\", \"stems, programming languages, and frameworks in use in a single environment.\\n\\nWCF distributed transa\", \"ction is an implementation of what is known as a two-phase commit (2PC). You can implement 2PC trans\", \"actions manually by coordinating messages across services, creating open transactions within each se\", \"rvice, and sending commit or rollback messages, depending upon success or failure. However, the comp\", \"lexity involved in managing 2PC can increase exponentially as systems evolve. Open transactions hold\", \" database locks that can negatively affect performance, or, worse, cause cross-service deadlocks.\\n\\nI\", \"f possible, it's best to avoid distributed transactions altogether. If two items of data are so link\", \"ed as to require atomic updates, consider handling them both with the same service. Apply those atom\", \"ic changes by using a single request or message to that service.\\n\\nIf that isn't possible, then one a\", \"lternative is to use the Saga pattern. In a saga, updates are processed sequentially; as each update\", \" succeeds, the next one is triggered. These triggers can be propagated from service to service, or m\", \"anaged by a saga coordinator or orchestrator. If an update fails at any point during the process, th\", \"e services that have already completed their updates apply specific logic to reverse them.\\n\\nAnother \", \"option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as \", \"described in the .NET Microservices e-book. In particular, using domain events or event sourcing can\", \" help to ensure that updates are consistently, if not immediately, applied.\"]"