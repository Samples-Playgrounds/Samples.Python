"[\"\\n\\n\\fEDITION v7.0 - Updated to ASP.NET Core 7.0\\n\\nRefer changelog for the book updates and community co\", \"ntributions.\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Visual Studio product teams\\n\\nA d\", \"ivision of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington 98052-6399\\n\\nCopyright \\u00a9 202\", \"3 by Microsoft Corporation\\n\\nAll rights reserved. No part of the contents of this book may be reprodu\", \"ced or transmitted in any\\nform or by any means without the written permission of the publisher.\\n\\nThi\", \"s book is provided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions and\\nin\", \"formation expressed in this book, including URL and other Internet website references, may change\\nwi\", \"thout notice.\\n\\nSome examples depicted herein are provided for illustration only and are fictitious. \", \"No real association\\nor connection is intended or should be inferred.\\n\\nMicrosoft and the trademarks l\", \"isted at https://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are\\ntrademarks of the Microsoft group\", \" of companies.\\n\\nThe Docker whale logo is a registered trademark of Docker, Inc. Used by permission.\\n\", \"\\nAll other marks and logos are property of their respective owners.\\n\\nAuthors:\\n\\nMark Rendle - Chief T\", \"echnical Officer - Visual Recode\\n\\nMiranda Steiner - Technical Author\\n\\nEditor:\\n\\nMaira Wenzel - Sr. Co\", \"ntent Developer - Microsoft\\n\\nIntroduction\\n\\ngRPC is a modern framework for building networked service\", \"s and distributed applications. Imagine\\nthe performance of Windows Communication Foundation (WCF) Ne\", \"tTCP bindings, combined with the\\ncross-platform interoperability of SOAP. gRPC builds on HTTP/2 and \", \"the Protobuf message-encoding\\nprotocol to provide high performance, low-bandwidth communication betw\", \"een applications and\\nservices. It supports server and client code generation across most popular pro\", \"gramming languages\\nand platforms, including .NET, Java, Python, Node.js, Go, and C++. With the first\", \"-class support for\\ngRPC in ASP.NET Core 7.0, alongside the existing gRPC tools and libraries for .NE\", \"T Framework 4.x, it\\u2019s\\nan excellent alternative to WCF for development teams looking to adopt .NET in\", \" their organizations.\\n\\n\\fWho should use this guide\\n\\nThis guide was written for developers working in \", \".NET Framework or .NET who have previously used\\nWCF, and who are seeking to migrate their applicatio\", \"ns to a modern RPC environment for .NET Core\\n3.0 and later versions. More generally, if you are upgr\", \"ading, or considering upgrading, to .NET 7, and\\nyou want to use the built-in gRPC tools, this guide \", \"is also useful.\\n\\nHow you can use this guide\\n\\nThis is a short introduction to building gRPC Services \", \"in ASP.NET Core 7.0, with particular reference to\\nWCF as an analogous platform. It explains the prin\", \"ciples of gRPC, relating each concept to the\\nequivalent features of WCF, and offers guidance for mig\", \"rating an existing WCF application to gRPC.\\nIt\\u2019s also useful for developers who have experience with\", \" WCF and are looking to learn gRPC to build\\nnew services. You can use the sample applications as a t\", \"emplate or reference for your own projects,\\nand you are free to copy and reuse code from the book or\", \" its samples.\\n\\nFeel free to forward this guide to your team to help ensure a common understanding of\", \" these\\nconsiderations and opportunities. Having everybody working from a common set of terms and\\nund\", \"erlying principles helps ensure consistent application of architectural patterns and practices.\\n\\nRef\", \"erences\\n\\n\\u2022\\n\\n\\u2022\\n\\ngRPC website https://grpc.io\\n\\nChoosing between .NET 5 and .NET Framework for server a\", \"pps\\nhttps://learn.microsoft.com/dotnet/standard/choosing-core-framework-server\\n\\n\\fContents\\n\\nIntroduct\", \"ion to gRPC for WCF developers .....................................................................\", \"...... 1\\n\\nHistory ..................................................................................\", \"....................................................................................................\", \".... 1\\n\\nMicroservices ..............................................................................\", \"............................................................................................... 2\\n\\nA\", \"bout this guide ....................................................................................\", \"................................................................................... 3\\n\\nWho this guid\", \"e is for ...........................................................................................\", \"................................................................... 3\\n\\ngRPC overview ...............\", \"....................................................................................................\", \"...... 4\\n\\nKey principles ...........................................................................\", \"................................................................................................. 4\\n\", \"\\nHow gRPC approaches RPC ...........................................................................\", \"...................................................................... 5\\n\\nInterface Definition Langu\", \"age ................................................................................................\", \"............................................ 6\\n\\nNetwork protocols ..................................\", \"....................................................................................................\", \"............................. 7\\n\\nKey features of HTTP/2 ............................................\", \"....................................................................................................\", \"..... 7\\n\\nWhy we recommend gRPC for WCF developers ..................................................\", \"....................................................... 8\\n\\nSimilarity to WCF .......................\", \"....................................................................................................\", \"...................................... 8\\n\\nBenefits of gRPC .........................................\", \"....................................................................................................\", \"..................... 8\\n\\nComparison with CoreWCF ...................................................\", \".......................................................................................... 9\\n\\nProtoc\", \"ol buffers .........................................................................................\", \"............................ 11\\n\\nHow Protobuf works ................................................\", \"....................................................................................................\", \"........ 11\\n\\nProtobuf messages .....................................................................\", \".......................................................................................... 11\\n\\nDecla\", \"ring a message .....................................................................................\", \".................................................................. 11\\n\\nField numbers ...............\", \"....................................................................................................\", \"................................................. 12\\n\\nTypes ........................................\", \"....................................................................................................\", \"......................................... 13\\n\\nThe generated code ...................................\", \"....................................................................................................\", \"................. 13\\n\\nProtobuf scalar data types ...................................................\", \"............................................................................................. 13\\n\\nOt\", \"her .NET primitive types ...........................................................................\", \"................................................................ 14\\n\\nDecimals ......................\", \"....................................................................................................\", \"..................................................... 16\\n\\nProtobuf nested types ....................\", \"....................................................................................................\", \"................................ 17\\n\\nRepeated fields for lists and arrays ..........................\", \"....................................................................................................\", \".. 18\\n\\nProtobuf reserved fields ....................................................................\", \"................................................................................. 18\\n\\ni\\n\\nContents\\n\\n\\f\", \"Protobuf Any and Oneof fields for variant types ....................................................\", \"................................................. 19\\n\\nAny ..........................................\", \"....................................................................................................\", \"........................................... 19\\n\\nOneof ..............................................\", \"....................................................................................................\", \".................................. 20\\n\\nProtobuf enumerations .......................................\", \"....................................................................................................\", \"........... 21\\n\\nProtobuf maps for dictionaries .....................................................\", \"................................................................................... 22\\n\\nUsing MapFie\", \"ld properties in code ..............................................................................\", \"............................................. 22\\n\\nFurther reading ..................................\", \"....................................................................................................\", \"........................... 23\\n\\nComparing WCF to gRPC ..............................................\", \"........................................................ 24\\n\\ngRPC example ..........................\", \"....................................................................................................\", \".......................................... 24\\n\\nWCF endpoints and gRPC methods ......................\", \"....................................................................................................\", \".... 25\\n\\nOperationContract properties ..............................................................\", \"....................................................................... 25\\n\\nWCF bindings and transpo\", \"rts ................................................................................................\", \".......................................... 26\\n\\nNetTCP ..............................................\", \"....................................................................................................\", \"................................ 26\\n\\nHTTP ..........................................................\", \"....................................................................................................\", \"........................ 27\\n\\nNamed pipes ...........................................................\", \"....................................................................................................\", \"....... 27\\n\\nMSMQ ...................................................................................\", \"................................................................................................ 27\\n\", \"\\nWebHttpBinding ....................................................................................\", \"........................................................................... 27\\n\\nTypes of RPC .......\", \"....................................................................................................\", \"................................................................ 27\\n\\nRequest/reply..................\", \"....................................................................................................\", \"............................................... 28\\n\\nWCF duplex, one way to client ..................\", \"....................................................................................................\", \"............. 28\\n\\nWCF one-way operations and gRPC client streaming .................................\", \"..................................................... 30\\n\\nWCF full-duplex services .................\", \"....................................................................................................\", \".......................... 31\\n\\nMetadata ............................................................\", \"....................................................................................................\", \".................. 32\\n\\nError handling ..............................................................\", \"....................................................................................................\", \"....... 33\\n\\nRaise errors in ASP.NET Core gRPC ......................................................\", \".................................................................... 34\\n\\nCatch errors in gRPC client\", \"s ..................................................................................................\", \"....................................... 34\\n\\ngRPC richer error model ................................\", \"....................................................................................................\", \"............ 35\\n\\nWS-* protocols.....................................................................\", \".................................................................................................. 3\", \"5\\n\\nMetadata exchange: WS-Policy, WS-Discovery, and so on ...........................................\", \".................................. 35\\n\\nSecurity: WS-Security, WS-Federation, XML Encryption, and so \", \"on ............................................................ 35\\n\\nWS-ReliableMessaging ...........\", \"....................................................................................................\", \"................................... 36\\n\\nWS-Transaction, WS-Coordination ............................\", \"............................................................................................... 36\\n\\n\", \"ii\\n\\nContents\\n\\n\\fMigrate a WCF solution to gRPC ......................................................\", \"................................... 37\\n\\nCreate a new ASP.NET Core gRPC project .....................\", \"............................................................................................. 37\\n\\nCr\", \"eate the project by using Visual Studio ............................................................\", \".................................................. 37\\n\\nCreate the project by using the .NET CLI ....\", \"....................................................................................................\", \"........ 40\\n\\nClean up the example code .............................................................\", \"............................................................................ 41\\n\\nMigrate a WCF reque\", \"st-reply service to a gRPC unary RPC ...............................................................\", \"................. 42\\n\\nThe WCF solution .............................................................\", \"................................................................................................ 42\\n\", \"\\nThe portfolios.proto file .........................................................................\", \"........................................................................ 44\\n\\nConvert the DataContrac\", \"t classes to gRPC messages .........................................................................\", \".............. 44\\n\\nConvert ServiceContract to a gRPC service .......................................\", \".................................................................... 45\\n\\nMigrate the PortfolioData l\", \"ibrary to .NET .....................................................................................\", \".......................... 46\\n\\nUse ASP.NET Core dependency injection ...............................\", \"................................................................................ 47\\n\\nImplement the g\", \"RPC service.........................................................................................\", \"............................................... 48\\n\\nGenerate client code ...........................\", \"....................................................................................................\", \"........................ 50\\n\\nMigrate WCF duplex services to gRPC ...................................\", \"...................................................................................... 53\\n\\nServer st\", \"reaming RPC ........................................................................................\", \"............................................................. 53\\n\\nBidirectional streaming ..........\", \"....................................................................................................\", \".................................... 58\\n\\ngRPC streaming services vs. repeated fields ...............\", \"............................................................................................... 63\\n\\n\", \"When to use repeated fields.........................................................................\", \"............................................................... 63\\n\\nWhen to use stream methods .....\", \"....................................................................................................\", \"............................ 64\\n\\nCreate gRPC client libraries ......................................\", \"....................................................................................................\", \"..... 64\\n\\nUseful extensions ........................................................................\", \"..................................................................................... 65\\n\\nSummary ..\", \"....................................................................................................\", \"........................................................................ 67\\n\\nSecurity in gRPC applic\", \"ations .............................................................................................\", \". 68\\n\\nWCF authentication and authorization .........................................................\", \"............................................................... 68\\n\\ngRPC authentication and authoriz\", \"ation ..............................................................................................\", \"......................... 68\\n\\nCall credentials .....................................................\", \"....................................................................................................\", \".............. 69\\n\\nWS-Federation ...................................................................\", \"............................................................................................... 69\\n\\n\", \"JWT Bearer tokens ..................................................................................\", \"......................................................................... 69\\n\\nAdd authentication and\", \" authorization to the server........................................................................\", \".................. 70\\n\\nProvide call credentials in the client application ..........................\", \"....................................................................... 71\\n\\nChannel credentials ....\", \"....................................................................................................\", \"...................................................... 72\\n\\niii\\n\\nContents\\n\\n\\fAdd certificate authentic\", \"ation to the server ................................................................................\", \".......................... 72\\n\\nProvide channel credentials in the client application ...............\", \"......................................................................... 73\\n\\nCombine ChannelCredent\", \"ials and CallCredentials ...........................................................................\", \".................. 74\\n\\nEncryption and network security .............................................\", \"....................................................................................... 75\\n\\ngRPC in \", \"production .........................................................................................\", \"...................... 77\\n\\nSelf-hosted gRPC applications ...........................................\", \"............................................................................................. 77\\n\\nRu\", \"n your app as a Windows service ....................................................................\", \"..................................................... 77\\n\\nRun your app as a Linux service with syste\", \"md .................................................................................................\", \".... 78\\n\\nHTTPS certificates for self-hosted applications ...........................................\", \"......................................................... 80\\n\\nCreate Docker images .................\", \"....................................................................................................\", \".................................... 81\\n\\nMicrosoft base images for ASP.NET Core applications .......\", \".............................................................................. 81\\n\\nCreate a Docker i\", \"mage ...............................................................................................\", \"................................................... 82\\n\\nBuild the image ............................\", \"....................................................................................................\", \"................................. 84\\n\\nRun the image in a container on your machine .................\", \"................................................................................. 84\\n\\nPush the image\", \" to a registry .....................................................................................\", \"................................................... 84\\n\\nKubernetes .................................\", \"....................................................................................................\", \".......................................... 85\\n\\nKubernetes terminology ..............................\", \"....................................................................................................\", \".............. 85\\n\\nGet started with Kubernetes .....................................................\", \"................................................................................... 86\\n\\nRun services\", \" on Kubernetes .....................................................................................\", \".................................................... 87\\n\\nService meshes ............................\", \"....................................................................................................\", \"....................................... 93\\n\\nService mesh options ...................................\", \"....................................................................................................\", \"............... 94\\n\\nExample: Add Linkerd to a deployment ...........................................\", \"....................................................................... 94\\n\\nLoad balancing gRPC ....\", \"....................................................................................................\", \".................................................. 97\\n\\nL4 load balancers ...........................\", \"....................................................................................................\", \".............................. 97\\n\\nL7 load balancers ...............................................\", \"....................................................................................................\", \".......... 97\\n\\nLoad balancing within Kubernetes ....................................................\", \"........................................................................ 98\\n\\nApplication Performance\", \" Management ........................................................................................\", \"............................... 98\\n\\nThe difference between logging and metrics .....................\", \".................................................................................. 98\\n\\nLogging in AS\", \"P.NET Core gRPC ....................................................................................\", \"............................................. 98\\n\\nMetrics in ASP.NET Core gRPC .....................\", \"....................................................................................................\", \".......... 99\\n\\nDistributed tracing .................................................................\", \"........................................................................................ 101\\n\\nAppend\", \"ix A - Transactions ................................................................................\", \"................. 104\\n\\niv\\n\\nContents\\n\\n\\fCHAPTER  1\\n\\nIntroduction to gRPC for\\nWCF developers\\n\\nHelping m\", \"achines communicate with each other has been one of the primary preoccupations of the\\ndigital age. I\", \"n particular, there\\u2019s an ongoing effort to determine the optimal remote communication\\nmechanism that\", \" will suit the interoperability demands of the current infrastructure. As you can\\nimagine, that mech\", \"anism changes as either the demands or the infrastructure evolves.\\n\\nThe release of .NET Core 3.0 mar\", \"ks a shift in the way that Microsoft delivers remote communication\\nsolutions to developers who want \", \"to deliver services across a range of platforms. .NET Core and later\\ndoesn\\u2019t offer Windows Communica\", \"tion Foundation (WCF) out of the box but, with the release of\\nASP.NET Core 3.0, it does provide buil\", \"t-in gRPC functionality.\\n\\ngRPC is a popular framework in the wider software community. It\\u2019s used by \", \"developers across many\\nprogramming languages for modern RPC scenarios. The community and the ecosyst\", \"em are vibrant\\nand active. Support for the gRPC protocol is being added to infrastructure components\", \" like\\nKubernetes, service meshes, load balancers, and more. These factors, together with its perform\", \"ance,\\nefficiency, and cross-platform compatibility, make gRPC a natural choice for new apps and WCF \", \"apps\\nmoving to .NET.\\n\\nHistory\\n\\nThe fundamental principle of a computer network as nothing more than \", \"a group of computers\\nexchanging data with each other to achieve a set of interrelated tasks hasn\\u2019t c\", \"hanged since its\\ninception. But the complexity, scale, and expectations have grown exponentially.\\n\\nD\", \"uring the 1990s, the emphasis was mainly on improving internal networks that used the same\\nlanguage \", \"and platforms. TCP/IP became the gold standard for this type of communication.\\n\\nThe focus soon shift\", \"ed to how best to optimize communication across multiple platforms by\\npromoting a language-agnostic \", \"approach. Service-oriented architecture (SOA) provided a structure\\nfor loosely coupling a broad coll\", \"ection of services that could be provided to an application.\\n\\nThe development of web services occurr\", \"ed when all major platforms could access the internet, but\\nthey still couldn\\u2019t interact with each ot\", \"her. Web services have open standards and protocols,\\nincluding:\\n\\n\\u2022\\n\\nXML to tag and code data.\\n\\n1\\n\\nCH\", \"APTER 1 | Introduction to gRPC for WCF developers\\n\\n\\f\\u2022\\n\\nSimple Object Access Protocol (SOAP) to trans\", \"fer data.\\n\\n\\u2022  Web Services Definition Language (WSDL) to describe and connect web services to client\", \"\\n\\napplications.\\n\\n\\u2022\\n\\nUniversal Description, Discovery, and Integration (UDDI) to make web services di\", \"scoverable by\\nother services.\\n\\nSOAP defines the rules by which distributed elements of an applicatio\", \"n can communicate with each\\nother, even if they\\u2019re on different platforms. SOAP is based on XML, so \", \"it\\u2019s human-readable. The\\nsacrifice for making SOAP easily understood is size; SOAP messages are larg\", \"er than messages in\\ncomparable protocols. SOAP was designed to break monolithic applications into mu\", \"lticomponent\\nform without losing security or control. So WCF was designed to work with that kind of \", \"system, unlike\\ngRPC, which began as a distributed system. WCF addressed some of these limitations by\", \" developing\\nand documenting proprietary extension protocols for the SOAP stack, but at the cost of a\", \" lack of\\nsupport from other platforms.\\n\\nWindows Communication Foundation is a framework for building\", \" services. It was designed in the early\\n2000s to help developers using early SOA to manage the compl\", \"exities of working with SOAP.\\nAlthough it removes the requirement for the developers to write their \", \"own SOAP protocols, WCF still\\nuses SOAP to enable interoperability with other systems. WCF was also \", \"designed to deliver solutions\\nacross multiple protocols (HTTP/1.1, Net.TCP, and so on).\\n\\nMicroservic\", \"es\\n\\nIn microservice architectures, large applications are built as a collection of smaller modular s\", \"ervices.\\nEach component does a specific task or process, and components are designed to work interop\", \"erably\\nbut can be isolated as necessary.\\n\\nAdvantages to microservices include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nChanges \", \"and upgrades can be handled independently.\\n\\nError handling becomes more efficient because problems c\", \"an be traced to specific services\\nthat are then isolated, rebuilt, tested, and redeployed independen\", \"tly of the other services.\\n\\nScalability can be confined to specific instances or services rather tha\", \"n the whole application.\\n\\nDevelopment can happen across multiple teams, with less friction than occu\", \"rs when many\\nteams work on a single codebase.\\n\\nThe move towards increasing virtualization, cloud com\", \"puting, containers, and the Internet of Things\\nhas contributed to the ongoing rise of microservices.\", \" But microservices aren\\u2019t without their challenges.\\nThe fragmented/decentralized infrastructure put \", \"more emphasis on the need for simplicity and speed\\nwhen communicating between services. This in turn\", \" drew attention to the sometimes laborious and\\ncontorted nature of SOAP.\\n\\nIt was into this environme\", \"nt that gRPC was launched, 10 years after Microsoft first released WCF.\\nEvolved directly from Google\", \"\\u2019s internal infrastructure RPC (Stubby), gRPC was never based on the\\nsame standards and protocols th\", \"at had informed the parameters of many earlier RPCs. And gRPC was\\nonly ever based on HTTP/2. That\\u2019s \", \"why it could draw on the new capabilities that advanced transport\\nprotocol provided. In particular, \", \"bidirectional streaming, binary messaging, and multiplexing.\\n\\n2\\n\\nCHAPTER 1 | Introduction to gRPC fo\", \"r WCF developers\\n\\n\\fAbout this guide\\n\\nThis guide covers the key features of gRPC. The early chapters \", \"take a high-level look at the main\\nfeatures of WCF and compare them to those of gRPC. It identifies \", \"where there are direct correlations\\nbetween WCF and gRPC and also where gRPC offers an advantage. Wh\", \"en there\\u2019s no correlation\\nbetween WCF and gRPC, or when gRPC isn\\u2019t able to offer an equivalent solut\", \"ion to WCF, this guide\\nwill suggest workarounds or where to go for more information.\\n\\nUsing a set of\", \" sample WCF applications, Chapter 5 is a deep-dive look at converting the main types of\\nWCF service \", \"(simple request-reply, one-way, and streaming) to their equivalents in gRPC.\\n\\nThe final section of t\", \"he book looks at how to get the best from gRPC in practice. This section includes\\ninformation on usi\", \"ng additional tools, like Docker containers or Kubernetes, to take advantage of the\\nefficiency of gR\", \"PC. It also includes a detailed look at monitoring with logging, metrics, and distributed\\ntracing.\\n\\n\", \"Who this guide is for\\n\\nThis guide was written for developers working in .NET Framework or .NET Core \", \"who have used WCF\\nand who are seeking to migrate their applications to a modern RPC environment for \", \".NET Core 3.0\\nand later versions. The guide might also be useful more generally for developers upgra\", \"ding or\\nconsidering upgrading to .NET and who want to use the built-in gRPC tools.\\n\\n3\\n\\nCHAPTER 1 | I\", \"ntroduction to gRPC for WCF developers\\n\\n\\fCHAPTER  2\\n\\ngRPC overview\\n\\nAfter looking at the genesis of \", \"both Windows Communication Foundation (WCF) and gRPC in the last\\nchapter, this chapter considers som\", \"e of the key features of gRPC and how they compare to WCF.\\n\\nASP.NET Core 3.0 is the first release of\", \" ASP.NET that natively supports gRPC as a first-class citizen,\\nwith Microsoft teams contributing to \", \"the official .NET implementation of gRPC. It\\u2019s recommended for\\nbuilding distributed applications wit\", \"h .NET that can interoperate with all other major programming\\nlanguages and frameworks.\\n\\nKey princip\", \"les\\n\\nAs discussed in chapter 1, Google wanted to use the introduction of HTTP/2 to replace Stubby, i\", \"ts\\ninternal, general purpose RPC infrastructure. gRPC, based on Stubby, now can take advantage of\\nst\", \"andardization and would extend its applicability to mobile computing, the cloud, and the Internet of\", \"\\nThings.\\n\\nTo achieve this standardization, the Cloud Native Computing Foundation (CNCF) established \", \"a set of\\nprinciples that would govern gRPC. The following list shows the most relevant ones, which a\", \"re\\nprimarily concerned with maximizing accessibility and usability:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nFree and open \\u2013 \", \"All artifacts should be open source, with licensing that doesn\\u2019t constrain\\ndevelopers from adopting \", \"gRPC.\\n\\nCoverage and simplicity \\u2013 gRPC should be available across every popular platform, and\\nsimple \", \"enough to build on any platform.\\n\\nInteroperability and reach \\u2013 It should be possible to use gRPC on \", \"any network, regardless of\\nbandwidth or latency, by using widely available network standards.\\n\\nGener\", \"al purpose and performant \\u2013 The framework should be usable by as broad a range of\\nuse-cases as possi\", \"ble, without compromising performance.\\n\\nStreaming \\u2013 The protocol should provide streaming semantics \", \"for large datasets or\\nasynchronous messaging.\\n\\n\\u2022  Metadata exchange \\u2013 The protocol allows non-busine\", \"ss data, such as authentication tokens,\\n\\nto be handled separately from actual business data.\\n\\n\\u2022\\n\\nSta\", \"ndardized status codes \\u2013 The variability of error codes should be reduced to make error\\nhandling dec\", \"isions clearer. Where additional, richer error handling is required, a mechanism\\nshould be provided \", \"for managing behavior within the metadata exchange.\\n\\n4\\n\\nCHAPTER 2 | gRPC overview\\n\\n\\fHow gRPC approac\", \"hes RPC\\n\\nWindows Communication Foundation (WCF) and gRPC are both implementations of the Remote\\nProc\", \"edure Call (RPC) pattern. This pattern aims to make calls to services that run on a different\\nmachin\", \"e, or in a different process, work seamlessly, like method calls in the client application. While\\nth\", \"e aims of WCF and gRPC are the same, the details of the implementation are quite different.\\n\\nThe fol\", \"lowing table sets out how the key features of WCF relate to gRPC, and where you can find\\nmore detail\", \"ed explanations.\\n\\nFeatures\\n\\nWCF\\n\\ngRPC\\n\\nObjective\\n\\nDefine services and messages (chapters 3-4)\\n\\nLangu\", \"age (chapters 3-5)\\n\\nWire format (chapter 3)\\n\\nInteroperability (chapter 4)\\n\\nNetworking (chapter 4)\\n\\nS\", \"eparate business\\ncode from\\nnetworking\\nimplementation.\\n\\nSeparate business code\\nfrom interface definit\", \"ion\\nand networking\\nimplementation.\\n\\nService Contract,\\nOperation\\nContract, and\\nData Contract.\\n\\nContra\", \"cts written\\nin C# or Visual\\nBasic.\\n\\nConfigurable,\\nincluding\\nSOAP/XML, Plain\\nXML, JSON, and\\n.NET Bina\", \"ry.\\n\\nWhen using\\nSOAP over HTTP.\\n\\nConfigured at run\\ntime. Switch\\nbetween NetTCP,\\nHTTP, and\\nMSMQ.\\n\\nUse\", \"s proto file to\\ndeclare services and\\nmessages.\\n\\nProtocol Buffer\\nlanguage.\\n\\nProtocol Buffer binary\\nfo\", \"rmat (although it\\u2019s\\npossible to use other\\nformats).\\n\\nOfficial support: .NET,\\nJava, Python, JavaScrip\", \"t,\\nC/C++, Go, Rust, Ruby,\\nSwift, Dart, PHP.\\nUnofficial support for\\nother languages from\\nthe communit\", \"y.\\n\\nHTTP/2, currently over\\nTCP only with ASP.NET\\nCore gRPC.\\n\\n5\\n\\nCHAPTER 2 | gRPC overview\\n\\n\\fFeatures\", \"\\n\\nWCF\\n\\ngRPC\\n\\nApproach (chapter 4)\\n\\nSecurity (chapter 6)\\n\\nRuntime\\ngeneration of\\nserialization,\\ndeseri\", \"alization,\\nand networking\\ncode in base\\nclasses.\\n\\nAuthentication,\\nWS-Security,\\nmessage\\nencryption.\\n\\nB\", \"uild-time generation of\\nserialization,\\ndeserialization, and\\nnetworking code in base\\nclasses.\\n\\nCreden\", \"tials, ASP.NET\\nCore security, TLS\\nnetworking.\\n\\nInterface Definition Language\\n\\nWith Windows Communica\", \"tion Foundation (WCF), services can expose description metadata by using\\nthe Web Service Definition \", \"Language (WSDL). WSDL is generated dynamically by using .NET reflection\\nat run time. Developers can \", \"use this metadata to generate clients for those services, potentially in\\nother languages if they\\u2019re \", \"using a platform-neutral binding such as SOAP over HTTP.\\n\\ngRPC uses the Interface Definition Languag\", \"e (IDL) from Protocol Buffers. The Protocol Buffers IDL is a\\ncustom, platform-neutral language with \", \"an open specification. Developers author .proto files to\\ndescribe services, along with their inputs \", \"and outputs. These .proto files can then be used to generate\\nlanguage- or platform-specific stubs fo\", \"r clients and servers, allowing multiple different platforms to\\ncommunicate. By sharing .proto files\", \", teams can generate code to use each others\\u2019 services, without\\nneeding to take a code dependency.\\n\\n\", \"One of the advantages of the Protobuf IDL is that as a custom language, it enables gRPC to be\\ncomple\", \"tely language and platform agnostic, not favoring any technology over another.\\n\\nThe Protobuf IDL is \", \"also designed for humans to both read and write, whereas WSDL is intended as a\\nmachine-readable/writ\", \"able format. Changing the WSDL of a WCF service typically requires changing\\nthe service, running the\", \" service, and regenerating the WSDL file from the server. By contrast, with a\\n.proto file, changes a\", \"re simple to apply with a text editor, and automatically flow through the\\ngenerated code. Visual Stu\", \"dio 2022 builds .proto files in the background when they are saved. With\\nother editors, such as VS C\", \"ode, the changes are applied when the project is built.\\n\\nWhen compared with XML, and particularly SO\", \"AP, messages encoded by using Protobuf have many\\nadvantages. Protobuf messages tend to be smaller th\", \"an the same data serialized as SOAP XML, and\\nencoding, decoding, and transmitting them over a networ\", \"k can be faster.\\n\\nThe potential disadvantage of Protobuf compared to SOAP is that, because the messa\", \"ges aren\\u2019t\\nreadable by humans, additional tooling is required to debug message content.\\n\\n6\\n\\nCHAPTER \", \"2 | gRPC overview\\n\\n\\fTip\\n\\ngRPC does support server reflection for dynamically accessing services with\", \"out pre-compiled stubs,\\nalthough it\\u2019s intended more for general-purpose tools than application-speci\", \"fic clients. For more\\ninformation, see GRPC Server Reflection Protocol on GitHub.\\n\\nNote\\n\\nWCF\\u2019s binar\", \"y format, used with the NetTCP binding, is much closer to Protobuf in terms of\\ncompactness and perfo\", \"rmance. But NetTCP is only usable between .NET clients and servers, whereas\\nProtobuf is a cross-plat\", \"form solution.\\n\\nNetwork protocols\\n\\nUnlike Windows Communication Foundation (WCF), gRPC uses HTTP/2 a\", \"s a base for its networking.\\nThis protocol offers significant advantages over WCF and SOAP, which op\", \"erate only on HTTP/1.1. For\\ndevelopers wanting to use gRPC, given that there\\u2019s no alternative to HTT\", \"P/2, it would seem to be the\\nideal moment to explore HTTP/2 in more detail and identify additional b\", \"enefits of using gRPC.\\n\\nHTTP/2, released by Internet Engineering Task Force in 2015, was derived fro\", \"m the experimental SPDY\\nprotocol, which was already being used by Google. It was specifically design\", \"ed to be more efficient,\\nfaster, and more secure than HTTP/1.1.\\n\\nKey features of HTTP/2\\n\\nThis list s\", \"hows some of the key features and advantages of HTTP/2:\\n\\nBinary protocol\\n\\nRequest/response cycles no\", \" longer need text commands. This activity simplifies and speeds up the\\nimplementation of commands. S\", \"pecifically, parsing data is faster and uses less memory, network\\nlatency is reduced with obvious re\", \"lated improvements to speed, and there\\u2019s an overall better use of\\nnetwork resources.\\n\\nStreams\\n\\nStrea\", \"ms allow you to create long-lived connections between sender and receiver, over which multiple\\nmessa\", \"ges or frames can be sent asynchronously. Multiple streams can operate independently over a\\nsingle H\", \"TTP/2 connection.\\n\\nRequest multiplexing over a single TCP connection\\n\\nThis feature is one of the mos\", \"t important innovations of HTTP/2. Because it allows multiple parallel\\nrequests for data, it\\u2019s now p\", \"ossible to download web files concurrently from a single server. Websites\\nload faster, and the need \", \"for optimization is reduced. Head-of-line (HOL) blocking, where responses\\n\\n7\\n\\nCHAPTER 2 | gRPC overv\", \"iew\\n\\n\\fthat are ready must wait to be sent until an earlier request is completed, is also mitigated (\", \"although\\nHOL blocking can still occur at the TCP-transport level).\\n\\nNet.TCP-like performance, cross-\", \"platform\\n\\nFundamentally, the combination of gRPC and HTTP/2 offers developers at least the equivalen\", \"t speed\\nand efficiency of Net.TCP bindings for WCF, and in some cases even greater speed and efficie\", \"ncy. But,\\nunlike Net.TCP, gRPC over HTTP/2 isn\\u2019t constrained to .NET applications.\\n\\nWhy we recommend\", \" gRPC for WCF developers\\n\\nBefore we dive deeply into the language and techniques of gRPC, it\\u2019s worth\", \" discussing why gRPC is\\nthe right solution for Windows Communication Foundation (WCF) developers who\", \" want to migrate to\\n.NET.\\n\\nSimilarity to WCF\\n\\nAlthough the implementation and approach are different\", \" for gRPC, the experience of developing and\\nconsuming services with gRPC should be intuitive for WCF\", \" developers. The underlying goal is the\\nsame: make it possible to code as though the client and serv\", \"er are on the same platform, without\\nneeding to worry about networking.\\n\\nBoth platforms share the pr\", \"inciple of declaring and then implementing an interface, even though the\\nprocess for declaring that \", \"interface is different. And as you\\u2019ll see in chapter 5, the different types of\\nRPC calls that gRPC s\", \"upports map well to the bindings available to WCF services.\\n\\nBenefits of gRPC\\n\\ngRPC stands above oth\", \"er solutions for the following reasons.\\n\\nPerformance\\n\\nUsing HTTP/2 rather than HTTP/1.1 removes the \", \"requirement for human-readable messages and\\ninstead uses the smaller, faster binary protocol. This i\", \"s more efficient for computers to parse. HTTP/2\\nalso supports multiplexing requests over a single co\", \"nnection. This support enables responses to be\\nsent as soon as they\\u2019re ready without the need to wai\", \"t in a queue. (In HTTP/1.1, this issue is known as\\n\\u201chead-of-line (HOL) blocking.\\u201d) You need fewer re\", \"sources when using gRPC, which makes it a good\\nsolution to use for mobile devices and over slower ne\", \"tworks.\\n\\nInteroperability\\n\\nThere are gRPC tools and libraries for all major programming languages an\", \"d platforms, including\\n.NET, Java, Python, Go, C++, Node.js, Swift, Dart, Ruby, and PHP. Thanks to t\", \"he Protocol Buffers binary\\nwire format and the efficient code generation for each platform, develope\", \"rs can build performant\\napps while still enjoying full cross-platform support.\\n\\n8\\n\\nCHAPTER 2 | gRPC \", \"overview\\n\\n\\fUsability and productivity\\n\\ngRPC is a comprehensive RPC solution. It works consistently a\", \"cross multiple languages and platforms.\\nIt also provides excellent tooling, with much of the necessa\", \"ry boilerplate code automatically\\ngenerated. So more developer time is freed up to focus on business\", \" logic.\\n\\nStreaming\\n\\ngRPC has full bidirectional streaming, which provides similar functionality to W\", \"CF\\u2019s full-duplex\\nservices. gRPC streaming can operate over regular internet connections, load balanc\", \"ers, and service\\nmeshes.\\n\\nDeadline/timeouts and cancellation\\n\\ngRPC allows clients to specify a maxim\", \"um time for an RPC to finish. If the specified deadline is\\nexceeded, the server can cancel the opera\", \"tion independently of the client. Deadlines and cancellations\\ncan be propagated through further gRPC\", \" calls to help enforce resource usage limits. Clients can also\\nstop operations when a deadline is ex\", \"ceeded, or earlier if necessary (for example, because of a user\\ninteraction).\\n\\nSecurity\\n\\ngRPC is imp\", \"licitly secure when it\\u2019s using HTTP/2 over a TLS end-to-end encrypted connection. Support\\nfor client\", \" certificate authentication (see chapter 6) further increases security and trust between client\\nand \", \"server.\\n\\nComparison with CoreWCF\\n\\nA notable alternative to gRPC for replacing WCF services when migr\", \"ating to .NET is CoreWCF. Both\\ngRPC and CoreWCF are Microsoft endorsed paths forward for WCF applica\", \"tions and each comes with\\nits own benefits and drawbacks.\\n\\nCoreWCF is a community-owned .NET Foundat\", \"ion project supported by Microsoft that implements\\nWCF server APIs for .NET. CoreWCF is an effort to\", \" allow existing WCF services to work with minimal\\nchanges on .NET. Your Data Contracts for WCF are u\", \"nchanged with CoreWCF, and it supports many of\\nthe bindings and APIs from WCF. The main differences \", \"are around the patterns for starting WCF\\nservices, and not all configuration options are available (\", \"some configuration must now be done in\\ncode).\\n\\nServices and interfaces can often migrate with few ch\", \"anges. Because of this, a key benefit of CoreWCF\\nis its very high compatibility with WCF. Where chan\", \"ges have been made, they are to adapt to the\\nprogramming style of modern .NET, for example hosting n\", \"ow through ASP.NET Core, and APIs now\\nuse the Task based async patterns usable with await rather tha\", \"n the older BeginXXX / EndXXX pattern.\\n\\nOn the other hand, gRPC is a modern remote communication sol\", \"ution with a number of features, as\\ndiscussed previously. Benefits of using gRPC include better inte\", \"roperability across languages, its\\nrelatively simple modern API, and a broad community ecosystem.\\n\\nW\", \"hen deciding whether to use CoreWCF or gRPC to migrate a WCF application to .NET, CoreWCF is\\ntypical\", \"ly a better fit if the goal is to migrate the application with minimal changes whereas gRPC may\\n\\n9\\n\\n\", \"CHAPTER 2 | gRPC overview\\n\\n\\fbe a better fit if the goal is to modernize the application while retarg\", \"eting to .NET. The remainder of\\nthis guide focuses on that modernization with gRPC.\\n\\n10\\n\\nCHAPTER 2 |\", \" gRPC overview\\n\\n\\fCHAPTER  3\\n\\nProtocol buffers\\n\\ngRPC services send and receive data as Protocol Buffe\", \"r (Protobuf) messages, similar to data contracts in\\nWindows Communication Foundation (WCF). Protobuf\", \" is an efficient way of serializing structured data\\nfor machines to read and write, without the over\", \"head that human-readable formats like XML or JSON\\nincur.\\n\\nThis chapter covers how Protobuf works, an\", \"d how to define your own Protobuf messages.\\n\\nHow Protobuf works\\n\\nMost .NET object serialization tech\", \"niques, including WCF\\u2019s data contracts, work by using reflection to\\nanalyze the object structure at \", \"run time. By contrast, most Protobuf libraries require you to define the\\nstructure up front by using\", \" a dedicated language (Protocol Buffer Language) in a .proto file. A compiler\\nthen uses this file to\", \" generate code for any of the supported platforms. Supported platforms include\\n.NET, Java, C/C++, Ja\", \"vaScript, and many more.\\n\\nThe Protobuf compiler, protoc, is maintained by Google, although alternati\", \"ve implementations are\\navailable. The generated code is efficient and optimized for fast serializati\", \"on and deserialization of\\ndata.\\n\\nThe Protobuf wire format is a binary encoding. It uses some clever \", \"tricks to minimize the number of\\nbytes used to represent messages. Knowledge of the binary encoding \", \"format isn\\u2019t necessary to use\\nProtobuf. But if you\\u2019re interested, you can learn more about it on the\", \" Protocol Buffers website.\\n\\nProtobuf messages\\n\\nThis section covers how to declare Protocol Buffer (P\", \"rotobuf) messages in .proto files. It explains the\\nfundamental concepts of field numbers and types, \", \"and it looks at the C# code that the protoc\\ncompiler generates.\\n\\nThe rest of the chapter will look i\", \"n more detail at how different types of data are represented in\\nProtobuf.\\n\\nDeclaring a message\\n\\nIn W\", \"indows Communication Foundation (WCF), a Stock class for a stock market trading application\\nmight be\", \" defined like the following example:\\n\\nnamespace TraderSys;\\n\\n11\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\f[Data\", \"Contract]\\npublic class Stock\\n{\\n    [DataMember]\\n    public int Id { get; set; }\\n    [DataMember]\\n   \", \" public string Symbol { get; set; }\\n    [DataMember]\\n    public string DisplayName { get; set; }\\n   \", \" [DataMember]\\n    public int MarketId { get; set; }\\n}\\n\\nTo implement the equivalent class in Protobuf\", \", you must declare it in the .proto file. The protoc\\ncompiler will then generate the .NET class as p\", \"art of the build process.\\n\\nsyntax = \\\"proto3\\\";\\n\\noption csharp_namespace = \\\"TraderSys\\\";\\n\\nmessage Stock\", \" {\\n\\n    int32 id = 1;\\n    string symbol = 2;\\n    string display_name = 3;\\n    int32 market_id = 4;\\n\\n\", \"}\\n\\nThe first line declares the syntax version being used. Version 3 of the language was released in \", \"2016.\\nIt\\u2019s the version that we recommend for gRPC services.\\n\\nThe option csharp_namespace line specif\", \"ies the namespace to be used for the generated C# types.\\nThis option will be ignored when the .proto\", \" file is compiled for other languages. Protobuf files often\\ncontain language-specific options for se\", \"veral languages.\\n\\nThe Stock message definition specifies four fields. Each has a type, a name, and a\", \" field number.\\n\\nField numbers\\n\\nField numbers are an important part of Protobuf. They\\u2019re used to iden\", \"tify fields in the binary encoded\\ndata, which means they can\\u2019t change from version to version of you\", \"r service. The advantage is that\\nbackward compatibility and forward compatibility are possible. Clie\", \"nts and services will ignore field\\nnumbers that they don\\u2019t know about, as long as the possibility of\", \" missing values is handled.\\n\\nIn the binary format, the field number is combined with a type identifi\", \"er. Field numbers from 1 to 15\\ncan be encoded with their type as a single byte. Numbers from 16 to 2\", \",047 take 2 bytes. You can go\\nhigher if you need more than 2,047 fields on a message for any reason.\", \" The single-byte identifiers for\\nfield numbers 1 to 15 offer better performance, so you should use t\", \"hem for the most basic, frequently\\nused fields.\\n\\n12\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\fTypes\\n\\nThe type \", \"declarations are using Protobuf\\u2019s native scalar data types, which are discussed in more detail\\nin th\", \"e next section. The rest of this chapter will cover Protobuf\\u2019s built-in types and show how they\\nrela\", \"te to common .NET types.\\n\\nNote\\n\\nProtobuf doesn\\u2019t natively support a decimal type, so double is used \", \"instead. For applications that\\nrequire full decimal precision, refer to the section on decimals in t\", \"he next part of this chapter.\\n\\nThe generated code\\n\\nWhen you build your application, Protobuf creates\", \" classes for each of your messages, mapping its\\nnative types to C# types. The generated Stock type w\", \"ould have the following signature:\\n\\npublic class Stock\\n{\\n    public int Id { get; set; }\\n    public \", \"string Symbol { get; set; }\\n    public string DisplayName { get; set; }\\n    public int MarketId { ge\", \"t; set; }\\n}\\n\\nThe actual code that\\u2019s generated is far more complicated than this. The reason is that \", \"each class\\ncontains all the code necessary to serialize and deserialize itself to the binary wire fo\", \"rmat.\\n\\nProperty names\\n\\nNote that the Protobuf compiler applied PascalCase to the property names, alt\", \"hough they were\\nsnake_case in the .proto file. The Protobuf style guide recommends using snake_case \", \"in your message\\ndefinitions so that the code generation for other platforms produces the expected ca\", \"se for their\\nconventions.\\n\\nProtobuf scalar data types\\n\\nProtocol Buffer (Protobuf) supports a range o\", \"f native scalar value types. The following table lists them\\nall with their equivalent C# type:\\n\\nProt\", \"obuf type\\n\\nC# type\\n\\nNotes\\n\\ndouble\\n\\nFloat\\n\\nint32\\n\\nint64\\n\\nuint32\\n\\nuint64\\n\\n13\\n\\ndouble\\n\\nfloat\\n\\nint\\n\\nlong\", \"\\n\\nuint\\n\\nulong\\n\\n1\\n\\n1\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\fProtobuf type\\n\\nC# type\\n\\nNotes\\n\\nint\\n\\nlong\\n\\nuint\\n\\n\", \"ulong\\n\\nint\\n\\nlong\\n\\nbool\\n\\nstring\\n\\nByteString\\n\\n1\\n\\n1\\n\\n2\\n\\n2\\n\\n2\\n\\n2\\n\\n3\\n\\n4\\n\\nsint32\\n\\nsint64\\n\\nfixed32\\n\\nfixed64\", \"\\n\\nsfixed32\\n\\nsfixed64\\n\\nbool\\n\\nstring\\n\\nbytes\\n\\nNotes:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\nThe standard encoding for int32 a\", \"nd int64 is inefficient when you\\u2019re working with signed\\nvalues. If your field is likely to contain n\", \"egative numbers, use sint32 or sint64 instead. These\\ntypes map to the C# int and long types, respect\", \"ively.\\n\\nThe fixed fields always use the same number of bytes no matter what the value is. This\\nbehav\", \"ior makes serialization and deserialization faster for larger values.\\n\\nProtobuf strings are UTF-8 (o\", \"r 7-bit ASCII) encoded. The encoded length can\\u2019t be greater than\\n232.\\n\\nThe Protobuf runtime provides\", \" a ByteString type that maps easily to and from C# byte[]\\narrays.\\n\\nOther .NET primitive types\\n\\nDates\", \" and times\\n\\nThe native scalar types don\\u2019t provide for date and time values, equivalent to C#\\u2019s DateT\", \"imeOffset,\\nDateTime, and TimeSpan. You can specify these types by using some of Google\\u2019s \\u201cWell Known\", \" Types\\u201d\\nextensions. These extensions provide code generation and runtime support for complex field t\", \"ypes\\nacross the supported platforms.\\n\\nThe following table shows the date and time types:\\n\\nC# type\\n\\nP\", \"rotobuf well-known type\\n\\nDateTimeOffset\\n\\ngoogle.protobuf.Timestamp\\n\\nDateTime\\n\\nTimeSpan\\n\\ngoogle.proto\", \"buf.Timestamp\\n\\ngoogle.protobuf.Duration\\n\\nsyntax = \\\"proto3\\\"\\n\\nimport \\\"google/protobuf/duration.proto\\\";\", \"\\nimport \\\"google/protobuf/timestamp.proto\\\";\\n\\nmessage Meeting {\\n\\n14\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\f  \", \"  string subject = 1;\\n    google.protobuf.Timestamp time = 2;\\n    google.protobuf.Duration duration \", \"= 3;\\n\\n}\\n\\nThe generated properties in the C# class aren\\u2019t the .NET date and time types. The propertie\", \"s use the\\nTimestamp and Duration classes in the Google.Protobuf.WellKnownTypes namespace. These clas\", \"ses\\nprovide methods for converting to and from DateTimeOffset, DateTime, and TimeSpan.\\n\\n// Create Ti\", \"mestamp and Duration from .NET DateTimeOffset and TimeSpan\\nvar meeting = new Meeting\\n{\\n    Time = Ti\", \"mestamp.FromDateTimeOffset(meetingTime), // also FromDateTime()\\n    Duration = Duration.FromTimeSpan\", \"(meetingLength)\\n};\\n\\n// Convert Timestamp and Duration to .NET DateTimeOffset and TimeSpan\\nDateTimeOf\", \"fset time = meeting.Time.ToDateTimeOffset();\\nTimeSpan? duration = meeting.Duration?.ToTimeSpan();\\n\\nN\", \"ote\\n\\nThe Timestamp type works with UTC times. DateTimeOffset values always have an offset of zero, a\", \"nd\\nthe DateTime.Kind property is always DateTimeKind.Utc.\\n\\nSystem.Guid\\n\\nProtobuf doesn\\u2019t directly su\", \"pport the Guid type, known as UUID on other platforms. There\\u2019s no well-\\nknown type for it.\\n\\nThe best\", \" approach is to handle Guid values as a string field, by using the standard 8-4-4-4-12\\nhexadecimal f\", \"ormat (for example, 45a9fda3-bd01-47a9-8460-c1cd7484b0b3). All languages and\\nplatforms can parse tha\", \"t format.\\n\\nDon\\u2019t use a bytes field for Guid values. Problems with endianness (Wikipedia definition) \", \"can result in\\nerratic behavior when Protobuf is interacting with other platforms, such as Java.\\n\\nNul\", \"lable types\\n\\nThe Protobuf code generation for C# uses the native types, such as int for int32. So th\", \"e values are\\nalways included and can\\u2019t be null.\\n\\nFor values that require explicit null, such as usin\", \"g int? in your C# code, Protobuf\\u2019s \\u201cWell Known Types\\u201d\\ninclude wrappers that are compiled to nullable\", \" C# types. To use them, import wrappers.proto into\\nyour .proto file, like this:\\n\\nsyntax = \\\"proto3\\\"\\n\\n\", \"import \\\"google/protobuf/wrappers.proto\\\";\\n\\nmessage Person {\\n\\n15\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\f    .\", \"..\\n    google.protobuf.Int32Value age = 5;\\n\\n}\\n\\nProtobuf will use the simple T? (for example, int?) f\", \"or the generated message property.\\n\\nThe following table shows the complete list of wrapper types wit\", \"h their equivalent C# type:\\n\\nC# type\\n\\nWell Known Type wrapper\\n\\ndouble?\\n\\ngoogle.protobuf.DoubleValue\\n\", \"\\nfloat?\\n\\nint?\\n\\nlong?\\n\\nuint?\\n\\nulong?\\n\\ngoogle.protobuf.FloatValue\\n\\ngoogle.protobuf.Int32Value\\n\\ngoogle.\", \"protobuf.Int64Value\\n\\ngoogle.protobuf.UInt32Value\\n\\ngoogle.protobuf.UInt64Value\\n\\nThe well-known types \", \"Timestamp and Duration are represented in .NET as classes. In C# 8 and\\nbeyond, you can use nullable \", \"reference types. But it\\u2019s important to check for null on properties of\\nthose types when you\\u2019re conve\", \"rting to DateTimeOffset or TimeSpan.\\n\\nDecimals\\n\\nProtobuf doesn\\u2019t natively support the .NET decimal t\", \"ype, just double and float. There\\u2019s an ongoing\\ndiscussion in the Protobuf project about the possibil\", \"ity of adding a standard Decimal type to the well-\\nknown types, with platform support for languages \", \"and frameworks that support it. Nothing has been\\nimplemented yet.\\n\\nIt\\u2019s possible to create a message\", \" definition to represent the decimal type that would work for safe\\nserialization between .NET client\", \"s and servers. But developers on other platforms would have to\\nunderstand the format being used and \", \"implement their own handling for it.\\n\\nCreating a custom decimal type for Protobuf\\n\\nA simple implemen\", \"tation might be similar to the nonstandard Money type that some Google APIs\\nuse, without the currenc\", \"y field.\\n\\npackage CustomTypes;\\n\\n// Example: 12345.6789 -> { units = 12345, nanos = 678900000 }\\nmessa\", \"ge DecimalValue {\\n\\n    // Whole units part of the amount\\n    int64 units = 1;\\n\\n    // Nano units of \", \"the amount (10^-9)\\n    // Must be same sign as units\\n    sfixed32 nanos = 2;\\n}\\n\\n16\\n\\nCHAPTER 3 | Prot\", \"ocol buffers\\n\\n\\fThe nanos field represents values from 0.999_999_999 to -0.999_999_999. For example, \", \"the decimal\\nvalue 1.5m would be represented as { units = 1, nanos = 500_000_000 }. This is why the n\", \"anos field in\\nthis example uses the sfixed32 type, which encodes more efficiently than int32 for lar\", \"ger values. If the\\nunits field is negative, the nanos field should also be negative.\\n\\nNote\\n\\nThere ar\", \"e multiple other algorithms for encoding decimal values as byte strings, but this message is\\neasier \", \"to understand than any of them. The values are not affected by endianness on different\\nplatforms.\\n\\nC\", \"onversion between this type and the BCL decimal type might be implemented in C# like this:\\n\\nnamespac\", \"e CustomTypes;\\npublic partial class DecimalValue\\n{\\n    private const decimal NanoFactor = 1_000_000_\", \"000;\\n    public DecimalValue(long units, int nanos)\\n    {\\n        Units = units;\\n        Nanos = nan\", \"os;\\n    }\\n\\n    public static implicit operator decimal(CustomTypes.DecimalValue grpcDecimal)\\n    {\\n \", \"       return grpcDecimal.Units + grpcDecimal.Nanos / NanoFactor;\\n    }\\n\\n    public static implicit \", \"operator CustomTypes.DecimalValue(decimal value)\\n    {\\n        var units = decimal.ToInt64(value);\\n \", \"       var nanos = decimal.ToInt32((value - units) * NanoFactor);\\n        return new CustomTypes.Dec\", \"imalValue(units, nanos);\\n    }\\n}\\n\\nImportant\\n\\nWhenever you use custom message types like this, you mu\", \"st document them with comments in\\n.proto. Other developers can then implement conversion to and from\", \" the equivalent type in their own\\nlanguage or framework.\\n\\nProtobuf nested types\\n\\nJust as C# allows y\", \"ou to declare classes inside other classes, Protocol Buffer (Protobuf) allows you to\\nnest message de\", \"finitions within other messages. The following example shows how to create nested\\nmessage types:\\n\\nme\", \"ssage Outer {\\n    message Inner {\\n        string text = 1;\\n    }\\n\\n17\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\", \"\\f    Inner inner = 1;\\n}\\n\\nIn the generated C# code, the Inner type will be declared in a nested stati\", \"c Types class within the\\nHelloRequest class:\\n\\nvar inner = new Outer.Types.Inner { Text = \\\"Hello\\\" };\\n\", \"\\nRepeated fields for lists and arrays\\n\\nYou specify lists in Protocol Buffer (Protobuf) by using the \", \"repeated prefix keyword. The following\\nexample shows how to create a list:\\n\\nmessage Person {\\n    // \", \"Other fields elided\\n    repeated string aliases = 8;\\n}\\n\\nIn the generated code, repeated fields are r\", \"epresented by read-only properties of the\\nGoogle.Protobuf.Collections.RepeatedField<T> type rather t\", \"han any of the built-in .NET collection\\ntypes. This type implements all the standard .NET collection\", \" interfaces, such as IList and IEnumerable.\\nSo you can use LINQ queries or convert it to an array or\", \" a list easily.\\n\\nThe RepeatedField<T> type includes the code required to serialize and deserialize t\", \"he list to the\\nbinary wire format.\\n\\nProtobuf reserved fields\\n\\nThe backward-compatibility guarantees \", \"in Protocol Buffer (Protobuf) rely on field numbers always\\nrepresenting the same data item. If a fie\", \"ld is removed from a message in a new version of the service,\\nthat field number should never be reus\", \"ed. You can enforce this behavior by using the reserved\\nkeyword.\\n\\nIf the displayName and marketId fi\", \"elds were removed from the Stock message defined earlier, their\\nfield numbers should be reserved as \", \"in the following example.\\n\\nsyntax \\\"proto3\\\";\\n\\nmessage Stock {\\n\\n    reserved 3, 4;\\n    int32 id = 1;\\n \", \"   string symbol = 2;\\n\\n}\\n\\nYou can also use the reserved keyword as a placeholder for fields that mig\", \"ht be added in the future.\\nYou can express contiguous field numbers as a range by using the to keywo\", \"rd.\\n\\nsyntax \\\"proto3\\\";\\n\\nmessage Info {\\n\\n18\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\f    reserved 2, 9 to 11, 1\", \"5;\\n    // ...\\n}\\n\\nProtobuf Any and Oneof fields for variant types\\n\\nHandling dynamic property types (t\", \"hat is, properties of type object) in Windows Communication\\nFoundation (WCF) is complicated. For exa\", \"mple, you must specify serializers and provide KnownType\\nattributes.\\n\\nProtocol Buffer (Protobuf) pro\", \"vides two simpler options for dealing with values that might be of more\\nthan one type. The Any type \", \"can represent any known Protobuf message type. And you can use the\\noneof keyword to specify that onl\", \"y one of a range of fields can be set in any message.\\n\\nAny\\n\\nAny is one of Protobuf\\u2019s \\u201cwell-known typ\", \"es\\u201d: a collection of useful, reusable message types with\\nimplementations in all supported languages.\", \" To use the Any type, you must import the\\ngoogle/protobuf/any.proto definition.\\n\\nsyntax = \\\"proto3\\\";\\n\", \"\\nimport \\\"google/protobuf/any.proto\\\";\\n\\nmessage Stock {\\n    // Stock-specific data\\n}\\n\\nmessage Currency\", \" {\\n    // Currency-specific data\\n}\\n\\nmessage ChangeNotification {\\n    int32 id = 1;\\n    google.protob\", \"uf.Any instrument = 2;\\n}\\n\\nIn the C# code, the Any class provides methods for setting the field, extr\", \"acting the message, and\\nchecking the type.\\n\\npublic void FormatChangeNotification(ChangeNotification \", \"change)\\n{\\n    if (change.Instrument.Is(Stock.Descriptor))\\n    {\\n        FormatStock(change.Instrumen\", \"t.Unpack<Stock>());\\n    }\\n    else if (change.Instrument.Is(Currency.Descriptor))\\n    {\\n        Form\", \"atCurrency(change.Instrument.Unpack<Currency>());\\n    }\\n    else\\n    {\\n        throw new ArgumentExc\", \"eption(\\\"Unknown instrument type\\\");\\n\\n19\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\f    }\\n}\\n\\nProtobuf\\u2019s internal \", \"reflection code uses the Descriptor static field on each generated type to resolve\\nAny field types. \", \"There\\u2019s also a TryUnpack<T> method, but that creates an uninitialized instance of T\\neven when it fai\", \"ls. It\\u2019s better to use the Is method as shown earlier.\\n\\nOneof\\n\\nOneof fields are a language feature: \", \"the compiler handles the oneof keyword when it generates the\\nmessage class. Using oneof to specify t\", \"he ChangeNotification message might look like this:\\n\\nmessage Stock {\\n    // Stock-specific data\\n}\\n\\nm\", \"essage Currency {\\n    // Currency-specific data\\n}\\n\\nmessage ChangeNotification {\\n  int32 id = 1;\\n  on\", \"eof instrument {\\n    Stock stock = 2;\\n    Currency currency = 3;\\n  }\\n}\\n\\nFields within the oneof set \", \"must have unique field numbers in the overall message declaration.\\n\\nWhen you use oneof, the generate\", \"d C# code includes an enum that specifies which of the fields has\\nbeen set. You can test the enum to\", \" find which field is set. Fields that aren\\u2019t set return null or the\\ndefault value, rather than throw\", \"ing an exception.\\n\\npublic void FormatChangeNotification(ChangeNotification change)\\n{\\n    switch (cha\", \"nge.InstrumentCase)\\n    {\\n        case ChangeNotification.InstrumentOneofCase.None:\\n            retu\", \"rn;\\n        case ChangeNotification.InstrumentOneofCase.Stock:\\n            FormatStock(change.Stock)\", \";\\n            break;\\n        case ChangeNotification.InstrumentOneofCase.Currency:\\n            Forma\", \"tCurrency(change.Currency);\\n            break;\\n        default:\\n            throw new ArgumentExcept\", \"ion(\\\"Unknown instrument type\\\");\\n    }\\n}\\n\\nSetting any field that\\u2019s part of a oneof set will automatic\", \"ally clear any other fields in the set. You can\\u2019t\\nuse repeated with oneof. Instead, you can create a\", \" nested message with either the repeated field or\\nthe oneof set to work around this limitation.\\n\\n20\\n\", \"\\nCHAPTER 3 | Protocol buffers\\n\\n\\fProtobuf enumerations\\n\\nProtobuf supports enumeration types. You saw \", \"this support in the previous section, where an enum\\nwas used to determine the type of a Oneof field.\", \" You can define your own enumeration types, and\\nProtobuf will compile them to C# enum types.\\n\\nBecaus\", \"e you can use Protobuf with various languages, the naming conventions for enumerations are\\ndifferent\", \" from the C# conventions. However, the code generator converts the names to the traditional\\nC# case.\", \" If the Pascal-case equivalent of the field name starts with the enumeration name, then it\\u2019s\\nremoved\", \".\\n\\nFor example, in the following Protobuf enumeration, the fields are prefixed with ACCOUNT_STATUS.\\n\", \"This prefix is equivalent to the Pascal-case enum name, AccountStatus.\\n\\nenum AccountStatus {\\n  ACCOU\", \"NT_STATUS_UNKNOWN = 0;\\n  ACCOUNT_STATUS_PENDING = 1;\\n  ACCOUNT_STATUS_ACTIVE = 2;\\n  ACCOUNT_STATUS_S\", \"USPENDED = 3;\\n  ACCOUNT_STATUS_CLOSED = 4;\\n}\\n\\nThe generator creates a C# enum equivalent to the foll\", \"owing code:\\n\\npublic enum AccountStatus\\n{\\n    Unknown = 0,\\n    Pending = 1,\\n    Active = 2,\\n    Suspe\", \"nded = 3,\\n    Closed = 4\\n}\\n\\nProtobuf enumeration definitions must have a zero constant as their firs\", \"t field. As in C#, you can\\ndeclare multiple fields with the same value. But you must explicitly enab\", \"le this option by using the\\nallow_alias option in the enum:\\n\\nenum AccountStatus {\\n  option allow_ali\", \"as = true;\\n  ACCOUNT_STATUS_UNKNOWN = 0;\\n  ACCOUNT_STATUS_PENDING = 1;\\n  ACCOUNT_STATUS_ACTIVE = 2;\\n\", \"  ACCOUNT_STATUS_SUSPENDED = 3;\\n  ACCOUNT_STATUS_CLOSED = 4;\\n}\\n\\nYou can declare enumerations at the \", \"top level in a .proto file, or nested within a message definition.\\nNested enumerations\\u2014like nested m\", \"essages\\u2014will be declared within the .Types static class in the\\ngenerated message class.\\n\\nThere\\u2019s no \", \"way to apply the [Flags] attribute to a Protobuf-generated enum, and Protobuf doesn\\u2019t\\nunderstand bit\", \"wise enum combinations. Look at the following example:\\n\\nenum Region {\\n  REGION_NONE = 0;\\n\\n21\\n\\nCHAPTE\", \"R 3 | Protocol buffers\\n\\n\\f  REGION_NORTH_AMERICA = 1;\\n  REGION_SOUTH_AMERICA = 2;\\n  REGION_EMEA = 4;\\n\", \"  REGION_APAC = 8;\\n}\\n\\nmessage Product {\\n  Region available_in = 1;\\n}\\n\\nIf you set product.AvailableIn\", \" to Region.NorthAmerica | Region.SouthAmerica, it\\u2019s serialized as the\\ninteger value 3. When a client\", \" or server tries to deserialize the value, it won\\u2019t find a match in the enum\\ndefinition for 3. The r\", \"esult will be Region.None.\\n\\nThe best way to work with multiple enum values in Protobuf is to use a r\", \"epeated field of the enum\\ntype.\\n\\nProtobuf maps for dictionaries\\n\\nIt\\u2019s important to be able to repres\", \"ent arbitrary collections of named values in messages. In .NET, this\\nactivity is commonly handled th\", \"rough dictionary types. The equivalent of the .NET\\nIDictionary<TKey,TValue> type in Protocol Buffer \", \"(Protobuf) is the map<key_type, value_type> type.\\nThis section shows how to declare a map type in Pr\", \"otobuf, and how to use the generated code.\\n\\nmessage StockPrices {\\n    map<string, double> prices = 1\", \";\\n}\\n\\nIn the generated code, map fields are represented by read-only properties of the\\nGoogle.Protobu\", \"f.Collections.MapField<TKey, TValue> type. This type implements the standard .NET\\ncollection interfa\", \"ces, including IDictionary<TKey,TValue>.\\n\\nMap fields can\\u2019t be directly repeated in a message definit\", \"ion. But you can create a nested message\\nthat contains a map and use repeated on the message type, a\", \"s in the following example:\\n\\nmessage Order {\\n    message Attributes {\\n        map<string, string> va\", \"lues = 1;\\n    }\\n    repeated Attributes attributes = 1;\\n}\\n\\nUsing MapField properties in code\\n\\nThe Ma\", \"pField properties generated from map fields are read-only, and will never be null. To set a map\\nprop\", \"erty, use the Add(IDictionary<TKey,TValue> values) method on the empty MapField property to\\ncopy val\", \"ues from any .NET dictionary.\\n\\npublic Order CreateOrder(Dictionary<string, string> attributes)\\n{\\n   \", \" var order = new Order();\\n    order.Attributes.Add(attributes);\\n\\n22\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\f\", \"    return order;\\n}\\n\\nFurther reading\\n\\nFor more information about Protobuf, see the official Protobuf\", \" documentation.\\n\\n23\\n\\nCHAPTER 3 | Protocol buffers\\n\\n\\fCHAPTER  4\\n\\nComparing WCF to gRPC\\n\\nThe previous \", \"chapter gave you a good look at Protobuf and how gRPC handles messages. Before you\\nwork through a de\", \"tailed conversion from Windows Communication Foundation (WCF) to gRPC, it\\u2019s\\nimportant to know how th\", \"e features available in WCF are handled in gRPC and what workarounds you\\ncan use when there\\u2019s no gRP\", \"C equivalent. In particular, this chapter will cover the following subjects:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nOperations an\", \"d methods\\n\\nBindings and transports\\n\\nRPC types\\n\\n\\u2022  Metadata\\n\\n\\u2022\\n\\nError handling\\n\\n\\u2022  WS-* protocols\\n\\ngR\", \"PC example\\n\\nWhen you create a new ASP.NET Core 7.0 gRPC project from Visual Studio 2022 or the comma\", \"nd line,\\nthe gRPC equivalent of \\u201cHello World\\u201d is generated for you. It consists of a greeter.proto f\", \"ile that\\ndefines the service and its messages, and a GreeterService.cs file with an implementation o\", \"f the\\nservice.\\n\\nsyntax = \\\"proto3\\\";\\n\\noption csharp_namespace = \\\"HelloGrpc\\\";\\n\\npackage Greet;\\n\\n// The g\", \"reeting service definition.\\nservice Greeter {\\n  // Sends a greeting\\n  rpc SayHello (HelloRequest) re\", \"turns (HelloReply);\\n}\\n\\n// The request message that contains the user's name.\\nmessage HelloRequest {\\n\", \"  string name = 1;\\n}\\n\\n// The response message that contains the greetings.\\nmessage HelloReply {\\n  st\", \"ring message = 1;\\n}\\n\\n24\\n\\nCHAPTER 4 | Comparing WCF to gRPC\\n\\n\\fnamespace HelloGrpc;\\n\\npublic class Gree\", \"terService : Greeter.GreeterBase\\n{\\n    private readonly ILogger<GreeterService> _logger;\\n    public \", \"GreeterService(ILogger<GreeterService> logger)\\n    {\\n        _logger = logger;\\n    }\\n\\n    public ove\", \"rride Task<HelloReply> SayHello(HelloRequest request, ServerCallContext\\ncontext)\\n    {\\n        retur\", \"n Task.FromResult(new HelloReply\\n        {\\n            Message = \\\"Hello \\\" + request.Name\\n        });\", \"\\n    }\\n}\\n\\nThis chapter will refer to this example code when explaining different concepts and featur\", \"es of gRPC.\\n\\nWCF endpoints and gRPC methods\\n\\nIn Windows Communication Foundation (WCF), when you\\u2019re \", \"writing your application code, you use\\none of the following methods:\\n\\n\\u2022\\n\\n\\u2022\\n\\nYou write the applicatio\", \"n code in a class and decorate methods with the OperationContract\\nattribute.\\n\\nYou declare an interfa\", \"ce for the service and add OperationContract attributes to the interface.\\n\\nFor example, the WCF equi\", \"valent of the greet.proto Greeter service might be written as follows:\\n\\n[ServiceContract]\\npublic int\", \"erface IGreeterService\\n{\\n    [OperationContract]\\n    string SayHello(string name);\\n}\\n\\nChapter 3 show\", \"ed that Protobuf message definitions are used to generate data classes. Service and\\nmethod declarati\", \"ons are used to generate base classes that you inherit from to implement the service.\\nYou just decla\", \"re the methods to be implemented in the .proto file, and the compiler generates a base\\nclass with vi\", \"rtual methods that you must override.\\n\\nOperationContract properties\\n\\nThe OperationContract attribute\", \" has properties to control or refine how it works. gRPC methods don\\u2019t\\noffer this type of control. Th\", \"e following table lists those OperationContract properties and describes\\nhow the functionality that \", \"they specify is (or isn\\u2019t) dealt with in gRPC:\\n\\n25\\n\\nCHAPTER 4 | Comparing WCF to gRPC\\n\\n\\fOperationCon\", \"tract property\\n\\ngRPC\\n\\nAction\\n\\nAsyncPattern\\n\\nIsInitiating\\n\\nIsOneWay\\n\\nIsTerminating\\n\\nName\\n\\nProtectionL\", \"evel\\n\\nA URI identifies the operation. gRPC uses the name of\\npackage, service, and rpc from the .prot\", \"o file.\\n\\nAll gRPC service methods return Task objects.\\n\\nSee the paragraph after this table.\\n\\nOne-way\", \" gRPC methods return Empty results or use client\\nstreaming.\\n\\nSee the paragraph after this table.\\n\\nTh\", \"is property is SOAP related and has no meaning in gRPC.\\n\\nThere\\u2019s no message encryption. Network encr\", \"yption is\\nhandled at the transport layer (TLS over HTTP/2).\\n\\nReplyAction\\n\\nThis property is SOAP rela\", \"ted and has no meaning in gRPC.\\n\\nThe IsInitiating property lets you indicate that a method within Se\", \"rviceContract can\\u2019t be the first\\nmethod called as part of a session. The IsTerminating property caus\", \"es the server to close the session\\nafter an operation is called (or the client, if the property is u\", \"sed on a callback client). In gRPC, streams\\nare created by single methods and closed explicitly. See\", \" gRPC streaming.\\n\\nFor more information on gRPC security and encryption, see chapter 6.\\n\\nWCF bindings\", \" and transports\\n\\nWindows Communication Foundation (WCF) has built-in bindings that specify different\", \" network\\nprotocols, wire formats, and other implementation details. gRPC effectively has just one ne\", \"twork\\nprotocol and one wire format. (Technically you can customize the wire format, but that\\u2019s beyon\", \"d the\\nscope of this book.) You\\u2019re likely to discover that gRPC offers the best solution in most case\", \"s.\\n\\nWhat follows is a short discussion about the most relevant WCF bindings and how they compare to\\n\", \"their equivalents in gRPC.\\n\\nNetTCP\\n\\nWCF\\u2019s NetTCP binding allows for persistent connections, small me\", \"ssages, and two-way messaging.\\nBut it works only between .NET clients and servers. gRPC allows the s\", \"ame functionality but is\\nsupported across multiple programming languages and platforms.\\n\\ngRPC has ma\", \"ny features of WCF\\u2019s NetTCP binding, but they\\u2019re not always implemented in the same\\nway. For example\", \", in WCF, encryption is controlled through configuration and handled in the\\nframework. In gRPC, encr\", \"yption is achieved at the connection level through HTTP/2 over TLS.\\n\\n26\\n\\nCHAPTER 4 | Comparing WCF t\", \"o gRPC\\n\\n\\fHTTP\\n\\nThe WCF binding called BasicHttpBinding is usually text-based and uses SOAP as the wi\", \"re format. It\\u2019s\\nslow compared to the NetTCP binding. It\\u2019s used to provide cross-platform interoperab\", \"ility, or\\nconnection over internet infrastructure.\\n\\nThe equivalent in gRPC uses HTTP/2 as the underl\", \"ying transport layer with the binary Protobuf wire\\nformat for messages. So it can offer performance \", \"at the NetTCP service level and full cross-platform\\ninteroperability with all modern programming lan\", \"guages and frameworks.\\n\\nNamed pipes\\n\\nWCF provided a named pipes binding for communication between pr\", \"ocesses on the same physical\\nmachine. ASP.NET Core gRPC doesn\\u2019t support named pipes. For inter-proce\", \"ss communication (IPC)\\nusing gRPC instead supports Unix domain sockets. Unix domain sockets are supp\", \"orted on Linux and\\nmodern versions of Windows.\\n\\nFor more information, see Inter-process communicatio\", \"n with gRPC.\\n\\nMSMQ\\n\\nMSMQ is a proprietary Windows message queue. WCF\\u2019s binding to MSMQ enables \\u201cfire\", \" and forget\\u201d\\nrequests from clients that might be processed at any time in the future. gRPC doesn\\u2019t n\", \"atively provide\\nany message queue functionality.\\n\\nThe best alternative is to directly use a messagin\", \"g system like Azure Service Bus, RabbitMQ, or Kafka.\\nYou can implement this functionality with the c\", \"lient placing messages directly onto the queue, or a\\ngRPC client streaming service that enqueues the\", \" messages.\\n\\nWebHttpBinding\\n\\nWebHttpBinding (also known as WCF REST), with the WebGet and WebInvoke a\", \"ttributes, enabled you\\nto develop RESTful APIs that could speak JSON at a time when this behavior wa\", \"s less common. If you\\nhave a RESTful API built with WCF REST, consider migrating it to a regular ASP\", \".NET Core MVC Web\\nAPI application. This migration would provide the same functionality as a conversi\", \"on to gRPC.\\n\\nTypes of RPC\\n\\nAs a Windows Communication Foundation (WCF) developer, you\\u2019re probably us\", \"ed to dealing with the\\nfollowing types of remote procedure call (RPC):\\n\\n\\u2022\\n\\n\\u2022\\n\\nRequest/reply\\n\\nDuplex:\", \"\\n\\n\\u2013\\n\\n\\u2013\\n\\nOne-way duplex with session\\n\\nFull duplex with session\\n\\n\\u2022\\n\\nOne-way\\n\\n27\\n\\nCHAPTER 4 | Comparing\", \" WCF to gRPC\\n\\n\\fIt\\u2019s possible to map these RPC types fairly naturally to existing gRPC concepts. This\", \" chapter will look at\\neach of these areas in turn. Chapter 5 will explore similar examples in greate\", \"r depth.\\n\\nWCF\\n\\ngRPC\\n\\nRegular request/reply\\n\\nUnary\\n\\nDuplex service with session using a client\\ncallba\", \"ck interface\\n\\nServer streaming\\n\\nFull duplex service with session\\n\\nBidirectional streaming\\n\\nOne-way o\", \"perations\\n\\nClient streaming\\n\\nRequest/reply\\n\\nFor simple request/reply methods that take and return sm\", \"all amounts of data, use the simplest gRPC\\npattern, the unary RPC.\\n\\nservice Things {\\n    rpc Get(Get\", \"ThingRequest) returns (GetThingResponse);\\n}\\n\\npublic class ThingService : Things.ThingsBase\\n{\\n    pub\", \"lic override async Task<GetThingResponse> Get(GetThingRequest request,\\nServerCallContext context)\\n  \", \"  {\\n        // Get thing from database\\n        return new GetThingResponse { Thing = thing };\\n    }\\n\", \"}\\n\\npublic async Task ShowThing(int thingId)\\n{\\n    var thing = await _thingsClient.GetAsync(new GetTh\", \"ingRequest { ThingId = thingId });\\n    Console.WriteLine($\\\"{thing.Name}\\\");\\n}\\n\\nAs you can see, implem\", \"enting a gRPC unary RPC service method is similar to implementing a WCF\\noperation. The difference is\", \" that with gRPC, you override a base class method instead of\\nimplementing an interface. On the serve\", \"r, gRPC base methods always return Task, although the client\\nprovides both async and blocking method\", \"s to call the service.\\n\\nWCF duplex, one way to client\\n\\nWCF applications (with certain bindings) can \", \"create a persistent connection between client and server.\\nThe server can asynchronously send data to\", \" the client until the connection is closed, by using a\\ncallback interface specified in the ServiceCo\", \"ntractAttribute.CallbackContract property.\\n\\ngRPC services provide similar functionality with message\", \" streams. Streams don\\u2019t map exactly to WCF\\nduplex services in terms of implementation, but you can a\", \"chieve the same results.\\n\\n28\\n\\nCHAPTER 4 | Comparing WCF to gRPC\\n\\n\\fgRPC streaming\\n\\ngRPC supports the \", \"creation of persistent streams from client to server, and from server to client. Both\\ntypes of strea\", \"m can be active concurrently. This ability is called bidirectional streaming.\\n\\nYou can use streams f\", \"or arbitrary, asynchronous messaging over time. Or you can use them for\\npassing large datasets that \", \"are too big to generate and send in a single request or response.\\n\\nThe following example shows a ser\", \"ver-streaming RPC.\\n\\nservice ClockStreamer {\\n    rpc Subscribe(ClockSubscribeRequest) returns (stream\", \" ClockMessage);\\n}\\n\\npublic class ClockStreamerService : ClockStreamer.ClockStreamerBase\\n{\\n    public \", \"override async Task Subscribe(ClockSubscribeRequest request,\\n        IServerStreamWriter<ClockMessag\", \"e> responseStream,\\n        ServerCallContext context)\\n    {\\n        while (!context.CancellationToke\", \"n.IsCancellationRequested)\\n        {\\n            var time = DateTimeOffset.UtcNow;\\n            await\", \" responseStream.WriteAsync(new ClockMessage { message = $\\\"The time is\\n{time:t}.\\\" });\\n            awa\", \"it Task.Delay(TimeSpan.FromSeconds(10), context.CancellationToken);\\n        }\\n    }\\n}\\n\\nThis server s\", \"tream can be consumed from a client application, as shown in the following code:\\n\\npublic async Task \", \"TellTheTimeAsync(CancellationToken token)\\n{\\n    var channel = GrpcChannel.ForAddress(\\\"https://localh\", \"ost:5001\\\");\\n    var client = new ClockStreamer.ClockStreamerClient(channel);\\n\\n    var request = new \", \"ClockSubscribeRequest();\\n    var response = client.Subscribe(request);\\n\\n    await foreach (var updat\", \"e in response.ResponseStream.ReadAllAsync(token))\\n    {\\n        Console.WriteLine(update.Message);\\n \", \"   }\\n}\\n\\nNote\\n\\nServer-streaming RPCs are useful for subscription-style services. They\\u2019re also useful \", \"for sending large\\ndatasets when it would be inefficient or impossible to build the entire dataset in\", \" memory. However,\\nstreaming responses isn\\u2019t as fast as sending repeated fields in a single message. \", \"As a rule, streaming\\nshouldn\\u2019t be used for small datasets.\\n\\n29\\n\\nCHAPTER 4 | Comparing WCF to gRPC\\n\\n\\f\", \"Differences from WCF\\n\\nA WCF duplex service uses a client callback interface that can have multiple m\", \"ethods. A gRPC server-\\nstreaming service can only send messages over a single stream. If you need mu\", \"ltiple methods, use a\\nmessage type with either an Any field or a oneof field to send different messa\", \"ges, and write code in\\nthe client to handle them.\\n\\nIn WCF, the ServiceContract class with the sessio\", \"n is kept alive until the connection is closed. Multiple\\nmethods can be called within the session. I\", \"n gRPC, the Task that the implementation method returns\\nshouldn\\u2019t finish until the connection is clo\", \"sed.\\n\\nWCF one-way operations and gRPC client streaming\\n\\nWCF provides one-way operations (marked with\", \" [OperationContract(IsOneWay = true)]) that return a\\ntransport-specific acknowledgment. gRPC service\", \" methods always return a response, even if it\\u2019s\\nempty. The client should always await that response.\", \" For the \\u201cfire-and-forget\\u201d style of messaging in\\ngRPC, you can create a client streaming service.\\n\\nt\", \"hing_log.proto\\n\\nservice ThingLog {\\n  rpc OpenConnection(stream Thing) returns (ConnectionClosedRespo\", \"nse);\\n}\\n\\nThingLogService.cs\\n\\npublic class ThingLogService : Protos.ThingLog.ThingLogBase\\n{\\n    priva\", \"te static readonly ConnectionClosedResponse EmptyResponse = new\\nConnectionClosedResponse();\\n    priv\", \"ate readonly ILogger<ThingLogService> _logger;\\n    public ThingLogService(ILogger<ThingLogService> l\", \"ogger)\\n    {\\n        _logger = logger;\\n    }\\n\\n    public override async Task<CompletedResponse> Open\", \"Connection(IAsyncStreamReader<Thing>\\nrequestStream, ServerCallContext context)\\n    {\\n        while (\", \"await requestStream.MoveNext(context.CancellationToken))\\n        {\\n            _logger.LogInformatio\", \"n(requestStream.Current.Description);\\n        }\\n        return EmptyResponse;\\n    }\\n}\\n\\nThingLog clie\", \"nt example\\n\\npublic class ThingLogger : IAsyncDisposable\\n{\\n    private readonly ThingLog.ThingLogClie\", \"nt _client;\\n    private readonly AsyncClientStreamingCall<ThingLogRequest, CompletedResponse> _strea\", \"m;\\n\\n    public ThingLogger(ThingLog.ThingLogClient client)\\n\\n30\\n\\nCHAPTER 4 | Comparing WCF to gRPC\\n\\n\\f\", \"    {\\n        _client = client;\\n        _stream = client.OpenConnection();\\n    }\\n\\n    public async T\", \"ask WriteAsync(string description)\\n    {\\n        await _stream.RequestStream.WriteAsync(new Thing\\n  \", \"      {\\n            Description = description,\\n            Time = Timestamp.FromDateTimeOffset(DateT\", \"imeOffset.UtcNow)\\n        });\\n    }\\n\\n    public async ValueTask DisposeAsync()\\n    {\\n        await _\", \"stream.RequestStream.CompleteAsync();\\n        _stream.Dispose();\\n    }\\n}\\n\\nYou can use client-streami\", \"ng RPCs for fire-and-forget messaging, as shown in the previous example.\\nYou can also use them for s\", \"ending very large datasets to the server. The same warning about\\nperformance applies: for smaller da\", \"tasets, use repeated fields in regular messages.\\n\\nWCF full-duplex services\\n\\nWCF duplex binding suppo\", \"rts multiple one-way operations on both the service interface and the\\nclient callback interface. Thi\", \"s support allows ongoing conversations between client and server. gRPC\\nsupports something similar wi\", \"th bidirectional streaming RPCs, where both parameters are marked\\nwith the stream modifier.\\n\\nchat.pr\", \"oto\\n\\nservice Chatter {\\n    rpc Connect(stream IncomingMessage) returns (stream OutgoingMessage);\\n}\\n\\n\", \"ChatterService.cs\\n\\npublic class ChatterService : Chatter.ChatterBase\\n{\\n    private readonly IChatHub\", \" _hub;\\n\\n    public ChatterService(IChatHub hub)\\n    {\\n        _hub = hub;\\n    }\\n\\n    public override\", \" async Task Connect(IAsyncStreamReader<MessageRequest> requestStream,\\nIServerStreamWriter<MessageRes\", \"ponse> responseStream, ServerCallContext context)\\n    {\\n        _hub.MessageReceived += async (sende\", \"r, args) =>\\n            await responseStream.WriteAsync(new MessageResponse {Text = args.Message});\\n\", \"\\n        while (await requestStream.MoveNext(context.CancellationToken))\\n        {\\n\\n31\\n\\nCHAPTER 4 | \", \"Comparing WCF to gRPC\\n\\n\\f            await _hub.SendAsync(requestStream.Current.Text);\\n        }\\n    \", \"}\\n}\\n\\nIn the previous example, you can see that the implementation method receives both a request str\", \"eam\\n(IAsyncStreamReader<MessageRequest>) and a response stream\\n(IServerStreamWriter<MessageResponse>\", \"). The method can read and write messages until the\\nconnection is closed.\\n\\nChatter client\\n\\npublic cl\", \"ass Chat : IAsyncDisposable\\n{\\n    private readonly Chatter.ChatterClient _client;\\n    private readon\", \"ly AsyncDuplexStreamingCall<MessageRequest, MessageResponse> _stream;\\n    private readonly Cancellat\", \"ionTokenSource _cancellationTokenSource;\\n    private readonly Task _readTask;\\n\\n    public Chat(Chatt\", \"er.ChatterClient client)\\n    {\\n        _client = client;\\n        _stream = _client.Connect();\\n      \", \"  _cancellationTokenSource = new CancellationTokenSource();\\n        _readTask = ReadAsync(_cancellat\", \"ionTokenSource.Token);\\n    }\\n\\n    public async Task SendAsync(string message)\\n    {\\n        await _s\", \"tream.RequestStream.WriteAsync(new MessageRequest {Text = message});\\n    }\\n\\n    private async Task R\", \"eadAsync(CancellationToken token)\\n    {\\n        while (await _stream.ResponseStream.MoveNext(token))\", \"\\n        {\\n            Console.WriteLine(_stream.ResponseStream.Current.Text);\\n        }\\n    }\\n\\n    \", \"public async ValueTask DisposeAsync()\\n    {\\n        await _stream.RequestStream.CompleteAsync();\\n   \", \"     await _readTask;\\n        _stream.Dispose();\\n    }\\n}\\n\\nMetadata\\n\\nMetadata refers to additional da\", \"ta that might be useful during the processing of requests and\\nresponses but that\\u2019s not part of the a\", \"ctual application data. Metadata might include authentication\\ntokens, request identifiers and tags f\", \"or monitoring purposes, and information about the data, like the\\nnumber of records in a dataset.\\n\\n32\", \"\\n\\nCHAPTER 4 | Comparing WCF to gRPC\\n\\n\\fIt\\u2019s possible to add generic key/value headers to Windows Comm\", \"unication Foundation (WCF)\\nmessages by using an OperationContextScope and the OperationContext.Outgo\", \"ingMessageHeaders\\nproperty and handle them by using MessageProperties.\\n\\ngRPC calls and responses can\", \" also include metadata that\\u2019s similar to HTTP headers. This metadata is\\nmostly invisible to gRPC its\", \"elf and is passed through to be processed by your application code or\\nmiddleware. Metadata is repres\", \"ented as key/value pairs, where the key is a string and the value is\\neither a string or binary data.\", \" You don\\u2019t need to specify metadata in the .proto file.\\n\\nMetadata is handled by the Metadata class o\", \"f the Grpc.Core.Api NuGet package. This class can be\\nused with collection initializer syntax.\\n\\nThis \", \"example shows how to add metadata to a call from a C# client:\\n\\nvar metadata = new Metadata\\n{\\n    { \\\"\", \"Requester\\\", _clientName }\\n};\\n\\nvar request = new GetPortfolioRequest\\n{\\n    Id = portfolioId\\n};\\n\\nvar r\", \"esponse = await client.GetPortfolioAsync(request, metadata);\\n\\ngRPC services can access metadata from\", \" the ServerCallContext argument\\u2019s RequestHeaders property:\\n\\npublic async Task<GetPortfolioResponse> \", \"GetPortfolio(GetPortfolioRequest request,\\nServerCallContext context)\\n{\\n    var requesterHeader = con\", \"text.RequestHeaders.FirstOrDefault(e => e.Key == \\\"Requester\\\");\\n    if (requesterHeader != null)\\n    \", \"{\\n        _logger.LogInformation($\\\"Request from {requesterHeader.Value}\\\");\\n    }\\n    // ...\\n}\\n\\nServi\", \"ces can send metadata to clients by using the ResponseTrailers property of ServerCallContext:\\n\\npubli\", \"c async Task<GetPortfolioResponse> GetPortfolio(GetPortfolioRequest request,\\nServerCallContext conte\", \"xt)\\n{\\n    // ...\\n    context.ResponseTrailers.Add(\\\"Responder\\\", _serverName);\\n    // ...\\n}\\n\\nError han\", \"dling\\n\\nWindows Communication Foundation (WCF) uses FaultException and FaultContract to provide\\ndetai\", \"led error information, including supporting the SOAP Fault standard.\\n\\n33\\n\\nCHAPTER 4 | Comparing WCF \", \"to gRPC\\n\\n\\fUnfortunately, the current version of gRPC lacks the sophistication found with WCF, and on\", \"ly has\\nlimited built-in error handling based on simple status codes and metadata. The following tabl\", \"e is a\\nquick guide to the most commonly used status codes:\\n\\nStatus code\\n\\nProblem\\n\\nGRPC_STATUS_UNIMPL\", \"EMENTED\\n\\nMethod hasn\\u2019t been written.\\n\\nGRPC_STATUS_UNAVAILABLE\\n\\nProblem with the whole service.\\n\\nGRPC\", \"_STATUS_UNKNOWN\\n\\nGRPC_STATUS_INTERNAL\\n\\nGRPC_STATUS_UNAUTHENTICATED\\n\\nGRPC_STATUS_PERMISSION_DENIED\\n\\nG\", \"RPC_STATUS_CANCELLED\\n\\nInvalid response.\\n\\nProblem with encoding/decoding.\\n\\nAuthentication failed.\\n\\nAu\", \"thorization failed.\\n\\nCall was canceled, usually by the\\ncaller.\\n\\nRaise errors in ASP.NET Core gRPC\\n\\nA\", \"n ASP.NET Core gRPC service can send an error response by throwing an RpcException, which can be\\ncau\", \"ght by the client as if it were in the same process. The RpcException must include a status code\\nand\", \" description, and can optionally include metadata and a longer exception message. The metadata\\ncan b\", \"e used to send supporting data, similar to how FaultContract objects can carry additional data\\nfor W\", \"CF errors.\\n\\npublic async Task<GetPortfolioResponse> GetPortfolio(GetPortfolioRequest request,\\nServer\", \"CallContext context)\\n{\\n    var user = context.GetHttpContext().User;\\n    if (!ValidateUser(user))\\n  \", \"  {\\n        var metadata = new Metadata\\n        {\\n            { \\\"User\\\", user.Identity.Name }\\n       \", \" };\\n        throw new RpcException(new Status(StatusCode.PermissionDenied, \\\"Permission\\ndenied\\\"), met\", \"adata);\\n    }\\n}\\n\\nCatch errors in gRPC clients\\n\\nJust like WCF clients can catch FaultException errors\", \", a gRPC client can catch an RpcException to\\nhandle errors. Because RpcException isn\\u2019t a generic typ\", \"e, you can\\u2019t catch different error types in\\ndifferent blocks. But you can use C#\\u2019s exception filters\", \" feature to declare separate catch blocks for\\ndifferent status codes, as shown in the following exam\", \"ple:\\n\\ntry\\n{\\n    var portfolio = await client.GetPortfolioAsync(new GetPortfolioRequest { Id = id });\", \"\\n}\\ncatch (RpcException ex) when (ex.StatusCode == StatusCode.PermissionDenied)\\n\\n34\\n\\nCHAPTER 4 | Comp\", \"aring WCF to gRPC\\n\\n\\f{\\n    var userEntry = ex.Trailers.FirstOrDefault(e => e.Key == \\\"User\\\");\\n    Cons\", \"ole.WriteLine($\\\"User '{userEntry.Value}' does not have permission to view this\\nportfolio.\\\");\\n}\\ncatch\", \" (RpcException)\\n{\\n    // Handle any other error type ...\\n}\\n\\nImportant\\n\\nWhen you provide additional m\", \"etadata for errors, be sure to document the relevant keys and values\\nin your API documentation, or i\", \"n comments in your .proto file.\\n\\ngRPC richer error model\\n\\nGoogle has developed a richer error model \", \"that\\u2019s more like WCF\\u2019s FaultContract, but this model isn\\u2019t\\nsupported in C# yet. Currently, it\\u2019s only\", \" available for Go, Java, Python, and C++.\\n\\nWS-* protocols\\n\\nOne of the real benefits of working with \", \"Windows Communication Foundation (WCF) was that it\\nsupported many of the existing WS-* standard prot\", \"ocols. This section will briefly cover how gRPC\\nmanages the same WS-* protocols and discuss what opt\", \"ions are available when there\\u2019s no alternative.\\n\\nMetadata exchange: WS-Policy, WS-Discovery, and so \", \"on\\n\\nSOAP services expose Web Services Description Language (WSDL) schema documents with\\ninformation \", \"such as data formats, operations, or communication options. You can use this schema to\\ngenerate the \", \"client code.\\n\\ngRPC works best when servers and clients are generated from the same .proto files, but\", \" a Server\\nReflection optional extension does provide a way to expose dynamic information from a runn\", \"ing\\nserver. For more information, see the Grpc.Reflection NuGet package.\\n\\nThe WS-Discovery protocol \", \"is used to locate services on a local network. gRPC services are located\\nthrough DNS or a service re\", \"gistry such as Consul or ZooKeeper.\\n\\nSecurity: WS-Security, WS-Federation, XML Encryption, and so on\", \"\\n\\nSecurity, authentication, and authorization are covered in much more detail in chapter 6. But it\\u2019s\", \" worth\\nnoting here that, unlike WCF, gRPC doesn\\u2019t support WS-Security, WS-Federation, or XML Encrypt\", \"ion.\\nEven so, gRPC provides excellent security. All gRPC network traffic is automatically encrypted \", \"when it\\u2019s\\nusing HTTP/2 over TLS. You can use X509 certificates for mutual client/server authenticati\", \"on.\\n\\n35\\n\\nCHAPTER 4 | Comparing WCF to gRPC\\n\\n\\fWS-ReliableMessaging\\n\\ngRPC does not provide an equivale\", \"nt to WS-ReliableMessaging. Retry semantics should be handled in\\ncode, possibly with a library like \", \"Polly. When you\\u2019re running in Kubernetes or similar orchestration\\nenvironments, service meshes can a\", \"lso help to provide reliable messaging between services.\\n\\nWS-Transaction, WS-Coordination\\n\\nWCF\\u2019s imp\", \"lementation of distributed transactions uses Microsoft Distributed Transaction Coordinator\\n(MSDTC). \", \"It works with resource managers that specifically support it, like SQL Server, MSMQ, or\\nWindows file\", \" systems. There\\u2019s no equivalent yet in the modern microservices world, in part due to the\\nwider rang\", \"e of technologies in use. For a discussion of transactions, see Appendix A.\\n\\n36\\n\\nCHAPTER 4 | Compari\", \"ng WCF to gRPC\\n\\n\\fCHAPTER  5\\n\\nMigrate a WCF solution to\\ngRPC\\n\\nThis chapter will describe how to work \", \"with ASP.NET Core 7.0 gRPC projects and demonstrate\\nmigrating different types of Windows Communicati\", \"on Foundation (WCF) services to the gRPC\\nequivalent:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nCreate an ASP.NET Core 7.0 gRPC pr\", \"oject.\\n\\nSimple request-reply operations to gRPC unary RPC.\\n\\nOne-way operations to gRPC client stream\", \"ing RPC.\\n\\nFull-duplex services to gRPC bidirectional streaming RPC.\\n\\nThere\\u2019s also a comparison of us\", \"ing streaming services versus repeated fields for returning datasets,\\nand there\\u2019s a discussion of th\", \"e use of client libraries at the end of the chapter.\\n\\nThe sample WCF application is a minimal stub o\", \"f a set of stock trading services. It uses the open-\\nsource Inversion of Control (IoC) container lib\", \"rary called Autofac for dependency injection. It includes\\nthree services, one for each WCF service t\", \"ype. The services will be discussed in more detail in the\\nfollowing sections. You can download the s\", \"olutions from dotnet-architecture/grpc-for-wcf-developers\\non GitHub. The services use fake data to m\", \"inimize external dependencies.\\n\\nThe samples include the WCF and gRPC implementations of each service\", \".\\n\\nCreate a new ASP.NET Core gRPC project\\n\\nThe .NET SDK comes with a powerful CLI tool, dotnet, whic\", \"h enables you to create and manage\\nprojects and solutions from the command line. The SDK is closely \", \"integrated with Visual Studio, so\\neverything is also available through the familiar graphical user i\", \"nterface. This chapter shows both ways\\nto create a new ASP.NET Core gRPC project.\\n\\nCreate the projec\", \"t by using Visual Studio\\n\\nImportant\\n\\nTo develop any ASP.NET Core 7.0 app, you need Visual Studio 202\", \"2, with the ASP.NET and web\\ndevelopment workload installed.\\n\\n37\\n\\nCHAPTER 5 | Migrate a WCF solution \", \"to gRPC\\n\\n\\fCreate an empty solution called TraderSys from the Blank Solution template. Add a solution\", \" folder\\ncalled src. Then, right-click on the folder and choose Add > New Project. Enter grpc in the \", \"template\\nsearch box, and you should see a project template called gRPC Service.\\n\\nSelect Next to cont\", \"inue to the Configure your new project dialog box. Name the project\\nTraderSys.Portfolios and add an \", \"src subdirectory to the Location.\\n\\n38\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fSelect Next to c\", \"ontinue to the Create a new gRPC service dialog box.\\n\\n39\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\", \"\\n\\n\\fAt present, you have limited options for the service creation. Docker will be introduced later, s\", \"o for\\nnow, leave that option unselected. Just select Create. Your first ASP.NET Core 7.0 gRPC projec\", \"t is\\ngenerated and added to the solution. If you don\\u2019t want to know about working with the dotnet CL\", \"I,\\nskip to the Clean up the example code section.\\n\\nCreate the project by using the .NET CLI\\n\\nThis se\", \"ction covers the creation of solutions and projects from the command line.\\n\\nCreate the solution as s\", \"hown in the following command. The -o (or --output) flag specifies the output\\ndirectory, which is cr\", \"eated in the current directory if it doesn\\u2019t already exist. The solution has the same\\nname as the di\", \"rectory: TraderSys.sln. You can provide a different name by using the -n (or --name)\\nflag.\\n\\ndotnet n\", \"ew sln -o TraderSys\\ncd TraderSys\\n\\nASP.NET Core 7.0 comes with a CLI template for gRPC services. Crea\", \"te the new project by using this\\ntemplate, putting it into an src subdirectory as is conventional fo\", \"r ASP.NET Core projects. The project\\nis named after the directory (TraderSys.Portfolios.csproj), unl\", \"ess you specify a different name with the\\n-n flag.\\n\\ndotnet new grpc -o src/TraderSys.Portfolios\\n\\nFin\", \"ally, add the project to the solution by using the dotnet sln command:\\n\\ndotnet sln add src/TraderSys\", \".Portfolios\\n\\n40\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fTip\\n\\nBecause the particular directory \", \"only contains a single .csproj file, you can specify just the directory, to\\nsave typing.\\n\\nYou can no\", \"w open this solution in Visual Studio 2022, Visual Studio Code, or whatever editor you\\nprefer.\\n\\nClea\", \"n up the example code\\n\\nYou\\u2019ve now created an example service by using the gRPC template, which was r\", \"eviewed earlier in the\\nbook. This code isn\\u2019t useful in our stock trading context, so we\\u2019ll edit thin\", \"gs for our first project.\\n\\nRename and edit the proto file\\n\\nGo ahead and rename the Protos/greet.prot\", \"o file to Protos/portfolios.proto, and open it in your\\neditor. Delete everything after the package l\", \"ine. Then change the option csharp_namespace, package\\nand service names, and remove the default SayH\", \"ello service. The code now looks like the following:\\n\\nsyntax = \\\"proto3\\\";\\n\\noption csharp_namespace = \", \"\\\"TraderSys.Portfolios.Protos\\\";\\n\\npackage PortfolioServer;\\n\\nservice Portfolios {\\n  // RPCs will go her\", \"e\\n}\\n\\nTip\\n\\nThe template doesn\\u2019t add the Protos namespace part by default, but adding it makes it easi\", \"er to keep\\ngRPC-generated classes and your own classes clearly separated in your code.\\n\\nIf you renam\", \"e the greet.proto file in an integrated development environment (IDE) like Visual Studio, a\\nreferenc\", \"e to this file is automatically updated in the .csproj file. But in some other editor, such as\\nVisua\", \"l Studio Code, this reference isn\\u2019t updated automatically, so you need to edit the project file\\nmanu\", \"ally.\\n\\nIn the gRPC build targets, there\\u2019s a Protobuf item element that lets you specify which .proto\", \" files\\nshould be compiled, and which form of code generation is required (that is, \\u201cServer\\u201d or \\u201cClie\", \"nt\\u201d).\\n\\n<ItemGroup>\\n  <Protobuf Include=\\\"Protos\\\\portfolios.proto\\\" GrpcServices=\\\"Server\\\" />\\n</ItemGrou\", \"p>\\n\\nRename the GreeterService class\\n\\nThe GreeterService class is in the Services folder and inherits\", \" from Greeter.GreeterBase. Rename it to\\nPortfolioService, and change the base class to Portfolios.Po\", \"rtfoliosBase. Delete the override methods.\\n\\n41\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fpublic \", \"class PortfolioService : Protos.Portfolios.PortfoliosBase\\n{\\n}\\n\\nThere was a reference to the GreeterS\", \"ervice class in the Program.cs. If you used refactoring to rename\\nthe class, this reference should h\", \"ave been updated automatically. However, if you didn\\u2019t, you need to\\nedit it manually.\\n\\nusing TraderS\", \"ys.Portfolios.Services;\\n\\nvar builder = WebApplication.CreateBuilder(args);\\n\\n// Add services to the c\", \"ontainer.\\n\\nbuilder.Services.AddGrpc();\\n\\nvar app = builder.Build();\\n\\n// Configure the HTTP request pi\", \"peline.\\napp.MapGrpcService<PortfolioService>();\\napp.MapGet(\\\"/\\\", () => \\\"Communication with gRPC endpo\", \"ints must be made through a gRPC\\nclient. To learn how to create a client, visit:\\nhttps://go.microsof\", \"t.com/fwlink/?linkid=2086909\\\");\\n\\napp.Run();\\n\\nIn the next section, we\\u2019ll add functionality to this ne\", \"w service.\\n\\nMigrate a WCF request-reply service to a gRPC\\nunary RPC\\n\\nThis section covers how to migr\", \"ate a basic request-reply service in WCF to a unary RPC service in\\nASP.NET Core gRPC. These services\", \" are the simplest service types in both Windows Communication\\nFoundation (WCF) and gRPC, so it\\u2019s an \", \"excellent place to start. After migrating the service, you\\u2019ll learn\\nhow to generate a client library\", \" from the same .proto file to consume the service from a .NET client\\napplication.\\n\\nThe WCF solution\\n\", \"\\nThe PortfoliosSample solution includes a simple request-reply Portfolio service to download either \", \"a\\nsingle portfolio or all portfolios for a given trader. The service is defined in the interface\\nIPo\", \"rtfolioService with a ServiceContract attribute:\\n\\n[ServiceContract]\\npublic interface IPortfolioServi\", \"ce\\n{\\n    [OperationContract]\\n    Task<Portfolio> Get(Guid traderId, int portfolioId);\\n\\n    [Operatio\", \"nContract]\\n    Task<List<Portfolio>> GetAll(Guid traderId);\\n}\\n\\n42\\n\\nCHAPTER 5 | Migrate a WCF solutio\", \"n to gRPC\\n\\n\\fThe Portfolio model is a simple C# class marked with DataContract and including a list o\", \"f\\nPortfolioItem objects. These models are defined in the TraderSys.PortfolioData project along with \", \"a\\nrepository class that represents a data access abstraction.\\n\\n[DataContract]\\npublic class Portfolio\", \"\\n{\\n    [DataMember]\\n    public int Id { get; set; }\\n\\n    [DataMember]\\n    public Guid TraderId { get\", \"; set; }\\n\\n    [DataMember]\\n    public List<PortfolioItem> Items { get; set; }\\n}\\n\\n[DataContract]\\npubl\", \"ic class PortfolioItem\\n{\\n    [DataMember]\\n    public int Id { get; set; }\\n\\n    [DataMember]\\n    publ\", \"ic int ShareId { get; set; }\\n\\n    [DataMember]\\n    public int Holding { get; set; }\\n\\n    [DataMember\", \"]\\n    public decimal Cost { get; set; }\\n}\\n\\nThe ServiceContract implementation uses a repository clas\", \"s provided via dependency injection that\\nreturns instances of the DataContract types:\\n\\npublic class \", \"PortfolioService : Protos.Portfolios.PortfoliosBase\\n{\\n    private readonly IPortfolioRepository _rep\", \"ository;\\n\\n    public PortfolioService(IPortfolioRepository repository)\\n    {\\n        _repository = r\", \"epository;\\n    }\\n\\n    public async Task<Portfolio> Get(Guid traderId, int portfolioId)\\n    {\\n       \", \" return await _repository.GetAsync(traderId, portfolioId);\\n    }\\n\\n    public async Task<List<Portfol\", \"io>> GetAll(Guid traderId)\\n    {\\n        return await _repository.GetAllAsync(traderId);\\n    }\\n}\\n\\n43\", \"\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fThe portfolios.proto file\\n\\nIf you followed the instru\", \"ctions in the previous section, you should have a gRPC project with a\\nportfolios.proto file that loo\", \"ks like this:\\n\\nsyntax = \\\"proto3\\\";\\n\\noption csharp_namespace = \\\"TraderSys.Portfolios.Protos\\\";\\n\\npackage\", \" PortfolioServer;\\n\\nservice Portfolios {\\n  // RPCs will go here\\n}\\n\\nThe first step is to migrate the D\", \"ataContract classes to their Protobuf equivalents.\\n\\nConvert the DataContract classes to gRPC message\", \"s\\n\\nThe PortfolioItem class will be converted to a Protobuf message first, because the Portfolio clas\", \"s\\ndepends on it. The class is simple, and three of the properties map directly to gRPC data types. T\", \"he\\nCost property, which represents the price paid for the shares at purchase, is a decimal field. gR\", \"PC\\nsupports only float or double for real numbers, which aren\\u2019t suitable for currency. Because share\", \"\\nprices vary by a minimum of one cent, the cost can be expressed as an int32 of cents.\\n\\nNote\\n\\nRememb\", \"er to use snake_case for field names in your .proto file. The C# code generator will convert\\nthem to\", \" PascalCase for you, and users of other languages will thank you for respecting their different\\ncodi\", \"ng standards.\\n\\nmessage PortfolioItem {\\n    int32 id = 1;\\n    int32 share_id = 2;\\n    int32 holding =\", \" 3;\\n    int32 cost_cents = 4;\\n}\\n\\nThe Portfolio class is a little more complicated. In the WCF code, \", \"the developer used a Guid for the\\nTraderId property, and contains a List<PortfolioItem>. In Protobuf\", \", which doesn\\u2019t have a first-class\\nUUID type, you should use a string for the traderId field and par\", \"se it in your own code. For the list of\\nitems, use the repeated keyword on the field.\\n\\nmessage Portf\", \"olio {\\n    int32 id = 1;\\n    string trader_id = 2;\\n    repeated PortfolioItem items = 3;\\n}\\n\\nNow that\", \" you have the data messages, you can declare the service RPC endpoints.\\n\\n44\\n\\nCHAPTER 5 | Migrate a W\", \"CF solution to gRPC\\n\\n\\fConvert ServiceContract to a gRPC service\\n\\nThe WCF Get method takes two parame\", \"ters: Guid traderId and int portfolioId. gRPC service methods\\ncan take only a single parameter, so y\", \"ou need to create a message to hold the two values. It\\u2019s\\ncommon practice to name these request objec\", \"ts with the same name as the method followed by the\\nsuffix Request. Again, string is being used for \", \"the traderId field instead of Guid.\\n\\nThe service could just return a Portfolio message directly, but\", \" again, this could affect backward\\ncompatibility in the future. It\\u2019s a good practice to define separ\", \"ate Request and Response messages for\\nevery method in a service, even if many of them are the same r\", \"ight now. So declare a GetResponse\\nmessage with a single Portfolio field.\\n\\nThis example shows the de\", \"claration of the gRPC service method with the GetRequest message:\\n\\nmessage GetRequest {\\n    string t\", \"rader_id = 1;\\n    int32 portfolio_id = 2;\\n}\\n\\nmessage GetResponse {\\n    Portfolio portfolio = 1;\\n}\\n\\ns\", \"ervice Portfolios {\\n    rpc Get(GetRequest) returns (GetResponse);\\n}\\n\\nThe WCF GetAll method takes on\", \"ly a single parameter, traderId, so it might seem that you could\\nspecify string as the parameter typ\", \"e. But gRPC requires a defined message type. This requirement\\nhelps to enforce the practice of using\", \" custom messages for all inputs and outputs, for future backward\\ncompatibility.\\n\\nThe WCF method also\", \" returns a List<Portfolio>, but for the same reason it doesn\\u2019t allow simple\\nparameter types, gRPC wo\", \"n\\u2019t allow repeated Portfolio as a return type. Instead, create a\\nGetAllResponse type to wrap the lis\", \"t.\\n\\nWarning\\n\\nYou might be tempted to create a PortfolioList message or something similar and use it \", \"across\\nmultiple service methods, but you should resist this temptation. It\\u2019s impossible to know how \", \"the\\nvarious methods on a service will evolve, so keep their messages specific and cleanly separated.\", \"\\n\\nmessage GetAllRequest {\\n    string trader_id = 1;\\n}\\n\\nmessage GetAllResponse {\\n    repeated Portfol\", \"io portfolios = 1;\\n}\\n\\nservice Portfolios {\\n    rpc Get(GetRequest) returns (GetResponse);\\n\\n45\\n\\nCHAPT\", \"ER 5 | Migrate a WCF solution to gRPC\\n\\n\\f    rpc GetAll(GetAllRequest) returns (GetAllResponse);\\n}\\n\\nI\", \"f you save your project with these changes, the gRPC build target will run in the background and\\ngen\", \"erate all the Protobuf message types and a base class that you can inherit to implement the\\nservice.\", \"\\n\\nOpen the Services/GreeterService.cs class and delete the example code. Now you can add the\\nPortfol\", \"io service implementation. The generated base class will be in the Protos namespace and is\\ngenerated\", \" as a nested class. gRPC creates a static class with the same name as the service in the\\n.proto file\", \" and a base class with the suffix Base inside that static class, so the full identifier for the base\", \"\\ntype is TraderSys.Portfolios.Protos.Portfolios.PortfoliosBase.\\n\\nnamespace TraderSys.Portfolios.Serv\", \"ices;\\n\\npublic class PortfolioService : Protos.Portfolios.PortfoliosBase\\n{\\n}\\n\\nThe base class declares\", \" virtual methods for Get and GetAll that can be overridden to implement the\\nservice. The methods are\", \" virtual rather than abstract so that if you don\\u2019t implement them, the service\\ncan return an explici\", \"t gRPC Unimplemented status code, much like you might throw a\\nNotImplementedException in regular C# \", \"code.\\n\\nThe signature for all gRPC unary service methods in ASP.NET Core is consistent. There are two\", \"\\nparameters: the first is the message type declared in the .proto file, and the second is a\\nServerCa\", \"llContext that works similarly to the HttpContext from ASP.NET Core. In fact, there\\u2019s an\\nextension m\", \"ethod called GetHttpContext on the ServerCallContext class that you can use to get the\\nunderlying Ht\", \"tpContext, although you shouldn\\u2019t need to use it often. We\\u2019ll take a look at\\nServerCallContext later\", \" in this chapter, and also in the chapter that discusses authentication.\\n\\nThe method\\u2019s return type i\", \"s a Task<T>, where T is the response message type. All gRPC service\\nmethods are asynchronous.\\n\\nMigra\", \"te the PortfolioData library to .NET\\n\\nAt this point, the project needs the Portfolio repository and \", \"models contained in the\\nTraderSys.PortfolioData class library in the WCF solution. The easiest way t\", \"o bring them across is to\\ncreate a new class library by using either the Visual Studio New project d\", \"ialog box with the Class\\nLibrary (.NET Standard) template, or from the command line by using the .NE\", \"T CLI, running these\\ncommands from the directory that contains the TraderSys.sln file:\\n\\ndotnet new c\", \"lasslib -o src/TraderSys.PortfolioData\\ndotnet sln add src/TraderSys.PortfolioData\\n\\nAfter you\\u2019ve crea\", \"ted the library and added it to the solution, delete the generated Class1.cs file and\\ncopy the files\", \" from the WCF solution\\u2019s library into the new class library\\u2019s folder, keeping the folder\\nstructure:\\n\", \"\\nModels\\n  Portfolio.cs\\n  PortfolioItem.cs\\n\\n46\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fIPortfol\", \"ioRepository.cs\\nPortfolioRepository.cs\\n\\nSDK-style .NET projects automatically include any .cs files \", \"in or under their own directory, so you don\\u2019t\\nneed to explicitly add them to the project. The only s\", \"tep remaining is to remove the DataContract and\\nDataMember attributes from the Portfolio and Portfol\", \"ioItem classes so they\\u2019re plain old C# classes:\\n\\npublic class Portfolio\\n{\\n    public int Id { get; s\", \"et; }\\n    public Guid TraderId { get; set; }\\n    public List<PortfolioItem> Items { get; set; }\\n}\\n\\np\", \"ublic class PortfolioItem\\n{\\n    public int Id { get; set; }\\n    public int ShareId { get; set; }\\n   \", \" public int Holding { get; set; }\\n    public decimal Cost { get; set; }\\n}\\n\\nUse ASP.NET Core dependen\", \"cy injection\\n\\nNow you can add a reference to this library to the gRPC application project and consum\", \"e the\\nPortfolioRepository class by using dependency injection in the gRPC service implementation. In\", \" the\\nWCF application, dependency injection was provided by the Autofac IoC container. ASP.NET Core h\", \"as\\ndependency injection baked in. You can register the repository in the Program.cs itself:\\n\\nusing T\", \"raderSys.Portfolios.Services;\\n\\nvar builder = WebApplication.CreateBuilder(args);\\n\\n// Register the re\", \"pository class as a scoped service (instance per request)\\nbuilder.Services.AddScoped<IPortfolioRepos\", \"itory, PortfolioRepository>();\\n\\nbuilder.Services.AddGrpc();\\n\\nvar app = builder.Build();\\n\\n// Configur\", \"e the HTTP request pipeline.\\napp.MapGrpcService<PortfolioService>();\\napp.MapGet(\\\"/\\\", () => \\\"Communic\", \"ation with gRPC endpoints must be made through a gRPC\\nclient. To learn how to create a client, visit\", \":\\nhttps://go.microsoft.com/fwlink/?linkid=2086909\\\");\\n\\napp.Run();\\n\\nThe IPortfolioRepository implement\", \"ation can now be specified as a constructor parameter in the\\nPortfolioService class, as follows:\\n\\npu\", \"blic class PortfolioService : Protos.Portfolios.PortfoliosBase\\n{\\n    private readonly IPortfolioRepo\", \"sitory _repository;\\n\\n    public PortfolioService(IPortfolioRepository repository)\\n    {\\n\\n47\\n\\nCHAPTER\", \" 5 | Migrate a WCF solution to gRPC\\n\\n\\f        _repository = repository;\\n    }\\n}\\n\\nImplement the gRPC \", \"service\\n\\nNow that you\\u2019ve declared your messages and your service in the portfolios.proto file, you h\", \"ave to\\nimplement the service methods in the PortfolioService class that inherits from the gRPC-gener\", \"ated\\nPortfolios.PortfoliosBase class. The methods are declared as virtual in the base class. If you \", \"don\\u2019t\\noverride them, they\\u2019ll return a gRPC \\u201cNot Implemented\\u201d status code by default.\\n\\nStart by imple\", \"menting the Get method. The default override looks like this example:\\n\\npublic override Task<GetRespo\", \"nse> Get(GetRequest request, ServerCallContext context)\\n{\\n    return base.Get(request, context);\\n}\\n\\n\", \"The first problem is that request.TraderId is a string, and the service requires a Guid. Even though\", \" the\\nexpected format for the string is UUID, the code has to deal with the possibility that a caller\", \" has sent\\nan invalid value and respond appropriately. The service can respond with errors by throwin\", \"g an\\nRpcException and use the standard InvalidArgument status code to express the problem:\\n\\npublic o\", \"verride Task<GetResponse> Get(GetRequest request, ServerCallContext context)\\n{\\n    if (!Guid.TryPars\", \"e(request.TraderId, out var traderId))\\n    {\\n        throw new RpcException(new Status(StatusCode.In\", \"validArgument, \\\"traderId must be a\\nUUID\\\"));\\n    }\\n\\n    return base.Get(request, context);\\n}\\n\\nAfter t\", \"here\\u2019s a proper Guid value for traderId, you can use the repository to retrieve the Portfolio and\\nre\", \"turn it to the client:\\n\\n    var response = new GetResponse\\n    {\\n        Portfolio = await _reposito\", \"ry.GetAsync(request.TraderId, request.PortfolioId)\\n    };\\n\\nMap internal models to gRPC messages\\n\\nThe\", \" previous code doesn\\u2019t actually work because the repository is returning its own POCO model\\nPortfoli\", \"o, but gRPC needs its own Protobuf message Portfolio. As when you map Entity Framework\\ntypes to data\", \" transfer types, the best solution is to provide a conversion between the two. A good\\nplace to put t\", \"he code for this conversion is in the Protobuf-generated class, which is declared as a\\npartial class\", \" so it can be extended:\\n\\nnamespace TraderSys.Portfolios.Protos;\\n\\npublic partial class PortfolioItem\\n\", \"{\\n    public static PortfolioItem FromRepositoryModel(PortfolioData.Models.PortfolioItem\\n\\n48\\n\\nCHAPTE\", \"R 5 | Migrate a WCF solution to gRPC\\n\\n\\fsource)\\n    {\\n        if (source is null) return null;\\n\\n     \", \"   return new PortfolioItem\\n        {\\n            Id = source.Id,\\n            ShareId = source.Share\", \"Id,\\n            Holding = source.Holding,\\n            CostCents = (int)(source.Cost * 100)\\n        }\", \";\\n    }\\n}\\n\\npublic partial class Portfolio\\n{\\n    public static Portfolio FromRepositoryModel(Portfoli\", \"oData.Models.Portfolio source)\\n    {\\n        if (source is null) return null;\\n\\n        var target = \", \"new Portfolio\\n        {\\n            Id = source.Id,\\n            TraderId = source.TraderId.ToString(\", \"),\\n        };\\n\\n        target.Items.AddRange(source.Items.Select(PortfolioItem.FromRepositoryModel))\", \";\\n\\n        return target;\\n    }\\n}\\n\\nNote\\n\\nYou could use a library like AutoMapper to handle this conv\", \"ersion from internal model classes to\\nProtobuf types, as long as you configure the lower-level type \", \"conversions like string/Guid or\\ndecimal/double and the list mapping.\\n\\nNow that you have the conversi\", \"on code in place, you can complete the Get method implementation:\\n\\npublic override async Task<GetRes\", \"ponse> Get(GetRequest request, ServerCallContext context)\\n{\\n    if (!Guid.TryParse(request.TraderId,\", \" out var traderId))\\n    {\\n        throw new RpcException(new Status(StatusCode.InvalidArgument, \\\"tra\", \"derId must be a\\nUUID\\\"));\\n    }\\n\\n    var portfolio = await _repository.GetAsync(traderId, request.Por\", \"tfolioId);\\n\\n    return new GetResponse\\n    {\\n        Portfolio = Portfolio.FromRepositoryModel(portf\", \"olio)\\n    };\\n}\\n\\n49\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fThe implementation of the GetAll me\", \"thod is similar. Note that the repeated fields on Protobuf\\nmessages are generated as readonly proper\", \"ties of type RepeatedField<T>, so you have to add items\\nto them by using the AddRange method, like i\", \"n this example:\\n\\npublic override async Task<GetAllResponse> GetAll(GetAllRequest request, ServerCall\", \"Context\\ncontext)\\n{\\n    if (!Guid.TryParse(request.TraderId, out var traderId))\\n    {\\n        throw n\", \"ew RpcException(new Status(StatusCode.InvalidArgument, \\\"traderId must be a\\nUUID\\\"));\\n    }\\n\\n    var p\", \"ortfolios = await _repository.GetAllAsync(traderId);\\n\\n    var response = new GetAllResponse();\\n    r\", \"esponse.Portfolios.AddRange(portfolios.Select(Portfolio.FromRepositoryModel));\\n\\n    return response;\", \"\\n}\\n\\nHaving successfully migrated the WCF request-reply service to gRPC, let\\u2019s look at creating a cli\", \"ent for\\nit from the .proto file.\\n\\nGenerate client code\\n\\nCreate a .NET Standard class library in the \", \"same solution to contain the client. This is primarily an\\nexample of creating client code, but you c\", \"ould package such a library by using NuGet and distribute it\\non an internal repository for other .NE\", \"T teams to consume. Go ahead and add a new .NET Standard\\nclass library called TraderSys.Portfolios.C\", \"lient to the solution and delete the Class1.cs file.\\n\\nCaution\\n\\nThe Grpc.Net.Client NuGet package req\", \"uires .NET Core 3.0 or later (or another .NET Standard 2.1-\\ncompliant runtime). Earlier versions of \", \".NET Framework and .NET Core are supported by the Grpc.Core\\nNuGet package.\\n\\nIn Visual Studio 2022, y\", \"ou can add references to gRPC services in a way that\\u2019s similar to how you\\u2019d\\nadd service references t\", \"o WCF projects in earlier versions of Visual Studio. Service references and\\nconnected services are a\", \"ll managed under the same UI now. You can access the UI by right-clicking\\nthe Dependencies node in t\", \"he TraderSys.Portfolios.Client project in Solution Explorer and selecting\\nManage Connected Service. \", \"In the tool window that appears, select the Connected Services section,\\nthen select Add a service re\", \"ference in Service References section, select gRPC and click Next:\\n\\n50\\n\\nCHAPTER 5 | Migrate a WCF so\", \"lution to gRPC\\n\\n\\fBrowse to the portfolios.proto file in the TraderSys.Portfolios project, leave Clie\", \"nt under Select the\\ntype of class to be generated, and then select OK:\\n\\n51\\n\\nCHAPTER 5 | Migrate a WC\", \"F solution to gRPC\\n\\n\\fTip\\n\\nNotice that this dialog box also provides a URL field. If your organizatio\", \"n maintains a web-accessible\\ndirectory of .proto files, you can create clients just by setting this \", \"URL address.\\n\\nWhen you use the Visual Studio Add Connected Service feature, the portfolios.proto fil\", \"e is added to\\nthe class library project as a linked file rather than copied, so changes to the file \", \"in the service project\\nwill automatically be applied in the client project. The <Protobuf> element i\", \"n the csproj file looks like\\nthis:\\n\\n<Protobuf Include=\\\"..\\\\TraderSys.Portfolios\\\\Protos\\\\portfolios.pro\", \"to\\\" GrpcServices=\\\"Client\\\">\\n  <Link>Protos\\\\portfolios.proto</Link>\\n</Protobuf>\\n\\nTip\\n\\nIf you\\u2019re not us\", \"ing Visual Studio or prefer to work from the command line, you can use the dotnet-\\ngrpc global tool \", \"to manage Protobuf references in a .NET gRPC project. For more information, see the\\ndotnet-grpc docu\", \"mentation.\\n\\nUse the Portfolios service from a client application\\n\\nThe following code is a brief exam\", \"ple of how to use the generated client in a console application. A\\nmore detailed exploration of the \", \"gRPC client code is at the end of this chapter.\\n\\n52\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fpu\", \"blic class Program\\n{\\n    public async Task Main(string[] args)\\n    {\\n        GetResponse response;\\n\\n\", \"        using (var channel = GrpcChannel.ForAddress(\\\"https://localhost:5001\\\"))\\n        {\\n           \", \" var client = new Protos.Portfolios.PortfoliosClient(channel);\\n\\n            response = await client.\", \"GetAsync(new GetRequest\\n            {\\n                TraderId = args[0],\\n                PortfolioI\", \"d = int.Parse(args[1])\\n            });\\n        }\\n\\n        foreach (var item in response.Portfolio.It\", \"ems)\\n        {\\n            Console.WriteLine($\\\"Holding {item.Holding} of Share ID {item.ShareId}.\\\");\", \"\\n        }\\n    }\\n}\\n\\nYou\\u2019ve now migrated a basic WCF application to an ASP.NET Core gRPC service and \", \"created a client to\\nconsume the service from a .NET application. The next section will cover the mor\", \"e involved duplex\\nservices.\\n\\nMigrate WCF duplex services to gRPC\\n\\nNow that you have a sense of the b\", \"asic concepts, in this section, you\\u2019ll look at the more complicated\\nstreaming gRPC services.\\n\\nThere \", \"are multiple ways to use duplex services in Windows Communication Foundation (WCF). Some\\nservices ar\", \"e initiated by the client and then they stream data from the server. Other full-duplex\\nservices migh\", \"t involve more ongoing two-way communication, like the classic Calculator example in\\nthe WCF documen\", \"tation. This chapter will take two possible WCF stock ticker implementations and\\nmigrate them to gRP\", \"C: one that uses a server streaming RPC and another one that uses a bidirectional\\nstreaming RPC.\\n\\nSe\", \"rver streaming RPC\\n\\nIn the sample SimpleStockTicker WCF solution, SimpleStockPriceTicker, there\\u2019s a \", \"duplex service for\\nwhich the client starts the connection with a list of stock symbols, and the serv\", \"er uses the callback\\ninterface to send updates as they become available. The client implements that \", \"interface to respond\\nto calls from the server.\\n\\nThe WCF solution\\n\\nThe WCF solution is implemented as\", \" a self-hosted Net.TCP server in a .NET Framework 4.x console\\napplication.\\n\\n53\\n\\nCHAPTER 5 | Migrate \", \"a WCF solution to gRPC\\n\\n\\fServiceContract\\n\\n[ServiceContract(SessionMode = SessionMode.Required, Callb\", \"ackContract =\\ntypeof(ISimpleStockTickerCallback))]\\npublic interface ISimpleStockTickerService\\n{\\n    \", \"[OperationContract(IsOneWay = true)]\\n    void Subscribe(string[] symbols);\\n}\\n\\nThe service has a sing\", \"le method with no return type because it uses the callback interface\\nISimpleStockTickerCallback to s\", \"end data to the client in real time.\\n\\nThe callback interface\\n\\n[ServiceContract]\\npublic interface ISi\", \"mpleStockTickerCallback\\n{\\n    [OperationContract(IsOneWay = true)]\\n    void Update(string symbol, de\", \"cimal price);\\n}\\n\\nYou can find the implementations of these interfaces in the solution, along with fa\", \"ked external\\ndependencies to provide test data.\\n\\ngRPC streaming\\n\\nThe gRPC process for handling real-\", \"time data is different from the WCF process. A call from client to\\nserver can create a persistent st\", \"ream, which can be monitored for messages that arrive\\nasynchronously. Despite the difference, stream\", \"s can be a more intuitive way of dealing with this data\\nand are more relevant in modern programming,\", \" which emphasizes LINQ, Reactive Streams, functional\\nprogramming, and so on.\\n\\nThe service definition\", \" needs two messages: one for the request and one for the stream. The service\\nreturns a stream of the\", \" StockTickerUpdate message with the stream keyword in its return declaration.\\nWe recommend that you \", \"add a Timestamp to the update to show the exact time of the price change.\\n\\nsimple_stock_ticker.proto\", \"\\n\\nsyntax = \\\"proto3\\\";\\n\\noption csharp_namespace = \\\"TraderSys.SimpleStockTickerServer.Protos\\\";\\n\\nimport \", \"\\\"google/protobuf/timestamp.proto\\\";\\n\\npackage SimpleStockTickerServer;\\n\\nservice SimpleStockTicker {\\n  \", \"rpc Subscribe (SubscribeRequest) returns (stream StockTickerUpdate);\\n}\\n\\nmessage SubscribeRequest {\\n \", \" repeated string symbols = 1;\\n}\\n\\nmessage StockTickerUpdate {\\n\\n54\\n\\nCHAPTER 5 | Migrate a WCF solution\", \" to gRPC\\n\\n\\f  string symbol = 1;\\n  int32 price_cents = 2;\\n  google.protobuf.Timestamp time = 3;\\n}\\n\\nIm\", \"plement SimpleStockTicker\\n\\nReuse the fake StockPriceSubscriber from the WCF project by copying the t\", \"hree classes from the\\nTraderSys.StockMarket class library into a new .NET Standard class library in \", \"the target solution. To\\nbetter follow best practices, add a Factory type to create instances of it, \", \"and register the\\nIStockPriceSubscriberFactory with the ASP.NET Core dependency injection services.\\n\\n\", \"The factory implementation\\n\\npublic interface IStockPriceSubscriberFactory\\n{\\n    IStockPriceSubscribe\", \"r GetSubscriber(string[] symbols);\\n}\\n\\npublic class StockPriceSubscriberFactory : IStockPriceSubscrib\", \"erFactory\\n{\\n    public IStockPriceSubscriber GetSubscriber(string[] symbols)\\n    {\\n        return ne\", \"w StockPriceSubscriber(symbols);\\n    }\\n}\\n\\nRegister the factory\\n\\nvar builder = WebApplication.CreateB\", \"uilder(args);\\n\\n// Additional configuration is required to successfully run gRPC on macOS.\\n// For ins\", \"tructions on how to configure Kestrel and gRPC clients on macOS, visit\\nhttps://go.microsoft.com/fwli\", \"nk/?linkid=2099682\\n\\n// Add services to the container.\\n\\n// Register the factory\\nbuilder.Services.AddS\", \"ingleton<IStockPriceSubscriberFactory, StockPriceSubscriberFactory>();\\n\\nbuilder.Services.AddGrpc();\\n\", \"\\nvar app = builder.Build();\\n\\n// Configure the HTTP request pipeline.\\napp.MapGrpcService<StockTickerS\", \"ervice>();\\napp.MapGet(\\\"/\\\", async context =>\\n{\\n    await context.Response.WriteAsync(\\\"Communication w\", \"ith gRPC endpoints must be made\\nthrough a gRPC client. To learn how to create a client, visit:\\nhttps\", \"://go.microsoft.com/fwlink/?linkid=2086909\\\");\\n});\\n\\napp.Run();\\n\\nThis class can now be used to impleme\", \"nt the gRPC StockTickerService.\\n\\n55\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fStockTickerService\", \".cs\\n\\npublic class StockTickerService : Protos.SimpleStockTicker.SimpleStockTickerBase\\n{\\n    private \", \"readonly IStockPriceSubscriberFactory _subscriberFactory;\\n\\n    public StockTickerService(IStockPrice\", \"SubscriberFactory subscriberFactory)\\n    {\\n        _subscriberFactory = subscriberFactory;\\n    }\\n\\n  \", \"  public override async Task Subscribe(SubscribeRequest request,\\nIServerStreamWriter<StockTickerUpda\", \"te> responseStream, ServerCallContext context)\\n    {\\n        var subscriber = _subscriberFactory.Get\", \"Subscriber(request.Symbols.ToArray());\\n\\n        subscriber.Update += async (sender, args) =>\\n       \", \"     await WriteUpdateAsync(responseStream, args.Symbol, args.Price);\\n\\n        await AwaitCancellati\", \"on(context.CancellationToken);\\n    }\\n\\n    private async Task WriteUpdateAsync(IServerStreamWriter<St\", \"ockTickerUpdate> stream,\\nstring symbol, decimal price)\\n    {\\n        try\\n        {\\n            await\", \" stream.WriteAsync(new StockTickerUpdate\\n            {\\n                Symbol = symbol,\\n            \", \"    PriceCents = (int)(price * 100),\\n                Time = Timestamp.FromDateTimeOffset(DateTimeOff\", \"set.UtcNow)\\n            });\\n        }\\n        catch (Exception e)\\n        {\\n            // Handle an\", \"y errors caused by broken connection, etc.\\n            _logger.LogError($\\\"Failed to write message: {\", \"e.Message}\\\");\\n        }\\n    }\\n\\n    private static Task AwaitCancellation(CancellationToken token)\\n  \", \"  {\\n        var completion = new TaskCompletionSource<object>();\\n        token.Register(() => comple\", \"tion.SetResult(null));\\n        return completion.Task;\\n    }\\n}\\n\\nAs you can see, although the declara\", \"tion in the .proto file says the method returns a stream of\\nStockTickerUpdate messages, it actually \", \"returns a Task. The job of creating the stream is handled by\\nthe generated code and the gRPC runtime\", \" libraries, which provide the\\nIServerStreamWriter<StockTickerUpdate> response stream, ready to use.\\n\", \"\\nUnlike a WCF duplex service, where the instance of the service class is kept alive while the connec\", \"tion\\nis open, the gRPC service uses the returned task to keep the service alive. The task shouldn\\u2019t \", \"complete\\nuntil the connection is closed.\\n\\n56\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fThe servi\", \"ce can tell when the client has closed the connection by using the CancellationToken from\\nthe Server\", \"CallContext. A simple static method, AwaitCancellation, is used to create a task that\\ncompletes when\", \" the token is canceled.\\n\\nIn the Subscribe method, then, get a StockPriceSubscriber and add an event \", \"handler that writes to the\\nresponse stream. Then wait for the connection to be closed before immedia\", \"tely disposing the\\nsubscriber to prevent it from trying to write data to the closed stream.\\n\\nThe Wri\", \"teUpdateAsync method has a try/catch block to handle any errors that might happen when a\\nmessage is \", \"written to the stream. This consideration is important in persistent connections over\\nnetworks, whic\", \"h could be broken at any millisecond, whether intentionally or because of a failure\\nsomewhere.\\n\\nUse \", \"StockTickerService from a client application\\n\\nFollow the same steps in the previous section to creat\", \"e a shareable client class library from the .proto\\nfile. In the sample, there\\u2019s a .NET console appli\", \"cation that demonstrates how to use the client.\\n\\nExample Program.cs\\n\\nclass Program\\n{\\n    static asyn\", \"c Task Main(string[] args)\\n    {\\n        using var channel = GrpcChannel.ForAddress(\\\"https://localho\", \"st:5001\\\");\\n        var client = new SimpleStockTicker.SimpleStockTickerClient(channel);\\n\\n        var\", \" request = new SubscribeRequest();\\n        request.Symbols.AddRange(args);\\n\\n        using var stream\", \" = client.Subscribe(request);\\n\\n        var tokenSource = new CancellationTokenSource();\\n\\n        var\", \" task = DisplayAsync(stream.ResponseStream, tokenSource.Token);\\n\\n        WaitForExitKey();\\n\\n        \", \"tokenSource.Cancel();\\n        await task;\\n    }\\n}\\n\\nIn this case, the Subscribe method on the generat\", \"ed client isn\\u2019t asynchronous. The stream is created\\nand usable right away because its MoveNext metho\", \"d is asynchronous and the first time it\\u2019s called it\\nwon\\u2019t complete until the connection is alive.\\n\\nT\", \"he stream is passed to an asynchronous DisplayAsync method. The application then waits for the\\nuser \", \"to press a key, and then cancels the DisplayAsync method and waits for the task to complete\\nbefore e\", \"xiting.\\n\\n57\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fNote\\n\\nThis code uses the new C# 8 using de\", \"claration syntax to dispose of the stream and the channel when\\nthe Main method exits. It\\u2019s a small c\", \"hange, but a nice one that reduces indentations and empty lines.\\n\\nConsume the stream\\n\\nWCF uses callb\", \"ack interfaces to allow the server to call methods directly on the client. gRPC streams\\nwork differe\", \"ntly. The client iterates over the returned stream and processes messages, just as though\\nthey were \", \"returned from a local method returning an IEnumerable.\\n\\nThe IAsyncStreamReader<T> type works much li\", \"ke an IEnumerator<T>. There\\u2019s a MoveNext method\\nthat returns true as long as there\\u2019s more data, and \", \"a Current property that returns the latest value. The\\nonly difference is that the MoveNext method re\", \"turns a Task<bool> instead of just a bool. The\\nReadAllAsync extension method wraps the stream in a s\", \"tandard C# 8 IAsyncEnumerable that can be\\nused with the new await foreach syntax.\\n\\nstatic async Task\", \" DisplayAsync(IAsyncStreamReader<StockTickerUpdate> stream,\\nCancellationToken token)\\n{\\n    try\\n    {\", \"\\n        await foreach (var update in stream.ReadAllAsync(token))\\n        {\\n            Console.Writ\", \"eLine($\\\"{update.Symbol}: {update.Price}\\\");\\n        }\\n    }\\n    catch (RpcException e) when (e.Status\", \"Code == StatusCode.Cancelled)\\n    {\\n        return;\\n    }\\n    catch (OperationCanceledException)\\n   \", \" {\\n        Console.WriteLine(\\\"Finished.\\\");\\n    }\\n}\\n\\nTip\\n\\nFor developers using reactive programming p\", \"atterns, the section on client libraries at the end of this\\nchapter shows how to add an extension me\", \"thod and classes to wrap IAsyncStreamReader<T> in an\\nIObservable<T>.\\n\\nAgain, be sure to catch except\", \"ions here because of the possibility of network failure, and because of\\nthe OperationCanceledExcepti\", \"on that will inevitably be thrown because the code is using a\\nCancellationToken to break the loop. T\", \"he RpcException type has a lot of useful information about\\ngRPC runtime errors, including the Status\", \"Code. For more information, see Error handling in Chapter 4.\\n\\nBidirectional streaming\\n\\nA WCF full-du\", \"plex service allows for asynchronous, real-time messaging in both directions. In the\\nserver streamin\", \"g example, the client starts a request and then receives a stream of updates. A better\\n\\n58\\n\\nCHAPTER \", \"5 | Migrate a WCF solution to gRPC\\n\\n\\fversion of that service would allow the client to add and remov\", \"e stocks from the list without having to\\nstop and create a new subscription. That functionality has \", \"been implemented in the FullStockTicker\\nsample solution.\\n\\nThe IFullStockTickerService interface prov\", \"ides three methods:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nSubscribe starts the connection.\\n\\nAddSymbol adds a stock symbol to wat\", \"ch.\\n\\nRemoveSymbol removes a symbol from the watched list.\\n\\n[ServiceContract(SessionMode = SessionMod\", \"e.Required, CallbackContract =\\ntypeof(IFullStockTickerCallback))]\\npublic interface IFullStockTickerS\", \"ervice\\n{\\n    [OperationContract(IsOneWay = true)]\\n    void Subscribe();\\n\\n    [OperationContract(IsOn\", \"eWay = true)]\\n    void AddSymbol(string symbol);\\n\\n    [OperationContract(IsOneWay = true)]\\n    void \", \"RemoveSymbol(string symbol);\\n}\\n\\nThe callback interface remains the same.\\n\\nImplementing this pattern \", \"in gRPC is less straightforward because there are now two streams of data\\nwith messages being passed\", \": one from client to server and another from server to client. It isn\\u2019t\\npossible to use multiple met\", \"hods to implement the add and remove operations, but you can pass\\nmore than one type of message on a\", \" single stream by using either the Any type or the oneof\\nkeyword, which were covered in Chapter 3.\\n\\n\", \"In a case where there\\u2019s a specific set of types that are acceptable, oneof is a better way to go. Us\", \"e an\\nActionMessage that can hold either an AddSymbolRequest or a RemoveSymbolRequest:\\n\\nmessage Actio\", \"nMessage {\\n  oneof action {\\n    AddSymbolRequest add = 1;\\n    RemoveSymbolRequest remove = 2;\\n  }\\n}\\n\", \"\\nmessage AddSymbolRequest {\\n  string symbol = 1;\\n}\\n\\nmessage RemoveSymbolRequest {\\n  string symbol = \", \"1;\\n}\\n\\nDeclare a bidirectional streaming service that takes a stream of ActionMessage messages:\\n\\nserv\", \"ice FullStockTicker {\\n  rpc Subscribe (stream ActionMessage) returns (stream StockTickerUpdate);\\n}\\n\\n\", \"59\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fThe implementation for this service is similar to t\", \"hat of the previous example, except the first\\nparameter of the Subscribe method is now an IAsyncStre\", \"amReader<ActionMessage>, which can be\\nused to handle the Add and Remove requests:\\n\\npublic override a\", \"sync Task Subscribe(IAsyncStreamReader<ActionMessage> requestStream,\\nIServerStreamWriter<StockTicker\", \"Update> responseStream, ServerCallContext context)\\n{\\n    using var subscriber = _subscriberFactory.G\", \"etSubscriber();\\n\\n    subscriber.Update += async (sender, args) =>\\n        await WriteUpdateAsync(res\", \"ponseStream, args.Symbol, args.Price);\\n\\n    var actionsTask = HandleActions(requestStream, subscribe\", \"r, context.CancellationToken);\\n\\n    _logger.LogInformation(\\\"Subscription started.\\\");\\n    await Await\", \"Cancellation(context.CancellationToken);\\n\\n    try { await actionsTask; } catch { /* Ignored */ }\\n\\n  \", \"  _logger.LogInformation(\\\"Subscription finished.\\\");\\n}\\n\\nprivate async Task WriteUpdateAsync(IServerSt\", \"reamWriter<StockTickerUpdate> stream, string\\nsymbol, decimal price)\\n{\\n    try\\n    {\\n        await st\", \"ream.WriteAsync(new StockTickerUpdate\\n        {\\n            Symbol = symbol,\\n            PriceCents \", \"= (int)(price * 100),\\n            Time = Timestamp.FromDateTimeOffset(DateTimeOffset.UtcNow)\\n       \", \" });\\n    }\\n    catch (Exception e)\\n    {\\n        // Handle any errors caused by broken connection, e\", \"tc.\\n        _logger.LogError($\\\"Failed to write message: {e.Message}\\\");\\n    }\\n}\\n\\nprivate static Task \", \"AwaitCancellation(CancellationToken token)\\n{\\n    var completion = new TaskCompletionSource<object>()\", \";\\n    token.Register(() => completion.SetResult(null));\\n    return completion.Task;\\n}\\n\\nThe ActionMes\", \"sage class that gRPC has generated guarantees that only one of the Add and Remove\\nproperties can be \", \"set. Finding which one isn\\u2019t null is a valid way to determine which type of message\\nis used, but the\", \"re\\u2019s a better way. The code generation also created an enum ActionOneOfCase in the\\nActionMessage cla\", \"ss, which looks like this:\\n\\npublic enum ActionOneofCase {\\n    None = 0,\\n    Add = 1,\\n    Remove = 2,\", \"\\n}\\n\\n60\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fThe property ActionCase on the ActionMessage ob\", \"ject can be used with a switch statement to\\ndetermine which field is set:\\n\\nprivate async Task Handle\", \"Actions(IAsyncStreamReader<ActionMessage> requestStream,\\nIFullStockPriceSubscriber subscriber, Cance\", \"llationToken token)\\n{\\n    await foreach (var action in requestStream.ReadAllAsync(token))\\n    {\\n    \", \"    switch (action.ActionCase)\\n        {\\n            case ActionMessage.ActionOneofCase.None:\\n      \", \"          _logger.LogWarning(\\\"No Action specified.\\\");\\n                break;\\n            case Action\", \"Message.ActionOneofCase.Add:\\n                subscriber.Add(action.Add.Symbol);\\n                brea\", \"k;\\n            case ActionMessage.ActionOneofCase.Remove:\\n                subscriber.Remove(action.R\", \"emove.Symbol);\\n                break;\\n            default:\\n                _logger.LogWarning($\\\"Unkn\", \"own Action '{action.ActionCase}'.\\\");\\n                break;\\n        }\\n    }\\n}\\n\\nTip\\n\\nThe switch state\", \"ment has a default case that logs a warning if it encounters an unknown\\nActionOneOfCase value. This \", \"could be useful to indicate that a client is using a later version of the\\n.proto file that has added\", \" more actions. This is one reason why using a switch is better than testing for\\nnull on known fields\", \".\\n\\nUse FullStockTickerService from a client application\\n\\nThere\\u2019s a simple .NET WPF application that \", \"demonstrates the use of this more complex client. You can\\nfind the full application on GitHub.\\n\\nThe \", \"client is used in the MainWindowViewModel class, which gets an instance of the\\nFullStockTicker.FullS\", \"tockTickerClient type from dependency injection:\\n\\npublic class MainWindowViewModel : IAsyncDisposabl\", \"e, INotifyPropertyChanged\\n{\\n    private readonly FullStockTicker.FullStockTickerClient _client;\\n    \", \"private readonly AsyncDuplexStreamingCall<ActionMessage, StockTickerUpdate>\\n_duplexStream;\\n    priva\", \"te readonly CancellationTokenSource _cancellationTokenSource;\\n    private readonly Task _responseTas\", \"k;\\n    private string _addSymbol;\\n\\n    public MainWindowViewModel(FullStockTicker.FullStockTickerCli\", \"ent client)\\n    {\\n        _cancellationTokenSource = new CancellationTokenSource();\\n        _client \", \"= client;\\n        _duplexStream = _client.Subscribe();\\n        _responseTask = HandleResponsesAsync(\", \"_cancellationTokenSource.Token);\\n\\n61\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\f        AddComman\", \"d = new AsyncCommand(Add, CanAdd);\\n    }\\n\\nThe object returned by the client.Subscribe() method is no\", \"w an instance of the gRPC library type\\nAsyncDuplexStreamingCall<TRequest, TResponse>, which provides\", \" a RequestStream for sending\\nrequests to the server and a ResponseStream for handling responses.\\n\\nTh\", \"e request stream is used from some WPF ICommand methods to add and remove symbols. For\\neach operatio\", \"n, set the relevant field on an ActionMessage object:\\n\\nprivate async Task Add()\\n{\\n    if (CanAdd())\\n\", \"    {\\n        await _duplexStream.RequestStream.WriteAsync(new ActionMessage {Add = new\\nAddSymbolReq\", \"uest {Symbol = AddSymbol}});\\n    }\\n}\\n\\npublic async Task Remove(PriceViewModel priceViewModel)\\n{\\n    \", \"await _duplexStream.RequestStream.WriteAsync(new ActionMessage {Remove = new\\nRemoveSymbolRequest {Sy\", \"mbol = priceViewModel.Symbol}});\\n    Prices.Remove(priceViewModel);\\n}\\n\\nImportant\\n\\nSetting a oneof fi\", \"eld\\u2019s value on a message automatically clears any fields that have been set\\npreviously.\\n\\nThe stream \", \"of responses is handled in an async method. The Task it returns is held to be disposed\\nwhen the wind\", \"ow is closed:\\n\\nprivate async Task HandleResponsesAsync(CancellationToken token)\\n{\\n    var stream = _\", \"duplexStream.ResponseStream;\\n\\n    try\\n    {\\n        await foreach (var update in stream.ReadAllAsync\", \"(token))\\n        {\\n            var price = Prices.FirstOrDefault(p => p.Symbol.Equals(update.Symbol)\", \");\\n            if (price == null)\\n            {\\n                price = new PriceViewModel(this) {Sy\", \"mbol = update.Symbol, Price =\\nupdate.PriceCents / 100m};\\n                Prices.Add(price);\\n        \", \"    }\\n            else\\n            {\\n                price.Price = update.PriceCents / 100m;\\n       \", \"     }\\n        }\\n    }\\n\\n62\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\f    catch (OperationCancell\", \"edException) { }\\n}\\n\\nClient cleanup\\n\\nWhen the window is closed and the MainWindowViewModel is dispose\", \"d (from the Closed event of\\nMainWindow), we recommend that you properly dispose the AsyncDuplexStrea\", \"mingCall object. In\\nparticular, the CompleteAsync method on the RequestStream should be called to gr\", \"acefully close the\\nstream on the server. This example shows the DisposeAsync method from the sample \", \"view-model:\\n\\npublic async ValueTask DisposeAsync()\\n{\\n    try\\n    {\\n        await _duplexStream.Reque\", \"stStream.CompleteAsync().ConfigureAwait(false);\\n        await _responseTask.ConfigureAwait(false);\\n \", \"   }\\n    finally\\n    {\\n        _duplexStream.Dispose();\\n    }\\n}\\n\\nClosing request streams enables the\", \" server to dispose of its own resources in a timely way. This\\nimproves the efficiency and scalabilit\", \"y of services and prevents exceptions.\\n\\ngRPC streaming services vs. repeated fields\\n\\ngRPC services p\", \"rovide two ways of returning datasets, or lists of objects. The Protocol Buffers message\\nspecificati\", \"on uses the repeated keyword for declaring lists or arrays of messages within another\\nmessage. The g\", \"RPC service specification uses the stream keyword to declare a long-running persistent\\nconnection. O\", \"ver that connection, multiple messages are sent, and can be processed, individually.\\n\\nYou can also u\", \"se the stream feature for long-running temporal data such as notifications or log\\nmessages. But this\", \" chapter will consider its use for returning a single dataset.\\n\\nWhich you should use depends on fact\", \"ors such as:\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe overall size of the dataset.\\n\\nThe time it took to create the dataset at eith\", \"er the client or server end.\\n\\n\\u2022  Whether the consumer of the dataset can start acting on it as soon \", \"as the first item is\\n\\navailable, or needs the complete dataset to do anything useful.\\n\\nWhen to use r\", \"epeated fields\\n\\nFor any dataset that\\u2019s constrained in size and that can be generated in its entirety\", \" in a short time\\u2014\\nsay, under one second\\u2014you should use a repeated field in a regular Protobuf messag\", \"e. For example,\\nin an e-commerce system, to build a list of items within an order is probably quick \", \"and the list won\\u2019t\\nbe very large. Returning a single message with a repeated field is an order of ma\", \"gnitude faster than\\nusing stream and incurs less network overhead.\\n\\n63\\n\\nCHAPTER 5 | Migrate a WCF so\", \"lution to gRPC\\n\\n\\fIf the client needs all the data before starting to process it and the dataset is s\", \"mall enough to\\nconstruct in memory, then consider using a repeated field. Consider it even if the cr\", \"eation of the\\ndataset in memory on the server is slower.\\n\\nWhen to use stream methods\\n\\nWhen the messa\", \"ge objects in your datasets are potentially very large, it\\u2019s best for you transfer them\\nby using str\", \"eaming requests or responses. It\\u2019s more efficient to construct a large object in memory,\\nwrite it to\", \" the network, and then free up the resources. This approach will improve the scalability of\\nyour ser\", \"vice.\\n\\nSimilarly, you should send datasets of unconstrained size over streams to avoid running out o\", \"f\\nmemory while constructing them.\\n\\nFor datasets where the consumer can separately process each item,\", \" you should consider using a\\nstream if it means that progress can be indicated to the user. Using a \", \"stream can improve the\\nresponsiveness of an application, but you should balance it against the overa\", \"ll performance of the\\napplication.\\n\\nAnother scenario where streams can be useful is where a message \", \"is being processed across multiple\\nservices. If each service in a chain returns a stream, then the t\", \"erminal service (that is, the last one in\\nthe chain) can start returning messages. These messages ca\", \"n be processed and passed back along the\\nchain to the original requestor. The requestor can either r\", \"eturn a stream or aggregate the results into\\na single response message. This approach lends itself w\", \"ell to patterns like MapReduce.\\n\\nCreate gRPC client libraries\\n\\nIt isn\\u2019t necessary to distribute clie\", \"nt libraries for a gRPC application. You can create a shared library of\\n.proto files within your org\", \"anization, and other teams can use those files to generate client code in\\ntheir own projects. But if\", \" you have a private NuGet repository and many other teams are using .NET,\\nyou can create and publish\", \" client NuGet packages as part of your service project. This approach can\\nbe a good way of sharing a\", \"nd promoting your service.\\n\\nOne advantage of distributing a client library is that you can enhance t\", \"he generated gRPC and\\nProtobuf classes with helpful \\u201cconvenience\\u201d methods and properties. In the cli\", \"ent code, as in the\\nserver, all the classes are declared as partial, so you can extend them without \", \"editing the generated\\ncode. This behavior means it\\u2019s easy to add constructors, methods, and calculat\", \"ed properties to the\\nbasic types.\\n\\nCaution\\n\\nYou shouldn\\u2019t use custom code to provide essential funct\", \"ionality. You don\\u2019t want to restrict that\\nessential functionality to .NET teams that use the shared \", \"library, and not provide it to teams that use\\nother languages or platforms, such as Python or Java.\\n\", \"\\nEnsure that as many teams as possible can access your gRPC service. The best way to do this\\nfunctio\", \"nality is to share .proto files so developers can generate their own clients. This approach is\\n\\n64\\n\\n\", \"CHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fparticularly true in a multi-platform environment, wher\", \"e different teams frequently use different\\nprogramming languages and frameworks, or where your API i\", \"s externally accessible.\\n\\nUseful extensions\\n\\nThere are two commonly used interfaces in .NET for deal\", \"ing with streams of objects: IEnumerable and\\nIObservable. Starting with .NET Core 3.0 and C# 8.0, th\", \"ere\\u2019s an IAsyncEnumerable interface for\\nprocessing streams asynchronously, and an await foreach synt\", \"ax for using the interface. This section\\npresents reusable code for applying these interfaces to gRP\", \"C streams.\\n\\nWith the .NET gRPC client libraries, there\\u2019s a ReadAllAsync extension method for\\nIAsyncS\", \"treamReader<T> that creates an IAsyncEnumerable<T> interface. For developers using\\nreactive programm\", \"ing, an equivalent extension method to create an IObservable<T> interface might\\nlook like the exampl\", \"e in the following section.\\n\\nIObservable\\n\\nThe IObservable<T> interface is the \\u201creactive\\u201d inverse of \", \"IEnumerable<T>. Rather than pulling items\\nfrom a stream, the reactive approach lets the stream push \", \"items to a subscriber. This behavior is very\\nsimilar to gRPC streams, and it\\u2019s easy to wrap an IObse\", \"rvable<T> interface around an\\nIAsyncStreamReader<T> interface.\\n\\nThis code is longer than the IAsyncE\", \"numerable<T> code, because C# doesn\\u2019t have built-in support for\\nworking with observables. You have t\", \"o create the implementation class manually. It\\u2019s a generic class,\\nthough, so a single implementation\", \" works across all types.\\n\\nnamespace Grpc.Core;\\n\\npublic class GrpcStreamObservable<T> : IObservable<T\", \">\\n{\\n    private readonly IAsyncStreamReader<T> _reader;\\n    private readonly CancellationToken _toke\", \"n;\\n    private int _used;\\n\\n    public GrpcStreamObservable(IAsyncStreamReader<T> reader, Cancellatio\", \"nToken token =\\ndefault)\\n    {\\n        _reader = reader ?? throw new ArgumentNullException(nameof(rea\", \"der));\\n        _token = token;\\n        _used = 0;\\n    }\\n\\n    public IDisposable Subscribe(IObserver<\", \"T> observer) =>\\n        Interlocked.Exchange(ref _used, 1) == 0\\n            ? new GrpcStreamSubscrip\", \"tion<T>(_reader, observer, _token)\\n            : throw new InvalidOperationException(\\\"Subscribe can \", \"only be called once.\\\");\\n\\n}\\n\\n65\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fImportant\\n\\nThis observa\", \"ble implementation allows the Subscribe method to be called only once, because having\\nmultiple subsc\", \"ribers trying to read from the stream would result in chaos. There are operators, such as\\nReplay in \", \"the System.Reactive.Linq, that enable buffering and repeatable sharing of observables,\\nwhich can be \", \"used with this implementation.\\n\\nThe GrpcStreamSubscription class handles the enumeration of the IAsy\", \"ncStreamReader:\\n\\npublic class GrpcStreamSubscription<T> : IDisposable\\n{\\n    private readonly IAsyncS\", \"treamReader<T> _reader;\\n    private readonly IObserver<T> _observer;\\n\\n    private readonly Cancellat\", \"ionTokenSource _tokenSource;\\n\\n    private readonly Task _task;\\n\\n    private bool _completed;\\n\\n    pu\", \"blic GrpcStreamSubscription(IAsyncStreamReader<T> reader, IObserver<T> observer,\\nCancellationToken t\", \"oken = default)\\n    {\\n        _reader = reader ?? throw new ArgumentNullException(nameof(reader));\\n \", \"       _observer = observer ?? throw new ArgumentNullException(nameof(observer));\\n\\n        _tokenSou\", \"rce = new CancellationTokenSource();\\n        token.Register(_tokenSource.Cancel);\\n\\n        _task = R\", \"un(_tokenSource.Token);\\n    }\\n\\n    private async Task Run(CancellationToken token)\\n    {\\n        whi\", \"le (!token.IsCancellationRequested)\\n        {\\n            try\\n            {\\n                if (!awa\", \"it _reader.MoveNext(token)) break;\\n            }\\n            catch (RpcException e) when (e.StatusCo\", \"de == Grpc.Core.StatusCode.NotFound)\\n            {\\n                break;\\n            }\\n            \", \"catch (OperationCanceledException)\\n            {\\n                break;\\n            }\\n            ca\", \"tch (Exception e)\\n            {\\n                _observer.OnError(e);\\n                _completed = t\", \"rue;\\n                return;\\n            }\\n\\n            _observer.OnNext(_reader.Current);\\n        }\", \"\\n\\n        _completed = true;\\n\\n66\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\f        _observer.OnC\", \"ompleted();\\n    }\\n\\n    public void Dispose()\\n    {\\n        if (!_completed && !_tokenSource.IsCancel\", \"lationRequested)\\n        {\\n            _tokenSource.Cancel();\\n        }\\n\\n        _tokenSource.Dispos\", \"e();\\n        _task.Dispose();\\n    }\\n\\n}\\n\\nAll that is required now is a simple extension method to cre\", \"ate the observable from the stream reader.\\n\\nnamespace Grpc.Core;\\npublic static class AsyncStreamRead\", \"erObservableExtensions\\n{\\n    public static IObservable<T> AsObservable<T>(\\n        this IAsyncStream\", \"Reader<T> reader,\\n        CancellationToken cancellationToken = default) =>\\n        new GrpcStreamOb\", \"servable<T>(reader, cancellationToken);\\n}\\n\\nSummary\\n\\nThe IAsyncEnumerable and IObservable models are \", \"both well-supported and well-documented ways\\nof dealing with asynchronous streams of data in .NET. g\", \"RPC streams map well to both paradigms,\\noffering close integration with .NET, and reactive and async\", \"hronous programming styles.\\n\\n67\\n\\nCHAPTER 5 | Migrate a WCF solution to gRPC\\n\\n\\fCHAPTER  6\\n\\nSecurity i\", \"n gRPC\\napplications\\n\\nIn any real-world scenario, securing applications and services are essential. S\", \"ecurity covers three key\\nareas:\\n\\nEncrypting network traffic to prevent malicious hackers from interc\", \"epting it.\\n\\nAuthenticating clients and servers to establish identity and trust.\\n\\nAuthorizing clients\", \" to control access to systems and apply permissions based on identity.\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nNote\\n\\nAuthenticatio\", \"n is concerned with establishing the identity of a client or server. Authorization is\\nconcerned with\", \" determining whether a client has permission to access a resource or issue a command.\\n\\nThis chapter \", \"will cover the facilities for authentication and authorization in gRPC for ASP.NET Core. It\\nwill als\", \"o discuss network security through TLS encrypted connections.\\n\\nWCF authentication and authorization\\n\", \"\\nIn Windows Communication Foundation (WCF), authentication and authorization were handled in\\ndiffere\", \"nt ways, depending on the transports and bindings being used. WCF supported various WS-*\\nsecurity st\", \"andards. It also supported Windows authentication for HTTP services running in IIS or\\nNetTCP service\", \"s between Windows systems.\\n\\ngRPC authentication and authorization\\n\\ngRPC authentication and authoriza\", \"tion works on two levels:\\n\\n\\u2022\\n\\n\\u2022\\n\\nCall-level authentication/authorization is usually handled through \", \"tokens that are applied in\\nmetadata when the call is made.\\n\\nChannel-level authentication uses a clie\", \"nt certificate that\\u2019s applied at the connection level. It\\ncan also include call-level authentication\", \"/authorization credentials to be applied to every call\\non the channel automatically.\\n\\nYou can use ei\", \"ther or both of these mechanisms to help secure your service.\\n\\n68\\n\\nCHAPTER 6 | Security in gRPC appl\", \"ications\\n\\n\\fThe ASP.NET Core implementation of gRPC supports authentication and authorization through\", \" most\\nof the standard ASP.NET Core mechanisms:\\n\\n\\u2022\\n\\nCall authentication\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\nAzure Active \", \"Directory\\n\\nIdentityServer\\n\\nJWT Bearer Token\\n\\nOAuth 2.0\\n\\nOpenID Connect\\n\\n\\u2013  WS-Federation\\n\\n\\u2022\\n\\nChannel\", \" authentication\\n\\n\\u2013\\n\\nClient certificate\\n\\nThe call authentication methods are all based on tokens. The\", \" only real difference is how the tokens are\\ngenerated and the libraries that are used to validate th\", \"e tokens in the ASP.NET Core service.\\n\\nFor more information, see the Authentication and authorizatio\", \"n article.\\n\\nNote\\n\\nWhen you\\u2019re using gRPC over a TLS-encrypted HTTP/2 connection, all traffic between\", \" clients and\\nservers is encrypted, even if you don\\u2019t use channel-level authentication.\\n\\nThis chapter\", \" will show how to apply call credentials and channel credentials to a gRPC service. It will\\nalso sho\", \"w how to use credentials from a .NET gRPC client to authenticate with the service.\\n\\nCall credentials\", \"\\n\\nCall credentials are all based on a token passed in metadata with each request.\\n\\nWS-Federation\\n\\nAS\", \"P.NET Core supports WS-Federation using the WsFederation NuGet package. WS-Federation is the\\nclosest\", \" available alternative to Windows Authentication, which isn\\u2019t supported over HTTP/2. Users are\\nauthe\", \"nticated by using Active Directory Federation Services (AD FS), which provides a token that can\\nbe u\", \"sed to authenticate with ASP.NET Core.\\n\\nFor more information on how to get started with this authent\", \"ication method, see Authenticate users\\nwith WS-Federation in ASP.NET Core.\\n\\nJWT Bearer tokens\\n\\nThe J\", \"SON Web Token (JWT) standard provides a way to encode information about a user and their\\nclaims in a\", \"n encoded string. It also provides a way to sign that token, so that the consumer can verify\\nthe int\", \"egrity of the token by using public key cryptography. You can use various services, such as\\nIdentity\", \"Server4, to authenticate users and generate OpenID Connect (OIDC) tokens to use with gRPC\\nand HTTP A\", \"PIs.\\n\\n69\\n\\nCHAPTER 6 | Security in gRPC applications\\n\\n\\fASP.NET Core 7.0 can handle JWTs by using the \", \"JWT Bearer package. The configuration is exactly the\\nsame for a gRPC application as it is for an ASP\", \".NET Core MVC application. Here, we\\u2019ll focus on JWT\\nBearer tokens, because they\\u2019re easier to develop\", \" with than WS-Federation.\\n\\nAdd authentication and authorization to the server\\n\\nThe JWT Bearer packag\", \"e isn\\u2019t included in ASP.NET Core 7.0 by default. Install the\\nMicrosoft.AspNetCore.Authentication.Jwt\", \"Bearer NuGet package in your app.\\n\\nAdd the Authentication service in the Program.cs class, and confi\", \"gure the JWT Bearer handler:\\n\\n//\\n//\\nbuilder.Services.AddGrpc();\\n\\nvar signingKey = ObtainSigningKeySo\", \"mehow();\\n\\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\\n    .AddJwtBear\", \"er(options =>\\n    {\\n        options.TokenValidationParameters =\\n            new TokenValidationParam\", \"eters\\n            {\\n                ValidateAudience = false,\\n                ValidateIssuer = false\", \",\\n                ValidateActor = false,\\n                ValidateLifetime = true,\\n                Is\", \"suerSigningKey = signingKey\\n            };\\n    });\\n//\\n//\\n\\nThe IssuerSigningKey property requires an \", \"implementation of\\nMicrosoft.IdentityModels.Tokens.SecurityKey with the cryptographic data necessary \", \"to validate the\\nsigned tokens. Store this token securely in a secrets server, like Azure Key Vault.\\n\", \"\\nNext, add the Authorization service, which controls access to the system:\\n\\n    services.AddAuthoriz\", \"ation(options =>\\n    {\\n        options.AddPolicy(JwtBearerDefaults.AuthenticationScheme, policy =>\\n \", \"       {\\n            policy.AddAuthenticationSchemes(JwtBearerDefaults.AuthenticationScheme);\\n      \", \"      policy.RequireClaim(ClaimTypes.Name);\\n        });\\n    });\\n\\nTip\\n\\nAuthentication and authorizati\", \"on are two separate steps. You use authentication to determine the\\nuser\\u2019s identity. You use authoriz\", \"ation to decide whether that user is allowed to access various parts of\\nthe system.\\n\\n70\\n\\nCHAPTER 6 |\", \" Security in gRPC applications\\n\\n\\fNow add the authentication and authorization middleware to the ASP.\", \"NET Core pipeline in the\\nProgram.cs:\\n\\n//\\n    app.UseRouting();\\n\\n    // Authenticate, then Authorize\\n\", \"    app.UseAuthentication();\\n    app.UseAuthorization();\\n\\n    app.UseEndpoints(endpoints =>\\n    {\\n  \", \"      endpoints.MapGrpcService<PortfolioService>();\\n    });\\n}\\n\\nFinally, apply the [Authorize] attrib\", \"ute to any services or methods to be secured, and use the User\\nproperty from the underlying HttpCont\", \"ext to verify permissions.\\n\\n[Authorize]\\npublic override async Task<GetResponse> Get(GetRequest reque\", \"st, ServerCallContext context)\\n{\\n    if (!TryValidateUser(request.TraderId, context.GetHttpContext()\", \".User))\\n    {\\n        throw new RpcException(new Status(StatusCode.PermissionDenied, \\\"Denied.\\\"));\\n  \", \"  }\\n\\n    var portfolio = await _repository.GetAsync(traderId, request.PortfolioId);\\n\\n    return new \", \"GetResponse\\n    {\\n        Portfolio = Portfolio.FromRepositoryModel(portfolio)\\n    };\\n}\\n\\nProvide cal\", \"l credentials in the client application\\n\\nAfter you\\u2019ve obtained a JWT token from an identity server, \", \"you can use it to authenticate gRPC calls\\nfrom the client by adding it as a metadata header on the c\", \"all, as follows:\\n\\npublic async Task ShowPortfolioAsync(int portfolioId)\\n{\\n    var headers = new Grpc\", \".Core.Metadata\\n    {\\n        { \\\"Authorization\\\", $\\\"Bearer {_userToken}\\\" }\\n    };\\n    var request = ne\", \"w GetRequest\\n    {\\n        TraderId = _userId,\\n        PortfolioId = portfolioId\\n    };\\n    var resp\", \"onse = await _portfoliosClient.GetAsync(request, headers);\\n\\n    // Display portfolio\\n}\\n\\nNow you\\u2019ve s\", \"ecured your gRPC service by using JWT bearer tokens as call credentials. A version of the\\nportfolios\", \" sample gRPC application with authentication and authorization added is on GitHub.\\n\\n71\\n\\nCHAPTER 6 | \", \"Security in gRPC applications\\n\\n\\fChannel credentials\\n\\nAs the name implies, channel credentials are at\", \"tached to the underlying gRPC channel. The standard\\nform of channel credentials uses client certific\", \"ate authentication. In this process, the client provides a\\nTLS certificate when it\\u2019s making the conn\", \"ection, and then the server verifies this certificate before\\nallowing any calls to be made.\\n\\nYou can\", \" combine channel credentials with call credentials to provide comprehensive security for a\\ngRPC serv\", \"ice. The channel credentials prove that the client application is allowed to access the service,\\nand\", \" the call credentials provide information about the person who is using the client application.\\n\\nCli\", \"ent certificate authentication works for gRPC the same way it works for ASP.NET Core. For more\\ninfor\", \"mation, see Configure certificate authentication in ASP.NET Core.\\n\\nFor development purposes you can \", \"use a self-signed certificate, but for production you should use a\\nproper HTTPS certificate signed b\", \"y a trusted authority.\\n\\nAdd certificate authentication to the server\\n\\nConfigure certificate authenti\", \"cation both at the host level (for example, on the Kestrel server), and in\\nthe ASP.NET Core pipeline\", \".\\n\\nConfigure certificate validation on Kestrel\\n\\nYou can configure Kestrel (the ASP.NET Core HTTP ser\", \"ver) to require a client certificate, and optionally\\nto carry out some validation of the supplied ce\", \"rtificate, before accepting incoming connections. You\\nspecify this configuration in the Program.cs:\\n\", \"\\nvar builder = WebApplication.CreateBuilder(args);\\nvar serverCert = ObtainServerCertificate();\\nbuild\", \"er.WebHost.UseKestrel(kestrelServerOptions => {\\n    kestrelServerOptions.ConfigureHttpsDefaults(opt \", \"=>\\n    {\\n        opt.ClientCertificateMode = ClientCertificateMode.RequireCertificate;\\n\\n        // V\", \"erify that client certificate was issued by same CA as server certificate\\n        opt.ClientCertific\", \"ateValidation = (certificate, chain, errors) =>\\n            certificate.Issuer == serverCert.Issuer;\", \"\\n    });\\n\\n});\\n\\nThe ClientCertificateMode.RequireCertificate setting causes Kestrel to immediately re\", \"ject any\\nconnection request that doesn\\u2019t provide a client certificate, but this setting by itself wo\", \"n\\u2019t validate a\\ncertificate that is provided. Add the ClientCertificateValidation callback to enable \", \"Kestrel to validate\\nthe client certificate at the point the connection is made, before the ASP.NET C\", \"ore pipeline is\\nengaged. (In this case, the callback ensures that it was issued by the same Certific\", \"ate Authority as the\\nserver certificate.)\\n\\n72\\n\\nCHAPTER 6 | Security in gRPC applications\\n\\n\\fAdd ASP.N\", \"ET Core certificate authentication\\n\\nThe Microsoft.AspNetCore.Authentication.Certificate NuGet packag\", \"e provides certificate\\nauthentication.\\n\\nAdd the certificate authentication service in the Program.cs\", \", and add authentication and authorization\\nto the ASP.NET Core pipeline.\\n\\n//\\nbuilder.Services.AddAut\", \"hentication(CertificateAuthenticationDefaults.AuthenticationScheme)\\n            .AddCertificate(opti\", \"ons =>\\n            {\\n                options.AllowedCertificateTypes = CertificateTypes.Chained;\\n   \", \"             options.RevocationMode = X509RevocationMode.NoCheck;\\n\\n                options.Events = \", \"new CertificateAuthenticationEvents\\n                {\\n                    OnCertificateValidated = D\", \"evelopmentModeCertificateHelper.Validate\\n                };\\n            });\\nbuilder.Services.AddAuth\", \"orization();\\nbuilder.Services.AddGrpc();\\n\\nvar app = builder.Build();\\n\\n// Configure the HTTP request \", \"pipeline.\\n\\napp.UseRouting();\\n\\napp.UseAuthentication();\\napp.UseEndpoints(endpoints => { endpoints.Map\", \"GrpcService<GreeterService>(); });\\n//\\n\\nProvide channel credentials in the client application\\n\\nWith t\", \"he Grpc.Net.Client package, you configure certificates on an HttpClient instance that is provided\\nto\", \" the GrpcChannel used for the connection.\\n\\nLoad a client certificate from a .PFX file\\n\\nA certificate\", \" can be loaded from a .pfx file.\\n\\nclass Program\\n{\\n    static async Task Main(string[] args)\\n    {\\n  \", \"      // Assume path to a client .pfx file and password are passed from command line\\n        // On W\", \"indows this would probably be a reference to the Certificate Store\\n        var cert = new X509Certif\", \"icate2(args[0], args[1]);\\n\\n        var handler = new HttpClientHandler();\\n        handler.ClientCert\", \"ificates.Add(cert);\\n        var httpClient = new HttpClient(handler);\\n\\n        var channel = GrpcCha\", \"nnel.ForAddress(\\\"https://localhost:5001/\\\", new\\nGrpcChannelOptions\\n        {\\n            HttpClient =\", \" httpClient\\n\\n73\\n\\nCHAPTER 6 | Security in gRPC applications\\n\\n\\f        });\\n\\n        var grpc = new Gre\", \"eter.GreeterClient(channel);\\n        var response = await grpc.SayHelloAsync(new HelloRequest { Name\", \" = \\\"Bob\\\" });\\n        System.Console.WriteLine(response.Message);\\n    }\\n}\\n\\nLoad a client certificate \", \"from certificate and private key .PEM files\\n\\nA certificate can be loaded from a certificate and priv\", \"ate key .pem file.\\n\\nclass Program\\n{\\n    static async Task Main(string[] args)\\n    {\\n        // Assum\", \"e path to a certificate and private key .pem files are passed from command\\nline\\n        string certi\", \"ficatePem = File.ReadAllText(args[0]);\\n        string privateKeyPem = File.ReadAllText(args[1]);\\n   \", \"     var cert = X509Certificate2.CreateFromPem(certificatePem, privateKeyPem);\\n\\n        var handler \", \"= new HttpClientHandler();\\n        handler.ClientCertificates.Add(cert);\\n        using HttpClient ht\", \"tpClient = new(handler);\\n\\n        var channel = GrpcChannel.ForAddress(\\\"https://localhost:5001/\\\", ne\", \"w\\nGrpcChannelOptions\\n        {\\n            HttpClient = httpClient\\n        });\\n\\n        var grpc = n\", \"ew Greeter.GreeterClient(channel);\\n        var response = await grpc.SayHelloAsync(new HelloRequest \", \"{ Name = \\\"Bob\\\" });\\n        System.Console.WriteLine(response.Message);\\n    }\\n}\\n\\nNote\\n\\nDue to an inte\", \"rnal Windows bug as documented here, you\\u2019ll need to apply the following workaround\\nif the certificat\", \"e is created from a certificate and private key PEM data.\\n\\n]{custom-style=Code}`csharp X509Certifica\", \"te2 cert = X509Certificate2.CreateFromPem(certificatePem,\\nrsaPrivateKeyPem); if (RuntimeInformation.\", \"IsOSPlatform(OSPlatform.Windows)) { var originalCert =\\ncert; cert = new X509Certificate2(cert.Export\", \"(X509ContentType.Pkcs12)); originalCert.Dispose(); } [`\\n\\nCombine ChannelCredentials and CallCredenti\", \"als\\n\\nYou can configure your server to use both certificate and token authentication. To do this, app\", \"ly the\\ncertificate changes to the Kestrel server, and use the JWT bearer middleware in ASP.NET Core.\", \"\\n\\nTo provide both ChannelCredentials and CallCredentials on the client, use the\\nChannelCredentials.C\", \"reate method to apply the call credentials. You still need to apply certificate\\nauthentication by us\", \"ing the HttpClient instance. If you pass any arguments to the SslCredentials\\n\\n74\\n\\nCHAPTER 6 | Securi\", \"ty in gRPC applications\\n\\n\\fconstructor, the internal client code throws an exception. The SslCredenti\", \"als parameter is only\\nincluded in the Grpc.Net.Client package\\u2019s Create method to maintain compatibil\", \"ity with the Grpc.Core\\npackage.\\n\\nvar handler = new HttpClientHandler();\\nhandler.ClientCertificates.A\", \"dd(cert);\\n\\nvar httpClient = new HttpClient(handler);\\n\\nvar callCredentials = CallCredentials.FromInte\", \"rceptor(((context, metadata) =>\\n    {\\n        metadata.Add(\\\"Authorization\\\", $\\\"Bearer {_token}\\\");\\n   \", \"     return Task.CompletedTask;\\n    }));\\n\\nvar channelCredentials = ChannelCredentials.Create(new Ssl\", \"Credentials(), callCredentials);\\n\\nvar channel = GrpcChannel.ForAddress(\\\"https://localhost:5001/\\\", ne\", \"w GrpcChannelOptions\\n{\\n    HttpClient = httpClient,\\n    Credentials = channelCredentials\\n});\\n\\nvar gr\", \"pc = new Portfolios.PortfoliosClient(channel);\\n\\nTip\\n\\nYou can use the ChannelCredentials.Create metho\", \"d for a client without certificate authentication. This\\nis a useful way to pass token credentials wi\", \"th every call made on the channel.\\n\\nA version of the FullStockTicker sample gRPC application with ce\", \"rtificate authentication added is on\\nGitHub.\\n\\nEncryption and network security\\n\\nThe network security \", \"model for Windows Communication Foundation (WCF) is extensive and complex.\\nIt includes transport-lev\", \"el security by using HTTPS or TLS-over-TCP, and message-level security by\\nusing the WS-Security spec\", \"ification to encrypt individual messages.\\n\\ngRPC leaves secure networking to the underlying HTTP/2 pr\", \"otocol, which you can secure by using TLS\\ncertificates.\\n\\nWeb browsers insist on using TLS connection\", \"s for HTTP/2, but most programmatic clients, including\\n.NET\\u2019s HttpClient, can use HTTP/2 over unencr\", \"ypted connections.\\n\\nFor public APIs, you should always use TLS connections, and provide valid certif\", \"icates for your services\\nfrom a proper SSL authority. LetsEncrypt provides free, automated SSL certi\", \"ficates, and most hosting\\ninfrastructure today supports the LetsEncrypt standard with common plug-in\", \"s or extensions.\\n\\nFor internal services across a corporate network, you should still consider using \", \"TLS to secure network\\ntraffic to and from your gRPC services.\\n\\n75\\n\\nCHAPTER 6 | Security in gRPC appl\", \"ications\\n\\n\\fIf you need to use explicit TLS between services running in Kubernetes, consider using an\", \" in-cluster\\ncertificate authority and a certificate manager controller like cert-manager. You can th\", \"en automatically\\nassign certificates to services at deployment time.\\n\\n76\\n\\nCHAPTER 6 | Security in gR\", \"PC applications\\n\\n\\fCHAPTER  7\\n\\ngRPC in production\\n\\nYou can run ASP.NET Core 7.0 applications, includi\", \"ng gRPC services, on Windows, on Linux, and in\\ncontainers using modern platforms like Docker and Kub\", \"ernetes. This chapter explores the various\\noptions for running your gRPC services in production, and\", \" looks at monitoring and logging options to\\nensure the optimal operation of systems.\\n\\nSelf-hosted gR\", \"PC applications\\n\\nAlthough ASP.NET Core 7.0 applications can be hosted in IIS on Windows Server, curr\", \"ently it isn\\u2019t\\npossible to host a gRPC application in IIS because some of the HTTP/2 functionality i\", \"sn\\u2019t supported.\\nThis functionality is a goal for a future update to Windows Server.\\n\\nYou can run you\", \"r application as a Windows service. Or you can run it as a Linux service controlled by\\nsystemd, beca\", \"use of features introduced in the .NET 6 hosting extensions.\\n\\nRun your app as a Windows service\\n\\nTo \", \"configure your ASP.NET Core application to run as a Windows service, install the\\nMicrosoft.Extension\", \"s.Hosting.WindowsServices package from NuGet. Then add a call to\\nUseWindowsService to the CreateHost\", \"Builder method in Program.cs.\\n\\nHost.CreateDefaultBuilder(args)\\n    .UseWindowsService()\\n    ...\\n\\nNot\", \"e\\n\\nIf the application isn\\u2019t running as a Windows service, the UseWindowsService method doesn\\u2019t do\\nan\", \"ything.\\n\\nNow publish your application by using one of these methods:\\n\\n\\u2022\\n\\n\\u2022\\n\\nFrom Visual Studio by ri\", \"ght-clicking the project and selecting Publish on the shortcut menu.\\n\\nFrom the .NET CLI.\\n\\nWhen you p\", \"ublish a .NET application, you can choose to create a framework-dependent deployment\\nor a self-conta\", \"ined deployment. Framework-dependent deployments require the .NET Shared Runtime\\nto be installed on \", \"the host where they\\u2019re run. Self-contained deployments are published with a\\ncomplete copy of the .NE\", \"T runtime and framework and can be run on any host. For more information,\\n\\n77\\n\\nCHAPTER 7 | gRPC in p\", \"roduction\\n\\n\\fincluding the advantages and disadvantages of each approach, see the .NET application de\", \"ployment\\ndocumentation.\\n\\nTo publish a self-contained build of the application that doesn\\u2019t require t\", \"he .NET 5 runtime to be\\ninstalled on the host, specify the runtime to be included with the applicati\", \"on. Use the -r (or --runtime)\\nflag.\\n\\ndotnet publish -c Release -r win-x64 -o ./publish\\n\\nTo publish a\", \" framework-dependent build, omit the -r flag.\\n\\ndotnet publish -c Release -o ./publish\\n\\nCopy the comp\", \"lete contents of the publish directory to an installation folder. Then, use the sc tool to\\ncreate a \", \"Windows service for the executable file.\\n\\nsc create MyService binPath=C:\\\\MyService\\\\MyService.exe\\n\\nLo\", \"g to the Windows event log\\n\\nThe UseWindowsService method automatically adds a logging provider that \", \"writes log messages to\\nthe Windows event log. You can configure logging for this provider by adding \", \"an EventLog entry to\\nthe Logging section of appsettings.json or another configuration source.\\n\\nYou c\", \"an override the source name used in the event log by setting a SourceName property in these\\nsettings\", \". If you don\\u2019t specify a name, the default application name (normally the executable assembly\\nname) \", \"will be used.\\n\\nMore information on logging is at the end of this chapter.\\n\\nRun your app as a Linux s\", \"ervice with systemd\\n\\nTo configure your ASP.NET Core application to run as a Linux service (or daemon\", \" in Linux parlance),\\ninstall the Microsoft.Extensions.Hosting.Systemd package from NuGet. Then add a\", \" call to UseSystemd\\nto the CreateHostBuilder method in Program.cs.\\n\\npublic static IHostBuilder Creat\", \"eHostBuilder(string[] args) =>\\n    Host.CreateDefaultBuilder(args)\\n        .UseSystemd() // Enable r\", \"unning as a Systemd service\\n        .ConfigureServices((hostContext, services) =>\\n        {\\n        \", \"   ...\\n        });\\n\\nNote\\n\\nIf the application isn\\u2019t running as a Linux service, the UseSystemd method\", \" doesn\\u2019t do anything.\\n\\nNow publish your application. The application can be either framework depende\", \"nt or self-contained\\nfor the relevant Linux runtime (for example, linux-x64). You can publish by usi\", \"ng one of these\\nmethods:\\n\\n78\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\f\\u2022\\n\\n\\u2022\\n\\nFrom Visual Studio by right-cli\", \"cking the project and selecting Publish on the shortcut menu.\\n\\nFrom the .NET CLI, by using the follo\", \"wing command:\\n\\ndotnet publish -c Release -r linux-x64 -o ./publish\\n\\nCopy the complete contents of th\", \"e publish directory to an installation folder on the Linux host.\\nRegistering the service requires a \", \"special file, called a unit file, to be added to the /etc/systemd/system\\ndirectory. You\\u2019ll need root\", \" permission to create a file in this folder. Name the file with the identifier\\nthat you want systemd\", \" to use and the .service extension. For example, use\\n/etc/systemd/system/myapp.service.\\n\\nThe service\", \" file uses INI format, as shown in this example:\\n\\n[Unit]\\nDescription=My gRPC Application\\n\\n[Service]\\n\", \"Type=notify\\nExecStart=/usr/sbin/myapp\\n\\n[Install]\\nWantedBy=multi-user.target\\n\\nThe Type=notify propert\", \"y tells systemd that the application will notify it on startup and shutdown. The\\nWantedBy=multi-user\", \".target setting will cause the service to start when the Linux system reaches\\n\\u201crunlevel 2,\\u201d which me\", \"ans a nongraphical, multi-user shell is active.\\n\\nBefore systemd will recognize the service, it needs\", \" to reload its configuration. You control systemd by\\nusing the systemctl command. After reloading, u\", \"se the status subcommand to confirm that the\\napplication has registered successfully.\\n\\nsudo systemct\", \"l daemon-reload\\nsudo systemctl status myapp\\n\\nIf you\\u2019ve configured the service correctly, you\\u2019ll get \", \"the following output:\\n\\nmyapp.service - My gRPC Application\\n Loaded: loaded (/etc/systemd/system/myap\", \"p.service; disabled; vendor preset: enabled)\\n Active: inactive (dead)\\n\\nUse the start command to star\", \"t the service.\\n\\nsudo systemctl start myapp.service\\n\\nTip\\n\\nThe .service extension is optional when you\", \"\\u2019re using systemctl start.\\n\\nTo tell systemd to start the service automatically on system startup, us\", \"e the enable command.\\n\\nsudo systemctl enable myapp\\n\\n79\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fLog to jour\", \"nald\\n\\nThe Linux equivalent of the Windows event log is journald, a structured logging system service\", \" that\\u2019s\\npart of systemd. Log messages written to the standard output by a Linux daemon are automatic\", \"ally\\nwritten to journald. To configure logging levels, use the Console section of the logging config\", \"uration.\\nThe UseSystemd host builder method automatically configures the console output format to su\", \"it the\\njournal.\\n\\nBecause journald is the standard for Linux logs, a variety of tools integrate with \", \"it. You can easily route\\nlogs from journald to an external logging system. Working locally on the ho\", \"st, you can use the\\njournalctl command to view logs from the command line.\\n\\nsudo journalctl -u myapp\", \"\\n\\nTip\\n\\nIf you have a GUI environment available on your host, a few graphical log viewers are availab\", \"le for\\nLinux, such as QJournalctl and gnome-logs.\\n\\nTo learn more about querying the systemd journal \", \"from the command line by using journalctl, see the\\nmanpages.\\n\\nHTTPS certificates for self-hosted app\", \"lications\\n\\nWhen you\\u2019re running a gRPC application in production, you should use a TLS certificate fr\", \"om a trusted\\ncertificate authority (CA). This CA might be a public CA, or an internal one for your o\", \"rganization.\\n\\nOn Windows hosts, you can load the certificate from a secure certificate store by usin\", \"g the X509Store\\nclass. You can also use the X509Store class with the OpenSSL key store on some Linux\", \" hosts.\\n\\nYou can also create certificates by using one of the X509Certificate2 constructors, from ei\", \"ther:\\n\\n\\u2022\\n\\n\\u2022\\n\\nA file, such as a .pfx file protected by a strong password\\n\\nBinary data retrieved from \", \"a secure storage service such as Azure Key Vault\\n\\nYou can configure Kestrel to use a certificate in \", \"two ways: from configuration or in code.\\n\\nSet HTTPS certificates by using configuration\\n\\nThe configu\", \"ration approach requires setting the password and path to the certificate .pfx file in the\\nKestrel c\", \"onfiguration section. In appsettings.json, that looks like this:\\n\\n{\\n  \\\"Kestrel\\\": {\\n    \\\"Certificates\", \"\\\": {\\n      \\\"Default\\\": {\\n        \\\"Path\\\": \\\"cert.pfx\\\",\\n        \\\"Password\\\": \\\"DO NOT STORE PLAINTEXT PASS\", \"WORDS IN APPSETTINGS FILES\\\"\\n      }\\n    }\\n  }\\n}\\n\\n80\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fProvide the pa\", \"ssword by using a secure configuration source such as Azure Key Vault or Hashicorp\\nVault.\\n\\nImportant\", \"\\n\\nDon\\u2019t store unencrypted passwords in configuration files.\\n\\nSet HTTPS certificates in code\\n\\nTo conf\", \"igure HTTPS on Kestrel in code, use the ConfigureKestrel method on IWebHostBuilder in the\\nProgram cl\", \"ass.\\n\\npublic static IHostBuilder CreateHostBuilder(string[] args) =>\\n    Host.CreateDefaultBuilder(a\", \"rgs)\\n        .ConfigureWebHostDefaults(webBuilder =>\\n        {\\n            webBuilder.ConfigureKestr\", \"el(kestrel =>\\n            {\\n                kestrel.ConfigureHttpsDefaults(https =>\\n                \", \"{\\n                    https.ServerCertificate = new X509Certificate2(\\\"mycert.pfx\\\",\\n\\\"password\\\");\\n    \", \"            });\\n            });\\n        });\\n\\nAgain, be sure to store the password for the .pfx file \", \"in, and retrieve it from, a secure configuration\\nsource.\\n\\nCreate Docker images\\n\\nThis section covers \", \"the creation of Docker images for ASP.NET Core gRPC applications, ready to run in\\nDocker, Kubernetes\", \", or other container environments. The sample application used, with an ASP.NET\\nCore MVC web app and\", \" a gRPC service, is available on the dotnet-architecture/grpc-for-wcf-\\ndevelopers repository on GitH\", \"ub.\\n\\nMicrosoft base images for ASP.NET Core applications\\n\\nMicrosoft provides a range of base images \", \"for building and running .NET applications. To create an\\nASP.NET Core 7.0 image, you use two base im\", \"ages:\\n\\n\\u2022\\n\\n\\u2022\\n\\nAn SDK image to build and publish the application.\\n\\nA runtime image for deployment.\\n\\nIm\", \"age\\n\\nDescription\\n\\nmcr.microsoft.com/dotnet/sd\\nk\\n\\nFor building applications with docker build. Not to\", \" be used in\\nproduction.\\n\\nmcr.microsoft.com/dotnet/as\\npnet\\n\\nContains the runtime and ASP.NET Core dep\", \"endencies. For\\nproduction.\\n\\nFor each image, there are four variants based on different Linux distrib\", \"utions, distinguished by tags.\\n\\n81\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fImage tag(s)\\n\\nLinux\\n\\nNotes\\n\\n7.0\", \"-bullseye-slim, 7.0\\n\\nDebian 11\\n\\n7.0-alpine\\n\\nAlpine 3.17\\n\\nThe default image if no\\nOS variant is speci\", \"fied.\\n\\nAlpine base images are\\nmuch smaller than\\nDebian or Ubuntu ones.\\n\\nThe Alpine base image is aro\", \"und 100 MB, compared to 200 MB for the Debian and Ubuntu images.\\nSome software packages or libraries\", \" might not be available in Alpine\\u2019s package management. If you\\u2019re\\nnot sure which image to use, you s\", \"hould probably choose the default Debian.\\n\\nImportant\\n\\nMake sure you use the same variant of Linux fo\", \"r the build and the runtime. Applications built and\\npublished on one variant might not work on anoth\", \"er.\\n\\nCreate a Docker image\\n\\nA Docker image is defined by a Dockerfile. This Dockerfile is a text fil\", \"e that contains all the commands\\nneeded to build the application and install any dependencies that a\", \"re required for either building or\\nrunning the application. The following example shows the simplest\", \" Dockerfile for an ASP.NET Core 7.0\\napplication:\\n\\nFROM mcr.microsoft.com/dotnet/sdk:7.0 as build\\n\\nWO\", \"RKDIR /src\\n\\nCOPY ./StockKube.sln .\\nCOPY ./src/StockData/StockData.csproj ./src/StockData/\\nCOPY ./src\", \"/StockWeb/StockWeb.csproj ./src/StockWeb/\\n\\nRUN dotnet restore\\n\\nCOPY . .\\n\\nRUN dotnet publish --no-res\", \"tore -c Release -o /published src/StockData/StockData.csproj\\n\\nFROM mcr.microsoft.com/dotnet/aspnet:7\", \".0 as runtime\\n\\n# Uncomment the line below if running with HTTPS\\n# ENV ASPNETCORE_URLS=https://+:443\\n\", \"\\nWORKDIR /app\\n\\nCOPY --from=build /published .\\n\\nENTRYPOINT [ \\\"dotnet\\\", \\\"StockData.dll\\\" ]\\n\\nThe Dockerf\", \"ile has two parts: the first uses the sdk base image to build and publish the application;\\nthe secon\", \"d creates a runtime image from the aspnet base. This is because the sdk image is around\\n900 MB, comp\", \"ared to around 200 MB for the runtime image, and most of its contents are unnecessary\\nat run time.\\n\\n\", \"82\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fThe build steps\\n\\nStep\\n\\nDescription\\n\\nFROM ...\\n\\nDeclares the base\", \" image and assigns the builder alias.\\n\\nWORKDIR /src\\n\\nCreates the /src directory and sets it as the c\", \"urrent working directory.\\n\\nCOPY . .\\n\\nCopies everything below the current directory on the host into \", \"the\\ncurrent directory on the image.\\n\\nRUN dotnet restore\\n\\nRestores any external packages (ASP.NET Cor\", \"e 3.0 framework is\\npreinstalled with the SDK).\\n\\nRUN dotnet publish ...\\n\\nBuilds and publishes a Relea\", \"se build. The --runtime flag isn\\u2019t required.\\n\\nThe runtime image steps\\n\\nStep\\n\\nDescription\\n\\nFROM ...\\n\\n\", \"Declares a new base image.\\n\\nWORKDIR /app\\n\\nCreates the /app directory and sets it as the current work\", \"ing directory.\\n\\nCOPY --from=builder ...\\n\\nCopies the published application from the previous image, b\", \"y using the\\nbuilder alias from the first FROM line.\\n\\nENTRYPOINT [ ... ]\\n\\nSets the command to run whe\", \"n the container starts. The dotnet\\ncommand in the runtime image can only run DLL files.\\n\\nHTTPS in Do\", \"cker\\n\\nMicrosoft base images for Docker set the ASPNETCORE_URLS environment variable to http://+:80,\\n\", \"meaning that Kestrel runs without HTTPS on that port. If you\\u2019re using HTTPS with a custom certificat\", \"e\\n(as described in Self-hosted gRPC applications), you should override this configuration. Set the\\ne\", \"nvironment variable in the runtime image creation part of your Dockerfile.\\n\\n# Runtime image creation\", \"\\nFROM mcr.microsoft.com/dotnet/aspnet:7.0\\n\\nENV ASPNETCORE_URLS=https://+:443\\n\\nThe .dockerignore file\", \"\\n\\nMuch like .gitignore files that exclude certain files and directories from source control, the\\n.do\", \"ckerignore file can be used to exclude files and directories from being copied to the image during\\nb\", \"uild. This file not only saves time copying, but can also avoid some errors that arise from having t\", \"he\\nobj directory from your PC copied into the image. At a minimum, you should add entries for bin an\", \"d\\nobj to your .dockerignore file.\\n\\nbin/\\nobj/\\n\\n83\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fBuild the image\\n\\n\", \"For a StockKube.sln solution containing two different applications StockData and StockWeb, it\\u2019s\\nsimp\", \"lest to put the Dockerfile for each one of them in the base directory. In that case, to build the\\nim\", \"age, use the following docker build command from the same directory where .sln file resides.\\n\\ndocker\", \" build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .\\n\\nThe confusingly named --tag flag (which c\", \"an be shortened to -t) specifies the whole name of the\\nimage, including the actual tag if specified.\", \" The . at the end specifies the context in which the build\\nwill be run; the current working director\", \"y for the COPY commands in the Dockerfile.\\n\\nIf you have multiple applications within a single soluti\", \"on, you can keep the Dockerfile for each\\napplication in its own folder, beside the .csproj file. You\", \" should still run the docker build command\\nfrom the base directory to ensure that the solution and a\", \"ll the projects are copied into the image. You\\ncan specify a Dockerfile below the current directory \", \"by using the --file (or -f) flag.\\n\\ndocker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .\\n\\n\", \"Run the image in a container on your machine\\n\\nTo run the image in your local Docker instance, use th\", \"e docker run command.\\n\\ndocker run -ti -p 5000:80 stockdata:1.0.0\\n\\nThe -ti flag connects your current\", \" terminal to the container\\u2019s terminal, and runs in interactive mode.\\nThe -p 5000:80 publishes (links\", \") port 80 on the container to port 5000 on the localhost network\\ninterface.\\n\\nPush the image to a reg\", \"istry\\n\\nAfter you\\u2019ve verified that the image works, push it to a Docker registry to make it available\", \" on other\\nsystems. Internal networks will need to provision a Docker registry. This activity can be \", \"as simple as\\nrunning Docker\\u2019s own registry image (the Docker registry runs in a Docker container), b\", \"ut there are\\nvarious more comprehensive solutions available. For external sharing and cloud use, the\", \"re are various\\nmanaged registries available, such as Azure Container Registry or Docker Hub.\\n\\nTo pus\", \"h to Docker Hub, prefix the image name with your user or organization name.\\n\\ndocker tag stockdata:1.\", \"0.0 <myorg>/stockdata:1.0.0\\ndocker push <myorg>/stockdata:1.0.0\\n\\nTo push to a private registry, pref\", \"ix the image name with the registry host name and the organization\\nname.\\n\\ndocker tag stockdata <inte\", \"rnal-registry:5000>/<myorg>/stockdata:1.0.0\\ndocker push <internal-registry:5000>/<myorg>/stockdata:1\", \".0.0\\n\\nAfter the image is in a registry, you can deploy it to individual Docker hosts, or to a contai\", \"ner\\norchestration engine like Kubernetes.\\n\\n84\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fKubernetes\\n\\nAlthough\", \" it\\u2019s possible to run containers manually on Docker hosts, for reliable production systems it\\u2019s\\nbett\", \"er to use a container orchestration engine to manage multiple instances running across several\\nserve\", \"rs in a cluster. There are various container orchestration engines available, including Kubernetes,\\n\", \"Docker Swarm, and Apache Mesos. But of these engines, Kubernetes is far and away the most widely\\nuse\", \"d, so it will be the focus of this chapter.\\n\\nKubernetes includes the following functionality:\\n\\n\\u2022\\n\\n\\u2022\\n\", \"\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nScheduling runs containers on multiple nodes within a cluster, ensuring balanced usage of\\n\", \"the available resource, keeping containers running if there are outages, and handling rolling\\nupdate\", \"s to new versions of images or new configurations.\\n\\nHealth checks monitor containers to ensure conti\", \"nued service.\\n\\nDNS & service discovery handles routing between services within a cluster.\\n\\nIngress e\", \"xposes selected services externally and generally provides load-balancing across\\ninstances of those \", \"services.\\n\\nResource management attaches external resources like storage to containers.\\n\\nThis chapter\", \" will detail how to deploy an ASP.NET Core gRPC service and a website that consumes the\\nservice into\", \" a Kubernetes cluster. The sample application used is available in the dotnet-\\narchitecture/grpc-for\", \"-wcf-developers repository on GitHub.\\n\\nKubernetes terminology\\n\\nKubernetes uses desired state configu\", \"ration: the API is used to describe objects like Pods, Deployments,\\nand Services, and the Control Pl\", \"ane takes care of implementing the desired state across all the nodes\\nin a cluster. A Kubernetes clu\", \"ster has a Master node that runs the Kubernetes API, which you can\\ncommunicate with programmatically\", \" or by using the kubectl command-line tool. kubectl can create\\nand manage objects through command-li\", \"ne arguments, but it works best with YAML files that contain\\ndeclaration data for Kubernetes objects\", \".\\n\\nKubernetes YAML files\\n\\nEvery Kubernetes YAML file will have at least three top-level properties:\\n\", \"\\napiVersion: v1\\nkind: Namespace\\nmetadata:\\n  # Object properties\\n\\nThe apiVersion property is used to \", \"specify which version (and which API) the file is intended for. The\\nkind property specifies the kind\", \" of object the YAML represents. The metadata property contains\\nobject properties like name, namespac\", \"e, and labels.\\n\\nMost Kubernetes YAML files will also have a spec section that describes the resource\", \"s and\\nconfiguration necessary to create the object.\\n\\n85\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fPods\\n\\nPods\", \" are the basic units of execution in Kubernetes. They can run multiple containers, but they\\u2019re also\\n\", \"used to run single containers. The pod also includes any storage resources required by the container\", \"s,\\nand the network IP address.\\n\\nServices\\n\\nServices are meta-objects that describe Pods (or sets of P\", \"ods) and provide a way to access them\\nwithin the cluster, such as mapping a service name to a set of\", \" pod IP addresses by using the cluster\\nDNS service.\\n\\nDeployments\\n\\nDeployments are the desired state \", \"objects for Pods. If you create a pod manually, it won\\u2019t be restarted\\nwhen it terminates. Deployment\", \"s are used to tell the cluster which Pods, and how many replicas of\\nthose Pods, should be running at\", \" the present time.\\n\\nOther objects\\n\\nPods, Services, and Deployments are just three of the most basic \", \"object types. There are dozens of\\nother object types that are managed by Kubernetes clusters. For mo\", \"re information, see the\\nKubernetes Concepts documentation.\\n\\nNamespaces\\n\\nKubernetes clusters are desi\", \"gned to scale to hundreds or thousands of nodes and to run similar\\nnumbers of services. To avoid cla\", \"shes between object names, namespaces are used to group objects\\ntogether as part of larger applicati\", \"ons. Kubernetes\\u2019s own services run in a default namespace. All user\\nobjects should be created in the\", \"ir own namespaces to avoid potential clashes with default objects or\\nother tenants in the cluster.\\n\\n\", \"Get started with Kubernetes\\n\\nIf you\\u2019re running Docker Desktop for Windows or Docker Desktop for Mac,\", \" Kubernetes is already\\navailable. Just enable it in the Kubernetes section of the Settings window:\\n\\n\", \"86\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fTo run a local Kubernetes cluster on Linux, consider minikube, \", \"or MicroK8s if your Linux distribution\\nsupports snaps.\\n\\nTo confirm that your cluster is running and \", \"accessible, run the kubectl version command:\\n\\nkubectl version\\nClient Version: version.Info{Major:\\\"1\\\"\", \", Minor:\\\"19\\\", GitVersion:\\\"v1.19.3\\\",\\nGitCommit:\\\"1e11e4a2108024935ecfcb2912226cedeafd99df\\\", GitTreeSta\", \"te:\\\"clean\\\",\\nBuildDate:\\\"2020-10-14T12:50:19Z\\\", GoVersion:\\\"go1.15.2\\\", Compiler:\\\"gc\\\",\\nPlatform:\\\"windows\", \"/amd64\\\"}\\nServer Version: version.Info{Major:\\\"1\\\", Minor:\\\"19\\\", GitVersion:\\\"v1.19.3\\\",\\nGitCommit:\\\"1e11e4\", \"a2108024935ecfcb2912226cedeafd99df\\\", GitTreeState:\\\"clean\\\",\\nBuildDate:\\\"2020-10-14T12:41:49Z\\\", GoVersi\", \"on:\\\"go1.15.2\\\", Compiler:\\\"gc\\\",\\nPlatform:\\\"linux/amd64\\\"}\\n\\nIn this example, both the kubectl CLI and the\", \" Kubernetes server are running version 1.14.6. Each\\nversion of kubectl is supposed to support the pr\", \"evious and next version of the server, so kubectl 1.14\\nshould work with server versions 1.13 and 1.1\", \"5 as well.\\n\\nRun services on Kubernetes\\n\\nThe sample application has a kube directory that contains th\", \"ree YAML files. The namespace.yml file\\ndeclares a custom namespace: stocks. The stockdata.yml file d\", \"eclares the Deployment and the Service\\nfor the gRPC application, and the stockweb.yml file declares \", \"the Deployment and Service for an\\nASP.NET Core 7.0 MVC web application that consumes the gRPC servic\", \"e.\\n\\nTo use a YAML file with kubectl, run the apply -f command:\\n\\nkubectl apply -f object.yml\\n\\nThe app\", \"ly command will check the validity of the YAML file and display any errors received from the\\nAPI, bu\", \"t doesn\\u2019t wait until all the objects declared in the file have been created because this step can\\n\\n8\", \"7\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\ftake some time. Use the kubectl get command with the relevant ob\", \"ject types to check on object\\ncreation in the cluster.\\n\\nThe namespace declaration\\n\\nNamespace declara\", \"tion is simple and requires only assigning a name:\\n\\napiVersion: v1\\nkind: Namespace\\nmetadata:\\n  name:\", \" stocks\\n\\nUse kubectl to apply the namespace.yml file and to confirm the namespace is created success\", \"fully:\\n\\n> kubectl apply -f namespace.yml\\nnamespace/stocks created\\n\\n> kubectl get namespaces\\nNAME    \", \"          STATUS   AGE\\nstocks            Active   2m53s\\n\\nThe StockData application\\n\\nThe stockdata.ym\", \"l file declares two objects: a Deployment and a Service.\\n\\nThe StockData Deployment\\n\\nThe Deployment p\", \"art of the YAML file provides the spec for the deployment itself, including the\\nnumber of replicas r\", \"equired, and a template for the Pod objects to be created and managed by the\\ndeployment. Note that D\", \"eployment objects are managed by the apps API, as specified in apiVersion,\\nrather than the main Kube\", \"rnetes API.\\n\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: stockdata\\n  namespace: stocks\\nsp\", \"ec:\\n  selector:\\n    matchLabels:\\n      run: stockdata\\n  replicas: 1\\n  template:\\n    metadata:\\n      \", \"labels:\\n        run: stockdata\\n    spec:\\n      containers:\\n      - name: stockdata\\n        image: st\", \"ockdata:1.0.0\\n        imagePullPolicy: Never\\n        resources:\\n          limits:\\n            cpu: 1\", \"00m\\n            memory: 100Mi\\n        ports:\\n        - containerPort: 80\\n\\n88\\n\\nCHAPTER 7 | gRPC in pr\", \"oduction\\n\\n\\fThe spec.selector property is used to match running Pods to the Deployment. The Pod\\u2019s\\nmet\", \"adata.labels property must match the matchLabels property or the API call will fail.\\n\\nThe template.s\", \"pec section declares the container to be run. When you\\u2019re working with a local\\nKubernetes cluster, s\", \"uch as the one provided by Docker Desktop, you can specify images that were\\nbuilt locally as long as\", \" they have a version tag.\\n\\nImportant\\n\\nBy default, Kubernetes will always check for and try to pull a\", \" new image. If it can\\u2019t find the image in\\nany of its known repositories, the Pod creation will fail.\", \" To work with local images, set the\\nimagePullPolicy to Never.\\n\\nThe ports property specifies which co\", \"ntainer ports should be published on the Pod. The stockservice\\nimage runs the service on the standar\", \"d HTTP port, so port 80 is published.\\n\\nThe resources section applies resource limits to the containe\", \"r running within the Pod. This is a good\\npractice because it prevents an individual Pod from consumi\", \"ng all the available CPU or memory on a\\nnode.\\n\\nNote\\n\\nASP.NET Core 7.0 has been optimized and tuned t\", \"o run in resource-limited containers. The\\ndotnet/core/aspnet Docker image sets an environment variab\", \"le to tell the dotnet runtime that it\\u2019s in a\\ncontainer.\\n\\nThe StockData Service\\n\\nThe Service part of \", \"the YAML file declares the service that provides access to the Pods within the\\ncluster.\\n\\napiVersion:\", \" v1\\nkind: Service\\nmetadata:\\n  name: stockdata\\n  namespace: stocks\\nspec:\\n  ports:\\n  - port: 80\\n  sele\", \"ctor:\\n    run: stockdata\\n\\nThe Service spec uses the selector property to match running Pods, in this\", \" case looking for Pods that\\nhave a label run: stockdata. The specified port on matching Pods is publ\", \"ished by the named service.\\nOther Pods running in the stocks namespace can access HTTP on this servi\", \"ce by using\\nhttp://stockdata as the address. Pods running in other namespaces can use the http://sto\", \"ckdata.stocks\\nhost name. You can control cross-namespace service access by using Network Policies.\\n\\n\", \"Deploy the StockData application\\n\\nUse kubectl to apply the stockdata.yml file and confirm that the D\", \"eployment and Service were\\ncreated:\\n\\n89\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\f> kubectl apply -f .\\\\stock\", \"data.yml\\ndeployment.apps/stockdata created\\nservice/stockdata created\\n\\n> kubectl get deployment stock\", \"data --namespace stocks\\nNAME        READY   UP-TO-DATE   AVAILABLE   AGE\\nstockdata   1/1     1      \", \"      1           17s\\n\\n> kubectl get service stockdata --namespace stocks\\nNAME        TYPE        CL\", \"USTER-IP      EXTERNAL-IP   PORT(S)   AGE\\nstockdata   ClusterIP   10.97.132.103   <none>        80/T\", \"CP    33s\\n\\nThe StockWeb application\\n\\nThe stockweb.yml file declares the Deployment and Service for t\", \"he MVC application.\\n\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: stockweb\\n  namespace: st\", \"ocks\\nspec:\\n  selector:\\n    matchLabels:\\n      run: stockweb\\n  replicas: 1\\n  template:\\n    metadata:\\n\", \"      labels:\\n        run: stockweb\\n    spec:\\n      containers:\\n      - name: stockweb\\n        image\", \": stockweb:1.0.0\\n        imagePullPolicy: Never\\n        resources:\\n          limits:\\n            cpu\", \": 100m\\n            memory: 100Mi\\n        ports:\\n        - containerPort: 80\\n        env:\\n        - n\", \"ame: StockData__Address\\n          value: \\\"http://stockdata\\\"\\n        - name: DOTNET_SYSTEM_NET_HTTP_S\", \"OCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT\\n          value: \\\"true\\\"\\n\\n---\\n\\napiVersion: v1\\nkind: Service\", \"\\nmetadata:\\n  name: stockweb\\n  namespace: stocks\\nspec:\\n  type: NodePort\\n  ports:\\n  - port: 80\\n  selec\", \"tor:\\n    run: stockweb\\n\\n90\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fEnvironment variables\\n\\nThe env section \", \"of the Deployment object specifies environment variables to be set in the container\\nthat\\u2019s running t\", \"he stockweb:1.0.0 images.\\n\\nThe StockData__Address environment variable will map to the StockData:Add\", \"ress configuration\\nsetting thanks to the EnvironmentVariables configuration provider. This setting u\", \"ses double\\nunderscores between names to separate sections. The address uses the service name of the \", \"stockdata\\nService, which is running in the same Kubernetes namespace.\\n\\nThe DOTNET_SYSTEM_NET_HTTP_SO\", \"CKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT\\nenvironment variable sets an AppContext switch that enables\", \" unencrypted HTTP/2 connections for\\nHttpClient. This environment variable does the same thing as set\", \"ting the switch in code, as shown\\nhere:\\n\\nAppContext.SetSwitch(\\\"System.Net.Http.SocketsHttpHandler.Ht\", \"tp2UnencryptedSupport\\\", true);\\n\\nIf you use an environment variable for the switch, you can easily ch\", \"ange the context depending on the\\ncontext in which the application is running.\\n\\nService types\\n\\nThe t\", \"ype: NodePort property is used to make the web application accessible from outside the cluster.\\nThis\", \" property type causes Kubernetes to publish port 80 on the Service to an arbitrary port on the\\nclust\", \"er\\u2019s external network sockets. You can find the assigned port by using the kubectl get service\\ncomma\", \"nd.\\n\\nThe stockdata Service shouldn\\u2019t be accessible from outside the cluster, so it uses the default \", \"type,\\nClusterIP.\\n\\nProduction systems will most likely use an integrated load balancer to expose publ\", \"ic applications to\\nexternal consumers. Services exposed in this way should use the LoadBalancer type\", \".\\n\\nFor more information on Service types, see the Kubernetes Publishing Services documentation.\\n\\nDep\", \"loy the StockWeb application\\n\\nUse kubectl to apply the stockweb.yml file and confirm that the Deploy\", \"ment and Service were created:\\n\\n> kubectl apply -f .\\\\stockweb.yml\\ndeployment.apps/stockweb created\\ns\", \"ervice/stockweb created\\n\\n> kubectl get deployment stockweb --namespace stocks\\nNAME       READY   UP-\", \"TO-DATE   AVAILABLE   AGE\\nstockweb   1/1     1            1           8s\\n\\n> kubectl get service stoc\", \"kweb --namespace stocks\\nNAME       TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE\\nstockw\", \"eb   NodePort   10.106.141.5   <none>        80:32564/TCP   13s\\n\\nThe output of the get service comma\", \"nd shows that the HTTP port has been published to port 32564\\non the external network. For Docker Des\", \"ktop, this IP address will be localhost. You can access the\\napplication by browsing to http://localh\", \"ost:32564.\\n\\n91\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fTest the application\\n\\nThe StockWeb application disp\", \"lays a list of NASDAQ stocks that are retrieved from a simple request-\\nreply service. For this demon\", \"stration, each line also shows the unique ID of the Service instance that\\nreturned it.\\n\\nIf the numbe\", \"r of replicas of the stockdata Service were increased, you might expect the Server value\\nto change f\", \"rom line to line, but in fact all 100 records are always returned from the same instance. If\\nyou ref\", \"resh the page every few seconds, the server ID remains the same. Why does this happen?\\nThere are two\", \" factors at play here.\\n\\nFirst, the Kubernetes Service discovery system uses round-robin load balanci\", \"ng by default. The first\\ntime the DNS server is queried, it will return the first matching IP addres\", \"s for the Service. The next\\ntime, it will return the next IP address in the list, and so on, until t\", \"he end. At that point, it loops back to\\nthe start.\\n\\nSecond, the HttpClient used for the StockWeb app\", \"lication\\u2019s gRPC client is created and managed by\\nthe ASP.NET Core HttpClientFactory, and a single in\", \"stance of this client is used for every call to the\\npage. The client only does one DNS lookup, so al\", \"l requests are routed to the same IP address. And\\nbecause the HttpClientHandler is cached for perfor\", \"mance reasons, multiple requests in quick\\nsuccession will all use the same IP address, until the cac\", \"hed DNS entry expires or the handler instance\\nis disposed for some reason.\\n\\nThe result is that by de\", \"fault requests to a gRPC Service aren\\u2019t balanced across all instances of that\\nService in the cluster\", \". Different consumers will use different instances, but that doesn\\u2019t guarantee a\\ngood distribution o\", \"f requests or a balanced use of resources.\\n\\nThe next chapter, Service meshes, will address this prob\", \"lem.\\n\\n92\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fService meshes\\n\\nA service mesh is an infrastructure compo\", \"nent that takes control of routing service requests within a\\nnetwork. Service meshes can handle all \", \"kinds of network-level concerns within a Kubernetes cluster,\\nincluding:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nService discove\", \"ry\\n\\nLoad balancing\\n\\nFault tolerance\\n\\nEncryption\\n\\n\\u2022  Monitoring\\n\\nKubernetes service meshes work by ad\", \"ding an extra container, called a sidecar proxy, to each pod\\nincluded in the mesh. The proxy takes o\", \"ver handling all inbound and outbound network requests. You\\ncan then keep the configuration and mana\", \"gement of networking matters separate from the\\napplication containers. In many cases, this separatio\", \"n doesn\\u2019t require any changes to the application\\ncode.\\n\\nIn the previous chapter\\u2019s example, the gRPC \", \"requests from the web application were all routed to a\\nsingle instance of the gRPC service. This hap\", \"pens because the service\\u2019s host name is resolved to an IP\\naddress, and that IP address is cached for\", \" the lifetime of the HttpClientHandler instance. It might be\\npossible to work around this behavior b\", \"y handling DNS lookups manually or creating multiple clients.\\nBut this workaround would complicate t\", \"he application code without adding any business or customer\\nvalue.\\n\\nWhen you use a service mesh, the\", \" requests from the application container are sent to the sidecar\\nproxy. The sidecar proxy can then d\", \"istribute them intelligently across all instances of the other service.\\nThe mesh can also:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\", \"\\nRespond seamlessly to failures of individual instances of a service.\\n\\nHandle retry semantics for fa\", \"iled calls or timeouts.\\n\\nReroute failed requests to an alternate instance without returning to the c\", \"lient application.\\n\\nThe following screenshot shows the StockWeb application running with the Linkerd\", \" service mesh.\\nThere are no changes to the application code, and the Docker image isn\\u2019t being used. \", \"The only\\nchange required was the addition of an annotation to the deployment in the YAML files for t\", \"he\\nstockdata and stockweb services.\\n\\n93\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fYou can see from the Serve\", \"r column that the requests from the StockWeb application have been\\nrouted to both replicas of the St\", \"ockData service, despite originating from a single HttpClient instance\\nin the application code. In f\", \"act, if you review the code, you\\u2019ll see that all 100 requests to the StockData\\nservice are made simu\", \"ltaneously by using the same HttpClient instance. With the service mesh, those\\nrequests will be bala\", \"nced across however many service instances are available.\\n\\nService meshes apply only to traffic with\", \"in a cluster. For external clients, see the next chapter, Load\\nBalancing.\\n\\nService mesh options\\n\\nThr\", \"ee general-purpose service mesh implementations are currently available for use with Kubernetes:\\nIst\", \"io, Linkerd, and Consul Connect. All three provide request routing/proxying, traffic encryption,\\nres\", \"ilience, host-to-host authentication, and traffic control.\\n\\nChoosing a service mesh depends on multi\", \"ple factors:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe organization\\u2019s specific requirements around costs, compliance, paid suppo\", \"rt plans, and so\\non.\\n\\nThe nature of the cluster, its size, the number of services deployed, and the \", \"volume of traffic\\nwithin the cluster network.\\n\\nEase of deploying and managing the mesh and using it \", \"with services.\\n\\nExample: Add Linkerd to a deployment\\n\\nIn this example, you\\u2019ll learn how to use the L\", \"inkerd service mesh with the StockKube application from\\nthe previous section. To follow this example\", \", you\\u2019ll need to install the Linkerd CLI. You can download\\n\\n94\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fWin\", \"dows binaries from the section that lists GitHub releases. Be sure to use the most recent stable\\nrel\", \"ease and not one of the edge releases.\\n\\nWith the Linkerd CLI installed, follow the Getting Started i\", \"nstructions to install the Linkerd\\ncomponents on your Kubernetes cluster. The instructions are strai\", \"ghtforward, and the installation\\nshould take only a couple of minutes on a local Kubernetes instance\", \".\\n\\nAdd Linkerd to Kubernetes deployments\\n\\nThe Linkerd CLI provides an inject command to add the nece\", \"ssary sections and properties to\\nKubernetes files. You can run the command and write the output to a\", \" new file.\\n\\nlinkerd inject stockdata.yml > stockdata-with-mesh.yml\\nlinkerd inject stockweb.yml > sto\", \"ckweb-with-mesh.yml\\n\\nYou can inspect the new files to see what changes have been made. For deploymen\", \"t objects, a\\nmetadata annotation is added to tell Linkerd to inject a sidecar proxy container into t\", \"he pod when it\\u2019s\\ncreated.\\n\\nIt\\u2019s also possible to pipe the output of the linkerd inject command to ku\", \"bectl directly. The following\\ncommands will work in PowerShell or any Linux shell.\\n\\nlinkerd inject s\", \"tockdata.yml | kubectl apply -f -\\nlinkerd inject stockweb.yml | kubectl apply -f -\\n\\nInspect services\", \" in the Linkerd dashboard\\n\\nOpen the Linkerd dashboard by using the linkerd CLI.\\n\\nlinkerd dashboard\\n\\n\", \"The dashboard provides detailed information about all services that are connected to the mesh.\\n\\n95\\n\\n\", \"CHAPTER 7 | gRPC in production\\n\\n\\fIf you increase the number of replicas of the StockData gRPC servic\", \"e as shown in the following\\nexample, and refresh the StockWeb page in the browser, you should see a \", \"mix of IDs in the Server\\ncolumn. This mix indicates that all the available instances are serving req\", \"uests.\\n\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: stockdata\\n  namespace: stocks\\nspec:\\n \", \" selector:\\n    matchLabels:\\n      run: stockdata\\n  replicas: 2 # Increase the target number of insta\", \"nces\\n  template:\\n    metadata:\\n      annotations:\\n        linkerd.io/inject: enabled\\n      creationT\", \"imestamp: null\\n      labels:\\n        run: stockdata\\n    spec:\\n      containers:\\n      - name: stockd\", \"ata\\n        image: stockdata:1.0.0\\n        imagePullPolicy: Never\\n        resources:\\n          limit\", \"s:\\n            cpu: 100m\\n            memory: 100Mi\\n        ports:\\n        - containerPort: 80\\n\\n96\\n\\nC\", \"HAPTER 7 | gRPC in production\\n\\n\\fLoad balancing gRPC\\n\\nA typical deployment of a gRPC application incl\", \"udes a number of identical instances of the service,\\nproviding resilience and horizontal scalability\", \". Load balancing distributes incoming requests across\\nthese instances to provide full usage of all a\", \"vailable resources. To make this load balancing invisible to\\nthe client, it\\u2019s common to use a proxy \", \"load balancer server to handle requests from clients and route\\nthem to back-end instances.\\n\\nLoad bal\", \"ancers are classified according to the layer they operate on. Layer 4 load balancers work on\\nthe tra\", \"nsport level, for example, with TCP sockets, connections, and packets. Layer 7 load balancers\\nwork a\", \"t the application level, specifically handling HTTP/2 requests for gRPC applications.\\n\\nL4 load balan\", \"cers\\n\\nAn L4 load balancer accepts a TCP connection request from a client, opens another connection t\", \"o one\\nof the back-end instances, and copies data between the two connections with no real processing\", \". L4\\noffers excellent performance and low latency, but with little control or intelligence. As long \", \"as the\\nclient keeps the connection open, all requests will be directed to the same back-end instance\", \".\\n\\nAzure Load Balancer is an example of an L4 load balancer.\\n\\nL7 load balancers\\n\\nAn L7 load balancer\", \" parses incoming HTTP/2 requests and passes them on to back-end instances on a\\nrequest-by-request ba\", \"sis, no matter how long the connection is held by the client.\\n\\nExamples of L7 load balancers:\\n\\n\\u2022\\n\\n\\u2022\\n\", \"\\n\\u2022\\n\\nNGINX\\n\\nHAProxy\\n\\nTraefik\\n\\nAs a rule of thumb, L7 load balancers are the best choice for gRPC and \", \"other HTTP/2 applications (and\\nfor HTTP applications generally, in fact). L4 load balancers will wor\", \"k with gRPC applications, but\\nthey\\u2019re primarily useful when low latency and low overhead are importa\", \"nt.\\n\\nImportant\\n\\nAt the time of this writing, some L7 load balancers don\\u2019t support all the parts of t\", \"he HTTP/2\\nspecification that are required by gRPC services, such as trailing headers.\\n\\nIf you\\u2019re usi\", \"ng TLS encryption, load balancers can terminate the TLS connection and pass unencrypted\\nrequests to \", \"the back-end application, or they can pass the encrypted request along. Either way, the\\nload balance\", \"r will need to be configured with the server\\u2019s public and private key so it can decrypt\\nrequests for\", \" processing.\\n\\nSee to the documentation for your preferred load balancer to find out how to configure\", \" it to handle\\nHTTP/2 requests with your back-end services.\\n\\n97\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fLoa\", \"d balancing within Kubernetes\\n\\nSee the section on service meshes for a discussion of load balancing \", \"across internal services on\\nKubernetes.\\n\\nApplication Performance Management\\n\\nIn production environme\", \"nts like Kubernetes, it\\u2019s important to monitor applications to ensure they\\u2019re\\nrunning optimally. Log\", \"ging and metrics are important in particular. ASP.NET Core, including gRPC,\\nprovides built-in suppor\", \"t for producing and managing log messages and metrics data, as well as\\ntracing data.\\n\\nThe difference\", \" between logging and metrics\\n\\nLogging is concerned with text messages that record detailed informati\", \"on about things that have\\nhappened in the system. Log messages might include exception data, like st\", \"ack traces, or structured\\ndata that provide context about the message. Logging output is commonly wr\", \"itten to a searchable\\ntext store.\\n\\nMetrics refers to numeric data designed to be aggregated and pres\", \"ented by using charts and graphs\\nin a dashboard. The dashboard provides a view of the overall health\", \" and performance of an\\napplication. Metrics data can also be used to trigger automated alerts when a\", \" threshold is exceeded.\\nHere are some examples of metrics data:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nTime taken to process requ\", \"ests.\\n\\nThe number of requests per second being handled by an instance of a service.\\n\\nThe number of f\", \"ailed requests on an instance.\\n\\nLogging in ASP.NET Core gRPC\\n\\nASP.NET Core provides built-in support\", \" for logging, in the form of Microsoft.Extensions.Logging\\nNuGet package. The core parts of this libr\", \"ary are included with the Web SDK, so there\\u2019s no need to\\ninstall it manually. By default, log messag\", \"es are written to the standard output (the \\u201cconsole\\u201d) and to\\nany attached debugger. To write logs to\", \" persistent external data stores, you might need to import\\noptional logging sink packages.\\n\\nThe ASP.\", \"NET Core gRPC framework writes detailed diagnostic logging messages to this logging\\nframework, so th\", \"ey can be processed and stored along with your application\\u2019s own messages.\\n\\nProduce log messages\\n\\nTh\", \"e logging extension is automatically registered with ASP.NET Core\\u2019s dependency injection system,\\nso \", \"you can specify loggers as a constructor parameter on gRPC service types.\\n\\npublic class StockData : \", \"Stocks.StocksBase\\n{\\n    private readonly ILogger<StockData> _logger;\\n\\n    public StockData(ILogger<S\", \"tockData> logger)\\n\\n98\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\f    {\\n        _logger = logger;\\n    }\\n}\\n\\nMan\", \"y log messages, such as requests and exceptions, are provided by the ASP.NET Core and gRPC\\nframework\", \" components. Add your own log messages to provide detail and context about application\\nlogic, rather\", \" than lower-level concerns.\\n\\nFor more information about writing log messages and available logging s\", \"inks and targets, see\\nLogging in .NET Core and ASP.NET Core.\\n\\nMetrics in ASP.NET Core gRPC\\n\\nThe .NET\", \" Core runtime provides a set of components for emitting and observing metrics. These\\ninclude APIs su\", \"ch as the EventSource and EventCounter classes. These APIs can emit basic numeric\\ndata that can be c\", \"onsumed by external processes, like the dotnet-counters global tool, or Event\\nTracing for Windows. F\", \"or more information about using EventCounter in your own code, see\\nEventCounter introduction.\\n\\nFor m\", \"ore advanced metrics and for writing metric data to a wider range of data stores, you might try\\nan o\", \"pen-source project called App Metrics. This suite of libraries provides an extensive set of types to\", \"\\ninstrument your code. It also offers packages to write metrics to different kinds of targets that i\", \"nclude\\ntime-series databases, such as Prometheus and InfluxDB, and Application Insights. The\\nApp.Met\", \"rics.AspNetCore.Mvc NuGet package even adds a comprehensive set of basic metrics that are\\nautomatica\", \"lly generated via integration with the ASP.NET Core framework. The project website\\nprovides template\", \"s for displaying those metrics with the Grafana visualization platform.\\n\\nProduce metrics\\n\\nMost metri\", \"cs platforms support the following types:\\n\\nMetric type\\n\\nDescription\\n\\nCounter\\n\\nGauge\\n\\nHistogram\\n\\nMete\", \"r\\n\\n99\\n\\nTracks how often something happens, such as\\nrequests and errors.\\n\\nRecords a single value that\", \" changes over time,\\nsuch as active connections.\\n\\nMeasures a distribution of values across\\narbitrary \", \"limits. For example, a histogram can\\ntrack dataset size, counting how many\\ncontained <10 records, ho\", \"w many contained\\n11-100 records, how many contained 101-1000\\nrecords, and how many contained >1000\\nr\", \"ecords.\\n\\nMeasures the rate at which an event occurs in\\nvarious time spans.\\n\\nCHAPTER 7 | gRPC in prod\", \"uction\\n\\n\\fMetric type\\n\\nDescription\\n\\nTimer\\n\\nTracks the duration of events and the rate at\\nwhich it occ\", \"urs, stored as a histogram.\\n\\nBy using App Metrics, an IMetrics interface can be obtained via depende\", \"ncy injection, and used to\\nrecord any of these metrics for a gRPC service. The following example sho\", \"ws how to count the\\nnumber of Get requests made over time:\\n\\npublic class StockData : Stocks.StocksBa\", \"se\\n{\\n    private static readonly CounterOptions GetRequestCounter = new CounterOptions\\n    {\\n       \", \" Name = \\\"StockData_Get_Requests\\\",\\n        MeasurementUnit = Unit.Calls\\n    };\\n\\n    private readonly \", \"IStockRepository _repository;\\n    private readonly IMetrics _metrics;\\n\\n    public StockData(IStockRe\", \"pository repository, IMetrics metrics)\\n    {\\n        _repository = repository;\\n        _metrics = me\", \"trics;\\n    }\\n\\n    public override async Task<GetResponse> Get(GetRequest request, ServerCallContext\\n\", \"context)\\n    {\\n        _metrics.Measure.Counter.Increment(GetRequestCounter);\\n\\n        // Serve requ\", \"est...\\n    }\\n}\\n\\nStore and visualize metrics data\\n\\nThe best way to store metrics data is in a time-se\", \"ries database, a specialized data store designed to\\nrecord numerical data series marked with timesta\", \"mps. The most popular of these databases are\\nPrometheus and InfluxDB. Microsoft Azure also provides \", \"dedicated metrics storage through the Azure\\nMonitor service.\\n\\nThe current go-to solution for visuali\", \"zing metrics data is Grafana, which works with a wide range of\\nstorage providers. The following imag\", \"e shows an example Grafana dashboard that displays metrics\\nfrom the Linkerd service mesh running the\", \" StockData sample:\\n\\n100\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fMetrics-based alerting\\n\\nThe numerical natu\", \"re of metrics data means that it\\u2019s ideally suited to drive alerting systems, notifying\\ndevelopers or\", \" support engineers when a value falls outside of some defined tolerance. The platforms\\nalready menti\", \"oned all provide support for alerting via a range of options, including emails, text\\nmessages, or in\", \"-dashboard visualizations.\\n\\nDistributed tracing\\n\\nDistributed tracing is a relatively recent developm\", \"ent in monitoring, which has arisen from the\\nincreasing use of microservices and distributed archite\", \"ctures. A single request from a client browser,\\napplication, or device can be broken down into many \", \"steps and sub-requests, and involve the use of\\nmany services across a network. This activity makes i\", \"t difficult to correlate log messages and metrics\\nwith the specific request that triggered them. Dis\", \"tributed tracing applies identifiers to requests, and\\nallows logs and metrics to be correlated with \", \"a particular operation. This tracing is similar to WCF\\u2019s\\nend-to-end tracing, but it\\u2019s applied across\", \" multiple platforms.\\n\\nDistributed tracing has grown quickly in popularity and is beginning to standa\", \"rdize. The Cloud Native\\nComputing Foundation created the Open Tracing standard, attempting to provid\", \"e vendor-neutral\\nlibraries for working with back ends like Jaeger and Elastic APM. At the same time,\", \" Google created the\\nOpenCensus project to address the same set of problems. These two projects are m\", \"erging into a new\\nproject, OpenTelemetry, which aims to be the industry standard of the future.\\n\\nHow\", \" distributed tracing works\\n\\nDistributed tracing is based on the concept of spans: named, timed opera\", \"tions that are part of a single\\ntrace, which can involve processing on multiple nodes of a system. W\", \"hen a new operation is initiated,\\na trace is created with a unique identifier. For each sub-operatio\", \"n, a span is created with its own\\n\\n101\\n\\nCHAPTER 7 | gRPC in production\\n\\n\\fidentifier and trace identi\", \"fier. As the request passes around the system, various components can\\ncreate child spans that includ\", \"e the identifier of their parent. A span has a context, which contains the\\ntrace and span identifier\", \"s, as well as useful data in the form of key and value pairs (called baggage).\\n\\nDistributed tracing \", \"with DiagnosticSource\\n\\n.NET has an internal module that maps well to distributed traces and spans: D\", \"iagnosticSource. As well\\nas providing a simple way to produce and consume diagnostics within a proce\", \"ss, the\\nDiagnosticSource module has the concept of an activity. An activity is effectively an implem\", \"entation of\\na distributed trace, or a span within a trace. The internals of the module take care of \", \"parent/child\\nactivities, including allocating identifiers. For more information about using the Acti\", \"vity type, see the\\nActivity User Guide on GitHub.\\n\\nBecause DiagnosticSource is a part of the core fr\", \"amework and later, it\\u2019s supported by several core\\ncomponents. These include HttpClient, Entity Frame\", \"work Core, and ASP.NET Core, including explicit\\nsupport in the gRPC framework. When ASP.NET Core rec\", \"eives a request, it checks for a pair of HTTP\\nheaders matching the W3C Trace Context standard. If th\", \"e headers are found, an activity is started by\\nusing the identity values and context from the header\", \"s. If no headers are found, an activity is started\\nwith generated identity values that match the sta\", \"ndard format. Any diagnostics generated by the\\nframework or by application code during the lifetime \", \"of this activity can be tagged with the trace and\\nspan identifiers. The HttpClient support extends t\", \"his functionality further by checking for a current\\nactivity on every request, and automatically add\", \"ing the trace headers to the outgoing request.\\n\\nThe ASP.NET Core gRPC client and server libraries in\", \"clude explicit support for DiagnosticSource and\\nActivity, and create activities and apply and use he\", \"ader information automatically.\\n\\nNote\\n\\nAll of this happens only if a listener is consuming the diagn\", \"ostic information. If there\\u2019s no listener, no\\ndiagnostics are written and no activities are created.\", \"\\n\\nAdd your own DiagnosticSource and Activity\\n\\nTo add your own diagnostics or create explicit spans w\", \"ithin your application code, see the\\nDiagnosticSource User Guide and Activity User Guide.\\n\\nStore dis\", \"tributed trace data\\n\\nAt the time of writing, the OpenTelemetry project is still in the early stages,\", \" and only alpha-quality\\npackages are available for .NET applications. The OpenTracing project curren\", \"tly offers more mature\\nlibraries.\\n\\nThe OpenTracing API is described in the following section. If you\", \" want to use the OpenTelemetry API\\nin your application instead, refer to the OpenTelemetry .NET SDK \", \"repository on GitHub.\\n\\nUse the OpenTracing package to store distributed trace data\\n\\nThe OpenTracing \", \"NuGet package supports all OpenTracing-compliant back ends (which can be used\\nindependently of Diagn\", \"osticSource). There\\u2019s an additional package from the OpenTracing API\\n\\n102\\n\\nCHAPTER 7 | gRPC in produ\", \"ction\\n\\n\\fContributions project, OpenTracing.Contrib.NetCore. This package adds a DiagnosticSource lis\", \"tener,\\nand writes events and activities to a back end automatically. Enabling this package is as sim\", \"ple as\\ninstalling it from NuGet and adding it as a service in your Program class.\\n\\n//\\n\\nbuilder.Servi\", \"ces.AddOpenTracing();\\n\\n//\\n\\nThe OpenTracing package is an abstraction layer, and as such it requires \", \"implementation specific to\\nthe back end. OpenTracing API implementations are available for the follo\", \"wing open source back\\nends.\\n\\nName\\n\\nPackage\\n\\nWebsite\\n\\nJaeger\\n\\nJaeger\\n\\njaegertracing.io\\n\\nElastic APM\\n\\n\", \"Elastic.Apm.NetCoreAll\\n\\nelastic.co/products/apm\\n\\nFor more information on the OpenTracing API for .NE\", \"T, see the OpenTracing for C# and the\\nOpenTracing Contrib C#/.NET Core repositories on GitHub.\\n\\n103\\n\", \"\\nCHAPTER 7 | gRPC in production\\n\\n\\fCHAPTER  8\\n\\nAppendix A - Transactions\\n\\nWindows Communication Found\", \"ation (WCF) supports distributed transactions, allowing you to\\nperform atomic operations across mult\", \"iple services. This functionality is based on the Microsoft\\nDistributed Transaction Coordinator.\\n\\nIn\", \" the newer microservices landscape, this type of automated distributed transaction processing isn\\u2019t\\n\", \"possible. There are too many different technologies involved, including relational databases, NoSQL\\n\", \"data stores, and messaging systems. There might also be a mix of operating systems, programming\\nlang\", \"uages, and frameworks in use in a single environment.\\n\\nWCF distributed transaction is an implementat\", \"ion of what is known as a two-phase commit (2PC). You\\ncan implement 2PC transactions manually by coo\", \"rdinating messages across services, creating open\\ntransactions within each service, and sending comm\", \"it or rollback messages, depending upon success\\nor failure. However, the complexity involved in mana\", \"ging 2PC can increase exponentially as systems\\nevolve. Open transactions hold database locks that ca\", \"n negatively affect performance, or, worse, cause\\ncross-service deadlocks.\\n\\nIf possible, it\\u2019s best t\", \"o avoid distributed transactions altogether. If two items of data are so linked as to\\nrequire atomic\", \" updates, consider handling them both with the same service. Apply those atomic\\nchanges by using a s\", \"ingle request or message to that service.\\n\\nIf that isn\\u2019t possible, then one alternative is to use th\", \"e Saga pattern. In a saga, updates are processed\\nsequentially; as each update succeeds, the next one\", \" is triggered. These triggers can be propagated\\nfrom service to service, or managed by a saga coordi\", \"nator or orchestrator. If an update fails at any\\npoint during the process, the services that have al\", \"ready completed their updates apply specific logic\\nto reverse them.\\n\\nAnother option is to use Domain\", \" Driven Design (DDD) and Command/Query Responsibility\\nSegregation (CQRS), as described in the .NET M\", \"icroservices e-book. In particular, using domain events\\nor event sourcing can help to ensure that up\", \"dates are consistently, if not immediately, applied.\\n\\n104\\n\\nCHAPTER 8 | Appendix A - Transactions\\n\\n\"]"