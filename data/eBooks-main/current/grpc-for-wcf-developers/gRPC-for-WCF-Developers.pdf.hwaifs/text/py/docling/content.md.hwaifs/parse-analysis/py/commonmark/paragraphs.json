[
    "Mark Rendle Miranda Steiner",
    "Mark Rendle Miranda Steiner",
    "EDITION v7.0 - Updated to ASP.NET Core 7.0",
    "EDITION v7.0 - Updated to ASP.NET Core 7.0",
    "Refer changelog for the book updates and community contributions.",
    "Refer changelog for the book updates and community contributions.",
    "PUBLISHED BY",
    "PUBLISHED BY",
    "Microsoft Developer Division, .NET, and Visual Studio product teams",
    "Microsoft Developer Division, .NET, and Visual Studio product teams",
    "A division of Microsoft Corporation",
    "A division of Microsoft Corporation",
    "One Microsoft Way",
    "One Microsoft Way",
    "Redmond, Washington 98052-6399",
    "Redmond, Washington 98052-6399",
    "Copyright \u00a9 2023 by Microsoft Corporation",
    "Copyright \u00a9 2023 by Microsoft Corporation",
    "All rights reserved. No part of the contents of this book may be reproduced or transmitted in any form or by any means without the written permission of the publisher.",
    "All rights reserved. No part of the contents of this book may be reproduced or transmitted in any form or by any means without the written permission of the publisher.",
    "This book is provided ",
    "This book is provided ",
    "Some examples depicted herein are provided for illustration only and are fictitious. No real association or connection is intended or should be inferred.",
    "Some examples depicted herein are provided for illustration only and are fictitious. No real association or connection is intended or should be inferred.",
    "Microsoft and the trademarks listed at https://www.microsoft.com on the ",
    "Microsoft and the trademarks listed at https://www.microsoft.com on the ",
    "The Docker whale logo is a registered trademark of Docker, Inc. Used by permission.",
    "The Docker whale logo is a registered trademark of Docker, Inc. Used by permission.",
    "All other marks and logos are property of their respective owners.",
    "All other marks and logos are property of their respective owners.",
    "Authors:",
    "Authors:",
    "Mark Rendle - Chief Technical Officer - Visual Recode",
    "Mark Rendle - Chief Technical Officer - Visual Recode",
    "Miranda Steiner - Technical Author",
    "Miranda Steiner - Technical Author",
    "Editor:",
    "Editor:",
    "Maira Wenzel - Sr. Content Developer - Microsoft",
    "Maira Wenzel - Sr. Content Developer - Microsoft",
    "gRPC is a modern framework for building networked services and distributed applications. Imagine the performance of Windows Communication Foundation (WCF) NetTCP bindings, combined with the cross-platform interoperability of SOAP. gRPC builds on HTTP/2 and the Protobuf message-encoding protocol to provide high performance, low-bandwidth communication between applications and services. It supports server and client code generation across most popular programming languages and platforms, including .NET, Java, Python, Node.js, Go, and C++. With the first-class support for gRPC in ASP.NET Core 7.0, alongside the existing gRPC tools and libraries for .NET Framework 4.x, it",
    "gRPC is a modern framework for building networked services and distributed applications. Imagine the performance of Windows Communication Foundation (WCF) NetTCP bindings, combined with the cross-platform interoperability of SOAP. gRPC builds on HTTP/2 and the Protobuf message-encoding protocol to provide high performance, low-bandwidth communication between applications and services. It supports server and client code generation across most popular programming languages and platforms, including .NET, Java, Python, Node.js, Go, and C++. With the first-class support for gRPC in ASP.NET Core 7.0, alongside the existing gRPC tools and libraries for .NET Framework 4.x, it",
    "This guide was written for developers working in .NET Framework or .NET who have previously used WCF, and who are seeking to migrate their applications to a modern RPC environment for .NET Core 3.0 and later versions. More generally, if you are upgrading, or considering upgrading, to .NET 7, and you want to use the built-in gRPC tools, this guide is also useful.",
    "This guide was written for developers working in .NET Framework or .NET who have previously used WCF, and who are seeking to migrate their applications to a modern RPC environment for .NET Core 3.0 and later versions. More generally, if you are upgrading, or considering upgrading, to .NET 7, and you want to use the built-in gRPC tools, this guide is also useful.",
    "This is a short introduction to building gRPC Services in ASP.NET Core 7.0, with particular reference to WCF as an analogous platform. It explains the principles of gRPC, relating each concept to the equivalent features of WCF, and offers guidance for migrating an existing WCF application to gRPC. It",
    "This is a short introduction to building gRPC Services in ASP.NET Core 7.0, with particular reference to WCF as an analogous platform. It explains the principles of gRPC, relating each concept to the equivalent features of WCF, and offers guidance for migrating an existing WCF application to gRPC. It",
    "Feel free to forward this guide to your team to help ensure a common understanding of these considerations and opportunities. Having everybody working from a common set of terms and underlying principles helps ensure consistent application of architectural patterns and practices.",
    "Feel free to forward this guide to your team to help ensure a common understanding of these considerations and opportunities. Having everybody working from a common set of terms and underlying principles helps ensure consistent application of architectural patterns and practices.",
    "gRPC website https://grpc.io",
    "gRPC website https://grpc.io",
    "Choosing between .NET 5 and .NET Framework for server apps https://learn.microsoft.com/dotnet/standard/choosing-core-framework-server",
    "Choosing between .NET 5 and .NET Framework for server apps https://learn.microsoft.com/dotnet/standard/choosing-core-framework-server",
    "| Introduction to gRPC for WCF developers ........................................................................... 1                                                                              |",
    "| Introduction to gRPC for WCF developers ........................................................................... 1                                                                              |",
    "| Protobuf Any and Oneof fields for variant types .....................................................................................................                                          | 19   |",
    "| Protobuf Any and Oneof fields for variant types .....................................................................................................                                          | 19   |",
    "| Migrate a WCF solution to gRPC.........................................................................................                                                                 | 37   |",
    "| Migrate a WCF solution to gRPC.........................................................................................                                                                 | 37   |",
    "| Add certificate authentication to the                                                                                                                                                     | server..........................................................................................................72   |",
    "| Add certificate authentication to the                                                                                                                                                     | server..........................................................................................................72   |",
    "Helping machines communicate with each other has been one of the primary preoccupations of the digital age. In particular, there",
    "Helping machines communicate with each other has been one of the primary preoccupations of the digital age. In particular, there",
    "The release of .NET Core 3.0 marks a shift in the way that Microsoft delivers remote communication solutions to developers who want to deliver services across a range of platforms. .NET Core and later doesn",
    "The release of .NET Core 3.0 marks a shift in the way that Microsoft delivers remote communication solutions to developers who want to deliver services across a range of platforms. .NET Core and later doesn",
    "gRPC is a popular framework in the wider software community. It",
    "gRPC is a popular framework in the wider software community. It",
    "The fundamental principle of a computer network as nothing more than a group of computers exchanging data with each other to achieve a set of interrelated tasks hasn",
    "The fundamental principle of a computer network as nothing more than a group of computers exchanging data with each other to achieve a set of interrelated tasks hasn",
    "During the 1990s, the emphasis was mainly on improving internal networks that used the same language and platforms. TCP/IP became the gold standard for this type of communication.",
    "During the 1990s, the emphasis was mainly on improving internal networks that used the same language and platforms. TCP/IP became the gold standard for this type of communication.",
    "The focus soon shifted to how best to optimize communication across multiple platforms by promoting a language-agnostic approach. Service-oriented architecture (SOA) provided a structure for loosely coupling a broad collection of services that could be provided to an application.",
    "The focus soon shifted to how best to optimize communication across multiple platforms by promoting a language-agnostic approach. Service-oriented architecture (SOA) provided a structure for loosely coupling a broad collection of services that could be provided to an application.",
    "The development of web services occurred when all major platforms could access the internet, but they still couldn",
    "The development of web services occurred when all major platforms could access the internet, but they still couldn",
    "XML to tag and code data.",
    "XML to tag and code data.",
    "Simple Object Access Protocol (SOAP) to transfer data.",
    "Simple Object Access Protocol (SOAP) to transfer data.",
    "Web Services Definition Language (WSDL) to describe and connect web services to client applications.",
    "Web Services Definition Language (WSDL) to describe and connect web services to client applications.",
    "Universal Description, Discovery, and Integration (UDDI) to make web services discoverable by other services.",
    "Universal Description, Discovery, and Integration (UDDI) to make web services discoverable by other services.",
    "SOAP defines the rules by which distributed elements of an application can communicate with each other, even if they",
    "SOAP defines the rules by which distributed elements of an application can communicate with each other, even if they",
    "Windows Communication Foundation is a framework for building services. It was designed in the early 2000s to help developers using early SOA to manage the complexities of working with SOAP. Although it removes the requirement for the developers to write their own SOAP protocols, WCF still uses SOAP to enable interoperability with other systems. WCF was also designed to deliver solutions across multiple protocols (HTTP/1.1, Net.TCP, and so on).",
    "Windows Communication Foundation is a framework for building services. It was designed in the early 2000s to help developers using early SOA to manage the complexities of working with SOAP. Although it removes the requirement for the developers to write their own SOAP protocols, WCF still uses SOAP to enable interoperability with other systems. WCF was also designed to deliver solutions across multiple protocols (HTTP/1.1, Net.TCP, and so on).",
    "In microservice architectures, large applications are built as a collection of smaller modular services. Each component does a specific task or process, and components are designed to work interoperably but can be isolated as necessary.",
    "In microservice architectures, large applications are built as a collection of smaller modular services. Each component does a specific task or process, and components are designed to work interoperably but can be isolated as necessary.",
    "Advantages to microservices include:",
    "Advantages to microservices include:",
    "Changes and upgrades can be handled independently.",
    "Changes and upgrades can be handled independently.",
    "Error handling becomes more efficient because problems can be traced to specific services that are then isolated, rebuilt, tested, and redeployed independently of the other services.",
    "Error handling becomes more efficient because problems can be traced to specific services that are then isolated, rebuilt, tested, and redeployed independently of the other services.",
    "Scalability can be confined to specific instances or services rather than the whole application.",
    "Scalability can be confined to specific instances or services rather than the whole application.",
    "Development can happen across multiple teams, with less friction than occurs when many teams work on a single codebase.",
    "Development can happen across multiple teams, with less friction than occurs when many teams work on a single codebase.",
    "The move towards increasing virtualization, cloud computing, containers, and the Internet of Things has contributed to the ongoing rise of microservices. But microservices aren",
    "The move towards increasing virtualization, cloud computing, containers, and the Internet of Things has contributed to the ongoing rise of microservices. But microservices aren",
    "It was into this environment that gRPC was launched, 10 years after Microsoft first released WCF. Evolved directly from Google",
    "It was into this environment that gRPC was launched, 10 years after Microsoft first released WCF. Evolved directly from Google",
    "This guide covers the key features of gRPC. The early chapters take a high-level look at the main features of WCF and compare them to those of gRPC. It identifies where there are direct correlations between WCF and gRPC and also where gRPC offers an advant age. When there",
    "This guide covers the key features of gRPC. The early chapters take a high-level look at the main features of WCF and compare them to those of gRPC. It identifies where there are direct correlations between WCF and gRPC and also where gRPC offers an advant age. When there",
    "Using a set of sample WCF applications, Chapter 5 is a deep-dive look at converting the main types of WCF service (simple request-reply, one-way, and streaming) to their equivalents in gRPC.",
    "Using a set of sample WCF applications, Chapter 5 is a deep-dive look at converting the main types of WCF service (simple request-reply, one-way, and streaming) to their equivalents in gRPC.",
    "The final section of the book looks at how to get the best from gRPC in practice. This section includes information on using additional tools, like Docker containers or Kubernetes, to take advantage of the efficiency of gRPC. It also includes a detailed look at monitoring with logging, metrics, and distributed tracing.",
    "The final section of the book looks at how to get the best from gRPC in practice. This section includes information on using additional tools, like Docker containers or Kubernetes, to take advantage of the efficiency of gRPC. It also includes a detailed look at monitoring with logging, metrics, and distributed tracing.",
    "This guide was written for developers working in .NET Framework or .NET Core who have used WCF and who are seeking to migrate their applications to a modern RPC environment for .NET Core 3.0 and later versions. The guide might also be useful more generally for developers upgrading or considering upgrading to .NET and who want to use the built-in gRPC tools.",
    "This guide was written for developers working in .NET Framework or .NET Core who have used WCF and who are seeking to migrate their applications to a modern RPC environment for .NET Core 3.0 and later versions. The guide might also be useful more generally for developers upgrading or considering upgrading to .NET and who want to use the built-in gRPC tools.",
    "After looking at the genesis of both Windows Communication Foundation (WCF) and gRPC in the last chapter, this chapter considers some of the key features of gRPC and how they compare to WCF.",
    "After looking at the genesis of both Windows Communication Foundation (WCF) and gRPC in the last chapter, this chapter considers some of the key features of gRPC and how they compare to WCF.",
    "ASP.NET Core 3.0 is the first release of ASP.NET that natively supports gRPC as a first-class citizen, with Microsoft teams contributing to the official .NET implementation of gRPC. It",
    "ASP.NET Core 3.0 is the first release of ASP.NET that natively supports gRPC as a first-class citizen, with Microsoft teams contributing to the official .NET implementation of gRPC. It",
    "As discussed in chapter 1, Google wanted to use the introduction of HTTP/2 to replace Stubby, its internal, general purpose RPC infrastructure. gRPC, based on Stubby, now can take advantage of standardization and would extend its applicability to mobile computing, the cloud, and the Internet of Things.",
    "As discussed in chapter 1, Google wanted to use the introduction of HTTP/2 to replace Stubby, its internal, general purpose RPC infrastructure. gRPC, based on Stubby, now can take advantage of standardization and would extend its applicability to mobile computing, the cloud, and the Internet of Things.",
    "To achieve this standardization, the Cloud Native Computing Foundation (CNCF) established a set of principles that would govern gRPC. The following list shows the most relevant ones, which are primarily concerned with maximizing accessibility and usability:",
    "To achieve this standardization, the Cloud Native Computing Foundation (CNCF) established a set of principles that would govern gRPC. The following list shows the most relevant ones, which are primarily concerned with maximizing accessibility and usability:",
    "Free and open -All artifacts should be open source, with licensing that doesn",
    "Free and open -All artifacts should be open source, with licensing that doesn",
    "Coverage and simplicity -gRPC should be available across every popular platform, and simple enough to build on any platform.",
    "Coverage and simplicity -gRPC should be available across every popular platform, and simple enough to build on any platform.",
    "Interoperability and reach -It should be possible to use gRPC on any network, regardless of bandwidth or latency, by using widely available network standards.",
    "Interoperability and reach -It should be possible to use gRPC on any network, regardless of bandwidth or latency, by using widely available network standards.",
    "General purpose and performant -The framework should be usable by as broad a range of use-cases as possible, without compromising performance.",
    "General purpose and performant -The framework should be usable by as broad a range of use-cases as possible, without compromising performance.",
    "Streaming -The protocol should provide streaming semantics for large datasets or asynchronous messaging.",
    "Streaming -The protocol should provide streaming semantics for large datasets or asynchronous messaging.",
    "Metadata exchange -The protocol allows non-business data, such as authentication tokens, to be handled separately from actual business data.",
    "Metadata exchange -The protocol allows non-business data, such as authentication tokens, to be handled separately from actual business data.",
    "Standardized status codes -The variability of error codes should be reduced to make error handling decisions clearer. Where additional, richer error handling is required, a mechanism should be provided for managing behavior within the metadata exchange.",
    "Standardized status codes -The variability of error codes should be reduced to make error handling decisions clearer. Where additional, richer error handling is required, a mechanism should be provided for managing behavior within the metadata exchange.",
    "Windows Communication Foundation (WCF) and gRPC are both implementations of the Remote Procedure Call (RPC) pattern. This pattern aims to make calls to services that run on a different machine, or in a different process, work seamlessly, like method calls in the client application. While the aims of WCF and gRPC are the same, the details of the implementation are quite different.",
    "Windows Communication Foundation (WCF) and gRPC are both implementations of the Remote Procedure Call (RPC) pattern. This pattern aims to make calls to services that run on a different machine, or in a different process, work seamlessly, like method calls in the client application. While the aims of WCF and gRPC are the same, the details of the implementation are quite different.",
    "The following table sets out how the key features of WCF relate to gRPC, and where you can find more detailed explanations.",
    "The following table sets out how the key features of WCF relate to gRPC, and where you can find more detailed explanations.",
    "| Features                                    | WCF                                                                 | gRPC                                                                                                                                                  |",
    "| Features                                    | WCF                                                                 | gRPC                                                                                                                                                  |",
    "| Features             | WCF                                                                                        | gRPC                                                                                          |",
    "| Features             | WCF                                                                                        | gRPC                                                                                          |",
    "With Windows Communication Foundation (WCF), services can expose description metadata by using the Web Service Definition Language (WSDL). WSDL is generated dynamically by using .NET reflection at run time. Developers can use this metadata to generate clients for those services, potentially in other languages if they",
    "With Windows Communication Foundation (WCF), services can expose description metadata by using the Web Service Definition Language (WSDL). WSDL is generated dynamically by using .NET reflection at run time. Developers can use this metadata to generate clients for those services, potentially in other languages if they",
    "gRPC uses the Interface Definition Language (IDL) from Protocol Buffers. The Protocol Buffers IDL is a custom, platform-neutral language with an open specification. Developers author .proto files to describe services, along with their inputs and outputs. These .proto files can then be used to generate language- or platform-specific stubs for clients and servers, allowing multiple different platforms to communicate. By sharing .proto files, teams can generate code to use each others",
    "gRPC uses the Interface Definition Language (IDL) from Protocol Buffers. The Protocol Buffers IDL is a custom, platform-neutral language with an open specification. Developers author .proto files to describe services, along with their inputs and outputs. These .proto files can then be used to generate language- or platform-specific stubs for clients and servers, allowing multiple different platforms to communicate. By sharing .proto files, teams can generate code to use each others",
    "One of the advantages of the Protobuf IDL is that as a custom language, it enables gRPC to be completely language and platform agnostic, not favoring any technology over another.",
    "One of the advantages of the Protobuf IDL is that as a custom language, it enables gRPC to be completely language and platform agnostic, not favoring any technology over another.",
    "The Protobuf IDL is also designed for humans to both read and write, whereas WSDL is intended as a machine-readable/writable format. Changing the WSDL of a WCF service typically requires changing the service, running the service, and regenerating the WSDL file from the server. By contrast, with a .proto file, changes are simple to apply with a text editor, and automatically flow through the generated code. Visual Studio 2022 builds .proto files in the background when they are saved. With other editors, such as VS Code, the changes are applied when the project is built.",
    "The Protobuf IDL is also designed for humans to both read and write, whereas WSDL is intended as a machine-readable/writable format. Changing the WSDL of a WCF service typically requires changing the service, running the service, and regenerating the WSDL file from the server. By contrast, with a .proto file, changes are simple to apply with a text editor, and automatically flow through the generated code. Visual Studio 2022 builds .proto files in the background when they are saved. With other editors, such as VS Code, the changes are applied when the project is built.",
    "When compared with XML, and particularly SOAP, messages encoded by using Protobuf have many advantages. Protobuf messages tend to be smaller than the same data serialized as SOAP XML, and encoding, decoding, and transmitting them over a network can be faster.",
    "When compared with XML, and particularly SOAP, messages encoded by using Protobuf have many advantages. Protobuf messages tend to be smaller than the same data serialized as SOAP XML, and encoding, decoding, and transmitting them over a network can be faster.",
    "The potential disadvantage of Protobuf compared to SOAP is that, because the messages aren",
    "The potential disadvantage of Protobuf compared to SOAP is that, because the messages aren",
    "gRPC does support server reflection for dynamically accessing services without pre-compiled stubs, although it",
    "gRPC does support server reflection for dynamically accessing services without pre-compiled stubs, although it",
    "WCF",
    "WCF",
    "Unlike Windows Communication Foundation (WCF), gRPC uses HTTP/2 as a base for its networking. This protocol offers significant advantages over WCF and SOAP, which operate only on HTTP/1.1. For developers wanting to use gRPC, given that there",
    "Unlike Windows Communication Foundation (WCF), gRPC uses HTTP/2 as a base for its networking. This protocol offers significant advantages over WCF and SOAP, which operate only on HTTP/1.1. For developers wanting to use gRPC, given that there",
    "HTTP/2, released by Internet Engineering Task Force in 2015, was derived from the experimental SPDY protocol, which was already being used by Google. It was specifically designed to be more efficient, faster, and more secure than HTTP/1.1.",
    "HTTP/2, released by Internet Engineering Task Force in 2015, was derived from the experimental SPDY protocol, which was already being used by Google. It was specifically designed to be more efficient, faster, and more secure than HTTP/1.1.",
    "This list shows some of the key features and advantages of HTTP/2:",
    "This list shows some of the key features and advantages of HTTP/2:",
    "Request/response cycles no longer need text commands. This activity simplifies and speeds up the implementation of commands. Specifically, parsing data is faster and uses less memory, network latency is reduced with obvious related improvements to speed, and there",
    "Request/response cycles no longer need text commands. This activity simplifies and speeds up the implementation of commands. Specifically, parsing data is faster and uses less memory, network latency is reduced with obvious related improvements to speed, and there",
    "Streams allow you to create long-lived connections between sender and receiver, over which multiple messages or frames can be sent asynchronously. Multiple streams can operate independently over a single HTTP/2 connection.",
    "Streams allow you to create long-lived connections between sender and receiver, over which multiple messages or frames can be sent asynchronously. Multiple streams can operate independently over a single HTTP/2 connection.",
    "This feature is one of the most important innovations of HTTP/2. Because it allows multiple parallel requests for data, it",
    "This feature is one of the most important innovations of HTTP/2. Because it allows multiple parallel requests for data, it",
    "that are ready must wait to be sent until an earlier request is completed, is also mitigated (although HOL blocking can still occur at the TCP-transport level).",
    "that are ready must wait to be sent until an earlier request is completed, is also mitigated (although HOL blocking can still occur at the TCP-transport level).",
    "Fundamentally, the combination of gRPC and HTTP/2 offers developers at least the equivalent speed and efficiency of Net.TCP bindings for WCF, and in some cases even greater speed and efficiency. But, unlike Net.TCP, gRPC over HTTP/2 isn",
    "Fundamentally, the combination of gRPC and HTTP/2 offers developers at least the equivalent speed and efficiency of Net.TCP bindings for WCF, and in some cases even greater speed and efficiency. But, unlike Net.TCP, gRPC over HTTP/2 isn",
    "Before we dive deeply into the language and techniques of gRPC, it",
    "Before we dive deeply into the language and techniques of gRPC, it",
    "Although the implementation and approach are different for gRPC, the experience of developing and consuming services with gRPC should be intuitive for WCF developers. The underlying goal is the same: make it possible to code as though the client and server are on the same platform, without needing to worry about networking.",
    "Although the implementation and approach are different for gRPC, the experience of developing and consuming services with gRPC should be intuitive for WCF developers. The underlying goal is the same: make it possible to code as though the client and server are on the same platform, without needing to worry about networking.",
    "Both platforms share the principle of declaring and then implementing an interface, even though the process for declaring that interface is different. And as you",
    "Both platforms share the principle of declaring and then implementing an interface, even though the process for declaring that interface is different. And as you",
    "gRPC stands above other solutions for the following reasons.",
    "gRPC stands above other solutions for the following reasons.",
    "Using HTTP/2 rather than HTTP/1.1 removes the requirement for human-readable messages and instead uses the smaller, faster binary protocol. This is more efficient for computers to parse. HTTP/2 also supports multiplexing requests over a single connection. This support enables responses to be sent as soon as they",
    "Using HTTP/2 rather than HTTP/1.1 removes the requirement for human-readable messages and instead uses the smaller, faster binary protocol. This is more efficient for computers to parse. HTTP/2 also supports multiplexing requests over a single connection. This support enables responses to be sent as soon as they",
    "There are gRPC tools and libraries for all major programming languages and platforms, including .NET, Java, Python, Go, C++, Node.js, Swift, Dart, Ruby, and PHP. Thanks to the Protocol Buffers binary wire format and the efficient code generation for each platform, developers can build performant apps while still enjoying full cross-platform support.",
    "There are gRPC tools and libraries for all major programming languages and platforms, including .NET, Java, Python, Go, C++, Node.js, Swift, Dart, Ruby, and PHP. Thanks to the Protocol Buffers binary wire format and the efficient code generation for each platform, developers can build performant apps while still enjoying full cross-platform support.",
    "gRPC is a comprehensive RPC solution. It works consistently across multiple languages and platforms. It also provides excellent tooling, with much of the necessary boilerplate code automatically generated. So more developer time is freed up to focus on business logic.",
    "gRPC is a comprehensive RPC solution. It works consistently across multiple languages and platforms. It also provides excellent tooling, with much of the necessary boilerplate code automatically generated. So more developer time is freed up to focus on business logic.",
    "gRPC has full bidirectional streaming, which provides similar functionality to WCF",
    "gRPC has full bidirectional streaming, which provides similar functionality to WCF",
    "gRPC allows clients to specify a maximum time for an RPC to finish. If the specified deadline is exceeded, the server can cancel the operation independently of the client. Deadlines and cancellations can be propagated through further gRPC calls to help enforce resource usage limits. Clients can also stop operations when a deadline is exceeded, or earlier if necessary (for example, because of a user interaction).",
    "gRPC allows clients to specify a maximum time for an RPC to finish. If the specified deadline is exceeded, the server can cancel the operation independently of the client. Deadlines and cancellations can be propagated through further gRPC calls to help enforce resource usage limits. Clients can also stop operations when a deadline is exceeded, or earlier if necessary (for example, because of a user interaction).",
    "gRPC is implicitly secure when it",
    "gRPC is implicitly secure when it",
    "A notable alternative to gRPC for replacing WCF services when migrating to .NET is CoreWCF. Both gRPC and CoreWCF are Microsoft endorsed paths forward for WCF applications and each comes with its own benefits and drawbacks.",
    "A notable alternative to gRPC for replacing WCF services when migrating to .NET is CoreWCF. Both gRPC and CoreWCF are Microsoft endorsed paths forward for WCF applications and each comes with its own benefits and drawbacks.",
    "CoreWCF is a community-owned .NET Foundation project supported by Microsoft that implements WCF server APIs for .NET. CoreWCF is an effort to allow existing WCF services to work with minimal changes on .NET. Your Data Contracts for WCF are unchanged with CoreWCF, and it supports many of the bindings and APIs from WCF. The main differences are around the patterns for starting WCF services, and not all configuration options are available (some configuration must now be done in code).",
    "CoreWCF is a community-owned .NET Foundation project supported by Microsoft that implements WCF server APIs for .NET. CoreWCF is an effort to allow existing WCF services to work with minimal changes on .NET. Your Data Contracts for WCF are unchanged with CoreWCF, and it supports many of the bindings and APIs from WCF. The main differences are around the patterns for starting WCF services, and not all configuration options are available (some configuration must now be done in code).",
    "Services and interfaces can often migrate with few changes. Because of this, a key benefit of CoreWCF is its very high compatibility with WCF. Where changes have been made, they are to adapt to the programming style of modern .NET, for example hosting now through ASP.NET Core, and APIs now use the Task based async patterns usable with await rather than the older BeginXXX / EndXXX pattern.",
    "Services and interfaces can often migrate with few changes. Because of this, a key benefit of CoreWCF is its very high compatibility with WCF. Where changes have been made, they are to adapt to the programming style of modern .NET, for example hosting now through ASP.NET Core, and APIs now use the Task based async patterns usable with await rather than the older BeginXXX / EndXXX pattern.",
    "On the other hand, gRPC is a modern remote communication solution with a number of features, as discussed previously. Benefits of using gRPC include better interoperability across languages, its relatively simple modern API, and a broad community ecosystem.",
    "On the other hand, gRPC is a modern remote communication solution with a number of features, as discussed previously. Benefits of using gRPC include better interoperability across languages, its relatively simple modern API, and a broad community ecosystem.",
    "When deciding whether to use CoreWCF or gRPC to migrate a WCF application to .NET, CoreWCF is typically a better fit if the goal is to migrate the application with minimal changes whereas gRPC may",
    "When deciding whether to use CoreWCF or gRPC to migrate a WCF application to .NET, CoreWCF is typically a better fit if the goal is to migrate the application with minimal changes whereas gRPC may",
    "be a better fit if the goal is to modernize the application while retargeting to .NET. The remainder of this guide focuses on that modernization with gRPC.",
    "be a better fit if the goal is to modernize the application while retargeting to .NET. The remainder of this guide focuses on that modernization with gRPC.",
    "gRPC services send and receive data as Protocol Buffer (Protobuf) messages , similar to data contracts in Windows Communication Foundation (WCF). Protobuf is an efficient way of serializing structured data for machines to read and write, without the overhead that human-readable formats like XML or JSON incur.",
    "gRPC services send and receive data as Protocol Buffer (Protobuf) messages , similar to data contracts in Windows Communication Foundation (WCF). Protobuf is an efficient way of serializing structured data for machines to read and write, without the overhead that human-readable formats like XML or JSON incur.",
    "This chapter covers how Protobuf works, and how to define your own Protobuf messages.",
    "This chapter covers how Protobuf works, and how to define your own Protobuf messages.",
    "Most .NET object serialization techniques, including WCF",
    "Most .NET object serialization techniques, including WCF",
    "The Protobuf compiler, protoc, is maintained by Google, although alternative implementations are available. The generated code is efficient and optimized for fast serialization and deserialization of data.",
    "The Protobuf compiler, protoc, is maintained by Google, although alternative implementations are available. The generated code is efficient and optimized for fast serialization and deserialization of data.",
    "The Protobuf wire format is a binary encoding. It uses some clever tricks to minimize the number of bytes used to represent messages. Knowledge of the binary encoding format isn",
    "The Protobuf wire format is a binary encoding. It uses some clever tricks to minimize the number of bytes used to represent messages. Knowledge of the binary encoding format isn",
    "This section covers how to declare Protocol Buffer (Protobuf) messages in .proto files. It explains the fundamental concepts of field numbers and types, and it looks at the C# code that the protoc compiler generates.",
    "This section covers how to declare Protocol Buffer (Protobuf) messages in .proto files. It explains the fundamental concepts of field numbers and types, and it looks at the C# code that the protoc compiler generates.",
    "The rest of the chapter will look in more detail at how different types of data are represented in Protobuf.",
    "The rest of the chapter will look in more detail at how different types of data are represented in Protobuf.",
    "In Windows Communication Foundation (WCF), a Stock class for a stock market trading application might be defined like the following example:",
    "In Windows Communication Foundation (WCF), a Stock class for a stock market trading application might be defined like the following example:",
    "To implement the equivalent class in Protobuf, you must declare it in the .proto file. The protoc compiler will then generate the .NET class as part of the build process.",
    "To implement the equivalent class in Protobuf, you must declare it in the .proto file. The protoc compiler will then generate the .NET class as part of the build process.",
    "The first line declares the syntax version being used. Version 3 of the language was released in 2016. It",
    "The first line declares the syntax version being used. Version 3 of the language was released in 2016. It",
    "The option csharp",
    "The option csharp",
    "The Stock message definition specifies four fields. Each has a type, a name, and a field number.",
    "The Stock message definition specifies four fields. Each has a type, a name, and a field number.",
    "Field numbers are an important part of Protobuf. They",
    "Field numbers are an important part of Protobuf. They",
    "In the binary format, the field number is combined with a type identifier. Field numbers from 1 to 15 can be encoded with their type as a single byte. Numbers from 16 to 2,047 take 2 bytes. You can go higher if you need more than 2,047 fields on a message for any reason. The single-byte identifiers for field numbers 1 to 15 offer better performance, so you should use them for the most basic, frequently used fields.",
    "In the binary format, the field number is combined with a type identifier. Field numbers from 1 to 15 can be encoded with their type as a single byte. Numbers from 16 to 2,047 take 2 bytes. You can go higher if you need more than 2,047 fields on a message for any reason. The single-byte identifiers for field numbers 1 to 15 offer better performance, so you should use them for the most basic, frequently used fields.",
    "The type declarations are using Protobuf",
    "The type declarations are using Protobuf",
    "Protobuf doesn",
    "Protobuf doesn",
    "When you build your application, Protobuf creates classes for each of your messages, mapping its native types to C# types. The generated Stock type would have the following signature:",
    "When you build your application, Protobuf creates classes for each of your messages, mapping its native types to C# types. The generated Stock type would have the following signature:",
    "The actual code that",
    "The actual code that",
    "Note that the Protobuf compiler applied PascalCase to the property names, although they were snake",
    "Note that the Protobuf compiler applied PascalCase to the property names, although they were snake",
    "Protocol Buffer (Protobuf) supports a range of native scalar value types. The following table lists them all with their equivalent C# type:",
    "Protocol Buffer (Protobuf) supports a range of native scalar value types. The following table lists them all with their equivalent C# type:",
    "| Protobuf type   | C# type   | Notes   |",
    "| Protobuf type   | C# type   | Notes   |",
    "| Protobuf type   | C# type    | Notes   |",
    "| Protobuf type   | C# type    | Notes   |",
    "The standard encoding for int32 and int64 is inefficient when you",
    "The standard encoding for int32 and int64 is inefficient when you",
    "The fixed fields always use the same number of bytes no matter what the value is. This behavior makes serialization and deserialization faster for larger values.",
    "The fixed fields always use the same number of bytes no matter what the value is. This behavior makes serialization and deserialization faster for larger values.",
    "Protobuf strings are UTF-8 (or 7bit ASCII) encoded. The encoded length can",
    "Protobuf strings are UTF-8 (or 7bit ASCII) encoded. The encoded length can",
    "The Protobuf runtime provides a ByteString type that maps easily to and from C# byte",
    "The Protobuf runtime provides a ByteString type that maps easily to and from C# byte",
    "The native scalar types don",
    "The native scalar types don",
    "The following table shows the date and time types:",
    "The following table shows the date and time types:",
    "| C# type        | Protobuf well-known type   |",
    "| C# type        | Protobuf well-known type   |",
    "The generated properties in the C# class aren",
    "The generated properties in the C# class aren",
    "The Timestamp type works with UTC times. DateTimeOffset values always have an offset of zero, and the DateTime.Kind property is always DateTimeKind.Utc.",
    "The Timestamp type works with UTC times. DateTimeOffset values always have an offset of zero, and the DateTime.Kind property is always DateTimeKind.Utc.",
    "Protobuf doesn",
    "Protobuf doesn",
    "The best approach is to handle Guid values as a string field, by using the standard 8-4-4-4-12 hexadecimal format (for example, 45a9fda3-bd01-47a9-8460-c1cd7484b0b3). All languages and platforms can parse that format.",
    "The best approach is to handle Guid values as a string field, by using the standard 8-4-4-4-12 hexadecimal format (for example, 45a9fda3-bd01-47a9-8460-c1cd7484b0b3). All languages and platforms can parse that format.",
    "Don",
    "Don",
    "The Protobuf code generation for C# uses the native types, such as int for int32. So the values are always included and can",
    "The Protobuf code generation for C# uses the native types, such as int for int32. So the values are always included and can",
    "For values that require explicit null, such as using int? in your C# code, Protobuf",
    "For values that require explicit null, such as using int? in your C# code, Protobuf",
    "Protobuf will use the simple T? (for example, int?) for the generated message property.",
    "Protobuf will use the simple T? (for example, int?) for the generated message property.",
    "The following table shows the complete list of wrapper types with their equivalent C# type:",
    "The following table shows the complete list of wrapper types with their equivalent C# type:",
    "| C# type   | Well Known Type wrapper     |",
    "| C# type   | Well Known Type wrapper     |",
    "The well-known types Timestamp and Duration are represented in .NET as classes. In C# 8 and beyond, you can use nullable reference types. But it",
    "The well-known types Timestamp and Duration are represented in .NET as classes. In C# 8 and beyond, you can use nullable reference types. But it",
    "Protobuf doesn",
    "Protobuf doesn",
    "It",
    "It",
    "A simple implementation might be similar to the nonstandard Money type that some Google APIs use, without the currency field.",
    "A simple implementation might be similar to the nonstandard Money type that some Google APIs use, without the currency field.",
    "The nanos field represents values from 0.999",
    "The nanos field represents values from 0.999",
    "There are multiple other algorithms for encoding decimal values as byte strings, but this message is easier to understand than any of them. The values are not affected by endianness on different platforms.",
    "There are multiple other algorithms for encoding decimal values as byte strings, but this message is easier to understand than any of them. The values are not affected by endianness on different platforms.",
    "Conversion between this type and the BCL decimal type might be implemented in C# like this:",
    "Conversion between this type and the BCL decimal type might be implemented in C# like this:",
    "Whenever you use custom message types like this, you must document them with comments in .proto. Other developers can then implement conversion to and from the equivalent type in their own language or framework.",
    "Whenever you use custom message types like this, you must document them with comments in .proto. Other developers can then implement conversion to and from the equivalent type in their own language or framework.",
    "Just as C# allows you to declare classes inside other classes, Protocol Buffer (Protobuf) allows you to nest message definitions within other messages. The following example shows how to create nested message types:",
    "Just as C# allows you to declare classes inside other classes, Protocol Buffer (Protobuf) allows you to nest message definitions within other messages. The following example shows how to create nested message types:",
    "In the generated C# code, the Inner type will be declared in a nested static Types class within the HelloRequest class:",
    "In the generated C# code, the Inner type will be declared in a nested static Types class within the HelloRequest class:",
    "You specify lists in Protocol Buffer (Protobuf) by using the repeated prefix keyword. The following example shows how to create a list:",
    "You specify lists in Protocol Buffer (Protobuf) by using the repeated prefix keyword. The following example shows how to create a list:",
    "In the generated code, repeated fields are represented by read-only properties of the Google.Protobuf.Collections.RepeatedField",
    "In the generated code, repeated fields are represented by read-only properties of the Google.Protobuf.Collections.RepeatedField",
    "The RepeatedField",
    "The RepeatedField",
    "The backward-compatibility guarantees in Protocol Buffer (Protobuf) rely on field numbers always representing the same data item. If a field is removed from a message in a new version of the service, that field number should never be reused. You can enforce this behavior by using the reserved keyword.",
    "The backward-compatibility guarantees in Protocol Buffer (Protobuf) rely on field numbers always representing the same data item. If a field is removed from a message in a new version of the service, that field number should never be reused. You can enforce this behavior by using the reserved keyword.",
    "If the displayName and marketId fields were removed from the Stock message defined earlier, their field numbers should be reserved as in the following example.",
    "If the displayName and marketId fields were removed from the Stock message defined earlier, their field numbers should be reserved as in the following example.",
    "You can also use the reserved keyword as a placeholder for fields that might be added in the future. You can express contiguous field numbers as a range by using the to keyword.",
    "You can also use the reserved keyword as a placeholder for fields that might be added in the future. You can express contiguous field numbers as a range by using the to keyword.",
    "Handling dynamic property types (that is, properties of type object) in Windows Communication Foundation (WCF) is complicated. For example, you must specify serializers and provide KnownType attributes.",
    "Handling dynamic property types (that is, properties of type object) in Windows Communication Foundation (WCF) is complicated. For example, you must specify serializers and provide KnownType attributes.",
    "Protocol Buffer (Protobuf) provides two simpler options for dealing with values that might be of more than one type. The Any type can represent any known Protobuf message type. And you can use the oneof keyword to specify that only one of a range of fields can be set in any message.",
    "Protocol Buffer (Protobuf) provides two simpler options for dealing with values that might be of more than one type. The Any type can represent any known Protobuf message type. And you can use the oneof keyword to specify that only one of a range of fields can be set in any message.",
    "Any is one of Protobuf",
    "Any is one of Protobuf",
    "In the C# code, the Any class provides methods for setting the field, extracting the message, and checking the type.",
    "In the C# code, the Any class provides methods for setting the field, extracting the message, and checking the type.",
    "Protobuf",
    "Protobuf",
    "Oneof fields are a language feature: the compiler handles the oneof keyword when it generates the message class. Using oneof to specify the ChangeNotification message might look like this:",
    "Oneof fields are a language feature: the compiler handles the oneof keyword when it generates the message class. Using oneof to specify the ChangeNotification message might look like this:",
    "Fields within the oneof set must have unique field numbers in the overall message declaration.",
    "Fields within the oneof set must have unique field numbers in the overall message declaration.",
    "When you use oneof, the generated C# code includes an enum that specifies which of the fields has been set. You can test the enum to find which field is set. Fields that aren",
    "When you use oneof, the generated C# code includes an enum that specifies which of the fields has been set. You can test the enum to find which field is set. Fields that aren",
    "Setting any field that",
    "Setting any field that",
    "Protobuf supports enumeration types. You saw this support in the previous section, where an enum was used to determine the type of a Oneof field. You can define your own enumeration types, and Protobuf will compile them to C# enum types.",
    "Protobuf supports enumeration types. You saw this support in the previous section, where an enum was used to determine the type of a Oneof field. You can define your own enumeration types, and Protobuf will compile them to C# enum types.",
    "Because you can use Protobuf with various languages, the naming conventions for enumerations are different from the C# conventions. However, the code generator converts the names to the traditional C# case. If the Pascal-case equivalent of the field name s tarts with the enumeration name, then it",
    "Because you can use Protobuf with various languages, the naming conventions for enumerations are different from the C# conventions. However, the code generator converts the names to the traditional C# case. If the Pascal-case equivalent of the field name s tarts with the enumeration name, then it",
    "For example, in the following Protobuf enumeration, the fields are prefixed with ACCOUNT",
    "For example, in the following Protobuf enumeration, the fields are prefixed with ACCOUNT",
    "The generator creates a C# enum equivalent to the following code:",
    "The generator creates a C# enum equivalent to the following code:",
    "Protobuf enumeration definitions must have a zero constant as their first field. As in C#, you can declare multiple fields with the same value. But you must explicitly enable this option by using the allow",
    "Protobuf enumeration definitions must have a zero constant as their first field. As in C#, you can declare multiple fields with the same value. But you must explicitly enable this option by using the allow",
    "You can declare enumerations at the top level in a .proto file, or nested within a message definition. Nested enumerations -like nested messages -will be declared within the .Types static class in the generated message class.",
    "You can declare enumerations at the top level in a .proto file, or nested within a message definition. Nested enumerations -like nested messages -will be declared within the .Types static class in the generated message class.",
    "There",
    "There",
    "If you set product.AvailableIn to Region.NorthAmerica | Region.SouthAmerica, it",
    "If you set product.AvailableIn to Region.NorthAmerica | Region.SouthAmerica, it",
    "The best way to work with multiple enum values in Protobuf is to use a repeated field of the enum type.",
    "The best way to work with multiple enum values in Protobuf is to use a repeated field of the enum type.",
    "It",
    "It",
    "In the generated code, map fields are represented by read-only properties of the Google.Protobuf.Collections.MapField",
    "In the generated code, map fields are represented by read-only properties of the Google.Protobuf.Collections.MapField",
    "Map fields can",
    "Map fields can",
    "The MapField properties generated from map fields are read-only, and will never be null. To set a map property, use the Add(IDictionary",
    "The MapField properties generated from map fields are read-only, and will never be null. To set a map property, use the Add(IDictionary",
    "| return order;   |",
    "| return order;   |",
    "For more information about Protobuf, see the official Protobuf documentation.",
    "For more information about Protobuf, see the official Protobuf documentation.",
    "The previous chapter gave you a good look at Protobuf and how gRPC handles messages. Before you work through a detailed conversion from Windows Communication Foundation (WCF) to gRPC, it",
    "The previous chapter gave you a good look at Protobuf and how gRPC handles messages. Before you work through a detailed conversion from Windows Communication Foundation (WCF) to gRPC, it",
    "Operations and methods",
    "Operations and methods",
    "Bindings and transports",
    "Bindings and transports",
    "RPC types",
    "RPC types",
    "Metadata",
    "Metadata",
    "Error handling",
    "Error handling",
    "WS-",
    "WS-",
    "When you create a new ASP.NET Core 7.0 gRPC project from Visual Studio 2022 or the command line, the gRPC equivalent of ",
    "When you create a new ASP.NET Core 7.0 gRPC project from Visual Studio 2022 or the command line, the gRPC equivalent of ",
    "This chapter will refer to this example code when explaining different concepts and features of gRPC.",
    "This chapter will refer to this example code when explaining different concepts and features of gRPC.",
    "In Windows Communication Foundation (WCF), when you",
    "In Windows Communication Foundation (WCF), when you",
    "You write the application code in a class and decorate methods with the OperationContract attribute.",
    "You write the application code in a class and decorate methods with the OperationContract attribute.",
    "You declare an interface for the service and add OperationContract attributes to the interface.",
    "You declare an interface for the service and add OperationContract attributes to the interface.",
    "For example, the WCF equivalent of the greet.proto Greeter service might be written as follows:",
    "For example, the WCF equivalent of the greet.proto Greeter service might be written as follows:",
    "Chapter 3 showed that Protobuf message definitions are used to generate data classes. Service and method declarations are used to generate base classes that you inherit from to implement the service. You just declare the methods to be implemented in the .proto file, and the compiler generates a base class with virtual methods that you must override.",
    "Chapter 3 showed that Protobuf message definitions are used to generate data classes. Service and method declarations are used to generate base classes that you inherit from to implement the service. You just declare the methods to be implemented in the .proto file, and the compiler generates a base class with virtual methods that you must override.",
    "The OperationContract attribute has properties to control or refine how it works. gRPC methods don",
    "The OperationContract attribute has properties to control or refine how it works. gRPC methods don",
    "| OperationContract property   | gRPC                                                                                                   |",
    "| OperationContract property   | gRPC                                                                                                   |",
    "The IsInitiating property lets you indicate that a method within ServiceContract can",
    "The IsInitiating property lets you indicate that a method within ServiceContract can",
    "For more information on gRPC security and encryption, see chapter 6.",
    "For more information on gRPC security and encryption, see chapter 6.",
    "Windows Communication Foundation (WCF) has built-in bindings that specify different network protocols, wire formats, and other implementation details. gRPC effectively has just one network protocol and one wire format. (Technically you can customize the wire format, but that",
    "Windows Communication Foundation (WCF) has built-in bindings that specify different network protocols, wire formats, and other implementation details. gRPC effectively has just one network protocol and one wire format. (Technically you can customize the wire format, but that",
    "What follows is a short discussion about the most relevant WCF bindings and how they compare to their equivalents in gRPC.",
    "What follows is a short discussion about the most relevant WCF bindings and how they compare to their equivalents in gRPC.",
    "WCF",
    "WCF",
    "gRPC has many features of WCF",
    "gRPC has many features of WCF",
    "The WCF binding called BasicHttpBinding is usually textbased and uses SOAP as the wire format. It",
    "The WCF binding called BasicHttpBinding is usually textbased and uses SOAP as the wire format. It",
    "The equivalent in gRPC uses HTTP/2 as the underlying transport layer with the binary Protobuf wire format for messages. So it can offer performance at the NetTCP service level and full cross-platform interoperability with all modern programming languages and frameworks.",
    "The equivalent in gRPC uses HTTP/2 as the underlying transport layer with the binary Protobuf wire format for messages. So it can offer performance at the NetTCP service level and full cross-platform interoperability with all modern programming languages and frameworks.",
    "WCF provided a named pipes binding for communication between processes on the same physical machine. ASP.NET Core gRPC doesn",
    "WCF provided a named pipes binding for communication between processes on the same physical machine. ASP.NET Core gRPC doesn",
    "For more information, see Inter-process communication with gRPC.",
    "For more information, see Inter-process communication with gRPC.",
    "MSMQ is a proprietary Windows message queue. WCF",
    "MSMQ is a proprietary Windows message queue. WCF",
    "The best alternative is to directly use a messaging system like Azure Service Bus, RabbitMQ, or Kafka. You can implement this functionality with the client placing messages directly onto the queue, or a gRPC client streaming service that enqueues the messages.",
    "The best alternative is to directly use a messaging system like Azure Service Bus, RabbitMQ, or Kafka. You can implement this functionality with the client placing messages directly onto the queue, or a gRPC client streaming service that enqueues the messages.",
    "WebHttpBinding (also known as WCF REST), with the WebGet and WebInvoke attributes, enabled you to develop RESTful APIs that could speak JSON at a time when this behavior was less common. If you have a RESTful API built with WCF REST, consider migrating it to a regular ASP.NET Core MVC Web API application. This migration would provide the same functionality as a conversion to gRPC.",
    "WebHttpBinding (also known as WCF REST), with the WebGet and WebInvoke attributes, enabled you to develop RESTful APIs that could speak JSON at a time when this behavior was less common. If you have a RESTful API built with WCF REST, consider migrating it to a regular ASP.NET Core MVC Web API application. This migration would provide the same functionality as a conversion to gRPC.",
    "As a Windows Communication Foundation (WCF) developer, you",
    "As a Windows Communication Foundation (WCF) developer, you",
    "Request/reply",
    "Request/reply",
    "Duplex:",
    "Duplex:",
    "-One-way duplex with session",
    "-One-way duplex with session",
    "-Full duplex with session",
    "-Full duplex with session",
    "One-way",
    "One-way",
    "It",
    "It",
    "| WCF                                                           | gRPC                    |",
    "| WCF                                                           | gRPC                    |",
    "For simple request/reply methods that take and return small amounts of data, use the simplest gRPC pattern, the unary RPC.",
    "For simple request/reply methods that take and return small amounts of data, use the simplest gRPC pattern, the unary RPC.",
    "As you can see, implementing a gRPC unary RPC service method is similar to implementing a WCF operation. The difference is that with gRPC, you override a base class method instead of implementing an interface. On the server, gRPC base methods always return Task, although the client provides both async and blocking methods to call the service.",
    "As you can see, implementing a gRPC unary RPC service method is similar to implementing a WCF operation. The difference is that with gRPC, you override a base class method instead of implementing an interface. On the server, gRPC base methods always return Task, although the client provides both async and blocking methods to call the service.",
    "WCF applications (with certain bindings) can create a persistent connection between client and server. The server can asynchronously send data to the client until the connection is closed, by using a callback interface specified in the ServiceContractAttribute.CallbackContract property.",
    "WCF applications (with certain bindings) can create a persistent connection between client and server. The server can asynchronously send data to the client until the connection is closed, by using a callback interface specified in the ServiceContractAttribute.CallbackContract property.",
    "gRPC services provide similar functionality with message streams. Streams don",
    "gRPC services provide similar functionality with message streams. Streams don",
    "gRPC supports the creation of persistent streams from client to server, and from server to client. Both types of stream can be active concurrently. This ability is called bidirectional streaming.",
    "gRPC supports the creation of persistent streams from client to server, and from server to client. Both types of stream can be active concurrently. This ability is called bidirectional streaming.",
    "You can use streams for arbitrary, asynchronous messaging over time. Or you can use them for passing large datasets that are too big to generate and send in a single request or response.",
    "You can use streams for arbitrary, asynchronous messaging over time. Or you can use them for passing large datasets that are too big to generate and send in a single request or response.",
    "The following example shows a server-streaming RPC.",
    "The following example shows a server-streaming RPC.",
    "This server stream can be consumed from a client application, as shown in the following code:",
    "This server stream can be consumed from a client application, as shown in the following code:",
    "Server-streaming RPCs are useful for subscriptionstyle services. They",
    "Server-streaming RPCs are useful for subscriptionstyle services. They",
    "A WCF duplex service uses a client callback interface that can have multiple methods. A gRPC serverstreaming service can only send messages over a single stream. If you need multiple methods, use a message type with either an Any field or a oneof field to send different messages, and write code in the client to handle them.",
    "A WCF duplex service uses a client callback interface that can have multiple methods. A gRPC serverstreaming service can only send messages over a single stream. If you need multiple methods, use a message type with either an Any field or a oneof field to send different messages, and write code in the client to handle them.",
    "In WCF, the ServiceContract class with the session is kept alive until the connection is closed. Multiple methods can be called within the session. In gRPC, the Task that the implementation method returns shouldn",
    "In WCF, the ServiceContract class with the session is kept alive until the connection is closed. Multiple methods can be called within the session. In gRPC, the Task that the implementation method returns shouldn",
    "WCF provides one-way operations (marked with ",
    "WCF provides one-way operations (marked with ",
    "You can use client-streaming RPCs for fire-and-forget messaging, as shown in the previous example. You can also use them for sending very large datasets to the server. The same warning about performance applies: for smaller datasets, use repeated fields in regular messages.",
    "You can use client-streaming RPCs for fire-and-forget messaging, as shown in the previous example. You can also use them for sending very large datasets to the server. The same warning about performance applies: for smaller datasets, use repeated fields in regular messages.",
    "WCF duplex binding supports multiple one-way operations on both the service interface and the client callback interface. This support allows ongoing conversations between client and server. gRPC supports something similar with bidirectional streaming RPCs, where both parameters are marked with the stream modifier.",
    "WCF duplex binding supports multiple one-way operations on both the service interface and the client callback interface. This support allows ongoing conversations between client and server. gRPC supports something similar with bidirectional streaming RPCs, where both parameters are marked with the stream modifier.",
    "In the previous example, you can see that the implementation method receives both a request stream (IAsyncStreamReader",
    "In the previous example, you can see that the implementation method receives both a request stream (IAsyncStreamReader",
    "(IServerStreamWriter",
    "(IServerStreamWriter",
    "Metadata refers to additional data that might be useful during the processing of requests and responses but that",
    "Metadata refers to additional data that might be useful during the processing of requests and responses but that",
    "It",
    "It",
    "gRPC calls and responses can also include metadata that",
    "gRPC calls and responses can also include metadata that",
    "Metadata is handled by the Metadata class of the Grpc.Core.Api NuGet package. This class can be used with collection initializer syntax.",
    "Metadata is handled by the Metadata class of the Grpc.Core.Api NuGet package. This class can be used with collection initializer syntax.",
    "This example shows how to add metadata to a call from a C# client:",
    "This example shows how to add metadata to a call from a C# client:",
    "gRPC services can access metadata from the ServerCallContext argument",
    "gRPC services can access metadata from the ServerCallContext argument",
    "Services can send metadata to clients by using the ResponseTrailers property of ServerCallContext:",
    "Services can send metadata to clients by using the ResponseTrailers property of ServerCallContext:",
    "Windows Communication Foundation (WCF) uses FaultException and FaultContract to provide detailed error information, including supporting the SOAP Fault standard.",
    "Windows Communication Foundation (WCF) uses FaultException and FaultContract to provide detailed error information, including supporting the SOAP Fault standard.",
    "Unfortunately, the current version of gRPC lacks the sophistication found with WCF, and only has limited built-in error handling based on simple status codes and metadata. The following table is a quick guide to the most commonly used status codes:",
    "Unfortunately, the current version of gRPC lacks the sophistication found with WCF, and only has limited built-in error handling based on simple status codes and metadata. The following table is a quick guide to the most commonly used status codes:",
    "| Status code                   | Problem                                   |",
    "| Status code                   | Problem                                   |",
    "An ASP.NET Core gRPC service can send an error response by throwing an RpcException, which can be caught by the client as if it were in the same process. The RpcException must include a status code and description, and can optionally include metadata and a longer exception message. The metadata can be used to send supporting data, similar to how FaultContract objects can carry additional data for WCF errors.",
    "An ASP.NET Core gRPC service can send an error response by throwing an RpcException, which can be caught by the client as if it were in the same process. The RpcException must include a status code and description, and can optionally include metadata and a longer exception message. The metadata can be used to send supporting data, similar to how FaultContract objects can carry additional data for WCF errors.",
    "Just like WCF clients can catch FaultException errors, a gRPC client can catch an RpcException to handle errors. Because RpcException isn",
    "Just like WCF clients can catch FaultException errors, a gRPC client can catch an RpcException to handle errors. Because RpcException isn",
    "When you provide additional metadata for errors, be sure to document the relevant keys and values in your API documentation, or in comments in your .proto file.",
    "When you provide additional metadata for errors, be sure to document the relevant keys and values in your API documentation, or in comments in your .proto file.",
    "Google has developed a richer error model that",
    "Google has developed a richer error model that",
    "One of the real benefits of working with Windows Communication Foundation (WCF) was that it supported many of the existing WS-",
    "One of the real benefits of working with Windows Communication Foundation (WCF) was that it supported many of the existing WS-",
    "SOAP services expose Web Services Description Language (WSDL) schema documents with information such as data formats, operations, or communication options. You can use this schema to generate the client code.",
    "SOAP services expose Web Services Description Language (WSDL) schema documents with information such as data formats, operations, or communication options. You can use this schema to generate the client code.",
    "gRPC works best when servers and clients are generated from the same .proto files, but a Server Reflection optional extension does provide a way to expose dynamic information from a running server. For more information, see the Grpc.Reflection NuGet package.",
    "gRPC works best when servers and clients are generated from the same .proto files, but a Server Reflection optional extension does provide a way to expose dynamic information from a running server. For more information, see the Grpc.Reflection NuGet package.",
    "The WS-Discovery protocol is used to locate services on a local network. gRPC services are located through DNS or a service registry such as Consul or ZooKeeper.",
    "The WS-Discovery protocol is used to locate services on a local network. gRPC services are located through DNS or a service registry such as Consul or ZooKeeper.",
    "Security, authentication, and authorization are covered in much more detail in chapter 6 . But it",
    "Security, authentication, and authorization are covered in much more detail in chapter 6 . But it",
    "gRPC does not provide an equivalent to WS-ReliableMessaging. Retry semantics should be handled in code, possibly with a library like Polly . When you",
    "gRPC does not provide an equivalent to WS-ReliableMessaging. Retry semantics should be handled in code, possibly with a library like Polly . When you",
    "WCF",
    "WCF",
    "This chapter will describe how to work with ASP.NET Core 7.0 gRPC projects and demonstrate migrating different types of Windows Communication Foundation (WCF) services to the gRPC equivalent:",
    "This chapter will describe how to work with ASP.NET Core 7.0 gRPC projects and demonstrate migrating different types of Windows Communication Foundation (WCF) services to the gRPC equivalent:",
    "Create an ASP.NET Core 7.0 gRPC project.",
    "Create an ASP.NET Core 7.0 gRPC project.",
    "Simple request-reply operations to gRPC unary RPC.",
    "Simple request-reply operations to gRPC unary RPC.",
    "One-way operations to gRPC client streaming RPC.",
    "One-way operations to gRPC client streaming RPC.",
    "Full-duplex services to gRPC bidirectional streaming RPC.",
    "Full-duplex services to gRPC bidirectional streaming RPC.",
    "There",
    "There",
    "The sample WCF application is a minimal stub of a set of stock trading services. It uses the opensource Inversion of Control (IoC) container library called Autofac for dependency injection. It includes three services, one for each WCF service type. The services will be discussed in more detail in the following sections. You can download the solutions from dotnet-architecture/grpc-for-wcf-developers on GitHub. The services use fake data to minimize external dependencies.",
    "The sample WCF application is a minimal stub of a set of stock trading services. It uses the opensource Inversion of Control (IoC) container library called Autofac for dependency injection. It includes three services, one for each WCF service type. The services will be discussed in more detail in the following sections. You can download the solutions from dotnet-architecture/grpc-for-wcf-developers on GitHub. The services use fake data to minimize external dependencies.",
    "The samples include the WCF and gRPC implementations of each service.",
    "The samples include the WCF and gRPC implementations of each service.",
    "The .NET SDK comes with a powerful CLI tool, dotnet, which enables you to create and manage projects and solutions from the command line. The SDK is closely integrated with Visual Studio, so everything is also available through the familiar graphical user interface. This chapter shows both ways to create a new ASP.NET Core gRPC project.",
    "The .NET SDK comes with a powerful CLI tool, dotnet, which enables you to create and manage projects and solutions from the command line. The SDK is closely integrated with Visual Studio, so everything is also available through the familiar graphical user interface. This chapter shows both ways to create a new ASP.NET Core gRPC project.",
    "To develop any ASP.NET Core 7.0 app, you need Visual Studio 2022, with the ASP.NET and web development workload installed.",
    "To develop any ASP.NET Core 7.0 app, you need Visual Studio 2022, with the ASP.NET and web development workload installed.",
    "Add a new project",
    "Add a new project",
    "Recent project templates displayed here.",
    "Recent project templates displayed here.",
    "grpd",
    "grpd",
    "All languages",
    "All languages",
    "All platforms",
    "All platforms",
    "All project types",
    "All project types",
    "Create an empty solution called TraderSys from the Blank Solution template. Add a solution folder called src. Then, right-click on the folder and choose Add ",
    "Create an empty solution called TraderSys from the Blank Solution template. Add a solution folder called src. Then, right-click on the folder and choose Add ",
    "Select Next to continue to the Configure your new project dialog box. Name the project TraderSys.Portfolios and add an src subdirectory to the Location .",
    "Select Next to continue to the Configure your new project dialog box. Name the project TraderSys.Portfolios and add an src subdirectory to the Location .",
    "Clear all",
    "Clear all",
    "Configure your new project",
    "Configure your new project",
    "ASP.NET Core gRPC Service",
    "ASP.NET Core gRPC Service",
    "Project name",
    "Project name",
    "TraderSys.Portfolios",
    "TraderSys.Portfolios",
    "Location",
    "Location",
    "C:",
    "C:",
    "\u2022C#",
    "\u2022C#",
    "Linux macOS",
    "Linux macOS",
    "Windows",
    "Windows",
    "Cloud",
    "Cloud",
    "Service",
    "Service",
    "Web",
    "Web",
    "Select Next to continue to the Create a new gRPC service dialog box.",
    "Select Next to continue to the Create a new gRPC service dialog box.",
    "Additional information",
    "Additional information",
    "ASP.NET Core gRPC Service C",
    "ASP.NET Core gRPC Service C",
    "Framework i",
    "Framework i",
    ".NET 7.0 (Standard Term Support)",
    ".NET 7.0 (Standard Term Support)",
    "Enable Docker O",
    "Enable Docker O",
    "Docker OS O",
    "Docker OS O",
    "Linux",
    "Linux",
    "Do not use top-level statements O",
    "Do not use top-level statements O",
    "Windows",
    "Windows",
    "Service",
    "Service",
    "At present, you have limited options for the service creation. Docker will be introduced later, so for now, leave that option unselected. Just select Create . Your first ASP.NET Core 7.0 gRPC project is generated and added to the solution. If you don",
    "At present, you have limited options for the service creation. Docker will be introduced later, so for now, leave that option unselected. Just select Create . Your first ASP.NET Core 7.0 gRPC project is generated and added to the solution. If you don",
    "This section covers the creation of solutions and projects from the command line.",
    "This section covers the creation of solutions and projects from the command line.",
    "Create the solution as shown in the following command. The -o (or --output) flag specifies the output directory, which is created in the current directory if it doesn",
    "Create the solution as shown in the following command. The -o (or --output) flag specifies the output directory, which is created in the current directory if it doesn",
    "ASP.NET Core 7.0 comes with a CLI template for gRPC services. Create the new project by using this template, putting it into an src subdirectory as is conventional for ASP.NET Core projects. The project is named after the directory (TraderSys.Portfolios.csproj), unless you specify a different name with the -n flag.",
    "ASP.NET Core 7.0 comes with a CLI template for gRPC services. Create the new project by using this template, putting it into an src subdirectory as is conventional for ASP.NET Core projects. The project is named after the directory (TraderSys.Portfolios.csproj), unless you specify a different name with the -n flag.",
    "Finally, add the project to the solution by using the dotnet sln command:",
    "Finally, add the project to the solution by using the dotnet sln command:",
    "dotnet sln add src/TraderSys.Portfolios",
    "dotnet sln add src/TraderSys.Portfolios",
    "X",
    "X",
    "Because the particular directory only contains a single .csproj file, you can specify just the directory, to save typing.",
    "Because the particular directory only contains a single .csproj file, you can specify just the directory, to save typing.",
    "You can now open this solution in Visual Studio 2022, Visual Studio Code, or whatever editor you prefer.",
    "You can now open this solution in Visual Studio 2022, Visual Studio Code, or whatever editor you prefer.",
    "You",
    "You",
    "Go ahead and rename the Protos/greet.proto file to Protos/portfolios.proto, and open it in your editor. Delete everything after the package line. Then change the option csharp",
    "Go ahead and rename the Protos/greet.proto file to Protos/portfolios.proto, and open it in your editor. Delete everything after the package line. Then change the option csharp",
    "The template doesn",
    "The template doesn",
    "If you rename the greet.proto file in an integrated development environment (IDE) like Visual Studio, a reference to this file is automatically updated in the .csproj file. But in some other editor, such as Visual Studio Code, this reference isn",
    "If you rename the greet.proto file in an integrated development environment (IDE) like Visual Studio, a reference to this file is automatically updated in the .csproj file. But in some other editor, such as Visual Studio Code, this reference isn",
    "In the gRPC build targets, there",
    "In the gRPC build targets, there",
    "The GreeterService class is in the Services folder and inherits from Greeter.GreeterBase. Rename it to PortfolioService, and change the base class to Portfolios.PortfoliosBase. Delete the override methods.",
    "The GreeterService class is in the Services folder and inherits from Greeter.GreeterBase. Rename it to PortfolioService, and change the base class to Portfolios.PortfoliosBase. Delete the override methods.",
    "There was a reference to the GreeterService class in the Program.cs . If you used refactoring to rename the class, this reference should have been updated automatically. However, if you didn",
    "There was a reference to the GreeterService class in the Program.cs . If you used refactoring to rename the class, this reference should have been updated automatically. However, if you didn",
    "In the next section, we",
    "In the next section, we",
    "This section covers how to migrate a basic request-reply service in WCF to a unary RPC service in ASP.NET Core gRPC. These services are the simplest service types in both Windows Communication Foundation (WCF) and gRPC, so it",
    "This section covers how to migrate a basic request-reply service in WCF to a unary RPC service in ASP.NET Core gRPC. These services are the simplest service types in both Windows Communication Foundation (WCF) and gRPC, so it",
    "The PortfoliosSample solution includes a simple request-reply Portfolio service to download either a single portfolio or all portfolios for a given trader. The service is defined in the interface IPortfolioService with a ServiceContract attribute:",
    "The PortfoliosSample solution includes a simple request-reply Portfolio service to download either a single portfolio or all portfolios for a given trader. The service is defined in the interface IPortfolioService with a ServiceContract attribute:",
    "The Portfolio model is a simple C# class marked with DataContract and including a list of PortfolioItem objects. These models are defined in the TraderSys.PortfolioData project along with a repository class that represents a data access abstraction.",
    "The Portfolio model is a simple C# class marked with DataContract and including a list of PortfolioItem objects. These models are defined in the TraderSys.PortfolioData project along with a repository class that represents a data access abstraction.",
    "The ServiceContract implementation uses a repository class provided via dependency injection that returns instances of the DataContract types:",
    "The ServiceContract implementation uses a repository class provided via dependency injection that returns instances of the DataContract types:",
    "If you followed the instructions in the previous section, you should have a gRPC project with a portfolios.proto file that looks like this:",
    "If you followed the instructions in the previous section, you should have a gRPC project with a portfolios.proto file that looks like this:",
    "The first step is to migrate the DataContract classes to their Protobuf equivalents.",
    "The first step is to migrate the DataContract classes to their Protobuf equivalents.",
    "The PortfolioItem class will be converted to a Protobuf message first, because the Portfolio class depends on it. The class is simple, and three of the properties map directly to gRPC data types. The Cost property, which represents the price paid for the shares at purchase, is a decimal field. gRPC supports only float or double for real numbers, which aren",
    "The PortfolioItem class will be converted to a Protobuf message first, because the Portfolio class depends on it. The class is simple, and three of the properties map directly to gRPC data types. The Cost property, which represents the price paid for the shares at purchase, is a decimal field. gRPC supports only float or double for real numbers, which aren",
    "Remember to use snake",
    "Remember to use snake",
    "The Portfolio class is a little more complicated. In the WCF code, the developer used a Guid for the TraderId property, and contains a List",
    "The Portfolio class is a little more complicated. In the WCF code, the developer used a Guid for the TraderId property, and contains a List",
    "Now that you have the data messages, you can declare the service RPC endpoints.",
    "Now that you have the data messages, you can declare the service RPC endpoints.",
    "The WCF Get method takes two parameters: Guid traderId and int portfolioId. gRPC service methods can take only a single parameter, so you need to create a message to hold the two values. It",
    "The WCF Get method takes two parameters: Guid traderId and int portfolioId. gRPC service methods can take only a single parameter, so you need to create a message to hold the two values. It",
    "The service could just return a Portfolio message directly, but again, this could affect backward compatibility in the future. It",
    "The service could just return a Portfolio message directly, but again, this could affect backward compatibility in the future. It",
    "This example shows the declaration of the gRPC service method with the GetRequest message:",
    "This example shows the declaration of the gRPC service method with the GetRequest message:",
    "The WCF GetAll method takes only a single parameter, traderId, so it might seem that you could specify string as the parameter type. But gRPC requires a defined message type. This requirement helps to enforce the practice of using custom messages for all inputs and outputs, for future backward compatibility.",
    "The WCF GetAll method takes only a single parameter, traderId, so it might seem that you could specify string as the parameter type. But gRPC requires a defined message type. This requirement helps to enforce the practice of using custom messages for all inputs and outputs, for future backward compatibility.",
    "The WCF method also returns a List",
    "The WCF method also returns a List",
    "You might be tempted to create a PortfolioList message or something similar and use it across multiple service methods, but you should resist this temptation. It",
    "You might be tempted to create a PortfolioList message or something similar and use it across multiple service methods, but you should resist this temptation. It",
    "If you save your project with these changes, the gRPC build target will run in the background and generate all the Protobuf message types and a base class that you can inherit to implement the service.",
    "If you save your project with these changes, the gRPC build target will run in the background and generate all the Protobuf message types and a base class that you can inherit to implement the service.",
    "Open the Services/GreeterService.cs class and delete the example code. Now you can add the Portfolio service implementation. The generated base class will be in the Protos namespace and is generated as a nested class. gRPC creates a static class with the same name as the service in the .proto file and a base class with the suffix Base inside that static class, so the full identifier for the base type is TraderSys.Portfolios.Protos.Portfolios.PortfoliosBase.",
    "Open the Services/GreeterService.cs class and delete the example code. Now you can add the Portfolio service implementation. The generated base class will be in the Protos namespace and is generated as a nested class. gRPC creates a static class with the same name as the service in the .proto file and a base class with the suffix Base inside that static class, so the full identifier for the base type is TraderSys.Portfolios.Protos.Portfolios.PortfoliosBase.",
    "The base class declares virtual methods for Get and GetAll that can be overridden to implement the service. The methods are virtual rather than abstract so that if you don",
    "The base class declares virtual methods for Get and GetAll that can be overridden to implement the service. The methods are virtual rather than abstract so that if you don",
    "The signature for all gRPC unary service methods in ASP.NET Core is consistent. There are two parameters: the first is the message type declared in the .proto file, and the second is a ServerCallContext that works similarly to the HttpContext from ASP.NET Core. In fact, there",
    "The signature for all gRPC unary service methods in ASP.NET Core is consistent. There are two parameters: the first is the message type declared in the .proto file, and the second is a ServerCallContext that works similarly to the HttpContext from ASP.NET Core. In fact, there",
    "The method",
    "The method",
    "At this point, the project needs the Portfolio repository and models contained in the TraderSys.PortfolioData class library in the WCF solution. The easiest way to bring them across is to create a new class library by using either the Visual Studio New project dialog box with the Class Library (.NET Standard) template, or from the command line by using the .NET CLI, running these commands from the directory that contains the TraderSys.sln file:",
    "At this point, the project needs the Portfolio repository and models contained in the TraderSys.PortfolioData class library in the WCF solution. The easiest way to bring them across is to create a new class library by using either the Visual Studio New project dialog box with the Class Library (.NET Standard) template, or from the command line by using the .NET CLI, running these commands from the directory that contains the TraderSys.sln file:",
    "After you",
    "After you",
    "SDKstyle .NET projects automatically include any .cs files in or under their own directory, so you don",
    "SDKstyle .NET projects automatically include any .cs files in or under their own directory, so you don",
    "Now you can add a reference to this library to the gRPC application project and consume the PortfolioRepository class by using dependency injection in the gRPC service implementation. In the WCF application, dependency injection was provided by the Autofac IoC container. ASP.NET Core has dependency injection baked in. You can register the repository in the Program.cs itself:",
    "Now you can add a reference to this library to the gRPC application project and consume the PortfolioRepository class by using dependency injection in the gRPC service implementation. In the WCF application, dependency injection was provided by the Autofac IoC container. ASP.NET Core has dependency injection baked in. You can register the repository in the Program.cs itself:",
    "The IPortfolioRepository implementation can now be specified as a constructor parameter in the PortfolioService class, as follows:",
    "The IPortfolioRepository implementation can now be specified as a constructor parameter in the PortfolioService class, as follows:",
    "Now that you",
    "Now that you",
    "Start by implementing the Get method. The default override looks like this example:",
    "Start by implementing the Get method. The default override looks like this example:",
    "The first problem is that request.TraderId is a string, and the service requires a Guid. Even though the expected format for the string is UUID, the code has to deal with the possibility that a caller has sent an invalid value and respond appropriately. The service can respond with errors by throwing an RpcException and use the standard InvalidArgument status code to express the problem:",
    "The first problem is that request.TraderId is a string, and the service requires a Guid. Even though the expected format for the string is UUID, the code has to deal with the possibility that a caller has sent an invalid value and respond appropriately. The service can respond with errors by throwing an RpcException and use the standard InvalidArgument status code to express the problem:",
    "After there",
    "After there",
    "The previous code doesn",
    "The previous code doesn",
    "You could use a library like AutoMapper to handle this conversion from internal model classes to Protobuf types, as long as you configure the lower-level type conversions like string/Guid or decimal/double and the list mapping.",
    "You could use a library like AutoMapper to handle this conversion from internal model classes to Protobuf types, as long as you configure the lower-level type conversions like string/Guid or decimal/double and the list mapping.",
    "Now that you have the conversion code in place, you can complete the Get method implementation:",
    "Now that you have the conversion code in place, you can complete the Get method implementation:",
    "The implementation of the GetAll method is similar. Note that the repeated fields on Protobuf messages are generated as readonly properties of type RepeatedField",
    "The implementation of the GetAll method is similar. Note that the repeated fields on Protobuf messages are generated as readonly properties of type RepeatedField",
    "Having successfully migrated the WCF requestreply service to gRPC, let",
    "Having successfully migrated the WCF requestreply service to gRPC, let",
    "Create a .NET Standard class library in the same solution to contain the client. This is primarily an example of creating client code, but you could package such a library by using NuGet and distribute it on an internal repository for other .NET teams to consume. Go ahead and add a new .NET Standard class library called TraderSys.Portfolios.Client to the solution and delete the Class1.cs file.",
    "Create a .NET Standard class library in the same solution to contain the client. This is primarily an example of creating client code, but you could package such a library by using NuGet and distribute it on an internal repository for other .NET teams to consume. Go ahead and add a new .NET Standard class library called TraderSys.Portfolios.Client to the solution and delete the Class1.cs file.",
    "The Grpc.Net.Client NuGet package requires .NET Core 3.0 or later (or another .NET Standard 2.1compliant runtime). Earlier versions of .NET Framework and .NET Core are supported by the Grpc.Core NuGet package.",
    "The Grpc.Net.Client NuGet package requires .NET Core 3.0 or later (or another .NET Standard 2.1compliant runtime). Earlier versions of .NET Framework and .NET Core are supported by the Grpc.Core NuGet package.",
    "In Visual Studio 2022, you can add references to gRPC services in a way that",
    "In Visual Studio 2022, you can add references to gRPC services in a way that",
    "Connected Services",
    "Connected Services",
    "Publish",
    "Publish",
    "Service Dependencies",
    "Service Dependencies",
    "There are currently no service dependencies configured.",
    "There are currently no service dependencies configured.",
    "Add a service dependency",
    "Add a service dependency",
    "Add service reference",
    "Add service reference",
    "Select a service reference to add to your application",
    "Select a service reference to add to your application",
    "OpenAPI",
    "OpenAPI",
    "gRPC",
    "gRPC",
    "WCF Web Service",
    "WCF Web Service",
    "Browse to the portfolios.proto file in the TraderSys.Portfolios project, leave Client under Select the type of class to be generated , and then select OK :",
    "Browse to the portfolios.proto file in the TraderSys.Portfolios project, leave Client under Select the type of class to be generated , and then select OK :",
    "+02...",
    "+02...",
    "Add new gRPC service reference",
    "Add new gRPC service reference",
    "Select a file or URL",
    "Select a file or URL",
    "\u2022 File",
    "\u2022 File",
    "\u2022 URL",
    "\u2022 URL",
    "Select the type of class to be generated",
    "Select the type of class to be generated",
    "Client",
    "Client",
    "Tip",
    "Tip",
    "Notice that this dialog box also provides a URL field. If your organization maintains a web-accessible directory of .proto files, you can create clients just by setting this URL address.",
    "Notice that this dialog box also provides a URL field. If your organization maintains a web-accessible directory of .proto files, you can create clients just by setting this URL address.",
    "When you use the Visual Studio Add Connected Service feature, the portfolios.proto file is added to the class library project as a linked file rather than copied, so changes to the file in the service project will automatically be applied in the client project. The ",
    "When you use the Visual Studio Add Connected Service feature, the portfolios.proto file is added to the class library project as a linked file rather than copied, so changes to the file in the service project will automatically be applied in the client project. The ",
    "<",
    "<",
    "Tip",
    "Tip",
    "If you",
    "If you",
    "grpc global tool to manage Protobuf references in a .NET gRPC project. For more information, see the dotnet-grpc documentation.",
    "grpc global tool to manage Protobuf references in a .NET gRPC project. For more information, see the dotnet-grpc documentation.",
    "The following code is a brief example of how to use the generated client in a console application. A more detailed exploration of the gRPC client code is at the end of this chapter.",
    "The following code is a brief example of how to use the generated client in a console application. A more detailed exploration of the gRPC client code is at the end of this chapter.",
    "You",
    "You",
    "Now that you have a sense of the basic concepts, in this section, you",
    "Now that you have a sense of the basic concepts, in this section, you",
    "There are multiple ways to use duplex services in Windows Communication Foundation (WCF). Some services are initiated by the client and then they stream data from the server. Other full-duplex services might involve more ongoing two-way communication, like the classic Calculator example in the WCF documentation. This chapter will take two possible WCF stock ticker implementations and migrate them to gRPC: one that uses a server streaming RPC and another one that uses a bidirectional streaming RPC.",
    "There are multiple ways to use duplex services in Windows Communication Foundation (WCF). Some services are initiated by the client and then they stream data from the server. Other full-duplex services might involve more ongoing two-way communication, like the classic Calculator example in the WCF documentation. This chapter will take two possible WCF stock ticker implementations and migrate them to gRPC: one that uses a server streaming RPC and another one that uses a bidirectional streaming RPC.",
    "In the sample SimpleStockTicker WCF solution , SimpleStockPriceTicker, there",
    "In the sample SimpleStockTicker WCF solution , SimpleStockPriceTicker, there",
    "The WCF solution is implemented as a self-hosted Net.TCP server in a .NET Framework 4. x console application.",
    "The WCF solution is implemented as a self-hosted Net.TCP server in a .NET Framework 4. x console application.",
    "The service has a single method with no return type because it uses the callback interface ISimpleStockTickerCallback to send data to the client in real time.",
    "The service has a single method with no return type because it uses the callback interface ISimpleStockTickerCallback to send data to the client in real time.",
    "You can find the implementations of these interfaces in the solution, along with faked external dependencies to provide test data.",
    "You can find the implementations of these interfaces in the solution, along with faked external dependencies to provide test data.",
    "The gRPC process for handling real-time data is different from the WCF process. A call from client to server can create a persistent stream, which can be monitored for messages that arrive asynchronously. Despite the difference, streams can be a more intuitive way of dealing with this data and are more relevant in modern programming, which emphasizes LINQ, Reactive Streams, functional programming, and so on.",
    "The gRPC process for handling real-time data is different from the WCF process. A call from client to server can create a persistent stream, which can be monitored for messages that arrive asynchronously. Despite the difference, streams can be a more intuitive way of dealing with this data and are more relevant in modern programming, which emphasizes LINQ, Reactive Streams, functional programming, and so on.",
    "The service definition needs two messages: one for the request and one for the stream. The service returns a stream of the StockTickerUpdate message with the stream keyword in its return declaration. We recommend that you add a Timestamp to the update to show the exact time of the price change.",
    "The service definition needs two messages: one for the request and one for the stream. The service returns a stream of the StockTickerUpdate message with the stream keyword in its return declaration. We recommend that you add a Timestamp to the update to show the exact time of the price change.",
    "Reuse the fake StockPriceSubscriber from the WCF project by copying the three classes from the TraderSys.StockMarket class library into a new .NET Standard class library in the target solution. To better follow best practices, add a Factory type to create instances of it, and register the IStockPriceSubscriberFactory with the ASP.NET Core dependency injection services.",
    "Reuse the fake StockPriceSubscriber from the WCF project by copying the three classes from the TraderSys.StockMarket class library into a new .NET Standard class library in the target solution. To better follow best practices, add a Factory type to create instances of it, and register the IStockPriceSubscriberFactory with the ASP.NET Core dependency injection services.",
    "This class can now be used to implement the gRPC StockTickerService.",
    "This class can now be used to implement the gRPC StockTickerService.",
    "As you can see, although the declaration in the .proto file says the method returns a stream of StockTickerUpdate messages, it actually returns a Task. The job of creating the stream is handled by the generated code and the gRPC runtime libraries, which provide the IServerStreamWriter",
    "As you can see, although the declaration in the .proto file says the method returns a stream of StockTickerUpdate messages, it actually returns a Task. The job of creating the stream is handled by the generated code and the gRPC runtime libraries, which provide the IServerStreamWriter",
    "Unlike a WCF duplex service, where the instance of the service class is kept alive while the connection is open, the gRPC service uses the returned task to keep the service alive. The task shouldn",
    "Unlike a WCF duplex service, where the instance of the service class is kept alive while the connection is open, the gRPC service uses the returned task to keep the service alive. The task shouldn",
    "The service can tell when the client has closed the connection by using the CancellationToken from the ServerCallContext. A simple static method, AwaitCancellation, is used to create a task that completes when the token is canceled.",
    "The service can tell when the client has closed the connection by using the CancellationToken from the ServerCallContext. A simple static method, AwaitCancellation, is used to create a task that completes when the token is canceled.",
    "In the Subscribe method, then, get a StockPriceSubscriber and add an event handler that writes to the response stream. Then wait for the connection to be closed before immediately disposing the subscriber to prevent it from trying to write data to the closed stream.",
    "In the Subscribe method, then, get a StockPriceSubscriber and add an event handler that writes to the response stream. Then wait for the connection to be closed before immediately disposing the subscriber to prevent it from trying to write data to the closed stream.",
    "The WriteUpdateAsync method has a try/catch block to handle any errors that might happen when a message is written to the stream. This consideration is important in persistent connections over networks, which could be broken at any millisecond, whether intentionally or because of a failure somewhere.",
    "The WriteUpdateAsync method has a try/catch block to handle any errors that might happen when a message is written to the stream. This consideration is important in persistent connections over networks, which could be broken at any millisecond, whether intentionally or because of a failure somewhere.",
    "Follow the same steps in the previous section to create a shareable client class library from the .proto file. In the sample, there",
    "Follow the same steps in the previous section to create a shareable client class library from the .proto file. In the sample, there",
    "In this case, the Subscribe method on the generated client isn",
    "In this case, the Subscribe method on the generated client isn",
    "The stream is passed to an asynchronous DisplayAsync method. The application then waits for the user to press a key, and then cancels the DisplayAsync method and waits for the task to complete before exiting.",
    "The stream is passed to an asynchronous DisplayAsync method. The application then waits for the user to press a key, and then cancels the DisplayAsync method and waits for the task to complete before exiting.",
    "This code uses the new C# 8 using declaration syntax to dispose of the stream and the channel when the Main method exits. It",
    "This code uses the new C# 8 using declaration syntax to dispose of the stream and the channel when the Main method exits. It",
    "WCF uses callback interfaces to allow the server to call methods directly on the client. gRPC streams work differently. The client iterates over the returned stream and processes messages, just as though they were returned from a local method returning an IEnumerable.",
    "WCF uses callback interfaces to allow the server to call methods directly on the client. gRPC streams work differently. The client iterates over the returned stream and processes messages, just as though they were returned from a local method returning an IEnumerable.",
    "The IAsyncStreamReader",
    "The IAsyncStreamReader",
    "For developers using reactive programming patterns, the section on client libraries at the end of this chapter shows how to add an extension method and classes to wrap IAsyncStreamReader",
    "For developers using reactive programming patterns, the section on client libraries at the end of this chapter shows how to add an extension method and classes to wrap IAsyncStreamReader",
    "Again, be sure to catch exceptions here because of the possibility of network failure, and because of the OperationCanceledException that will inevitably be thrown because the code is using a CancellationToken to break the loop. The RpcException type has a lot of useful information about gRPC runtime errors, including the StatusCode. For more information, see Error handling in Chapter 4.",
    "Again, be sure to catch exceptions here because of the possibility of network failure, and because of the OperationCanceledException that will inevitably be thrown because the code is using a CancellationToken to break the loop. The RpcException type has a lot of useful information about gRPC runtime errors, including the StatusCode. For more information, see Error handling in Chapter 4.",
    "A WCF full-duplex service allows for asynchronous, real-time messaging in both directions. In the server streaming example, the client starts a request and then receives a stream of updates. A better",
    "A WCF full-duplex service allows for asynchronous, real-time messaging in both directions. In the server streaming example, the client starts a request and then receives a stream of updates. A better",
    "version of that service would allow the client to add and remove stocks from the list without having to stop and create a new subscription. That functionality has been implemented in the FullStockTicker sample solution.",
    "version of that service would allow the client to add and remove stocks from the list without having to stop and create a new subscription. That functionality has been implemented in the FullStockTicker sample solution.",
    "The IFullStockTickerService interface provides three methods:",
    "The IFullStockTickerService interface provides three methods:",
    "Subscribe starts the connection.",
    "Subscribe starts the connection.",
    "AddSymbol adds a stock symbol to watch.",
    "AddSymbol adds a stock symbol to watch.",
    "RemoveSymbol removes a symbol from the watched list.",
    "RemoveSymbol removes a symbol from the watched list.",
    "The callback interface remains the same.",
    "The callback interface remains the same.",
    "Implementing this pattern in gRPC is less straightforward because there are now two streams of data with messages being passed: one from client to server and another from server to client. It isn",
    "Implementing this pattern in gRPC is less straightforward because there are now two streams of data with messages being passed: one from client to server and another from server to client. It isn",
    "In a case where there",
    "In a case where there",
    "Declare a bidirectional streaming service that takes a stream of ActionMessage messages:",
    "Declare a bidirectional streaming service that takes a stream of ActionMessage messages:",
    "The implementation for this service is similar to that of the previous example, except the first parameter of the Subscribe method is now an IAsyncStreamReader",
    "The implementation for this service is similar to that of the previous example, except the first parameter of the Subscribe method is now an IAsyncStreamReader",
    "The ActionMessage class that gRPC has generated guarantees that only one of the Add and Remove properties can be set. Finding which one isn",
    "The ActionMessage class that gRPC has generated guarantees that only one of the Add and Remove properties can be set. Finding which one isn",
    "The property ActionCase on the ActionMessage object can be used with a switch statement to determine which field is set:",
    "The property ActionCase on the ActionMessage object can be used with a switch statement to determine which field is set:",
    "The switch statement has a default case that logs a warning if it encounters an unknown ActionOneOfCase value. This could be useful to indicate that a client is using a later version of the .proto file that has added more actions. This is one reason why using a switch is better than testing for null on known fields.",
    "The switch statement has a default case that logs a warning if it encounters an unknown ActionOneOfCase value. This could be useful to indicate that a client is using a later version of the .proto file that has added more actions. This is one reason why using a switch is better than testing for null on known fields.",
    "There",
    "There",
    "The client is used in the MainWindowViewModel class, which gets an instance of the FullStockTicker.FullStockTickerClient type from dependency injection:",
    "The client is used in the MainWindowViewModel class, which gets an instance of the FullStockTicker.FullStockTickerClient type from dependency injection:",
    "The object returned by the client.Subscribe() method is now an instance of the gRPC library type AsyncDuplexStreamingCall",
    "The object returned by the client.Subscribe() method is now an instance of the gRPC library type AsyncDuplexStreamingCall",
    "The request stream is used from some WPF ICommand methods to add and remove symbols. For each operation, set the relevant field on an ActionMessage object:",
    "The request stream is used from some WPF ICommand methods to add and remove symbols. For each operation, set the relevant field on an ActionMessage object:",
    "Setting a oneof field",
    "Setting a oneof field",
    "The stream of responses is handled in an async method. The Task it returns is held to be disposed when the window is closed:",
    "The stream of responses is handled in an async method. The Task it returns is held to be disposed when the window is closed:",
    "When the window is closed and the MainWindowViewModel is disposed (from the Closed event of MainWindow), we recommend that you properly dispose the AsyncDuplexStreamingCall object. In particular, the CompleteAsync method on the RequestStream should be called to gracefully close the stream on the server. This example shows the DisposeAsync method from the sample view-model:",
    "When the window is closed and the MainWindowViewModel is disposed (from the Closed event of MainWindow), we recommend that you properly dispose the AsyncDuplexStreamingCall object. In particular, the CompleteAsync method on the RequestStream should be called to gracefully close the stream on the server. This example shows the DisposeAsync method from the sample view-model:",
    "Closing request streams enables the server to dispose of its own resources in a timely way. This improves the efficiency and scalability of services and prevents exceptions.",
    "Closing request streams enables the server to dispose of its own resources in a timely way. This improves the efficiency and scalability of services and prevents exceptions.",
    "gRPC services provide two ways of returning datasets, or lists of objects. The Protocol Buffers message specification uses the repeated keyword for declaring lists or arrays of messages within another message. The gRPC service specification uses the stream keyword to declare a long-running persistent connection. Over that connection, multiple messages are sent, and can be processed, individually.",
    "gRPC services provide two ways of returning datasets, or lists of objects. The Protocol Buffers message specification uses the repeated keyword for declaring lists or arrays of messages within another message. The gRPC service specification uses the stream keyword to declare a long-running persistent connection. Over that connection, multiple messages are sent, and can be processed, individually.",
    "You can also use the stream feature for long-running temporal data such as notifications or log messages. But this chapter will consider its use for returning a single dataset.",
    "You can also use the stream feature for long-running temporal data such as notifications or log messages. But this chapter will consider its use for returning a single dataset.",
    "Which you should use depends on factors such as:",
    "Which you should use depends on factors such as:",
    "The overall size of the dataset.",
    "The overall size of the dataset.",
    "The time it took to create the dataset at either the client or server end.",
    "The time it took to create the dataset at either the client or server end.",
    "Whether the consumer of the dataset can start acting on it as soon as the first item is available, or needs the complete dataset to do anything useful.",
    "Whether the consumer of the dataset can start acting on it as soon as the first item is available, or needs the complete dataset to do anything useful.",
    "For any dataset that",
    "For any dataset that",
    "If the client needs all the data before starting to process it and the dataset is small enough to construct in memory, then consider using a repeated field. Consider it even if the creation of the dataset in memory on the server is slower.",
    "If the client needs all the data before starting to process it and the dataset is small enough to construct in memory, then consider using a repeated field. Consider it even if the creation of the dataset in memory on the server is slower.",
    "When the message objects in your datasets are potentially very large, it",
    "When the message objects in your datasets are potentially very large, it",
    "Similarly, you should send datasets of unconstrained size over streams to avoid running out of memory while constructing them.",
    "Similarly, you should send datasets of unconstrained size over streams to avoid running out of memory while constructing them.",
    "For datasets where the consumer can separately process each item, you should consider using a stream if it means that progress can be indicated to the user. Using a stream can improve the responsiveness of an application, but you should balance it against the overall performance of the application.",
    "For datasets where the consumer can separately process each item, you should consider using a stream if it means that progress can be indicated to the user. Using a stream can improve the responsiveness of an application, but you should balance it against the overall performance of the application.",
    "Another scenario where streams can be useful is where a message is being processed across multiple services. If each service in a chain returns a stream, then the terminal service (that is, the last one in the chain) can start returning messages. These messages can be processed and passed back along the chain to the original requestor. The requestor can either return a stream or aggregate the results into a single response message. This approach lends itself well to patterns like MapReduce.",
    "Another scenario where streams can be useful is where a message is being processed across multiple services. If each service in a chain returns a stream, then the terminal service (that is, the last one in the chain) can start returning messages. These messages can be processed and passed back along the chain to the original requestor. The requestor can either return a stream or aggregate the results into a single response message. This approach lends itself well to patterns like MapReduce.",
    "It isn",
    "It isn",
    "One advantage of distributing a client library is that you can enhance the generated gRPC and Protobuf classes with helpful ",
    "One advantage of distributing a client library is that you can enhance the generated gRPC and Protobuf classes with helpful ",
    "| Caution                                                                                                                                                                                                                                                         |",
    "| Caution                                                                                                                                                                                                                                                         |",
    "Ensure that as many teams as possible can access your gRPC service. The best way to do this functionality is to share .proto files so developers can generate their own clients. This approach is",
    "Ensure that as many teams as possible can access your gRPC service. The best way to do this functionality is to share .proto files so developers can generate their own clients. This approach is",
    "particularly true in a multi-platform environment, where different teams frequently use different programming languages and frameworks, or where your API is externally accessible.",
    "particularly true in a multi-platform environment, where different teams frequently use different programming languages and frameworks, or where your API is externally accessible.",
    "There are two commonly used interfaces in .NET for dealing with streams of objects: IEnumerable and IObservable . Starting with .NET Core 3.0 and C# 8.0, there",
    "There are two commonly used interfaces in .NET for dealing with streams of objects: IEnumerable and IObservable . Starting with .NET Core 3.0 and C# 8.0, there",
    "With the .NET gRPC client libraries, there",
    "With the .NET gRPC client libraries, there",
    "The IObservable",
    "The IObservable",
    "This code is longer than the IAsyncEnumerable",
    "This code is longer than the IAsyncEnumerable",
    "This observable implementation allows the Subscribe method to be called only once, because having multiple subscribers trying to read from the stream would result in chaos. There are operators, such as Replay in the System.Reactive.Linq, that enable buffering and repeatable sharing of observables, which can be used with this implementation.",
    "This observable implementation allows the Subscribe method to be called only once, because having multiple subscribers trying to read from the stream would result in chaos. There are operators, such as Replay in the System.Reactive.Linq, that enable buffering and repeatable sharing of observables, which can be used with this implementation.",
    "The GrpcStreamSubscription class handles the enumeration of the IAsyncStreamReader:",
    "The GrpcStreamSubscription class handles the enumeration of the IAsyncStreamReader:",
    "All that is required now is a simple extension method to create the observable from the stream reader.",
    "All that is required now is a simple extension method to create the observable from the stream reader.",
    "The IAsyncEnumerable and IObservable models are both well-supported and well-documented ways of dealing with asynchronous streams of data in .NET. gRPC streams map well to both paradigms, offering close integration with .NET, and reactive and asynchronous programming styles.",
    "The IAsyncEnumerable and IObservable models are both well-supported and well-documented ways of dealing with asynchronous streams of data in .NET. gRPC streams map well to both paradigms, offering close integration with .NET, and reactive and asynchronous programming styles.",
    "In any real-world scenario, securing applications and services are essential. Security covers three key areas:",
    "In any real-world scenario, securing applications and services are essential. Security covers three key areas:",
    "Encrypting network traffic to prevent malicious hackers from intercepting it.",
    "Encrypting network traffic to prevent malicious hackers from intercepting it.",
    "Authenticating clients and servers to establish identity and trust.",
    "Authenticating clients and servers to establish identity and trust.",
    "Authorizing clients to control access to systems and apply permissions based on identity.",
    "Authorizing clients to control access to systems and apply permissions based on identity.",
    "Authentication is concerned with establishing the identity of a client or server. Authorization is concerned with determining whether a client has permission to access a resource or issue a command.",
    "Authentication is concerned with establishing the identity of a client or server. Authorization is concerned with determining whether a client has permission to access a resource or issue a command.",
    "This chapter will cover the facilities for authentication and authorization in gRPC for ASP.NET Core. It will also discuss network security through TLS encrypted connections.",
    "This chapter will cover the facilities for authentication and authorization in gRPC for ASP.NET Core. It will also discuss network security through TLS encrypted connections.",
    "In Windows Communication Foundation (WCF), authentication and authorization were handled in different ways, depending on the transports and bindings being used. WCF supported various WS-",
    "In Windows Communication Foundation (WCF), authentication and authorization were handled in different ways, depending on the transports and bindings being used. WCF supported various WS-",
    "gRPC authentication and authorization works on two levels:",
    "gRPC authentication and authorization works on two levels:",
    "Call-level authentication/authorization is usually handled through tokens that are applied in metadata when the call is made.",
    "Call-level authentication/authorization is usually handled through tokens that are applied in metadata when the call is made.",
    "Channellevel authentication uses a client certificate that",
    "Channellevel authentication uses a client certificate that",
    "You can use either or both of these mechanisms to help secure your service.",
    "You can use either or both of these mechanisms to help secure your service.",
    "The ASP.NET Core implementation of gRPC supports authentication and authorization through most of the standard ASP.NET Core mechanisms:",
    "The ASP.NET Core implementation of gRPC supports authentication and authorization through most of the standard ASP.NET Core mechanisms:",
    "Call authentication",
    "Call authentication",
    "-Azure Active Directory",
    "-Azure Active Directory",
    "-IdentityServer",
    "-IdentityServer",
    "-JWT Bearer Token",
    "-JWT Bearer Token",
    "-OAuth 2.0",
    "-OAuth 2.0",
    "-OpenID Connect",
    "-OpenID Connect",
    "-WS-Federation",
    "-WS-Federation",
    "Channel authentication",
    "Channel authentication",
    "-Client certificate",
    "-Client certificate",
    "The call authentication methods are all based on tokens . The only real difference is how the tokens are generated and the libraries that are used to validate the tokens in the ASP.NET Core service.",
    "The call authentication methods are all based on tokens . The only real difference is how the tokens are generated and the libraries that are used to validate the tokens in the ASP.NET Core service.",
    "For more information, see the Authentication and authorization article.",
    "For more information, see the Authentication and authorization article.",
    "| Note                                                                                                                                                                       |",
    "| Note                                                                                                                                                                       |",
    "This chapter will show how to apply call credentials and channel credentials to a gRPC service. It will also show how to use credentials from a .NET gRPC client to authenticate with the service.",
    "This chapter will show how to apply call credentials and channel credentials to a gRPC service. It will also show how to use credentials from a .NET gRPC client to authenticate with the service.",
    "Call credentials are all based on a token passed in metadata with each request.",
    "Call credentials are all based on a token passed in metadata with each request.",
    "ASP.NET Core supports WS-Federation using the WsFederation NuGet package. WS-Federation is the closest available alternative to Windows Authentication, which isn",
    "ASP.NET Core supports WS-Federation using the WsFederation NuGet package. WS-Federation is the closest available alternative to Windows Authentication, which isn",
    "For more information on how to get started with this authentication method, see Authenticate users with WS-Federation in ASP.NET Core.",
    "For more information on how to get started with this authentication method, see Authenticate users with WS-Federation in ASP.NET Core.",
    "The JSON Web Token (JWT) standard provides a way to encode information about a user and their claims in an encoded string. It also provides a way to sign that token, so that the consumer can verify the integrity of the token by using public key cryptography. You can use various services, such as IdentityServer4, to authenticate users and generate OpenID Connect (OIDC) tokens to use with gRPC and HTTP APIs.",
    "The JSON Web Token (JWT) standard provides a way to encode information about a user and their claims in an encoded string. It also provides a way to sign that token, so that the consumer can verify the integrity of the token by using public key cryptography. You can use various services, such as IdentityServer4, to authenticate users and generate OpenID Connect (OIDC) tokens to use with gRPC and HTTP APIs.",
    "ASP.NET Core 7.0 can handle JWTs by using the JWT Bearer package. The configuration is exactly the same for a gRPC application as it is for an ASP.NET Core MVC application. Here, we",
    "ASP.NET Core 7.0 can handle JWTs by using the JWT Bearer package. The configuration is exactly the same for a gRPC application as it is for an ASP.NET Core MVC application. Here, we",
    "The JWT Bearer package isn",
    "The JWT Bearer package isn",
    "Add the Authentication service in the Program.cs class, and configure the JWT Bearer handler:",
    "Add the Authentication service in the Program.cs class, and configure the JWT Bearer handler:",
    "The IssuerSigningKey property requires an implementation of",
    "The IssuerSigningKey property requires an implementation of",
    "Microsoft.IdentityModels.Tokens.SecurityKey with the cryptographic data necessary to validate the signed tokens. Store this token securely in a secrets server , like Azure Key Vault.",
    "Microsoft.IdentityModels.Tokens.SecurityKey with the cryptographic data necessary to validate the signed tokens. Store this token securely in a secrets server , like Azure Key Vault.",
    "Next, add the Authorization service, which controls access to the system:",
    "Next, add the Authorization service, which controls access to the system:",
    "Authentication and authorization are two separate steps. You use authentication to determine the user",
    "Authentication and authorization are two separate steps. You use authentication to determine the user",
    "Now add the authentication and authorization middleware to the ASP.NET Core pipeline in the Program.cs :",
    "Now add the authentication and authorization middleware to the ASP.NET Core pipeline in the Program.cs :",
    "Finally, apply the ",
    "Finally, apply the ",
    "After you",
    "After you",
    "Now you",
    "Now you",
    "As the name implies, channel credentials are attached to the underlying gRPC channel. The standard form of channel credentials uses client certificate authentication. In this process, the client provides a TLS certificate when it",
    "As the name implies, channel credentials are attached to the underlying gRPC channel. The standard form of channel credentials uses client certificate authentication. In this process, the client provides a TLS certificate when it",
    "You can combine channel credentials with call credentials to provide comprehensive security for a gRPC service. The channel credentials prove that the client application is allowed to access the service, and the call credentials provide information about the person who is using the client application.",
    "You can combine channel credentials with call credentials to provide comprehensive security for a gRPC service. The channel credentials prove that the client application is allowed to access the service, and the call credentials provide information about the person who is using the client application.",
    "Client certificate authentication works for gRPC the same way it works for ASP.NET Core. For more information, see Configure certificate authentication in ASP.NET Core.",
    "Client certificate authentication works for gRPC the same way it works for ASP.NET Core. For more information, see Configure certificate authentication in ASP.NET Core.",
    "For development purposes you can use a self-signed certificate, but for production you should use a proper HTTPS certificate signed by a trusted authority.",
    "For development purposes you can use a self-signed certificate, but for production you should use a proper HTTPS certificate signed by a trusted authority.",
    "Configure certificate authentication both at the host level (for example, on the Kestrel server), and in the ASP.NET Core pipeline.",
    "Configure certificate authentication both at the host level (for example, on the Kestrel server), and in the ASP.NET Core pipeline.",
    "You can configure Kestrel (the ASP.NET Core HTTP server) to require a client certificate, and optionally to carry out some validation of the supplied certificate, before accepting incoming connections. You specify this configuration in the Program.cs :",
    "You can configure Kestrel (the ASP.NET Core HTTP server) to require a client certificate, and optionally to carry out some validation of the supplied certificate, before accepting incoming connections. You specify this configuration in the Program.cs :",
    "The ClientCertificateMode.RequireCertificate setting causes Kestrel to immediately reject any connection request that doesn",
    "The ClientCertificateMode.RequireCertificate setting causes Kestrel to immediately reject any connection request that doesn",
    "The Microsoft.AspNetCore.Authentication.Certificate NuGet package provides certificate authentication.",
    "The Microsoft.AspNetCore.Authentication.Certificate NuGet package provides certificate authentication.",
    "Add the certificate authentication service in the Program.cs , and add authentication and authorization to the ASP.NET Core pipeline.",
    "Add the certificate authentication service in the Program.cs , and add authentication and authorization to the ASP.NET Core pipeline.",
    "With the Grpc.Net.Client package, you configure certificates on an HttpClient instance that is provided to the GrpcChannel used for the connection.",
    "With the Grpc.Net.Client package, you configure certificates on an HttpClient instance that is provided to the GrpcChannel used for the connection.",
    "A certificate can be loaded from a .pfx file.",
    "A certificate can be loaded from a .pfx file.",
    "A certificate can be loaded from a certificate and private key .pem file.",
    "A certificate can be loaded from a certificate and private key .pem file.",
    "Due to an internal Windows bug as documented here , you",
    "Due to an internal Windows bug as documented here , you",
    "]",
    "]",
    "You can configure your server to use both certificate and token authentication. To do this, apply the certificate changes to the Kestrel server, and use the JWT bearer middleware in ASP.NET Core.",
    "You can configure your server to use both certificate and token authentication. To do this, apply the certificate changes to the Kestrel server, and use the JWT bearer middleware in ASP.NET Core.",
    "To provide both ChannelCredentials and CallCredentials on the client, use the ChannelCredentials.Create method to apply the call credentials. You still need to apply certificate authentication by using the HttpClient instance. If you pass any arguments to the SslCredentials",
    "To provide both ChannelCredentials and CallCredentials on the client, use the ChannelCredentials.Create method to apply the call credentials. You still need to apply certificate authentication by using the HttpClient instance. If you pass any arguments to the SslCredentials",
    "constructor, the internal client code throws an exception. The SslCredentials parameter is only included in the Grpc.Net.Client package",
    "constructor, the internal client code throws an exception. The SslCredentials parameter is only included in the Grpc.Net.Client package",
    "You can use the ChannelCredentials.Create method for a client without certificate authentication. This is a useful way to pass token credentials with every call made on the channel.",
    "You can use the ChannelCredentials.Create method for a client without certificate authentication. This is a useful way to pass token credentials with every call made on the channel.",
    "A version of the FullStockTicker sample gRPC application with certificate authentication added is on GitHub.",
    "A version of the FullStockTicker sample gRPC application with certificate authentication added is on GitHub.",
    "The network security model for Windows Communication Foundation (WCF) is extensive and complex. It includes transport-level security by using HTTPS or TLS-over-TCP, and message-level security by using the WS-Security specification to encrypt individual messages.",
    "The network security model for Windows Communication Foundation (WCF) is extensive and complex. It includes transport-level security by using HTTPS or TLS-over-TCP, and message-level security by using the WS-Security specification to encrypt individual messages.",
    "gRPC leaves secure networking to the underlying HTTP/2 protocol, which you can secure by using TLS certificates.",
    "gRPC leaves secure networking to the underlying HTTP/2 protocol, which you can secure by using TLS certificates.",
    "Web browsers insist on using TLS connections for HTTP/2, but most programmatic clients, including .NET",
    "Web browsers insist on using TLS connections for HTTP/2, but most programmatic clients, including .NET",
    "For public APIs, you should always use TLS connections, and provide valid certificates for your services from a proper SSL authority. LetsEncrypt provides free, automated SSL certificates, and most hosting infrastructure today supports the LetsEncrypt standard with common plug-ins or extensions.",
    "For public APIs, you should always use TLS connections, and provide valid certificates for your services from a proper SSL authority. LetsEncrypt provides free, automated SSL certificates, and most hosting infrastructure today supports the LetsEncrypt standard with common plug-ins or extensions.",
    "For internal services across a corporate network, you should still consider using TLS to secure network traffic to and from your gRPC services.",
    "For internal services across a corporate network, you should still consider using TLS to secure network traffic to and from your gRPC services.",
    "If you need to use explicit TLS between services running in Kubernetes, consider using an in-cluster certificate authority and a certificate manager controller like cert-manager. You can then automatically assign certificates to services at deployment time.",
    "If you need to use explicit TLS between services running in Kubernetes, consider using an in-cluster certificate authority and a certificate manager controller like cert-manager. You can then automatically assign certificates to services at deployment time.",
    "You can run ASP.NET Core 7.0 applications, including gRPC services, on Windows, on Linux, and in containers using modern platforms like Docker and Kubernetes. This chapter explores the various options for running your gRPC services in production, and looks at monitoring and logging options to ensure the optimal operation of systems.",
    "You can run ASP.NET Core 7.0 applications, including gRPC services, on Windows, on Linux, and in containers using modern platforms like Docker and Kubernetes. This chapter explores the various options for running your gRPC services in production, and looks at monitoring and logging options to ensure the optimal operation of systems.",
    "Although ASP.NET Core 7.0 applications can be hosted in IIS on Windows Server, currently it isn",
    "Although ASP.NET Core 7.0 applications can be hosted in IIS on Windows Server, currently it isn",
    "You can run your application as a Windows service. Or you can run it as a Linux service controlled by systemd, because of features introduced in the .NET 6 hosting extensions.",
    "You can run your application as a Windows service. Or you can run it as a Linux service controlled by systemd, because of features introduced in the .NET 6 hosting extensions.",
    "To configure your ASP.NET Core application to run as a Windows service, install the Microsoft.Extensions.Hosting.WindowsServices package from NuGet. Then add a call to UseWindowsService to the CreateHostBuilder method in Program.cs.",
    "To configure your ASP.NET Core application to run as a Windows service, install the Microsoft.Extensions.Hosting.WindowsServices package from NuGet. Then add a call to UseWindowsService to the CreateHostBuilder method in Program.cs.",
    "If the application isn",
    "If the application isn",
    "Now publish your application by using one of these methods:",
    "Now publish your application by using one of these methods:",
    "From Visual Studio by right-clicking the project and selecting Publish on the shortcut menu.",
    "From Visual Studio by right-clicking the project and selecting Publish on the shortcut menu.",
    "From the .NET CLI.",
    "From the .NET CLI.",
    "When you publish a .NET application, you can choose to create a framework-dependent deployment or a self-contained deployment. Framework-dependent deployments require the .NET Shared Runtime to be installed on the host where they",
    "When you publish a .NET application, you can choose to create a framework-dependent deployment or a self-contained deployment. Framework-dependent deployments require the .NET Shared Runtime to be installed on the host where they",
    "including the advantages and disadvantages of each approach, see the .NET application deployment documentation.",
    "including the advantages and disadvantages of each approach, see the .NET application deployment documentation.",
    "To publish a selfcontained build of the application that doesn",
    "To publish a selfcontained build of the application that doesn",
    "To publish a framework-dependent build, omit the -r flag.",
    "To publish a framework-dependent build, omit the -r flag.",
    "Copy the complete contents of the publish directory to an installation folder. Then, use the sc tool to create a Windows service for the executable file.",
    "Copy the complete contents of the publish directory to an installation folder. Then, use the sc tool to create a Windows service for the executable file.",
    "The UseWindowsService method automatically adds a logging provider that writes log messages to the Windows event log. You can configure logging for this provider by adding an EventLog entry to the Logging section of appsettings.json or another configuration source.",
    "The UseWindowsService method automatically adds a logging provider that writes log messages to the Windows event log. You can configure logging for this provider by adding an EventLog entry to the Logging section of appsettings.json or another configuration source.",
    "You can override the source name used in the event log by setting a SourceName property in these settings. If you don",
    "You can override the source name used in the event log by setting a SourceName property in these settings. If you don",
    "More information on logging is at the end of this chapter.",
    "More information on logging is at the end of this chapter.",
    "To configure your ASP.NET Core application to run as a Linux service (or daemon in Linux parlance), install the Microsoft.Extensions.Hosting.Systemd package from NuGet. Then add a call to UseSystemd to the CreateHostBuilder method in Program.cs.",
    "To configure your ASP.NET Core application to run as a Linux service (or daemon in Linux parlance), install the Microsoft.Extensions.Hosting.Systemd package from NuGet. Then add a call to UseSystemd to the CreateHostBuilder method in Program.cs.",
    "If the application isn",
    "If the application isn",
    "Now publish your application. The application can be either framework dependent or self-contained for the relevant Linux runtime (for example, linux-x64). You can publish by using one of these methods:",
    "Now publish your application. The application can be either framework dependent or self-contained for the relevant Linux runtime (for example, linux-x64). You can publish by using one of these methods:",
    "From Visual Studio by right-clicking the project and selecting Publish on the shortcut menu.",
    "From Visual Studio by right-clicking the project and selecting Publish on the shortcut menu.",
    "From the .NET CLI, by using the following command:",
    "From the .NET CLI, by using the following command:",
    "Copy the complete contents of the publish directory to an installation folder on the Linux host. Registering the service requires a special file, called a unit file , to be added to the /etc/systemd/system directory. You",
    "Copy the complete contents of the publish directory to an installation folder on the Linux host. Registering the service requires a special file, called a unit file , to be added to the /etc/systemd/system directory. You",
    "The service file uses INI format, as shown in this example:",
    "The service file uses INI format, as shown in this example:",
    "The Type=notify property tells systemd that the application will notify it on startup and shutdown. The WantedBy=multi-user.target setting will cause the service to start when the Linux system reaches ",
    "The Type=notify property tells systemd that the application will notify it on startup and shutdown. The WantedBy=multi-user.target setting will cause the service to start when the Linux system reaches ",
    "Before systemd will recognize the service, it needs to reload its configuration. You control systemd by using the systemctl command. After reloading, use the status subcommand to confirm that the application has registered successfully.",
    "Before systemd will recognize the service, it needs to reload its configuration. You control systemd by using the systemctl command. After reloading, use the status subcommand to confirm that the application has registered successfully.",
    "If you",
    "If you",
    "Use the start command to start the service.",
    "Use the start command to start the service.",
    "To tell systemd to start the service automatically on system startup, use the enable command.",
    "To tell systemd to start the service automatically on system startup, use the enable command.",
    "The Linux equivalent of the Windows event log is journald, a structured logging system service that",
    "The Linux equivalent of the Windows event log is journald, a structured logging system service that",
    "Because journald is the standard for Linux logs, a variety of tools integrate with it. You can easily route logs from journald to an external logging system. Working locally on the host, you can use the journalctl command to view logs from the command line.",
    "Because journald is the standard for Linux logs, a variety of tools integrate with it. You can easily route logs from journald to an external logging system. Working locally on the host, you can use the journalctl command to view logs from the command line.",
    "sudo journalctl -u myapp",
    "sudo journalctl -u myapp",
    "If you have a GUI environment available on your host, a few graphical log viewers are available for Linux, such as QJournalctl and gnome-logs .",
    "If you have a GUI environment available on your host, a few graphical log viewers are available for Linux, such as QJournalctl and gnome-logs .",
    "To learn more about querying the systemd journal from the command line by using journalctl, see the manpages.",
    "To learn more about querying the systemd journal from the command line by using journalctl, see the manpages.",
    "When you",
    "When you",
    "On Windows hosts, you can load the certificate from a secure certificate store by using the X509Store class. You can also use the X509Store class with the OpenSSL key store on some Linux hosts.",
    "On Windows hosts, you can load the certificate from a secure certificate store by using the X509Store class. You can also use the X509Store class with the OpenSSL key store on some Linux hosts.",
    "You can also create certificates by using one of the X509Certificate2 constructors, from either:",
    "You can also create certificates by using one of the X509Certificate2 constructors, from either:",
    "A file, such as a .pfx file protected by a strong password",
    "A file, such as a .pfx file protected by a strong password",
    "Binary data retrieved from a secure storage service such as Azure Key Vault",
    "Binary data retrieved from a secure storage service such as Azure Key Vault",
    "You can configure Kestrel to use a certificate in two ways: from configuration or in code.",
    "You can configure Kestrel to use a certificate in two ways: from configuration or in code.",
    "The configuration approach requires setting the password and path to the certificate .pfx file in the Kestrel configuration section. In appsettings.json, that looks like this:",
    "The configuration approach requires setting the password and path to the certificate .pfx file in the Kestrel configuration section. In appsettings.json, that looks like this:",
    "Provide the password by using a secure configuration source such as Azure Key Vault or Hashicorp Vault.",
    "Provide the password by using a secure configuration source such as Azure Key Vault or Hashicorp Vault.",
    "Don",
    "Don",
    "To configure HTTPS on Kestrel in code, use the ConfigureKestrel method on IWebHostBuilder in the Program class.",
    "To configure HTTPS on Kestrel in code, use the ConfigureKestrel method on IWebHostBuilder in the Program class.",
    "Again, be sure to store the password for the .pfx file in, and retrieve it from, a secure configuration source.",
    "Again, be sure to store the password for the .pfx file in, and retrieve it from, a secure configuration source.",
    "This section covers the creation of Docker images for ASP.NET Core gRPC applications, ready to run in Docker, Kubernetes, or other container environments. The sample application used, with an ASP.NET Core MVC web app and a gRPC service, is available on the dotnet-architecture/grpc-for-wcfdevelopers repository on GitHub.",
    "This section covers the creation of Docker images for ASP.NET Core gRPC applications, ready to run in Docker, Kubernetes, or other container environments. The sample application used, with an ASP.NET Core MVC web app and a gRPC service, is available on the dotnet-architecture/grpc-for-wcfdevelopers repository on GitHub.",
    "Microsoft provides a range of base images for building and running .NET applications. To create an ASP.NET Core 7.0 image, you use two base images:",
    "Microsoft provides a range of base images for building and running .NET applications. To create an ASP.NET Core 7.0 image, you use two base images:",
    "An SDK image to build and publish the application.",
    "An SDK image to build and publish the application.",
    "A runtime image for deployment.",
    "A runtime image for deployment.",
    "| Image                            | Description                                                                |",
    "| Image                            | Description                                                                |",
    "For each image, there are four variants based on different Linux distributions, distinguished by tags.",
    "For each image, there are four variants based on different Linux distributions, distinguished by tags.",
    "| Image tag(s)           | Linux       | Notes                                                           |",
    "| Image tag(s)           | Linux       | Notes                                                           |",
    "The Alpine base image is around 100 MB, compared to 200 MB for the Debian and Ubuntu images. Some software packages or libraries might not be available in Alpine",
    "The Alpine base image is around 100 MB, compared to 200 MB for the Debian and Ubuntu images. Some software packages or libraries might not be available in Alpine",
    "Make sure you use the same variant of Linux for the build and the runtime. Applications built and published on one variant might not work on another.",
    "Make sure you use the same variant of Linux for the build and the runtime. Applications built and published on one variant might not work on another.",
    "A Docker image is defined by a Dockerfile . This Dockerfile is a text file that contains all the commands needed to build the application and install any dependencies that are required for either building or running the application. The following example shows the simplest Dockerfile for an ASP.NET Core 7.0 application:",
    "A Docker image is defined by a Dockerfile . This Dockerfile is a text file that contains all the commands needed to build the application and install any dependencies that are required for either building or running the application. The following example shows the simplest Dockerfile for an ASP.NET Core 7.0 application:",
    "The Dockerfile has two parts: the first uses the sdk base image to build and publish the application; the second creates a runtime image from the aspnet base. This is because the sdk image is around 900 MB, compared to around 200 MB for the runtime image, and most of its contents are unnecessary at run time.",
    "The Dockerfile has two parts: the first uses the sdk base image to build and publish the application; the second creates a runtime image from the aspnet base. This is because the sdk image is around 900 MB, compared to around 200 MB for the runtime image, and most of its contents are unnecessary at run time.",
    "| Step                   | Description                                                                                        |",
    "| Step                   | Description                                                                                        |",
    "| Step                    | Description                                                                                                        |",
    "| Step                    | Description                                                                                                        |",
    "Microsoft base images for Docker set the ASPNETCORE",
    "Microsoft base images for Docker set the ASPNETCORE",
    "Much like .gitignore files that exclude certain files and directories from source control, the .dockerignore file can be used to exclude files and directories from being copied to the image during build. This file not only saves time copying, but can also avoid some errors that arise from having the obj directory from your PC copied into the image. At a minimum, you should add entries for bin and obj to your .dockerignore file.",
    "Much like .gitignore files that exclude certain files and directories from source control, the .dockerignore file can be used to exclude files and directories from being copied to the image during build. This file not only saves time copying, but can also avoid some errors that arise from having the obj directory from your PC copied into the image. At a minimum, you should add entries for bin and obj to your .dockerignore file.",
    "bin/",
    "bin/",
    "obj/",
    "obj/",
    "For a StockKube.sln solution containing two different applications StockData and StockWeb, it",
    "For a StockKube.sln solution containing two different applications StockData and StockWeb, it",
    "docker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .",
    "docker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .",
    "The confusingly named --tag flag (which can be shortened to -t) specifies the whole name of the image, including the actual tag if specified. The . at the end specifies the context in which the build will be run; the current working directory for the COPY commands in the Dockerfile.",
    "The confusingly named --tag flag (which can be shortened to -t) specifies the whole name of the image, including the actual tag if specified. The . at the end specifies the context in which the build will be run; the current working directory for the COPY commands in the Dockerfile.",
    "If you have multiple applications within a single solution, you can keep the Dockerfile for each application in its own folder, beside the .csproj file. You should still run the docker build command from the base directory to ensure that the solution and all the projects are copied into the image. You can specify a Dockerfile below the current directory by using the --file (or -f) flag.",
    "If you have multiple applications within a single solution, you can keep the Dockerfile for each application in its own folder, beside the .csproj file. You should still run the docker build command from the base directory to ensure that the solution and all the projects are copied into the image. You can specify a Dockerfile below the current directory by using the --file (or -f) flag.",
    "docker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .",
    "docker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .",
    "To run the image in your local Docker instance, use the docker run command.",
    "To run the image in your local Docker instance, use the docker run command.",
    "The -ti flag connects your current terminal to the container",
    "The -ti flag connects your current terminal to the container",
    "After you",
    "After you",
    "To push to Docker Hub, prefix the image name with your user or organization name.",
    "To push to Docker Hub, prefix the image name with your user or organization name.",
    "To push to a private registry, prefix the image name with the registry host name and the organization name.",
    "To push to a private registry, prefix the image name with the registry host name and the organization name.",
    "After the image is in a registry, you can deploy it to individual Docker hosts, or to a container orchestration engine like Kubernetes.",
    "After the image is in a registry, you can deploy it to individual Docker hosts, or to a container orchestration engine like Kubernetes.",
    "Although it",
    "Although it",
    "Kubernetes includes the following functionality:",
    "Kubernetes includes the following functionality:",
    "Scheduling runs containers on multiple nodes within a cluster, ensuring balanced usage of the available resource, keeping containers running if there are outages, and handling rolling updates to new versions of images or new configurations.",
    "Scheduling runs containers on multiple nodes within a cluster, ensuring balanced usage of the available resource, keeping containers running if there are outages, and handling rolling updates to new versions of images or new configurations.",
    "Health checks monitor containers to ensure continued service.",
    "Health checks monitor containers to ensure continued service.",
    "DNS ",
    "DNS ",
    "Ingress exposes selected services externally and generally provides load-balancing across instances of those services.",
    "Ingress exposes selected services externally and generally provides load-balancing across instances of those services.",
    "Resource management attaches external resources like storage to containers.",
    "Resource management attaches external resources like storage to containers.",
    "This chapter will detail how to deploy an ASP.NET Core gRPC service and a website that consumes the service into a Kubernetes cluster. The sample application used is available in the dotnetarchitecture/grpc-for-wcf-developers repository on GitHub.",
    "This chapter will detail how to deploy an ASP.NET Core gRPC service and a website that consumes the service into a Kubernetes cluster. The sample application used is available in the dotnetarchitecture/grpc-for-wcf-developers repository on GitHub.",
    "Kubernetes uses desired state configuration : the API is used to describe objects like Pods , Deployments , and Services , and the Control Plane takes care of implementing the desired state across all the nodes in a cluster . A Kubernetes cluster has a Master node that runs the Kubernetes API , which you can communicate with programmatically or by using the kubectl command-line tool. kubectl can create and manage objects through command-line arguments, but it works best with YAML files that contain declaration data for Kubernetes objects.",
    "Kubernetes uses desired state configuration : the API is used to describe objects like Pods , Deployments , and Services , and the Control Plane takes care of implementing the desired state across all the nodes in a cluster . A Kubernetes cluster has a Master node that runs the Kubernetes API , which you can communicate with programmatically or by using the kubectl command-line tool. kubectl can create and manage objects through command-line arguments, but it works best with YAML files that contain declaration data for Kubernetes objects.",
    "Every Kubernetes YAML file will have at least three top-level properties:",
    "Every Kubernetes YAML file will have at least three top-level properties:",
    "| apiVersion : v1     |",
    "| apiVersion : v1     |",
    "The apiVersion property is used to specify which version (and which API) the file is intended for. The kind property specifies the kind of object the YAML represents. The metadata property contains object properties like name, namespace, and labels.",
    "The apiVersion property is used to specify which version (and which API) the file is intended for. The kind property specifies the kind of object the YAML represents. The metadata property contains object properties like name, namespace, and labels.",
    "Most Kubernetes YAML files will also have a spec section that describes the resources and configuration necessary to create the object.",
    "Most Kubernetes YAML files will also have a spec section that describes the resources and configuration necessary to create the object.",
    "Pods are the basic units of execution in Kubernetes. They can run multiple containers, but they",
    "Pods are the basic units of execution in Kubernetes. They can run multiple containers, but they",
    "Services are meta-objects that describe Pods (or sets of Pods) and provide a way to access them within the cluster, such as mapping a service name to a set of pod IP addresses by using the cluster DNS service.",
    "Services are meta-objects that describe Pods (or sets of Pods) and provide a way to access them within the cluster, such as mapping a service name to a set of pod IP addresses by using the cluster DNS service.",
    "Deployments are the desired state objects for Pods. If you create a pod manually, it won",
    "Deployments are the desired state objects for Pods. If you create a pod manually, it won",
    "Pods, Services, and Deployments are just three of the most basic object types. There are dozens of other object types that are managed by Kubernetes clusters. For more information, see the Kubernetes Concepts documentation.",
    "Pods, Services, and Deployments are just three of the most basic object types. There are dozens of other object types that are managed by Kubernetes clusters. For more information, see the Kubernetes Concepts documentation.",
    "Kubernetes clusters are designed to scale to hundreds or thousands of nodes and to run similar numbers of services. To avoid clashes between object names, namespaces are used to group objects together as part of larger applications. Kubernetes",
    "Kubernetes clusters are designed to scale to hundreds or thousands of nodes and to run similar numbers of services. To avoid clashes between object names, namespaces are used to group objects together as part of larger applications. Kubernetes",
    "If you",
    "If you",
    "Settings",
    "Settings",
    "\u2022 Docker running",
    "\u2022 Docker running",
    "General",
    "General",
    "X",
    "X",
    "X",
    "X",
    "Kubernetes",
    "Kubernetes",
    "To run a local Kubernetes cluster on Linux, consider minikube, or MicroK8s if your Linux distribution supports snaps.",
    "To run a local Kubernetes cluster on Linux, consider minikube, or MicroK8s if your Linux distribution supports snaps.",
    "To confirm that your cluster is running and accessible, run the kubectl version command:",
    "To confirm that your cluster is running and accessible, run the kubectl version command:",
    "In this example, both the kubectl CLI and the Kubernetes server are running version 1.14.6. Each version of kubectl is supposed to support the previous and next version of the server, so kubectl 1.14 should work with server versions 1.13 and 1.15 as well.",
    "In this example, both the kubectl CLI and the Kubernetes server are running version 1.14.6. Each version of kubectl is supposed to support the previous and next version of the server, so kubectl 1.14 should work with server versions 1.13 and 1.15 as well.",
    "The sample application has a kube directory that contains three YAML files. The namespace.yml file declares a custom namespace: stocks. The stockdata.yml file declares the Deployment and the Service for the gRPC application, and the stockweb.yml file declares the Deployment and Service for an ASP.NET Core 7.0 MVC web application that consumes the gRPC service.",
    "The sample application has a kube directory that contains three YAML files. The namespace.yml file declares a custom namespace: stocks. The stockdata.yml file declares the Deployment and the Service for the gRPC application, and the stockweb.yml file declares the Deployment and Service for an ASP.NET Core 7.0 MVC web application that consumes the gRPC service.",
    "To use a YAML file with kubectl, run the apply -f command:",
    "To use a YAML file with kubectl, run the apply -f command:",
    "The apply command will check the validity of the YAML file and display any errors received from the API, but doesn",
    "The apply command will check the validity of the YAML file and display any errors received from the API, but doesn",
    "take some time. Use the kubectl get command with the relevant object types to check on object creation in the cluster.",
    "take some time. Use the kubectl get command with the relevant object types to check on object creation in the cluster.",
    "Namespace declaration is simple and requires only assigning a name:",
    "Namespace declaration is simple and requires only assigning a name:",
    "Use kubectl to apply the namespace.yml file and to confirm the namespace is created successfully:",
    "Use kubectl to apply the namespace.yml file and to confirm the namespace is created successfully:",
    "The stockdata.yml file declares two objects: a Deployment and a Service.",
    "The stockdata.yml file declares two objects: a Deployment and a Service.",
    "The Deployment part of the YAML file provides the spec for the deployment itself, including the number of replicas required, and a template for the Pod objects to be created and managed by the deployment. Note that Deployment objects are managed by the apps API, as specified in apiVersion, rather than the main Kubernetes API.",
    "The Deployment part of the YAML file provides the spec for the deployment itself, including the number of replicas required, and a template for the Pod objects to be created and managed by the deployment. Note that Deployment objects are managed by the apps API, as specified in apiVersion, rather than the main Kubernetes API.",
    "The spec.selector property is used to match running Pods to the Deployment. The Pod",
    "The spec.selector property is used to match running Pods to the Deployment. The Pod",
    "The template.spec section declares the container to be run. When you",
    "The template.spec section declares the container to be run. When you",
    "By default, Kubernetes will always check for and try to pull a new image. If it can",
    "By default, Kubernetes will always check for and try to pull a new image. If it can",
    "The ports property specifies which container ports should be published on the Pod. The stockservice image runs the service on the standard HTTP port, so port 80 is published.",
    "The ports property specifies which container ports should be published on the Pod. The stockservice image runs the service on the standard HTTP port, so port 80 is published.",
    "The resources section applies resource limits to the container running within the Pod. This is a good practice because it prevents an individual Pod from consuming all the available CPU or memory on a node.",
    "The resources section applies resource limits to the container running within the Pod. This is a good practice because it prevents an individual Pod from consuming all the available CPU or memory on a node.",
    "ASP.NET Core 7.0 has been optimized and tuned to run in resource-limited containers. The dotnet/core/aspnet Docker image sets an environment variable to tell the dotnet runtime that it",
    "ASP.NET Core 7.0 has been optimized and tuned to run in resource-limited containers. The dotnet/core/aspnet Docker image sets an environment variable to tell the dotnet runtime that it",
    "The Service part of the YAML file declares the service that provides access to the Pods within the cluster.",
    "The Service part of the YAML file declares the service that provides access to the Pods within the cluster.",
    "The Service spec uses the selector property to match running Pods, in this case looking for Pods that have a label run: stockdata. The specified port on matching Pods is published by the named service. Other Pods running in the stocks namespace can access HTTP on this service by using http://stockdata as the address. Pods running in other namespaces can use the http://stockdata.stocks host name. You can control cross-namespace service access by using Network Policies.",
    "The Service spec uses the selector property to match running Pods, in this case looking for Pods that have a label run: stockdata. The specified port on matching Pods is published by the named service. Other Pods running in the stocks namespace can access HTTP on this service by using http://stockdata as the address. Pods running in other namespaces can use the http://stockdata.stocks host name. You can control cross-namespace service access by using Network Policies.",
    "Use kubectl to apply the stockdata.yml file and confirm that the Deployment and Service were created:",
    "Use kubectl to apply the stockdata.yml file and confirm that the Deployment and Service were created:",
    "The stockweb.yml file declares the Deployment and Service for the MVC application.",
    "The stockweb.yml file declares the Deployment and Service for the MVC application.",
    "The env section of the Deployment object specifies environment variables to be set in the container that",
    "The env section of the Deployment object specifies environment variables to be set in the container that",
    "The StockData",
    "The StockData",
    "The DOTNET",
    "The DOTNET",
    "If you use an environment variable for the switch, you can easily change the context depending on the context in which the application is running.",
    "If you use an environment variable for the switch, you can easily change the context depending on the context in which the application is running.",
    "The type: NodePort property is used to make the web application accessible from outside the cluster. This property type causes Kubernetes to publish port 80 on the Service to an arbitrary port on the cluster",
    "The type: NodePort property is used to make the web application accessible from outside the cluster. This property type causes Kubernetes to publish port 80 on the Service to an arbitrary port on the cluster",
    "The stockdata Service shouldn",
    "The stockdata Service shouldn",
    "Production systems will most likely use an integrated load balancer to expose public applications to external consumers. Services exposed in this way should use the LoadBalancer type.",
    "Production systems will most likely use an integrated load balancer to expose public applications to external consumers. Services exposed in this way should use the LoadBalancer type.",
    "For more information on Service types, see the Kubernetes Publishing Services documentation.",
    "For more information on Service types, see the Kubernetes Publishing Services documentation.",
    "Use kubectl to apply the stockweb.yml file and confirm that the Deployment and Service were created:",
    "Use kubectl to apply the stockweb.yml file and confirm that the Deployment and Service were created:",
    "The output of the get service command shows that the HTTP port has been published to port 32564 on the external network. For Docker Desktop, this IP address will be localhost. You can access the application by browsing to http://localhost:32564.",
    "The output of the get service command shows that the HTTP port has been published to port 32564 on the external network. For Docker Desktop, this IP address will be localhost. You can access the application by browsing to http://localhost:32564.",
    "Home Page - StockWeb x+",
    "Home Page - StockWeb x+",
    "<",
    "<",
    "\u2022 localhost:32564",
    "\u2022 localhost:32564",
    "StockWeb",
    "StockWeb",
    "Home Privacy",
    "Home Privacy",
    "The StockWeb application displays a list of NASDAQ stocks that are retrieved from a simple requestreply service. For this demonstration, each line also shows the unique ID of the Service instance that returned it. American Airlines Group Inc 83345e3b-7b5e-4ad6-aa84-c2c0a1d83495",
    "The StockWeb application displays a list of NASDAQ stocks that are retrieved from a simple requestreply service. For this demonstration, each line also shows the unique ID of the Service instance that returned it. American Airlines Group Inc 83345e3b-7b5e-4ad6-aa84-c2c0a1d83495",
    "If the number of replicas of the stockdata Service were increased, you might expect the Server value to change from line to line, but in fact all 100 records are always returned from the same instance. If you refresh the page every few seconds, the server ID remains the same. Why does this happen? There are two factors at play here.",
    "If the number of replicas of the stockdata Service were increased, you might expect the Server value to change from line to line, but in fact all 100 records are always returned from the same instance. If you refresh the page every few seconds, the server ID remains the same. Why does this happen? There are two factors at play here.",
    "First, the Kubernetes Service discovery system uses round-robin load balancing by default. The first time the DNS server is queried, it will return the first matching IP address for the Service. The next time, it will return the next IP address in the list, and so on, until the end. At that point, it loops back to the start.",
    "First, the Kubernetes Service discovery system uses round-robin load balancing by default. The first time the DNS server is queried, it will return the first matching IP address for the Service. The next time, it will return the next IP address in the list, and so on, until the end. At that point, it loops back to the start.",
    "Second, the HttpClient used for the StockWeb application",
    "Second, the HttpClient used for the StockWeb application",
    "The result is that by default requests to a gRPC Service aren",
    "The result is that by default requests to a gRPC Service aren",
    "The next chapter, Service meshes, will address this problem.",
    "The next chapter, Service meshes, will address this problem.",
    "Guest",
    "Guest",
    "A service mesh is an infrastructure component that takes control of routing service requests within a network. Service meshes can handle all kinds of network-level concerns within a Kubernetes cluster, including:",
    "A service mesh is an infrastructure component that takes control of routing service requests within a network. Service meshes can handle all kinds of network-level concerns within a Kubernetes cluster, including:",
    "Service discovery",
    "Service discovery",
    "Load balancing",
    "Load balancing",
    "Fault tolerance",
    "Fault tolerance",
    "Encryption",
    "Encryption",
    "Monitoring",
    "Monitoring",
    "Kubernetes service meshes work by adding an extra container, called a sidecar proxy , to each pod included in the mesh. The proxy takes over handling all inbound and outbound network requests. You can then keep the configuration and management of networking matters separate from the application containers. In many cases, this separation d oesn",
    "Kubernetes service meshes work by adding an extra container, called a sidecar proxy , to each pod included in the mesh. The proxy takes over handling all inbound and outbound network requests. You can then keep the configuration and management of networking matters separate from the application containers. In many cases, this separation d oesn",
    "In the previous chapter",
    "In the previous chapter",
    "When you use a service mesh, the requests from the application container are sent to the sidecar proxy. The sidecar proxy can then distribute them intelligently across all instances of the other service. The mesh can also:",
    "When you use a service mesh, the requests from the application container are sent to the sidecar proxy. The sidecar proxy can then distribute them intelligently across all instances of the other service. The mesh can also:",
    "Respond seamlessly to failures of individual instances of a service.",
    "Respond seamlessly to failures of individual instances of a service.",
    "Handle retry semantics for failed calls or timeouts.",
    "Handle retry semantics for failed calls or timeouts.",
    "Reroute failed requests to an alternate instance without returning to the client application.",
    "Reroute failed requests to an alternate instance without returning to the client application.",
    "The following screenshot shows the StockWeb application running with the Linkerd service mesh. There are no changes to the application code, and the Docker image isn",
    "The following screenshot shows the StockWeb application running with the Linkerd service mesh. There are no changes to the application code, and the Docker image isn",
    "E Home Page - StockWeb",
    "E Home Page - StockWeb",
    "<",
    "<",
    "StockWeb",
    "StockWeb",
    "localhost:31700",
    "localhost:31700",
    "Home Privacy",
    "Home Privacy",
    "You can see from the Server column that the requests from the StockWeb application have been routed to both replicas of the StockData service, despite originating from a single HttpClient instance in the application code. In fact, if you review the code, you",
    "You can see from the Server column that the requests from the StockWeb application have been routed to both replicas of the StockData service, despite originating from a single HttpClient instance in the application code. In fact, if you review the code, you",
    "Service meshes apply only to traffic within a cluster. For external clients, see the next chapter, Load Balancing.",
    "Service meshes apply only to traffic within a cluster. For external clients, see the next chapter, Load Balancing.",
    "Three general-purpose service mesh implementations are currently available for use with Kubernetes: Istio, Linkerd, and Consul Connect. All three provide request routing/proxying, traffic encryption, resilience, host-to-host authentication, and traffic control.",
    "Three general-purpose service mesh implementations are currently available for use with Kubernetes: Istio, Linkerd, and Consul Connect. All three provide request routing/proxying, traffic encryption, resilience, host-to-host authentication, and traffic control.",
    "Choosing a service mesh depends on multiple factors:",
    "Choosing a service mesh depends on multiple factors:",
    "The organization",
    "The organization",
    "The nature of the cluster, its size, the number of services deployed, and the volume of traffic within the cluster network.",
    "The nature of the cluster, its size, the number of services deployed, and the volume of traffic within the cluster network.",
    "Ease of deploying and managing the mesh and using it with services.",
    "Ease of deploying and managing the mesh and using it with services.",
    "In this example, you",
    "In this example, you",
    "Guest 8)",
    "Guest 8)",
    "o a ..",
    "o a ..",
    "Windows binaries from the section that lists GitHub releases. Be sure to use the most recent stable release and not one of the edge releases.",
    "Windows binaries from the section that lists GitHub releases. Be sure to use the most recent stable release and not one of the edge releases.",
    "With the Linkerd CLI installed, follow the Getting Started instructions to install the Linkerd components on your Kubernetes cluster. The instructions are straightforward, and the installation should take only a couple of minutes on a local Kubernetes instance.",
    "With the Linkerd CLI installed, follow the Getting Started instructions to install the Linkerd components on your Kubernetes cluster. The instructions are straightforward, and the installation should take only a couple of minutes on a local Kubernetes instance.",
    "The Linkerd CLI provides an inject command to add the necessary sections and properties to Kubernetes files. You can run the command and write the output to a new file.",
    "The Linkerd CLI provides an inject command to add the necessary sections and properties to Kubernetes files. You can run the command and write the output to a new file.",
    "You can inspect the new files to see what changes have been made. For deployment objects, a metadata annotation is added to tell Linkerd to inject a sidecar proxy container into the pod when it",
    "You can inspect the new files to see what changes have been made. For deployment objects, a metadata annotation is added to tell Linkerd to inject a sidecar proxy container into the pod when it",
    "It",
    "It",
    "| linkerd inject stockdata.yml ",
    "| linkerd inject stockdata.yml ",
    "Open the Linkerd dashboard by using the linkerd CLI.",
    "Open the Linkerd dashboard by using the linkerd CLI.",
    "linkerd dashboard",
    "linkerd dashboard",
    "The dashboard provides detailed information about all services that are connected to the mesh.",
    "The dashboard provides detailed information about all services that are connected to the mesh.",
    "LINKERD ",
    "LINKERD ",
    "Overview",
    "Overview",
    "Tap",
    "Tap",
    "Top",
    "Top",
    "=",
    "=",
    "Top Routes",
    "Top Routes",
    "Service Mesh",
    "Service Mesh",
    "Resources",
    "Resources",
    "Documentation",
    "Documentation",
    "Community",
    "Community",
    "Join the Mailing List",
    "Join the Mailing List",
    "Join us on Slack",
    "Join us on Slack",
    "File an Issue",
    "File an Issue",
    "Running Linkerd 2.5.0 (stable).",
    "Running Linkerd 2.5.0 (stable).",
    "Linkerd is up to date.",
    "Linkerd is up to date.",
    "stocks",
    "stocks",
    "Namespace: stocks",
    "Namespace: stocks",
    "If you increase the number of replicas of the StockData gRPC service as shown in the following example, and refresh the StockWeb page in the browser, you should see a mix of IDs in the Server column. This mix indicates that all the available instances are serving requests.",
    "If you increase the number of replicas of the StockData gRPC service as shown in the following example, and refresh the StockWeb page in the browser, you should see a mix of IDs in the Server column. This mix indicates that all the available instances are serving requests.",
    "meshed",
    "meshed",
    "A typical deployment of a gRPC application includes a number of identical instances of the service, providing resilience and horizontal scalability. Load balancing distributes incoming requests across these instances to provide full usage of all available resources. To make this load balancing invisible to the client, it",
    "A typical deployment of a gRPC application includes a number of identical instances of the service, providing resilience and horizontal scalability. Load balancing distributes incoming requests across these instances to provide full usage of all available resources. To make this load balancing invisible to the client, it",
    "Load balancers are classified according to the layer they operate on. Layer 4 load balancers work on the transport level, for example, with TCP sockets, connections, and packets. Layer 7 load balancers work at the application level, specifically handling HTTP/2 requests for gRPC applications.",
    "Load balancers are classified according to the layer they operate on. Layer 4 load balancers work on the transport level, for example, with TCP sockets, connections, and packets. Layer 7 load balancers work at the application level, specifically handling HTTP/2 requests for gRPC applications.",
    "An L4 load balancer accepts a TCP connection request from a client, opens another connection to one of the back-end instances, and copies data between the two connections with no real processing. L4 offers excellent performance and low latency, but with little control or intelligence. As long as the client keeps the connection open, all requests will be directed to the same back-end instance.",
    "An L4 load balancer accepts a TCP connection request from a client, opens another connection to one of the back-end instances, and copies data between the two connections with no real processing. L4 offers excellent performance and low latency, but with little control or intelligence. As long as the client keeps the connection open, all requests will be directed to the same back-end instance.",
    "Azure Load Balancer is an example of an L4 load balancer.",
    "Azure Load Balancer is an example of an L4 load balancer.",
    "An L7 load balancer parses incoming HTTP/2 requests and passes them on to back-end instances on a request-by-request basis, no matter how long the connection is held by the client.",
    "An L7 load balancer parses incoming HTTP/2 requests and passes them on to back-end instances on a request-by-request basis, no matter how long the connection is held by the client.",
    "Examples of L7 load balancers:",
    "Examples of L7 load balancers:",
    "NGINX",
    "NGINX",
    "HAProxy",
    "HAProxy",
    "Traefik",
    "Traefik",
    "As a rule of thumb, L7 load balancers are the best choice for gRPC and other HTTP/2 applications (and for HTTP applications generally, in fact). L4 load balancers will work with gRPC applications, but they",
    "As a rule of thumb, L7 load balancers are the best choice for gRPC and other HTTP/2 applications (and for HTTP applications generally, in fact). L4 load balancers will work with gRPC applications, but they",
    "| Important                                                                                                                                                                 |",
    "| Important                                                                                                                                                                 |",
    "If you",
    "If you",
    "See to the documentation for your preferred load balancer to find out how to configure it to handle HTTP/2 requests with your back-end services.",
    "See to the documentation for your preferred load balancer to find out how to configure it to handle HTTP/2 requests with your back-end services.",
    "See the section on service meshes for a discussion of load balancing across internal services on Kubernetes.",
    "See the section on service meshes for a discussion of load balancing across internal services on Kubernetes.",
    "In production environments like Kubernetes, it",
    "In production environments like Kubernetes, it",
    "Logging is concerned with text messages that record detailed information about things that have happened in the system. Log messages might include exception data, like stack traces, or structured data that provide context about the message. Logging output is commonly written to a searchable text store.",
    "Logging is concerned with text messages that record detailed information about things that have happened in the system. Log messages might include exception data, like stack traces, or structured data that provide context about the message. Logging output is commonly written to a searchable text store.",
    "Metrics refers to numeric data designed to be aggregated and presented by using charts and graphs in a dashboard. The dashboard provides a view of the overall health and performance of an application. Metrics data can also be used to trigger automated alerts when a threshold is exceeded. Here are some examples of metrics data:",
    "Metrics refers to numeric data designed to be aggregated and presented by using charts and graphs in a dashboard. The dashboard provides a view of the overall health and performance of an application. Metrics data can also be used to trigger automated alerts when a threshold is exceeded. Here are some examples of metrics data:",
    "Time taken to process requests.",
    "Time taken to process requests.",
    "The number of requests per second being handled by an instance of a service.",
    "The number of requests per second being handled by an instance of a service.",
    "The number of failed requests on an instance.",
    "The number of failed requests on an instance.",
    "ASP.NET Core provides built-in support for logging, in the form of Microsoft.Extensions.Logging NuGet package. The core parts of this library are included with the Web SDK, so there",
    "ASP.NET Core provides built-in support for logging, in the form of Microsoft.Extensions.Logging NuGet package. The core parts of this library are included with the Web SDK, so there",
    "The ASP.NET Core gRPC framework writes detailed diagnostic logging messages to this logging framework, so they can be processed and stored along with your application",
    "The ASP.NET Core gRPC framework writes detailed diagnostic logging messages to this logging framework, so they can be processed and stored along with your application",
    "The logging extension is automatically registered with ASP.NET Core",
    "The logging extension is automatically registered with ASP.NET Core",
    "Many log messages, such as requests and exceptions, are provided by the ASP.NET Core and gRPC framework components. Add your own log messages to provide detail and context about application logic, rather than lower-level concerns.",
    "Many log messages, such as requests and exceptions, are provided by the ASP.NET Core and gRPC framework components. Add your own log messages to provide detail and context about application logic, rather than lower-level concerns.",
    "For more information about writing log messages and available logging sinks and targets, see Logging in .NET Core and ASP.NET Core.",
    "For more information about writing log messages and available logging sinks and targets, see Logging in .NET Core and ASP.NET Core.",
    "The .NET Core runtime provides a set of components for emitting and observing metrics. These include APIs such as the EventSource and EventCounter classes. These APIs can emit basic numeric data that can be consumed by external processes, like the dotnet-counters global tool, or Event Tracing for Windows. For more information about using EventCounter in your own code, see EventCounter introduction.",
    "The .NET Core runtime provides a set of components for emitting and observing metrics. These include APIs such as the EventSource and EventCounter classes. These APIs can emit basic numeric data that can be consumed by external processes, like the dotnet-counters global tool, or Event Tracing for Windows. For more information about using EventCounter in your own code, see EventCounter introduction.",
    "For more advanced metrics and for writing metric data to a wider range of data stores, you might try an open-source project called App Metrics. This suite of libraries provides an extensive set of types to instrument your code. It also offers packages to write metrics to different kinds of targets that include time-series databases, such as Prometheus and InfluxDB, and Application Insights. The App.Metrics.AspNetCore.Mvc NuGet package even adds a comprehensive set of basic metrics that are automatically generated via integration with the ASP.NET Core framework. The project website provides templates for displaying those metrics with the Grafana visualization platform.",
    "For more advanced metrics and for writing metric data to a wider range of data stores, you might try an open-source project called App Metrics. This suite of libraries provides an extensive set of types to instrument your code. It also offers packages to write metrics to different kinds of targets that include time-series databases, such as Prometheus and InfluxDB, and Application Insights. The App.Metrics.AspNetCore.Mvc NuGet package even adds a comprehensive set of basic metrics that are automatically generated via integration with the ASP.NET Core framework. The project website provides templates for displaying those metrics with the Grafana visualization platform.",
    "Most metrics platforms support the following types:",
    "Most metrics platforms support the following types:",
    "| Metric type   | Description                                                                                                                                                                                                                                                        |",
    "| Metric type   | Description                                                                                                                                                                                                                                                        |",
    "| Metric type   | Description                                                                           |",
    "| Metric type   | Description                                                                           |",
    "By using App Metrics , an IMetrics interface can be obtained via dependency injection, and used to record any of these metrics for a gRPC service. The following example shows how to count the number of Get requests made over time:",
    "By using App Metrics , an IMetrics interface can be obtained via dependency injection, and used to record any of these metrics for a gRPC service. The following example shows how to count the number of Get requests made over time:",
    "The best way to store metrics data is in a time-series database , a specialized data store designed to record numerical data series marked with timestamps. The most popular of these databases are Prometheus and InfluxDB. Microsoft Azure also provides dedicated metrics storage through the Azure Monitor service.",
    "The best way to store metrics data is in a time-series database , a specialized data store designed to record numerical data series marked with timestamps. The most popular of these databases are Prometheus and InfluxDB. Microsoft Azure also provides dedicated metrics storage through the Azure Monitor service.",
    "The current go-to solution for visualizing metrics data is Grafana, which works with a wide range of storage providers. The following image shows an example Grafana dashboard that displays metrics from the Linkerd service mesh running the StockData sample:",
    "The current go-to solution for visualizing metrics data is Grafana, which works with a wide range of storage providers. The following image shows an example Grafana dashboard that displays metrics from the Linkerd service mesh running the StockData sample:",
    "88 Linkerd Deployment - ral deploy/stockdata",
    "88 Linkerd Deployment - ral deploy/stockdata",
    "SUCCESS RATE",
    "SUCCESS RATE",
    "REQUEST RATE",
    "REQUEST RATE",
    "thit",
    "thit",
    "INBOUND DEPLOYMENTS",
    "INBOUND DEPLOYMENTS",
    "\u00a9 Last 5 minutes",
    "\u00a9 Last 5 minutes",
    "OUTBOUND DEPLOYMENTS",
    "OUTBOUND DEPLOYMENTS",
    "100.00%",
    "100.00%",
    "75.00%",
    "75.00%",
    "50.00%",
    "50.00%",
    "25.00%",
    "25.00%",
    "o%",
    "o%",
    "17:43",
    "17:43",
    "17:44",
    "17:44",
    ">",
    ">",
    ">",
    ">",
    "The numerical nature of metrics data means that it",
    "The numerical nature of metrics data means that it",
    "Distributed tracing is a relatively recent development in monitoring, which has arisen from the increasing use of microservices and distributed architectures. A single request from a client browser, application, or device can be broken down into many steps and sub-requests, and involve the use of many services across a network. This activity makes it difficult to correlate log messages and metrics with the specific request that triggered them. Distributed tracing applies identifiers to requests, and allows logs and metrics to be correlated with a particular operation. This tracing is similar to WCF",
    "Distributed tracing is a relatively recent development in monitoring, which has arisen from the increasing use of microservices and distributed architectures. A single request from a client browser, application, or device can be broken down into many steps and sub-requests, and involve the use of many services across a network. This activity makes it difficult to correlate log messages and metrics with the specific request that triggered them. Distributed tracing applies identifiers to requests, and allows logs and metrics to be correlated with a particular operation. This tracing is similar to WCF",
    "Distributed tracing has grown quickly in popularity and is beginning to standardize. The Cloud Native Computing Foundation created the Open Tracing standard, attempting to provide vendor-neutral libraries for working with back ends like Jaeger and Elastic APM. At the same time, Google created the OpenCensus project to address the same set of problems. These two projects are merging into a new project, OpenTelemetry, which aims to be the industry standard of the future.",
    "Distributed tracing has grown quickly in popularity and is beginning to standardize. The Cloud Native Computing Foundation created the Open Tracing standard, attempting to provide vendor-neutral libraries for working with back ends like Jaeger and Elastic APM. At the same time, Google created the OpenCensus project to address the same set of problems. These two projects are merging into a new project, OpenTelemetry, which aims to be the industry standard of the future.",
    "Distributed tracing is based on the concept of spans : named, timed operations that are part of a single trace , which can involve processing on multiple nodes of a system. When a new operation is initiated, a trace is created with a unique identifier. For each sub-operation, a span is created with its own",
    "Distributed tracing is based on the concept of spans : named, timed operations that are part of a single trace , which can involve processing on multiple nodes of a system. When a new operation is initiated, a trace is created with a unique identifier. For each sub-operation, a span is created with its own",
    "identifier and trace identifier. As the request passes around the system, various components can create child spans that include the identifier of their parent . A span has a context , which contains the trace and span identifiers, as well as useful data in the form of key and value pairs (called baggage ).",
    "identifier and trace identifier. As the request passes around the system, various components can create child spans that include the identifier of their parent . A span has a context , which contains the trace and span identifiers, as well as useful data in the form of key and value pairs (called baggage ).",
    ".NET has an internal module that maps well to distributed traces and spans: DiagnosticSource. As well as providing a simple way to produce and consume diagnostics within a process, the DiagnosticSource module has the concept of an activity . An activity is effectively an implementation of a distributed trace, or a span within a trace. The internals of the module take care of parent/child activities, including allocating identifiers. For more information about using the Activity type, see the Activity User Guide on GitHub.",
    ".NET has an internal module that maps well to distributed traces and spans: DiagnosticSource. As well as providing a simple way to produce and consume diagnostics within a process, the DiagnosticSource module has the concept of an activity . An activity is effectively an implementation of a distributed trace, or a span within a trace. The internals of the module take care of parent/child activities, including allocating identifiers. For more information about using the Activity type, see the Activity User Guide on GitHub.",
    "Because DiagnosticSource is a part of the core framework and later, it",
    "Because DiagnosticSource is a part of the core framework and later, it",
    "The ASP.NET Core gRPC client and server libraries include explicit support for DiagnosticSource and Activity, and create activities and apply and use header information automatically.",
    "The ASP.NET Core gRPC client and server libraries include explicit support for DiagnosticSource and Activity, and create activities and apply and use header information automatically.",
    "All of this happens only if a listener is consuming the diagnostic information. If there",
    "All of this happens only if a listener is consuming the diagnostic information. If there",
    "To add your own diagnostics or create explicit spans within your application code, see the DiagnosticSource User Guide and Activity User Guide.",
    "To add your own diagnostics or create explicit spans within your application code, see the DiagnosticSource User Guide and Activity User Guide.",
    "At the time of writing, the OpenTelemetry project is still in the early stages, and only alpha-quality packages are available for .NET applications. The OpenTracing project currently offers more mature libraries.",
    "At the time of writing, the OpenTelemetry project is still in the early stages, and only alpha-quality packages are available for .NET applications. The OpenTracing project currently offers more mature libraries.",
    "The OpenTracing API is described in the following section. If you want to use the OpenTelemetry API in your application instead, refer to the OpenTelemetry .NET SDK repository on GitHub.",
    "The OpenTracing API is described in the following section. If you want to use the OpenTelemetry API in your application instead, refer to the OpenTelemetry .NET SDK repository on GitHub.",
    "The OpenTracing NuGet package supports all OpenTracing-compliant back ends (which can be used independently of DiagnosticSource). There",
    "The OpenTracing NuGet package supports all OpenTracing-compliant back ends (which can be used independently of DiagnosticSource). There",
    "Contributions project, OpenTracing.Contrib.NetCore. This package adds a DiagnosticSource listener, and writes events and activities to a back end automatically. Enabling this package is as simple as installing it from NuGet and adding it as a service in your Program class.",
    "Contributions project, OpenTracing.Contrib.NetCore. This package adds a DiagnosticSource listener, and writes events and activities to a back end automatically. Enabling this package is as simple as installing it from NuGet and adding it as a service in your Program class.",
    "The OpenTracing package is an abstraction layer, and as such it requires implementation specific to the back end. OpenTracing API implementations are available for the following open source back ends.",
    "The OpenTracing package is an abstraction layer, and as such it requires implementation specific to the back end. OpenTracing API implementations are available for the following open source back ends.",
    "| Name        | Package                | Website                 |",
    "| Name        | Package                | Website                 |",
    "For more information on the OpenTracing API for .NET, see the OpenTracing for C# and the OpenTracing Contrib C#/.NET Core repositories on GitHub.",
    "For more information on the OpenTracing API for .NET, see the OpenTracing for C# and the OpenTracing Contrib C#/.NET Core repositories on GitHub.",
    "Windows Communication Foundation (WCF) supports distributed transactions, allowing you to perform atomic operations across multiple services. This functionality is based on the Microsoft Distributed Transaction Coordinator.",
    "Windows Communication Foundation (WCF) supports distributed transactions, allowing you to perform atomic operations across multiple services. This functionality is based on the Microsoft Distributed Transaction Coordinator.",
    "In the newer microservices landscape, this type of automated distributed transaction processing isn",
    "In the newer microservices landscape, this type of automated distributed transaction processing isn",
    "WCF distributed transaction is an implementation of what is known as a two-phase commit (2PC). You can implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service, and sending commit or rollback messages, depending upon success or failure. However, the complexity involved in managing 2PC can increase exponentially as systems evolve. Open transactions hold database locks that can negatively affect performance, or, worse, cause cross-service deadlocks.",
    "WCF distributed transaction is an implementation of what is known as a two-phase commit (2PC). You can implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service, and sending commit or rollback messages, depending upon success or failure. However, the complexity involved in managing 2PC can increase exponentially as systems evolve. Open transactions hold database locks that can negatively affect performance, or, worse, cause cross-service deadlocks.",
    "If possible, it",
    "If possible, it",
    "If that isn",
    "If that isn",
    "Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the .NET Microservices e-book. In particular, using domain events or event sourcing can help to ensure that updates are consistently, if not immediately, applied.",
    "Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the .NET Microservices e-book. In particular, using domain events or event sourcing can help to ensure that updates are consistently, if not immediately, applied."
]