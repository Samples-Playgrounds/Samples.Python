<p>EDITION v7.0 - Updated to ASP.NET Core 7.0</p>
<p><a href="https://aka.ms/grpc-ebook-changelog">Refer changelog</a> for the book updates and community contributions.</p>
<p>PUBLISHED BY</p>
<p>Microsoft Developer Division, .NET, and Visual Studio product teams</p>
<p>A division of Microsoft Corporation</p>
<p>One Microsoft Way</p>
<p>Redmond, Washington 98052-6399</p>
<p>Copyright © 2023 by Microsoft Corporation</p>
<p>All rights reserved. No part of the contents of this book may be reproduced or transmitted in any<br />
form or by any means without the written permission of the publisher.</p>
<p>This book is provided “as-is” and expresses the author’s views and opinions. The views, opinions and<br />
information expressed in this book, including URL and other Internet website references, may change<br />
without notice.</p>
<p>Some examples depicted herein are provided for illustration only and are fictitious. No real association<br />
or connection is intended or should be inferred.</p>
<p><a href="https://www.microsoft.com/">Microsoft and the trademarks listed at https://www.microsoft.com</a> on the “Trademarks” webpage are<br />
trademarks of the Microsoft group of companies.</p>
<p>The Docker whale logo is a registered trademark of Docker, Inc. Used by permission.</p>
<p>All other marks and logos are property of their respective owners.</p>
<p>Authors:</p>
<p><strong>Mark Rendle</strong> <a href="https://visualrecode.com/">- Chief Technical Officer - Visual Recode</a></p>
<p><strong>Miranda Steiner</strong> - Technical Author</p>
<p>Editor:</p>
<p><strong>Maira Wenzel</strong> - Sr. Content Developer - Microsoft</p>
<h3>Introduction</h3>
<p>gRPC is a modern framework for building networked services and distributed applications. Imagine<br />
the performance of Windows Communication Foundation (WCF) NetTCP bindings, combined with the<br />
cross-platform interoperability of SOAP. gRPC builds on HTTP/2 and the Protobuf message-encoding<br />
protocol to provide high performance, low-bandwidth communication between applications and<br />
services. It supports server and client code generation across most popular programming languages<br />
and platforms, including .NET, Java, Python, Node.js, Go, and C++. With the first-class support for<br />
gRPC in ASP.NET Core 7.0, alongside the existing gRPC tools and libraries for .NET Framework 4.x, it’s<br />
an excellent alternative to WCF for development teams looking to adopt .NET in their organizations.</p>
<h3>Who should use this guide</h3>
<p>This guide was written for developers working in .NET Framework or .NET who have previously used<br />
WCF, and who are seeking to migrate their applications to a modern RPC environment for .NET Core<br />
3.0 and later versions. More generally, if you are upgrading, or considering upgrading, to .NET 7, and<br />
you want to use the built-in gRPC tools, this guide is also useful.</p>
<h3>How you can use this guide</h3>
<p>This is a short introduction to building gRPC Services in ASP.NET Core 7.0, with particular reference to<br />
WCF as an analogous platform. It explains the principles of gRPC, relating each concept to the<br />
equivalent features of WCF, and offers guidance for migrating an existing WCF application to gRPC.<br />
It’s also useful for developers who have experience with WCF and are looking to learn gRPC to build<br />
new services. You can use the sample applications as a template or reference for your own projects,<br />
and you are free to copy and reuse code from the book or its samples.</p>
<p>Feel free to forward this guide to your team to help ensure a common understanding of these<br />
considerations and opportunities. Having everybody working from a common set of terms and<br />
underlying principles helps ensure consistent application of architectural patterns and practices.</p>
<h3>References</h3>
<ul>
<li>
<p><strong>gRPC website</strong> <a href="https://grpc.io/">https://grpc.io</a></p>
</li>
<li>
<p><strong>Choosing between .NET 5 and .NET Framework for server apps</strong><br />
<a href="https://docs.microsoft.com/dotnet/standard/choosing-core-framework-server">https://learn.microsoft.com/dotnet/standard/choosing-core-framework-server</a></p>
</li>
</ul>
<h2>Contents</h2>
<p><strong>Introduction to gRPC for WCF developers ........................................................................... 1</strong></p>
<p>History .......................................................................................................................................................................................... 1</p>
<p>Microservices ............................................................................................................................................................................. 2</p>
<p>About this guide ....................................................................................................................................................................... 3</p>
<p>Who this guide is for .............................................................................................................................................................. 3</p>
<p><strong>gRPC overview ......................................................................................................................... 4</strong></p>
<p>Key principles ............................................................................................................................................................................ 4</p>
<p>How gRPC approaches RPC ................................................................................................................................................. 5</p>
<p>Interface Definition Language ............................................................................................................................................ 6</p>
<p>Network protocols ................................................................................................................................................................... 7</p>
<p>Key features of HTTP/2 ..................................................................................................................................................... 7</p>
<p>Why we recommend gRPC for WCF developers ......................................................................................................... 8</p>
<p>Similarity to WCF ................................................................................................................................................................. 8</p>
<p>Benefits of gRPC .................................................................................................................................................................. 8</p>
<p>Comparison with CoreWCF ............................................................................................................................................. 9</p>
<p><strong>Protocol buffers ..................................................................................................................... 11</strong></p>
<p>How Protobuf works ............................................................................................................................................................ 11</p>
<p>Protobuf messages ............................................................................................................................................................... 11</p>
<p>Declaring a message ....................................................................................................................................................... 11</p>
<p>Field numbers .................................................................................................................................................................... 12</p>
<p>Types ..................................................................................................................................................................................... 13</p>
<p>The generated code ........................................................................................................................................................ 13</p>
<p>Protobuf scalar data types ................................................................................................................................................ 13</p>
<p>Other .NET primitive types ........................................................................................................................................... 14</p>
<p>Decimals ............................................................................................................................................................................... 16</p>
<p>Protobuf nested types ........................................................................................................................................................ 17</p>
<p>Repeated fields for lists and arrays ................................................................................................................................ 18</p>
<p>Protobuf reserved fields ..................................................................................................................................................... 18</p>
<p>i Contents</p>
<p>Protobuf Any and Oneof fields for variant types ..................................................................................................... 19</p>
<p>Any ......................................................................................................................................................................................... 19</p>
<p>Oneof .................................................................................................................................................................................... 20</p>
<p>Protobuf enumerations ...................................................................................................................................................... 21</p>
<p>Protobuf maps for dictionaries ........................................................................................................................................ 22</p>
<p>Using MapField properties in code ........................................................................................................................... 22</p>
<p>Further reading ................................................................................................................................................................. 23</p>
<p><strong>Comparing WCF to gRPC ...................................................................................................... 24</strong></p>
<p>gRPC example ........................................................................................................................................................................ 24</p>
<p>WCF endpoints and gRPC methods .............................................................................................................................. 25</p>
<p>OperationContract properties ..................................................................................................................................... 25</p>
<p>WCF bindings and transports .......................................................................................................................................... 26</p>
<p>NetTCP .................................................................................................................................................................................. 26</p>
<p>HTTP ...................................................................................................................................................................................... 27</p>
<p>Named pipes ...................................................................................................................................................................... 27</p>
<p>MSMQ ................................................................................................................................................................................... 27</p>
<p>WebHttpBinding ............................................................................................................................................................... 27</p>
<p>Types of RPC ........................................................................................................................................................................... 27</p>
<p>Request/reply..................................................................................................................................................................... 28</p>
<p>WCF duplex, one way to client ................................................................................................................................... 28</p>
<p>WCF one-way operations and gRPC client streaming ...................................................................................... 30</p>
<p>WCF full-duplex services ............................................................................................................................................... 31</p>
<p>Metadata .................................................................................................................................................................................. 32</p>
<p>Error handling ......................................................................................................................................................................... 33</p>
<p>Raise errors in ASP.NET Core gRPC .......................................................................................................................... 34</p>
<p>Catch errors in gRPC clients ......................................................................................................................................... 34</p>
<p>gRPC richer error model ................................................................................................................................................ 35</p>
<p>WS-* protocols....................................................................................................................................................................... 35</p>
<p>Metadata exchange: WS-Policy, WS-Discovery, and so on ............................................................................. 35</p>
<p>Security: WS-Security, WS-Federation, XML Encryption, and so on ............................................................ 35</p>
<p>WS-ReliableMessaging .................................................................................................................................................. 36</p>
<p>WS-Transaction, WS-Coordination ........................................................................................................................... 36</p>
<p>ii Contents</p>
<p><strong>Migrate a WCF solution to gRPC ......................................................................................... 37</strong></p>
<p>Create a new ASP.NET Core gRPC project .................................................................................................................. 37</p>
<p>Create the project by using Visual Studio .............................................................................................................. 37</p>
<p>Create the project by using the .NET CLI ................................................................................................................ 40</p>
<p>Clean up the example code ......................................................................................................................................... 41</p>
<p>Migrate a WCF request-reply service to a gRPC unary RPC ................................................................................ 42</p>
<p>The WCF solution ............................................................................................................................................................. 42</p>
<p>The portfolios.proto file ................................................................................................................................................. 44</p>
<p>Convert the DataContract classes to gRPC messages ....................................................................................... 44</p>
<p>Convert ServiceContract to a gRPC service ........................................................................................................... 45</p>
<p>Migrate the PortfolioData library to .NET ............................................................................................................... 46</p>
<p>Use ASP.NET Core dependency injection ............................................................................................................... 47</p>
<p>Implement the gRPC service........................................................................................................................................ 48</p>
<p>Generate client code ....................................................................................................................................................... 50</p>
<p>Migrate WCF duplex services to gRPC ......................................................................................................................... 53</p>
<p>Server streaming RPC ..................................................................................................................................................... 53</p>
<p>Bidirectional streaming .................................................................................................................................................. 58</p>
<p>gRPC streaming services vs. repeated fields .............................................................................................................. 63</p>
<p>When to use repeated fields........................................................................................................................................ 63</p>
<p>When to use stream methods ..................................................................................................................................... 64</p>
<p>Create gRPC client libraries ............................................................................................................................................... 64</p>
<p>Useful extensions ............................................................................................................................................................. 65</p>
<p>Summary .............................................................................................................................................................................. 67</p>
<p><strong>Security in gRPC applications .............................................................................................. 68</strong></p>
<p>WCF authentication and authorization ........................................................................................................................ 68</p>
<p>gRPC authentication and authorization ....................................................................................................................... 68</p>
<p>Call credentials ....................................................................................................................................................................... 69</p>
<p>WS-Federation .................................................................................................................................................................. 69</p>
<p>JWT Bearer tokens ........................................................................................................................................................... 69</p>
<p>Add authentication and authorization to the server.......................................................................................... 70</p>
<p>Provide call credentials in the client application ................................................................................................. 71</p>
<p>Channel credentials .............................................................................................................................................................. 72</p>
<p>iii Contents</p>
<p>Add certificate authentication to the server .......................................................................................................... 72</p>
<p>Provide channel credentials in the client application ........................................................................................ 73</p>
<p>Combine ChannelCredentials and CallCredentials ............................................................................................. 74</p>
<p>Encryption and network security .................................................................................................................................... 75</p>
<p><strong>gRPC in production ............................................................................................................... 77</strong></p>
<p>Self-hosted gRPC applications ........................................................................................................................................ 77</p>
<p>Run your app as a Windows service ......................................................................................................................... 77</p>
<p>Run your app as a Linux service with systemd ..................................................................................................... 78</p>
<p>HTTPS certificates for self-hosted applications .................................................................................................... 80</p>
<p>Create Docker images ......................................................................................................................................................... 81</p>
<p>Microsoft base images for ASP.NET Core applications ..................................................................................... 81</p>
<p>Create a Docker image .................................................................................................................................................. 82</p>
<p>Build the image ................................................................................................................................................................. 84</p>
<p>Run the image in a container on your machine .................................................................................................. 84</p>
<p>Push the image to a registry ........................................................................................................................................ 84</p>
<p>Kubernetes ............................................................................................................................................................................... 85</p>
<p>Kubernetes terminology ................................................................................................................................................ 85</p>
<p>Get started with Kubernetes ........................................................................................................................................ 86</p>
<p>Run services on Kubernetes ......................................................................................................................................... 87</p>
<p>Service meshes ....................................................................................................................................................................... 93</p>
<p>Service mesh options ...................................................................................................................................................... 94</p>
<p>Example: Add Linkerd to a deployment .................................................................................................................. 94</p>
<p>Load balancing gRPC .......................................................................................................................................................... 97</p>
<p>L4 load balancers ............................................................................................................................................................. 97</p>
<p>L7 load balancers ............................................................................................................................................................. 97</p>
<p>Load balancing within Kubernetes ............................................................................................................................ 98</p>
<p>Application Performance Management ....................................................................................................................... 98</p>
<p>The difference between logging and metrics ....................................................................................................... 98</p>
<p>Logging in ASP.NET Core gRPC ................................................................................................................................. 98</p>
<p>Metrics in ASP.NET Core gRPC ................................................................................................................................... 99</p>
<p>Distributed tracing ......................................................................................................................................................... 101</p>
<p><strong>Appendix A - Transactions ................................................................................................. 104</strong></p>
<p>iv Contents</p>
<p><strong>CHAPTER</strong></p>
<h1>1</h1>
<h2>Introduction to gRPC for WCF developers</h2>
<p>Helping machines communicate with each other has been one of the primary preoccupations of the<br />
digital age. In particular, there’s an ongoing effort to determine the optimal remote communication<br />
mechanism that will suit the interoperability demands of the current infrastructure. As you can<br />
imagine, that mechanism changes as either the demands or the infrastructure evolves.</p>
<p>The release of .NET Core 3.0 marks a shift in the way that Microsoft delivers remote communication<br />
solutions to developers who want to deliver services across a range of platforms. .NET Core and later<br />
doesn’t offer Windows Communication Foundation (WCF) out of the box but, with the release of<br />
ASP.NET Core 3.0, it does provide built-in gRPC functionality.</p>
<p>gRPC is a popular framework in the wider software community. It’s used by developers across many<br />
programming languages for modern RPC scenarios. The community and the ecosystem are vibrant<br />
and active. Support for the gRPC protocol is being added to infrastructure components like<br />
Kubernetes, service meshes, load balancers, and more. These factors, together with its performance,<br />
efficiency, and cross-platform compatibility, make gRPC a natural choice for new apps and WCF apps<br />
moving to .NET.</p>
<h3>History</h3>
<p>The fundamental principle of a computer network as nothing more than a group of computers<br />
exchanging data with each other to achieve a set of interrelated tasks hasn’t changed since its<br />
inception. But the complexity, scale, and expectations have grown exponentially.</p>
<p>During the 1990s, the emphasis was mainly on improving internal networks that used the same<br />
language and platforms. TCP/IP became the gold standard for this type of communication.</p>
<p>The focus soon shifted to how best to optimize communication across multiple platforms by<br />
promoting a language-agnostic approach. Service-oriented architecture (SOA) provided a structure<br />
for loosely coupling a broad collection of services that could be provided to an application.</p>
<p>The development of <em>web services</em> occurred when all major platforms could access the internet, but<br />
they still couldn’t interact with each other. Web services have open standards and protocols,<br />
including:</p>
<ul>
<li>XML to tag and code data.</li>
</ul>
<p>1 CHAPTER 1 | Introduction to gRPC for WCF developers</p>
<ul>
<li>
<p>Simple Object Access Protocol (SOAP) to transfer data.</p>
</li>
<li>
<p>Web Services Definition Language (WSDL) to describe and connect web services to client<br />
applications.</p>
</li>
<li>
<p>Universal Description, Discovery, and Integration (UDDI) to make web services discoverable by<br />
other services.</p>
</li>
</ul>
<p>SOAP defines the rules by which distributed elements of an application can communicate with each<br />
other, even if they’re on different platforms. SOAP is based on XML, so it’s human-readable. The<br />
sacrifice for making SOAP easily understood is size; SOAP messages are larger than messages in<br />
comparable protocols. SOAP was designed to break monolithic applications into multicomponent<br />
form without losing security or control. So WCF was designed to work with that kind of system, unlike<br />
gRPC, which began as a distributed system. WCF addressed some of these limitations by developing<br />
and documenting proprietary extension protocols for the SOAP stack, but at the cost of a lack of<br />
support from other platforms.</p>
<p>Windows Communication Foundation is a framework for building services. It was designed in the early<br />
2000s to help developers using early SOA to manage the complexities of working with SOAP.<br />
Although it removes the requirement for the developers to write their own SOAP protocols, WCF still<br />
uses SOAP to enable interoperability with other systems. WCF was also designed to deliver solutions<br />
across multiple protocols (HTTP/1.1, Net.TCP, and so on).</p>
<h3>Microservices</h3>
<p>In microservice architectures, large applications are built as a collection of smaller modular services.<br />
Each component does a specific task or process, and components are designed to work interoperably<br />
but can be isolated as necessary.</p>
<p>Advantages to microservices include:</p>
<ul>
<li>
<p>Changes and upgrades can be handled independently.</p>
</li>
<li>
<p>Error handling becomes more efficient because problems can be traced to specific services<br />
that are then isolated, rebuilt, tested, and redeployed independently of the other services.</p>
</li>
<li>
<p>Scalability can be confined to specific instances or services rather than the whole application.</p>
</li>
<li>
<p>Development can happen across multiple teams, with less friction than occurs when many<br />
teams work on a single codebase.</p>
</li>
</ul>
<p>The move towards increasing virtualization, cloud computing, containers, and the Internet of Things<br />
has contributed to the ongoing rise of microservices. But microservices aren’t without their challenges.<br />
The fragmented/decentralized infrastructure put more emphasis on the need for simplicity and speed<br />
when communicating between services. This in turn drew attention to the sometimes laborious and<br />
contorted nature of SOAP.</p>
<p>It was into this environment that gRPC was launched, 10 years after Microsoft first released WCF.<br />
Evolved directly from Google’s internal infrastructure RPC (Stubby), gRPC was never based on the<br />
same standards and protocols that had informed the parameters of many earlier RPCs. And gRPC was<br />
only ever based on HTTP/2. That’s why it could draw on the new capabilities that advanced transport<br />
protocol provided. In particular, bidirectional streaming, binary messaging, and multiplexing.</p>
<p>2 CHAPTER 1 | Introduction to gRPC for WCF developers</p>
<h3>About this guide</h3>
<p>This guide covers the key features of gRPC. The early chapters take a high-level look at the main<br />
features of WCF and compare them to those of gRPC. It identifies where there are direct correlations<br />
between WCF and gRPC and also where gRPC offers an advantage. When there’s no correlation<br />
between WCF and gRPC, or when gRPC isn’t able to offer an equivalent solution to WCF, this guide<br />
will suggest workarounds or where to go for more information.</p>
<p>Using a set of sample WCF applications, Chapter 5 is a deep-dive look at converting the main types of<br />
WCF service (simple request-reply, one-way, and streaming) to their equivalents in gRPC.</p>
<p>The final section of the book looks at how to get the best from gRPC in practice. This section includes<br />
information on using additional tools, like Docker containers or Kubernetes, to take advantage of the<br />
efficiency of gRPC. It also includes a detailed look at monitoring with logging, metrics, and distributed<br />
tracing.</p>
<h3>Who this guide is for</h3>
<p>This guide was written for developers working in .NET Framework or .NET Core who have used WCF<br />
and who are seeking to migrate their applications to a modern RPC environment for .NET Core 3.0<br />
and later versions. The guide might also be useful more generally for developers upgrading or<br />
considering upgrading to .NET and who want to use the built-in gRPC tools.</p>
<p>3 CHAPTER 1 | Introduction to gRPC for WCF developers</p>
<p><strong>CHAPTER</strong></p>
<h1>2</h1>
<h2>gRPC overview</h2>
<p>After looking at the genesis of both Windows Communication Foundation (WCF) and gRPC in the last<br />
chapter, this chapter considers some of the key features of gRPC and how they compare to WCF.</p>
<p>ASP.NET Core 3.0 is the first release of ASP.NET that natively supports gRPC as a first-class citizen,<br />
with Microsoft teams contributing to the official .NET implementation of gRPC. It’s recommended for<br />
building distributed applications with .NET that can interoperate with all other major programming<br />
languages and frameworks.</p>
<h3>Key principles</h3>
<p>As discussed in chapter 1, Google wanted to use the introduction of HTTP/2 to replace Stubby, its<br />
internal, general purpose RPC infrastructure. gRPC, based on Stubby, now can take advantage of<br />
standardization and would extend its applicability to mobile computing, the cloud, and the Internet of<br />
Things.</p>
<p><a href="https://www.cncf.io/">To achieve this standardization, the Cloud Native Computing Foundation (CNCF)</a> established a set of<br />
principles that would govern gRPC. The following list shows the most relevant ones, which are<br />
primarily concerned with maximizing accessibility and usability:</p>
<ul>
<li>
<p><strong>Free and open</strong>  - All artifacts should be open source, with licensing that doesn’t constrain<br />
developers from adopting gRPC.</p>
</li>
<li>
<p><strong>Coverage and simplicity</strong>  - gRPC should be available across every popular platform, and<br />
simple enough to build on any platform.</p>
</li>
<li>
<p><strong>Interoperability and reach</strong>  - It should be possible to use gRPC on any network, regardless of<br />
bandwidth or latency, by using widely available network standards.</p>
</li>
<li>
<p><strong>General purpose and performant</strong>  - The framework should be usable by as broad a range of<br />
use-cases as possible, without compromising performance.</p>
</li>
<li>
<p><strong>Streaming</strong>  - The protocol should provide streaming semantics for large datasets or<br />
asynchronous messaging.</p>
</li>
<li>
<p><strong>Metadata exchange</strong>  - The protocol allows non-business data, such as authentication tokens,<br />
to be handled separately from actual business data.</p>
</li>
<li>
<p><strong>Standardized status codes</strong>  - The variability of error codes should be reduced to make error<br />
handling decisions clearer. Where additional, richer error handling is required, a mechanism<br />
should be provided for managing behavior within the metadata exchange.</p>
</li>
</ul>
<p>4 CHAPTER 2 | gRPC overview</p>
<h3>How gRPC approaches RPC</h3>
<p>Windows Communication Foundation (WCF) and gRPC are both implementations of the <em>Remote</em><br />
<em>Procedure Call</em> (RPC) pattern. This pattern aims to make calls to services that run on a different<br />
machine, or in a different process, work seamlessly, like method calls in the client application. While<br />
the aims of WCF and gRPC are the same, the details of the implementation are quite different.</p>
<p>The following table sets out how the key features of WCF relate to gRPC, and where you can find</p>
<table>
<thead>
<tr>
<th>more detailed explanations.</th>
<th>Col2</th>
<th>Col3</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Features</strong></td>
<td><strong>WCF</strong></td>
<td><strong>gRPC</strong></td>
</tr>
<tr>
<td>Objective</td>
<td>Separate business<br>code from<br>networking<br>implementation.</td>
<td>Separate business code<br>from interface definition<br>and networking<br>implementation.</td>
</tr>
<tr>
<td>Define services and messages (chapters 3-4)</td>
<td>Service Contract,<br>Operation<br>Contract, and<br>Data Contract.</td>
<td>Uses proto file to<br>declare services and<br>messages.</td>
</tr>
<tr>
<td>Language (chapters 3-5)</td>
<td>Contracts written<br>in C# or Visual<br>Basic.</td>
<td>Protocol Buffer<br>language.</td>
</tr>
<tr>
<td>Wire format (chapter 3)</td>
<td>Configurable,<br>including<br>SOAP/XML, Plain<br>XML, JSON, and<br>.NET Binary.</td>
<td>Protocol Buffer binary<br>format (although it’s<br>possible to use other<br>formats).</td>
</tr>
<tr>
<td>Interoperability (chapter 4)</td>
<td>When using<br>SOAP over HTTP.</td>
<td>Official support: .NET,<br>Java, Python, JavaScript,<br>C/C++, Go, Rust, Ruby,<br>Swift, Dart, PHP.<br>Unofficial support for<br>other languages from<br>the community.</td>
</tr>
<tr>
<td>Networking (chapter 4)</td>
<td>Configured at run<br>time. Switch<br>between NetTCP,<br>HTTP, and<br>MSMQ.</td>
<td>HTTP/2, currently over<br>TCP only with ASP.NET<br>Core gRPC.</td>
</tr>
</tbody>
</table>
<p>5 CHAPTER 2 | gRPC overview</p>
<table>
<thead>
<tr>
<th>Features</th>
<th>WCF</th>
<th>gRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Approach (chapter 4)</td>
<td>Runtime<br>generation of<br>serialization,<br>deserialization,<br>and networking<br>code in base<br>classes.</td>
<td>Build-time generation of<br>serialization,<br>deserialization, and<br>networking code in base<br>classes.</td>
</tr>
<tr>
<td>Security (chapter 6)</td>
<td>Authentication,<br>WS-Security,<br>message<br>encryption.</td>
<td>Credentials, ASP.NET<br>Core security, TLS<br>networking.</td>
</tr>
</tbody>
</table>
<h3>Interface Definition Language</h3>
<p>With Windows Communication Foundation (WCF), services can expose description metadata by using<br />
the Web Service Definition Language (WSDL). WSDL is generated dynamically by using .NET reflection<br />
at run time. Developers can use this metadata to generate clients for those services, potentially in<br />
other languages if they’re using a platform-neutral binding such as SOAP over HTTP.</p>
<p>gRPC uses the Interface Definition Language (IDL) from Protocol Buffers. The Protocol Buffers IDL is a<br />
custom, platform-neutral language with an open specification. Developers author .proto files to<br />
describe services, along with their inputs and outputs. These .proto files can then be used to generate<br />
language- or platform-specific stubs for clients and servers, allowing multiple different platforms to<br />
communicate. By sharing .proto files, teams can generate code to use each others’ services, without<br />
needing to take a code dependency.</p>
<p>One of the advantages of the Protobuf IDL is that as a custom language, it enables gRPC to be<br />
completely language and platform agnostic, not favoring any technology over another.</p>
<p>The Protobuf IDL is also designed for humans to both read and write, whereas WSDL is intended as a<br />
machine-readable/writable format. Changing the WSDL of a WCF service typically requires changing<br />
the service, running the service, and regenerating the WSDL file from the server. By contrast, with a<br />
.proto file, changes are simple to apply with a text editor, and automatically flow through the<br />
generated code. Visual Studio 2022 builds .proto files in the background when they are saved. With<br />
other editors, such as VS Code, the changes are applied when the project is built.</p>
<p>When compared with XML, and particularly SOAP, messages encoded by using Protobuf have many<br />
advantages. Protobuf messages tend to be smaller than the same data serialized as SOAP XML, and<br />
encoding, decoding, and transmitting them over a network can be faster.</p>
<p>The potential disadvantage of Protobuf compared to SOAP is that, because the messages aren’t<br />
readable by humans, additional tooling is required to debug message content.</p>
<p>6 CHAPTER 2 | gRPC overview</p>
<h3>Network protocols</h3>
<p>Unlike Windows Communication Foundation (WCF), gRPC uses HTTP/2 as a base for its networking.<br />
This protocol offers significant advantages over WCF and SOAP, which operate only on HTTP/1.1. For<br />
developers wanting to use gRPC, given that there’s no alternative to HTTP/2, it would seem to be the<br />
ideal moment to explore HTTP/2 in more detail and identify additional benefits of using gRPC.</p>
<p>HTTP/2, released by Internet Engineering Task Force in 2015, was derived from the experimental SPDY<br />
protocol, which was already being used by Google. It was specifically designed to be more efficient,<br />
faster, and more secure than HTTP/1.1.</p>
<h4><strong>Key features of HTTP/2</strong></h4>
<p>This list shows some of the key features and advantages of HTTP/2:</p>
<p><strong>Binary protocol</strong></p>
<p>Request/response cycles no longer need text commands. This activity simplifies and speeds up the<br />
implementation of commands. Specifically, parsing data is faster and uses less memory, network<br />
latency is reduced with obvious related improvements to speed, and there’s an overall better use of<br />
network resources.</p>
<p><strong>Streams</strong></p>
<p>Streams allow you to create long-lived connections between sender and receiver, over which multiple<br />
messages or frames can be sent asynchronously. Multiple streams can operate independently over a<br />
single HTTP/2 connection.</p>
<p><strong>Request multiplexing over a single TCP connection</strong></p>
<p>This feature is one of the most important innovations of HTTP/2. Because it allows multiple parallel<br />
requests for data, it’s now possible to download web files concurrently from a single server. Websites<br />
load faster, and the need for optimization is reduced. Head-of-line (HOL) blocking, where responses</p>
<p>7 CHAPTER 2 | gRPC overview</p>
<p>that are ready must wait to be sent until an earlier request is completed, is also mitigated (although<br />
HOL blocking can still occur at the TCP-transport level).</p>
<p><strong>Net.TCP-like performance, cross-platform</strong></p>
<p>Fundamentally, the combination of gRPC and HTTP/2 offers developers at least the equivalent speed<br />
and efficiency of Net.TCP bindings for WCF, and in some cases even greater speed and efficiency. But,<br />
unlike Net.TCP, gRPC over HTTP/2 isn’t constrained to .NET applications.</p>
<h3>Why we recommend gRPC for WCF developers</h3>
<p>Before we dive deeply into the language and techniques of gRPC, it’s worth discussing why gRPC is<br />
the right solution for Windows Communication Foundation (WCF) developers who want to migrate to<br />
.NET.</p>
<h4><strong>Similarity to WCF</strong></h4>
<p>Although the implementation and approach are different for gRPC, the experience of developing and<br />
consuming services with gRPC should be intuitive for WCF developers. The underlying goal is the<br />
same: make it possible to code as though the client and server are on the same platform, without<br />
needing to worry about networking.</p>
<p>Both platforms share the principle of declaring and then implementing an interface, even though the<br />
process for declaring that interface is different. And as you’ll see in chapter 5, the different types of<br />
RPC calls that gRPC supports map well to the bindings available to WCF services.</p>
<h4><strong>Benefits of gRPC</strong></h4>
<p>gRPC stands above other solutions for the following reasons.</p>
<p><strong>Performance</strong></p>
<p>Using HTTP/2 rather than HTTP/1.1 removes the requirement for human-readable messages and<br />
instead uses the smaller, faster binary protocol. This is more efficient for computers to parse. HTTP/2<br />
also supports multiplexing requests over a single connection. This support enables responses to be<br />
sent as soon as they’re ready without the need to wait in a queue. (In HTTP/1.1, this issue is known as<br />
“head-of-line (HOL) blocking.”) You need fewer resources when using gRPC, which makes it a good<br />
solution to use for mobile devices and over slower networks.</p>
<p><strong>Interoperability</strong></p>
<p>There are gRPC tools and libraries for all major programming languages and platforms, including<br />
.NET, Java, Python, Go, C++, Node.js, Swift, Dart, Ruby, and PHP. Thanks to the Protocol Buffers binary<br />
wire format and the efficient code generation for each platform, developers can build performant<br />
apps while still enjoying full cross-platform support.</p>
<p>8 CHAPTER 2 | gRPC overview</p>
<p><strong>Usability and productivity</strong></p>
<p>gRPC is a comprehensive RPC solution. It works consistently across multiple languages and platforms.<br />
It also provides excellent tooling, with much of the necessary boilerplate code automatically<br />
generated. So more developer time is freed up to focus on business logic.</p>
<p><strong>Streaming</strong></p>
<p>gRPC has full bidirectional streaming, which provides similar functionality to WCF’s full-duplex<br />
services. gRPC streaming can operate over regular internet connections, load balancers, and service<br />
meshes.</p>
<p><strong>Deadline/timeouts and cancellation</strong></p>
<p>gRPC allows clients to specify a maximum time for an RPC to finish. If the specified deadline is<br />
exceeded, the server can cancel the operation independently of the client. Deadlines and cancellations<br />
can be propagated through further gRPC calls to help enforce resource usage limits. Clients can also<br />
stop operations when a deadline is exceeded, or earlier if necessary (for example, because of a user<br />
interaction).</p>
<p><strong>Security</strong></p>
<p>gRPC is implicitly secure when it’s using HTTP/2 over a TLS end-to-end encrypted connection. Support<br />
for client certificate authentication (see chapter 6) further increases security and trust between client<br />
and server.</p>
<h4><strong>Comparison with CoreWCF</strong></h4>
<p><a href="https://github.com/corewcf/corewcf">A notable alternative to gRPC for replacing WCF services when migrating to .NET is CoreWCF. Both</a><br />
gRPC and CoreWCF are Microsoft endorsed paths forward for WCF applications and each comes with<br />
its own benefits and drawbacks.</p>
<p>CoreWCF is a community-owned .NET Foundation project supported by Microsoft that implements<br />
WCF server APIs for .NET. CoreWCF is an effort to allow existing WCF services to work with minimal<br />
changes on .NET. Your Data Contracts for WCF are unchanged with CoreWCF, and it supports many of<br />
the bindings and APIs from WCF. The main differences are around the patterns for starting WCF<br />
services, and not all configuration options are available (some configuration must now be done in<br />
code).</p>
<p>Services and interfaces can often migrate with few changes. Because of this, a key benefit of CoreWCF<br />
is its very high compatibility with WCF. Where changes have been made, they are to adapt to the<br />
programming style of modern .NET, for example hosting now through ASP.NET Core, and APIs now<br />
use the Task based async patterns usable with await rather than the older BeginXXX / EndXXX pattern.</p>
<p>On the other hand, gRPC is a modern remote communication solution with a number of features, as<br />
discussed previously. Benefits of using gRPC include better interoperability across languages, its<br />
relatively simple modern API, and a broad community ecosystem.</p>
<p>When deciding whether to use CoreWCF or gRPC to migrate a WCF application to .NET, CoreWCF is<br />
typically a better fit if the goal is to migrate the application with minimal changes whereas gRPC may</p>
<p>9 CHAPTER 2 | gRPC overview</p>
<p>be a better fit if the goal is to modernize the application while retargeting to .NET. The remainder of<br />
this guide focuses on that modernization with gRPC.</p>
<p>10 CHAPTER 2 | gRPC overview</p>
<p><strong>CHAPTER</strong></p>
<h1>3</h1>
<h2>Protocol buffers</h2>
<p>gRPC services send and receive data as <em>Protocol Buffer (Protobuf) messages</em>, similar to data contracts in<br />
Windows Communication Foundation (WCF). Protobuf is an efficient way of serializing structured data<br />
for machines to read and write, without the overhead that human-readable formats like XML or JSON<br />
incur.</p>
<p>This chapter covers how Protobuf works, and how to define your own Protobuf messages.</p>
<h3>How Protobuf works</h3>
<p>Most .NET object serialization techniques, including WCF’s data contracts, work by using reflection to<br />
analyze the object structure at run time. By contrast, most Protobuf libraries require you to define the<br />
structure up front by using a dedicated language ( <em>Protocol Buffer Language</em> ) in a .proto file. A compiler<br />
then uses this file to generate code for any of the supported platforms. Supported platforms include<br />
.NET, Java, C/C++, JavaScript, and many more.</p>
<p>The Protobuf compiler, protoc, is maintained by Google, although alternative implementations are<br />
available. The generated code is efficient and optimized for fast serialization and deserialization of<br />
data.</p>
<p>The Protobuf wire format is a binary encoding. It uses some clever tricks to minimize the number of<br />
bytes used to represent messages. Knowledge of the binary encoding format isn’t necessary to use<br />
<a href="https://developers.google.com/protocol-buffers/docs/encoding">Protobuf. But if you’re interested, you can learn more about it on the Protocol Buffers website.</a></p>
<h3>Protobuf messages</h3>
<p>This section covers how to declare Protocol Buffer (Protobuf) messages in .proto files. It explains the<br />
fundamental concepts of field numbers and types, and it looks at the C# code that the protoc<br />
compiler generates.</p>
<p>The rest of the chapter will look in more detail at how different types of data are represented in<br />
Protobuf.</p>
<h4><strong>Declaring a message</strong></h4>
<p>In Windows Communication Foundation (WCF), a Stock class for a stock market trading application<br />
might be defined like the following example:</p>
<p>11 CHAPTER 3 | Protocol buffers</p>
<p>To implement the equivalent class in Protobuf, you must declare it in the .proto file. The protoc<br />
compiler will then generate the .NET class as part of the build process.</p>
<p>The first line declares the syntax version being used. Version 3 of the language was released in 2016.<br />
It’s the version that we recommend for gRPC services.</p>
<p>The option csharp_namespace line specifies the namespace to be used for the generated C# types.<br />
This option will be ignored when the .proto file is compiled for other languages. Protobuf files often<br />
contain language-specific options for several languages.</p>
<p>The Stock message definition specifies four fields. Each has a type, a name, and a field number.</p>
<h4><strong>Field numbers</strong></h4>
<p>Field numbers are an important part of Protobuf. They’re used to identify fields in the binary encoded<br />
data, which means they can’t change from version to version of your service. The advantage is that<br />
backward compatibility and forward compatibility are possible. Clients and services will ignore field<br />
numbers that they don’t know about, as long as the possibility of missing values is handled.</p>
<p>In the binary format, the field number is combined with a type identifier. Field numbers from 1 to 15<br />
can be encoded with their type as a single byte. Numbers from 16 to 2,047 take 2 bytes. You can go<br />
higher if you need more than 2,047 fields on a message for any reason. The single-byte identifiers for<br />
field numbers 1 to 15 offer better performance, so you should use them for the most basic, frequently<br />
used fields.</p>
<p>12 CHAPTER 3 | Protocol buffers</p>
<h4><strong>Types</strong></h4>
<p>The type declarations are using Protobuf’s native scalar data types, which are discussed in more detail<br />
in the next section. The rest of this chapter will cover Protobuf’s built-in types and show how they<br />
relate to common .NET types.</p>
<h4><strong>The generated code</strong></h4>
<p>When you build your application, Protobuf creates classes for each of your messages, mapping its<br />
native types to C# types. The generated Stock type would have the following signature:</p>
<p>The actual code that’s generated is far more complicated than this. The reason is that each class<br />
contains all the code necessary to serialize and deserialize itself to the binary wire format.</p>
<p><strong>Property names</strong></p>
<p>Note that the Protobuf compiler applied PascalCase to the property names, although they were<br />
<a href="https://developers.google.com/protocol-buffers/docs/style">snake_case in the .proto file. The Protobuf style guide</a> recommends using snake_case in your message<br />
definitions so that the code generation for other platforms produces the expected case for their<br />
conventions.</p>
<h3>Protobuf scalar data types</h3>
<p>Protocol Buffer (Protobuf) supports a range of native scalar value types. The following table lists them</p>
<table>
<thead>
<tr>
<th>all with their equivalent C# type:</th>
<th>Col2</th>
<th>Col3</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Protobuf type</strong></td>
<td><strong>C# type</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td>double</td>
<td>double</td>
<td></td>
</tr>
<tr>
<td>Float</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>int32</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td>int64</td>
<td>long</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>uint</td>
<td></td>
</tr>
<tr>
<td>uint64</td>
<td>ulong</td>
<td></td>
</tr>
</tbody>
</table>
<p>13 CHAPTER 3 | Protocol buffers</p>
<table>
<thead>
<tr>
<th>Protobuf type</th>
<th>C# type</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>sint32</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td>sint64</td>
<td>long</td>
<td>1</td>
</tr>
<tr>
<td>fixed32</td>
<td>uint</td>
<td>2</td>
</tr>
<tr>
<td>fixed64</td>
<td>ulong</td>
<td>2</td>
</tr>
<tr>
<td>sfixed32</td>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td>sfixed64</td>
<td>long</td>
<td>2</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>3</td>
</tr>
<tr>
<td>bytes</td>
<td>ByteString</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol>
<li>
<p>The standard encoding for int32 and int64 is inefficient when you’re working with signed<br />
values. If your field is likely to contain negative numbers, use sint32 or sint64 instead. These<br />
types map to the C# int and long types, respectively.</p>
</li>
<li>
<p>The fixed fields always use the same number of bytes no matter what the value is. This<br />
behavior makes serialization and deserialization faster for larger values.</p>
</li>
<li>
<p>Protobuf strings are UTF-8 (or 7-bit ASCII) encoded. The encoded length can’t be greater than</p>
</li>
<li></li>
<li>
<p>The Protobuf runtime provides a ByteString type that maps easily to and from C# byte[]<br />
arrays.</p>
</li>
</ol>
<h4><strong>Other .NET primitive types</strong></h4>
<p><strong>Dates and times</strong></p>
<p><a href="https://docs.microsoft.com/dotnet/api/system.datetimeoffset">The native scalar types don’t provide for date and time values, equivalent to C#’s DateTimeOffset,</a><br />
<a href="https://docs.microsoft.com/dotnet/api/system.datetime">DateTime, and TimeSpan. You can specify these types by using some of Google’s “Well Known Types”</a><br />
extensions. These extensions provide code generation and runtime support for complex field types<br />
across the supported platforms.</p>
<p>The following table shows the date and time types:</p>
<table>
<thead>
<tr>
<th>C# type</th>
<th>Protobuf well-known type</th>
</tr>
</thead>
<tbody>
<tr>
<td>DateTimeOffset</td>
<td>google.protobuf.Timestamp</td>
</tr>
<tr>
<td>DateTime</td>
<td>google.protobuf.Timestamp</td>
</tr>
<tr>
<td>TimeSpan</td>
<td>google.protobuf.Duration</td>
</tr>
</tbody>
</table>
<p>14 CHAPTER 3 | Protocol buffers</p>
<p>The generated properties in the C# class aren’t the .NET date and time types. The properties use the<br />
Timestamp and Duration classes in the Google.Protobuf.WellKnownTypes namespace. These classes<br />
provide methods for converting to and from DateTimeOffset, DateTime, and TimeSpan.</p>
<p><strong>System.Guid</strong></p>
<p><a href="https://docs.microsoft.com/dotnet/api/system.guid">Protobuf doesn’t directly support the Guid</a> type, known as UUID on other platforms. There’s no wellknown type for it.</p>
<p>The best approach is to handle Guid values as a string field, by using the standard 8-4-4-4-12<br />
hexadecimal format (for example, 45a9fda3-bd01-47a9-8460-c1cd7484b0b3). All languages and<br />
platforms can parse that format.</p>
<p>Don’t use a bytes field for Guid values. Problems with <em>endianness</em> <a href="https://en.wikipedia.org/wiki/Endianness">(Wikipedia definition) can result in</a><br />
erratic behavior when Protobuf is interacting with other platforms, such as Java.</p>
<p><strong>Nullable types</strong></p>
<p>The Protobuf code generation for C# uses the native types, such as int for int32. So the values are<br />
always included and can’t be null.</p>
<p>For values that require explicit null, such as using int? in your C# code, Protobuf’s “Well Known Types”<br />
include wrappers that are compiled to nullable C# types. To use them, import wrappers.proto into<br />
your .proto file, like this:</p>
<p>15 CHAPTER 3 | Protocol buffers</p>
<p>Protobuf will use the simple T? (for example, int?) for the generated message property.</p>
<p>The following table shows the complete list of wrapper types with their equivalent C# type:</p>
<table>
<thead>
<tr>
<th>C# type</th>
<th>Well Known Type wrapper</th>
</tr>
</thead>
<tbody>
<tr>
<td>double?</td>
<td>google.protobuf.DoubleValue</td>
</tr>
<tr>
<td>float?</td>
<td>google.protobuf.FloatValue</td>
</tr>
<tr>
<td>int?</td>
<td>google.protobuf.Int32Value</td>
</tr>
<tr>
<td>long?</td>
<td>google.protobuf.Int64Value</td>
</tr>
<tr>
<td>uint?</td>
<td>google.protobuf.UInt32Value</td>
</tr>
<tr>
<td>ulong?</td>
<td>google.protobuf.UInt64Value</td>
</tr>
</tbody>
</table>
<p>The well-known types Timestamp and Duration are represented in .NET as classes. In C# 8 and<br />
beyond, you can use nullable reference types. But it’s important to check for null on properties of<br />
those types when you’re converting to DateTimeOffset or TimeSpan.</p>
<h4><strong>Decimals</strong></h4>
<p>Protobuf doesn’t natively support the .NET decimal type, just double and float. There’s an ongoing<br />
discussion in the Protobuf project about the possibility of adding a standard Decimal type to the wellknown types, with platform support for languages and frameworks that support it. Nothing has been<br />
implemented yet.</p>
<p>It’s possible to create a message definition to represent the decimal type that would work for safe<br />
serialization between .NET clients and servers. But developers on other platforms would have to<br />
understand the format being used and implement their own handling for it.</p>
<p><strong>Creating a custom decimal type for Protobuf</strong></p>
<p>A simple implementation might be similar to the nonstandard Money type that some Google APIs<br />
use, without the currency field.</p>
<p>16 CHAPTER 3 | Protocol buffers</p>
<p>The nanos field represents values from 0.999_999_999 to -0.999_999_999. For example, the decimal<br />
value 1.5m would be represented as { units = 1, nanos = 500_000_000 }. This is why the nanos field in<br />
this example uses the sfixed32 type, which encodes more efficiently than int32 for larger values. If the<br />
units field is negative, the nanos field should also be negative.</p>
<p>Conversion between this type and the BCL decimal type might be implemented in C# like this:</p>
<h3>Protobuf nested types</h3>
<p>Just as C# allows you to declare classes inside other classes, Protocol Buffer (Protobuf) allows you to<br />
nest message definitions within other messages. The following example shows how to create nested<br />
message types:</p>
<p>17 CHAPTER 3 | Protocol buffers</p>
<p>In the generated C# code, the Inner type will be declared in a nested static Types class within the<br />
HelloRequest class:</p>
<pre><code>var inner = new Outer.Types.Inner { Text = &quot;Hello&quot; };

### Repeated fields for lists and arrays

</code></pre>
<p>You specify lists in Protocol Buffer (Protobuf) by using the repeated prefix keyword. The following<br />
example shows how to create a list:</p>
<p>In the generated code, repeated fields are represented by read-only properties of the<br />
<a href="https://developers.google.cn/protocol-buffers/docs/reference/csharp/class/google/protobuf/collections/repeated-field-t-">Google.Protobuf.Collections.RepeatedField<T> type rather than any of the built-in .NET collection</a><br />
<a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.ilist-1">types. This type implements all the standard .NET collection interfaces, such as IList</a> <a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1">and IEnumerable.</a><br />
So you can use LINQ queries or convert it to an array or a list easily.</p>
<p>The RepeatedField<T> type includes the code required to serialize and deserialize the list to the<br />
binary wire format.</p>
<h3>Protobuf reserved fields</h3>
<p>The backward-compatibility guarantees in Protocol Buffer (Protobuf) rely on field numbers always<br />
representing the same data item. If a field is removed from a message in a new version of the service,<br />
that field number should never be reused. You can enforce this behavior by using the reserved<br />
keyword.</p>
<p>If the displayName and marketId fields were removed from the Stock message defined earlier, their<br />
field numbers should be reserved as in the following example.</p>
<p>You can also use the reserved keyword as a placeholder for fields that might be added in the future.<br />
You can express contiguous field numbers as a range by using the to keyword.</p>
<p>18 CHAPTER 3 | Protocol buffers</p>
<h3>Protobuf Any and Oneof fields for variant types</h3>
<p>Handling dynamic property types (that is, properties of type object) in Windows Communication<br />
<a href="https://docs.microsoft.com/dotnet/api/system.runtime.serialization.knowntypeattribute">Foundation (WCF) is complicated. For example, you must specify serializers and provide KnownType</a><br />
attributes.</p>
<p>Protocol Buffer (Protobuf) provides two simpler options for dealing with values that might be of more<br />
than one type. The Any type can represent any known Protobuf message type. And you can use the<br />
oneof keyword to specify that only one of a range of fields can be set in any message.</p>
<h4><strong>Any</strong></h4>
<p>Any is one of Protobuf’s “well-known types”: a collection of useful, reusable message types with<br />
implementations in all supported languages. To use the Any type, you must import the<br />
google/protobuf/any.proto definition.</p>
<p>In the C# code, the Any class provides methods for setting the field, extracting the message, and<br />
checking the type.</p>
<p>19 CHAPTER 3 | Protocol buffers</p>
<p>Protobuf’s internal reflection code uses the Descriptor static field on each generated type to resolve<br />
Any field types. There’s also a TryUnpack<T> method, but that creates an uninitialized instance of T<br />
even when it fails. It’s better to use the Is method as shown earlier.</p>
<h4><strong>Oneof</strong></h4>
<p>Oneof fields are a language feature: the compiler handles the oneof keyword when it generates the<br />
message class. Using oneof to specify the ChangeNotification message might look like this:</p>
<p>Fields within the oneof set must have unique field numbers in the overall message declaration.</p>
<p>When you use oneof, the generated C# code includes an enum that specifies which of the fields has<br />
been set. You can test the enum to find which field is set. Fields that aren’t set return null or the<br />
default value, rather than throwing an exception.</p>
<p>Setting any field that’s part of a oneof set will automatically clear any other fields in the set. You can’t<br />
use repeated with oneof. Instead, you can create a nested message with either the repeated field or<br />
the oneof set to work around this limitation.</p>
<p>20 CHAPTER 3 | Protocol buffers</p>
<h3>Protobuf enumerations</h3>
<p>Protobuf supports enumeration types. You saw this support in the previous section, where an enum<br />
was used to determine the type of a Oneof field. You can define your own enumeration types, and<br />
Protobuf will compile them to C# enum types.</p>
<p>Because you can use Protobuf with various languages, the naming conventions for enumerations are<br />
different from the C# conventions. However, the code generator converts the names to the traditional<br />
C# case. If the Pascal-case equivalent of the field name starts with the enumeration name, then it’s<br />
removed.</p>
<p>For example, in the following Protobuf enumeration, the fields are prefixed with ACCOUNT_STATUS.<br />
This prefix is equivalent to the Pascal-case enum name, AccountStatus.</p>
<p>The generator creates a C# enum equivalent to the following code:</p>
<p>Protobuf enumeration definitions <em>must</em> have a zero constant as their first field. As in C#, you can<br />
declare multiple fields with the same value. But you must explicitly enable this option by using the<br />
allow_alias option in the enum:</p>
<p>You can declare enumerations at the top level in a .proto file, or nested within a message definition.<br />
Nested enumerations—like nested messages—will be declared within the .Types static class in the<br />
generated message class.</p>
<p><a href="https://docs.microsoft.com/dotnet/api/system.flagsattribute">There’s no way to apply the [Flags]</a> attribute to a Protobuf-generated enum, and Protobuf doesn’t<br />
understand bitwise enum combinations. Look at the following example:</p>
<p>21 CHAPTER 3 | Protocol buffers</p>
<p>If you set product.AvailableIn to Region.NorthAmerica | Region.SouthAmerica, it’s serialized as the<br />
integer value 3. When a client or server tries to deserialize the value, it won’t find a match in the enum<br />
definition for 3. The result will be Region.None.</p>
<p>The best way to work with multiple enum values in Protobuf is to use a repeated field of the enum<br />
type.</p>
<h3>Protobuf maps for dictionaries</h3>
<p>It’s important to be able to represent arbitrary collections of named values in messages. In .NET, this<br />
activity is commonly handled through dictionary types. The equivalent of the .NET<br />
<a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.idictionary-2">IDictionary&lt;TKey,TValue&gt; type in Protocol Buffer (Protobuf) is the map&lt;key_type, value_type&gt; type.</a><br />
This section shows how to declare a map type in Protobuf, and how to use the generated code.</p>
<p>In the generated code, map fields are represented by read-only properties of the<br />
<a href="https://developers.google.cn/protocol-buffers/docs/reference/csharp/class/google/protobuf/collections/map-field-t-key-t-value-">Google.Protobuf.Collections.MapField&lt;TKey, TValue&gt; type. This type implements the standard .NET</a><br />
<a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.idictionary-2">collection interfaces, including IDictionary&lt;TKey,TValue&gt;.</a></p>
<p>Map fields can’t be directly repeated in a message definition. But you can create a nested message<br />
that contains a map and use repeated on the message type, as in the following example:</p>
<h4><strong>Using MapField properties in code</strong></h4>
<p>The MapField properties generated from map fields are read-only, and will never be null. To set a map<br />
property, use the Add(IDictionary&lt;TKey,TValue&gt; values) method on the empty MapField property to<br />
copy values from any .NET dictionary.</p>
<p>22 CHAPTER 3 | Protocol buffers</p>
<h4><strong>Further reading</strong></h4>
<p><a href="https://developers.google.com/protocol-buffers/docs/overview">For more information about Protobuf, see the official Protobuf documentation.</a></p>
<p>23 CHAPTER 3 | Protocol buffers</p>
<p><strong>CHAPTER</strong></p>
<h1>4</h1>
<h2>Comparing WCF to gRPC</h2>
<p>The previous chapter gave you a good look at Protobuf and how gRPC handles messages. Before you<br />
work through a detailed conversion from Windows Communication Foundation (WCF) to gRPC, it’s<br />
important to know how the features available in WCF are handled in gRPC and what workarounds you<br />
can use when there’s no gRPC equivalent. In particular, this chapter will cover the following subjects:</p>
<ul>
<li>
<p>Operations and methods</p>
</li>
<li>
<p>Bindings and transports</p>
</li>
<li>
<p>RPC types</p>
</li>
<li>
<p>Metadata</p>
</li>
<li>
<p>Error handling</p>
</li>
<li>
<p>WS-* protocols</p>
</li>
</ul>
<h3>gRPC example</h3>
<p>When you create a new ASP.NET Core 7.0 gRPC project from Visual Studio 2022 or the command line,<br />
the gRPC equivalent of “Hello World” is generated for you. It consists of a greeter.proto file that<br />
defines the service and its messages, and a GreeterService.cs file with an implementation of the<br />
service.</p>
<p>24 CHAPTER 4 | Comparing WCF to gRPC</p>
<p>This chapter will refer to this example code when explaining different concepts and features of gRPC.</p>
<h3>WCF endpoints and gRPC methods</h3>
<p>In Windows Communication Foundation (WCF), when you’re writing your application code, you use<br />
one of the following methods:</p>
<ul>
<li>
<p><a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.operationcontractattribute">You write the application code in a class and decorate methods with the OperationContract</a><br />
attribute.</p>
</li>
<li>
<p><a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.operationcontractattribute">You declare an interface for the service and add OperationContract attributes to the interface.</a></p>
</li>
</ul>
<p>For example, the WCF equivalent of the greet.proto Greeter service might be written as follows:</p>
<p>Chapter 3 showed that Protobuf message definitions are used to generate data classes. Service and<br />
method declarations are used to generate base classes that you inherit from to implement the service.<br />
You just declare the methods to be implemented in the .proto file, and the compiler generates a base<br />
class with virtual methods that you must override.</p>
<h4><strong>OperationContract properties</strong></h4>
<p><a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.operationcontractattribute">The OperationContract</a> attribute has properties to control or refine how it works. gRPC methods don’t<br />
offer this type of control. The following table lists those OperationContract properties and describes<br />
how the functionality that they specify is (or isn’t) dealt with in gRPC:</p>
<p>25 CHAPTER 4 | Comparing WCF to gRPC</p>
<table>
<thead>
<tr>
<th>OperationContract property</th>
<th>gRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Action</td>
<td>A URI identifies the operation. gRPC uses the name of<br>package, service, and rpc from the .proto file.</td>
</tr>
<tr>
<td>AsyncPattern</td>
<td>All gRPC service methods return Task objects.</td>
</tr>
<tr>
<td>IsInitiating</td>
<td>See the paragraph after this table.</td>
</tr>
<tr>
<td>IsOneWay</td>
<td>One-way gRPC methods return Empty results or use client<br>streaming.</td>
</tr>
<tr>
<td>IsTerminating</td>
<td>See the paragraph after this table.</td>
</tr>
<tr>
<td>Name</td>
<td>This property is SOAP related and has no meaning in gRPC.</td>
</tr>
<tr>
<td>ProtectionLevel</td>
<td>There’s no message encryption. Network encryption is<br>handled at the transport layer (TLS over HTTP/2).</td>
</tr>
<tr>
<td>ReplyAction</td>
<td>This property is SOAP related and has no meaning in gRPC.</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.servicecontractattribute">The IsInitiating property lets you indicate that a method within ServiceContract</a> can’t be the first<br />
method called as part of a session. The IsTerminating property causes the server to close the session<br />
after an operation is called (or the client, if the property is used on a callback client). In gRPC, streams<br />
are created by single methods and closed explicitly. See gRPC streaming.</p>
<p>For more information on gRPC security and encryption, see chapter 6.</p>
<h3>WCF bindings and transports</h3>
<p>Windows Communication Foundation (WCF) has built-in <em>bindings</em> that specify different network<br />
protocols, wire formats, and other implementation details. gRPC effectively has just one network<br />
protocol and one wire format. (Technically you <em>can</em> customize the wire format, but that’s beyond the<br />
scope of this book.) You’re likely to discover that gRPC offers the best solution in most cases.</p>
<p>What follows is a short discussion about the most relevant WCF bindings and how they compare to<br />
their equivalents in gRPC.</p>
<h4><strong>NetTCP</strong></h4>
<p>WCF’s NetTCP binding allows for persistent connections, small messages, and two-way messaging.<br />
But it works only between .NET clients and servers. gRPC allows the same functionality but is<br />
supported across multiple programming languages and platforms.</p>
<p>gRPC has many features of WCF’s NetTCP binding, but they’re not always implemented in the same<br />
way. For example, in WCF, encryption is controlled through configuration and handled in the<br />
framework. In gRPC, encryption is achieved at the connection level through HTTP/2 over TLS.</p>
<p>26 CHAPTER 4 | Comparing WCF to gRPC</p>
<h4><strong>HTTP</strong></h4>
<p>The WCF binding called BasicHttpBinding is usually text-based and uses SOAP as the wire format. It’s<br />
slow compared to the NetTCP binding. It’s used to provide cross-platform interoperability, or<br />
connection over internet infrastructure.</p>
<p>The equivalent in gRPC uses HTTP/2 as the underlying transport layer with the binary Protobuf wire<br />
format for messages. So it can offer performance at the NetTCP service level and full cross-platform<br />
interoperability with all modern programming languages and frameworks.</p>
<h4><strong>Named pipes</strong></h4>
<p>WCF provided a <em>named pipes</em> binding for communication between processes on the same physical<br />
machine. ASP.NET Core gRPC doesn’t support named pipes. For inter-process communication (IPC)<br />
using gRPC instead supports Unix domain sockets. Unix domain sockets are supported on Linux and<br />
<a href="https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/">modern versions of Windows.</a></p>
<p><a href="https://docs.microsoft.com/aspnet/core/grpc/interprocess">For more information, see Inter-process communication with gRPC.</a></p>
<h4><strong>MSMQ</strong></h4>
<p>MSMQ is a proprietary Windows message queue. WCF’s binding to MSMQ enables “fire and forget”<br />
requests from clients that might be processed at any time in the future. gRPC doesn’t natively provide<br />
any message queue functionality.</p>
<p>The best alternative is to directly use a messaging system like Azure Service Bus, RabbitMQ, or Kafka.<br />
You can implement this functionality with the client placing messages directly onto the queue, or a<br />
gRPC client streaming service that enqueues the messages.</p>
<h4><strong>WebHttpBinding</strong></h4>
<p>WebHttpBinding (also known as WCF REST), with the WebGet and WebInvoke attributes, enabled you<br />
to develop RESTful APIs that could speak JSON at a time when this behavior was less common. If you<br />
have a RESTful API built with WCF REST, consider migrating it to a regular ASP.NET Core MVC Web<br />
API application. This migration would provide the same functionality as a conversion to gRPC.</p>
<h3>Types of RPC</h3>
<p>As a Windows Communication Foundation (WCF) developer, you’re probably used to dealing with the<br />
following types of remote procedure call (RPC):</p>
<ul>
<li>
<p>Request/reply</p>
</li>
<li>
<p>Duplex:</p>
<ul>
<li>
<p>One-way duplex with session</p>
</li>
<li>
<p>Full duplex with session</p>
</li>
</ul>
</li>
<li>
<p>One-way</p>
</li>
</ul>
<p>27 CHAPTER 4 | Comparing WCF to gRPC</p>
<p>It’s possible to map these RPC types fairly naturally to existing gRPC concepts. This chapter will look at<br />
each of these areas in turn. Chapter 5 will explore similar examples in greater depth.</p>
<table>
<thead>
<tr>
<th>WCF</th>
<th>gRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Regular request/reply</td>
<td>Unary</td>
</tr>
<tr>
<td>Duplex service with session using a client<br>callback interface</td>
<td>Server streaming</td>
</tr>
<tr>
<td>Full duplex service with session</td>
<td>Bidirectional streaming</td>
</tr>
<tr>
<td>One-way operations</td>
<td>Client streaming</td>
</tr>
</tbody>
</table>
<h4><strong>Request/reply</strong></h4>
<p>For simple request/reply methods that take and return small amounts of data, use the simplest gRPC<br />
pattern, the unary RPC.</p>
<p>As you can see, implementing a gRPC unary RPC service method is similar to implementing a WCF<br />
operation. The difference is that with gRPC, you override a base class method instead of<br />
<a href="https://docs.microsoft.com/dotnet/api/system.threading.tasks.task-1">implementing an interface. On the server, gRPC base methods always return Task, although the client</a><br />
provides both async and blocking methods to call the service.</p>
<h4><strong>WCF duplex, one way to client</strong></h4>
<p>WCF applications (with certain bindings) can create a persistent connection between client and server.<br />
The server can asynchronously send data to the client until the connection is closed, by using a<br />
<em>callback interface</em> <a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.servicecontractattribute.callbackcontract">specified in the ServiceContractAttribute.CallbackContract</a> property.</p>
<p>gRPC services provide similar functionality with message streams. Streams don’t map <em>exactly</em> to WCF<br />
duplex services in terms of implementation, but you can achieve the same results.</p>
<p>28 CHAPTER 4 | Comparing WCF to gRPC</p>
<p><strong>gRPC streaming</strong></p>
<p>gRPC supports the creation of persistent streams from client to server, and from server to client. Both<br />
types of stream can be active concurrently. This ability is called bidirectional streaming.</p>
<p>You can use streams for arbitrary, asynchronous messaging over time. Or you can use them for<br />
passing large datasets that are too big to generate and send in a single request or response.</p>
<p>The following example shows a server-streaming RPC.</p>
<p>This server stream can be consumed from a client application, as shown in the following code:</p>
<p>29 CHAPTER 4 | Comparing WCF to gRPC</p>
<p><strong>Differences from WCF</strong></p>
<p>A WCF duplex service uses a client callback interface that can have multiple methods. A gRPC serverstreaming service can only send messages over a single stream. If you need multiple methods, use a<br />
message type with either an Any field or a oneof field to send different messages, and write code in<br />
the client to handle them.</p>
<p><a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.servicecontractattribute">In WCF, the ServiceContract class with the session is kept alive until the connection is closed. Multiple</a><br />
methods can be called within the session. In gRPC, the Task that the implementation method returns<br />
shouldn’t finish until the connection is closed.</p>
<h4><strong>WCF one-way operations and gRPC client streaming</strong></h4>
<p>WCF provides one-way operations (marked with [OperationContract(IsOneWay = true)]) that return a<br />
transport-specific acknowledgment. gRPC service methods always return a response, even if it’s<br />
empty. The client should always await that response. For the “fire-and-forget” style of messaging in<br />
gRPC, you can create a client streaming service.</p>
<p><strong>thing_log.proto</strong></p>
<p><strong>ThingLogService.cs</strong></p>
<p><strong>ThingLog client example</strong></p>
<p>30 CHAPTER 4 | Comparing WCF to gRPC</p>
<p>You can use client-streaming RPCs for fire-and-forget messaging, as shown in the previous example.<br />
You can also use them for sending very large datasets to the server. The same warning about<br />
performance applies: for smaller datasets, use repeated fields in regular messages.</p>
<h4><strong>WCF full-duplex services</strong></h4>
<p>WCF duplex binding supports multiple one-way operations on both the service interface and the<br />
client callback interface. This support allows ongoing conversations between client and server. gRPC<br />
supports something similar with bidirectional streaming RPCs, where both parameters are marked<br />
with the stream modifier.</p>
<p><strong>chat.proto</strong></p>
<p><strong>ChatterService.cs</strong></p>
<p>31 CHAPTER 4 | Comparing WCF to gRPC</p>
<p>In the previous example, you can see that the implementation method receives both a request stream<br />
(IAsyncStreamReader<MessageRequest>) and a response stream<br />
(IServerStreamWriter<MessageResponse>). The method can read and write messages until the<br />
connection is closed.</p>
<p><strong>Chatter client</strong></p>
<h3>Metadata</h3>
<p><em>Metadata</em> refers to additional data that might be useful during the processing of requests and<br />
responses but that’s not part of the actual application data. Metadata might include authentication<br />
tokens, request identifiers and tags for monitoring purposes, and information about the data, like the<br />
number of records in a dataset.</p>
<p>32 CHAPTER 4 | Comparing WCF to gRPC</p>
<p>It’s possible to add generic key/value headers to Windows Communication Foundation (WCF)<br />
<a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.operationcontextscope">messages by using an OperationContextScope and the OperationContext.OutgoingMessageHeaders</a><br />
<a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.channels.messageproperties">property and handle them by using MessageProperties.</a></p>
<p>gRPC calls and responses can also include metadata that’s similar to HTTP headers. This metadata is<br />
mostly invisible to gRPC itself and is passed through to be processed by your application code or<br />
middleware. Metadata is represented as key/value pairs, where the key is a string and the value is<br />
either a string or binary data. You don’t need to specify metadata in the .proto file.</p>
<p><a href="https://www.nuget.org/packages/Grpc.Core.Api/">Metadata is handled by the Metadata class of the Grpc.Core.Api</a> NuGet package. This class can be<br />
used with collection initializer syntax.</p>
<p>This example shows how to add metadata to a call from a C# client:</p>
<p>gRPC services can access metadata from the ServerCallContext argument’s RequestHeaders property:</p>
<p>Services can send metadata to clients by using the ResponseTrailers property of ServerCallContext:</p>
<h3>Error handling</h3>
<p><a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.faultexception-1">Windows Communication Foundation (WCF) uses FaultException</a> <a href="xref:System.ServiceModel.FaultContractAttribute">and FaultContract</a> to provide<br />
detailed error information, including supporting the SOAP Fault standard.</p>
<p>33 CHAPTER 4 | Comparing WCF to gRPC</p>
<p>Unfortunately, the current version of gRPC lacks the sophistication found with WCF, and only has<br />
limited built-in error handling based on simple status codes and metadata. The following table is a</p>
<table>
<thead>
<tr>
<th>quick guide to the most commonly used status codes:</th>
<th>Col2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Status code</strong></td>
<td><strong>Problem</strong></td>
</tr>
<tr>
<td>GRPC_STATUS_UNIMPLEMENTED</td>
<td>Method hasn’t been written.</td>
</tr>
<tr>
<td>GRPC_STATUS_UNAVAILABLE</td>
<td>Problem with the whole service.</td>
</tr>
<tr>
<td>GRPC_STATUS_UNKNOWN</td>
<td>Invalid response.</td>
</tr>
<tr>
<td>GRPC_STATUS_INTERNAL</td>
<td>Problem with encoding/decoding.</td>
</tr>
<tr>
<td>GRPC_STATUS_UNAUTHENTICATED</td>
<td>Authentication failed.</td>
</tr>
<tr>
<td>GRPC_STATUS_PERMISSION_DENIED</td>
<td>Authorization failed.</td>
</tr>
<tr>
<td>GRPC_STATUS_CANCELLED</td>
<td>Call was canceled, usually by the<br>caller.</td>
</tr>
</tbody>
</table>
<h4><strong>Raise errors in ASP.NET Core gRPC</strong></h4>
<p>An ASP.NET Core gRPC service can send an error response by throwing an RpcException, which can be<br />
caught by the client as if it were in the same process. The RpcException must include a status code<br />
and description, and can optionally include metadata and a longer exception message. The metadata<br />
can be used to send supporting data, similar to how FaultContract objects can carry additional data<br />
for WCF errors.</p>
<h4><strong>Catch errors in gRPC clients</strong></h4>
<p><a href="https://docs.microsoft.com/dotnet/api/system.servicemodel.faultexception-1">Just like WCF clients can catch FaultException</a> errors, a gRPC client can catch an RpcException to<br />
handle errors. Because RpcException isn’t a generic type, you can’t catch different error types in<br />
different blocks. But you can use C#’s <em>exception filters</em> feature to declare separate catch blocks for<br />
different status codes, as shown in the following example:</p>
<p>34 CHAPTER 4 | Comparing WCF to gRPC</p>
<h4><strong>gRPC richer error model</strong></h4>
<p><a href="https://cloud.google.com/apis/design/errors#error_model">Google has developed a richer error model that’s more like WCF’s FaultContract, but this model isn’t</a><br />
supported in C# yet. Currently, it’s only available for Go, Java, Python, and C++.</p>
<h3>WS-* protocols</h3>
<p>One of the real benefits of working with Windows Communication Foundation (WCF) was that it<br />
supported many of the existing <em>WS-*</em> standard protocols. This section will briefly cover how gRPC<br />
manages the same WS-* protocols and discuss what options are available when there’s no alternative.</p>
<h4><strong>Metadata exchange: WS-Policy, WS-Discovery, and so on</strong></h4>
<p>SOAP services expose Web Services Description Language (WSDL) schema documents with<br />
information such as data formats, operations, or communication options. You can use this schema to<br />
generate the client code.</p>
<p>gRPC works best when servers and clients are generated from the same .proto files, but a Server<br />
Reflection optional extension does provide a way to expose dynamic information from a running<br />
<a href="https://nuget.org/packages/Grpc.Reflection">server. For more information, see the Grpc.Reflection</a> NuGet package.</p>
<p>The WS-Discovery protocol is used to locate services on a local network. gRPC services are located<br />
through DNS or a service registry such as Consul or ZooKeeper.</p>
<h4><strong>Security: WS-Security, WS-Federation, XML Encryption, and so on</strong></h4>
<p>Security, authentication, and authorization are covered in much more detail in chapter 6. But it’s worth<br />
noting here that, unlike WCF, gRPC doesn’t support WS-Security, WS-Federation, or XML Encryption.<br />
Even so, gRPC provides excellent security. All gRPC network traffic is automatically encrypted when it’s<br />
using HTTP/2 over TLS. You can use X509 certificates for mutual client/server authentication.</p>
<p>35 CHAPTER 4 | Comparing WCF to gRPC</p>
<h4><strong>WS-ReliableMessaging</strong></h4>
<p>gRPC does not provide an equivalent to WS-ReliableMessaging. Retry semantics should be handled in<br />
<a href="https://github.com/App-vNext/Polly">code, possibly with a library like Polly. When you’re running in Kubernetes or similar orchestration</a><br />
environments, service meshes can also help to provide reliable messaging between services.</p>
<h4><strong>WS-Transaction, WS-Coordination</strong></h4>
<p>WCF’s implementation of distributed transactions uses Microsoft Distributed Transaction Coordinator<br />
(MSDTC). It works with resource managers that specifically support it, like SQL Server, MSMQ, or<br />
Windows file systems. There’s no equivalent yet in the modern microservices world, in part due to the<br />
wider range of technologies in use. For a discussion of transactions, see Appendix A.</p>
<p>36 CHAPTER 4 | Comparing WCF to gRPC</p>
<p><strong>CHAPTER</strong></p>
<h1>5</h1>
<h2>Migrate a WCF solution to gRPC</h2>
<p>This chapter will describe how to work with ASP.NET Core 7.0 gRPC projects and demonstrate<br />
migrating different types of Windows Communication Foundation (WCF) services to the gRPC<br />
equivalent:</p>
<ul>
<li>
<p>Create an ASP.NET Core 7.0 gRPC project.</p>
</li>
<li>
<p>Simple request-reply operations to gRPC unary RPC.</p>
</li>
<li>
<p>One-way operations to gRPC client streaming RPC.</p>
</li>
<li>
<p>Full-duplex services to gRPC bidirectional streaming RPC.</p>
</li>
</ul>
<p>There’s also a comparison of using streaming services versus repeated fields for returning datasets,<br />
and there’s a discussion of the use of client libraries at the end of the chapter.</p>
<p>The sample WCF application is a minimal stub of a set of stock trading services. It uses the opensource Inversion of Control (IoC) container library called Autofac for dependency injection. It includes<br />
three services, one for each WCF service type. The services will be discussed in more detail in the<br />
<a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers">following sections. You can download the solutions from dotnet-architecture/grpc-for-wcf-developers</a><br />
on GitHub. The services use fake data to minimize external dependencies.</p>
<p>The samples include the WCF and gRPC implementations of each service.</p>
<h3>Create a new ASP.NET Core gRPC project</h3>
<p>The .NET SDK comes with a powerful CLI tool, dotnet, which enables you to create and manage<br />
projects and solutions from the command line. The SDK is closely integrated with Visual Studio, so<br />
everything is also available through the familiar graphical user interface. This chapter shows both ways<br />
to create a new ASP.NET Core gRPC project.</p>
<h4><strong>Create the project by using Visual Studio</strong></h4>
<p>37 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>Create an empty solution called <strong>TraderSys</strong> from the <em>Blank Solution</em> template. Add a solution folder<br />
called src. Then, right-click on the folder and choose <strong>Add</strong> - <strong>New Project</strong> . Enter grpc in the template<br />
search box, and you should see a project template called gRPC Service.</p>
<p>Select <strong>Next</strong> to continue to the <strong>Configure your new project</strong> dialog box. Name the project<br />
TraderSys.Portfolios and add an src subdirectory to the <strong>Location</strong> .</p>
<p>38 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>Select <strong>Next</strong> to continue to the <strong>Create a new gRPC service</strong> dialog box.</p>
<p>39 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>At present, you have limited options for the service creation. Docker will be introduced later, so for<br />
now, leave that option unselected. Just select <strong>Create</strong> . Your first ASP.NET Core 7.0 gRPC project is<br />
generated and added to the solution. If you don’t want to know about working with the dotnet CLI,<br />
skip to the Clean up the example code section.</p>
<h4><strong>Create the project by using the .NET CLI</strong></h4>
<p>This section covers the creation of solutions and projects from the command line.</p>
<p>Create the solution as shown in the following command. The -o (or --output) flag specifies the output<br />
directory, which is created in the current directory if it doesn’t already exist. The solution has the same<br />
name as the directory: TraderSys.sln. You can provide a different name by using the -n (or --name)<br />
flag.</p>
<p>ASP.NET Core 7.0 comes with a CLI template for gRPC services. Create the new project by using this<br />
template, putting it into an src subdirectory as is conventional for ASP.NET Core projects. The project<br />
is named after the directory (TraderSys.Portfolios.csproj), unless you specify a different name with the<br />
-n flag.</p>
<pre><code>dotnet new grpc -o src/TraderSys.Portfolios

</code></pre>
<p>Finally, add the project to the solution by using the dotnet sln command:</p>
<pre><code>dotnet sln add src/TraderSys.Portfolios

</code></pre>
<p>40 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>You can now open this solution in Visual Studio 2022, Visual Studio Code, or whatever editor you<br />
prefer.</p>
<h4><strong>Clean up the example code</strong></h4>
<p>You’ve now created an example service by using the gRPC template, which was reviewed earlier in the<br />
book. This code isn’t useful in our stock trading context, so we’ll edit things for our first project.</p>
<p><strong>Rename and edit the proto file</strong></p>
<p>Go ahead and rename the Protos/greet.proto file to Protos/portfolios.proto, and open it in your<br />
editor. Delete everything after the package line. Then change the option csharp_namespace, package<br />
and service names, and remove the default SayHello service. The code now looks like the following:</p>
<p>If you rename the greet.proto file in an integrated development environment (IDE) like Visual Studio, a<br />
reference to this file is automatically updated in the .csproj file. But in some other editor, such as<br />
Visual Studio Code, this reference isn’t updated automatically, so you need to edit the project file<br />
manually.</p>
<p>In the gRPC build targets, there’s a Protobuf item element that lets you specify which .proto files<br />
should be compiled, and which form of code generation is required (that is, “Server” or “Client”).</p>
<p><strong>Rename the GreeterService class</strong></p>
<p>The GreeterService class is in the Services folder and inherits from Greeter.GreeterBase. Rename it to<br />
PortfolioService, and change the base class to Portfolios.PortfoliosBase. Delete the override methods.</p>
<p>41 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>There was a reference to the GreeterService class in the <em>Program.cs</em> . If you used refactoring to rename<br />
the class, this reference should have been updated automatically. However, if you didn’t, you need to<br />
edit it manually.</p>
<p>In the next section, we’ll add functionality to this new service.</p>
<h3>Migrate a WCF request-reply service to a gRPC unary RPC</h3>
<p>This section covers how to migrate a basic request-reply service in WCF to a unary RPC service in<br />
ASP.NET Core gRPC. These services are the simplest service types in both Windows Communication<br />
Foundation (WCF) and gRPC, so it’s an excellent place to start. After migrating the service, you’ll learn<br />
how to generate a client library from the same .proto file to consume the service from a .NET client<br />
application.</p>
<h4><strong>The WCF solution</strong></h4>
<p><a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/PortfoliosSample/wcf/TraderSys">The PortfoliosSample solution includes a simple request-reply Portfolio service to download either a</a><br />
single portfolio or all portfolios for a given trader. The service is defined in the interface<br />
IPortfolioService with a ServiceContract attribute:</p>
<p>42 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p><a href="https://docs.microsoft.com/dotnet/api/system.runtime.serialization.datacontractattribute">The Portfolio model is a simple C# class marked with DataContract</a> and including a list of<br />
PortfolioItem objects. These models are defined in the TraderSys.PortfolioData project along with a<br />
repository class that represents a data access abstraction.</p>
<p>The ServiceContract implementation uses a repository class provided via dependency injection that<br />
returns instances of the DataContract types:</p>
<p>43 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<h4><strong>The portfolios.proto file</strong></h4>
<p>If you followed the instructions in the previous section, you should have a gRPC project with a<br />
portfolios.proto file that looks like this:</p>
<p>The first step is to migrate the DataContract classes to their Protobuf equivalents.</p>
<h4><strong>Convert the DataContract classes to gRPC messages</strong></h4>
<p>The PortfolioItem class will be converted to a Protobuf message first, because the Portfolio class<br />
depends on it. The class is simple, and three of the properties map directly to gRPC data types. The<br />
Cost property, which represents the price paid for the shares at purchase, is a decimal field. gRPC<br />
supports only float or double for real numbers, which aren’t suitable for currency. Because share<br />
prices vary by a minimum of one cent, the cost can be expressed as an int32 of cents.</p>
<p>The Portfolio class is a little more complicated. In the WCF code, the developer used a Guid for the<br />
TraderId property, and contains a List<PortfolioItem>. In Protobuf, which doesn’t have a first-class<br />
UUID type, you should use a string for the traderId field and parse it in your own code. For the list of<br />
items, use the repeated keyword on the field.</p>
<p>Now that you have the data messages, you can declare the service RPC endpoints.</p>
<p>44 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<h4><strong>Convert ServiceContract to a gRPC service</strong></h4>
<p>The WCF Get method takes two parameters: Guid traderId and int portfolioId. gRPC service methods<br />
can take only a single parameter, so you need to create a message to hold the two values. It’s<br />
common practice to name these request objects with the same name as the method followed by the<br />
suffix Request. Again, string is being used for the traderId field instead of Guid.</p>
<p>The service could just return a Portfolio message directly, but again, this could affect backward<br />
compatibility in the future. It’s a good practice to define separate Request and Response messages for<br />
every method in a service, even if many of them are the same right now. So declare a GetResponse<br />
message with a single Portfolio field.</p>
<p>This example shows the declaration of the gRPC service method with the GetRequest message:</p>
<p>The WCF GetAll method takes only a single parameter, traderId, so it might seem that you could<br />
specify string as the parameter type. But gRPC requires a defined message type. This requirement<br />
helps to enforce the practice of using custom messages for all inputs and outputs, for future backward<br />
compatibility.</p>
<p>The WCF method also returns a List<Portfolio>, but for the same reason it doesn’t allow simple<br />
parameter types, gRPC won’t allow repeated Portfolio as a return type. Instead, create a<br />
GetAllResponse type to wrap the list.</p>
<p>45 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>If you save your project with these changes, the gRPC build target will run in the background and<br />
generate all the Protobuf message types and a base class that you can inherit to implement the<br />
service.</p>
<p>Open the Services/GreeterService.cs class and delete the example code. Now you can add the<br />
Portfolio service implementation. The generated base class will be in the Protos namespace and is<br />
generated as a nested class. gRPC creates a static class with the same name as the service in the<br />
.proto file and a base class with the suffix Base inside that static class, so the full identifier for the base<br />
type is TraderSys.Portfolios.Protos.Portfolios.PortfoliosBase.</p>
<p>The base class declares virtual methods for Get and GetAll that can be overridden to implement the<br />
service. The methods are virtual rather than abstract so that if you don’t implement them, the service<br />
can return an explicit gRPC Unimplemented status code, much like you might throw a<br />
NotImplementedException in regular C# code.</p>
<p>The signature for all gRPC unary service methods in ASP.NET Core is consistent. There are two<br />
parameters: the first is the message type declared in the .proto file, and the second is a<br />
ServerCallContext that works similarly to the HttpContext from ASP.NET Core. In fact, there’s an<br />
extension method called GetHttpContext on the ServerCallContext class that you can use to get the<br />
underlying HttpContext, although you shouldn’t need to use it often. We’ll take a look at<br />
ServerCallContext later in this chapter, and also in the chapter that discusses authentication.</p>
<p>The method’s return type is a Task<T>, where T is the response message type. All gRPC service<br />
methods are asynchronous.</p>
<h4><strong>Migrate the PortfolioData library to .NET</strong></h4>
<p>At this point, the project needs the Portfolio repository and models contained in the<br />
TraderSys.PortfolioData class library in the WCF solution. The easiest way to bring them across is to<br />
create a new class library by using either the Visual Studio <strong>New project</strong> dialog box with the Class<br />
Library (.NET Standard) template, or from the command line by using the .NET CLI, running these<br />
commands from the directory that contains the TraderSys.sln file:</p>
<p>After you’ve created the library and added it to the solution, delete the generated Class1.cs file and<br />
copy the files from the WCF solution’s library into the new class library’s folder, keeping the folder<br />
structure:</p>
<p>46 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>SDK-style .NET projects automatically include any .cs files in or under their own directory, so you don’t<br />
need to explicitly add them to the project. The only step remaining is to remove the DataContract and<br />
DataMember attributes from the Portfolio and PortfolioItem classes so they’re plain old C# classes:</p>
<h4><strong>Use ASP.NET Core dependency injection</strong></h4>
<p>Now you can add a reference to this library to the gRPC application project and consume the<br />
PortfolioRepository class by using dependency injection in the gRPC service implementation. In the<br />
WCF application, dependency injection was provided by the Autofac IoC container. ASP.NET Core has<br />
dependency injection baked in. You can register the repository in the <em>Program.cs</em> itself:</p>
<p>The IPortfolioRepository implementation can now be specified as a constructor parameter in the<br />
PortfolioService class, as follows:</p>
<pre><code>public class PortfolioService : Protos.Portfolios.PortfoliosBase
{
  private readonly IPortfolioRepository _repository;

  public PortfolioService(IPortfolioRepository repository)
  {

</code></pre>
<p>47 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<pre><code>_repository = repository;
  }
}

#### **Implement the gRPC service**

</code></pre>
<p>Now that you’ve declared your messages and your service in the portfolios.proto file, you have to<br />
implement the service methods in the PortfolioService class that inherits from the gRPC-generated<br />
Portfolios.PortfoliosBase class. The methods are declared as virtual in the base class. If you don’t<br />
override them, they’ll return a gRPC “Not Implemented” status code by default.</p>
<p>Start by implementing the Get method. The default override looks like this example:</p>
<p>The first problem is that request.TraderId is a string, and the service requires a Guid. Even though the<br />
expected format for the string is UUID, the code has to deal with the possibility that a caller has sent<br />
an invalid value and respond appropriately. The service can respond with errors by throwing an<br />
RpcException and use the standard InvalidArgument status code to express the problem:</p>
<p>After there’s a proper Guid value for traderId, you can use the repository to retrieve the Portfolio and<br />
return it to the client:</p>
<p><strong>Map internal models to gRPC messages</strong></p>
<p>The previous code doesn’t actually work because the repository is returning its own POCO model<br />
Portfolio, but gRPC needs its own Protobuf message Portfolio. As when you map Entity Framework<br />
types to data transfer types, the best solution is to provide a conversion between the two. A good<br />
place to put the code for this conversion is in the Protobuf-generated class, which is declared as a<br />
partial class so it can be extended:</p>
<p>48 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>Now that you have the conversion code in place, you can complete the Get method implementation:</p>
<p>49 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>The implementation of the GetAll method is similar. Note that the repeated fields on Protobuf<br />
messages are generated as readonly properties of type RepeatedField<T>, so you have to add items<br />
to them by using the AddRange method, like in this example:</p>
<p>Having successfully migrated the WCF request-reply service to gRPC, let’s look at creating a client for<br />
it from the .proto file.</p>
<h4><strong>Generate client code</strong></h4>
<p>Create a .NET Standard class library in the same solution to contain the client. This is primarily an<br />
example of creating client code, but you could package such a library by using NuGet and distribute it<br />
on an internal repository for other .NET teams to consume. Go ahead and add a new .NET Standard<br />
class library called TraderSys.Portfolios.Client to the solution and delete the Class1.cs file.</p>
<p>In Visual Studio 2022, you can add references to gRPC services in a way that’s similar to how you’d<br />
add service references to WCF projects in earlier versions of Visual Studio. Service references and<br />
connected services are all managed under the same UI now. You can access the UI by right-clicking<br />
the <strong>Dependencies</strong> node in the TraderSys.Portfolios.Client project in Solution Explorer and selecting<br />
<strong>Manage Connected Service</strong> . In the tool window that appears, select the <strong>Connected Services</strong> section,<br />
then select <strong>Add a service reference</strong> in Service References section, select gRPC and click Next:</p>
<p>50 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>Browse to the portfolios.proto file in the TraderSys.Portfolios project, leave <strong>Client</strong> under <strong>Select the</strong><br />
<strong>type of class to be generated</strong>, and then select <strong>OK</strong> :</p>
<p>51 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>When you use the Visual Studio <strong>Add Connected Service</strong> feature, the portfolios.proto file is added to<br />
the class library project as a <em>linked file</em> rather than copied, so changes to the file in the service project<br />
will automatically be applied in the client project. The <Protobuf> element in the csproj file looks like<br />
this:</p>
<p><strong>Use the Portfolios service from a client application</strong></p>
<p>The following code is a brief example of how to use the generated client in a console application. A<br />
more detailed exploration of the gRPC client code is at the end of this chapter.</p>
<p>52 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>You’ve now migrated a basic WCF application to an ASP.NET Core gRPC service and created a client to<br />
consume the service from a .NET application. The next section will cover the more involved duplex<br />
services.</p>
<h3>Migrate WCF duplex services to gRPC</h3>
<p>Now that you have a sense of the basic concepts, in this section, you’ll look at the more complicated<br />
<em>streaming</em> gRPC services.</p>
<p>There are multiple ways to use duplex services in Windows Communication Foundation (WCF). Some<br />
services are initiated by the client and then they stream data from the server. Other full-duplex<br />
services might involve more ongoing two-way communication, like the classic Calculator example in<br />
the WCF documentation. This chapter will take two possible WCF stock ticker implementations and<br />
migrate them to gRPC: one that uses a server streaming RPC and another one that uses a bidirectional<br />
streaming RPC.</p>
<h4><strong>Server streaming RPC</strong></h4>
<p><a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/SimpleStockTickerSample/wcf/SimpleStockTicker">In the sample SimpleStockTicker WCF solution, SimpleStockPriceTicker, there’s a duplex service for</a><br />
which the client starts the connection with a list of stock symbols, and the server uses the <em>callback</em><br />
<em>interface</em> to send updates as they become available. The client implements that interface to respond<br />
to calls from the server.</p>
<p><strong>The WCF solution</strong></p>
<p>The WCF solution is implemented as a self-hosted Net.TCP server in a .NET Framework 4. <em>x</em> console<br />
application.</p>
<p>53 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p><strong>ServiceContract</strong></p>
<p>The service has a single method with no return type because it uses the callback interface<br />
ISimpleStockTickerCallback to send data to the client in real time.</p>
<p><strong>The callback interface</strong></p>
<p>You can find the implementations of these interfaces in the solution, along with faked external<br />
dependencies to provide test data.</p>
<p><strong>gRPC streaming</strong></p>
<p>The gRPC process for handling real-time data is different from the WCF process. A call from client to<br />
server can create a persistent stream, which can be monitored for messages that arrive<br />
asynchronously. Despite the difference, streams can be a more intuitive way of dealing with this data<br />
and are more relevant in modern programming, which emphasizes LINQ, Reactive Streams, functional<br />
programming, and so on.</p>
<p>The service definition needs two messages: one for the request and one for the stream. The service<br />
returns a stream of the StockTickerUpdate message with the stream keyword in its return declaration.<br />
We recommend that you add a Timestamp to the update to show the exact time of the price change.</p>
<p><strong>simple_stock_ticker.proto</strong></p>
<p>54 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p><strong>Implement SimpleStockTicker</strong></p>
<p>Reuse the fake StockPriceSubscriber from the WCF project by copying the three classes from the<br />
TraderSys.StockMarket class library into a new .NET Standard class library in the target solution. To<br />
better follow best practices, add a Factory type to create instances of it, and register the<br />
IStockPriceSubscriberFactory with the ASP.NET Core dependency injection services.</p>
<p><strong>The factory implementation</strong></p>
<p><strong>Register the factory</strong></p>
<p>This class can now be used to implement the gRPC StockTickerService.</p>
<p>55 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p><strong>StockTickerService.cs</strong></p>
<p>As you can see, although the declaration in the .proto file says the method returns a stream of<br />
StockTickerUpdate messages, it actually returns a Task. The job of creating the stream is handled by<br />
the generated code and the gRPC runtime libraries, which provide the<br />
IServerStreamWriter<StockTickerUpdate> response stream, ready to use.</p>
<p>Unlike a WCF duplex service, where the instance of the service class is kept alive while the connection<br />
is open, the gRPC service uses the returned task to keep the service alive. The task shouldn’t complete<br />
until the connection is closed.</p>
<p>56 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>The service can tell when the client has closed the connection by using the CancellationToken from<br />
the ServerCallContext. A simple static method, AwaitCancellation, is used to create a task that<br />
completes when the token is canceled.</p>
<p>In the Subscribe method, then, get a StockPriceSubscriber and add an event handler that writes to the<br />
response stream. Then wait for the connection to be closed before immediately disposing the<br />
subscriber to prevent it from trying to write data to the closed stream.</p>
<p>The WriteUpdateAsync method has a try/catch block to handle any errors that might happen when a<br />
message is written to the stream. This consideration is important in persistent connections over<br />
networks, which could be broken at any millisecond, whether intentionally or because of a failure<br />
somewhere.</p>
<p><strong>Use StockTickerService from a client application</strong></p>
<p>Follow the same steps in the previous section to create a shareable client class library from the .proto<br />
file. In the sample, there’s a .NET console application that demonstrates how to use the client.</p>
<p><strong>Example Program.cs</strong></p>
<p>In this case, the Subscribe method on the generated client isn’t asynchronous. The stream is created<br />
and usable right away because its MoveNext method is asynchronous and the first time it’s called it<br />
won’t complete until the connection is alive.</p>
<p>The stream is passed to an asynchronous DisplayAsync method. The application then waits for the<br />
user to press a key, and then cancels the DisplayAsync method and waits for the task to complete<br />
before exiting.</p>
<p>57 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p><strong>Consume the stream</strong></p>
<p>WCF uses callback interfaces to allow the server to call methods directly on the client. gRPC streams<br />
work differently. The client iterates over the returned stream and processes messages, just as though<br />
they were returned from a local method returning an IEnumerable.</p>
<p>The IAsyncStreamReader<T> type works much like an IEnumerator<T>. There’s a MoveNext method<br />
that returns true as long as there’s more data, and a Current property that returns the latest value. The<br />
only difference is that the MoveNext method returns a Task<bool> instead of just a bool. The<br />
ReadAllAsync extension method wraps the stream in a standard C# 8 IAsyncEnumerable that can be<br />
used with the new await foreach syntax.</p>
<p>Again, be sure to catch exceptions here because of the possibility of network failure, and because of<br />
<a href="https://docs.microsoft.com/dotnet/api/system.operationcanceledexception">the OperationCanceledException that will inevitably be thrown because the code is using a</a><br />
<a href="https://docs.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a> to break the loop. The RpcException type has a lot of useful information about<br />
gRPC runtime errors, including the StatusCode. For more information, see <em>Error handling</em> in Chapter 4.</p>
<h4><strong>Bidirectional streaming</strong></h4>
<p>A WCF full-duplex service allows for asynchronous, real-time messaging in both directions. In the<br />
server streaming example, the client starts a request and then receives a stream of updates. A better</p>
<p>58 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>version of that service would allow the client to add and remove stocks from the list without having to<br />
<a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/FullStockTickerSample/wcf/FullStockTicker">stop and create a new subscription. That functionality has been implemented in the FullStockTicker</a><br />
<a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/FullStockTickerSample/wcf/FullStockTicker">sample solution.</a></p>
<p>The IFullStockTickerService interface provides three methods:</p>
<ul>
<li>
<p>Subscribe starts the connection.</p>
</li>
<li>
<p>AddSymbol adds a stock symbol to watch.</p>
</li>
<li>
<p>RemoveSymbol removes a symbol from the watched list.</p>
</li>
</ul>
<p>The callback interface remains the same.</p>
<p>Implementing this pattern in gRPC is less straightforward because there are now two streams of data<br />
with messages being passed: one from client to server and another from server to client. It isn’t<br />
possible to use multiple methods to implement the add and remove operations, but you can pass<br />
more than one type of message on a single stream by using either the Any type or the oneof<br />
keyword, which were covered in Chapter 3.</p>
<p>In a case where there’s a specific set of types that are acceptable, oneof is a better way to go. Use an<br />
ActionMessage that can hold either an AddSymbolRequest or a RemoveSymbolRequest:</p>
<p>Declare a bidirectional streaming service that takes a stream of ActionMessage messages:</p>
<p>59 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>The implementation for this service is similar to that of the previous example, except the first<br />
parameter of the Subscribe method is now an IAsyncStreamReader<ActionMessage>, which can be<br />
used to handle the Add and Remove requests:</p>
<p>The ActionMessage class that gRPC has generated guarantees that only one of the Add and Remove<br />
properties can be set. Finding which one isn’t null is a valid way to determine which type of message<br />
is used, but there’s a better way. The code generation also created an enum ActionOneOfCase in the<br />
ActionMessage class, which looks like this:</p>
<p>60 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>The property ActionCase on the ActionMessage object can be used with a switch statement to<br />
determine which field is set:</p>
<p><strong>Use FullStockTickerService from a client application</strong></p>
<p>There’s a simple .NET WPF application that demonstrates the use of this more complex client. You can<br />
<a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/FullStockTickerSample/grpc/FullStockTicker">find the full application on GitHub.</a></p>
<p>The client is used in the MainWindowViewModel class, which gets an instance of the<br />
FullStockTicker.FullStockTickerClient type from dependency injection:</p>
<p>61 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>The object returned by the client.Subscribe() method is now an instance of the gRPC library type<br />
AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;, which provides a RequestStream for sending<br />
requests to the server and a ResponseStream for handling responses.</p>
<p>The request stream is used from some WPF ICommand methods to add and remove symbols. For<br />
each operation, set the relevant field on an ActionMessage object:</p>
<p>The stream of responses is handled in an async method. The Task it returns is held to be disposed<br />
when the window is closed:</p>
<p>62 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p><strong>Client cleanup</strong></p>
<p>When the window is closed and the MainWindowViewModel is disposed (from the Closed event of<br />
MainWindow), we recommend that you properly dispose the AsyncDuplexStreamingCall object. In<br />
particular, the CompleteAsync method on the RequestStream should be called to gracefully close the<br />
stream on the server. This example shows the DisposeAsync method from the sample view-model:</p>
<p>Closing request streams enables the server to dispose of its own resources in a timely way. This<br />
improves the efficiency and scalability of services and prevents exceptions.</p>
<h3>gRPC streaming services vs. repeated fields</h3>
<p>gRPC services provide two ways of returning datasets, or lists of objects. The Protocol Buffers message<br />
specification uses the repeated keyword for declaring lists or arrays of messages within another<br />
message. The gRPC service specification uses the stream keyword to declare a long-running persistent<br />
connection. Over that connection, multiple messages are sent, and can be processed, individually.</p>
<p>You can also use the stream feature for long-running temporal data such as notifications or log<br />
messages. But this chapter will consider its use for returning a single dataset.</p>
<p>Which you should use depends on factors such as:</p>
<ul>
<li>
<p>The overall size of the dataset.</p>
</li>
<li>
<p>The time it took to create the dataset at either the client or server end.</p>
</li>
<li>
<p>Whether the consumer of the dataset can start acting on it as soon as the first item is<br />
available, or needs the complete dataset to do anything useful.</p>
</li>
</ul>
<h4><strong>When to use repeated fields</strong></h4>
<p>For any dataset that’s constrained in size and that can be generated in its entirety in a short time—<br />
say, under one second—you should use a repeated field in a regular Protobuf message. For example,<br />
in an e-commerce system, to build a list of items within an order is probably quick and the list won’t<br />
be very large. Returning a single message with a repeated field is an order of magnitude faster than<br />
using stream and incurs less network overhead.</p>
<p>63 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>If the client needs all the data before starting to process it and the dataset is small enough to<br />
construct in memory, then consider using a repeated field. Consider it even if the creation of the<br />
dataset in memory on the server is slower.</p>
<h4><strong>When to use stream methods</strong></h4>
<p>When the message objects in your datasets are potentially very large, it’s best for you transfer them<br />
by using streaming requests or responses. It’s more efficient to construct a large object in memory,<br />
write it to the network, and then free up the resources. This approach will improve the scalability of<br />
your service.</p>
<p>Similarly, you should send datasets of unconstrained size over streams to avoid running out of<br />
memory while constructing them.</p>
<p>For datasets where the consumer can separately process each item, you should consider using a<br />
stream if it means that progress can be indicated to the user. Using a stream can improve the<br />
responsiveness of an application, but you should balance it against the overall performance of the<br />
application.</p>
<p>Another scenario where streams can be useful is where a message is being processed across multiple<br />
services. If each service in a chain returns a stream, then the terminal service (that is, the last one in<br />
the chain) can start returning messages. These messages can be processed and passed back along the<br />
chain to the original requestor. The requestor can either return a stream or aggregate the results into<br />
a single response message. This approach lends itself well to patterns like MapReduce.</p>
<h3>Create gRPC client libraries</h3>
<p>It isn’t necessary to distribute client libraries for a gRPC application. You can create a shared library of<br />
.proto files within your organization, and other teams can use those files to generate client code in<br />
their own projects. But if you have a private NuGet repository and many other teams are using .NET,<br />
you can create and publish client NuGet packages as part of your service project. This approach can<br />
be a good way of sharing and promoting your service.</p>
<p>One advantage of distributing a client library is that you can enhance the generated gRPC and<br />
Protobuf classes with helpful “convenience” methods and properties. In the client code, as in the<br />
server, all the classes are declared as partial, so you can extend them without editing the generated<br />
code. This behavior means it’s easy to add constructors, methods, and calculated properties to the<br />
basic types.</p>
<p>Ensure that as many teams as possible can access your gRPC service. The best way to do this<br />
functionality is to share .proto files so developers can generate their own clients. This approach is</p>
<p>64 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>particularly true in a multi-platform environment, where different teams frequently use different<br />
programming languages and frameworks, or where your API is externally accessible.</p>
<h4><strong>Useful extensions</strong></h4>
<p><a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1">There are two commonly used interfaces in .NET for dealing with streams of objects: IEnumerable</a> and<br />
<a href="https://docs.microsoft.com/dotnet/api/system.iobservable-1">IObservable. Starting with .NET Core 3.0 and C# 8.0, there’s an IAsyncEnumerable</a> interface for<br />
processing streams asynchronously, and an await foreach syntax for using the interface. This section<br />
presents reusable code for applying these interfaces to gRPC streams.</p>
<p>With the .NET gRPC client libraries, there’s a ReadAllAsync extension method for<br />
IAsyncStreamReader<T> that creates an IAsyncEnumerable<T> interface. For developers using<br />
reactive programming, an equivalent extension method to create an IObservable<T> interface might<br />
look like the example in the following section.</p>
<p><strong>IObservable</strong></p>
<p>The IObservable<T> interface is the “reactive” inverse of IEnumerable<T>. Rather than pulling items<br />
from a stream, the reactive approach lets the stream push items to a subscriber. This behavior is very<br />
similar to gRPC streams, and it’s easy to wrap an IObservable<T> interface around an<br />
IAsyncStreamReader<T> interface.</p>
<p>This code is longer than the IAsyncEnumerable<T> code, because C# doesn’t have built-in support for<br />
working with observables. You have to create the implementation class manually. It’s a generic class,<br />
though, so a single implementation works across all types.</p>
<p>65 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>The GrpcStreamSubscription class handles the enumeration of the IAsyncStreamReader:</p>
<p>66 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p>All that is required now is a simple extension method to create the observable from the stream reader.</p>
<h4><strong>Summary</strong></h4>
<p><a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.iasyncenumerable-1">The IAsyncEnumerable</a> <a href="https://docs.microsoft.com/dotnet/api/system.iobservable-1">and IObservable</a> models are both well-supported and well-documented ways<br />
of dealing with asynchronous streams of data in .NET. gRPC streams map well to both paradigms,<br />
offering close integration with .NET, and reactive and asynchronous programming styles.</p>
<p>67 CHAPTER 5 | Migrate a WCF solution to gRPC</p>
<p><strong>CHAPTER</strong></p>
<h1>6</h1>
<h2>Security in gRPC applications</h2>
<p>In any real-world scenario, securing applications and services are essential. Security covers three key<br />
areas:</p>
<ul>
<li>
<p>Encrypting network traffic to prevent malicious hackers from intercepting it.</p>
</li>
<li>
<p>Authenticating clients and servers to establish identity and trust.</p>
</li>
<li>
<p>Authorizing clients to control access to systems and apply permissions based on identity.</p>
</li>
</ul>
<p>This chapter will cover the facilities for authentication and authorization in gRPC for ASP.NET Core. It<br />
will also discuss network security through TLS encrypted connections.</p>
<h3>WCF authentication and authorization</h3>
<p>In Windows Communication Foundation (WCF), authentication and authorization were handled in<br />
different ways, depending on the transports and bindings being used. WCF supported various WS-*<br />
security standards. It also supported Windows authentication for HTTP services running in IIS or<br />
NetTCP services between Windows systems.</p>
<h3>gRPC authentication and authorization</h3>
<p>gRPC authentication and authorization works on two levels:</p>
<ul>
<li>
<p>Call-level authentication/authorization is usually handled through tokens that are applied in<br />
metadata when the call is made.</p>
</li>
<li>
<p>Channel-level authentication uses a client certificate that’s applied at the connection level. It<br />
can also include call-level authentication/authorization credentials to be applied to every call<br />
on the channel automatically.</p>
</li>
</ul>
<p>You can use either or both of these mechanisms to help secure your service.</p>
<p>68 CHAPTER 6 | Security in gRPC applications</p>
<p>The ASP.NET Core implementation of gRPC supports authentication and authorization through most<br />
of the standard ASP.NET Core mechanisms:</p>
<ul>
<li>
<p>Call authentication</p>
<ul>
<li>
<p>Azure Active Directory</p>
</li>
<li>
<p>IdentityServer</p>
</li>
<li>
<p>JWT Bearer Token</p>
</li>
<li>
<p>OAuth 2.0</p>
</li>
<li>
<p>OpenID Connect</p>
</li>
<li>
<p>WS-Federation</p>
</li>
</ul>
</li>
<li>
<p>Channel authentication</p>
<ul>
<li>Client certificate</li>
</ul>
</li>
</ul>
<p>The call authentication methods are all based on <em>tokens</em> . The only real difference is how the tokens are<br />
generated and the libraries that are used to validate the tokens in the ASP.NET Core service.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/grpc/authn-and-authz">For more information, see the Authentication and authorization</a> article.</p>
<p>This chapter will show how to apply call credentials and channel credentials to a gRPC service. It will<br />
also show how to use credentials from a .NET gRPC client to authenticate with the service.</p>
<h3>Call credentials</h3>
<p>Call credentials are all based on a token passed in metadata with each request.</p>
<h4><strong>WS-Federation</strong></h4>
<p><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation">ASP.NET Core supports WS-Federation using the WsFederation</a> NuGet package. WS-Federation is the<br />
closest available alternative to Windows Authentication, which isn’t supported over HTTP/2. Users are<br />
authenticated by using Active Directory Federation Services (AD FS), which provides a token that can<br />
be used to authenticate with ASP.NET Core.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/security/authentication/ws-federation">For more information on how to get started with this authentication method, see Authenticate users</a><br />
<a href="https://docs.microsoft.com/aspnet/core/security/authentication/ws-federation">with WS-Federation in ASP.NET Core.</a></p>
<h4><strong>JWT Bearer tokens</strong></h4>
<p><a href="https://jwt.io/">The JSON Web Token</a> (JWT) standard provides a way to encode information about a user and their<br />
claims in an encoded string. It also provides a way to sign that token, so that the consumer can verify<br />
the integrity of the token by using public key cryptography. You can use various services, such as<br />
IdentityServer4, to authenticate users and generate OpenID Connect (OIDC) tokens to use with gRPC<br />
and HTTP APIs.</p>
<p>69 CHAPTER 6 | Security in gRPC applications</p>
<p>ASP.NET Core 7.0 can handle JWTs by using the JWT Bearer package. The configuration is exactly the<br />
same for a gRPC application as it is for an ASP.NET Core MVC application. Here, we’ll focus on JWT<br />
Bearer tokens, because they’re easier to develop with than WS-Federation.</p>
<h4><strong>Add authentication and authorization to the server</strong></h4>
<p>The JWT Bearer package isn’t included in ASP.NET Core 7.0 by default. Install the<br />
<a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer">Microsoft.AspNetCore.Authentication.JwtBearer NuGet package in your app.</a></p>
<p>Add the Authentication service in the <em>Program.cs</em> class, and configure the JWT Bearer handler:</p>
<p>The IssuerSigningKey property requires an implementation of<br />
Microsoft.IdentityModels.Tokens.SecurityKey with the cryptographic data necessary to validate the<br />
signed tokens. Store this token securely in a <em>secrets server</em>, like Azure Key Vault.</p>
<p>Next, add the Authorization service, which controls access to the system:</p>
<p>70 CHAPTER 6 | Security in gRPC applications</p>
<p>Now add the authentication and authorization middleware to the ASP.NET Core pipeline in the<br />
<em>Program.cs</em> :</p>
<p>Finally, apply the [Authorize] attribute to any services or methods to be secured, and use the User<br />
property from the underlying HttpContext to verify permissions.</p>
<h4><strong>Provide call credentials in the client application</strong></h4>
<p>After you’ve obtained a JWT token from an identity server, you can use it to authenticate gRPC calls<br />
from the client by adding it as a metadata header on the call, as follows:</p>
<p>Now you’ve secured your gRPC service by using JWT bearer tokens as call credentials. A version of the<br />
<a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/PortfoliosSample/grpc/TraderSysAuth">portfolios sample gRPC application with authentication and authorization added</a> is on GitHub.</p>
<p>71 CHAPTER 6 | Security in gRPC applications</p>
<h3>Channel credentials</h3>
<p>As the name implies, channel credentials are attached to the underlying gRPC channel. The standard<br />
form of channel credentials uses client certificate authentication. In this process, the client provides a<br />
TLS certificate when it’s making the connection, and then the server verifies this certificate before<br />
allowing any calls to be made.</p>
<p>You can combine channel credentials with call credentials to provide comprehensive security for a<br />
gRPC service. The channel credentials prove that the client application is allowed to access the service,<br />
and the call credentials provide information about the person who is using the client application.</p>
<p>Client certificate authentication works for gRPC the same way it works for ASP.NET Core. For more<br />
<a href="https://docs.microsoft.com/aspnet/core/security/authentication/certauth">information, see Configure certificate authentication in ASP.NET Core.</a></p>
<p>For development purposes you can use a self-signed certificate, but for production you should use a<br />
proper HTTPS certificate signed by a trusted authority.</p>
<h4><strong>Add certificate authentication to the server</strong></h4>
<p>Configure certificate authentication both at the host level (for example, on the Kestrel server), and in<br />
the ASP.NET Core pipeline.</p>
<p><strong>Configure certificate validation on Kestrel</strong></p>
<p>You can configure Kestrel (the ASP.NET Core HTTP server) to require a client certificate, and optionally<br />
to carry out some validation of the supplied certificate, before accepting incoming connections. You<br />
specify this configuration in the <em>Program.cs</em> :</p>
<p>The ClientCertificateMode.RequireCertificate setting causes Kestrel to immediately reject any<br />
connection request that doesn’t provide a client certificate, but this setting by itself won’t validate a<br />
certificate that is provided. Add the ClientCertificateValidation callback to enable Kestrel to validate<br />
the client certificate at the point the connection is made, before the ASP.NET Core pipeline is<br />
engaged. (In this case, the callback ensures that it was issued by the same <em>Certificate Authority</em> as the<br />
server certificate.)</p>
<p>72 CHAPTER 6 | Security in gRPC applications</p>
<p><strong>Add ASP.NET Core certificate authentication</strong></p>
<p><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Certificate">The Microsoft.AspNetCore.Authentication.Certificate NuGet package provides certificate</a><br />
authentication.</p>
<p>Add the certificate authentication service in the <em>Program.cs</em>, and add authentication and authorization<br />
to the ASP.NET Core pipeline.</p>
<h4><strong>Provide channel credentials in the client application</strong></h4>
<p><a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient">With the Grpc.Net.Client package, you configure certificates on an HttpClient</a> instance that is provided<br />
to the GrpcChannel used for the connection.</p>
<p><strong>Load a client certificate from a .PFX file</strong></p>
<p>A certificate can be loaded from a <em>.pfx</em> file.</p>
<p>73 CHAPTER 6 | Security in gRPC applications</p>
<p><strong>Load a client certificate from certificate and private key .PEM files</strong></p>
<p>A certificate can be loaded from a certificate and private key <em>.pem</em> file.</p>
<h4><strong>Combine ChannelCredentials and CallCredentials</strong></h4>
<p>You can configure your server to use both certificate and token authentication. To do this, apply the<br />
certificate changes to the Kestrel server, and use the JWT bearer middleware in ASP.NET Core.</p>
<p>To provide both ChannelCredentials and CallCredentials on the client, use the<br />
ChannelCredentials.Create method to apply the call credentials. You still need to apply certificate<br />
<a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient">authentication by using the HttpClient</a> instance. If you pass any arguments to the SslCredentials</p>
<p>74 CHAPTER 6 | Security in gRPC applications</p>
<p>constructor, the internal client code throws an exception. The SslCredentials parameter is only<br />
included in the Grpc.Net.Client package’s Create method to maintain compatibility with the Grpc.Core<br />
package.</p>
<p><a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/FullStockTickerSample/grpc/FullStockTickerAuth/FullStockTicker">A version of the FullStockTicker sample gRPC application with certificate authentication added is on</a><br />
GitHub.</p>
<h3>Encryption and network security</h3>
<p>The network security model for Windows Communication Foundation (WCF) is extensive and complex.<br />
It includes transport-level security by using HTTPS or TLS-over-TCP, and message-level security by<br />
using the WS-Security specification to encrypt individual messages.</p>
<p>gRPC leaves secure networking to the underlying HTTP/2 protocol, which you can secure by using TLS<br />
certificates.</p>
<p>Web browsers insist on using TLS connections for HTTP/2, but most programmatic clients, including<br />
.NET’s HttpClient, can use HTTP/2 over unencrypted connections.</p>
<p>For public APIs, you should always use TLS connections, and provide valid certificates for your services<br />
<a href="https://letsencrypt.org/">from a proper SSL authority. LetsEncrypt</a> provides free, automated SSL certificates, and most hosting<br />
infrastructure today supports the LetsEncrypt standard with common plug-ins or extensions.</p>
<p>For internal services across a corporate network, you should still consider using TLS to secure network<br />
traffic to and from your gRPC services.</p>
<p>75 CHAPTER 6 | Security in gRPC applications</p>
<p>If you need to use explicit TLS between services running in Kubernetes, consider using an in-cluster<br />
<a href="https://docs.cert-manager.io/en/latest/">certificate authority and a certificate manager controller like cert-manager. You can then automatically</a><br />
assign certificates to services at deployment time.</p>
<p>76 CHAPTER 6 | Security in gRPC applications</p>
<p><strong>CHAPTER</strong></p>
<h1>7</h1>
<h2>gRPC in production</h2>
<p>You can run ASP.NET Core 7.0 applications, including gRPC services, on Windows, on Linux, and in<br />
containers using modern platforms like Docker and Kubernetes. This chapter explores the various<br />
options for running your gRPC services in production, and looks at monitoring and logging options to<br />
ensure the optimal operation of systems.</p>
<h3>Self-hosted gRPC applications</h3>
<p>Although ASP.NET Core 7.0 applications can be hosted in IIS on Windows Server, currently it isn’t<br />
possible to host a gRPC application in IIS because some of the HTTP/2 functionality isn’t supported.<br />
This functionality is a goal for a future update to Windows Server.</p>
<p>You can run your application as a Windows service. Or you can run it as a Linux service controlled by<br />
<a href="https://en.wikipedia.org/wiki/Systemd">systemd, because of features introduced in the .NET 6 hosting extensions.</a></p>
<h4><strong>Run your app as a Windows service</strong></h4>
<p>To configure your ASP.NET Core application to run as a Windows service, install the<br />
<a href="https://www.nuget.org/packages/Microsoft.Extensions.Hosting.WindowsServices">Microsoft.Extensions.Hosting.WindowsServices package from NuGet. Then add a call to</a><br />
UseWindowsService to the CreateHostBuilder method in Program.cs.</p>
<p>Now publish your application by using one of these methods:</p>
<ul>
<li>
<p>From Visual Studio by right-clicking the project and selecting <strong>Publish</strong> on the shortcut menu.</p>
</li>
<li>
<p>From the .NET CLI.</p>
</li>
</ul>
<p>When you publish a .NET application, you can choose to create a <em>framework-dependent</em> deployment<br />
or a <em>self-contained</em> deployment. Framework-dependent deployments require the .NET Shared Runtime<br />
to be installed on the host where they’re run. Self-contained deployments are published with a<br />
complete copy of the .NET runtime and framework and can be run on any host. For more information,</p>
<p>77 CHAPTER 7 | gRPC in production</p>
<p><a href="https://docs.microsoft.com/dotnet/core/deploying/">including the advantages and disadvantages of each approach, see the .NET application deployment</a><br />
documentation.</p>
<p>To publish a self-contained build of the application that doesn’t require the .NET 5 runtime to be<br />
installed on the host, specify the runtime to be included with the application. Use the -r (or --runtime)<br />
flag.</p>
<pre><code>dotnet publish -c Release -r win-x64 -o ./publish

</code></pre>
<p>To publish a framework-dependent build, omit the -r flag.</p>
<pre><code>dotnet publish -c Release -o ./publish

</code></pre>
<p><a href="https://docs.microsoft.com/windows/desktop/services/controlling-a-service-using-sc">Copy the complete contents of the publish directory to an installation folder. Then, use the sc tool</a> to<br />
create a Windows service for the executable file.</p>
<pre><code>sc create MyService binPath=C:\MyService\MyService.exe

</code></pre>
<p><strong>Log to the Windows event log</strong></p>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/">The UseWindowsService method automatically adds a logging</a> provider that writes log messages to<br />
the Windows event log. You can configure logging for this provider by adding an EventLog entry to<br />
the Logging section of appsettings.json or another configuration source.</p>
<p>You can override the source name used in the event log by setting a SourceName property in these<br />
settings. If you don’t specify a name, the default application name (normally the executable assembly<br />
name) will be used.</p>
<p>More information on logging is at the end of this chapter.</p>
<h4><strong>Run your app as a Linux service with systemd</strong></h4>
<p>To configure your ASP.NET Core application to run as a Linux service (or <em>daemon</em> in Linux parlance),<br />
<a href="https://www.nuget.org/packages/Microsoft.Extensions.Hosting.Systemd">install the Microsoft.Extensions.Hosting.Systemd package from NuGet. Then add a call to UseSystemd</a><br />
to the CreateHostBuilder method in Program.cs.</p>
<p>Now publish your application. The application can be either framework dependent or self-contained<br />
for the relevant Linux runtime (for example, linux-x64). You can publish by using one of these<br />
methods:</p>
<p>78 CHAPTER 7 | gRPC in production</p>
<ul>
<li>
<p>From Visual Studio by right-clicking the project and selecting <strong>Publish</strong> on the shortcut menu.</p>
</li>
<li>
<p>From the .NET CLI, by using the following command:</p>
</li>
</ul>
<pre><code>    dotnet publish -c Release -r linux-x64 -o ./publish

</code></pre>
<p>Copy the complete contents of the publish directory to an installation folder on the Linux host.<br />
Registering the service requires a special file, called a <em>unit file</em>, to be added to the /etc/systemd/system<br />
directory. You’ll need root permission to create a file in this folder. Name the file with the identifier<br />
that you want systemd to use and the .service extension. For example, use<br />
/etc/systemd/system/myapp.service.</p>
<p>The service file uses INI format, as shown in this example:</p>
<p>The Type=notify property tells systemd that the application will notify it on startup and shutdown. The<br />
WantedBy=multi-user.target setting will cause the service to start when the Linux system reaches<br />
“runlevel 2,” which means a nongraphical, multi-user shell is active.</p>
<p>Before systemd will recognize the service, it needs to reload its configuration. You control systemd by<br />
using the systemctl command. After reloading, use the status subcommand to confirm that the<br />
application has registered successfully.</p>
<p>If you’ve configured the service correctly, you’ll get the following output:</p>
<pre><code>myapp.service - My gRPC Application
Loaded: loaded (/etc/systemd/system/myapp.service; disabled; vendor preset: enabled)
Active: inactive (dead)

</code></pre>
<p>Use the start command to start the service.</p>
<pre><code>sudo systemctl start myapp.service

</code></pre>
<p>To tell systemd to start the service automatically on system startup, use the enable command.</p>
<pre><code>sudo systemctl enable myapp

</code></pre>
<p>79 CHAPTER 7 | gRPC in production</p>
<p><strong>Log to journald</strong></p>
<p>The Linux equivalent of the Windows event log is journald, a structured logging system service that’s<br />
part of systemd. Log messages written to the standard output by a Linux daemon are automatically<br />
written to journald. To configure logging levels, use the Console section of the logging configuration.<br />
The UseSystemd host builder method automatically configures the console output format to suit the<br />
journal.</p>
<p>Because journald is the standard for Linux logs, a variety of tools integrate with it. You can easily route<br />
logs from journald to an external logging system. Working locally on the host, you can use the<br />
journalctl command to view logs from the command line.</p>
<pre><code>sudo journalctl -u myapp

</code></pre>
<p><a href="https://manpages.debian.org/buster/systemd/journalctl.1">To learn more about querying the systemd journal from the command line by using journalctl, see the</a><br />
<a href="https://manpages.debian.org/buster/systemd/journalctl.1">manpages.</a></p>
<h4><strong>HTTPS certificates for self-hosted applications</strong></h4>
<p>When you’re running a gRPC application in production, you should use a TLS certificate from a trusted<br />
certificate authority (CA). This CA might be a public CA, or an internal one for your organization.</p>
<p><a href="https://docs.microsoft.com/windows/win32/seccrypto/managing-certificates-with-certificate-stores">On Windows hosts, you can load the certificate from a secure certificate store by using the X509Store</a><br />
class. You can also use the X509Store class with the OpenSSL key store on some Linux hosts.</p>
<p><a href="https://docs.microsoft.com/dotnet/api/system.security.cryptography.x509certificates.x509certificate2.-ctor">You can also create certificates by using one of the X509Certificate2 constructors, from either:</a></p>
<ul>
<li>
<p>A file, such as a .pfx file protected by a strong password</p>
</li>
<li>
<p><a href="https://azure.microsoft.com/services/key-vault/">Binary data retrieved from a secure storage service such as Azure Key Vault</a></p>
</li>
</ul>
<p>You can configure Kestrel to use a certificate in two ways: from configuration or in code.</p>
<p><strong>Set HTTPS certificates by using configuration</strong></p>
<p>The configuration approach requires setting the password and path to the certificate .pfx file in the<br />
Kestrel configuration section. In appsettings.json, that looks like this:</p>
<p>80 CHAPTER 7 | gRPC in production</p>
<p>Provide the password by using a secure configuration source such as Azure Key Vault or Hashicorp<br />
Vault.</p>
<p><strong>Set HTTPS certificates in code</strong></p>
<p>To configure HTTPS on Kestrel in code, use the ConfigureKestrel method on IWebHostBuilder in the<br />
Program class.</p>
<p>Again, be sure to store the password for the .pfx file in, and retrieve it from, a secure configuration<br />
source.</p>
<h3>Create Docker images</h3>
<p>This section covers the creation of Docker images for ASP.NET Core gRPC applications, ready to run in<br />
Docker, Kubernetes, or other container environments. The sample application used, with an ASP.NET<br />
<a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/KubernetesSample">Core MVC web app and a gRPC service, is available on the dotnet-architecture/grpc-for-wcf-</a><br />
<a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/KubernetesSample">developers</a> repository on GitHub.</p>
<h4><strong>Microsoft base images for ASP.NET Core applications</strong></h4>
<p>Microsoft provides a range of base images for building and running .NET applications. To create an<br />
ASP.NET Core 7.0 image, you use two base images:</p>
<ul>
<li>
<p>An SDK image to build and publish the application.</p>
</li>
<li>
<p>A runtime image for deployment.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Image</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>mcr.microsoft.com/dotnet/sd<br>k</td>
<td>For building applications with docker build. Not to be used in<br>production.</td>
</tr>
<tr>
<td>mcr.microsoft.com/dotnet/as<br>pnet</td>
<td>Contains the runtime and ASP.NET Core dependencies. For<br>production.</td>
</tr>
</tbody>
</table>
<p>For each image, there are four variants based on different Linux distributions, distinguished by tags.</p>
<p>81 CHAPTER 7 | gRPC in production</p>
<table>
<thead>
<tr>
<th>Image tag(s)</th>
<th>Linux</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>7.0-bullseye-slim, 7.0</td>
<td>Debian 11</td>
<td>The default image if no<br>OS variant is specified.</td>
</tr>
<tr>
<td>7.0-alpine</td>
<td>Alpine 3.17</td>
<td>Alpine base images are<br>much smaller than<br>Debian or Ubuntu ones.</td>
</tr>
</tbody>
</table>
<p>The Alpine base image is around 100 MB, compared to 200 MB for the Debian and Ubuntu images.<br />
Some software packages or libraries might not be available in Alpine’s package management. If you’re<br />
not sure which image to use, you should probably choose the default Debian.</p>
<h4><strong>Create a Docker image</strong></h4>
<p>A Docker image is defined by a <em>Dockerfile</em> . This <em>Dockerfile</em> is a text file that contains all the commands<br />
needed to build the application and install any dependencies that are required for either building or<br />
running the application. The following example shows the simplest Dockerfile for an ASP.NET Core 7.0<br />
application:</p>
<p>The Dockerfile has two parts: the first uses the sdk base image to build and publish the application;<br />
the second creates a runtime image from the aspnet base. This is because the sdk image is around<br />
900 MB, compared to around 200 MB for the runtime image, and most of its contents are unnecessary<br />
at run time.</p>
<p>82 CHAPTER 7 | gRPC in production</p>
<table>
<thead>
<tr>
<th>The build steps</th>
<th>Col2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Step</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>FROM ...</td>
<td>Declares the base image and assigns the builder alias.</td>
</tr>
<tr>
<td>WORKDIR /src</td>
<td>Creates the /src directory and sets it as the current working directory.</td>
</tr>
<tr>
<td>COPY . .</td>
<td>Copies everything below the current directory on the host into the<br>current directory on the image.</td>
</tr>
<tr>
<td>RUN dotnet restore</td>
<td>Restores any external packages (ASP.NET Core 3.0 framework is<br>preinstalled with the SDK).</td>
</tr>
<tr>
<td>RUN dotnet publish ...</td>
<td>Builds and publishes a Release build. The --runtime flag isn’t required.</td>
</tr>
</tbody>
</table>
<p><strong>The runtime image steps</strong></p>
<table>
<thead>
<tr>
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM ...</td>
<td>Declares a new base image.</td>
</tr>
<tr>
<td>WORKDIR /app</td>
<td>Creates the /app directory and sets it as the current working directory.</td>
</tr>
<tr>
<td>COPY --from=builder ...</td>
<td>Copies the published application from the previous image, by using the<br>builder alias from the first FROM line.</td>
</tr>
<tr>
<td>ENTRYPOINT [ ... ]</td>
<td>Sets the command to run when the container starts. The dotnet<br>command in the runtime image can only run DLL files.</td>
</tr>
</tbody>
</table>
<p><strong>HTTPS in Docker</strong></p>
<p>Microsoft base images for Docker set the ASPNETCORE_URLS environment variable to http://+:80,<br />
meaning that Kestrel runs without HTTPS on that port. If you’re using HTTPS with a custom certificate<br />
(as described in Self-hosted gRPC applications), you should override this configuration. Set the<br />
environment variable in the runtime image creation part of your Dockerfile.</p>
<p><strong>The .dockerignore file</strong></p>
<p>Much like .gitignore files that exclude certain files and directories from source control, the<br />
.dockerignore file can be used to exclude files and directories from being copied to the image during<br />
build. This file not only saves time copying, but can also avoid some errors that arise from having the<br />
obj directory from your PC copied into the image. At a minimum, you should add entries for bin and<br />
obj to your .dockerignore file.</p>
<pre><code>bin/
obj/

</code></pre>
<p>83 CHAPTER 7 | gRPC in production</p>
<h4><strong>Build the image</strong></h4>
<p>For a StockKube.sln solution containing two different applications StockData and StockWeb, it’s<br />
simplest to put the Dockerfile for each one of them in the base directory. In that case, to build the<br />
image, use the following docker build command from the same directory where .sln file resides.</p>
<pre><code>docker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .

</code></pre>
<p>The confusingly named --tag flag (which can be shortened to -t) specifies the whole name of the<br />
image, including the actual tag if specified. The . at the end specifies the context in which the build<br />
will be run; the current working directory for the COPY commands in the Dockerfile.</p>
<p>If you have multiple applications within a single solution, you can keep the Dockerfile for each<br />
application in its own folder, beside the .csproj file. You should still run the docker build command<br />
from the base directory to ensure that the solution and all the projects are copied into the image. You<br />
can specify a Dockerfile below the current directory by using the --file (or -f) flag.</p>
<pre><code>docker build -t stockdata:1.0.0 -f ./src/StockData/Dockerfile .

#### **Run the image in a container on your machine**

</code></pre>
<p>To run the image in your local Docker instance, use the docker run command.</p>
<pre><code>docker run -ti -p 5000:80 stockdata:1.0.0

</code></pre>
<p>The -ti flag connects your current terminal to the container’s terminal, and runs in interactive mode.<br />
The -p 5000:80 publishes (links) port 80 on the container to port 5000 on the localhost network<br />
interface.</p>
<h4><strong>Push the image to a registry</strong></h4>
<p>After you’ve verified that the image works, push it to a Docker registry to make it available on other<br />
systems. Internal networks will need to provision a Docker registry. This activity can be as simple as<br />
<a href="https://docs.docker.com/registry/deploying/">running Docker’s own registry image</a> (the Docker registry runs in a Docker container), but there are<br />
various more comprehensive solutions available. For external sharing and cloud use, there are various<br />
<a href="https://docs.microsoft.com/azure/container-registry/">managed registries available, such as Azure Container Registry</a> <a href="https://docs.docker.com/docker-hub/repos/">or Docker Hub.</a></p>
<p>To push to Docker Hub, prefix the image name with your user or organization name.</p>
<p>To push to a private registry, prefix the image name with the registry host name and the organization<br />
name.</p>
<p>After the image is in a registry, you can deploy it to individual Docker hosts, or to a container<br />
orchestration engine like Kubernetes.</p>
<p>84 CHAPTER 7 | gRPC in production</p>
<h3>Kubernetes</h3>
<p>Although it’s possible to run containers manually on Docker hosts, for reliable production systems it’s<br />
better to use a container orchestration engine to manage multiple instances running across several<br />
servers in a cluster. There are various container orchestration engines available, including Kubernetes,<br />
Docker Swarm, and Apache Mesos. But of these engines, Kubernetes is far and away the most widely<br />
used, so it will be the focus of this chapter.</p>
<p>Kubernetes includes the following functionality:</p>
<ul>
<li>
<p><strong>Scheduling</strong> runs containers on multiple nodes within a cluster, ensuring balanced usage of<br />
the available resource, keeping containers running if there are outages, and handling rolling<br />
updates to new versions of images or new configurations.</p>
</li>
<li>
<p><strong>Health checks</strong> monitor containers to ensure continued service.</p>
</li>
<li>
<p><strong>DNS &amp; service discovery</strong> handles routing between services within a cluster.</p>
</li>
<li>
<p><strong>Ingress</strong> exposes selected services externally and generally provides load-balancing across<br />
instances of those services.</p>
</li>
<li>
<p><strong>Resource management</strong> attaches external resources like storage to containers.</p>
</li>
</ul>
<p>This chapter will detail how to deploy an ASP.NET Core gRPC service and a website that consumes the<br />
service into a Kubernetes cluster. The sample application used is available in the dotnet<a href="https://github.com/dotnet-architecture/grpc-for-wcf-developers/tree/main/KubernetesSample">architecture/grpc-for-wcf-developers repository on GitHub.</a></p>
<h4><strong>Kubernetes terminology</strong></h4>
<p>Kubernetes uses <em>desired state configuration</em> : the API is used to describe objects like <em>Pods</em>, <em>Deployments</em>,<br />
and <em>Services</em>, and the <em>Control Plane</em> takes care of implementing the desired state across all the <em>nodes</em><br />
in a <em>cluster</em> . A Kubernetes cluster has a <em>Master</em> node that runs the <em>Kubernetes API</em>, which you can<br />
communicate with programmatically or by using the kubectl command-line tool. kubectl can create<br />
and manage objects through command-line arguments, but it works best with YAML files that contain<br />
declaration data for Kubernetes objects.</p>
<p><strong>Kubernetes YAML files</strong></p>
<p>Every Kubernetes YAML file will have at least three top-level properties:</p>
<p>The apiVersion property is used to specify which version (and which API) the file is intended for. The<br />
kind property specifies the kind of object the YAML represents. The metadata property contains<br />
object properties like name, namespace, and labels.</p>
<p>Most Kubernetes YAML files will also have a spec section that describes the resources and<br />
configuration necessary to create the object.</p>
<p>85 CHAPTER 7 | gRPC in production</p>
<p><strong>Pods</strong></p>
<p>Pods are the basic units of execution in Kubernetes. They can run multiple containers, but they’re also<br />
used to run single containers. The pod also includes any storage resources required by the containers,<br />
and the network IP address.</p>
<p><strong>Services</strong></p>
<p>Services are meta-objects that describe Pods (or sets of Pods) and provide a way to access them<br />
within the cluster, such as mapping a service name to a set of pod IP addresses by using the cluster<br />
DNS service.</p>
<p><strong>Deployments</strong></p>
<p>Deployments are the <em>desired state</em> objects for Pods. If you create a pod manually, it won’t be restarted<br />
when it terminates. Deployments are used to tell the cluster which Pods, and how many replicas of<br />
those Pods, should be running at the present time.</p>
<p><strong>Other objects</strong></p>
<p>Pods, Services, and Deployments are just three of the most basic object types. There are dozens of<br />
other object types that are managed by Kubernetes clusters. For more information, see the<br />
<a href="https://kubernetes.io/docs/concepts/">Kubernetes Concepts</a> documentation.</p>
<p><strong>Namespaces</strong></p>
<p>Kubernetes clusters are designed to scale to hundreds or thousands of nodes and to run similar<br />
numbers of services. To avoid clashes between object names, namespaces are used to group objects<br />
together as part of larger applications. Kubernetes’s own services run in a default namespace. All user<br />
objects should be created in their own namespaces to avoid potential clashes with default objects or<br />
other tenants in the cluster.</p>
<h4><strong>Get started with Kubernetes</strong></h4>
<p>If you’re running Docker Desktop for Windows or Docker Desktop for Mac, Kubernetes is already<br />
available. Just enable it in the <strong>Kubernetes</strong> section of the <strong>Settings</strong> window:</p>
<p>86 CHAPTER 7 | gRPC in production</p>
<p><a href="https://github.com/kubernetes/minikube">To run a local Kubernetes cluster on Linux, consider minikube, or MicroK8s</a> if your Linux distribution<br />
<a href="https://snapcraft.io/">supports snaps.</a></p>
<p>To confirm that your cluster is running and accessible, run the kubectl version command:</p>
<p>In this example, both the kubectl CLI and the Kubernetes server are running version 1.14.6. Each<br />
version of kubectl is supposed to support the previous and next version of the server, so kubectl 1.14<br />
should work with server versions 1.13 and 1.15 as well.</p>
<h4><strong>Run services on Kubernetes</strong></h4>
<p>The sample application has a kube directory that contains three YAML files. The namespace.yml file<br />
declares a custom namespace: stocks. The stockdata.yml file declares the Deployment and the Service<br />
for the gRPC application, and the stockweb.yml file declares the Deployment and Service for an<br />
ASP.NET Core 7.0 MVC web application that consumes the gRPC service.</p>
<p>To use a YAML file with kubectl, run the apply -f command:</p>
<pre><code>kubectl apply -f object.yml

</code></pre>
<p>The apply command will check the validity of the YAML file and display any errors received from the<br />
API, but doesn’t wait until all the objects declared in the file have been created because this step can</p>
<p>87 CHAPTER 7 | gRPC in production</p>
<p>take some time. Use the kubectl get command with the relevant object types to check on object<br />
creation in the cluster.</p>
<p><strong>The namespace declaration</strong></p>
<p>Namespace declaration is simple and requires only assigning a name:</p>
<p>Use kubectl to apply the namespace.yml file and to confirm the namespace is created successfully:</p>
<p><strong>The StockData application</strong></p>
<p>The stockdata.yml file declares two objects: a Deployment and a Service.</p>
<p><strong>The StockData Deployment</strong></p>
<p>The Deployment part of the YAML file provides the spec for the deployment itself, including the<br />
number of replicas required, and a template for the Pod objects to be created and managed by the<br />
deployment. Note that Deployment objects are managed by the apps API, as specified in apiVersion,<br />
rather than the main Kubernetes API.</p>
<p>88 CHAPTER 7 | gRPC in production</p>
<p>The spec.selector property is used to match running Pods to the Deployment. The Pod’s<br />
metadata.labels property must match the matchLabels property or the API call will fail.</p>
<p>The template.spec section declares the container to be run. When you’re working with a local<br />
Kubernetes cluster, such as the one provided by Docker Desktop, you can specify images that were<br />
built locally as long as they have a version tag.</p>
<p>The ports property specifies which container ports should be published on the Pod. The stockservice<br />
image runs the service on the standard HTTP port, so port 80 is published.</p>
<p>The resources section applies resource limits to the container running within the Pod. This is a good<br />
practice because it prevents an individual Pod from consuming all the available CPU or memory on a<br />
node.</p>
<p><strong>The StockData Service</strong></p>
<p>The Service part of the YAML file declares the service that provides access to the Pods within the<br />
cluster.</p>
<p>The Service spec uses the selector property to match running Pods, in this case looking for Pods that<br />
have a label run: stockdata. The specified port on matching Pods is published by the named service.<br />
Other Pods running in the stocks namespace can access HTTP on this service by using<br />
http://stockdata as the address. Pods running in other namespaces can use the http://stockdata.stocks<br />
<a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">host name. You can control cross-namespace service access by using Network Policies.</a></p>
<p><strong>Deploy the StockData application</strong></p>
<p>Use kubectl to apply the stockdata.yml file and confirm that the Deployment and Service were<br />
created:</p>
<p>89 CHAPTER 7 | gRPC in production</p>
<p><strong>The StockWeb application</strong></p>
<p>The stockweb.yml file declares the Deployment and Service for the MVC application.</p>
<p>90 CHAPTER 7 | gRPC in production</p>
<p><strong>Environment variables</strong></p>
<p>The env section of the Deployment object specifies environment variables to be set in the container<br />
that’s running the stockweb:1.0.0 images.</p>
<p>The <strong>StockData__Address</strong> environment variable will map to the StockData:Address configuration<br />
setting thanks to the EnvironmentVariables configuration provider. This setting uses double<br />
underscores between names to separate sections. The address uses the service name of the stockdata<br />
Service, which is running in the same Kubernetes namespace.</p>
<p>The <strong>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT</strong><br />
<a href="https://docs.microsoft.com/dotnet/api/system.appcontext">environment variable sets an AppContext</a> switch that enables unencrypted HTTP/2 connections for<br />
<a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient">HttpClient. This environment variable does the same thing as setting the switch in code, as shown</a><br />
here:</p>
<pre><code>AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport&quot;, true );

</code></pre>
<p>If you use an environment variable for the switch, you can easily change the context depending on the<br />
context in which the application is running.</p>
<p><strong>Service types</strong></p>
<p>The type: NodePort property is used to make the web application accessible from outside the cluster.<br />
This property type causes Kubernetes to publish port 80 on the Service to an arbitrary port on the<br />
cluster’s external network sockets. You can find the assigned port by using the kubectl get service<br />
command.</p>
<p>The stockdata Service shouldn’t be accessible from outside the cluster, so it uses the default type,<br />
ClusterIP.</p>
<p>Production systems will most likely use an integrated load balancer to expose public applications to<br />
external consumers. Services exposed in this way should use the LoadBalancer type.</p>
<p><a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types">For more information on Service types, see the Kubernetes Publishing Services</a> documentation.</p>
<p><strong>Deploy the StockWeb application</strong></p>
<p>Use kubectl to apply the stockweb.yml file and confirm that the Deployment and Service were created:</p>
<p>The output of the get service command shows that the HTTP port has been published to port 32564<br />
on the external network. For Docker Desktop, this IP address will be localhost. You can access the<br />
application by browsing to http://localhost:32564.</p>
<p>91 CHAPTER 7 | gRPC in production</p>
<p><strong>Test the application</strong></p>
<p>The StockWeb application displays a list of NASDAQ stocks that are retrieved from a simple requestreply service. For this demonstration, each line also shows the unique ID of the Service instance that<br />
returned it.</p>
<p>If the number of replicas of the stockdata Service were increased, you might expect the <strong>Server</strong> value<br />
to change from line to line, but in fact all 100 records are always returned from the same instance. If<br />
you refresh the page every few seconds, the server ID remains the same. Why does this happen?<br />
There are two factors at play here.</p>
<p>First, the Kubernetes Service discovery system uses round-robin load balancing by default. The first<br />
time the DNS server is queried, it will return the first matching IP address for the Service. The next<br />
time, it will return the next IP address in the list, and so on, until the end. At that point, it loops back to<br />
the start.</p>
<p>Second, the HttpClient used for the StockWeb application’s gRPC client is created and managed by<br />
<a href="https://docs.microsoft.com/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests">the ASP.NET Core HttpClientFactory, and a single instance of this client is used for every call to the</a><br />
page. The client only does one DNS lookup, so all requests are routed to the same IP address. And<br />
because the HttpClientHandler is cached for performance reasons, multiple requests in quick<br />
succession will <em>all</em> use the same IP address, until the cached DNS entry expires or the handler instance<br />
is disposed for some reason.</p>
<p>The result is that by default requests to a gRPC Service aren’t balanced across all instances of that<br />
Service in the cluster. Different consumers will use different instances, but that doesn’t guarantee a<br />
good distribution of requests or a balanced use of resources.</p>
<p>The next chapter, Service meshes, will address this problem.</p>
<p>92 CHAPTER 7 | gRPC in production</p>
<h3>Service meshes</h3>
<p>A service mesh is an infrastructure component that takes control of routing service requests within a<br />
network. Service meshes can handle all kinds of network-level concerns within a Kubernetes cluster,<br />
including:</p>
<ul>
<li>
<p>Service discovery</p>
</li>
<li>
<p>Load balancing</p>
</li>
<li>
<p>Fault tolerance</p>
</li>
<li>
<p>Encryption</p>
</li>
<li>
<p>Monitoring</p>
</li>
</ul>
<p>Kubernetes service meshes work by adding an extra container, called a <em>sidecar proxy</em>, to each pod<br />
included in the mesh. The proxy takes over handling all inbound and outbound network requests. You<br />
can then keep the configuration and management of networking matters separate from the<br />
application containers. In many cases, this separation doesn’t require any changes to the application<br />
code.</p>
<p>In the previous chapter’s example, the gRPC requests from the web application were all routed to a<br />
single instance of the gRPC service. This happens because the service’s host name is resolved to an IP<br />
address, and that IP address is cached for the lifetime of the HttpClientHandler instance. It might be<br />
possible to work around this behavior by handling DNS lookups manually or creating multiple clients.<br />
But this workaround would complicate the application code without adding any business or customer<br />
value.</p>
<p>When you use a service mesh, the requests from the application container are sent to the sidecar<br />
proxy. The sidecar proxy can then distribute them intelligently across all instances of the other service.<br />
The mesh can also:</p>
<ul>
<li>
<p>Respond seamlessly to failures of individual instances of a service.</p>
</li>
<li>
<p>Handle retry semantics for failed calls or timeouts.</p>
</li>
<li>
<p>Reroute failed requests to an alternate instance without returning to the client application.</p>
</li>
</ul>
<p>The following screenshot shows the StockWeb application running with the Linkerd service mesh.<br />
There are no changes to the application code, and the Docker image isn’t being used. The only<br />
change required was the addition of an annotation to the deployment in the YAML files for the<br />
stockdata and stockweb services.</p>
<p>93 CHAPTER 7 | gRPC in production</p>
<p>You can see from the <strong>Server</strong> column that the requests from the StockWeb application have been<br />
routed to both replicas of the StockData service, despite originating from a single HttpClient instance<br />
in the application code. In fact, if you review the code, you’ll see that all 100 requests to the StockData<br />
service are made simultaneously by using the same HttpClient instance. With the service mesh, those<br />
requests will be balanced across however many service instances are available.</p>
<p>Service meshes apply only to traffic within a cluster. For external clients, see the next chapter, Load<br />
Balancing.</p>
<h4><strong>Service mesh options</strong></h4>
<p>Three general-purpose service mesh implementations are currently available for use with Kubernetes:<br />
<a href="https://istio.io/">Istio,</a> <a href="https://linkerd.io/">Linkerd, and Consul Connect. All three provide request routing/proxying, traffic encryption,</a><br />
resilience, host-to-host authentication, and traffic control.</p>
<p>Choosing a service mesh depends on multiple factors:</p>
<ul>
<li>
<p>The organization’s specific requirements around costs, compliance, paid support plans, and so<br />
on.</p>
</li>
<li>
<p>The nature of the cluster, its size, the number of services deployed, and the volume of traffic<br />
within the cluster network.</p>
</li>
<li>
<p>Ease of deploying and managing the mesh and using it with services.</p>
</li>
</ul>
<h4><strong>Example: Add Linkerd to a deployment</strong></h4>
<p>In this example, you’ll learn how to use the Linkerd service mesh with the <em>StockKube</em> application from<br />
<a href="https://linkerd.io/2/getting-started/#step-1-install-the-cli">the previous section. To follow this example, you’ll need to install the Linkerd CLI. You can download</a></p>
<p>94 CHAPTER 7 | gRPC in production</p>
<p>Windows binaries from the section that lists GitHub releases. Be sure to use the most recent <em>stable</em><br />
release and not one of the edge releases.</p>
<p><a href="https://linkerd.io/2/getting-started/index.html">With the Linkerd CLI installed, follow the Getting Started</a> instructions to install the Linkerd<br />
components on your Kubernetes cluster. The instructions are straightforward, and the installation<br />
should take only a couple of minutes on a local Kubernetes instance.</p>
<p><strong>Add Linkerd to Kubernetes deployments</strong></p>
<p>The Linkerd CLI provides an inject command to add the necessary sections and properties to<br />
Kubernetes files. You can run the command and write the output to a new file.</p>
<pre><code>linkerd inject stockdata.yml &gt; stockdata-with-mesh.yml
linkerd inject stockweb.yml &gt; stockweb-with-mesh.yml

</code></pre>
<p>You can inspect the new files to see what changes have been made. For deployment objects, a<br />
metadata annotation is added to tell Linkerd to inject a sidecar proxy container into the pod when it’s<br />
created.</p>
<p>It’s also possible to pipe the output of the linkerd inject command to kubectl directly. The following<br />
commands will work in PowerShell or any Linux shell.</p>
<p><strong>Inspect services in the Linkerd dashboard</strong></p>
<p>Open the Linkerd dashboard by using the linkerd CLI.</p>
<pre><code>linkerd dashboard

</code></pre>
<p>The dashboard provides detailed information about all services that are connected to the mesh.</p>
<p>95 CHAPTER 7 | gRPC in production</p>
<p>If you increase the number of replicas of the StockData gRPC service as shown in the following<br />
example, and refresh the StockWeb page in the browser, you should see a mix of IDs in the <strong>Server</strong><br />
column. This mix indicates that all the available instances are serving requests.</p>
<p>96 CHAPTER 7 | gRPC in production</p>
<h3>Load balancing gRPC</h3>
<p>A typical deployment of a gRPC application includes a number of identical instances of the service,<br />
providing resilience and horizontal scalability. Load balancing distributes incoming requests across<br />
these instances to provide full usage of all available resources. To make this load balancing invisible to<br />
the client, it’s common to use a proxy load balancer server to handle requests from clients and route<br />
them to back-end instances.</p>
<p>Load balancers are classified according to the <em>layer</em> they operate on. Layer 4 load balancers work on<br />
the <em>transport</em> level, for example, with TCP sockets, connections, and packets. Layer 7 load balancers<br />
work at the <em>application</em> level, specifically handling HTTP/2 requests for gRPC applications.</p>
<h4><strong>L4 load balancers</strong></h4>
<p>An L4 load balancer accepts a TCP connection request from a client, opens another connection to one<br />
of the back-end instances, and copies data between the two connections with no real processing. L4<br />
offers excellent performance and low latency, but with little control or intelligence. As long as the<br />
client keeps the connection open, all requests will be directed to the same back-end instance.</p>
<p><a href="https://azure.microsoft.com/services/load-balancer/">Azure Load Balancer</a> is an example of an L4 load balancer.</p>
<h4><strong>L7 load balancers</strong></h4>
<p>An L7 load balancer parses incoming HTTP/2 requests and passes them on to back-end instances on a<br />
request-by-request basis, no matter how long the connection is held by the client.</p>
<p>Examples of L7 load balancers:</p>
<ul>
<li>
<p><a href="https://www.nginx.com/">NGINX</a></p>
</li>
<li>
<p><a href="https://www.haproxy.com/">HAProxy</a></p>
</li>
<li>
<p><a href="https://traefik.io/">Traefik</a></p>
</li>
</ul>
<p>As a rule of thumb, L7 load balancers are the best choice for gRPC and other HTTP/2 applications (and<br />
for HTTP applications generally, in fact). L4 load balancers will <em>work</em> with gRPC applications, but<br />
they’re primarily useful when low latency and low overhead are important.</p>
<p>If you’re using TLS encryption, load balancers can terminate the TLS connection and pass unencrypted<br />
requests to the back-end application, or they can pass the encrypted request along. Either way, the<br />
load balancer will need to be configured with the server’s public and private key so it can decrypt<br />
requests for processing.</p>
<p>See to the documentation for your preferred load balancer to find out how to configure it to handle<br />
HTTP/2 requests with your back-end services.</p>
<p>97 CHAPTER 7 | gRPC in production</p>
<h4><strong>Load balancing within Kubernetes</strong></h4>
<p>See the section on service meshes for a discussion of load balancing across internal services on<br />
Kubernetes.</p>
<h3>Application Performance Management</h3>
<p>In production environments like Kubernetes, it’s important to monitor applications to ensure they’re<br />
running optimally. Logging and metrics are important in particular. ASP.NET Core, including gRPC,<br />
provides built-in support for producing and managing log messages and metrics data, as well as<br />
<em>tracing</em> data.</p>
<h4><strong>The difference between logging and metrics</strong></h4>
<p><em>Logging</em> is concerned with text messages that record detailed information about things that have<br />
happened in the system. Log messages might include exception data, like stack traces, or structured<br />
data that provide context about the message. Logging output is commonly written to a searchable<br />
text store.</p>
<p><em>Metrics</em> refers to numeric data designed to be aggregated and presented by using charts and graphs<br />
in a dashboard. The dashboard provides a view of the overall health and performance of an<br />
application. Metrics data can also be used to trigger automated alerts when a threshold is exceeded.<br />
Here are some examples of metrics data:</p>
<ul>
<li>
<p>Time taken to process requests.</p>
</li>
<li>
<p>The number of requests per second being handled by an instance of a service.</p>
</li>
<li>
<p>The number of failed requests on an instance.</p>
</li>
</ul>
<h4><strong>Logging in ASP.NET Core gRPC</strong></h4>
<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging">ASP.NET Core provides built-in support for logging, in the form of Microsoft.Extensions.Logging</a><br />
NuGet package. The core parts of this library are included with the Web SDK, so there’s no need to<br />
install it manually. By default, log messages are written to the standard output (the “console”) and to<br />
any attached debugger. To write logs to persistent external data stores, you might need to import<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/#third-party-logging-providers">optional logging sink packages.</a></p>
<p>The ASP.NET Core gRPC framework writes detailed diagnostic logging messages to this logging<br />
framework, so they can be processed and stored along with your application’s own messages.</p>
<p><strong>Produce log messages</strong></p>
<p>The logging extension is automatically registered with ASP.NET Core’s dependency injection system,<br />
so you can specify loggers as a constructor parameter on gRPC service types.</p>
<p>98 CHAPTER 7 | gRPC in production</p>
<p>Many log messages, such as requests and exceptions, are provided by the ASP.NET Core and gRPC<br />
framework components. Add your own log messages to provide detail and context about application<br />
logic, rather than lower-level concerns.</p>
<p>For more information about writing log messages and available logging sinks and targets, see<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/">Logging in .NET Core and ASP.NET Core.</a></p>
<h4><strong>Metrics in ASP.NET Core gRPC</strong></h4>
<p>The .NET Core runtime provides a set of components for emitting and observing metrics. These<br />
<a href="https://docs.microsoft.com/dotnet/api/system.diagnostics.tracing.eventsource">include APIs such as the EventSource and EventCounter</a> classes. These APIs can emit basic numeric<br />
<a href="https://docs.microsoft.com/dotnet/core/diagnostics/dotnet-counters">data that can be consumed by external processes, like the dotnet-counters global tool, or Event</a><br />
Tracing for Windows. For more information about using EventCounter in your own code, see<br />
<a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md">EventCounter introduction.</a></p>
<p>For more advanced metrics and for writing metric data to a wider range of data stores, you might try<br />
<a href="https://www.app-metrics.io/">an open-source project called App Metrics. This suite of libraries provides an extensive set of types to</a><br />
instrument your code. It also offers packages to write metrics to different kinds of targets that include<br />
<a href="https://docs.microsoft.com/azure/azure-monitor/app/app-insights-overview">time-series databases, such as Prometheus and InfluxDB, and Application Insights. The</a><br />
<a href="https://www.nuget.org/packages/App.Metrics.AspNetCore.Mvc/">App.Metrics.AspNetCore.Mvc NuGet package even adds a comprehensive set of basic metrics that are</a><br />
automatically generated via integration with the ASP.NET Core framework. The project website<br />
<a href="https://www.app-metrics.io/samples/grafana/">provides templates</a> <a href="https://grafana.com/">for displaying those metrics with the Grafana</a> visualization platform.</p>
<p><strong>Produce metrics</strong></p>
<p>Most metrics platforms support the following types:</p>
<table>
<thead>
<tr>
<th>Metric type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Counter</td>
<td>Tracks how often something happens, such as<br>requests and errors.</td>
</tr>
<tr>
<td>Gauge</td>
<td>Records a single value that changes over time,<br>such as active connections.</td>
</tr>
<tr>
<td>Histogram</td>
<td>Measures a distribution of values across<br>arbitrary limits. For example, a histogram can<br>track dataset size, counting how many<br>contained &lt;10 records, how many contained<br>11-100 records, how many contained 101-1000<br>records, and how many contained &gt;1000<br>records.</td>
</tr>
<tr>
<td>Meter</td>
<td>Measures the rate at which an event occurs in<br>various time spans.</td>
</tr>
</tbody>
</table>
<p>99 CHAPTER 7 | gRPC in production</p>
<table>
<thead>
<tr>
<th>Metric type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Timer</td>
<td>Tracks the duration of events and the rate at<br>which it occurs, stored as a histogram.</td>
</tr>
</tbody>
</table>
<p>By using <em>App Metrics</em>, an IMetrics interface can be obtained via dependency injection, and used to<br />
record any of these metrics for a gRPC service. The following example shows how to count the<br />
number of Get requests made over time:</p>
<p><strong>Store and visualize metrics data</strong></p>
<p>The best way to store metrics data is in a <em>time-series database</em>, a specialized data store designed to<br />
record numerical data series marked with timestamps. The most popular of these databases are<br />
<a href="https://prometheus.io/">Prometheus</a> <a href="https://www.influxdata.com/products/influxdb-overview/">and InfluxDB. Microsoft Azure also provides dedicated metrics storage through the Azure</a><br />
<a href="https://docs.microsoft.com/azure/azure-monitor/overview">Monitor</a> service.</p>
<p><a href="https://grafana.com/">The current go-to solution for visualizing metrics data is Grafana, which works with a wide range of</a><br />
storage providers. The following image shows an example Grafana dashboard that displays metrics<br />
from the Linkerd service mesh running the StockData sample:</p>
<p>100 CHAPTER 7 | gRPC in production</p>
<p><strong>Metrics-based alerting</strong></p>
<p>The numerical nature of metrics data means that it’s ideally suited to drive alerting systems, notifying<br />
developers or support engineers when a value falls outside of some defined tolerance. The platforms<br />
already mentioned all provide support for alerting via a range of options, including emails, text<br />
messages, or in-dashboard visualizations.</p>
<h4><strong>Distributed tracing</strong></h4>
<p>Distributed tracing is a relatively recent development in monitoring, which has arisen from the<br />
increasing use of microservices and distributed architectures. A single request from a client browser,<br />
application, or device can be broken down into many steps and sub-requests, and involve the use of<br />
many services across a network. This activity makes it difficult to correlate log messages and metrics<br />
with the specific request that triggered them. Distributed tracing applies identifiers to requests, and<br />
<a href="https://docs.microsoft.com/dotnet/framework/wcf/diagnostics/tracing/end-to-end-tracing">allows logs and metrics to be correlated with a particular operation. This tracing is similar to WCF’s</a><br />
<a href="https://docs.microsoft.com/dotnet/framework/wcf/diagnostics/tracing/end-to-end-tracing">end-to-end tracing, but it’s applied across multiple platforms.</a></p>
<p>Distributed tracing has grown quickly in popularity and is beginning to standardize. The Cloud Native<br />
<a href="https://opentracing.io/">Computing Foundation created the Open Tracing standard, attempting to provide vendor-neutral</a><br />
<a href="https://www.jaegertracing.io/">libraries for working with back ends like Jaeger</a> <a href="https://www.elastic.co/products/apm">and Elastic APM. At the same time, Google created the</a><br />
<a href="https://opencensus.io/">OpenCensus project</a> to address the same set of problems. These two projects are merging into a new<br />
<a href="https://opentelemetry.io/">project, OpenTelemetry, which aims to be the industry standard of the future.</a></p>
<p><strong>How distributed tracing works</strong></p>
<p>Distributed tracing is based on the concept of <em>spans</em> : named, timed operations that are part of a single<br />
<em>trace</em>, which can involve processing on multiple nodes of a system. When a new operation is initiated,<br />
a trace is created with a unique identifier. For each sub-operation, a span is created with its own</p>
<p>101 CHAPTER 7 | gRPC in production</p>
<p>identifier and trace identifier. As the request passes around the system, various components can<br />
create <em>child</em> spans that include the identifier of their <em>parent</em> . A span has a <em>context</em>, which contains the<br />
trace and span identifiers, as well as useful data in the form of key and value pairs (called <em>baggage</em> ).</p>
<p><strong>Distributed tracing with DiagnosticSource</strong></p>
<p><a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#diagnosticsource-users-guide">.NET has an internal module that maps well to distributed traces and spans: DiagnosticSource. As well</a><br />
as providing a simple way to produce and consume diagnostics within a process, the<br />
DiagnosticSource module has the concept of an <em>activity</em> . An activity is effectively an implementation of<br />
a distributed trace, or a span within a trace. The internals of the module take care of parent/child<br />
activities, including allocating identifiers. For more information about using the Activity type, see the<br />
<a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-user-guide">Activity User Guide on GitHub.</a></p>
<p>Because DiagnosticSource is a part of the core framework and later, it’s supported by several core<br />
<a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient">components. These include HttpClient, Entity Framework Core, and ASP.NET Core, including explicit</a><br />
support in the gRPC framework. When ASP.NET Core receives a request, it checks for a pair of HTTP<br />
<a href="https://www.w3.org/TR/trace-context">headers matching the W3C Trace Context standard. If the headers are found, an activity is started by</a><br />
using the identity values and context from the headers. If no headers are found, an activity is started<br />
with generated identity values that match the standard format. Any diagnostics generated by the<br />
framework or by application code during the lifetime of this activity can be tagged with the trace and<br />
span identifiers. The HttpClient support extends this functionality further by checking for a current<br />
activity on every request, and automatically adding the trace headers to the outgoing request.</p>
<p>The ASP.NET Core gRPC client and server libraries include explicit support for DiagnosticSource and<br />
Activity, and create activities and apply and use header information automatically.</p>
<p><strong>Add your own DiagnosticSource and Activity</strong></p>
<p>To add your own diagnostics or create explicit spans within your application code, see the<br />
<a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#instrumenting-with-diagnosticsourcediagnosticlistener">DiagnosticSource User Guide and Activity User Guide.</a></p>
<p><strong>Store distributed trace data</strong></p>
<p>At the time of writing, the OpenTelemetry project is still in the early stages, and only alpha-quality<br />
packages are available for .NET applications. The OpenTracing project currently offers more mature<br />
libraries.</p>
<p>The OpenTracing API is described in the following section. If you want to use the OpenTelemetry API<br />
<a href="https://github.com/open-telemetry/opentelemetry-dotnet">in your application instead, refer to the OpenTelemetry .NET SDK repository</a> on GitHub.</p>
<p><strong>Use the OpenTracing package to store distributed trace data</strong></p>
<p><a href="https://www.nuget.org/packages/OpenTracing/">The OpenTracing NuGet package supports all OpenTracing-compliant back ends (which can be used</a><br />
independently of DiagnosticSource). There’s an additional package from the OpenTracing API</p>
<p>102 CHAPTER 7 | gRPC in production</p>
<p><a href="https://www.nuget.org/packages/OpenTracing.Contrib.NetCore/">Contributions project, OpenTracing.Contrib.NetCore. This package adds a DiagnosticSource listener,</a><br />
and writes events and activities to a back end automatically. Enabling this package is as simple as<br />
installing it from NuGet and adding it as a service in your Program class.</p>
<p>The OpenTracing package is an abstraction layer, and as such it requires implementation specific to<br />
the back end. OpenTracing API implementations are available for the following open source back</p>
<table>
<thead>
<tr>
<th>ends.</th>
<th>Col2</th>
<th>Col3</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td><strong>Package</strong></td>
<td><strong>Website</strong></td>
</tr>
<tr>
<td>Jaeger</td>
<td>Jaeger</td>
<td>jaegertracing.io</td>
</tr>
<tr>
<td>Elastic APM</td>
<td>Elastic.Apm.NetCoreAll</td>
<td>elastic.co/products/apm</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/opentracing/opentracing-csharp">For more information on the OpenTracing API for .NET, see the OpenTracing for C#</a> and the<br />
<a href="https://github.com/opentracing-contrib/csharp-netcore">OpenTracing Contrib C#/.NET Core repositories on GitHub.</a></p>
<p>103 CHAPTER 7 | gRPC in production</p>
<p><strong>CHAPTER</strong></p>
<h1>8</h1>
<h2>Appendix A - Transactions</h2>
<p>Windows Communication Foundation (WCF) supports distributed transactions, allowing you to<br />
<a href="https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)">perform atomic operations across multiple services. This functionality is based on the Microsoft</a><br />
<a href="https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)">Distributed Transaction Coordinator.</a></p>
<p>In the newer microservices landscape, this type of automated distributed transaction processing isn’t<br />
possible. There are too many different technologies involved, including relational databases, NoSQL<br />
data stores, and messaging systems. There might also be a mix of operating systems, programming<br />
languages, and frameworks in use in a single environment.</p>
<p><a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">WCF distributed transaction is an implementation of what is known as a two-phase commit (2PC). You</a><br />
can implement 2PC transactions manually by coordinating messages across services, creating open<br />
transactions within each service, and sending commit or rollback messages, depending upon success<br />
or failure. However, the complexity involved in managing 2PC can increase exponentially as systems<br />
evolve. Open transactions hold database locks that can negatively affect performance, or, worse, cause<br />
cross-service deadlocks.</p>
<p>If possible, it’s best to avoid distributed transactions altogether. If two items of data are so linked as to<br />
require atomic updates, consider handling them both with the same service. Apply those atomic<br />
changes by using a single request or message to that service.</p>
<p><a href="https://microservices.io/patterns/data/saga.html">If that isn’t possible, then one alternative is to use the Saga pattern. In a saga, updates are processed</a><br />
sequentially; as each update succeeds, the next one is triggered. These triggers can be propagated<br />
from service to service, or managed by a saga coordinator or orchestrator. If an update fails at any<br />
point during the process, the services that have already completed their updates apply specific logic<br />
to reverse them.</p>
<p>Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility<br />
<a href="https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/">Segregation (CQRS), as described in the .NET Microservices e-book. In particular, using domain events</a><br />
<a href="https://martinfowler.com/eaaDev/EventSourcing.html">or event sourcing</a> can help to ensure that updates are consistently, if not immediately, applied.</p>
<p>104 CHAPTER 8 | Appendix A - Transactions</p>
