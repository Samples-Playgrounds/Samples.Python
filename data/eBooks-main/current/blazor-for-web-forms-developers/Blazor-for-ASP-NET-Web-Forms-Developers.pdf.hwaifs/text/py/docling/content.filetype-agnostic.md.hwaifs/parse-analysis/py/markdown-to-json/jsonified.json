{"dbo.aspnet\\_Applications": {"Authorization configuration in Web Forms": "To configure authorized access to certain pages in an ASP.NET Web Forms application, typically you specify that certain pages or folders are inaccessible to anonymous users. This configuration is done in the web.config file:\n\n```\n<?xml version=\"1.0\"?> <configuration> <system.web> <authentication mode=\"Forms\"> <forms defaultUrl=\"~/home.aspx\" loginUrl=\"~/login.aspx\" slidingExpiration=\"true\" timeout=\"2880\"></forms> </authentication> <authorization> <deny users=\"?\" /> </authorization> </system.web> </configuration>\n```\n\nThe authentication configuration section sets up the forms authentication for the application. The authorization section is used to disallow anonymous users for the entire application. However, you can provide more granular authorization rules on a per-location basis as well as apply role-based authorization checks.\n\n```\n<location path=\"login.aspx\"> <system.web>\n```\n\n[]\n\n```\n<authorization> <allow users=\"*\" /> </authorization> </system.web> </location>\n```\n\nThe above configuration, when combined with the first one, would allow anonymous users to access the login page, overriding the site-wide restriction on non-authenticated users.\n\n```\n<location path=\"/admin\"> <system.web> <authorization> <allow roles=\"Administrators\" /> <deny users= \"*\" /> </authorization> </system.web> </location>\n```\n\nThe above configuration, when combined with the others, restricts access to the /admin folder and all resources within it to members of the \"Administrators\" role. This restriction could also be applied by placing a separate web.config file within the /admin folder root.", "Authorization code in Web Forms": "In addition to configuring access using web.config, you can also programmatically configure access and behavior in your Web Forms application. For instance, you can restrict the ability to perform certain operations or view certain data based on the user's role.\n\nThis code can be used both in code -behind logic as well as in the page itself:\n\n```\n<% if (HttpContext.Current.User.IsInRole(\"Administrators\")) { %> <a href=\"/admin\">Go To Admin</a> <% } %>\n```\n\nIn addition to checking user role membership, you can also determine if they are authenticated (though often this is better done using the location-based configuration covered above). Below is an example of this approach.\n\n```\nprotected void Page_Load(object sender , EventArgs e) { if (!User . Identity . IsAuthenticated) { FormsAuthentication . RedirectToLoginPage(); } if (!Roles . IsUserInRole(User . Identity . Name , \"Administrators\")) { MessageLabel . Text = \"Only administrators can view this.\"; SecretPanel . Visible = false; } }\n```\n\nIn the code above, role-based access control (RBAC) is used to determine whether certain elements of the page, such as a SecretPanel, are visible based on the current user's role.\n\nTypically, ASP.NET Web Forms applications configure security within the web.config file and then add additional checks where needed in .aspx pages and their related .aspx.cs code-behind files. Most applications leverage the universal membership provider, frequently with the additional role provider.", "ASP.NET Core Identity": "Although still tasked with authentication and authorization, ASP.NET Core Identity uses a different set of abstractions and assumptions when compared to the universal providers. For example, the new Identity model supports third party authentication, allowing users to authenticate using a social media account or other trusted authentication provider. ASP.NET Core Identity supports UI for commonly needed pages like login, logout, and register. It leverages EF Core for its data access, and uses EF Core migrations to generate the necessary schema required to support its data model. This introduction to Identity on ASP.NET Core provides a good overview of what is included with ASP.NET Core Identity and how to get started working with it. If you haven't already set up ASP.NET Core Identity in your application and its database, it will help you get started.", "Roles, claims, and policies": "Both the universal providers and ASP.NET Core Identity support the concept of roles. You can create roles for users and assign users to roles. Users can belong to any number of roles, and you can verify role membership as part of your authorization implementation.\n\nIn addition to roles, ASP.NET Core identity supports the concepts of claims and policies. While a role should specifically correspond to a set of resources a user in that role should be able to access, a claim is simply part of a user's identity. A claim is a name value pair that represents what the subject is, not what the subject can do.\n\nIt is possible to directly inspect a user's claims and determine based on these values whether a user should be given access to a resource. However, such checks are often repetitive and scattered throughout the system. A better approach is to define a policy .\n\nAn authorization policy consists of one or more requirements. Policies are registered as part of the authorization service configuration in the ConfigureServices method of Startup.cs. For example, the following code snippet configures a policy called \"CanadiansOnly\", which has the requirement that the user has the Country claim with the value of \"Canada\".\n\n```\nservices . AddAuthorization(options => { options . AddPolicy(\"CanadiansOnly\" , policy => policy . RequireClaim(ClaimTypes . Country , \"Canada\")); });\n```\n\nYou can learn more about how to create custom policies in the documentation .\n\nWhether you're using policies or roles, you can specify that a particular page in your Blazor application requires that role or policy with the [Authorize] attribute, applied with the @attribute directive.\n\nRequiring a role:\n\n```\n@attribute [Authorize(Roles =\"administrators\")]\n```\n\nRequiring a policy be satisfied:\n\n```\n@attribute [Authorize(Policy =\"CanadiansOnly\")]\n```\n\nIf you need access to a user's authentication state, roles, or claims in your code, there are two primary ways to achieve this functionality. The first is to receive the authentication state as a cascading parameter. The second is to access the state using an injected AuthenticationStateProvider. The details of each of these approaches are described in the Blazor Security documentation .\n\nThe following code shows how to receive the AuthenticationState as a cascading parameter:\n\n```\n[CascadingParameter] private Task<AuthenticationState> authenticationStateTask { get; set; }\n```\n\nWith this parameter in place, you can get the user using this code:\n\n```\nvar authState = await authenticationStateTask; var user = authState . User;\n```\n\nThe following code shows how to inject the AuthenticationStateProvider:\n\n```\n@using Microsoft . AspNetCore . Components . Authorization @inject AuthenticationStateProvider AuthenticationStateProvider\n```\n\nWith the provider in place, you can gain access to the user with the following code:\n\n```\nAuthenticationState authState = await AuthenticationStateProvider . GetAuthenticationStateAsync(); ClaimsPrincipal user = authState . User; if (user . Identity . IsAuthenticated) { // work with user.Claims and/or user.Roles }\n```\n\nNote: The AuthorizeView component, covered later in this chapter, provides a declarative way to control what a user sees on a page or component.\n\nTo work with users and claims (in Blazor Server applications) you may also need to inject a UserManager&lt;T&gt; (use IdentityUser for default) which you can use to enumerate and modify claims for a user. First inject the type and assign it to a property:\n\n```\n@inject UserManager<IdentityUser> MyUserManager\n```\n\nThen use it to work with the user's claims. The following sample shows how to add and persist a claim on a user:\n\n```\nprivate async Task AddCountryClaim() { var authState = await AuthenticationStateProvider . GetAuthenticationStateAsync(); var user = authState . User; var identityUser = await MyUserManager . FindByNameAsync(user . Identity . Name); if (!user . HasClaim(c => c . Type == ClaimTypes . Country)) {\n```\n\n```\n// stores the claim in the cookie ClaimsIdentity id = new ClaimsIdentity(); id . AddClaim(new Claim(ClaimTypes . Country , \"Canada\")); user . AddIdentity(id); // save the claim in the database await MyUserManager . AddClaimAsync(identityUser , new Claim(ClaimTypes . Country , \"Canada\")); } }\n```\n\nIf you need to work with roles, follow the same approach. You may need to inject a RoleManager&lt;T&gt; (use IdentityRole for default type) to list and manage the roles themselves.\n\nNote: In Blazor WebAssembly projects, you will need to provide server APIs to perform these operations (instead of using UserManager&lt;T&gt; or RoleManager&lt;T&gt; directly). A Blazor WebAssembly client application would manage claims and/or roles by securely calling API endpoints exposed for this purpose.", "Migration guide": "Migrating from ASP.NET Web Forms and universal providers to ASP.NET Core Identity requires several steps:\n\n['Create ASP.NET Core Identity database schema in the destination database', 'Migrate data from universal provider schema to ASP.NET Core Identity schema', 'Migrate configuration from the web.config to middleware and services, typically in Program.cs (or a Startup class)', 'Update individual pages using controls and conditionals to use tag helpers and new identity APIs.']\n\nEach of these steps is described in detail in the following sections.", "Creating the ASP.NET Core Identity schema": "There are several ways to create the necessary table structure used for ASP.NET Core Identity. The simplest is to create a new ASP.NET Core Web application. Choose Web Application and then change Authentication type to use Individual Accounts.\n\nAdditional information\n\nASP.NET Core Web App c*\n\nFramework i\n\nNET 6.0 (Long-term support)\n\nAuthentication type O\n\nIndividual Accounts\n\n/ Configure for HTTPS O\n\nL Enable Docker M\n\nDocker OS O\n\nLinux\n\nLinux macos\n\nWindows\n\nCloud\n\nService\n\nWeb\n\n<!-- image -->\n\nFrom the command line, you can do the same thing by running dotnet new webapp -au Individual. Once the app has been created, run it and register on the site. You should trigger a page like the one shown below:\n\nX\n\nInternal Server Error\n\n[]\n\nECR8 localhost:44343/Identity/Account/Register by the login. The login failed. Login failed for user 'NIGHTKING\\steve'.\n\nThere are migrations for ApplicationDbContext that have not been applied to the database\n\n\u2022 00000000000000\\_CreateldentitySchema\n\nApply Migrations\n\nPM&gt; Update-Database\n\n\u203a dotnet ef database update\n\nGuest\n\n<!-- image -->\n\nClick on the \"Apply Migrations\" button and the necessary database tables should be created for you. In addition, the migration files should appear in your project, as shown:\n\nX\n\nSolution Explorer\n\nSearch Solution Explorer (Ctrl+:)\n\nSolution 'WebApplication12' (1 of 1 project)\n\nWebApplication12\n\nConnected Services\n\nDependencies\n\nProperties wwwroot\n\nAreas\n\nData\n\nPages appsettings.json\n\nC# Program.cs\n\n<!-- image -->\n\nYou can run the migration yourself, without running the web application, using this command-line tool:\n\n<!-- image -->\n\nIf you would rather run a script to apply the new schema to an existing database, you can script these migrations from the command-line. Run this command to generate the script:\n\n<!-- image -->\n\nThe above command will produce a SQL script in the output file auth.sql, which can then be run against whatever database you like. If you have any trouble running dotnet ef commands, make sure you have the EF Core tools installed on your system .\n\nIn the event you have additional columns on your source tables, you will need to identify the best location for these columns in the new schema. Generally, columns found on the aspnet\\_Membership table should be mapped to the AspNetUsers table. Columns on aspnet\\_Roles should be mapped to AspNetRoles. Any additional columns on the aspnet\\_UsersInRoles table would be added to the AspNetUserRoles table.\n\nIt's also worth considering putting any additional columns on separate tables. So that future migrations won't need to take into account such customizations of the default identity schema.", "Migrating data from universal providers to ASP.NET Core Identity": "Once you have the destination table schema in place, the next step is to migrate your user and role records to the new schema. A complete list of the schema differences, including which columns map to which new columns, can be found here .\n\nP\n\nP\n\nP\n\nP\n\nP\n\nP\n\n['7 4 x']\n\nTo migrate your users from membership to the new identity tables, you should follow the steps described in the documentation. After following these steps and the script provided, your users will need to change their password the next time they log in.\n\nIt is possible to migrate user passwords but the process is much more involved. Requiring users to update their passwords as part of the migration process, and encouraging them to use new, unique passwords, is likely to enhance the overall security of the application.", "Migrating security settings from web.config to app startup": "As noted above, ASP.NET membership and role providers are configured in the application's web.config file. Since ASP.NET Core apps are not tied to IIS and use a separate system for configuration, these settings must be configured elsewhere. For the most part, ASP.NET Core Identity is configured in the Program.cs file. Open the web project that was created earlier (to generate the identity table schema) and review its Program.cs (or Startup.cs) file.\n\nThis code adds support for EF Core and Identity:\n\n```\n// Add services to the container. var connectionString = builder . Configuration . GetConnectionString(\"DefaultConnection\"); builder . Services . AddDbContext<ApplicationDbContext>(options => options . UseSqlServer(connectionString)); builder . Services . AddDatabaseDeveloperPageExceptionFilter(); builder . Services . AddDefaultIdentity<IdentityUser>(options => options . SignIn . RequireConfirmedAccount = true) . AddEntityFrameworkStores<ApplicationDbContext>();\n```\n\nThe AddDefaultIdentity extension method is used to configure Identity to use the default ApplicationDbContext and the framework's IdentityUser type. If you're using a custom IdentityUser, be sure to specify its type here. If these extension methods aren't working in your application, check that you have the appropriate using statements and that you have the necessary NuGet package references. For example, your project should have some version of the Microsoft.AspNetCore.Identity.EntityFrameworkCore and Microsoft.AspNetCore.Identity.UI packages referenced.\n\nAlso in Program.cs you should see the necessary middleware configured for the site. Specifically, UseAuthentication and UseAuthorization should be set up, and in the proper location.\n\n```\n// Configure the HTTP request pipeline. if (app . Environment . IsDevelopment()) { app.UseMigrationsEndPoint(); } else { app.UseExceptionHandler(\"/Error\"); // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts. app.UseHsts(); } app.UseHttpsRedirection(); app.UseStaticFiles();\n```\n\n```\napp.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); //app.MapControllers(); app.MapBlazorHub(); app.MapFallbackToPage(\"/_Host\");\n```\n\nASP.NET Identity does not configure anonymous or role-based access to locations from Program.cs . You will need to migrate any location-specific authorization configuration data to filters in ASP.NET Core. Make note of which folders and pages will require such updates. You will make these changes in the next section.", "Updating individual pages to use ASP.NET Core Identity abstractions": "In your ASP.NET Web Forms application, if you had web.config settings to deny access to certain pages or folders to anonymous users, you would migrate these changes by adding the [Authorize] attribute to such pages:\n\n```\n@attribute [Authorize]\n```\n\nIf you further had denied access except to those users belonging to a certain role, you would likewise migrate this behavior by adding an attribute specifying a role:\n\n```\n@attribute [Authorize(Roles =\"administrators\")]\n```\n\nThe [Authorize] attribute only works on @page components that are reached via the Blazor Router. The attribute does not work with child components, which should instead use AuthorizeView.\n\nIf you have logic within page markup for determining whether to display some code to a certain user, you can replace this with the AuthorizeView component. The AuthorizeView component selectively displays UI depending on whether the user is authorized to see it. It also exposes a context variable that can be used to access user information.\n\n```\n<AuthorizeView> <Authorized> <h1>Hello, @context.User.Identity.Name!</h1> <p>You can only see this content if you are authenticated.</p> </Authorized> <NotAuthorized> <h1>Authentication Failure!</h1> <p>You are not signed in.</p> </NotAuthorized> </AuthorizeView>\n```\n\nYou can access the authentication state within procedural logic by accessing the user from a Task&lt;AuthenticationState configured with the [CascadingParameter] attribute. This configuration will get you access to the user, which can let you determine if they are authenticated and if they belong to a particular role. If you need to evaluate a policy procedurally, you can inject an instance of the IAuthorizationService and calls the AuthorizeAsync method on it. The following sample code demonstrates how to get user information and allow an authorized user to perform a task restricted by the content-editor policy.\n\n```\n@using Microsoft.AspNetCore.Authorization @inject IAuthorizationService AuthorizationService <button @onclick=\"@DoSomething\">Do something important</button> @code { [CascadingParameter] private Task<AuthenticationState> authenticationStateTask { get; set; } private async Task DoSomething() { var user = (await authenticationStateTask).User; if (user.Identity.IsAuthenticated) { // Perform an action only available to authenticated (signed-in) users. } if (user.IsInRole(\"admin\")) { // Perform an action only available to users in the 'admin' role. } if ((await AuthorizationService.AuthorizeAsync(user, \"content-editor\")) .Succeeded) { // Perform an action only available to users satisfying the // 'content-editor' policy. } } }\n```\n\nThe AuthenticationState first need to be set up as a cascading value before it can be bound to a cascading parameter like this. That's typically done using the CascadingAuthenticationState component. This configuration is typically done in App.razor:\n\n```\n<CascadingAuthenticationState> <Router AppAssembly=\"@typeof(Program).Assembly\"> <Found Context=\"routeData\"> <AuthorizeRouteView RouteData=\"@routeData\" DefaultLayout=\"@typeof(MainLayout)\" /> </Found> <NotFound> <LayoutView Layout=\"@typeof(MainLayout)\"> <p>Sorry, there's nothing at this address.</p> </LayoutView> </NotFound> </Router> </CascadingAuthenticationState>\n```", "Summary": "Blazor uses the same security model as ASP.NET Core, which is ASP.NET Core Identity. Migrating from universal providers to ASP.NET Core Identity is relatively straightforward, assuming not too much customization was applied to the original data schema. Once the data has been migrated, working\n\nwith authentication and authorization in Blazor apps is well documented, with configurable as well as programmatic support for most security requirements.", "References": ["Introduction to Identity on ASP.NET Core", "Migrate from ASP.NET Membership authentication to ASP.NET Core 2.0 Identity", "Migrate Authentication and Identity to ASP.NET Core", "ASP.NET Core Blazor authentication and authorization"], "Migrate from ASP.NET Web Forms to Blazor": "Migrating a code base from ASP.NET Web Forms to Blazor is a time-consuming task that requires planning. This chapter outlines the process. Something that can ease the transition is to ensure the app adheres to an N-tier architecture, wherein the app model (in this case, Web Forms) is separate from the business logic. This logical separation of layers makes it clear what needs to move to .NET Core and Blazor.\n\nFor this example, the eShop app available on GitHub is used. eShop is a catalog service that provides CRUD capabilities via form entry and validation.\n\nWhy should a working app be migrated to Blazor? Many times, there's no need. ASP.NET Web Forms will continue to be supported for many years. However, many of the features that Blazor provides are only supported on a migrated app. Such features include:\n\n['Performance improvements in the framework such as Span&lt;T&gt;', 'Ability to run as WebAssembly', 'Cross -platform support for Linux and macOS', 'App -local deployment or shared framework deployment without impacting other apps']\n\nIf these or other new features are compelling enough, there may be value in migrating the app. The migration can take different shapes; it can be the entire app, or only certain endpoints that require the changes. The decision to migrate is ultimately based on the business problems to be solved by the developer.", "Server -side versus client -side hosting": "As described in the hosting models chapter, a Blazor app can be hosted in two different ways: serverside and client -side. The server -side model uses ASP.NET Core SignalR connections to manage the DOM updates while running any actual code on the server. The client-side model runs as WebAssembly within a browser and requires no server connections. There are a number of differences that may affect which is best for a specific app:\n\n[\"Running as WebAssembly doesn't support all features (such as threading) at the current time\", 'Chatty communication between the client and server may cause latency issues in server-side mode']\n\n<!-- image -->\n\n['Access to databases and internal or protected services require a separate service with clientside hosting']\n\nAt the time of writing, the server-side model more closely resembles Web Forms. Most of this chapter focuses on the server -side hosting model, as it's production-ready.", "Create a new project": "This initial migration step is to create a new project. This project type is based on the SDK style projects of .NET and simplifies much of the boilerplate that was used in previous project formats. For more detail, please see the chapter on Project Structure .\n\nOnce the project has been created, install the libraries that were used in the previous project. In older Web Forms projects, you may have used the packages.config file to list the required NuGet packages. In the new SDK -style project, packages.config has been replaced with &lt;PackageReference&gt; elements in the project file. A benefit to this approach is that all dependencies are installed transitively. You only list the top-level dependencies you care about.\n\nMany of the dependencies you're using are available for .NET, including Entity Framework 6 and log4net. If there's no .NET or .NET Standard version available, the .NET Framework version can often be used. Your mileage may vary. Any API used that isn't available in .NET causes a runtime error. Visual Studio notifies you of such packages. A yellow icon appears on the project's References node in Solution Explorer .\n\nIn the Blazor -based eShop project, you can see the packages that are installed. Previously, the packages.config file listed every package used in the project, resulting in a file almost 50 lines long. A snippet of packages.config is:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <packages> ... <package id=\"Microsoft.ApplicationInsights.Agent.Intercept\" version=\"2.4.0\" targetFramework=\"net472\" /> <package id=\"Microsoft.ApplicationInsights.DependencyCollector\" version=\"2.9.1\" targetFramework=\"net472\" /> <package id=\"Microsoft.ApplicationInsights.PerfCounterCollector\" version=\"2.9.1\" targetFramework=\"net472\" /> <package id=\"Microsoft.ApplicationInsights.Web\" version=\"2.9.1\" targetFramework=\"net472\" /> <package id=\"Microsoft.ApplicationInsights.WindowsServer\" version=\"2.9.1\" targetFramework=\"net472\" /> <package id=\"Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel\" version=\"2.9.1\" targetFramework=\"net472\" /> <package id=\"Microsoft.AspNet.FriendlyUrls\" version=\"1.0.2\" targetFramework=\"net472\" /> <package id=\"Microsoft.AspNet.FriendlyUrls.Core\" version=\"1.0.2\" targetFramework=\"net472\" /> <package id=\"Microsoft.AspNet.ScriptManager.MSAjax\" version=\"5.0.0\" targetFramework=\"net472\" /> <package id=\"Microsoft.AspNet.ScriptManager.WebForms\" version=\"5.0.0\" targetFramework=\"net472\" /> ... <package id=\"System.Memory\" version=\"4.5.1\" targetFramework=\"net472\" /> <package id=\"System.Numerics.Vectors\" version=\"4.4.0\" targetFramework=\"net472\" /> <package id=\"System.Runtime.CompilerServices.Unsafe\" version=\"4.5.0 \"\n```\n\n```\ntargetFramework=\"net472\" /> <package id=\"System.Threading.Channels\" version=\"4.5.0\" targetFramework=\"net472\" /> <package id=\"System.Threading.Tasks.Extensions\" version=\"4.5.1\" targetFramework=\"net472\" /> <package id=\"WebGrease\" version=\"1.6.0\" targetFramework=\"net472\" /> </packages>\n```\n\nThe &lt;packages&gt; element includes all necessary dependencies. It's difficult to identify which of these packages are included because you require them. Some &lt;package&gt; elements are listed simply to satisfy the needs of dependencies you require.\n\nThe Blazor project lists the dependencies you require within an &lt;ItemGroup&gt; element in the project file:\n\n```\n<ItemGroup> <PackageReference Include=\"Autofac\" Version=\"4.9.3\" /> <PackageReference Include=\"EntityFramework\" Version=\"6.4.4\" /> <PackageReference Include=\"log4net\" Version=\"2.0.12\" /> <PackageReference Include=\"Microsoft.Extensions.Logging.Log4Net.AspNetCore\" Version=\"2.2.12\" /> </ItemGroup>\n```\n\nOne NuGet package that simplifies the life of Web Forms developers is the Windows Compatibility Pack. Although .NET is cross-platform, some features are only available on Windows. Windowsspecific features are made available by installing the compatibility pack. Examples of such features include the Registry, WMI, and Directory Services. The package adds around 20,000 APIs and activates many services with which you may already be familiar. The eShop project doesn't require the compatibility pack; but if your projects use Windows-specific features, the package eases the migration efforts.", "Enable startup process": "The startup process for Blazor has changed from Web Forms and follows a similar setup for other ASP.NET Core services. When hosted server -side, Razor components are run as part of a normal ASP.NET Core app. When hosted in the browser with WebAssembly, Razor components use a similar hosting model. The difference is the components are run as a separate service from any of the backend processes. Either way, the startup is similar.\n\nThe Global.asax.cs file is the default startup page for Web Forms projects. In the eShop project, this file configures the Inversion of Control (IoC) container and handles the various lifecycle events of the app or request. Some of these events are handled with middleware (such as Application\\_BeginRequest). Other events require the overriding of specific services via dependency injection (DI).\n\nBy way of example, the Global.asax.cs file for eShop, contains the following code:\n\n```\npublic class Global : HttpApplication , IContainerProviderAccessor { private static readonly ILog _log = LogManager . GetLogger(System . Reflection . MethodBase . GetCurrentMethod().DeclaringType); static IContainerProvider _containerProvider; IContainer container;\n```\n\n```\npublic IContainerProvider ContainerProvider { get { return _containerProvider; } } protected void Application_Start(object sender , EventArgs e) { // Code that runs on app startup RouteConfig . RegisterRoutes(RouteTable . Routes); BundleConfig . RegisterBundles(BundleTable . Bundles); ConfigureContainer(); ConfigDataBase(); } /// <summary> /// Track the machine name and the start time for the session inside the current session /// </summary> protected void Session_Start(Object sender , EventArgs e) { HttpContext . Current . Session[\"MachineName\"] = Environment . MachineName; HttpContext . Current . Session[\"SessionStartTime\"] = DateTime . Now; } /// <summary> /// https://autofaccn.readthedocs.io/en/latest/integration/webforms.html /// </summary> private void ConfigureContainer() { var builder = new ContainerBuilder(); var mockData = bool . Parse(ConfigurationManager . AppSettings[\"UseMockData\"]); builder . RegisterModule(new ApplicationModule(mockData)); container = builder . Build(); _containerProvider = new ContainerProvider(container); } private void ConfigDataBase() { var mockData = bool . Parse(ConfigurationManager . AppSettings[\"UseMockData\"]); if (!mockData) { Database . SetInitializer<CatalogDBContext>(container . Resolve<CatalogDBInitializer>()); } } protected void Application_BeginRequest(object sender , EventArgs e) { //set the property to our new object LogicalThreadContext . Properties[\"activityid\"] = new ActivityIdHelper(); LogicalThreadContext . Properties[\"requestinfo\"] = new WebRequestInfo(); _log . Debug(\"Application_BeginRequest\"); } }\n```\n\nThe preceding file becomes the Program.cs file in server-side Blazor:\n\n```\nusing eShopOnBlazor . Models; using eShopOnBlazor . Models . Infrastructure; using eShopOnBlazor . Services; using log4net; using System . Data . Entity; using eShopOnBlazor; var builder = WebApplication . CreateBuilder(args); // add services builder . Services . AddRazorPages(); builder . Services . AddServerSideBlazor(); if (builder . Configuration . GetValue<bool>(\"UseMockData\")) { builder . Services . AddSingleton<ICatalogService , CatalogServiceMock>(); } else { builder . Services . AddScoped<ICatalogService , CatalogService>(); builder . Services . AddScoped<IDatabaseInitializer<CatalogDBContext>, CatalogDBInitializer>(); builder . Services . AddSingleton<CatalogItemHiLoGenerator>(); builder . Services . AddScoped( _ => new CatalogDBContext(builder . Configuration . GetConnectionString(\"CatalogDBContext\"))); } var app = builder . Build(); new LoggerFactory().AddLog4Net(\"log4Net.xml\"); if (app . Environment . IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(\"/Home/Error\"); } // Middleware for Application_BeginRequest app.Use((ctx , next) => { LogicalThreadContext . Properties[\"activityid\"] = new ActivityIdHelper(ctx); LogicalThreadContext . Properties[\"requestinfo\"] = new WebRequestInfo(ctx); return next(); }); app.UseStaticFiles(); app.UseRouting(); app.UseEndpoints(endpoints => { endpoints . MapBlazorHub(); endpoints . MapFallbackToPage(\"/_Host\"); }); ConfigDataBase(app);\n```\n\n```\nvoid ConfigDataBase(IApplicationBuilder app) { using (var scope = app . ApplicationServices . CreateScope()) { var initializer = scope.ServiceProvider . GetService<IDatabaseInitializer<CatalogDBContext>>(); if (initializer != null) { Database . SetInitializer(initializer); } } } app.Run();\n```\n\nOne significant change you may notice from Web Forms is the prominence of dependency injection (DI). DI has been a guiding principle in the ASP.NET Core design. It supports customization of almost all aspects of the ASP.NET Core framework. There's even a built-in service provider that can be used for many scenarios. If more customization is required, it can be supported by many community projects. For example, you can carry forward your third-party DI library investment.\n\nIn the original eShop app, there's some configuration for session management. Since server-side Blazor uses ASP.NET Core SignalR for communication, the session state isn't supported as the connections may occur independent of an HTTP context. An app that uses the session state requires rearchitecting before running as a Blazor app.\n\nFor more information about app startup, see App startup .", "Migrate HTTP modules and handlers to middleware": "HTTP modules and handlers are common patterns in Web Forms to control the HTTP request pipeline. Classes that implement IHttpModule or IHttpHandler could be registered and process incoming requests. Web Forms configure modules and handlers in the web.config file. Web Forms is also heavily based on app lifecycle event handling. ASP.NET Core uses middleware instead. Middleware is registered in the Configure method of the Startup class. Middleware execution order is determined by the registration order.\n\nIn the Enable startup process section, a lifecycle event was raised by Web Forms as the Application\\_BeginRequest method. This event isn't available in ASP.NET Core. One way to achieve this behavior is to implement middleware as seen in the Startup.cs file example. This middleware does the same logic and then transfers control to the next handler in the middleware pipeline.\n\nFor more information on migrating modules and handlers, see Migrate HTTP handlers and modules to ASP.NET Core middleware .", "Migrate static files": "To serve static files (for example, HTML, CSS, images, and JavaScript), the files must be exposed by middleware. Calling the UseStaticFiles method enables the serving of static files from the web root path. The default web root directory is wwwroot, but it can be customized. As included in the Program.cs file:\n\n```\n... app.UseStaticFiles(); ...\n```\n\nThe eShop project enables basic static file access. There are many customizations available for static file access. For information on enabling default files or a file browser, see Static files in ASP.NET Core .", "Migrate runtime bundling and minification setup": "Bundling and minification are performance optimization techniques for reducing the number and size of server requests to retrieve certain file types. JavaScript and CSS often undergo some form of bundling or minification before being sent to the client. In ASP.NET Web Forms, these optimizations are handled at run time. The optimization conventions are defined an App\\_Start/BundleConfig.cs file. In ASP.NET Core, a more declarative approach is adopted. A file lists the files to be minified, along with specific minification settings.\n\nFor more information on bundling and minification, see Bundle and minify static assets in ASP.NET Core .", "Migrate ASPX pages": "A page in a Web Forms app is a file with the .aspx extension. A Web Forms page can often be mapped to a component in Blazor. A Razor component is authored in a file with the .razor extension. For the eShop project, five pages are converted to a Razor page.\n\nFor example, the details view comprises three files in the Web Forms project: Details.aspx, x, Details.aspx.cs, and Details.aspx.designer.cs. When converting to Blazor, the code-behind and markup are combined into Details.razor. Razor compilation (equivalent to what's in .designer.cs files) is stored in the obj directory and isn't, by default, viewable in Solution Explorer. The Web Forms page consists of the following markup:\n\n```\n<%@ Page Title=\"Details\" Language=\"C#\" MasterPageFile=\"~/Site.Master\" AutoEventWireup=\"true\" CodeBehind=\"Details.aspx.cs\" Inherits=\"eShopLegacyWebForms.Catalog.Details\" %> <asp:Content ID=\"Details\" ContentPlaceHolderID=\"MainContent\" runat=\"server\"> <h2 class=\"esh -body-title\">Details</h2> <div class=\"container\"> <div class=\"row\">\n```\n\n```\n<asp:Image runat=\"server\" CssClass=\"col-md-6 esh-picture\" ImageUrl='<%#\"/Pics/\" + product.PictureFileName%>' /> <dl class=\"col -md -6 dl -horizontal\"> <dt>Name </dt> <dd> <asp:Label runat=\"server\" Text='<%#product.Name%>' /> </dd> <dt>Description </dt> <dd> <asp:Label runat=\"server\" Text='<%#product.Description%>' /> </dd> <dt>Brand </dt> <dd> <asp:Label runat=\"server\" Text='<%#product.CatalogBrand.Brand%>' /> </dd> <dt>Type </dt> <dd> <asp:Label runat=\"server\" Text='<%#product.CatalogType.Type%>' /> </dd> <dt>Price </dt> <dd> <asp:Label CssClass=\"esh-price\" runat=\"server\" Text='<%#product.Price%>' /> </dd> <dt>Picture name </dt> <dd> <asp:Label runat=\"server\" Text='<%#product.PictureFileName%>' /> </dd> <dt>Stock </dt> <dd> <asp:Label runat=\"server\" Text='<%#product.AvailableStock%>' /> </dd> <dt>Restock </dt> <dd> <asp:Label runat=\"server\" Text='<%#product.RestockThreshold%>' /> </dd> <dt>Max stock </dt>\n```\n\n```\n<dd> <asp:Label runat=\"server\" Text='<%#product.MaxStockThreshold%>' /> </dd> </dl> </div> <div class=\"form -actions no -color esh -link -list\"> <a runat=\"server\" href='<%# GetRouteUrl(\"EditProductRoute\", new {id =product.Id}) %>' class=\"esh-link-item\">Edit </a> | <a runat=\"server\" href=\"~\" class=\"esh -link -item\">Back to list </a> </div> </div> </asp:Content>\n```\n\nThe preceding markup\u2019s code-behind includes the following code:\n\n```\nusing eShopLegacyWebForms . Models; using eShopLegacyWebForms . Services; using log4net; using System; using System . Web . UI; namespace eShopLegacyWebForms . Catalog { public partial class Details : System . Web . UI . Page { private static readonly ILog _log = LogManager . GetLogger(System . Reflection . MethodBase . GetCurrentMethod().DeclaringType); protected CatalogItem product; public ICatalogService CatalogService { get; set; } protected void Page_Load(object sender , EventArgs e) { var productId = Convert . ToInt32(Page . RouteData . Values[\"id\"]); _log . Info($\"Now loading... /Catalog/Details.aspx?id={productId}\"); product = CatalogService . FindCatalogItem(productId); this . DataBind(); } } }\n```\n\nWhen converted to Blazor, the Web Forms page translates to the following code:\n\n```\n@page \"/Catalog/Details/{id:int}\" @inject ICatalogService CatalogService @inject ILogger<Details> Logger <h2 class=\"esh -body-title\">Details</h2> <div class=\"container\"> <div class=\"row\">\n```\n\n```\n<img class=\"col-md-6 esh-picture\" src=\"@($\"/Pics/{_item.PictureFileName}\")\"> <dl class=\"col -md -6 dl -horizontal\"> <dt> Name </dt> <dd> @_item.Name </dd> <dt> Description </dt> <dd> @_item.Description </dd> <dt> Brand </dt> <dd> @_item.CatalogBrand.Brand </dd> <dt> Type </dt> <dd> @_item.CatalogType.Type </dd> <dt> Price </dt> <dd> @_item.Price </dd> <dt> Picture name </dt> <dd> @_item.PictureFileName </dd> <dt> Stock </dt> <dd> @_item.AvailableStock </dd> <dt> Restock </dt>\n```\n\n```\n<dd> @_item.RestockThreshold </dd> <dt> Max stock </dt> <dd> @_item.MaxStockThreshold </dd> </dl> </div> <div class=\"form -actions no -color esh -link -list\"> <a href=\"@($\"/Catalog/Edit/{_item.Id}\")\" class=\"esh-link-item\"> Edit </a> | <a href=\"/\" class=\"esh-link-item\"> Back to list </a> </div> </div> @code { private CatalogItem _item; [Parameter] public int Id { get; set; } protected override void OnInitialized() { Logger.LogInformation(\"Now loading... /Catalog/Details/{Id}\", Id); _item = CatalogService.FindCatalogItem(Id); } }\n```\n\nNotice that the code and markup are in the same file. Any required services are made accessible with the @inject attribute. Per the @page directive, this page can be accessed at the Catalog/Details/{id} route. The value of the route's {id} placeholder has been constrained to an integer. As described in the routing section, unlike Web Forms, a Razor component explicitly states its route and any parameters that are included. Many Web Forms controls may not have exact counterparts in Blazor. There's often an equivalent HTML snippet that will serve the same purpose. For example, the &lt;asp:Label /&gt; control can be replaced with an HTML &lt;label&gt; element.", "Model validation in Blazor": "If your Web Forms code includes validation, you can transfer much of what you have with little-to-no changes. A benefit to running in Blazor is that the same validation logic can be run without needing custom JavaScript. Data annotations enable easy model validation.\n\nFor example, the Create.aspx page has a data entry form with validation. An example snippet would look like this:\n\n```\n<div class=\"form -group\"> <label class=\"control -label col -md -2\">Name</label> <div class=\"col -md -3\"> <asp:TextBox ID=\"Name\" runat=\"server\" CssClass=\"form-control\"></asp:TextBox> <asp:RequiredFieldValidator runat=\"server\" ControlToValidate=\"Name\" Display=\"Dynamic\" CssClass=\"field -validation -valid text -danger\" ErrorMessage=\"The Name field is required.\" /> </div> </div>\n```\n\nIn Blazor, the equivalent markup is provided in a Create.razor file:\n\n```\n<EditForm Model=\"_item\" OnValidSubmit=\"@...\"> <DataAnnotationsValidator /> <div class=\"form -group\"> <label class=\"control -label col -md -2\">Name</label> <div class=\"col -md -3\"> <InputText class=\"form-control\" @bind-Value=\"_item.Name\" /> <ValidationMessage For=\"(() => _item.Name)\" /> </div> </div> ... </EditForm>\n```\n\nThe EditForm context includes validation support and can be wrapped around an input. Data annotations are a common way to add validation. Such validation support can be added via the DataAnnotationsValidator component. For more information on this mechanism, see ASP.NET Core Blazor forms and validation .", "Migrate configuration": "In a Web Forms project, configuration data is most commonly stored in the web.config file. The configuration data is accessed with ConfigurationManager. Services were often required to parse objects. With .NET Framework 4.7.2, composability was added to the configuration via ConfigurationBuilders. These builders allowed developers to add various sources for the configuration that was then composed at run time to retrieve the necessary values.\n\nASP.NET Core introduced a flexible configuration system that allows you to define the configuration source or sources used by your app and deployment. The ConfigurationBuilder infrastructure that you may be using in your Web Forms app was modeled after the concepts used in the ASP.NET Core configuration system.\n\nThe following snippet demonstrates how the Web Forms eShop project uses web.config to store configuration values:\n\n```\n<configuration> <configSections> <section name=\"entityFramework\"\n```\n\n```\ntype=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" /> </configSections> <connectionStrings> <add name=\"CatalogDBContext\" connectionString=\"Data Source=(localdb)\\MSSQLLocalDB; Initial Catalog=Microsoft.eShopOnContainers.Services.CatalogDb; Integrated Security=True; MultipleActiveResultSets=True;\" providerName=\"System.Data.SqlClient\" /> </connectionStrings> <appSettings> <add key=\"UseMockData\" value=\"true\" /> <add key=\"UseCustomizationData\" value=\"false\" /> </appSettings> </configuration>\n```\n\nIt's common for secrets, such as database connection strings, to be stored within the web.config. The secrets are inevitably persisted in unsecure locations, such as source control. With Blazor on ASP.NET Core, the preceding XML-based configuration is replaced with the following JSON:\n\n```\n{ \"ConnectionStrings\": { \"CatalogDBContext\": \"Data Source=(localdb)\\\\MSSQLLocalDB; Initial Catalog=Microsoft.eShopOnContainers.Services.CatalogDb; Integrated Security=True; MultipleActiveResultSets=True;\" }, \"UseMockData\": true , \"UseCustomizationData\": false }\n```\n\nJSON is the default configuration format; however, ASP.NET Core supports many other formats, including XML. There are also several community-supported formats.\n\nYou can access configuration values from the builder in Program.cs:\n\n```\nif (builder . Configuration . GetValue<bool>(\"UseMockData\")) { builder . Services . AddSingleton<ICatalogService , CatalogServiceMock>(); } else { builder . Services . AddScoped<ICatalogService , CatalogService>(); builder . Services . AddScoped<IDatabaseInitializer<CatalogDBContext>, CatalogDBInitializer>(); builder . Services . AddSingleton<CatalogItemHiLoGenerator>(); builder . Services . AddScoped( _ => new CatalogDBContext(builder . Configuration . GetConnectionString(\"CatalogDBContext\"))); }\n```\n\nBy default, environment variables, JSON files (appsettings.json and appsettings.{Environment}.json), and command -line options are registered as valid configuration sources in the configuration object. The configuration sources can be accessed via Configuration[key]. A more advanced technique is to bind the configuration data to objects using the options pattern. For more information on configuration and the options pattern, see Configuration in ASP.NET Core and Options pattern in ASP.NET Core , respectively.", "Migrate data access": "Data access is an important aspect of any app. The eShop project stores catalog information in a database and retrieves the data with Entity Framework (EF) 6. Since EF 6 is supported in .NET 5, the project can continue to use it.\n\nThe following EF-related changes were necessary to eShop:\n\n[\"In .NET Framework, the DbContext object accepts a string of the form name=ConnectionString and uses the connection string from ConfigurationManager.AppSettings[ConnectionString] to connect. In .NET Core, this isn't supported. The connection string must be supplied.\", 'The database was accessed in a synchronous way. Though this works, scalability may suffer. This logic should be moved to an asynchronous pattern.']\n\nAlthough there isn't the same native support for dataset binding, Blazor provides flexibility and power with its C# support in a Razor page. For example, you can perform calculations and display the result. For more information on data patterns in Blazor, see the Data access chapter.", "Architectural changes": "Finally, there are some important architectural differences to consider when migrating to Blazor. Many of these changes are applicable to anything based on .NET Core or ASP.NET Core.\n\nBecause Blazor is built on .NET Core, there are considerations in ensuring support on .NET Core. Some of the major changes include the removal of the following features:\n\n['Multiple AppDomains', 'Remoting', 'Code Access Security (CAS)', 'Security Transparency']\n\nFor more information on techniques to identify necessary changes to support running on .NET Core, see Port your code from .NET Framework to .NET Core .\n\nASP.NET Core is a reimagined version of ASP.NET and has some changes that may not initially seem obvious. The main changes are:\n\n[\"No synchronization context, which means there's no HttpContext.Current, Thread.CurrentPrincipal, or other static accessors\", 'No shadow copying', 'No request queue']\n\nMany operations in ASP.NET Core are asynchronous, which allows easier off-loading of I/O-bound tasks. It's important to never block by using Task.Wait() or Task.GetResult(), which can quickly exhaust thread pool resources.", "Migration conclusion": "At this point, you've seen many examples of what it takes to move a Web Forms project to Blazor. For a full example, see the eShopOnBlazor project."}}