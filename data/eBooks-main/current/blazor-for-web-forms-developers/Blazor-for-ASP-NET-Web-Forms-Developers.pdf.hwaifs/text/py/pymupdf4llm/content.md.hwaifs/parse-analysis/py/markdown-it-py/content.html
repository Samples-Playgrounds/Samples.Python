<p><strong>EDITION v8.0</strong> - Updated to .NET 8</p>
<p><a href="https://aka.ms/blazor-ebook-changelog">Refer to changelog</a> for the book updates and community contributions.</p>
<p>PUBLISHED BY</p>
<p>Microsoft Developer Division, .NET, and Visual Studio product teams</p>
<p>A division of Microsoft Corporation</p>
<p>One Microsoft Way</p>
<p>Redmond, Washington 98052-6399</p>
<p>Copyright © 2023 by Microsoft Corporation</p>
<p>All rights reserved. No part of the contents of this book may be reproduced or transmitted in any<br />
form or by any means without the written permission of the publisher.</p>
<p>This book is provided “as-is” and expresses the author’s views and opinions. The views, opinions, and<br />
information expressed in this book, including URL and other Internet website references, may change<br />
without notice.</p>
<p>Some examples depicted herein are provided for illustration only and are fictitious. No real association<br />
or connection is intended or should be inferred.</p>
<p><a href="https://www.microsoft.com/">Microsoft and the trademarks listed at https://www.microsoft.com</a> on the “Trademarks” webpage are<br />
trademarks of the Microsoft group of companies.</p>
<p>Mac and macOS are trademarks of Apple Inc.</p>
<p>All other marks and logos are property of their respective owners.</p>
<p>Authors:</p>
<p><strong><a href="https://github.com/danroth27">Daniel Roth</a></strong>, Principal Program Manager, Microsoft Corp.</p>
<p><strong><a href="https://github.com/csharpfritz">Jeff Fritz</a></strong>, Senior Program Manager, Microsoft Corp.</p>
<p><strong><a href="https://github.com/twsouthwick">Taylor Southwick</a></strong>, Senior Software Engineer, Microsoft Corp.</p>
<p><strong><a href="https://github.com/scottaddie">Scott Addie</a></strong>, Senior Content Developer, Microsoft Corp.</p>
<p><strong><a href="https://github.com/ardalis">Steve “@ardalis” Smith</a></strong>, Software Architect and Trainer, NimblePros.com</p>
<h3>Introduction</h3>
<p>.NET has long supported web app development through ASP.NET, a comprehensive set of frameworks<br />
and tools for building any kind of web app. ASP.NET has its own lineage of web frameworks and<br />
technologies starting all the way back with classic Active Server Pages (ASP). Frameworks like ASP.NET<br />
Web Forms, ASP.NET MVC, ASP.NET Web Pages, and more recently ASP.NET Core, provide a<br />
productive and powerful way to build <em>server-rendered</em> web apps, where UI content is dynamically<br />
generated on the server in response to HTTP requests. Each ASP.NET framework caters to a different<br />
audience and app building philosophy. ASP.NET Web Forms shipped with the original release of the<br />
.NET Framework and enabled web development using many of the patterns familiar to desktop</p>
<p>developers, like reusable UI controls with simple event handling. However, none of the ASP.NET<br />
offerings provide a way to run code that executed in the user’s browser. To do that requires writing<br />
JavaScript and using any of the many JavaScript frameworks and tools that have phased in and out of<br />
popularity over the years: jQuery, Knockout, Angular, React, and so on.</p>
<p><a href="https://blazor.net/">Blazor</a> is a new web framework that changes what is possible when building web apps with .NET.<br />
Blazor is a client-side web UI framework based on C# instead of JavaScript. With Blazor you can write<br />
your client-side logic and UI components in C#, compile them into normal .NET assemblies, and then<br />
run them directly in the browser using a new open web standard called WebAssembly. Or<br />
alternatively, Blazor can run your .NET UI components on the server and handle all UI interactions<br />
fluidly over a real-time connection with the browser. When paired with .NET running on the server,<br />
Blazor enables full-stack web development with .NET. While Blazor shares many commonalities with<br />
ASP.NET Web Forms, like having a reusable component model and a simple way to handle user<br />
events, it also builds on the foundations of .NET to provide a modern and high-performance web<br />
development experience.</p>
<p>This book introduces ASP.NET Web Forms developers to Blazor in a way that is familiar and<br />
convenient. It introduces Blazor concepts in parallel with analogous concepts in ASP.NET Web Forms<br />
while also explaining new concepts that may be less familiar. It covers a broad range of topics and<br />
concerns including component authoring, routing, layout, configuration, and security. And while the<br />
content of this book is primarily for enabling new development, it also covers guidelines and<br />
strategies for migrating existing ASP.NET Web Forms to Blazor for when you want to modernize an<br />
existing app.</p>
<h3>Who should use the book</h3>
<p>This book is for ASP.NET Web Forms developers looking for an introduction to Blazor that relates to<br />
their existing knowledge and skills. This book can help with quickly getting started on a new Blazorbased project or to help chart a roadmap for modernizing an existing ASP.NET Web Forms<br />
application.</p>
<h3>How to use the book</h3>
<p>The first part of this book covers what Blazor is and compares it to web app development with<br />
ASP.NET Web Forms. The book then covers a variety of Blazor topics, chapter by chapter, and relates<br />
each Blazor concept to the corresponding concept in ASP.NET Web Forms, or explains fully any<br />
completely new concepts. The book also refers regularly to a complete sample app implemented in<br />
both ASP.NET Web Forms and Blazor to demonstrate Blazor features and to provide a case study for<br />
migrating from ASP.NET Web Forms to Blazor. You can find both implementations of the sample app<br />
<a href="https://github.com/dotnet-architecture/eshoponblazor">(ASP.NET Web Forms and Blazor versions) on GitHub.</a></p>
<h3>What this book doesn’t cover</h3>
<p>This book is an introduction to Blazor, not a comprehensive migration guide. While it does include<br />
guidance on how to approach migrating a project from ASP.NET Web Forms to Blazor, it does not</p>
<p>attempt to cover every nuance and detail. For more general guidance on migrating from ASP.NET to<br />
<a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/">ASP.NET Core, refer to the migration guidance</a> in the ASP.NET Core documentation.</p>
<h4><strong>Additional resources</strong></h4>
<p><a href="https://blazor.net/">You can find the official Blazor home page and documentation at https://blazor.net.</a></p>
<h2>Contents</h2>
<p><strong>An introduction to Blazor for ASP.NET Web Forms developers ........................................ 1</strong></p>
<p>An open-source and cross-platform .NET ..................................................................................................................... 2</p>
<p>Client-side web development ............................................................................................................................................. 3</p>
<p>WebAssembly fulfills a need ............................................................................................................................................... 3</p>
<p>Blazor: full-stack web development with .NET ............................................................................................................. 4</p>
<p>Get started with Blazor .......................................................................................................................................................... 4</p>
<p><strong>Architecture comparison of ASP.NET Web Forms and Blazor ............................................ 5</strong></p>
<p>ASP.NET Web Forms ............................................................................................................................................................... 5</p>
<p>Blazor ............................................................................................................................................................................................ 6</p>
<p><strong>Blazor app hosting models ..................................................................................................... 8</strong></p>
<p>Blazor WebAssembly apps ................................................................................................................................................... 8</p>
<p>Blazor Server apps ................................................................................................................................................................... 9</p>
<p>How to choose the right Blazor hosting model ....................................................................................................... 10</p>
<p>Deploy your app .................................................................................................................................................................... 11</p>
<p><strong>Project structure for Blazor apps ......................................................................................... 12</strong></p>
<p>Project file ................................................................................................................................................................................ 12</p>
<p>Entry point ............................................................................................................................................................................... 13</p>
<p>Static files ................................................................................................................................................................................. 15</p>
<p>Configuration.......................................................................................................................................................................... 15</p>
<p>Razor components ............................................................................................................................................................... 15</p>
<p>Pages .......................................................................................................................................................................................... 16</p>
<p>Layout ........................................................................................................................................................................................ 16</p>
<p>Bootstrap Blazor .................................................................................................................................................................... 16</p>
<p>Build output ............................................................................................................................................................................ 18</p>
<p>Run the app with Hot Reload........................................................................................................................................... 18</p>
<p><strong>App startup ............................................................................................................................ 21</strong></p>
<p>Application_Start and Web Forms ................................................................................................................................. 21</p>
<p>Blazor Server Startup Structure ....................................................................................................................................... 21</p>
<p>i Contents</p>
<p>Upgrading the BundleConfig Process .......................................................................................................................... 23</p>
<p><strong>Build reusable UI components with Blazor......................................................................... 24</strong></p>
<p>An introduction to Razor ................................................................................................................................................... 24</p>
<p>Use components ................................................................................................................................................................... 28</p>
<p>Modify page title from components ............................................................................................................................. 28</p>
<p>Component parameters ..................................................................................................................................................... 29</p>
<p>Query string parameters ............................................................................................................................................... 29</p>
<p>Components and error boundaries ............................................................................................................................... 30</p>
<p>Event handlers ........................................................................................................................................................................ 30</p>
<p>Data binding ........................................................................................................................................................................... 32</p>
<p>State changes ......................................................................................................................................................................... 33</p>
<p>Component lifecycle ............................................................................................................................................................ 34</p>
<p>OnInitialized ....................................................................................................................................................................... 34</p>
<p>OnParametersSet ............................................................................................................................................................. 35</p>
<p>OnAfterRender .................................................................................................................................................................. 35</p>
<p>IDisposable ......................................................................................................................................................................... 35</p>
<p>Capture component references ...................................................................................................................................... 36</p>
<p>Capture element references ............................................................................................................................................. 36</p>
<p>Templated components ..................................................................................................................................................... 36</p>
<p>Child content...................................................................................................................................................................... 37</p>
<p>Template parameters ...................................................................................................................................................... 37</p>
<p>Code-behind ........................................................................................................................................................................... 38</p>
<p>Additional resources ............................................................................................................................................................ 39</p>
<p><strong>Pages, routing, and layouts .................................................................................................. 40</strong></p>
<p>Create pages ........................................................................................................................................................................... 41</p>
<p>Router component ............................................................................................................................................................... 42</p>
<p>Navigation ............................................................................................................................................................................... 42</p>
<p>Base URLs ................................................................................................................................................................................. 43</p>
<p>Page layout .............................................................................................................................................................................. 43</p>
<p><strong>State management ................................................................................................................ 46</strong></p>
<p>Request state management with ViewState .............................................................................................................. 46</p>
<p>ii Contents</p>
<p>Maintain state with Session .............................................................................................................................................. 47</p>
<p>Application state ................................................................................................................................................................... 47</p>
<p>In the browser ........................................................................................................................................................................ 48</p>
<p><strong>Forms and validation ............................................................................................................ 49</strong></p>
<p>Additional resources ............................................................................................................................................................ 51</p>
<p><strong>Work with data ...................................................................................................................... 52</strong></p>
<p>Entity Framework .................................................................................................................................................................. 52</p>
<p>EF Code First....................................................................................................................................................................... 53</p>
<p>EF Database First .............................................................................................................................................................. 54</p>
<p>Interact with web services ................................................................................................................................................. 54</p>
<p><strong>Modules, handlers, and middleware ................................................................................... 56</strong></p>
<p>Overview ................................................................................................................................................................................... 56</p>
<p>Katana ........................................................................................................................................................................................ 57</p>
<p>Common middleware .......................................................................................................................................................... 57</p>
<p>Custom middleware ............................................................................................................................................................. 58</p>
<p><strong>App configuration ................................................................................................................. 60</strong></p>
<p>Configuration sources ......................................................................................................................................................... 60</p>
<p>appsettings.json format and access .............................................................................................................................. 61</p>
<p>User secrets ............................................................................................................................................................................. 61</p>
<p>Environment variables ......................................................................................................................................................... 61</p>
<p>Command-line arguments ................................................................................................................................................ 62</p>
<p>The return of web.config ................................................................................................................................................... 62</p>
<p>Read configuration in the app ......................................................................................................................................... 63</p>
<p>Strongly typed configuration ........................................................................................................................................... 63</p>
<p><strong>Security: Authentication and Authorization in ASP.NET Web Forms and Blazor ........... 65</strong></p>
<p>ASP.NET universal providers ............................................................................................................................................. 65</p>
<p>Authorization configuration in Web Forms ........................................................................................................... 66</p>
<p>Authorization code in Web Forms ............................................................................................................................ 67</p>
<p>ASP.NET Core Identity ......................................................................................................................................................... 68</p>
<p>Roles, claims, and policies ............................................................................................................................................ 68</p>
<p>Migration guide ................................................................................................................................................................ 70</p>
<p>iii Contents</p>
<p>Creating the ASP.NET Core Identity schema ......................................................................................................... 70</p>
<p>Migrating data from universal providers to ASP.NET Core Identity ............................................................ 73</p>
<p>Migrating security settings from web.config to app startup .......................................................................... 74</p>
<p>Updating individual pages to use ASP.NET Core Identity abstractions ..................................................... 75</p>
<p>Summary .................................................................................................................................................................................. 76</p>
<p>References ............................................................................................................................................................................... 77</p>
<p><strong>Migrate from ASP.NET Web Forms to Blazor ..................................................................... 78</strong></p>
<p>Server-side versus client-side hosting .......................................................................................................................... 78</p>
<p>Create a new project............................................................................................................................................................ 79</p>
<p>Enable startup process ........................................................................................................................................................ 80</p>
<p>Migrate HTTP modules and handlers to middleware ............................................................................................ 83</p>
<p>Migrate static files ................................................................................................................................................................ 84</p>
<p>Migrate runtime bundling and minification setup .................................................................................................. 84</p>
<p>Migrate ASPX pages ............................................................................................................................................................ 84</p>
<p>Model validation in Blazor ............................................................................................................................................ 88</p>
<p>Migrate configuration ......................................................................................................................................................... 89</p>
<p>Migrate data access ............................................................................................................................................................. 91</p>
<p>Architectural changes .......................................................................................................................................................... 91</p>
<p>Migration conclusion ........................................................................................................................................................... 92</p>
<p>iv Contents</p>
<p><strong>CHAPTER</strong></p>
<h1>1</h1>
<h2>An introduction to Blazor for ASP.NET Web Forms developers</h2>
<p>The ASP.NET Web Forms framework has been a staple of .NET web development since the .NET<br />
Framework first shipped in 2002. Back when the Web was still largely in its infancy, ASP.NET Web<br />
Forms made building web apps simple and productive by adopting many of the patterns that were<br />
used for desktop development. In ASP.NET Web Forms, web pages can be quickly composed from<br />
reusable UI controls. User interactions are handled naturally as events. There’s a rich ecosystem of<br />
Web Forms UI controls provided by Microsoft and control vendors. The controls ease the efforts of<br />
connecting to data sources and displaying rich data visualizations. For the visually inclined, the Web<br />
Forms designer provides a simple drag-and-drop interface for managing controls.</p>
<p>Over the years, Microsoft has introduced new ASP.NET-based web frameworks to address web<br />
development trends. Some such web frameworks include ASP.NET MVC, ASP.NET Web Pages, and<br />
more recently ASP.NET Core. With each new framework, some have predicted the imminent decline of<br />
ASP.NET Web Forms and criticized it as an outdated, outmoded web framework. Despite these<br />
predictions, many .NET web developers continue to find ASP.NET Web Forms a simple, stable, and<br />
productive way to get their work done.</p>
<p>At the time of writing, almost half a million web developers use ASP.NET Web Forms every month. The<br />
ASP.NET Web Forms framework is stable to the point that docs, samples, books, and blog posts from<br />
a decade ago remain useful and relevant. For many .NET web developers, “ASP.NET” is still<br />
synonymous with “ASP.NET Web Forms” as it was when .NET was first conceived. Arguments on the<br />
pros and cons of ASP.NET Web Forms compared to the other new .NET web frameworks may rage on.<br />
ASP.NET Web Forms remains a popular framework for creating web apps.</p>
<p>Even so, innovations in software development aren’t slowing. All software developers need to stay<br />
abreast of new technologies and trends. Two trends in particular are worth considering:</p>
<ol>
<li>
<p>The shift to open-source and cross-platform</p>
</li>
<li>
<p>The shift of app logic to the client</p>
</li>
</ol>
<p>1 CHAPTER 1 | An introduction to Blazor for ASP.NET Web Forms developers</p>
<h3>An open-source and cross-platform .NET</h3>
<p>When .NET and ASP.NET Web Forms first shipped, the platform ecosystem looked much different than<br />
it does today. The desktop and server markets were dominated by Windows. Alternative platforms like<br />
macOS and Linux were still struggling to gain traction. ASP.NET Web Forms ships with the .NET<br />
Framework as a Windows-only component, which means ASP.NET Web Forms apps can only run on<br />
Windows Server machines. Many modern environments now use different kinds of platforms for<br />
servers and development machines such that cross-platform support for many users is an absolute<br />
requirement.</p>
<p>Most modern web frameworks are now also open-source, which has a number of benefits. Users<br />
aren’t beheld to a single project owner to fix bugs and add features. Open-source projects provide<br />
improved transparency on development progress and upcoming changes. Open-source projects enjoy<br />
contributions from an entire community, and they foster a supportive open-source ecosystem.<br />
Despite the risks of open-source, many consumers and contributors have found suitable mitigations<br />
that enable them to enjoy the benefits of an open-source ecosystem in a safe and reasonable way.<br />
Examples of such mitigations include contributor license agreements, friendly licenses, pedigree scans,<br />
and supporting foundations.</p>
<p>The .NET community has embraced both cross-platform support and open-source. .NET Core is an<br />
open-source and cross-platform implementation of .NET that runs on a plethora of platforms,<br />
including Windows, macOS, and various Linux distributions. Xamarin provides Mono, an open-source<br />
version of .NET. Mono runs on Android, iOS, and a variety of other form factors, including watches<br />
<a href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0/">and smart TVs. In 2020, Microsoft released .NET 5 that reconciled .NET Core and Mono into “a single</a><br />
.NET runtime and framework that can be used everywhere and that has uniform runtime behaviors<br />
and developer experiences.”</p>
<p>Will ASP.NET Web Forms benefit from the move to open-source and cross-platform support? The<br />
answer, unfortunately, is no, or at least not to the same extent as the rest of the platform. The .NET<br />
<a href="https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/">team made it clear</a> that ASP.NET Web Forms won’t be ported to .NET Core or .NET 8. Why is that?</p>
<p>There were efforts in the early days of .NET Core to port ASP.NET Web Forms. The number of breaking<br />
changes required were found to be too drastic. There’s also an admission here that even for Microsoft,<br />
there’s a limit to the number of web frameworks that it can support simultaneously. Perhaps someone<br />
in the community will take up the cause of creating an open-source and cross-platform version of<br />
<a href="https://github.com/microsoft/referencesource">ASP.NET Web Forms. The source code for ASP.NET Web Forms</a> has been made available publicly in<br />
reference form. But for the time being, it seems ASP.NET Web Forms will remain Windows-only and<br />
without an open-source contribution model. If cross-platform support or open-source become<br />
important for your scenarios, then you’ll need to look for something new.</p>
<p>Does this mean ASP.NET Web Forms is <em>dead</em> and should no longer be used? Of course not! As long as<br />
the .NET Framework ships as part of Windows, ASP.NET Web Forms will be a supported framework.<br />
For many Web Forms developers, the lack of cross-platform and open-source support is a non-issue.<br />
If you don’t have a requirement for cross-platform support, open-source, or any of the other new<br />
features in .NET Core or .NET 8, then sticking with ASP.NET Web Forms on Windows is fine. ASP.NET<br />
Web Forms will continue to be a productive way to write web apps for many years to come.</p>
<p>But there’s another trend worth considering, and that’s the shift to the client.</p>
<p>2 CHAPTER 1 | An introduction to Blazor for ASP.NET Web Forms developers</p>
<h3>Client-side web development</h3>
<p>All of the .NET-based web frameworks, including ASP.NET Web Forms, have historically had one thing<br />
in common: they’re <em>server-rendered</em> . In server-rendered web apps, the browser makes a request to the<br />
server, which executes some code (.NET code in ASP.NET apps) to produce a response. That response<br />
is sent back to the browser to handle. In this model, the browser is used as a thin rendering engine.<br />
The hard work of producing the UI, running the business logic, and managing state occurs on the<br />
server.</p>
<p>However, browsers have become versatile platforms. They implement an ever-increasing number of<br />
open web standards that grant access to the capabilities of the user’s machine. Why not take<br />
advantage of the compute power, storage, memory, and other resources of the client device? UI<br />
interactions in particular can benefit from a richer and more interactive feel when handled at least<br />
partially or completely client-side. Logic and data that should be handled on the server can still be<br />
handled server-side. Web API calls or even real-time protocols, like WebSockets, can be used. These<br />
benefits are available to web developers for free if they’re willing to write JavaScript. Client-side UI<br />
frameworks, such as Angular, React, and Vue, simplify client-side web development and have grown in<br />
popularity. ASP.NET Web Forms developers can also benefit from leveraging the client, and even have<br />
some out-of-the-box support with integrated JavaScript frameworks like ASP.NET AJAX.</p>
<p>But bridging two different platforms and ecosystems (.NET and JavaScript) comes with a cost.<br />
Expertise is required in two parallel worlds with different languages, frameworks, and tools. Code and<br />
logic can’t be easily shared between client and server, resulting in duplication and engineering<br />
overhead. It can also be difficult to keep up with the JavaScript ecosystem, which has a history of<br />
evolving at breakneck speed. Front-end framework and build tool preferences change quickly. The<br />
industry has observed the progression from Grunt to Gulp to Webpack, and so on. The same restless<br />
churn has occurred with front-end frameworks such as jQuery, Knockout, Angular, React, and Vue. But<br />
given JavaScript’s browser monopoly, there was little choice in the matter. That is, until the web<br />
community got together and caused a <em>miracle</em> to happen!</p>
<h3>WebAssembly fulfills a need</h3>
<p>In 2015, the major browser vendors joined forces in a W3C Community Group to create a new open<br />
web standard called WebAssembly. WebAssembly is a byte code for the Web. If you can compile your<br />
code to WebAssembly, it can then run on any browser on any platform at near native speed. Initial<br />
efforts focused on C/C++. The result was a dramatic demonstration of running native 3D graphics<br />
engines directly in the browser without plugins. WebAssembly has since been standardized and<br />
implemented by all major browsers.</p>
<p>Work on running .NET on WebAssembly was announced in late 2017 and released in 2020, including<br />
support in .NET 5 and beyond. The ability to run .NET code directly in the browser enables full-stack<br />
web development with .NET.</p>
<p>3 CHAPTER 1 | An introduction to Blazor for ASP.NET Web Forms developers</p>
<h3>Blazor: full-stack web development with .NET</h3>
<p>On its own, the ability to run .NET code in a browser doesn’t provide an end-to-end experience for<br />
creating client-side web apps. That’s where Blazor comes in. Blazor is a client-side web UI framework<br />
based on C# instead of JavaScript. Blazor can run directly in the browser via WebAssembly. No<br />
browser plugins are required. Alternatively, Blazor apps can run server-side on .NET and handle all<br />
user interactions over a real-time connection with the browser.</p>
<p>Blazor has great tooling support in Visual Studio and Visual Studio Code. The framework also includes<br />
a full UI component model and has built-in facilities for:</p>
<ul>
<li>
<p>Forms and validation</p>
</li>
<li>
<p>Dependency injection</p>
</li>
<li>
<p>Client-side routing</p>
</li>
<li>
<p>Layouts</p>
</li>
<li>
<p>In-browser debugging</p>
</li>
<li>
<p>JavaScript interop</p>
</li>
</ul>
<p>Blazor has a lot in common with ASP.NET Web Forms. Both frameworks offer component-based,<br />
event-driven, stateful UI programming models. The main architectural difference is that ASP.NET Web<br />
Forms runs only on the server. Blazor can run on the client in the browser. But if you’re coming from<br />
an ASP.NET Web Forms background, there’s a lot in Blazor that will feel familiar. Blazor is a natural<br />
solution for ASP.NET Web Forms developers looking for a way to take advantage of client-side<br />
development and the open-source, cross-platform future of .NET.</p>
<p>This book provides an introduction to Blazor that is catered specifically to ASP.NET Web Forms<br />
developers. Each Blazor concept is presented in the context of analogous ASP.NET Web Forms<br />
features and practices. By the end of this book, you’ll have an understanding of:</p>
<ul>
<li>
<p>How to build Blazor apps.</p>
</li>
<li>
<p>How Blazor works.</p>
</li>
<li>
<p>How Blazor relates to .NET.</p>
</li>
<li>
<p>Reasonable strategies for migrating existing ASP.NET Web Forms apps to Blazor where<br />
appropriate.</p>
</li>
</ul>
<h3>Get started with Blazor</h3>
<p><a href="https://blazor.net/">Getting started with Blazor is easy. Go to https://blazor.net</a> and follow the links to install the<br />
appropriate .NET SDK and Blazor project templates. You’ll also find instructions for setting up the<br />
Blazor tooling in Visual Studio or Visual Studio Code.</p>
<p>4 CHAPTER 1 | An introduction to Blazor for ASP.NET Web Forms developers</p>
<p><strong>CHAPTER</strong></p>
<h1>2</h1>
<h2>Architecture comparison of ASP.NET Web Forms and Blazor</h2>
<p>While ASP.NET Web Forms and Blazor have many similar concepts, there are differences in how they<br />
work. This chapter examines the inner workings and architectures of ASP.NET Web Forms and Blazor.</p>
<h3>ASP.NET Web Forms</h3>
<p>The ASP.NET Web Forms framework is based on a page-centric architecture. Each HTTP request for a<br />
location in the app is a separate page with which ASP.NET responds. As pages are requested, the<br />
contents of the browser are replaced with the results of the page requested.</p>
<p>Pages consist of the following components:</p>
<ul>
<li>
<p>HTML markup</p>
</li>
<li>
<p>C# or Visual Basic code</p>
</li>
<li>
<p>A code-behind class containing logic and event-handling capabilities</p>
</li>
<li>
<p>Controls</p>
</li>
</ul>
<p>Controls are reusable units of web UI that can be programmatically placed and interacted with on a<br />
page. Pages are composed of files that end with <em>.aspx</em> containing markup, controls, and some code.<br />
The code-behind classes are in files with the same base name and an <em>.aspx.cs</em> or <em>.aspx.vb</em> extension,<br />
depending on the programming language used. Interestingly, the web server interprets contents of<br />
the <em>.aspx</em> files and compiles them whenever they change. This recompilation occurs even if the web<br />
server is already running.</p>
<p>Controls can be built with markup and delivered as user controls. A user control derives from the<br />
UserControl class and has a similar structure to the Page. Markup for user controls is stored in an <em>.ascx</em><br />
file. An accompanying code-behind class resides in an <em>.ascx.cs</em> or <em>.ascx.vb</em> file. Controls can also be<br />
built completely with code, by inheriting from either the WebControl or CompositeControl base class.</p>
<p>Pages also have an extensive event lifecycle. Each page raises events for the initialization, load,<br />
prerender, and unload events that occur as the ASP.NET runtime executes the page’s code for each<br />
request.</p>
<p>5 CHAPTER 2 | Architecture comparison of ASP.NET Web Forms and Blazor</p>
<p>Controls on a Page typically post-back to the same page that presented the control, and carry along<br />
with them a payload from a hidden form field called ViewState. The ViewState field contains<br />
information about the state of the controls at the time they were rendered and presented on the<br />
page, allowing the ASP.NET runtime to compare and identify changes in the content submitted to the<br />
server.</p>
<h3>Blazor</h3>
<p>Blazor is a client-side web UI framework similar in nature to JavaScript front-end frameworks like<br />
Angular or React. Blazor handles user interactions and renders the necessary UI updates. Blazor <em>isn’t</em><br />
based on a request-reply model. User interactions are handled as events that aren’t in the context of<br />
any particular HTTP request.</p>
<p>Blazor apps consist of one or more root components that are rendered on an HTML page.</p>
<p>How the user specifies where components should render and how the components are then wired up<br />
for user interactions is hosting model specific.</p>
<p>Blazor components are .NET classes that represent a reusable piece of UI. Each component maintains<br />
its own state and specifies its own rendering logic, which can include rendering other components.<br />
Components specify event handlers for specific user interactions to update the component’s state.</p>
<p>After a component handles an event, Blazor renders the component and keeps track of what changed<br />
in the rendered output. Components don’t render directly to the Document Object Model (DOM).<br />
They instead render to an in-memory representation of the DOM called a RenderTree so that Blazor<br />
can track the changes. Blazor compares the newly rendered output with the previous output to<br />
calculate a UI diff that it then applies efficiently to the DOM.</p>
<p>6 CHAPTER 2 | Architecture comparison of ASP.NET Web Forms and Blazor</p>
<p>Components can also manually indicate that they should be rendered if their state changes outside of<br />
a normal UI event. Blazor uses a SynchronizationContext to enforce a single logical thread of<br />
execution. A component’s lifecycle methods and any event callbacks that are raised by Blazor are<br />
executed on this SynchronizationContext.</p>
<p>7 CHAPTER 2 | Architecture comparison of ASP.NET Web Forms and Blazor</p>
<p><strong>CHAPTER</strong></p>
<h1>3</h1>
<h2>Blazor app hosting models</h2>
<p>Blazor apps can be hosted in one of the following ways:</p>
<ul>
<li>
<p>Client-side in the browser on WebAssembly.</p>
</li>
<li>
<p>Server-side in an ASP.NET Core app.</p>
</li>
</ul>
<h3>Blazor WebAssembly apps</h3>
<p>Blazor WebAssembly apps execute directly in the browser on a WebAssembly-based .NET runtime.<br />
Blazor WebAssembly apps function in a similar way to front-end JavaScript frameworks like Angular or<br />
React. However, instead of writing JavaScript you write C#. The .NET runtime is downloaded with the<br />
app along with the app assembly and any required dependencies. No browser plugins or extensions<br />
are required.</p>
<p>The downloaded assemblies are normal .NET assemblies, like you would use in any other .NET app.<br />
Because the runtime supports .NET Standard, you can use existing .NET Standard libraries with your<br />
Blazor WebAssembly app. However, these assemblies will still execute in the browser security<br />
<a href="https://docs.microsoft.com/dotnet/api/system.platformnotsupportedexception">sandbox. Some functionality may throw a PlatformNotSupportedException, like trying to access the</a><br />
file system or opening arbitrary network connections.</p>
<p>When the app loads, the .NET runtime is started and pointed at the app assembly. The app startup<br />
logic runs, and the root components are rendered. Blazor calculates the UI updates based on the<br />
rendered output from the components. The DOM updates are then applied.</p>
<p>8 CHAPTER 3 | Blazor app hosting models</p>
<p>Blazor WebAssembly apps run purely client-side. Such apps can be deployed to static site hosting<br />
solutions like GitHub Pages or Azure Static Website Hosting. .NET isn’t required on the server at all.<br />
Deep linking to parts of the app typically requires a routing solution on the server. The routing<br />
solution redirects requests to the root of the app. For example, this redirection can be handled using<br />
URL rewrite rules in IIS.</p>
<p>To get all the benefits of Blazor and full-stack .NET web development, host your Blazor WebAssembly<br />
app with ASP.NET Core. By using .NET on both the client and server, you can easily share code and<br />
build your app using one consistent set of languages, frameworks, and tools. Blazor provides<br />
convenient templates for setting up a solution that contains both a Blazor WebAssembly app and an<br />
ASP.NET Core host project. When the solution is built, the built static files from the Blazor app are<br />
hosted by the ASP.NET Core app with fallback routing already setup.</p>
<h3>Blazor Server apps</h3>
<p>Recall from the Blazor architecture discussion that Blazor components render their output to an<br />
intermediate abstraction called a RenderTree. The Blazor framework then compares what was<br />
rendered with what was previously rendered. The differences are applied to the DOM. Blazor<br />
components are decoupled from how their rendered output is applied. Consequently, the<br />
components themselves don’t have to run in the same process as the process updating the UI. In fact,<br />
they don’t even have to run on the same machine.</p>
<p>In Blazor Server apps, the components run on the server instead of client-side in the browser. UI<br />
events that occur in the browser are sent to the server over a real-time connection. The events are<br />
dispatched to the correct component instances. The components render, and the calculated UI diff is<br />
serialized and sent to the browser where it’s applied to the DOM.</p>
<p>9 CHAPTER 3 | Blazor app hosting models</p>
<p>The Blazor Server hosting model may sound familiar if you’ve used ASP.NET AJAX and the<br />
<a href="https://docs.microsoft.com/dotnet/api/system.web.ui.updatepanel">UpdatePanel</a> control. The UpdatePanel control handles applying partial page updates in response to<br />
trigger events on the page. When triggered, the UpdatePanel requests a partial update and then<br />
applies it without needing to refresh the page. The state of the UI is managed using ViewState. Blazor<br />
Server apps are slightly different in that the app requires an active connection with the client.<br />
Additionally, all UI state is maintained on the server. Aside from those differences, the two models are<br />
conceptually similar.</p>
<h3>How to choose the right Blazor hosting model</h3>
<p><a href="https://docs.microsoft.com/aspnet/core/blazor/hosting-models">As described in the Blazor hosting model docs, the different Blazor hosting models have different</a><br />
tradeoffs.</p>
<p>The Blazor WebAssembly hosting model has the following benefits:</p>
<ul>
<li>
<p>There’s no .NET server-side dependency. The app is fully functioning after downloaded to the<br />
client.</p>
</li>
<li>
<p>Client resources and capabilities are fully leveraged.</p>
</li>
<li>
<p>Work is offloaded from the server to the client.</p>
</li>
<li>
<p>An ASP.NET Core web server isn’t required to host the app. Serverless deployment scenarios<br />
are possible (for example, serving the app from a CDN).</p>
</li>
</ul>
<p>The downsides of the Blazor WebAssembly hosting model are:</p>
<ul>
<li>
<p>Browser capabilities restrict the app.</p>
</li>
<li>
<p>Capable client hardware and software (for example, WebAssembly support) is required.</p>
</li>
<li>
<p>Download size is larger, and apps take longer to load.</p>
</li>
</ul>
<p>10 CHAPTER 3 | Blazor app hosting models</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard">.NET runtime and tooling support is less mature. For example, there are limitations in .NET</a><br />
<a href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard">Standard</a> support and debugging.</li>
</ul>
<p>Conversely, the Blazor Server hosting model offers the following benefits:</p>
<ul>
<li>
<p>Download size is much smaller than a client-side app, and the app loads much faster.</p>
</li>
<li>
<p>The app takes full advantage of server capabilities, including use of any .NET compatible APIs.</p>
</li>
<li>
<p>.NET on the server is used to run the app, so existing .NET tooling, such as debugging, works<br />
as expected.</p>
</li>
<li>
<p>Thin clients are supported. For example, server-side apps work with browsers that don’t<br />
support WebAssembly and on resource-constrained devices.</p>
</li>
<li>
<p>The app’s .NET/C# code base, including the app’s component code, isn’t served to clients.</p>
</li>
</ul>
<p>The downsides to the Blazor Server hosting model are:</p>
<ul>
<li>
<p>Higher UI latency. Every user interaction involves a network hop.</p>
</li>
<li>
<p>There’s no offline support. If the client connection fails, the app stops working.</p>
</li>
<li>
<p>Scalability is challenging for apps with many users. The server must manage multiple client<br />
connections and handle client state.</p>
</li>
<li>
<p>An ASP.NET Core server is required to serve the app. Serverless deployment scenarios aren’t<br />
possible. For example, you can’t serve the app from a CDN.</p>
</li>
</ul>
<p>The preceding list of trade-offs may be intimidating, but your hosting model can be changed later.<br />
Regardless of the Blazor hosting model selected, the component model is <em>the same</em> . In principle, the<br />
same components can be used with either hosting model. Your app code doesn’t change; however,<br />
it’s a good practice to introduce abstractions so that your components stay hosting model-agnostic.<br />
The abstractions allow your app to more easily adopt a different hosting model.</p>
<h3>Deploy your app</h3>
<p>ASP.NET Web Forms apps are typically hosted on IIS on a Windows Server machine or cluster. Blazor<br />
apps can also:</p>
<ul>
<li>
<p>Be hosted on IIS, either as static files or as an ASP.NET Core app.</p>
</li>
<li>
<p>Leverage ASP.NET Core’s flexibility to be hosted on various platforms and server<br />
<a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/linux-nginx">infrastructures. For example, you can host a Blazor App using Nginx</a> <a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/linux-apache">or Apache on Linux. For</a><br />
<a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/">more information about how to publish and deploy Blazor apps, see the Blazor Hosting and</a><br />
<a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/">deployment</a> documentation.</p>
</li>
</ul>
<p>In the next section, we’ll look at how the projects for Blazor WebAssembly and Blazor Server apps are<br />
set up.</p>
<p>11 CHAPTER 3 | Blazor app hosting models</p>
<p><strong>CHAPTER</strong></p>
<h1>4</h1>
<h2>Project structure for Blazor apps</h2>
<p>Despite their significant project structure differences, ASP.NET Web Forms and Blazor share many<br />
similar concepts. Here, we’ll look at the structure of a Blazor project and compare it to an ASP.NET<br />
Web Forms project.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/blazor/get-started">To create your first Blazor app, follow the instructions in the Blazor getting started steps. You can</a><br />
follow the instructions to create either a Blazor Server app or a Blazor WebAssembly app hosted in<br />
ASP.NET Core. Except for the hosting model-specific logic, most of the code in both projects is the<br />
same.</p>
<h3>Project file</h3>
<p>Blazor Server apps are .NET projects. The project file for the Blazor Server app is about as simple as it<br />
can get:</p>
<p>12 CHAPTER 4 | Project structure for Blazor apps</p>
<p>Blazor WebAssembly project targets Microsoft.NET.Sdk.BlazorWebAssembly instead of<br />
Microsoft.NET.Sdk.Web sdk because they run in the browser on a WebAssembly-based .NET runtime.<br />
You can’t install .NET into a web browser like you can on a server or developer machine.<br />
Consequently, the project references the Blazor framework using individual package references.</p>
<p>By comparison, a default ASP.NET Web Forms project includes almost 300 lines of XML in its <em>.csproj</em><br />
file, most of which is explicitly listing the various code and content files in the project. Since the<br />
release of .NET 5, both Blazor Server and Blazor WebAssembly apps can easily share one unified<br />
runtime.</p>
<p>Although they’re supported, individual assembly references are less common in .NET projects. Most<br />
project dependencies are handled as NuGet package references. You only need to reference top-level<br />
package dependencies in .NET projects. Transitive dependencies are included automatically. Instead of<br />
using the <em>packages.config</em> file commonly found in ASP.NET Web Forms projects to reference packages,<br />
package references are added to the project file using the <PackageReference> element.</p>
<h3>Entry point</h3>
<p>The Blazor Server app’s entry point is defined in the <em>Program.cs</em> file, as you would see in a Console<br />
app. When the app executes, it creates and runs a web host instance using defaults specific to web<br />
apps. The web host manages the Blazor Server app’s lifecycle and sets up host-level services.<br />
Examples of such services are configuration, logging, dependency injection, and the HTTP server. This<br />
code is mostly boilerplate and is often left unchanged.</p>
<p>13 CHAPTER 4 | Project structure for Blazor apps</p>
<p>Blazor WebAssembly apps also define an entry point in <em>Program.cs</em> . The code looks slightly different.<br />
The code is similar in that it’s setting up the app host to provide the same host-level services to the<br />
app. The WebAssembly app host doesn’t, however, set up an HTTP server because it executes directly<br />
in the browser.</p>
<p>Blazor apps don’t use a <em>Global.asax</em> file to define the startup logic for the app. Instead, this logic is<br />
contained in <em>Program.cs</em> or in a related Startup class that is referenced from <em>Program.cs</em> . Either way,<br />
this code is used to configure the app and any app-specific services.</p>
<p>In a Blazor Server app, the <em>Program.cs</em> file shown is used to set up the endpoint for the real-time<br />
connection used by Blazor between the client browsers and the server.</p>
<p>In a Blazor WebAssembly app, the <em>Program.cs</em> file defines the root components for the app and where<br />
they should be rendered:</p>
<p>14 CHAPTER 4 | Project structure for Blazor apps</p>
<h3>Static files</h3>
<p>Unlike ASP.NET Web Forms projects, not all files in a Blazor project can be requested as static files.<br />
Only the files in the <em>wwwroot</em> folder are web-addressable. This folder is referred to as the app’s “web<br />
root”. Anything outside of the app’s web root <em>isn’t</em> web-addressable. This setup provides an additional<br />
level of security that prevents accidental exposure of project files over the web.</p>
<h3>Configuration</h3>
<p>Configuration in ASP.NET Web Forms apps is typically handled using one or more <em>web.config</em> files.<br />
Blazor apps don’t typically have <em>web.config</em> files. If they do, the file is only used to configure IISspecific settings when hosted on IIS. Instead, Blazor Server apps use the ASP.NET Core configuration<br />
abstractions. (Blazor WebAssembly apps don’t currently support the same configuration abstractions,<br />
but that may be a feature added in the future.) For example, the default Blazor Server app stores some<br />
settings in <em>appsettings.json</em> .</p>
<p>You’ll learn more about configuration in ASP.NET Core projects in the Configuration section.</p>
<h3>Razor components</h3>
<p>Most files in Blazor projects are <em>.razor</em> files. Razor is a templating language based on HTML and C#<br />
that is used to dynamically generate web UI. The <em>.razor</em> files define components that make up the UI<br />
of the app. For the most part, the components are identical for both the Blazor Server and Blazor<br />
WebAssembly apps. Components in Blazor are analogous to user controls in ASP.NET Web Forms.</p>
<p>Each Razor component file is compiled into a .NET class when the project is built. The generated class<br />
captures the component’s state, rendering logic, lifecycle methods, event handlers, and other logic.<br />
You’ll learn more about authoring components in the Building reusable UI components with Blazor<br />
section.</p>
<p>The <em>_Imports.razor</em> files aren’t Razor component files. Instead, they define a set of Razor directives to<br />
import into other <em>.razor</em> files within the same folder and in its subfolders. For example, a<br />
<em>_Imports.razor</em> file is a conventional way to add using directives for commonly used namespaces:</p>
<p>15 CHAPTER 4 | Project structure for Blazor apps</p>
<h3>Pages</h3>
<p>Where are the pages in the Blazor apps? Blazor doesn’t define a separate file extension for<br />
addressable pages, like the <em>.aspx</em> files in ASP.NET Web Forms apps. Instead, pages are defined by<br />
assigning routes to components. A route is typically assigned using the @page Razor directive. For<br />
example, the Counter component authored in the <em>Pages/Counter.razor</em> file defines the following route:</p>
<pre><code>@page &quot;/counter&quot;

</code></pre>
<p>Routing in Blazor is handled client-side, not on the server. As the user navigates in the browser, Blazor<br />
intercepts the navigation and then renders the component with the matching route.</p>
<p>The component routes aren’t currently inferred by the component’s file location like they are with<br />
<em>.aspx</em> pages or ASP.NET Core Razor Pages. This feature may be added in the future. Each route must<br />
be specified explicitly on the component. Storing routable components in a <em>Pages</em> folder has no<br />
special meaning and is purely a convention.</p>
<p>You’ll learn more about routing in Blazor in the Pages, routing, and layouts section.</p>
<h3>Layout</h3>
<p>In ASP.NET Web Forms apps, a common page layout is handled using master pages ( <em>Site.Master</em> ). In<br />
Blazor apps, the page layout is handled using layout components ( <em>Shared/MainLayout.razor</em> ). Layout<br />
components are discussed in more detail in the Page, routing, and layouts section.</p>
<h3>Bootstrap Blazor</h3>
<p>To bootstrap Blazor, the app must:</p>
<ul>
<li>
<p>Specify where on the page the root component ( <em>App.Razor</em> ) should be rendered.</p>
</li>
<li>
<p>Add the corresponding Blazor framework script.</p>
</li>
</ul>
<p>In the Blazor Server app, the root component’s host page is defined in the <em>_Host.cshtml</em> file. This file<br />
defines a Razor Page, not a component. Razor Pages use Razor syntax to define a server-addressable<br />
page, very much like an <em>.aspx</em> page.</p>
<p>16 CHAPTER 4 | Project structure for Blazor apps</p>
<p>The render-mode attribute is used to define where a root-level component should be rendered. The<br />
RenderMode option indicates the manner in which the component should be rendered. The following</p>
<table>
<thead>
<tr>
<th>table outlines the supported RenderMode options.</th>
<th>Col2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Option</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>RenderMode.Server</td>
<td>Rendered interactively once a<br>connection with the browser is<br>established</td>
</tr>
<tr>
<td>RenderMode.ServerPrerendered</td>
<td>First prerendered and then rendered<br>interactively</td>
</tr>
<tr>
<td>RenderMode.Static</td>
<td>Rendered as static content</td>
</tr>
</tbody>
</table>
<p>The <em>_Layout.cshtml</em> file includes the default HTML for the app and its components.</p>
<p>The script reference to <em>_framework/blazor.server.js</em> establishes the real-time connection with the<br />
server and then deals with all user interactions and UI updates.</p>
<p>17 CHAPTER 4 | Project structure for Blazor apps</p>
<p>In the Blazor WebAssembly app, the host page is a simple static HTML file under <em>wwwroot/index.html</em> .<br />
The <div> element with id named app is used to indicate where the root component should be<br />
rendered.</p>
<p>The root component to render is specified in the app’s <em>Program.cs</em> file with the flexibility to register<br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/fundamentals/dependency-injection?pivots=webassembly">services through dependency injection. For more information, see ASP.NET Core Blazor dependency</a><br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/fundamentals/dependency-injection?pivots=webassembly">injection.</a></p>
<h3>Build output</h3>
<p>When a Blazor project is built, all Razor component and code files are compiled into a single<br />
assembly. Unlike ASP.NET Web Forms projects, Blazor doesn’t support runtime compilation of the UI<br />
logic.</p>
<h3>Run the app with Hot Reload</h3>
<p>To run the Blazor Server app, press F5 in Visual Studio to run with the debugger attached, or Ctrl + F5<br />
to run without the debugger attached.</p>
<p>To run the Blazor WebAssembly app, choose one of the following approaches:</p>
<ul>
<li>Run the client project directly using the development server.</li>
</ul>
<p>18 CHAPTER 4 | Project structure for Blazor apps</p>
<ul>
<li>Run the server project when hosting the app with ASP.NET Core.</li>
</ul>
<p><a href="https://docs.microsoft.com/aspnet/core/blazor/debug">Blazor WebAssembly apps can be debugged in both browser and Visual Studio. See Debug ASP.NET</a><br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/debug">Core Blazor WebAssembly for details.</a></p>
<p>Both Blazor Server and Blazor WebAssembly apps support Hot Reload in Visual Studio. Hot Reload is<br />
a feature that automatically updates changes made to a Blazor app live, in the browser. You can<br />
toggle whether Hot Reload is enabled from its icon in the toolbar:</p>
<p>Selecting the caret beside the icon reveals additional options. You can toggle Hot Reload on or off,<br />
restart the application, and toggle whether Hot Reload should occur whenever a file is saved.</p>
<p>You can also access additional configuration options. The configuration dialog lets you specify<br />
whether Hot Reload should be enabled when debugging (along with Edit and Continue), when<br />
starting without debugging, or when a file is saved.</p>
<p>19 CHAPTER 4 | Project structure for Blazor apps</p>
<p>The “developer inner loop” has been greatly streamlined with Hot Reload. Without Hot Reload, a<br />
Blazor developer would typically need to restart and rerun the app after every change, navigating to<br />
the appropriate part of the app as required. With Hot Reload, changes can be made to the running<br />
app without the need to restart in most cases. Hot Reload even retains the state of pages, so there’s<br />
no need to have to re-enter form values or otherwise get the app back where you need it.</p>
<p>20 CHAPTER 4 | Project structure for Blazor apps</p>
<p><strong>CHAPTER</strong></p>
<h1>5</h1>
<h2>App startup</h2>
<p>Applications that are written for ASP.NET typically have a global.asax.cs file that defines the<br />
Application_Start event that controls which services are configured and made available for both HTML<br />
rendering and .NET processing. This chapter looks at how things are slightly different with ASP.NET<br />
Core and Blazor Server.</p>
<h3>Application_Start and Web Forms</h3>
<p>The default web forms Application_Start method has grown in purpose over years to handle many<br />
configuration tasks. A fresh web forms project with the default template in Visual Studio 2022 now<br />
contains the following configuration logic:</p>
<ul>
<li>
<p>RouteConfig - Application URL routing</p>
</li>
<li>
<p>BundleConfig - CSS and JavaScript bundling and minification</p>
</li>
</ul>
<p>Each of these individual files resides in the App_Start folder and run only once at the start of our<br />
application. RouteConfig in the default project template adds the FriendlyUrlSettings for web forms to<br />
allow application URLs to omit the .ASPX file extension. The default template also contains a directive<br />
that provides permanent HTTP redirect status codes (HTTP 301) for the .ASPX pages to the friendly<br />
URL with the file name that omits the extension.</p>
<p>With ASP.NET Core and Blazor, these methods are either simplified and consolidated into the Startup<br />
class or they are eliminated in favor of common web technologies.</p>
<h3>Blazor Server Startup Structure</h3>
<p>Blazor Server applications reside on top of an ASP.NET Core 3.0 or later version. ASP.NET Core web<br />
applications are configured in <em>Program.cs</em>, or through a pair of methods in the Startup.cs class. A<br />
sample <em>Program.cs</em> file is shown below:</p>
<p>21 CHAPTER 5 | App startup</p>
<p>The app’s required services are added to the WebApplicationBuilder instance’s Services collection.<br />
This is how the various ASP.NET Core framework services are configured with the framework’s built-in<br />
dependency injection container. The various builder.Services.Add* methods add services that enable<br />
features such as authentication, razor pages, MVC controller routing, SignalR, and Blazor Server<br />
interactions among many others. This method was not needed in web forms, as the parsing and<br />
handling of the ASPX, ASCX, ASHX, and ASMX files were defined by referencing ASP.NET in the<br />
web.config configuration file. More information about dependency injection in ASP.NET Core is<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection">available in the online documentation.</a></p>
<p>After the app has been built by the builder, the rest of the calls on app configure its HTTP pipeline.<br />
With these calls, we declare from top to bottom the Middleware that will handle every request sent to<br />
our application. Most of these features in the default configuration were scattered across the web<br />
forms configuration files and are now in one place for ease of reference.</p>
<p>No longer is the configuration of the custom error page placed in a web.config file, but now is<br />
configured to always be shown if the application environment is not labeled Development.<br />
Additionally, ASP.NET Core applications are now configured to serve secure pages with TLS by default<br />
with the UseHttpsRedirection method call.</p>
<p>Next, an unexpected configuration method call is made to UseStaticFiles. In ASP.NET Core, support for<br />
requests for static files (like JavaScript, CSS, and image files) must be explicitly enabled, and only files<br />
in the app’s <em>wwwroot</em> folder are publicly addressable by default.</p>
<p>The next line is the first that replicates one of the configuration options from web forms: UseRouting.<br />
This method adds the ASP.NET Core router to the pipeline and it can be either configured here or in<br />
the individual files that it can consider routing to. More information about routing configuration can<br />
be found in the Routing section.</p>
<p>The final app.Map* calls in this section define the endpoints that ASP.NET Core is listening on. These<br />
routes are the web accessible locations that you can access on the web server and receive some<br />
content handled by .NET and returned to you. The first entry, MapBlazorHub configures a SignalR hub<br />
for use in providing the real-time and persistent connection to the server where the state and<br />
rendering of Blazor components is handled. The MapFallbackToPage method call indicates the webaccessible location of the page that starts the Blazor application and also configures the application to</p>
<p>22 CHAPTER 5 | App startup</p>
<p>handle deep-linking requests from the client-side. You will see this feature at work if you open a<br />
browser and navigate directly to Blazor handled route in your application, such as /counter in the<br />
default project template. The request gets handled by the <em>_Host.cshtml</em> fallback page, which then<br />
runs the Blazor router and renders the counter page.</p>
<p>The very last line starts the application, something that wasn’t required in web forms (since it relied on<br />
IIS to be running).</p>
<h3>Upgrading the BundleConfig Process</h3>
<p>Technologies for bundling assets like CSS stylesheets and JavaScript files have changed significantly,<br />
with other technologies providing quickly evolving tools and techniques for managing these<br />
resources. To this end, we recommend using a Node command-line tool such as Grunt / Gulp /<br />
WebPack to package your static assets.</p>
<p>The Grunt, Gulp, and WebPack command-line tools and their associated configurations can be added<br />
to your application and ASP.NET Core will quietly ignore those files during the application build<br />
process. You can add a call to run their tasks by adding a Target inside your project file with syntax<br />
similar to the following that would trigger a gulp script and the min target inside that script:</p>
<p><a href="https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification">More details about both strategies to manage your CSS and JavaScript files are available in the Bundle</a><br />
<a href="https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification">and minify static assets in ASP.NET Core documentation.</a></p>
<p>23 CHAPTER 5 | App startup</p>
<p><strong>CHAPTER</strong></p>
<h1>6</h1>
<h2>Build reusable UI components with Blazor</h2>
<p>One of the beautiful things about ASP.NET Web Forms is how it enables encapsulation of reusable<br />
pieces of user interface (UI) code into reusable UI controls. Custom user controls can be defined in<br />
markup using <em>.ascx</em> files. You can also build elaborate server controls in code with full designer<br />
support.</p>
<p>Blazor also supports UI encapsulation through <em>components</em> . A component:</p>
<ul>
<li>
<p>Is a self-contained chunk of UI.</p>
</li>
<li>
<p>Maintains its own state and rendering logic.</p>
</li>
<li>
<p>Can define UI event handlers, bind to input data, and manage its own lifecycle.</p>
</li>
<li>
<p>Is typically defined in a <em>.razor</em> file using Razor syntax.</p>
</li>
</ul>
<h3>An introduction to Razor</h3>
<p>Razor is a light-weight markup templating language based on HTML and C#. With Razor, you can<br />
seamlessly transition between markup and C# code to define your component rendering logic. When<br />
the <em>.razor</em> file is compiled, the rendering logic is captured in a structured way in a .NET class. The name<br />
of the compiled class is taken from the <em>.razor</em> file name. The namespace is taken from the default<br />
namespace for the project and the folder path, or you can explicitly specify the namespace using the<br />
@namespace directive (more on Razor directives below).</p>
<p>A component’s rendering logic is authored using normal HTML markup with dynamic logic added<br />
using C#. The @ character is used to transition to C#. Razor is typically smart about figuring out when<br />
you’ve switched back to HTML. For example, the following component renders a <p> tag with the<br />
current time:</p>
<pre><code>&lt;p&gt;@DateTime.Now&lt;/p&gt;

</code></pre>
<p>To explicitly specify the beginning and ending of a C# expression, use parentheses:</p>
<pre><code>&lt;p&gt;@(DateTime.Now)&lt;/p&gt;

</code></pre>
<p>Razor also makes it easy to use C# control flow in your rendering logic. For example, you can<br />
conditionally render some HTML like this:</p>
<p>24 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>Or you can generate a list of items using a normal C# foreach loop like this:</p>
<p>Razor directives, like directives in ASP.NET Web Forms, control many aspects of how a Razor<br />
component is compiled. Examples include the component’s:</p>
<ul>
<li>
<p>Namespace</p>
</li>
<li>
<p>Base class</p>
</li>
<li>
<p>Implemented interfaces</p>
</li>
<li>
<p>Generic parameters</p>
</li>
<li>
<p>Imported namespaces</p>
</li>
<li>
<p>Routes</p>
</li>
</ul>
<p>Razor directives start with the @ character and are typically used at the start of a new line at the start<br />
of the file. For example, the @namespace directive defines the component’s namespace:</p>
<pre><code>@namespace MyComponentNamespace

</code></pre>
<p>The following table summarizes the various Razor directives used in Blazor and their ASP.NET Web</p>
<table>
<thead>
<tr>
<th>Forms equivalents, if they</th>
<th>exist.</th>
<th>Col3</th>
<th>Col4</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Directive</strong></td>
<td><strong>Description</strong></td>
<td><strong>Example</strong></td>
<td><strong>Web Forms equivalent</strong></td>
</tr>
<tr>
<td>@attribute</td>
<td>Adds a class-level<br>attribute to the<br>component</td>
<td>@attribute<br>[Authorize]</td>
<td>None</td>
</tr>
<tr>
<td>@code</td>
<td>Adds class<br>members to the<br>component</td>
<td>@code { ... }</td>
<td><script runat="server">...</script></td>
</tr>
<tr>
<td>@implements</td>
<td>Implements the<br>specified interface</td>
<td>@impleme<br>nts<br>IDisposable</td>
<td>Use code-behind</td>
</tr>
<tr>
<td>@inherits</td>
<td>Inherits from the<br>specified base class</td>
<td>@inherits<br>MyCompon<br>entBase</td>
<td>&lt;%@ Control<br>Inherits=&quot;MyUserControlBase&quot; %&gt;</td>
</tr>
<tr>
<td>@inject</td>
<td>Injects a service<br>into the component</td>
<td>@inject<br>IJSRuntime<br>JS</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>25 CHAPTER 6 | Build reusable UI components with Blazor</p>
<table>
<thead>
<tr>
<th>Directive</th>
<th>Description</th>
<th>Example</th>
<th>Web Forms equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td>@layout</td>
<td>Specifies a layout<br>component for the<br>component</td>
<td>@layout<br>MainLayout</td>
<td>&lt;%@ Page<br>MasterPageFile=&quot;~/Site.Master&quot; %&gt;</td>
</tr>
<tr>
<td>@namespace</td>
<td>Sets the namespace<br>for the component</td>
<td>@namespa<br>ce<br>MyNamesp<br>ace</td>
<td>None</td>
</tr>
<tr>
<td>@page</td>
<td>Specifies the route<br>for the component</td>
<td>@page<br>&quot;/product/{i<br>d}&quot;</td>
<td>&lt;%@ Page %&gt;</td>
</tr>
<tr>
<td>@typeparam</td>
<td>Specifies a generic<br>type parameter for<br>the component</td>
<td>@typepara<br>m TItem</td>
<td>Use code-behind</td>
</tr>
<tr>
<td>@using</td>
<td>Specifies a<br>namespace to bring<br>into scope</td>
<td>@using<br>MyCompon<br>entNamesp<br>ace</td>
<td>Add namespace in_web.config_</td>
</tr>
</tbody>
</table>
<p>Razor components also make extensive use of <em>directive attributes</em> on elements to control various<br />
aspects of how components get compiled (event handling, data binding, component &amp; element<br />
references, and so on). Directive attributes all follow a common generic syntax where the values in<br />
parenthesis are optional:</p>
<pre><code>@directive(-suffix(:name))(=&quot;value&quot;)

</code></pre>
<p>The following table summarizes the various attributes for Razor directives used in Blazor.</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>@attributes</td>
<td>Renders a dictionary of attributes</td>
<td>&lt;input<br>@attributes=&quot;ExtraA<br>ttributes&quot; /&gt;</td>
</tr>
<tr>
<td>@bind</td>
<td>Creates a two-way data binding</td>
<td>&lt;input<br>@bind=&quot;username&quot;<br>@bind:event=&quot;oninp<br>ut&quot; /&gt;</td>
</tr>
<tr>
<td>@on{event}</td>
<td>Adds an event handler for the<br>specified event</td>
<td>&lt;button<br>@onclick=&quot;Incremen<br>tCount&quot;&gt;Click<br>me!</button></td>
</tr>
<tr>
<td>@key</td>
<td>Specifies a key to be used by the<br>diffing algorithm for preserving<br>elements in a collection</td>
<td>&lt;DetailsEditor<br>@key=&quot;person&quot;<br>Details=&quot;person.Det<br>ails&quot; /&gt;</td>
</tr>
</tbody>
</table>
<p>26 CHAPTER 6 | Build reusable UI components with Blazor</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ref</td>
<td>Captures a reference to the<br>component or HTML element</td>
<td>&lt;MyDialog<br>@ref=&quot;myDialog&quot; /&gt;</td>
</tr>
</tbody>
</table>
<p>The various directive attributes used by Blazor (@onclick, @bind, @ref, and so on) are covered in the<br />
sections below and later chapters.</p>
<p>Many of the syntaxes used in <em>.aspx</em> and <em>.ascx</em> files have parallel syntaxes in Razor. Below is a simple<br />
comparison of the syntaxes for ASP.NET Web Forms and Razor.</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Web Forms</th>
<th>Syntax</th>
<th>Razor</th>
<th>Synt<br>ax</th>
</tr>
</thead>
<tbody>
<tr>
<td>Directives</td>
<td>&lt;%@ [directive] %&gt;</td>
<td>&lt;%@ Page %&gt;</td>
<td>@[directive]</td>
<td>@pa<br>ge</td>
</tr>
<tr>
<td>Code blocks</td>
<td>&lt;% %&gt;</td>
<td>&lt;% int x = 123; %&gt;</td>
<td>@{ }</td>
<td>@{<br>int x<br>= <br>123; }</td>
</tr>
<tr>
<td>Expressions<br>(HTML-encoded)</td>
<td>&lt;%: %&gt;</td>
<td>&lt;%:DateTime.Now<br>%&gt;</td>
<td>Implicit: @<br>Explicit: @()</td>
<td>@Da<br>teTi<br>me.N<br>ow<br>@(Da<br>teTi<br>me.N<br>ow)</td>
</tr>
<tr>
<td>Comments</td>
<td>&lt;%-- --%&gt;</td>
<td>&lt;%-- Commented --<br>%&gt;</td>
<td>@* *@</td>
<td>@<em><br>Com<br>ment<br>ed<br></em>@</td>
</tr>
<tr>
<td>Data binding</td>
<td>&lt;%# %&gt;</td>
<td>&lt;%# Bind(&quot;Name&quot;)<br>%&gt;</td>
<td>@bind</td>
<td>&lt;inp<br>ut<br>@bin<br>d=&quot;u<br>serna<br>me&quot;<br>/&gt;</td>
</tr>
</tbody>
</table>
<p>To add members to the Razor component class, use the @code directive. This technique is similar to<br />
using a <script runat="server">...</script> block in an ASP.NET Web Forms user control or page.</p>
<p>27 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>Because Razor is based on C#, it must be compiled from within a C# project ( <em>.csproj</em> ). You can’t<br />
compile <em>.razor</em> files from a Visual Basic project ( <em>.vbproj</em> ). You can still reference Visual Basic projects<br />
from your Blazor project. The opposite is true too.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/views/razor">For a full Razor syntax reference, see Razor syntax reference for ASP.NET Core.</a></p>
<h3>Use components</h3>
<p>Aside from normal HTML, components can also use other components as part of their rendering logic.<br />
The syntax for using a component in Razor is similar to using a user control in an ASP.NET Web Forms<br />
app. Components are specified using an element tag that matches the type name of the component.<br />
For example, you can add a Counter component like this:</p>
<pre><code>&lt;Counter /&gt;

</code></pre>
<p>Unlike ASP.NET Web Forms, components in Blazor:</p>
<ul>
<li>
<p>Don’t use an element prefix (for example, asp:).</p>
</li>
<li>
<p>Don’t require registration on the page or in the <em>web.config</em> .</p>
</li>
</ul>
<p>Think of Razor components like you would .NET types, because that’s exactly what they are. If the<br />
assembly containing the component is referenced, then the component is available for use. To bring<br />
the component’s namespace into scope, apply the @using directive:</p>
<p>As seen in the default Blazor projects, it’s common to put @using directives into a <em>_Imports.razor</em> file<br />
so that they’re imported into all <em>.razor</em> files in the same directory and in child directories.</p>
<p>If the namespace for a component isn’t in scope, you can specify a component using its full type<br />
name, as you can in C#:</p>
<pre><code>&lt;MyComponentLib.Counter /&gt;

### Modify page title from components

</code></pre>
<p>When building SPA-style apps, it’s common for parts of a page to reload without reloading the entire<br />
page. Even so, it can be useful to have the title of the page change based on which component is<br />
currently loaded. This can be accomplished by including the <PageTitle> tag in the component’s<br />
Razor page:</p>
<p>The contents of this element can be dynamic, for instance showing the current count of messages:</p>
<p>28 CHAPTER 6 | Build reusable UI components with Blazor</p>
<pre><code>&lt;PageTitle&gt;@MessageCount messages&lt;/PageTitle&gt;

</code></pre>
<p>Note that if several components on a particular page include <PageTitle> tags, only the last one will<br />
be displayed (since each one will overwrite the previous one).</p>
<h3>Component parameters</h3>
<p>In ASP.NET Web Forms, you can flow parameters and data to controls using public properties. These<br />
properties can be set in markup using attributes or set directly in code. Razor components work in a<br />
similar fashion, although the component properties must also be marked with the [Parameter]<br />
attribute to be considered component parameters.</p>
<p>The following Counter component defines a component parameter called IncrementAmount that can<br />
be used to specify the amount that the Counter should be incremented each time the button is<br />
clicked.</p>
<p>To specify a component parameter in Blazor, use an attribute as you would in ASP.NET Web Forms:</p>
<pre><code>&lt;Counter IncrementAmount=&quot;10&quot; /&gt;

#### **Query string parameters**

</code></pre>
<p>Razor components can also leverage values from the query string of the page they’re rendered on as<br />
a parameter source. To enable this, add the [SupplyParameterFromQuery] attribute to the parameter.<br />
For example, the following parameter definition would get its value from the request in the form<br />
?IncBy=2:</p>
<p>If you don’t supply a custom Name in the [SupplyParameterFromQuery] attribute, by default it will<br />
match the property name (IncrementAmount in this case).</p>
<p>29 CHAPTER 6 | Build reusable UI components with Blazor</p>
<h3>Components and error boundaries</h3>
<p>By default, Blazor apps will detect unhandled exceptions and show an error message at the bottom of<br />
the page with no additional detail. To constrain the parts of the app that are impacted by an<br />
unhandled error, for instance to limit the impact to a single component, the <ErrorBoundary> tag can<br />
be wrapped around component declarations.</p>
<p>For example, to protect against possible exceptions thrown from the Counter component, declare it<br />
within an <ErrorBoundary> and optionally specify a message to display if there is an exception:</p>
<p>A default message stating “An error as occurred.” will be displayed if an unhandled exception occurs<br />
in the wrapped component.</p>
<h3>Event handlers</h3>
<p>Both ASP.NET Web Forms and Blazor provide an event-based programming model for handling UI<br />
events. Examples of such events include button clicks and text input. In ASP.NET Web Forms, you use<br />
HTML server controls to handle UI events exposed by the DOM, or you can handle events exposed by<br />
web server controls. The events are surfaced on the server through form post-back requests. Consider<br />
the following Web Forms button click example:</p>
<p><em>Counter.ascx</em></p>
<p>In Blazor, you can register handlers for DOM UI events directly using directive attributes of the form<br />
@on{event}. The {event} placeholder represents the name of the event. For example, you can listen for<br />
button clicks like this:</p>
<p>30 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>Event handlers can accept an optional, event-specific argument to provide more information about<br />
the event. For example, mouse events can take a MouseEventArgs argument, but it isn’t required.</p>
<p>Instead of referring to a method group for an event handler, you can use a lambda expression. A<br />
lambda expression allows you to close over other in-scope values.</p>
<p>Event handlers can execute synchronously or asynchronously. For example, the following OnClick<br />
event handler executes asynchronously:</p>
<p>After an event is handled, the component is rendered to account for any component state changes.<br />
With asynchronous event handlers, the component is rendered immediately after the handler<br />
execution completes. The component is rendered <em>again</em> after the asynchronous Task completes. This<br />
asynchronous execution mode provides an opportunity to render some appropriate UI while the<br />
asynchronous Task is still in progress.</p>
<p>31 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>Components can also define their own events by defining a component parameter of type<br />
EventCallback<TValue>. Event callbacks support all the variations of DOM UI event handlers: optional<br />
arguments, synchronous or asynchronous, method groups, or lambda expressions.</p>
<h3>Data binding</h3>
<p>Blazor provides a simple mechanism to bind data from a UI component to the component’s state. This<br />
approach differs from the features in ASP.NET Web Forms for binding data from data sources to UI<br />
controls. We’ll cover handling data from different data sources in the Dealing with data section.</p>
<p>To create a two-way data binding from a UI component to the component’s state, use the @bind<br />
directive attribute. In the following example, the value of the check box is bound to the isChecked<br />
field.</p>
<p>When the component is rendered, the value of the checkbox is set to the value of the isChecked field.<br />
When the user toggles the checkbox, the onchange event is fired and the isChecked field is set to the<br />
new value. The @bind syntax in this case is equivalent to the following markup:</p>
<pre><code>&lt;input value=&quot;@isChecked&quot; @onchange=&quot;(UIChangeEventArgs e) =&gt; isChecked = e.Value&quot; /&gt;

</code></pre>
<p>To change the event used for the bind, use the @bind:event attribute.</p>
<p>32 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>Components can also support data binding to their parameters. To data bind, define an event callback<br />
parameter with the same name as the bindable parameter. The “Changed” suffix is added to the<br />
name.</p>
<p><em>PasswordBox.razor</em></p>
<p>To chain a data binding to an underlying UI element, set the value and handle the event directly on<br />
the UI element instead of using the @bind attribute.</p>
<p>To bind to a component parameter, use a @bind-{Parameter} attribute to specify the parameter to<br />
which you want to bind.</p>
<h3>State changes</h3>
<p>If the component’s state has changed outside of a normal UI event or event callback, then the<br />
component must manually signal that it needs to be rendered again. To signal that a component’s<br />
state has changed, call the StateHasChanged method on the component.</p>
<p>In the example below, a component displays a message from an AppState service that can be updated<br />
by other parts of the app. The component registers its StateHasChanged method with the<br />
AppState.OnChange event so that the component is rendered whenever the message gets updated.</p>
<p>33 CHAPTER 6 | Build reusable UI components with Blazor</p>
<h3>Component lifecycle</h3>
<p>The ASP.NET Web Forms framework has well-defined lifecycle methods for modules, pages, and<br />
controls. For example, the following control implements event handlers for the Init, Load, and UnLoad<br />
lifecycle events:</p>
<p><em>Counter.ascx.cs</em></p>
<p>Razor components also have a well-defined lifecycle. A component’s lifecycle can be used to initialize<br />
component state and implement advanced component behaviors.</p>
<p>All of Blazor’s component lifecycle methods have both synchronous and asynchronous versions.<br />
Component rendering is synchronous. You can’t run asynchronous logic as part of the component<br />
rendering. All asynchronous logic must execute as part of an async lifecycle method.</p>
<h4><strong>OnInitialized</strong></h4>
<p>The OnInitialized and OnInitializedAsync methods are used to initialize the component. A component<br />
is typically initialized after it’s first rendered. After a component is initialized, it may be rendered</p>
<p>34 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>multiple times before it’s eventually disposed. The OnInitialized method is similar to the Page_Load<br />
event in ASP.NET Web Forms pages and controls.</p>
<h4><strong>OnParametersSet</strong></h4>
<p>The OnParametersSet and OnParametersSetAsync methods are called when a component has<br />
received parameters from its parent and the value are assigned to properties. These methods are<br />
executed after component initialization and <em>each time the component is rendered</em> .</p>
<h4><strong>OnAfterRender</strong></h4>
<p>The OnAfterRender and OnAfterRenderAsync methods are called after a component has finished<br />
rendering. Element and component references are populated at this point (more on these concepts<br />
below). Interactivity with the browser is enabled at this point. Interactions with the DOM and<br />
JavaScript execution can safely take place.</p>
<p>OnAfterRender and OnAfterRenderAsync <em>aren’t called when prerendering on the server</em> .</p>
<p>The firstRender parameter is true the first time the component is rendered; otherwise, its value is false.</p>
<h4><strong>IDisposable</strong></h4>
<p>Razor components can implement IDisposable to dispose of resources when the component is<br />
removed from the UI. A Razor component can implement IDispose by using the @implements<br />
directive:</p>
<p>35 CHAPTER 6 | Build reusable UI components with Blazor</p>
<h3>Capture component references</h3>
<p>In ASP.NET Web Forms, it’s common to manipulate a control instance directly in code by referring to<br />
its ID. In Blazor, it’s also possible to capture and manipulate a reference to a component, although it’s<br />
much less common.</p>
<p>To capture a component reference in Blazor, use the @ref directive attribute. The value of the<br />
attribute should match the name of a settable field with the same type as the referenced component.</p>
<p>When the parent component is rendered, the field is populated with the child component instance.<br />
You can then call methods on, or otherwise manipulate, the component instance.</p>
<p>Manipulating component state directly using component references isn’t recommended. Doing so<br />
prevents the component from being rendered automatically at the correct times.</p>
<h3>Capture element references</h3>
<p>Razor components can capture references to an element. Unlike HTML server controls in ASP.NET<br />
Web Forms, you can’t manipulate the DOM directly using an element reference in Blazor. Blazor<br />
handles most DOM interactions for you using its DOM diffing algorithm. Captured element references<br />
in Blazor are opaque. However, they’re used to pass a specific element reference in a JavaScript<br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/javascript-interop">interop call. For more information about JavaScript interop, see ASP.NET Core Blazor JavaScript</a><br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/javascript-interop">interop.</a></p>
<h3>Templated components</h3>
<p>In ASP.NET Web Forms, you can create <em>templated controls</em> . Templated controls enable the developer<br />
to specify a portion of the HTML used to render a container control. The mechanics of building<br />
templated server controls are complex, but they enable powerful scenarios for rendering data in a<br />
user customizable way. Examples of templated controls include Repeater and DataList.</p>
<p>Razor components can also be templated by defining component parameters of type<br />
RenderFragment or RenderFragment<T>. A RenderFragment represents a chunk of Razor markup</p>
<p>36 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>that can then be rendered by the component. A RenderFragment<T> is a chunk of Razor markup that<br />
takes a parameter that can be specified when the render fragment is rendered.</p>
<h4><strong>Child content</strong></h4>
<p>Razor components can capture their child content as a RenderFragment and render that content as<br />
part of the component rendering. To capture child content, define a component parameter of type<br />
RenderFragment and name it ChildContent.</p>
<p><em>ChildContentComponent.razor</em></p>
<h4><strong>Template parameters</strong></h4>
<p>A templated Razor component can also define multiple component parameters of type<br />
RenderFragment or RenderFragment<T>. The parameter for a RenderFragment<T> can be specified<br />
when it’s invoked. To specify a generic type parameter for a component, use the @typeparam Razor<br />
directive.</p>
<p><em>SimpleListView.razor</em></p>
<p>37 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>When using a templated component, the template parameters can be specified using child elements<br />
that match the names of the parameters. Component arguments of type RenderFragment<T> passed<br />
as elements have an implicit parameter named context. You can change the name of this implement<br />
parameter using the Context attribute on the child element. Any generic type parameters can be<br />
specified using an attribute that matches the name of the type parameter. The type parameter will be<br />
inferred if possible:</p>
<h3>Code-behind</h3>
<p>A Razor component is typically authored in a single <em>.razor</em> file. However, it’s also possible to separate<br />
the code and markup using a code-behind file. To use a component file, add a C# file that matches<br />
the file name of the component file but with a <em>.cs</em> extension added ( <em>Counter.razor.cs</em> ). Use the C# file<br />
to define a base class for the component. You can name the base class anything you’d like, but it’s<br />
common to name the class the same as the component class, but with a Base extension added<br />
(CounterBase). The component-based class must also derive from ComponentBase. Then, in the Razor<br />
component file, add the @inherits directive to specify the base class for the component (@inherits<br />
CounterBase).</p>
<p><em>Counter.razor</em></p>
<p>38 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p>The visibility of the component’s members in the base class must be protected or public to be visible<br />
to the component class.</p>
<h3>Additional resources</h3>
<p>The preceding isn’t an exhaustive treatment of all aspects of Razor components. For more information<br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/components">on how to Create and use ASP.NET Core Razor components, see the Blazor documentation.</a></p>
<p>39 CHAPTER 6 | Build reusable UI components with Blazor</p>
<p><strong>CHAPTER</strong></p>
<h1>7</h1>
<h2>Pages, routing, and layouts</h2>
<p>ASP.NET Web Forms apps are composed of pages defined in <em>.aspx</em> files. Each page’s address is based<br />
on its physical file path in the project. When a browser makes a request to the page, the contents of<br />
the page are dynamically rendered on the server. The rendering accounts for both the page’s HTML<br />
markup and its server controls.</p>
<p>In Blazor, each page in the app is a component, typically defined in a <em>.razor</em> file, with one or more<br />
specified routes. Routing mostly happens client-side without involving a specific server request. The<br />
browser first makes a request to the root address of the app. A root Router component in the Blazor<br />
app then handles intercepting navigation requests and forwards them to the correct component.</p>
<p>Blazor also supports <em>deep linking</em> . Deep linking occurs when the browser makes a request to a specific<br />
route other than the root of the app. Requests for deep links sent to the server are routed to the<br />
Blazor app, which then routes the request client-side to the correct component.</p>
<p>A simple page in ASP.NET Web Forms might contain the following markup:</p>
<p><em>Name.aspx</em></p>
<p><em>Name.aspx.cs</em></p>
<p>40 CHAPTER 7 | Pages, routing, and layouts</p>
<p>The equivalent page in a Blazor app would look like this:</p>
<p><em>Name.razor</em></p>
<h3>Create pages</h3>
<p>To create a page in Blazor, create a component and add the @page Razor directive to specify the<br />
route for the component. The @page directive takes a single parameter, which is the route template<br />
to add to that component.</p>
<pre><code>@page &quot;/counter&quot;

</code></pre>
<p>The route template parameter is required. Unlike ASP.NET Web Forms, the route to a Blazor<br />
component <em>isn’t</em> inferred from its file location (although that may be a feature added in the future).</p>
<p>The route template syntax is the same basic syntax used for routing in ASP.NET Web Forms. Route<br />
parameters are specified in the template using braces. Blazor will bind route values to component<br />
parameters with the same name (case-insensitive).</p>
<p>You can also specify constraints on the value of the route parameter. For example, to constrain the<br />
product ID to be an int:</p>
<p>41 CHAPTER 7 | Pages, routing, and layouts</p>
<p><a href="https://docs.microsoft.com/aspnet/core/blazor/routing#route-constraints">For a full list of the route constraints supported by Blazor, see Route constraints.</a></p>
<h3>Router component</h3>
<p>Routing in Blazor is handled by the Router component. The Router component is typically used in the<br />
app’s root component ( <em>App.razor</em> ).</p>
<p>The Router component discovers the routable components in the specified AppAssembly and in the<br />
optionally specified AdditionalAssemblies. When the browser navigates, the Router intercepts the<br />
navigation and renders the contents of its Found parameter with the extracted RouteData if a route<br />
matches the address, otherwise the Router renders its NotFound parameter.</p>
<p>The RouteView component handles rendering the matched component specified by the RouteData<br />
with its layout if it has one. If the matched component doesn’t have a layout, then the optionally<br />
specified DefaultLayout is used.</p>
<p>The LayoutView component renders its child content within the specified layout. We’ll look at layouts<br />
more in detail later in this chapter.</p>
<h3>Navigation</h3>
<p>In ASP.NET Web Forms, you trigger navigation to a different page by returning a redirect response to<br />
the browser. For example:</p>
<p>Returning a redirect response isn’t typically possible in Blazor. Blazor doesn’t use a request-reply<br />
model. You can, however, trigger browser navigations directly, as you can with JavaScript.</p>
<p>42 CHAPTER 7 | Pages, routing, and layouts</p>
<p>Blazor provides a NavigationManager service that can be used to:</p>
<ul>
<li>
<p>Get the current browser address</p>
</li>
<li>
<p>Get the base address</p>
</li>
<li>
<p>Trigger navigations</p>
</li>
<li>
<p>Get notified when the address changes</p>
</li>
</ul>
<p>To navigate to a different address, use the NavigateTo method:</p>
<p><a href="https://docs.microsoft.com/aspnet/core/blazor/routing#uri-and-navigation-state-helpers">For a description of all NavigationManager members, see URI and navigation state helpers.</a></p>
<h3>Base URLs</h3>
<p>If your Blazor app is deployed under a base path, then you need to specify the base URL in the page<br />
metadata using the <base> tag for routing to work property. If the host page for the app is serverrendered using Razor, then you can use the ~/ syntax to specify the app’s base address. If the host<br />
page is static HTML, then you need to specify the base URL explicitly.</p>
<pre><code>&lt; base href =&quot;~/&quot; /&gt;

### Page layout

</code></pre>
<p>Page layout in ASP.NET Web Forms is handled by Master Pages. Master Pages define a template with<br />
one or more content placeholders that can then be supplied by individual pages. Master Pages are<br />
defined in <em>.master</em> files and start with the &lt;%@ Master %&gt; directive. The content of the <em>.master</em> files is<br />
coded as you would an <em>.aspx</em> page, but with the addition of <a href="asp:ContentPlaceHolder">asp:ContentPlaceHolder</a> controls to<br />
mark where pages can supply content.</p>
<p><em>Site.master</em></p>
<p>43 CHAPTER 7 | Pages, routing, and layouts</p>
<p>In Blazor, you handle page layout using layout components. Layout components inherit from<br />
LayoutComponentBase, which defines a single Body property of type RenderFragment, which can be<br />
used to render the contents of the page.</p>
<p><em>MainLayout.razor</em></p>
<p>When the page with a layout is rendered, the page is rendered within the contents of the specified<br />
layout at the location where the layout renders its Body property.</p>
<p>To apply a layout to a page, use the @layout directive:</p>
<pre><code>@layout MainLayout

</code></pre>
<p>You can specify the layout for all components in a folder and subfolders using an <em>_Imports.razor</em> file.<br />
You can also specify a default layout for all your pages using the Router component.</p>
<p>Master Pages can define multiple content placeholders, but layouts in Blazor only have a single Body<br />
property. This limitation of Blazor layout components will hopefully be addressed in a future release.</p>
<p>Master Pages in ASP.NET Web Forms can be nested. That is, a Master Page may also use a Master<br />
Page. Layout components in Blazor may be nested too. You can apply a layout component to a layout<br />
component. The contents of the inner layout will be rendered within the outer layout.</p>
<p><em>ChildLayout.razor</em></p>
<p><em>Index.razor</em></p>
<p>The rendered output for the page would then be:</p>
<p>44 CHAPTER 7 | Pages, routing, and layouts</p>
<p>Layouts in Blazor don’t typically define the root HTML elements for a page (<html>, <body>, <head>,<br />
and so on). The root HTML elements are instead defined in a Blazor app’s host page, which is used to<br />
render the initial HTML content for the app (see Bootstrap Blazor). The host page can render multiple<br />
root components for the app with surrounding markup.</p>
<p>Components in Blazor, including pages, can’t render <script> tags. This rendering restriction exists<br />
because <script> tags get loaded once and then can’t be changed. Unexpected behavior may occur if<br />
you try to render the tags dynamically using Razor syntax. Instead, all <script> tags should be added<br />
to the app’s host page.</p>
<p>45 CHAPTER 7 | Pages, routing, and layouts</p>
<p><strong>CHAPTER</strong></p>
<h1>8</h1>
<h2>State management</h2>
<p>State management is a key concept of Web Forms applications, facilitated through ViewState, Session<br />
State, Application State, and Postback features. These stateful features of the framework helped to<br />
hide the state management required for an application and allow application developers to focus on<br />
delivering their functionality. With ASP.NET Core and Blazor, some of these features have been<br />
relocated and some have been removed altogether. This chapter reviews how to maintain state and<br />
deliver the same functionality with the new features in Blazor.</p>
<h3>Request state management with ViewState</h3>
<p>When discussing state management in Web Forms application, many developers will immediately<br />
think of ViewState. In Web Forms, ViewState manages the state of the content between HTTP requests<br />
by sending a large encoded block of text back and forth to the browser. The ViewState field could be<br />
overwhelmed with content from a page containing many elements, potentially expanding to several<br />
megabytes in size.</p>
<p>With Blazor Server, the app maintains an ongoing connection with the server. The app’s state, called a<br />
<em>circuit</em>, is held in server memory while the connection is considered active. State will only be disposed<br />
when the user navigates away from the app or a particular page in the app. All members of the active<br />
components are available between interactions with the server.</p>
<p>There are several advantages of this feature:</p>
<ul>
<li>
<p>Component state is readily available and not rebuilt between interactions.</p>
</li>
<li>
<p>State isn’t transmitted to the browser.</p>
</li>
</ul>
<p>However, there are some disadvantages to in-memory component state persistence to be aware of:</p>
<ul>
<li>
<p>If the server restarts between request, state is lost.</p>
</li>
<li>
<p>Your application web server load-balancing solution must include sticky sessions to ensure<br />
that all requests from the same browser return to the same server. If a request goes to a<br />
different server, state will be lost.</p>
</li>
<li>
<p>Persistence of component state on the server can lead to memory pressure on the web server.</p>
</li>
</ul>
<p>For the preceding reasons, don’t rely on just the state of the component to reside in-memory on the<br />
server. Your application should also include some backing data store for data between requests. Some<br />
simple examples of this strategy:</p>
<ul>
<li>In a shopping cart application, persist the content of new items added to the cart in a<br />
database record. If the state on the server is lost, you can reconstitute it from the database<br />
records.</li>
</ul>
<p>46 CHAPTER 8 | State management</p>
<ul>
<li>In a multi-part web form, your users will expect your application to remember values between<br />
each request. Write the data between each of your user’s posts to a data store so that they<br />
can be fetched and assembled into the final form response structure when the multi-part<br />
form is completed.</li>
</ul>
<p><a href="https://docs.microsoft.com/aspnet/core/blazor/state-management">For additional details on managing state in Blazor apps, see ASP.NET Core Blazor state management.</a></p>
<h3>Maintain state with Session</h3>
<p>Web Forms developers could maintain information about the currently acting user with the<br />
<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.http.isession">Microsoft.AspNetCore.Http.ISession dictionary object. It’s easy enough to add an object with a string</a><br />
key to the Session, and that object would be available at a later time during the user’s interactions<br />
with the application. In an attempt to eliminate managing interacting with HTTP, the Session object<br />
made it easy to maintain state.</p>
<p>The signature of the .NET Framework Session object isn’t the same as the ASP.NET Core Session<br />
<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.http.isession">object. Consider the documentation for the new ASP.NET Core Session</a> before deciding to migrate<br />
and use the new session state feature.</p>
<p>Session is available in ASP.NET Core and Blazor Server, but is discouraged from use in favor of storing<br />
data in a data repository appropriately. Session state is also not functional if visitors decline the use<br />
HTTP cookies in your application due to privacy concerns.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/app-state#session-state">Configuration for ASP.NET Core and Session state is available in the Session and state management in</a><br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/app-state#session-state">ASP.NET Core article.</a></p>
<h3>Application state</h3>
<p>The Application object in the Web Forms framework provides a massive, cross-request repository for<br />
interacting with application-scope configuration and state. Application state was an ideal place to<br />
store various application configuration properties that would be referenced by all requests, regardless<br />
of the user making the request. The problem with the Application object was that data didn’t persist<br />
across multiple servers. The state of the application object was lost between restarts.</p>
<p>As with Session, it’s recommended that data move to a persistent backing store that could be<br />
accessed by multiple server instances. If there is volatile data that you would like to be able to access<br />
across requests and users, you could easily store it in a singleton service that can be injected into<br />
components that require this information or interaction.</p>
<p>The construction of an object to maintain application state and its consumption could resemble the<br />
following implementation:</p>
<p>47 CHAPTER 8 | State management</p>
<p>The MyApplicationState object is created only once on the server, and the value VisitorCounter is<br />
fetched and output in the component’s label. The VisitorCounter value should be persisted and<br />
retrieved from a backing data store for durability and scalability.</p>
<h3>In the browser</h3>
<p>Application data can also be stored client-side on the user’s device so that is available later. There are<br />
two browser features that allow for persistence of data in different scopes of the user’s browser:</p>
<ul>
<li>
<p>localStorage - scoped to the user’s entire browser. If the page is reloaded, the browser is<br />
closed and reopened, or another tab is opened with the same URL then the same<br />
localStorage is provided by the browser</p>
</li>
<li>
<p>sessionStorage - scoped to the user’s current browser tab. If the tab is reloaded, the state<br />
persists. However, if the user opens another tab to your application or closes and reopens the<br />
browser the state is lost.</p>
</li>
</ul>
<p>You can write some custom JavaScript code to interact with these features, or there are a number of<br />
NuGet packages that you can use that provide this functionality. One such package is<br />
<a href="https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage">Microsoft.AspNetCore.ProtectedBrowserStorage.</a></p>
<p>For instructions on utilizing this package to interact with localStorage and sessionStorage, see the<br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/state-management#protected-browser-storage-experimental-package">Blazor State Management article.</a></p>
<p>48 CHAPTER 8 | State management</p>
<p><strong>CHAPTER</strong></p>
<h1>9</h1>
<h2>Forms and validation</h2>
<p>The ASP.NET Web Forms framework includes a set of validation server controls that handle validating<br />
user input entered into a form (RequiredFieldValidator, CompareValidator, RangeValidator, and so on).<br />
The ASP.NET Web Forms framework also supports model binding and validating the model based on<br />
data annotations ([Required], [StringLength], [Range], and so on). The validation logic can be enforced<br />
both on the server and on the client using unobtrusive JavaScript-based validation. The<br />
ValidationSummary server control is used to display a summary of the validation errors to the user.</p>
<p>Blazor supports the sharing of validation logic between both the client and the server. ASP.NET<br />
provides pre-built JavaScript implementations of many common server validations. In many cases, the<br />
developer still has to write JavaScript to fully implement their app-specific validation logic. The same<br />
model types, data annotations, and validation logic can be used on both the server and client.</p>
<p>Blazor provides a set of input components. The input components handle binding field data to a<br />
model and validating the user input when the form is submitted.</p>
<table>
<thead>
<tr>
<th>Input component</th>
<th>Rendered HTML element</th>
</tr>
</thead>
<tbody>
<tr>
<td>InputCheckbox</td>
<td><input type="checkbox"></td>
</tr>
<tr>
<td>InputDate</td>
<td><input type="date"></td>
</tr>
<tr>
<td>InputNumber</td>
<td><input type="number"></td>
</tr>
<tr>
<td>InputSelect</td>
<td><select></td>
</tr>
<tr>
<td>InputText</td>
<td><input></td>
</tr>
<tr>
<td>InputTextArea</td>
<td><textarea></td>
</tr>
</tbody>
</table>
<p>The EditForm component wraps these input components and orchestrates the validation process<br />
through an EditContext. When creating an EditForm, you specify what model instance to bind to using<br />
the Model parameter. Validation is typically done using data annotations, and it’s extensible. To<br />
enable data annotation-based validation, add the DataAnnotationsValidator component as a child of<br />
the EditForm. The EditForm component provides a convenient event for handling valid<br />
(OnValidSubmit) and invalid (OnInvalidSubmit) submissions. There’s also a more generic OnSubmit<br />
event that lets you trigger and handle the validation yourself.</p>
<p>To display a validation error summary, use the ValidationSummary component. To display validation<br />
messages for a specific input field, use the ValidationMessage component, specifying a lambda<br />
expression for the For parameter that points to the appropriate model member.</p>
<p>The following model type defines several validation rules using data annotations:</p>
<p>49 CHAPTER 9 | Forms and validation</p>
<p>The following component demonstrates building a form in Blazor based on the Starship model type:</p>
<p>50 CHAPTER 9 | Forms and validation</p>
<p>After the form submission, the model-bound data hasn’t been saved to any data store, like a<br />
database. In a Blazor WebAssembly app, the data must be sent to the server. For example, using an<br />
HTTP POST request. In a Blazor Server app, the data is already on the server, but it must be persisted.<br />
Handling data access in Blazor apps is the subject of the Dealing with data section.</p>
<h3>Additional resources</h3>
<p><a href="https://docs.microsoft.com/aspnet/core/blazor/forms-validation">For more information on forms and validation</a> in Blazor apps, see the Blazor documentation.</p>
<p>51 CHAPTER 9 | Forms and validation</p>
<p><strong>CHAPTER</strong></p>
<h1>10</h1>
<h2>Work with data</h2>
<p>Data access is the backbone of an ASP.NET Web Forms app. If you’re building forms for the web, what<br />
happens to that data? With Web Forms, there were multiple data access techniques you could use to<br />
interact with a database:</p>
<ul>
<li>
<p>Data Sources</p>
</li>
<li>
<p>ADO.NET</p>
</li>
<li>
<p>Entity Framework</p>
</li>
</ul>
<p>Data Sources were controls that you could place on a Web Forms page and configure like other<br />
controls. Visual Studio provided a friendly set of dialogs to configure and bind the controls to your<br />
Web Forms pages. Developers who enjoy a “low code” or “no code” approach preferred this<br />
technique when Web Forms was first released.</p>
<p>ADO.NET is the low-level approach to interacting with a database. Your apps could create a<br />
connection to the database with Commands, Datatables, and Datasets for interacting. The results<br />
could then be bound to fields on screen without much code. The drawback of this approach was that<br />
each set of ADO.NET objects (Connection, Command, and DataTable) was bound to libraries provided<br />
by a database vendor. Use of these components made the code rigid and difficult to migrate to a<br />
different database.</p>
<h3>Entity Framework</h3>
<p>Entity Framework (EF) is the open source object-relational mapping framework maintained by the<br />
.NET Foundation. Initially released with .NET Framework, EF allows for generating code for the<br />
database connections, storage schemas, and interactions. With this abstraction, you can focus on your</p>
<p>52 CHAPTER 10 | Work with data</p>
<p>app’s business rules and allow the database to be managed by a trusted database administrator. In<br />
.NET, you can use an updated version of EF called EF Core. EF Core helps generate and maintain the<br />
interactions between your code and the database with a series of commands that are available for you<br />
using the dotnet ef command-line tool. Let’s take a look at a few samples to get you working with a<br />
database.</p>
<h4><strong>EF Code First</strong></h4>
<p>A quick way to get started building your database interactions is to start with the class objects you<br />
want to work with. EF provides a tool to help generate the appropriate database code for your classes.<br />
This approach is called “Code First” development. Consider the following Product class for a sample<br />
storefront app that we want to store in a relational database like Microsoft SQL Server.</p>
<p>Product has a primary key and three additional fields that would be created in our database:</p>
<ul>
<li>
<p>EF will identify the Id property as a primary key by convention.</p>
</li>
<li>
<p>Name will be stored in a column configured for text storage. The [Required] attribute<br />
decorating this property will add a not null constraint to help enforce this declared behavior<br />
of the property.</p>
</li>
<li>
<p>Description will be stored in a column configured for text storage, and have a maximum<br />
length configured of 4000 characters as dictated by the [MaxLength] attribute. The database<br />
schema will be configured with a column named MaxLength using data type varchar(4000).</p>
</li>
<li>
<p>The Price property will be stored as currency. The [Range] attribute will generate appropriate<br />
constraints to prevent data storage outside of the minimum and maximum values declared.</p>
</li>
</ul>
<p>We need to add this Product class to a database context class that defines the connection and<br />
translation operations with our database.</p>
<p>The MyDbContext class provides the one property that defines the access and translation for the<br />
Product class. Your application configures this class for interaction with the database using the<br />
following entries in the Startup class’s ConfigureServices method (or appropriate location in<br />
<em>Program.cs</em> using the builder.Services property instead of services):</p>
<p>53 CHAPTER 10 | Work with data</p>
<p>The preceding code will connect to a SQL Server database with the specified connection string. You<br />
can place the connection string in your <em>appsettings.json</em> file, environment variables, or other<br />
configuration storage locations and replace this embedded string appropriately.</p>
<p>You can then generate the database table appropriate for this class using the following commands:</p>
<p>The first command defines the changes you’re making to the database schema as a new EF Migration<br />
called Create Product table. A Migration defines how to apply and remove your new database<br />
changes.</p>
<p>Once applied, you have a simple Product table in your database and some new classes added to the<br />
project that help manage the database schema. You can find these generated classes, by default, in a<br />
new folder called <em>Migrations</em> . When you make changes to the Product class or add more related<br />
classes you would like interacting with your database, you need to run the command-line commands<br />
again with a new name of the migration. This command will generate another set of migration classes<br />
to update your database schema.</p>
<h4><strong>EF Database First</strong></h4>
<p>For existing databases, you can generate the classes for EF Core by using the .NET command-line<br />
tools. To scaffold the classes, use a variation of the following command:</p>
<p>The preceding command connects to the database using the specified connection string and the<br />
Microsoft.EntityFrameworkCore.SqlServer provider. Once connected, a database context class named<br />
MyDbContext is created. Additionally, supporting classes are created for the Product and Customer<br />
tables that were specified with the -t options. There are many configuration options for this command<br />
to generate the class hierarchy appropriate for your database. For a complete reference, see the<br />
<a href="https://docs.microsoft.com/ef/core/miscellaneous/cli/dotnet#dotnet-ef-dbcontext-scaffold">command’s documentation.</a></p>
<p><a href="https://docs.microsoft.com/ef/core/">More information about EF Core can be found on the Microsoft Docs site.</a></p>
<h3>Interact with web services</h3>
<p>When ASP.NET was first released, SOAP services were the preferred way for web servers and clients to<br />
exchange data. Much has changed since that time, and the preferred interactions with services have<br />
shifted to direct HTTP client interactions. With ASP.NET Core and Blazor, you can register the<br />
configuration of your HttpClient in <em>Program.cs</em> or in the Startup class’s ConfigureServices method. Use<br />
that configuration when you need to interact with the HTTP endpoint. Consider the following<br />
configuration code:</p>
<p>54 CHAPTER 10 | Work with data</p>
<p>Whenever you need to access data from GitHub, create a client with a name of github. The client is<br />
configured with the base address, and the request headers are set appropriately. Inject the<br />
IHttpClientFactory into your Blazor components with the @inject directive or an [Inject] attribute on a<br />
property. Create your named client and interact with services using the following syntax:</p>
<p>This method returns the string describing the collection of issues in the <em>dotnet/docs</em> GitHub repository.<br />
It returns content in JSON format and is deserialized into appropriate GitHub issue objects. There are<br />
many ways that you can configure the HttpClientFactory to deliver preconfigured HttpClient objects.<br />
Try configuring multiple HttpClient instances with different names and endpoints for the various web<br />
services you work with. This approach will make your interactions with those services easier to work<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/http-requests">with on each page. For more information, see Make HTTP requests using IHttpClientFactory.</a></p>
<p>55 CHAPTER 10 | Work with data</p>
<p><strong>CHAPTER</strong></p>
<h1>11</h1>
<h2>Modules, handlers, and middleware</h2>
<p>An ASP.NET Core app is built upon a series of <em>middleware</em> . Middleware is handlers that are arranged<br />
into a pipeline to handle requests and responses. In a Web Forms app, HTTP handlers and modules<br />
solve similar problems. In ASP.NET Core, modules, handlers, <em>Global.asax.cs</em>, and the app life cycle are<br />
replaced with middleware. In this chapter, you’ll learn about middleware in the context of a Blazor<br />
app.</p>
<h3>Overview</h3>
<p>The ASP.NET Core request pipeline consists of a sequence of request delegates, called one after the<br />
other. The following diagram demonstrates the concept. The thread of execution follows the black<br />
arrows.</p>
<p>56 CHAPTER 11 | Modules, handlers, and middleware</p>
<p>The preceding diagram lacks a concept of lifecycle events. This concept is foundational to how<br />
ASP.NET Web Forms requests are handled. This system makes it easier to reason about what process<br />
is occurring and allows middleware to be inserted at any point. Middleware executes in the order in<br />
which it’s added to the request pipeline. They’re also added in code instead of configuration files,<br />
usually in <em>Startup.cs</em> .</p>
<h3>Katana</h3>
<p>Readers familiar with Katana will feel comfortable in ASP.NET Core. In fact, Katana is a framework from<br />
which ASP.NET Core derives. It introduced similar middleware and pipeline patterns for ASP.NET 4.x.<br />
Middleware designed for Katana can be adapted to work with the ASP.NET Core pipeline.</p>
<h3>Common middleware</h3>
<p>ASP.NET 4.x includes many modules. In a similar fashion, ASP.NET Core has many middleware<br />
components available as well. IIS modules may be used in some cases with ASP.NET Core. In other<br />
cases, native ASP.NET Core middleware may be available.</p>
<p>The following table lists replacement middleware and components in ASP.NET Core.</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>ASP.NET 4.x module</th>
<th>ASP.NET Core option</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP errors</td>
<td>CustomErrorModule</td>
<td>Status Code Pages<br>Middleware</td>
</tr>
</tbody>
</table>
<p>57 CHAPTER 11 | Modules, handlers, and middleware</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>ASP.NET 4.x module</th>
<th>ASP.NET Core option</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default document</td>
<td>DefaultDocumentModule</td>
<td>Default Files Middleware</td>
</tr>
<tr>
<td>Directory browsing</td>
<td>DirectoryListingModule</td>
<td>Directory Browsing<br>Middleware</td>
</tr>
<tr>
<td>Dynamic compression</td>
<td>DynamicCompressionModule</td>
<td>Response Compression<br>Middleware</td>
</tr>
<tr>
<td>Failed requests tracing</td>
<td>FailedRequestsTracingModule</td>
<td>ASP.NET Core Logging</td>
</tr>
<tr>
<td>File caching</td>
<td>FileCacheModule</td>
<td>Response Caching<br>Middleware</td>
</tr>
<tr>
<td>HTTP caching</td>
<td>HttpCacheModule</td>
<td>Response Caching<br>Middleware</td>
</tr>
<tr>
<td>HTTP logging</td>
<td>HttpLoggingModule</td>
<td>ASP.NET Core Logging</td>
</tr>
<tr>
<td>HTTP redirection</td>
<td>HttpRedirectionModule</td>
<td>URL Rewriting<br>Middleware</td>
</tr>
<tr>
<td>ISAPI filters</td>
<td>IsapiFilterModule</td>
<td>Middleware</td>
</tr>
<tr>
<td>ISAPI</td>
<td>IsapiModule</td>
<td>Middleware</td>
</tr>
<tr>
<td>Request filtering</td>
<td>RequestFilteringModule</td>
<td>URL Rewriting<br>Middleware IRule</td>
</tr>
<tr>
<td>URL rewriting†</td>
<td>RewriteModule</td>
<td>URL Rewriting<br>Middleware</td>
</tr>
<tr>
<td>Static compression</td>
<td>StaticCompressionModule</td>
<td>Response Compression<br>Middleware</td>
</tr>
<tr>
<td>Static content</td>
<td>StaticFileModule</td>
<td>Static File Middleware</td>
</tr>
<tr>
<td>URL authorization</td>
<td>UrlAuthorizationModule</td>
<td>ASP.NET Core Identity</td>
</tr>
</tbody>
</table>
<p>This list isn’t exhaustive but should give an idea of what mapping exists between the two frameworks.<br />
<a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/iis/modules">For a more detailed list, see IIS modules with ASP.NET Core.</a></p>
<h3>Custom middleware</h3>
<p>Built-in middleware may not handle all scenarios needed for an app. In such cases, it makes sense to<br />
create your own middleware. There are multiple ways of defining middleware, with the simplest being<br />
a simple delegate. Consider the following middleware, which accepts a culture request from a query<br />
string:</p>
<p>58 CHAPTER 11 | Modules, handlers, and middleware</p>
<p>Middleware can also be defined as class, either by implementing the IMiddleware interface or by<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/middleware/write">following middleware convention. For more information, see Write custom ASP.NET Core middleware.</a></p>
<p>59 CHAPTER 11 | Modules, handlers, and middleware</p>
<p><strong>CHAPTER</strong></p>
<h1>12</h1>
<h2>App configuration</h2>
<p>The primary way to load app configuration in Web Forms is with entries in the <em>web.config</em> file—either<br />
on the server or a related configuration file referenced by <em>web.config</em> . You can use the static<br />
ConfigurationManager object to interact with app settings, data repository connection strings, and<br />
other extended configuration providers that are added into the app. It’s typical to see interactions<br />
with app configuration as seen in the following code:</p>
<p>With ASP.NET Core and server-side Blazor, the <em>web.config</em> file MAY be present if your app is hosted on<br />
a Windows IIS server. However, there’s no ConfigurationManager interaction with this configuration,<br />
and you can receive more structured app configuration from other sources. Let’s take a look at how<br />
configuration is gathered and how you can still access configuration information from a <em>web.config</em><br />
file.</p>
<h3>Configuration sources</h3>
<p>ASP.NET Core recognizes there are many configuration sources you may want to use for your app. The<br />
framework attempts to offer you the best of these features by default. Configuration is read and<br />
aggregated from these various sources by ASP.NET Core. Later loaded values for the same<br />
configuration key take precedence over earlier values.</p>
<p>ASP.NET Core was designed to be cloud-aware and to make the configuration of apps easier for both<br />
operators and developers. ASP.NET Core is environment-aware and knows if it’s running in your<br />
Production or Development environment. The environment indicator is set in the<br />
ASPNETCORE_ENVIRONMENT system environment variable. If no value is configured, the app defaults<br />
to running in the Production environment.</p>
<p>Your app can trigger and add configuration from several sources based on the environment’s name.<br />
By default, the configuration is loaded from the following resources in the order listed:</p>
<ol>
<li>
<p><em>appsettings.json</em> file, if present</p>
</li>
<li>
<p><em>appsettings.{ENVIRONMENT_NAME}.json</em> file, if present</p>
</li>
<li>
<p>User secrets file on disk, if present</p>
</li>
<li>
<p>Environment variables</p>
</li>
<li>
<p>Command-line arguments</p>
</li>
</ol>
<p>60 CHAPTER 12 | App configuration</p>
<h3>appsettings.json format and access</h3>
<p>The <em>appsettings.json</em> file can be hierarchical with values structured like the following JSON:</p>
<p>When presented with the preceding JSON, the configuration system flattens child values and<br />
references their fully qualified hierarchical paths. A colon (:) character separates each property in the<br />
hierarchy. For example, the configuration key section1:key0 accesses the section1 object literal’s key0<br />
value.</p>
<h3>User secrets</h3>
<p>User secrets are:</p>
<ul>
<li>
<p>Configuration values that are stored in a JSON file on the developer’s workstation, outside of<br />
the app development folder.</p>
</li>
<li>
<p>Only loaded when running in the Development environment.</p>
</li>
<li>
<p>Associated with a specific app.</p>
</li>
<li>
<p>Managed with the .NET CLI’s user-secrets command.</p>
</li>
</ul>
<p>Configure your app for secrets storage by executing the user-secrets command:</p>
<pre><code>dotnet user-secrets init

</code></pre>
<p>The preceding command adds a UserSecretsId element to the project file. The element contains a<br />
GUID, which is used to associate secrets with the app. You can then define a secret with the set<br />
command. For example:</p>
<pre><code>dotnet user-secrets set &quot;Parent:ApiKey&quot; &quot;12345&quot;

</code></pre>
<p>The preceding command makes the Parent:ApiKey configuration key available on a developer’s<br />
workstation with the value 12345.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/security/app-secrets">For more information about creating, storing, and managing user secrets, see the Safe storage of app</a><br />
<a href="https://docs.microsoft.com/aspnet/core/security/app-secrets">secrets in development in ASP.NET Core document.</a></p>
<h3>Environment variables</h3>
<p>The next set of values loaded into your app configuration is the system’s environment variables. All of<br />
your system’s environment variable settings are now accessible to you through the configuration API.</p>
<p>61 CHAPTER 12 | App configuration</p>
<p>Hierarchical values are flattened and separated by colon characters when read inside your app.<br />
However, some operating systems don’t allow the colon character environment variable names.<br />
ASP.NET Core addresses this limitation by converting values that have double-underscores (__) into a<br />
colon when they’re accessed. The Parent:ApiKey value from the user secrets section above can be<br />
overridden with the environment variable Parent__ApiKey.</p>
<h3>Command-line arguments</h3>
<p>Configuration can also be provided as command-line arguments when your app is started. Use the<br />
double-dash (--) or forward-slash (/) notation to indicate the name of the configuration value to set<br />
and the value to be configured. The syntax resembles the following commands:</p>
<h3>The return of web.config</h3>
<p>If you’ve deployed your app to Windows on IIS, the <em>web.config</em> file still configures IIS to manage your<br />
app. By default, IIS adds a reference to the ASP.NET Core Module (ANCM). ANCM is a native IIS<br />
module that hosts your app in place of the Kestrel web server. This <em>web.config</em> section resembles the<br />
following XML markup:</p>
<p>App-specific configuration can be defined by nesting an environmentVariables element in the<br />
aspNetCore element. The values defined in this section are presented to the ASP.NET Core app as<br />
environment variables. The environment variables load appropriately during that segment of app<br />
startup.</p>
<p>62 CHAPTER 12 | App configuration</p>
<h3>Read configuration in the app</h3>
<p><a href="https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration">ASP.NET Core provides app configuration through the IConfiguration interface. This configuration</a><br />
interface should be requested by your Blazor components, Blazor pages, and any other ASP.NET Coremanaged class that needs access to configuration. The ASP.NET Core framework will automatically<br />
populate this interface with the resolved configuration configured earlier. On a Blazor page or a<br />
component’s Razor markup, you can inject the IConfiguration object with an @inject directive at the<br />
top of the <em>.razor</em> file like this:</p>
<pre><code>@inject IConfiguration Configuration

</code></pre>
<p>This preceding statement makes the IConfiguration object available as the Configuration variable<br />
throughout the rest of the Razor template.</p>
<p>Individual configuration settings can be read by specifying the configuration setting hierarchy sought<br />
as an indexer parameter:</p>
<pre><code>var mySetting = Configuration[&quot;section1:key0&quot;];

</code></pre>
<p><a href="https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration.getsection">You can fetch entire configuration sections by using the GetSection</a> method to retrieve a collection of<br />
keys at a specific location with a syntax similar to GetSection(&quot;section1&quot;) to retrieve the configuration<br />
for section1 from the earlier example.</p>
<h3>Strongly typed configuration</h3>
<p>With Web Forms, it was possible to create a strongly typed configuration type that inherited from the<br />
<a href="https://docs.microsoft.com/dotnet/api/system.configuration.configurationsection">ConfigurationSection</a> type and associated types. A ConfigurationSection allowed you to configure<br />
some business rules and processing for those configuration values.</p>
<p>In ASP.NET Core, you can specify a class hierarchy that will receive the configuration values. These<br />
classes:</p>
<ul>
<li>
<p>Don’t need to inherit from a parent class.</p>
</li>
<li>
<p>Should include public properties that match the properties and type references for the<br />
configuration structure you wish to capture.</p>
</li>
</ul>
<p>For the earlier <em>appsettings.json</em> sample, you could define the following classes to capture the values:</p>
<p>63 CHAPTER 12 | App configuration</p>
<p>This class hierarchy can be populated by adding the following line to the Startup.ConfigureServices<br />
method (or appropriate location in <em>Program.cs</em> using the builder.Services property instead of services):</p>
<pre><code>services.Configure&lt;MyConfig&gt;(Configuration);

</code></pre>
<p>In the rest of the app, you can add an input parameter to classes or an @inject directive in Razor<br />
templates of type IOptions<MyConfig> to receive the strongly typed configuration settings. The<br />
IOptions<MyConfig>.Value property will yield the MyConfig value populated from the configuration<br />
settings.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces">More information about the Options feature can be found in the Options pattern in ASP.NET Core</a><br />
document.</p>
<p>64 CHAPTER 12 | App configuration</p>
<p><strong>CHAPTER</strong></p>
<h1>13</h1>
<h2>Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</h2>
<p>Migrating from an ASP.NET Web Forms application to Blazor will almost certainly require updating<br />
how authentication and authorization are performed, assuming the application had authentication<br />
configured. This chapter will cover how to migrate from the ASP.NET Web Forms universal provider<br />
model (for membership, roles, and user profiles) and how to work with ASP.NET Core Identity from<br />
Blazor apps. While this chapter will cover the high-level steps and considerations, the detailed steps<br />
and scripts may be found in the referenced documentation.</p>
<h3>ASP.NET universal providers</h3>
<p>Since ASP.NET 2.0, the ASP.NET Web Forms platform has supported a provider model for a variety of<br />
features, including membership. The universal membership provider, along with the optional role<br />
provider, is commonly deployed with ASP.NET Web Forms applications. It offers a robust and secure<br />
way to manage authentication and authorization that continues to work well today. The most recent<br />
<a href="https://www.nuget.org/packages/Microsoft.AspNet.Providers">offering of these universal providers is available as a NuGet package, Microsoft.AspNet.Providers.</a></p>
<p>The Universal Providers work with a SQL database schema that includes tables like<br />
aspnet_Applications, aspnet_Membership, aspnet_Roles, and aspnet_Users. When configured by<br />
<a href="https://docs.microsoft.com/previous-versions/ms229862(v=vs.140)">running the aspnet_regsql.exe command, the providers install tables and stored procedures that</a><br />
provide all of the necessary queries and commands to work with the underlying data. The database<br />
schema and these stored procedures are not compatible with newer ASP.NET Identity and ASP.NET<br />
Core Identity systems, so existing data must be migrated into the new system. Figure 1 shows an<br />
example table schema configured for universal providers.</p>
<p>65 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>The universal provider handles users, membership, roles, and profiles. Users are assigned globally<br />
unique identifiers and basic information like userId, userName etc. are stored in the aspnet_Users<br />
table. Authentication information, such as password, password format, password salt, lockout counters<br />
and details, etc. are stored in the aspnet_Membership table. Roles consist simply of names and unique<br />
identifiers, which are assigned to users via the aspnet_UsersInRoles association table, providing a<br />
many-to-many relationship.</p>
<p>If your existing system is using roles in addition to membership, you will need to migrate the user<br />
accounts, the associated passwords, the roles, and the role membership into ASP.NET Core Identity.<br />
You will also most likely need to update your code where you’re currently performing role checks<br />
using if statements to instead leverage declarative filters, attributes, and/or tag helpers. We will review<br />
migration considerations in greater detail at the end of this chapter.</p>
<h4><strong>Authorization configuration in Web Forms</strong></h4>
<p>To configure authorized access to certain pages in an ASP.NET Web Forms application, typically you<br />
specify that certain pages or folders are inaccessible to anonymous users. This configuration is done in<br />
the web.config file:</p>
<p>The authentication configuration section sets up the forms authentication for the application. The<br />
authorization section is used to disallow anonymous users for the entire application. However, you<br />
can provide more granular authorization rules on a per-location basis as well as apply role-based<br />
authorization checks.</p>
<p>66 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>The above configuration, when combined with the first one, would allow anonymous users to access<br />
the login page, overriding the site-wide restriction on non-authenticated users.</p>
<p>The above configuration, when combined with the others, restricts access to the /admin folder and all<br />
resources within it to members of the “Administrators” role. This restriction could also be applied by<br />
placing a separate web.config file within the /admin folder root.</p>
<h4><strong>Authorization code in Web Forms</strong></h4>
<p>In addition to configuring access using web.config, you can also programmatically configure access<br />
and behavior in your Web Forms application. For instance, you can restrict the ability to perform<br />
certain operations or view certain data based on the user’s role.</p>
<p>This code can be used both in code-behind logic as well as in the page itself:</p>
<p>In addition to checking user role membership, you can also determine if they are authenticated<br />
(though often this is better done using the location-based configuration covered above). Below is an<br />
example of this approach.</p>
<p>In the code above, role-based access control (RBAC) is used to determine whether certain elements of<br />
the page, such as a SecretPanel, are visible based on the current user’s role.</p>
<p>67 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>Typically, ASP.NET Web Forms applications configure security within the web.config file and then add<br />
additional checks where needed in .aspx pages and their related .aspx.cs code-behind files. Most<br />
applications leverage the universal membership provider, frequently with the additional role provider.</p>
<h3>ASP.NET Core Identity</h3>
<p>Although still tasked with authentication and authorization, ASP.NET Core Identity uses a different set<br />
of abstractions and assumptions when compared to the universal providers. For example, the new<br />
Identity model supports third party authentication, allowing users to authenticate using a social media<br />
account or other trusted authentication provider. ASP.NET Core Identity supports UI for commonly<br />
needed pages like login, logout, and register. It leverages EF Core for its data access, and uses EF Core<br />
<a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity">migrations to generate the necessary schema required to support its data model. This introduction to</a><br />
<a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity">Identity on ASP.NET Core provides a good overview of what is included with ASP.NET Core Identity</a><br />
and how to get started working with it. If you haven’t already set up ASP.NET Core Identity in your<br />
application and its database, it will help you get started.</p>
<h4><strong>Roles, claims, and policies</strong></h4>
<p>Both the universal providers and ASP.NET Core Identity support the concept of roles. You can create<br />
roles for users and assign users to roles. Users can belong to any number of roles, and you can verify<br />
role membership as part of your authorization implementation.</p>
<p>In addition to roles, ASP.NET Core identity supports the concepts of claims and policies. While a role<br />
should specifically correspond to a set of resources a user in that role should be able to access, a<br />
claim is simply part of a user’s identity. A claim is a name value pair that represents what the subject<br />
is, not what the subject can do.</p>
<p>It is possible to directly inspect a user’s claims and determine based on these values whether a user<br />
should be given access to a resource. However, such checks are often repetitive and scattered<br />
throughout the system. A better approach is to define a <em>policy</em> .</p>
<p>An authorization policy consists of one or more requirements. Policies are registered as part of the<br />
authorization service configuration in the ConfigureServices method of Startup.cs. For example, the<br />
following code snippet configures a policy called “CanadiansOnly”, which has the requirement that the<br />
user has the Country claim with the value of “Canada”.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/security/authorization/policies">You can learn more about how to create custom policies in the documentation.</a></p>
<p>Whether you’re using policies or roles, you can specify that a particular page in your Blazor<br />
application requires that role or policy with the [Authorize] attribute, applied with the @attribute<br />
directive.</p>
<p>Requiring a role:</p>
<p>68 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<pre><code>@attribute [Authorize(Roles =&quot;administrators&quot;)]

</code></pre>
<p>Requiring a policy be satisfied:</p>
<pre><code>@attribute [Authorize(Policy =&quot;CanadiansOnly&quot;)]

</code></pre>
<p>If you need access to a user’s authentication state, roles, or claims in your code, there are two primary<br />
ways to achieve this functionality. The first is to receive the authentication state as a cascading<br />
parameter. The second is to access the state using an injected AuthenticationStateProvider. The<br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/security/">details of each of these approaches are described in the Blazor Security documentation.</a></p>
<p>The following code shows how to receive the AuthenticationState as a cascading parameter:</p>
<p>With this parameter in place, you can get the user using this code:</p>
<p>The following code shows how to inject the AuthenticationStateProvider:</p>
<p>With the provider in place, you can gain access to the user with the following code:</p>
<p><strong>Note:</strong> The AuthorizeView component, covered later in this chapter, provides a declarative way to<br />
control what a user sees on a page or component.</p>
<p>To work with users and claims (in Blazor Server applications) you may also need to inject a<br />
UserManager<T> (use IdentityUser for default) which you can use to enumerate and modify claims<br />
for a user. First inject the type and assign it to a property:</p>
<pre><code>@inject UserManager&lt;IdentityUser&gt; MyUserManager

</code></pre>
<p>Then use it to work with the user’s claims. The following sample shows how to add and persist a claim<br />
on a user:</p>
<p>69 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>If you need to work with roles, follow the same approach. You may need to inject a RoleManager<T><br />
(use IdentityRole for default type) to list and manage the roles themselves.</p>
<p><strong>Note:</strong> In Blazor WebAssembly projects, you will need to provide server APIs to perform these<br />
operations (instead of using UserManager<T> or RoleManager<T> directly). A Blazor WebAssembly<br />
client application would manage claims and/or roles by securely calling API endpoints exposed for<br />
this purpose.</p>
<h4><strong>Migration guide</strong></h4>
<p>Migrating from ASP.NET Web Forms and universal providers to ASP.NET Core Identity requires several<br />
steps:</p>
<ol>
<li>
<p>Create ASP.NET Core Identity database schema in the destination database</p>
</li>
<li>
<p>Migrate data from universal provider schema to ASP.NET Core Identity schema</p>
</li>
<li>
<p>Migrate configuration from the web.config to middleware and services, typically in <em>Program.cs</em><br />
(or a Startup class)</p>
</li>
<li>
<p>Update individual pages using controls and conditionals to use tag helpers and new identity<br />
APIs.</p>
</li>
</ol>
<p>Each of these steps is described in detail in the following sections.</p>
<h4><strong>Creating the ASP.NET Core Identity schema</strong></h4>
<p>There are several ways to create the necessary table structure used for ASP.NET Core Identity. The<br />
simplest is to create a new ASP.NET Core Web application. Choose Web Application and then change<br />
Authentication type to use Individual Accounts.</p>
<p>70 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>From the command line, you can do the same thing by running dotnet new webapp -au Individual.<br />
Once the app has been created, run it and register on the site. You should trigger a page like the one<br />
shown below:</p>
<p>71 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>Click on the “Apply Migrations” button and the necessary database tables should be created for you.<br />
In addition, the migration files should appear in your project, as shown:</p>
<p>72 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>You can run the migration yourself, without running the web application, using this command-line<br />
tool:</p>
<pre><code>dotnet ef database update

</code></pre>
<p>If you would rather run a script to apply the new schema to an existing database, you can script these<br />
migrations from the command-line. Run this command to generate the script:</p>
<pre><code>dotnet ef migrations script -o auth.sql

</code></pre>
<p>The above command will produce a SQL script in the output file auth.sql, which can then be run<br />
<a href="https://docs.microsoft.com/ef/core/miscellaneous/cli/dotnet">against whatever database you like. If you have any trouble running dotnet ef commands, make sure</a><br />
<a href="https://docs.microsoft.com/ef/core/miscellaneous/cli/dotnet">you have the EF Core tools installed on your system.</a></p>
<p>In the event you have additional columns on your source tables, you will need to identify the best<br />
location for these columns in the new schema. Generally, columns found on the aspnet_Membership<br />
table should be mapped to the AspNetUsers table. Columns on aspnet_Roles should be mapped to<br />
AspNetRoles. Any additional columns on the aspnet_UsersInRoles table would be added to the<br />
AspNetUserRoles table.</p>
<p>It’s also worth considering putting any additional columns on separate tables. So that future<br />
migrations won’t need to take into account such customizations of the default identity schema.</p>
<h4><strong>Migrating data from universal providers to ASP.NET Core Identity</strong></h4>
<p>Once you have the destination table schema in place, the next step is to migrate your user and role<br />
records to the new schema. A complete list of the schema differences, including which columns map<br />
<a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity">to which new columns, can be found here.</a></p>
<p>73 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity">To migrate your users from membership to the new identity tables, you should follow the steps</a><br />
<a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity">described in the documentation. After following these steps and the script provided, your users will</a><br />
need to change their password the next time they log in.</p>
<p>It is possible to migrate user passwords but the process is much more involved. Requiring users to<br />
update their passwords as part of the migration process, and encouraging them to use new, unique<br />
passwords, is likely to enhance the overall security of the application.</p>
<h4><strong>Migrating security settings from web.config to app startup</strong></h4>
<p>As noted above, ASP.NET membership and role providers are configured in the application’s<br />
web.config file. Since ASP.NET Core apps are not tied to IIS and use a separate system for<br />
configuration, these settings must be configured elsewhere. For the most part, ASP.NET Core Identity<br />
is configured in the <em>Program.cs</em> file. Open the web project that was created earlier (to generate the<br />
identity table schema) and review its <em>Program.cs</em> (or <em>Startup.cs</em> ) file.</p>
<p>This code adds support for EF Core and Identity:</p>
<p>The AddDefaultIdentity extension method is used to configure Identity to use the default<br />
ApplicationDbContext and the framework’s IdentityUser type. If you’re using a custom IdentityUser, be<br />
sure to specify its type here. If these extension methods aren’t working in your application, check that<br />
you have the appropriate using statements and that you have the necessary NuGet package<br />
references. For example, your project should have some version of the<br />
Microsoft.AspNetCore.Identity.EntityFrameworkCore and Microsoft.AspNetCore.Identity.UI packages<br />
referenced.</p>
<p>Also in <em>Program.cs</em> you should see the necessary middleware configured for the site. Specifically,<br />
UseAuthentication and UseAuthorization should be set up, and in the proper location.</p>
<p>74 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>ASP.NET Identity does not configure anonymous or role-based access to locations from <em>Program.cs</em> .<br />
You will need to migrate any location-specific authorization configuration data to filters in ASP.NET<br />
Core. Make note of which folders and pages will require such updates. You will make these changes in<br />
the next section.</p>
<h4><strong>Updating individual pages to use ASP.NET Core Identity abstractions</strong></h4>
<p>In your ASP.NET Web Forms application, if you had web.config settings to deny access to certain<br />
pages or folders to anonymous users, you would migrate these changes by adding the [Authorize]<br />
attribute to such pages:</p>
<pre><code>@attribute [Authorize]

</code></pre>
<p>If you further had denied access except to those users belonging to a certain role, you would likewise<br />
migrate this behavior by adding an attribute specifying a role:</p>
<pre><code>@attribute [Authorize(Roles =&quot;administrators&quot;)]

</code></pre>
<p>The [Authorize] attribute only works on @page components that are reached via the Blazor Router.<br />
The attribute does not work with child components, which should instead use AuthorizeView.</p>
<p>If you have logic within page markup for determining whether to display some code to a certain user,<br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/security#authorizeview-component">you can replace this with the AuthorizeView component. The AuthorizeView component selectively</a><br />
displays UI depending on whether the user is authorized to see it. It also exposes a context variable<br />
that can be used to access user information.</p>
<p>You can access the authentication state within procedural logic by accessing the user from a<br />
Task&lt;AuthenticationState configured with the [CascadingParameter] attribute. This configuration will<br />
get you access to the user, which can let you determine if they are authenticated and if they belong to<br />
a particular role. If you need to evaluate a policy procedurally, you can inject an instance of the<br />
IAuthorizationService and calls the AuthorizeAsync method on it. The following sample code<br />
demonstrates how to get user information and allow an authorized user to perform a task restricted<br />
by the content-editor policy.</p>
<p>75 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>The AuthenticationState first need to be set up as a cascading value before it can be bound to a<br />
cascading parameter like this. That’s typically done using the CascadingAuthenticationState<br />
component. This configuration is typically done in App.razor:</p>
<h3>Summary</h3>
<p>Blazor uses the same security model as ASP.NET Core, which is ASP.NET Core Identity. Migrating from<br />
universal providers to ASP.NET Core Identity is relatively straightforward, assuming not too much<br />
customization was applied to the original data schema. Once the data has been migrated, working</p>
<p>76 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p>with authentication and authorization in Blazor apps is well documented, with configurable as well as<br />
programmatic support for most security requirements.</p>
<h3>References</h3>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity">Introduction to Identity on ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity">Migrate from ASP.NET Membership authentication to ASP.NET Core 2.0 Identity</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/identity">Migrate Authentication and Identity to ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/blazor/security/">ASP.NET Core Blazor authentication and authorization</a></p>
</li>
</ul>
<p>77 CHAPTER 13 | Security: Authentication and Authorization in ASP.NET Web Forms and Blazor</p>
<p><strong>CHAPTER</strong></p>
<h1>14</h1>
<h2>Migrate from ASP.NET Web Forms to Blazor</h2>
<p>Migrating a code base from ASP.NET Web Forms to Blazor is a time-consuming task that requires<br />
planning. This chapter outlines the process. Something that can ease the transition is to ensure the<br />
app adheres to an <em>N-tier</em> architecture, wherein the app model (in this case, Web Forms) is separate<br />
from the business logic. This logical separation of layers makes it clear what needs to move to .NET<br />
Core and Blazor.</p>
<p><a href="https://github.com/dotnet-architecture/eShopOnBlazor">For this example, the eShop app available on GitHub</a> is used. eShop is a catalog service that provides<br />
CRUD capabilities via form entry and validation.</p>
<p>Why should a working app be migrated to Blazor? Many times, there’s no need. ASP.NET Web Forms<br />
will continue to be supported for many years. However, many of the features that Blazor provides are<br />
only supported on a migrated app. Such features include:</p>
<ul>
<li>
<p>Performance improvements in the framework such as Span<T></p>
</li>
<li>
<p>Ability to run as WebAssembly</p>
</li>
<li>
<p>Cross-platform support for Linux and macOS</p>
</li>
<li>
<p>App-local deployment or shared framework deployment without impacting other apps</p>
</li>
</ul>
<p>If these or other new features are compelling enough, there may be value in migrating the app. The<br />
migration can take different shapes; it can be the entire app, or only certain endpoints that require the<br />
changes. The decision to migrate is ultimately based on the business problems to be solved by the<br />
developer.</p>
<h3>Server-side versus client-side hosting</h3>
<p>As described in the hosting models chapter, a Blazor app can be hosted in two different ways: serverside and client-side. The server-side model uses ASP.NET Core SignalR connections to manage the<br />
DOM updates while running any actual code on the server. The client-side model runs as<br />
WebAssembly within a browser and requires no server connections. There are a number of differences<br />
that may affect which is best for a specific app:</p>
<ul>
<li>
<p>Running as WebAssembly doesn’t support all features (such as threading) at the current time</p>
</li>
<li>
<p>Chatty communication between the client and server may cause latency issues in server-side<br />
mode</p>
</li>
</ul>
<p>78 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<ul>
<li>Access to databases and internal or protected services require a separate service with clientside hosting</li>
</ul>
<p>At the time of writing, the server-side model more closely resembles Web Forms. Most of this chapter<br />
focuses on the server-side hosting model, as it’s production-ready.</p>
<h3>Create a new project</h3>
<p>This initial migration step is to create a new project. This project type is based on the SDK style<br />
projects of .NET and simplifies much of the boilerplate that was used in previous project formats. For<br />
more detail, please see the chapter on Project Structure.</p>
<p>Once the project has been created, install the libraries that were used in the previous project. In older<br />
Web Forms projects, you may have used the <em>packages.config</em> file to list the required NuGet packages.<br />
In the new SDK-style project, <em>packages.config</em> has been replaced with <PackageReference> elements<br />
in the project file. A benefit to this approach is that all dependencies are installed transitively. You only<br />
list the top-level dependencies you care about.</p>
<p>Many of the dependencies you’re using are available for .NET, including Entity Framework 6 and<br />
log4net. If there’s no .NET or .NET Standard version available, the .NET Framework version can often<br />
be used. Your mileage may vary. Any API used that isn’t available in .NET causes a runtime error. Visual<br />
Studio notifies you of such packages. A yellow icon appears on the project’s <strong>References</strong> node in<br />
<strong>Solution Explorer</strong> .</p>
<p>In the Blazor-based eShop project, you can see the packages that are installed. Previously, the<br />
<em>packages.config</em> file listed every package used in the project, resulting in a file almost 50 lines long. A<br />
snippet of <em>packages.config</em> is:</p>
<p>79 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>The <packages> element includes all necessary dependencies. It’s difficult to identify which of these<br />
packages are included because you require them. Some <package> elements are listed simply to<br />
satisfy the needs of dependencies you require.</p>
<p>The Blazor project lists the dependencies you require within an <ItemGroup> element in the project<br />
file:</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/porting/windows-compat-pack">One NuGet package that simplifies the life of Web Forms developers is the Windows Compatibility</a><br />
<a href="https://docs.microsoft.com/en-us/dotnet/core/porting/windows-compat-pack">Pack. Although .NET is cross-platform, some features are only available on Windows. Windows-</a><br />
specific features are made available by installing the compatibility pack. Examples of such features<br />
include the Registry, WMI, and Directory Services. The package adds around 20,000 APIs and activates<br />
many services with which you may already be familiar. The eShop project doesn’t require the<br />
compatibility pack; but if your projects use Windows-specific features, the package eases the<br />
migration efforts.</p>
<h3>Enable startup process</h3>
<p>The startup process for Blazor has changed from Web Forms and follows a similar setup for other<br />
ASP.NET Core services. When hosted server-side, Razor components are run as part of a normal<br />
ASP.NET Core app. When hosted in the browser with WebAssembly, Razor components use a similar<br />
hosting model. The difference is the components are run as a separate service from any of the<br />
backend processes. Either way, the startup is similar.</p>
<p>The <em>Global.asax.cs</em> file is the default startup page for Web Forms projects. In the eShop project, this file<br />
configures the Inversion of Control (IoC) container and handles the various lifecycle events of the app<br />
or request. Some of these events are handled with middleware (such as Application_BeginRequest).<br />
Other events require the overriding of specific services via dependency injection (DI).</p>
<p>By way of example, the <em>Global.asax.cs</em> file for eShop, contains the following code:</p>
<p>80 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>The preceding file becomes the <em>Program.cs</em> file in server-side Blazor:</p>
<p>81 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>82 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>One significant change you may notice from Web Forms is the prominence of dependency injection<br />
(DI). DI has been a guiding principle in the ASP.NET Core design. It supports customization of almost<br />
all aspects of the ASP.NET Core framework. There’s even a built-in service provider that can be used<br />
for many scenarios. If more customization is required, it can be supported by many community<br />
projects. For example, you can carry forward your third-party DI library investment.</p>
<p>In the original eShop app, there’s some configuration for session management. Since server-side<br />
Blazor uses ASP.NET Core SignalR for communication, the session state isn’t supported as the<br />
connections may occur independent of an HTTP context. An app that uses the session state requires<br />
rearchitecting before running as a Blazor app.</p>
<p>For more information about app startup, see App startup.</p>
<h3>Migrate HTTP modules and handlers to middleware</h3>
<p>HTTP modules and handlers are common patterns in Web Forms to control the HTTP request pipeline.<br />
Classes that implement IHttpModule or IHttpHandler could be registered and process incoming<br />
requests. Web Forms configure modules and handlers in the <em>web.config</em> file. Web Forms is also heavily<br />
based on app lifecycle event handling. ASP.NET Core uses middleware instead. Middleware is<br />
registered in the Configure method of the Startup class. Middleware execution order is determined by<br />
the registration order.</p>
<p>In the Enable startup process section, a lifecycle event was raised by Web Forms as the<br />
Application_BeginRequest method. This event isn’t available in ASP.NET Core. One way to achieve this<br />
behavior is to implement middleware as seen in the <em>Startup.cs</em> file example. This middleware does the<br />
same logic and then transfers control to the next handler in the middleware pipeline.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/http-modules">For more information on migrating modules and handlers, see Migrate HTTP handlers and modules to</a><br />
<a href="https://docs.microsoft.com/aspnet/core/migration/http-modules">ASP.NET Core middleware.</a></p>
<p>83 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<h3>Migrate static files</h3>
<p>To serve static files (for example, HTML, CSS, images, and JavaScript), the files must be exposed by<br />
middleware. Calling the UseStaticFiles method enables the serving of static files from the web root<br />
path. The default web root directory is <em>wwwroot</em>, but it can be customized. As included in the<br />
<em>Program.cs</em> file:</p>
<p>The eShop project enables basic static file access. There are many customizations available for static<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/static-files">file access. For information on enabling default files or a file browser, see Static files in ASP.NET Core.</a></p>
<h3>Migrate runtime bundling and minification setup</h3>
<p>Bundling and minification are performance optimization techniques for reducing the number and size<br />
of server requests to retrieve certain file types. JavaScript and CSS often undergo some form of<br />
bundling or minification before being sent to the client. In ASP.NET Web Forms, these optimizations<br />
are handled at run time. The optimization conventions are defined an <em>App_Start/BundleConfig.cs</em> file.<br />
In ASP.NET Core, a more declarative approach is adopted. A file lists the files to be minified, along<br />
with specific minification settings.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification">For more information on bundling and minification, see Bundle and minify static assets in ASP.NET</a><br />
<a href="https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification">Core.</a></p>
<h3>Migrate ASPX pages</h3>
<p>A page in a Web Forms app is a file with the <em>.aspx</em> extension. A Web Forms page can often be mapped<br />
to a component in Blazor. A Razor component is authored in a file with the <em>.razor</em> extension. For the<br />
eShop project, five pages are converted to a Razor page.</p>
<p>For example, the details view comprises three files in the Web Forms project: <em>Details.aspx</em>,<br />
<em>Details.aspx.cs</em>, and <em>Details.aspx.designer.cs</em> . When converting to Blazor, the code-behind and markup<br />
are combined into <em>Details.razor</em> . Razor compilation (equivalent to what’s in <em>.designer.cs</em> files) is stored<br />
in the <em>obj</em> directory and isn’t, by default, viewable in <strong>Solution Explorer</strong> . The Web Forms page consists<br />
of the following markup:</p>
<p>84 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>85 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>The preceding markup’s code-behind includes the following code:</p>
<p>When converted to Blazor, the Web Forms page translates to the following code:</p>
<p>86 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>87 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>Notice that the code and markup are in the same file. Any required services are made accessible with<br />
the @inject attribute. Per the @page directive, this page can be accessed at the Catalog/Details/{id}<br />
route. The value of the route’s {id} placeholder has been constrained to an integer. As described in the<br />
routing section, unlike Web Forms, a Razor component explicitly states its route and any parameters<br />
that are included. Many Web Forms controls may not have exact counterparts in Blazor. There’s often<br />
an equivalent HTML snippet that will serve the same purpose. For example, the &lt;asp:Label /&gt; control<br />
can be replaced with an HTML <label> element.</p>
<h4><strong>Model validation in Blazor</strong></h4>
<p>If your Web Forms code includes validation, you can transfer much of what you have with little-to-no<br />
changes. A benefit to running in Blazor is that the same validation logic can be run without needing<br />
custom JavaScript. Data annotations enable easy model validation.</p>
<p>88 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>For example, the <em>Create.aspx</em> page has a data entry form with validation. An example snippet would<br />
look like this:</p>
<p>In Blazor, the equivalent markup is provided in a <em>Create.razor</em> file:</p>
<p>The EditForm context includes validation support and can be wrapped around an input. Data<br />
annotations are a common way to add validation. Such validation support can be added via the<br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/forms-validation">DataAnnotationsValidator component. For more information on this mechanism, see ASP.NET Core</a><br />
<a href="https://docs.microsoft.com/aspnet/core/blazor/forms-validation">Blazor forms and validation.</a></p>
<h3>Migrate configuration</h3>
<p>In a Web Forms project, configuration data is most commonly stored in the <em>web.config</em> file. The<br />
configuration data is accessed with ConfigurationManager. Services were often required to parse<br />
objects. With .NET Framework 4.7.2, composability was added to the configuration via<br />
ConfigurationBuilders. These builders allowed developers to add various sources for the configuration<br />
that was then composed at run time to retrieve the necessary values.</p>
<p>ASP.NET Core introduced a flexible configuration system that allows you to define the configuration<br />
source or sources used by your app and deployment. The ConfigurationBuilder infrastructure that you<br />
may be using in your Web Forms app was modeled after the concepts used in the ASP.NET Core<br />
configuration system.</p>
<p>The following snippet demonstrates how the Web Forms eShop project uses <em>web.config</em> to store<br />
configuration values:</p>
<p>89 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<p>It’s common for secrets, such as database connection strings, to be stored within the <em>web.config</em> . The<br />
secrets are inevitably persisted in unsecure locations, such as source control. With Blazor on ASP.NET<br />
Core, the preceding XML-based configuration is replaced with the following JSON:</p>
<p>JSON is the default configuration format; however, ASP.NET Core supports many other formats,<br />
including XML. There are also several community-supported formats.</p>
<p>You can access configuration values from the builder in <em>Program.cs</em> :</p>
<p>By default, environment variables, JSON files ( <em>appsettings.json</em> and <em>appsettings.{Environment}.json</em> ), and<br />
command-line options are registered as valid configuration sources in the configuration object. The<br />
configuration sources can be accessed via Configuration[key]. A more advanced technique is to bind<br />
the configuration data to objects using the options pattern. For more information on configuration<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/">and the options pattern, see Configuration in ASP.NET Core</a> <a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options">and Options pattern in ASP.NET Core,</a><br />
respectively.</p>
<p>90 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<h3>Migrate data access</h3>
<p>Data access is an important aspect of any app. The eShop project stores catalog information in a<br />
database and retrieves the data with Entity Framework (EF) 6. Since EF 6 is supported in .NET 5, the<br />
project can continue to use it.</p>
<p>The following EF-related changes were necessary to eShop:</p>
<ul>
<li>
<p>In .NET Framework, the DbContext object accepts a string of the form <em>name=ConnectionString</em><br />
and uses the connection string from ConfigurationManager.AppSettings[ConnectionString] to<br />
connect. In .NET Core, this isn’t supported. The connection string must be supplied.</p>
</li>
<li>
<p>The database was accessed in a synchronous way. Though this works, scalability may suffer.<br />
This logic should be moved to an asynchronous pattern.</p>
</li>
</ul>
<p>Although there isn’t the same native support for dataset binding, Blazor provides flexibility and power<br />
with its C# support in a Razor page. For example, you can perform calculations and display the result.<br />
For more information on data patterns in Blazor, see the Data access chapter.</p>
<h3>Architectural changes</h3>
<p>Finally, there are some important architectural differences to consider when migrating to Blazor. Many<br />
of these changes are applicable to anything based on .NET Core or ASP.NET Core.</p>
<p>Because Blazor is built on .NET Core, there are considerations in ensuring support on .NET Core. Some<br />
of the major changes include the removal of the following features:</p>
<ul>
<li>
<p>Multiple AppDomains</p>
</li>
<li>
<p>Remoting</p>
</li>
<li>
<p>Code Access Security (CAS)</p>
</li>
<li>
<p>Security Transparency</p>
</li>
</ul>
<p>For more information on techniques to identify necessary changes to support running on .NET Core,<br />
<a href="https://docs.microsoft.com/en-us/dotnet/core/porting/">see Port your code from .NET Framework to .NET Core.</a></p>
<p>ASP.NET Core is a reimagined version of ASP.NET and has some changes that may not initially seem<br />
obvious. The main changes are:</p>
<ul>
<li>
<p>No synchronization context, which means there’s no HttpContext.Current,<br />
Thread.CurrentPrincipal, or other static accessors</p>
</li>
<li>
<p>No shadow copying</p>
</li>
<li>
<p>No request queue</p>
</li>
</ul>
<p>Many operations in ASP.NET Core are asynchronous, which allows easier off-loading of I/O-bound<br />
tasks. It’s important to never block by using Task.Wait() or Task.GetResult(), which can quickly exhaust<br />
thread pool resources.</p>
<p>91 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
<h3>Migration conclusion</h3>
<p>At this point, you’ve seen many examples of what it takes to move a Web Forms project to Blazor. For<br />
<a href="https://github.com/dotnet-architecture/eShopOnBlazor">a full example, see the eShopOnBlazor project.</a></p>
<p>92 CHAPTER 14 | Migrate from ASP.NET Web Forms to Blazor</p>
