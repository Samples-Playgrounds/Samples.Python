{"Blazor for ASP.NET Web Forms Developers": {"Contents": "| An introduction to Blazor for ASP.NET Web Forms developers | 1  |\n|------------------------------------------------------------|----|\n| An open-source and cross-platform .NET                     | 2  |\n| Client-side web development                                | 3  |\n| WebAssembly fulfills a need                                | 3  |\n| Blazor: full-stack web development with .NET               | 4  |\n| Get started with Blazor                                    | 4  |\n| Architecture comparison of ASP.NET Web Forms and Blazor    | 5  |\n| ASP.NET Web Forms                                          | 5  |\n| Blazor                                                     | 6  |\n| Blazor app hosting models                                  | 8  |\n| Blazor WebAssembly apps                                    | 8  |\n| Blazor Server apps                                         | 9  |\n| How to choose the right Blazor hosting model               | 10 |\n| Deploy your app                                            | 11 |\n| Project structure for Blazor apps                          | 12 |\n| Project file                                               | 12 |\n| Entry point                                                | 13 |\n| Static files                                               | 15 |\n| Configuration                                              | 15 |\n| Razor components                                           | 15 |\n| Pages                                                      | 16 |\n| Layout                                                     | 16 |\n| Bootstrap Blazor                                           | 16 |\n| Build output                                               | 18 |\n| Run the app with Hot Reload                                | 18 |\n| App startup                                                | 21 |\n| Application_Start and Web Forms                            | 21 |\n| Blazor Server Startup Structure                            | 21 |\n\n| Upgrading the BundleConfig Process       |    |\n|------------------------------------------|----|\n| Build reusable UI components with Blazor | 24 |\n| An introduction to Razor                 | 24 |\n| Use components                           | 28 |\n| Modify page title from components        | 28 |\n| Component parameters                     | 29 |\n| Query string parameters                  | 29 |\n| Components and error boundaries          | 30 |\n| Event handlers                           | 30 |\n| Data binding                             | 32 |\n| State changes                            | 33 |\n| Component lifecycle                      | 34 |\n| OnInitialized                            | 34 |\n| On Parameters Set                        | 35 |\n| OnAfterRender                            | 35 |\n| IDisposable                              | 35 |\n| Capture component references             | 36 |\n| Capture element references               | 36 |\n| Templated components                     | 36 |\n| Child content                            | 37 |\n| Template parameters                      | 37 |\n| Code-behind                              |    |\n| Additional resources                     | 39 |\n| Pages, routing, and layouts              | 40 |\n| Create pages                             | 41 |\n| Router component                         | 42 |\n| Navigation                               | 42 |\n| Base URLs                                | 43 |\n| Page layout                              | 43 |\n| State management                         | 46 |\n| Request state management with ViewState  | 46 |\n\n| Maintain state with Session                                                | 47 |\n|----------------------------------------------------------------------------|----|\n| Application state                                                          | 47 |\n| In the browser                                                             | 48 |\n| Forms and validation                                                       | 49 |\n| Additional resources                                                       | 51 |\n| Work with data                                                             | 52 |\n| Entity Framework                                                           | 52 |\n| EF Code First                                                              | 53 |\n| EF Database First                                                          | 54 |\n| Interact with web services                                                 | 54 |\n| Modules, handlers, and middleware                                          | 56 |\n| Overview                                                                   | 56 |\n| Katana                                                                     | 57 |\n| Common middleware                                                          | 57 |\n| Custom middleware                                                          | 58 |\n| App configuration                                                          | 60 |\n| Configuration sources                                                      | 60 |\n| appsettings.json format and access                                         | 61 |\n| User secrets                                                               | 61 |\n| Environment variables                                                      | 61 |\n| Command-line arguments                                                     | 62 |\n| The return of web.config                                                   | 62 |\n| Read configuration in the app                                              | 63 |\n| Strongly typed configuration                                               | 63 |\n| Security: Authentication and Authorization in ASP.NET Web Forms and Blazor | 65 |\n| ASP.NET universal providers                                                | 65 |\n| Authorization configuration in Web Forms                                   | 66 |\n| Authorization code in Web Forms                                            | 67 |\n| ASP.NET Core Identity                                                      | 68 |\n| Roles, claims, and policies                                                | 68 |\n| Migration guide                                                            | 70 |\n\n| Creating the ASP.NET Core Identity schema                           | 70 |\n|---------------------------------------------------------------------|----|\n| Migrating data from universal providers to ASP.NET Core Identity    | 73 |\n| Migrating security settings from web.config to app startup          | 74 |\n| Updating individual pages to use ASP.NET Core Identity abstractions | 75 |\n| Summary                                                             | 76 |\n| References                                                          | 77 |\n| Migrate from ASP.NET Web Forms to Blazor                            | 78 |\n| Server-side versus client-side hosting                              | 78 |\n| Create a new project                                                | 79 |\n| Enable startup process                                              | 80 |\n| Migrate HTTP modules and handlers to middleware                     | 83 |\n| Migrate static files                                                | 84 |\n| Migrate runtime bundling and minification setup                     | 84 |\n| Migrate ASPX pages                                                  | 84 |\n| Model validation in Blazor                                          | 88 |\n| Migrate configuration                                               | 89 |\n| Migrate data access                                                 | 91 |\n| Architectural changes                                               | 91 |\n| Migration conclusion                                                | 92 |\n\n**CHAPTER** 1"}, "<span id=\"page-8-0\"></span>An introduction to Blazor for ASP.NET Web Forms developers": {"<span id=\"page-9-0\"></span>An open-source and cross-platform .NET": "When .NET and ASP.NET Web Forms first shipped, the platform ecosystem looked much different than it does today. The desktop and server markets were dominated by Windows. Alternative platforms like macOS and Linux were still struggling to gain traction. ASP.NET Web Forms ships with the .NET Framework as a Windows-only component, which means ASP.NET Web Forms apps can only run on Windows Server machines. Many modern environments now use different kinds of platforms for servers and development machines such that cross-platform support for many users is an absolute requirement.\n\nMost modern web frameworks are now also open-source, which has a number of benefits. Users aren't beheld to a single project owner to fix bugs and add features. Open-source projects provide improved transparency on development progress and upcoming changes. Open-source projects enjoy contributions from an entire community, and they foster a supportive open-source ecosystem. Despite the risks of open-source, many consumers and contributors have found suitable mitigations that enable them to enjoy the benefits of an open-source ecosystem in a safe and reasonable way. Examples of such mitigations include contributor license agreements, friendly licenses, pedigree scans, and supporting foundations.\n\nThe .NET community has embraced both cross-platform support and open-source. .NET Core is an open-source and cross-platform implementation of .NET that runs on a plethora of platforms, including Windows, macOS, and various Linux distributions. Xamarin provides Mono, an open-source version of .NET. Mono runs on Android, iOS, and a variety of other form factors, including watches and smart TVs. In 2020, Microsoft released [.NET 5](https://devblogs.microsoft.com/dotnet/announcing-net-5-0/) that reconciled .NET Core and Mono into \"a single .NET runtime and framework that can be used everywhere and that has uniform runtime behaviors and developer experiences.\"\n\nWill ASP.NET Web Forms benefit from the move to open-source and cross-platform support? The answer, unfortunately, is no, or at least not to the same extent as the rest of the platform. The .NET team [made it clear](https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/) that ASP.NET Web Forms won't be ported to .NET Core or .NET 8. Why is that?\n\nThere were efforts in the early days of .NET Core to port ASP.NET Web Forms. The number of breaking changes required were found to be too drastic. There's also an admission here that even for Microsoft, there's a limit to the number of web frameworks that it can support simultaneously. Perhaps someone in the community will take up the cause of creating an open-source and cross-platform version of ASP.NET Web Forms. The [source code for ASP.NET Web Forms](https://github.com/microsoft/referencesource) has been made available publicly in reference form. But for the time being, it seems ASP.NET Web Forms will remain Windows-only and without an open-source contribution model. If cross-platform support or open-source become important for your scenarios, then you'll need to look for something new.\n\nDoes this mean ASP.NET Web Forms is *dead* and should no longer be used? Of course not! As long as the .NET Framework ships as part of Windows, ASP.NET Web Forms will be a supported framework. For many Web Forms developers, the lack of cross-platform and open-source support is a non-issue. If you don't have a requirement for cross-platform support, open-source, or any of the other new features in .NET Core or .NET 8, then sticking with ASP.NET Web Forms on Windows is fine. ASP.NET Web Forms will continue to be a productive way to write web apps for many years to come.\n\nBut there's another trend worth considering, and that's the shift to the client.", "<span id=\"page-10-0\"></span>Client-side web development": "All of the .NET-based web frameworks, including ASP.NET Web Forms, have historically had one thing in common: they're *server-rendered*. In server-rendered web apps, the browser makes a request to the server, which executes some code (.NET code in ASP.NET apps) to produce a response. That response is sent back to the browser to handle. In this model, the browser is used as a thin rendering engine. The hard work of producing the UI, running the business logic, and managing state occurs on the server.\n\nHowever, browsers have become versatile platforms. They implement an ever-increasing number of open web standards that grant access to the capabilities of the user's machine. Why not take advantage of the compute power, storage, memory, and other resources of the client device? UI interactions in particular can benefit from a richer and more interactive feel when handled at least partially or completely client-side. Logic and data that should be handled on the server can still be handled server-side. Web API calls or even real-time protocols, like WebSockets, can be used. These benefits are available to web developers for free if they're willing to write JavaScript. Client-side UI frameworks, such as Angular, React, and Vue, simplify client-side web development and have grown in popularity. ASP.NET Web Forms developers can also benefit from leveraging the client, and even have some out-of-the-box support with integrated JavaScript frameworks like ASP.NET AJAX.\n\nBut bridging two different platforms and ecosystems (.NET and JavaScript) comes with a cost. Expertise is required in two parallel worlds with different languages, frameworks, and tools. Code and logic can't be easily shared between client and server, resulting in duplication and engineering overhead. It can also be difficult to keep up with the JavaScript ecosystem, which has a history of evolving at breakneck speed. Front-end framework and build tool preferences change quickly. The industry has observed the progression from Grunt to Gulp to Webpack, and so on. The same restless churn has occurred with front-end frameworks such as jQuery, Knockout, Angular, React, and Vue. But given JavaScript's browser monopoly, there was little choice in the matter. That is, until the web community got together and caused a *miracle* to happen!\n\n<span id=\"page-10-1\"></span>WebAssembly fulfills a need\n\nIn 2015, the major browser vendors joined forces in a W3C Community Group to create a new open web standard called WebAssembly. WebAssembly is a byte code for the Web. If you can compile your code to WebAssembly, it can then run on any browser on any platform at near native speed. Initial efforts focused on C/C++. The result was a dramatic demonstration of running native 3D graphics engines directly in the browser without plugins. WebAssembly has since been standardized and implemented by all major browsers.\n\nWork on running .NET on WebAssembly was announced in late 2017 and released in 2020, including support in .NET 5 and beyond. The ability to run .NET code directly in the browser enables full-stack web development with .NET.", "<span id=\"page-11-0\"></span>Blazor: full-stack web development with .NET": "On its own, the ability to run .NET code in a browser doesn't provide an end-to-end experience for creating client-side web apps. That's where Blazor comes in. Blazor is a client-side web UI framework based on C# instead of JavaScript. Blazor can run directly in the browser via WebAssembly. No browser plugins are required. Alternatively, Blazor apps can run server-side on .NET and handle all user interactions over a real-time connection with the browser.\n\nBlazor has great tooling support in Visual Studio and Visual Studio Code. The framework also includes a full UI component model and has built-in facilities for:\n\n['Forms and validation', 'Dependency injection', 'Client-side routing', 'Layouts', 'In-browser debugging', 'JavaScript interop']\n\nBlazor has a lot in common with ASP.NET Web Forms. Both frameworks offer component-based, event-driven, stateful UI programming models. The main architectural difference is that ASP.NET Web Forms runs only on the server. Blazor can run on the client in the browser. But if you're coming from an ASP.NET Web Forms background, there's a lot in Blazor that will feel familiar. Blazor is a natural solution for ASP.NET Web Forms developers looking for a way to take advantage of client-side development and the open-source, cross-platform future of .NET.\n\nThis book provides an introduction to Blazor that is catered specifically to ASP.NET Web Forms developers. Each Blazor concept is presented in the context of analogous ASP.NET Web Forms features and practices. By the end of this book, you'll have an understanding of:\n\n['How to build Blazor apps.', 'How Blazor works.', 'How Blazor relates to .NET.', 'Reasonable strategies for migrating existing ASP.NET Web Forms apps to Blazor where appropriate.']\n\n<span id=\"page-11-1\"></span>Get started with Blazor\n\nGetting started with Blazor is easy. Go to [https://blazor.net](https://blazor.net/) and follow the links to install the appropriate .NET SDK and Blazor project templates. You'll also find instructions for setting up the Blazor tooling in Visual Studio or Visual Studio Code."}, "<span id=\"page-12-0\"></span>Architecture comparison of ASP.NET Web Forms and Blazor": {"<span id=\"page-15-0\"></span>Blazor app hosting models": "Blazor apps can be hosted in one of the following ways:\n\n['Client-side in the browser on WebAssembly.', '<span id=\"page-15-1\"></span>\u2022 Server-side in an ASP.NET Core app.']", "Blazor WebAssembly apps": "Blazor WebAssembly apps execute directly in the browser on a WebAssembly-based .NET runtime. Blazor WebAssembly apps function in a similar way to front-end JavaScript frameworks like Angular or React. However, instead of writing JavaScript you write C#. The .NET runtime is downloaded with the app along with the app assembly and any required dependencies. No browser plugins or extensions are required.\n\nThe downloaded assemblies are normal .NET assemblies, like you would use in any other .NET app. Because the runtime supports .NET Standard, you can use existing .NET Standard libraries with your Blazor WebAssembly app. However, these assemblies will still execute in the browser security sandbox. Some functionality may throw a [PlatformNotSupportedException,](https://docs.microsoft.com/dotnet/api/system.platformnotsupportedexception) like trying to access the file system or opening arbitrary network connections.\n\nWhen the app loads, the .NET runtime is started and pointed at the app assembly. The app startup logic runs, and the root components are rendered. Blazor calculates the UI updates based on the rendered output from the components. The DOM updates are then applied.\n\n![](_page_16_Picture_0.jpeg)\n\nBlazor WebAssembly apps run purely client-side. Such apps can be deployed to static site hosting solutions like GitHub Pages or Azure Static Website Hosting. .NET isn't required on the server at all. Deep linking to parts of the app typically requires a routing solution on the server. The routing solution redirects requests to the root of the app. For example, this redirection can be handled using URL rewrite rules in IIS.\n\nTo get all the benefits of Blazor and full-stack .NET web development, host your Blazor WebAssembly app with ASP.NET Core. By using .NET on both the client and server, you can easily share code and build your app using one consistent set of languages, frameworks, and tools. Blazor provides convenient templates for setting up a solution that contains both a Blazor WebAssembly app and an ASP.NET Core host project. When the solution is built, the built static files from the Blazor app are hosted by the ASP.NET Core app with fallback routing already setup.", "<span id=\"page-16-0\"></span>Blazor Server apps": {"<span id=\"page-17-0\"></span>How to choose the right Blazor hosting model": "As described in the [Blazor hosting model docs,](https://docs.microsoft.com/aspnet/core/blazor/hosting-models) the different Blazor hosting models have different tradeoffs.\n\nThe Blazor WebAssembly hosting model has the following benefits:\n\n[\"There's no .NET server-side dependency. The app is fully functioning after downloaded to the client.\", 'Client resources and capabilities are fully leveraged.', 'Work is offloaded from the server to the client.', \"An ASP.NET Core web server isn't required to host the app. Serverless deployment scenarios are possible (for example, serving the app from a CDN).\"]\n\nThe downsides of the Blazor WebAssembly hosting model are:\n\n['Browser capabilities restrict the app.', 'Capable client hardware and software (for example, WebAssembly support) is required.', 'Download size is larger, and apps take longer to load.']\n\n\u2022 .NET runtime and tooling support is less mature. For example, there are limitations in [.NET](https://docs.microsoft.com/en-us/dotnet/standard/net-standard)  [Standard](https://docs.microsoft.com/en-us/dotnet/standard/net-standard) support and debugging.\n\nConversely, the Blazor Server hosting model offers the following benefits:\n\n['Download size is much smaller than a client-side app, and the app loads much faster.', 'The app takes full advantage of server capabilities, including use of any .NET compatible APIs.', '.NET on the server is used to run the app, so existing .NET tooling, such as debugging, works as expected.', \"Thin clients are supported. For example, server-side apps work with browsers that don't support WebAssembly and on resource-constrained devices.\", \"The app's .NET/C# code base, including the app's component code, isn't served to clients.\"]\n\nThe downsides to the Blazor Server hosting model are:\n\n['Higher UI latency. Every user interaction involves a network hop.', \"There's no offline support. If the client connection fails, the app stops working.\", 'Scalability is challenging for apps with many users. The server must manage multiple client connections and handle client state.', \"An ASP.NET Core server is required to serve the app. Serverless deployment scenarios aren't possible. For example, you can't serve the app from a CDN.\"]\n\nThe preceding list of trade-offs may be intimidating, but your hosting model can be changed later. Regardless of the Blazor hosting model selected, the component model is *the same*. In principle, the same components can be used with either hosting model. Your app code doesn't change; however, it's a good practice to introduce abstractions so that your components stay hosting model-agnostic. The abstractions allow your app to more easily adopt a different hosting model."}, "<span id=\"page-18-0\"></span>Deploy your app": "ASP.NET Web Forms apps are typically hosted on IIS on a Windows Server machine or cluster. Blazor apps can also:\n\n['Be hosted on IIS, either as static files or as an ASP.NET Core app.', \"Leverage ASP.NET Core's flexibility to be hosted on various platforms and server infrastructures. For example, you can host a Blazor App using [Nginx](https://docs.microsoft.com/aspnet/core/host-and-deploy/linux-nginx) or [Apache](https://docs.microsoft.com/aspnet/core/host-and-deploy/linux-apache) on Linux. For more information about how to publish and deploy Blazor apps, see the Blazor [Hosting and](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/)  [deployment](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/) documentation.\"]\n\nIn the next section, we'll look at how the projects for Blazor WebAssembly and Blazor Server apps are set up."}, "<span id=\"page-19-0\"></span>Project structure for Blazor apps": {"<span id=\"page-20-0\"></span>Entry point": "The Blazor Server app's entry point is defined in the *Program.cs* file, as you would see in a Console app. When the app executes, it creates and runs a web host instance using defaults specific to web apps. The web host manages the Blazor Server app's lifecycle and sets up host-level services. Examples of such services are configuration, logging, dependency injection, and the HTTP server. This code is mostly boilerplate and is often left unchanged.\n\n```\nusing BlazorApp3.Areas.Identity;\nusing BlazorApp3.Data;\nusing Microsoft.AspNetCore.Components.Authorization;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.EntityFrameworkCore;\nvar builder = WebApplication.CreateBuilder(args);\n// Add services to the container.\nvar connectionString = builder.Configuration.GetConnectionString(\"DefaultConnection\");\nbuilder.Services.AddDbContext<ApplicationDbContext>(options =>\n options.UseSqlServer(connectionString));\nbuilder.Services.AddDatabaseDeveloperPageExceptionFilter();\nbuilder.Services.AddDefaultIdentity<IdentityUser>(options =>\noptions.SignIn.RequireConfirmedAccount = true)\n .AddEntityFrameworkStores<ApplicationDbContext>();\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddServerSideBlazor();\nbuilder.Services.AddScoped<AuthenticationStateProvider,\nRevalidatingIdentityAuthenticationStateProvider<IdentityUser>>();\nbuilder.Services.AddSingleton<WeatherForecastService>();\nvar app = builder.Build();\n// Configure the HTTP request pipeline.\n```\n\n```\nif (app.Environment.IsDevelopment())\n{\n app.UseMigrationsEndPoint();\n}\nelse\n{\n app.UseExceptionHandler(\"/Error\");\n // The default HSTS value is 30 days. You may want to change this for production \nscenarios, see https://aka.ms/aspnetcore-hsts.\n app.UseHsts();\n}\napp.UseHttpsRedirection();\napp.UseStaticFiles();\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\napp.MapBlazorHub();\napp.MapFallbackToPage(\"/_Host\");\napp.Run();\n```\n\nBlazor WebAssembly apps also define an entry point in *Program.cs*. The code looks slightly different. The code is similar in that it's setting up the app host to provide the same host-level services to the app. The WebAssembly app host doesn't, however, set up an HTTP server because it executes directly in the browser.\n\nBlazor apps don't use a *Global.asax* file to define the startup logic for the app. Instead, this logic is contained in *Program.cs* or in a related Startup class that is referenced from *Program.cs*. Either way, this code is used to configure the app and any app-specific services.\n\nIn a Blazor Server app, the *Program.cs* file shown is used to set up the endpoint for the real-time connection used by Blazor between the client browsers and the server.\n\nIn a Blazor WebAssembly app, the *Program.cs* file defines the root components for the app and where they should be rendered:\n\n```\nusing BlazorApp1;\nusing Microsoft.AspNetCore.Components.Web;\nusing Microsoft.AspNetCore.Components.WebAssembly.Hosting;\nvar builder = WebAssemblyHostBuilder.CreateDefault(args);\nbuilder.RootComponents.Add<App>(\"#app\");\nbuilder.RootComponents.Add<HeadOutlet>(\"head::after\");\nbuilder.Services.AddScoped(sp => new HttpClient { BaseAddress = new\nUri(builder.HostEnvironment.BaseAddress) });\nawait builder.Build().RunAsync();\n```\n\n<span id=\"page-22-0\"></span>Static files\n\nUnlike ASP.NET Web Forms projects, not all files in a Blazor project can be requested as static files. Only the files in the *wwwroot* folder are web-addressable. This folder is referred to as the app's \"web root\". Anything outside of the app's web root *isn't* web-addressable. This setup provides an additional level of security that prevents accidental exposure of project files over the web.\n\n<span id=\"page-22-1\"></span>Configuration\n\nConfiguration in ASP.NET Web Forms apps is typically handled using one or more *web.config* files. Blazor apps don't typically have *web.config* files. If they do, the file is only used to configure IISspecific settings when hosted on IIS. Instead, Blazor Server apps use the ASP.NET Core configuration abstractions. (Blazor WebAssembly apps don't currently support the same configuration abstractions, but that may be a feature added in the future.) For example, the default Blazor Server app stores some settings in *appsettings.json*.\n\n```\n{\n \"Logging\": {\n \"LogLevel\": {\n \"Default\": \"Information\",\n \"Microsoft\": \"Warning\",\n \"Microsoft.Hosting.Lifetime\": \"Information\"\n }\n },\n \"AllowedHosts\": \"*\"\n}\n```\n\nYou'll learn more about configuration in ASP.NET Core projects in the [Configuration](#page-67-0) section.\n\n<span id=\"page-22-2\"></span>Razor components\n\nMost files in Blazor projects are *.razor* files. Razor is a templating language based on HTML and C# that is used to dynamically generate web UI. The *.razor* files define components that make up the UI of the app. For the most part, the components are identical for both the Blazor Server and Blazor WebAssembly apps. Components in Blazor are analogous to user controls in ASP.NET Web Forms.\n\nEach Razor component file is compiled into a .NET class when the project is built. The generated class captures the component's state, rendering logic, lifecycle methods, event handlers, and other logic. You'll learn more about authoring components in the [Building reusable UI components with Blazor](#page-31-0) section.\n\nThe \\*\\_Imports.razor\\* files aren't Razor component files. Instead, they define a set of Razor directives to import into other *.razor* files within the same folder and in its subfolders. For example, a\n\n\\*\\_Imports.razor\\* file is a conventional way to add using directives for commonly used namespaces:\n\n```\n@using System.Net.Http\n@using System.Net.Http.Json\n@using Microsoft.AspNetCore.Components.Forms\n@using Microsoft.AspNetCore.Components.Routing\n```\n\n```\n@using Microsoft.AspNetCore.Components.Web\n@using Microsoft.AspNetCore.Components.Web.Virtualization\n@using Microsoft.AspNetCore.Components.WebAssembly.Http\n@using Microsoft.JSInterop\n@using BlazorApp1\n@using BlazorApp1.Shared\n```", "<span id=\"page-23-0\"></span>Pages": {"<span id=\"page-25-0\"></span>Build output": {"<span id=\"page-25-1\"></span>Run the app with Hot Reload": "To run the Blazor Server app, press F5 in Visual Studio to run with the debugger attached, or Ctrl + F5 to run without the debugger attached.\n\nTo run the Blazor WebAssembly app, choose one of the following approaches:\n\n\u2022 Run the client project directly using the development server.\n\n\u2022 Run the server project when hosting the app with ASP.NET Core.\n\nBlazor WebAssembly apps can be debugged in both browser and Visual Studio. See [Debug ASP.NET](https://docs.microsoft.com/aspnet/core/blazor/debug)  [Core Blazor WebAssembly](https://docs.microsoft.com/aspnet/core/blazor/debug) for details.\n\nBoth Blazor Server and Blazor WebAssembly apps support Hot Reload in Visual Studio. Hot Reload is a feature that automatically updates changes made to a Blazor app live, in the browser. You can toggle whether Hot Reload is enabled from its icon in the toolbar:\n\n![](_page_26_Figure_3.jpeg)\n\nSelecting the caret beside the icon reveals additional options. You can toggle Hot Reload on or off, restart the application, and toggle whether Hot Reload should occur whenever a file is saved.\n\n![](_page_26_Picture_5.jpeg)\n\nYou can also access additional configuration options. The configuration dialog lets you specify whether Hot Reload should be enabled when debugging (along with Edit and Continue), when starting without debugging, or when a file is saved.\n\n![](_page_27_Figure_0.jpeg)\n\nThe \"developer inner loop\" has been greatly streamlined with Hot Reload. Without Hot Reload, a Blazor developer would typically need to restart and rerun the app after every change, navigating to the appropriate part of the app as required. With Hot Reload, changes can be made to the running app without the need to restart in most cases. Hot Reload even retains the state of pages, so there's no need to have to re-enter form values or otherwise get the app back where you need it."}}, "<span id=\"page-28-0\"></span>App startup": "Applications that are written for ASP.NET typically have a global.asax.cs file that defines the Application\\_Start event that controls which services are configured and made available for both HTML rendering and .NET processing. This chapter looks at how things are slightly different with ASP.NET Core and Blazor Server.\n\n<span id=\"page-28-1\"></span>Application\\_Start and Web Forms\n\nThe default web forms Application\\_Start method has grown in purpose over years to handle many configuration tasks. A fresh web forms project with the default template in Visual Studio 2022 now contains the following configuration logic:\n\n['RouteConfig Application URL routing', 'BundleConfig CSS and JavaScript bundling and minification']\n\nEach of these individual files resides in the App\\_Start folder and run only once at the start of our application. RouteConfig in the default project template adds the FriendlyUrlSettings for web forms to allow application URLs to omit the .ASPX file extension. The default template also contains a directive that provides permanent HTTP redirect status codes (HTTP 301) for the .ASPX pages to the friendly URL with the file name that omits the extension.\n\nWith ASP.NET Core and Blazor, these methods are either simplified and consolidated into the Startup class or they are eliminated in favor of common web technologies.\n\n<span id=\"page-28-2\"></span>Blazor Server Startup Structure\n\nBlazor Server applications reside on top of an ASP.NET Core 3.0 or later version. ASP.NET Core web applications are configured in *Program.cs*, or through a pair of methods in the Startup.cs class. A sample *Program.cs* file is shown below:\n\n```\nusing BlazorApp1.Data;\nusing Microsoft.AspNetCore.Components;\nusing Microsoft.AspNetCore.Components.Web;\nvar builder = WebApplication.CreateBuilder(args);\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddServerSideBlazor();\nbuilder.Services.AddSingleton<WeatherForecastService>();\n```\n\n```\nvar app = builder.Build();\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n app.UseExceptionHandler(\"/Error\");\n // The default HSTS value is 30 days. You may want to change this for production \nscenarios, see https://aka.ms/aspnetcore-hsts.\n app.UseHsts();\n}\napp.UseHttpsRedirection();\napp.UseStaticFiles();\napp.UseRouting();\napp.MapBlazorHub();\napp.MapFallbackToPage(\"/_Host\");\napp.Run();\n```\n\nThe app's required services are added to the WebApplicationBuilder instance's Services collection. This is how the various ASP.NET Core framework services are configured with the framework's built-in dependency injection container. The various builder.Services.Add\\* methods add services that enable features such as authentication, razor pages, MVC controller routing, SignalR, and Blazor Server interactions among many others. This method was not needed in web forms, as the parsing and handling of the ASPX, ASCX, ASHX, and ASMX files were defined by referencing ASP.NET in the web.config configuration file. More information about dependency injection in ASP.NET Core is available in the [online documentation.](https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection)\n\nAfter the app has been built by the builder, the rest of the calls on app configure its HTTP pipeline. With these calls, we declare from top to bottom the Middleware that will handle every request sent to our application. Most of these features in the default configuration were scattered across the web forms configuration files and are now in one place for ease of reference.\n\nNo longer is the configuration of the custom error page placed in a web.config file, but now is configured to always be shown if the application environment is not labeled Development. Additionally, ASP.NET Core applications are now configured to serve secure pages with TLS by default with the UseHttpsRedirection method call.\n\nNext, an unexpected configuration method call is made to UseStaticFiles. In ASP.NET Core, support for requests for static files (like JavaScript, CSS, and image files) must be explicitly enabled, and only files in the app's *wwwroot* folder are publicly addressable by default.\n\nThe next line is the first that replicates one of the configuration options from web forms: UseRouting. This method adds the ASP.NET Core router to the pipeline and it can be either configured here or in the individual files that it can consider routing to. More information about routing configuration can be found in the Routing section.\n\nThe final app.Map\\* calls in this section define the endpoints that ASP.NET Core is listening on. These routes are the web accessible locations that you can access on the web server and receive some content handled by .NET and returned to you. The first entry, MapBlazorHub configures a SignalR hub for use in providing the real-time and persistent connection to the server where the state and rendering of Blazor components is handled. The MapFallbackToPage method call indicates the webaccessible location of the page that starts the Blazor application and also configures the application to handle deep-linking requests from the client-side. You will see this feature at work if you open a browser and navigate directly to Blazor handled route in your application, such as /counter in the default project template. The request gets handled by the \\*\\_Host.cshtml\\* fallback page, which then runs the Blazor router and renders the counter page.\n\nThe very last line starts the application, something that wasn't required in web forms (since it relied on IIS to be running).\n\n<span id=\"page-30-0\"></span>Upgrading the BundleConfig Process\n\nTechnologies for bundling assets like CSS stylesheets and JavaScript files have changed significantly, with other technologies providing quickly evolving tools and techniques for managing these resources. To this end, we recommend using a Node command-line tool such as Grunt / Gulp / WebPack to package your static assets.\n\nThe Grunt, Gulp, and WebPack command-line tools and their associated configurations can be added to your application and ASP.NET Core will quietly ignore those files during the application build process. You can add a call to run their tasks by adding a Target inside your project file with syntax similar to the following that would trigger a gulp script and the min target inside that script:\n\n```\n<Target Name=\"MyPreCompileTarget\" BeforeTargets=\"Build\">\n <Exec Command=\"gulp min\" />\n</Target>\n```\n\nMore details about both strategies to manage your CSS and JavaScript files are available in the [Bundle](https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification)  [and minify static assets in ASP.NET Core](https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification) documentation."}, "<span id=\"page-31-0\"></span>Build reusable UI components with Blazor": {"Use components": "Aside from normal HTML, components can also use other components as part of their rendering logic. The syntax for using a component in Razor is similar to using a user control in an ASP.NET Web Forms app. Components are specified using an element tag that matches the type name of the component. For example, you can add a Counter component like this:\n\n```\n<Counter />\n```\n\nUnlike ASP.NET Web Forms, components in Blazor:\n\n[\"Don't use an element prefix (for example, asp:).\", \"Don't require registration on the page or in the *web.config*.\"]\n\nThink of Razor components like you would .NET types, because that's exactly what they are. If the assembly containing the component is referenced, then the component is available for use. To bring the component's namespace into scope, apply the @using directive:\n\n```\n@using MyComponentLib\n<Counter />\n```\n\nAs seen in the default Blazor projects, it's common to put @using directives into a \\*\\_Imports.razor\\* file so that they're imported into all *.razor* files in the same directory and in child directories.\n\nIf the namespace for a component isn't in scope, you can specify a component using its full type name, as you can in C#:\n\n<MyComponentLib.Counter />", "<span id=\"page-35-1\"></span>Modify page title from components": {"<span id=\"page-36-0\"></span>Component parameters": {"<span id=\"page-36-1\"></span>**Query string parameters**": "Razor components can also leverage values from the query string of the page they're rendered on as a parameter source. To enable this, add the [SupplyParameterFromQuery] attribute to the parameter. For example, the following parameter definition would get its value from the request in the form ?IncBy=2:\n\n```\n[Parameter]\n[SupplyParameterFromQuery(Name = \"IncBy\")]\npublic int IncrementAmount { get; set; } = 1;\n```\n\nIf you don't supply a custom Name in the [SupplyParameterFromQuery] attribute, by default it will match the property name (IncrementAmount in this case).", "<span id=\"page-37-0\"></span>Components and error boundaries": "By default, Blazor apps will detect unhandled exceptions and show an error message at the bottom of the page with no additional detail. To constrain the parts of the app that are impacted by an unhandled error, for instance to limit the impact to a single component, the <ErrorBoundary> tag can be wrapped around component declarations.\n\nFor example, to protect against possible exceptions thrown from the Counter component, declare it within an <ErrorBoundary> and optionally specify a message to display if there is an exception:\n\n```\n<ErrorBoundary>\n <ChildContent>\n <Counter />\n </ChildContent>\n <ErrorContent>\n Oops! The counter isn't working right now; please try again later.\n </ErrorContent>\n</ErrorBoundary>\nIf you don't need to specify custom error content, you can just wrap the component \ndirectly:\n<ErrorBoundary>\n <Counter />\n</ErrorBoundary>\n```\n\nA default message stating \"An error as occurred.\" will be displayed if an unhandled exception occurs in the wrapped component."}, "<span id=\"page-37-1\"></span>Event handlers": {"*Counter.ascx*": "```\n<asp:Button ID=\"ClickMeButton\" runat=\"server\" Text=\"Click me!\" \nOnClick=\"ClickMeButton_Click\" />\nCounter.ascx.cs\npublic partial class Counter : System.Web.UI.UserControl\n{\n protected void ClickMeButton_Click(object sender, EventArgs e)\n {\n Console.WriteLine(\"The button was clicked!\");\n }\n}\n```\n\nIn Blazor, you can register handlers for DOM UI events directly using directive attributes of the form @on{event}. The {event} placeholder represents the name of the event. For example, you can listen for button clicks like this:\n\n```\n<button @onclick=\"OnClick\">Click me!</button>\n@code {\n void OnClick()\n {\n Console.WriteLine(\"The button was clicked!\");\n }\n}\n```\n\nEvent handlers can accept an optional, event-specific argument to provide more information about the event. For example, mouse events can take a MouseEventArgs argument, but it isn't required.\n\n```\n<button @onclick=\"OnClick\">Click me!</button>\n@code {\n void OnClick(MouseEventArgs e)\n {\n Console.WriteLine($\"Mouse clicked at {e.ScreenX}, {e.ScreenY}.\");\n }\n}\n```\n\nInstead of referring to a method group for an event handler, you can use a lambda expression. A lambda expression allows you to close over other in-scope values.\n\n```\n@foreach (var buttonLabel in buttonLabels)\n{\n <button @onclick=\"() => Console.WriteLine($\"The {buttonLabel} button was \nclicked!\")\">@buttonLabel</button>\n}\n```\n\nEvent handlers can execute synchronously or asynchronously. For example, the following OnClick event handler executes asynchronously:\n\n```\n<button @onclick=\"OnClick\">Click me!</button>\n@code {\n async Task OnClick()\n {\n var result = await Http.GetAsync(\"api/values\");\n }\n}\n```\n\nAfter an event is handled, the component is rendered to account for any component state changes. With asynchronous event handlers, the component is rendered immediately after the handler execution completes. The component is rendered *again* after the asynchronous Task completes. This asynchronous execution mode provides an opportunity to render some appropriate UI while the asynchronous Task is still in progress.\n\n```\n<button @onclick=\"ShowMessage\">Get message</button>\n@if (showMessage)\n{\n @if (message == null)\n {\n <p><em>Loading...</em></p>\n }\n else\n```\n\n```\n {\n <p>The message is: @message</p>\n }\n}\n@code\n{\n bool showMessage = false;\n string message;\n public async Task ShowMessage()\n {\n showMessage = true;\n message = await MessageService.GetMessageAsync();\n }\n}\n```\n\nComponents can also define their own events by defining a component parameter of type EventCallback<TValue>. Event callbacks support all the variations of DOM UI event handlers: optional arguments, synchronous or asynchronous, method groups, or lambda expressions.\n\n```\n<button class=\"btn btn-primary\" @onclick=\"OnClick\">Click me!</button>\n@code {\n [Parameter]\n public EventCallback<MouseEventArgs> OnClick { get; set; }\n}\n```"}, "<span id=\"page-39-0\"></span>Data binding": "Blazor provides a simple mechanism to bind data from a UI component to the component's state. This approach differs from the features in ASP.NET Web Forms for binding data from data sources to UI controls. We'll cover handling data from different data sources in the [Dealing with data](#page-59-0) section.\n\nTo create a two-way data binding from a UI component to the component's state, use the @bind directive attribute. In the following example, the value of the check box is bound to the isChecked field.\n\n```\n<input type=\"checkbox\" @bind=\"isChecked\" />\n@code {\n bool isChecked;\n}\n```\n\nWhen the component is rendered, the value of the checkbox is set to the value of the isChecked field. When the user toggles the checkbox, the onchange event is fired and the isChecked field is set to the new value. The @bind syntax in this case is equivalent to the following markup:\n\n```\n<input value=\"@isChecked\" @onchange=\"(UIChangeEventArgs e) => isChecked = e.Value\" />\n```\n\nTo change the event used for the bind, use the @bind:event attribute.\n\n```\n<input @bind=\"text\" @bind:event=\"oninput\" />\n<p>@text</p>\n```\n\n```\n@code {\n string text;\n}\n```\n\nComponents can also support data binding to their parameters. To data bind, define an event callback parameter with the same name as the bindable parameter. The \"Changed\" suffix is added to the name.\n\n*PasswordBox.razor*\n\n```\nPassword: <input\n value=\"@Password\"\n @oninput=\"OnPasswordChanged\"\n type=\"@(showPassword ? \"text\" : \"password\")\" />\n<label><input type=\"checkbox\" @bind=\"showPassword\" />Show password</label>\n@code {\n private bool showPassword;\n [Parameter]\n public string Password { get; set; }\n [Parameter]\n public EventCallback<string> PasswordChanged { get; set; }\n private Task OnPasswordChanged(ChangeEventArgs e)\n {\n Password = e.Value.ToString();\n return PasswordChanged.InvokeAsync(Password);\n }\n}\n```\n\nTo chain a data binding to an underlying UI element, set the value and handle the event directly on the UI element instead of using the @bind attribute.\n\nTo bind to a component parameter, use a @bind-{Parameter} attribute to specify the parameter to which you want to bind.\n\n```\n<PasswordBox @bind-Password=\"password\" />\n@code {\n string password;\n}\n```"}, "<span id=\"page-40-0\"></span>State changes": {"<span id=\"page-43-0\"></span>Capture component references": {"<span id=\"page-43-1\"></span>Capture element references": "Razor components can capture references to an element. Unlike HTML server controls in ASP.NET Web Forms, you can't manipulate the DOM directly using an element reference in Blazor. Blazor handles most DOM interactions for you using its DOM diffing algorithm. Captured element references in Blazor are opaque. However, they're used to pass a specific element reference in a JavaScript interop call. For more information about JavaScript interop, see [ASP.NET Core Blazor JavaScript](https://docs.microsoft.com/aspnet/core/blazor/javascript-interop)  [interop.](https://docs.microsoft.com/aspnet/core/blazor/javascript-interop)"}}, "<span id=\"page-43-2\"></span>Templated components": "In ASP.NET Web Forms, you can create *templated controls*. Templated controls enable the developer to specify a portion of the HTML used to render a container control. The mechanics of building templated server controls are complex, but they enable powerful scenarios for rendering data in a user customizable way. Examples of templated controls include Repeater and DataList.\n\nRazor components can also be templated by defining component parameters of type RenderFragment or RenderFragment<T>. A RenderFragment represents a chunk of Razor markup that can then be rendered by the component. A RenderFragment<T> is a chunk of Razor markup that takes a parameter that can be specified when the render fragment is rendered.\n\n<span id=\"page-44-0\"></span>**Child content**\n\nRazor components can capture their child content as a RenderFragment and render that content as part of the component rendering. To capture child content, define a component parameter of type RenderFragment and name it ChildContent.\n\n*ChildContentComponent.razor*\n\n```\n<h1>Component with child content</h1>\n<div>@ChildContent</div>\n@code {\n [Parameter]\n public RenderFragment ChildContent { get; set; }\n}\nA parent component can then supply child content using normal Razor syntax.\n<ChildContentComponent>\n <ChildContent>\n <p>The time is @DateTime.Now</p>\n </ChildContent>\n</ChildContentComponent>\n```\n\n<span id=\"page-44-1\"></span>**Template parameters**\n\nA templated Razor component can also define multiple component parameters of type RenderFragment or RenderFragment<T>. The parameter for a RenderFragment<T> can be specified when it's invoked. To specify a generic type parameter for a component, use the @typeparam Razor directive.\n\n*SimpleListView.razor*\n\n```\n@typeparam TItem\n@Heading\n<ul>\n@foreach (var item in Items)\n{\n <li>@ItemTemplate(item)</li>\n}\n</ul>\n@code {\n [Parameter]\n public RenderFragment Heading { get; set; }\n [Parameter]\n public RenderFragment<TItem> ItemTemplate { get; set; }\n [Parameter]\n public IEnumerable<TItem> Items { get; set; }\n}\n```\n\nWhen using a templated component, the template parameters can be specified using child elements that match the names of the parameters. Component arguments of type RenderFragment<T> passed as elements have an implicit parameter named context. You can change the name of this implement parameter using the Context attribute on the child element. Any generic type parameters can be specified using an attribute that matches the name of the type parameter. The type parameter will be inferred if possible:\n\n```\n<SimpleListView Items=\"messages\" TItem=\"string\">\n <Heading>\n <h1>My list</h1>\n </Heading>\n <ItemTemplate Context=\"message\">\n <p>The message is: @message</p>\n </ItemTemplate>\n</SimpleListView>\nThe output of this component looks like this:\n<h1>My list</h1>\n<ul>\n <li><p>The message is: message1</p></li>\n <li><p>The message is: message2</p></li>\n<ul>\n```\n\n<span id=\"page-45-0\"></span>Code-behind\n\nA Razor component is typically authored in a single *.razor* file. However, it's also possible to separate the code and markup using a code-behind file. To use a component file, add a C# file that matches the file name of the component file but with a *.cs* extension added (*Counter.razor.cs*). Use the C# file to define a base class for the component. You can name the base class anything you'd like, but it's common to name the class the same as the component class, but with a Base extension added (CounterBase). The component-based class must also derive from ComponentBase. Then, in the Razor component file, add the @inherits directive to specify the base class for the component (@inherits CounterBase).\n\n*Counter.razor*\n\n```\n@inherits CounterBase\n<h1>Counter</h1>\n<p>Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\nCounter.razor.cs\npublic class CounterBase : ComponentBase\n{\n protected int currentCount = 0;\n protected void IncrementCount()\n {\n currentCount++;\n }\n}\n```\n\nThe visibility of the component's members in the base class must be protected or public to be visible to the component class.\n\n<span id=\"page-46-0\"></span>Additional resources\n\nThe preceding isn't an exhaustive treatment of all aspects of Razor components. For more information on how to [Create and use ASP.NET Core Razor components,](https://docs.microsoft.com/aspnet/core/blazor/components) see the Blazor documentation."}, "<span id=\"page-47-0\"></span>Pages, routing, and layouts": {"<span id=\"page-49-1\"></span>Navigation": "In ASP.NET Web Forms, you trigger navigation to a different page by returning a redirect response to the browser. For example:\n\n```\nprotected void NavigateButton_Click(object sender, EventArgs e)\n{\n Response.Redirect(\"Counter\");\n}\n```\n\nReturning a redirect response isn't typically possible in Blazor. Blazor doesn't use a request-reply model. You can, however, trigger browser navigations directly, as you can with JavaScript.\n\nBlazor provides a NavigationManager service that can be used to:\n\n['Get the current browser address', 'Get the base address', 'Trigger navigations', 'Get notified when the address changes']\n\nTo navigate to a different address, use the NavigateTo method:\n\n```\n@page \"/\"\n@inject NavigationManager NavigationManager\n<button @onclick=\"Navigate\">Navigate</button>\n@code {\n void Navigate() {\n NavigationManager.NavigateTo(\"counter\");\n }\n}\n```\n\nFor a description of all NavigationManager members, see [URI and navigation state helpers.](https://docs.microsoft.com/aspnet/core/blazor/routing#uri-and-navigation-state-helpers)\n\n<span id=\"page-50-0\"></span>Base URLs\n\nIf your Blazor app is deployed under a base path, then you need to specify the base URL in the page metadata using the <base> tag for routing to work property. If the host page for the app is serverrendered using Razor, then you can use the ~/ syntax to specify the app's base address. If the host page is static HTML, then you need to specify the base URL explicitly.\n\n```\n<base href=\"~/\" />\n```\n\n<span id=\"page-50-1\"></span>Page layout\n\nPage layout in ASP.NET Web Forms is handled by Master Pages. Master Pages define a template with one or more content placeholders that can then be supplied by individual pages. Master Pages are defined in *.master* files and start with the <%@ Master %> directive. The content of the *.master* files is coded as you would an *.aspx* page, but with the addition of <asp:ContentPlaceHolder> controls to mark where pages can supply content.\n\n*Site.master*\n\n```\n<%@ Master Language=\"C#\" AutoEventWireup=\"true\" CodeBehind=\"Site.master.cs\" \nInherits=\"WebApplication1.SiteMaster\" %>\n<!DOCTYPE html>\n<html lang=\"en\">\n<head runat=\"server\">\n <meta charset=\"utf-8\" />\n <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n <title><%: Page.Title %> - My ASP.NET Application</title>\n <link href=\"~/favicon.ico\" rel=\"shortcut icon\" type=\"image/x-icon\" />\n</head>\n```\n\n```\n<body>\n <form runat=\"server\">\n <div class=\"container body-content\">\n <asp:ContentPlaceHolder ID=\"MainContent\" runat=\"server\">\n </asp:ContentPlaceHolder>\n <hr />\n <footer>\n <p>&copy; <%: DateTime.Now.Year %> - My ASP.NET Application</p>\n </footer>\n </div>\n </form>\n</body>\n</html>\n```\n\nIn Blazor, you handle page layout using layout components. Layout components inherit from LayoutComponentBase, which defines a single Body property of type RenderFragment, which can be used to render the contents of the page.\n\n*MainLayout.razor*\n\n```\n@inherits LayoutComponentBase\n<h1>Main layout</h1>\n<div>\n @Body\n</div>\n```\n\nWhen the page with a layout is rendered, the page is rendered within the contents of the specified layout at the location where the layout renders its Body property.\n\nTo apply a layout to a page, use the @layout directive:\n\n```\n@layout MainLayout\n```\n\nYou can specify the layout for all components in a folder and subfolders using an \\*\\_Imports.razor\\* file. You can also specify a default layout for all your pages using the [Router component.](#page-49-0)\n\nMaster Pages can define multiple content placeholders, but layouts in Blazor only have a single Body property. This limitation of Blazor layout components will hopefully be addressed in a future release.\n\nMaster Pages in ASP.NET Web Forms can be nested. That is, a Master Page may also use a Master Page. Layout components in Blazor may be nested too. You can apply a layout component to a layout component. The contents of the inner layout will be rendered within the outer layout.\n\n*ChildLayout.razor*\n\n```\n@layout MainLayout\n<h2>Child layout</h2>\n<div>\n @Body\n</div>\n```\n\n*Index.razor*\n\n```\n@page \"/\"\n@layout ChildLayout\n<p>I'm in a nested layout!</p>\n```\n\nThe rendered output for the page would then be:\n\n```\n<h1>Main layout</h1>\n<div>\n <h2>Child layout</h2>\n <div>\n <p>I'm in a nested layout!</p>\n </div>\n</div>\n```\n\nLayouts in Blazor don't typically define the root HTML elements for a page (<html>, <body>, <head>, and so on). The root HTML elements are instead defined in a Blazor app's host page, which is used to render the initial HTML content for the app (see [Bootstrap Blazor\\)](#page-23-2). The host page can render multiple root components for the app with surrounding markup.\n\nComponents in Blazor, including pages, can't render <script> tags. This rendering restriction exists because <script> tags get loaded once and then can't be changed. Unexpected behavior may occur if you try to render the tags dynamically using Razor syntax. Instead, all <script> tags should be added to the app's host page.\n\n**CHAPTER** 8", "<span id=\"page-53-0\"></span>State management": "State management is a key concept of Web Forms applications, facilitated through ViewState, Session State, Application State, and Postback features. These stateful features of the framework helped to hide the state management required for an application and allow application developers to focus on delivering their functionality. With ASP.NET Core and Blazor, some of these features have been relocated and some have been removed altogether. This chapter reviews how to maintain state and deliver the same functionality with the new features in Blazor.", "<span id=\"page-53-1\"></span>Request state management with ViewState": "When discussing state management in Web Forms application, many developers will immediately think of ViewState. In Web Forms, ViewState manages the state of the content between HTTP requests by sending a large encoded block of text back and forth to the browser. The ViewState field could be overwhelmed with content from a page containing many elements, potentially expanding to several megabytes in size.\n\nWith Blazor Server, the app maintains an ongoing connection with the server. The app's state, called a *circuit*, is held in server memory while the connection is considered active. State will only be disposed when the user navigates away from the app or a particular page in the app. All members of the active components are available between interactions with the server.\n\nThere are several advantages of this feature:\n\n['Component state is readily available and not rebuilt between interactions.', \"State isn't transmitted to the browser.\"]\n\nHowever, there are some disadvantages to in-memory component state persistence to be aware of:\n\n['If the server restarts between request, state is lost.', 'Your application web server load-balancing solution must include sticky sessions to ensure that all requests from the same browser return to the same server. If a request goes to a different server, state will be lost.', 'Persistence of component state on the server can lead to memory pressure on the web server.']\n\nFor the preceding reasons, don't rely on just the state of the component to reside in-memory on the server. Your application should also include some backing data store for data between requests. Some simple examples of this strategy:\n\n\u2022 In a shopping cart application, persist the content of new items added to the cart in a database record. If the state on the server is lost, you can reconstitute it from the database records.\n\n\u2022 In a multi-part web form, your users will expect your application to remember values between each request. Write the data between each of your user's posts to a data store so that they can be fetched and assembled into the final form response structure when the multi-part form is completed.\n\nFor additional details on managing state in Blazor apps, see [ASP.NET Core Blazor state management.](https://docs.microsoft.com/aspnet/core/blazor/state-management)\n\n<span id=\"page-54-0\"></span>Maintain state with Session\n\nWeb Forms developers could maintain information about the currently acting user with the [Microsoft.AspNetCore.Http.ISession](https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.http.isession) dictionary object. It's easy enough to add an object with a string key to the Session, and that object would be available at a later time during the user's interactions with the application. In an attempt to eliminate managing interacting with HTTP, the Session object made it easy to maintain state.\n\nThe signature of the .NET Framework Session object isn't the same as the ASP.NET Core Session object. Consider [the documentation for the new ASP.NET Core Session](https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.http.isession) before deciding to migrate and use the new session state feature.\n\nSession is available in ASP.NET Core and Blazor Server, but is discouraged from use in favor of storing data in a data repository appropriately. Session state is also not functional if visitors decline the use HTTP cookies in your application due to privacy concerns.\n\nConfiguration for ASP.NET Core and Session state is available in the [Session and state management in](https://docs.microsoft.com/aspnet/core/fundamentals/app-state#session-state)  [ASP.NET Core article.](https://docs.microsoft.com/aspnet/core/fundamentals/app-state#session-state)\n\n<span id=\"page-54-1\"></span>Application state\n\nThe Application object in the Web Forms framework provides a massive, cross-request repository for interacting with application-scope configuration and state. Application state was an ideal place to store various application configuration properties that would be referenced by all requests, regardless of the user making the request. The problem with the Application object was that data didn't persist across multiple servers. The state of the application object was lost between restarts.\n\nAs with Session, it's recommended that data move to a persistent backing store that could be accessed by multiple server instances. If there is volatile data that you would like to be able to access across requests and users, you could easily store it in a singleton service that can be injected into components that require this information or interaction.\n\nThe construction of an object to maintain application state and its consumption could resemble the following implementation:\n\n```\npublic class MyApplicationState\n{\n public int VisitorCounter { get; private set; } = 0;\n public void IncrementCounter() => VisitorCounter += 1;\n}\n```\n\n```\napp.AddSingleton<MyApplicationState>();\n@inject MyApplicationState AppState\n<label>Total Visitors: @AppState.VisitorCounter</label>\n```\n\nThe MyApplicationState object is created only once on the server, and the value VisitorCounter is fetched and output in the component's label. The VisitorCounter value should be persisted and retrieved from a backing data store for durability and scalability.\n\n<span id=\"page-55-0\"></span>In the browser\n\nApplication data can also be stored client-side on the user's device so that is available later. There are two browser features that allow for persistence of data in different scopes of the user's browser:\n\n[\"localStorage scoped to the user's entire browser. If the page is reloaded, the browser is closed and reopened, or another tab is opened with the same URL then the same localStorage is provided by the browser\", \"sessionStorage scoped to the user's current browser tab. If the tab is reloaded, the state persists. However, if the user opens another tab to your application or closes and reopens the browser the state is lost.\"]\n\nYou can write some custom JavaScript code to interact with these features, or there are a number of NuGet packages that you can use that provide this functionality. One such package is [Microsoft.AspNetCore.ProtectedBrowserStorage.](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage)\n\nFor instructions on utilizing this package to interact with localStorage and sessionStorage, see the [Blazor State Management](https://docs.microsoft.com/aspnet/core/blazor/state-management#protected-browser-storage-experimental-package) article.", "<span id=\"page-56-0\"></span>Forms and validation": "The ASP.NET Web Forms framework includes a set of validation server controls that handle validating user input entered into a form (RequiredFieldValidator, CompareValidator, RangeValidator, and so on). The ASP.NET Web Forms framework also supports model binding and validating the model based on data annotations ([Required], [StringLength], [Range], and so on). The validation logic can be enforced both on the server and on the client using unobtrusive JavaScript-based validation. The ValidationSummary server control is used to display a summary of the validation errors to the user.\n\nBlazor supports the sharing of validation logic between both the client and the server. ASP.NET provides pre-built JavaScript implementations of many common server validations. In many cases, the developer still has to write JavaScript to fully implement their app-specific validation logic. The same model types, data annotations, and validation logic can be used on both the server and client.\n\nBlazor provides a set of input components. The input components handle binding field data to a model and validating the user input when the form is submitted.\n\n| Input component | Rendered HTML element                                                   |\n|-----------------|-------------------------------------------------------------------------|\n| InputCheckbox   | <input type=\"checkbox\"/>                                                |\n| InputDate       | <input type=\"date\"/>                                                    |\n| InputNumber     | <input type=\"number\"/>                                                  |\n| InputSelect     | <select></select>                                                       |\n| InputText       | <input/>                                                                |\n| InputTextArea   | <textarea>&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</textarea> |\n\nThe EditForm component wraps these input components and orchestrates the validation process through an EditContext. When creating an EditForm, you specify what model instance to bind to using the Model parameter. Validation is typically done using data annotations, and it's extensible. To enable data annotation-based validation, add the DataAnnotationsValidator component as a child of the EditForm. The EditForm component provides a convenient event for handling valid (OnValidSubmit) and invalid (OnInvalidSubmit) submissions. There's also a more generic OnSubmit event that lets you trigger and handle the validation yourself.\n\nTo display a validation error summary, use the ValidationSummary component. To display validation messages for a specific input field, use the ValidationMessage component, specifying a lambda expression for the For parameter that points to the appropriate model member.\n\nThe following model type defines several validation rules using data annotations:\n\n```\nusing System;\nusing System.ComponentModel.DataAnnotations;\npublic class Starship\n{\n [Required]\n [StringLength(16,\n ErrorMessage = \"Identifier too long (16 character limit).\")]\n public string Identifier { get; set; }\n public string Description { get; set; }\n [Required]\n public string Classification { get; set; }\n [Range(1, 100000,\n ErrorMessage = \"Accommodation invalid (1-100000).\")]\n public int MaximumAccommodation { get; set; }\n [Required]\n [Range(typeof(bool), \"true\", \"true\",\n ErrorMessage = \"This form disallows unapproved ships.\")]\n public bool IsValidatedDesign { get; set; }\n [Required]\n public DateTime ProductionDate { get; set; }\n}\n```\n\nThe following component demonstrates building a form in Blazor based on the Starship model type:\n\n```\n<h1>New Ship Entry Form</h1>\n<EditForm Model=\"@starship\" OnValidSubmit=\"@HandleValidSubmit\">\n <DataAnnotationsValidator />\n <ValidationSummary />\n <p>\n <label for=\"identifier\">Identifier: </label>\n <InputText id=\"identifier\" @bind-Value=\"starship.Identifier\" />\n <ValidationMessage For=\"() => starship.Identifier\" />\n </p>\n <p>\n <label for=\"description\">Description (optional): </label>\n <InputTextArea id=\"description\" @bind-Value=\"starship.Description\" />\n </p>\n <p>\n <label for=\"classification\">Primary Classification: </label>\n <InputSelect id=\"classification\" @bind-Value=\"starship.Classification\">\n <option value=\"\">Select classification ...</option>\n <option value=\"Exploration\">Exploration</option>\n <option value=\"Diplomacy\">Diplomacy</option>\n <option value=\"Defense\">Defense</option>\n </InputSelect>\n <ValidationMessage For=\"() => starship.Classification\" />\n </p>\n <p>\n <label for=\"accommodation\">Maximum Accommodation: </label>\n <InputNumber id=\"accommodation\" @bind-Value=\"starship.MaximumAccommodation\" />\n <ValidationMessage For=\"() => starship.MaximumAccommodation\" />\n </p>\n```\n\n```\n <p>\n <label for=\"valid\">Engineering Approval: </label>\n <InputCheckbox id=\"valid\" @bind-Value=\"starship.IsValidatedDesign\" />\n <ValidationMessage For=\"() => starship.IsValidatedDesign\" />\n </p>\n <p>\n <label for=\"productionDate\">Production Date: </label>\n <InputDate id=\"productionDate\" @bind-Value=\"starship.ProductionDate\" />\n <ValidationMessage For=\"() => starship.ProductionDate\" />\n </p>\n <button type=\"submit\">Submit</button>\n</EditForm>\n@code {\n private Starship starship = new Starship();\n private void HandleValidSubmit()\n {\n // Save the data\n }\n}\n```\n\nAfter the form submission, the model-bound data hasn't been saved to any data store, like a database. In a Blazor WebAssembly app, the data must be sent to the server. For example, using an HTTP POST request. In a Blazor Server app, the data is already on the server, but it must be persisted. Handling data access in Blazor apps is the subject of the [Dealing with data](#page-59-0) section.\n\n<span id=\"page-58-0\"></span>Additional resources\n\nFor more information on [forms and validation](https://docs.microsoft.com/aspnet/core/blazor/forms-validation) in Blazor apps, see the Blazor documentation.", "<span id=\"page-59-0\"></span>Work with data": "Data access is the backbone of an ASP.NET Web Forms app. If you're building forms for the web, what happens to that data? With Web Forms, there were multiple data access techniques you could use to interact with a database:\n\n['Data Sources', 'ADO.NET', 'Entity Framework']\n\nData Sources were controls that you could place on a Web Forms page and configure like other controls. Visual Studio provided a friendly set of dialogs to configure and bind the controls to your Web Forms pages. Developers who enjoy a \"low code\" or \"no code\" approach preferred this technique when Web Forms was first released.\n\n| SqlDataSource | - CustomersData |           |           |                     |\n|---------------|-----------------|-----------|-----------|---------------------|\n| CustomerID    | CompanyName     | FirstName | LastName  |                     |\n| Databound     | Databound       | Databound | Databound | Click Me! Databound |\n| Databound     | Databound       | Databound | Databound | Click Me! Databound |\n| Databound     | Databound       | Databound | Databound | Click Me! Databound |\n| Databound     | Databound       | Databound | Databound | Click Me! Databound |\n| Databound     | Databound       | Databound | Databound | Click Me! Databound |\n\nADO.NET is the low-level approach to interacting with a database. Your apps could create a connection to the database with Commands, Datatables, and Datasets for interacting. The results could then be bound to fields on screen without much code. The drawback of this approach was that each set of ADO.NET objects (Connection, Command, and DataTable) was bound to libraries provided by a database vendor. Use of these components made the code rigid and difficult to migrate to a different database.\n\n<span id=\"page-59-1\"></span>Entity Framework\n\nEntity Framework (EF) is the open source object-relational mapping framework maintained by the .NET Foundation. Initially released with .NET Framework, EF allows for generating code for the database connections, storage schemas, and interactions. With this abstraction, you can focus on your app's business rules and allow the database to be managed by a trusted database administrator. In .NET, you can use an updated version of EF called EF Core. EF Core helps generate and maintain the interactions between your code and the database with a series of commands that are available for you using the dotnet ef command-line tool. Let's take a look at a few samples to get you working with a database.\n\n<span id=\"page-60-0\"></span>**EF Code First**\n\nA quick way to get started building your database interactions is to start with the class objects you want to work with. EF provides a tool to help generate the appropriate database code for your classes. This approach is called \"Code First\" development. Consider the following Product class for a sample storefront app that we want to store in a relational database like Microsoft SQL Server.\n\n```\npublic class Product\n{\n public int Id { get; set; }\n [Required]\n public string Name { get; set; }\n [MaxLength(4000)]\n public string Description { get; set; }\n [Range(0, 99999,99)]\n [DataType(DataType.Currency)]\n public decimal Price { get; set; }\n}\n```\n\nProduct has a primary key and three additional fields that would be created in our database:\n\n['EF will identify the Id property as a primary key by convention.', 'Name will be stored in a column configured for text storage. The [Required] attribute decorating this property will add a not null constraint to help enforce this declared behavior of the property.', 'Description will be stored in a column configured for text storage, and have a maximum length configured of 4000 characters as dictated by the [MaxLength] attribute. The database schema will be configured with a column named MaxLength using data type varchar(4000).', 'The Price property will be stored as currency. The [Range] attribute will generate appropriate constraints to prevent data storage outside of the minimum and maximum values declared.']\n\nWe need to add this Product class to a database context class that defines the connection and translation operations with our database.\n\n```\npublic class MyDbContext : DbContext\n{\n public DbSet<Product> Products { get; set; }\n}\n```\n\nThe MyDbContext class provides the one property that defines the access and translation for the Product class. Your application configures this class for interaction with the database using the following entries in the Startup class's ConfigureServices method (or appropriate location in *Program.cs* using the builder.Services property instead of services):\n\n```\nservices.AddDbContext<MyDbContext>(options =>\n options.UseSqlServer(\"MY DATABASE CONNECTION STRING\"));\n```\n\nThe preceding code will connect to a SQL Server database with the specified connection string. You can place the connection string in your *appsettings.json* file, environment variables, or other configuration storage locations and replace this embedded string appropriately.\n\nYou can then generate the database table appropriate for this class using the following commands:\n\n```\ndotnet ef migrations add 'Create Product table'\ndotnet ef database update\n```\n\nThe first command defines the changes you're making to the database schema as a new EF Migration called Create Product table. A Migration defines how to apply and remove your new database changes.\n\nOnce applied, you have a simple Product table in your database and some new classes added to the project that help manage the database schema. You can find these generated classes, by default, in a new folder called *Migrations*. When you make changes to the Product class or add more related classes you would like interacting with your database, you need to run the command-line commands again with a new name of the migration. This command will generate another set of migration classes to update your database schema.\n\n<span id=\"page-61-0\"></span>**EF Database First**\n\nFor existing databases, you can generate the classes for EF Core by using the .NET command-line tools. To scaffold the classes, use a variation of the following command:\n\n```\ndotnet ef dbcontext scaffold \"CONNECTION STRING\" Microsoft.EntityFrameworkCore.SqlServer -c \nMyDbContext -t Product -t Customer\n```\n\nThe preceding command connects to the database using the specified connection string and the Microsoft.EntityFrameworkCore.SqlServer provider. Once connected, a database context class named MyDbContext is created. Additionally, supporting classes are created for the Product and Customer tables that were specified with the -t options. There are many configuration options for this command to generate the class hierarchy appropriate for your database. For a complete reference, see [the](https://docs.microsoft.com/ef/core/miscellaneous/cli/dotnet#dotnet-ef-dbcontext-scaffold)  [command's documentation](https://docs.microsoft.com/ef/core/miscellaneous/cli/dotnet#dotnet-ef-dbcontext-scaffold).\n\n<span id=\"page-61-1\"></span>More information about [EF Core](https://docs.microsoft.com/ef/core/) can be found on the Microsoft Docs site.\n\nInteract with web services\n\nWhen ASP.NET was first released, SOAP services were the preferred way for web servers and clients to exchange data. Much has changed since that time, and the preferred interactions with services have shifted to direct HTTP client interactions. With ASP.NET Core and Blazor, you can register the configuration of your HttpClient in *Program.cs* or in the Startup class's ConfigureServices method. Use that configuration when you need to interact with the HTTP endpoint. Consider the following configuration code:\n\n```\n// in Program.cs\nbuilder.Services.AddHttpClient(\"github\", client =>\n{\n client.BaseAddress = new Uri(\"http://api.github.com/\");\n // Github API versioning\n client.DefaultRequestHeaders.Add(\"Accept\", \"application/vnd.github.v3+json\");\n // Github requires a user-agent\n client.DefaultRequestHeaders.Add(\"User-Agent\", \"BlazorWebForms-Sample\");\n});\n```\n\nWhenever you need to access data from GitHub, create a client with a name of github. The client is configured with the base address, and the request headers are set appropriately. Inject the IHttpClientFactory into your Blazor components with the @inject directive or an [Inject] attribute on a property. Create your named client and interact with services using the following syntax:\n\n```\n@inject IHttpClientFactory factory\n...\n@code {\n protected override async Task OnInitializedAsync()\n {\n var client = factory.CreateClient(\"github\");\n var response = await client.GetAsync(\"repos/dotnet/docs/issues\");\n response.EnsureStatusCode();\n var content = await response.Content.ReadAsStringAsync();\n }\n}\n```\n\nThis method returns the string describing the collection of issues in the *dotnet/docs* GitHub repository. It returns content in JSON format and is deserialized into appropriate GitHub issue objects. There are many ways that you can configure the HttpClientFactory to deliver preconfigured HttpClient objects. Try configuring multiple HttpClient instances with different names and endpoints for the various web services you work with. This approach will make your interactions with those services easier to work with on each page. For more information, see [Make HTTP requests using IHttpClientFactory.](https://docs.microsoft.com/aspnet/core/fundamentals/http-requests)\n\n**CHAPTER** 11"}, "<span id=\"page-63-0\"></span>Modules, handlers, and middleware": {"<span id=\"page-67-0\"></span>App configuration": "The primary way to load app configuration in Web Forms is with entries in the *web.config* file\u2014either on the server or a related configuration file referenced by *web.config*. You can use the static ConfigurationManager object to interact with app settings, data repository connection strings, and other extended configuration providers that are added into the app. It's typical to see interactions with app configuration as seen in the following code:\n\n```\nvar configurationValue = ConfigurationManager.AppSettings[\"ConfigurationSettingName\"];\nvar connectionString =\nConfigurationManager.ConnectionStrings[\"MyDatabaseConnectionName\"].ConnectionString;\n```\n\nWith ASP.NET Core and server-side Blazor, the *web.config* file MAY be present if your app is hosted on a Windows IIS server. However, there's no ConfigurationManager interaction with this configuration, and you can receive more structured app configuration from other sources. Let's take a look at how configuration is gathered and how you can still access configuration information from a *web.config* file.\n\n<span id=\"page-67-1\"></span>Configuration sources\n\nASP.NET Core recognizes there are many configuration sources you may want to use for your app. The framework attempts to offer you the best of these features by default. Configuration is read and aggregated from these various sources by ASP.NET Core. Later loaded values for the same configuration key take precedence over earlier values.\n\nASP.NET Core was designed to be cloud-aware and to make the configuration of apps easier for both operators and developers. ASP.NET Core is environment-aware and knows if it's running in your Production or Development environment. The environment indicator is set in the ASPNETCORE\\_ENVIRONMENT system environment variable. If no value is configured, the app defaults to running in the Production environment.\n\nYour app can trigger and add configuration from several sources based on the environment's name. By default, the configuration is loaded from the following resources in the order listed:\n\n[['*appsettings.json* file, if present'], ['*appsettings.{ENVIRONMENT\\\\_NAME}.json* file, if present'], ['User secrets file on disk, if present'], ['Environment variables'], ['Command-line arguments']]", "<span id=\"page-68-0\"></span>appsettings.json format and access": "The *appsettings.json* file can be hierarchical with values structured like the following JSON:\n\n```\n{\n \"section0\": {\n \"key0\": \"value\",\n \"key1\": \"value\"\n },\n \"section1\": {\n \"key0\": \"value\",\n \"key1\": \"value\"\n }\n}\n```\n\nWhen presented with the preceding JSON, the configuration system flattens child values and references their fully qualified hierarchical paths. A colon (:) character separates each property in the hierarchy. For example, the configuration key section1:key0 accesses the section1 object literal's key0 value.\n\n<span id=\"page-68-1\"></span>User secrets\n\nUser secrets are:\n\n[\"Configuration values that are stored in a JSON file on the developer's workstation, outside of the app development folder.\", 'Only loaded when running in the Development environment.', 'Associated with a specific app.', \"Managed with the .NET CLI's user-secrets command.\"]\n\nConfigure your app for secrets storage by executing the user-secrets command:\n\n```\ndotnet user-secrets init\n```\n\nThe preceding command adds a UserSecretsId element to the project file. The element contains a GUID, which is used to associate secrets with the app. You can then define a secret with the set command. For example:\n\n```\ndotnet user-secrets set \"Parent:ApiKey\" \"12345\"\n```\n\nThe preceding command makes the Parent:ApiKey configuration key available on a developer's workstation with the value 12345.\n\nFor more information about creating, storing, and managing user secrets, see the [Safe storage of app](https://docs.microsoft.com/aspnet/core/security/app-secrets)  [secrets in development in ASP.NET Core](https://docs.microsoft.com/aspnet/core/security/app-secrets) document.\n\n<span id=\"page-68-2\"></span>Environment variables\n\nThe next set of values loaded into your app configuration is the system's environment variables. All of your system's environment variable settings are now accessible to you through the configuration API.\n\nHierarchical values are flattened and separated by colon characters when read inside your app. However, some operating systems don't allow the colon character environment variable names. ASP.NET Core addresses this limitation by converting values that have double-underscores (\\_\\_) into a colon when they're accessed. The Parent:ApiKey value from the user secrets section above can be overridden with the environment variable Parent\\_\\_ApiKey.\n\n<span id=\"page-69-0\"></span>Command-line arguments\n\nConfiguration can also be provided as command-line arguments when your app is started. Use the double-dash (--) or forward-slash (/) notation to indicate the name of the configuration value to set and the value to be configured. The syntax resembles the following commands:\n\n```\ndotnet run CommandLineKey1=value1 --CommandLineKey2=value2 /CommandLineKey3=value3\ndotnet run --CommandLineKey1 value1 /CommandLineKey2 value2\ndotnet run Parent:ApiKey=67890\n```", "<span id=\"page-69-1\"></span>The return of web.config": {"<span id=\"page-70-0\"></span>Read configuration in the app": "ASP.NET Core provides app configuration through the [IConfiguration](https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration) interface. This configuration interface should be requested by your Blazor components, Blazor pages, and any other ASP.NET Coremanaged class that needs access to configuration. The ASP.NET Core framework will automatically populate this interface with the resolved configuration configured earlier. On a Blazor page or a component's Razor markup, you can inject the IConfiguration object with an @inject directive at the top of the *.razor* file like this:\n\n```\n@inject IConfiguration Configuration\n```\n\nThis preceding statement makes the IConfiguration object available as the Configuration variable throughout the rest of the Razor template.\n\nIndividual configuration settings can be read by specifying the configuration setting hierarchy sought as an indexer parameter:\n\n```\nvar mySetting = Configuration[\"section1:key0\"];\n```\n\nYou can fetch entire configuration sections by using the [GetSection](https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration.getsection) method to retrieve a collection of keys at a specific location with a syntax similar to GetSection(\"section1\") to retrieve the configuration for section1 from the earlier example."}, "<span id=\"page-70-1\"></span>Strongly typed configuration": "With Web Forms, it was possible to create a strongly typed configuration type that inherited from the [ConfigurationSection](https://docs.microsoft.com/dotnet/api/system.configuration.configurationsection) type and associated types. A ConfigurationSection allowed you to configure some business rules and processing for those configuration values.\n\nIn ASP.NET Core, you can specify a class hierarchy that will receive the configuration values. These classes:\n\n[\"Don't need to inherit from a parent class.\", 'Should include public properties that match the properties and type references for the configuration structure you wish to capture.']\n\nFor the earlier *appsettings.json* sample, you could define the following classes to capture the values:\n\n```\npublic class MyConfig\n{\n public MyConfigSection section0 { get; set;}\n public MyConfigSection section1 { get; set;}\n}\npublic class MyConfigSection\n{\n```\n\n```\n public string key0 { get; set; }\n public string key1 { get; set; }\n}\n```\n\nThis class hierarchy can be populated by adding the following line to the Startup.ConfigureServices method (or appropriate location in *Program.cs* using the builder.Services property instead of services):\n\n```\nservices.Configure<MyConfig>(Configuration);\n```\n\nIn the rest of the app, you can add an input parameter to classes or an @inject directive in Razor templates of type IOptions<MyConfig> to receive the strongly typed configuration settings. The IOptions<MyConfig>.Value property will yield the MyConfig value populated from the configuration settings.\n\n```\n@inject IOptions<MyConfig> options\n@code {\n var MyConfiguration = options.Value;\n var theSetting = MyConfiguration.section1.key0;\n}\n```\n\nMore information about the Options feature can be found in the [Options pattern in ASP.NET Core](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces) document."}, "<span id=\"page-72-0\"></span>Security: Authentication and Authorization in ASP.NET Web Forms and Blazor": {"<span id=\"page-72-1\"></span>ASP.NET universal providers": {"<span id=\"page-75-0\"></span>ASP.NET Core Identity": {"<span id=\"page-75-1\"></span>**Roles, claims, and policies**": "Both the universal providers and ASP.NET Core Identity support the concept of roles. You can create roles for users and assign users to roles. Users can belong to any number of roles, and you can verify role membership as part of your authorization implementation.\n\nIn addition to roles, ASP.NET Core identity supports the concepts of claims and policies. While a role should specifically correspond to a set of resources a user in that role should be able to access, a claim is simply part of a user's identity. A claim is a name value pair that represents what the subject is, not what the subject can do.\n\nIt is possible to directly inspect a user's claims and determine based on these values whether a user should be given access to a resource. However, such checks are often repetitive and scattered throughout the system. A better approach is to define a *policy*.\n\nAn authorization policy consists of one or more requirements. Policies are registered as part of the authorization service configuration in the ConfigureServices method of Startup.cs. For example, the following code snippet configures a policy called \"CanadiansOnly\", which has the requirement that the user has the Country claim with the value of \"Canada\".\n\n```\nservices.AddAuthorization(options =>\n{\n options.AddPolicy(\"CanadiansOnly\", policy => policy.RequireClaim(ClaimTypes.Country,\n\"Canada\"));\n});\n```\n\nYou can [learn more about how to create custom policies in the documentation.](https://docs.microsoft.com/aspnet/core/security/authorization/policies)\n\nWhether you're using policies or roles, you can specify that a particular page in your Blazor application requires that role or policy with the [Authorize] attribute, applied with the @attribute directive.\n\nRequiring a role:\n\n```\n@attribute [Authorize(Roles =\"administrators\")]\n```\n\nRequiring a policy be satisfied:\n\n```\n@attribute [Authorize(Policy =\"CanadiansOnly\")]\n```\n\nIf you need access to a user's authentication state, roles, or claims in your code, there are two primary ways to achieve this functionality. The first is to receive the authentication state as a cascading parameter. The second is to access the state using an injected AuthenticationStateProvider. The details of each of these approaches are described in the [Blazor Security documentation.](https://docs.microsoft.com/aspnet/core/blazor/security/)\n\nThe following code shows how to receive the AuthenticationState as a cascading parameter:\n\n```\n[CascadingParameter]\nprivate Task<AuthenticationState> authenticationStateTask { get; set; }\n```\n\nWith this parameter in place, you can get the user using this code:\n\n```\nvar authState = await authenticationStateTask;\nvar user = authState.User;\n```\n\nThe following code shows how to inject the AuthenticationStateProvider:\n\n```\n@using Microsoft.AspNetCore.Components.Authorization\n@inject AuthenticationStateProvider AuthenticationStateProvider\n```\n\nWith the provider in place, you can gain access to the user with the following code:\n\n```\nAuthenticationState authState = await \nAuthenticationStateProvider.GetAuthenticationStateAsync();\nClaimsPrincipal user = authState.User;\nif (user.Identity.IsAuthenticated)\n{\n // work with user.Claims and/or user.Roles\n}\n```\n\n**Note:** The AuthorizeView component, covered later in this chapter, provides a declarative way to control what a user sees on a page or component.\n\nTo work with users and claims (in Blazor Server applications) you may also need to inject a UserManager<T> (use IdentityUser for default) which you can use to enumerate and modify claims for a user. First inject the type and assign it to a property:\n\n```\n@inject UserManager<IdentityUser> MyUserManager\n```\n\nThen use it to work with the user's claims. The following sample shows how to add and persist a claim on a user:\n\n```\nprivate async Task AddCountryClaim()\n{\n var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();\n var user = authState.User;\n var identityUser = await MyUserManager.FindByNameAsync(user.Identity.Name);\n if (!user.HasClaim(c => c.Type == ClaimTypes.Country))\n {\n```\n\n```\n // stores the claim in the cookie\n ClaimsIdentity id = new ClaimsIdentity();\n id.AddClaim(new Claim(ClaimTypes.Country, \"Canada\"));\n user.AddIdentity(id);\n // save the claim in the database\n await MyUserManager.AddClaimAsync(identityUser, new Claim(ClaimTypes.Country,\n\"Canada\"));\n }\n}\n```\n\nIf you need to work with roles, follow the same approach. You may need to inject a RoleManager<T> (use IdentityRole for default type) to list and manage the roles themselves.\n\n**Note:** In Blazor WebAssembly projects, you will need to provide server APIs to perform these operations (instead of using UserManager<T> or RoleManager<T> directly). A Blazor WebAssembly client application would manage claims and/or roles by securely calling API endpoints exposed for this purpose.", "<span id=\"page-77-0\"></span>**Migration guide**": "Migrating from ASP.NET Web Forms and universal providers to ASP.NET Core Identity requires several steps:\n\n[['Create ASP.NET Core Identity database schema in the destination database'], ['Migrate data from universal provider schema to ASP.NET Core Identity schema'], ['Migrate configuration from the web.config to middleware and services, typically in *Program.cs* (or a Startup class)'], ['Update individual pages using controls and conditionals to use tag helpers and new identity APIs.']]\n\nEach of these steps is described in detail in the following sections.", "<span id=\"page-77-1\"></span>**Creating the ASP.NET Core Identity schema**": "There are several ways to create the necessary table structure used for ASP.NET Core Identity. The simplest is to create a new ASP.NET Core Web application. Choose Web Application and then change Authentication type to use Individual Accounts.\n\n![](_page_78_Figure_0.jpeg)\n\nFrom the command line, you can do the same thing by running dotnet new webapp -au Individual. Once the app has been created, run it and register on the site. You should trigger a page like the one shown below:\n\n![](_page_79_Figure_0.jpeg)", "A database operation failed while processing the request.": "SqlException: Cannot open database \"aspnet-WebApplication10-53bc9b9d-9d6a-45d4-8429-2a2761773502\" requested by the login. The login failed. Login failed for user 'NIGHTKING\\steve'.", "Applying existing migrations for ApplicationDbContext may resolve this issue": "There are migrations for ApplicationDbContext that have not been applied to the database\n\n\u2022 00000000000000\\_CreateIdentitySchema", "**Apply Migrations**": "In Visual Studio, you can use the Package Manager Console to apply pending migrations to the database:\n\nPM> Update-Database\n\nAlternatively, you can apply pending migrations from a command prompt at your project directory:\n\n['dotnet ef database update']\n\nClick on the \"Apply Migrations\" button and the necessary database tables should be created for you. In addition, the migration files should appear in your project, as shown:\n\n![](_page_80_Figure_0.jpeg)\n\nYou can run the migration yourself, without running the web application, using this command-line tool:", "dotnet ef database update": "If you would rather run a script to apply the new schema to an existing database, you can script these migrations from the command-line. Run this command to generate the script:\n\n```\ndotnet ef migrations script -o auth.sql\n```\n\nThe above command will produce a SQL script in the output file auth.sql, which can then be run against whatever database you like. If you have any trouble running dotnet ef commands, [make sure](https://docs.microsoft.com/ef/core/miscellaneous/cli/dotnet)  [you have the EF Core tools installed on your system.](https://docs.microsoft.com/ef/core/miscellaneous/cli/dotnet)\n\nIn the event you have additional columns on your source tables, you will need to identify the best location for these columns in the new schema. Generally, columns found on the aspnet\\_Membership table should be mapped to the AspNetUsers table. Columns on aspnet\\_Roles should be mapped to AspNetRoles. Any additional columns on the aspnet\\_UsersInRoles table would be added to the AspNetUserRoles table.\n\nIt's also worth considering putting any additional columns on separate tables. So that future migrations won't need to take into account such customizations of the default identity schema.", "<span id=\"page-80-0\"></span>**Migrating data from universal providers to ASP.NET Core Identity**": "Once you have the destination table schema in place, the next step is to migrate your user and role records to the new schema. A complete list of the schema differences, including which columns map to which new columns, can be found [here.](https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity)\n\nTo migrate your users from membership to the new identity tables, you should [follow the steps](https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity)  [described in the documentation.](https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity) After following these steps and the script provided, your users will need to change their password the next time they log in.\n\nIt is possible to migrate user passwords but the process is much more involved. Requiring users to update their passwords as part of the migration process, and encouraging them to use new, unique passwords, is likely to enhance the overall security of the application.", "<span id=\"page-81-0\"></span>**Migrating security settings from web.config to app startup**": "As noted above, ASP.NET membership and role providers are configured in the application's web.config file. Since ASP.NET Core apps are not tied to IIS and use a separate system for configuration, these settings must be configured elsewhere. For the most part, ASP.NET Core Identity is configured in the *Program.cs* file. Open the web project that was created earlier (to generate the identity table schema) and review its *Program.cs* (or *Startup.cs*) file.\n\nThis code adds support for EF Core and Identity:\n\n```\n// Add services to the container.\nvar connectionString = builder.Configuration.GetConnectionString(\"DefaultConnection\");\nbuilder.Services.AddDbContext<ApplicationDbContext>(options =>\n options.UseSqlServer(connectionString));\nbuilder.Services.AddDatabaseDeveloperPageExceptionFilter();\nbuilder.Services.AddDefaultIdentity<IdentityUser>(options =>\n options.SignIn.RequireConfirmedAccount = true)\n .AddEntityFrameworkStores<ApplicationDbContext>();\n```\n\nThe AddDefaultIdentity extension method is used to configure Identity to use the default ApplicationDbContext and the framework's IdentityUser type. If you're using a custom IdentityUser, be sure to specify its type here. If these extension methods aren't working in your application, check that you have the appropriate using statements and that you have the necessary NuGet package references. For example, your project should have some version of the Microsoft.AspNetCore.Identity.EntityFrameworkCore and Microsoft.AspNetCore.Identity.UI packages referenced.\n\nAlso in *Program.cs* you should see the necessary middleware configured for the site. Specifically, UseAuthentication and UseAuthorization should be set up, and in the proper location.\n\n```\n// Configure the HTTP request pipeline.\nif (app.Environment.IsDevelopment())\n{\n app.UseMigrationsEndPoint();\n}\nelse\n{\n app.UseExceptionHandler(\"/Error\");\n // The default HSTS value is 30 days. You may want to change this for production \nscenarios, see https://aka.ms/aspnetcore-hsts.\n app.UseHsts();\n}\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n```\n\n```\napp.UseRouting();\napp.UseAuthentication();\napp.UseAuthorization();\n//app.MapControllers();\napp.MapBlazorHub();\napp.MapFallbackToPage(\"/_Host\");\n```\n\nASP.NET Identity does not configure anonymous or role-based access to locations from *Program.cs*. You will need to migrate any location-specific authorization configuration data to filters in ASP.NET Core. Make note of which folders and pages will require such updates. You will make these changes in the next section.", "<span id=\"page-82-0\"></span>**Updating individual pages to use ASP.NET Core Identity abstractions**": "In your ASP.NET Web Forms application, if you had web.config settings to deny access to certain pages or folders to anonymous users, you would migrate these changes by adding the [Authorize] attribute to such pages:\n\n```\n@attribute [Authorize]\n```\n\nIf you further had denied access except to those users belonging to a certain role, you would likewise migrate this behavior by adding an attribute specifying a role:\n\n```\n@attribute [Authorize(Roles =\"administrators\")]\n```\n\nThe [Authorize] attribute only works on @page components that are reached via the Blazor Router. The attribute does not work with child components, which should instead use AuthorizeView.\n\nIf you have logic within page markup for determining whether to display some code to a certain user, you can replace this with the AuthorizeView component. The [AuthorizeView component](https://docs.microsoft.com/aspnet/core/blazor/security#authorizeview-component) selectively displays UI depending on whether the user is authorized to see it. It also exposes a context variable that can be used to access user information.\n\n```\n<AuthorizeView>\n <Authorized>\n <h1>Hello, @context.User.Identity.Name!</h1>\n <p>You can only see this content if you are authenticated.</p>\n </Authorized>\n <NotAuthorized>\n <h1>Authentication Failure!</h1>\n <p>You are not signed in.</p>\n </NotAuthorized>\n</AuthorizeView>\n```\n\nYou can access the authentication state within procedural logic by accessing the user from a Task<AuthenticationState configured with the [CascadingParameter] attribute. This configuration will get you access to the user, which can let you determine if they are authenticated and if they belong to a particular role. If you need to evaluate a policy procedurally, you can inject an instance of the IAuthorizationService and calls the AuthorizeAsync method on it. The following sample code demonstrates how to get user information and allow an authorized user to perform a task restricted by the content-editor policy.\n\n```\n@using Microsoft.AspNetCore.Authorization\n@inject IAuthorizationService AuthorizationService\n<button @onclick=\"@DoSomething\">Do something important</button>\n@code {\n [CascadingParameter]\n private Task<AuthenticationState> authenticationStateTask { get; set; }\n private async Task DoSomething()\n {\n var user = (await authenticationStateTask).User;\n if (user.Identity.IsAuthenticated)\n {\n // Perform an action only available to authenticated (signed-in) users.\n }\n if (user.IsInRole(\"admin\"))\n {\n // Perform an action only available to users in the 'admin' role.\n }\n if ((await AuthorizationService.AuthorizeAsync(user, \"content-editor\"))\n .Succeeded)\n {\n // Perform an action only available to users satisfying the\n // 'content-editor' policy.\n }\n }\n}\n```\n\nThe AuthenticationState first need to be set up as a cascading value before it can be bound to a cascading parameter like this. That's typically done using the CascadingAuthenticationState component. This configuration is typically done in App.razor:\n\n```\n<CascadingAuthenticationState>\n <Router AppAssembly=\"@typeof(Program).Assembly\">\n <Found Context=\"routeData\">\n <AuthorizeRouteView RouteData=\"@routeData\"\n DefaultLayout=\"@typeof(MainLayout)\" />\n </Found>\n <NotFound>\n <LayoutView Layout=\"@typeof(MainLayout)\">\n <p>Sorry, there's nothing at this address.</p>\n </LayoutView>\n </NotFound>\n </Router>\n</CascadingAuthenticationState>\n```"}}, "<span id=\"page-83-0\"></span>Summary": "Blazor uses the same security model as ASP.NET Core, which is ASP.NET Core Identity. Migrating from universal providers to ASP.NET Core Identity is relatively straightforward, assuming not too much customization was applied to the original data schema. Once the data has been migrated, working\n\nwith authentication and authorization in Blazor apps is well documented, with configurable as well as programmatic support for most security requirements.\n\n<span id=\"page-84-0\"></span>References\n\n['[Introduction to Identity on ASP.NET Core](https://docs.microsoft.com/aspnet/core/security/authentication/identity)', '[Migrate from ASP.NET Membership authentication to ASP.NET Core 2.0 Identity](https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity)', '[Migrate Authentication and Identity to ASP.NET Core](https://docs.microsoft.com/aspnet/core/migration/identity)', '[ASP.NET Core Blazor authentication and authorization](https://docs.microsoft.com/aspnet/core/blazor/security/)']"}, "<span id=\"page-85-0\"></span>Migrate from ASP.NET Web Forms to Blazor": {"<span id=\"page-91-0\"></span>Migrate static files": "To serve static files (for example, HTML, CSS, images, and JavaScript), the files must be exposed by middleware. Calling the UseStaticFiles method enables the serving of static files from the web root path. The default web root directory is *wwwroot*, but it can be customized. As included in the *Program.cs* file:\n\n```\n...\napp.UseStaticFiles();\n...\n```\n\nThe eShop project enables basic static file access. There are many customizations available for static file access. For information on enabling default files or a file browser, see [Static files in ASP.NET Core.](https://docs.microsoft.com/aspnet/core/fundamentals/static-files)", "<span id=\"page-91-1\"></span>Migrate runtime bundling and minification setup": "Bundling and minification are performance optimization techniques for reducing the number and size of server requests to retrieve certain file types. JavaScript and CSS often undergo some form of bundling or minification before being sent to the client. In ASP.NET Web Forms, these optimizations are handled at run time. The optimization conventions are defined an *App\\_Start/BundleConfig.cs* file. In ASP.NET Core, a more declarative approach is adopted. A file lists the files to be minified, along with specific minification settings.\n\nFor more information on bundling and minification, see [Bundle and minify static assets in ASP.NET](https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification)  [Core.](https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification)", "<span id=\"page-91-2\"></span>Migrate ASPX pages": "A page in a Web Forms app is a file with the *.aspx* extension. A Web Forms page can often be mapped to a component in Blazor. A Razor component is authored in a file with the *.razor* extension. For the eShop project, five pages are converted to a Razor page.\n\nFor example, the details view comprises three files in the Web Forms project: *Details.aspx*, *Details.aspx.cs*, and *Details.aspx.designer.cs*. When converting to Blazor, the code-behind and markup are combined into *Details.razor*. Razor compilation (equivalent to what's in *.designer.cs* files) is stored in the *obj* directory and isn't, by default, viewable in **Solution Explorer**. The Web Forms page consists of the following markup:\n\n```\n<%@ Page Title=\"Details\" Language=\"C#\" MasterPageFile=\"~/Site.Master\" \nAutoEventWireup=\"true\" CodeBehind=\"Details.aspx.cs\" \nInherits=\"eShopLegacyWebForms.Catalog.Details\" %>\n<asp:Content ID=\"Details\" ContentPlaceHolderID=\"MainContent\" runat=\"server\">\n <h2 class=\"esh-body-title\">Details</h2>\n <div class=\"container\">\n <div class=\"row\">\n```\n\n```\n <asp:Image runat=\"server\" CssClass=\"col-md-6 esh-picture\" ImageUrl='<%#\"/Pics/\" \n+ product.PictureFileName%>' />\n <dl class=\"col-md-6 dl-horizontal\">\n <dt>Name\n </dt>\n <dd>\n <asp:Label runat=\"server\" Text='<%#product.Name%>' />\n </dd>\n <dt>Description\n </dt>\n <dd>\n <asp:Label runat=\"server\" Text='<%#product.Description%>' />\n </dd>\n <dt>Brand\n </dt>\n <dd>\n <asp:Label runat=\"server\" Text='<%#product.CatalogBrand.Brand%>' />\n </dd>\n <dt>Type\n </dt>\n <dd>\n <asp:Label runat=\"server\" Text='<%#product.CatalogType.Type%>' />\n </dd>\n <dt>Price\n </dt>\n <dd>\n <asp:Label CssClass=\"esh-price\" runat=\"server\" \nText='<%#product.Price%>' />\n </dd>\n <dt>Picture name\n </dt>\n <dd>\n <asp:Label runat=\"server\" Text='<%#product.PictureFileName%>' />\n </dd>\n <dt>Stock\n </dt>\n <dd>\n <asp:Label runat=\"server\" Text='<%#product.AvailableStock%>' />\n </dd>\n <dt>Restock\n </dt>\n <dd>\n <asp:Label runat=\"server\" Text='<%#product.RestockThreshold%>' />\n </dd>\n <dt>Max stock\n </dt>\n```\n\n```\n <dd>\n <asp:Label runat=\"server\" Text='<%#product.MaxStockThreshold%>' />\n </dd>\n </dl>\n </div>\n <div class=\"form-actions no-color esh-link-list\">\n <a runat=\"server\" href='<%# GetRouteUrl(\"EditProductRoute\", new {id \n=product.Id}) %>' class=\"esh-link-item\">Edit\n </a>\n |\n <a runat=\"server\" href=\"~\" class=\"esh-link-item\">Back to list\n </a>\n </div>\n </div>\n</asp:Content>\n```\n\nThe preceding markup's code-behind includes the following code:\n\n```\nusing eShopLegacyWebForms.Models;\nusing eShopLegacyWebForms.Services;\nusing log4net;\nusing System;\nusing System.Web.UI;\nnamespace eShopLegacyWebForms.Catalog\n{\n public partial class Details : System.Web.UI.Page\n {\n private static readonly ILog _log =\nLogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);\n protected CatalogItem product;\n public ICatalogService CatalogService { get; set; }\n protected void Page_Load(object sender, EventArgs e)\n {\n var productId = Convert.ToInt32(Page.RouteData.Values[\"id\"]);\n _log.Info($\"Now loading... /Catalog/Details.aspx?id={productId}\");\n product = CatalogService.FindCatalogItem(productId);\n this.DataBind();\n }\n }\n}\n```\n\nWhen converted to Blazor, the Web Forms page translates to the following code:\n\n```\n@page \"/Catalog/Details/{id:int}\"\n@inject ICatalogService CatalogService\n@inject ILogger<Details> Logger\n<h2 class=\"esh-body-title\">Details</h2>\n<div class=\"container\">\n <div class=\"row\">\n```\n\n```\n <img class=\"col-md-6 esh-picture\" src=\"@($\"/Pics/{_item.PictureFileName}\")\">\n <dl class=\"col-md-6 dl-horizontal\">\n <dt>\n Name\n </dt>\n <dd>\n @_item.Name\n </dd>\n <dt>\n Description\n </dt>\n <dd>\n @_item.Description\n </dd>\n <dt>\n Brand\n </dt>\n <dd>\n @_item.CatalogBrand.Brand\n </dd>\n <dt>\n Type\n </dt>\n <dd>\n @_item.CatalogType.Type\n </dd>\n <dt>\n Price\n </dt>\n <dd>\n @_item.Price\n </dd>\n <dt>\n Picture name\n </dt>\n <dd>\n @_item.PictureFileName\n </dd>\n <dt>\n Stock\n </dt>\n <dd>\n @_item.AvailableStock\n </dd>\n <dt>\n Restock\n </dt>\n```\n\n```\n <dd>\n @_item.RestockThreshold\n </dd>\n <dt>\n Max stock\n </dt>\n <dd>\n @_item.MaxStockThreshold\n </dd>\n </dl>\n </div>\n <div class=\"form-actions no-color esh-link-list\">\n <a href=\"@($\"/Catalog/Edit/{_item.Id}\")\" class=\"esh-link-item\">\n Edit\n </a>\n |\n <a href=\"/\" class=\"esh-link-item\">\n Back to list\n </a>\n </div>\n</div>\n@code {\n private CatalogItem _item;\n [Parameter]\n public int Id { get; set; }\n protected override void OnInitialized()\n {\n Logger.LogInformation(\"Now loading... /Catalog/Details/{Id}\", Id);\n _item = CatalogService.FindCatalogItem(Id);\n }\n}\n```\n\nNotice that the code and markup are in the same file. Any required services are made accessible with the @inject attribute. Per the @page directive, this page can be accessed at the Catalog/Details/{id} route. The value of the route's {id} placeholder has been constrained to an integer. As described in the routing section, unlike Web Forms, a Razor component explicitly states its route and any parameters that are included. Many Web Forms controls may not have exact counterparts in Blazor. There's often an equivalent HTML snippet that will serve the same purpose. For example, the <asp:Label /> control can be replaced with an HTML <label> element.\n\n<span id=\"page-95-0\"></span>**Model validation in Blazor**\n\nIf your Web Forms code includes validation, you can transfer much of what you have with little-to-no changes. A benefit to running in Blazor is that the same validation logic can be run without needing custom JavaScript. Data annotations enable easy model validation.\n\nFor example, the *Create.aspx* page has a data entry form with validation. An example snippet would look like this:\n\n```\n<div class=\"form-group\">\n <label class=\"control-label col-md-2\">Name</label>\n <div class=\"col-md-3\">\n <asp:TextBox ID=\"Name\" runat=\"server\" CssClass=\"form-control\"></asp:TextBox>\n <asp:RequiredFieldValidator runat=\"server\" ControlToValidate=\"Name\"\nDisplay=\"Dynamic\"\n CssClass=\"field-validation-valid text-danger\" ErrorMessage=\"The Name field is \nrequired.\" />\n </div>\n</div>\n```\n\nIn Blazor, the equivalent markup is provided in a *Create.razor* file:\n\n```\n<EditForm Model=\"_item\" OnValidSubmit=\"@...\">\n <DataAnnotationsValidator />\n <div class=\"form-group\">\n <label class=\"control-label col-md-2\">Name</label>\n <div class=\"col-md-3\">\n <InputText class=\"form-control\" @bind-Value=\"_item.Name\" />\n <ValidationMessage For=\"(() => _item.Name)\" />\n </div>\n </div>\n ...\n</EditForm>\n```\n\nThe EditForm context includes validation support and can be wrapped around an input. Data annotations are a common way to add validation. Such validation support can be added via the DataAnnotationsValidator component. For more information on this mechanism, see [ASP.NET Core](https://docs.microsoft.com/aspnet/core/blazor/forms-validation)  [Blazor forms and validation.](https://docs.microsoft.com/aspnet/core/blazor/forms-validation)", "<span id=\"page-96-0\"></span>Migrate configuration": "In a Web Forms project, configuration data is most commonly stored in the *web.config* file. The configuration data is accessed with ConfigurationManager. Services were often required to parse objects. With .NET Framework 4.7.2, composability was added to the configuration via ConfigurationBuilders. These builders allowed developers to add various sources for the configuration that was then composed at run time to retrieve the necessary values.\n\nASP.NET Core introduced a flexible configuration system that allows you to define the configuration source or sources used by your app and deployment. The ConfigurationBuilder infrastructure that you may be using in your Web Forms app was modeled after the concepts used in the ASP.NET Core configuration system.\n\nThe following snippet demonstrates how the Web Forms eShop project uses *web.config* to store configuration values:\n\n```\n<configuration>\n <configSections>\n <section name=\"entityFramework\"\n```\n\n```\ntype=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, \nVersion=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\"\nrequirePermission=\"false\" />\n </configSections>\n <connectionStrings>\n <add name=\"CatalogDBContext\" connectionString=\"Data Source=(localdb)\\MSSQLLocalDB; \nInitial Catalog=Microsoft.eShopOnContainers.Services.CatalogDb; Integrated Security=True; \nMultipleActiveResultSets=True;\" providerName=\"System.Data.SqlClient\" />\n </connectionStrings>\n <appSettings>\n <add key=\"UseMockData\" value=\"true\" />\n <add key=\"UseCustomizationData\" value=\"false\" />\n </appSettings>\n</configuration>\n```\n\nIt's common for secrets, such as database connection strings, to be stored within the *web.config*. The secrets are inevitably persisted in unsecure locations, such as source control. With Blazor on ASP.NET Core, the preceding XML-based configuration is replaced with the following JSON:\n\n```\n{\n \"ConnectionStrings\": {\n \"CatalogDBContext\": \"Data Source=(localdb)\\\\MSSQLLocalDB; Initial \nCatalog=Microsoft.eShopOnContainers.Services.CatalogDb; Integrated Security=True; \nMultipleActiveResultSets=True;\"\n },\n \"UseMockData\": true,\n \"UseCustomizationData\": false\n}\n```\n\nJSON is the default configuration format; however, ASP.NET Core supports many other formats, including XML. There are also several community-supported formats.\n\nYou can access configuration values from the builder in *Program.cs*:\n\n```\nif (builder.Configuration.GetValue<bool>(\"UseMockData\"))\n{\n builder.Services.AddSingleton<ICatalogService, CatalogServiceMock>();\n}\nelse\n{\n builder.Services.AddScoped<ICatalogService, CatalogService>();\n builder.Services.AddScoped<IDatabaseInitializer<CatalogDBContext>,\nCatalogDBInitializer>();\n builder.Services.AddSingleton<CatalogItemHiLoGenerator>();\n builder.Services.AddScoped(_ => new\nCatalogDBContext(builder.Configuration.GetConnectionString(\"CatalogDBContext\")));\n}\n```\n\nBy default, environment variables, JSON files (*appsettings.json* and *appsettings.{Environment}.json*), and command-line options are registered as valid configuration sources in the configuration object. The configuration sources can be accessed via Configuration[key]. A more advanced technique is to bind the configuration data to objects using the options pattern. For more information on configuration and the options pattern, see [Configuration in ASP.NET Core](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/) and [Options pattern in ASP.NET Core,](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options)  respectively.", "<span id=\"page-98-0\"></span>Migrate data access": {"<span id=\"page-98-1\"></span>Architectural changes": "Finally, there are some important architectural differences to consider when migrating to Blazor. Many of these changes are applicable to anything based on .NET Core or ASP.NET Core.\n\nBecause Blazor is built on .NET Core, there are considerations in ensuring support on .NET Core. Some of the major changes include the removal of the following features:\n\n['Multiple AppDomains', 'Remoting', 'Code Access Security (CAS)', 'Security Transparency']\n\nFor more information on techniques to identify necessary changes to support running on .NET Core, see [Port your code from .NET Framework to .NET Core.](https://docs.microsoft.com/en-us/dotnet/core/porting/)\n\nASP.NET Core is a reimagined version of ASP.NET and has some changes that may not initially seem obvious. The main changes are:\n\n[\"No synchronization context, which means there's no HttpContext.Current, Thread.CurrentPrincipal, or other static accessors\", 'No shadow copying', 'No request queue']\n\nMany operations in ASP.NET Core are asynchronous, which allows easier off-loading of I/O-bound tasks. It's important to never block by using Task.Wait() or Task.GetResult(), which can quickly exhaust thread pool resources."}, "<span id=\"page-99-0\"></span>Migration conclusion": "At this point, you've seen many examples of what it takes to move a Web Forms project to Blazor. For a full example, see the [eShopOnBlazor](https://github.com/dotnet-architecture/eShopOnBlazor) project."}}