[
    null,
    null,
    null,
    null,
    "Steve ",
    "Steve ",
    null,
    null,
    "PUBLISHED BY",
    "PUBLISHED BY",
    "Microsoft Developer Division, .NET, and Visual Studio product teams",
    "Microsoft Developer Division, .NET, and Visual Studio product teams",
    "A division of Microsoft Corporation",
    "A division of Microsoft Corporation",
    "One Microsoft Way",
    "One Microsoft Way",
    "Redmond, Washington 98052-6399",
    "Redmond, Washington 98052-6399",
    "Copyright \u00a9 2023 by Microsoft Corporation",
    "Copyright \u00a9 2023 by Microsoft Corporation",
    "All rights reserved. No part of this book",
    "All rights reserved. No part of this book",
    "This book is provided ",
    "This book is provided ",
    "Some examples depicted herein are provided for illustration only and are fictitious. No real association or connection is intended or should be inferred.",
    "Some examples depicted herein are provided for illustration only and are fictitious. No real association or connection is intended or should be inferred.",
    "Microsoft and the trademarks listed at ",
    "Microsoft and the trademarks listed at ",
    "Mac and macOS are trademarks of Apple Inc.",
    "Mac and macOS are trademarks of Apple Inc.",
    "The Docker whale logo is a registered trademark of Docker, Inc. Used by permission.",
    "The Docker whale logo is a registered trademark of Docker, Inc. Used by permission.",
    "All other marks and logos are property of their respective owners.",
    "All other marks and logos are property of their respective owners.",
    "Authors:",
    "Authors:",
    null,
    null,
    "Participants and Reviewers:",
    "Participants and Reviewers:",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "This guide covers ",
    "This guide covers ",
    "This guide",
    "This guide",
    null,
    null,
    ".NET version. ASP.NET Web Forms developers will benefit from this guide but should also read the ",
    ".NET version. ASP.NET Web Forms developers will benefit from this guide but should also read the ",
    "A secondary audience is technical decision-makers planning when to move their apps to .NET 7.",
    "A secondary audience is technical decision-makers planning when to move their apps to .NET 7.",
    "The target audience for this book is .NET developers with large, existing apps that run on ASP.NET MVC and Web API. Apps built on ASP.NET Web Forms are outside of the focus of this book, though much of the information comparing .NET Framework and .NET Core/latest may still be relevant.",
    "The target audience for this book is .NET developers with large, existing apps that run on ASP.NET MVC and Web API. Apps built on ASP.NET Web Forms are outside of the focus of this book, though much of the information comparing .NET Framework and .NET Core/latest may still be relevant.",
    "You can read this book straight through, as we expect many readers to do. This book will provide you first with considerations for whether you should port your app at all. That content is followed by architectural differences between .NET Framework and .NET Core. From there, you",
    "You can read this book straight through, as we expect many readers to do. This book will provide you first with considerations for whether you should port your app at all. That content is followed by architectural differences between .NET Framework and .NET Core. From there, you",
    "Whether or not you choose to start from the first chapter, you can reference any of these chapters to learn about specific concepts:",
    "Whether or not you choose to start from the first chapter, you can reference any of these chapters to learn about specific concepts:",
    "Architectural differences",
    "Architectural differences",
    null,
    null,
    "Sample migration",
    "Sample migration",
    "Deployment scenarios",
    "Deployment scenarios",
    "This guide is available both in ",
    "This guide is available both in ",
    "| References                                               |",
    "| References                                               |",
    "| References                                                            | S  |",
    "| References                                                            | S  |",
    "| Migrate configuration                                                           | 20 |",
    "| Migrate configuration                                                           | 20 |",
    "| References                                              | 32 |",
    "| References                                              | 32 |",
    "| Data access considerations                                       | 63 |",
    "| Data access considerations                                       | 63 |",
    null,
    null,
    ".NET Core and its latest version, .NET 7, represent a revolutionary step forward from .NET Framework. It offers a host of advantages over .NET Framework across the board from productivity to performance, from cross-platform support to developer satisfaction. ASP.NET Core was even voted the most-loved web framework (tied with Svelte) in the ",
    ".NET Core and its latest version, .NET 7, represent a revolutionary step forward from .NET Framework. It offers a host of advantages over .NET Framework across the board from productivity to performance, from cross-platform support to developer satisfaction. ASP.NET Core was even voted the most-loved web framework (tied with Svelte) in the ",
    "Even before .NET 7 shipped, Microsoft was clear: ",
    "Even before .NET 7 shipped, Microsoft was clear: ",
    "New apps should be built on .NET Core. .NET Core is where future investments in .NET will happen. Existing apps are safe to remain on .NET Framework which will be supported. Existing apps that want to take advantage of the new features in .NET should consider moving to .NET Core. As we plan into the future, we will be bringing in even more capabilities to the platform.",
    "New apps should be built on .NET Core. .NET Core is where future investments in .NET will happen. Existing apps are safe to remain on .NET Framework which will be supported. Existing apps that want to take advantage of the new features in .NET should consider moving to .NET Core. As we plan into the future, we will be bringing in even more capabilities to the platform.",
    "Today, .NET 7 is what new apps should target, and if you",
    "Today, .NET 7 is what new apps should target, and if you",
    "However, upgrading your app to ASP.NET Core will require some effort. That effort should be balanced against business value and goals. .NET Framework apps have a long life ahead of them, with support built into Windows for the foreseeable future. What are some of the questions you should consider before deciding migration to .NET 7 is appropriate? What are the expected advantages? What are the tradeoffs? How much effort is involved? These obvious questions are just the beginning, but make for a great starting point as teams consider how to support their customers",
    "However, upgrading your app to ASP.NET Core will require some effort. That effort should be balanced against business value and goals. .NET Framework apps have a long life ahead of them, with support built into Windows for the foreseeable future. What are some of the questions you should consider before deciding migration to .NET 7 is appropriate? What are the expected advantages? What are the tradeoffs? How much effort is involved? These obvious questions are just the beginning, but make for a great starting point as teams consider how to support their customers",
    "Is migration to .NET 7 appropriate?",
    "Is migration to .NET 7 appropriate?",
    "When does it make sense to remain on .NET Framework?",
    "When does it make sense to remain on .NET Framework?",
    "Should apps target ASP.NET Core 2.1 as a stepping stone?",
    "Should apps target ASP.NET Core 2.1 as a stepping stone?",
    "How should teams choose the right .NET version to target?",
    "How should teams choose the right .NET version to target?",
    "What strategies are recommended for incremental migration of large apps?",
    "What strategies are recommended for incremental migration of large apps?",
    "What deployment strategies should be considered when porting to .NET 7?",
    "What deployment strategies should be considered when porting to .NET 7?",
    "Where can we find additional resources?",
    "Where can we find additional resources?",
    "This introductory chapter addresses all of these questions and more before moving on to more specific and technical considerations in future chapters.",
    "This introductory chapter addresses all of these questions and more before moving on to more specific and technical considerations in future chapters.",
    null,
    null,
    null,
    null,
    "The most fundamental question teams must answer when it comes to porting their apps to .NET Core is, should they port at all? In some cases, the best path forward is to remain on .NET Framework using ASP.NET MVC and/or Web API. This chapter considers reasons why moving to .NET Core makes sense. The chapter also considers scenarios and counterpoints for staying on .NET Framework.",
    "The most fundamental question teams must answer when it comes to porting their apps to .NET Core is, should they port at all? In some cases, the best path forward is to remain on .NET Framework using ASP.NET MVC and/or Web API. This chapter considers reasons why moving to .NET Core makes sense. The chapter also considers scenarios and counterpoints for staying on .NET Framework.",
    "Let",
    "Let",
    "Apps built on .NET Core are truly cross-platform and can run on Windows, Linux, and macOS. Not only can your developers use whatever hardware they want, but you can also host your app anywhere. Examples range from local IIS to Azure in the cloud or from Linux Docker containers to IoT devices.",
    "Apps built on .NET Core are truly cross-platform and can run on Windows, Linux, and macOS. Not only can your developers use whatever hardware they want, but you can also host your app anywhere. Examples range from local IIS to Azure in the cloud or from Linux Docker containers to IoT devices.",
    "Apps built with .NET Core are running on ",
    "Apps built with .NET Core are running on ",
    "For the above reasons and others, .NET Core apps are well-suited to running in cloud hosting environments. Lightweight and fast, .NET Core apps can be deployed to Azure App Services or containers and scaled horizontally as needed to meet immediate system demand.",
    "For the above reasons and others, .NET Core apps are well-suited to running in cloud hosting environments. Lightweight and fast, .NET Core apps can be deployed to Azure App Services or containers and scaled horizontally as needed to meet immediate system demand.",
    "For many apps, while they",
    "For many apps, while they",
    "ASP.NET Core is modular, using NuGet packages as a first-class part of the framework. Apps built for .NET Core all support dependency injection, making it easy to compose solutions from whatever implementations are needed for a given environment. Building microservices with .NET Core is easier than with ASP.NET MVC with its dependency on IIS, which opens up additional options to break up large apps into smaller modules.",
    "ASP.NET Core is modular, using NuGet packages as a first-class part of the framework. Apps built for .NET Core all support dependency injection, making it easy to compose solutions from whatever implementations are needed for a given environment. Building microservices with .NET Core is easier than with ASP.NET MVC with its dependency on IIS, which opens up additional options to break up large apps into smaller modules.",
    "Staying on a modern, actively developed technology stack has a host of advantages. New features and C# language features will only be added to .NET Core. The .NET Framework has had its last release with version 4.8, and versions of C# beyond 8 won",
    "Staying on a modern, actively developed technology stack has a host of advantages. New features and C# language features will only be added to .NET Core. The .NET Framework has had its last release with version 4.8, and versions of C# beyond 8 won",
    "There are many compelling reasons to consider migrating to .NET Core, which presumably is why you",
    "There are many compelling reasons to consider migrating to .NET Core, which presumably is why you",
    "The biggest reason to stay on .NET Framework is when an app isn",
    "The biggest reason to stay on .NET Framework is when an app isn",
    "Application domains (AppDomains) isolate apps from one another. AppDomains require runtime support and can be expensive. Creating additional app domains isn",
    "Application domains (AppDomains) isolate apps from one another. AppDomains require runtime support and can be expensive. Creating additional app domains isn",
    ".NET Core and .NET 5+ support WCF clients. Server-side WCF is possible through ",
    ".NET Core and .NET 5+ support WCF clients. Server-side WCF is possible through ",
    "There is a ",
    "There is a ",
    "To learn more about migrating from WCF to gRPC, consult the ",
    "To learn more about migrating from WCF to gRPC, consult the ",
    ".NET Remoting was identified as a problematic architecture. It",
    ".NET Remoting was identified as a problematic architecture. It",
    "Neither of these technologies are supported by .NET Core. Instead, the recommendation is to use security boundaries provided by the operating system. For example, virtualization, containers, or user accounts. Run processes with the minimal set of privileges necessary.",
    "Neither of these technologies are supported by .NET Core. Instead, the recommendation is to use security boundaries provided by the operating system. For example, virtualization, containers, or user accounts. Run processes with the minimal set of privileges necessary.",
    null,
    null,
    "ASP.NET Core 2.1 is an interesting release because it",
    "ASP.NET Core 2.1 is an interesting release because it",
    "ASP.NET Core 2.2 and earlier supported both .NET Core and .NET Framework runtimes. Does it make sense to migrate some or all of an app to ASP.NET Core 2.1 as a stepping stone, before porting over completely to .NET Core? Apps, or subsets of apps, could see their front-end ASP.NET logic ported to use ASP.NET Core, while still consuming .NET Framework libraries for business logic and infrastructure consumption. This approach may make sense when there",
    "ASP.NET Core 2.2 and earlier supported both .NET Core and .NET Framework runtimes. Does it make sense to migrate some or all of an app to ASP.NET Core 2.1 as a stepping stone, before porting over completely to .NET Core? Apps, or subsets of apps, could see their front-end ASP.NET logic ported to use ASP.NET Core, while still consuming .NET Framework libraries for business logic and infrastructure consumption. This approach may make sense when there",
    "The main benefit of porting just the front-end web layer to ASP.NET Core 2.1 is that the existing .NET class libraries can remain as is during the initial migration. They may be in continued use by other .NET apps or simply don",
    "The main benefit of porting just the front-end web layer to ASP.NET Core 2.1 is that the existing .NET class libraries can remain as is during the initial migration. They may be in continued use by other .NET apps or simply don",
    "If you have an existing app that may use this strategy, some things you can do today to help prepare for the process are to move as much business logic, data access, and other non-UI logic out of the ASP.NET projects and into separate class libraries as possible. It will also help if you have automated",
    "If you have an existing app that may use this strategy, some things you can do today to help prepare for the process are to move as much business logic, data access, and other non-UI logic out of the ASP.NET projects and into separate class libraries as possible. It will also help if you have automated",
    "test coverage of your system, so that you can verify behavior remains consistent before and after the migration.",
    "test coverage of your system, so that you can verify behavior remains consistent before and after the migration.",
    "If your app is so large that you can",
    "If your app is so large that you can",
    "Keep in mind that ASP.NET Core 2.1 was the last LTS release of .NET Core that supported running on .NET Framework and consuming .NET Framework libraries. Although the release is now unsupported on .NET Core, it continues to be supported for use with .NET Framework. It will remain supported for as long as the specific .NET Framework version is supported. For more information, see ",
    "Keep in mind that ASP.NET Core 2.1 was the last LTS release of .NET Core that supported running on .NET Framework and consuming .NET Framework libraries. Although the release is now unsupported on .NET Core, it continues to be supported for use with .NET Framework. It will remain supported for as long as the specific .NET Framework version is supported. For more information, see ",
    null,
    null,
    "The largest consideration for most organizations when choosing which version of .NET to target is the support lifecycle. Long Term Support (LTS) releases ship less frequently but have a longer support window than Standard Term Support (STS) releases. Currently, LTS releases are scheduled to ship every other year. Customers can choose which releases to target, and can install different releases of .NET side by side on the same machine. LTS releases will receive only critical and compatible fixes throughout their lifecycle. STS releases will receive these same fixes and will also be updated with compatible innovations and features. LTS releases are supported for three years after their initial release. STS releases are supported for six months after a subsequent STS or LTS release.",
    "The largest consideration for most organizations when choosing which version of .NET to target is the support lifecycle. Long Term Support (LTS) releases ship less frequently but have a longer support window than Standard Term Support (STS) releases. Currently, LTS releases are scheduled to ship every other year. Customers can choose which releases to target, and can install different releases of .NET side by side on the same machine. LTS releases will receive only critical and compatible fixes throughout their lifecycle. STS releases will receive these same fixes and will also be updated with compatible innovations and features. LTS releases are supported for three years after their initial release. STS releases are supported for six months after a subsequent STS or LTS release.",
    ".NET 7 is the latest STS release; .NET 6 is the latest LTS release.",
    ".NET 7 is the latest STS release; .NET 6 is the latest LTS release.",
    "Customers looking to migrate a large .NET Framework app to .NET today may be looking for a stable destination, given that they haven",
    "Customers looking to migrate a large .NET Framework app to .NET today may be looking for a stable destination, given that they haven",
    "Other customers may want to ensure they",
    "Other customers may want to ensure they",
    "In either case, there is very little difference in the migration process. This book assumes .NET Framework apps will be upgraded to .NET 7.",
    "In either case, there is very little difference in the migration process. This book assumes .NET Framework apps will be upgraded to .NET 7.",
    null,
    null,
    "The biggest challenge with migrating any large app is determining how to break the process into smaller tasks. There are several strategies that can be applied for this purpose, including breaking the app into horizontal layers such as UI, data access, business logic, or breaking up the app into separate, smaller apps. Another strategy is to upgrade some or all of the app to different framework versions on the way to a recent .NET Core release. One approach you could use is to migrate ",
    "The biggest challenge with migrating any large app is determining how to break the process into smaller tasks. There are several strategies that can be applied for this purpose, including breaking the app into horizontal layers such as UI, data access, business logic, or breaking up the app into separate, smaller apps. Another strategy is to upgrade some or all of the app to different framework versions on the way to a recent .NET Core release. One approach you could use is to migrate ",
    "One successful approach to migrating is to identify vertical slices of functionality and migrate them to the target platform one by one. The first step is to create a new ASP.NET Core 7 app. Next, identify the individual page or API endpoint that will be migrated first. Build out just the necessary functionality to support this one route in the new ASP.NET Core app. Then use HTTP rewriting and/or a reverse proxy to start sending requests for these pages or endpoints to the new app rather than the ASP.NET app. This approach is well-suited to API projects, but can also work for many MVC apps.",
    "One successful approach to migrating is to identify vertical slices of functionality and migrate them to the target platform one by one. The first step is to create a new ASP.NET Core 7 app. Next, identify the individual page or API endpoint that will be migrated first. Build out just the necessary functionality to support this one route in the new ASP.NET Core app. Then use HTTP rewriting and/or a reverse proxy to start sending requests for these pages or endpoints to the new app rather than the ASP.NET app. This approach is well-suited to API projects, but can also work for many MVC apps.",
    "When migrating slice by slice, the entire stack of the individual API endpoint or requested route is recreated in the new project or solution. The very first such slice typically requires the most effort, since it will typically need several projects to be created and decisions to be made about data access and solution organization. Once the first slice",
    "When migrating slice by slice, the entire stack of the individual API endpoint or requested route is recreated in the new project or solution. The very first such slice typically requires the most effort, since it will typically need several projects to be created and decisions to be made about data access and solution organization. Once the first slice",
    "Some specific guidance on how to follow this strategy using IIS is covered in Chapter 5, Deployment Scenarios.",
    "Some specific guidance on how to follow this strategy using IIS is covered in Chapter 5, Deployment Scenarios.",
    "Consider the challenge of migrating a large ASP.NET 4.5 app. One approach is to migrate the entire app directly from .NET Framework 4.5 to .NET 7. However, this approach needs to account for every breaking change between the two frameworks and versions, which are substantial. Performing this work on one project at a time provides a set of stepping stones so that the entire solution doesn",
    "Consider the challenge of migrating a large ASP.NET 4.5 app. One approach is to migrate the entire app directly from .NET Framework 4.5 to .NET 7. However, this approach needs to account for every breaking change between the two frameworks and versions, which are substantial. Performing this work on one project at a time provides a set of stepping stones so that the entire solution doesn",
    "One piece of the .NET ecosystem that helps with interoperability between different .NET frameworks is ",
    "One piece of the .NET ecosystem that helps with interoperability between different .NET frameworks is ",
    "One approach to incrementally upgrade a .NET Framework 4.5 system layer-by-layer is to first update its class library dependencies to .NET Framework 4.8. Then, modify these libraries to be .NET Standard class libraries. Use multi-targeting and conditional compilation, if necessary. This step can be helpful",
    "One approach to incrementally upgrade a .NET Framework 4.5 system layer-by-layer is to first update its class library dependencies to .NET Framework 4.8. Then, modify these libraries to be .NET Standard class libraries. Use multi-targeting and conditional compilation, if necessary. This step can be helpful",
    "in scenarios where app dependencies require .NET Framework and cannot easily be ported directly to use .NET Standard and .NET Core. Since .NET Framework libraries can be consumed by ASP.NET Core 2.1 apps, the next step is to migrate some or all of the web functionality of the app to ASP.NET Core 2.1 (as described in the ",
    "in scenarios where app dependencies require .NET Framework and cannot easily be ported directly to use .NET Standard and .NET Core. Since .NET Framework libraries can be consumed by ASP.NET Core 2.1 apps, the next step is to migrate some or all of the web functionality of the app to ASP.NET Core 2.1 (as described in the ",
    "Once the app is running on ASP.NET Core 2.1, migrating it to .NET 7 in isolation is relatively straightforward. The most likely challenge during this step is updating incompatible dependencies to support .NET Core and possibly higher versions of .NET Standard. For apps that don",
    "Once the app is running on ASP.NET Core 2.1, migrating it to .NET 7 in isolation is relatively straightforward. The most likely challenge during this step is updating incompatible dependencies to support .NET Core and possibly higher versions of .NET Standard. For apps that don",
    ".NET 7 is the latest version of .NET and will be supported until six months after the next STS or LTS release (scheduled for November 2023) - so most likely support will last at least until May 2024. Many teams looking to migrate today will choose to upgrade to .NET 7.",
    ".NET 7 is the latest version of .NET and will be supported until six months after the next STS or LTS release (scheduled for November 2023) - so most likely support will last at least until May 2024. Many teams looking to migrate today will choose to upgrade to .NET 7.",
    "Instead of a ",
    "Instead of a ",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "<span id=\"page-14-1\">",
    "<span id=\"page-14-1\">",
    "This book offers guidance for migrating large ASP.NET MVC and Web API apps to .NET Core. Some of these ASP.NET apps may also include Web Forms (",
    "This book offers guidance for migrating large ASP.NET MVC and Web API apps to .NET Core. Some of these ASP.NET apps may also include Web Forms (",
    "Web Forms will continue to be supported for quite some time. One option may be to keep this functionality in an ASP.NET 4.x app.",
    "Web Forms will continue to be supported for quite some time. One option may be to keep this functionality in an ASP.NET 4.x app.",
    "The less code in your ASP.NET Web Forms pages, the better. When possible, keep business logic and other concerns like data access in separate classes, ideally in separate class libraries. These class libraries can be ported to .NET Standard and consumed by any ASP.NET Core app.",
    "The less code in your ASP.NET Web Forms pages, the better. When possible, keep business logic and other concerns like data access in separate classes, ideally in separate class libraries. These class libraries can be ported to .NET Standard and consumed by any ASP.NET Core app.",
    "Consider the choice between implementing logic in Web Forms or in the browser with the help of API calls. Favor the latter. Migrating APIs to ASP.NET Core is supported. Client-side behavior should be independent of the server-side stack your app is using. Using this approach has the added benefit of providing a more responsive user experience.",
    "Consider the choice between implementing logic in Web Forms or in the browser with the help of API calls. Favor the latter. Migrating APIs to ASP.NET Core is supported. Client-side behavior should be independent of the server-side stack your app is using. Using this approach has the added benefit of providing a more responsive user experience.",
    "Blazor lets you build interactive web UIs with C# instead of JavaScript. It can run on the server or in the browser using WebAssembly. ASP.NET Web Forms apps may be ported page-by-page to Blazor apps. For more information on porting Web Forms apps to Blazor, see ",
    "Blazor lets you build interactive web UIs with C# instead of JavaScript. It can run on the server or in the browser using WebAssembly. ASP.NET Web Forms apps may be ported page-by-page to Blazor apps. For more information on porting Web Forms apps to Blazor, see ",
    "Migrating directly from ASP.NET Web Forms to ASP.NET Core isn",
    "Migrating directly from ASP.NET Web Forms to ASP.NET Core isn",
    "Keeping non-web functionality out of your projects.",
    "Keeping non-web functionality out of your projects.",
    "Using web APIs wherever possible.",
    "Using web APIs wherever possible.",
    "Considering Blazor as an option for a more modern UI.",
    "Considering Blazor as an option for a more modern UI.",
    null,
    null,
    "<span id=\"page-15-4\">",
    "<span id=\"page-15-4\">",
    "One consideration as you plan the migration of your large ASP.NET app to ASP.NET Core is how you",
    "One consideration as you plan the migration of your large ASP.NET app to ASP.NET Core is how you",
    "Because .NET Core runs on Linux, you",
    "Because .NET Core runs on Linux, you",
    "Your organization has infrastructure or expertise.",
    "Your organization has infrastructure or expertise.",
    "Hosting providers offer attractive features or pricing for Linux-based hosting.",
    "Hosting providers offer attractive features or pricing for Linux-based hosting.",
    ".NET Core opens the door to these options.",
    ".NET Core opens the door to these options.",
    "Most organizations today are using cloud platforms for at least some of their software capabilities. With an app migration to .NET Core, it",
    "Most organizations today are using cloud platforms for at least some of their software capabilities. With an app migration to .NET Core, it",
    "Learn more about cloud native app development in this free e-book, ",
    "Learn more about cloud native app development in this free e-book, ",
    "Modern apps often leverage containers as a means of reducing variation between hosting environments. By deploying an app to a particular container, the container-hosted app will run the same whether it",
    "Modern apps often leverage containers as a means of reducing variation between hosting environments. By deploying an app to a particular container, the container-hosted app will run the same whether it",
    "Migrating large .NET Framework apps to .NET Core often requires a substantial effort. Most organizations will want to be able to break this effort up in some fashion, so that pieces of the app can be migrated and deployed in production before the entire migration is complete. Running both the original ASP.NET app and its newly-migrated ASP.NET Core sub-app(s) side by side is a frequently cited goal. This can be achieved through a number of mechanisms including leveraging IIS routing, which is covered in chapter 5. Other options include leveraging app gateways or cloud design patterns like ",
    "Migrating large .NET Framework apps to .NET Core often requires a substantial effort. Most organizations will want to be able to break this effort up in some fashion, so that pieces of the app can be migrated and deployed in production before the entire migration is complete. Running both the original ASP.NET app and its newly-migrated ASP.NET Core sub-app(s) side by side is a frequently cited goal. This can be achieved through a number of mechanisms including leveraging IIS routing, which is covered in chapter 5. Other options include leveraging app gateways or cloud design patterns like ",
    "You can continue hosting your apps on IIS running on Windows. This is a fine option for customers who want to take advantage of ASP.NET Core features without changing their current deployment model. While moving to ASP.NET Core provides more options in terms of how and where to deploy your apps, it doesn",
    "You can continue hosting your apps on IIS running on Windows. This is a fine option for customers who want to take advantage of ASP.NET Core features without changing their current deployment model. While moving to ASP.NET Core provides more options in terms of how and where to deploy your apps, it doesn",
    "You can host apps side-by-side apps on Windows using any combination of Kestrel, HTTP.sys, and IIS hosts, in addition to Docker containers, if needed. If your app requires a combination of Windows and Linux services, hosting on a Windows server with ",
    "You can host apps side-by-side apps on Windows using any combination of Kestrel, HTTP.sys, and IIS hosts, in addition to Docker containers, if needed. If your app requires a combination of Windows and Linux services, hosting on a Windows server with ",
    "\u2022 ",
    "\u2022 ",
    null,
    null,
    "<span id=\"page-17-0\">",
    "<span id=\"page-17-0\">",
    "As you",
    "As you",
    "The official documentation website, ",
    "The official documentation website, ",
    "Because .NET Core is an open-source project, many issues are discovered, reported, discussed, and fixed on GitHub. Microsoft has several GitHub organizations in which you",
    "Because .NET Core is an open-source project, many issues are discovered, reported, discussed, and fixed on GitHub. Microsoft has several GitHub organizations in which you",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "If you run into problems with your migration, these GitHub repositories are a good place to report them. The product teams watch the issues and typically respond quickly to bug reports (though ",
    "If you run into problems with your migration, these GitHub repositories are a good place to report them. The product teams watch the issues and typically respond quickly to bug reports (though ",
    null,
    null,
    "YouTube has a huge amount of .NET and .NET Core video content, which may include useful tutorials or walkthroughs covering any scenario you may encounter. Consider searching it separately if your other efforts to find help online come up short. Here are a few good places to get started:",
    "YouTube has a huge amount of .NET and .NET Core video content, which may include useful tutorials or walkthroughs covering any scenario you may encounter. Consider searching it separately if your other efforts to find help online come up short. Here are a few good places to get started:",
    null,
    null,
    null,
    null,
    "You",
    "You",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "There are many architectural differences between ASP.NET MVC on .NET Framework and ASP.NET Core. It",
    "There are many architectural differences between ASP.NET MVC on .NET Framework and ASP.NET Core. It",
    ".NET Core is a cross-platform rewrite of .NET Framework. There are many ",
    ".NET Core is a cross-platform rewrite of .NET Framework. There are many ",
    "ASP.NET MVC apps lived entirely within Internet Information Server (IIS), the primary web server available on Windows operating systems. Unlike ASP.NET MVC, ASP.NET Core apps are executable apps. You can run them from the command line, using dotnet run. They have an entry point method like all C# programs, typically public static void Main() or a similar variation (perhaps with arguments or async support). This is perhaps the biggest architectural difference between ASP.NET Core and ASP.NET MVC, and is one of several differences that allows ASP.NET Core to run on non-Windows systems.",
    "ASP.NET MVC apps lived entirely within Internet Information Server (IIS), the primary web server available on Windows operating systems. Unlike ASP.NET MVC, ASP.NET Core apps are executable apps. You can run them from the command line, using dotnet run. They have an entry point method like all C# programs, typically public static void Main() or a similar variation (perhaps with arguments or async support). This is perhaps the biggest architectural difference between ASP.NET Core and ASP.NET MVC, and is one of several differences that allows ASP.NET Core to run on non-Windows systems.",
    "Hosted within IIS, ASP.NET apps rely on IIS to instantiate certain objects and call certain methods when a request arrives. ASP.NET creates an instance of the ",
    "Hosted within IIS, ASP.NET apps rely on IIS to instantiate certain objects and call certain methods when a request arrives. ASP.NET creates an instance of the ",
    "Many NuGet packages for ASP.NET MVC and Web API use the ",
    "Many NuGet packages for ASP.NET MVC and Web API use the ",
    "It",
    "It",
    "If you need to run code when your ASP.NET MVC app starts up, it will typically use one of these approaches.",
    "If you need to run code when your ASP.NET MVC app starts up, it will typically use one of these approaches.",
    "As noted previously, ASP.NET Core apps are standalone programs. As such, they typically include a ",
    "As noted previously, ASP.NET Core apps are standalone programs. As such, they typically include a ",
    null,
    null,
    "The code shown in Figure 2-1 uses a builder to configure the host and its services. Then, it creates the request pipeline for the app, which controls how every request to the app is handled.",
    "The code shown in Figure 2-1 uses a builder to configure the host and its services. Then, it creates the request pipeline for the app, which controls how every request to the app is handled.",
    "Previous versions of .NET would use a separate ",
    "Previous versions of .NET would use a separate ",
    "In addition to code related to configuring the app",
    "In addition to code related to configuring the app",
    "The IHostedService interface just exposes two methods, StartAsync and StopAsync. You register the interface when configuring the app",
    "The IHostedService interface just exposes two methods, StartAsync and StopAsync. You register the interface when configuring the app",
    "Teams looking to migrate their apps from ASP.NET MVC to ASP.NET Core need to identify what code is being run when their app starts up and determine the appropriate location for such code in their ASP.NET Core app. For custom code needed to run when the app starts up, especially async code, the recommended approach is typically to put such code into IHostedService implementations.",
    "Teams looking to migrate their apps from ASP.NET MVC to ASP.NET Core need to identify what code is being run when their app starts up and determine the appropriate location for such code in their ASP.NET Core app. For custom code needed to run when the app starts up, especially async code, the recommended approach is typically to put such code into IHostedService implementations.",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "<span id=\"page-21-2\">",
    "<span id=\"page-21-2\">",
    "ASP.NET MVC apps are hosted in IIS, and may rely on IIS configuration for their behavior. This often includes ",
    "ASP.NET MVC apps are hosted in IIS, and may rely on IIS configuration for their behavior. This often includes ",
    null,
    null,
    "Kestrel does not have an equivalent to IIS modules (though apps hosted in IIS can still take advantage of IIS modules). To achieve equivalent behavior, ",
    "Kestrel does not have an equivalent to IIS modules (though apps hosted in IIS can still take advantage of IIS modules). To achieve equivalent behavior, ",
    null,
    null,
    null,
    null,
    null,
    null,
    "Most web apps involve a combination of server-side logic and static files that must be sent to the client as-is. How should your migration from ASP.NET MVC to ASP.NET Core handle serving static files?",
    "Most web apps involve a combination of server-side logic and static files that must be sent to the client as-is. How should your migration from ASP.NET MVC to ASP.NET Core handle serving static files?",
    "ASP.NET MVC apps, hosted by IIS, typically host static files directly from the app. ASP.NET MVC supports placing static files side by side with files that should be kept private on the server. IIS and ASP.NET require explicitly restricting certain files or file extensions from being served from the folder in which an ASP.NET app is hosted.",
    "ASP.NET MVC apps, hosted by IIS, typically host static files directly from the app. ASP.NET MVC supports placing static files side by side with files that should be kept private on the server. IIS and ASP.NET require explicitly restricting certain files or file extensions from being served from the folder in which an ASP.NET app is hosted.",
    "For many static files, using a content delivery network (CDN) is a good practice. ",
    "For many static files, using a content delivery network (CDN) is a good practice. ",
    "It may be surprising, but ASP.NET Core doesn",
    "It may be surprising, but ASP.NET Core doesn",
    "With static files middleware configured, an ASP.NET Core app will serve all files located in a certain folder (typically ",
    "With static files middleware configured, an ASP.NET Core app will serve all files located in a certain folder (typically ",
    "Because support for static files uses middleware, any other middleware can be applied as part of the same request pipeline. Examples of middleware include authentication, caching, and compression.",
    "Because support for static files uses middleware, any other middleware can be applied as part of the same request pipeline. Examples of middleware include authentication, caching, and compression.",
    "Of course, CDNs remain a good choice for ASP.NET Core apps for all the same reasons they",
    "Of course, CDNs remain a good choice for ASP.NET Core apps for all the same reasons they",
    null,
    null,
    null,
    null,
    "Although dependency injection (DI) isn",
    "Although dependency injection (DI) isn",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "If your ASP.NET MVC app isn",
    "If your ASP.NET MVC app isn",
    "If your app does use DI, then probably your best course of action is to see if the container you",
    "If your app does use DI, then probably your best course of action is to see if the container you",
    "Either way, you should consider using the built-in support for DI that ships with ASP.NET Core, as it may meet your app",
    "Either way, you should consider using the built-in support for DI that ships with ASP.NET Core, as it may meet your app",
    "ASP.NET Core assumes apps will use DI. It",
    "ASP.NET Core assumes apps will use DI. It",
    "In addition to using the default implementation, apps can still use custom containers. The ",
    "In addition to using the default implementation, apps can still use custom containers. The ",
    "DI is fundamental to ASP.NET Core. If your team isn",
    "DI is fundamental to ASP.NET Core. If your team isn",
    null,
    null,
    null,
    null,
    "If your existing ASP.NET MVC or Web API app uses OWIN/Katana, you",
    "If your existing ASP.NET MVC or Web API app uses OWIN/Katana, you",
    null,
    null,
    "If your app is using custom HTTP modules or HTTP handlers, you",
    "If your app is using custom HTTP modules or HTTP handlers, you",
    "ASP.NET Core defines a request pipeline in each app",
    "ASP.NET Core defines a request pipeline in each app",
    "Behavior in an ASP.NET MVC app that uses HTTP modules is probably best suited to ",
    "Behavior in an ASP.NET MVC app that uses HTTP modules is probably best suited to ",
    "Many .NET apps reference the current request",
    "Many .NET apps reference the current request",
    "Similarly, ASP.NET Core filters pass a context argument to their methods, from which the current HttpContext can be accessed:",
    "Similarly, ASP.NET Core filters pass a context argument to their methods, from which the current HttpContext can be accessed:",
    "If you have components or services that require access to HttpContext, rather than using a static call like HttpContext.Current you should instead use constructor dependency injection and the ",
    "If you have components or services that require access to HttpContext, rather than using a static call like HttpContext.Current you should instead use constructor dependency injection and the ",
    "This approach eliminates the static coupling of the method to the current context while providing access in a testable fashion.",
    "This approach eliminates the static coupling of the method to the current context while providing access in a testable fashion.",
    null,
    null,
    "<span id=\"page-25-1\">",
    "<span id=\"page-25-1\">",
    "How configuration values are stored and read changed dramatically between ASP.NET and ASP.NET Core.",
    "How configuration values are stored and read changed dramatically between ASP.NET and ASP.NET Core.",
    "In ASP.NET apps, configuration uses the built-in .NET configuration files, ",
    "In ASP.NET apps, configuration uses the built-in .NET configuration files, ",
    "Configuration in a .NET Framework app is accessed using the",
    "Configuration in a .NET Framework app is accessed using the",
    "System.Configuration.ConfigurationManager class. Unfortunately, this class provides static access to the configuration elements. As a result, very few ASP.NET MVC apps tend to abstract access to their configuration settings or inject them where needed. Instead, most .NET Framework apps tend to directly access the configuration system anywhere the app needs to use a setting.",
    "System.Configuration.ConfigurationManager class. Unfortunately, this class provides static access to the configuration elements. As a result, very few ASP.NET MVC apps tend to abstract access to their configuration settings or inject them where needed. Instead, most .NET Framework apps tend to directly access the configuration system anywhere the app needs to use a setting.",
    "Typical ASP.NET MVC configuration access:",
    "Typical ASP.NET MVC configuration access:",
    "In ASP.NET Core apps, configuration is, itself, configurable. However, most apps use a set of defaults provided as part of the standard project templates and the ConfigureWebHostDefaults method used in them. The default settings use JSON formatted files, with the ability to override settings in the base ",
    "In ASP.NET Core apps, configuration is, itself, configurable. However, most apps use a set of defaults provided as part of the standard project templates and the ConfigureWebHostDefaults method used in them. The default settings use JSON formatted files, with the ability to override settings in the base ",
    "Accessing configuration values can be done in many ways in .NET Core. Because dependency injection is built into .NET Core, configuration values are generally accessed through an interface that is injected into classes that need them. This can involve passing a interface like ",
    "Accessing configuration values can be done in many ways in .NET Core. Because dependency injection is built into .NET Core, configuration values are generally accessed through an interface that is injected into classes that need them. This can involve passing a interface like ",
    "Figure 2-2 shows how to pass IConfiguration into a Razor Page and access configuration settings from it:",
    "Figure 2-2 shows how to pass IConfiguration into a Razor Page and access configuration settings from it:",
    null,
    null,
    "Using the ",
    "Using the ",
    null,
    null,
    "For the options pattern to work, the options type must be configured in ConfigureServices when the app starts up:",
    "For the options pattern to work, the options type must be configured in ConfigureServices when the app starts up:",
    "When considering how to port an app",
    "When considering how to port an app",
    "Once all settings in the config files have been cataloged, the next step should be to identify where and how the settings are used in the app itself. If some settings aren",
    "Once all settings in the config files have been cataloged, the next step should be to identify where and how the settings are used in the app itself. If some settings aren",
    "If you",
    "If you",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "Routing is responsible for mapping incoming browser requests to particular controller actions (or Razor Pages handlers). This section covers how routing differs between ASP.NET MVC (and Web API) and ASP.NET Core (MVC, Razor Pages, and otherwise).",
    "Routing is responsible for mapping incoming browser requests to particular controller actions (or Razor Pages handlers). This section covers how routing differs between ASP.NET MVC (and Web API) and ASP.NET Core (MVC, Razor Pages, and otherwise).",
    "ASP.NET MVC offers two approaches to routing:",
    "ASP.NET MVC offers two approaches to routing:",
    "The route table, which is a collection of routes that can be used to match incoming requests to controller actions.",
    "The route table, which is a collection of routes that can be used to match incoming requests to controller actions.",
    "Attribute routing, which performs the same function but is achieved by decorating the actions themselves, rather than editing a global route table.",
    "Attribute routing, which performs the same function but is achieved by decorating the actions themselves, rather than editing a global route table.",
    "The route table is configured when the app starts up. Typically, a static method call is used to configure the global route collection, like so:",
    "The route table is configured when the app starts up. Typically, a static method call is used to configure the global route collection, like so:",
    "In the preceding code, the route table is managed by the RouteCollection type, which is used to add new routes with MapRoute. Routes are named and include a route string, which can include parameters for controllers, actions, areas, and other placeholders. If an app follows a standard convention, most of its actions can be handled by this single default route, with any exceptions to this convention configured using additional routes.",
    "In the preceding code, the route table is managed by the RouteCollection type, which is used to add new routes with MapRoute. Routes are named and include a route string, which can include parameters for controllers, actions, areas, and other placeholders. If an app follows a standard convention, most of its actions can be handled by this single default route, with any exceptions to this convention configured using additional routes.",
    "Routes that are defined with their actions may be easier to discover and reason about than routes defined in an external location. Using attribute routing, an individual action method can have its route defined with a ",
    "Routes that are defined with their actions may be easier to discover and reason about than routes defined in an external location. Using attribute routing, an individual action method can have its route defined with a ",
    null,
    null,
    "Setting up attribute routing requires adding one line to the default route table configuration:",
    "Setting up attribute routing requires adding one line to the default route table configuration:",
    "Attribute routing can take advantage of route constraints, both built-in and custom, and supports named routes and areas using the ",
    "Attribute routing can take advantage of route constraints, both built-in and custom, and supports named routes and areas using the ",
    "AreaRegistration.RegisterAllAreas();",
    "AreaRegistration.RegisterAllAreas();",
    null,
    null,
    "As shown in the preceding code, attribute routing may be combined with convention-based routing in Web API apps.",
    "As shown in the preceding code, attribute routing may be combined with convention-based routing in Web API apps.",
    "In addition to attribute routing, ",
    "In addition to attribute routing, ",
    "Given the above controller, an HTTP GET request to localhost:123/products/ matches the GetAll action. An HTTP GET request to localhost:123/products?name=ardalis matches the FindProductsByName action.",
    "Given the above controller, an HTTP GET request to localhost:123/products/ matches the GetAll action. An HTTP GET request to localhost:123/products?name=ardalis matches the FindProductsByName action.",
    "In ASP.NET Core, routing is handled by routing middleware, which matches the URLs of incoming requests to actions or other endpoints. Controller actions are either conventionally routed or attribute-routed. Conventional routing is similar to the route table approach used in ASP.NET MVC and Web API. Whether you",
    "In ASP.NET Core, routing is handled by routing middleware, which matches the URLs of incoming requests to actions or other endpoints. Controller actions are either conventionally routed or attribute-routed. Conventional routing is similar to the route table approach used in ASP.NET MVC and Web API. Whether you",
    "With conventional routing, you set up one or more conventions that will be used to match incoming URLs to ",
    "With conventional routing, you set up one or more conventions that will be used to match incoming URLs to ",
    "The preceding code is used (in addition to UseRouting) to configure various endpoints, including Health Checks, controllers, and Razor Pages. For controllers, the above configuration specifies a default routing convention, which is the fairly standard {controller}/{action}/{id?} pattern that",
    "The preceding code is used (in addition to UseRouting) to configure various endpoints, including Health Checks, controllers, and Razor Pages. For controllers, the above configuration specifies a default routing convention, which is the fairly standard {controller}/{action}/{id?} pattern that",
    "Attribute routing in ASP.NET Core is the preferred approach for configuring routing in controllers. If you",
    "Attribute routing in ASP.NET Core is the preferred approach for configuring routing in controllers. If you",
    "Attribute routing in ASP.NET Core behaves similarly in ASP.NET MVC and Web API. In addition to supporting the ",
    "Attribute routing in ASP.NET Core behaves similarly in ASP.NET MVC and Web API. In addition to supporting the ",
    "As with previous versions, you can specify a default route with placeholders, and add this at the controller class level or even on a base class. You use the same ",
    "As with previous versions, you can specify a default route with placeholders, and add this at the controller class level or even on a base class. You use the same ",
    "Using this attribute, classes inheriting from this type would route URLs to actions based on the controller name, action name, and an optional integer id parameter.",
    "Using this attribute, classes inheriting from this type would route URLs to actions based on the controller name, action name, and an optional integer id parameter.",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "Application logging provides important diagnostic information, especially for apps running in production. ASP.NET Core introduces a new system for adding standardized logging to any app. Existing ASP.NET MVC and Web API apps most likely use third-party logging solutions, which likely continue to be supported on ASP.NET Core.",
    "Application logging provides important diagnostic information, especially for apps running in production. ASP.NET Core introduces a new system for adding standardized logging to any app. Existing ASP.NET MVC and Web API apps most likely use third-party logging solutions, which likely continue to be supported on ASP.NET Core.",
    "There",
    "There",
    "In ASP.NET Core, ",
    "In ASP.NET Core, ",
    "ASP.NET Core logging uses categories and levels to control what is logged and how. Classes typically use instances of the ILogger",
    "ASP.NET Core logging uses categories and levels to control what is logged and how. Classes typically use instances of the ILogger",
    "A typical logging configuration could log Information and above information by default, but only Warning or above from Microsoft-prefixed categories:",
    "A typical logging configuration could log Information and above information by default, but only Warning or above from Microsoft-prefixed categories:",
    "Support for logging in ASP.NET Core is extensive and flexible. For more detailed information, ",
    "Support for logging in ASP.NET Core is extensive and flexible. For more detailed information, ",
    "How you migrate your .NET Framework app",
    "How you migrate your .NET Framework app",
    "Migrate the logging solution yourself",
    "Migrate the logging solution yourself",
    "Migrate to a third-party logging solution",
    "Migrate to a third-party logging solution",
    "Use the built-in logging support in ASP.NET Core",
    "Use the built-in logging support in ASP.NET Core",
    "You can reference the Microsoft.Extensions.Logging package from .NET Framework apps as long as they",
    "You can reference the Microsoft.Extensions.Logging package from .NET Framework apps as long as they",
    null,
    null,
    "<span id=\"page-33-2\">",
    "<span id=\"page-33-2\">",
    "Razor Pages is the preferred way to create page- or form-based apps in ASP.NET Core. From the ",
    "Razor Pages is the preferred way to create page- or form-based apps in ASP.NET Core. From the ",
    "A typical strongly typed view-based MVC app will use a controller to contain one or more actions. The controller will interact with the domain or data model, and create an instance of a viewmodel class. Then this viewmodel class is passed to the view associated with that action. Using this approach, coupled with the default folder structure of MVC apps, to add a new page to an app requires modifying a controller in one folder, a view in a nested subfolder in another folder, and a viewmodel in yet another folder.",
    "A typical strongly typed view-based MVC app will use a controller to contain one or more actions. The controller will interact with the domain or data model, and create an instance of a viewmodel class. Then this viewmodel class is passed to the view associated with that action. Using this approach, coupled with the default folder structure of MVC apps, to add a new page to an app requires modifying a controller in one folder, a view in a nested subfolder in another folder, and a viewmodel in yet another folder.",
    "Razor Pages group together the action (now a ",
    "Razor Pages group together the action (now a ",
    "As part of a move from ASP.NET MVC to ASP.NET Core, teams should consider whether they want to migrate controllers and views to ASP.NET Core controllers and views, or to Razor Pages. The former",
    "As part of a move from ASP.NET MVC to ASP.NET Core, teams should consider whether they want to migrate controllers and views to ASP.NET Core controllers and views, or to Razor Pages. The former",
    "will most likely require slightly less overall effort, but won",
    "will most likely require slightly less overall effort, but won",
    null,
    null,
    "<span id=\"page-34-1\">",
    "<span id=\"page-34-1\">",
    "ASP.NET Core offers iterative improvements to ASP.NET Web API 2, but should feel familiar to developers who have used Web API 2. ASP.NET Web API 2 was developed and shipped alongside ASP.NET MVC. This meant the two approaches had similar-but-different approaches to things like attribute routing and dependency injection. In ASP.NET Core, there",
    "ASP.NET Core offers iterative improvements to ASP.NET Web API 2, but should feel familiar to developers who have used Web API 2. ASP.NET Web API 2 was developed and shipped alongside ASP.NET MVC. This meant the two approaches had similar-but-different approaches to things like attribute routing and dependency injection. In ASP.NET Core, there",
    "In addition to being consistent and unified within ASP.NET Core, APIs built in .NET Core are much easier to test than those built on ASP.NET Web API 2. We",
    "In addition to being consistent and unified within ASP.NET Core, APIs built in .NET Core are much easier to test than those built on ASP.NET Web API 2. We",
    "See ",
    "See ",
    null,
    null,
    null,
    null,
    "In ASP.NET MVC 5, authentication is configured in ",
    "In ASP.NET MVC 5, authentication is configured in ",
    "Authentication and authorization are performed using middleware added to the request pipeline:",
    "Authentication and authorization are performed using middleware added to the request pipeline:",
    "It",
    "It",
    "In ASP.NET MVC and Web API, apps often refer to the current user using the ClaimsPrincipal.Current property. This property isn",
    "In ASP.NET MVC and Web API, apps often refer to the current user using the ClaimsPrincipal.Current property. This property isn",
    "Authorization defines what a given user can do within the app. It",
    "Authorization defines what a given user can do within the app. It",
    "Authorization in ASP.NET Core may be as simple as prohibiting anonymous users while allowing authenticated users. Or it can scale up to support role-based, claims-based, or policy-based authorization approaches. For more information on these approaches, see the documentation on ",
    "Authorization in ASP.NET Core may be as simple as prohibiting anonymous users while allowing authenticated users. Or it can scale up to support role-based, claims-based, or policy-based authorization approaches. For more information on these approaches, see the documentation on ",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "In ASP.NET MVC, identity features are typically configured in ",
    "In ASP.NET MVC, identity features are typically configured in ",
    "ASP.NET Identity is an API that supports user interface login functionality and manages users, passwords, profile data, roles, claims, tokens, email confirmations, and more. It supports external login providers like Facebook, Google, Microsoft, and Twitter.",
    "ASP.NET Identity is an API that supports user interface login functionality and manages users, passwords, profile data, roles, claims, tokens, email confirmations, and more. It supports external login providers like Facebook, Google, Microsoft, and Twitter.",
    "If your ASP.NET MVC app is using ASP.NET Membership, you",
    "If your ASP.NET MVC app is using ASP.NET Membership, you",
    "If you migrate your ASP.NET Identity users to ASP.NET Core Identity, you may need to update their password hashes, or track which passwords are hashed with the new ASP.NET Core Identity approach or the older ASP.NET Identity approach. ",
    "If you migrate your ASP.NET Identity users to ASP.NET Core Identity, you may need to update their password hashes, or track which passwords are hashed with the new ASP.NET Core Identity approach or the older ASP.NET Identity approach. ",
    "One of the biggest differences when it comes to ASP.NET Core Identity compared to ASP.NET Identity is how little code you need to include in your project. ASP.NET Core Identity now ships as a Razor Class Library, meaning its UI and logic are all available from a NuGet package. You can override the existing UI and logic by ",
    "One of the biggest differences when it comes to ASP.NET Core Identity compared to ASP.NET Identity is how little code you need to include in your project. ASP.NET Core Identity now ships as a Razor Class Library, meaning its UI and logic are all available from a NuGet package. You can override the existing UI and logic by ",
    "The following resources offer some guidance for migrating from OWIN / Katana:",
    "The following resources offer some guidance for migrating from OWIN / Katana:",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "In ASP.NET MVC 5 and Web API 2, there were two different Controller base types. MVC controllers inherited from Controller; Web API controllers inherited from ApiController. In ASP.NET Core, this object hierarchy has been merged. It",
    "In ASP.NET MVC 5 and Web API 2, there were two different Controller base types. MVC controllers inherited from Controller; Web API controllers inherited from ApiController. In ASP.NET Core, this object hierarchy has been merged. It",
    "In both frameworks, controllers are used to organize sets of action methods. Filters and routes can be applied on a controller level in addition to at the action level. These conventions can be extended further by using custom base Controller types with default behavior and attributes applied to them.",
    "In both frameworks, controllers are used to organize sets of action methods. Filters and routes can be applied on a controller level in addition to at the action level. These conventions can be extended further by using custom base Controller types with default behavior and attributes applied to them.",
    "In ASP.NET MVC, content negotiation isn",
    "In ASP.NET MVC, content negotiation isn",
    "When migrating ASP.NET Web API controllers to ASP.NET Core, a few components need to be changed if they exist. These include references to the ApiController base class, the System.Web.Http namespace, and the IHttpActionResult interface. Refer to the ",
    "When migrating ASP.NET Web API controllers to ASP.NET Core, a few components need to be changed if they exist. These include references to the ApiController base class, the System.Web.Http namespace, and the IHttpActionResult interface. Refer to the ",
    "In addition, the ",
    "In addition, the ",
    "ASP.NET Core includes two new attributes: ",
    "ASP.NET Core includes two new attributes: ",
    null,
    null,
    null,
    null,
    "The basic syntax of Razor hasn",
    "The basic syntax of Razor hasn",
    "Tag Helpers enable server-side code to participate in creating and rendering HTML elements in Razor files. They offer many advantages over HTML Helpers and should be used in place of HTML Helpers wherever possible. They provide an HTML-friendly development experience, since they look like standard HTML and are ignored by most tooling designed to edit HTML. Within ",
    "Tag Helpers enable server-side code to participate in creating and rendering HTML elements in Razor files. They offer many advantages over HTML Helpers and should be used in place of HTML Helpers wherever possible. They provide an HTML-friendly development experience, since they look like standard HTML and are ignored by most tooling designed to edit HTML. Within ",
    "Razor Pages offer an alternative to controllers, actions, and views for page- and form-based apps. ",
    "Razor Pages offer an alternative to controllers, actions, and views for page- and form-based apps. ",
    null,
    null,
    null,
    null,
    null,
    null,
    "<span id=\"page-38-1\">",
    "<span id=\"page-38-1\">",
    "ASP.NET Core SignalR is incompatible with clients or servers using ASP.NET SignalR. You",
    "ASP.NET Core SignalR is incompatible with clients or servers using ASP.NET SignalR. You",
    "ASP.NET SignalR automatically attempts to reconnect dropped connections; this behavior is opt-in for ASP.NET Core SignalR clients.",
    "ASP.NET SignalR automatically attempts to reconnect dropped connections; this behavior is opt-in for ASP.NET Core SignalR clients.",
    "Both frameworks support JSON; ASP.NET Core SignalR also supports a binary protocol based on MessagePack, and custom protocols can be created.",
    "Both frameworks support JSON; ASP.NET Core SignalR also supports a binary protocol based on MessagePack, and custom protocols can be created.",
    "The Forever Frame transport, supported by ASP.NET SignalR, isn",
    "The Forever Frame transport, supported by ASP.NET SignalR, isn",
    "ASP.NET Core SignalR must be configured by adding services.AddSignalR() and app.UseEndpoints in ",
    "ASP.NET Core SignalR must be configured by adding services.AddSignalR() and app.UseEndpoints in ",
    "ASP.NET Core SignalR requires sticky sessions; ASP.NET SignalR doesn",
    "ASP.NET Core SignalR requires sticky sessions; ASP.NET SignalR doesn",
    "ASP.NET Core simplifies the connection model; connections are only made to a single hub.",
    "ASP.NET Core simplifies the connection model; connections are only made to a single hub.",
    "ASP.NET Core SignalR supports streaming data from the hub to the client.",
    "ASP.NET Core SignalR supports streaming data from the hub to the client.",
    "ASP.NET Core SignalR doesn",
    "ASP.NET Core SignalR doesn",
    "The PersistentConnection class doesn",
    "The PersistentConnection class doesn",
    "ASP.NET SignalR supports SQL Server and Redis. ASP.NET Core SignalR supports ",
    "ASP.NET SignalR supports SQL Server and Redis. ASP.NET Core SignalR supports ",
    null,
    null,
    null,
    null,
    "ASP.NET MVC apps support unit testing of controllers, but this approach often omits many MVC features like routing, authorization, model binding, model validation, filters, and more. To test these MVC features in addition to the logic within the controller action itself, frequently the app would need to be deployed and then tested with a tool like Selenium. These tests are substantially more expensive, more brittle, and slower than typical unit tests that can be run without the need for hosting and running the entire app.",
    "ASP.NET MVC apps support unit testing of controllers, but this approach often omits many MVC features like routing, authorization, model binding, model validation, filters, and more. To test these MVC features in addition to the logic within the controller action itself, frequently the app would need to be deployed and then tested with a tool like Selenium. These tests are substantially more expensive, more brittle, and slower than typical unit tests that can be run without the need for hosting and running the entire app.",
    null,
    null,
    "ASP.NET MVC and Web API did not support anything like the integration testing scenarios available in ASP.NET Core. In any migration effort, you should allocate time to write some integration tests for your newly migrated system to ensure it",
    "ASP.NET MVC and Web API did not support anything like the integration testing scenarios available in ASP.NET Core. In any migration effort, you should allocate time to write some integration tests for your newly migrated system to ensure it",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "Migrating large solutions from .NET Framework to .NET Core requires some planning. Dependencies must be migrated or updated before the projects that depend on them. There are tools that can identify dependencies and offer help with migrating to .NET Core. Depending on the app, its scope, and current usage patterns, different strategies may be employed when migrating. Do you migrate it all at once, or over time, side-by-side with the current system? Do you wrap the current system in the new one, and incrementally replace its functionality?",
    "Migrating large solutions from .NET Framework to .NET Core requires some planning. Dependencies must be migrated or updated before the projects that depend on them. There are tools that can identify dependencies and offer help with migrating to .NET Core. Depending on the app, its scope, and current usage patterns, different strategies may be employed when migrating. Do you migrate it all at once, or over time, side-by-side with the current system? Do you wrap the current system in the new one, and incrementally replace its functionality?",
    "In this chapter, you",
    "In this chapter, you",
    null,
    null,
    null,
    null,
    "For solutions that involve multiple front-end apps, it",
    "For solutions that involve multiple front-end apps, it",
    "Once you",
    "Once you",
    null,
    null,
    null,
    null,
    "Choose a particular front-end app, an ASP.NET MVC 5 / Web API 2 project. Identify its dependencies in the solution, and map out their dependencies until you have a complete list. A diagram like the one shown in Figure 3-1 may be useful when mapping out project dependencies. Visual Studio can produce a ",
    "Choose a particular front-end app, an ASP.NET MVC 5 / Web API 2 project. Identify its dependencies in the solution, and map out their dependencies until you have a complete list. A diagram like the one shown in Figure 3-1 may be useful when mapping out project dependencies. Visual Studio can produce a ",
    "Figure 3-2 shows the installer for the ",
    "Figure 3-2 shows the installer for the ",
    null,
    null,
    null,
    null,
    "The extension currently supports Visual Studio 2017 and 2019. Visual Studio 2022 support is planned.",
    "The extension currently supports Visual Studio 2017 and 2019. Visual Studio 2022 support is planned.",
    "Once installed, you configure it from the ",
    "Once installed, you configure it from the ",
    null,
    null,
    null,
    null,
    "The analyzer produces a detailed report for each assembly. The report:",
    "The analyzer produces a detailed report for each assembly. The report:",
    "Describes how compatible each project is with a given target framework, such as .NET 7 or .NET Standard 2.0.",
    "Describes how compatible each project is with a given target framework, such as .NET 7 or .NET Standard 2.0.",
    "Helps teams assess the effort required to port a particular project to a particular target framework.",
    "Helps teams assess the effort required to port a particular project to a particular target framework.",
    "The details of this analysis are covered in the next section.",
    "The details of this analysis are covered in the next section.",
    "Once you",
    "Once you",
    "In the example shown in Figure 3-1, you would start with the ",
    "In the example shown in Figure 3-1, you would start with the ",
    "Missing from the previous diagrams are unit test projects. Hopefully there are tests covering at least some of the existing behavior of the libraries being ported.",
    "Missing from the previous diagrams are unit test projects. Hopefully there are tests covering at least some of the existing behavior of the libraries being ported.",
    "If you have unit tests, it",
    "If you have unit tests, it",
    "MSTest, xUnit, and NUnit all work on .NET Core. If you don",
    "MSTest, xUnit, and NUnit all work on .NET Core. If you don",
    "Some organizations will have many different apps to migrate, and migrating each one by hand may require too many resources to be tenable. In these situations, some degree of automation is recommended. The steps followed in this chapter can be automated. Structural changes, like project file differences and updates to common packages, can be applied by scripts. These scripts can be refined as they",
    "Some organizations will have many different apps to migrate, and migrating each one by hand may require too many resources to be tenable. In these situations, some degree of automation is recommended. The steps followed in this chapter can be automated. Structural changes, like project file differences and updates to common packages, can be applied by scripts. These scripts can be refined as they",
    "Watch an overview of how to employ this approach in this ",
    "Watch an overview of how to employ this approach in this ",
    "Migrate third-party NuGet dependencies",
    "Migrate third-party NuGet dependencies",
    "Migrate apps to use new ",
    "Migrate apps to use new ",
    "Update internal NuGet dependencies to .NET Standard",
    "Update internal NuGet dependencies to .NET Standard",
    "Migrate apps to ASP.NET Core (targeting .NET Framework)",
    "Migrate apps to ASP.NET Core (targeting .NET Framework)",
    "Update all apps to target .NET 7",
    "Update all apps to target .NET 7",
    "When automating a large suite of apps, it helps significantly if they follow consistent coding guidelines and project organization. Automation efforts rely on this consistency to be effective. In addition to parsing and migrating project files, common code patterns can be migrated automatically. Some code pattern examples include differences in how controller actions are declared or how they return results.",
    "When automating a large suite of apps, it helps significantly if they follow consistent coding guidelines and project organization. Automation efforts rely on this consistency to be effective. In addition to parsing and migrating project files, common code patterns can be migrated automatically. Some code pattern examples include differences in how controller actions are declared or how they return results.",
    "For example, a migration script could search files matching ",
    "For example, a migration script could search files matching ",
    "In ASP.NET Core, either of the preceding lines of code can be replaced with:",
    "In ASP.NET Core, either of the preceding lines of code can be replaced with:",
    "The best approach to porting a large .NET Framework app to .NET Core is to:",
    "The best approach to porting a large .NET Framework app to .NET Core is to:",
    "Identify project dependencies.",
    "Identify project dependencies.",
    "Analyze what",
    "Analyze what",
    "Start from the bottom up.",
    "Start from the bottom up.",
    "You can use the .NET Portability Analyzer to determine how compatible existing libraries may be with target platforms. Automated tests will help ensure no breaking changes are introduced as the app is ported. These test projects should be among the first projects ported.",
    "You can use the .NET Portability Analyzer to determine how compatible existing libraries may be with target platforms. Automated tests will help ensure no breaking changes are introduced as the app is ported. These test projects should be among the first projects ported.",
    null,
    null,
    null,
    null,
    "<span id=\"page-45-2\">",
    "<span id=\"page-45-2\">",
    "After identifying the sequence in which the app",
    "After identifying the sequence in which the app",
    null,
    null,
    null,
    null,
    "Large apps typically involve multiple projects, and most projects other than the ASP.NET MVC web project are likely to be class libraries. Class libraries tend to be the easiest to port between .NET",
    "Large apps typically involve multiple projects, and most projects other than the ASP.NET MVC web project are likely to be class libraries. Class libraries tend to be the easiest to port between .NET",
    "platforms, especially compared to ASP.NET projects, which are among the most difficult (and typically need to be re-created).",
    "platforms, especially compared to ASP.NET projects, which are among the most difficult (and typically need to be re-created).",
    "Teams can consider the ",
    "Teams can consider the ",
    "The try-convert and Upgrade Assistant tools are deployed as .NET Core command line tools. They only run on Windows, since they",
    "The try-convert and Upgrade Assistant tools are deployed as .NET Core command line tools. They only run on Windows, since they",
    "Once you",
    "Once you",
    "Install the .NET Upgrade Assistant with the following command (after installing try-convert):",
    "Install the .NET Upgrade Assistant with the following command (after installing try-convert):",
    "dotnet tool install -g upgrade-assistant",
    "dotnet tool install -g upgrade-assistant",
    "Run the tool with the command upgrade-assistant upgrade ",
    "Run the tool with the command upgrade-assistant upgrade ",
    "Analyze your use of third-party NuGet packages and determine if any of them don",
    "Analyze your use of third-party NuGet packages and determine if any of them don",
    "If support exists using the version of the package the app currently uses, great",
    "If support exists using the version of the package the app currently uses, great",
    "In some cases, no version of a given package works with .NET Core. In that case, teams have a couple options. They can continue depending on the .NET Framework version, but this has limitations. The app may only run on Windows, and the team may want to run Portability Analyzer on the package",
    "In some cases, no version of a given package works with .NET Core. In that case, teams have a couple options. They can continue depending on the .NET Framework version, but this has limitations. The app may only run on Windows, and the team may want to run Portability Analyzer on the package",
    "The System.Web namespace and types don",
    "The System.Web namespace and types don",
    "In general, it",
    "In general, it",
    "The next chapter digs into details of how to migrate from ASP.NET MVC and Web API projects to ASP.NET Core projects. The previous chapter called out the biggest differences between the apps. Once the basic project structure is in place, migrating individual controllers and views is usually straightforward, especially if they",
    "The next chapter digs into details of how to migrate from ASP.NET MVC and Web API projects to ASP.NET Core projects. The previous chapter called out the biggest differences between the apps. Once the basic project structure is in place, migrating individual controllers and views is usually straightforward, especially if they",
    null,
    null,
    null,
    null,
    null,
    null,
    "Many teams have .NET Framework apps they plan to migrate to .NET Core/.NET 7, but the app is so large that the migration requires a significant amount of time to complete. The original app needs to live on while the migration is done piece by piece. There needs to be a way for the old and new versions of the app to work together side-by-side, or for the old version to be migrated in-place, at least some of the way, without breaking it. Teams can employ many different strategies to support these goals.",
    "Many teams have .NET Framework apps they plan to migrate to .NET Core/.NET 7, but the app is so large that the migration requires a significant amount of time to complete. The original app needs to live on while the migration is done piece by piece. There needs to be a way for the old and new versions of the app to work together side-by-side, or for the old version to be migrated in-place, at least some of the way, without breaking it. Teams can employ many different strategies to support these goals.",
    "A good place to start if you plan to port a .NET Framework app to .NET Core is to refactor it to work better with .NET Core. This means updating individual class libraries to target .NET Standard and moving as much logic out of your ASP.NET MVC projects and into these class libraries. Any code you have in .NET Standard libraries is immediately usable from both .NET Framework to .NET Core apps, which is why this step is so valuable as part of a migration.",
    "A good place to start if you plan to port a .NET Framework app to .NET Core is to refactor it to work better with .NET Core. This means updating individual class libraries to target .NET Standard and moving as much logic out of your ASP.NET MVC projects and into these class libraries. Any code you have in .NET Standard libraries is immediately usable from both .NET Framework to .NET Core apps, which is why this step is so valuable as part of a migration.",
    "When refactoring, make sure you",
    "When refactoring, make sure you",
    "If your .NET Framework apps include a lot of static assets, like scripts, CSS files, or images, you may be able to migrate these to a separate CDN. Then, update the existing app to reference the CDN links for these assets. When you port the app to .NET Core, these static files won",
    "If your .NET Framework apps include a lot of static assets, like scripts, CSS files, or images, you may be able to migrate these to a separate CDN. Then, update the existing app to reference the CDN links for these assets. When you port the app to .NET Core, these static files won",
    "Large .NET Framework apps may already be comprised of separate front-end systems that can be migrated individually. Or they may be candidates for migration to a microservices architecture, with some pieces of existing ASP.NET MVC apps being pulled out into new ASP.NET Core microservice implementations. You can learn more about microservices in the associated ebook, ",
    "Large .NET Framework apps may already be comprised of separate front-end systems that can be migrated individually. Or they may be candidates for migration to a microservices architecture, with some pieces of existing ASP.NET MVC apps being pulled out into new ASP.NET Core microservice implementations. You can learn more about microservices in the associated ebook, ",
    "For example, the existing app might have a set of features it uses related to user sign-in and registration. These could be migrated to a separate microservice, which could be built and deployed using ASP.NET Core and then integrated into the legacy .NET Framework app. Next, the app might have a few pages dedicated to tracking the individual user",
    "For example, the existing app might have a set of features it uses related to user sign-in and registration. These could be migrated to a separate microservice, which could be built and deployed using ASP.NET Core and then integrated into the legacy .NET Framework app. Next, the app might have a few pages dedicated to tracking the individual user",
    "Using a combination of host headers and redirects, an existing ASP.NET MVC app can be configured to run side by side with an ASP.NET Core app on the same IIS server. As pieces of functionality, such as individual controllers, are ported to ASP.NET Core, their routes and URLs are mapped within IIS to target the ASP.NET Core web site or sub-application (IIS virtual directories aren",
    "Using a combination of host headers and redirects, an existing ASP.NET MVC app can be configured to run side by side with an ASP.NET Core app on the same IIS server. As pieces of functionality, such as individual controllers, are ported to ASP.NET Core, their routes and URLs are mapped within IIS to target the ASP.NET Core web site or sub-application (IIS virtual directories aren",
    "Large ASP.NET MVC apps can be gradually replaced with a new ASP.NET Core app by incrementally migrating pieces of functionality. One approach to this is called the ",
    "Large ASP.NET MVC apps can be gradually replaced with a new ASP.NET Core app by incrementally migrating pieces of functionality. One approach to this is called the ",
    "Once the facade is in place, you can route part of it to a new ASP.NET Core app. As you port more of the original .NET Framework app to .NET Core, you continue to update the facade layer accordingly, sending more of the facade",
    "Once the facade is in place, you can route part of it to a new ASP.NET Core app. As you port more of the original .NET Framework app to .NET Core, you continue to update the facade layer accordingly, sending more of the facade",
    null,
    null,
    null,
    null,
    "Eventually, the entire facade layer corresponds to the new, modern implementation. At this point, both the legacy system and the face layer can be retired. Microsoft has guidance on how to achieve ",
    "Eventually, the entire facade layer corresponds to the new, modern implementation. At this point, both the legacy system and the face layer can be retired. Microsoft has guidance on how to achieve ",
    "Multi-targeting is recommended for large apps that will be migrated over time and for teams applying the Strangler pattern approach. This approach can address BindingRedirect and package restoration challenges that surface from mixing ",
    "Multi-targeting is recommended for large apps that will be migrated over time and for teams applying the Strangler pattern approach. This approach can address BindingRedirect and package restoration challenges that surface from mixing ",
    "Preprocessor directives ",
    "Preprocessor directives ",
    "Project files can use conditional ",
    "Project files can use conditional ",
    "Typically you only follow these recommendations for class libraries. These techniques allow a single common codebase to be maintained while new functionality is added and features of the app are incrementally ported to use .NET Core.",
    "Typically you only follow these recommendations for class libraries. These techniques allow a single common codebase to be maintained while new functionality is added and features of the app are incrementally ported to use .NET Core.",
    "Frequently, large ASP.NET MVC and Web API apps won",
    "Frequently, large ASP.NET MVC and Web API apps won",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "In this chapter, you",
    "In this chapter, you",
    "The initial version of the project is shown in Figure 4-1. It",
    "The initial version of the project is shown in Figure 4-1. It",
    null,
    null,
    null,
    null,
    "This chapter demonstrates how to perform many of the upgrade steps by hand. Alternatively, you can use the ",
    "This chapter demonstrates how to perform many of the upgrade steps by hand. Alternatively, you can use the ",
    "The first step in preparing to migrate is to run the ",
    "The first step in preparing to migrate is to run the ",
    "After ",
    "After ",
    null,
    null,
    null,
    null,
    "Choose the web project",
    "Choose the web project",
    null,
    null,
    null,
    null,
    "If your solution includes several projects, you can choose all of them. The ",
    "If your solution includes several projects, you can choose all of them. The ",
    "Once the report is generated, open the file and review the results. The summary provides a high-level view of what percentage of .NET Framework calls your app is making have compatible versions. Figure 4-4 shows the summary for the ",
    "Once the report is generated, open the file and review the results. The summary provides a high-level view of what percentage of .NET Framework calls your app is making have compatible versions. Figure 4-4 shows the summary for the ",
    null,
    null,
    null,
    null,
    "For this app, about 80 percent of the .NET Framework calls are compatible. 20 percent of the calls need to be addressed during the porting process. Viewing the details reveals that all of the incompatible calls are part of System.Web, which is an expected incompatibility. The dependencies on System.Web calls will be addressed when the app",
    "For this app, about 80 percent of the .NET Framework calls are compatible. 20 percent of the calls need to be addressed during the porting process. Viewing the details reveals that all of the incompatible calls are part of System.Web, which is an expected incompatibility. The dependencies on System.Web calls will be addressed when the app",
    "| Target type                           | \u25bc Target member                               | Assembly Name  |",
    "| Target type                           | \u25bc Target member                               | Assembly Name  |",
    null,
    null,
    "Most of the incompatible types refer to Controller and various related attributes that have equivalents in ASP.NET Core.",
    "Most of the incompatible types refer to Controller and various related attributes that have equivalents in ASP.NET Core.",
    "Next, migrate from the older ",
    "Next, migrate from the older ",
    "The original project",
    "The original project",
    null,
    null,
    "A common way to create a new project file for an existing ASP.NET project is to create a new ASP.NET Core app using dotnet new or ",
    "A common way to create a new project file for an existing ASP.NET project is to create a new ASP.NET Core app using dotnet new or ",
    "In addition to the C# project file, NuGet dependencies are stored in a separate 45-line ",
    "In addition to the C# project file, NuGet dependencies are stored in a separate 45-line ",
    null,
    null,
    "You can migrate ",
    "You can migrate ",
    "Add a new ASP.NET Core project to the existing app",
    "Add a new ASP.NET Core project to the existing app",
    null,
    null,
    null,
    null,
    "The next dialog will ask you to choose which template to use. Select the ",
    "The next dialog will ask you to choose which template to use. Select the ",
    null,
    null,
    null,
    null,
    "Since the built-in migration tool for migrating ",
    "Since the built-in migration tool for migrating ",
    "https://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7c9218bf9c/raw/7789 53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.ps1 -OutFile Convert-ToPackageReference.ps1",
    "https://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7c9218bf9c/raw/7789 53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.ps1 -OutFile Convert-ToPackageReference.ps1",
    "https://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7c9218bf9c/raw/7789 53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.xsl -OutFile Convert-ToPackageReference.xsl",
    "https://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7c9218bf9c/raw/7789 53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.xsl -OutFile Convert-ToPackageReference.xsl",
    "./Convert-ToPackageReference.ps1 | Out-Null",
    "./Convert-ToPackageReference.ps1 | Out-Null",
    "The first two commands download files so that they exist locally. The last line runs the script. After running it, try to build the new project. You",
    "The first two commands download files so that they exist locally. The last line runs the script. After running it, try to build the new project. You",
    "In most ASP.NET MVC apps, many client-side dependencies like Bootstrap and jQuery were deployed using NuGet packages. In ASP.NET Core, NuGet packages are only used for server-side functionality. Client files should be managed through other means. Review the list of ",
    "In most ASP.NET MVC apps, many client-side dependencies like Bootstrap and jQuery were deployed using NuGet packages. In ASP.NET Core, NuGet packages are only used for server-side functionality. Client files should be managed through other means. Review the list of ",
    "Bootstrap",
    "Bootstrap",
    "jQuery",
    "jQuery",
    "jQuery.Validation",
    "jQuery.Validation",
    "Modernizr",
    "Modernizr",
    "popper.js",
    "popper.js",
    "Respond",
    "Respond",
    "The static client files installed by NuGet for these packages will be copied over to the new project",
    "The static client files installed by NuGet for these packages will be copied over to the new project",
    null,
    null,
    "The package references can be further compacted by making the ",
    "The package references can be further compacted by making the ",
    "Any static files the app uses, including third-party scripts and frameworks but also custom images and stylesheets, must be copied from the old project to the new one. In ASP.NET MVC apps, files were typically accessed based on their location within the project folder. In ASP.NET Core apps, these static files will be accessed based on their location within the ",
    "Any static files the app uses, including third-party scripts and frameworks but also custom images and stylesheets, must be copied from the old project to the new one. In ASP.NET MVC apps, files were typically accessed based on their location within the project folder. In ASP.NET Core apps, these static files will be accessed based on their location within the ",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "The ",
    "The ",
    "Add a ",
    "Add a ",
    "Add version 2.2.0 of the Microsoft.AspNetCore.StaticFiles NuGet package.",
    "Add version 2.2.0 of the Microsoft.AspNetCore.StaticFiles NuGet package.",
    "In ",
    "In ",
    "Copy the ",
    "Copy the ",
    "Run the app and navigate to its ",
    "Run the app and navigate to its ",
    null,
    null,
    null,
    null,
    "Next, copy over the C# files used by the app, including standard MVC folders and their contents like ",
    "Next, copy over the C# files used by the app, including standard MVC folders and their contents like ",
    "For the ",
    "For the ",
    "Next, the ",
    "Next, the ",
    "The ",
    "The ",
    "That leaves the ",
    "That leaves the ",
    "Missing compiler required member ",
    "Missing compiler required member ",
    "To resolve this error, add a NuGet package reference to C#:",
    "To resolve this error, add a NuGet package reference to C#:",
    "The remaining three errors specify types that are defined in an assembly that isn",
    "The remaining three errors specify types that are defined in an assembly that isn",
    "HttpServerUtilityBase",
    "HttpServerUtilityBase",
    "RouteValueDictionary",
    "RouteValueDictionary",
    "HttpRequestBase",
    "HttpRequestBase",
    "Let",
    "Let",
    "There are two possible solutions to this problem. The first is to keep the functionality as it is. In this case, rather than using Server.MapPath, a fixed path referencing the image files",
    "There are two possible solutions to this problem. The first is to keep the functionality as it is. In this case, rather than using Server.MapPath, a fixed path referencing the image files",
    "The next two errors both occur in the same private method in the same line of code:",
    "The next two errors both occur in the same private method in the same line of code:",
    "Both this.Url and this.Request cause compiler errors. Looking at how this code is used, its purpose is to build a link to the PicController action that renders image files. The same one we just discovered could probably be replaced with direct links to the static files located in ",
    "Both this.Url and this.Request cause compiler errors. Looking at how this code is used, its purpose is to build a link to the PicController action that renders image files. The same one we just discovered could probably be replaced with direct links to the static files located in ",
    "It",
    "It",
    "This time, there are 16 errors:",
    "This time, there are 16 errors:",
    "Include is not a valid named attribute argument (2)",
    "Include is not a valid named attribute argument (2)",
    "HttpStatusCodeResult not found (3)",
    "HttpStatusCodeResult not found (3)",
    "HttpNotFound does not exist (3)",
    "HttpNotFound does not exist (3)",
    "SelectList not found (8)",
    "SelectList not found (8)",
    "Once more, let",
    "Once more, let",
    "All references to return HttpNotFound(); should be replaced with return NotFound();.",
    "All references to return HttpNotFound(); should be replaced with return NotFound();.",
    "All references to return new HttpStatusCodeResult(HttpStatusCode.BadRequest); should be replaced with return BadRequest();.",
    "All references to return new HttpStatusCodeResult(HttpStatusCode.BadRequest); should be replaced with return BadRequest();.",
    "That just leaves the use of Include with a ",
    "That just leaves the use of Include with a ",
    "The preceding code restricts model binding to the properties listed in the Include string. In ASP.NET Core MVC, the ",
    "The preceding code restricts model binding to the properties listed in the Include string. In ASP.NET Core MVC, the ",
    "With these changes, the project compiles once more. It",
    "With these changes, the project compiles once more. It",
    "The two biggest ASP.NET Core MVC features related to views are ",
    "The two biggest ASP.NET Core MVC features related to views are ",
    "HttpContext does not exist (2)",
    "HttpContext does not exist (2)",
    "Scripts does not exist (5)",
    "Scripts does not exist (5)",
    "Styles does not exist (1)",
    "Styles does not exist (1)",
    "HtmlString could not be found(1)",
    "HtmlString could not be found(1)",
    "Investigating these errors finds that most of them are in the main ",
    "Investigating these errors finds that most of them are in the main ",
    "The reference to Modernizr can be removed. The references to Bootstrap and jQuery can be replaced with CDN links to the appropriate version.",
    "The reference to Modernizr can be removed. The references to Bootstrap and jQuery can be replaced with CDN links to the appropriate version.",
    "Replace @Styles.Render line with:",
    "Replace @Styles.Render line with:",
    "Replace the last two Scripts.Render lines with:",
    "Replace the last two Scripts.Render lines with:",
    "Finally, after the Bootstrap ",
    "Finally, after the Bootstrap ",
    "To determine the order in which the ",
    "To determine the order in which the ",
    "Building again reveals one more error loading jQuery Validation on the ",
    "Building again reveals one more error loading jQuery Validation on the ",
    "The last thing to fix in the views is the reference to Session to display how long the app has been running, and on which machine. We can display this data directly in the site",
    "The last thing to fix in the views is the reference to Session to display how long the app has been running, and on which machine. We can display this data directly in the site",
    "System.Diagnostics.Process.GetCurrentProcess().StartTime:",
    "System.Diagnostics.Process.GetCurrentProcess().StartTime:",
    "At this point, the app once more builds successfully. However, trying to run it just yields ",
    "At this point, the app once more builds successfully. However, trying to run it just yields ",
    "The last migration step is to take the app startup tasks from ",
    "The last migration step is to take the app startup tasks from ",
    "The original ASP.NET MVC app has the following code in its Application",
    "The original ASP.NET MVC app has the following code in its Application",
    "Looking at these lines one by one, the RegisterContainer method sets up dependency injection, which will be ported below. The next three lines configure different parts of MVC: areas, filters, and routes. Bundles are replaced by static files in the ported app. The last line sets up data access for the app, which will be shown in a later section.",
    "Looking at these lines one by one, the RegisterContainer method sets up dependency injection, which will be ported below. The next three lines configure different parts of MVC: areas, filters, and routes. Bundles are replaced by static files in the ported app. The last line sets up data access for the app, which will be shown in a later section.",
    "Since this app isn",
    "Since this app isn",
    "The call to register global filters invokes a helper on the FilterConfig class in the app",
    "The call to register global filters invokes a helper on the FilterConfig class in the app",
    "The only attribute added to the app is the ASP.NET MVC filter, HandleErrorAttribute. This filter ensures that when an exception occurs as part of a request, a default action and view are displayed, rather than the exception details. In ASP.NET Core, this same functionality is performed by the UseExceptionHandler middleware. The detailed error messages aren",
    "The only attribute added to the app is the ASP.NET MVC filter, HandleErrorAttribute. This filter ensures that when an exception occurs as part of a request, a default action and view are displayed, rather than the exception details. In ASP.NET Core, this same functionality is performed by the UseExceptionHandler middleware. The detailed error messages aren",
    "This takes care of the only filter used by the eShop app, and in this case it was done by using built-in middleware. If you have global filters that must be configured in your app, this is done when MVC is added in ",
    "This takes care of the only filter used by the eShop app, and in this case it was done by using built-in middleware. If you have global filters that must be configured in your app, this is done when MVC is added in ",
    "The last piece of MVC-related logic that needs to be migrated are the app",
    "The last piece of MVC-related logic that needs to be migrated are the app",
    "Taking this code line-by-line, the first line sets up support for attribute routes. This is built into ASP.NET Core, so it",
    "Taking this code line-by-line, the first line sets up support for attribute routes. This is built into ASP.NET Core, so it",
    "ASP.NET Core MVC supports ",
    "ASP.NET Core MVC supports ",
    "With ASP.NET Core 3.0 and later, this is changed to use endpoints. For the initial port to ASP.NET Core 2.2, this is the proper syntax for mapping conventional routes.",
    "With ASP.NET Core 3.0 and later, this is changed to use endpoints. For the initial port to ASP.NET Core 2.2, this is the proper syntax for mapping conventional routes.",
    "With these changes in place, the Configure method is almost done. The original template",
    "With these changes in place, the Configure method is almost done. The original template",
    "Now it",
    "Now it",
    "First, to get ASP.NET Core MVC to work properly, it needs to be added:",
    "First, to get ASP.NET Core MVC to work properly, it needs to be added:",
    "The preceding code is the minimal configuration required to get MVC features working. There are many additional features that can be configured from this call (some of which are detailed later in this chapter), but for now this will suffice to build the app. Running it now routes the default request properly, but since we",
    "The preceding code is the minimal configuration required to get MVC features working. There are many additional features that can be configured from this call (some of which are detailed later in this chapter), but for now this will suffice to build the app. Running it now routes the default request properly, but since we",
    "The original app",
    "The original app",
    "This code configures an ",
    "This code configures an ",
    "ASP.NET Core has built-in support for dependency injection, but you can wire up a third-party container such as Autofac easily if necessary. In this case, since the app is already configured to use Autofac, the simplest solution is to maintain its usage. In ",
    "ASP.NET Core has built-in support for dependency injection, but you can wire up a third-party container such as Autofac easily if necessary. In this case, since the app is already configured to use Autofac, the simplest solution is to maintain its usage. In ",
    "For now, the setting for useMockData is set to true. This setting will be read from configuration in a moment. At this point, the app compiles and should load successfully when run, as shown in Figure 4- 12.",
    "For now, the setting for useMockData is set to true. This setting will be read from configuration in a moment. At this point, the app compiles and should load successfully when run, as shown in Figure 4- 12.",
    null,
    null,
    null,
    null,
    "ASP.NET Core uses a new ",
    "ASP.NET Core uses a new ",
    "The original app referenced its settings using ConfigurationManager.AppSettings. A quick search for all references of this term yields the set of settings the new app needs. There are only two:",
    "The original app referenced its settings using ConfigurationManager.AppSettings. A quick search for all references of this term yields the set of settings the new app needs. There are only two:",
    "UseMockData",
    "UseMockData",
    "UseCustomizationData",
    "UseCustomizationData",
    "If your app has more complex configuration, especially if it",
    "If your app has more complex configuration, especially if it",
    "First, modify the ported app",
    "First, modify the ported app",
    "Now, modify ",
    "Now, modify ",
    "At this point, the setting is pulled from configuration. The other setting, UseCustomizationData, is used by the CatalogDBInitializer class. When you first ported this class, you commented out the access to ConfigurationManager.AppSettings",
    "At this point, the setting is pulled from configuration. The other setting, UseCustomizationData, is used by the CatalogDBInitializer class. When you first ported this class, you commented out the access to ConfigurationManager.AppSettings",
    "All access to configuration within the web app should be modified in this manner to use the new IConfiguration type. Dependencies that require access to .NET Framework configuration can include such settings in an ",
    "All access to configuration within the web app should be modified in this manner to use the new IConfiguration type. Dependencies that require access to .NET Framework configuration can include such settings in an ",
    "<span id=\"page-70-0\">",
    "<span id=\"page-70-0\">",
    "ASP.NET Core apps running on .NET Framework can continue to use Entity Framework (EF). If performing an incremental migration, getting the app working with EF 6 before trying to port its data access to use EF Core may be worthwhile. In this way, any problems with the app",
    "ASP.NET Core apps running on .NET Framework can continue to use Entity Framework (EF). If performing an incremental migration, getting the app working with EF 6 before trying to port its data access to use EF Core may be worthwhile. In this way, any problems with the app",
    "As it happens, configuring EF 6 in the eShop sample migration doesn",
    "As it happens, configuring EF 6 in the eShop sample migration doesn",
    "Update the ",
    "Update the ",
    "The connection string must be passed into the constructor when the DbContext is created. Since the instances are created by Autofac, the change needs to be made in ApplicationModule. Modify the module to take in a connectionString in its constructor and assign it to a field. Then modify the registration for CatalogDBContext to add connection string as a parameter:",
    "The connection string must be passed into the constructor when the DbContext is created. Since the instances are created by Autofac, the change needs to be made in ApplicationModule. Modify the module to take in a connectionString in its constructor and assign it to a field. Then modify the registration for CatalogDBContext to add connection string as a parameter:",
    "The parameter must also be added to a new constructor overload in CatalogDBContext itself:",
    "The parameter must also be added to a new constructor overload in CatalogDBContext itself:",
    "Finally, ",
    "Finally, ",
    "With this code in place, the app runs as it did before, connecting to a SQL Server database when UseMockData is false.",
    "With this code in place, the app runs as it did before, connecting to a SQL Server database when UseMockData is false.",
    "The app can be deployed and run in production at this point, converted to ASP.NET Core but still running on .NET Framework and EF 6. If desired, the app can be migrated to run on .NET Core and Entity Framework Core, which will bring additional advantages described in earlier chapters. Specific to Entity Framework, ",
    "The app can be deployed and run in production at this point, converted to ASP.NET Core but still running on .NET Framework and EF 6. If desired, the app can be migrated to run on .NET Core and Entity Framework Core, which will bring additional advantages described in earlier chapters. Specific to Entity Framework, ",
    "Assuming a decision is made to migrate to EF Core, the steps can be fairly straightforward, especially if the original app used a code-based model approach. When ",
    "Assuming a decision is made to migrate to EF Core, the steps can be fairly straightforward, especially if the original app used a code-based model approach. When ",
    "To upgrade to EF Core 2.2, the basic steps involved are to add the appropriate NuGet package(s) and update namespaces. Then adjust how the connection string is passed to the DbContext type and how they",
    "To upgrade to EF Core 2.2, the basic steps involved are to add the appropriate NuGet package(s) and update namespaces. Then adjust how the connection string is passed to the DbContext type and how they",
    "EF Core is added as a package reference to the project:",
    "EF Core is added as a package reference to the project:",
    "The reference to EF 6 is removed:",
    "The reference to EF 6 is removed:",
    "The compiler will report errors in CatalogDBContext and CatalogDBInitializer. CatalogDbContext needs to have the old namespaces removed and replaced with Microsoft.EntityFrameworkCore. Its constructors can be removed. DbModelBuilder should be replaced with ModelBuilder. The helper methods for configuring types are moved to separate classes implementing IEntityTypeConfiguration",
    "The compiler will report errors in CatalogDBContext and CatalogDBInitializer. CatalogDbContext needs to have the old namespaces removed and replaced with Microsoft.EntityFrameworkCore. Its constructors can be removed. DbModelBuilder should be replaced with ModelBuilder. The helper methods for configuring types are moved to separate classes implementing IEntityTypeConfiguration",
    "Other changes involved include:",
    "Other changes involved include:",
    "HasDatabaseGeneratedOption(DatabaseGeneratedOption.None) replaced with ValueGeneratedNever()",
    "HasDatabaseGeneratedOption(DatabaseGeneratedOption.None) replaced with ValueGeneratedNever()",
    "HasRequired",
    "HasRequired",
    "Installed Microsoft.EntityFrameworkCore.Relational package",
    "Installed Microsoft.EntityFrameworkCore.Relational package",
    "Add a constructor to CatalogDBContext taking DbContextOptions and passing it to the base constructor",
    "Add a constructor to CatalogDBContext taking DbContextOptions and passing it to the base constructor",
    "An example configuration class for CatalogType is shown here:",
    "An example configuration class for CatalogType is shown here:",
    "The CatalogDBInitializer and its base class, CreateDatabaseIfNotExists",
    "The CatalogDBInitializer and its base class, CreateDatabaseIfNotExists",
    "Seeding data in EF Core can be done with manual scripts, or as part of the type configuration. Along with other entity properties, seed data can be configured in IEntityTypeConfiguration classes by using builder.HasData(). The original app loaded seed data from CSV files in the ",
    "Seeding data in EF Core can be done with manual scripts, or as part of the type configuration. Along with other entity properties, seed data can be configured in IEntityTypeConfiguration classes by using builder.HasData(). The original app loaded seed data from CSV files in the ",
    "The initial app includes a PreconfiguredData class, which includes data for CatalogBrand and CatalogType, so using this method the HasData call reduces to:",
    "The initial app includes a PreconfiguredData class, which includes data for CatalogBrand and CatalogType, so using this method the HasData call reduces to:",
    "The CatalogItem data can also be pulled from PreconfiguredData, and assuming the associated images are kept in source control, that is the last table needed for the app to function. The CatalogDBInitializer class can be removed, along with any references to it. The CatalogItemHiLoGenerator class and the SQL files in the Infrastructure directory are also removed, along with any references to them (in CatalogService, ApplicationModule).",
    "The CatalogItem data can also be pulled from PreconfiguredData, and assuming the associated images are kept in source control, that is the last table needed for the app to function. The CatalogDBInitializer class can be removed, along with any references to it. The CatalogItemHiLoGenerator class and the SQL files in the Infrastructure directory are also removed, along with any references to them (in CatalogService, ApplicationModule).",
    "With the elimination of the special key generator classes for CatalogItem, this code now is removed from CatalogItemConfig:",
    "With the elimination of the special key generator classes for CatalogItem, this code now is removed from CatalogItemConfig:",
    "With these modifications, the ASP.NET Core app builds, but it doesn",
    "With these modifications, the ASP.NET Core app builds, but it doesn",
    "The final version of Autofac",
    "The final version of Autofac",
    "The ported app runs, but doesn",
    "The ported app runs, but doesn",
    "dotnet ef migrations add Initial",
    "dotnet ef migrations add Initial",
    "Drop the existing ",
    "Drop the existing ",
    "dotnet ef database update",
    "dotnet ef database update",
    "This creates and seeds the database. It",
    "This creates and seeds the database. It",
    "Running the ported app at this point reveals that no pictures are shown on the page. This is because the PictureUri property of CatalogItem is never set. Looking at the list of TODO items we created",
    "Running the ported app at this point reveals that no pictures are shown on the page. This is because the PictureUri property of CatalogItem is never set. Looking at the list of TODO items we created",
    "using Visual Studio",
    "using Visual Studio",
    "The simplest fix is to reference the public image files in the site",
    "The simplest fix is to reference the public image files in the site",
    "With this change, running the app reveals the images work as before.",
    "With this change, running the app reveals the images work as before.",
    "The ",
    "The ",
    "To finish configuring CORS, you must also call app.UseCors() after building the application.",
    "To finish configuring CORS, you must also call app.UseCors() after building the application.",
    "Other advanced scenarios, like adding ",
    "Other advanced scenarios, like adding ",
    "Dependencies that use .NET Framework features that had a dependency on the legacy configuration model, such as the WCF client type and tracing code, must be modified when ported. Rather than having these types pull in their configuration information directly, they should be configured in code. For example, a connection to a WCF service that was configured in an ASP.NET app",
    "Dependencies that use .NET Framework features that had a dependency on the legacy configuration model, such as the WCF client type and tracing code, must be modified when ported. Rather than having these types pull in their configuration information directly, they should be configured in code. For example, a connection to a WCF service that was configured in an ASP.NET app",
    "Rather than relying on config files for its settings, WCF clients and other .NET Framework types should have their settings specified in code. Configured in this manner, these types can continue to work in ASP.NET Core 2.2 apps.",
    "Rather than relying on config files for its settings, WCF clients and other .NET Framework types should have their settings specified in code. Configured in this manner, these types can continue to work in ASP.NET Core 2.2 apps.",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "<span id=\"page-76-2\">",
    "<span id=\"page-76-2\">",
    "This section describes several different ASP.NET app scenarios, and offers specific techniques for solving each of them. You can use this section to identify scenarios applicable to your app, and evaluate which techniques will work for your app and its hosting environment.",
    "This section describes several different ASP.NET app scenarios, and offers specific techniques for solving each of them. You can use this section to identify scenarios applicable to your app, and evaluate which techniques will work for your app and its hosting environment.",
    "A common scenario in ASP.NET MVC 5 and Web API 2 apps was for both products to be installed in the same application. This is a supported and relatively common approach used by many teams, but because the two products use different abstractions, there is some redundant effort needed. For example, setting up routes for ASP.NET MVC is done using methods on RouteCollection, such as MapMvcAttributeRoutes() and MapRoute(). But ASP.NET Web API 2 routing is managed with HttpConfiguration and methods like MapHttpAttributeRoutes() and MapHttpRoute().",
    "A common scenario in ASP.NET MVC 5 and Web API 2 apps was for both products to be installed in the same application. This is a supported and relatively common approach used by many teams, but because the two products use different abstractions, there is some redundant effort needed. For example, setting up routes for ASP.NET MVC is done using methods on RouteCollection, such as MapMvcAttributeRoutes() and MapRoute(). But ASP.NET Web API 2 routing is managed with HttpConfiguration and methods like MapHttpAttributeRoutes() and MapHttpRoute().",
    "The eShopLegacyMVC app includes both ASP.NET MVC and Web API, and includes methods in its App",
    "The eShopLegacyMVC app includes both ASP.NET MVC and Web API, and includes methods in its App",
    "When upgrading these apps to use ASP.NET Core, this duplicate effort and the confusion that sometimes accompanies it is eliminated. ASP.NET Core MVC is a unified framework with one set of rules for routing, filters, and more. Dependency injection is built into .NET Core itself. All of this can be configured in ",
    "When upgrading these apps to use ASP.NET Core, this duplicate effort and the confusion that sometimes accompanies it is eliminated. ASP.NET Core MVC is a unified framework with one set of rules for routing, filters, and more. Dependency injection is built into .NET Core itself. All of this can be configured in ",
    "Some ASP.NET Web API apps may have action methods that return HttpResponseMessage. This type does not exist in ASP.NET Core. Below is an example of its usage in a Delete action method, using the ResponseMessage helper method on the base ApiController:",
    "Some ASP.NET Web API apps may have action methods that return HttpResponseMessage. This type does not exist in ASP.NET Core. Below is an example of its usage in a Delete action method, using the ResponseMessage helper method on the base ApiController:",
    "In ASP.NET Core MVC, there are helper methods available for all of the common HTTP response status codes, so the above method would be ported to the following code:",
    "In ASP.NET Core MVC, there are helper methods available for all of the common HTTP response status codes, so the above method would be ported to the following code:",
    "If you do find that you need to return a custom status code for which no helper exists, you can always use return StatusCode(int statusCode) to return any numeric code you like.",
    "If you do find that you need to return a custom status code for which no helper exists, you can always use return StatusCode(int statusCode) to return any numeric code you like.",
    "ASP.NET Web API 2 supports ",
    "ASP.NET Web API 2 supports ",
    "ASP.NET MVC 5 apps do not have content negotiation support built in.",
    "ASP.NET MVC 5 apps do not have content negotiation support built in.",
    "Content negotiation is preferable to returning a specific encoding type, as it is more flexible and makes the API available to a larger number of clients. If you currently have action methods that return a specific format, you should consider modifying them to return a result type that supports content negotiation when you port the code to ASP.NET Core.",
    "Content negotiation is preferable to returning a specific encoding type, as it is more flexible and makes the API available to a larger number of clients. If you currently have action methods that return a specific format, you should consider modifying them to return a result type that supports content negotiation when you port the code to ASP.NET Core.",
    "The following code returns data in JSON format regardless of client Accept header content:",
    "The following code returns data in JSON format regardless of client Accept header content:",
    null,
    null,
    "This will default to returning the data in JSON format. XML and other formats will be used ",
    "This will default to returning the data in JSON format. XML and other formats will be used ",
    "Most ASP.NET MVC and Web API apps make use of model binding. The default model binding syntax migrates fairly seamlessly between these apps and ASP.NET Core MVC. However, in some cases customers have written ",
    "Most ASP.NET MVC and Web API apps make use of model binding. The default model binding syntax migrates fairly seamlessly between these apps and ASP.NET Core MVC. However, in some cases customers have written ",
    "Once the custom binder is created, it must be registered with the app. This step requires creating another type, a ModelBinderProvider, which acts as a factory and creates the model binder during a request. Binders can be added during ApplicationStart in MVC apps as shown:",
    "Once the custom binder is created, it must be registered with the app. This step requires creating another type, a ModelBinderProvider, which acts as a factory and creates the model binder during a request. Binders can be added during ApplicationStart in MVC apps as shown:",
    "ModelBinderProviders.BinderProviders.Insert(0, ",
    "ModelBinderProviders.BinderProviders.Insert(0, ",
    "In Web API apps, custom binders can be referenced using attributes. The ModelBinder attribute can be added to action method parameters or to the parameter",
    "In Web API apps, custom binders can be referenced using attributes. The ModelBinder attribute can be added to action method parameters or to the parameter",
    "To register a model binder globally in ASP.NET Web API, its provider must be added during app startup:",
    "To register a model binder globally in ASP.NET Web API, its provider must be added during app startup:",
    "When migrating ",
    "When migrating ",
    "ASP.NET Web API supports multiple media formats and can be extended by using custom media formatters. The docs describe an ",
    "ASP.NET Web API supports multiple media formats and can be extended by using custom media formatters. The docs describe an ",
    "To create a custom formatter in Web API 2, you inherited from an appropriate base class and then added the formatter to the Web API pipeline using the HttpConfiguration object:",
    "To create a custom formatter in Web API 2, you inherited from an appropriate base class and then added the formatter to the Web API pipeline using the HttpConfiguration object:",
    "In ASP.NET Core, the process is similar. ASP.NET Core supports both input formatters (used by model binding) and output formatters (used to format responses). Adding a custom formatter to output responses in a specific way involves inheriting from an appropriate base class and adding the formatter to MVC in ",
    "In ASP.NET Core, the process is similar. ASP.NET Core supports both input formatters (used by model binding) and output formatters (used to format responses). Adding a custom formatter to output responses in a specific way involves inheriting from an appropriate base class and adding the formatter to MVC in ",
    "You",
    "You",
    "The steps to migrate from a Web API formatter to an ASP.NET Core MVC formatter are:",
    "The steps to migrate from a Web API formatter to an ASP.NET Core MVC formatter are:",
    "Identify an appropriate base class for the new formatter.",
    "Identify an appropriate base class for the new formatter.",
    "Create a new instance of the base class and implement its required methods.",
    "Create a new instance of the base class and implement its required methods.",
    "Copy over the functionality from the Web API formatter to the new implementation.",
    "Copy over the functionality from the Web API formatter to the new implementation.",
    "Configure MVC in the ASP.NET Core App",
    "Configure MVC in the ASP.NET Core App",
    "Filters are used in ASP.NET Core apps to execute code before and/or after certain stages in the request processing pipeline. ASP.NET MVC and Web API also use filters in much the same way, but the details vary. For instance, ",
    "Filters are used in ASP.NET Core apps to execute code before and/or after certain stages in the request processing pipeline. ASP.NET MVC and Web API also use filters in much the same way, but the details vary. For instance, ",
    "The most common filter used in ASP.NET MVC and Web API apps is the action filter, which is defined by an ",
    "The most common filter used in ASP.NET MVC and Web API apps is the action filter, which is defined by an ",
    "ASP.NET Core continues to support filters, and its unification of MVC and Web API means there is only one approach to their implementation. The ",
    "ASP.NET Core continues to support filters, and its unification of MVC and Web API means there is only one approach to their implementation. The ",
    "Web API have associated versions in ASP.NET Core, so migration is generally just a matter of identifying the appropriate interface and/or base class and migrating the code over.",
    "Web API have associated versions in ASP.NET Core, so migration is generally just a matter of identifying the appropriate interface and/or base class and migrating the code over.",
    "In addition to the synchronous interfaces, ASP.NET Core also provides async interfaces like IAsyncActionFilter which provide a single async method that can be used to incorporate code to run both before and after the action, as shown:",
    "In addition to the synchronous interfaces, ASP.NET Core also provides async interfaces like IAsyncActionFilter which provide a single async method that can be used to incorporate code to run both before and after the action, as shown:",
    "When migrating async code (or code that should be async), teams should consider leveraging the built in async types that are provided for this purpose.",
    "When migrating async code (or code that should be async), teams should consider leveraging the built in async types that are provided for this purpose.",
    "Most ASP.NET MVC and Web API apps do not use a large number of custom filters. Since the approach to filters in ASP.NET Core MVC is closely aligned with filters in ASP.NET MVC and Web API, the migration of custom filters is generally fairly straightforward. Be sure to read the detailed documentation on filters in ASP.NET Core",
    "Most ASP.NET MVC and Web API apps do not use a large number of custom filters. Since the approach to filters in ASP.NET Core MVC is closely aligned with filters in ASP.NET MVC and Web API, the migration of custom filters is generally fairly straightforward. Be sure to read the detailed documentation on filters in ASP.NET Core",
    "ASP.NET Core uses route constraints to help ensure requests are routed properly to route a request. ",
    "ASP.NET Core uses route constraints to help ensure requests are routed properly to route a request. ",
    "The :int after the id route parameter constrains the value to match the int type. One benefit of using route constraints is that they allow for two otherwise-identical routes to exist where the parameters differ only by their type. This allows for the equivalent of ",
    "The :int after the id route parameter constrains the value to match the int type. One benefit of using route constraints is that they allow for two otherwise-identical routes to exist where the parameters differ only by their type. This allows for the equivalent of ",
    "The set of route constraints, their syntax, and usage is very similar between all three approaches. Custom route constraints are fairly rare in customer applications. If your app uses a custom route constraint and needs to port to ASP.NET Core, the docs include examples showing ",
    "The set of route constraints, their syntax, and usage is very similar between all three approaches. Custom route constraints are fairly rare in customer applications. If your app uses a custom route constraint and needs to port to ASP.NET Core, the docs include examples showing ",
    "This is very similar to how custom constraints are used in ASP.NET Web API, which uses IHttpRouteConstraint and configures it using a resolver and a call to HttpConfiguration.MapHttpAttributeRoutes:",
    "This is very similar to how custom constraints are used in ASP.NET Web API, which uses IHttpRouteConstraint and configures it using a resolver and a call to HttpConfiguration.MapHttpAttributeRoutes:",
    "ASP.NET MVC 5 follows a very similar approach, using IRouteConstraint for its interface name and configuring the constraint as part of route configuration:",
    "ASP.NET MVC 5 follows a very similar approach, using IRouteConstraint for its interface name and configuring the constraint as part of route configuration:",
    "Migrating route constraint usage as well as custom route constraints to ASP.NET Core is typically very straightforward.",
    "Migrating route constraint usage as well as custom route constraints to ASP.NET Core is typically very straightforward.",
    "Another fairly advanced feature of ASP.NET MVC 5 is route handlers. Custom route handlers implement IRouteHandler, which includes a single method that returns an IHttpHandler for a give request. The IHttpHandler, in turn, exposes an IsReusable property and a single ProcessRequest method. In ASP.NET MVC 5, you can configure a particular route in the route table to use your custom handler:",
    "Another fairly advanced feature of ASP.NET MVC 5 is route handlers. Custom route handlers implement IRouteHandler, which includes a single method that returns an IHttpHandler for a give request. The IHttpHandler, in turn, exposes an IsReusable property and a single ProcessRequest method. In ASP.NET MVC 5, you can configure a particular route in the route table to use your custom handler:",
    "To migrate custom route handlers from ASP.NET MVC 5 to ASP.NET Core, you can either use a filter (such as an action filter) or a custom ",
    "To migrate custom route handlers from ASP.NET MVC 5 to ASP.NET Core, you can either use a filter (such as an action filter) or a custom ",
    "The IRouter option requires implementing the interface",
    "The IRouter option requires implementing the interface",
    "In ASP.NET Web API, these handlers are referred to as ",
    "In ASP.NET Web API, these handlers are referred to as ",
    "ASP.NET Core has no DelegatingHandler type or separate message handler pipeline. Instead, such handlers should be migrated using global filters, custom IRouter instances (see above), or custom middleware. ASP.NET Core MVC filters and IRouter types have the advantage of having built-in access to MVC constructs like controllers and actions, while middleware is a lower level approach that has no ties to MVC. This makes it more flexible but also requires more effort if you need to access MVC components.",
    "ASP.NET Core has no DelegatingHandler type or separate message handler pipeline. Instead, such handlers should be migrated using global filters, custom IRouter instances (see above), or custom middleware. ASP.NET Core MVC filters and IRouter types have the advantage of having built-in access to MVC constructs like controllers and actions, while middleware is a lower level approach that has no ties to MVC. This makes it more flexible but also requires more effort if you need to access MVC components.",
    "CORS, or Cross-Origin Resource Sharing, is a W3C standard that allows servers to accept requests that don",
    "CORS, or Cross-Origin Resource Sharing, is a W3C standard that allows servers to accept requests that don",
    "ASP.NET Web API can also use such a filter, but it has ",
    "ASP.NET Web API can also use such a filter, but it has ",
    "Once this is added, you can configure allowed origins, headers, and methods using the EnableCors attribute, like so:",
    "Once this is added, you can configure allowed origins, headers, and methods using the EnableCors attribute, like so:",
    "Before migrating your CORS implementation from ASP.NET MVC 5 or ASP.NET Web API 2, be sure to review ",
    "Before migrating your CORS implementation from ASP.NET MVC 5 or ASP.NET Web API 2, be sure to review ",
    "In ASP.NET Core, there are three built-in ways to enable CORS:",
    "In ASP.NET Core, there are three built-in ways to enable CORS:",
    null,
    null,
    "Enabled with ",
    "Enabled with ",
    "Enabled with the ",
    "Enabled with the ",
    "Each of these approaches is covered in detail in the docs, which are linked from the above options. Which one you choose will largely depend on how your existing app supports CORS. If the app uses attributes, you can probably migrate to use the EnableCors attribute most easily. If your app uses filters, you could continue using that approach (though it",
    "Each of these approaches is covered in detail in the docs, which are linked from the above options. Which one you choose will largely depend on how your existing app supports CORS. If the app uses attributes, you can probably migrate to use the EnableCors attribute most easily. If your app uses filters, you could continue using that approach (though it",
    "Many ASP.NET MVC apps use Areas to organize the project. Areas typically reside in the root of the project in an ",
    "Many ASP.NET MVC apps use Areas to organize the project. Areas typically reside in the root of the project in an ",
    "AreaRegistration.RegisterAllAreas();",
    "AreaRegistration.RegisterAllAreas();",
    "An alternative to registering all areas in startup is to use the RouteArea attribute on individual controllers:",
    "An alternative to registering all areas in startup is to use the RouteArea attribute on individual controllers:",
    "ASP.NET Web API apps don",
    "ASP.NET Web API apps don",
    null,
    null,
    "AreaRegistration.RegisterAllAreas is not used in ASP.NET Core MVC",
    "AreaRegistration.RegisterAllAreas is not used in ASP.NET Core MVC",
    "Areas are applied using the ",
    "Areas are applied using the ",
    "Areas can be added to the route table templates, if desired (or they can use attribute routing)",
    "Areas can be added to the route table templates, if desired (or they can use attribute routing)",
    "To add area support to the route table in ASP.NET Core MVC, you would add the following during app startup:",
    "To add area support to the route table in ASP.NET Core MVC, you would add the following during app startup:",
    "Areas can also be used with attribute routing, using the {area} keyword in the route definition (it",
    "Areas can also be used with attribute routing, using the {area} keyword in the route definition (it",
    "Tag helpers support areas with the asp-area attribute, which can be used to generate links in Razor views and pages:",
    "Tag helpers support areas with the asp-area attribute, which can be used to generate links in Razor views and pages:",
    "If you",
    "If you",
    "In addition to the above guidance, teams should review ",
    "In addition to the above guidance, teams should review ",
    "Integration tests are automated tests that verify several different parts of an app work together correctly. Writing integration tests for ASP.NET MVC and ASP.NET Web API usually involved deploying the app to a real web server, such as a local instance of IIS or IIS Express, and then making requests to this hosted application using an HTTP client. Some of these tests may interact with the client-side user interface using browser automation tools like ",
    "Integration tests are automated tests that verify several different parts of an app work together correctly. Writing integration tests for ASP.NET MVC and ASP.NET Web API usually involved deploying the app to a real web server, such as a local instance of IIS or IIS Express, and then making requests to this hosted application using an HTTP client. Some of these tests may interact with the client-side user interface using browser automation tools like ",
    "If your migrated app shares the same behavior as its original version, whatever existing technology the team is using to perform integration tests (and UI tests) should continue to work just as it did before. These tests are usually indifferent to the underlying technology used to host the app they",
    "If your migrated app shares the same behavior as its original version, whatever existing technology the team is using to perform integration tests (and UI tests) should continue to work just as it did before. These tests are usually indifferent to the underlying technology used to host the app they",
    "Teams should strongly consider migrating their integration tests to use ",
    "Teams should strongly consider migrating their integration tests to use ",
    "One of the best features of ASP.NET Core",
    "One of the best features of ASP.NET Core",
    "Below you can see an example ASP.NET Core integration test (sometimes referred to as ",
    "Below you can see an example ASP.NET Core integration test (sometimes referred to as ",
    "If the app being migrated has no integration tests, the migration process can be a great opportunity to add some. These tests can verify that the migrated app behaves as the team expects. When such tests are in place early in a migration, they can ensure that later migration efforts do not break previously migrated portions of the app. Given how easy it is to set up and run integration tests in ASP.NET Core, the return on the investment spent setting up such tests is usually pretty high.",
    "If the app being migrated has no integration tests, the migration process can be a great opportunity to add some. These tests can verify that the migrated app behaves as the team expects. When such tests are in place early in a migration, they can ensure that later migration efforts do not break previously migrated portions of the app. Given how easy it is to set up and run integration tests in ASP.NET Core, the return on the investment spent setting up such tests is usually pretty high.",
    "If your app currently relies on WCF services as a client, this scenario is supported. However, you will need to ",
    "If your app currently relies on WCF services as a client, this scenario is supported. However, you will need to ",
    "If your organization has extensive services built using WCF that your app relies on, consider migrating them to use gRPC instead. For more details on gRPC, why you may wish to migrate, and a detailed migration guide, consult the ",
    "If your organization has extensive services built using WCF that your app relies on, consider migrating them to use gRPC instead. For more details on gRPC, why you may wish to migrate, and a detailed migration guide, consult the ",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "Existing ASP.NET MVC and Web API apps run on IIS and Windows. Large apps may require a phased or side-by-side approach when porting to ASP.NET Core. In previous chapters, you learned a number of strategies for migrating large .NET Framework apps to ASP.NET Core in phases. In this chapter, you will see how different deployment scenarios can be achieved when there is a need to maintain the original app in production while migrating portions of it.",
    "Existing ASP.NET MVC and Web API apps run on IIS and Windows. Large apps may require a phased or side-by-side approach when porting to ASP.NET Core. In previous chapters, you learned a number of strategies for migrating large .NET Framework apps to ASP.NET Core in phases. In this chapter, you will see how different deployment scenarios can be achieved when there is a need to maintain the original app in production while migrating portions of it.",
    "Consider the common scenario of a large web app that currently is hosted on IIS in a single web site. Within the large app, functionality is segmented into different routes and/or directories. The app is a mix of MVC views and API endpoints. The MVC routes include many different paths based on functionality and all start from the root of the app using the standard /{controller}/{action}/{id?} route template. The API endpoints follow a similar pattern, but are all under an /api root.",
    "Consider the common scenario of a large web app that currently is hosted on IIS in a single web site. Within the large app, functionality is segmented into different routes and/or directories. The app is a mix of MVC views and API endpoints. The MVC routes include many different paths based on functionality and all start from the root of the app using the standard /{controller}/{action}/{id?} route template. The API endpoints follow a similar pattern, but are all under an /api root.",
    "Assuming the task of porting the app is split such that either the MVC functionality or the API functionality is migrated to ASP.NET Core first, how would the original site continue to function seamlessly with the new ASP.NET Core app running somewhere else? Users of the system should continue to see the same URLs they did prior to the migration, unless it",
    "Assuming the task of porting the app is split such that either the MVC functionality or the API functionality is migrated to ASP.NET Core first, how would the original site continue to function seamlessly with the new ASP.NET Core app running somewhere else? Users of the system should continue to see the same URLs they did prior to the migration, unless it",
    "Fortunately, IIS is a feature-rich web server, and two features it has are ",
    "Fortunately, IIS is a feature-rich web server, and two features it has are ",
    "As a reverse proxy, IIS can route traffic matching certain patterns to entirely separate apps, potentially on different servers.",
    "As a reverse proxy, IIS can route traffic matching certain patterns to entirely separate apps, potentially on different servers.",
    "Using just the URL Rewrite module (perhaps combined with host headers), IIS can easily support multiple web sites, each potentially running different versions of .NET. A large web app might be deployed as a collection of individual sites, each responding to different IP addresses and/or host headers, or as a single web site with one or more sub-applications in it responding to certain URL paths (which doesn",
    "Using just the URL Rewrite module (perhaps combined with host headers), IIS can easily support multiple web sites, each potentially running different versions of .NET. A large web app might be deployed as a collection of individual sites, each responding to different IP addresses and/or host headers, or as a single web site with one or more sub-applications in it responding to certain URL paths (which doesn",
    "Subdomains typically refer to the portion of a domain preceding the top two levels. For example, in the domain api.contoso.com, api is a subdomain of the contoso.com domain (which itself is composed of the contoso domain name and the .com top-level domain or TLD). URL paths refer to portion of the URL that follows the domain name, starting with a /. The URL https://contoso.com/api has a path of /api.",
    "Subdomains typically refer to the portion of a domain preceding the top two levels. For example, in the domain api.contoso.com, api is a subdomain of the contoso.com domain (which itself is composed of the contoso domain name and the .com top-level domain or TLD). URL paths refer to portion of the URL that follows the domain name, starting with a /. The URL https://contoso.com/api has a path of /api.",
    "There are pros and cons to using the same or different subdomains (and domains) to host a single app. Features like cookies and intra-app communication using mechanisms like ",
    "There are pros and cons to using the same or different subdomains (and domains) to host a single app. Features like cookies and intra-app communication using mechanisms like ",
    "In the example described above, assume the API endpoints are designated as the first part of the app to be ported to ASP.NET Core. In this case, a new ASP.NET Core app is created and hosted in IIS as a separate web ",
    "In the example described above, assume the API endpoints are designated as the first part of the app to be ported to ASP.NET Core. In this case, a new ASP.NET Core app is created and hosted in IIS as a separate web ",
    "Figure 5-1 shows how the ASP.NET Core 2.1 ",
    "Figure 5-1 shows how the ASP.NET Core 2.1 ",
    null,
    null,
    null,
    null,
    "The ",
    "The ",
    "Configured in this manner, the only change that must be made in order for the ASP.NET Core app",
    "Configured in this manner, the only change that must be made in order for the ASP.NET Core app",
    "Alternately the ASP.NET Core app can be another top-level web site in IIS. In this case, you can configure the original site to use a rewrite rule (with ",
    "Alternately the ASP.NET Core app can be another top-level web site in IIS. In this case, you can configure the original site to use a rewrite rule (with ",
    "As an example, the same ASP.NET Core app used in Figure 5-1 can be deployed to another folder configured as an IIS web site. The site should use an app pool configured just as before, with ",
    "As an example, the same ASP.NET Core app used in Figure 5-1 can be deployed to another folder configured as an IIS web site. The site should use an app pool configured just as before, with ",
    null,
    null,
    null,
    null,
    null,
    null,
    "If your app requires single sign-on between different sites or apps within IIS, refer to the documentation on ",
    "If your app requires single sign-on between different sites or apps within IIS, refer to the documentation on ",
    "Another alternative to IIS Rewrite rules is the use of a reverse proxy like ",
    "Another alternative to IIS Rewrite rules is the use of a reverse proxy like ",
    "A common approach to porting large apps from .NET Framework to ASP.NET Core is to choose individual portions of the app to migrate one by one. As each piece of the app is ported, the entire app remains running and usable, with some parts of it running in its original configuration and other parts running on some version of .NET Core. By following this approach, a large app migration can be performed incrementally. This approach results in limiting risk by providing more rapid feedback and",
    "A common approach to porting large apps from .NET Framework to ASP.NET Core is to choose individual portions of the app to migrate one by one. As each piece of the app is ported, the entire app remains running and usable, with some parts of it running in its original configuration and other parts running on some version of .NET Core. By following this approach, a large app migration can be performed incrementally. This approach results in limiting risk by providing more rapid feedback and",
    "reducing total surface area involved in testing. It also allows for more rapid realization of benefits of .NET Core, such as performance increases. Although ASP.NET Core apps are no longer required to be hosted on IIS, IIS remains a very flexible and powerful web server that can be configured to support a variety of hosting scenarios involving both .NET Framework and ASP.NET Core apps on the same IIS instance or even hosted on different servers.",
    "reducing total surface area involved in testing. It also allows for more rapid realization of benefits of .NET Core, such as performance increases. Although ASP.NET Core apps are no longer required to be hosted on IIS, IIS remains a very flexible and powerful web server that can be configured to support a variety of hosting scenarios involving both .NET Framework and ASP.NET Core apps on the same IIS instance or even hosted on different servers.",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "In this book, you",
    "In this book, you",
    "Porting a large app often entails a fair amount of risk and effort. You learned how to mitigate this risk by employing one or more ",
    "Porting a large app often entails a fair amount of risk and effort. You learned how to mitigate this risk by employing one or more ",
    "There are many architectural differences between ASP.NET and ASP.NET Core. In chapter 2, you learned about many of these differences and how they relate to your app",
    "There are many architectural differences between ASP.NET and ASP.NET Core. In chapter 2, you learned about many of these differences and how they relate to your app",
    "Large apps are often comprised of many projects and packages, and dependencies can play a major role in determining how easy or difficult migration may be. ",
    "Large apps are often comprised of many projects and packages, and dependencies can play a major role in determining how easy or difficult migration may be. ",
    "In chapter 4, you saw how a real ASP.NET MVC reference app was migrated to ASP.NET Core. This chapter included a detailed breakdown of all the changes that were needed to take the existing app and port it over to run on ASP.NET Core. Refer back to it if you have specific questions about the porting process and some of its more specific details.",
    "In chapter 4, you saw how a real ASP.NET MVC reference app was migrated to ASP.NET Core. This chapter included a detailed breakdown of all the changes that were needed to take the existing app and port it over to run on ASP.NET Core. Refer back to it if you have specific questions about the porting process and some of its more specific details.",
    "Finally, chapter 5 detailed specific deployment scenarios focused on IIS. You saw how you can use your existing IIS web server to host parts of your app that have been ported to ASP.NET Core while keeping the app",
    "Finally, chapter 5 detailed specific deployment scenarios focused on IIS. You saw how you can use your existing IIS web server to host parts of your app that have been ported to ASP.NET Core while keeping the app"
]