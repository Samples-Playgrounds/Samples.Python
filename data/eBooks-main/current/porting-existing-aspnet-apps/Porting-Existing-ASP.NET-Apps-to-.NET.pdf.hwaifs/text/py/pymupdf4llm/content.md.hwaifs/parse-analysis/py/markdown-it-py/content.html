<p>PUBLISHED BY</p>
<p>Microsoft Developer Division, .NET, and Visual Studio product teams</p>
<p>A division of Microsoft Corporation</p>
<p>One Microsoft Way</p>
<p>Redmond, Washington 98052-6399</p>
<p>Copyright © 2023 by Microsoft Corporation</p>
<p>All rights reserved. No part of this book’s contents may be reproduced or transmitted in any form or<br />
by any means without the written permission of the publisher.</p>
<p>This book is provided “as-is” and expresses the author’s views and opinions. The views, opinions, and<br />
information expressed in this book, including URL and other Internet website references, may change<br />
without notice.</p>
<p>Some examples depicted herein are provided for illustration only and are fictitious. No real association<br />
or connection is intended or should be inferred.</p>
<p><a href="https://www.microsoft.com/">Microsoft and the trademarks listed at https://www.microsoft.com</a> on the “Trademarks” webpage are<br />
trademarks of the Microsoft group of companies.</p>
<p>Mac and macOS are trademarks of Apple Inc.</p>
<p>The Docker whale logo is a registered trademark of Docker, Inc. Used by permission.</p>
<p>All other marks and logos are property of their respective owners.</p>
<p>Authors:</p>
<p><strong>Steve “ardalis” Smith</strong> <a href="https://ardalis.com/">, Software Architect and Trainer - Ardalis.com</a></p>
<p>Participants and Reviewers:</p>
<p><strong>Nish Anil</strong>, Senior Program Manager, .NET team, Microsoft</p>
<p><strong>Mike Rousos</strong>, Principal Software Engineer, .NET team, Microsoft</p>
<p><strong>Scott Addie</strong>, Senior Content Developer, .NET team, Microsoft</p>
<p><strong>David Pine</strong>, Senior Content Developer, .NET team, Microsoft</p>
<h3>Version</h3>
<p>This guide covers <strong>.NET 7</strong> and updates related to the same technology “wave” (that is, Azure and other<br />
third-party technologies) coinciding in time with the .NET 7 release. This book covers migration of<br />
apps that are currently running on .NET Framework 4.x.</p>
<h3>Who should use this guide</h3>
<p>This guide’s audience is developers, development leads, and architects who are interested in<br />
migrating their existing apps written for ASP.NET MVC and Web API (.NET Framework 4.x) to the latest</p>
<p>.NET version. ASP.NET Web Forms developers will benefit from this guide but should also read the<br />
<a href="https://docs.microsoft.com/en-us/dotnet/architecture/blazor-for-web-forms-developers/">Blazor for ASP.NET Web Forms Developers e-book.</a></p>
<p>A secondary audience is technical decision-makers planning when to move their apps to .NET 7.</p>
<p>The target audience for this book is .NET developers with large, existing apps that run on ASP.NET<br />
MVC and Web API. Apps built on ASP.NET Web Forms are outside of the focus of this book, though<br />
much of the information comparing .NET Framework and .NET Core/latest may still be relevant.</p>
<h3>How you can use this guide</h3>
<p>You can read this book straight through, as we expect many readers to do. This book will provide you<br />
first with considerations for whether you should port your app at all. That content is followed by<br />
architectural differences between .NET Framework and .NET Core. From there, you’ll learn strategies<br />
for migrating a large solution over time and how to port a real app. Next, the book includes<br />
deployment scenarios that address the need to run different apps while appearing as a single app to<br />
users. The book concludes with two case studies describing real apps that have migrated from<br />
ASP.NET MVC to ASP.NET Core.</p>
<p>Whether or not you choose to start from the first chapter, you can reference any of these chapters to<br />
learn about specific concepts:</p>
<ul>
<li>
<p>Architectural differences</p>
</li>
<li>
<p>Migrate large solutions</p>
</li>
<li>
<p>Sample migration</p>
</li>
<li>
<p>Deployment scenarios</p>
</li>
</ul>
<p><a href="https://aka.ms/aspnet-porting-ebook">This guide is available both in PDF form</a> and online. Feel free to forward this document or links to its<br />
online version to your team to ensure a common understanding of these concepts.</p>
<h2>Contents</h2>
<p><strong>Introduction to porting apps to .NET 7 ................................................................................ 1</strong></p>
<p>References .................................................................................................................................................................................. 2</p>
<p>Migration considerations ...................................................................................................................................................... 2</p>
<p>Is migration to .NET Core appropriate? ..................................................................................................................... 2</p>
<p>When is .NET Framework appropriate? ...................................................................................................................... 3</p>
<p>References .............................................................................................................................................................................. 4</p>
<p>Migrate to ASP.NET Core 2.1 .............................................................................................................................................. 4</p>
<p>Should apps run on .NET Framework with ASP.NET Core 2.1 ........................................................................... 4</p>
<p>References .............................................................................................................................................................................. 5</p>
<p>Choose the right .NET Core version ................................................................................................................................. 5</p>
<p>References .............................................................................................................................................................................. 5</p>
<p>Strategies for migrating incrementally ............................................................................................................................ 6</p>
<p>Migrating slice by slice ...................................................................................................................................................... 6</p>
<p>Migrating layer by layer .................................................................................................................................................... 6</p>
<p>References .............................................................................................................................................................................. 7</p>
<p>Strategies for migrating ASP.NET Web Forms apps .................................................................................................. 7</p>
<p>Separate business logic and other concerns............................................................................................................ 7</p>
<p>Implement client behavior and web APIs .................................................................................................................. 8</p>
<p>Consider Blazor .................................................................................................................................................................... 8</p>
<p>Summary ................................................................................................................................................................................. 8</p>
<p>References .............................................................................................................................................................................. 8</p>
<p>Deployment strategies ........................................................................................................................................................... 8</p>
<p>Cross-platform options ..................................................................................................................................................... 8</p>
<p>Cloud native development .............................................................................................................................................. 9</p>
<p>Leverage containers ........................................................................................................................................................... 9</p>
<p>Side-by-side deployment options ................................................................................................................................ 9</p>
<p>IIS on Windows .................................................................................................................................................................... 9</p>
<p>Other options on Windows ............................................................................................................................................. 9</p>
<p>i Contents</p>
<p>References .............................................................................................................................................................................. 9</p>
<p>Additional migration resources ....................................................................................................................................... 10</p>
<p>Official documentation .................................................................................................................................................. 10</p>
<p>GitHub .................................................................................................................................................................................. 10</p>
<p>Stack Overflow .................................................................................................................................................................. 11</p>
<p>YouTube channels ............................................................................................................................................................ 11</p>
<p>Twitter, Gitter, Slack, and other community channels ....................................................................................... 11</p>
<p>References ........................................................................................................................................................................... 11</p>
<p>Architectural differences between ASP.NET MVC and ASP.NET Core ............................................... 12</p>
<p>Breaking changes .................................................................................................................................................................. 12</p>
<p>App startup differences between ASP.NET MVC and ASP.NET Core ............................................................... 12</p>
<p>ASP.NET MVC Startup .................................................................................................................................................... 13</p>
<p>ASP.NET Core Startup ..................................................................................................................................................... 13</p>
<p>Porting considerations ................................................................................................................................................... 14</p>
<p>References ........................................................................................................................................................................... 14</p>
<p>Hosting differences between ASP.NET MVC and ASP.NET Core ....................................................................... 14</p>
<p>References ........................................................................................................................................................................... 15</p>
<p>Serve static files in ASP.NET MVC and ASP.NET Core ............................................................................................ 15</p>
<p>Host static files in ASP.NET MVC ............................................................................................................................... 15</p>
<p>Host static files in ASP.NET Core ................................................................................................................................ 15</p>
<p>References ........................................................................................................................................................................... 16</p>
<p>Dependency injection differences between ASP.NET MVC and ASP.NET Core ........................................... 16</p>
<p>Dependency injection in ASP.NET Core .................................................................................................................. 16</p>
<p>References ........................................................................................................................................................................... 17</p>
<p>Compare middleware to modules and handlers ...................................................................................................... 17</p>
<p>ASP.NET modules and handlers ................................................................................................................................. 17</p>
<p>ASP.NET Core middleware ............................................................................................................................................ 17</p>
<p>Accessing HttpContext................................................................................................................................................... 17</p>
<p>References ........................................................................................................................................................................... 18</p>
<p>Configuration differences between ASP.NET MVC and ASP.NET Core ........................................................... 18</p>
<p>ASP.NET MVC configuration ........................................................................................................................................ 19</p>
<p>ASP.NET Core configuration ........................................................................................................................................ 19</p>
<p>ii Contents</p>
<p>Migrate configuration .................................................................................................................................................... 20</p>
<p>References ........................................................................................................................................................................... 21</p>
<p>Routing differences between ASP.NET MVC and ASP.NET Core ....................................................................... 21</p>
<p>Routing in ASP.NET MVC and Web API .................................................................................................................. 21</p>
<p>Route table ......................................................................................................................................................................... 21</p>
<p>Routing in .NET 7 ............................................................................................................................................................. 23</p>
<p>References ........................................................................................................................................................................... 24</p>
<p>Logging differences between ASP.NET MVC and ASP.NET Core ...................................................................... 25</p>
<p>ASP.NET MVC logging ................................................................................................................................................... 25</p>
<p>ASP.NET Core logging .................................................................................................................................................... 25</p>
<p>Migrate logging ................................................................................................................................................................ 26</p>
<p>References ........................................................................................................................................................................... 26</p>
<p>Compare Razor Pages to ASP.NET MVC ...................................................................................................................... 26</p>
<p>References ........................................................................................................................................................................... 27</p>
<p>Compare ASP.NET Web API 2 and ASP.NET Core ................................................................................................... 27</p>
<p>References ........................................................................................................................................................................... 27</p>
<p>Compare authentication and authorization between ASP.NET MVC and ASP.NET Core ........................ 27</p>
<p>Authorization ..................................................................................................................................................................... 28</p>
<p>References ........................................................................................................................................................................... 28</p>
<p>Compare ASP.NET Identity and ASP.NET Core Identity ........................................................................................ 28</p>
<p>Migrate from OWIN / Katana ...................................................................................................................................... 29</p>
<p>References ........................................................................................................................................................................... 29</p>
<p>Compare controllers in ASP.NET MVC and Web API with controllers in ASP.NET Core .......................... 29</p>
<p>References ........................................................................................................................................................................... 30</p>
<p>Compare Razor usage in ASP.NET MVC and ASP.NET Core ................................................................................ 30</p>
<p>Tag Helpers ......................................................................................................................................................................... 30</p>
<p>Razor Pages ........................................................................................................................................................................ 30</p>
<p>References ........................................................................................................................................................................... 31</p>
<p>Compare ASP.NET SignalR and ASP.NET Core SignalR ......................................................................................... 31</p>
<p>Feature differences .......................................................................................................................................................... 31</p>
<p>References ........................................................................................................................................................................... 31</p>
<p>Compare testing options between ASP.NET MVC and ASP.NET Core ............................................................ 32</p>
<p>iii Contents</p>
<p>References ........................................................................................................................................................................... 32</p>
<p>Migrate large solutions to ASP.NET Core ..................................................................................................... 33</p>
<p>References ............................................................................................................................................................................... 33</p>
<p>Identify sequence of projects to migrate .................................................................................................................... 33</p>
<p>Unit tests .............................................................................................................................................................................. 37</p>
<p>Considerations for migrating many apps ............................................................................................................... 37</p>
<p>Summary .............................................................................................................................................................................. 38</p>
<p>References ........................................................................................................................................................................... 38</p>
<p>Understand and update dependencies ........................................................................................................................ 38</p>
<p>Update class library dependencies............................................................................................................................ 38</p>
<p>Update NuGet package dependencies.................................................................................................................... 39</p>
<p>Migrate ASP.NET MVC projects .................................................................................................................................. 40</p>
<p>References ........................................................................................................................................................................... 40</p>
<p>Strategies for migrating while running in production ........................................................................................... 40</p>
<p>Refactor the .NET Framework solution .................................................................................................................... 40</p>
<p>Extract front-end assets to a CDN ............................................................................................................................. 41</p>
<p>Extract and migrate individual microservices ....................................................................................................... 41</p>
<p>Deploy multiple versions of the app side-by-side in IIS ................................................................................... 41</p>
<p>Apply the Strangler pattern ......................................................................................................................................... 41</p>
<p>Multi-targeting approaches ......................................................................................................................................... 42</p>
<p>Summary .............................................................................................................................................................................. 42</p>
<p>References ........................................................................................................................................................................... 42</p>
<p>Example migration of eShop to ASP.NET Core .......................................................................................... 43</p>
<p>Run <em>ApiPort</em> to identify problematic APIs.................................................................................................................... 44</p>
<p>Update project files and NuGet reference syntax .................................................................................................... 47</p>
<p>Create new ASP.NET Core project .................................................................................................................................. 49</p>
<p>Migrating NuGet Packages .......................................................................................................................................... 51</p>
<p>Migrate static files ............................................................................................................................................................ 53</p>
<p>Migrate C# files ................................................................................................................................................................. 54</p>
<p>Migrate views ......................................................................................................................................................................... 56</p>
<p>Migrate app startup components .................................................................................................................................. 58</p>
<p>Configure MVC .................................................................................................................................................................. 58</p>
<p>iv Contents</p>
<p>Data access considerations ............................................................................................................................................... 63</p>
<p>Migrate to Entity Framework Core ............................................................................................................................ 64</p>
<p>Fix all TODO tasks ................................................................................................................................................................. 67</p>
<p>Additional MVC customizations ...................................................................................................................................... 68</p>
<p>Other dependencies ............................................................................................................................................................ 69</p>
<p>References ............................................................................................................................................................................... 69</p>
<p>More migration scenarios ................................................................................................................................................. 69</p>
<p>Migrate ASP.NET MVC 5 and WebApi 2 to ASP.NET Core MVC ................................................................... 69</p>
<p>Migrate HttpResponseMessage to ASP.NET Core .............................................................................................. 70</p>
<p>Migrate content negotiation from ASP.NET Web API to ASP.NET Core .................................................... 71</p>
<p>Custom model binding .................................................................................................................................................. 71</p>
<p>Media formatters .............................................................................................................................................................. 73</p>
<p>Custom filters ..................................................................................................................................................................... 73</p>
<p>Route constraints ............................................................................................................................................................. 74</p>
<p>Custom route handlers .................................................................................................................................................. 75</p>
<p>CORS support .................................................................................................................................................................... 76</p>
<p>Custom areas ..................................................................................................................................................................... 77</p>
<p>Integration tests for ASP.NET MVC and ASP.NET Web API............................................................................. 78</p>
<p>WCF client configuration ............................................................................................................................................... 80</p>
<p>References ........................................................................................................................................................................... 80</p>
<p>Deployment scenarios when migrating to ASP.NET Core ..................................................................... 81</p>
<p>Split a large web app ........................................................................................................................................................... 81</p>
<p>Summary .................................................................................................................................................................................. 84</p>
<p>References ............................................................................................................................................................................... 85</p>
<p>Summary: Port existing ASP.NET Apps to .NET 7 ...................................................................................... 86</p>
<p>v Contents</p>
<p><strong>CHAPTER</strong></p>
<h1>1</h1>
<h2>Introduction to porting apps to .NET 7</h2>
<p>.NET Core and its latest version, .NET 7, represent a revolutionary step forward from .NET Framework.<br />
It offers a host of advantages over .NET Framework across the board from productivity to<br />
performance, from cross-platform support to developer satisfaction. ASP.NET Core was even voted<br />
<a href="https://insights.stackoverflow.com/survey/2021#technology-most-loved-dreaded-and-wanted">the most-loved web framework (tied with Svelte) in the 2021 Stack Overflow developer survey. Clearly</a><br />
there are strong reasons to consider migrating.</p>
<p><a href="https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/">Even before .NET 7 shipped, Microsoft was clear: .NET Core is the Future of .NET. To quote this article:</a></p>
<p>New apps should be built on .NET Core. .NET Core is where future investments in .NET will happen.<br />
Existing apps are safe to remain on .NET Framework which will be supported. Existing apps that want<br />
to take advantage of the new features in .NET should consider moving to .NET Core. As we plan into<br />
the future, we will be bringing in even more capabilities to the platform.</p>
<p>Today, .NET 7 is what new apps should target, and if you’re migrating an existing app from .NET<br />
Framework, .NET 7 is your ideal target framework.</p>
<p>However, upgrading your app to ASP.NET Core will require some effort. That effort should be<br />
balanced against business value and goals. .NET Framework apps have a long life ahead of them, with<br />
support built into Windows for the foreseeable future. What are some of the questions you should<br />
consider before deciding migration to .NET 7 is appropriate? What are the expected advantages?<br />
What are the tradeoffs? How much effort is involved? These obvious questions are just the beginning,<br />
but make for a great starting point as teams consider how to support their customers’ needs with<br />
apps today and tomorrow.</p>
<ul>
<li>
<p>Is migration to .NET 7 appropriate?</p>
</li>
<li>
<p>When does it make sense to remain on .NET Framework?</p>
</li>
<li>
<p>Should apps target ASP.NET Core 2.1 as a stepping stone?</p>
</li>
<li>
<p>How should teams choose the right .NET version to target?</p>
</li>
<li>
<p>What strategies are recommended for incremental migration of large apps?</p>
</li>
<li>
<p>What deployment strategies should be considered when porting to .NET 7?</p>
</li>
<li>
<p>Where can we find additional resources?</p>
</li>
</ul>
<p>This introductory chapter addresses all of these questions and more before moving on to more<br />
specific and technical considerations in future chapters.</p>
<p>1 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<h3>References</h3>
<ul>
<li>
<p><a href="https://insights.stackoverflow.com/survey/2021#technology-most-loved-dreaded-and-wanted">2021 Stack Overflow developer survey most loved web frameworks</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/">.NET Core is the Future of .NET</a></p>
</li>
</ul>
<h3>Migration considerations</h3>
<p>The most fundamental question teams must answer when it comes to porting their apps to .NET Core<br />
is, should they port at all? In some cases, the best path forward is to remain on .NET Framework using<br />
ASP.NET MVC and/or Web API. This chapter considers reasons why moving to .NET Core makes sense.<br />
The chapter also considers scenarios and counterpoints for staying on .NET Framework.</p>
<h4><strong>Is migration to .NET Core appropriate?</strong></h4>
<p>Let’s start with some of the reasons why you might want to move to .NET Core/.NET 7. There are quite<br />
a few, so don’t consider this list exhaustive.</p>
<p><strong>Cross-platform support</strong></p>
<p>Apps built on .NET Core are truly cross-platform and can run on Windows, Linux, and macOS. Not only<br />
can your developers use whatever hardware they want, but you can also host your app anywhere.<br />
Examples range from local IIS to Azure in the cloud or from Linux Docker containers to IoT devices.</p>
<p><strong>Performance and scalability</strong></p>
<p><a href="https://www.techempower.com/benchmarks/#hw=ph&amp;test=plaintext">Apps built with .NET Core are running on one of the fastest tech stacks available anywhere. ASP.NET</a><br />
MVC apps often see performance improvements on ASP.NET Core, especially if they’re updated to<br />
take advantage of some new features available in .NET Core.</p>
<p><strong>Cloud-native</strong></p>
<p>For the above reasons and others, .NET Core apps are well-suited to running in cloud hosting<br />
environments. Lightweight and fast, .NET Core apps can be deployed to Azure App Services or<br />
containers and scaled horizontally as needed to meet immediate system demand.</p>
<p><strong>Maintainable</strong></p>
<p>For many apps, while they’ve continued to meet customer and business needs, technical debt has<br />
accumulated and maintaining the app has grown expensive. ASP.NET Core apps are more easily<br />
tested than ASP.NET MVC apps, making them easier to refactor and extend with confidence.</p>
<p><strong>Modular</strong></p>
<p>ASP.NET Core is modular, using NuGet packages as a first-class part of the framework. Apps built for<br />
.NET Core all support dependency injection, making it easy to compose solutions from whatever<br />
implementations are needed for a given environment. Building microservices with .NET Core is easier</p>
<p>2 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<p>than with ASP.NET MVC with its dependency on IIS, which opens up additional options to break up<br />
large apps into smaller modules.</p>
<p><strong>Modern</strong></p>
<p>Staying on a modern, actively developed technology stack has a host of advantages. New features<br />
and C# language features will only be added to .NET Core. The .NET Framework has had its last<br />
release with version 4.8, and versions of C# beyond 8 won’t target .NET Framework. While ASP.NET<br />
MVC will remain supported by Microsoft for many years, the best and brightest .NET software<br />
developers are likely looking to use the more modern .NET Core framework, with all of the advantages<br />
it offers (only some of which are summarized above). Finding developers with the skills to maintain an<br />
ASP.NET MVC app will start to become a challenge at some point, as will finding online training and<br />
troubleshooting assistance. There probably aren’t that many new blog posts being written about<br />
ASP.NET MVC 5, while there are plenty being written for .NET 7, for example.</p>
<p>There are many compelling reasons to consider migrating to .NET Core, which presumably is why<br />
you’re reading this book! But let’s consider some disadvantages and reasons why it may make more<br />
sense to remain on the .NET Framework.</p>
<h4><strong>When is .NET Framework appropriate?</strong></h4>
<p>The biggest reason to stay on .NET Framework is when an app isn’t under active development and<br />
wouldn’t benefit substantially from the advantages listed above. In that case, there probably isn’t a<br />
good business case to incur the cost of porting the app. If your app might benefit from the<br />
advantages .NET Core offers, you may still need to stay on .NET Framework if you need certain<br />
<a href="https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable">technologies that are unavailable on .NET Core. There are some .NET technologies that are unavailable</a><br />
<a href="https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable">on .NET Core, including AppDomains, Remoting, Code Access Security (CAS), Security Transparency,</a><br />
and System.EnterpriseServices. A brief summary of these technologies and their alternatives is<br />
included here. For more detailed guidance, see the documentation.</p>
<p><strong>Application domains</strong></p>
<p>Application domains (AppDomains) isolate apps from one another. AppDomains require runtime<br />
support and can be expensive. Creating additional app domains isn’t supported, and there are no<br />
plans to add this capability to .NET Core in the future. For code isolation, use separate processes or<br />
containers as an alternative. Some customers use AppDomains as a way of unloading assemblies. In<br />
<a href="https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability">.NET Core AssemblyLoadContext provides an alternative way to unload assemblies.</a></p>
<p><strong>WCF</strong></p>
<p><a href="https://www.nuget.org/profiles/corewcf">.NET Core and .NET 5+ support WCF clients. Server-side WCF is possible through CoreWCF, which is</a><br />
officially supported by Microsoft as of April 2022. Apps that require server-side WCF functionality can<br />
also consider a different communication technology (such as gRPC or REST) as part of a migration.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-5#windows-communication-foundation">There is a WCF client port available from the .NET Foundation. It’s entirely open source, cross</a><br />
platform, and supported by Microsoft.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/">To learn more about migrating from WCF to gRPC, consult the gRPC for WCF Developers ebook.</a></p>
<p>3 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<p><strong>Remoting</strong></p>
<p>.NET Remoting was identified as a problematic architecture. It’s used for cross-AppDomain<br />
communication, which is no longer supported. Also, Remoting requires runtime support, which is<br />
expensive to maintain. For these reasons, .NET Remoting isn’t supported on .NET Core, and the<br />
product team doesn’t plan on adding support for it in the future. There are several alternative<br />
messaging strategies and implementations you can use to replace remoting in your .NET Core apps.</p>
<p><strong>Code Access Security (CAS) and Security Transparency</strong></p>
<p>Neither of these technologies are supported by .NET Core. Instead, the recommendation is to use<br />
security boundaries provided by the operating system. For example, virtualization, containers, or user<br />
accounts. Run processes with the minimal set of privileges necessary.</p>
<h4><strong>References</strong></h4>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable">.NET Framework Technologies Unavailable on .NET Core</a></p>
<h3>Migrate to ASP.NET Core 2.1</h3>
<p>ASP.NET Core 2.1 is an interesting release because it’s the most recently supported ASP.NET Core<br />
release that supported both .NET Core and .NET Framework runtimes. As such, it may offer an easier<br />
upgrade path for some apps when compared to upgrading all parts of the app to .NET Core/.NET 7 at<br />
once. Although support for .NET Core 2.1 ended in August 2021, it may make sense as an interim step<br />
for some apps. Also, support for ASP.NET Core 2.1 running on .NET Framework will continue for as<br />
<a href="https://docs.microsoft.com/lifecycle/products/microsoft-net-framework">long as its underlying .NET Framework is supported. A complete list of currently supported ASP.NET</a><br />
<a href="https://dotnet.microsoft.com/platform/support/policy/aspnetcore-2.1">Core 2.1 packages</a> is available for reference.</p>
<h4><strong>Should apps run on .NET Framework with ASP.NET Core 2.1</strong></h4>
<p>ASP.NET Core 2.2 and earlier supported both .NET Core and .NET Framework runtimes. Does it make<br />
sense to migrate some or all of an app to ASP.NET Core 2.1 as a stepping stone, before porting over<br />
completely to .NET Core? Apps, or subsets of apps, could see their front-end ASP.NET logic ported to<br />
use ASP.NET Core, while still consuming .NET Framework libraries for business logic and infrastructure<br />
consumption. This approach may make sense when there’s a relatively thin UI layer without much<br />
business logic, and a much larger set of functionality in class libraries.</p>
<p>The main benefit of porting just the front-end web layer to ASP.NET Core 2.1 is that the existing .NET<br />
class libraries can remain as is during the initial migration. They may be in continued use by other<br />
.NET apps or simply don’t need to be in scope for the first iteration of a planned full migration to .NET<br />
Core. Reducing the scope of the initial migration for large apps helps provide incremental goals that<br />
act as stepping stones toward the desired end state, which is often a complete port to .NET Core.</p>
<p>If you have an existing app that may use this strategy, some things you can do today to help prepare<br />
for the process are to move as much business logic, data access, and other non-UI logic out of the<br />
ASP.NET projects and into separate class libraries as possible. It will also help if you have automated</p>
<p>4 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<p>test coverage of your system, so that you can verify behavior remains consistent before and after the<br />
migration.</p>
<p>If your app is so large that you can’t migrate the entire web app at once, and you need to be able to<br />
deploy the new ASP.NET Core app side-by-side with the existing ASP.NET app, there are deployment<br />
strategies that can be used to achieve this. These are covered in Chapter 5: Deployment Scenarios.</p>
<p>Keep in mind that ASP.NET Core 2.1 was the last LTS release of .NET Core that supported running on<br />
.NET Framework and consuming .NET Framework libraries. Although the release is now unsupported<br />
on .NET Core, it continues to be supported for use with .NET Framework. It will remain supported for<br />
<a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core">as long as the specific .NET Framework version is supported. For more information, see ASP.NET Core</a><br />
<a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core">2.1 on .NET Framework.</a></p>
<h4><strong>References</strong></h4>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/?preserve-view=true&amp;view=aspnetcore-2.1">Migrating from ASP.NET to ASP.NET Core 2.1</a> <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core">ASP.NET Core 2.1 on .NET Framework</a> <a href="https://dotnet.microsoft.com/en-us/platform/support/policy/aspnetcore-2.1">ASP.NET Core 2.1</a><br />
<a href="https://dotnet.microsoft.com/en-us/platform/support/policy/aspnetcore-2.1">Supported Packages</a></p>
<h3>Choose the right .NET Core version</h3>
<p>The largest consideration for most organizations when choosing which version of .NET to target is the<br />
support lifecycle. Long Term Support (LTS) releases ship less frequently but have a longer support<br />
window than Standard Term Support (STS) releases. Currently, LTS releases are scheduled to ship<br />
every other year. Customers can choose which releases to target, and can install different releases of<br />
.NET side by side on the same machine. LTS releases will receive only critical and compatible fixes<br />
throughout their lifecycle. STS releases will receive these same fixes and will also be updated with<br />
compatible innovations and features. LTS releases are supported for three years after their initial<br />
release. STS releases are supported for six months after a subsequent STS or LTS release.</p>
<p>.NET 7 is the latest STS release; .NET 6 is the latest LTS release.</p>
<p>Customers looking to migrate a large .NET Framework app to .NET today may be looking for a stable<br />
destination, given that they haven’t already made the move to an earlier version of .NET Core. In this<br />
case, the best .NET version to target for the migration is .NET 6, which is the most recent LTS version.<br />
While support for .NET Core 3.1 ended in December 2022, support for .NET 6 will continue until<br />
November 2024.</p>
<p>Other customers may want to ensure they’re upgrading to the latest supported version, so that postmigration they’re not already behind a version. These customers will want to target .NET 7 for the<br />
migration.</p>
<p>In either case, there is very little difference in the migration process. This book assumes .NET<br />
Framework apps will be upgraded to .NET 7.</p>
<h4><strong>References</strong></h4>
<p><a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core">.NET and .NET Core Support Policy</a></p>
<p>5 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<h3>Strategies for migrating incrementally</h3>
<p>The biggest challenge with migrating any large app is determining how to break the process into<br />
smaller tasks. There are several strategies that can be applied for this purpose, including breaking the<br />
app into horizontal layers such as UI, data access, business logic, or breaking up the app into separate,<br />
smaller apps. Another strategy is to upgrade some or all of the app to different framework versions on<br />
<a href="https://deviq.com/practices/vertical-slices">the way to a recent .NET Core release. One approach you could use is to migrate vertical slices of the</a><br />
app, rather than attempting to migrate one horizontal layer at a time. Let’s consider each of these<br />
different approaches.</p>
<h4><strong>Migrating slice by slice</strong></h4>
<p>One successful approach to migrating is to identify vertical slices of functionality and migrate them to<br />
the target platform one by one. The first step is to create a new ASP.NET Core 7 app. Next, identify the<br />
individual page or API endpoint that will be migrated first. Build out just the necessary functionality to<br />
support this one route in the new ASP.NET Core app. Then use HTTP rewriting and/or a reverse proxy<br />
to start sending requests for these pages or endpoints to the new app rather than the ASP.NET app.<br />
This approach is well-suited to API projects, but can also work for many MVC apps.</p>
<p>When migrating slice by slice, the entire stack of the individual API endpoint or requested route is<br />
recreated in the new project or solution. The very first such slice typically requires the most effort,<br />
since it will typically need several projects to be created and decisions to be made about data access<br />
and solution organization. Once the first slice’s functionality mirrors the existing app’s, it can be<br />
deployed and the existing app can redirect to it or simply be removed. This approach is then repeated<br />
until the entire app has been ported to the new structure.</p>
<p>Some specific guidance on how to follow this strategy using IIS is covered in Chapter 5, Deployment<br />
Scenarios.</p>
<h4><strong>Migrating layer by layer</strong></h4>
<p>Consider the challenge of migrating a large ASP.NET 4.5 app. One approach is to migrate the entire<br />
app directly from .NET Framework 4.5 to .NET 7. However, this approach needs to account for every<br />
breaking change between the two frameworks and versions, which are substantial. Performing this<br />
work on one project at a time provides a set of stepping stones so that the entire solution doesn’t<br />
need to be moved at once.</p>
<p>One piece of the .NET ecosystem that helps with interoperability between different .NET frameworks is<br />
<a href="https://dotnet.microsoft.com/platform/dotnet-standard">.NET Standard. .NET Standard allows libraries to build against an agreed upon set of common APIs,</a><br />
ensuring they can be used in any .NET app. .NET Standard 2.0 is notable because it covers most base<br />
class library functionality used by most .NET Framework and .NET Core apps. Unfortunately, the<br />
earliest version of .NET with support for .NET Standard 2.0 is .NET Framework 4.6.1, and there are a<br />
number of updates in .NET Framework 4.8 that make it a compelling choice for initial upgrades.</p>
<p>One approach to incrementally upgrade a .NET Framework 4.5 system layer-by-layer is to first update<br />
its class library dependencies to .NET Framework 4.8. Then, modify these libraries to be .NET Standard<br />
class libraries. Use multi-targeting and conditional compilation, if necessary. This step can be helpful</p>
<p>6 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<p>in scenarios where app dependencies require .NET Framework and cannot easily be ported directly to<br />
use .NET Standard and .NET Core. Since .NET Framework libraries can be consumed by ASP.NET Core<br />
2.1 apps, the next step is to migrate some or all of the web functionality of the app to ASP.NET Core<br />
2.1 (as described in the previous chapter). This is a “bottom up” approach, starting with low level class<br />
library dependencies and working up to the web app entry point.</p>
<p>Once the app is running on ASP.NET Core 2.1, migrating it to .NET 7 in isolation is relatively<br />
straightforward. The most likely challenge during this step is updating incompatible dependencies to<br />
support .NET Core and possibly higher versions of .NET Standard. For apps that don’t have<br />
problematic dependencies on .NET Framework-only libraries, there’s little reason to upgrade to<br />
ASP.NET Core 2.1. Porting directly to ASP.NET Core 7 makes more sense and requires less effort.</p>
<p>.NET 7 is the latest version of .NET and will be supported until six months after the next STS or LTS<br />
release (scheduled for November 2023) - so most likely support will last at least until May 2024. Many<br />
teams looking to migrate today will choose to upgrade to .NET 7.</p>
<p>Instead of a “bottom up” approach, another alternative is to start with the web app (or even the entire<br />
<a href="https://aka.ms/dotnet-upgrade-assistant">solution) and use an automated tool to assist with the upgrade. The .NET Upgrade Assistant tool can</a><br />
be used to help upgrade .NET Framework apps to .NET Core / .NET 7. It automates many of the<br />
common tasks related to upgrading apps, such as modifying project file format, setting appropriate<br />
target frameworks, updating NuGet dependencies, and more.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://dotnet.microsoft.com/platform/dotnet-standard">What is .NET Standard?</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/60-70">Migrate from ASP.NET Core 6.0 to 7.0</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/dotnet/announcing-net-6/">Announcing .NET 6 - The Fastest .NET Yet</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/dotnet/introducing-net-5/">Introducing .NET 5</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/31-to-60">Migrate from ASP.NET Core 3.1 to 6.0 LTS</a></p>
</li>
<li>
<p><a href="https://aka.ms/dotnet-upgrade-assistant">.NET Upgrade Assistant tool</a></p>
</li>
</ul>
<h3>Strategies for migrating ASP.NET Web Forms apps</h3>
<p>This book offers guidance for migrating large ASP.NET MVC and Web API apps to .NET Core. Some of<br />
these ASP.NET apps may also include Web Forms ( <em>.aspx</em> ) pages that must be addressed. ASP.NET Web<br />
Forms isn’t supported in ASP.NET Core (nor are ASP.NET Web Pages). Typically, the functionality of<br />
these pages must be rewritten when porting to ASP.NET Core. There are, however, some strategies<br />
you can apply before or during such migration to help reduce the overall effort required.</p>
<p>Web Forms will continue to be supported for quite some time. One option may be to keep this<br />
functionality in an ASP.NET 4.x app.</p>
<h4><strong>Separate business logic and other concerns</strong></h4>
<p>The less code in your ASP.NET Web Forms pages, the better. When possible, keep business logic and<br />
other concerns like data access in separate classes, ideally in separate class libraries. These class<br />
libraries can be ported to .NET Standard and consumed by any ASP.NET Core app.</p>
<p>7 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<h4><strong>Implement client behavior and web APIs</strong></h4>
<p>Consider the choice between implementing logic in Web Forms or in the browser with the help of API<br />
calls. Favor the latter. Migrating APIs to ASP.NET Core is supported. Client-side behavior should be<br />
independent of the server-side stack your app is using. Using this approach has the added benefit of<br />
providing a more responsive user experience.</p>
<h4><strong>Consider Blazor</strong></h4>
<p>Blazor lets you build interactive web UIs with C# instead of JavaScript. It can run on the server or in<br />
the browser using WebAssembly. ASP.NET Web Forms apps may be ported page-by-page to Blazor<br />
<a href="https://devblogs.microsoft.com/aspnet/blazor-aspnet-webforms-ebook/">apps. For more information on porting Web Forms apps to Blazor, see Blazor for ASP.NET Web Forms</a><br />
<a href="https://devblogs.microsoft.com/aspnet/blazor-aspnet-webforms-ebook/">Developers. In addition, many Web Forms controls have been ported to Blazor as part of an open-</a><br />
<a href="https://fritzandfriends.github.io/BlazorWebFormsComponents/">source community project, Blazor Web Forms Components. With these components, you can more</a><br />
easily port Web Forms pages to Blazor even if they use the built-in Web Forms controls.</p>
<h4><strong>Summary</strong></h4>
<p>Migrating directly from ASP.NET Web Forms to ASP.NET Core isn’t supported. However, there are<br />
strategies to make moving to ASP.NET Core easier. You can migrate your Web Forms functionality to<br />
ASP.NET Core successfully by:</p>
<ul>
<li>
<p>Keeping non-web functionality out of your projects.</p>
</li>
<li>
<p>Using web APIs wherever possible.</p>
</li>
<li>
<p>Considering Blazor as an option for a more modern UI.</p>
</li>
</ul>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://devblogs.microsoft.com/aspnet/blazor-aspnet-webforms-ebook/">Free e-book: Blazor for ASP.NET Web Forms Developers</a></p>
</li>
<li>
<p><a href="https://fritzandfriends.github.io/BlazorWebFormsComponents/">Blazor Web Forms Components (Community Project)</a></p>
</li>
</ul>
<h3>Deployment strategies</h3>
<p>One consideration as you plan the migration of your large ASP.NET app to ASP.NET Core is how you’ll<br />
deploy the new app. With ASP.NET, deployment options were limited to IIS on Windows. With<br />
ASP.NET Core, a much wider array of deployment options is available.</p>
<h4><strong>Cross-platform options</strong></h4>
<p>Because .NET Core runs on Linux, you’ll find some hosting options available that weren’t a<br />
consideration previously. Linux-based hosting may be preferable for the following reasons:</p>
<ul>
<li>
<p>Your organization has infrastructure or expertise.</p>
</li>
<li>
<p>Hosting providers offer attractive features or pricing for Linux-based hosting.</p>
</li>
</ul>
<p>.NET Core opens the door to these options.</p>
<p>8 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<h4><strong>Cloud native development</strong></h4>
<p>Most organizations today are using cloud platforms for at least some of their software capabilities.<br />
With an app migration to .NET Core, it’s a good time to consider whether the app should be<br />
purposefully written with cloud hosting in mind. Such <em>cloud native</em> apps are better able to apply cloud<br />
capabilities like serverless, microservices, and can be less concerned with the low-level details of how<br />
and where they may be deployed.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/architecture/cloud-native/">Learn more about cloud native app development in this free e-book, Architecting Cloud Native .NET</a><br />
<a href="https://docs.microsoft.com/en-us/dotnet/architecture/cloud-native/">Applications for Azure.</a></p>
<h4><strong>Leverage containers</strong></h4>
<p>Modern apps often leverage containers as a means of reducing variation between hosting<br />
environments. By deploying an app to a particular container, the container-hosted app will run the<br />
same whether it’s running on a developer’s laptop or in production. As part of a migration to .NET<br />
Core, it may make sense to consider whether the app would benefit from deployment via container,<br />
either as a full monolith or broken up into multiple smaller containerized apps.</p>
<h4><strong>Side-by-side deployment options</strong></h4>
<p>Migrating large .NET Framework apps to .NET Core often requires a substantial effort. Most<br />
organizations will want to be able to break this effort up in some fashion, so that pieces of the app<br />
can be migrated and deployed in production before the entire migration is complete. Running both<br />
the original ASP.NET app and its newly-migrated ASP.NET Core sub-app(s) side by side is a frequently<br />
cited goal. This can be achieved through a number of mechanisms including leveraging IIS routing,<br />
which is covered in chapter 5. Other options include leveraging app gateways or cloud design<br />
<a href="https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends">patterns like backends for frontends to manage sets of ASP.NET Web APIs and ASP.NET Core API</a><br />
endpoints.</p>
<h4><strong>IIS on Windows</strong></h4>
<p>You can continue hosting your apps on IIS running on Windows. This is a fine option for customers<br />
who want to take advantage of ASP.NET Core features without changing their current deployment<br />
model. While moving to ASP.NET Core provides more options in terms of how and where to deploy<br />
your apps, it doesn’t require that you change from the status quo of using the proven combination of<br />
IIS on Windows.</p>
<h4><strong>Other options on Windows</strong></h4>
<p>You can host apps side-by-side apps on Windows using any combination of Kestrel, HTTP.sys, and IIS<br />
hosts, in addition to Docker containers, if needed. If your app requires a combination of Windows and<br />
<a href="https://docs.microsoft.com/windows/wsl/about">Linux services, hosting on a Windows server with WSL</a> and/or Linux Docker containers provides a<br />
single server solution to hosting all parts of the app.</p>
<h4><strong>References</strong></h4>
<ul>
<li><a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/">Host and deploy ASP.NET Core</a></li>
</ul>
<p>9 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/iis/">Host ASP.NET Core on Windows with IIS</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/test/troubleshoot-azure-iis">Troubleshooting ASP.NET Core on Azure App Service and IIS</a></p>
</li>
</ul>
<h3>Additional migration resources</h3>
<p>As you’re planning and executing your migration from ASP.NET MVC and/or Web API to ASP.NET<br />
Core, there are a number of resources available to help beyond this book. Make a note of these and<br />
leverage them where appropriate to help you overcome obstacles you encounter on your migration<br />
journey.</p>
<h4><strong>Official documentation</strong></h4>
<p><a href="https://docs.microsoft.com/">The official documentation website, learn.microsoft.com, has the most up-to-date information</a><br />
available about versions, frameworks, breaking changes, and support options. You’ll find many links in<br />
this book to docs articles, but for any problem you’re facing it’s often worth at least doing a quick<br />
search of the docs to see if there is already information covering the issue and offering a solution or<br />
workaround.</p>
<h4><strong>GitHub</strong></h4>
<p>Because .NET Core is an open-source project, many issues are discovered, reported, discussed, and<br />
fixed on GitHub. Microsoft has several GitHub organizations in which you’ll find repositories that may<br />
be helpful. A partial list of these organizations and some of their public repositories are listed below:</p>
<ul>
<li>
<p><a href="https://github.com/microsoft">Microsoft</a></p>
<ul>
<li><a href="https://github.com/microsoft/aspnet-api-versioning">ASP.NET API Versioning</a></li>
</ul>
</li>
<li>
<p><a href="https://github.com/dotnet">dotnet</a></p>
<ul>
<li>
<p><a href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet/runtime">.NET Runtime</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet/efcore">Entity Framework Core</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet/csharplang">C# Language</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet/docs">Docs</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet/samples">Docs Samples</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet/try-convert">Try Convert</a></p>
</li>
<li>
<p><a href="https://aka.ms/dotnet-upgrade-assistant">.NET Upgrade Assistant tool</a></p>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/dotnet-architecture">.NET Architecture Reference Apps</a></p>
<ul>
<li>
<p><a href="https://github.com/dotnet-architecture/eShopModernizing">eShopModernizing</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet-architecture/eShopOnWeb">eShopOnWeb</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a></p>
</li>
</ul>
</li>
</ul>
<p>If you run into problems with your migration, these GitHub repositories are a good place to report<br />
them. The product teams watch the issues and typically respond quickly to bug reports (though “how<br />
to” questions may be more appropriately directed to Stack Overflow).</p>
<p>10 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<h4><strong>Stack Overflow</strong></h4>
<p><a href="https://stackoverflow.com/">Stack Overflow</a> has a wealth of information in the form of previous questions asked and answers<br />
given, with the most helpful answers listed first and marked if they solved the problem. In addition to<br />
searching for an existing solution to a problem you may encounter, you can of course also ask a<br />
question yourself and hope for some response from the .NET community. Don’t forget you can narrow<br />
down a search by using tags, and remember to use appropriate tags when you ask questions to<br />
maximize the chances of someone with the experience needed noticing your question.</p>
<h4><strong>YouTube channels</strong></h4>
<p>YouTube has a huge amount of .NET and .NET Core video content, which may include useful tutorials<br />
or walkthroughs covering any scenario you may encounter. Consider searching it separately if your<br />
other efforts to find help online come up short. Here are a few good places to get started:</p>
<ul>
<li>
<p><a href="https://www.youtube.com/dotnet">dotnet</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/visualstudio">Visual Studio</a></p>
</li>
</ul>
<h4><strong>Twitter, Gitter, Slack, and other community channels</strong></h4>
<p><a href="https://dotnet.microsoft.com/platform/community">You’ll find many other ways to connect with .NET developers on the .NET Community page. You can</a><br />
<a href="https://aka.ms/dotnet-discord">also join the DotNetEvolution Discord server. Additionally, many product teams and team members</a><br />
are on Twitter as well as in various other communities. You can follow and communicate with the<br />
<a href="https://twitter.com/ardalis">author of this book on Twitter as well.</a></p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/porting/">Overview of porting from .NET Framework to .NET Core</a></p>
</li>
<li>
<p><a href="https://aka.ms/dotnet-upgrade-assistant">.NET Upgrade Assistant tool</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/porting/">Migrate from ASP.NET to ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://dotnet.microsoft.com/platform/community">.NET Community Resources</a></p>
</li>
</ul>
<p>11 CHAPTER 1 | Introduction to porting apps to .NET 7</p>
<p><strong>CHAPTER</strong></p>
<h1>2</h1>
<h2>Architectural differences between ASP.NET MVC and ASP.NET Core</h2>
<p>There are many architectural differences between ASP.NET MVC on .NET Framework and ASP.NET<br />
Core. It’s important to have a broad understanding of these differences as teams evaluate the work<br />
involved in porting their ASP.NET MVC apps to ASP.NET Core. This chapter looks at each of the ways<br />
in which ASP.NET Core differs substantially from ASP.NET MVC.</p>
<h3>Breaking changes</h3>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/compatibility/fx-core">.NET Core is a cross-platform rewrite of .NET Framework. There are many breaking changes between</a><br />
<a href="https://docs.microsoft.com/en-us/dotnet/core/compatibility/fx-core">the two frameworks. The following sections identify specific differences between how ASP.NET MVC</a><br />
and ASP.NET Core apps are designed and developed. Take care to also examine the documentation to<br />
determine which framework libraries you’re using that may need to change. In many cases, a<br />
replacement NuGet package exists to fill in any gaps left between .NET Framework and .NET Core. In<br />
rare cases, you may need to find a third-party solution or implement new custom code to address<br />
incompatibilities.</p>
<h3>App startup differences between ASP.NET MVC and ASP.NET Core</h3>
<p>ASP.NET MVC apps lived entirely within Internet Information Server (IIS), the primary web server<br />
available on Windows operating systems. Unlike ASP.NET MVC, ASP.NET Core apps are executable<br />
apps. You can run them from the command line, using dotnet run. They have an entry point method<br />
like all C# programs, typically public static void Main() or a similar variation (perhaps with arguments<br />
or async support). This is perhaps the biggest architectural difference between ASP.NET Core and<br />
ASP.NET MVC, and is one of several differences that allows ASP.NET Core to run on non-Windows<br />
systems.</p>
<p>12 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<h4><strong>ASP.NET MVC Startup</strong></h4>
<p>Hosted within IIS, ASP.NET apps rely on IIS to instantiate certain objects and call certain methods<br />
when a request arrives. ASP.NET creates an instance of the <em>Global.asax</em> file’s class, which derives from<br />
HttpApplication. When the first request is received, before handling the request itself, ASP.NET calls<br />
the Application_Start method in the <em>Global.asax</em> file’s class. Any logic that needs to run when the<br />
ASP.NET MVC app begins can be added to this method.</p>
<p><a href="https://github.com/davidebbo/WebActivator">Many NuGet packages for ASP.NET MVC and Web API use the WebActivator</a> package to let them run<br />
some code during app startup. By convention, this code would typically be added to an <em>App_Start</em><br />
folder and would be configured via attribute to run either immediately before or just after<br />
Application_Start.</p>
<p><a href="https://docs.microsoft.com/aspnet/aspnet/overview/owin-and-katana/getting-started-with-owin-and-katana">It’s also possible to use the Open Web Interface for .NET (OWIN) and Project Katana with ASP.NET</a><br />
<a href="https://docs.microsoft.com/aspnet/aspnet/overview/owin-and-katana/getting-started-with-owin-and-katana">MVC. When doing so, the app will include a</a> <em>Startup.cs</em> file that is responsible for setting up request<br />
middleware in a way that’s very similar to how ASP.NET Core behaves.</p>
<p>If you need to run code when your ASP.NET MVC app starts up, it will typically use one of these<br />
approaches.</p>
<h4><strong>ASP.NET Core Startup</strong></h4>
<p>As noted previously, ASP.NET Core apps are standalone programs. As such, they typically include a<br />
<em>Program.cs</em> file containing the entry point for the app. A typical example of this file is shown in Figure<br />
2-1. Notice that in .NET 7, this file is streamlined by the use of implicit using statements and top-level<br />
statements, eliminating the need for a lot of “boiler plate” code.</p>
<p><em>Figure 2-1. A typical ASP.NET Core Program.cs file.</em></p>
<p>13 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>The code shown in Figure 2-1 uses a builder to configure the host and its services. Then, it creates the<br />
request pipeline for the app, which controls how every request to the app is handled.</p>
<p>Previous versions of .NET would use a separate <em>Startup.cs</em> file, referenced by <em>Program.cs</em> . This approach<br />
is still supported in .NET 7, but is no longer the default approach.</p>
<p>In addition to code related to configuring the app’s services and request pipeline, apps may have<br />
other code that must run when the app begins. Such code is typically placed in <em>Program.cs</em> or<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host">registered as an IHostedService, which will be started by the generic host when the app starts.</a></p>
<p>The IHostedService interface just exposes two methods, StartAsync and StopAsync. You register the<br />
interface when configuring the app’s services and the host does the rest, calling the StartAsync<br />
method before the app starts up.</p>
<h4><strong>Porting considerations</strong></h4>
<p>Teams looking to migrate their apps from ASP.NET MVC to ASP.NET Core need to identify what code<br />
is being run when their app starts up and determine the appropriate location for such code in their<br />
ASP.NET Core app. For custom code needed to run when the app starts up, especially async code, the<br />
recommended approach is typically to put such code into IHostedService implementations.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/previous-versions/aspnet/bb470252(v=vs.100)">ASP.NET Application Life Cycle Overview for IIS 7</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/previous-versions/aspnet/ms178473(v=vs.100)">ASP.NET Application Life Cycle Overview for IIS 5 and 6</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/aspnet/overview/owin-and-katana/getting-started-with-owin-and-katana">Getting Started with OWIN and Katana</a></p>
</li>
<li>
<p><a href="https://github.com/davidebbo/WebActivator">WebActivator</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/startup">App Startup in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host">.NET Generic Host in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/background-tasks-with-ihostedservice">IHostedService</a></p>
</li>
</ul>
<h3>Hosting differences between ASP.NET MVC and ASP.NET Core</h3>
<p>ASP.NET MVC apps are hosted in IIS, and may rely on IIS configuration for their behavior. This often<br />
<a href="https://docs.microsoft.com/iis/get-started/introduction-to-iis/iis-modules-overview">includes IIS modules. As part of reviewing an app to prepare to port it from ASP.NET MVC to ASP.NET</a><br />
Core, teams should identify which modules, if any, they’re using from the list of IIS Modules installed<br />
on their server.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/servers/">ASP.NET Core apps can run on a number of different servers. The default cross platform server,</a><br />
Kestrel, is a good default choice. Apps running in Kestrel can be hosted by IIS, running in a separate<br />
process. On Windows, apps can also run in process on IIS or using HTTP.sys. Kestrel is generally<br />
recommended for best performance. HTTP.sys can be used in scenarios where the app is exposed to<br />
the Internet and required capabilities are supported by HTTP.sys but not Kestrel.</p>
<p>14 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>Kestrel does not have an equivalent to IIS modules (though apps hosted in IIS can still take advantage<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/middleware/">of IIS modules). To achieve equivalent behavior, middleware</a> configured in the ASP.NET Core app itself<br />
is typically used.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/iis/get-started/introduction-to-iis/iis-modules-overview">IIS Modules</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/middleware/">ASP.NET Core Middleware</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/servers/">ASP.NET Core Servers</a></p>
</li>
</ul>
<h3>Serve static files in ASP.NET MVC and ASP.NET Core</h3>
<p>Most web apps involve a combination of server-side logic and static files that must be sent to the<br />
client as-is. How should your migration from ASP.NET MVC to ASP.NET Core handle serving static<br />
files?</p>
<h4><strong>Host static files in ASP.NET MVC</strong></h4>
<p>ASP.NET MVC apps, hosted by IIS, typically host static files directly from the app. ASP.NET MVC<br />
supports placing static files side by side with files that should be kept private on the server. IIS and<br />
ASP.NET require explicitly restricting certain files or file extensions from being served from the folder<br />
in which an ASP.NET app is hosted.</p>
<p><a href="https://docs.microsoft.com/azure/architecture/patterns/static-content-hosting">For many static files, using a content delivery network (CDN) is a good practice. Static content hosting</a><br />
allows better performance while reducing load and bandwidth from app servers.</p>
<h4><strong>Host static files in ASP.NET Core</strong></h4>
<p>It may be surprising, but ASP.NET Core doesn’t have built-in support for static files. This feature that<br />
has always existed as just a part of ASP.NET, enabled by IIS, isn’t intrinsic to ASP.NET Core or its<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/static-files">Kestrel web server. To serve static files from an ASP.NET Core app, you must configure static files</a><br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/static-files">middleware.</a></p>
<p>With static files middleware configured, an ASP.NET Core app will serve all files located in a certain<br />
folder (typically <em>/wwwroot</em> ). No other files in the app or project folder are at risk of being accidentally<br />
exposed by the server. No special restrictions based on file names or extensions need to be<br />
configured, as is the case with IIS. Instead, developers explicitly choose to expose files publicly when<br />
they place them in the <em>wwwroot</em> folder. By default, files outside of this folder aren’t shared.</p>
<p>Because support for static files uses middleware, any other middleware can be applied as part of the<br />
same request pipeline. Examples of middleware include authentication, caching, and compression.</p>
<p>Of course, CDNs remain a good choice for ASP.NET Core apps for all the same reasons they’re used in<br />
ASP.NET MVC apps. As part of preparing to migrate to .NET Core, if there are benefits your app could<br />
realize from using a CDN, it would be good to move static files to a CDN before migrating to .NET<br />
Core. Doing so reduces the migration effort’s overall scope for static assets.</p>
<p>15 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/azure/architecture/patterns/static-content-hosting">Static content hosting</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/static-files">Static files in ASP.NET Core</a></p>
</li>
</ul>
<h3>Dependency injection differences between ASP.NET MVC and ASP.NET Core</h3>
<p>Although dependency injection (DI) isn’t built into ASP.NET MVC or Web API, many apps enable it by<br />
adding a NuGet package with an inversion of control (IOC) container. These are sometimes referred to<br />
as DI containers, for dependency injection (or inversion). Some of the most popular containers used in<br />
ASP.NET MVC apps include:</p>
<ul>
<li>
<p><a href="https://www.autofac.org/">Autofac</a></p>
</li>
<li>
<p><a href="https://unitycontainer.github.io/">Unity</a></p>
</li>
<li>
<p><a href="http://www.ninject.org/">Ninject</a></p>
</li>
<li>
<p><a href="http://structuremap.github.io/">StructureMap</a> <em>(deprecated)</em></p>
</li>
<li>
<p><a href="http://www.castleproject.org/projects/windsor/">Castle Windsor</a></p>
</li>
</ul>
<p>If your ASP.NET MVC app isn’t using DI, you will probably want to investigate the built-in support for<br />
DI in ASP.NET Core. DI promotes loose coupling of modules in your app and enables better testability<br />
<a href="https://www.weeklydevtips.com/episodes/047">and adherence to principles like SOLID.</a></p>
<p>If your app does use DI, then probably your best course of action is to see if the container you’re<br />
using supports ASP.NET Core. If so, you may be able to continue using it and your custom<br />
configuration rules describing your type mappings and lifetimes.</p>
<p>Either way, you should consider using the built-in support for DI that ships with ASP.NET Core, as it<br />
may meet your app’s needs.</p>
<h4><strong>Dependency injection in ASP.NET Core</strong></h4>
<p>ASP.NET Core assumes apps will use DI. It’s not just built into the framework, but is required in order<br />
to bring support for framework features into your ASP.NET Core apps. In app startup, calls are made<br />
to configure services using the builder.Services property of the web host builder. This property works<br />
with the application’s DI container (service collection/service provider) and is used to create and inject<br />
service dependencies within the app. Built-in ASP.NET Core features like Entity Framework Core,<br />
Identity, and even MVC are brought into the app by configuring them as services during application<br />
startup.</p>
<p>In addition to using the default implementation, apps can still use custom containers. The<br />
<a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines#default-service-container-replacement">documentation covers how to replace the default service container.</a></p>
<p>DI is fundamental to ASP.NET Core. If your team isn’t already well-versed in this practice, you’ll want<br />
to understand it before porting your app.</p>
<p>16 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection">Dependency Injection in .NET</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection">Dependency Injection in ASP.NET Core</a></p>
</li>
</ul>
<h3>Compare middleware to modules and handlers</h3>
<p>If your existing ASP.NET MVC or Web API app uses OWIN/Katana, you’re most likely already familiar<br />
with the concept of middleware and porting it to ASP.NET Core should be fairly straightforward.<br />
However, most ASP.NET apps rely on HTTP modules and HTTP handlers instead of middleware.<br />
Migrating these to ASP.NET Core requires extra effort.</p>
<h4><strong>ASP.NET modules and handlers</strong></h4>
<p><a href="https://docs.microsoft.com/troubleshoot/aspnet/http-modules-handlers">HTTP modules and HTTP handlers are an integral part of the ASP.NET architecture. While a request is</a><br />
being processed, each request is processed by multiple HTTP modules (for example, the<br />
authentication module and the session module) and is then processed by a single HTTP handler. After<br />
the handler has processed the request, the request flows back through the HTTP modules.</p>
<p>If your app is using custom HTTP modules or HTTP handlers, you’ll need a plan to migrate them to<br />
ASP.NET Core. The most likely replacement in ASP.NET Core is middleware.</p>
<h4><strong>ASP.NET Core middleware</strong></h4>
<p>ASP.NET Core defines a request pipeline in each app’s Configure method. This request pipeline<br />
defines how an incoming request is handled by the app, with each method in the pipeline calling the<br />
next method until eventually a method terminates, and the chain of <em>middleware</em> terminates and<br />
returns back up the stack. Middleware can target all requests, or can be configured to only map to<br />
certain requests based on the requested path or other factors. It can be configured wholly in the<br />
Configure method of an app, or implemented in a separate class.</p>
<p>Behavior in an ASP.NET MVC app that uses HTTP modules is probably best suited to custom<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/middleware/?preserve-view=true&amp;view=aspnetcore-3.1">middleware. Custom HTTP handlers can be replaced with custom routes or endpoints that respond to</a><br />
the same path.</p>
<h4><strong>Accessing HttpContext</strong></h4>
<p>Many .NET apps reference the current request’s context through HttpContext.Current. This static<br />
access can be a common source of problems with testing and other code usage outside of individual<br />
requests. When building ASP.NET Core apps, access to the current HttpContext should be provided as<br />
a method parameter on middleware, as this sample demonstrates:</p>
<p>17 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>Similarly, ASP.NET Core filters pass a context argument to their methods, from which the current<br />
HttpContext can be accessed:</p>
<p>If you have components or services that require access to HttpContext, rather than using a static call<br />
like HttpContext.Current you should instead use constructor dependency injection and the<br />
<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.http.ihttpcontextaccessor">IHttpContextAccessor</a> interface:</p>
<p>This approach eliminates the static coupling of the method to the current context while providing<br />
access in a testable fashion.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/troubleshoot/aspnet/http-modules-handlers">ASP.NET HTTP modules and HTTP handlers</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/middleware/?preserve-view=true&amp;view=aspnetcore-3.1">ASP.NET Core middleware</a></p>
</li>
</ul>
<h3>Configuration differences between ASP.NET MVC and ASP.NET Core</h3>
<p>How configuration values are stored and read changed dramatically between ASP.NET and ASP.NET<br />
Core.</p>
<p>18 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<h4><strong>ASP.NET MVC configuration</strong></h4>
<p>In ASP.NET apps, configuration uses the built-in .NET configuration files, <em>web.config</em> in the app folder<br />
and <em>machine.config</em> on the server. Most ASP.NET MVC and Web API apps store their settings in the<br />
configuration file’s appSettings or connectionStrings elements. Some also use custom configuration<br />
sections that can be mapped to a settings class.</p>
<p>Configuration in a .NET Framework app is accessed using the<br />
System.Configuration.ConfigurationManager class. Unfortunately, this class provides static access to<br />
the configuration elements. As a result, very few ASP.NET MVC apps tend to abstract access to their<br />
configuration settings or inject them where needed. Instead, most .NET Framework apps tend to<br />
directly access the configuration system anywhere the app needs to use a setting.</p>
<p>Typical ASP.NET MVC configuration access:</p>
<h4><strong>ASP.NET Core configuration</strong></h4>
<p>In ASP.NET Core apps, configuration is, itself, configurable. However, most apps use a set of defaults<br />
provided as part of the standard project templates and the ConfigureWebHostDefaults method used<br />
in them. The default settings use JSON formatted files, with the ability to override settings in the base<br />
<em>appsettings.json</em> file with environment-specific files like <em>appsettings.Development.json</em> . Additionally, the<br />
default configuration system further overrides all file-based settings with any environment variable<br />
that exists for the same named setting. This is useful in many scenarios and is especially useful when<br />
deploying to a hosting environment, since it eliminates the need to worry about whether deploying<br />
configuration files will accidentally overwrite important production configuration settings.<br />
Configuration values can also be provided as command line arguments.</p>
<p>Accessing configuration values can be done in many ways in .NET Core. Because dependency injection<br />
is built into .NET Core, configuration values are generally accessed through an interface that is<br />
<a href="https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration">injected into classes that need them. This can involve passing a interface like IConfiguration, but</a><br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options">usually it’s better to pass just the settings required by the class using the options pattern.</a></p>
<p>Figure 2-2 shows how to pass IConfiguration into a Razor Page and access configuration settings from<br />
it:</p>
<p>19 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p><em>Figure 2-2. Accessing configuration values with IConfiguration.</em></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/options">Using the options pattern, settings access is similar but is strongly typed and more specific to the</a><br />
setting(s) needed by the consuming class, as Figure 2-3 demonstrates.</p>
<p><em>Figure 2-3. Using the options pattern in ASP.NET Core.</em></p>
<p>For the options pattern to work, the options type must be configured in ConfigureServices when the<br />
app starts up:</p>
<h4><strong>Migrate configuration</strong></h4>
<p>When considering how to port an app’s configuration settings from .NET Framework to .NET Core, the<br />
first step is to identify all of the configuration settings that are being used. Most of these will be in the<br />
<em>web.config</em> file in the app’s root folder, but some apps expect settings to be found in the shared<br />
<em>machine.config</em> file as well. These settings will include elements of the appSettings element, the<br />
connectionStrings element, and any custom configuration elements as well. In .NET Core, all of these<br />
settings are typically stored in the <em>appsettings.json</em> file.</p>
<p>Once all settings in the config files have been cataloged, the next step should be to identify where<br />
and how the settings are used in the app itself. If some settings aren’t being used, these can probably<br />
be omitted from the migration. For each setting, note all of the places it’s being used so you can be<br />
sure you don’t miss any when you migrate the code.</p>
<p>20 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>If you’re still maintaining the ASP.NET app, it may be helpful to avoid static references to<br />
ConfigurationManager and replace them with access through interfaces. This will ease the transition<br />
to ASP.NET Core’s configuration system. In general, static access to external resources makes code<br />
harder to test and maintain, so be on the lookout for anywhere else the app may be following this<br />
pattern.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/">Configuration in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options">Options pattern in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/configuration">Migrate configuration to ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://ardalis.com/refactoring-static-config-access/">Refactoring Static Config Access</a></p>
</li>
</ul>
<h3>Routing differences between ASP.NET MVC and ASP.NET Core</h3>
<p>Routing is responsible for mapping incoming browser requests to particular controller actions (or<br />
Razor Pages handlers). This section covers how routing differs between ASP.NET MVC (and Web API)<br />
and ASP.NET Core (MVC, Razor Pages, and otherwise).</p>
<h4><strong>Routing in ASP.NET MVC and Web API</strong></h4>
<p>ASP.NET MVC offers two approaches to routing:</p>
<ol>
<li>
<p>The route table, which is a collection of routes that can be used to match incoming requests<br />
to controller actions.</p>
</li>
<li>
<p>Attribute routing, which performs the same function but is achieved by decorating the actions<br />
themselves, rather than editing a global route table.</p>
</li>
</ol>
<h4><strong>Route table</strong></h4>
<p>The route table is configured when the app starts up. Typically, a static method call is used to<br />
configure the global route collection, like so:</p>
<p>21 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>In the preceding code, the route table is managed by the RouteCollection type, which is used to add<br />
new routes with MapRoute. Routes are named and include a route string, which can include<br />
parameters for controllers, actions, areas, and other placeholders. If an app follows a standard<br />
convention, most of its actions can be handled by this single default route, with any exceptions to this<br />
convention configured using additional routes.</p>
<p><strong>Attribute routing in ASP.NET MVC</strong></p>
<p>Routes that are defined with their actions may be easier to discover and reason about than routes<br />
defined in an external location. Using attribute routing, an individual action method can have its route<br />
defined with a [Route] attribute:</p>
<p><a href="https://devblogs.microsoft.com/aspnet/attribute-routing-in-asp-net-mvc-5/">Attribute routing in ASP.NET MVC 5 also supports defaults and prefixes, which can be added at the</a><br />
controller level (and which are applied to all actions within that controller). Refer to the<br />
documentation for details.</p>
<p>Setting up attribute routing requires adding one line to the default route table configuration:</p>
<pre><code>routes.MapMvcAttributeRoutes();

</code></pre>
<p>Attribute routing can take advantage of route constraints, both built-in and custom, and supports<br />
named routes and areas using the [RouteArea] attribute. If your app uses areas, you’ll need to<br />
configure support for them in your route registration code by adding one more line:</p>
<pre><code>routes.MapMvcAttributeRoutes();

AreaRegistration.RegisterAllAreas();

</code></pre>
<p><strong>Attribute routing in ASP.NET Web API 2</strong></p>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2">Attribute routing in ASP.NET Web API 2 is similar to routing in ASP.NET MVC 5, with minor differences.</a><br />
Configuring Web API 2 is typically done in its own class, which is called during app startup. Attribute<br />
routing configuration is handled in this class:</p>
<p>22 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>As shown in the preceding code, attribute routing may be combined with convention-based routing<br />
in Web API apps.</p>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/web-api-routing-and-actions/routing-and-action-selection">In addition to attribute routing, ASP.NET Web API chooses which action to call</a> based on the HTTP<br />
method (for example, GET or POST), the {action} placeholder in a route (if any), and parameters of the<br />
action. In many cases, the name of the action will help determine whether it’s matched, since prefixing<br />
the action name with “Get” or “Post” is used to match the appropriate HTTP method to it.<br />
Alternatively, actions can be decorated with an appropriate HTTP method attribute, like [HttpGet],<br />
allowing the use of action names that aren’t prefixed with an HTTP method.</p>
<p>Given the above controller, an HTTP GET request to localhost:123/products/ matches the GetAll<br />
action. An HTTP GET request to localhost:123/products?name=ardalis matches the<br />
FindProductsByName action.</p>
<h4><strong>Routing in .NET 7</strong></h4>
<p>In ASP.NET Core, routing is handled by routing middleware, which matches the URLs of incoming<br />
requests to actions or other endpoints. Controller actions are either conventionally routed or<br />
attribute-routed. Conventional routing is similar to the route table approach used in ASP.NET MVC<br />
and Web API. Whether you’re using conventional, attribute, or both, you need to configure your app<br />
to use the routing middleware. To use the middleware, add the following code to your <em>Program.cs</em> file:</p>
<pre><code>app.UseRouting();

</code></pre>
<p><strong>Conventional routing</strong></p>
<p>With conventional routing, you set up one or more conventions that will be used to match incoming<br />
URLs to <em>endpoints</em> in the app. In ASP.NET Core, these endpoints may be controller actions, like in<br />
ASP.NET MVC or Web API. The endpoints could also be Razor Pages, Health Checks, or SignalR hubs.<br />
All of these routable features are configured in a similar fashion using endpoints:</p>
<p>23 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>The preceding code is used (in addition to UseRouting) to configure various endpoints, including<br />
Health Checks, controllers, and Razor Pages. For controllers, the above configuration specifies a<br />
default routing convention, which is the fairly standard {controller}/{action}/{id?} pattern that’s been<br />
recommended since the first versions of ASP.NET MVC.</p>
<p><strong>Attribute routing</strong></p>
<p>Attribute routing in ASP.NET Core is the preferred approach for configuring routing in controllers. If<br />
you’re building APIs, the [ApiController] attribute should be applied to your controllers. Among other<br />
things, this attribute requires the use of attribute routing for actions in such controller classes.</p>
<p>Attribute routing in ASP.NET Core behaves similarly in ASP.NET MVC and Web API. In addition to<br />
supporting the [Route] attribute, however, route information can also be specified as part of the HTTP<br />
method attribute:</p>
<p>As with previous versions, you can specify a default route with placeholders, and add this at the<br />
controller class level or even on a base class. You use the same [Route] attribute for all of these cases.<br />
For example, a base API controller class might look like this:</p>
<p>Using this attribute, classes inheriting from this type would route URLs to actions based on the<br />
controller name, action name, and an optional integer id parameter.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/mvc/overview/older-versions-1/controllers-and-routing/asp-net-mvc-routing-overview-cs">ASP.NET MVC Routing Overview</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/aspnet/attribute-routing-in-asp-net-mvc-5/">Attribute Routing in ASP.NET MVC 5</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2">Attribute routing in ASP.NET Web API 2</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/web-api-routing-and-actions/routing-and-action-selection">Routing and Action Selection in ASP.NET Web API</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/routing">Routing in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/routing">Routing to controller actions in ASP.NET Core MVC</a></p>
</li>
</ul>
<p>24 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<h3>Logging differences between ASP.NET MVC and ASP.NET Core</h3>
<p>Application logging provides important diagnostic information, especially for apps running in<br />
production. ASP.NET Core introduces a new system for adding standardized logging to any app.<br />
Existing ASP.NET MVC and Web API apps most likely use third-party logging solutions, which likely<br />
continue to be supported on ASP.NET Core.</p>
<h4><strong>ASP.NET MVC logging</strong></h4>
<p>There’s no built-in logging solution in ASP.NET MVC and Web API apps. Instead, most apps use third<a href="https://www.nuget.org/packages/log4net/">party logging solutions like log4net,</a> <a href="https://www.nuget.org/packages/NLog/">NLog, or Serilog. Many teams also choose to roll their own</a><br />
logging solution. Logging frameworks typically support multiple “sinks” (or targets or appenders) for<br />
log output, such as text files, databases, or even emails. They use configuration to determine which<br />
levels of log messages from which parts of the system are routed to different sinks. When considering<br />
how to migrate an app’s logging to .NET Core, review how logging is performed and configured in the<br />
app.</p>
<h4><strong>ASP.NET Core logging</strong></h4>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/">In ASP.NET Core, logging is a built-in feature that can be configured and extended when the app</a><br />
starts up. Third-party loggers, including those mentioned above, can be integrated with ASP.NET Core<br />
to enhance its functionality.</p>
<p>ASP.NET Core logging uses categories and levels to control what is logged and how. Classes typically<br />
use instances of the ILogger<T> interface, with the class’s type used as the generic T type. In this<br />
scenario, the class’s fully qualified name is used as the category. Loggers can also be created with a<br />
custom category using an ILoggerFactory. Log levels range from the most detailed, Trace, to the most<br />
important, Critical. Using configuration, apps can specify what minimum level of logging should be<br />
included on a per-category (with wildcards) basis.</p>
<p>A typical logging configuration could log Information and above information by default, but only<br />
Warning or above from Microsoft-prefixed categories:</p>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/">Support for logging in ASP.NET Core is extensive and flexible. For more detailed information, refer to</a><br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/">the docs.</a></p>
<p>25 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<h4><strong>Migrate logging</strong></h4>
<p>How you migrate your .NET Framework app’s logging to .NET Core depends on how the app is<br />
logging now. If it’s using a third-party NuGet package, refer to the upgrade documentation for that<br />
package. Most likely the upgrade path will be fairly straightforward. If you’re using your own logging<br />
solution, take one of the following actions:</p>
<ol>
<li>
<p>Migrate the logging solution yourself</p>
</li>
<li>
<p>Migrate to a third-party logging solution</p>
</li>
<li>
<p>Use the built-in logging support in ASP.NET Core</p>
</li>
</ol>
<p>You can reference the Microsoft.Extensions.Logging package from .NET Framework apps as long as<br />
they’re using NuGet 4.3 or later and are on .NET Framework 4.6.1 or later. Once your app has<br />
referenced this package, you can convert your logging statements to use the new extensions before<br />
migrating the app to .NET Core. This can provide a stepping stone toward full migration, since the app<br />
can continue running on .NET Framework while logging using the newer extensions package.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/">Logging in .NET Core and ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://www.nuget.org/packages/microsoft.extensions.logging/">Microsoft.Extensions.Logging NuGet Package</a></p>
</li>
</ul>
<h3>Compare Razor Pages to ASP.NET MVC</h3>
<p><a href="https://docs.microsoft.com/aspnet/core/razor-pages/">Razor Pages is the preferred way to create page- or form-based apps in ASP.NET Core. From the docs,</a><br />
“Razor Pages can make coding page-focused scenarios easier and more productive than using<br />
controllers and views.” If your ASP.NET MVC app makes heavy use of views, you may want to consider<br />
migrating from actions and views to Razor Pages.</p>
<p>A typical strongly typed view-based MVC app will use a controller to contain one or more actions. The<br />
controller will interact with the domain or data model, and create an instance of a viewmodel class.<br />
Then this viewmodel class is passed to the view associated with that action. Using this approach,<br />
coupled with the default folder structure of MVC apps, to add a new page to an app requires<br />
modifying a controller in one folder, a view in a nested subfolder in another folder, and a viewmodel<br />
in yet another folder.</p>
<p>Razor Pages group together the action (now a <em>handler</em> ) and the viewmodel (called a <em>PageModel</em> ) in<br />
one class, and link this class to the view (called a Razor Page). All Razor Pages go into a <em>Pages</em> folder in<br />
the root of the ASP.NET Core project. Razor Pages use a routing convention based on their name and<br />
location within this folder. Handlers behave exactly like action methods but have the HTTP verb they<br />
handle in their name (for example, OnGet). They also don’t necessarily need to return, since by default<br />
they’re assumed to return the page they’re associated with. This tends to keep Razor Pages and their<br />
handlers smaller and more focused while at the same time making it easier to find and work with all of<br />
the files needed to add or modify a particular part of an app.</p>
<p>As part of a move from ASP.NET MVC to ASP.NET Core, teams should consider whether they want to<br />
migrate controllers and views to ASP.NET Core controllers and views, or to Razor Pages. The former</p>
<p>26 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>will most likely require slightly less overall effort, but won’t allow the team to take advantage of the<br />
benefits of Razor Pages over traditional view-based file organization.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/razor-pages/">Introduction to Razor Pages in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/archive/msdn-magazine/2017/september/asp-net-core-simpler-asp-net-mvc-apps-with-razor-pages">Simpler ASP.NET Core Apps with Razor Pages</a></p>
</li>
</ul>
<h3>Compare ASP.NET Web API 2 and ASP.NET Core</h3>
<p>ASP.NET Core offers iterative improvements to ASP.NET Web API 2, but should feel familiar to<br />
developers who have used Web API 2. ASP.NET Web API 2 was developed and shipped alongside<br />
ASP.NET MVC. This meant the two approaches had similar-but-different approaches to things like<br />
attribute routing and dependency injection. In ASP.NET Core, there’s no longer any distinction<br />
<a href="https://docs.microsoft.com/aspnet/core/introduction-to-aspnet-core">between MVC and Web APIs. There’s only ASP.NET Core, which includes support for view-based</a><br />
scenarios, API endpoints, Razor Pages, health checks, SignalR, and more.</p>
<p>In addition to being consistent and unified within ASP.NET Core, APIs built in .NET Core are much<br />
easier to test than those built on ASP.NET Web API 2. We’ll cover testing differences in more detail in<br />
a moment. The built-in support for hosting ASP.NET Core apps, in a test host that can create an<br />
HttpClient that makes in-memory requests to the app, is a huge benefit when it comes to automated<br />
testing.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/inc/overview">See Incremental ASP.NET to ASP.NET Core migration for an incremental approach to migrating to</a><br />
ASP.NET Core.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/webapi">Migrate from ASP.NET Web API to ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://www.nuget.org/packages/Ardalis.ApiEndpoints/">Ardalis.ApiEndpoints NuGet package</a></p>
</li>
</ul>
<h3>Compare authentication and authorization between ASP.NET MVC and ASP.NET Core</h3>
<p>In ASP.NET MVC 5, authentication is configured in <em>Startup.Auth.cs</em> in the <em>App_Start</em> folder. In ASP.NET<br />
Core MVC, this configuration occurs in <em>Startup.cs</em> or <em>Program.cs</em>, as part of configuring the app’s<br />
services and middleware.</p>
<p>Authentication and authorization are performed using middleware added to the request pipeline:</p>
<p>27 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>It’s important to add the auth middleware in the appropriate order in the middleware pipeline. Only<br />
requests that make it to the middleware will be impacted by it. For instance, if a call to UseStaticFiles()<br />
were placed above the code shown here, it wouldn’t be protected by authentication and<br />
authorization.</p>
<p>In ASP.NET MVC and Web API, apps often refer to the current user using the ClaimsPrincipal.Current<br />
property. This property isn’t set in ASP.NET Core, and any behavior in your app that depends on it will<br />
<a href="https://docs.microsoft.com/aspnet/core/migration/claimsprincipal-current">need to migrate from ClaimsPrincipal.Current by using the User property on ControllerBase or getting</a><br />
access to the current HttpContext and referencing its User property. If neither of these solutions is an<br />
option, services can request the User as an argument, in which case it must be supplied from<br />
elsewhere in the app, or the IHttpContextAccessor can be requested and used to get the HttpContext.</p>
<h4><strong>Authorization</strong></h4>
<p>Authorization defines what a given user can do within the app. It’s separate from authentication,<br />
which is concerned merely with identifying who the user is. ASP.NET Core provides a simple,<br />
declarative role and a rich, policy-based model for authorization. Specifying that a resource requires<br />
authorization is often as simple as adding the [Authorize] attribute to the action or controller. If you’re<br />
<a href="https://docs.microsoft.com/aspnet/core/security/authorization/razor-pages-authorization">migrating to Razor Pages from MVC views, you should specify conventions for authorization when</a><br />
<a href="https://docs.microsoft.com/aspnet/core/security/authorization/razor-pages-authorization">you configure Razor Pages.</a></p>
<p>Authorization in ASP.NET Core may be as simple as prohibiting anonymous users while allowing<br />
authenticated users. Or it can scale up to support role-based, claims-based, or policy-based<br />
authorization approaches. For more information on these approaches, see the documentation on<br />
<a href="https://docs.microsoft.com/aspnet/core/security/authorization/introduction">authorization in ASP.NET Core. You’ll likely find that one of them is closely aligned with your current</a><br />
authorization approach.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/mvc/overview/security/">Security, Authentication, and Authorization with ASP.NET MVC</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/mvc/overview/security/">Migrate Authentication and Identity to ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/claimsprincipal-current">Migrate from ClaimsPrincipal.Current</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/authorization/introduction">Introduction to Authorization in ASP.NET Core</a></p>
</li>
</ul>
<h3>Compare ASP.NET Identity and ASP.NET Core Identity</h3>
<p>In ASP.NET MVC, identity features are typically configured in <em>IdentityConfig.cs</em> in the <em>App_Start</em> folder.<br />
<a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity-configuration">Review how this is configured in the existing app, and compare it to the configuration required for</a><br />
<a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity-configuration">ASP.NET Core Identity</a> in <em>Program.cs</em> .</p>
<p>28 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>ASP.NET Identity is an API that supports user interface login functionality and manages users,<br />
passwords, profile data, roles, claims, tokens, email confirmations, and more. It supports external login<br />
providers like Facebook, Google, Microsoft, and Twitter.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity">If your ASP.NET MVC app is using ASP.NET Membership, you’ll find a guide to migrate from ASP.NET</a><br />
<a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/membership-to-core-identity">Membership authentication to ASP.NET Core 2.0 Identity. This is mainly a data migration exercise, at</a><br />
the completion of which you should be able to use ASP.NET Core Identity with your migrated user<br />
records.</p>
<p>If you migrate your ASP.NET Identity users to ASP.NET Core Identity, you may need to update their<br />
password hashes, or track which passwords are hashed with the new ASP.NET Core Identity approach<br />
<a href="https://stackoverflow.com/a/57074910/13729">or the older ASP.NET Identity approach. This approach described on Stack Overflow provides some</a><br />
options for migrating user password hashes over time, rather than all at once.</p>
<p>One of the biggest differences when it comes to ASP.NET Core Identity compared to ASP.NET Identity<br />
is how little code you need to include in your project. ASP.NET Core Identity now ships as a Razor<br />
Class Library, meaning its UI and logic are all available from a NuGet package. You can override the<br />
<a href="https://docs.microsoft.com/aspnet/core/security/authentication/scaffold-identity">existing UI and logic by scaffolding the ASP.NET Core Identity files</a> but even in this case you need only<br />
scaffold the pages you want to modify, not every one that exists.</p>
<h4><strong>Migrate from OWIN / Katana</strong></h4>
<p>The following resources offer some guidance for migrating from OWIN / Katana:</p>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/proper-to-2x/#globalasax-file-replacement">Migration</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/aspnet/katana-asp-net-5-and-bridging-the-gap/">Katana to ASPNET 5</a></p>
</li>
</ul>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/identity">Migrate Authentication and Identity to ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/authorization/introduction">Introduction to Identity on ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity-configuration">Configure ASP.NET Core Identity</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/authentication/scaffold-identity">Scaffold Identity in ASP.NET Core projects</a></p>
</li>
</ul>
<h3>Compare controllers in ASP.NET MVC and Web API with controllers in ASP.NET Core</h3>
<p>In ASP.NET MVC 5 and Web API 2, there were two different Controller base types. MVC controllers<br />
inherited from Controller; Web API controllers inherited from ApiController. In ASP.NET Core, this<br />
object hierarchy has been merged. It’s recommended that API controllers in ASP.NET Core inherit<br />
from ControllerBase and add the [ApiController] attribute. Standard view-based MVC controllers<br />
should inherit from Controller.</p>
<p>In both frameworks, controllers are used to organize sets of action methods. Filters and routes can be<br />
applied on a controller level in addition to at the action level. These conventions can be extended<br />
further by using custom base Controller types with default behavior and attributes applied to them.</p>
<p>29 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p>In ASP.NET MVC, content negotiation isn’t supported. ASP.NET Web API 2 does support content<br />
<a href="https://docs.microsoft.com/aspnet/core/web-api/advanced/formatting">negotiation, as does ASP.NET Core. Using content negotiation, the format of the content returned to a</a><br />
request can be determined by headers the client provides indicating its preferred manner of receiving<br />
the content.</p>
<p>When migrating ASP.NET Web API controllers to ASP.NET Core, a few components need to be<br />
changed if they exist. These include references to the ApiController base class, the System.Web.Http<br />
<a href="https://docs.microsoft.com/aspnet/core/migration/webapi">namespace, and the IHttpActionResult interface. Refer to the documentation for recommendations on</a><br />
<a href="https://docs.microsoft.com/aspnet/core/migration/webapi">how to migrate these specific differences. Note that the preferred return type for API actions in</a><br />
ASP.NET Core is ActionResult<T>.</p>
<p>In addition, the [ChildActionOnly] attribute isn’t supported in ASP.NET Core. In ASP.NET Core, similar<br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/views/view-components">functionality is achieved using View Components.</a></p>
<p><a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.consumesattribute">ASP.NET Core includes two new attributes: ConsumesAttribute</a> <a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.producesattribute">and ProducesAttribute. These are used</a><br />
to specify the type an action consumes or produces, which can be helpful for routing and<br />
<a href="https://docs.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-swagger">documenting the API using tools like Swagger/OpenAPI.</a></p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/web-api/advanced/formatting">Format response data in ASP.NET Core Web API</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/webapi">Migrate from ASP.NET Web API to ASP.NET Core</a></p>
</li>
</ul>
<h3>Compare Razor usage in ASP.NET MVC and ASP.NET Core</h3>
<p>The basic syntax of Razor hasn’t changed substantially between ASP.NET MVC and ASP.NET Core.<br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/views/tag-helpers/intro">However, there are certain differences, such as the introduction of Tag Helpers</a> and Razor Pages, that<br />
should be considered when migrating. If your app makes heavy use of custom Razor functionality,<br />
<a href="https://docs.microsoft.com/aspnet/core/razor-pages">refer to the Razor syntax reference for ASP.NET Core to see what changes may be required when you</a><br />
migrate to ASP.NET Core.</p>
<h4><strong>Tag Helpers</strong></h4>
<p>Tag Helpers enable server-side code to participate in creating and rendering HTML elements in Razor<br />
files. They offer many advantages over HTML Helpers and should be used in place of HTML Helpers<br />
wherever possible. They provide an HTML-friendly development experience, since they look like<br />
standard HTML and are ignored by most tooling designed to edit HTML. Within <em>Visual Studio</em>, there’s<br />
rich IntelliSense support for creating HTML and Razor markup with Tag Helpers. Tag Helpers can<br />
provide simple or complex behavior from declarative markup in Razor files.</p>
<h4><strong>Razor Pages</strong></h4>
<p>Razor Pages offer an alternative to controllers, actions, and views for page- and form-based apps.<br />
Razor Pages were compared to ASP.NET MVC earlier in this chapter.</p>
<p>30 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/migration/mvc#migrate-controllers-and-views">Migrate from ASP.NET MVC to ASP.NET Core MVC: Controllers and Views</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/views/tag-helpers/intro">Tag Helpers in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/razor-pages">Introduction to Razor Pages in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/razor-pages">Razor syntax reference for ASP.NET Core</a></p>
</li>
</ul>
<h3>Compare ASP.NET SignalR and ASP.NET Core SignalR</h3>
<p>ASP.NET Core SignalR is incompatible with clients or servers using ASP.NET SignalR. You’ll need to<br />
update both clients and server to use ASP.NET Core SignalR. Some differences are described in this<br />
<a href="https://docs.microsoft.com/aspnet/core/signalr/version-differences">section, while the full list is available in the docs. ASP.NET Core SignalR requires .NET Core 2.1 or</a><br />
greater.</p>
<h4><strong>Feature differences</strong></h4>
<ul>
<li>
<p>ASP.NET SignalR automatically attempts to reconnect dropped connections; this behavior is<br />
opt-in for ASP.NET Core SignalR clients.</p>
</li>
<li>
<p>Both frameworks support JSON; ASP.NET Core SignalR also supports a binary protocol based<br />
on MessagePack, and custom protocols can be created.</p>
</li>
<li>
<p>The Forever Frame transport, supported by ASP.NET SignalR, isn’t supported in ASP.NET Core<br />
SignalR.</p>
</li>
<li>
<p>ASP.NET Core SignalR must be configured by adding services.AddSignalR() and<br />
app.UseEndpoints in <em>Program.cs</em> .</p>
</li>
<li>
<p>ASP.NET Core SignalR requires sticky sessions; ASP.NET SignalR doesn’t.</p>
</li>
<li>
<p>ASP.NET Core simplifies the connection model; connections are only made to a single hub.</p>
</li>
<li>
<p>ASP.NET Core SignalR supports streaming data from the hub to the client.</p>
</li>
<li>
<p>ASP.NET Core SignalR doesn’t support passing state between clients and the hub (but method<br />
calls still allow passing information between hubs and clients).</p>
</li>
<li>
<p>The PersistentConnection class doesn’t exist in ASP.NET Core SignalR.</p>
</li>
<li>
<p>ASP.NET SignalR supports SQL Server and Redis. ASP.NET Core SignalR supports Azure<br />
SignalR and Redis.</p>
</li>
</ul>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/signalr/version-differences">Differences between ASP.NET SignalR and ASP.NET Core SignalR</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/azure/azure-signalr/">Azure SignalR Service</a></p>
</li>
</ul>
<p>31 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<h3>Compare testing options between ASP.NET MVC and ASP.NET Core</h3>
<p>ASP.NET MVC apps support unit testing of controllers, but this approach often omits many MVC<br />
features like routing, authorization, model binding, model validation, filters, and more. To test these<br />
MVC features in addition to the logic within the controller action itself, frequently the app would need<br />
to be deployed and then tested with a tool like Selenium. These tests are substantially more<br />
expensive, more brittle, and slower than typical unit tests that can be run without the need for hosting<br />
and running the entire app.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/testing">ASP.NET Core controllers can be unit tested just like ASP.NET MVC controllers, but with the same</a><br />
<a href="https://docs.microsoft.com/aspnet/core/test/integration-tests">limitations. However, ASP.NET Core supports fast, easy-to-author integration tests</a> as well. Integration<br />
tests are hosted by a TestHost class and are typically configured in a custom WebApplicationFactory<br />
that can override or replace app dependencies. For instance, frequently during integration tests the<br />
app will target a different data source and may replace services that send emails with fake or mock<br />
implementations.</p>
<p>ASP.NET MVC and Web API did not support anything like the integration testing scenarios available in<br />
ASP.NET Core. In any migration effort, you should allocate time to write some integration tests for<br />
your newly migrated system to ensure it’s working as expected and continues to do so. Even if you<br />
weren’t writing tests of your web app logic before the migration, you should strongly consider doing<br />
so as you move to ASP.NET Core.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/mvc/overview/older-versions-1/unit-testing/creating-unit-tests-for-asp-net-mvc-applications-cs">Creating Unit Tests for ASP.NET MVC Applications</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/testing">Unit test controller logic in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/test/integration-tests">Integration tests in ASP.NET Core</a></p>
</li>
</ul>
<p>32 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core</p>
<p><strong>CHAPTER</strong></p>
<h1>3</h1>
<h2>Migrate large solutions to ASP.NET Core</h2>
<p>Migrating large solutions from .NET Framework to .NET Core requires some planning. Dependencies<br />
must be migrated or updated before the projects that depend on them. There are tools that can<br />
identify dependencies and offer help with migrating to .NET Core. Depending on the app, its scope,<br />
and current usage patterns, different strategies may be employed when migrating. Do you migrate it<br />
all at once, or over time, side-by-side with the current system? Do you wrap the current system in the<br />
new one, and incrementally replace its functionality?</p>
<p>In this chapter, you’ll learn how create a migration plan for a large solution, how to use tools to help<br />
with the migration, and some strategies to consider for the migration itself.</p>
<h3>References</h3>
<ul>
<li>
<p><a href="https://twitter.com/ardalis/status/1313669040859217921">What topics are important to migrating large MVC and Web API apps to .NET Core?</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/porting/">Porting from .NET Framework to .NET Core</a></p>
</li>
</ul>
<h3>Identify sequence of projects to migrate</h3>
<p>For solutions that involve multiple front-end apps, it’s best to migrate the apps one by one. For<br />
example, create a solution that only includes one front-end app and its dependencies so you can<br />
easily identify the scope of work involved. Solutions are lightweight, and you can include projects in<br />
multiple solutions if needed. Take advantage of solutions as an organizational tool when migrating.</p>
<p>Once you’ve identified the ASP.NET app to migrate and have its dependent projects located with it<br />
(ideally in a solution), the next step is to identify framework and NuGet dependencies. Having<br />
identified all dependencies, the simplest migration approach is a “bottom up” approach. With this<br />
approach, the lowest level of dependencies is migrated first. Then the next level of dependencies is<br />
migrated, until eventually the only thing left is the front-end app. Figure 3-1 shows an example set of<br />
projects composing an app. The low-level class libraries are at the bottom, and the ASP.NET MVC<br />
project is at the top.</p>
<p>33 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<p><em>Figure 3-1. Project dependencies graph.</em></p>
<p>Choose a particular front-end app, an ASP.NET MVC 5 / Web API 2 project. Identify its dependencies<br />
in the solution, and map out their dependencies until you have a complete list. A diagram like the one<br />
shown in Figure 3-1 may be useful when mapping out project dependencies. Visual Studio can<br />
<a href="https://docs.microsoft.com/visualstudio/modeling/create-layer-diagrams-from-your-code">produce a dependency diagram for your solution, depending on which edition you’re using. The .NET</a><br />
<a href="https://docs.microsoft.com/en-us/dotnet/standard/analyzers/portability-analyzer">Portability Analyzer</a> can also produce dependency diagrams.</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer">Figure 3-2 shows the installer for the .NET Portability Analyzer Visual Studio extension:</a></p>
<p>34 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<p><em>Figure 3-2. .NET Portability Analyzer installer.</em></p>
<p>The extension currently supports Visual Studio 2017 and 2019. Visual Studio 2022 support is planned.</p>
<p>Once installed, you configure it from the <strong>Analyze</strong> - <strong>Portability Analyzer Settings</strong> menu, as shown in<br />
Figure 3-3.</p>
<p>35 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<p><em>Figure 3-3. Configure the .NET Portability Analyzer.</em></p>
<p>The analyzer produces a detailed report for each assembly. The report:</p>
<ul>
<li>
<p>Describes how compatible each project is with a given target framework, such as .NET 7 or<br />
.NET Standard 2.0.</p>
</li>
<li>
<p>Helps teams assess the effort required to port a particular project to a particular target<br />
framework.</p>
</li>
</ul>
<p>The details of this analysis are covered in the next section.</p>
<p>Once you’ve mapped out the projects and their relationships with one another, you’re ready to<br />
determine the order in which you’ll migrate the projects. Begin with projects that have no<br />
dependencies. Then, work your way up the tree to the projects that depend on these projects.</p>
<p>In the example shown in Figure 3-1, you would start with the <em>Contoso.Utils</em> project, since it doesn’t<br />
depend on any other projects. Next, <em>Contoso.Data</em> since it only depends on “Utils”. Then migrate the<br />
“BusinessLogic” library, and finally the front-end ASP.NET “Web” project. Following this “bottom up”<br />
approach works well for relatively small and well-factored apps that can be migrated as a unit once all<br />
of their projects have migrated. Larger apps with more complexity, or more code that will take longer<br />
to migrate, may need to consider more incremental strategies.</p>
<p>36 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<h4><strong>Unit tests</strong></h4>
<p>Missing from the previous diagrams are unit test projects. Hopefully there are tests covering at least<br />
some of the existing behavior of the libraries being ported.</p>
<p>If you have unit tests, it’s best to convert those projects first. You’ll want to continue testing changes<br />
in the project you’re working on. Remember that porting to .NET Core is a significant change to your<br />
codebase.</p>
<p>MSTest, xUnit, and NUnit all work on .NET Core. If you don’t currently have tests for your app,<br />
consider building some characterization tests that verify the system’s current behavior. The benefit is<br />
that once the migration is complete, you can confirm the app’s behavior remains unchanged.</p>
<h4><strong>Considerations for migrating many apps</strong></h4>
<p>Some organizations will have many different apps to migrate, and migrating each one by hand may<br />
require too many resources to be tenable. In these situations, some degree of automation is<br />
recommended. The steps followed in this chapter can be automated. Structural changes, like project<br />
file differences and updates to common packages, can be applied by scripts. These scripts can be<br />
refined as they’re run iteratively on more projects. On each run, examine whatever manual steps are<br />
required for each project. Automate those manual steps, if possible. Using this approach, the<br />
organization should grow faster and better at porting their apps over time, with improved automation<br />
support each step of the way.</p>
<p><a href="https://www.youtube.com/watch?v=C-2haqb60No">Watch an overview of how to employ this approach in this dotNetConf presentation by Lizzy</a><br />
<a href="https://www.youtube.com/watch?v=C-2haqb60No">Gallagher of Mastercard. The five phases employed in this presentation included:</a></p>
<ul>
<li>
<p>Migrate third-party NuGet dependencies</p>
</li>
<li>
<p>Migrate apps to use new <em>.csproj</em> file format</p>
</li>
<li>
<p>Update internal NuGet dependencies to .NET Standard</p>
</li>
<li>
<p>Migrate apps to ASP.NET Core (targeting .NET Framework)</p>
</li>
<li>
<p>Update all apps to target .NET 7</p>
</li>
</ul>
<p>When automating a large suite of apps, it helps significantly if they follow consistent coding<br />
guidelines and project organization. Automation efforts rely on this consistency to be effective. In<br />
addition to parsing and migrating project files, common code patterns can be migrated automatically.<br />
Some code pattern examples include differences in how controller actions are declared or how they<br />
return results.</p>
<p>For example, a migration script could search files matching <em>Controller.cs</em> for lines of code matching<br />
one of these patterns:</p>
<p>In ASP.NET Core, either of the preceding lines of code can be replaced with:</p>
<pre><code>  return Ok();

</code></pre>
<p>37 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<h4><strong>Summary</strong></h4>
<p>The best approach to porting a large .NET Framework app to .NET Core is to:</p>
<ol>
<li>
<p>Identify project dependencies.</p>
</li>
<li>
<p>Analyze what’s required to port each project.</p>
</li>
<li>
<p>Start from the bottom up.</p>
</li>
</ol>
<p>You can use the .NET Portability Analyzer to determine how compatible existing libraries may be with<br />
target platforms. Automated tests will help ensure no breaking changes are introduced as the app is<br />
ported. These test projects should be among the first projects ported.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/porting/">Porting from .NET Framework to .NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/analyzers/portability-analyzer">The .NET Portability Analyzer</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=C-2haqb60No">2 Years, 200 Apps: A .NET Core Migration at Scale (Video)</a></p>
</li>
</ul>
<h3>Understand and update dependencies</h3>
<p>After identifying the sequence in which the app’s individual projects must be migrated, the next step<br />
is to understand each project’s dependencies and update them if necessary. For platform<br />
<a href="https://docs.microsoft.com/en-us/dotnet/standard/analyzers/portability-analyzer">dependencies, the best way to start is to run the .NET Portability Analyzer</a> on the assembly in<br />
question, and then look at the detailed results that are generated. You configure the tool to specify<br />
one or more target platforms, such as .NET 7 or .NET Standard 2.0. Results are provided with details<br />
for each platform targeted. Figure 3-4 shows an example of the tool’s output.</p>
<p><em>Figure 3-4. .NET Portability Analyzer report details.</em></p>
<h4><strong>Update class library dependencies</strong></h4>
<p>Large apps typically involve multiple projects, and most projects other than the ASP.NET MVC web<br />
project are likely to be class libraries. Class libraries tend to be the easiest to port between .NET</p>
<p>38 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<p>platforms, especially compared to ASP.NET projects, which are among the most difficult (and typically<br />
need to be re-created).</p>
<p><a href="https://github.com/dotnet/try-convert">Teams can consider the try-convert tool or the .NET Upgrade Assistant tool</a> for migrating class<br />
libraries to .NET Core. These tools analyze a .NET Framework project file and attempt to migrate it to<br />
the .NET Core project file format, making any modifications it can safely perform in the process. The<br />
tools may require some manual assistance to work with ASP.NET projects, but can usually help speed<br />
up the process of migrating class libraries.</p>
<p>The try-convert and Upgrade Assistant tools are deployed as .NET Core command line tools. They only<br />
run on Windows, since they’re designed to work with .NET Framework apps. You can install tryconvert by running the following command from a command prompt:</p>
<pre><code>dotnet tool install -g try-convert

</code></pre>
<p>Once you’ve successfully installed the tool, you can run try-convert in the folder where the class<br />
library’s project file is located.</p>
<p>Install the .NET Upgrade Assistant with the following command (after installing try-convert):</p>
<pre><code>dotnet tool install -g upgrade-assistant

</code></pre>
<p>Run the tool with the command upgrade-assistant upgrade <project> in the folder where the project<br />
file is located.</p>
<h4><strong>Update NuGet package dependencies</strong></h4>
<p>Analyze your use of third-party NuGet packages and determine if any of them don’t yet support .NET<br />
<a href="https://docs.microsoft.com/nuget/consume-packages/migrate-packages-config-to-package-reference">Standard (or do support it but only with a new version). It can be helpful to update NuGet packages</a><br />
<a href="https://docs.microsoft.com/nuget/consume-packages/migrate-packages-config-to-package-reference">to use <PackageReference> syntax using Visual Studio’s converter tool, so that top-level</a><br />
dependencies are visible. Next, check whether the current or later versions of these packages support<br />
.NET Core or .NET Standard. This information can be found on [nuget.org] or within Visual Studio for<br />
each package.</p>
<p>If support exists using the version of the package the app currently uses, great! If not, see if a more<br />
recent version of the package has the support and research what would be involved in upgrading.<br />
There may be breaking changes in the package, especially if the major version of the package changes<br />
between your currently used version and the one to which you’re upgrading.</p>
<p>In some cases, no version of a given package works with .NET Core. In that case, teams have a couple<br />
options. They can continue depending on the .NET Framework version, but this has limitations. The<br />
app may only run on Windows, and the team may want to run Portability Analyzer on the package’s<br />
binaries to see if there are any issues likely to be encountered. Certainly the team will want to test<br />
thoroughly, since if .NET Framework packages are used that reference APIs not available in .NET Core,<br />
a runtime exception will occur. The other option is to find a different package or, if the required<br />
package is open source, upgrade it to .NET Standard or .NET Core themselves.</p>
<p>39 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<h4><strong>Migrate ASP.NET MVC projects</strong></h4>
<p>The System.Web namespace and types don’t exist in .NET Core. When you’re analyzing dependencies<br />
and using tools like try-convert, you’ll find they don’t offer many suggestions for automatic migration<br />
of ASP.NET MVC projects and any code in them that references System.Web. For these projects, you’ll<br />
need to start with a new ASP.NET Core web project and manually migrate files to this project.</p>
<p>In general, it’s a good practice to minimize how much of an app’s business logic lives in its user<br />
interface layer. It’s also best to keep controllers and views small. Apps that have followed this<br />
guidance will be easier to port than those that have a significant amount of their logic in the ASP.NET<br />
web project. If you have an app you’re considering porting, but haven’t begun the process yet, keep<br />
this in mind as you maintain it. Any effort you put toward minimizing how much code is in the<br />
ASP.NET MVC or Web API project will likely result in less work when the time comes to port the app.</p>
<p>The next chapter digs into details of how to migrate from ASP.NET MVC and Web API projects to<br />
ASP.NET Core projects. The previous chapter called out the biggest differences between the apps.<br />
Once the basic project structure is in place, migrating individual controllers and views is usually<br />
straightforward, especially if they’re mainly focused on web responsibilities.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://aka.ms/dotnet-upgrade-assistant">.NET Upgrade Assistant tool</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet/try-convert">try-convert tool</a></p>
</li>
<li>
<p><a href="https://github.com/microsoft/dotnet-apiport">apiport tool</a></p>
</li>
</ul>
<h3>Strategies for migrating while running in production</h3>
<p>Many teams have .NET Framework apps they plan to migrate to .NET Core/.NET 7, but the app is so<br />
large that the migration requires a significant amount of time to complete. The original app needs to<br />
live on while the migration is done piece by piece. There needs to be a way for the old and new<br />
versions of the app to work together side-by-side, or for the old version to be migrated in-place, at<br />
least some of the way, without breaking it. Teams can employ many different strategies to support<br />
these goals.</p>
<h4><strong>Refactor the .NET Framework solution</strong></h4>
<p>A good place to start if you plan to port a .NET Framework app to .NET Core is to refactor it to work<br />
better with .NET Core. This means updating individual class libraries to target .NET Standard and<br />
moving as much logic out of your ASP.NET MVC projects and into these class libraries. Any code you<br />
have in .NET Standard libraries is immediately usable from both .NET Framework to .NET Core apps,<br />
which is why this step is so valuable as part of a migration.</p>
<p>When refactoring, make sure you’re following good refactoring fundamentals. For example, create<br />
tests that verify what the system does before you start refactoring. Run these tests when you’re done<br />
to confirm you didn’t change the system’s behavior. You may need to add characterization tests to the<br />
system if you don’t already have a good suite of automated tests you can rely on.</p>
<p>40 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<h4><strong>Extract front-end assets to a CDN</strong></h4>
<p>If your .NET Framework apps include a lot of static assets, like scripts, CSS files, or images, you may be<br />
able to migrate these to a separate CDN. Then, update the existing app to reference the CDN links for<br />
these assets. When you port the app to .NET Core, these static files won’t be part of the migration,<br />
and you’ll just continue referencing them from the CDN in the ASP.NET Core app.</p>
<h4><strong>Extract and migrate individual microservices</strong></h4>
<p>Large .NET Framework apps may already be comprised of separate front-end systems that can be<br />
migrated individually. Or they may be candidates for migration to a microservices architecture, with<br />
some pieces of existing ASP.NET MVC apps being pulled out into new ASP.NET Core microservice<br />
implementations. You can learn more about microservices in the associated ebook, .NET<br />
<a href="https://aka.ms/microservicesebook">Microservices: Architecture for Containerized .NET Applications.</a></p>
<p>For example, the existing app might have a set of features it uses related to user sign-in and<br />
registration. These could be migrated to a separate microservice, which could be built and deployed<br />
using ASP.NET Core and then integrated into the legacy .NET Framework app. Next, the app might<br />
have a few pages dedicated to tracking the individual user’s shopping cart. These pages could also be<br />
pulled out into their own separate microservice and again integrated into the existing app. In this way,<br />
the original .NET Framework app continues running in production, but with more and more of its<br />
features coming from modernized .NET Core microservices.</p>
<h4><strong>Deploy multiple versions of the app side-by-side in IIS</strong></h4>
<p>Using a combination of host headers and redirects, an existing ASP.NET MVC app can be configured<br />
to run side by side with an ASP.NET Core app on the same IIS server. As pieces of functionality, such<br />
as individual controllers, are ported to ASP.NET Core, their routes and URLs are mapped within IIS to<br />
target the ASP.NET Core web site or sub-application (IIS virtual directories aren’t supported with<br />
ASP.NET Core apps). An ASP.NET Core app can be hosted as an IIS sub-application (sub-app). The<br />
sub-app’s path becomes part of the root app’s URL.</p>
<h4><strong>Apply the Strangler pattern</strong></h4>
<p>Large ASP.NET MVC apps can be gradually replaced with a new ASP.NET Core app by incrementally<br />
<a href="https://docs.microsoft.com/azure/architecture/patterns/strangler">migrating pieces of functionality. One approach to this is called the strangler pattern, named for</a><br />
strangler vines that strangle and eventually tear down trees. This approach relies on first<br />
implementing a facade layer over top of the existing solution. This facade should be built using the<br />
new approach to the problem, or an off-the-shelf solution such as an API gateway.</p>
<p>Once the facade is in place, you can route part of it to a new ASP.NET Core app. As you port more of<br />
the original .NET Framework app to .NET Core, you continue to update the facade layer accordingly,<br />
sending more of the facade’s total functionality to the new system. Figure 3-5 shows the strangler<br />
pattern progression over time.</p>
<p>41 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<p><em>Figure 3-5. The Strangler pattern over time.</em></p>
<p>Eventually, the entire facade layer corresponds to the new, modern implementation. At this point,<br />
both the legacy system and the face layer can be retired. Microsoft has guidance on how to achieve<br />
<a href="https://devblogs.microsoft.com/dotnet/incremental-asp-net-to-asp-net-core-migration/">incremental ASP.NET to ASP.NET Core migration using the YARP reverse proxy.</a></p>
<h4><strong>Multi-targeting approaches</strong></h4>
<p>Multi-targeting is recommended for large apps that will be migrated over time and for teams<br />
applying the Strangler pattern approach. This approach can address BindingRedirect and package<br />
<a href="https://docs.microsoft.com/nuget/consume-packages/package-references-in-project-files">restoration challenges that surface from mixing PackageReference</a> <a href="https://docs.microsoft.com/nuget/reference/packages-config">and packages.config restore styles.</a><br />
There are two options available for code that must run in both .NET Framework and .NET Core<br />
environments.</p>
<ul>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives#conditional-compilation">Preprocessor directives (#if in C#</a> <a href="https://docs.microsoft.com/dotnet/visual-basic/reference/language-specification/preprocessing-directives#conditional-compilation">or #If in Visual Basic) allow you to implement different</a><br />
functionality or use different dependencies when run in .NET Framework versus .NET Core.</p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/project-sdk/overview#default-includes-and-excludes">Project files can use conditional globbing patterns, such as *.core.cs, to include different sets</a><br />
of files based on which framework is being targeted.</p>
</li>
</ul>
<p>Typically you only follow these recommendations for class libraries. These techniques allow a single<br />
common codebase to be maintained while new functionality is added and features of the app are<br />
incrementally ported to use .NET Core.</p>
<h4><strong>Summary</strong></h4>
<p>Frequently, large ASP.NET MVC and Web API apps won’t be ported to ASP.NET Core all at once, but<br />
will migrate incrementally over time. This section offers several strategies for performing this<br />
incremental migration. Choose the one(s) that will work best for your organization and app.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://aka.ms/microservicesebook">.NET Microservices: Architecture for Containerized .NET Applications</a></p>
</li>
<li>
<p><a href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers Reference Microservices Application</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/iis/">Host ASP.NET Core on Windows with IIS</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/azure/architecture/patterns/strangler">Strangler pattern</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/dotnet/incremental-asp-net-to-asp-net-core-migration/">Incremental ASP.NET to ASP.NET Core Migration</a></p>
</li>
</ul>
<p>42 CHAPTER 3 | Migrate large solutions to ASP.NET Core</p>
<p><strong>CHAPTER</strong></p>
<h1>4</h1>
<h2>Example migration of eShop to ASP.NET Core</h2>
<p>In this chapter, you’ll see how to migrate a .NET Framework app to .NET Core. The chapter examines a<br />
sample online store app written for ASP.NET MVC 5. The app will use many of the concepts and tools<br />
described earlier in this book. You’ll find the starting point app in the <em><a href="https://github.com/dotnet-architecture/eShopModernizing">eShopModernizing</a></em> GitHub<br />
<a href="https://github.com/dotnet-architecture/eShopModernizing">repository. There are several different starting point apps. This chapter focuses on the</a><br />
<em>eShopLegacyMVCSolution</em> .</p>
<p>The initial version of the project is shown in Figure 4-1. It’s a fairly standard ASP.NET MVC 5 app.</p>
<p><em>Figure 4-1. The eShopModernizing MVC sample project structure.</em></p>
<p>43 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>This chapter demonstrates how to perform many of the upgrade steps by hand. Alternatively, you can<br />
<a href="https://aka.ms/dotnet-upgrade-assistant">use the .NET Upgrade Assistant tool to perform many of the initial steps, like converting the project</a><br />
file, changing the target framework, and updating NuGet packages.</p>
<h3>Run ApiPort to identify problematic APIs</h3>
<p>The first step in preparing to migrate is to run the <em>ApiPort</em> tool. The tool identifies how many .NET<br />
Framework APIs the app calls and how many of these have .NET Standard or .NET Core equivalents.<br />
Focus primarily on your own app’s logic, not third-party dependencies, and pay attention to<br />
System.Web dependencies that will need to be ported. The ApiPort tool was introduced in the last<br />
chapter on understanding and updating dependencies. Note that currently it requires Visual Studio<br />
2019; Visual Studio 2022 support is planned.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/analyzers/portability-analyzer">After installing and configuring the</a> <em>ApiPort</em> tool, run the analysis from within Visual Studio, as shown<br />
in Figure 4-2.</p>
<p>44 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-2. Analyze assembly portability in Visual Studio.</em></p>
<p>Choose the web project’s assembly from the project’s <em>bin</em> folder, as shown in Figure 4-3.</p>
<p>45 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-3. Choose the project’s web assembly.</em></p>
<p>If your solution includes several projects, you can choose all of them. The <em>eShop</em> sample includes just a<br />
single MVC project.</p>
<p>Once the report is generated, open the file and review the results. The summary provides a high-level<br />
view of what percentage of .NET Framework calls your app is making have compatible versions. Figure<br />
4-4 shows the summary for the <em>eShop</em> MVC project.</p>
<p><em>Figure 4-4. ApiPort summary.</em></p>
<p>For this app, about 80 percent of the .NET Framework calls are compatible. 20 percent of the calls<br />
need to be addressed during the porting process. Viewing the details reveals that all of the<br />
incompatible calls are part of System.Web, which is an expected incompatibility. The dependencies on<br />
System.Web calls will be addressed when the app’s controllers and related classes are migrated in a<br />
later step. Figure 4-5 lists some of the specific types found by the tool:</p>
<p>46 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-5. ApiPort incompatible type details.</em></p>
<p>Most of the incompatible types refer to Controller and various related attributes that have equivalents<br />
in ASP.NET Core.</p>
<h3>Update project files and NuGet reference syntax</h3>
<p>Next, migrate from the older <em>.csproj</em> file structure to the newer, simpler structure introduced with .NET<br />
Core. In doing so, you’ll also migrate from using a <em>packages.config</em> file for NuGet references to using<br />
<PackageReference> elements in the project file. Old-style project files may also use<br />
<PackageReference> elements, so it usually makes sense to migrate all NuGet package references to<br />
this format first, before upgrading to the new project file format.</p>
<p>The original project’s <em>eShopLegacyMVC.csproj</em> file is 418 lines long. A sample of the project file is<br />
shown in Figure 4-6. To offer a sense of its overall size and complexity, the right side of the image<br />
contains a miniature view of the entire file.</p>
<p>47 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-6. The eShopLegacyMVC.csproj file structure.</em></p>
<p>A common way to create a new project file for an existing ASP.NET project is to create a new ASP.NET<br />
Core app using dotnet new or <strong>File</strong> - <strong>New</strong> - <strong>Project</strong> in Visual Studio. Then files can be copied from<br />
the old project to the new one to complete the migration.</p>
<p>In addition to the C# project file, NuGet dependencies are stored in a separate 45-line <em>packages.config</em><br />
file, as shown in Figure 4-7.</p>
<p>48 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-7. The packages.config file.</em></p>
<p>You can migrate <em>packages.config</em> in class library projects using Visual Studio. This functionality doesn’t<br />
work with ASP.NET projects, however. Learn more about migrating <em><a href="https://docs.microsoft.com/nuget/consume-packages/migrate-packages-config-to-package-reference">packages.config</a></em> to<br />
<a href="https://docs.microsoft.com/nuget/consume-packages/migrate-packages-config-to-package-reference"><PackageReference> in Visual Studio. If you have a large number of projects to migrate, this</a><br />
<a href="https://github.com/MarkKharitonov/NuGetPCToPRMigrator">community tool may help. If you’re using a tool to migrate the project file to the new format, you</a><br />
should do that after you’ve finished migrating all NuGet references to use <PackageReference>.</p>
<h3>Create new ASP.NET Core project</h3>
<p>Add a new ASP.NET Core project to the existing app’s solution to make moving files easier, as most of<br />
the work can be done from within Visual Studio’s <strong>Solution Explorer</strong> . In Visual Studio, right-click on<br />
your app’s solution and choose <strong>Add New Project</strong> . Choose <strong>ASP.NET Core web application</strong>, and give<br />
the new project a name as shown in Figure 4-8.</p>
<p>49 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-8. Add new ASP.NET Core web application.</em></p>
<p>The next dialog will ask you to choose which template to use. Select the <strong>Empty</strong> template. Be sure to<br />
also change the dropdown from <strong>.NET Core</strong> to <strong>.NET Framework</strong> . Select <strong>ASP.NET Core 2.2</strong>, as shown<br />
in Figure 4-9.</p>
<p>50 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-9. Choose an Empty project template targeting .NET Framework with ASP.NET Core 2.2.</em></p>
<h4><strong>Migrating NuGet Packages</strong></h4>
<p>Since the built-in migration tool for migrating <em>packages.config</em> to <PackageReference> doesn’t work<br />
<a href="https://gist.github.com/tomkuijsten/2d75074d9a3c19c04ee8ea19a6289ddf">on ASP.NET projects, you can use a community tool instead, or migrate by hand. A community tool</a><br />
<a href="https://gist.github.com/tomkuijsten/2d75074d9a3c19c04ee8ea19a6289ddf">I’ve used</a> uses an XSL file to transform from one format to the other. To use it, first copy the<br />
<em>packages.config</em> file to the newly created ASP.NET Core project folder. Make a backup of your files, as<br />
this script removes the <em>packages.config</em> file from all folders under where you run the script. Then run<br />
these commands from the project folder (or for the entire solution if you prefer):</p>
<pre><code>iwr
https://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7c9218bf9c/raw/7789
53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.ps1 -OutFile ConvertToPackageReference.ps1
iwr
https://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7c9218bf9c/raw/7789
53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.xsl -OutFile ConvertToPackageReference.xsl
./Convert-ToPackageReference.ps1 | Out-Null

</code></pre>
<p>The first two commands download files so that they exist locally. The last line runs the script. After<br />
running it, try to build the new project. You’ll most likely get some errors. To resolve them, you’ll want<br />
to eliminate some references (like most of the Microsoft.AspNet and System packages), and you may<br />
need to remove some xmlns attributes.</p>
<p>51 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>In most ASP.NET MVC apps, many client-side dependencies like Bootstrap and jQuery were deployed<br />
using NuGet packages. In ASP.NET Core, NuGet packages are only used for server-side functionality.<br />
Client files should be managed through other means. Review the list of <PackageReference><br />
elements added and remove and make note of any that are for client libraries, including:</p>
<ul>
<li>
<p>Bootstrap</p>
</li>
<li>
<p>jQuery</p>
</li>
<li>
<p>jQuery.Validation</p>
</li>
<li>
<p>Modernizr</p>
</li>
<li>
<p>popper.js</p>
</li>
<li>
<p>Respond</p>
</li>
</ul>
<p>The static client files installed by NuGet for these packages will be copied over to the new project’s<br />
<em>wwwroot</em> folder and hosted from there. It’s worth considering whether these files are still needed by<br />
the app, and whether it makes sense to continue hosting them or to use a content delivery network<br />
<a href="https://docs.microsoft.com/aspnet/core/client-side/libman/">(CDN) instead. These library versions can be managed at build time using tools like LibMan or npm.</a><br />
Figure 4-10 shows the full <em>eShopPorted.csproj</em> file after migrating package references using the<br />
conversion tool shown and removing unnecessary packages.</p>
<p><em>Figure 4-10. Package references in the eShopPorted.csproj file.</em></p>
<p>The package references can be further compacted by making the <Version>1.0.0.0</Version><br />
element a Version=1.0.0.0 attribute on <PackageReference>.</p>
<p>52 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<h4><strong>Migrate static files</strong></h4>
<p>Any static files the app uses, including third-party scripts and frameworks but also custom images and<br />
stylesheets, must be copied from the old project to the new one. In ASP.NET MVC apps, files were<br />
typically accessed based on their location within the project folder. In ASP.NET Core apps, these static<br />
files will be accessed based on their location within the <em>wwwroot</em> folder. For the <em>eShop</em> project, there<br />
are static files in the following folders:</p>
<ul>
<li>
<p><em>Content</em></p>
</li>
<li>
<p><em>fonts</em></p>
</li>
<li>
<p><em>Images</em></p>
</li>
<li>
<p><em>Pics</em></p>
</li>
<li>
<p><em>Scripts</em></p>
</li>
</ul>
<p>The <strong>Empty</strong> project template used in the previous step doesn’t include this folder by default, or the<br />
middleware needed for it to work. You’ll need to add them.</p>
<p>Add a <em>wwwroot</em> folder to the root of the project.</p>
<p>Add version 2.2.0 of the Microsoft.AspNetCore.StaticFiles NuGet package.</p>
<p>In <em>Startup.cs</em>, add a call to app.UseStaticFiles() in the Configure method:</p>
<p>Copy the <em>Content</em> folder from the ASP.NET MVC app to the new project’s <em>wwwroot</em> folder.</p>
<p>Run the app and navigate to its <em>/Content/base.css</em> folder to verify that the static file is served correctly<br />
from its expected path. Continue copying the rest of the folders containing static files to the new<br />
project. You’ll also want to copy the <em>favicon.ico</em> file from the project’s root to the <em>wwwroot</em> folder.<br />
Figure 4-11 shows the results after these files and their folders have all been copied.</p>
<p>53 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-11. Static folders copied over to wwwroot folder.</em></p>
<h4><strong>Migrate C# files</strong></h4>
<p>Next, copy over the C# files used by the app, including standard MVC folders and their contents like<br />
<em>Controllers</em>, <em>Models</em>, <em>ViewModel</em>, and <em>Services</em> . There will most likely be some changes needed in these<br />
files. It’s best to copy one folder (or subfolder) at a time and compile to see what errors need to be<br />
addressed as you go.</p>
<p>For the <em>eShop</em> sample, the first folder I choose to migrate is the <em>Models</em> folder, which includes C#<br />
entities and Entity Framework classes. This folder’s classes are used by most of the others, so they<br />
won’t work until these classes have been copied. After copying the folder and building, the compiler<br />
revealed errors related to missing namespace System.Web.Hosting, related access to<br />
HostingEnvironment, and a reference to ConfigurationManager.AppSettings. The solution to these<br />
issues will be to pass in the necessary path data; for now the breaking lines are commented out and a<br />
TODO: comment is added to each one to track it. After changing five lines, the <strong>Task List</strong> shows five<br />
items and the project builds.</p>
<p>Next, the <em>ViewModel</em> folder, with its one class, is copied over. It’s an easy one, and builds immediately.</p>
<p>The <em>Services</em> folder is copied over. This folder’s classes depend on Entity Framework classes from the<br />
<em>Models</em> folder, which is why it needed to be copied after that folder. Fortunately, it too builds without<br />
errors.</p>
<p>54 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>That leaves the <em>Controllers</em> folder and its two Controller classes. After copying the folder to the new<br />
project and building, there are seven build errors. Four of them are related to ViewBag access and<br />
report an error of:</p>
<p>Missing compiler required member 'Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo.Create'</p>
<p>To resolve this error, add a NuGet package reference to C#:</p>
<pre><code>&lt; PackageReference Include=&quot;Microsoft.CSharp&quot; Version=&quot;4.7.0&quot; /&gt;

</code></pre>
<p>The remaining three errors specify types that are defined in an assembly that isn’t referenced.<br />
Specifically these types:</p>
<ul>
<li>
<p>HttpServerUtilityBase</p>
</li>
<li>
<p>RouteValueDictionary</p>
</li>
<li>
<p>HttpRequestBase</p>
</li>
</ul>
<p>Let’s look at each error one by one. The first error occurs while trying to reference the Server property<br />
of Controller, which no longer exists. The goal of the operation is to get the path to an image file in<br />
the app:</p>
<p>There are two possible solutions to this problem. The first is to keep the functionality as it is. In this<br />
case, rather than using Server.MapPath, a fixed path referencing the image files’ location in <em>wwwroot</em><br />
should be used. Alternately, since the only purpose of this action method is to return a static image<br />
file, the references to this action in view files can be updated to reference the static files directly, which<br />
improves runtime performance. Since no processing is being done as part of this action, there’s no<br />
reason not to just serve the files directly. If it’s not tenable to update all references to this action, the<br />
action could be rewritten to produce a redirect to the static file’s location.</p>
<p>The next two errors both occur in the same private method in the same line of code:</p>
<p>Both this.Url and this.Request cause compiler errors. Looking at how this code is used, its purpose is<br />
to build a link to the PicController action that renders image files. The same one we just discovered<br />
could probably be replaced with direct links to the static files located in <em>wwwroot</em> . For now, it’s worth<br />
commenting out this code and adding a TODO: comment to reference the pics another way.</p>
<p>55 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>It’s worth noting that the base Controller class, used by the CatalogController class in which this code<br />
appears, is still referring to System.Web.Mvc.Controller. There will undoubtedly be more errors to fix<br />
once we update this to use ASP.NET Core. First, remove the using System.Web.Mvc; line from the list<br />
of using statements in CatalogController. Next, add the NuGet package Microsoft.AspNetCore.Mvc.<br />
Finally, add a using Microsoft.AspNetCore.Mvc; statement, and build the app again.</p>
<p>This time, there are 16 errors:</p>
<ul>
<li>
<p>Include is not a valid named attribute argument (2)</p>
</li>
<li>
<p>HttpStatusCodeResult not found (3)</p>
</li>
<li>
<p>HttpNotFound does not exist (3)</p>
</li>
<li>
<p>SelectList not found (8)</p>
</li>
</ul>
<p>Once more, let’s review these errors one by one. First, SelectList can be fixed by adding using<br />
Microsoft.AspNetCore.Mvc.Rendering;, which eliminates half of the errors.</p>
<p>All references to return HttpNotFound(); should be replaced with return NotFound();.</p>
<p>All references to return new HttpStatusCodeResult(HttpStatusCode.BadRequest); should be replaced<br />
with return BadRequest();.</p>
<p>That just leaves the use of Include with a [Bind] attribute on a couple of action methods that look like<br />
this:</p>
<p>The preceding code restricts model binding to the properties listed in the Include string. In ASP.NET<br />
Core MVC, the [Bind] attribute still exists, but no longer needs the Include = argument. Pass the list of<br />
properties directly to the [Bind] attribute:</p>
<p>With these changes, the project compiles once more. It’s generally a better practice to use separate<br />
model types for controller inputs, rather than using model binding directly to your domain model or<br />
data model types.</p>
<h3>Migrate views</h3>
<p><a href="https://docs.microsoft.com/aspnet/core/razor-pages/">The two biggest ASP.NET Core MVC features related to views are Razor Pages and Tag Helpers. For</a><br />
the initial migration, we won’t use either feature. You should, however, keep the features in mind if<br />
you continue supporting the app once it’s been migrated. The next step is to copy the <em>Views</em> folder<br />
from the original project into the new one. After building, there are nine errors:</p>
<p>56 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<ul>
<li>
<p>HttpContext does not exist (2)</p>
</li>
<li>
<p>Scripts does not exist (5)</p>
</li>
<li>
<p>Styles does not exist (1)</p>
</li>
<li>
<p>HtmlString could not be found(1)</p>
</li>
</ul>
<p>Investigating these errors finds that most of them are in the main <em>_Layout.cshtml <em>, with several related</em><br />
<em>to rendering script and style tags, or displaying when the server hosting the app was last restarted. The</em><br />
<em>following code listing shows problem areas in the</em> _Layout.cshtml</em> file:</p>
<p>The reference to Modernizr can be removed. The references to Bootstrap and jQuery can be replaced<br />
with CDN links to the appropriate version.</p>
<p>Replace @Styles.Render line with:</p>
<p>Replace the last two Scripts.Render lines with:</p>
<p>Finally, after the Bootstrap <link>, add additional <link> elements for local styles your app uses. For<br />
<em>eShop</em>, the result is shown here:</p>
<p>To determine the order in which the <link> elements should appear, look at your original app’s<br />
rendered HTML. Alternatively, review <em>BundleConfig.cs</em>, which for the <em>eShop</em> sample includes this code<br />
indicating the appropriate sequence:</p>
<p>57 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>Building again reveals one more error loading jQuery Validation on the <em>Create</em> and <em>Edit</em> views. Replace<br />
it with this script:</p>
<p>The last thing to fix in the views is the reference to Session to display how long the app has been<br />
running, and on which machine. We can display this data directly in the site’s <em>_Layout.cshtml</em> by<br />
using System.Environment.MachineName and<br />
System.Diagnostics.Process.GetCurrentProcess().StartTime:</p>
<p>At this point, the app once more builds successfully. However, trying to run it just yields <em>Hello World!</em><br />
because the <strong>Empty</strong> ASP.NET Core template is only configured to display that in response to any<br />
request. In the next section, I complete the migration by configuring the app to use ASP.NET Core<br />
MVC, including dependency injection and configuration. Once that’s in place, the app should run.<br />
Then it will be time to fix the TODO: tasks that were created earlier.</p>
<h3>Migrate app startup components</h3>
<p>The last migration step is to take the app startup tasks from <em>Global.asax</em>, and the classes it calls, and<br />
migrate these to their ASP.NET Core equivalents. These tasks include configuration of MVC itself,<br />
setting up dependency injection, and working with the new configuration system. In ASP.NET Core,<br />
these tasks are handled in the <em>Startup.cs</em> file.</p>
<h4><strong>Configure MVC</strong></h4>
<p>The original ASP.NET MVC app has the following code in its Application_Start in <em>Global.asax</em>, which<br />
runs when the app starts up:</p>
<p>58 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>Looking at these lines one by one, the RegisterContainer method sets up dependency injection, which<br />
will be ported below. The next three lines configure different parts of MVC: areas, filters, and routes.<br />
Bundles are replaced by static files in the ported app. The last line sets up data access for the app,<br />
which will be shown in a later section.</p>
<p>Since this app isn’t actually using areas, there’s nothing that needs to be done to migrate the area<br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/areas">registration call. If your app does need to migrate areas, the docs specify how to configure areas in</a><br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/areas">ASP.NET Core.</a></p>
<p>The call to register global filters invokes a helper on the FilterConfig class in the app’s <em>App_Start</em><br />
folder:</p>
<p>The only attribute added to the app is the ASP.NET MVC filter, HandleErrorAttribute. This filter ensures<br />
that when an exception occurs as part of a request, a default action and view are displayed, rather<br />
than the exception details. In ASP.NET Core, this same functionality is performed by the<br />
UseExceptionHandler middleware. The detailed error messages aren’t enabled by default. They must<br />
be configured using the UseDeveloperExceptionPage middleware. To configure this behavior to match<br />
the original app, the following code must be added to the start of the Configure method in <em>Startup.cs</em> :</p>
<p>This takes care of the only filter used by the eShop app, and in this case it was done by using built-in<br />
middleware. If you have global filters that must be configured in your app, this is done when MVC is<br />
added in <em>Program.cs</em> when you configure services, which is shown later in this chapter.</p>
<p>The last piece of MVC-related logic that needs to be migrated are the app’s default routes. The call to<br />
RouteConfig.RegisterRoutes(RouteTable.Routes) passes the MVC route table to the RegisterRoutes<br />
helper method, where the following code is executed when the app starts up:</p>
<p>59 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>Taking this code line-by-line, the first line sets up support for attribute routes. This is built into<br />
ASP.NET Core, so it’s unnecessary to configure it separately. Likewise, <em>{resource}.axd</em> files aren’t used<br />
with ASP.NET Core, so there’s no need to ignore such routes. The MapRoute method configures the<br />
default for MVC, which uses the typical {controller}/{action}/{id} route template. It also specifies the<br />
defaults for this template, such that the CatalogController is the default controller used and the Index<br />
method is the default action. Larger apps will frequently include more calls to MapRoute to set up<br />
additional routes.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/routing?preserve-view=true&amp;view=aspnetcore-2.2">ASP.NET Core MVC supports conventional routing and attribute routing. Conventional routing is</a><br />
analogous to how the route table is configured in the RegisterRoutes method listed previously. To set<br />
up conventional routing with a default route like the one used in the <em>eShop</em> app, add the following<br />
code to the bottom of the Configure method in <em>Startup.cs</em> :</p>
<p>With these changes in place, the Configure method is almost done. The original template’s app.Run<br />
method that prints <em>Hello World!</em> should be deleted. At this point, the method is as shown here:</p>
<p>Now it’s time to configure MVC services, followed by the rest of the app’s support for dependency<br />
injection (DI). So far, the <em>eShopPorted</em> project’s <em>Program.cs</em> file hasn’t added any service configuration.<br />
Now it’s time to start adding necessary services.</p>
<p>First, to get ASP.NET Core MVC to work properly, it needs to be added:</p>
<p>60 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<pre><code>builder.Services.AddMvc();

</code></pre>
<p>The preceding code is the minimal configuration required to get MVC features working. There are<br />
many additional features that can be configured from this call (some of which are detailed later in this<br />
chapter), but for now this will suffice to build the app. Running it now routes the default request<br />
properly, but since we’ve not yet configured DI, an error occurs while activating CatalogController,<br />
because no implementation of type ICatalogService has been provided yet. We’ll return to configure<br />
MVC further in a moment. For now, let’s migrate the app’s dependency injection.</p>
<p><strong>Migrate dependency injection configuration</strong></p>
<p>The original app’s <em>Global.asax</em> file defines the following method, called when the app starts up:</p>
<p><a href="https://autofac.org/">This code configures an Autofac container, reads a config setting to determine whether real or mock</a><br />
data should be used, and passes this setting into an Autofac module (found in the app’s <em>/Modules</em><br />
directory). Fortunately, Autofac supports .NET Core, so the module can be migrated directly. Copy the<br />
folder into the new project and updates the class’s namespace and it should compile.</p>
<p>ASP.NET Core has built-in support for dependency injection, but you can wire up a third-party<br />
container such as Autofac easily if necessary. In this case, since the app is already configured to use<br />
Autofac, the simplest solution is to maintain its usage. In <em>Program.cs</em>, simply configure the builder to<br />
use the AutofacServiceProviderFactory as shown:</p>
<p>For now, the setting for useMockData is set to true. This setting will be read from configuration in a<br />
moment. At this point, the app compiles and should load successfully when run, as shown in Figure 412.</p>
<p>61 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><em>Figure 4-12. Ported eShop app running locally with mock data.</em></p>
<p><strong>Migrate app settings</strong></p>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/?preserve-view=true&amp;view=aspnetcore-2.2">ASP.NET Core uses a new configuration system, which by default uses an</a> <em>appsettings.json</em> file. By using<br />
CreateDefaultBuilder in <em>Program.cs</em>, the default configuration is already set up in the app. To access<br />
configuration, classes just need to request it in their constructor. In <em>Program.cs</em>, configuration is<br />
accessible from builder.Configuration.</p>
<p>The original app referenced its settings using ConfigurationManager.AppSettings. A quick search for<br />
all references of this term yields the set of settings the new app needs. There are only two:</p>
<ul>
<li>
<p>UseMockData</p>
</li>
<li>
<p>UseCustomizationData</p>
</li>
</ul>
<p>If your app has more complex configuration, especially if it’s using custom configuration sections,<br />
you’ll probably want to create and bind objects to different parts of your app’s configuration. These<br />
<a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/options">types can then be accessed using the options pattern. However, as noted in the referenced doc, this</a><br />
pattern shouldn’t be used in <em>Program.cs</em> (or Startup.ConfigureServices). Instead the ported app will<br />
reference the UseMockData configuration value directly.</p>
<p>First, modify the ported app’s appsettings.json file and add the two settings in the root:</p>
<p>62 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>Now, modify <em>Program.cs</em> to access the UseMockData setting from the builder.Configuration property<br />
(where previously we set the value to true):</p>
<pre><code>bool useMockData = builder.Configuration.GetValue&lt;bool&gt;(&quot;UseMockData&quot;);

</code></pre>
<p>At this point, the setting is pulled from configuration. The other setting, UseCustomizationData, is<br />
used by the CatalogDBInitializer class. When you first ported this class, you commented out the access<br />
to ConfigurationManager.AppSettings[&quot;UseCustomizationData&quot;]. Now it’s time to modify it to use<br />
ASP.NET Core configuration. Modify the constructor of CatalogDBInitializer as follows:</p>
<p>All access to configuration within the web app should be modified in this manner to use the new<br />
IConfiguration type. Dependencies that require access to .NET Framework configuration can include<br />
such settings in an <em>app.config</em> file added to the web project. The dependent projects can work with<br />
ConfigurationManager to access settings, and shouldn’t require any changes if they already use this<br />
approach. However, since ASP.NET Core apps run as their own executable, they don’t reference<br />
<em>web.config</em> but rather <em>app.config</em> . By migrating settings from the legacy app’s <em>web.config</em> file to a new<br />
<em>app.config</em> file in the ASP.NET Core app, components that use ConfigurationManager to access their<br />
settings will continue to function properly.</p>
<p>The app’s migration is nearly complete. The only remaining task is data access configuration.</p>
<h3>Data access considerations</h3>
<p>ASP.NET Core apps running on .NET Framework can continue to use Entity Framework (EF). If<br />
performing an incremental migration, getting the app working with EF 6 before trying to port its data<br />
access to use EF Core may be worthwhile. In this way, any problems with the app’s migration can be<br />
identified and addressed before another block of migration effort is begun.</p>
<p>As it happens, configuring EF 6 in the eShop sample migration doesn’t require any special work, since<br />
this work was performed in the Autofac ApplicationModule. The only problem is that currently the<br />
CatalogDBContext class tries to read its connection string from <em>web.config</em> . To address this, the<br />
connection details need to be added to <em>appsettings.json</em> . Then the connection string must be passed<br />
into CatalogDBContext when it’s created.</p>
<p>Update the <em>appsettings.json</em> to include the connection string. The full file is listed here:</p>
<p>63 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>The connection string must be passed into the constructor when the DbContext is created. Since the<br />
instances are created by Autofac, the change needs to be made in ApplicationModule. Modify the<br />
module to take in a connectionString in its constructor and assign it to a field. Then modify the<br />
registration for CatalogDBContext to add connection string as a parameter:</p>
<p>The parameter must also be added to a new constructor overload in CatalogDBContext itself:</p>
<p>Finally, <em>Program.cs</em> must read the connection string from Configuration and pass it into the<br />
ApplicationModule when it instantiates it:</p>
<p>With this code in place, the app runs as it did before, connecting to a SQL Server database when<br />
UseMockData is false.</p>
<p>The app can be deployed and run in production at this point, converted to ASP.NET Core but still<br />
running on .NET Framework and EF 6. If desired, the app can be migrated to run on .NET Core and<br />
Entity Framework Core, which will bring additional advantages described in earlier chapters. Specific<br />
<a href="https://docs.microsoft.com/ef/efcore-and-ef6/">to Entity Framework, this documentation compares EF Core and EF 6 and includes a grid showing</a><br />
which library supports each of dozens of individual features.</p>
<h4><strong>Migrate to Entity Framework Core</strong></h4>
<p>Assuming a decision is made to migrate to EF Core, the steps can be fairly straightforward, especially<br />
<a href="https://docs.microsoft.com/ef/efcore-and-ef6/porting/">if the original app used a code-based model approach. When preparing to port from EF 6 to EF Core,</a><br />
review the availability of features in the destination version of EF Core you’ll be using. Review the<br />
<a href="https://docs.microsoft.com/ef/efcore-and-ef6/porting/port-edmx">documentation on porting from and EDMX-based model</a> <a href="https://docs.microsoft.com/ef/efcore-and-ef6/porting/port-code">versus porting from a code-based model.</a></p>
<p>64 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>To upgrade to EF Core 2.2, the basic steps involved are to add the appropriate NuGet package(s) and<br />
update namespaces. Then adjust how the connection string is passed to the DbContext type and how<br />
they’re wired up for dependency injection.</p>
<p>EF Core is added as a package reference to the project:</p>
<pre><code>&lt; PackageReference Include=&quot;Microsoft.EntityFrameworkCore&quot; Version=&quot;2.2.6&quot; /&gt;

</code></pre>
<p>The reference to EF 6 is removed:</p>
<pre><code>&lt; PackageReference Include=&quot;EntityFramework&quot; Version=&quot;6.2.0&quot; /&gt;

</code></pre>
<p>The compiler will report errors in CatalogDBContext and CatalogDBInitializer. CatalogDbContext<br />
needs to have the old namespaces removed and replaced with Microsoft.EntityFrameworkCore. Its<br />
constructors can be removed. DbModelBuilder should be replaced with ModelBuilder. The helper<br />
methods for configuring types are moved to separate classes implementing<br />
IEntityTypeConfiguration<T>. Then the CatalogDBContext class’s OnModelCreating method simply<br />
becomes:</p>
<p>Other changes involved include:</p>
<ul>
<li>
<p>HasDatabaseGeneratedOption(DatabaseGeneratedOption.None) replaced with<br />
ValueGeneratedNever()</p>
</li>
<li>
<p>HasRequired<T> replaced with HasOne<T></p>
</li>
<li>
<p>Installed Microsoft.EntityFrameworkCore.Relational package</p>
</li>
<li>
<p>Add a constructor to CatalogDBContext taking DbContextOptions and passing it to the base<br />
constructor</p>
</li>
</ul>
<p>An example configuration class for CatalogType is shown here:</p>
<p>65 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>The CatalogDBInitializer and its base class, CreateDatabaseIfNotExists<T>, are incompatible with EF<br />
<a href="https://docs.microsoft.com/ef/core/managing-schemas/ensure-created">Core. The purpose of this class is to create and seed the database. Using EF Core will create and drop</a><br />
<a href="https://docs.microsoft.com/ef/core/managing-schemas/ensure-created">the associated database for a DbContext using these methods:</a></p>
<p>Seeding data in EF Core can be done with manual scripts, or as part of the type configuration. Along<br />
with other entity properties, seed data can be configured in IEntityTypeConfiguration classes by using<br />
builder.HasData(). The original app loaded seed data from CSV files in the <em>Setup</em> directory. Given that<br />
there are only a handful of items, these data records can instead be added as part of the entity<br />
configuration. This approach works well for lookup data in tables that change infrequently. Adding the<br />
following to CatalogTypeConfig’s Configure method ensures the associated rows are present when<br />
the database is created:</p>
<p>The initial app includes a PreconfiguredData class, which includes data for CatalogBrand and<br />
CatalogType, so using this method the HasData call reduces to:</p>
<p>The CatalogItem data can also be pulled from PreconfiguredData, and assuming the associated<br />
images are kept in source control, that is the last table needed for the app to function. The<br />
CatalogDBInitializer class can be removed, along with any references to it. The<br />
CatalogItemHiLoGenerator class and the SQL files in the Infrastructure directory are also removed,<br />
along with any references to them (in CatalogService, ApplicationModule).</p>
<p>With the elimination of the special key generator classes for CatalogItem, this code now is removed<br />
from CatalogItemConfig:</p>
<p>With these modifications, the ASP.NET Core app builds, but it doesn’t yet work with EF Core, which<br />
must still be configured for dependency injection. With EF Core, the simplest way to configure it is in<br />
<em>Program.cs</em> :</p>
<p>66 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>The final version of Autofac’s ApplicationModule only configures one type, depending on whether the<br />
app is configured to use mock data:</p>
<p>The ported app runs, but doesn’t display any data if configured to use non-mock data. The seed data<br />
added through HasData is only inserted when migrations are applied. The source app didn’t use<br />
migrations, and if it had, they wouldn’t migrate as-is. The best approach is to start with a new<br />
migration script. To do this, add a package reference for Microsoft.EntityFrameworkCore.Design and<br />
open a terminal window in the project root. Then run:</p>
<pre><code>dotnet ef migrations add Initial

</code></pre>
<p>Drop the existing <em>eShopPorted</em> database if it exists, then run:</p>
<pre><code>dotnet ef database update

</code></pre>
<p>This creates and seeds the database. It’s now ready to run, with a few small updates left to address.</p>
<h3>Fix all TODO tasks</h3>
<p>Running the ported app at this point reveals that no pictures are shown on the page. This is because<br />
the PictureUri property of CatalogItem is never set. Looking at the list of TODO items we created</p>
<p>67 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>using Visual Studio’s <strong>Task List</strong>, the only one that remains is in CatalogController, with a note to<br />
“Reference pic from wwwroot.” The code in question is:</p>
<p>The simplest fix is to reference the public image files in the site’s public <em>wwwroot/Pics</em> directory. This<br />
task can be accomplished by replacing the method with the following code:</p>
<p>With this change, running the app reveals the images work as before.</p>
<h3>Additional MVC customizations</h3>
<p>The <em>eShopLegacyMVC</em> app is fairly simple, so there isn’t much to configure in terms of default MVC<br />
behavior. However, if you do need to configure additional MVC components, such as CORS, filters,<br />
and route constraints, you generally provide this information in <em>Program.cs</em>, where UseMvc is called.<br />
<a href="https://docs.microsoft.com/aspnet/core/security/cors?preserve-view=true&amp;view=aspnetcore-2.2">For example, the following code listing configures CORS</a> and sets up a global action filter:</p>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding?preserve-view=true&amp;view=aspnetcore-2.2">Other advanced scenarios, like adding custom model binders, formatters, and more are covered in the</a><br />
detailed ASP.NET Core docs. Generally these can be applied on an individual controller or action basis,<br />
or globally using the same options approach shown in the previous code listing.</p>
<p>68 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<h3>Other dependencies</h3>
<p>Dependencies that use .NET Framework features that had a dependency on the legacy configuration<br />
model, such as the WCF client type and tracing code, must be modified when ported. Rather than<br />
having these types pull in their configuration information directly, they should be configured in code.<br />
For example, a connection to a WCF service that was configured in an ASP.NET app’s <em>web.config</em> to use<br />
basicHttpBinding could instead be configured programmatically with the following code:</p>
<p>Rather than relying on config files for its settings, WCF clients and other .NET Framework types should<br />
have their settings specified in code. Configured in this manner, these types can continue to work in<br />
ASP.NET Core 2.2 apps.</p>
<h3>References</h3>
<ul>
<li>
<p><a href="https://github.com/dotnet-architecture/eShopModernizing">eShopModernizing GitHub repository</a></p>
</li>
<li>
<p><a href="https://aka.ms/dotnet-upgrade-assistant">.NET Upgrade Assistant tool</a></p>
</li>
<li>
<p><a href="https://ardalis.com/your-api-and-view-models-should-not-reference-domain-models/">Your API and ViewModels Should Not Reference Domain Models</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/error-handling#developer-exception-page">Developer Exception Page Middleware</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/archive/msdn-magazine/2018/august/data-points-deep-dive-into-ef-core-hasdata-seeding">Deep Dive into EF Core HasData</a></p>
</li>
</ul>
<h3>More migration scenarios</h3>
<p>This section describes several different ASP.NET app scenarios, and offers specific techniques for<br />
solving each of them. You can use this section to identify scenarios applicable to your app, and<br />
evaluate which techniques will work for your app and its hosting environment.</p>
<h4><strong>Migrate ASP.NET MVC 5 and WebApi 2 to ASP.NET Core MVC</strong></h4>
<p>A common scenario in ASP.NET MVC 5 and Web API 2 apps was for both products to be installed in<br />
the same application. This is a supported and relatively common approach used by many teams, but<br />
because the two products use different abstractions, there is some redundant effort needed. For<br />
example, setting up routes for ASP.NET MVC is done using methods on RouteCollection, such as<br />
MapMvcAttributeRoutes() and MapRoute(). But ASP.NET Web API 2 routing is managed with<br />
HttpConfiguration and methods like MapHttpAttributeRoutes() and MapHttpRoute().</p>
<p>The eShopLegacyMVC app includes both ASP.NET MVC and Web API, and includes methods in its<br />
App_Start folder for setting up routes for both. It also supports dependency injection using Autofac,<br />
which also requires two sets of similar work to configure:</p>
<p>69 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>When upgrading these apps to use ASP.NET Core, this duplicate effort and the confusion that<br />
sometimes accompanies it is eliminated. ASP.NET Core MVC is a unified framework with one set of<br />
rules for routing, filters, and more. Dependency injection is built into .NET Core itself. All of this can be<br />
configured in <em>Program.cs</em>, as is shown in the eShopPorted app in the sample.</p>
<h4><strong>Migrate HttpResponseMessage to ASP.NET Core</strong></h4>
<p>Some ASP.NET Web API apps may have action methods that return HttpResponseMessage. This type<br />
does not exist in ASP.NET Core. Below is an example of its usage in a Delete action method, using the<br />
ResponseMessage helper method on the base ApiController:</p>
<p>In ASP.NET Core MVC, there are helper methods available for all of the common HTTP response status<br />
codes, so the above method would be ported to the following code:</p>
<p>70 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>If you do find that you need to return a custom status code for which no helper exists, you can always<br />
use return StatusCode(int statusCode) to return any numeric code you like.</p>
<h4><strong>Migrate content negotiation from ASP.NET Web API to ASP.NET Core</strong></h4>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/formats-and-model-binding/content-negotiation">ASP.NET Web API 2 supports content negotiation</a> natively. The sample app includes a<br />
BrandsController that demonstrates this support by listing its results in either XML or JSON. This is<br />
based on the request’s Accept header, and changes when it includes application/xml or<br />
application/json.</p>
<p>ASP.NET MVC 5 apps do not have content negotiation support built in.</p>
<p>Content negotiation is preferable to returning a specific encoding type, as it is more flexible and<br />
makes the API available to a larger number of clients. If you currently have action methods that return<br />
a specific format, you should consider modifying them to return a result type that supports content<br />
negotiation when you port the code to ASP.NET Core.</p>
<p>The following code returns data in JSON format regardless of client Accept header content:</p>
<p><a href="https://docs.microsoft.com/aspnet/core/web-api/advanced/formatting">ASP.NET Core MVC supports content negotiation natively, provided an appropriate return type is</a><br />
used. Content negotiation is implemented by [ObjectResult] which is returned by the status codespecific action results returned by the controller helper methods. The previous action method,<br />
implemented in ASP.NET Core MVC and using content negotiation, would be:</p>
<p><a href="https://docs.microsoft.com/aspnet/core/web-api/advanced/formatting">This will default to returning the data in JSON format. XML and other formats will be used if the app</a><br />
<a href="https://docs.microsoft.com/aspnet/core/web-api/advanced/formatting">has been configured with the appropriate formatter.</a></p>
<h4><strong>Custom model binding</strong></h4>
<p>Most ASP.NET MVC and Web API apps make use of model binding. The default model binding syntax<br />
migrates fairly seamlessly between these apps and ASP.NET Core MVC. However, in some cases<br />
<a href="https://docs.microsoft.com/aspnet/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api#model-binders">customers have written custom model binders to support specific model types or usage scenarios.</a><br />
Custom model binders in ASP.NET MVC and Web API projects use separate IModelBinder interfaces<br />
defined in System.Web.Mvc and System.Web.Http namespaces, respectively. In both cases, the custom</p>
<p>71 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>binder exposes a Bind method that accepts a controller or action context and a model binding context<br />
as arguments.</p>
<p>Once the custom binder is created, it must be registered with the app. This step requires creating<br />
another type, a ModelBinderProvider, which acts as a factory and creates the model binder during a<br />
request. Binders can be added during ApplicationStart in MVC apps as shown:</p>
<pre><code>ModelBinderProviders.BinderProviders.Insert(0, new MyCustomBinderProvider()); // MVC

</code></pre>
<p>In Web API apps, custom binders can be referenced using attributes. The ModelBinder attribute can<br />
be added to action method parameters or to the parameter’s type definition, as shown:</p>
<p>To register a model binder globally in ASP.NET Web API, its provider must be added during app<br />
startup:</p>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding#custom-model-binder-sample">When migrating custom model providers to ASP.NET Core, the Web API pattern is closer to the</a><br />
ASP.NET Core approach than the ASP.NET MVC 5. The main differences between ASP.NET Core’s<br />
IModelBinder interface and Web API’s is that the ASP.NET Core method is async (BindModelAsync)<br />
and it only requires a single BindingModelContext parameter instead of two parameters like Web<br />
API’s version required. In ASP.NET Core, you can use a [ModelBinder] attribute on individual action<br />
method parameters or their associated types. You can also create a ModelBinderProvider that will be<br />
used globally within the app where appropriate. To configure such a provider, you would add code to<br />
<em>Program.cs</em> :</p>
<p>72 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<h4><strong>Media formatters</strong></h4>
<p>ASP.NET Web API supports multiple media formats and can be extended by using custom media<br />
<a href="https://docs.microsoft.com/aspnet/web-api/overview/formats-and-model-binding/media-formatters#example-creating-a-csv-media-formatter">formatters. The docs describe an example CSV Media Formatter</a> that can be used to send data in a<br />
comma-separated value format. If your Web API app uses custom media formatters, you’ll need to<br />
<a href="https://docs.microsoft.com/aspnet/core/web-api/advanced/custom-formatters">convert them to ASP.NET Core custom formatters.</a></p>
<p>To create a custom formatter in Web API 2, you inherited from an appropriate base class and then<br />
added the formatter to the Web API pipeline using the HttpConfiguration object:</p>
<p>In ASP.NET Core, the process is similar. ASP.NET Core supports both input formatters (used by model<br />
binding) and output formatters (used to format responses). Adding a custom formatter to output<br />
responses in a specific way involves inheriting from an appropriate base class and adding the<br />
formatter to MVC in <em>Program.cs</em> :</p>
<p><a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.formatters">You’ll find a complete list of base classes in the Microsoft.AspNetCore.Mvc.Formatters</a> namespace.</p>
<p>The steps to migrate from a Web API formatter to an ASP.NET Core MVC formatter are:</p>
<ol>
<li>
<p>Identify an appropriate base class for the new formatter.</p>
</li>
<li>
<p>Create a new instance of the base class and implement its required methods.</p>
</li>
<li>
<p>Copy over the functionality from the Web API formatter to the new implementation.</p>
</li>
<li>
<p>Configure MVC in the ASP.NET Core App’s ConfigureServices method to use the new<br />
formatter.</p>
</li>
</ol>
<h4><strong>Custom filters</strong></h4>
<p>Filters are used in ASP.NET Core apps to execute code before and/or after certain stages in the<br />
request processing pipeline. ASP.NET MVC and Web API also use filters in much the same way, but the<br />
<a href="https://docs.microsoft.com/aspnet/mvc/overview/older-versions-1/controllers-and-routing/understanding-action-filters-cs#the-different-types-of-filters">details vary. For instance, ASP.NET MVC supports four kinds of filters. ASP.NET Web API 2 supports</a><br />
<a href="https://docs.microsoft.com/dotnet/api/system.web.mvc.filters.ioverridefilter">similar filters, and both MVC and Web API included attributes to override filters.</a></p>
<p>The most common filter used in ASP.NET MVC and Web API apps is the action filter, which is defined<br />
<a href="https://docs.microsoft.com/dotnet/api/system.web.mvc.iactionfilter">by an IActionFilter interface. This interface provides methods for before (OnActionExecuting) and after</a><br />
(OnActionExecuted) which can be used to execute code before and/or after an action executes, as<br />
noted for each method.</p>
<p>ASP.NET Core continues to support filters, and its unification of MVC and Web API means there is only<br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/filters#filter-types">one approach to their implementation. The docs include detailed coverage of the five (5) kinds of</a><br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/filters#filter-types">filters built into ASP.NET Core MVC. All of the filter variants supported in ASP.NET MVC and ASP.NET</a></p>
<p>73 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>Web API have associated versions in ASP.NET Core, so migration is generally just a matter of<br />
identifying the appropriate interface and/or base class and migrating the code over.</p>
<p>In addition to the synchronous interfaces, ASP.NET Core also provides async interfaces like<br />
IAsyncActionFilter which provide a single async method that can be used to incorporate code to run<br />
both before and after the action, as shown:</p>
<p>When migrating async code (or code that should be async), teams should consider leveraging the<br />
built in async types that are provided for this purpose.</p>
<p>Most ASP.NET MVC and Web API apps do not use a large number of custom filters. Since the<br />
approach to filters in ASP.NET Core MVC is closely aligned with filters in ASP.NET MVC and Web API,<br />
the migration of custom filters is generally fairly straightforward. Be sure to read the detailed<br />
documentation on filters in ASP.NET Core’s docs, and once you’re sure you have a good<br />
understanding of them, port the logic from the old system to the new system’s filters.</p>
<h4><strong>Route constraints</strong></h4>
<p>ASP.NET Core uses route constraints to help ensure requests are routed properly to route a request.<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference">ASP.NET Core supports a large number of different route constraints for this purpose. Route</a><br />
constraints can be applied in the route table, but most apps built with ASP.NET MVC 5 and/or<br />
<a href="https://docs.microsoft.com/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2#route-constraints">ASP.NET Web API 2</a> use inline route constraints applied to attribute routes. Inline route constraints use<br />
a format like this one:</p>
<pre><code>[Route(&quot;/customer/{id:int}&quot;)]

</code></pre>
<p>The :int after the id route parameter constrains the value to match the int type. One benefit of using<br />
route constraints is that they allow for two otherwise-identical routes to exist where the parameters<br />
<a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/member-overloading">differ only by their type. This allows for the equivalent of method overloading</a> of routes based solely<br />
on parameter type.</p>
<p>The set of route constraints, their syntax, and usage is very similar between all three approaches.<br />
Custom route constraints are fairly rare in customer applications. If your app uses a custom route<br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/routing#custom-route-constraints">constraint and needs to port to ASP.NET Core, the docs include examples showing how to create</a><br />
<a href="https://docs.microsoft.com/aspnet/core/fundamentals/routing#custom-route-constraints">custom route constraints in ASP.NET Core. Essentially all that’s required is to implement</a><br />
IRouteConstraint and its Match method, and then add the custom constraint when configuring<br />
routing for the app:</p>
<p>74 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>This is very similar to how custom constraints are used in ASP.NET Web API, which uses<br />
IHttpRouteConstraint and configures it using a resolver and a call to<br />
HttpConfiguration.MapHttpAttributeRoutes:</p>
<p>ASP.NET MVC 5 follows a very similar approach, using IRouteConstraint for its interface name and<br />
configuring the constraint as part of route configuration:</p>
<p>Migrating route constraint usage as well as custom route constraints to ASP.NET Core is typically very<br />
straightforward.</p>
<h4><strong>Custom route handlers</strong></h4>
<p>Another fairly advanced feature of ASP.NET MVC 5 is route handlers. Custom route handlers<br />
implement IRouteHandler, which includes a single method that returns an IHttpHandler for a give<br />
request. The IHttpHandler, in turn, exposes an IsReusable property and a single ProcessRequest<br />
method. In ASP.NET MVC 5, you can configure a particular route in the route table to use your custom<br />
handler:</p>
<p>75 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>To migrate custom route handlers from ASP.NET MVC 5 to ASP.NET Core, you can either use a filter<br />
<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.routing.irouter">(such as an action filter) or a custom IRouter. The filter approach is relatively straightforward, and can</a><br />
be added as a global filter when MVC is added to the app’s services during startup:</p>
<p>The IRouter option requires implementing the interface’s RouteAsync and GetVirtualPath methods.<br />
The custom router is added to the request pipeline during app startup.</p>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/advanced/http-message-handlers#custom-message-handlers">In ASP.NET Web API, these handlers are referred to as custom message handlers, rather than</a> <em>route</em><br />
<em>handlers</em> . Message handlers must derive from DelegatingHandler and override its SendAsync method.<br />
Message handlers can be chained together to form a pipeline in a fashion that is very similar to<br />
ASP.NET Core middleware and its request pipeline.</p>
<p>ASP.NET Core has no DelegatingHandler type or separate message handler pipeline. Instead, such<br />
handlers should be migrated using global filters, custom IRouter instances (see above), or custom<br />
middleware. ASP.NET Core MVC filters and IRouter types have the advantage of having built-in access<br />
to MVC constructs like controllers and actions, while middleware is a lower level approach that has no<br />
ties to MVC. This makes it more flexible but also requires more effort if you need to access MVC<br />
components.</p>
<h4><strong>CORS support</strong></h4>
<p>CORS, or Cross-Origin Resource Sharing, is a W3C standard that allows servers to accept requests that<br />
don’t originate from responses they’ve served. ASP.NET MVC 5 and ASP.NET Web API 2 support CORS<br />
in different ways. The simplest way to enable CORS support in ASP.NET MVC 5 is with an action filter<br />
like this one:</p>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/security/enabling-cross-origin-requests-in-web-api#enable-cors">ASP.NET Web API can also use such a filter, but it has built-in support for enabling CORS</a> as well:</p>
<p>76 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>Once this is added, you can configure allowed origins, headers, and methods using the EnableCors<br />
attribute, like so:</p>
<p>Before migrating your CORS implementation from ASP.NET MVC 5 or ASP.NET Web API 2, be sure to<br />
<a href="https://docs.microsoft.com/aspnet/web-api/overview/security/enabling-cross-origin-requests-in-web-api#how-cors-works">review how CORS works</a> and create some automated tests that demonstrate CORS is working as<br />
expected in your current system.</p>
<p>In ASP.NET Core, there are three built-in ways to enable CORS:</p>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/cors?#cors-with-named-policy-and-middleware">Configured via policy in ConfigureServices</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/cors?#enable-cors-with-endpoint-routing">Enabled with endpoint routing</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/cors#enable-cors-with-attributes">Enabled with the EnableCors attribute</a></p>
</li>
</ul>
<p>Each of these approaches is covered in detail in the docs, which are linked from the above options.<br />
Which one you choose will largely depend on how your existing app supports CORS. If the app uses<br />
attributes, you can probably migrate to use the EnableCors attribute most easily. If your app uses<br />
filters, you could continue using that approach (though it’s not the typical approach used in ASP.NET<br />
Core), or migrate to use attributes or policies. Endpoint routing is a relatively new feature introduced<br />
with ASP.NET Core 3 and as such it doesn’t have a close analog in ASP.NET MVC 5 or ASP.NET Web<br />
API 2 apps.</p>
<h4><strong>Custom areas</strong></h4>
<p>Many ASP.NET MVC apps use Areas to organize the project. Areas typically reside in the root of the<br />
project in an <em>Areas</em> folder, and must be registered when the application starts, typically in<br />
Application_Start():</p>
<pre><code>AreaRegistration.RegisterAllAreas();

</code></pre>
<p>An alternative to registering all areas in startup is to use the RouteArea attribute on individual<br />
controllers:</p>
<p>ASP.NET Web API apps don’t typically use areas explicitly, since their controllers can be placed in any<br />
folder in the project. Teams can use any folder structure they like to organize their API controllers.</p>
<p>77 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/areas">Areas</a> are supported in ASP.NET Core MVC. The approach used is nearly identical to the use of areas<br />
in ASP.NET MVC 5. Developers migrating code using areas should keep in mind the following<br />
differences:</p>
<ul>
<li>
<p>AreaRegistration.RegisterAllAreas is not used in ASP.NET Core MVC</p>
</li>
<li>
<p>Areas are applied using the [Area(&quot;name&quot;)] attribute (not RouteArea as in ASP.NET MVC 5)</p>
</li>
<li>
<p>Areas can be added to the route table templates, if desired (or they can use attribute routing)</p>
</li>
</ul>
<p>To add area support to the route table in ASP.NET Core MVC, you would add the following during app<br />
startup:</p>
<p>Areas can also be used with attribute routing, using the {area} keyword in the route definition (it’s one<br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/routing#reserved-routing-names">of several reserved routing names that can be used with route templates).</a></p>
<p>Tag helpers support areas with the asp-area attribute, which can be used to generate links in Razor<br />
views and pages:</p>
<p>If you’re migrating to Razor Pages you will need to use an <em>Areas</em> folder in your <em>Pages</em> folder. For more<br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/areas#areas-with-razor-pages">information, see Areas with Razor Pages.</a></p>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/routing#areas">In addition to the above guidance, teams should review how routing in ASP.NET Core works with</a><br />
<a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/routing#areas">areas</a> as part of their migration planning process.</p>
<h4><strong>Integration tests for ASP.NET MVC and ASP.NET Web API</strong></h4>
<p>Integration tests are automated tests that verify several different parts of an app work together<br />
correctly. Writing integration tests for ASP.NET MVC and ASP.NET Web API usually involved deploying</p>
<p>78 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>the app to a real web server, such as a local instance of IIS or IIS Express, and then making requests to<br />
this hosted application using an HTTP client. Some of these tests may interact with the client-side user<br />
<a href="https://www.selenium.dev/">interface using browser automation tools like Selenium, though often these are referred to as</a> <em>UI tests</em><br />
rather than integration tests.</p>
<p>If your migrated app shares the same behavior as its original version, whatever existing technology<br />
the team is using to perform integration tests (and UI tests) should continue to work just as it did<br />
before. These tests are usually indifferent to the underlying technology used to host the app they’re<br />
testing, and interact with it only through HTTP requests. Where things may get more challenging is<br />
with how the tests interact with the app to get it into a known good state prior to each test. This may<br />
require some migration effort, since configuration and startup are significantly different in ASP.NET<br />
Core compared to ASP.NET MVC or ASP.NET Web API.</p>
<p><a href="https://docs.microsoft.com/aspnet/core/test/integration-tests">Teams should strongly consider migrating their integration tests to use ASP.NET Core’s built-in</a><br />
<a href="https://docs.microsoft.com/aspnet/core/test/integration-tests">integration testing</a> support. In ASP.NET Core, apps can be tested by deploying them to a TestHost,<br />
which is configured using a WebApplicationFactory. There’s a little bit of setup required to host the<br />
app for testing, but once this is in place, creating individual integration tests is very straightforward.</p>
<p>One of the best features of ASP.NET Core’s integration testing support is that the app is hosted in<br />
memory. There’s no need to configure a real webserver to host the app. There’s no need to use a<br />
browser automation tool (if you’re only testing ASP.NET Core and not client-side behavior). Many of<br />
the problems that can be encountered when trying to use a real web server for automated integration<br />
tests, such as firewall issues or process start/stop issues, are eliminated with this approach. Since the<br />
requests are all made in memory with no network requirement, the tests also tend to run much faster<br />
than tests that must set up a separate webserver and communicate with it over the network (even if<br />
it’s running on the same machine).</p>
<p>Below you can see an example ASP.NET Core integration test (sometimes referred to as <em>functional</em><br />
<em>tests</em> <a href="https://github.com/dotnet-architecture/eShopOnWeb">to distinguish them from lower-level integration tests) from the eShopOnWeb reference</a><br />
<a href="https://github.com/dotnet-architecture/eShopOnWeb">application:</a></p>
<p>79 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p>If the app being migrated has no integration tests, the migration process can be a great opportunity<br />
to add some. These tests can verify that the migrated app behaves as the team expects. When such<br />
tests are in place early in a migration, they can ensure that later migration efforts do not break<br />
previously migrated portions of the app. Given how easy it is to set up and run integration tests in<br />
ASP.NET Core, the return on the investment spent setting up such tests is usually pretty high.</p>
<h4><strong>WCF client configuration</strong></h4>
<p>If your app currently relies on WCF services as a client, this scenario is supported. However, you will<br />
<a href="https://docs.microsoft.com/aspnet/core/migration/configuration">need to migrate your configuration from</a> <em>web.config</em> to use the new <em>appsettings.json</em> file. Another<br />
option is to add any necessary configuration to your clients programmatically when you create them.<br />
For example:</p>
<p>If your organization has extensive services built using WCF that your app relies on, consider migrating<br />
them to use gRPC instead. For more details on gRPC, why you may wish to migrate, and a detailed<br />
<a href="https://docs.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/">migration guide, consult the gRPC for WCF Developers</a> eBook.</p>
<h4><strong>References</strong></h4>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/formats-and-model-binding/content-negotiation">ASP.NET Web API Content Negotiation</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/web-api/advanced/formatting">Format response data in ASP.NET Core Web API</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api#model-binders">Custom Model Binders in ASP.NET Web API</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding#custom-model-binder-sample">Custom Model Binders in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/formats-and-model-binding/media-formatters">Media Formatters in ASP.NET Web API 2</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/web-api/advanced/custom-formatters">Custom formatters in ASP.NET Core Web API</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/filters">Filters in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2#route-constraints">Route constraints in ASP.NET Web API 2</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/aspnet/attribute-routing-in-asp-net-mvc-5/#route-constraints">Route constraints in ASP.NET MVC 5</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference">ASP.NET Core Route Constraint Reference</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/advanced/http-message-handlers#custom-message-handlers">Custom message handlers in ASP.NET Web API 2</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/6290053/setting-access-control-allow-origin-in-asp-net-mvc-simplest-possible-method">Simple CORS control in MVC 5 and Web API 2</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/web-api/overview/security/enabling-cross-origin-requests-in-web-api#enable-cors">Enabling Cross-Origin Requests in Web API</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/cors">Enable Cross-Origin Requests (CORS) in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/mvc/controllers/areas">Areas in ASP.NET Core</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/test/integration-tests">Integration tests in ASP.NET Core</a></p>
</li>
</ul>
<p>80 CHAPTER 4 | Example migration of eShop to ASP.NET Core</p>
<p><strong>CHAPTER</strong></p>
<h1>5</h1>
<h2>Deployment scenarios when migrating to ASP.NET Core</h2>
<p>Existing ASP.NET MVC and Web API apps run on IIS and Windows. Large apps may require a phased<br />
or side-by-side approach when porting to ASP.NET Core. In previous chapters, you learned a number<br />
of strategies for migrating large .NET Framework apps to ASP.NET Core in phases. In this chapter, you<br />
will see how different deployment scenarios can be achieved when there is a need to maintain the<br />
original app in production while migrating portions of it.</p>
<h3>Split a large web app</h3>
<p>Consider the common scenario of a large web app that currently is hosted on IIS in a single web site.<br />
Within the large app, functionality is segmented into different routes and/or directories. The app is a<br />
mix of MVC views and API endpoints. The MVC routes include many different paths based on<br />
functionality and all start from the root of the app using the standard /{controller}/{action}/{id?} route<br />
template. The API endpoints follow a similar pattern, but are all under an /api root.</p>
<p>Assuming the task of porting the app is split such that either the MVC functionality or the API<br />
functionality is migrated to ASP.NET Core first, how would the original site continue to function<br />
seamlessly with the new ASP.NET Core app running somewhere else? Users of the system should<br />
continue to see the same URLs they did prior to the migration, unless it’s absolutely necessary to<br />
change them.</p>
<p><a href="https://docs.microsoft.com/iis/extensions/url-rewrite-module/url-rewrite-module-video-walkthrough">Fortunately, IIS is a feature-rich web server, and two features it has are URL Rewrite module and</a><br />
<a href="https://docs.microsoft.com/iis/extensions/planning-for-arr/application-request-routing-version-2-overview">Application Request Routing. Using these features, IIS can act as a reverse proxy, routing client</a><br />
requests to the appropriate back-end web app. To configure IIS as a reverse proxy, check the <strong>Enable</strong><br />
<strong>proxy</strong> checkbox in the Application Request Routing feature, then add a URL Rewrite rule like this one:</p>
<p>As a reverse proxy, IIS can route traffic matching certain patterns to entirely separate apps, potentially<br />
on different servers.</p>
<p>81 CHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core</p>
<p>Using just the URL Rewrite module (perhaps combined with host headers), IIS can easily support<br />
multiple web sites, each potentially running different versions of .NET. A large web app might be<br />
deployed as a collection of individual sites, each responding to different IP addresses and/or host<br />
headers, or as a single web site with one or more sub-applications in it responding to certain URL<br />
paths (which doesn’t even require URL Rewrite).</p>
<p>There are pros and cons to using the same or different subdomains (and domains) to host a single<br />
<a href="https://docs.microsoft.com/aspnet/core/security/cors">app. Features like cookies and intra-app communication using mechanisms like CORS may require</a><br />
more configuration to work properly in distributed apps. However, apps that use different<br />
subdomains can more easily use DNS to route requests to entirely different network destinations, and<br />
so can more easily be deployed to many different servers (virtual or otherwise) without the need for<br />
IIS to act as a reverse proxy.</p>
<p>In the example described above, assume the API endpoints are designated as the first part of the app<br />
to be ported to ASP.NET Core. In this case, a new ASP.NET Core app is created and hosted in IIS as a<br />
separate web <em>application</em> within the existing ASP.NET MVC web <em>site</em> . Since it will be added as a child of<br />
the original web site and will be named <em>api</em>, its default route should no longer begin with api/.<br />
Keeping this would result in it matching URLs of the form /api/api/endpoint.</p>
<p>Figure 5-1 shows how the ASP.NET Core 2.1 <em>api</em> app appears in IIS Manager as a part of the existing<br />
<em>DotNetMvcApp</em> site.</p>
<p>82 CHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core</p>
<p><em>Figure 5-1. .NET Framework Site with .NET Core app in IIS.</em></p>
<p>The <em>DotNetMvcApp</em> site is hosted as an MVC 5 app running on .NET Framework 4.7.2. It has its own IIS<br />
app pool configured in integrated mode and running .NET CLR version 4.0.30319. The <em>api</em> app is an<br />
ASP.NET Core app running on .NET Framework 4.6.1 (net461). It was added to the <em>DotNetMvcApp</em> as a<br />
new IIS app and configured to use its own Application Pool. Its Application Pool is also running in<br />
integrated mode but is configured with a .NET CLR version of <strong>No Managed Code</strong> since it will be<br />
<a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/aspnet-core-module">executed using the ASP.NET Core Module. The version of the ASP.NET Core app is just an example. It</a><br />
could also be configured to run on NET 5+. Though at that point, it would no longer be able to target<br />
.NET Framework libraries (see Choose the Right .NET Core Version)</p>
<p>Configured in this manner, the only change that must be made in order for the ASP.NET Core app’s<br />
APIs to be routed properly is to change its default route template from [Route(&quot;[api/controller]&quot;)] to</p>
<p>[Route(&quot;[controller]&quot;)].</p>
<p>Alternately the ASP.NET Core app can be another top-level web site in IIS. In this case, you can<br />
<a href="https://www.iis.net/downloads/microsoft/url-rewrite">configure the original site to use a rewrite rule (with URL Rewrite) that will redirect to the other app if</a><br />
the path starts with /api. The ASP.NET Core app can use a different host header for its route so that it<br />
doesn’t conflict with the main app but can still respond to requests using root-based routes.</p>
<p>As an example, the same ASP.NET Core app used in Figure 5-1 can be deployed to another folder<br />
configured as an IIS web site. The site should use an app pool configured just as before, with <strong>No</strong></p>
<p>83 CHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core</p>
<p><strong>Managed Code</strong> . Configure its bindings to respond to a unique host name on the server, such as<br />
api.contoso.com. To configure URL Rewrite to rewrite requests matching /api just add a new inbound<br />
rule at the IIS server (or individual site) level. Match the pattern ^/api(.<em>) and specify an Action type of<br />
Rewrite and a Rewrite URL of api.contoso.com/{R:1}. The combination of using (.</em>) in the matching<br />
pattern and {R:1} in the rewrite URL will ensure the rest of the path gets used with the new URL. With<br />
this in place, separate sites on the same IIS server can coexist running separate versions of .NET, but<br />
they can be made to appear to the Internet as one web app. Figure 5-2 shows the rewrite rule as<br />
configured in IIS with the separate web site.</p>
<p><em>Figure 5-2. Rewrite rule to rewrite subfolder requests to another web site.</em></p>
<p>If your app requires single sign-on between different sites or apps within IIS, refer to the<br />
<a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/iis/">documentation on how to share authentication cookies among ASP.NET apps</a> for detailed instructions<br />
on supporting this scenario.</p>
<p><a href="https://microsoft.github.io/reverse-proxy/">Another alternative to IIS Rewrite rules is the use of a reverse proxy like YARP, which can facilitate</a><br />
<a href="https://devblogs.microsoft.com/dotnet/incremental-asp-net-to-asp-net-core-migration/">incremental ASP.NET to ASP.NET Core Migration.</a></p>
<h3>Summary</h3>
<p>A common approach to porting large apps from .NET Framework to ASP.NET Core is to choose<br />
individual portions of the app to migrate one by one. As each piece of the app is ported, the entire<br />
app remains running and usable, with some parts of it running in its original configuration and other<br />
parts running on some version of .NET Core. By following this approach, a large app migration can be<br />
performed incrementally. This approach results in limiting risk by providing more rapid feedback and</p>
<p>84 CHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core</p>
<p>reducing total surface area involved in testing. It also allows for more rapid realization of benefits of<br />
.NET Core, such as performance increases. Although ASP.NET Core apps are no longer required to be<br />
hosted on IIS, IIS remains a very flexible and powerful web server that can be configured to support a<br />
variety of hosting scenarios involving both .NET Framework and ASP.NET Core apps on the same IIS<br />
instance or even hosted on different servers.</p>
<h3>References</h3>
<ul>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/iis/">Host ASP.NET Core on Windows with IIS</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing">URL Rewrite module and Application Request Routing</a></p>
</li>
<li>
<p><a href="https://www.iis.net/downloads/microsoft/url-rewrite">URL Rewrite</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/aspnet-core-module">ASP.NET Core Module</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/aspnet/core/security/cookie-sharing">Share authentication cookies among ASP.NET apps</a></p>
</li>
<li>
<p><a href="https://github.com/ardalis/MigrateDotNetWithIIS">Samples used in this section</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/dotnet/incremental-asp-net-to-asp-net-core-migration/">Incremental ASP.NET to ASP.NET Core Migration</a></p>
</li>
</ul>
<p>85 CHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core</p>
<p><strong>CHAPTER</strong></p>
<p><strong>CHAPTER</strong></p>
<h2>Summary: Port existing ASP.NET Apps to .NET 7</h2>
<p>In this book, you’ve been given the resources needed to decide whether it makes sense to port your<br />
organization’s existing ASP.NET apps running on .NET Framework to ASP.NET Core. You’ve learned<br />
about important considerations for choosing when it makes sense to migrate to .NET Core, and when<br />
it may be appropriate to keep (parts of) your app on .NET Framework. There are differences between<br />
.NET Core versions and their capabilities and compatibilities with .NET Framework, and you learned<br />
how to choose the right version of .NET Core for your app.</p>
<p>Porting a large app often entails a fair amount of risk and effort. You learned how to mitigate this risk<br />
by employing one or more incremental migration strategies along with several deployment strategies<br />
for keeping partially migrated apps running in production.</p>
<p>There are many architectural differences between ASP.NET and ASP.NET Core. In chapter 2, you<br />
learned about many of these differences and how they relate to your app’s migration. This chapter<br />
covered everything from app startup and low-level middleware to high-level controller and Web API<br />
differences and new features enabling much better testing scenarios.</p>
<p>Large apps are often comprised of many projects and packages, and dependencies can play a major<br />
role in determining how easy or difficult migration may be. Chapter 3 helped you identify the<br />
sequence in which to migrate projects and how to understand and update your app’s dependencies. It<br />
also detailed additional strategies for migrating apps while keeping them running in production.</p>
<p>In chapter 4, you saw how a real ASP.NET MVC reference app was migrated to ASP.NET Core. This<br />
chapter included a detailed breakdown of all the changes that were needed to take the existing app<br />
and port it over to run on ASP.NET Core. Refer back to it if you have specific questions about the<br />
porting process and some of its more specific details.</p>
<p>Finally, chapter 5 detailed specific deployment scenarios focused on IIS. You saw how you can use<br />
your existing IIS web server to host parts of your app that have been ported to ASP.NET Core while<br />
keeping the app’s public URLs consistent. IIS includes great support for URL rewriting and request<br />
routing that enables it to host multiple versions of your site side by side or even on different servers,<br />
with no change to the public-facing URLs the app exposes.</p>
<p>86 CHAPTER 6 | Summary: Port existing ASP.NET Apps to .NET 7</p>
