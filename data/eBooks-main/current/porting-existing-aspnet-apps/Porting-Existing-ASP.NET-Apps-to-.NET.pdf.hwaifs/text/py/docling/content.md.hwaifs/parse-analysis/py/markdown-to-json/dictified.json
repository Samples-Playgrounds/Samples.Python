{"Videos": {"Update project files and NuGet reference syntax": "Next, migrate from the older .csproj file structure to the newer, simpler structure introduced with .NET Core. In doing so, you'll also migrate from using a packages.config file for NuGet references to using &lt;PackageReference&gt; elements in the project file. Old-style project files may also use &lt;PackageReference&gt; elements, so it usually makes sense to migrate all NuGet package references to this format first, before upgrading to the new project file format.\n\nThe original project's eShopLegacyMVC.csproj file is 418 lines long. A sample of the project file is shown in Figure 4-6. To offer a sense of its overall size and complexity, the right side of the image contains a miniature view of the entire file.\n\n\u2022 eShopLegacyMVC.csproj X\n\nsrc &gt; eShopLegacyMVC &gt; i eShopLegacyMVC.csproj k/?xm] version=\"1.0\" encoding=\"utf-8\"?l)\n\n\u2039Project ToolsVersion=\"15.0\" DefaultTargets=\"Build\" xmIns=\"http://schemas.microsoft.com/developer/msbuild/200=\n\n\u2039Import Project=\"..\\.. \\packages\\Microsoft.CodeDom.Providers.DotNetCompilerPlatform.2.0.1\\build\\net46\\Microsc\n\n\u2039Import Project=\"\n\n..\\..\\packages\\Microsoft.Net.Compilers.2.10.0\\build\\Microsoft.Net.Compilers.props\" Conditic\n\n\u2039Import Project=\"$(MSBuildExtensionsPath32) \\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Micros\n\n&lt;PropertyGroup&gt;...\n\n&lt;/PropertyGroup&gt;\n\n&lt;/PropertyGroup&gt;\n\n&lt;/PropertyGroup&gt;\n\n&lt;ItemGroup&gt;...\n\n&lt;/ ItemGroup&gt;\n\n&lt; ItemGroup&gt;\n\n\u2039Compile Include=\"Global.asax.cs\"\u203a\n\n&lt;/Compile&gt;\n\nFigure 4-6. The eShopLegacyMVC.csproj file structure.\n\n<!-- image -->\n\nA common way to create a new project file for an existing ASP.NET project is to create a new ASP.NET Core app using dotnet new or File &gt; New &gt; Project in Visual Studio. Then files can be copied from the old project to the new one to complete the migration.\n\nIn addition to the C# project file, NuGet dependencies are stored in a separate 45-line packages.config file, as shown in Figure 4-7.\n\n2\n\n5\n\n6\n\n7\n\n32\n\n33\n\n42\n\n43\n\n51\n\n52\n\n197\n\n198\n\n199\n\n200\n\n201\n\n202\n\n203\n\n204\n\n205\n\n206\n\n207\n\n208\n\n209\n\n210\n\n211\n\n212\n\n213\n\n&gt;\n\n&gt;\n\n\u2022 packages.config X\n\nsrc &gt; eShopLegacyMVC &gt; \u2022 packages.config\n\n1\n\n#?xml version=\"1.0\" encoding=\"utf-8\"?[\n\n\u2039packages&gt;\n\n&lt; package\n\n&lt; package\n\n\u2039package\n\n&lt; package\n\n\u2039package\n\n\u2039package\n\n\u2039 package\n\n\u2039package\n\n&lt; package\n\n&lt; package\n\n&lt; package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n&lt; package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n\u2039package\n\n&lt; package\n\n&lt; package\n\n&lt; package\n\n\u2039 package\n\n\u2039package\n\n&lt; package\n\n\u2039package\n\n\u2039 package\n\n\u2039package\n\n\u2039 package id=\"Ant]r\" version=\"3.5.0.2\" targetFramework=\"net472\" /&gt;\n\nid=\"Autofac\" version=\"4.9.1\" targetFramework=\"net472\" / &gt;\n\nid= \"Autofac. Mvc5\" version=\"4.0.2\" targetFramework=\"net472\" /&gt;\n\nid= \"bootstrap\" version=\"4.3.1\" targetFramework=\"net472\" /&gt;\n\nFigure 4-7. The packages.config file.\n\n<!-- image -->\n\nYou can migrate packages.config in class library projects using Visual Studio. This functionality doesn't work with ASP.NET projects, however. Learn more about migrating packages.config to &lt;PackageReference&gt; in Visual Studio. If you have a large number of projects to migrate, this community tool may help . If you're using a tool to migrate the project file to the new format, you should do that after you've finished migrating all NuGet references to use &lt;PackageReference&gt;.", "Create new ASP.NET Core project": "Add a new ASP.NET Core project to the existing app's solution to make moving files easier, as most of the work can be done from within Visual Studio's Solution Explorer . In Visual Studio, right-click on your app's solution and choose Add New Project . Choose ASP.NET Core web application , and give the new project a name as shown in Figure 4-8.\n\n8\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\nConfigure your new project\n\nASP.NET Core Web Applicationc*\n\nProject name eShopPorted\n\nLocation\n\nC:\\dev\\GitHub\\eShopModernizing\\eShopLegacyMVCSolution\n\nLinux macos\n\nWindows\n\nCloud\n\nService\n\nWeb\n\nFigure 4-8. Add new ASP.NET Core web application.\n\n<!-- image -->\n\nThe next dialog will ask you to choose which template to use. Select the Empty template. Be sure to also change the dropdown from .NET Core to .NET Framework . Select ASP.NET Core 2.2 , as shown in Figure 4-9.\n\nX\n\nCreate a new ASPINET Core web application\n\nNET Framework\n\nEmpty it.\n\nAPI\n\nWeb Application\n\nWeb Application (Model-View-Controller)\n\nAngular\n\nA\n\nReact js\n\nGet additional project templates\n\nFigure 4-9. Choose an Empty project template targeting .NET Framework with ASP.NET Core 2.2.\n\n<!-- image -->", "Migrating NuGet Packages": "Since the built-in migration tool for migrating packages.config to &lt;PackageReference&gt; doesn't work on ASP.NET projects, you can use a community tool instead, or migrate by hand. A community tool I've used uses an XSL file to transform from one format to the other. To use it, first copy the packages.config file to the newly created ASP.NET Core project folder. Make a backup of your files, as this script removes the packages.config file from all folders under where you run the script. Then run these commands from the project folder (or for the entire solution if you prefer):", "iwr": "https://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7c9218bf9c/raw/7789 53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.xsl -OutFile  ConvertToPackageReference.xsl\n\n./Convert-ToPackageReference.ps1 | Out-Null\n\nThe first two commands download files so that they exist locally. The last line runs the script. After running it, try to build the new project. You'll most likely get some errors. To resolve them, you'll want to eliminate some references (like most of the Microsoft.AspNet and System packages), and you may need to remove some xmlns attributes.\n\nX\n\neShopPorted &gt; \u2022 eShopPorted.csproj\n\n1\n\n\u2039Project Sdk=\"Microsoft.NET.Sdk. Web\"&gt;\n\n2\n\n3\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n&lt;PropertyGroup&gt;\n\n\u2039TargetFramework\u203anet461&lt;/TargetFramework\u203a\n\n&lt;/PropertyGroup&gt;\n\n&lt; ItemGroup \u203a\n\nIn most ASP.NET MVC apps, many client-side dependencies like Bootstrap and jQuery were deployed using NuGet packages. In ASP.NET Core, NuGet packages are only used for server-side functionality. Client files should be managed through other means. Review the list of &lt;PackageReference&gt; elements added and remove and make note of any that are for client libraries, including:\n\n&lt;/PackageReference&gt;\n\n['Bootstrap', 'jQuery', 'jQuery.Validation', 'Modernizr', 'popper.js', 'Respond']\n\nThe static client files installed by NuGet for these packages will be copied over to the new project's wwwroot folder and hosted from there. It's worth considering whether these files are still needed by the app, and whether it makes sense to continue hosting them or to use a content delivery network (CDN) instead. These library versions can be managed at build time using tools like LibMan or npm. Figure 4-10 shows the full eShopPorted.csproj file after migrating package references using the conversion tool shown and removing unnecessary packages.\n\nFigure 4-10. Package references in the eShopPorted.csproj file.\n\n<!-- image -->\n\nThe package references can be further compacted by making the &lt;Version&gt;1.0.0.0&lt;/Version&gt; element a Version=1.0.0.0 attribute on &lt;PackageReference&gt;.", "Migrate static files": "Any static files the app uses, including third-party scripts and frameworks but also custom images and stylesheets, must be copied from the old project to the new one. In ASP.NET MVC apps, files were typically accessed based on their location within the project folder. In ASP.NET Core apps, these static files will be accessed based on their location within the wwwroot folder. For the eShop project, there are static files in the following folders:\n\n['Content', 'fonts', 'Images', 'Pics', 'Scripts']\n\nThe Empty project template used in the previous step doesn't include this folder by default, or the middleware needed for it to work. You'll need to add them.\n\nAdd a wwwroot folder to the root of the project.\n\nAdd version 2.2.0 of the Microsoft.AspNetCore.StaticFiles NuGet package.\n\nIn Startup.cs , add a call to app.UseStaticFiles() in the Configure method:\n\n```\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseStaticFiles(); // ... }\n```\n\nCopy the Content folder from the ASP.NET MVC app to the new project's wwwroot folder.\n\nRun the app and navigate to its /Content/base.css folder to verify that the static file is served correctly from its expected path. Continue copying the rest of the folders containing static files to the new project. You'll also want to copy the favicon.ico file from the project's root to the wwwroot folder. Figure 4-11 shows the results after these files and their folders have all been copied.\n\n\u2022 B\n\neShopPorted\n\n&gt; Connected Services\n\nDependencies\n\n\u2022 8.\n\n1 8t\n\nProperties www.root\n\n8\n\n8\n\n\u2022 8\u041f\n\nControllers\n\n\u2022 82] Migrations\n\n\u2022 &amp;\n\nModels\n\n8 Modules\n\n8C Services\n\n\u2022 8\n\nViewModel\n\n\u2022 8C\n\nViews\n\n82] app.config\n\n\u2022 B\n\nappsettings json\n\n\u2022 8C# Program.cs\n\nD BC# Startup.cs\n\nFigure 4-11. Static folders copied over to wwwroot folder.\n\n<!-- image -->", "Migrate C# files": "Next, copy over the C# files used by the app, including standard MVC folders and their contents like Controllers , Models , ViewModel , and Services . There will most likely be some changes needed in these files. It's best to copy one folder (or subfolder) at a time and compile to see what errors need to be addressed as you go.\n\nFor the eShop sample, the first folder I choose to migrate is the Models folder, which includes C# entities and Entity Framework classes. This folder's classes are used by most of the others, so they won't work until these classes have been copied. After copying the folder and building, the compiler revealed errors related to missing namespace System.Web.Hosting, related access to HostingEnvironment, and a reference to ConfigurationManager.AppSettings. The solution to these issues will be to pass in the necessary path data; for now the breaking lines are commented out and a TODO: comment is added to each one to track it. After changing five lines, the Task List shows five items and the project builds.\n\nNext, the ViewModel folder, with its one class, is copied over. It's an easy one, and builds immediately.\n\nThe Services folder is copied over. This folder's classes depend on Entity Framework classes from the Models folder, which is why it needed to be copied after that folder. Fortunately, it too builds without errors.\n\nfonts\n\nPics\n\nThat leaves the Controllers folder and its two Controller classes. After copying the folder to the new project and building, there are seven build errors. Four of them are related to ViewBag access and report an error of:\n\nMissing compiler required member 'Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo.Create'\n\nTo resolve this error, add a NuGet package reference to C#:\n\n```\n< PackageReference Include=\"Microsoft.CSharp\" Version=\"4.7.0\" />\n```\n\nThe remaining three errors specify types that are defined in an assembly that isn't referenced. Specifically these types:\n\n['HttpServerUtilityBase', 'RouteValueDictionary', 'HttpRequestBase']\n\nLet's look at each error one by one. The first error occurs while trying to reference the Server property of Controller, which no longer exists. The goal of the operation is to get the path to an image file in the app:\n\n```\nif (item != null ) { var webRoot = Server.MapPath(\"~/Pics\"); // compiler error on this line var path = Path.Combine(webRoot, item.PictureFileName); string imageFileExtension = Path.GetExtension(item.PictureFileName); string mimetype = GetImageMimeTypeFromImageFileExtension(imageFileExtension); var buffer = System.IO.File.ReadAllBytes(path); return File(buffer, mimetype); }\n```\n\nThere are two possible solutions to this problem. The first is to keep the functionality as it is. In this case, rather than using Server.MapPath, a fixed path referencing the image files' location in wwwroot should be used. Alternately, since the only purpose of this action method is to return a static image file, the references to this action in view files can be updated to reference the static files directly, which improves runtime performance. Since no processing is being done as part of this action, th ere's no reason not to just serve the files directly. If it's not tenable to update all references to this action, the action could be rewritten to produce a redirect to the static file's location.\n\nThe next two errors both occur in the same private method in the same line of code:\n\n```\nprivate void AddUriPlaceHolder(CatalogItem item) { item.PictureUri = this .Url.RouteUrl(PicController.GetPicRouteName, new { catalogItemId = item.Id }, this .Request.Url.Scheme); }\n```\n\nBoth this.Url and this.Request cause compiler errors. Looking at how this code is used, its purpose is to build a link to the PicController action that renders image files. The same one we just discovered could probably be replaced with direct links to the static files located in wwwroot . For now, it's worth commenting out this code and adding a TODO: comment to reference the pics another way.\n\nIt's worth noting that the base Controller class, used by the CatalogController class in which this code appears, is still referring to System.Web.Mvc.Controller. There will undoubtedly be more errors to fix once we update this to use ASP.NET Core. First, remove the using System.Web.Mvc; line from the list of using statements in CatalogController. Next, add the NuGet package Microsoft.AspNetCore.Mvc. Finally, add a using Microsoft.AspNetCore.Mvc; statement, and build the app again.\n\nThis time, there are 16 errors:\n\n['Include is not a valid named attribute argument (2)', 'HttpStatusCodeResult not found (3)', 'HttpNotFound does not exist (3)', 'SelectList not found (8)']\n\nOnce more, let's review these errors one by one. First, SelectList can be fixed by adding using Microsoft.AspNetCore.Mvc.Rendering;, which eliminates half of the errors.\n\nAll references to return HttpNotFound(); should be replaced with return NotFound();.\n\nAll references to return new HttpStatusCodeResult(HttpStatusCode.BadRequest); should be replaced with return BadRequest();.\n\nThat just leaves the use of Include with a [Bind] attribute on a couple of action methods that look like this:\n\n```\n[HttpPost] [ValidateAntiForgeryToken] public ActionResult Create([Bind(Include = \"Id,Name,Description,Price,PictureFileName,CatalogTypeId,CatalogBrandId,AvailableStock,Rest ockThreshold,MaxStockThreshold,OnReorder\")] CatalogItem catalogItem) {\n```\n\nThe preceding code restricts model binding to the properties listed in the Include string. In ASP.NET Core MVC, the [Bind] attribute still exists, but no longer needs the Include = argument. Pass the list of properties directly to the [Bind] attribute:\n\n```\n[HttpPost] [ValidateAntiForgeryToken] public ActionResult Create([Bind(\"Id,Name,Description,Price,PictureFileName,CatalogTypeId,CatalogBrandId,Availa bleStock,RestockThreshold,MaxStockThreshold,OnReorder\")] CatalogItem catalogItem) {\n```\n\nWith these changes, the project compiles once more. It's generally a better practice to use separate model types for controller inputs, rather than using model binding directly to your domain model or data model types.", "Migrate views": "The two biggest ASP.NET Core MVC features related to views are Razor Pages and Tag Helpers. For the initial migration, we won't use either feature. You should, however, keep the features in mind if you continue supporting the app once it's been migrated. The next step is to copy the Views folder from the original project into the new one. After building, there are nine errors:\n\n['HttpContext does not exist (2)', 'Scripts does not exist (5)', 'Styles does not exist (1)', 'HtmlString could not be found(1)']\n\nInvestigating these errors finds that most of them are in the main *\\_Layout.cshtml , with several related to rendering script and style tags, or displaying when the server hosting the app was last restarted. The following code listing shows problem areas in the \\_Layout.cshtml* file:\n\n```\n// other lines omitted; only errors shown @Styles.Render(\"~/Content/css\") @Scripts.Render(\"~/bundles/modernizr\") @{ var sessionInfo = new HtmlString($\"{HttpContext.Current.Session[\"MachineName\"]}, {HttpContext.Current.Session[\"SessionStartTime\"]}\");} @Scripts.Render(\"~/bundles/jquery\") @Scripts.Render(\"~/bundles/bootstrap\")\n```\n\nThe reference to Modernizr can be removed. The references to Bootstrap and jQuery can be replaced with CDN links to the appropriate version.\n\nReplace @Styles.Render line with:\n\n```\n< link rel =\"stylesheet\" href =\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity =\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin =\"anonymous\">\n```\n\nReplace the last two Scripts.Render lines with:\n\n```\n< script src =\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity =\"sha384q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin =\"anonymous\"></ script > < script src =\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity =\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin =\"anonymous\"></ script > < script src =\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity =\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin =\"anonymous\"></ script >\n```\n\nFinally, after the Bootstrap &lt;link&gt;, add additional &lt;link&gt; elements for local styles your app uses. For eShop , the result is shown here:\n\n```\n< link rel =\"stylesheet\" href =\"~/Content/custom.css\" /> < link rel =\"stylesheet\" href =\"~/Content/base.css\" /> < link rel =\"stylesheet\" href =\"~/Content/Site.css\" />\n```\n\nTo determine the order in which the &lt;link&gt; elements should appear, look at your original app's rendered HTML. Alternatively, review BundleConfig.cs , which for the eShop sample includes this code indicating the appropriate sequence:\n\n```\nbundles.Add( new StyleBundle(\"~/Content/css\").Include( \"~/Content/bootstrap.css\", \"~/Content/custom.css\",\n```\n\n```\n\"~/Content/base.css\", \"~/Content/site.css\"));\n```\n\nBuilding again reveals one more error loading jQuery Validation on the Create and Edit views. Replace it with this script:\n\n```\n< script src =\"https://cdnjs.cloudflare.com/ajax/libs/jqueryvalidate/1.17.0/jquery.validate.min.js\" integrity =\"sha512O/nUTF5mdFkhEoQHFn9N5wmgYyW323JO6v8kr6ltSRKriZyTr/8417taVWeabVS4iONGk2V444QD0P2cwhuTkg==\" crossorigin =\"anonymous\"></ script >\n```\n\nThe last thing to fix in the views is the reference to Session to display how long the app has been running, and on which machine. We can display this data directly in the site's *\\_Layout.cshtml* by using System.Environment.MachineName and System.Diagnostics.Process.GetCurrentProcess().StartTime:\n\n```\n<section class=\"col-sm-6\"> <img class=\"esh-app-footer-text hidden-xs\" src=\"~/images/main_footer_text.png\" width=\"335\" height=\"26\" alt=\"footer text image\" /> <br /> <small>@Environment.MachineName @System.Diagnostics.Process.GetCurrentProcess().StartTime.ToString() UTC</small> </section>\n```\n\nAt this point, the app once more builds successfully. However, trying to run it just yields Hello World! because the Empty ASP.NET Core template is only configured to display that in response to any request. In the next section, I complete the migration by configuring the app to use ASP.NET Core MVC, including dependency injection and configuration. Once that's in place, the app should run. Then it will be time to fix the TODO: tasks that were created earlier.", "Migrate app startup components": "The last migration step is to take the app startup tasks from Global.asax , and the classes it calls, and migrate these to their ASP.NET Core equivalents. These tasks include configuration of MVC itself, setting up dependency injection, and working with the new configuration system. In ASP.NET Core, these tasks are handled in the Startup.cs file.", "Configure MVC": "The original ASP.NET MVC app has the following code in its Application\\_Start in Global.asax , which runs when the app starts up:\n\n```\nprotected void Application_Start() { container = RegisterContainer(); AreaRegistration.RegisterAllAreas(); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); ConfigDataBase(); }\n```\n\nLooking at these lines one by one, the RegisterContainer method sets up dependency injection, which will be ported below. The next three lines configure different parts of MVC: areas, filters, and routes. Bundles are replaced by static files in the ported app. The last line sets up data access for the app, which will be shown in a later section.\n\nSince this app isn't actually using areas, there's nothing that needs to be done to migrate the area registration call. If your app does need to migrate areas, the docs specify how to configure areas in ASP.NET Core.\n\nThe call to register global filters invokes a helper on the FilterConfig class in the app's App\\_Start folder:\n\n```\npublic static void RegisterGlobalFilters(GlobalFilterCollection filters) { filters.Add( new HandleErrorAttribute()); }\n```\n\nThe only attribute added to the app is the ASP.NET MVC filter, HandleErrorAttribute. This filter ensures that when an exception occurs as part of a request, a default action and view are displayed, rather than the exception details. In ASP.NET Core, this same functionality is performed by the UseExceptionHandler middleware. The detailed error messages aren't enabled by default. They must be configured using the UseDeveloperExceptionPage middleware. To configure this behavior to match the original app, the following code must be added to the start of the Configure method in Startup.cs :\n\n```\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(\"/Error\"); } // ... }\n```\n\nThis takes care of the only filter used by the eShop app, and in this case it was done by using built-in middleware. If you have global filters that must be configured in your app, this is done when MVC is added in Program.cs when you configure services, which is shown later in this chapter.\n\nThe last piece of MVCrelated logic that needs to be migrated are the app's default routes. The call to RouteConfig.RegisterRoutes(RouteTable.Routes) passes the MVC route table to the RegisterRoutes helper method, where the following code is executed when the app starts up:\n\n```\npublic static void RegisterRoutes(RouteCollection routes) { routes.MapMvcAttributeRoutes(); routes.IgnoreRoute(\"{resource}.axd/{*pathInfo}\"); routes.MapRoute( name: \"Default\", url: \"{controller}/{action}/{id}\", defaults: new { controller = \"Catalog\", action = \"Index\", id = UrlParameter.Optional }\n```\n\n```\n); }\n```\n\nTaking this code line-by-line, the first line sets up support for attribute routes. This is built into ASP.NET Core, so it's unnecessary to configure it separately. Likewise, {resource}.axd files aren't used with ASP.NET Core, so there's no need to ignore such routes. The MapRoute method configures the default for MVC, which uses the typical {controller}/{action}/{id} route template. It also specifies the defaults for this template, such that the CatalogController is the default controller used and the Index method is the default action. Larger apps will frequently include more calls to MapRoute to set up additional routes.\n\nASP.NET Core MVC supports conventional routing and attribute routing. Conventional routing is analogous to how the route table is configured in the RegisterRoutes method listed previously. To set up conventional routing with a default route like the one used in the eShop app, add the following code to the bottom of the Configure method in Startup.cs :\n\n```\napp.UseMvc(routes => { routes.MapRoute(\"default\", \"{controller=Catalog}/{action=Index}/{id?}\"); });\n```", "Note": "To finish configuring CORS, you must also call app.UseCors() after building the application.\n\nOther advanced scenarios, like adding custom model binders, formatters, and more are covered in the detailed ASP.NET Core docs. Generally these can be applied on an individual controller or action basis, or globally using the same options approach shown in the previous code listing.", "Migrate dependency injection configuration": "The original app's Global.asax file defines the following method, called when the app starts up:\n\n```\nprotected IContainer RegisterContainer() { var builder = new ContainerBuilder(); builder.RegisterControllers( typeof (MvcApplication).Assembly); var mockData = bool.Parse(ConfigurationManager.AppSettings[\"UseMockData\"]); builder.RegisterModule( new ApplicationModule(mockData)); var container = builder.Build(); DependencyResolver.SetResolver( new AutofacDependencyResolver(container)); return container; }\n```\n\nThis code configures an Autofac container, reads a config setting to determine whether real or mock data should be used, and passes this setting into an Autofac module (found in the app's /Modules directory). Fortunately, Autofac supports .NET Core, so the module can be migrated directly. Copy the folder into the new project and updates the class's namespace and it should compile.\n\nASP.NET Core has built-in support for dependency injection, but you can wire up a third-party container such as Autofac easily if necessary. In this case, since the app is already configured to use Autofac, the simplest solution is to maintain its usage. In Program.cs , simply configure the builder to use the AutofacServiceProviderFactory as shown:\n\n```\n// using Autofac.Extensions.DependencyInjection builder.Host.UseServiceProviderFactory( new AutofacServiceProviderFactory()); // note: the factory calls builder.Populate so we don't need to here bool useMockData = true ; // TODO : read from config builder.Host.ConfigureContainer<ContainerBuilder>(builder => builder.RegisterModule( new ApplicationModule(useMockData)));\n```\n\nFor now, the setting for useMockData is set to true. This setting will be read from configuration in a moment. At this point, the app compiles and should load successfully when run, as shown in Figure 412.\n\nIF Index - Catalog manager (MVC) \u00d7\n\n['&gt; C\u2022 localhost:44337']\n\nCreate New\n\nNAME\n\n.NET Bot Black Hoodie\n\n.NET Black &amp; White Mug\n\nPrism White T-Shirt\n\n.NET Foundation T-shirt\n\nRoslyn Red Sheet\n\nNET Blue Hoodie\n\nRoslyn Red T-Shirt\n\nKudu Purple Hoodie\n\nCupsT&gt; White Mug\n\n.NET Foundation Sheet\n\ne\n\neSHOP\n\nonCONTAINERS\n\nCatalog manage* (MVC)\n\nFigure 4-12. Ported eShop app running locally with mock data.\n\n<!-- image -->", "Migrate app settings": "ASP.NET Core uses a new configuration system, which by default uses an appsettings.json file. By using CreateDefaultBuilder in Program.cs , the default configuration is already set up in the app. To access configuration, classes just need to request it in their constructor. In Program.cs , configuration is accessible from builder.Configuration.\n\nThe original app referenced its settings using ConfigurationManager.AppSettings. A quick search for all references of this term yields the set of settings the new app needs. There are only two:\n\n['UseMockData', 'UseCustomizationData']\n\nIf your app has more complex configuration, especially if it's using custom configuration sections, you'll probably want to create and bind objects to different parts of your app's configuration. These types can then be accessed using the options pattern. However, as noted in the referenced doc, this pattern shouldn't be used in Program.cs (or Startup.ConfigureServices). Instead the ported app will reference the UseMockData configuration value directly.\n\nFirst, modify the ported app's appsettings.json file and add the two settings in the root:\n\n<!-- image -->\n\n[]\n\n[]\n\n| Guest\n\n```\n\"LogLevel\": { \"Default\": \"Warning\" } }, \"AllowedHosts\": \"*\", \"UseMockData\": \"true\", \"UseCustomizationData\" :  \"true\" }\n```\n\nNow, modify Program.cs to access the UseMockData setting from the builder.Configuration property (where previously we set the value to true):\n\n```\nbool useMockData = builder.Configuration.GetValue<bool>(\"UseMockData\");\n```\n\nAt this point, the setting is pulled from configuration. The other setting, UseCustomizationData, is used by the CatalogDBInitializer class. When you first ported this class, you commented out the access to ConfigurationManager.AppSettings[\"UseCustomizationData\"]. Now it's time to modify it to use ASP.NET Core configuration. Modify the constructor of CatalogDBInitializer as follows:\n\n```\n// add using Microsoft.Extensions.Configuration public CatalogDBInitializer(CatalogItemHiLoGenerator indexGenerator, IConfiguration configuration) { this .indexGenerator = indexGenerator; useCustomizationData = configuration.GetValue<bool>(\"UseCustomizationData\"); }\n```\n\nAll access to configuration within the web app should be modified in this manner to use the new IConfiguration type. Dependencies that require access to .NET Framework configuration can include such settings in an app.config file added to the web project. The dependent projects can work with ConfigurationManager to access settings, and shouldn't require any changes if they already use this approach. However, since ASP.NET Core apps run as their own executable, they don't refe rence web.config but rather app.config . By migrating settings from the legacy app's web.config file to a new app.config file in the ASP.NET Core app, components that use ConfigurationManager to access their settings will continue to function properly.\n\nThe app's migration is nearly complete. The only remaining task is data access configuration.", "Data access considerations": "ASP.NET Core apps running on .NET Framework can continue to use Entity Framework (EF). If performing an incremental migration, getting the app working with EF 6 before trying to port its data access to use EF Core may be worthwhile. In this way, any proble ms with the app's migration can be identified and addressed before another block of migration effort is begun.\n\nAs it happens, configuring EF 6 in the eShop sample migration doesn't require any special work, since this work was performed in the Autofac ApplicationModule. The only problem is that currently the CatalogDBContext class tries to read its connection string from web.config . To address this, the connection details need to be added to appsettings.json . Then the connection string must be passed into CatalogDBContext when it's created.\n\nUpdate the appsettings.json to include the connection string. The full file is listed here:\n\n```\n{ \"ConnectionStrings\": { \"DefaultConnection\": \"Server=(localdb)\\\\mssqllocaldb;Database=eShopPorted;Trusted_Connection=True;MultipleActive ResultSets=true\" }, \"Logging\": { \"LogLevel\": { \"Default\": \"Warning\" } }, \"AllowedHosts\": \"*\", \"UseMockData\": \"false\", \"UseCustomizationData\": \"true\" }\n```\n\nThe connection string must be passed into the constructor when the DbContext is created. Since the instances are created by Autofac, the change needs to be made in ApplicationModule. Modify the module to take in a connectionString in its constructor and assign it to a field. Then modify the registration for CatalogDBContext to add connection string as a parameter:\n\n```\nbuilder.RegisterType<CatalogDBContext>() .WithParameter(\"connectionString\", _connectionString) .InstancePerLifetimeScope();\n```\n\nThe parameter must also be added to a new constructor overload in CatalogDBContext itself:\n\n```\npublic CatalogDBContext(string connectionString) : base (connectionString) { }\n```\n\nFinally, Program.cs must read the connection string from Configuration and pass it into the ApplicationModule when it instantiates it:\n\n```\nbool useMockData = Configuration.GetValue<bool>(\"UseMockData\"); string connectionString = Configuration.GetConnectionString(\"DefaultConnection\"); builder.RegisterModule( new ApplicationModule(useMockData, connectionString));\n```\n\nWith this code in place, the app runs as it did before, connecting to a SQL Server database when UseMockData is false.\n\nThe app can be deployed and run in production at this point, converted to ASP.NET Core but still running on .NET Framework and EF 6. If desired, the app can be migrated to run on .NET Core and Entity Framework Core, which will bring additional advantages described in earlier chapters. Specific to Entity Framework, this documentation compares EF Core and EF 6 and includes a grid showing which library supports each of dozens of individual features.", "Migrate to Entity Framework Core": "Assuming a decision is made to migrate to EF Core, the steps can be fairly straightforward, especially if the original app used a code-based model approach. When preparing to port from EF 6 to EF Core, review the availability of features in the destination version of EF Core you'll be using. Review the documentation on porting from and EDMX-based model versus porting from a code-based model.\n\nTo upgrade to EF Core 2.2, the basic steps involved are to add the appropriate NuGet package(s) and update namespaces. Then adjust how the connection string is passed to the DbContext type and how they're wired up for dependency injection.\n\nEF Core is added as a package reference to the project:\n\n```\n< PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"2.2.6\" />\n```\n\nThe reference to EF 6 is removed:\n\n```\n< PackageReference Include=\"EntityFramework\" Version=\"6.2.0\" />\n```\n\nThe compiler will report errors in CatalogDBContext and CatalogDBInitializer. CatalogDbContext needs to have the old namespaces removed and replaced with Microsoft.EntityFrameworkCore. Its constructors can be removed. DbModelBuilder should be replaced with ModelBuilder. The helper methods for configuring types are moved to separate classes implementing\n\nIEntityTypeConfiguration&lt;T&gt;. Then the CatalogDBContext class's OnModelCreating method simply becomes:\n\n```\nprotected override void OnModelCreating(ModelBuilder builder) { builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly()); base .OnModelCreating(builder); }\n```\n\nOther changes involved include:\n\n['HasDatabaseGeneratedOption(DatabaseGeneratedOption.None) replaced with ValueGeneratedNever()', 'HasRequired&lt;T&gt; replaced with HasOne&lt;T&gt;', 'Installed Microsoft.EntityFrameworkCore.Relational package', 'Add a constructor to CatalogDBContext taking DbContextOptions and passing it to the base constructor']\n\nAn example configuration class for CatalogType is shown here:\n\n```\nusing Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata.Builders; namespace eShopPorted.Models.Config { public class CatalogTypeConfig : IEntityTypeConfiguration<CatalogType> { public void Configure(EntityTypeBuilder<CatalogType> builder) { builder.ToTable(nameof(CatalogType)); builder.HasKey(ci => ci.Id); builder.Property(ci => ci.Id) .IsRequired(); builder.Property(cb => cb.Type) .IsRequired() .HasMaxLength(100);\n```\n\n```\n} } }\n```\n\nThe CatalogDBInitializer and its base class, CreateDatabaseIfNotExists&lt;T&gt;, are incompatible with EF Core. The purpose of this class is to create and seed the database. Using EF Core will create and drop the associated database for a DbContext using these methods:\n\n```\ndbContext.Database.EnsureDeleted(); dbContext.Database.EnsureCreated();\n```\n\nSeeding data in EF Core can be done with manual scripts, or as part of the type configuration. Along with other entity properties, seed data can be configured in IEntityTypeConfiguration classes by using builder.HasData(). The original app loaded seed data from CSV files in the Setup directory. Given that there are only a handful of items, these data records can instead be added as part of the entity configuration. This approach works well for lookup data in tables that change infrequently. Adding the following to CatalogTypeConfig's Configure method ensures the associated rows are present when the database is created:\n\n```\nbuilder.HasData( new CatalogType { Id = 1, Type = \"Mug\" }, new CatalogType { Id = 2, Type = \"T-Shirt\" }, new CatalogType { Id = 3, Type = \"Sheet\" }, new CatalogType { Id = 4, Type = \"USB Memory Stick\" } );\n```\n\nThe initial app includes a PreconfiguredData class, which includes data for CatalogBrand and CatalogType, so using this method the HasData call reduces to:\n\n```\nbuilder.HasData( PreconfiguredData.GetPreconfiguredCatalogBrands() );\n```\n\nThe CatalogItem data can also be pulled from PreconfiguredData, and assuming the associated images are kept in source control, that is the last table needed for the app to function. The CatalogDBInitializer class can be removed, along with any references to it. The CatalogItemHiLoGenerator class and the SQL files in the Infrastructure directory are also removed, along with any references to them (in CatalogService, ApplicationModule).\n\nWith the elimination of the special key generator classes for CatalogItem, this code now is removed from CatalogItemConfig:\n\n```\nbuilder.Property(ci => ci.Id) .ValueGeneratedNever() .IsRequired();\n```\n\nWith these modifications, the ASP.NET Core app builds, but it doesn't yet work with EF Core, which must still be configured for dependency injection. With EF Core, the simplest way to configure it is in Program.cs :\n\n```\nbuilder.Services.AddMvc(); bool useMockData = builder.Configuration.GetValue<bool>(\"UseMockData\"); if (!useMockData) {\n```\n\n```\nstring connectionString = builder.Configuration.GetConnectionString(\"DefaultConnection\"); builder.Services.AddDbContext<CatalogDBContext>(options => options.UseSqlServer(connectionString) ); }\n```\n\nThe final version of Autofac's ApplicationModule only configures one type, depending on whether the app is configured to use mock data:\n\n```\npublic class ApplicationModule : Module { private bool _useMockData; public ApplicationModule(bool useMockData) { _useMockData = useMockData; } protected override void Load(ContainerBuilder builder) { if (_useMockData) { builder.RegisterType<CatalogServiceMock>() .As<ICatalogService>() .SingleInstance(); } else { builder.RegisterType<CatalogService>() .As<ICatalogService>() .InstancePerLifetimeScope(); } } }\n```\n\nThe ported app runs, but doesn't display any data if configured to use non-mock data. The seed data added through HasData is only inserted when migrations are applied. The source app didn't use migrations, and if it had, they wouldn't migrate as -is. The best approach is to start with a new migration script. To do this, add a package reference for Microsoft.EntityFrameworkCore.Design and open a terminal window in the project root. Then run:\n\ndotnet ef migrations add Initial\n\nDrop the existing eShopPorted database if it exists, then run:\n\ndotnet ef database update\n\nThis creates and seeds the database. It's now ready to run, with a few small updates left to address.", "Fix all TODO tasks": "Running the ported app at this point reveals that no pictures are shown on the page. This is because the PictureUri property of CatalogItem is never set. Looking at the list of TODO items we created\n\nusing Visual Studio's Task List , the only one that remains is in CatalogController, with a note to 'Reference pic from wwwroot.' The code in question is:\n\n```\nprivate void AddUriPlaceHolder(CatalogItem item) { // TODO : Reference pic from wwwroot //item.PictureUri = this.Url.RouteUrl(PicController.GetPicRouteName, new { catalogItemId = item.Id }, this.Request.Url.Scheme); }\n```\n\nThe simplest fix is to reference the public image files in the site's public wwwroot/Pics directory. This task can be accomplished by replacing the method with the following code:\n\n```\nprivate void AddUriPlaceHolder(CatalogItem item) { item.PictureUri = $\"/Pics/{item.Id}.png\"; }\n```\n\nWith this change, running the app reveals the images work as before.", "Additional MVC customizations": "The eShopLegacyMVC app is fairly simple, so there isn't much to configure in terms of default MVC behavior. However, if you do need to configure additional MVC components, such as CORS, filters, and route constraints, you generally provide this information in Program.cs , where UseMvc is called. For example, the following code listing configures CORS and sets up a global action filter:\n\n```\nbuilder.Services.AddCors(options => { options.AddPolicy(MyAllowSpecificOrigins, builder => builder.WithOrigins(\"http://example.com\", \"http://www.contoso.com\") .AllowAnyHeader() .AllowAnyMethod()); }); builder.Services.AddMvc(options => { options.Filters.Add( new SampleGlobalActionFilter()); }).SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n```", "Other dependencies": "Dependencies that use .NET Framework features that had a dependency on the legacy configuration model, such as the WCF client type and tracing code, must be modified when ported. Rather than having these types pull in their configuration information directly, they should be configured in code. For example, a connection to a WCF service that was configured in an ASP.NET app's web.config to use basicHttpBinding could instead be configured programmatically with the following code:\n\n```\nvar binding = new BasicHttpBinding(); binding.MaxReceivedMessageSize = 2_000_000; var endpointAddress = new EndpointAddress(\"http://localhost:9200/ExampleService\"); var myClient = new MyServiceClient(binding, endpointAddress);\n```\n\nRather than relying on config files for its settings, WCF clients and other .NET Framework types should have their settings specified in code. Configured in this manner, these types can continue to work in ASP.NET Core 2.2 apps.", "References": ["Host ASP.NET Core on Windows with IIS", "URL Rewrite module and Application Request Routing", "URL Rewrite", "ASP.NET Core Module", "Share authentication cookies among ASP.NET apps", "Samples used in this section", "Incremental ASP.NET to ASP.NET Core Migration"], "More migration scenarios": "This section describes several different ASP.NET app scenarios, and offers specific techniques for solving each of them. You can use this section to identify scenarios applicable to your app, and evaluate which techniques will work for your app and its hosting environment.", "Migrate ASP.NET MVC 5 and WebApi 2 to ASP.NET Core MVC": "A common scenario in ASP.NET MVC 5 and Web API 2 apps was for both products to be installed in the same application. This is a supported and relatively common approach used by many teams, but because the two products use different abstractions, there is some redundant effort needed. For example, setting up routes for ASP.NET MVC is done using methods on RouteCollection, such as MapMvcAttributeRoutes() and MapRoute(). But ASP.NET Web API 2 routing is managed with HttpConfiguration and methods like MapHttpAttributeRoutes() and MapHttpRoute().\n\nThe eShopLegacyMVC app includes both ASP.NET MVC and Web API, and includes methods in its App\\_Start folder for setting up routes for both. It also supports dependency injection using Autofac, which also requires two sets of similar work to configure:\n\n```\nprotected IContainer RegisterContainer() { var builder = new ContainerBuilder(); var thisAssembly = Assembly.GetExecutingAssembly(); builder.RegisterControllers(thisAssembly);      // MVC controllers builder.RegisterApiControllers(thisAssembly);   // Web API controllers var mockData = bool.Parse(ConfigurationManager.AppSettings[\"UseMockData\"]); builder.RegisterModule( new ApplicationModule(mockData)); var container = builder.Build(); // set mvc resolver DependencyResolver.SetResolver( new AutofacDependencyResolver(container)); // set webapi resolver var resolver = new AutofacWebApiDependencyResolver(container); GlobalConfiguration.Configuration.DependencyResolver = resolver; return container; }\n```\n\nWhen upgrading these apps to use ASP.NET Core, this duplicate effort and the confusion that sometimes accompanies it is eliminated. ASP.NET Core MVC is a unified framework with one set of rules for routing, filters, and more. Dependency injection is built into .NET Core itself. All of this can be configured in Program.cs , as is shown in the eShopPorted app in the sample.", "Migrate HttpResponseMessage to ASP.NET Core": "Some ASP.NET Web API apps may have action methods that return HttpResponseMessage. This type does not exist in ASP.NET Core. Below is an example of its usage in a Delete action method, using the ResponseMessage helper method on the base ApiController:\n\n```\n// DELETE api/<controller>/5 [HttpDelete] public IHttpActionResult Delete(int id) { var brandToDelete = _service.GetCatalogBrands().FirstOrDefault(x => x.Id == id); if (brandToDelete == null ) { return ResponseMessage( new HttpResponseMessage(HttpStatusCode.NotFound)); } // demo only - don't actually delete return ResponseMessage( new HttpResponseMessage(HttpStatusCode.OK)); }\n```\n\nIn ASP.NET Core MVC, there are helper methods available for all of the common HTTP response status codes, so the above method would be ported to the following code:\n\n```\n[HttpDelete(\"{id}\")] public IActionResult Delete(int id) { var brandToDelete = _service.GetCatalogBrands().FirstOrDefault(x => x.Id == id); if (brandToDelete == null ) {\n```\n\n```\nreturn NotFound(); } // demo only - don't actually delete return Ok(); }\n```\n\nIf you do find that you need to return a custom status code for which no helper exists, you can always use return StatusCode(int statusCode) to return any numeric code you like.", "Migrate content negotiation from ASP.NET Web API to ASP.NET Core": "ASP.NET Web API 2 supports content negotiation natively. The sample app includes a BrandsController that demonstrates this support by listing its results in either XML or JSON. This is based on the request's Accept header, and changes when it includes application/xml or application/json.\n\nASP.NET MVC 5 apps do not have content negotiation support built in.\n\nContent negotiation is preferable to returning a specific encoding type, as it is more flexible and makes the API available to a larger number of clients. If you currently have action methods that return a specific format, you should consider modifying them to return a result type that supports content negotiation when you port the code to ASP.NET Core.\n\nThe following code returns data in JSON format regardless of client Accept header content:\n\n```\n[HttpGet] public ActionResult Index() { return Json( new { Message = \"Hello World!\" }); }\n```\n\nASP.NET Core MVC supports content negotiation natively, provided an appropriate return type is used. Content negotiation is implemented by [ObjectResult] which is returned by the status codespecific action results returned by the controller helper methods. The previous action method, implemented in ASP.NET Core MVC and using content negotiation, would be:\n\n```\npublic IActionResult Index() { return Ok( new { Message = \"Hello World!\"} ); }\n```\n\nThis will default to returning the data in JSON format. XML and other formats will be used if the app has been configured with the appropriate formatter.", "Custom model binding": "Most ASP.NET MVC and Web API apps make use of model binding. The default model binding syntax migrates fairly seamlessly between these apps and ASP.NET Core MVC. However, in some cases customers have written custom model binders to support specific model types or usage scenarios. Custom model binders in ASP.NET MVC and Web API projects use separate IModelBinder interfaces defined in System.Web.Mvc and System.Web.Http namespaces, respectively. In both cases, the custom\n\nbinder exposes a Bind method that accepts a controller or action context and a model binding context as arguments.\n\nOnce the custom binder is created, it must be registered with the app. This step requires creating another type, a ModelBinderProvider, which acts as a factory and creates the model binder during a request. Binders can be added during ApplicationStart in MVC apps as shown:\n\n```\nModelBinderProviders.BinderProviders.Insert(0, new MyCustomBinderProvider()); // MVC\n```\n\nIn Web API apps, custom binders can be referenced using attributes. The ModelBinder attribute can be added to action method parameters or to the parameter's type definition, as shown:\n\n```\n// attribute on action method parameter public HttpResponseMessage([ModelBinder( typeof (MyCustomBinder))] CustomDTO custom) { } // attribute on type [ModelBinder( typeof (MyCustomBinder))] public class CustomDTO { }\n```\n\nTo register a model binder globally in ASP.NET Web API, its provider must be added during app startup:\n\n```\npublic static class WebApiConfig { public static void Register(HttpConfiguration config) { var provider = new CustomModelBinderProvider( typeof (CustomDTO), new CustomModelBinder()); config.Services.Insert( typeof (ModelBinderProvider), 0, provider); // ... } }\n```\n\nWhen migrating custom model providers to ASP.NET Core, the Web API pattern is closer to the ASP.NET Core approach than the ASP.NET MVC 5. The main differences between ASP.NET Core's IModelBinder interface and Web API's is that the ASP.NET Core method is async (BindModelAsync) and it only requires a single BindingModelContext parameter instead of two parameters like Web API's version required. In ASP.NET Core, you can use a [ModelBinder] attribute on individual action method parameters or their associated types. You can also create a ModelBinderProvider that will be used globally within the app where appropriate. To configure such a provider, you would add code to Program.cs :\n\n```\nbuilder.Services.AddControllers(options => { options.ModelBinderProviders.Insert(0, new CustomModelBinderProvider()); });\n```", "Media formatters": "ASP.NET Web API supports multiple media formats and can be extended by using custom media formatters. The docs describe an example CSV Media Formatter that can be used to send data in a commaseparated value format. If your Web API app uses custom media formatters, you'll need to convert them to ASP.NET Core custom formatters.\n\nTo create a custom formatter in Web API 2, you inherited from an appropriate base class and then added the formatter to the Web API pipeline using the HttpConfiguration object:\n\n```\npublic static void ConfigureApis(HttpConfiguration config) { config.Formatters.Add( new ProductCsvFormatter()); }\n```\n\nIn ASP.NET Core, the process is similar. ASP.NET Core supports both input formatters (used by model binding) and output formatters (used to format responses). Adding a custom formatter to output responses in a specific way involves inheriting from an appropriate base class and adding the formatter to MVC in Program.cs :\n\n```\nbuilder.Services.AddControllers(options => { options.InputFormatters.Insert(0, new CustomInputFormatter()); options.OutputFormatters.Insert(0, new CustomOutputFormatter()); });\n```\n\nYou'll find a complete list of base classes in the Microsoft.AspNetCore.Mvc.Formatters namespace.\n\nThe steps to migrate from a Web API formatter to an ASP.NET Core MVC formatter are:\n\n['Identify an appropriate base class for the new formatter.', 'Create a new instance of the base class and implement its required methods.', 'Copy over the functionality from the Web API formatter to the new implementation.', \"Configure MVC in the ASP.NET Core App's ConfigureServices method to use the new formatter.\"]", "Custom filters": "Filters are used in ASP.NET Core apps to execute code before and/or after certain stages in the request processing pipeline. ASP.NET MVC and Web API also use filters in much the same way, but the details vary. For instance, ASP.NET MVC supports four kinds of filters. ASP.NET Web API 2 supports similar filters, and both MVC and Web API included attributes to override filters.\n\nThe most common filter used in ASP.NET MVC and Web API apps is the action filter, which is defined by an IActionFilter interface. This interface provides methods for before (OnActionExecuting) and after (OnActionExecuted) which can be used to execute code before and/or after an action executes, as noted for each method.\n\nASP.NET Core continues to support filters, and its unification of MVC and Web API means there is only one approach to their implementation. The docs include detailed coverage of the five (5) kinds of filters built into ASP.NET Core MVC. All of the filter variants supported in ASP.NET MVC and ASP.NET\n\nWeb API have associated versions in ASP.NET Core, so migration is generally just a matter of identifying the appropriate interface and/or base class and migrating the code over.\n\nIn addition to the synchronous interfaces, ASP.NET Core also provides async interfaces like IAsyncActionFilter which provide a single async method that can be used to incorporate code to run both before and after the action, as shown:\n\n```\npublic class SampleAsyncActionFilter : IAsyncActionFilter { public async Task OnActionExecutionAsync( ActionExecutingContext context, ActionExecutionDelegate next) { // Do something before the action executes. // next() calls the action method. var resultContext = await next(); // resultContext.Result is set. // Do something after the action executes. } }\n```\n\nWhen migrating async code (or code that should be async), teams should consider leveraging the built in async types that are provided for this purpose.\n\nMost ASP.NET MVC and Web API apps do not use a large number of custom filters. Since the approach to filters in ASP.NET Core MVC is closely aligned with filters in ASP.NET MVC and Web API, the migration of custom filters is generally fairly straightforward. Be sure to read the detailed documentation on filters in ASP.NET Core's docs, and once you're sure you have a good understanding of them, port the logic from the old system to the new system's filters.", "Route constraints": "ASP.NET Core uses route constraints to help ensure requests are routed properly to route a request. ASP.NET Core supports a large number of different route constraints for this purpose. Route constraints can be applied in the route table, but most apps built with ASP.NET MVC 5 and/or ASP.NET Web API 2 use inline route constraints applied to attribute routes. Inline route constraints use a format like this one:\n\n```\n[Route(\"/customer/{id:int}\")]\n```\n\nThe :int after the id route parameter constrains the value to match the int type. One benefit of using route constraints is that they allow for two otherwise-identical routes to exist where the parameters differ only by their type. This allows for the equivalent of method overloading of routes based solely on parameter type.\n\nThe set of route constraints, their syntax, and usage is very similar between all three approaches. Custom route constraints are fairly rare in customer applications. If your app uses a custom route constraint and needs to port to ASP.NET Core, the docs include examples showing how to create custom route constraints in ASP.NET Core . Essentially all that's required is to implement IRouteConstraint and its Match method, and then add the custom constraint when configuring routing for the app:\n\n```\nbuilder.Services.AddControllers(); builder.Services.AddRouting(options => { options.ConstraintMap.Add(\"customName\", typeof (MyCustomConstraint)); });\n```\n\nThis is very similar to how custom constraints are used in ASP.NET Web API, which uses IHttpRouteConstraint and configures it using a resolver and a call to HttpConfiguration.MapHttpAttributeRoutes:\n\n```\npublic static class WebApiConfig { public static void Register(HttpConfiguration config) { var constraintResolver = new DefaultInlineConstraintResolver(); constraintResolver.ConstraintMap.Add(\"nonzero\", typeof (CustomConstraint)); config.MapHttpAttributeRoutes(constraintResolver); } }\n```\n\nASP.NET MVC 5 follows a very similar approach, using IRouteConstraint for its interface name and configuring the constraint as part of route configuration:\n\n```\npublic class RouteConfig { public static void RegisterRoutes(RouteCollection routes) { routes.IgnoreRoute(\"{resource}.axd/{*pathInfo}\"); var constraintsResolver = new DefaultInlineConstraintResolver(); constraintsResolver.ConstraintMap.Add(\"values\", typeof (ValuesConstraint)); routes.MapMvcAttributeRoutes(constraintsResolver); } }\n```\n\nMigrating route constraint usage as well as custom route constraints to ASP.NET Core is typically very straightforward.", "Custom route handlers": "Another fairly advanced feature of ASP.NET MVC 5 is route handlers. Custom route handlers implement IRouteHandler, which includes a single method that returns an IHttpHandler for a give request. The IHttpHandler, in turn, exposes an IsReusable property and a single ProcessRequest method. In ASP.NET MVC 5, you can configure a particular route in the route table to use your custom handler:\n\n```\npublic static void RegisterRoutes(RouteCollection routes) { routes.IgnoreRoute(\"{resource}.axd/{*pathInfo}\"); routes.Add( new Route(\"custom\", new CustomRouteHandler())); }\n```\n\nTo migrate custom route handlers from ASP.NET MVC 5 to ASP.NET Core, you can either use a filter (such as an action filter) or a custom IRouter. The filter approach is relatively straightforward, and can be added as a global filter when MVC is added to the app's services during startup:\n\n```\nbuilder.Services.AddMvc(options => { options.Filters.Add( typeof (CustomActionFilter)); });\n```\n\nThe IRouter option requires implementing the interface's RouteAsync and GetVirtualPath methods. The custom router is added to the request pipeline during app startup.\n\n```\n// ... app.UseMvc(routes => { routes.Routes.Add( new CustomRouter(routes.DefaultHandler)); });\n```\n\nIn ASP.NET Web API, these handlers are referred to as custom message handlers, rather than route handlers . Message handlers must derive from DelegatingHandler and override its SendAsync method. Message handlers can be chained together to form a pipeline in a fashion that is very similar to ASP.NET Core middleware and its request pipeline.\n\nASP.NET Core has no DelegatingHandler type or separate message handler pipeline. Instead, such handlers should be migrated using global filters, custom IRouter instances (see above), or custom middleware. ASP.NET Core MVC filters and IRouter types have the advantage of having built-in access to MVC constructs like controllers and actions, while middleware is a lower level approach that has no ties to MVC. This makes it more flexible but also requires more effort if you need to access MVC components.", "CORS support": "CORS, or Cross-Origin Resource Sharing, is a W3C standard that allows servers to accept requests that don't originate from responses they've served. ASP.NET MVC 5 and ASP.NET Web API 2 support CORS in different ways. The simplest way to enable CORS support in ASP.NET MVC 5 is with an action filter like this one:\n\n```\npublic class AllowCrossSiteAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext filterContext) { filterContext.RequestContext.HttpContext.Response.AddHeader( \"Access-Control-Allow-Origin\", \"example.com\"); base .OnActionExecuting(filterContext); } }\n```\n\nASP.NET Web API can also use such a filter, but it has built-in support for enabling CORS as well:\n\n```\npublic static class WebApiConfig { public static void Register(HttpConfiguration config) { config.EnableCors();\n```\n\n```\n// ... } }\n```\n\nOnce this is added, you can configure allowed origins, headers, and methods using the EnableCors attribute, like so:\n\n```\n[EnableCors(origins: \"https://dot.net\", headers: \"*\", methods: \"*\")] public class TestController : ApiController { // Controller methods not shown... }\n```\n\nBefore migrating your CORS implementation from ASP.NET MVC 5 or ASP.NET Web API 2, be sure to review how CORS works and create some automated tests that demonstrate CORS is working as expected in your current system.\n\nIn ASP.NET Core, there are three built-in ways to enable CORS:\n\n['Configured via policy in ConfigureServices', 'Enabled with endpoint routing', 'Enabled with the EnableCors attribute']\n\nEach of these approaches is covered in detail in the docs, which are linked from the above options. Which one you choose will largely depend on how your existing app supports CORS. If the app uses attributes, you can probably migrate to use the EnableCors attribute most easily. If your app uses filters, you could continue using that approach (though it's not the typical approach used in ASP.NET Core), or migrate to use attributes or policies. Endpoint routing is a relatively new feature introduced with ASP. NET Core 3 and as such it doesn't have a close analog in ASP.NET MVC 5 or ASP.NET Web API 2 apps.", "Custom areas": "Many ASP.NET MVC apps use Areas to organize the project. Areas typically reside in the root of the project in an Areas folder, and must be registered when the application starts, typically in Application\\_Start():\n\n```\nAreaRegistration.RegisterAllAreas();\n```\n\nAn alternative to registering all areas in startup is to use the RouteArea attribute on individual controllers:\n\n```\n[RouteArea(\"Admin\")] public class SomeController : Controller When using Areas, additional arguments are passed into HTML helper methods to generate links to actions in different areas: @Html.ActionLink(\"News\", \"Index\", \"News\", new { area = \"News\" }, null)\n```\n\nASP.NET Web API apps don't typically use areas explicitly, since their controllers can be placed in any folder in the project. Teams can use any folder structure they like to organize their API controllers.\n\nAreas are supported in ASP.NET Core MVC. The approach used is nearly identical to the use of areas in ASP.NET MVC 5. Developers migrating code using areas should keep in mind the following differences:\n\n['AreaRegistration.RegisterAllAreas is not used in ASP.NET Core MVC', 'Areas are applied using the [Area(\"name\")] attribute (not RouteArea as in ASP.NET MVC 5)', 'Areas can be added to the route table templates, if desired (or they can use attribute routing)']\n\nTo add area support to the route table in ASP.NET Core MVC, you would add the following during app startup:\n\n```\napp.UseEndpoints(endpoints => { endpoints.MapControllerRoute( name: \"MyArea\", pattern: \"{area:exists}/{controller=Home}/{action=Index}/{id?}\"); endpoints.MapControllerRoute( name: \"default\", pattern: \"{controller=Home}/{action=Index}/{id?}\"); });\n```\n\nAreas can also be used with attribute routing, using the {area} keyword in the route definition (it's one of several reserved routing names that can be used with route templates).\n\nTag helpers support areas with the asp-area attribute, which can be used to generate links in Razor views and pages:\n\n```\n<ul> <li> <a asp-area=\"Products\" asp-controller=\"Home\" asp-action=\"About\"> Products/Home/About </a> </li> <li> <a asp-area=\"Services\" asp-controller=\"Home\" asp-action=\"About\"> Services About </a> </li> <li> <a asp-area=\"\" asp-controller=\"Home\" asp-action=\"About\"> /Home/About </a> </li> </ul>\n```\n\nIf you're migrating to Razor Pages you will need to use an Areas folder in your Pages folder. For more information, see Areas with Razor Pages.\n\nIn addition to the above guidance, teams should review how routing in ASP.NET Core works with areas as part of their migration planning process.", "Integration tests for ASP.NET MVC and ASP.NET Web API": "Integration tests are automated tests that verify several different parts of an app work together correctly. Writing integration tests for ASP.NET MVC and ASP.NET Web API usually involved deploying\n\nthe app to a real web server, such as a local instance of IIS or IIS Express, and then making requests to this hosted application using an HTTP client. Some of these tests may interact with the client-side user interface using browser automation tools like Selenium, though often these are referred to as UI tests rather than integration tests.\n\nIf your migrated app shares the same behavior as its original version, whatever existing technology the team is using to perform integration tests (and UI tests) should continue to work just as it did before. These tests are usually indifferent to the unde rlying technology used to host the app they're testing, and interact with it only through HTTP requests. Where things may get more challenging is with how the tests interact with the app to get it into a known good state prior to each test. This may require some migration effort, since configuration and startup are significantly different in ASP.NET Core compared to ASP.NET MVC or ASP.NET Web API.\n\nTeams should strongly consider migrating their integration tests to use ASP.NET Core's built -in integration testing support. In ASP.NET Core, apps can be tested by deploying them to a TestHost, which is configured using a WebApplicationFactory. There's a little bit of setup required to host the app for testing, but once this is in place, creating individual integration tests is very straightforward.\n\nOne of the best features of ASP.NET Core's integration testing support is that the app is hosted in memory. There's no need to configure a real webserver to host the app. There's no need to use a browser automation tool (if you're only testing ASP.NET Core and not client-side behavior). Many of the problems that can be encountered when trying to use a real web server for automated integration tests, such as firewall issues or process start/stop issues, are eliminated with this approach. Since the requests are all made in memory with no network requirement, the tests also tend to run much faster than tests that must set up a separate webserver and communicate with it over the network (even if it's running on the same machine).\n\nBelow you can see an example ASP.NET Core integration test (sometimes referred to as functional tests to distinguish them from lower-level integration tests) from the eShopOnWeb reference application:\n\n```\npublic class GetByIdEndpoint : IClassFixture<ApiTestFixture> { JsonSerializerOptions _jsonOptions = new JsonSerializerOptions { PropertyNameCaseInsensitive = true }; public GetByIdEndpoint(ApiTestFixture factory) { Client = factory.CreateClient(); } public HttpClient Client { get ; } [Fact] public async Task ReturnsItemGivenValidId() { var response = await Client.GetAsync(\"api/catalog-items/5\"); response.EnsureSuccessStatusCode(); var stringResponse = await response.Content.ReadAsStringAsync(); var model = stringResponse.FromJson<GetByIdCatalogItemResponse>(); Assert.Equal(5, model.CatalogItem.Id); Assert.Equal(\"Roslyn Red Sheet\", model.CatalogItem.Name);\n```\n\n<!-- image -->\n\nIf the app being migrated has no integration tests, the migration process can be a great opportunity to add some. These tests can verify that the migrated app behaves as the team expects. When such tests are in place early in a migration, they can ensure that later migration efforts do not break previously migrated portions of the app. Given how easy it is to set up and run integration tests in ASP.NET Core, the return on the investment spent setting up such tests is usually pretty high.", "WCF client configuration": "If your app currently relies on WCF services as a client, this scenario is supported. However, you will need to migrate your configuration from web.config to use the new appsettings.json file. Another option is to add any necessary configuration to your clients programmatically when you create them. For example:\n\n<!-- image -->\n\nIf your organization has extensive services built using WCF that your app relies on, consider migrating them to use gRPC instead. For more details on gRPC, why you may wish to migrate, and a detailed migration guide, consult the gRPC for WCF Developers eBook.", "Deployment scenarios when migrating to ASP.NET Core": "Existing ASP.NET MVC and Web API apps run on IIS and Windows. Large apps may require a phased or side-by-side approach when porting to ASP.NET Core. In previous chapters, you learned a number of strategies for migrating large .NET Framework apps to ASP.NET Core in phases. In this chapter, you will see how different deployment scenarios can be achieved when there is a need to maintain the original app in production while migrating portions of it.", "Split a large web app": "Consider the common scenario of a large web app that currently is hosted on IIS in a single web site. Within the large app, functionality is segmented into different routes and/or directories. The app is a mix of MVC views and API endpoints. The MVC routes include many different paths based on functionality and all start from the root of the app using the standard /{controller}/{action}/{id?} route template. The API endpoints follow a similar pattern, but are all under an /api root.\n\nAssuming the task of porting the app is split such that either the MVC functionality or the API functionality is migrated to ASP.NET Core first, how would the original site continue to function seamlessly with the new ASP.NET Core app running somewhere else? Users of the system should continue to see the same URLs they did prior to the migration, unless it's absolutely necessary to change them.\n\nFortunately, IIS is a feature-rich web server, and two features it has are URL Rewrite module and Application Request Routing. Using these features, IIS can act as a reverse proxy, routing client requests to the appropriate back-end web app. To configure IIS as a reverse proxy, check the Enable proxy checkbox in the Application Request Routing feature, then add a URL Rewrite rule like this one:\n\n```\n< rule name=\"NetCoreProxy\"> < match url=\"(.*)>\" /> < action type=\"Rewrite\" url=\"http://servername/{R:1}\" /> </ rule >\n```\n\nAs a reverse proxy, IIS can route traffic matching certain patterns to entirely separate apps, potentially on different servers.\n\nUsing just the URL Rewrite module (perhaps combined with host headers), IIS can easily support multiple web sites, each potentially running different versions of .NET. A large web app might be deployed as a collection of individual sites, each responding to different IP addresses and/or host headers, or as a single web site with one or more sub-applications in it responding to certain URL paths (which doesn't even require URL Rewrite).\n\n| Important                                                                                                                                                                                                                                                                                                                                                                                                           |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Subdomains typically refer to the portion of a domain preceding the top two levels. For example, in the domain api.contoso.com, api is a subdomain of the contoso.com domain (which itself is composed of the contoso domain name and the .com top-level domain or TLD). URL paths refer to portion of the URL that follows the domain name, starting with a /. The URL https://contoso.com/api has a path of /api. |\n\nThere are pros and cons to using the same or different subdomains (and domains) to host a single app. Features like cookies and intra-app communication using mechanisms like CORS may require more configuration to work properly in distributed apps. However, apps that use different subdomains can more easily use DNS to route requests to entirely different network destinations, and so can more easily be deployed to many different servers (virtual or otherwise) without the need for IIS to act as a reverse proxy.\n\nIn the example described above, assume the API endpoints are designated as the first part of the app to be ported to ASP.NET Core. In this case, a new ASP.NET Core app is created and hosted in IIS as a separate web application within the existing ASP.NET MVC web site . Since it will be added as a child of the original web site and will be named api , its default route should no longer begin with api/. Keeping this would result in it matching URLs of the form /api/api/endpoint.\n\nFigure 5-1 shows how the ASP.NET Core 2.1 api app appears in IIS Manager as a part of the existing DotNetMvcApp site.\n\nInternet Information Services (IIS) Manager\n\n\u2022 NIGHTKING \u2022 Sites \u2022 DotNetMvcApp \u2022\n\nFile View Help\n\nConnections v .6g NIGHTKING (NIGHTKING\\stev\n\n..a Application Pools\n\nSites\n\nDotNetMvcApp aspnet\\_client\n\nbin\n\nContent fonts\n\nScripts\n\nViews api\n\nActions\n\nFigure 5-1. .NET Framework Site with .NET Core app in IIS.\n\n<!-- image -->\n\nThe DotNetMvcApp site is hosted as an MVC 5 app running on .NET Framework 4.7.2. It has its own IIS app pool configured in integrated mode and running .NET CLR version 4.0.30319. The api app is an ASP.NET Core app running on .NET Framework 4.6.1 (net461). It was added to the DotNetMvcApp as a new IIS app and configured to use its own Application Pool. Its Application Pool is also running in integrated mode but is configured with a .NET CLR version of No Managed Code since it will be executed using the ASP.NET Core Module. The version of the ASP.NET Core app is just an example. It could also be configured to run on NET 5+. Though at that point, it would no longer be able to target .NET Framework libraries (see Choose the Right .NET Core Version)\n\nConfigured in this manner, the only change that must be made in order for the ASP.NET Core app's APIs to be routed properly is to change its default route template from [Route(\"[api/controller]\")] to [Route(\"[controller]\")].\n\nAlternately the ASP.NET Core app can be another top-level web site in IIS. In this case, you can configure the original site to use a rewrite rule (with URL Rewrite) that will redirect to the other app if the path starts with /api. The ASP.NET Core app can use a different host header for its route so that it doesn't conflict with the main app but can still respond to requests using root -based routes.\n\nAs an example, the same ASP.NET Core app used in Figure 5-1 can be deployed to another folder configured as an IIS web site. The site should use an app pool configured just as before, with No\n\nReady\n\nDotNetMvcApp Home\n\nX\n\n[]\n\n['Internet Information Services (IIS) Manager']\n\n&lt; \u2192\n\n6] \u2022 NIGHTKING \u00bb\n\nFile View\n\nHelp\n\nConnections la Application Pools\n\nV\n\nEdit Inbound Rule\n\nActions\n\nEy Apply\n\nManaged Code . Configure its bindings to respond to a unique host name on the server, such as api.contoso.com. To configure URL Rewrite to rewrite requests matching /api just add a new inbound rule at the IIS server (or individual site) level. Match the pattern ^/api(.*) and specify an Action type of Rewrite and a Rewrite URL of api.contoso.com/{R:1}. The combination of using (.*) in the matching pattern and {R:1} in the rewrite URL will ensure the rest of the path gets used with the new URL. With this in place, separate sites on the same IIS server can coexist running separate versions of .NET, but they can be made to appear to the Internet as one web app. Figure 5-2 shows the rewrite rule as configured in IIS with the separate web site.\n\nSites\n\nConfiguration: 'localhost' applicationHost.config\n\nFigure 5-2. Rewrite rule to rewrite subfolder requests to another web site.\n\n<!-- image -->\n\nIf your app requires single sign-on between different sites or apps within IIS, refer to the documentation on how to share authentication cookies among ASP.NET apps for detailed instructions on supporting this scenario.\n\nAnother alternative to IIS Rewrite rules is the use of a reverse proxy like YARP, which can facilitate incremental ASP.NET to ASP.NET Core Migration.", "Summary": "A common approach to porting large apps from .NET Framework to ASP.NET Core is to choose individual portions of the app to migrate one by one. As each piece of the app is ported, the entire app remains running and usable, with some parts of it running in its original configuration and other parts running on some version of .NET Core. By following this approach, a large app migration can be performed incrementally. This approach results in limiting risk by providing more rapid feedback and\n\n\u2022 0-\n\nreducing total surface area involved in testing. It also allows for more rapid realization of benefits of .NET Core, such as performance increases. Although ASP.NET Core apps are no longer required to be hosted on IIS, IIS remains a very flexible and powerful web server that can be configured to support a variety of hosting scenarios involving both .NET Framework and ASP.NET Core apps on the same IIS instance or even hosted on different servers.", "Summary: Port existing ASP.NET Apps to .NET 7": "In this book, you've been given the resources needed to decide whether it makes sense to port your organization's existing ASP.NET apps running on .NET Framework to ASP.NET Core. You've learned about important considerations for choosing when it makes sense to migrate to .NET Core, and when it may be appropriate to keep (parts of) your app on .NET Framework. There are differences between .NET Core versions and their capabilities and compatibilities with .NET Framework, and you learned how to choose the right version of .NET Core for your app.\n\nPorting a large app often entails a fair amount of risk and effort. You learned how to mitigate this risk by employing one or more incremental migration strategies along with several deployment strategies for keeping partially migrated apps running in production.\n\nThere are many architectural differences between ASP.NET and ASP.NET Core. In chapter 2, you learned about many of these differences and how they relate to your app's migration. This chapter covered everything from app startup and low-level middleware to high-level controller and Web API differences and new features enabling much better testing scenarios.\n\nLarge apps are often comprised of many projects and packages, and dependencies can play a major role in determining how easy or difficult migration may be. Chapter 3 helped you identify the sequence in which to migrate projects and how to understand and update your app's dependencies . It also detailed additional strategies for migrating apps while keeping them running in production.\n\nIn chapter 4, you saw how a real ASP.NET MVC reference app was migrated to ASP.NET Core. This chapter included a detailed breakdown of all the changes that were needed to take the existing app and port it over to run on ASP.NET Core. Refer back to it if you have specific questions about the porting process and some of its more specific details.\n\nFinally, chapter 5 detailed specific deployment scenarios focused on IIS. You saw how you can use your existing IIS web server to host parts of your app that have been ported to ASP.NET Core while keeping the app's public URLs consistent. IIS includes great support for URL rewriting and request routing that enables it to host multiple versions of your site side by side or even on different servers, with no change to the public-facing URLs the app exposes."}}