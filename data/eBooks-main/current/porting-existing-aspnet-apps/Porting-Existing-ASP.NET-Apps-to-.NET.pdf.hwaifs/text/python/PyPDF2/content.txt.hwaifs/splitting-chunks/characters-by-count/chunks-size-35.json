"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\nPUBLISHED BY  \\nMicrosoft Developer Divis\", \"ion, .NET, and Visual Studio product teams  \\nA division of Microsoft Corporation  \\nOne Microsoft Way\", \"  \\nRedmond, Washington 98052 -6399  \\nCopyright \\u00a9 2023 by Microsoft Corporation  \\nAll rights reserved\", \". No part of this book\\u2019s contents may be reproduced or transmitted in any form or \\nby any means with\", \"out the written permission of the publisher.  \\nThis book is provided \\u201cas -is\\u201d and expresses the auth\", \"or\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in this book, including URL\", \" and other Internet website references, may change \\nwithout notice.  \\nSome examples depicted herein \", \"are provided for illustration only and are fictitious. No real association \\nor connection is intende\", \"d or should be inferred.  \\nMicrosoft and the trademarks listed at https://www.microsoft.com  on the \", \"\\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies.  \\nMac and macOS are tradem\", \"arks of Apple Inc.  \\nThe Docker whale logo is a registered trademark of Docker, Inc.  Used by permis\", \"sion.  \\nAll other marks and logos are property of their respective owners.  \\nAuthors:  \\nSteve \\u201cardal\", \"is\\u201d Smith , Software Architect and Trainer - Ardalis.com  \\nParticipants and Reviewers:  \\nNish Anil ,\", \" Senior Program Manager, .NET team, Microsoft  \\nMike Rousos , Principal Software Engineer, .NET team\", \", Microsoft  \\nScott Addie , Senior Content Developer, .NET team, Microsoft  \\nDavid Pine , Senior Con\", \"tent Developer, .NET team, Microsoft  \\nVersion  \\nThis guide covers .NET 7  and updates related to th\", \"e same technology \\u201cwave\\u201d (that is, Azure and other \\nthird -party technologies) coinciding in time wi\", \"th the .NET 7 release. This book covers migration of \\napps that are currently running on .NET Framew\", \"ork 4.x.  \\nWho should use this guide  \\nThis guide\\u2019s audience is developers, development leads, and a\", \"rchitects who are interested in \\nmigrating their existing apps written for ASP.NET MVC and Web API (\", \".NET Framework 4.x) to the latest  \\n.NET version. ASP.NET Web Forms developers will benefit from thi\", \"s guide but should also read the \\nBlazor for ASP.NET Web Forms Developers  e-book.  \\nA secondary aud\", \"ience is technical decision -makers planning when to move their apps to .NET 7.  \\nThe target audienc\", \"e for this book is .NET developers with large, existing apps that run on ASP.NET \\nMVC and Web API. A\", \"pps built on ASP.NET Web Forms are outside of the focus of this book, though \\nmuch of the informatio\", \"n comparing .NET Framework and .NET Core /latest may still be relevant.  \\nHow you can use this guide\", \"  \\nYou can read this book straight through, as we expect many readers to do. This book will provide \", \"you \\nfirst with considerations for whether you should port your app at all. That content is followed\", \" by \\narchitectural differences between .NET Framework and .NE T Core. From there, you\\u2019ll learn strat\", \"egies \\nfor migrating a large solution over time and how to port a real app. Next, the book includes \", \"\\ndeployment scenarios that address the need to run different apps while appearing as a single app to\", \" \\nusers. The book con cludes with two case studies describing real apps that have migrated from \\nASP\", \".NET MVC to ASP.NET Core.  \\nWhether or not you choose to start from the first chapter, you can refer\", \"ence any of these chapters to \\nlearn about specific concepts:  \\n\\u2022 Architectural differences  \\n\\u2022 Migr\", \"ate large solutions  \\n\\u2022 Sample migration  \\n\\u2022 Deployment scenarios  \\nThis guide is available both in \", \"PDF form  and online. Feel free to forward this document or links to its \\nonline version to your tea\", \"m to ensure a common understanding of these concepts.   \\ni Contents   \\nContents  \\nIntroduction to po\", \"rting apps to .NET 7  ................................ ................................ ............\", \"....  1 \\nReferences  ................................ ................................ .............\", \"................... ................................ ................................ ..............\", \"....  2 \\nMigration considerations  ................................ ................................\", \" ................................ ................................ ......................  2 \\nIs mig\", \"ration to .NET Core appropriate?  ................................ ................................ \", \"................................ .....................  2 \\nWhen is .NET Framework appropriate?  ....\", \"............................ ................................ ................................ .....\", \".................  3 \\nReferences  ................................ ................................ \", \"................................ ................................ ................................ .\", \".............  4 \\nMigrate to ASP.NET Core 2.1  ................................ ....................\", \"............ ................................ ................................ ..............  4 \\nSh\", \"ould apps run on .NET Framework with ASP.NET Core 2.1  ................................ ............\", \".................... ...........  4 \\nReferences  ................................ ..................\", \".............. ................................ ................................ ...................\", \"............. ..............  5 \\nChoose the right .NET Core version  ...............................\", \". ................................ ................................ ................................\", \" . 5 \\nReferences  ................................ ................................ ................\", \"................ ................................ ................................ ..............  5\", \" \\nStrategies for migrating incrementally  ................................ .........................\", \"....... ................................ ............................  6 \\nMigrating slice by slice  \", \"................................ ................................ ................................ .\", \"............................... ......................  6 \\nMigrating layer by layer  ...............\", \"................. ................................ ................................ ................\", \"................ ....................  6 \\nReferences  ................................ .............\", \"................... ................................ ................................ ..............\", \".................. ..............  7 \\nStrategies for migrating ASP.NET Web Forms apps  .............\", \"................... ................................ ................................ .. 7 \\nSeparate\", \" business logic and other concerns ................................ ................................\", \" ................................ ............  7 \\nImplement client behavior and web APIs  .........\", \"....................... ................................ ................................ ..........\", \"........  8 \\nConsider Blazor  ................................ ................................ ....\", \"............................ ................................ ................................ .... \", \"8 \\nSummary  ................................ ................................ ......................\", \".......... ................................ ................................ .................  8 \\nR\", \"eferences  ................................ ................................ .......................\", \"......... ................................ ................................ ..............  8 \\nDeplo\", \"yment strategies  ................................ ................................ ................\", \"................ ................................ ...........................  8 \\nCross -platform op\", \"tions  ................................ ................................ ...........................\", \"..... ................................ .....................  8 \\nCloud native development  .........\", \"....................... ................................ ................................ ..........\", \"...................... ..............  9 \\nLeverage containers  ................................ ....\", \"............................ ................................ ................................ .....\", \"......................  9 \\nSide-by-side deployment options  ................................ .......\", \"......................... ................................ ................................  9 \\nIIS \", \"on Windows  ................................ ................................ ......................\", \".......... ................................ ................................ .... 9 \\nOther options o\", \"n Windows  ................................ ................................ .......................\", \"......... ................................ .............  9  \\nii Contents  References  .............\", \"................... ................................ ................................ ..............\", \".................. ................................ ..............  9 \\nAdditional migration resource\", \"s  ................................ ................................ ...............................\", \". ................................ ....... 10 \\nOfficial documentation  .............................\", \"... ................................ ................................ ..............................\", \".. ..................  10 \\nGitHub  ................................ ................................\", \" ................................ ................................ ................................ \", \"..................  10 \\nStack Overflow  ................................ ...........................\", \"..... ................................ ................................ ............................\", \".... .. 11 \\nYouTube channels  ................................ ................................ ....\", \"............................ ................................ ............................  11 \\nTwit\", \"ter, Gitter, Slack, and other community channels  ................................ .................\", \"............... .......................  11 \\nReferences  ................................ ..........\", \"...................... ................................ ................................ ...........\", \"..................... ...........  11 \\nArchitectural differences between ASP.NET MVC and ASP.NET Cor\", \"e  ................................ ...............  12 \\nBreaking changes  .........................\", \"....... ................................ ................................ ..........................\", \"...... ................................ .. 12 \\nApp startup differences between ASP.NET MVC and ASP.N\", \"ET Core  ................................ ...............................  12 \\nASP.NET MVC Startup  \", \"................................ ................................ ................................ .\", \"............................... ....................  13 \\nASP.NET Core Startup  ....................\", \"............ ................................ ................................ .....................\", \"........... .....................  13 \\nPorting considerations  ................................ ....\", \"............................ ................................ ................................ .....\", \"..............  14 \\nReferences  ................................ ................................ ..\", \".............................. ................................ ................................ ...\", \"........  14 \\nHosting differences between ASP.NET MVC and ASP.NET Core  ............................\", \".... ................................ ....... 14 \\nReferences  ................................ .....\", \"........................... ................................ ................................ ......\", \".......................... ...........  15 \\nServe static files in ASP.NET MVC and ASP.NET Core  ....\", \"............................ ................................ ............................  15 \\nHost\", \" static files in ASP.NET MVC  ................................ ................................ ....\", \"............................ ...............................  15 \\nHost static files in ASP.NET Core \", \" ................................ ................................ ................................ \", \"................................  15 \\nReferences  ................................ .................\", \"............... ................................ ................................ ..................\", \".............. ...........  16 \\nDependency injection differences between ASP.NET MVC and ASP.NET Cor\", \"e  ................................ ...........  16 \\nDependency injection in ASP.NET Core  .........\", \"....................... ................................ ................................ ..........\", \"........  16 \\nReferences  ................................ ................................ ........\", \"........................ ................................ ................................ .........\", \"..  17 \\nCompare middleware to modules and handlers  ................................ ...............\", \"................. ................................ ...... 17 \\nASP.NET modules and handlers  ........\", \"........................ ................................ ................................ .........\", \"....................... . 17 \\nASP.NET Core middleware  ................................ ............\", \".................... ................................ ................................ ............ \", \" 17 \\nAccessing HttpContext ................................ ................................ .......\", \"......................... ................................ ...................  17 \\nReferences  ....\", \"............................ ................................ ................................ .....\", \"........................... ................................ ...........  18 \\nConfiguration differen\", \"ces between ASP.NET MVC and ASP.NET Core  ................................ .........................\", \"..  18 \\nASP.NET MVC configuration  ................................ ................................\", \" ................................ ................................ ........ 19 \\nASP.NET Core configu\", \"ration  ................................ ................................ ..........................\", \"...... ................................ ........ 19  \\niii Contents  Migrate configuration  .........\", \"....................... ................................ ................................ ..........\", \"...................... ....................  20 \\nReferences  ................................ ......\", \".......................... ................................ ................................ .......\", \"......................... ...........  21 \\nRouting differences between ASP.NET MVC and ASP.NET Core \", \" ................................ ................................ ....... 21 \\nRouting in ASP.NET MV\", \"C and Web API  ................................ ................................ ...................\", \"............. ..................  21 \\nRoute table  ................................ ................\", \"................ ................................ ................................ .................\", \"............... ......... 21 \\nRouting in .NET 7  ................................ ..................\", \".............. ................................ ................................ ...................\", \"..........  23 \\nReferences  ................................ ................................ ......\", \".......................... ................................ ................................ .......\", \"....  24 \\nLogging differences between ASP.NET MVC and ASP.NET Core  ................................\", \" ................................ ...... 25 \\nASP.NET MVC logging  ................................ .\", \"............................... ................................ ................................ ..\", \".................  25 \\nASP.NET Core logging  ................................ ......................\", \".......... ................................ ................................ ....................  2\", \"5 \\nMigrate logging  ................................ ................................ ..............\", \".................. ................................ ................................  26 \\nReferences\", \"  ................................ ................................ ................................\", \" ................................ ................................ ...........  26 \\nCompare Razor Pa\", \"ges to ASP.NET MVC  ................................ ................................ ..............\", \".................. ......................  26 \\nReferences  ................................ ........\", \"........................ ................................ ................................ .........\", \"....................... ...........  27 \\nCompare ASP.NET Web API 2 and ASP.NET Core  ...............\", \"................. ................................ ................................ ... 27 \\nReferenc\", \"es  ................................ ................................ ..............................\", \".. ................................ ................................ ...........  27 \\nCompare authen\", \"tication and authorization between ASP.NET MVC and ASP.NET Core  ........................  27 \\nAutho\", \"rization  ................................ ................................ ........................\", \"........ ................................ ................................ ..... 28 \\nReferences  ...\", \"............................. ................................ ................................ ....\", \"............................ ................................ ...........  28 \\nCompare ASP.NET Ident\", \"ity and ASP.NET Core Identity  ................................ ................................ ...\", \".....................  28 \\nMigrate from OWIN / Katana  ................................ ............\", \".................... ................................ ................................ ...... 29 \\nRe\", \"ferences  ................................ ................................ ........................\", \"........ ................................ ................................ ...........  29 \\nCompare \", \"controllers in ASP.NET MVC and Web API with controllers in ASP.NET Core  .......................... \", \" 29 \\nReferences  ................................ ................................ .................\", \"............... ................................ ................................ ...........  30 \\nC\", \"ompare Razor usage in ASP.NET MVC and ASP.NET Core  ................................ ...............\", \"................. ................  30 \\nTag Helpers  ................................ ..............\", \".................. ................................ ................................ ...............\", \"................. ......... 30 \\nRazor Pages  ................................ ......................\", \".......... ................................ ................................ .......................\", \"......... ........ 30 \\nReferences  ................................ ................................\", \" ................................ ................................ ................................ \", \"...........  31 \\nCompare ASP.NET SignalR and ASP.NET Core SignalR  ................................ \", \"................................ .........................  31 \\nFeature differences  ...............\", \"................. ................................ ................................ ................\", \"................ ..........................  31 \\nReferences  ................................ ......\", \".......................... ................................ ................................ .......\", \"......................... ...........  31 \\nCompare testing options between ASP.NET MVC and ASP.NET C\", \"ore  ................................ ............................  32  \\niv Contents  References  ..\", \".............................. ................................ ................................ ...\", \"............................. ................................ ...........  32 \\nMigrate large soluti\", \"ons to ASP.NET Core  ................................ ................................ .............\", \"................... ..... 33 \\nReferences  ................................ .........................\", \"....... ................................ ................................ ..........................\", \"...... ...............  33 \\nIdentify sequence of projects to migrate  ..............................\", \".. ................................ ................................ ....................  33 \\nUnit \", \"tests  ................................ ................................ ...........................\", \"..... ................................ ................................ ..............  37 \\nConsider\", \"ations for migrating many apps  ................................ ................................ ..\", \".............................. ...............  37 \\nSummary  ................................ ......\", \".......................... ................................ ................................ .......\", \"......................... ..............  38 \\nReferences  ................................ .........\", \"....................... ................................ ................................ ..........\", \"...................... ...........  38 \\nUnderstand and update dependencies  ........................\", \"........ ................................ ................................ ........................ \", \" 38 \\nUpdate class library dependencies ................................ ............................\", \".... ................................ ............................  38 \\nUpdate NuGet package depende\", \"ncies ................................ ................................ ............................\", \".... ....................  39 \\nMigrate ASP.NET MVC projects  ................................ ......\", \".......................... ................................ ................................ .. 40 \\n\", \"References  ................................ ................................ ......................\", \".......... ................................ ................................ ...........  40 \\nStrate\", \"gies for migrating while running in production  ................................ ...................\", \"............. ...........................  40 \\nRefactor the .NET Framework solution  ...............\", \"................. ................................ ................................ ................\", \"....  40 \\nExtract front -end assets to a CDN  ................................ .....................\", \"........... ................................ .............................  41 \\nExtract and migrate \", \"individual microservices  ................................ ................................ ........\", \"........................ ....... 41 \\nDeploy multiple versions of the app side -by-side in IIS  .....\", \"........................... ................................ ...................  41 \\nApply the Stra\", \"ngler pattern  ................................ ................................ ...................\", \"............. ................................ ......... 41 \\nMulti -targeting approaches  ..........\", \"...................... ................................ ................................ ...........\", \"..................... ......... 42 \\nSummary  ................................ ......................\", \".......... ................................ ................................ .......................\", \"......... ..............  42 \\nReferences  ................................ .........................\", \"....... ................................ ................................ ..........................\", \"...... ...........  42 \\nExample migration of eShop to ASP.NET Core  ................................\", \" ................................ ..........................  43 \\nRun ApiPort  to identify problemat\", \"ic APIs ................................ ................................ ..........................\", \"...... ....................  44 \\nUpdate project files and NuGet reference syntax  ..................\", \".............. ................................ ................................ .... 47 \\nCreate new\", \" ASP.NET Core project  ................................ ................................ ...........\", \"..................... ................................ .. 49 \\nMigrating NuGet Packages  ............\", \".................... ................................ ................................ .............\", \"................... ..........  51 \\nMigrate static files  ................................ .........\", \"....................... ................................ ................................ ..........\", \"..................  53 \\nMigrate C# files  ................................ .........................\", \"....... ................................ ................................ ..........................\", \"...... . 54 \\nMigrate views  ................................ ................................ ......\", \".......................... ................................ ................................ .......\", \".. 56 \\nMigrate app startup components  ................................ ............................\", \".... ................................ ................................ .. 58 \\nConfigure MVC  .......\", \"......................... ................................ ................................ ........\", \"........................ ................................ .. 58  \\nv Contents  Data access considerat\", \"ions  ................................ ................................ ............................\", \".... ................................ ...............  63 \\nMigrate to Entity Framework Core  .......\", \"......................... ................................ ................................ ........\", \"....................  64 \\nFix all TODO tasks  ................................ .....................\", \"........... ................................ ................................ ......................\", \".......... . 67 \\nAdditional MVC customizations  ................................ ...................\", \"............. ................................ ................................ ...... 68 \\nOther dep\", \"endencies  ................................ ................................ .......................\", \"......... ................................ ............................  69 \\nReferences  ...........\", \"..................... ................................ ................................ ............\", \".................... ................................ ...............  69 \\nMore migration scenarios \", \" ................................ ................................ ................................ \", \"................................ .................  69 \\nMigrate ASP.NET MVC 5 and WebApi 2 to ASP.NE\", \"T Core MVC  ................................ ................................ ... 69 \\nMigrate HttpRe\", \"sponseMessage to ASP.NET Core  ................................ ................................ ...\", \"...........................  70 \\nMigrate content negotiation from ASP.NET Web API to ASP.NET Core  .\", \"............................... ....................  71 \\nCustom model binding  ....................\", \"............ ................................ ................................ .....................\", \"........... ..................  71 \\nMedia formatters  ................................ .............\", \"................... ................................ ................................ ..............\", \"................  73 \\nCustom filters  ................................ .............................\", \"... ................................ ................................ ..............................\", \".. ..... 73 \\nRoute constraints  ................................ ................................ ..\", \".............................. ................................ .............................  74 \\nC\", \"ustom route handlers  ................................ ................................ ............\", \".................... ................................ ..................  75 \\nCORS support  ........\", \"........................ ................................ ................................ .........\", \"....................... ................................ .... 76 \\nCustom areas  ....................\", \"............ ................................ ................................ .....................\", \"........... ................................ ..... 77 \\nIntegration tests for ASP.NET MVC and ASP.NET\", \" Web API ................................ ................................ .............  78 \\nWCF cl\", \"ient configuration  ................................ ................................ ..............\", \".................. ................................ ...............  80 \\nReferences  ...............\", \"................. ................................ ................................ ................\", \"................ ................................ ...........  80 \\nDeployment scenarios when migrati\", \"ng to ASP.NET Core  ................................ ................................ ..... 81 \\nSpli\", \"t a large web app  ................................ ................................ ...............\", \"................. ................................ ...........................  81 \\nSummary  .......\", \"......................... ................................ ................................ ........\", \"........................ ................................ ..................  84 \\nReferences  ......\", \".......................... ................................ ................................ .......\", \"......................... ................................ ...............  85 \\nSummary: Port existi\", \"ng ASP.NET Apps to .NET 7  ................................ ................................ .......\", \"...............  86  \\n1 CHAPTER 1 | Introduction to porting apps to .NET 7  \\n CHAPTER  1 \\nIntroducti\", \"on to porting \\napps to .NET 7  \\n.NET Core and its latest version, .NET 7, represent a revolutionary \", \"step forward from .NET Framework. \\nIt offers a host of advantages over .NET Framework across the boa\", \"rd from productivity to \\nperformance, from cross -platform support to developer satisfactio n. ASP.N\", \"ET Core was even voted \\nthe most -loved web framework (tied with Svelte) in the 2021 Stack Overflow \", \"developer survey . Clearly \\nthere are strong reasons to consider migrating.  \\nEven before .NET 7 shi\", \"pped, Microsoft was clear: .NET Core is the Future of .NET . To quote this article:  \\nNew apps shoul\", \"d be built on .NET Core. .NET Core is where future investments in .NET will happen. \\nExisting apps a\", \"re safe to remain on .NET Framework which will be supported. Existing apps that want \\nto take advant\", \"age of the new features in .NET should consi der moving to .NET Core. As we plan into \\nthe future, w\", \"e will be bringing in even more capabilities to the platform.  \\nToday, .NET 7 is what new apps shoul\", \"d target, and if you\\u2019re migrating an existing app from .NET \\nFramework, .NET 7 is your ideal target \", \"framework.  \\nHowever, upgrading your app to ASP.NET Core will require some effort. That effort shoul\", \"d be \\nbalanced against business value and goals. .NET Framework apps have a long life ahead of them,\", \" with \\nsupport built into Windows for the foreseeable future. What are some of the questions you sho\", \"uld \\nconsider before deciding migration to .NET 7 is appropriate? What are the expected advantages? \", \"\\nWhat are the tradeoffs? How much effort is involved? These obvious questions are just the beginning\", \", \\nbut make for a great starti ng point as teams consider how to support their customers\\u2019 needs with\", \" \\napps today and tomorrow.  \\n\\u2022 Is migration to .NET 7 appropriate?  \\n\\u2022 When does it make sense to re\", \"main on .NET Framework?  \\n\\u2022 Should apps target ASP.NET Core 2.1 as a stepping stone?  \\n\\u2022 How should \", \"teams choose the right .NET version to target?  \\n\\u2022 What strategies are recommended for incremental m\", \"igration of large apps?  \\n\\u2022 What deployment strategies should be considered when porting to .NET 7? \", \" \\n\\u2022 Where can we find additional resources?  \\nThis introductory chapter addresses all of these quest\", \"ions and more before moving on to more \\nspecific and technical considerations in future chapters.   \", \"\\n2 CHAPTER 1 | Introduction to porting apps to .NET 7  \\n References  \\n\\u2022 2021 Stack Overflow develope\", \"r survey most loved web frameworks  \\n\\u2022 .NET Core is the Future of .NET  \\nMigration considerations  \\n\", \"The most fundamental question teams must answer when it comes to porting their apps to .NET Core \\nis\", \", should they port at all? In some cases, the best path forward is to remain on .NET Framework using\", \" \\nASP.NET MVC and/or Web API. This chapter considers reaso ns why moving to .NET Core makes sense. \\n\", \"The chapter also considers scenarios and counterpoints for staying on .NET Framework.  \\nIs migration\", \" to .NET Core appropriate?  \\nLet\\u2019s start with some of the reasons why you might want to move to .NET\", \" Core/.NET 7. There are quite \\na few, so don\\u2019t consider this list exhaustive.  \\nCross -platform supp\", \"ort  \\nApps built on .NET Core are truly cross -platform and can run on Windows, Linux, and macOS. No\", \"t only \\ncan your developers use whatever hardware they want, but you can also host your app anywhere\", \". \\nExamples range from local IIS to Azure in the cloud or from Li nux Docker containers to IoT devic\", \"es.  \\nPerformance and scalability  \\nApps built with .NET Core are running on one of the fastest tech\", \" stacks available anywhere . ASP.NET \\nMVC apps often see performance improvements on ASP.NET Core, e\", \"specially if they\\u2019re updated to \\ntake advantage of some new features available in .NET Core.  \\nCloud\", \" -native  \\nFor the above reasons and others, .NET Core apps are well -suited to running in cloud hos\", \"ting \\nenvironments. Lightweight and fast, .NET Core apps can be deployed to Azure App Services or \\nc\", \"ontainers and scaled horizontally as needed to meet immediate system d emand.  \\nMaintainable  \\nFor m\", \"any apps, while they\\u2019ve continued to meet customer and business needs, technical debt has \\naccumulat\", \"ed and maintaining the app has grown expensive. ASP.NET Core apps are more easily \\ntested than ASP.N\", \"ET MVC apps, making them easier to refactor and exten d with confidence.  \\nModular  \\nASP.NET Core is\", \" modular, using NuGet packages as a first -class part of the framework. Apps built for \\n.NET Core al\", \"l support dependency injection, making it easy to compose solutions from whatever \\nimplementations a\", \"re needed for a given environment. Building microservices with .NET Core is easier  \\n3 CHAPTER 1 | I\", \"ntroduction to porting apps to .NET 7  \\n than with ASP.NET MVC with its dependency on IIS, which ope\", \"ns up additional options to break up \\nlarge apps into smaller modules.  \\nModern  \\nStaying on a moder\", \"n, actively developed technology stack has a host of advantages. New features \\nand C# language featu\", \"res will only be added to .NET Core. The .NET Framework has had its last \\nrelease with version 4.8, \", \"and versions of C# beyond 8 won\\u2019t target  .NET Framework. While ASP.NET \\nMVC will remain supported b\", \"y Microsoft for many years, the best and brightest .NET software \\ndevelopers are likely looking to u\", \"se the more modern .NET Core framework, with all of the advantages \\nit offers (only some of which ar\", \" e summarized above). Finding developers with the skills to maintain an \\nASP.NET MVC app will start \", \"to become a challenge at some point, as will finding online training and \\ntroubleshooting assistance\", \". There probably aren\\u2019t that many new blog posts being writ ten about \\nASP.NET MVC 5, while there ar\", \"e plenty being written for .NET 7, for example.  \\nThere are many compelling reasons to consider migr\", \"ating to .NET Core, which presumably is why \\nyou\\u2019re reading this book! But let\\u2019s consider some disad\", \"vantages and reasons why it may make more \\nsense to remain on the .NET Framework.  \\nWhen is .NET Fra\", \"mework appropriate?  \\nThe biggest reason to stay on .NET Framework is when an app isn\\u2019t under active\", \" development and \\nwouldn\\u2019t benefit substantially from the advantages listed above. In that case, the\", \"re probably isn\\u2019t a \\ngood business case to incur the cost of porting the app. If  your app might ben\", \"efit from the \\nadvantages .NET Core offers, you may still need to stay on .NET Framework if you need\", \" certain \\ntechnologies that are unavailable on .NET Core. There are some .NET technologies that are \", \"unavailable \\non .NET Core , including AppDomains, Remoting, Code Access Security (CAS), Security Tra\", \"nsparency, \\nand System.EnterpriseServices. A brief summary of these technologies and their alternati\", \"ves is \\nincluded here. For more detailed guidance, see the documentation.  \\nApplication domains  \\nAp\", \"plication domains (AppDomains) isolate apps from one another. AppDomains require runtime \\nsupport an\", \"d can be expensive. Creating additional app domains isn\\u2019t supported, and there are no \\nplans to add \", \"this capability to .NET Core in the future. For code iso lation, use separate processes or \\ncontaine\", \"rs as an alternative. Some customers use AppDomains as a way of unloading assemblies. In \\n.NET Core \", \"AssemblyLoadContext  provides an alternative way to unload assemblies.  \\nWCF  \\n.NET Core and .NET 5+\", \" support WCF clients. Server -side WCF is possible through CoreWCF , which is \\nofficially supported \", \"by Microsoft as of April 2022. Apps that require server -side WCF functionality can \\nalso consider a\", \" different communication technology (such as gRPC or REST) as part of a migration.  \\nThere is a WCF \", \"client port available from the .NET Foundation . It\\u2019s entirely open source, cross \\nplatform, and sup\", \"ported by Microsoft.  \\nTo learn more about migrating from WCF to gRPC, consult the gRPC for WCF Deve\", \"lopers  ebook.   \\n4 CHAPTER 1 | Introduction to porting apps to .NET 7  \\n Remoting  \\n.NET Remoting w\", \"as identified as a problematic architecture. It\\u2019s used for cross -AppDomain \\ncommunication, which is\", \" no longer supported. Also, Remoting requires runtime support, which is \\nexpensive to maintain. For \", \"these reasons, .NET Remoting isn\\u2019t supported  on .NET Core, and the \\nproduct team doesn\\u2019t plan on ad\", \"ding support for it in the future. There are several alternative \\nmessaging strategies and implement\", \"ations you can use to replace remoting in your .NET Core apps.  \\nCode Access Security (CAS) and Secu\", \"rity Transparency  \\nNeither of these technologies are supported by .NET Core. Instead, the recommend\", \"ation is to use \\nsecurity boundaries provided by the operating system. For example, virtualization, \", \"containers, or user \\naccounts. Run processes with the minimal set of privilege s necessary.  \\nRefere\", \"nces  \\n.NET Framework Technologies Unavailable on .NET Core  \\nMigrate to ASP.NET Core 2.1  \\nASP.NET \", \"Core 2.1 is an interesting release because it\\u2019s the most recently supported ASP.NET Core \\nrelease th\", \"at supported both .NET Core and .NET Framework runtimes. As such, it may offer an easier \\nupgrade pa\", \"th for some apps when compared to upgrading all pa rts of the app to .NET Core/.NET 7 at \\nonce. Alth\", \"ough support for .NET Core 2.1 ended in August 2021, it may make sense as an interim step \\nfor some \", \"apps. Also, support for ASP.NET Core 2.1 running on .NET Framework will continue for as \\nlong as its\", \" underlying .NET Framework is supported . A complete list of currently supported ASP.NET \\nCore 2.1 p\", \"ackages  is available for reference.  \\nShould apps run on .NET Framework with ASP.NET Core 2.1  \\nASP\", \".NET Core 2.2 and earlier supported both .NET Core and .NET Framework runtimes. Does it make \\nsense \", \"to migrate some or all of an app to ASP.NET Core 2.1 as a stepping stone, before porting over \\ncompl\", \"etely to .NET Core? Apps, or subsets of apps, could see their front -end ASP.NET logic ported to \\nus\", \"e ASP.NET Core, while still consuming .NET Framework libraries for business logic and infrastructure\", \" \\nconsumption. This approach may make sense when there \\u2019s a relatively thin UI layer without much \\nb\", \"usiness logic, and a much larger set of functionality in class libraries.  \\nThe main benefit of port\", \"ing just the front -end web layer to ASP.NET Core 2.1 is that the existing .NET \\nclass libraries can\", \" remain as is during the initial migration. They may be in continued use by other \\n.NET apps or simp\", \"ly don\\u2019t need to be in scope for th e first iteration of a planned full migration to .NET \\nCore. Red\", \"ucing the scope of the initial migration for large apps helps provide incremental goals that \\nact as\", \" stepping stones toward the desired end state, which is often a complete port to .NET Core.  \\nIf you\", \" have an existing app that may use this strategy, some things you can do today to help prepare \\nfor \", \"the process are to move as much business logic, data access, and other non -UI logic out of the \\nASP\", \".NET projects and into separate class libraries as po ssible. It will also help if you have automate\", \"d  \\n5 CHAPTER 1 | Introduction to porting apps to .NET 7  \\n test coverage of your system, so that yo\", \"u can verify behavior remains consistent before and after the \\nmigration.  \\nIf your app is so large \", \"that you can\\u2019t migrate the entire web app at once, and you need to be able to \\ndeploy the new ASP.NE\", \"T Core app side -by-side with the existing ASP.NET app, there are deployment \\nstrategies that can be\", \" used to achieve this. These are co vered in Chapter 5: Deployment Scenarios . \\nKeep in mind that AS\", \"P.NET Core 2.1 was the last LTS release of .NET Core that supported running on \\n.NET Framework and c\", \"onsuming .NET Framework libraries. Although the release is now unsupported \\non .NET Core, it continu\", \"es to be supported for use with .NET F ramework. It will remain supported for \\nas long as the specif\", \"ic .NET Framework version is supported. For more information, see ASP.NET Core \\n2.1 on .NET Framewor\", \"k . \\nReferences  \\nMigrating from ASP.NET to ASP.NET Core 2.1  ASP.NET Core 2.1 on .NET Framework  AS\", \"P.NET Core 2.1 \\nSupported Packages  \\nChoose the right .NET Core version  \\nThe largest consideration \", \"for most organizations when choosing which version of .NET to target is the \\nsupport lifecycle. Long\", \" Term Support (LTS) releases ship less frequently but have a longer support \\nwindow than Standard Te\", \"rm Support (STS) releases. Curre ntly, LTS releases are scheduled to ship \\nevery other year. Custome\", \"rs can choose which releases to target, and can install different releases of \\n.NET side by side on \", \"the same machine. LTS releases will receive only critical and compatible fixes \\nthroughout t heir li\", \"fecycle. STS releases will receive these same fixes and will also be updated with \\ncompatible innova\", \"tions and features. LTS releases are supported for three years after their initial \\nrelease. STS rel\", \"eases are supported for six months after a subseque nt STS or LTS release.  \\n.NET 7 is the latest ST\", \"S release; .NET 6 is the latest LTS release.  \\nCustomers looking to migrate a large .NET Framework a\", \"pp to .NET today may be looking for a stable \\ndestination, given that they haven\\u2019t already made the \", \"move to an earlier version of .NET Core. In this \\ncase, the best .NET version to target for the migr\", \"ation  is .NET 6, which is the most recent LTS version. \\nWhile support for .NET Core 3.1 ended in De\", \"cember 2022, support for .NET 6 will continue until \\nNovember 2024.  \\nOther customers may want to en\", \"sure they\\u2019re upgrading to the latest supported version, so that post -\\nmigration they\\u2019re not already\", \" behind a version. These customers will want to target .NET 7 for the \\nmigration.  \\nIn either case, \", \"there is very little difference in the migration process. This book assumes .NET \\nFramework apps wil\", \"l be upgraded to .NET 7.  \\nReferences  \\n.NET and .NET Core Support Policy   \\n6 CHAPTER 1 | Introduct\", \"ion to porting apps to .NET 7  \\n Strategies for migrating incrementally  \\nThe biggest challenge with\", \" migrating any large app is determining how to break the process into \\nsmaller tasks. There are seve\", \"ral strategies that can be applied for this purpose, including breaking the \\napp into horizontal lay\", \"ers such as UI, data access, bus iness logic, or breaking up the app into separate, \\nsmaller apps. A\", \"nother strategy is to upgrade some or all of the app to different framework versions on \\nthe way to \", \"a recent .NET Core release. One approach you could use is to migrate vertical slices  of the \\napp, r\", \"ather than attempting to migrate one horizontal layer at a time. Let\\u2019s consider each of these \\ndiffe\", \"rent approaches.  \\nMigrating slice by slice  \\nOne successful approach to migrating is to identify ve\", \"rtical slices of functionality and migrate them to \\nthe target platform one by one. The first step i\", \"s to create a new ASP.NET Core 7 app. Next, identify the \\nindividual page or API endpoint that will \", \"be m igrated first. Build out just the necessary functionality to \\nsupport this one route in the new\", \" ASP.NET Core app. Then use HTTP rewriting and/or a reverse proxy \\nto start sending requests for the\", \"se pages or endpoints to the new app rather than the ASP.NET ap p. \\nThis approach is well -suited to\", \" API projects, but can also work for many MVC apps.  \\nWhen migrating slice by slice, the entire stac\", \"k of the individual API endpoint or requested route is \\nrecreated in the new project or solution. Th\", \"e very first such slice typically requires the most effort, \\nsince it will typically need several pr\", \"ojects to be  created and decisions to be made about data access \\nand solution organization. Once th\", \"e first slice\\u2019s functionality mirrors the existing app\\u2019s, it can be \\ndeployed and the existing app c\", \"an redirect to it or simply be removed. This approach is then repeated \\nuntil the entire app has bee\", \"n ported to the new structure.  \\nSome specific guidance on how to follow this strategy using IIS is \", \"covered in Chapter 5, Deployment \\nScenarios . \\nMigrating layer by layer  \\nConsider the challenge of \", \"migrating a large ASP.NET 4.5 app. One approach is to migrate the entire \\napp directly from .NET Fra\", \"mework 4.5 to .NET 7. However, this approach needs to account for every \\nbreaking change between the\", \" two frameworks and versions, wh ich are substantial. Performing this \\nwork on one project at a time\", \" provides a set of stepping stones so that the entire solution doesn\\u2019t \\nneed to be moved at once.  \\n\", \"One piece of the .NET ecosystem that helps with interoperability between different .NET frameworks i\", \"s \\n.NET Standard . .NET Standard allows libraries to build against an agreed upon set of common APIs\", \", \\nensuring they can be used in any .NET app. .NET Standard 2.0 is notable because it covers most ba\", \"se \\nclass library functionality used by most .NET Framework and .NET Core a pps. Unfortunately, the \", \"\\nearliest version of .NET with support for .NET Standard 2.0 is .NET Framework 4.6.1, and there are \", \"a \\nnumber of updates in .NET Framework 4.8 that make it a compelling choice for initial upgrades.  \\n\", \"One approach to incrementally upgrade a .NET Framework 4.5 system layer -by-layer is to first update\", \" \\nits class library dependencies to .NET Framework 4.8. Then, modify these libraries to be .NET Stan\", \"dard \\nclass libraries. Use multi -targeting and conditional compilation, if necessary. This step can\", \" be helpful  \\n7 CHAPTER 1 | Introduction to porting apps to .NET 7  \\n in scenarios where app depende\", \"ncies require .NET Framework and cannot easily be ported directly to \\nuse .NET Standard and .NET Cor\", \"e. Since .NET Framework libraries can be consumed by ASP.NET Core \\n2.1 apps, the next step is to mig\", \"rate some or all of the web functionality of the app to ASP.NET Core \\n2.1 (as described in the previ\", \"ous chapter ). This is a \\u201cbottom up\\u201d approach, starting with low level class \\nlibrary dependencies a\", \"nd working up to the web app entry point.  \\nOnce the app is running on ASP.NET Core 2.1, migrating i\", \"t to .NET 7 in isolation is relatively \\nstraightforward. The most likely challenge during this step \", \"is updating incompatible dependencies to \\nsupport .NET Core and possibly higher versions of .NET Sta\", \"nd ard. For apps that don\\u2019t have \\nproblematic dependencies on .NET Framework -only libraries, there\\u2019\", \"s little reason to upgrade to \\nASP.NET Core 2.1. Porting directly to ASP.NET Core 7 makes more sense\", \" and requires less effort.  \\n.NET 7 is the latest version of .NET and will be supported until six mo\", \"nths after the next STS or LTS \\nrelease (scheduled for November 2023) - so most likely support will \", \"last at least until May 2024. Many \\nteams looking to migrate today will choose to upgra de to .NET 7\", \".  \\nInstead of a \\u201cbottom up\\u201d approach, another alternative is to start with the web app (or even the\", \" entire \\nsolution) and use an automated tool to assist with the upgrade. The .NET Upgrade Assistant \", \"tool  can \\nbe used to help upgrade .NET Framework apps to .NET Core / .NET 7. It automates many of t\", \"he \\ncommon tasks related to upgrading apps, such as modifying project file format, setting appropria\", \"te \\ntarget frameworks, updating NuGet dependencies, and more.  \\nReferences  \\n\\u2022 What is .NET Standard\", \"?  \\n\\u2022 Migrate from ASP.NET Core 6.0 to 7.0  \\n\\u2022 Announcing .NET 6 - The Fastest .NET Yet  \\n\\u2022 Introduc\", \"ing .NET 5  \\n\\u2022 Migrate from ASP.NET Core 3.1 to 6.0 LTS  \\n\\u2022 .NET Upgrade Assistant tool  \\nStrategies\", \" for migrating ASP.NET Web Forms apps  \\nThis book offers guidance for migrating large ASP.NET MVC an\", \"d Web API apps to .NET Core. Some of \\nthese ASP.NET apps may also include Web Forms ( .aspx ) pages \", \"that must be addressed. ASP.NET Web \\nForms isn\\u2019t supported in ASP.NET Core (nor are ASP.NET Web Page\", \"s). Typically, the functionality of \\nthese pages must be rewritten when porting to ASP.NET Core. The\", \"re are, however, some strategies \\nyou can apply bef ore or during such migration to help reduce the \", \"overall effort required.  \\nWeb Forms will continue to be supported for quite some time. One option m\", \"ay be to keep this \\nfunctionality in an ASP.NET 4.x app.  \\nSeparate business logic and other concern\", \"s  \\nThe less code in your ASP.NET Web Forms pages, the better. When possible, keep business logic an\", \"d \\nother concerns like data access in separate classes, ideally in separate class libraries. These c\", \"lass \\nlibraries can be ported to .NET Standard and consumed by  any ASP.NET Core app.   \\n8 CHAPTER 1\", \" | Introduction to porting apps to .NET 7  \\n Implement client behavior and web APIs  \\nConsider the c\", \"hoice between implementing logic in Web Forms or in the browser with the help of API \\ncalls. Favor t\", \"he latter. Migrating APIs to ASP.NET Core is supported. Client -side behavior should be \\nindependent\", \" of the server -side stack your app is using. Using this approach has the added benefit of \\nprovidin\", \"g a more responsive user experience.  \\nConsider Blazor  \\nBlazor lets you build interactive web UIs w\", \"ith C# instead of JavaScript. It can run on the server or in \\nthe browser using WebAssembly. ASP.NET\", \" Web Forms apps may be ported page -by-page to Blazor \\napps. For more information on porting Web For\", \"ms apps to Blazo r, see Blazor for ASP.NET Web Forms \\nDevelopers . In addition, many Web Forms contr\", \"ols have been ported to Blazor as part of an open -\\nsource community project, Blazor Web Forms Compo\", \"nents . With these components, you can more \\neasily port Web Forms pages to Blazor even if they use \", \"the built -in Web Forms controls.  \\nSummary  \\nMigrating directly from ASP.NET Web Forms to ASP.NET C\", \"ore isn\\u2019t supported. However, there are \\nstrategies to make moving to ASP.NET Core easier. You can m\", \"igrate your Web Forms functionality to \\nASP.NET Core successfully by:  \\n\\u2022 Keeping non -web functiona\", \"lity out of your projects.  \\n\\u2022 Using web APIs wherever possible.  \\n\\u2022 Considering Blazor as an option\", \" for a more modern UI.  \\nReferences  \\n\\u2022 Free e -book: Blazor for ASP.NET Web Forms Developers  \\n\\u2022 Bl\", \"azor Web Forms Components (Community Project)  \\nDeployment strategies  \\nOne consideration as you pla\", \"n the migration of your large ASP.NET app to ASP.NET Core is how you\\u2019ll \\ndeploy the new app. With AS\", \"P.NET, deployment options were limited to IIS on Windows. With \\nASP.NET Core, a much wider array of \", \"deployment options is availabl e. \\nCross -platform options  \\nBecause .NET Core runs on Linux, you\\u2019ll\", \" find some hosting options available that weren\\u2019t a \\nconsideration previously. Linux -based hosting \", \"may be preferable for the following reasons:  \\n\\u2022 Your organization has infrastructure or expertise. \", \" \\n\\u2022 Hosting providers offer attractive features or pricing for Linux -based hosting.  \\n.NET Core ope\", \"ns the door to these options.   \\n9 CHAPTER 1 | Introduction to porting apps to .NET 7  \\n Cloud nativ\", \"e development  \\nMost organizations today are using cloud platforms for at least some of their softwa\", \"re capabilities. \\nWith an app migration to .NET Core, it\\u2019s a good time to consider whether the app s\", \"hould be \\npurposefully written with cloud hosting in mind. Such cloud native  apps are better able t\", \"o apply cloud \\ncapabilities like serverless, microservices, and can be less concerned with the low -\", \"level details of how \\nand where they may be deployed.  \\nLearn more about cloud native app developmen\", \"t in this free e -book, Architecting Cloud Native .NET \\nApplications for Azure . \\nLeverage container\", \"s  \\nModern apps often leverage containers as a means of reducing variation between hosting \\nenvironm\", \"ents. By deploying an app to a particular container, the container -hosted app will run the \\nsame wh\", \"ether it\\u2019s running on a developer\\u2019s laptop or in production. As  part of a migration to .NET \\nCore, \", \"it may make sense to consider whether the app would benefit from deployment via container, \\neither a\", \"s a full monolith or broken up into multiple smaller containerized apps.  \\nSide-by-side deployment o\", \"ptions  \\nMigrating large .NET Framework apps to .NET Core often requires a substantial effort. Most \", \"\\norganizations will want to be able to break this effort up in some fashion, so that pieces of the a\", \"pp \\ncan be migrated and deployed in production before the entire mi gration is complete. Running bot\", \"h \\nthe original ASP.NET app and its newly -migrated ASP.NET Core sub -app(s) side by side is a frequ\", \"ently \\ncited goal. This can be achieved through a number of mechanisms including leveraging IIS rout\", \"ing, \\nwhich is covered in chapter 5 . Other options include leveraging app gateways or cloud design \", \"\\npatterns like backends for frontends  to manage sets of ASP.NET Web APIs and ASP.NET Core API \\nendp\", \"oints.  \\nIIS on Windows  \\nYou can continue hosting your apps on IIS running on Windows. This is a fi\", \"ne option for customers \\nwho want to take advantage of ASP.NET Core features without changing their \", \"current deployment \\nmodel. While moving to ASP.NET Core provides more options in ter ms of how and w\", \"here to deploy \\nyour apps, it doesn\\u2019t require that you change from the status quo of using the prove\", \"n combination of \\nIIS on Windows.  \\nOther options on Windows  \\nYou can host apps side -by-side apps \", \"on Windows using any combination of Kestrel, HTTP.sys, and IIS \\nhosts, in addition to Docker contain\", \"ers, if needed. If your app requires a combination of Windows and \\nLinux services, hosting on a Wind\", \"ows server with WSL and/or Linux Docker containers provides a \\nsingle server solution to hosting all\", \" parts of the app.  \\nReferences  \\n\\u2022 Host and deploy ASP.NET Core   \\n10 CHAPTER 1 | Introduction to p\", \"orting apps to .NET 7  \\n \\u2022 Host ASP.NET Core on Windows with IIS  \\n\\u2022 Troubleshooting ASP.NET Core on\", \" Azure App Service and IIS  \\nAdditional migration resources  \\nAs you\\u2019re planning and executing your \", \"migration from ASP.NET MVC and/or Web API to ASP.NET \\nCore, there are a number of resources availabl\", \"e to help beyond this book. Make a note of these and \\nleverage them where appropriate to help you ov\", \"ercome obstacles you  encounter on your migration \\njourney.  \\nOfficial documentation  \\nThe official \", \"documentation website, learn.microsoft.com , has the most up -to-date information \\navailable about v\", \"ersions, frameworks, breaking changes, and support options. You\\u2019ll find many links in \\nthis book to \", \"docs articles, but for any problem you\\u2019re facing it\\u2019s often worth at least doing a quick \\nsearch of \", \"the  docs to see if there is already information covering the issue and offering a solution or \\nwork\", \"around.  \\nGitHub  \\nBecause .NET Core is an open -source project, many issues are discovered, reporte\", \"d, discussed, and \\nfixed on GitHub. Microsoft has several GitHub organizations in which you\\u2019ll find \", \"repositories that may \\nbe helpful. A partial list of these organizations and s ome of their public r\", \"epositories are listed below:  \\n\\u2022 Microsoft  \\n\\u2013 ASP.NET API Versioning  \\n\\u2022 dotnet  \\n\\u2013 ASP.NET Core  \", \"\\n\\u2013 .NET Runtime  \\n\\u2013 Entity Framework Core  \\n\\u2013 C# Language  \\n\\u2013 Docs  \\n\\u2013 Docs Samples  \\n\\u2013 Try Convert \", \" \\n\\u2013 .NET Upgrade Assistant tool  \\n\\u2022 .NET Architecture Reference Apps  \\n\\u2013 eShopModernizing  \\n\\u2013 eShopO\", \"nWeb  \\n\\u2013 eShopOnContainers  \\nIf you run into problems with your migration, these GitHub repositories\", \" are a good place to report \\nthem. The product teams watch the issues and typically respond quickly \", \"to bug reports (though \\u201chow \\nto\\u201d questions may be more appropriately directed to Stack Overflow).   \", \"\\n11 CHAPTER 1 | Introduction to porting apps to .NET 7  \\n Stack Overflow  \\nStack Overflow  has a wea\", \"lth of information in the form of previous questions asked and answers \\ngiven, with the most helpful\", \" answers listed first and marked if they solved the problem. In addition to \\nsearching for an existi\", \"ng solution to a problem you may encounter, you can of course also ask a \\nquestion yourself and hope\", \" for some response from the .NET community. Don\\u2019t forget you can narrow \\ndown a search by using tags\", \", and remember to use appropriate tags when you ask questions to \\nmaximize the chances of someone wi\", \"th the experience needed noticing your question.  \\nYouTube channels  \\nYouTube has a huge amount of .\", \"NET and .NET Core video content, which may include useful tutorials \\nor walkthroughs covering any sc\", \"enario you may encounter. Consider searching it separately if your \\nother efforts to find help onlin\", \"e come up short. Here are a few good places to get started:  \\n\\u2022 dotnet  \\n\\u2022 Visual Studio  \\nTwitter, \", \"Gitter, Slack, and other community channels  \\nYou\\u2019ll find many other ways to connect with .NET devel\", \"opers on the .NET Community page . You can \\nalso join the DotNetEvolution Discord server . Additiona\", \"lly, many product teams and team members \\nare on Twitter as well as in various other communities. Yo\", \"u can follow and communicate with the \\nauthor of this book on Twitter  as well.  \\nReferences  \\n\\u2022 Ove\", \"rview of porting from .NET Framework to .NET Core  \\n\\u2022 .NET Upgrade Assistant tool  \\n\\u2022 Migrate from A\", \"SP.NET to ASP.NET Core  \\n\\u2022 .NET Community Resources   \\n12 CHAPTER 2 | Architectural differences betw\", \"een ASP.NET MVC and ASP.NET Core  \\n CHAPTER  2 \\nArchitectural differences \\nbetween ASP.NET MVC \\nand \", \"ASP.NET Core  \\nThere are many architectural differences between ASP.NET MVC on .NET Framework and AS\", \"P.NET \\nCore. It\\u2019s important to have a broad understanding of these differences as teams evaluate the\", \" work \\ninvolved in porting their ASP.NET MVC apps to ASP.NET Core. This c hapter looks at each of th\", \"e ways \\nin which ASP.NET Core differs substantially from ASP.NET MVC.  \\nBreaking changes  \\n.NET Core\", \" is a cross -platform rewrite of .NET Framework. There are many breaking changes between \\nthe two fr\", \"ameworks . The following sections identify specific differences between how ASP.NET MVC \\nand ASP.NET\", \" Core apps are designed and developed. Take care to also examine the documentation to \\ndetermine whi\", \"ch framework libraries you\\u2019re using that may need to change. In man y cases, a \\nreplacement NuGet pa\", \"ckage exists to fill in any gaps left between .NET Framework and .NET Core. In \\nrare cases, you may \", \"need to find a third -party solution or implement new custom code to address \\nincompatibilities.  \\nA\", \"pp startup differences between ASP.NET MVC and \\nASP.NET Core  \\nASP.NET MVC apps lived entirely withi\", \"n Internet Information Server (IIS), the primary web server \\navailable on Windows operating systems.\", \" Unlike ASP.NET MVC, ASP.NET Core apps are executable \\napps. You can run them from the command line,\", \" using dotnet run. Th ey have an entry point method \\nlike all C# programs, typically public static v\", \"oid Main() or a similar variation (perhaps with arguments \\nor async support). This is perhaps the bi\", \"ggest architectural difference between ASP.NET Core and \\nASP.NET MVC, and is one of several differen\", \"ces that allows ASP.NET Core to run on non -Windows \\nsystems.   \\n13 CHAPTER 2 | Architectural differ\", \"ences between ASP.NET MVC and ASP.NET Core  \\n ASP.NET MVC Startup  \\nHosted within IIS, ASP.NET apps \", \"rely on IIS to instantiate certain objects and call certain methods \\nwhen a request arrives. ASP.NET\", \" creates an instance of the Global.asax  file\\u2019s class, which derives from \\nHttpApplication. When the\", \" first request is received, before handling the request itself, ASP.NET calls \\nthe Application_Start\", \" method in the Global.asax  file\\u2019s class. Any logic that needs to run when the \\nASP.NET MVC app begi\", \"ns can be added to this method.  \\nMany NuGet packages for ASP.NET MVC and Web API use the WebActivat\", \"or  package to let them run \\nsome code during app startup. By convention, this code would typically \", \"be added to an App_Start  \\nfolder and would be configured via attribute to run either immediately be\", \"fore or just after \\nApplication_Start.  \\nIt\\u2019s also possible to use the Open Web Interface for .NET (\", \"OWIN) and Project Katana with ASP.NET \\nMVC . When doing so, the app will include a Startup.cs  file \", \"that is responsible for setting up request \\nmiddleware in a way that\\u2019s very similar to how ASP.NET C\", \"ore behaves.  \\nIf you need to run code when your ASP.NET MVC app starts up, it will typically use on\", \"e of these \\napproaches.  \\nASP.NET Core Startup  \\nAs noted previously, ASP.NET Core apps are standalo\", \"ne programs. As such, they typically include a \\nProgram.cs  file containing the entry point for the \", \"app. A typical example of this file is shown in Figure \\n2-1. Notice that in .NET 7, this file is str\", \"eamlined by the use of implicit using statements and top -level \\nstatements, eliminating the need fo\", \"r a lot of \\u201cboiler  plate\\u201d code.  \\nvar builder = WebApplication .CreateBuilder (args); \\n \\n// Add ser\", \"vices to the container.  \\nbuilder.Services .AddRazorPages (); \\n \\nvar app = builder.Build(); \\n \\n// Co\", \"nfigure the HTTP request pipeline.  \\nif (!app.Environment .IsDevelopment ()) \\n{ \\n    app.UseExceptio\", \"nHandler (\\\"/Error\\\" ); \\n    // The default HSTS value is 30 days. You may want to change this for pro\", \"duction \\nscenarios, see https://aka.ms/aspnetcore -hsts. \\n    app.UseHsts(); \\n} \\n \\napp.UseHttpsRedir\", \"ection (); \\napp.UseStaticFiles (); \\n \\napp.UseRouting (); \\n \\napp.UseAuthorization (); \\n \\napp.MapRazor\", \"Pages (); \\n \\napp.Run(); \\nFigure 2 -1. A typical ASP.NET Core Program.cs  file.  \\n14 CHAPTER 2 | Arch\", \"itectural differences between ASP.NET MVC and ASP.NET Core  \\n The code shown in Figure 2 -1 uses a b\", \"uilder to configure the host and its services. Then, it creates the \\nrequest pipeline for the app, w\", \"hich controls how every request to the app is handled.  \\nPrevious versions of .NET would use a separ\", \"ate Startup.cs  file, referenced by Program.cs . This approach \\nis still supported in .NET 7, but is\", \" no longer the default approach.  \\nIn addition to code related to configuring the app\\u2019s services and\", \" request pipeline, apps may have \\nother code that must run when the app begins. Such code is typical\", \"ly placed in Program.cs  or \\nregistered as an IHostedService, which will be started by the generic h\", \"ost  when the app starts.  \\nThe IHostedService interface just exposes two methods, StartAsync and St\", \"opAsync. You register the \\ninterface when configuring the app\\u2019s services and the host does the rest,\", \" calling the StartAsync \\nmethod before the app starts up.  \\nPorting considerations  \\nTeams looking t\", \"o migrate their apps from ASP.NET MVC to ASP.NET Core need to identify what code \\nis being run when \", \"their app starts up and determine the appropriate location for such code in their \\nASP.NET Core app.\", \" For custom code needed to run when the app  starts up, especially async code, the \\nrecommended appr\", \"oach is typically to put such code into IHostedService implementations.  \\nReferences  \\n\\u2022 ASP.NET App\", \"lication Life Cycle Overview for IIS 7  \\n\\u2022 ASP.NET Application Life Cycle Overview for IIS 5 and 6  \", \"\\n\\u2022 Getting Started with OWIN and Katana  \\n\\u2022 WebActivator  \\n\\u2022 App Startup in ASP.NET Core  \\n\\u2022 .NET Ge\", \"neric Host in ASP.NET Core  \\n\\u2022 IHostedService  \\nHosting differences between ASP.NET MVC and \\nASP.NET\", \" Core  \\nASP.NET MVC apps are hosted in IIS, and may rely on IIS configuration for their behavior. Th\", \"is often \\nincludes IIS modules . As part of reviewing an app to prepare to port it from ASP.NET MVC \", \"to ASP.NET \\nCore, teams should identify which modules, if any, they\\u2019re using from the list of IIS Mo\", \"dules installed \\non their server.  \\nASP.NET Core apps can run on a number of different servers . The\", \" default cross platform server, \\nKestrel, is a good default choice. Apps running in Kestrel can be h\", \"osted by IIS, running in a separate \\nprocess. On Windows, apps can also run in process on IIS or usi\", \"ng HTTP.sys. Kestrel is generally \\nrecommended for bes t performance. HTTP.sys can be used in scenar\", \"ios where the app is exposed to \\nthe Internet and required capabilities are supported by HTTP.sys bu\", \"t not Kestrel.   \\n15 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core  \\n K\", \"estrel does not have an equivalent to IIS modules (though apps hosted in IIS can still take advantag\", \"e \\nof IIS modules). To achieve equivalent behavior, middleware  configured in the ASP.NET Core app i\", \"tself \\nis typically used.  \\nReferences  \\n\\u2022 IIS Modules  \\n\\u2022 ASP.NET Core Middleware  \\n\\u2022 ASP.NET Core \", \"Servers  \\nServe static files in ASP.NET MVC and ASP.NET Core  \\nMost web apps involve a combination o\", \"f server -side logic and static files that must be sent to the \\nclient as -is. How should your migra\", \"tion from ASP.NET MVC to ASP.NET Core handle serving static \\nfiles?  \\nHost static files in ASP.NET M\", \"VC  \\nASP.NET MVC apps, hosted by IIS, typically host static files directly from the app. ASP.NET MVC\", \" \\nsupports placing static files side by side with files that should be kept private on the server. I\", \"IS and \\nASP.NET require explicitly restricting certain files or  file extensions from being served f\", \"rom the folder \\nin which an ASP.NET app is hosted.  \\nFor many static files, using a content delivery\", \" network (CDN) is a good practice. Static content hosting  \\nallows better performance while reducing\", \" load and bandwidth from app servers.  \\nHost static files in ASP.NET Core  \\nIt may be surprising, bu\", \"t ASP.NET Core doesn\\u2019t have built -in support for static files. This feature that \\nhas always existe\", \"d as just a part of ASP.NET, enabled by IIS, isn\\u2019t intrinsic to ASP.NET Core or its \\nKestrel web ser\", \"ver. To serve static files from an ASP.NET Core app, you must configure static files \\nmiddleware . \\n\", \"With static files middleware configured, an ASP.NET Core app will serve all files located in a certa\", \"in \\nfolder (typically /wwwroot ). No other files in the app or project folder are at risk of being a\", \"ccidentally \\nexposed by the server. No special restrictions based on file names or extensions need t\", \"o be \\nconfigured, as is the case with IIS. Instead, developers explicitly choose to expos e files pu\", \"blicly when \\nthey place them in the wwwroot  folder. By default, files outside of this folder aren\\u2019t\", \" shared.  \\nBecause support for static files uses middleware, any other middleware can be applied as \", \"part of the \\nsame request pipeline. Examples of middleware include authentication, caching, and comp\", \"ression.  \\nOf course, CDNs remain a good choice for ASP.NET Core apps for all the same reasons they\\u2019\", \"re used in \\nASP.NET MVC apps. As part of preparing to migrate to .NET Core, if there are benefits yo\", \"ur app could \\nrealize from using a CDN, it would be good to move stat ic files to a CDN before migra\", \"ting to .NET \\nCore. Doing so reduces the migration effort\\u2019s overall scope for static assets.   \\n16 C\", \"HAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core  \\n References  \\n\\u2022 Static c\", \"ontent hosting  \\n\\u2022 Static files in ASP.NET Core  \\nDependency injection differences between ASP.NET \\n\", \"MVC and ASP.NET Core  \\nAlthough dependency injection (DI) isn\\u2019t built into ASP.NET MVC or Web API, m\", \"any apps enable it by \\nadding a NuGet package with an inversion of control (IOC) container. These ar\", \"e sometimes referred to \\nas DI containers, for dependency injection (or inversion ). Some of the mos\", \"t popular containers used in \\nASP.NET MVC apps include:  \\n\\u2022 Autofac  \\n\\u2022 Unity  \\n\\u2022 Ninject  \\n\\u2022 Struct\", \"ureMap  (deprecated)  \\n\\u2022 Castle Windsor  \\nIf your ASP.NET MVC app isn\\u2019t using DI, you will probably \", \"want to investigate the built -in support for \\nDI in ASP.NET Core. DI promotes loose coupling of mod\", \"ules in your app and enables better testability \\nand adherence to principles like SOLID . \\nIf your a\", \"pp does use DI, then probably your best course of action is to see if the container you\\u2019re \\nusing su\", \"pports ASP.NET Core. If so, you may be able to continue using it and your custom \\nconfiguration rule\", \"s describing your type mappings and lifetimes.  \\nEither way, you should consider using the built -in\", \" support for DI that ships with ASP.NET Core, as it \\nmay meet your app\\u2019s needs.  \\nDependency injecti\", \"on in ASP.NET Core  \\nASP.NET Core assumes apps will use DI. It\\u2019s not just built into the framework, \", \"but is required in order \\nto bring support for framework features into your ASP.NET Core apps. In ap\", \"p startup, calls are made \\nto configure services using the builder.Services pro perty of the web hos\", \"t builder. This property works \\nwith the application\\u2019s DI container (service collection/service prov\", \"ider) and is used to create and inject \\nservice dependencies within the app. Built -in ASP.NET Core \", \"features like Entity Framework Core, \\nIdentity, and even MVC are brought into the app by configuring\", \" them as services during application \\nstartup.  \\nIn addition to using the default implementation, ap\", \"ps can still use custom containers. The \\ndocumentation covers how to replace the default service con\", \"tainer . \\nDI is fundamental to ASP.NET Core. If your team isn\\u2019t already well -versed in this practic\", \"e, you\\u2019ll want \\nto understand it before porting your app.   \\n17 CHAPTER 2 | Architectural difference\", \"s between ASP.NET MVC and ASP.NET Core  \\n References  \\n\\u2022 Dependency Injection in .NET  \\n\\u2022 Dependency\", \" Injection in ASP.NET Core  \\nCompare middleware to modules and handlers  \\nIf your existing ASP.NET M\", \"VC or Web API app uses OWIN/Katana, you\\u2019re most likely already familiar \\nwith the concept of middlew\", \"are and porting it to ASP.NET Core should be fairly straightforward. \\nHowever, most ASP.NET apps rel\", \"y on HTTP modules and HTTP handl ers instead of middleware. \\nMigrating these to ASP.NET Core require\", \"s extra effort.  \\nASP.NET modules and handlers  \\nHTTP modules and HTTP handlers  are an integral par\", \"t of the ASP.NET architecture. While a request is \\nbeing processed, each request is processed by mul\", \"tiple HTTP modules (for example, the \\nauthentication module and the session module) and is then proc\", \"essed by a single HTTP handler. After \\nthe handler has processed the request, the request flows back\", \" through the HTTP modules.  \\nIf your app is using custom HTTP modules or HTTP handlers, you\\u2019ll need \", \"a plan to migrate them to \\nASP.NET Core. The most likely replacement in ASP.NET Core is middleware. \", \" \\nASP.NET Core middleware  \\nASP.NET Core defines a request pipeline in each app\\u2019s Configure method. \", \"This request pipeline \\ndefines how an incoming request is handled by the app, with each method in th\", \"e pipeline calling the \\nnext method until eventually a method terminates, and the chai n of middlewa\", \"re  terminates and \\nreturns back up the stack. Middleware can target all requests, or can be configu\", \"red to only map to \\ncertain requests based on the requested path or other factors. It can be configu\", \"red wholly in the \\nConfigure method of an app, or implemented in a separate class.  \\nBehavior in an \", \"ASP.NET MVC app that uses HTTP modules is probably best suited to custom \\nmiddleware . Custom HTTP h\", \"andlers can be replaced with custom routes or endpoints that respond to \\nthe same path.  \\nAccessing \", \"HttpContext  \\nMany .NET apps reference the current request\\u2019s context through HttpContext.Current. Th\", \"is static \\naccess can be a common source of problems with testing and other code usage outside of in\", \"dividual \\nrequests. When building ASP.NET Core apps, access to the curre nt HttpContext should be pr\", \"ovided as \\na method parameter on middleware, as this sample demonstrates:  \\npublic class Middleware \", \" \\n{ \\n    private readonly  RequestDelegate _next ; \\n \\n    public Middleware (RequestDelegate next ) \", \"\\n    { \\n        _next = next;  \\n18 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP\", \".NET Core  \\n     } \\n \\n    public Task Invoke(HttpContext httpContext ) \\n    { \\n        return _next(\", \"httpContext ); \\n    } \\n} \\nSimilarly, ASP.NET Core filters pass a context argument to their methods, \", \"from which the current \\nHttpContext can be accessed:  \\npublic class MyActionFilterAttribute : Action\", \"FilterAttribute  \\n{ \\n    public override  void OnResultExecuting (ResultExecutingContext context ) \\n\", \"    { \\n        var headers = context.HttpContext .Request.Headers; \\n        // do something based on\", \" a header  \\n \\n        base.OnResultExecuting (context); \\n    } \\n} \\nIf you have components or service\", \"s that require access to HttpContext, rather than using a static call \\nlike HttpContext.Current you \", \"should instead use constructor dependency injection and the \\nIHttpContextAccessor  interface:  \\npubl\", \"ic class MyService  \\n{ \\n    private readonly  IHttpContextAccessor _httpContextAccessor ; \\n \\n    pub\", \"lic MyService (IHttpContextAccessor httpContextAccessor ) \\n    { \\n        _httpContextAccessor = htt\", \"pContextAccessor ; \\n    } \\n \\n    public void DoSomething () \\n    { \\n        var currentContext = _ht\", \"tpContextAccessor .HttpContext ; \\n    } \\n} \\nThis approach eliminates the static coupling of the meth\", \"od to the current context while providing \\naccess in a testable fashion.  \\nReferences  \\n\\u2022 ASP.NET HT\", \"TP modules and HTTP handlers  \\n\\u2022 ASP.NET Core middleware  \\nConfiguration differences between ASP.NET\", \" MVC \\nand ASP.NET Core  \\nHow configuration values are stored and read changed dramatically between A\", \"SP.NET and ASP.NET \\nCore.   \\n19 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NE\", \"T Core  \\n ASP.NET MVC configuration  \\nIn ASP.NET apps, configuration uses the built -in .NET configu\", \"ration files, web.config  in the app folder \\nand machine.config  on the server. Most ASP.NET MVC and\", \" Web API apps store their settings in the \\nconfiguration file\\u2019s appSettings or connectionStrings ele\", \"ments. Some also use custom configuration \\nsections that can be mapped to a settings class.  \\nConfig\", \"uration in a .NET Framework app is accessed using the \\nSystem.Configuration.ConfigurationManager cla\", \"ss. Unfortunately, this class provides static access to \\nthe configuration elements. As a result, ve\", \"ry few ASP.NET MVC apps tend to abstract access to t heir \\nconfiguration settings or inject them whe\", \"re needed. Instead, most .NET Framework apps tend to \\ndirectly access the configuration system anywh\", \"ere the app needs to use a setting.  \\nTypical ASP.NET MVC configuration access:  \\nstring connectionS\", \"tring = \\n    ConfigurationManager .ConnectionStrings [\\\"DefaultConnection\\\" ] \\n        .ConnectionStri\", \"ng ; \\nASP.NET Core configuration  \\nIn ASP.NET Core apps, configuration is, itself, configurable. How\", \"ever, most apps use a set of defaults \\nprovided as part of the standard project templates and the Co\", \"nfigureWebHostDefaults method used \\nin them. The default settings use JSON formatted files, w ith th\", \"e ability to override settings in the base \\nappsettings.json  file with environment -specific files \", \"like appsettings.Development.json . Additionally, the \\ndefault configuration system further override\", \"s all file -based settings with any environment variable  \\nthat exists for the same named setting. T\", \"his is useful in many scenarios and is especially useful when \\ndeploying to a hosting environment, s\", \"ince it eliminates the need to worry about whether deploying \\nconfiguration files will accidentally \", \"overwrite import ant production configuration settings. \\nConfiguration values can also be provided a\", \"s command line arguments.  \\nAccessing configuration values can be done in many ways in .NET Core. Be\", \"cause dependency injection \\nis built into .NET Core, configuration values are generally accessed thr\", \"ough an interface that is \\ninjected into classes that need them. This can involve pass ing a interfa\", \"ce like IConfiguration , but \\nusually it\\u2019s better to pass just the settings required by the class us\", \"ing the options pattern . \\nFigure 2 -2 shows how to pass IConfiguration into a Razor Page and access\", \" configuration settings from \\nit: \\nusing Microsoft .Extensions .Configuration ; \\n \\npublic class Test\", \"Model : PageModel  \\n{ \\n    private readonly  IConfiguration _configuration ; \\n \\n    public TestModel\", \" (IConfiguration configuration ) \\n    { \\n        _configuration = configuration ; \\n    } \\n \\n    publ\", \"ic ContentResult OnGet() \\n    {  \\n20 CHAPTER 2 | Architectural differences between ASP.NET MVC and A\", \"SP.NET Core  \\n         var myKeyValue = _configuration [\\\"MyKey\\\"]; \\n \\n        // ... \\n    } \\n} \\nFigur\", \"e 2 -2. Accessing configuration values with IConfiguration.  \\nUsing the options pattern , settings a\", \"ccess is similar but is strongly typed and more specific to the \\nsetting(s) needed by the consuming \", \"class, as Figure 2 -3 demonstrates.  \\npublic class PositionOptions  \\n{ \\n    public const string Posi\", \"tion = nameof(Position ); \\n \\n    public string Title { get; set; } \\n    public string Name { get; se\", \"t; } \\n} \\n \\npublic class Test2Model : PageModel  \\n{ \\n    private readonly  PositionOptions _options ;\", \" \\n \\n    public Test2Model (IOptions <PositionOptions > options) \\n    { \\n        _options = options.V\", \"alue; \\n    } \\n \\n    public ContentResult OnGet() \\n    { \\n        return Content($\\\"Title: {_options.T\", \"itle} \\\\nName: {_options.Name}\\\" ); \\n    } \\n} \\nFigure 2 -3. Using the options pattern in ASP.NET Core.\", \"  \\nFor the options pattern to work, the options type must be configured in ConfigureServices when th\", \"e \\napp starts up:  \\n// required in ConfigureServices  \\nservices .Configure <PositionOptions >(Config\", \"uration .GetSection (PositionOptions .Position )); \\nMigrate configuration  \\nWhen considering how to \", \"port an app\\u2019s configuration settings from .NET Framework to .NET Core, the \\nfirst step is to identif\", \"y all of the configuration settings that are being used. Most of these will be in the \\nweb.config  f\", \"ile in the app\\u2019s root folder, but some apps expect settings to be found in the shared \\nmachine.confi\", \"g  file as well. These settings will include elements of the appSettings element, the \\nconnectionStr\", \"ings element, and any custom configuration elements as well. In .NET Core, all of these \\nsettings ar\", \"e typically stored in the appsettings.json  file. \\nOnce all settings in the config files have been c\", \"ataloged, the next step should be to identify where \\nand how the settings are used in the app itself\", \". If some settings aren\\u2019t being used, these can probably \\nbe omitted from the migration. For each se\", \"tting, no te all of the places it\\u2019s being used so you can be \\nsure you don\\u2019t miss any when you migra\", \"te the code.   \\n21 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core  \\n If \", \"you\\u2019re still maintaining the ASP.NET app, it may be helpful to avoid static references to \\nConfigura\", \"tionManager and replace them with access through interfaces. This will ease the transition \\nto ASP.N\", \"ET Core\\u2019s configuration system. In general, static acce ss to external resources makes code \\nharder \", \"to test and maintain, so be on the lookout for anywhere else the app may be following this \\npattern.\", \"  \\nReferences  \\n\\u2022 Configuration in ASP.NET Core  \\n\\u2022 Options pattern in ASP.NET Core  \\n\\u2022 Migrate conf\", \"iguration to ASP.NET Core  \\n\\u2022 Refactoring Static Config Access  \\nRouting differences between ASP.NET\", \" MVC and \\nASP.NET Core  \\nRouting is responsible for mapping incoming browser requests to particular \", \"controller actions (or \\nRazor Pages handlers). This section covers how routing differs between ASP.N\", \"ET MVC (and Web API) \\nand ASP.NET Core (MVC, Razor Pages, and otherwise).  \\nRouting in ASP.NET MVC a\", \"nd Web API  \\nASP.NET MVC offers two approaches to routing:  \\n1. The route table, which is a collecti\", \"on of routes that can be used to match incoming requests \\nto controller actions.  \\n2. Attribute rout\", \"ing, which performs the same function but is achieved by decorating the actions \\nthemselves, rather \", \"than editing a global route table.  \\nRoute table  \\nThe route table is configured when the app starts\", \" up. Typically, a static method call is used to \\nconfigure the global route collection, like so:  \\np\", \"ublic class MvcApplication : System.Web.HttpApplication  \\n{ \\n    public static void RegisterRoutes (\", \"RouteCollection routes ) \\n    { \\n        routes.IgnoreRoute (\\\"{resource}.axd/{*pathInfo}\\\" ); \\n      \", \"  routes.MapRoute ( \\n            name: \\\"Default\\\" , \\n            url: \\\"{controller}/{action}/{id}\\\" , \", \"\\n            defaults : new { controller = \\\"Home\\\", action = \\\"Index\\\", id = \\\"\\\" }, \\n            constra\", \"ints : new { id = \\\"\\\\\\\\d+\\\" } \\n        ); \\n    } \\n \\n    protected  void Application_Start () \\n    {  \\n2\", \"2 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core  \\n         RegisterRout\", \"es (RouteTable .Routes); \\n    } \\n} \\nIn the preceding code, the route table is managed by the RouteCo\", \"llection type, which is used to add \\nnew routes with MapRoute. Routes are named and include a route \", \"string, which can include \\nparameters for controllers, actions, areas, and other placeholders. If an\", \" app follows a standard \\nconvention, most of its actions can be handled by this single default route\", \", with  any exceptions to this \\nconvention configured using additional routes.  \\nAttribute routing i\", \"n ASP.NET MVC  \\nRoutes that are defined with their actions may be easier to discover and reason abou\", \"t than routes \\ndefined in an external location. Using attribute routing, an individual action method\", \" can have its route \\ndefined with a [Route] attribute:  \\npublic class ProductsController  \\n{ \\n    [R\", \"oute(\\\"products\\\" )] \\n    public ActionResult Index() \\n    { \\n        return View(); \\n    } \\n \\n    [Ro\", \"ute(\\\"products/{id}\\\" )] \\n    public ActionResult Details(int id) \\n    { \\n        return View(); \\n    \", \"} \\n} \\nAttribute routing in ASP.NET MVC 5  also supports defaults and prefixes, which can be added at\", \" the \\ncontroller level (and which are applied to all actions within that controller). Refer to the \\n\", \"documentation for details.  \\nSetting up attribute routing requires adding one line to the default ro\", \"ute table configuration:  \\nroutes.MapMvcAttributeRoutes (); \\nAttribute routing can take advantage of\", \" route constraints, both built -in and custom, and supports \\nnamed routes and areas using the [Route\", \"Area] attribute. If your app uses areas, you\\u2019ll need to \\nconfigure support for them in your route re\", \"gistration code by a dding one more line:  \\nroutes.MapMvcAttributeRoutes (); \\n \\nAreaRegistration .Re\", \"gisterAllAreas (); \\nAttribute routing in ASP.NET Web API 2  \\nAttribute routing in ASP.NET Web API 2 \", \" is similar to routing in ASP.NET MVC 5, with minor differences. \\nConfiguring Web API 2 is typically\", \" done in its own class, which is called during app startup. Attribute \\nrouting configuration is hand\", \"led in this class:  \\npublic static class WebApiConfig  \\n{  \\n23 CHAPTER 2 | Architectural differences\", \" between ASP.NET MVC and ASP.NET Core  \\n     public static void Register (HttpConfiguration config )\", \" \\n    { \\n        // Attribute routing.  \\n        config.MapHttpAttributeRoutes (); \\n \\n        // Con\", \"vention -based routing.  \\n        config.Routes.MapHttpRoute ( \\n            name: \\\"DefaultApi\\\" , \\n  \", \"          routeTemplate : \\\"api/{controller}/{id}\\\" , \\n            defaults : new { id = RouteParamete\", \"r .Optional  } \\n        ); \\n    } \\n} \\nAs shown in the preceding code, attribute routing may be combi\", \"ned with convention -based routing \\nin Web API apps.  \\nIn addition to attribute routing, ASP.NET Web\", \" API chooses which action to call  based on the HTTP \\nmethod (for example, GET or POST), the {action\", \"} placeholder in a route (if any), and parameters of the \\naction. In many cases, the name of the act\", \"ion will help determine whether it\\u2019s matched, since prefixing \\nthe action name with \\u201cGet\\u201d or \\u201cPost\\u201d \", \"is used to match the appropriate HTTP method to it. \\nAlternatively, actions can be decorated with an\", \" appropriate HTTP method attribute, like [HttpGet], \\nallowing the use of action names that aren\\u2019t pr\", \"efixed with an HTTP method.  \\npublic class ProductsController : ApiController  \\n{ \\n    // matched by\", \" name and (lack of) parameters  \\n    public IEnumerable <Product> GetAll() { } \\n \\n    // matched by \", \"GET and string parameter  \\n    [HttpGet] \\n    public IEnumerable <Product> FindProductsByName (strin\", \"g name) { } \\n} \\nGiven the above controller, an HTTP GET request to localhost:123/products/ matches t\", \"he GetAll \\naction. An HTTP GET request to localhost:123/products?name=ardalis matches the \\nFindProdu\", \"ctsByName action.  \\nRouting in .NET 7  \\nIn ASP.NET Core, routing is handled by routing middleware, w\", \"hich matches the URLs of incoming \\nrequests to actions or other endpoints. Controller actions are ei\", \"ther conventionally routed or \\nattribute -routed. Conventional routing is similar to the route tabl \", \"e approach used in ASP.NET MVC \\nand Web API. Whether you\\u2019re using conventional, attribute, or both, \", \"you need to configure your app \\nto use the routing middleware. To use the middleware, add the follow\", \"ing code to your Program.cs  file: \\napp.UseRouting (); \\nConventional routing  \\nWith conventional rou\", \"ting, you set up one or more conventions that will be used to match incoming \\nURLs to endpoints  in \", \"the app. In ASP.NET Core, these endpoints may be controller actions, like in \\nASP.NET MVC or Web API\", \". The endpoints could also be Razor Pages, Health Checks, or SignalR hubs. \\nAll of these routable fe\", \"atures are configured in a similar fashion using endpo ints:  \\n24 CHAPTER 2 | Architectural differen\", \"ces between ASP.NET MVC and ASP.NET Core  \\n app.UseEndpoints (endpoints => \\n{ \\n    endpoints .MapHea\", \"lthChecks (\\\"/healthz\\\" ).RequireAuthorization (); \\n    endpoints .MapControllerRoute ( \\n        name:\", \" \\\"default\\\" , \\n        pattern: \\\"{controller=Home}/{action=Index}/{id?}\\\" ); \\n    endpoints .MapRazorP\", \"ages (); \\n}); \\nThe preceding code is used (in addition to UseRouting) to configure various endpoints\", \", including \\nHealth Checks, controllers, and Razor Pages. For controllers, the above configuration s\", \"pecifies a \\ndefault routing convention, which is the fairly standard {control ler}/{action}/{id?} pa\", \"ttern that\\u2019s been \\nrecommended since the first versions of ASP.NET MVC.  \\nAttribute routing  \\nAttrib\", \"ute routing in ASP.NET Core is the preferred approach for configuring routing in controllers. If \\nyo\", \"u\\u2019re building APIs, the [ApiController] attribute should be applied to your controllers. Among other\", \" \\nthings, this attribute requires the use of attribu te routing for actions in such controller class\", \"es.  \\nAttribute routing in ASP.NET Core behaves similarly in ASP.NET MVC and Web API. In addition to\", \" \\nsupporting the [Route] attribute, however, route information can also be specified as part of the \", \"HTTP \\nmethod attribute:  \\n[HttpGet(\\\"api/products/{id}\\\" )] \\npublic async ActionResult <Product> Detai\", \"ls(int id) \\n{ \\n    // ... \\n} \\nAs with previous versions, you can specify a default route with placeh\", \"olders, and add this at the \\ncontroller class level or even on a base class. You use the same [Route\", \"] attribute for all of these cases. \\nFor example, a base API controller class might look  like this:\", \"  \\n[Route(\\\"api/{controller}/{action}/{id?:int}\\\" )] \\npublic abstract  class BaseApiController : Contr\", \"ollerBase , IApiController  \\n{ \\n    // ... \\n} \\nUsing this attribute, classes inheriting from this ty\", \"pe would route URLs to actions based on the \\ncontroller name, action name, and an optional integer i\", \"d parameter.  \\nReferences  \\n\\u2022 ASP.NET MVC Routing Overview  \\n\\u2022 Attribute Routing in ASP.NET MVC 5  \\n\", \"\\u2022 Attribute routing in ASP.NET Web API 2  \\n\\u2022 Routing and Action Selection in ASP.NET Web API  \\n\\u2022 Rou\", \"ting in ASP.NET Core  \\n\\u2022 Routing to controller actions in ASP.NET Core MVC   \\n25 CHAPTER 2 | Archite\", \"ctural differences between ASP.NET MVC and ASP.NET Core  \\n Logging differences between ASP.NET MVC a\", \"nd \\nASP.NET Core  \\nApplication logging provides important diagnostic information, especially for app\", \"s running in \\nproduction. ASP.NET Core introduces a new system for adding standardized logging to an\", \"y app. \\nExisting ASP.NET MVC and Web API apps most likely use third -party log ging solutions, which\", \" likely \\ncontinue to be supported on ASP.NET Core.  \\nASP.NET MVC logging  \\nThere\\u2019s no built -in logg\", \"ing solution in ASP.NET MVC and Web API apps. Instead, most apps use third -\\nparty logging solutions\", \" like log4net , NLog , or Serilog . Many teams also choose to roll their own \\nlogging solution. Logg\", \"ing frameworks typically support multiple \\u201csinks\\u201d (or targets or appenders) for \\nlog output, such as\", \" text files, databases, or even emails. They use configuration to determine which \\nlevels of log mes\", \"sages from which parts of the system are routed to different sinks. When considering \\nhow to migrate\", \" an app\\u2019s logging to .NET Core, review how logging is performed and configured  in the \\napp. \\nASP.NE\", \"T Core logging  \\nIn ASP.NET Core, logging is a built -in feature  that can be configured and extende\", \"d when the app \\nstarts up. Third -party loggers, including those mentioned above, can be integrated \", \"with ASP.NET Core \\nto enhance its functionality.  \\nASP.NET Core logging uses categories and levels t\", \"o control what is logged and how. Classes typically \\nuse instances of the ILogger<T> interface, with\", \" the class\\u2019s type used as the generic T type. In this \\nscenario, the class\\u2019s fully qualified name is\", \" used as the category. Loggers can also be created with a \\ncustom category using an ILoggerFactory. \", \"Log levels range from the most detailed, Trace, to the most \\nimportant, Critical. Using configuratio\", \"n, apps can specify what minimum level of logging should be \\ninclude d on a per -category (with wild\", \"cards) basis.  \\nA typical logging configuration could log Information and above information by defau\", \"lt, but only \\nWarning or above from Microsoft -prefixed categories:  \\n{ \\n  \\\"Logging\\\" : { \\n    \\\"LogLe\", \"vel\\\" : { \\n      \\\"Default\\\" : \\\"Information\\\" , \\n      \\\"Microsoft\\\" : \\\"Warning\\\"  \\n    } \\n  } \\n} \\nSupport \", \"for logging in ASP.NET Core is extensive and flexible. For more detailed information, refer to \\nthe \", \"docs .  \\n26 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core  \\n Migrate lo\", \"gging  \\nHow you migrate your .NET Framework app\\u2019s logging to .NET Core depends on how the app is \\nlo\", \"gging now. If it\\u2019s using a third -party NuGet package, refer to the upgrade documentation for that \\n\", \"package. Most likely the upgrade path will be fairly straightforwar d. If you\\u2019re using your own logg\", \"ing \\nsolution, take one of the following actions:  \\n1. Migrate the logging solution yourself  \\n2. Mi\", \"grate to a third -party logging solution  \\n3. Use the built -in logging support in ASP.NET Core  \\nYo\", \"u can reference the Microsoft.Extensions.Logging package from .NET Framework apps as long as \\nthey\\u2019r\", \"e using NuGet 4.3 or later and are on .NET Framework 4.6.1 or later. Once your app has \\nreferenced t\", \"his package, you can convert your logging statements to use the new extensions before \\nmigrating the\", \" app to .NET Core. This can provide a stepping stone toward full migration, since the app \\ncan conti\", \"nue running on .NET Framework while logging using the newer extensions package.  \\nReferences  \\n\\u2022 Log\", \"ging in .NET Core and ASP.NET Core  \\n\\u2022 Microsoft.Extensions.Logging NuGet Package  \\nCompare Razor Pa\", \"ges to ASP.NET MVC  \\nRazor Pages is the preferred way to create page - or form -based apps in ASP.NE\", \"T Core. From the docs , \\n\\u201cRazor Pages can make coding page -focused scenarios easier and more produc\", \"tive than using \\ncontrollers and views.\\u201d If your ASP.NET MVC app makes heavy use of views, you may w\", \"ant to consider \\nmigrating from actions and views to Razor Pages.  \\nA typical strongly typed view -b\", \"ased MVC app will use a controller to contain one or more actions. The \\ncontroller will interact wit\", \"h the domain or data model, and create an instance of a viewmodel class. \\nThen this viewmodel class \", \"is passed to the view assoc iated with that action. Using this approach, \\ncoupled with the default f\", \"older structure of MVC apps, to add a new page to an app requires \\nmodifying a controller in one fol\", \"der, a view in a nested subfolder in another folder, and a viewmodel \\nin yet another fo lder. \\nRazor\", \" Pages group together the action (now a handler ) and the viewmodel (called a PageModel ) in \\none cl\", \"ass, and link this class to the view (called a Razor Page). All Razor Pages go into a Pages  folder \", \"in \\nthe root of the ASP.NET Core project. Razor Pages use a routing convention based on their name a\", \"nd \\nlocation within this folder. Handlers behave exactly like action methods but have the HTTP verb \", \"they \\nhandle in their name (for example, OnGet). Th ey also don\\u2019t necessarily need to return, since \", \"by default \\nthey\\u2019re assumed to return the page they\\u2019re associated with. This tends to keep Razor Pag\", \"es and their \\nhandlers smaller and more focused while at the same time making it easier to find and \", \"work with all of \\nthe files needed to add or modify a particular part of a n app.  \\nAs part of a mov\", \"e from ASP.NET MVC to ASP.NET Core, teams should consider whether they want to \\nmigrate controllers \", \"and views to ASP.NET Core controllers and views, or to Razor Pages. The former  \\n27 CHAPTER 2 | Arch\", \"itectural differences between ASP.NET MVC and ASP.NET Core  \\n will most likely require slightly less\", \" overall effort, but won\\u2019t allow the team to take advantage of the \\nbenefits of Razor Pages over tra\", \"ditional view -based file organization.  \\nReferences  \\n\\u2022 Introduction to Razor Pages in ASP.NET Core\", \"  \\n\\u2022 Simpler ASP.NET Core Apps with Razor Pages  \\nCompare ASP.NET Web API 2 and ASP.NET Core  \\nASP.N\", \"ET Core offers iterative improvements to ASP.NET Web API 2, but should feel familiar to \\ndevelopers \", \"who have used Web API 2. ASP.NET Web API 2 was developed and shipped alongside \\nASP.NET MVC. This me\", \"ant the two approaches had similar -but-different appr oaches to things like \\nattribute routing and \", \"dependency injection. In ASP.NET Core, there\\u2019s no longer any distinction \\nbetween MVC and Web APIs. \", \"There\\u2019s only ASP.NET Core , which includes support for view -based \\nscenarios, API endpoints, Razor \", \"Pages, health checks, SignalR, and more.  \\nIn addition to being consistent and unified within ASP.NE\", \"T Core, APIs built in .NET Core are much \\neasier to test than those built on ASP.NET Web API 2. We\\u2019l\", \"l cover testing differences  in more detail in \\na moment. The built -in support for hosting ASP.NET \", \"Core apps, in a test host that can create an \\nHttpClient that makes in -memory requests to the app, \", \"is a huge benefit when it comes to automated \\ntesting.  \\nSee Incremental ASP.NET to ASP.NET Core mig\", \"ration  for an incremental approach to migrating to \\nASP.NET Core.  \\nReferences  \\n\\u2022 Migrate from ASP\", \".NET Web API to ASP.NET Core  \\n\\u2022 Ardalis.ApiEndpoints NuGet package  \\nCompare authentication and aut\", \"horization between \\nASP.NET MVC and ASP.NET Core  \\nIn ASP.NET MVC 5, authentication is configured in\", \" Startup.Auth.cs  in the App_Start  folder. In ASP.NET \\nCore MVC, this configuration occurs in Start\", \"up.cs  or Program.cs , as part of configuring the app\\u2019s \\nservices and middleware.  \\nAuthentication a\", \"nd authorization are performed using middleware added to the request pipeline:  \\napp.UseRouting (); \", \"\\n \\napp.UseAuthentication (); \\napp.UseAuthorization (); \\n \\napp.UseEndpoints (endpoints => \\n{  \\n28 CHA\", \"PTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core  \\n     endpoints .MapControl\", \"lerRoute ( \\n        name: \\\"default\\\" , \\n        pattern: \\\"{controller=Home}/{action=Index}/{id?}\\\" ); \", \"\\n    endpoints .MapRazorPages (); \\n}); \\nIt\\u2019s important to add the auth middleware in the appropriate\", \" order in the middleware pipeline. Only \\nrequests that make it to the middleware will be impacted by\", \" it. For instance, if a call to UseStaticFiles() \\nwere placed above the code shown here, it wouldn\\u2019t\", \" be protected by authentication and \\nauthorization.  \\nIn ASP.NET MVC and Web API, apps often refer t\", \"o the current user using the ClaimsPrincipal.Current \\nproperty. This property isn\\u2019t set in ASP.NET C\", \"ore, and any behavior in your app that depends on it will \\nneed to migrate from ClaimsPrincipal.Curr\", \"ent  by using the User property on ControllerBase or getting \\naccess to the current HttpContext and \", \"referencing its User property. If neither of these solutions is an \\noption, services can request the\", \" User as an argument, in which case it must be supplied from \\nelsewhere in the app, or the IHttpCont\", \"extAccessor can be requested and used to get the HttpContext.  \\nAuthorization  \\nAuthorization define\", \"s what a given user can do within the app. It\\u2019s separate from authentication, \\nwhich is concerned me\", \"rely with identifying who the user is. ASP.NET Core provides a simple, \\ndeclarative role and a rich,\", \" policy -based model for authorization.  Specifying that a resource requires \\nauthorization is often\", \" as simple as adding the [Authorize] attribute to the action or controller. If you\\u2019re \\nmigrating to \", \"Razor Pages from MVC views, you should specify conventions for authorization when \\nyou configure Raz\", \"or Pages . \\nAuthorization in ASP.NET Core may be as simple as prohibiting anonymous users while allo\", \"wing \\nauthenticated users. Or it can scale up to support role -based, claims -based, or policy -base\", \"d \\nauthorization approaches. For more information on these approaches, se e the documentation on \\nau\", \"thorization in ASP.NET Core . You\\u2019ll likely find that one of them is closely aligned with your curre\", \"nt \\nauthorization approach.  \\nReferences  \\n\\u2022 Security, Authentication, and Authorization with ASP.NE\", \"T MVC  \\n\\u2022 Migrate Authentication and Identity to ASP.NET Core  \\n\\u2022 Migrate from ClaimsPrincipal.Curre\", \"nt  \\n\\u2022 Introduction to Authorization in ASP.NET Core  \\nCompare ASP.NET Identity and ASP.NET Core \\nId\", \"entity  \\nIn ASP.NET MVC, identity features are typically configured in IdentityConfig.cs  in the App\", \"_Start  folder. \\nReview how this is configured in the existing app, and compare it to the configurat\", \"ion required for \\nASP.NET Core Identity  in Program.cs .  \\n29 CHAPTER 2 | Architectural differences \", \"between ASP.NET MVC and ASP.NET Core  \\n ASP.NET Identity is an API that supports user interface logi\", \"n functionality and manages users, \\npasswords, profile data, roles, claims, tokens, email confirmati\", \"ons, and more. It supports external login \\nproviders like Facebook, Google, Microsoft, and Twitter .\", \" \\nIf your ASP.NET MVC app is using ASP.NET Membership, you\\u2019ll find a guide to migrate from ASP.NET \\n\", \"Membership authentication to ASP.NET Core 2.0 Identity . This is mainly a data migration exercise, a\", \"t \\nthe completion of which you should be able to use ASP.NET Core Identity with your migrated user \\n\", \"records.  \\nIf you migrate your ASP.NET Identity users to ASP.NET Core Identity, you may need to upda\", \"te their \\npassword hashes, or track which passwords are hashed with the new ASP.NET Core Identity ap\", \"proach \\nor the older ASP.NET Identity approach. This approach described on Stack Overflow  provides \", \"some \\noptions for migrating user password hashes over time, rather than all at once.  \\nOne of the bi\", \"ggest differences when it comes to ASP.NET Core Identity compared to ASP.NET Identity \\nis how little\", \" code you need to include in your project. ASP.NET Core Identity now ships as a Razor \\nClass Library\", \", meaning its UI and logic are all available from a NuGet package. You can override the \\nexisting UI\", \" and logic by scaffolding the ASP.NET Core Identity files  but even in this case you need only \\nscaf\", \"fold the pages you want to modify, not every one that exists.  \\nMigrate from OWIN / Katana  \\nThe fol\", \"lowing resources offer some guidance for migrating from OWIN / Katana:  \\n\\u2022 Migration  \\n\\u2022 Katana to A\", \"SPNET 5  \\nReferences  \\n\\u2022 Migrate Authentication and Identity to ASP.NET Core  \\n\\u2022 Introduction to Ide\", \"ntity on ASP.NET Core  \\n\\u2022 Configure ASP.NET Core Identity  \\n\\u2022 Scaffold Identity in ASP.NET Core proj\", \"ects  \\nCompare controllers in ASP.NET MVC and Web API \\nwith controllers in ASP.NET Core  \\nIn ASP.NET\", \" MVC 5 and Web API 2, there were two different Controller base types. MVC controllers \\ninherited fro\", \"m Controller; Web API controllers inherited from ApiController. In ASP.NET Core, this \\nobject hierar\", \"chy has been merged. It\\u2019s recommended that API c ontrollers in ASP.NET Core inherit \\nfrom Controller\", \"Base and add the [ApiController] attribute. Standard view -based MVC controllers \\nshould inherit fro\", \"m Controller.  \\nIn both frameworks, controllers are used to organize sets of action methods. Filters\", \" and routes can be \\napplied on a controller level in addition to at the action level. These conventi\", \"ons can be extended \\nfurther by using custom base Controller types with default be havior and attrib\", \"utes applied to them.   \\n30 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Co\", \"re  \\n In ASP.NET MVC, content negotiation isn\\u2019t supported. ASP.NET Web API 2 does support content \\nn\", \"egotiation, as does ASP.NET Core. Using content negotiation , the format of the content returned to \", \"a \\nrequest can be determined by headers the client provides indicating its preferred manner of recei\", \"ving \\nthe content.  \\nWhen migrating ASP.NET Web API controllers to ASP.NET Core, a few components ne\", \"ed to be \\nchanged if they exist. These include references to the ApiController base class, the Syste\", \"m.Web.Http \\nnamespace, and the IHttpActionResult interface. Refer to the documentation for recommend\", \"ations on \\nhow to migrate these specific differences . Note that the preferred return type for API a\", \"ctions in \\nASP.NET Core is ActionResult<T>.  \\nIn addition, the [ChildActionOnly] attribute isn\\u2019t sup\", \"ported in ASP.NET Core. In ASP.NET Core, similar \\nfunctionality is achieved using View Components . \", \"\\nASP.NET Core includes two new attributes: ConsumesAttribute  and ProducesAttribute . These are used\", \" \\nto specify the type an action consumes or produces, which can be helpful for routing and \\ndocument\", \"ing the API using tools like Swagger/OpenAPI . \\nReferences  \\n\\u2022 Format response data in ASP.NET Core \", \"Web API  \\n\\u2022 Migrate from ASP.NET Web API to ASP.NET Core  \\nCompare Razor usage in ASP.NET MVC and \\nA\", \"SP.NET Core  \\nThe basic syntax of Razor hasn\\u2019t changed substantially between ASP.NET MVC and ASP.NET\", \" Core. \\nHowever, there are certain differences, such as the introduction of Tag Helpers  and Razor P\", \"ages, that \\nshould be considered when migrating. If your app makes heavy use of custom Razor functio\", \"nality, \\nrefer to the Razor syntax reference for ASP.NET Core  to see what changes may be required w\", \"hen you \\nmigrate to ASP.NET Core.  \\nTag Helpers  \\nTag Helpers enable server -side code to participat\", \"e in creating and rendering HTML elements in Razor \\nfiles. They offer many advantages over HTML Help\", \"ers and should be used in place of HTML Helpers \\nwherever possible. They provide an HTML -friendly d\", \"evelopment  experience, since they look like \\nstandard HTML and are ignored by most tooling designed\", \" to edit HTML. Within Visual Studio , there\\u2019s \\nrich IntelliSense support for creating HTML and Razor\", \" markup with Tag Helpers. Tag Helpers can \\nprovide simple or complex be havior from declarative mark\", \"up in Razor files.  \\nRazor Pages  \\nRazor Pages offer an alternative to controllers, actions, and vie\", \"ws for page - and form -based apps. \\nRazor Pages were compared to ASP.NET MVC earlier in this chapte\", \"r .  \\n31 CHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core  \\n References  \\n\", \"\\u2022 Migrate from ASP.NET MVC to ASP.NET Core MVC: Controllers and Views  \\n\\u2022 Tag Helpers in ASP.NET Cor\", \"e  \\n\\u2022 Introduction to Razor Pages in ASP.NET Core  \\n\\u2022 Razor syntax reference for ASP.NET Core  \\nComp\", \"are ASP.NET SignalR and ASP.NET Core \\nSignalR  \\nASP.NET Core SignalR is incompatible with clients or\", \" servers using ASP.NET SignalR. You\\u2019ll need to \\nupdate both clients and server to use ASP.NET Core S\", \"ignalR. Some differences are described in this \\nsection, while the full list is available in the doc\", \"s . ASP.NET Core SignalR requires .NET Core 2.1 or \\ngreater.  \\nFeature differences  \\n\\u2022 ASP.NET Signa\", \"lR automatically attempts to reconnect dropped connections; this behavior is \\nopt-in for ASP.NET Cor\", \"e SignalR clients.  \\n\\u2022 Both frameworks support JSON; ASP.NET Core SignalR also supports a binary pro\", \"tocol based \\non MessagePack, and custom protocols can be created.  \\n\\u2022 The Forever Frame transport, s\", \"upported by ASP.NET SignalR, isn\\u2019t supported in ASP.NET Core \\nSignalR.  \\n\\u2022 ASP.NET Core SignalR must\", \" be configured by adding services.AddSignalR() and \\napp.UseEndpoints in Program.cs . \\n\\u2022 ASP.NET Core\", \" SignalR requires sticky sessions; ASP.NET SignalR doesn\\u2019t.  \\n\\u2022 ASP.NET Core simplifies the connecti\", \"on model; connections are only made to a single hub.  \\n\\u2022 ASP.NET Core SignalR supports streaming dat\", \"a from the hub to the client.  \\n\\u2022 ASP.NET Core SignalR doesn\\u2019t support passing state between clients\", \" and the hub (but method \\ncalls still allow passing information between hubs and clients).  \\n\\u2022 The P\", \"ersistentConnection class doesn\\u2019t exist in ASP.NET Core SignalR.  \\n\\u2022 ASP.NET SignalR supports SQL Se\", \"rver and Redis. ASP.NET Core SignalR supports Azure \\nSignalR  and Redis.  \\nReferences  \\n\\u2022 Difference\", \"s between ASP.NET SignalR and ASP.NET Core SignalR  \\n\\u2022 Azure SignalR Service   \\n32 CHAPTER 2 | Archi\", \"tectural differences between ASP.NET MVC and ASP.NET Core  \\n Compare testing options between ASP.NET\", \" MVC \\nand ASP.NET Core  \\nASP.NET MVC apps support unit testing of controllers, but this approach oft\", \"en omits many MVC \\nfeatures like routing, authorization, model binding, model validation, filters, a\", \"nd more. To test these \\nMVC features in addition to the logic within the controller  action itself, \", \"frequently the app would need \\nto be deployed and then tested with a tool like Selenium. These tests\", \" are substantially more \\nexpensive, more brittle, and slower than typical unit tests that can be run\", \" without the need for hosting \\nand running the entire app.  \\nASP.NET Core controllers can be unit te\", \"sted  just like ASP.NET MVC controllers, but with the same \\nlimitations. However, ASP.NET Core suppo\", \"rts fast, easy -to-author integration tests  as well. Integration \\ntests are hosted by a TestHost cl\", \"ass and are typically configured in a custom WebApplicationFactory \\nthat can override or replace app\", \" dependencies. For instance, frequently during integration tests the \\napp will target a different da\", \"ta source and may replace services that send emails with fake or mock \\nimplementations.  \\nASP.NET MV\", \"C and Web API did not support anything like the integration testing scenarios available in \\nASP.NET \", \"Core. In any migration effort, you should allocate time to write some integration tests for \\nyour ne\", \"wly migrated system to ensure it\\u2019s working as ex pected and continues to do so. Even if you \\nweren\\u2019t\", \" writing tests of your web app logic before the migration, you should strongly consider doing \\nso as\", \" you move to ASP.NET Core.  \\nReferences  \\n\\u2022 Creating Unit Tests for ASP.NET MVC Applications  \\n\\u2022 Uni\", \"t test controller logic in ASP.NET Core  \\n\\u2022 Integration tests in ASP.NET Core   \\n33 CHAPTER 3 | Migr\", \"ate large solutions to ASP.NET Core  \\n CHAPTER  3 \\nMigrate large solutions to \\nASP.NET Core  \\nMigrat\", \"ing large solutions from .NET Framework to .NET Core requires some planning. Dependencies \\nmust be m\", \"igrated or updated before the projects that depend on them. There are tools that can \\nidentify depen\", \"dencies and offer help with migrating to .NET Core. Depending on the app, its scope, \\nand current us\", \"age patterns, different strategies may be employed when migrating. Do you migrate it \\nall at once, o\", \"r over time, side -by-side with the current system? Do you wrap the current system in the \\nnew one, \", \"and incremen tally replace its functionality?  \\nIn this chapter, you\\u2019ll learn how create a migration\", \" plan for a large solution, how to use tools to help \\nwith the migration, and some strategies to con\", \"sider for the migration itself.  \\nReferences  \\n\\u2022 What topics are important to migrating large MVC an\", \"d Web API apps to .NET Core?  \\n\\u2022 Porting from .NET Framework to .NET Core  \\nIdentify sequence of pro\", \"jects to migrate  \\nFor solutions that involve multiple front -end apps, it\\u2019s best to migrate the app\", \"s one by one. For \\nexample, create a solution that only includes one front -end app and its dependen\", \"cies so you can \\neasily identify the scope of work involved. Solutions are ligh tweight, and you can\", \" include projects in \\nmultiple solutions if needed. Take advantage of solutions as an organizational\", \" tool when migrating.  \\nOnce you\\u2019ve identified the ASP.NET app to migrate and have its dependent pro\", \"jects located with it \\n(ideally in a solution), the next step is to identify framework and NuGet dep\", \"endencies. Having \\nidentified all dependencies, the simplest migration approach is  a \\u201cbottom up\\u201d ap\", \"proach. With this \\napproach, the lowest level of dependencies is migrated first. Then the next level\", \" of dependencies is \\nmigrated, until eventually the only thing left is the front -end app. Figure 3 \", \"-1 shows an example set of \\nprojects composi ng an app. The low -level class libraries are at the bo\", \"ttom, and the ASP.NET MVC \\nproject is at the top.   \\n34 CHAPTER 3 | Migrate large solutions to ASP.N\", \"ET Core  \\n  \\nFigure 3 -1. Project dependencies graph.  \\nChoose a particular front -end app, an ASP.N\", \"ET MVC 5 / Web API 2 project. Identify its dependencies \\nin the solution, and map out their dependen\", \"cies until you have a complete list. A diagram like the one \\nshown in Figure 3 -1 may be useful when\", \" mapping out pro ject dependencies. Visual Studio can \\nproduce a dependency diagram for your solutio\", \"n , depending on which edition you\\u2019re using. The .NET \\nPortability Analyzer  can also produce depend\", \"ency diagrams.  \\nFigure 3 -2 shows the installer for the .NET Portability Analyzer Visual Studio ext\", \"ension : \\n \\n35 CHAPTER 3 | Migrate large solutions to ASP.NET Core  \\n  \\nFigure 3 -2. .NET Portabilit\", \"y Analyzer installer.  \\nThe extension currently supports Visual Studio 2017 and 2019. Visual Studio \", \"2022 support is planned.  \\nOnce installed, you configure it from the Analyze  > Portability Analyzer\", \" Settings  menu, as shown in \\nFigure 3 -3. \\n \\n36 CHAPTER 3 | Migrate large solutions to ASP.NET Core\", \"  \\n  \\nFigure 3 -3. Configure the .NET Portability Analyzer.  \\nThe analyzer produces a detailed repor\", \"t for each assembly. The report:  \\n\\u2022 Describes how compatible each project is with a given target fr\", \"amework, such as .NET 7 or \\n.NET Standard 2.0.  \\n\\u2022 Helps teams assess the effort required to port a \", \"particular project to a particular target \\nframework.  \\nThe details of this analysis are covered in \", \"the next section.  \\nOnce you\\u2019ve mapped out the projects and their relationships with one another, yo\", \"u\\u2019re ready to \\ndetermine the order in which you\\u2019ll migrate the projects. Begin with projects that ha\", \"ve no \\ndependencies. Then, work your way up the tree to the projects that depe nd on these projects.\", \"  \\nIn the example shown in Figure 3 -1, you would start with the Contoso.Utils  project, since it do\", \"esn\\u2019t \\ndepend on any other projects. Next, Contoso.Data  since it only depends on \\u201cUtils\\u201d. Then migr\", \"ate the \\n\\u201cBusinessLogic\\u201d library, and finally the front -end ASP.NET \\u201cWeb\\u201d project. Following this \\u201c\", \"bottom up\\u201d \\napproach works well for relatively small and well -factored apps that can be migrated as\", \" a unit once all  \\nof their projects have migrated. Larger apps with more complexity, or more code t\", \"hat will take longer \\nto m igrate, may need to consider more incremental strategies.  \\n \\n37 CHAPTER \", \"3 | Migrate large solutions to ASP.NET Core  \\n Unit tests  \\nMissing from the previous diagrams are u\", \"nit test projects. Hopefully there are tests covering at least \\nsome of the existing behavior of the\", \" libraries being ported.  \\nIf you have unit tests, it\\u2019s best to convert those projects first. You\\u2019ll\", \" want to continue testing changes \\nin the project you\\u2019re working on. Remember that porting to .NET C\", \"ore is a significant change to your \\ncodebase.  \\nMSTest, xUnit, and NUnit all work on .NET Core. If \", \"you don\\u2019t currently have tests for your app, \\nconsider building some characterization tests that ver\", \"ify the system\\u2019s current behavior. The benefit is \\nthat once the migration is complete, you can conf\", \"irm the  app\\u2019s behavior remains unchanged.  \\nConsiderations for migrating many apps  \\nSome organizat\", \"ions will have many different apps to migrate, and migrating each one by hand may \\nrequire too many \", \"resources to be tenable. In these situations, some degree of automation is \\nrecommended. The steps f\", \"ollowed in this chapter can be automated. St ructural changes, like project \\nfile differences and up\", \"dates to common packages, can be applied by scripts. These scripts can be \\nrefined as they\\u2019re run it\", \"eratively on more projects. On each run, examine whatever manual steps are \\nrequired for each projec\", \"t. A utomate those manual steps, if possible. Using this approach, the \\norganization should grow fas\", \"ter and better at porting their apps over time, with improved automation \\nsupport each step of the w\", \"ay.  \\nWatch an overview of how to employ this approach in this dotNetConf presentation by Lizzy \\nGal\", \"lagher of Mastercard . The five phases employed in this presentation included:  \\n\\u2022 Migrate third -pa\", \"rty NuGet dependencies  \\n\\u2022 Migrate apps to use new .csproj  file format  \\n\\u2022 Update internal NuGet de\", \"pendencies to .NET Standard  \\n\\u2022 Migrate apps to ASP.NET Core (targeting .NET Framework)  \\n\\u2022 Update a\", \"ll apps to target .NET 7  \\nWhen automating a large suite of apps, it helps significantly if they fol\", \"low consistent coding \\nguidelines and project organization. Automation efforts rely on this consiste\", \"ncy to be effective. In \\naddition to parsing and migrating project files, common code  patterns can \", \"be migrated automatically. \\nSome code pattern examples include differences in how controller actions\", \" are declared or how they \\nreturn results.  \\nFor example, a migration script could search files matc\", \"hing Controller.cs  for lines of code matching \\none of these patterns:  \\n   return new HttpStatusCod\", \"eResult (200); \\n   // or \\n   return new HttpStatusCodeResult (HttpStatusCode .OK); \\nIn ASP.NET Core,\", \" either of the preceding lines of code can be replaced with:  \\n    return Ok();  \\n38 CHAPTER 3 | Mig\", \"rate large solutions to ASP.NET Core  \\n Summary  \\nThe best approach to porting a large .NET Framewor\", \"k app to .NET Core is to:  \\n1. Identify project dependencies.  \\n2. Analyze what\\u2019s required to port e\", \"ach project.  \\n3. Start from the bottom up.  \\nYou can use the .NET Portability Analyzer to determine\", \" how compatible existing libraries may be with \\ntarget platforms. Automated tests will help ensure n\", \"o breaking changes are introduced as the app is \\nported. These test projects should be among the fir\", \"st p rojects ported.  \\nReferences  \\n\\u2022 Porting from .NET Framework to .NET Core  \\n\\u2022 The .NET Portabil\", \"ity Analyzer  \\n\\u2022 2 Years, 200 Apps: A .NET Core Migration at Scale (Video)  \\nUnderstand and update d\", \"ependencies  \\nAfter identifying the sequence in which the app\\u2019s individual projects must be migrated\", \", the next step \\nis to understand each project\\u2019s dependencies and update them if necessary. For plat\", \"form \\ndependencies, the best way to start is to run the .NET Portability Analyzer  on the assembly i\", \"n \\nquestion, and then look at the detailed results that are generated. You configure the tool to spe\", \"cify \\none or more target platforms, such as .NET 7 or .NET Standard 2.0. Results are provided with d\", \"etails \\nfor each platform targeted. Figur e 3-4 shows an example of the tool\\u2019s output.  \\n \\nFigure 3 \", \"-4. .NET Portability Analyzer report details.  \\nUpdate class library dependencies  \\nLarge apps typic\", \"ally involve multiple projects, and most projects other than the ASP.NET MVC web \\nproject are likely\", \" to be class libraries. Class libraries tend to be the easiest to port between .NET \\n \\n39 CHAPTER 3 \", \"| Migrate large solutions to ASP.NET Core  \\n platforms, especially compared to ASP.NET projects, whi\", \"ch are among the most difficult (and typically \\nneed to be re -created).  \\nTeams can consider the tr\", \"y-convert tool  or the .NET Upgrade Assistant tool  for migrating class \\nlibraries to .NET Core. The\", \"se tools analyze a .NET Framework project file and attempt to migrate it to \\nthe .NET Core project f\", \"ile format, making any modifications it can safely perform in the process. The \\ntools may require so\", \"me manual assistance to work with ASP.NET projects, but can usually help speed \\nup the process of mi\", \"grating class libraries.  \\nThe try -convert and Upgrade Assistant tools are deployed as .NET Core co\", \"mmand line tools. They only \\nrun on Windows, since they\\u2019re designed to work with .NET Framework apps\", \". You can install try -\\nconvert by running the following command from a command prompt:  \\ndotnet too\", \"l install -g try-convert \\nOnce you\\u2019ve successfully installed the tool, you can run try -convert in t\", \"he folder where the class \\nlibrary\\u2019s project file is located.  \\nInstall the .NET Upgrade Assistant w\", \"ith the following command (after installing try -convert):  \\ndotnet tool install -g upgrade -assista\", \"nt  \\nRun the tool with the command upgrade -assistant upgrade <project> in the folder where the proj\", \"ect \\nfile is located.  \\nUpdate NuGet package dependencies  \\nAnalyze your use of third -party NuGet p\", \"ackages and determine if any of them don\\u2019t yet support .NET \\nStandard (or do support it but only wit\", \"h a new version). It can be helpful to update NuGet packages \\nto use <PackageReference>  syntax usin\", \"g Visual Studio\\u2019s converter tool , so that top -level \\ndependencies are visible. Next, check whether\", \" the current or later versions of these packages support \\n.NET Core or .NET Standard. This informati\", \"on can be found on [nuget.org] or within Visual Studio for \\neach package.  \\nIf support exists using \", \"the version of the package the app currently uses, great! If not, see if a more \\nrecent version of t\", \"he package has the support and research what would be involved in upgrading. \\nThere may be breaking \", \"changes in the package, especially  if the major version of the package changes \\nbetween your curren\", \"tly used version and the one to which you\\u2019re upgrading.  \\nIn some cases, no version of a given packa\", \"ge works with .NET Core. In that case, teams have a couple \\noptions. They can continue depending on \", \"the .NET Framework version, but this has limitations. The \\napp may only run on Windows, and the team\", \" may want to run  Portability Analyzer on the package\\u2019s \\nbinaries to see if there are any issues lik\", \"ely to be encountered. Certainly the team will want to test \\nthoroughly, since if .NET Framework pac\", \"kages are used that reference APIs not available in .NET Core, \\na runtime ex ception will occur. The\", \" other option is to find a different package or, if the required \\npackage is open source, upgrade it\", \" to .NET Standard or .NET Core themselves.   \\n40 CHAPTER 3 | Migrate large solutions to ASP.NET Core\", \"  \\n Migrate ASP.NET MVC projects  \\nThe System.Web namespace and types don\\u2019t exist in .NET Core. When\", \" you\\u2019re analyzing dependencies \\nand using tools like try -convert, you\\u2019ll find they don\\u2019t offer many\", \" suggestions for automatic migration \\nof ASP.NET MVC projects and any code in them that references S\", \"ystem.Web. For these projects, you\\u2019ll \\nneed to start wit h a new ASP.NET Core web project and manual\", \"ly migrate files to this project.  \\nIn general, it\\u2019s a good practice to minimize how much of an app\\u2019\", \"s business logic lives in its user \\ninterface layer. It\\u2019s also best to keep controllers and views sm\", \"all. Apps that have followed this \\nguidance will be easier to port than those that have a sign ifica\", \"nt amount of their logic in the ASP.NET \\nweb project. If you have an app you\\u2019re considering porting,\", \" but haven\\u2019t begun the process yet, keep \\nthis in mind as you maintain it. Any effort you put toward\", \" minimizing how much code is in the \\nASP.NET MVC or We b API project will likely result in less work\", \" when the time comes to port the app.  \\nThe next chapter digs into details of how to migrate from AS\", \"P.NET MVC and Web API projects to \\nASP.NET Core projects. The previous chapter called out the bigges\", \"t differences between the apps. \\nOnce the basic project structure is in place, migrating individua l\", \" controllers and views is usually \\nstraightforward, especially if they\\u2019re mainly focused on web resp\", \"onsibilities.  \\nReferences  \\n\\u2022 .NET Upgrade Assistant tool  \\n\\u2022 try-convert tool  \\n\\u2022 apiport tool  \\nS\", \"trategies for migrating while running in production  \\nMany teams have .NET Framework apps they plan \", \"to migrate to .NET Core/.NET 7, but the app is so \\nlarge that the migration requires a significant a\", \"mount of time to complete. The original app needs to \\nlive on while the migration is done piece by p\", \"iece. There needs to be a way for the old and new \\nversions of the app to work together side -by-sid\", \"e, or for the old version to be migrated in -place, at \\nleast some of the way, without breaking it. \", \"Teams can employ many different strategies to support \\nthese goals.  \\nRefactor the .NET Framework so\", \"lution  \\nA good place to start if you plan to port a .NET Framework app to .NET Core is to refactor \", \"it to work \\nbetter with .NET Core. This means updating individual class libraries to target .NET Sta\", \"ndard and \\nmoving as much logic out of your ASP.NET MVC projects an d into these class libraries. An\", \"y code you \\nhave in .NET Standard libraries is immediately usable from both .NET Framework to .NET C\", \"ore apps, \\nwhich is why this step is so valuable as part of a migration.  \\nWhen refactoring, make su\", \"re you\\u2019re following good refactoring fundamentals. For example, create \\ntests that verify what the s\", \"ystem does before you start refactoring. Run these tests when you\\u2019re done \\nto confirm you didn\\u2019t cha\", \"nge the system\\u2019s behavior. You ma y need to add characterization tests to the \\nsystem if you don\\u2019t a\", \"lready have a good suite of automated tests you can rely on.   \\n41 CHAPTER 3 | Migrate large solutio\", \"ns to ASP.NET Core  \\n Extract front -end assets to a CDN  \\nIf your .NET Framework apps include a lot\", \" of static assets, like scripts, CSS files, or images, you may be \\nable to migrate these to a separa\", \"te CDN. Then, update the existing app to reference the CDN links for \\nthese assets. When you port th\", \"e app to .NET Cor e, these static files won\\u2019t be part of the migration, \\nand you\\u2019ll just continue re\", \"ferencing them from the CDN in the ASP.NET Core app.  \\nExtract and migrate individual microservices \", \" \\nLarge .NET Framework apps may already be comprised of separate front -end systems that can be \\nmig\", \"rated individually. Or they may be candidates for migration to a microservices architecture, with \\ns\", \"ome pieces of existing ASP.NET MVC apps being pulled out into  new ASP.NET Core microservice \\nimplem\", \"entations. You can learn more about microservices in the associated ebook, .NET \\nMicroservices: Arch\", \"itecture for Containerized .NET Applications . \\nFor example, the existing app might have a set of fe\", \"atures it uses related to user sign -in and \\nregistration. These could be migrated to a separate mic\", \"roservice, which could be built and deployed \\nusing ASP.NET Core and then integrated into the legacy\", \" .NET F ramework app. Next, the app might \\nhave a few pages dedicated to tracking the individual use\", \"r\\u2019s shopping cart. These pages could also be \\npulled out into their own separate microservice and ag\", \"ain integrated into the existing app. In this way, \\nthe original .N ET Framework app continues runni\", \"ng in production, but with more and more of its \\nfeatures coming from modernized .NET Core microserv\", \"ices.  \\nDeploy multiple versions of the app side -by-side in IIS  \\nUsing a combination of host heade\", \"rs and redirects, an existing ASP.NET MVC app can be configured \\nto run side by side with an ASP.NET\", \" Core app on the same IIS server. As pieces of functionality, such \\nas individual controllers, are p\", \"orted to ASP.NET Core, th eir routes and URLs are mapped within IIS to \\ntarget the ASP.NET Core web \", \"site or sub -application (IIS virtual directories aren\\u2019t supported with \\nASP.NET Core apps). An ASP.\", \"NET Core app can be hosted as an IIS sub -application (sub -app). The \\nsub-app\\u2019s path be comes part \", \"of the root app\\u2019s URL.  \\nApply the Strangler pattern  \\nLarge ASP.NET MVC apps can be gradually repla\", \"ced with a new ASP.NET Core app by incrementally \\nmigrating pieces of functionality. One approach to\", \" this is called the strangler pattern , named for \\nstrangler vines that strangle and eventually tear\", \" down trees. This approach relies on first \\nimplementing a facade layer over top of the existing sol\", \"ution. This facade should be built using the \\nnew approach to the problem, or an off -the-shelf so l\", \"ution such as an API gateway.  \\nOnce the facade is in place, you can route part of it to a new ASP.N\", \"ET Core app. As you port more of \\nthe original .NET Framework app to .NET Core, you continue to upda\", \"te the facade layer accordingly, \\nsending more of the facade\\u2019s total functionality to the new system\", \". Figure 3 -5 shows the strangler \\npattern progression over time.   \\n42 CHAPTER 3 | Migrate large so\", \"lutions to ASP.NET Core  \\n  \\nFigure 3 -5. The Strangler pattern over time.  \\nEventually, the entire \", \"facade layer corresponds to the new, modern implementation. At this point, \\nboth the legacy system a\", \"nd the face layer can be retired. Microsoft has guidance on how to achieve \\nincremental ASP.NET to A\", \"SP.NET Core migration using the YARP reverse proxy . \\nMulti -targeting approaches  \\nMulti -targeting\", \" is recommended for large apps that will be migrated over time and for teams \\napplying the Strangler\", \" pattern approach. This approach can address BindingRedirect and package \\nrestoration challenges tha\", \"t surface from mixing PackageReference  and packages.config  restore styles. \\nThere are two options \", \"available for code that must run in both .NET Framework and .NET Core \\nenvironments.  \\n\\u2022 Preprocesso\", \"r directives ( #if in C#  or #If in Visual Basic ) allow you to implement different \\nfunctionality o\", \"r use different dependencies when run in .NET Framework versus .NET Core.  \\n\\u2022 Project files can use \", \"conditional globbing patterns , such as *.core.cs, to include different sets \\nof files based on whic\", \"h framework is being targeted.  \\nTypically you only follow these recommendations for class libraries\", \". These techniques allow a single \\ncommon codebase to be maintained while new functionality is added\", \" and features of the app are \\nincrementally ported to use .NET Core.  \\nSummary  \\nFrequently, large A\", \"SP.NET MVC and Web API apps won\\u2019t be ported to ASP.NET Core all at once, but \\nwill migrate increment\", \"ally over time. This section offers several strategies for performing this \\nincremental migration. C\", \"hoose the one(s) that will work best fo r your organization and app.  \\nReferences  \\n\\u2022 .NET Microserv\", \"ices: Architecture for Containerized .NET Applications  \\n\\u2022 eShopOnContainers Reference Microservices\", \" Application  \\n\\u2022 Host ASP.NET Core on Windows with IIS  \\n\\u2022 Strangler pattern  \\n\\u2022 Incremental ASP.NET\", \" to ASP.NET Core Migration  \\n \\n43 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n CHAPTER \", \" 4 \\nExample migration of \\neShop to ASP.NET Core  \\nIn this chapter, you\\u2019ll see how to migrate a .NET \", \"Framework app to .NET Core. The chapter examines a \\nsample online store app written for ASP.NET MVC \", \"5. The app will use many of the concepts and tools \\ndescribed earlier in this book. You\\u2019ll find the \", \"starting  point app in the eShopModernizing  GitHub \\nrepository . There are several different starti\", \"ng point apps. This chapter focuses on the \\neShopLegacyMVCSolution . \\nThe initial version of the pro\", \"ject is shown in Figure 4 -1. It\\u2019s a fairly standard ASP.NET MVC 5 app.  \\n \\nFigure 4 -1. The eShopMo\", \"dernizing  MVC sample project structure.  \\n \\n44 CHAPTER 4 | Example migration of eShop to ASP.NET Co\", \"re  \\n This chapter demonstrates how to perform many of the upgrade steps by hand. Alternatively, you\", \" can \\nuse the .NET Upgrade Assistant tool  to perform many of the initial steps, like converting the\", \" project \\nfile, changing the target framework, and updating NuGet packages.  \\nRun ApiPort  to identi\", \"fy problematic APIs  \\nThe first step in preparing to migrate is to run the ApiPort  tool. The tool i\", \"dentifies how many .NET \\nFramework APIs the app calls and how many of these have .NET Standard or .N\", \"ET Core equivalents. \\nFocus primarily on your own app\\u2019s logic, not third -party dependencies, and pa\", \"y attention to \\nSystem.Web dependencies tha t will need to be ported. The ApiPort tool was introduce\", \"d in the last \\nchapter on understanding and updating dependencies . Note that currently it requires \", \"Visual Studio \\n2019; Visual Studio 2022 support is planned.  \\nAfter installing and configuring the A\", \"piPort  tool, run the analysis from within Visual Studio, as shown \\nin Figure 4 -2.  \\n45 CHAPTER 4 |\", \" Example migration of eShop to ASP.NET Core  \\n  \\nFigure 4 -2. Analyze assembly portability in Visual\", \" Studio.  \\nChoose the web project\\u2019s assembly from the project\\u2019s bin folder, as shown in Figure 4 -3.\", \" \\n \\n46 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n  \\nFigure 4 -3. Choose the project\\u2019s\", \" web assembly.  \\nIf your solution includes several projects, you can choose all of them. The eShop  \", \"sample includes just a \\nsingle MVC project.  \\nOnce the report is generated, open the file and review\", \" the results. The summary provides a high -level \\nview of what percentage of .NET Framework calls yo\", \"ur app is making have compatible versions. Figure \\n4-4 shows the summary for the eShop  MVC project.\", \"  \\n \\nFigure 4 -4. ApiPort summary.  \\nFor this app, about 80 percent of the .NET Framework calls are \", \"compatible. 20 percent of the calls \\nneed to be addressed during the porting process. Viewing the de\", \"tails reveals that all of the \\nincompatible calls are part of System.Web, which is an expected incom\", \"patibility. The dependencies on \\nSystem.Web calls will be addressed when the app\\u2019s controllers and r\", \"elated classes are migrated in a \\nlater step. Figure 4 -5 lists some of the specific types found by \", \"the tool:  \\n \\n47 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n  \\nFigure 4 -5. ApiPort  i\", \"ncompatible type details.  \\nMost of the incompatible types refer to Controller and various related a\", \"ttributes that have equivalents \\nin ASP.NET Core.  \\nUpdate project files and NuGet reference syntax \", \" \\nNext, migrate from the older .csproj  file structure to the newer, simpler structure introduced wi\", \"th .NET \\nCore. In doing so, you\\u2019ll also migrate from using a packages.config  file for NuGet referen\", \"ces to using \\n<PackageReference> elements in the project file. Old -style project files may also use\", \" \\n<PackageReference> elements, so it usually makes sense to migrate all NuGet package references to \", \"\\nthis format first, before upgrading to the new project file format.  \\nThe original project\\u2019s eShopL\", \"egacyMVC.csproj  file is 418 lines long. A sample of the project file is \\nshown in Figure 4 -6. To o\", \"ffer a sense of its overall size and complexity, the right side of the image \\ncontains a miniature v\", \"iew of the entire file.  \\n \\n48 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n  \\nFigure 4 \", \"-6. The eShopLegacyMVC.csproj  file structure.  \\nA common way to create a new project file for an ex\", \"isting ASP.NET project is to create a new ASP.NET \\nCore app using dotnet new or File > New  > Projec\", \"t  in Visual Studio. Then files can be copied from \\nthe old project to the new one to complete the m\", \"igration.  \\nIn addition to the C# project file, NuGet dependencies are stored in a separate 45 -line\", \" packages.config  \\nfile, as shown in Figure 4 -7. \\n \\n49 CHAPTER 4 | Example migration of eShop to AS\", \"P.NET Core  \\n  \\nFigure 4 -7. The packages.config  file. \\nYou can migrate packages.config  in class l\", \"ibrary projects using Visual Studio. This functionality doesn\\u2019t \\nwork with ASP.NET projects, however\", \". Learn more about migrating packages.config  to \\n<PackageReference>  in Visual Studio . If you have\", \" a large number of projects to migrate, this \\ncommunity tool may help . If you\\u2019re using a tool to mi\", \"grate the project file to the new format, you \\nshould do that after you\\u2019ve finished migrating all Nu\", \"Get references to use <PackageReference>.  \\nCreate new ASP.NET Core project  \\nAdd a new ASP.NET Core\", \" project to the existing app\\u2019s solution to make moving files easier, as most of \\nthe work can be don\", \"e from within Visual Studio\\u2019s Solution Explorer . In Visual Studio, right -click on \\nyour app\\u2019s solu\", \"tion and choose Add New Project . Choose ASP.NET Core web application , and give \\nthe new project a \", \"name as shown in Figure 4 -8. \\n \\n50 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n  \\nFigu\", \"re 4 -8. Add new ASP.NET Core web application.  \\nThe next dialog will ask you to choose which templa\", \"te to use. Select the Empty  template. Be sure to \\nalso change the dropdown from .NET Core  to .NET \", \"Framework . Select ASP.NET Core 2.2 , as shown \\nin Figure 4 -9. \\n \\n51 CHAPTER 4 | Example migration \", \"of eShop to ASP.NET Core  \\n  \\nFigure 4 -9. Choose an Empty project template targeting .NET Framework\", \" with ASP.NET Core 2.2.  \\nMigrating NuGet Packages  \\nSince the built -in migration tool for migratin\", \"g packages.config  to <PackageReference> doesn\\u2019t work \\non ASP.NET projects, you can use a community \", \"tool instead, or migrate by hand. A community tool \\nI\\u2019ve used  uses an XSL file to transform from on\", \"e format to the other. To use it, first copy the \\npackages.config  file to the newly created ASP.NET\", \" Core project folder. Make a backup of your files, as \\nthis script removes the packages.config  file\", \" from all folders under where you run the script. Then run \\nthese commands from the project folder (\", \"or for the entire solution if you prefer):  \\niwr \\nhttps://gist.githubusercontent .com/aienabled /0bc\", \"e5e4b17118122f2772e7c9218bf9c /raw/7789\\n53f89882877a7124894b47dccfb1ba3e80a0 /Convert-ToPackageRefer\", \"ence .ps1 -OutFile Convert -\\nToPackageReference .ps1 \\niwr \\nhttps://gist.githubusercontent .com/aiena\", \"bled /0bce5e4b17118122f2772e7c9218bf9c /raw/7789\\n53f89882877a7124894b47dccfb1ba3e80a0 /Convert-ToPac\", \"kageReference .xsl -OutFile  Convert -\\nToPackageReference .xsl \\n./Convert-ToPackageReference .ps1 | \", \"Out-Null \\nThe first two commands download files so that they exist locally. The last line runs the s\", \"cript. After \\nrunning it, try to build the new project. You\\u2019ll most likely get some errors. To resol\", \"ve them, you\\u2019ll want \\nto eliminate some references (like most of the Microsoft.AspNet and System pac\", \"kages), and you may \\nneed to remove some xmlns attributes.  \\n \\n52 CHAPTER 4 | Example migration of e\", \"Shop to ASP.NET Core  \\n In most ASP.NET MVC apps, many client -side dependencies like Bootstrap and \", \"jQuery were deployed \\nusing NuGet packages. In ASP.NET Core, NuGet packages are only used for server\", \" -side functionality. \\nClient files should be managed through other means. Review th e list of <Pack\", \"ageReference> \\nelements added and remove and make note of any that are for client libraries, includi\", \"ng:  \\n\\u2022 Bootstrap  \\n\\u2022 jQuery  \\n\\u2022 jQuery.Validation  \\n\\u2022 Modernizr  \\n\\u2022 popper.js  \\n\\u2022 Respond  \\nThe sta\", \"tic client files installed by NuGet for these packages will be copied over to the new project\\u2019s \\nwww\", \"root  folder and hosted from there. It\\u2019s worth considering whether these files are still needed by \\n\", \"the app, and whether it makes sense to continue hosting them or to use a content delivery network \\n(\", \"CDN) instead. These library versions can be managed at build ti me using tools like LibMan  or npm. \", \"\\nFigure 4 -10 shows the full eShopPorted.csproj  file after migrating package references using the \\n\", \"conversion tool shown and removing unnecessary packages.  \\n \\nFigure 4 -10. Package references in the\", \" eShopPorted.csproj  file. \\nThe package references can be further compacted by making the <Version>1\", \".0.0.0</Version> \\nelement a Version=1.0.0.0 attribute on <PackageReference>.  \\n \\n53 CHAPTER 4 | Exam\", \"ple migration of eShop to ASP.NET Core  \\n Migrate static files  \\nAny static files the app uses, incl\", \"uding third -party scripts and frameworks but also custom images and \\nstylesheets, must be copied fr\", \"om the old project to the new one. In ASP.NET MVC apps, files were \\ntypically accessed based on thei\", \"r location within the pr oject folder. In ASP.NET Core apps, these static \\nfiles will be accessed ba\", \"sed on their location within the wwwroot  folder. For the eShop  project, there \\nare static files in\", \" the following folders:  \\n\\u2022 Content  \\n\\u2022 fonts  \\n\\u2022 Images  \\n\\u2022 Pics \\n\\u2022 Scripts  \\nThe Empty  project te\", \"mplate used in the previous step doesn\\u2019t include this folder by default, or the \\nmiddleware needed f\", \"or it to work. You\\u2019ll need to add them.  \\nAdd a wwwroot  folder to the root of the project.  \\nAdd ve\", \"rsion 2.2.0 of the Microsoft.AspNetCore.StaticFiles NuGet package.  \\nIn Startup.cs , add a call to a\", \"pp.UseStaticFiles() in the Configure method:  \\npublic void Configure (IApplicationBuilder app , IHos\", \"tingEnvironment env ) \\n{ \\n    if (env.IsDevelopment ()) \\n    { \\n        app.UseDeveloperExceptionPag\", \"e (); \\n    } \\n \\n    app.UseStaticFiles (); \\n \\n    // ... \\n} \\nCopy the Content  folder from the ASP.N\", \"ET MVC app to the new project\\u2019s wwwroot  folder.  \\nRun the app and navigate to its /Content/base.css\", \"  folder to verify that the static file is served correctly \\nfrom its expected path. Continue copyin\", \"g the rest of the folders containing static files to the new \\nproject. You\\u2019ll also want to copy the \", \"favicon.ico  file from the project\\u2019s root to the wwwroot  folder. \\nFigure 4 -11 shows the results af\", \"ter these files and their folders have all been copied.   \\n54 CHAPTER 4 | Example migration of eShop\", \" to ASP.NET Core  \\n  \\nFigure 4 -11. Static folders copied over to wwwroot  folder.  \\nMigrate C# file\", \"s  \\nNext, copy over the C# files used by the app, including standard MVC folders and their contents \", \"like \\nControllers , Models , ViewModel , and Services . There will most likely be some changes neede\", \"d in these \\nfiles. It\\u2019s best to copy one folder (or subfolder) at a time and compile to see what err\", \"ors need to be \\naddressed as you go.  \\nFor the eShop  sample, the first folder I choose to migrate i\", \"s the Models  folder, which includes C# \\nentities and Entity Framework classes. This folder\\u2019s classe\", \"s are used by most of the others, so they \\nwon\\u2019t work until these classes have been copied. After co\", \"pying the folder and building, the compiler \\nrevealed errors related to missing namespace System.Web\", \".Hosting, related access to \\nHostingEnvironment, and a reference to ConfigurationManager.AppSettings\", \". The solution to these \\nissues will be to pass in the nec essary path data; for now the breaking li\", \"nes are commented out and a \\nTODO: comment is added to each one to track it. After changing five lin\", \"es, the Task List  shows five \\nitems and the project builds.  \\nNext, the ViewModel  folder, with its\", \" one class, is copied over. It\\u2019s an easy one, and builds immediately.  \\nThe Services  folder is copi\", \"ed over. This folder\\u2019s classes depend on Entity Framework classes from the \\nModels  folder, which is\", \" why it needed to be copied after that folder. Fortunately, it too builds without \\nerrors.  \\n \\n55 CH\", \"APTER 4 | Example migration of eShop to ASP.NET Core  \\n That leaves the Controllers  folder and its \", \"two Controller classes. After copying the folder to the new \\nproject and building, there are seven b\", \"uild errors. Four of them are related to ViewBag access and \\nreport an error of:  \\nMissing compiler \", \"required member 'Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo.Create'  \\nTo resolve this error, \", \"add a NuGet package reference to C#:  \\n<PackageReference  Include= \\\"Microsoft.CSharp\\\"  Version= \\\"4.7\", \".0\\\" /> \\nThe remaining three errors specify types that are defined in an assembly that isn\\u2019t referenc\", \"ed. \\nSpecifically these types:  \\n\\u2022 HttpServerUtilityBase  \\n\\u2022 RouteValueDictionary  \\n\\u2022 HttpRequestBas\", \"e  \\nLet\\u2019s look at each error one by one. The first error occurs while trying to reference the Server\", \" property \\nof Controller, which no longer exists. The goal of the operation is to get the path to an\", \" image file in \\nthe app:  \\nif (item != null) \\n{ \\n    var webRoot = Server.MapPath(\\\"~/Pics\\\" ); // com\", \"piler error on this line  \\n    var path = Path.Combine(webRoot, item.PictureFileName ); \\n \\n    strin\", \"g imageFileExtension = Path.GetExtension (item.PictureFileName ); \\n    string mimetype = GetImageMim\", \"eTypeFromImageFileExtension (imageFileExtension ); \\n \\n    var buffer = System.IO.File.ReadAllBytes (\", \"path); \\n \\n    return File(buffer, mimetype ); \\n} \\nThere are two possible solutions to this problem. \", \"The first is to keep the functionality as it is. In this \\ncase, rather than using Server.MapPath, a \", \"fixed path referencing the image files\\u2019 location in wwwroot  \\nshould be used. Alternately, since the\", \" only purpose of this action method is to return a static image \\nfile, the references to this action\", \" in view files can be updated to reference the static files directly, which \\nimproves runtime perfor\", \"mance. Since no pro cessing is being done as part of this action, th ere\\u2019s no \\nreason not to just se\", \"rve the files directly. If it\\u2019s not tenable to update all references to this action, the \\naction cou\", \"ld be rewritten to produce a redirect to the static file\\u2019s location.  \\nThe next two errors both occu\", \"r in the same private method in the same line of code:  \\nprivate void AddUriPlaceHolder (CatalogItem\", \" item ) \\n{ \\n    item.PictureUri  = this.Url.RouteUrl (PicController .GetPicRouteName , new { catalog\", \"ItemId \\n= item.Id }, this.Request.Url.Scheme); \\n} \\nBoth this.Url and this.Request cause compiler err\", \"ors. Looking at how this code is used, its purpose is \\nto build a link to the PicController action t\", \"hat renders image files. The same one we just discovered \\ncould probably be replaced with direct lin\", \"ks to the  static files located in wwwroot . For now, it\\u2019s worth \\ncommenting out this code and addin\", \"g a TODO: comment to reference the pics another way.   \\n56 CHAPTER 4 | Example migration of eShop to\", \" ASP.NET Core  \\n It\\u2019s worth noting that the base Controller class, used by the CatalogController cla\", \"ss in which this code \\nappears, is still referring to System.Web.Mvc.Controller. There will undoubte\", \"dly be more errors to fix \\nonce we update this to use ASP.NET Core. First, remove the using System.W\", \"eb.Mvc; line from the list \\nof using statements in CatalogController. Next, add the NuGet package Mi\", \"crosoft.AspNetCore.Mvc. \\nFinally, add a using Microsoft.AspNetCore.Mvc; statement, and build the app\", \" again.  \\nThis time, there are 16 errors:  \\n\\u2022 Include is not a valid named attribute argument (2)  \\n\", \"\\u2022 HttpStatusCodeResult not found (3)  \\n\\u2022 HttpNotFound does not exist (3)  \\n\\u2022 SelectList not found (8\", \")  \\nOnce more, let\\u2019s review these errors one by one. First, SelectList can be fixed by adding using \", \"\\nMicrosoft.AspNetCore.Mvc.Rendering;, which eliminates half of the errors.  \\nAll references to retur\", \"n HttpNotFound(); should be replaced with return NotFound();.  \\nAll references to return new HttpSta\", \"tusCodeResult(HttpStatusCode.BadRequest); should be replaced \\nwith return BadRequest();.  \\nThat just\", \" leaves the use of Include with a [Bind] attribute on a couple of action methods that look like \\nthi\", \"s: \\n[HttpPost ] \\n[ValidateAntiForgeryToken ] \\npublic ActionResult Create([Bind(Include = \\n\\\"Id,Name,D\", \"escription,Price,PictureFileName,CatalogTypeId,CatalogBrandId,AvailableStock,Rest\\nockThreshold,MaxSt\", \"ockThreshold,OnReorder\\\" )] CatalogItem catalogItem ) \\n{ \\nThe preceding code restricts model binding \", \"to the properties listed in the Include string. In ASP.NET \\nCore MVC, the [Bind] attribute still exi\", \"sts, but no longer needs the Include = argument. Pass the list of \\nproperties directly to the [Bind]\", \" attribute:  \\n[HttpPost ] \\n[ValidateAntiForgeryToken ] \\npublic ActionResult \\nCreate([Bind(\\\"Id,Name,D\", \"escription,Price,PictureFileName,CatalogTypeId,CatalogBrandId,Availa\\nbleStock,RestockThreshold,MaxSt\", \"ockThreshold,OnReorder\\\" )] CatalogItem catalogItem ) \\n{ \\nWith these changes, the project compiles on\", \"ce more. It\\u2019s generally a better practice to use separate \\nmodel types for controller inputs, rather\", \" than using model binding directly to your domain model or \\ndata model types.  \\nMigrate views  \\nThe \", \"two biggest ASP.NET Core MVC features related to views are Razor Pages  and Tag Helpers . For \\nthe i\", \"nitial migration, we won\\u2019t use either feature. You should, however, keep the features in mind if \\nyo\", \"u continue supporting the app once it\\u2019s been migrated. The next step is to copy the Views  folder \\nf\", \"rom the original project into the new one. After building, there are nine errors:   \\n57 CHAPTER 4 | \", \"Example migration of eShop to ASP.NET Core  \\n \\u2022 HttpContext does not exist (2)  \\n\\u2022 Scripts does not \", \"exist (5)  \\n\\u2022 Styles does not exist (1)  \\n\\u2022 HtmlString could not be found(1)  \\nInvestigating these e\", \"rrors finds that most of them are in the main *_Layout.cshtml , with several related \\nto rendering s\", \"cript and style tags, or displaying when the server hosting the app was last restarted. The \\nfollowi\", \"ng code listing shows problem areas in the _Layout.cshtml* file:  \\n// other lines omitted; only erro\", \"rs shown  \\n@Styles.Render(\\\"~/Content/css\\\")  \\n@Scripts.Render(\\\"~/bundles/modernizr\\\")  \\n \\n@{ var sessi\", \"onInfo = new HtmlString($\\\"{HttpContext.Current.Session[\\\"MachineName\\\"]}, \\n{HttpContext.Current.Sessio\", \"n[\\\"SessionStartTime\\\"]}\\\");}  \\n \\n@Scripts.Render(\\\"~/bundles/jquery\\\")  \\n@Scripts.Render(\\\"~/bundles/boot\", \"strap\\\")  \\nThe reference to Modernizr can be removed. The references to Bootstrap and jQuery can be r\", \"eplaced \\nwith CDN links to the appropriate version.  \\nReplace @Styles.Render line with:  \\n<link rel=\", \"\\\"stylesheet\\\"  \\nhref=\\\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\\\"  \\nint\", \"egrity =\\\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\\\"  \\ncrossorigin =\\\"an\", \"onymous\\\" > \\nReplace the last two Scripts.Render lines with:  \\n<script src=\\\"https://code.jquery.com/j\", \"query -3.3.1.slim.min.js\\\"  integrity =\\\"sha384-\\nq8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8ab\", \"tTE1Pi6jizo\\\"  \\ncrossorigin =\\\"anonymous\\\" ></script> \\n<script src=\\\"https://cdnjs.cloudflare.com/ajax/l\", \"ibs/popper.js/1.14.7/umd/popper.min.js\\\"  \\nintegrity =\\\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTM\", \"Ga3JDZwrnQq4sF86dIHNDz0W1\\\"  \\ncrossorigin =\\\"anonymous\\\" ></script> \\n<script src=\\\"https://stackpath.boo\", \"tstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\\\"  \\nintegrity =\\\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6\", \"OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\\\"  \\ncrossorigin =\\\"anonymous\\\" ></script> \\nFinally, after the Boot\", \"strap <link>, add additional <link> elements for local styles your app uses. For \\neShop , the result\", \" is shown here:  \\n<link rel=\\\"stylesheet\\\"  href=\\\"~/Content/custom.css\\\"  /> \\n<link rel=\\\"stylesheet\\\"  h\", \"ref=\\\"~/Content/base.css\\\"  /> \\n<link rel=\\\"stylesheet\\\"  href=\\\"~/Content/Site.css\\\"  /> \\nTo determine th\", \"e order in which the <link> elements should appear, look at your original app\\u2019s \\nrendered HTML. Alte\", \"rnatively, review BundleConfig.cs , which for the eShop  sample includes this code \\nindicating the a\", \"ppropriate sequence:  \\nbundles.Add(new StyleBundle (\\\"~/Content/css\\\" ).Include( \\n          \\\"~/Content\", \"/bootstrap.css\\\" , \\n          \\\"~/Content/custom.css\\\" ,  \\n58 CHAPTER 4 | Example migration of eShop to\", \" ASP.NET Core  \\n           \\\"~/Content/base.css\\\" , \\n          \\\"~/Content/site.css\\\" )); \\nBuilding agai\", \"n reveals one more error loading jQuery Validation on the Create  and Edit views. Replace \\nit with t\", \"his script:  \\n<script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/jquery -\\nvalidate/1.17.0/jquery.va\", \"lidate.min.js\\\"  integrity =\\\"sha512-\\nO/nUTF5mdFkhEoQHFn9N5wmgYyW323JO6v8kr6ltSRKriZyTr/8417taVWeabVS4\", \"iONGk2V444QD0P2cwhuTkg==\\\"  \\ncrossorigin =\\\"anonymous\\\" ></script> \\nThe last thing to fix in the views \", \"is the reference to Session to display how long the app has been \\nrunning, and on which machine. We \", \"can display this data directly in the site\\u2019s *_Layout.cshtml* by \\nusing System.Environment.MachineNa\", \"me and \\nSystem.Diagnosti cs.Process.GetCurrentProcess().StartTime:  \\n<section class=\\\"col -sm-6\\\"> \\n  \", \"  <img class=\\\"esh -app-footer-text hidden -xs\\\" src=\\\"~/images/main_footer_text.png\\\" \\nwidth=\\\"335\\\" heig\", \"ht=\\\"26\\\" alt=\\\"footer text image\\\" />  \\n    <br /> \\n<small>@Environment.MachineName - \\n@System.Diagnost\", \"ics.Process.GetCurrentProcess().St artTime.ToString() UTC</small>  \\n</section>  \\nAt this point, the \", \"app once more builds successfully. However, trying to run it just yields Hello World!  \\nbecause the \", \"Empty  ASP.NET Core template is only configured to display that in response to any \\nrequest. In the \", \"next section, I complete the migration by configuring the app to use ASP.NET Core \\nMVC, including de\", \"pendency injection and configuration. Once that\\u2019s in place, the app should run. \\nThen it will be tim\", \"e to fix the TODO: tasks that were created earlier.  \\nMigrate app startup components  \\nThe last migr\", \"ation step is to take the app startup tasks from Global.asax , and the classes it calls, and \\nmigrat\", \"e these to their ASP.NET Core equivalents. These tasks include configuration of MVC itself, \\nsetting\", \" up dependency injection, and working with the new configuration system. In ASP.NET Core, \\nthese tas\", \"ks are handled in th e Startup.cs  file. \\nConfigure MVC  \\nThe original ASP.NET MVC app has the follo\", \"wing code in its Application_Start in Global.asax , which \\nruns when the app starts up:  \\nprotected \", \" void Application_Start () \\n{ \\n    container = RegisterContainer (); \\n    AreaRegistration .Register\", \"AllAreas (); \\n    FilterConfig .RegisterGlobalFilters (GlobalFilters .Filters); \\n    RouteConfig .Re\", \"gisterRoutes (RouteTable .Routes); \\n    BundleConfig .RegisterBundles (BundleTable .Bundles); \\n    C\", \"onfigDataBase (); \\n}  \\n59 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n Looking at these\", \" lines one by one, the RegisterContainer method sets up dependency injection, which \\nwill be ported \", \"below. The next three lines configure different parts of MVC: areas, filters, and routes. \\nBundles a\", \"re replaced by static files in the ported app. The last line sets up data access for the app, \\nwhich\", \" will be shown in a later section.  \\nSince this app isn\\u2019t actually using areas, there\\u2019s nothing that\", \" needs to be done to migrate the area \\nregistration call. If your app does need to migrate areas, th\", \"e docs specify how to configure areas in \\nASP.NET Core . \\nThe call to register global filters invoke\", \"s a helper on the FilterConfig class in the app\\u2019s App_Start  \\nfolder:  \\npublic static void RegisterG\", \"lobalFilters (GlobalFilterCollection filters ) \\n{ \\n    filters.Add(new HandleErrorAttribute ()); \\n} \", \"\\nThe only attribute added to the app is the ASP.NET MVC filter, HandleErrorAttribute. This filter en\", \"sures \\nthat when an exception occurs as part of a request, a default action and view are displayed, \", \"rather \\nthan the exception details. In ASP.NET Core, this s ame functionality is performed by the \\nU\", \"seExceptionHandler middleware. The detailed error messages aren\\u2019t enabled by default. They must \\nbe \", \"configured using the UseDeveloperExceptionPage middleware. To configure this behavior to match \\nthe \", \"original app, the f ollowing code must be added to the start of the Configure method in Startup.cs :\", \" \\npublic void Configure (IApplicationBuilder app , IWebHostEnvironment env ) \\n{ \\n    if (env.IsDevel\", \"opment ()) \\n    { \\n        app.UseDeveloperExceptionPage (); \\n    } \\n    else \\n    { \\n        app.Us\", \"eExceptionHandler (\\\"/Error\\\" ); \\n    } \\n    // ... \\n} \\nThis takes care of the only filter used by the\", \" eShop app, and in this case it was done by using built -in \\nmiddleware. If you have global filters \", \"that must be configured in your app, this is done when MVC is \\nadded in Program.cs  when you configu\", \"re services, which is shown later in this chapter.  \\nThe last piece of MVC -related logic that needs\", \" to be migrated are the app\\u2019s default routes. The call to \\nRouteConfig.RegisterRoutes(RouteTable.Rou\", \"tes) passes the MVC route table to the RegisterRoutes \\nhelper method, where the following code is ex\", \"ecuted when the app starts up:  \\npublic static void RegisterRoutes (RouteCollection routes ) \\n{ \\n   \", \" routes.MapMvcAttributeRoutes (); \\n    routes.IgnoreRoute (\\\"{resource}.axd/{*pathInfo}\\\" ); \\n \\n    ro\", \"utes.MapRoute ( \\n        name: \\\"Default\\\" , \\n        url: \\\"{controller}/{action}/{id}\\\" , \\n        def\", \"aults : new { controller = \\\"Catalog\\\" , action = \\\"Index\\\", id = \\nUrlParameter .Optional  }  \\n60 CHAPTE\", \"R 4 | Example migration of eShop to ASP.NET Core  \\n     ); \\n} \\nTaking this code line -by-line, the f\", \"irst line sets up support for attribute routes. This is built into \\nASP.NET Core, so it\\u2019s unnecessar\", \"y to configure it separately. Likewise, {resource}.axd  files aren\\u2019t used \\nwith ASP.NET Core, so the\", \"re\\u2019s no need to ignore such routes. The MapRoute method configures the \\ndefault for MVC, which uses \", \"the typical {controller}/{action}/{id} route template. It also specifies the \\ndefaults for this temp\", \"late, such tha t the CatalogController is the default controller used and the Inde x \\nmethod is the \", \"default action. Larger apps will frequently include more calls to MapRoute to set up \\nadditional rou\", \"tes.  \\nASP.NET Core MVC supports conventional routing and attribute routing . Conventional routing i\", \"s \\nanalogous to how the route table is configured in the RegisterRoutes method listed previously. To\", \" set \\nup conventional routing with a default route like the one used in the eShop  app, add the foll\", \"owing \\ncode to the bottom of the Configure method in Startup.cs : \\napp.UseMvc(routes => \\n{ \\n   route\", \"s.MapRoute (\\\"default\\\" , \\\"{controller=Catalog}/{action=Index}/{id?}\\\" ); \\n}); \\n \\n \\nNote  \\nWith ASP.NET\", \" Core 3.0 and later, this is changed to use endpoints. For the initial port to ASP.NET Core \\n2.2, th\", \"is is the proper syntax for mapping conventional routes.  \\nWith these changes in place, the Configur\", \"e method is almost done. The original template\\u2019s app.Run \\nmethod that prints Hello World!  should be\", \" deleted. At this point, the method is as shown here:  \\npublic void Configure (IApplicationBuilder a\", \"pp , IHostingEnvironment env ) \\n{ \\n    if (env.IsDevelopment ()) \\n    { \\n        app.UseDeveloperExc\", \"eptionPage (); \\n    } \\n    else \\n    { \\n        app.UseExceptionHandler (\\\"/Home/Error\\\" ); \\n    } \\n \\n\", \"    app.UseStaticFiles (); \\n \\n    app.UseMvc(routes => \\n    { \\n        routes.MapRoute (\\\"default\\\" , \", \"\\\"{controller=Catalog}/{action=Index}/{id?}\\\" ); \\n    }); \\n} \\nNow it\\u2019s time to configure MVC services,\", \" followed by the rest of the app\\u2019s support for dependency \\ninjection (DI). So far, the eShopPorted  \", \"project\\u2019s Program.cs  file hasn\\u2019t added any service configuration. \\nNow it\\u2019s time to start adding ne\", \"cessary services.  \\nFirst, to get ASP.NET Core MVC to work properly, it needs to be added:   \\n61 CHA\", \"PTER 4 | Example migration of eShop to ASP.NET Core  \\n builder.Services .AddMvc(); \\nThe preceding co\", \"de is the minimal configuration required to get MVC features working. There are \\nmany additional fea\", \"tures that can be configured from this call (some of which are detailed later in this \\nchapter), but\", \" for now this will suffice to build the ap p. Running it now routes the default request \\nproperly, b\", \"ut since we\\u2019ve not yet configured DI, an error occurs while activating CatalogController, \\nbecause n\", \"o implementation of type ICatalogService has been provided yet. We\\u2019ll return to configure \\nMVC furth\", \"er  in a moment. For now, let\\u2019s migrate the app\\u2019s dependency injection.  \\nMigrate dependency injecti\", \"on configuration  \\nThe original app\\u2019s Global.asax  file defines the following method, called when th\", \"e app starts up:  \\nprotected  IContainer RegisterContainer () \\n{ \\n  var builder = new ContainerBuild\", \"er (); \\n \\n  builder.RegisterControllers (typeof(MvcApplication ).Assembly ); \\n \\n  var mockData = boo\", \"l.Parse(ConfigurationManager .AppSettings [\\\"UseMockData\\\" ]); \\n  builder.RegisterModule (new Applicat\", \"ionModule (mockData )); \\n \\n  var container = builder.Build(); \\n  DependencyResolver .SetResolver (ne\", \"w AutofacDependencyResolver (container )); \\n \\n  return container ; \\n} \\nThis code configures an Autof\", \"ac  container, reads a config setting to determine whether real or mock \\ndata should be used, and pa\", \"sses this setting into an Autofac module (found in the app\\u2019s /Modules  \\ndirectory). Fortunately, Aut\", \"ofac supports .NET Core, so the module can be migrated directly. Copy the \\nfolder into the new proje\", \"ct and updates the class\\u2019s namespace and it should compile.  \\nASP.NET Core has built -in support for\", \" dependency injection, but you can wire up a third -party \\ncontainer such as Autofac easily if neces\", \"sary. In this case, since the app is already configured to use \\nAutofac, the simplest solution is to\", \" maintain its usage. I n Program.cs , simply configure the builder to \\nuse the AutofacServiceProvide\", \"rFactory as shown:  \\n// using Autofac.Extensions.DependencyInjection  \\nbuilder.Host.UseServiceProvid\", \"erFactory (new AutofacServiceProviderFactory ()); \\n// note: the factory calls builder.Populate so we\", \" don't need to here  \\nbool useMockData = true; // TODO: read from config  \\nbuilder.Host.ConfigureCon\", \"tainer <ContainerBuilder >(builder => \\n    builder.RegisterModule (new ApplicationModule (useMockDat\", \"a ))); \\nFor now, the setting for useMockData is set to true. This setting will be read from configur\", \"ation in a \\nmoment. At this point, the app compiles and should load successfully when run, as shown \", \"in Figure 4 -\\n12.  \\n62 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n  \\nFigure 4 -12. Por\", \"ted eShop  app running locally with mock data.  \\nMigrate app settings  \\nASP.NET Core uses a new conf\", \"iguration system , which by default uses an appsettings.json  file. By using \\nCreateDefaultBuilder i\", \"n Program.cs , the default configuration is already set up in the app. To access \\nconfiguration, cla\", \"sses just need to request it in their constructor. In Program.cs , configuration is \\naccessible from\", \" builder.Configuration.  \\nThe original app referenced its settings using ConfigurationManager.AppSet\", \"tings. A quick search for \\nall references of this term yields the set of settings the new app needs.\", \" There are only two:  \\n\\u2022 UseMockData  \\n\\u2022 UseCustomizationData  \\nIf your app has more complex configu\", \"ration, especially if it\\u2019s using custom configuration sections, \\nyou\\u2019ll probably want to create and \", \"bind objects to different parts of your app\\u2019s configuration. These \\ntypes can then be accessed using\", \" the options pattern . However, as noted in the referenced doc, this \\npattern shouldn\\u2019t be used in P\", \"rogram.cs  (or Startup.ConfigureServices). Instead the ported app will \\nreference the UseMockData co\", \"nfiguration value directly.  \\nFirst, modify the ported app\\u2019s appsettings.json file and add the two s\", \"ettings in the root:  \\n{ \\n  \\\"Logging\\\" : { \\n \\n63 CHAPTER 4 | Example migration of eShop to ASP.NET Co\", \"re  \\n     \\\"LogLevel\\\" : { \\n      \\\"Default\\\" : \\\"Warning\\\"  \\n    } \\n  }, \\n  \\\"AllowedHosts\\\" : \\\"*\\\", \\n  \\\"Use\", \"MockData\\\" : \\\"true\\\", \\n  \\\"UseCustomizationData\\\"  :  \\\"true\\\" \\n} \\nNow, modify Program.cs  to access the U\", \"seMockData setting from the builder.Configuration property \\n(where previously we set the value to tr\", \"ue):  \\nbool useMockData = builder.Configuration .GetValue <bool>(\\\"UseMockData\\\" ); \\nAt this point, th\", \"e setting is pulled from configuration. The other setting, UseCustomizationData, is \\nused by the Cat\", \"alogDBInitializer class. When you first ported this class, you commented out the access \\nto Configur\", \"ationManager.AppSettings[\\\"UseCustomizationData\\\"]. Now it\\u2019s time to modify it to use \\nASP.NET Core co\", \"nfiguration. Modify the constructor of CatalogDBInitializer as follows:  \\n  // add using Microsoft.E\", \"xtensions.Configuration  \\n  public CatalogDBInitializer (CatalogItemHiLoGenerator indexGenerator , \\n\", \"      IConfiguration configuration ) \\n  { \\n      this.indexGenerator  = indexGenerator ; \\n      useC\", \"ustomizationData = configuration .GetValue <bool>(\\\"UseCustomizationData\\\" ); \\n  } \\nAll access to conf\", \"iguration within the web app should be modified in this manner to use the new \\nIConfiguration type. \", \"Dependencies that require access to .NET Framework configuration can include \\nsuch settings in an ap\", \"p.config  file added to the web project. The dependent projects can work with \\nConfigurationManager \", \"to access settings, and shouldn\\u2019t require any changes if they already use this \\napproach. However, s\", \"ince ASP.NET Core apps run as their own executable, they don\\u2019t refe rence \\nweb.config  but rather ap\", \"p.config . By migrating settings from the legacy app\\u2019s web.config  file to a new \\napp.config  file i\", \"n the ASP.NET Core app, components that use ConfigurationManager to access their \\nsettings will cont\", \"inue to function properly.  \\nThe app\\u2019s migration is nearly complete. The only remaining task is data\", \" access configuration.  \\nData access considerations  \\nASP.NET Core apps running on .NET Framework ca\", \"n continue to use Entity Framework (EF). If \\nperforming an incremental migration, getting the app wo\", \"rking with EF 6 before trying to port its data \\naccess to use EF Core may be worthwhile. In this way\", \", any proble ms with the app\\u2019s migration can be \\nidentified and addressed before another block of mi\", \"gration effort is begun.  \\nAs it happens, configuring EF 6 in the eShop sample migration doesn\\u2019t req\", \"uire any special work, since \\nthis work was performed in the Autofac ApplicationModule. The only pro\", \"blem is that currently the \\nCatalogDBContext class tries to read its connection strin g from web.con\", \"fig . To address this, the \\nconnection details need to be added to appsettings.json . Then the conne\", \"ction string must be passed \\ninto CatalogDBContext when it\\u2019s created.  \\nUpdate the appsettings.json \", \" to include the connection string. The full file is listed here:   \\n64 CHAPTER 4 | Example migration\", \" of eShop to ASP.NET Core  \\n { \\n  \\\"ConnectionStrings\\\" : { \\n    \\\"DefaultConnection\\\" : \\n\\\"Server=(local\", \"db) \\\\\\\\mssqllocaldb;Database=eShopPorted;Trusted_Connection=True;MultipleActive\\nResultSets=true\\\"  \\n  \", \"}, \\n  \\\"Logging\\\" : { \\n    \\\"LogLevel\\\" : { \\n      \\\"Default\\\" : \\\"Warning\\\"  \\n    } \\n  }, \\n  \\\"AllowedHosts\\\"\", \" : \\\"*\\\", \\n  \\\"UseMockData\\\" : \\\"false\\\", \\n  \\\"UseCustomizationData\\\" : \\\"true\\\" \\n} \\nThe connection string mus\", \"t be passed into the constructor when the DbContext is created. Since the \\ninstances are created by \", \"Autofac, the change needs to be made in ApplicationModule. Modify the \\nmodule to take in a connectio\", \"nString in its constructor and as sign it to a field. Then modify the \\nregistration for CatalogDBCon\", \"text to add connection string as a parameter:  \\nbuilder.RegisterType <CatalogDBContext >() \\n  .WithP\", \"arameter (\\\"connectionString\\\" , _connectionString ) \\n  .InstancePerLifetimeScope (); \\nThe parameter m\", \"ust also be added to a new constructor overload in CatalogDBContext itself:  \\npublic CatalogDBContex\", \"t (string connectionString ) : base(connectionString ) \\n{ \\n} \\nFinally, Program.cs  must read the con\", \"nection string from Configuration and pass it into the \\nApplicationModule when it instantiates it:  \", \"\\nbool useMockData = Configuration .GetValue <bool>(\\\"UseMockData\\\" ); \\nstring connectionString = Confi\", \"guration .GetConnectionString (\\\"DefaultConnection\\\" ); \\nbuilder.RegisterModule (new ApplicationModule\", \" (useMockData , connectionString )); \\nWith this code in place, the app runs as it did before, connec\", \"ting to a SQL Server database when \\nUseMockData is false.  \\nThe app can be deployed and run in produ\", \"ction at this point, converted to ASP.NET Core but still \\nrunning on .NET Framework and EF 6. If des\", \"ired, the app can be migrated to run on .NET Core and \\nEntity Framework Core, which will bring addit\", \"ional advantages d escribed in earlier chapters. Specific \\nto Entity Framework, this documentation c\", \"ompares EF Core and EF 6  and includes a grid showing \\nwhich library supports each of dozens of indi\", \"vidual features.  \\nMigrate to Entity Framework Core  \\nAssuming a decision is made to migrate to EF C\", \"ore, the steps can be fairly straightforward, especially \\nif the original app used a code -based mod\", \"el approach. When preparing to port from EF 6 to EF Core , \\nreview the availability of features in t\", \"he destination version of EF Core you\\u2019ll be using. Review the \\ndocumentation on porting from and EDM\", \"X -based model  versus porting from a code -based model .  \\n65 CHAPTER 4 | Example migration of eSho\", \"p to ASP.NET Core  \\n To upgrade to EF Core 2.2, the basic steps involved are to add the appropriate \", \"NuGet package(s) and \\nupdate namespaces. Then adjust how the connection string is passed to the DbCo\", \"ntext type and how \\nthey\\u2019re wired up for dependency injection.  \\nEF Core is added as a package refer\", \"ence to the project:  \\n<PackageReference  Include= \\\"Microsoft.EntityFrameworkCore\\\"  Version= \\\"2.2.6\\\"\", \" /> \\nThe reference to EF 6 is removed:  \\n<PackageReference  Include= \\\"EntityFramework\\\"  Version= \\\"6.\", \"2.0\\\" /> \\nThe compiler will report errors in CatalogDBContext and CatalogDBInitializer. CatalogDbCont\", \"ext \\nneeds to have the old namespaces removed and replaced with Microsoft.EntityFrameworkCore. Its \\n\", \"constructors can be removed. DbModelBuilder should be replaced with  ModelBuilder. The helper \\nmetho\", \"ds for configuring types are moved to separate classes implementing \\nIEntityTypeConfiguration<T>. Th\", \"en the CatalogDBContext class\\u2019s OnModelCreating method simply \\nbecomes:  \\nprotected  override  void \", \"OnModelCreating (ModelBuilder builder ) \\n{ \\n    builder.ApplyConfigurationsFromAssembly (Assembly .G\", \"etExecutingAssembly ()); \\n \\n    base.OnModelCreating (builder); \\n} \\nOther changes involved include: \", \" \\n\\u2022 HasDatabaseGeneratedOption(DatabaseGeneratedOption.None) replaced with \\nValueGeneratedNever()  \\n\", \"\\u2022 HasRequired<T> replaced with HasOne<T>  \\n\\u2022 Installed Microsoft.EntityFrameworkCore.Relational pack\", \"age  \\n\\u2022 Add a constructor to CatalogDBContext taking DbContextOptions and passing it to the base \\nco\", \"nstructor  \\nAn example configuration class for CatalogType is shown here:  \\nusing Microsoft .EntityF\", \"rameworkCore ; \\nusing Microsoft .EntityFrameworkCore .Metadata .Builders ; \\n \\nnamespace  eShopPorted\", \" .Models.Config \\n{ \\n    public class CatalogTypeConfig : IEntityTypeConfiguration <CatalogType > \\n  \", \"  { \\n        public void Configure (EntityTypeBuilder <CatalogType > builder) \\n        { \\n          \", \"  builder.ToTable(nameof(CatalogType )); \\n \\n            builder.HasKey(ci => ci.Id); \\n \\n            \", \"builder.Property (ci => ci.Id) \\n               .IsRequired (); \\n \\n            builder.Property (cb =\", \"> cb.Type) \\n                .IsRequired () \\n                .HasMaxLength (100);  \\n66 CHAPTER 4 | Ex\", \"ample migration of eShop to ASP.NET Core  \\n         } \\n    } \\n} \\nThe CatalogDBInitializer and its ba\", \"se class, CreateDatabaseIfNotExists<T>, are incompatible with EF \\nCore. The purpose of this class is\", \" to create and seed the database. Using EF Core will create and drop \\nthe associated database for a \", \"DbContext  using these methods:  \\ndbContext .Database .EnsureDeleted (); \\ndbContext .Database .Ensur\", \"eCreated (); \\nSeeding data in EF Core can be done with manual scripts, or as part of the type config\", \"uration. Along \\nwith other entity properties, seed data can be configured in IEntityTypeConfiguratio\", \"n classes by using \\nbuilder.HasData(). The original app loaded seed data  from CSV files in the Setu\", \"p  directory. Given that \\nthere are only a handful of items, these data records can instead be added\", \" as part of the entity \\nconfiguration. This approach works well for lookup data in tables that chang\", \"e infrequently. Adding the \\nfollowing to CatalogTypeConfig\\u2019s Configure method ensures the associated\", \" rows are present when \\nthe database is created:  \\nbuilder.HasData( \\n    new CatalogType { Id = 1, T\", \"ype = \\\"Mug\\\" }, \\n    new CatalogType { Id = 2, Type = \\\"T-Shirt\\\" }, \\n    new CatalogType { Id = 3, Typ\", \"e = \\\"Sheet\\\" }, \\n    new CatalogType { Id = 4, Type = \\\"USB Memory Stick\\\"  } \\n); \\nThe initial app incl\", \"udes a PreconfiguredData class, which includes data for CatalogBrand and \\nCatalogType, so using this\", \" method the HasData call reduces to:  \\nbuilder.HasData( \\n    PreconfiguredData .GetPreconfiguredCata\", \"logBrands () \\n); \\nThe CatalogItem data can also be pulled from PreconfiguredData, and assuming the a\", \"ssociated \\nimages are kept in source control, that is the last table needed for the app to function.\", \" The \\nCatalogDBInitializer class can be removed, along with any references t o it. The \\nCatalogItemH\", \"iLoGenerator class and the SQL files in the Infrastructure directory are also removed, \\nalong with a\", \"ny references to them (in CatalogService, ApplicationModule).  \\nWith the elimination of the special \", \"key generator classes for CatalogItem, this code now is removed \\nfrom CatalogItemConfig:  \\nbuilder.P\", \"roperty (ci => ci.Id) \\n    .ValueGeneratedNever () \\n    .IsRequired (); \\nWith these modifications, t\", \"he ASP.NET Core app builds, but it doesn\\u2019t yet work with EF Core, which \\nmust still be configured fo\", \"r dependency injection. With EF Core, the simplest way to configure it is in \\nProgram.cs : \\nbuilder.\", \"Services .AddMvc(); \\nbool useMockData = builder.Configuration .GetValue <bool>(\\\"UseMockData\\\" ); \\nif \", \"(!useMockData ) \\n{  \\n67 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n     string connect\", \"ionString = \\nbuilder.Configuration .GetConnectionString (\\\"DefaultConnection\\\" ); \\n \\n    builder.Servi\", \"ces .AddDbContext <CatalogDBContext >(options => \\n        options.UseSqlServer (connectionString ) \\n\", \"    ); \\n} \\nThe final version of Autofac\\u2019s ApplicationModule only configures one type, depending on w\", \"hether the \\napp is configured to use mock data:  \\npublic class ApplicationModule : Module \\n{ \\n    pr\", \"ivate bool _useMockData ; \\n \\n    public ApplicationModule (bool useMockData ) \\n    { \\n        _useMo\", \"ckData = useMockData ; \\n    } \\n \\n    protected  override  void Load(ContainerBuilder builder ) \\n    \", \"{ \\n        if (_useMockData ) \\n        { \\n            builder.RegisterType <CatalogServiceMock >() \\n\", \"                .As<ICatalogService >() \\n                .SingleInstance (); \\n        } \\n        els\", \"e \\n        { \\n            builder.RegisterType <CatalogService >() \\n                .As<ICatalogServ\", \"ice >() \\n                .InstancePerLifetimeScope (); \\n        } \\n    } \\n} \\nThe ported app runs, bu\", \"t doesn\\u2019t display any data if configured to use non -mock data. The seed data \\nadded through HasData\", \" is only inserted when migrations are applied. The source app didn\\u2019t use \\nmigrations, and if it had,\", \" they wouldn\\u2019t migrate as -is. The best approach is to start with a new \\nmigration script. To do thi\", \"s, add a package reference for Microsoft.EntityFrameworkCore.Design and \\nopen a terminal window in t\", \"he project root. Then run:  \\ndotnet ef migrations add Initial  \\nDrop the existing eShopPorted  datab\", \"ase if it exists, then run:  \\ndotnet ef database update  \\nThis creates and seeds the database. It\\u2019s \", \"now ready to run, with a few small updates left to address.  \\nFix all TODO tasks  \\nRunning the porte\", \"d app at this point reveals that no pictures are shown on the page. This is because \\nthe PictureUri \", \"property of CatalogItem is never set. Looking at the list of TODO items we created  \\n68 CHAPTER 4 | \", \"Example migration of eShop to ASP.NET Core  \\n using Visual Studio\\u2019s Task List , the only one that re\", \"mains is in CatalogController, with a note to \\n\\u201cReference pic from wwwroot.\\u201d The code in question is\", \":  \\nprivate void AddUriPlaceHolder (CatalogItem item ) \\n{ \\n    //TODO: Reference pic from wwwroot  \\n\", \"    //item.PictureUri = this.Url.RouteUrl(PicController.GetPicRouteName, new { \\ncatalogItemId = item\", \".Id }, this.Request.Url.Scheme);  \\n} \\nThe simplest fix is to reference the public image files in the\", \" site\\u2019s public wwwroot/Pics  directory. This \\ntask can be accomplished by replacing the method with \", \"the following code:  \\nprivate void AddUriPlaceHolder (CatalogItem item ) \\n{ \\n    item.PictureUri  = \", \"$\\\"/Pics/{item.Id}.png\\\" ; \\n} \\nWith this change, running the app reveals the images work as before.  \\n\", \"Additional MVC customizations  \\nThe eShopLegacyMVC  app is fairly simple, so there isn\\u2019t much to con\", \"figure in terms of default MVC \\nbehavior. However, if you do need to configure additional MVC compon\", \"ents, such as CORS, filters, \\nand route constraints, you generally provide this information in Progr\", \"am.cs , where UseMvc is called. \\nFor example, the following code listing configures CORS  and sets u\", \"p a global action filter:  \\nbuilder.Services .AddCors(options => \\n{ \\n    options.AddPolicy (MyAllowS\", \"pecificOrigins , \\n        builder => \\n            builder.WithOrigins (\\\"http://example.com\\\" , \\\"http:\", \"//www.contoso.com\\\" ) \\n                .AllowAnyHeader () \\n                .AllowAnyMethod ()); \\n}); \", \"\\n \\nbuilder.Services .AddMvc(options => \\n{ \\n    options.Filters.Add(new SampleGlobalActionFilter ());\", \" \\n}).SetCompatibilityVersion (CompatibilityVersion .Version_2_2 ); \\n \\n \\nNote  \\nTo finish configuring\", \" CORS, you must also call app.UseCors() after building the application.  \\nOther advanced scenarios, \", \"like adding custom model binders , formatters, and more are covered in the \\ndetailed ASP.NET Core do\", \"cs. Generally these can be applied on an individual controller or action basis, \\nor globally using t\", \"he same options approach shown in the previous code listing.   \\n69 CHAPTER 4 | Example migration of \", \"eShop to ASP.NET Core  \\n Other dependencies  \\nDependencies that use .NET Framework features that had\", \" a dependency on the legacy configuration \\nmodel, such as the WCF client type and tracing code, must\", \" be modified when ported. Rather than \\nhaving these types pull in their configuration information di\", \"rect ly, they should be configured in code. \\nFor example, a connection to a WCF service that was con\", \"figured in an ASP.NET app\\u2019s web.config  to use \\nbasicHttpBinding could instead be configured program\", \"matically with the following code:  \\nvar binding = new BasicHttpBinding (); \\nbinding.MaxReceivedMess\", \"ageSize  = 2_000_000 ; \\n \\nvar endpointAddress = new EndpointAddress (\\\"http://localhost:9200/ExampleS\", \"ervice\\\" ); \\n \\nvar myClient = new MyServiceClient (binding, endpointAddress ); \\nRather than relying o\", \"n config files for its settings, WCF clients and other .NET Framework types should \\nhave their setti\", \"ngs specified in code. Configured in this manner, these types can continue to work in \\nASP.NET Core \", \"2.2 apps.  \\nReferences  \\n\\u2022 eShopModernizing GitHub repository  \\n\\u2022 .NET Upgrade Assistant tool  \\n\\u2022 Yo\", \"ur API and ViewModels Should Not Reference Domain Models  \\n\\u2022 Developer Exception Page Middleware  \\n\\u2022\", \" Deep Dive into EF Core HasData  \\nMore migration scenarios  \\nThis section describes several differen\", \"t ASP.NET app scenarios, and offers specific techniques for \\nsolving each of them. You can use this \", \"section to identify scenarios applicable to your app, and \\nevaluate which techniques will work for y\", \"our app and its hos ting environment.  \\nMigrate ASP.NET MVC 5 and WebApi 2 to ASP.NET Core MVC  \\nA c\", \"ommon scenario in ASP.NET MVC 5 and Web API 2 apps was for both products to be installed in \\nthe sam\", \"e application. This is a supported and relatively common approach used by many teams, but \\nbecause t\", \"he two products use different abstractions, there is so me redundant effort needed. For \\nexample, se\", \"tting up routes for ASP.NET MVC is done using methods on RouteCollection, such as \\nMapMvcAttributeRo\", \"utes() and MapRoute(). But ASP.NET Web API 2 routing is managed with \\nHttpConfiguration and methods \", \"like MapHttpAtt ributeRoutes() and MapHttpRoute().  \\nThe eShopLegacyMVC app includes both ASP.NET MV\", \"C and Web API, and includes methods in its \\nApp_Start folder for setting up routes for both. It also\", \" supports dependency injection using Autofac, \\nwhich also requires two sets of similar work to confi\", \"gure:   \\n70 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n protected  IContainer Register\", \"Container () \\n{ \\n    var builder = new ContainerBuilder (); \\n \\n    var thisAssembly = Assembly .GetE\", \"xecutingAssembly (); \\n    builder.RegisterControllers (thisAssembly );      // MVC controllers  \\n   \", \" builder.RegisterApiControllers (thisAssembly );   // Web API controllers  \\n \\n    var mockData = boo\", \"l.Parse(ConfigurationManager .AppSettings [\\\"UseMockData\\\" ]); \\n    builder.RegisterModule (new Applic\", \"ationModule (mockData )); \\n \\n    var container = builder.Build(); \\n \\n    // set mvc resolver  \\n    D\", \"ependencyResolver .SetResolver (new AutofacDependencyResolver (container )); \\n \\n    // set webapi re\", \"solver  \\n    var resolver = new AutofacWebApiDependencyResolver (container ); \\n    GlobalConfigurati\", \"on .Configuration .DependencyResolver  = resolver ; \\n \\n    return container ; \\n} \\nWhen upgrading the\", \"se apps to use ASP.NET Core, this duplicate effort and the confusion that \\nsometimes accompanies it \", \"is eliminated. ASP.NET Core MVC is a unified framework with one set of \\nrules for routing, filters, \", \"and more. Dependency injection is built into .NET Core itself. All of this can be \\nconfigured in Pro\", \"gram.cs , as is shown in the eShopPorted app in the sample.  \\nMigrate HttpResponseMessage to ASP.NET\", \" Core  \\nSome ASP.NET Web API apps may have action methods that return HttpResponseMessage. This type\", \" \\ndoes not exist in ASP.NET Core. Below is an example of its usage in a Delete action method, using \", \"the \\nResponseMessage helper method on the base ApiController:  \\n// DELETE api/<controller>/5  \\n[Http\", \"Delete ] \\npublic IHttpActionResult Delete(int id) \\n{ \\n    var brandToDelete = _service .GetCatalogBr\", \"ands ().FirstOrDefault (x => x.Id == id); \\n    if (brandToDelete == null) \\n    { \\n        return Res\", \"ponseMessage (new HttpResponseMessage (HttpStatusCode .NotFound )); \\n    } \\n \\n    // demo only - don\", \"'t actually delete  \\n    return ResponseMessage (new HttpResponseMessage (HttpStatusCode .OK)); \\n} \\n\", \"In ASP.NET Core MVC, there are helper methods available for all of the common HTTP response status \\n\", \"codes, so the above method would be ported to the following code:  \\n[HttpDelete (\\\"{id}\\\")] \\npublic IA\", \"ctionResult Delete(int id) \\n{ \\n    var brandToDelete = _service .GetCatalogBrands ().FirstOrDefault \", \"(x => x.Id == id); \\n    if (brandToDelete == null) \\n    {  \\n71 CHAPTER 4 | Example migration of eSho\", \"p to ASP.NET Core  \\n         return NotFound (); \\n    } \\n \\n    // demo only - don't actually delete \", \" \\n    return Ok(); \\n} \\nIf you do find that you need to return a custom status code for which no help\", \"er exists, you can always \\nuse return StatusCode(int statusCode) to return any numeric code you like\", \".  \\nMigrate content negotiation from ASP.NET Web API to ASP.NET Core  \\nASP.NET Web API 2 supports co\", \"ntent negotiation  natively. The sample app includes a \\nBrandsController that demonstrates this supp\", \"ort by listing its results in either XML or JSON. This is \\nbased on the request\\u2019s Accept header, and\", \" changes when it includes application/xml or \\napplication/json.  \\nASP.NET MVC 5 apps do not have con\", \"tent negotiation support built in.  \\nContent negotiation is preferable to returning a specific encod\", \"ing type, as it is more flexible and \\nmakes the API available to a larger number of clients. If you \", \"currently have action methods that return \\na specific format, you should consider modifying the m to\", \" return a result type that supports content \\nnegotiation when you port the code to ASP.NET Core.  \\nT\", \"he following code returns data in JSON format regardless of client Accept header content:  \\n[HttpGet\", \"] \\npublic ActionResult Index() \\n{ \\n    return Json(new { Message = \\\"Hello World!\\\"  }); \\n} \\nASP.NET C\", \"ore MVC supports content negotiation natively , provided an appropriate return type  is \\nused. Conte\", \"nt negotiation is implemented by [ObjectResult] which is returned by the status code -\\nspecific acti\", \"on results returned by the controller helper methods. The previous action method, \\nimplemented in AS\", \"P.NET Core MVC and using content negotiation , would be:  \\npublic IActionResult Index() \\n{ \\n    retu\", \"rn Ok(new { Message = \\\"Hello World!\\\" } ); \\n} \\nThis will default to returning the data in JSON format\", \". XML and other formats will be used if the app \\nhas been configured with the appropriate formatter \", \". \\nCustom model binding  \\nMost ASP.NET MVC and Web API apps make use of model binding. The default m\", \"odel binding syntax \\nmigrates fairly seamlessly between these apps and ASP.NET Core MVC. However, in\", \" some cases \\ncustomers have written custom model binders  to support specific model types or usage s\", \"cenarios. \\nCustom model binders in ASP.NET MVC and Web API projects use separate IModelBinder interf\", \"aces \\ndefined in System.Web.Mvc and System.Web.Http namespaces, respectively. In both cases, the cus\", \"tom  \\n72 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n binder exposes a Bind method that\", \" accepts a controller or action context and a model binding context \\nas arguments.  \\nOnce the custom\", \" binder is created, it must be registered with the app. This step requires creating \\nanother type, a\", \" ModelBinderProvider, which acts as a factory and creates the model binder during a \\nrequest. Binder\", \"s can be added during ApplicationStart in M VC apps as shown:  \\nModelBinderProviders .BinderProvider\", \"s .Insert(0, new MyCustomBinderProvider ()); // MVC \\nIn Web API apps, custom binders can be referenc\", \"ed using attributes. The ModelBinder attribute can \\nbe added to action method parameters or to the p\", \"arameter\\u2019s type definition, as shown:  \\n// attribute on action method parameter  \\npublic HttpRespons\", \"eMessage ([ModelBinder (typeof(MyCustomBinder ))] CustomDTO custom ) \\n{ \\n} \\n \\n// attribute on type  \", \"\\n[ModelBinder (typeof(MyCustomBinder ))] \\npublic class CustomDTO  \\n{ \\n} \\nTo register a model binder \", \"globally in ASP.NET Web API, its provider must be added during app \\nstartup:  \\npublic static class W\", \"ebApiConfig  \\n{ \\n    public static void Register (HttpConfiguration config ) \\n    { \\n        var pro\", \"vider = new CustomModelBinderProvider ( \\n            typeof(CustomDTO ), new CustomModelBinder ()); \", \"\\n        config.Services .Insert(typeof(ModelBinderProvider ), 0, provider ); \\n \\n        // ... \\n   \", \" } \\n} \\nWhen migrating custom model providers to ASP.NET Core , the Web API pattern is closer to the \", \"\\nASP.NET Core approach than the ASP.NET MVC 5. The main differences between ASP.NET Core\\u2019s \\nIModelBi\", \"nder interface and Web API\\u2019s is that the ASP.NET Core method is async (BindModelAsync) \\nand it only \", \"requires a single Bi ndingModelContext parameter instead of two parameters like Web \\nAPI\\u2019s version r\", \"equired. In ASP.NET Core, you can use a [ModelBinder] attribute on individual action \\nmethod paramet\", \"ers or their associated types. You can also create a ModelBinderProvider that w ill be \\nused globall\", \"y within the app where appropriate. To configure such a provider, you would add code to \\nProgram.cs \", \": \\nbuilder.Services .AddControllers (options => \\n{ \\n    options.ModelBinderProviders .Insert(0, new \", \"CustomModelBinderProvider ()); \\n});  \\n73 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n M\", \"edia formatters  \\nASP.NET Web API supports multiple media formats and can be extended by using custo\", \"m media \\nformatters. The docs describe an example CSV Media Formatter  that can be used to send data\", \" in a \\ncomma -separated value format. If your Web API app uses custom media formatters, you\\u2019ll need \", \"to \\nconvert them to ASP.NET Core custom formatters . \\nTo create a custom formatter in Web API 2, you\", \" inherited from an appropriate base class and then \\nadded the formatter to the Web API pipeline usin\", \"g the HttpConfiguration object:  \\npublic static void ConfigureApis (HttpConfiguration config ) \\n{ \\n \", \"   config.Formatters .Add(new ProductCsvFormatter ()); \\n} \\nIn ASP.NET Core, the process is similar. \", \"ASP.NET Core supports both input formatters (used by model \\nbinding) and output formatters (used to \", \"format responses). Adding a custom formatter to output \\nresponses in a specific way involves inherit\", \"ing from an appro priate base class and adding the \\nformatter to MVC in Program.cs : \\nbuilder.Servic\", \"es .AddControllers (options => \\n{ \\n    options.InputFormatters .Insert(0, new CustomInputFormatter (\", \")); \\n    options.OutputFormatters .Insert(0, new CustomOutputFormatter ()); \\n}); \\nYou\\u2019ll find a comp\", \"lete list of base classes in the Microsoft.AspNetCore.Mvc.Formatters  namespace.  \\nThe steps to migr\", \"ate from a Web API formatter to an ASP.NET Core MVC formatter are:  \\n1. Identify an appropriate base\", \" class for the new formatter.  \\n2. Create a new instance of the base class and implement its require\", \"d methods.  \\n3. Copy over the functionality from the Web API formatter to the new implementation.  \\n\", \"4. Configure MVC in the ASP.NET Core App\\u2019s ConfigureServices method to use the new \\nformatter.  \\nCus\", \"tom filters  \\nFilters are used in ASP.NET Core apps to execute code before and/or after certain stag\", \"es in the \\nrequest processing pipeline. ASP.NET MVC and Web API also use filters in much the same wa\", \"y, but the \\ndetails vary. For instance, ASP.NET MVC supports four kinds of filters . ASP.NET Web API\", \" 2 supports \\nsimilar filters, and both MVC and Web API included attributes to override filters . \\nTh\", \"e most common filter used in ASP.NET MVC and Web API apps is the action filter, which is defined \\nby\", \" an IActionFilter interface . This interface provides methods for before (OnActionExecuting) and aft\", \"er \\n(OnActionExecuted) which can be used to execute code before and/or after an action executes, as \", \"\\nnoted for each method.  \\nASP.NET Core continues to support filters, and its unification of MVC and \", \"Web API means there is only \\none approach to their implementation. The docs include detailed coverag\", \"e of the five (5) kinds of \\nfilters built into ASP.NET Core MVC . All of the filter variants support\", \"ed in ASP.NET MVC and ASP.NET  \\n74 CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n Web API\", \" have associated versions in ASP.NET Core, so migration is generally just a matter of \\nidentifying t\", \"he appropriate interface and/or base class and migrating the code over.  \\nIn addition to the synchro\", \"nous interfaces, ASP.NET Core also provides async interfaces like \\nIAsyncActionFilter which provide \", \"a single async method that can be used to incorporate code to run \\nboth before and after the action,\", \" as shown:  \\npublic class SampleAsyncActionFilter : IAsyncActionFilter  \\n{ \\n    public async Task On\", \"ActionExecutionAsync ( \\n        ActionExecutingContext context , \\n        ActionExecutionDelegate ne\", \"xt ) \\n    { \\n        // Do something before the action executes.  \\n \\n        // next() calls the act\", \"ion method.  \\n        var resultContext = await next(); \\n        // resultContext.Result is set.  \\n \", \"       // Do something after the action executes.  \\n    } \\n} \\nWhen migrating async code (or code tha\", \"t should be async), teams should consider leveraging the \\nbuilt in async types that are provided for\", \" this purpose.  \\nMost ASP.NET MVC and Web API apps do not use a large number of custom filters. Sinc\", \"e the \\napproach to filters in ASP.NET Core MVC is closely aligned with filters in ASP.NET MVC and We\", \"b API, \\nthe migration of custom filters is generally fairly straightforward . Be sure to read the de\", \"tailed \\ndocumentation on filters in ASP.NET Core\\u2019s docs, and once you\\u2019re sure you have a good \\nunder\", \"standing of them, port the logic from the old system to the new system\\u2019s filters.  \\nRoute constraint\", \"s  \\nASP.NET Core uses route constraints to help ensure requests are routed properly to route a reque\", \"st. \\nASP.NET Core supports a large number of different route constraints for this purpose . Route \\nc\", \"onstraints can be applied in the route table, but most apps built with ASP.NET MVC 5 and/or \\nASP.NET\", \" Web API 2  use inline route constraints applied to attribute routes. Inline route constraints use \\n\", \"a format like this one:  \\n[Route(\\\"/customer/{id:int}\\\" )] \\nThe :int after the id route parameter cons\", \"trains the value to match the int type. One benefit of using \\nroute constraints is that they allow f\", \"or two otherwise -identical routes to exist where the parameters \\ndiffer only by their type. This al\", \"lows for the equi valent of method overloading  of routes based solely \\non parameter type.  \\nThe set\", \" of route constraints, their syntax, and usage is very similar between all three approaches. \\nCustom\", \" route constraints are fairly rare in customer applications. If your app uses a custom route \\nconstr\", \"aint and needs to port to ASP.NET Core, the docs in clude examples showing how to create \\ncustom rou\", \"te constraints in ASP.NET Core . Essentially all that\\u2019s required is to implement \\nIRouteConstraint a\", \"nd its Match method, and then add the custom constraint when configuring \\nrouting for the app:   \\n75\", \" CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n builder.Services .AddControllers (); \\n \\nb\", \"uilder.Services .AddRouting (options => \\n{ \\n    options.ConstraintMap .Add(\\\"customName\\\" , typeof(MyC\", \"ustomConstraint )); \\n}); \\nThis is very similar to how custom constraints are used in ASP.NET Web API\", \", which uses \\nIHttpRouteConstraint and configures it using a resolver and a call to \\nHttpConfigurati\", \"on.MapHttpAttributeRoutes:  \\npublic static class WebApiConfig  \\n{ \\n    public static void Register (\", \"HttpConfiguration config ) \\n    { \\n        var constraintResolver = new DefaultInlineConstraintResol\", \"ver (); \\n        constraintResolver .ConstraintMap .Add(\\\"nonzero\\\" , typeof(CustomConstraint )); \\n \\n \", \"       config.MapHttpAttributeRoutes (constraintResolver ); \\n    } \\n} \\nASP.NET MVC 5 follows a very \", \"similar approach, using IRouteConstraint for its interface name and \\nconfiguring the constraint as p\", \"art of route configuration:  \\npublic class RouteConfig  \\n{ \\n    public static void RegisterRoutes (R\", \"outeCollection routes ) \\n    { \\n        routes.IgnoreRoute (\\\"{resource}.axd/{*pathInfo}\\\" ); \\n \\n     \", \"   var constraintsResolver = new DefaultInlineConstraintResolver (); \\n        constraintsResolver .C\", \"onstraintMap .Add(\\\"values\\\" , typeof(ValuesConstraint )); \\n        routes.MapMvcAttributeRoutes (cons\", \"traintsResolver ); \\n    } \\n} \\nMigrating route constraint usage as well as custom route constraints t\", \"o ASP.NET Core is typically very \\nstraightforward.  \\nCustom route handlers  \\nAnother fairly advanced\", \" feature of ASP.NET MVC 5 is route handlers. Custom route handlers \\nimplement IRouteHandler, which i\", \"ncludes a single method that returns an IHttpHandler for a give \\nrequest. The IHttpHandler, in turn,\", \" exposes an IsReusable property and  a single ProcessRequest \\nmethod. In ASP.NET MVC 5, you can conf\", \"igure a particular route in the route table to use your custom \\nhandler:  \\npublic static void Regist\", \"erRoutes (RouteCollection routes ) \\n{ \\n    routes.IgnoreRoute (\\\"{resource}.axd/{*pathInfo}\\\" ); \\n \\n  \", \"  routes.Add(new Route(\\\"custom\\\" , new CustomRouteHandler ())); \\n}  \\n76 CHAPTER 4 | Example migration\", \" of eShop to ASP.NET Core  \\n To migrate custom route handlers from ASP.NET MVC 5 to ASP.NET Core, yo\", \"u can either use a filter \\n(such as an action filter) or a custom IRouter . The filter approach is r\", \"elatively straightforward, and can \\nbe added as a global filter when MVC is added to the app\\u2019s servi\", \"ces during startup:  \\nbuilder.Services .AddMvc(options => \\n{ \\n    options.Filters.Add(typeof(CustomA\", \"ctionFilter )); \\n}); \\nThe IRouter option requires implementing the interface\\u2019s RouteAsync and GetVir\", \"tualPath methods. \\nThe custom router is added to the request pipeline during app startup.  \\n// ... \\n\", \"app.UseMvc(routes => \\n{ \\n    routes.Routes.Add(new CustomRouter (routes.DefaultHandler )); \\n}); \\nIn \", \"ASP.NET Web API, these handlers are referred to as custom message handlers , rather than route \\nhand\", \"lers . Message handlers must derive from DelegatingHandler and override its SendAsync method. \\nMessa\", \"ge handlers can be chained together to form a pipeline in a fashion that is very similar to \\nASP.NET\", \" Core middleware and its request pipeline.  \\nASP.NET Core has no DelegatingHandler type or separate \", \"message handler pipeline. Instead, such \\nhandlers should be migrated using global filters, custom IR\", \"outer instances (see above), or custom \\nmiddleware. ASP.NET Core MVC filters and IRouter types have \", \"the  advantage of having built -in access \\nto MVC constructs like controllers and actions, while mid\", \"dleware is a lower level approach that has no \\nties to MVC. This makes it more flexible but also req\", \"uires more effort if you need to access MVC \\ncomponents.  \\nCORS support  \\nCORS, or Cross -Origin Res\", \"ource Sharing, is a W3C standard that allows servers to accept requests that \\ndon\\u2019t originate from r\", \"esponses they\\u2019ve served. ASP.NET MVC 5 and ASP.NET Web API 2 support CORS \\nin different ways. The si\", \"mplest way to enable CORS support  in ASP.NET MVC 5 is with an action filter \\nlike this one:  \\npubli\", \"c class AllowCrossSiteAttribute : ActionFilterAttribute  \\n{ \\n    public override  void OnActionExecu\", \"ting (ActionExecutingContext filterContext ) \\n    { \\n        filterContext .RequestContext .HttpCont\", \"ext .Response .AddHeader ( \\n            \\\"Access-Control-Allow-Origin\\\", \\\"example.com\\\" ); \\n        bas\", \"e.OnActionExecuting (filterContext ); \\n    } \\n} \\nASP.NET Web API can also use such a filter, but it \", \"has built-in support for enabling CORS  as well:  \\npublic static class WebApiConfig  \\n{ \\n    public \", \"static void Register (HttpConfiguration config ) \\n    { \\n        config.EnableCors ();  \\n77 CHAPTER \", \"4 | Example migration of eShop to ASP.NET Core  \\n         // ... \\n    } \\n} \\nOnce this is added, you \", \"can configure allowed origins, headers, and methods using the EnableCors \\nattribute, like so:  \\n[Ena\", \"bleCors (origins: \\\"https://dot.net\\\" , headers: \\\"*\\\", methods: \\\"*\\\")] \\npublic class TestController : Ap\", \"iController  \\n{ \\n    // Controller methods not shown...  \\n} \\nBefore migrating your CORS implementati\", \"on from ASP.NET MVC 5 or ASP.NET Web API 2, be sure to \\nreview how CORS works  and create some autom\", \"ated tests that demonstrate CORS is working as \\nexpected in your current system.  \\nIn ASP.NET Core, \", \"there are three built -in ways to enable CORS:  \\n\\u2022 Configured via policy  in ConfigureServices  \\n\\u2022 E\", \"nabled with endpoint routing  \\n\\u2022 Enabled with the EnableCors  attribute  \\nEach of these approaches i\", \"s covered in detail in the docs, which are linked from the above options. \\nWhich one you choose will\", \" largely depend on how your existing app supports CORS. If the app uses \\nattributes, you can probabl\", \"y migrate to use the EnableCors attribute most easily. If your app uses \\nfilters, you could continue\", \" using that approach (though it\\u2019s not the typical approach used in ASP.NET \\nCore), or migrate to use\", \" attributes or policies. Endpoint routing is a relatively new feature introduced \\nwith ASP. NET Core\", \" 3 and as such it doesn\\u2019t have a close analog in ASP.NET MVC 5 or ASP.NET Web \\nAPI 2 apps.  \\nCustom \", \"areas  \\nMany ASP.NET MVC apps use Areas to organize the project. Areas typically reside in the root \", \"of the \\nproject in an Areas  folder, and must be registered when the application starts, typically i\", \"n \\nApplication_Start():  \\nAreaRegistration .RegisterAllAreas (); \\nAn alternative to registering all \", \"areas in startup is to use the RouteArea attribute on individual \\ncontrollers:  \\n[RouteArea (\\\"Admin\\\"\", \")] \\npublic class SomeController : Controller  \\nWhen using Areas, additional arguments are passed int\", \"o HTML helper methods to generate \\nlinks to actions in different areas:  \\n@Html.ActionLink(\\\"News\\\", \\\"\", \"Index\\\", \\\"News\\\", new { area = \\\"News\\\" }, null)  \\nASP.NET Web API apps don\\u2019t typically use areas explic\", \"itly, since their controllers can be placed in any \\nfolder in the project. Teams can use any folder \", \"structure they like to organize their API controllers.   \\n78 CHAPTER 4 | Example migration of eShop \", \"to ASP.NET Core  \\n Areas  are supported in ASP.NET Core MVC. The approach used is nearly identical t\", \"o the use of areas \\nin ASP.NET MVC 5. Developers migrating code using areas should keep in mind the \", \"following \\ndifferences:  \\n\\u2022 AreaRegistration.RegisterAllAreas is not used in ASP.NET Core MVC  \\n\\u2022 Ar\", \"eas are applied using the [Area(\\\"name\\\")] attribute (not RouteArea as in ASP.NET MVC 5)  \\n\\u2022 Areas can\", \" be added to the route table templates, if desired (or they can use attribute routing)  \\nTo add area\", \" support to the route table in ASP.NET Core MVC, you would add the following during app \\nstartup:  \\n\", \"app.UseEndpoints (endpoints => \\n{ \\n    endpoints .MapControllerRoute ( \\n        name: \\\"MyArea\\\" , \\n  \", \"      pattern: \\\"{area:exists}/{controller=Home}/{action=Index}/{id?}\\\" ); \\n \\n    endpoints .MapContro\", \"llerRoute ( \\n        name: \\\"default\\\" , \\n        pattern: \\\"{controller=Home}/{action=Index}/{id?}\\\" );\", \" \\n}); \\nAreas can also be used with attribute routing, using the {area} keyword in the route definiti\", \"on (it\\u2019s one \\nof several reserved routing names  that can be used with route templates).  \\nTag helpe\", \"rs support areas with the asp -area attribute, which can be used to generate links in Razor \\nviews a\", \"nd pages:  \\n<ul> \\n    <li> \\n        <a asp-area=\\\"Products\\\" asp -controller=\\\"Home\\\" asp -action=\\\"About\", \"\\\">  \\n            Products/Home/About  \\n        </a> \\n    </li> \\n    <li> \\n        <a asp-area=\\\"Servi\", \"ces\\\" asp -controller=\\\"Home\\\" asp -action=\\\"About\\\">  \\n            Services About  \\n        </a> \\n    </\", \"li> \\n    <li> \\n        <a asp-area=\\\"\\\" asp -controller=\\\"Home\\\" asp -action=\\\"About\\\">  \\n            /Hom\", \"e/About  \\n        </a> \\n    </li> \\n</ul> \\nIf you\\u2019re migrating to Razor Pages you will need to use an\", \" Areas  folder in your Pages  folder. For more \\ninformation, see Areas with Razor Pages . \\nIn additi\", \"on to the above guidance, teams should review how routing in ASP.NET Core works with \\nareas  as part\", \" of their migration planning process.  \\nIntegration tests for ASP.NET MVC and ASP.NET Web API  \\nInte\", \"gration tests are automated tests that verify several different parts of an app work together \\ncorre\", \"ctly. Writing integration tests for ASP.NET MVC and ASP.NET Web API usually involved deploying  \\n79 \", \"CHAPTER 4 | Example migration of eShop to ASP.NET Core  \\n the app to a real web server, such as a lo\", \"cal instance of IIS or IIS Express, and then making requests to \\nthis hosted application using an HT\", \"TP client. Some of these tests may interact with the client -side user \\ninterface using browser auto\", \"mation tools like  Selenium , though often these are referred to as UI tests  \\nrather than integrati\", \"on tests.  \\nIf your migrated app shares the same behavior as its original version, whatever existing\", \" technology \\nthe team is using to perform integration tests (and UI tests) should continue to work j\", \"ust as it did \\nbefore. These tests are usually indifferent to the unde rlying technology used to hos\", \"t the app they\\u2019re \\ntesting, and interact with it only through HTTP requests. Where things may get mo\", \"re challenging is \\nwith how the tests interact with the app to get it into a known good state prior \", \"to each test. This may \\nrequir e some migration effort, since configuration and startup are signific\", \"antly different in ASP.NET \\nCore compared to ASP.NET MVC or ASP.NET Web API.  \\nTeams should strongly\", \" consider migrating their integration tests to use ASP.NET Core\\u2019s built -in \\nintegration testing  su\", \"pport. In ASP.NET Core, apps can be tested by deploying them to a TestHost, \\nwhich is configured usi\", \"ng a WebApplicationFactory. There\\u2019s a little bit of setup required to host the \\napp for testing, but\", \" once this is in place, creating individual integration  tests is very straightforward.  \\nOne of the\", \" best features of ASP.NET Core\\u2019s integration testing support is that the app is hosted in \\nmemory. T\", \"here\\u2019s no need to configure a real webserver to host the app. There\\u2019s no need to use a \\nbrowser auto\", \"mation tool (if you\\u2019re only testing ASP.NET Core  and not client -side behavior). Many of \\nthe probl\", \"ems that can be encountered when trying to use a real web server for automated integration \\ntests, s\", \"uch as firewall issues or process start/stop issues, are eliminated with this approach. Since the \\nr\", \"equests a re all made in memory with no network requirement, the tests also tend to run much faster \", \"\\nthan tests that must set up a separate webserver and communicate with it over the network (even if \", \"\\nit\\u2019s running on the same machine).  \\nBelow you can see an example ASP.NET Core integration test (so\", \"metimes referred to as functional \\ntests to distinguish them from lower -level integration tests) fr\", \"om the eShopOnWeb reference \\napplication : \\npublic class GetByIdEndpoint : IClassFixture <ApiTestFix\", \"ture > \\n{ \\n    JsonSerializerOptions _jsonOptions = new JsonSerializerOptions { \\nPropertyNameCaseIns\", \"ensitive = true }; \\n \\n    public GetByIdEndpoint (ApiTestFixture factory ) \\n    { \\n        Client = \", \"factory.CreateClient (); \\n    } \\n \\n    public HttpClient Client { get; } \\n \\n    [Fact] \\n    public a\", \"sync Task ReturnsItemGivenValidId () \\n    { \\n        var response = await Client .GetAsync (\\\"api/cat\", \"alog -items/5\\\" ); \\n        response .EnsureSuccessStatusCode (); \\n        var stringResponse = await\", \" response .Content.ReadAsStringAsync (); \\n        var model = stringResponse .FromJson <GetByIdCatal\", \"ogItemResponse >(); \\n \\n        Assert.Equal(5, model.CatalogItem .Id); \\n        Assert.Equal(\\\"Roslyn\", \" Red Sheet\\\" , model.CatalogItem .Name);  \\n80 CHAPTER 4 | Example migration of eShop to ASP.NET Core \", \" \\n     } \\n} \\nIf the app being migrated has no integration tests, the migration process can be a grea\", \"t opportunity \\nto add some. These tests can verify that the migrated app behaves as the team expects\", \". When such \\ntests are in place early in a migration, they can ensure t hat later migration efforts \", \"do not break \\npreviously migrated portions of the app. Given how easy it is to set up and run integr\", \"ation tests in \\nASP.NET Core, the return on the investment spent setting up such tests is usually pr\", \"etty high.  \\nWCF client configuration  \\nIf your app currently relies on WCF services as a client, th\", \"is scenario is supported. However, you will \\nneed to migrate your configuration  from web.config  to\", \" use the new appsettings.json  file. Another \\noption is to add any necessary configuration to your c\", \"lients programmatically when you create them. \\nFor example:  \\nvar wcfClient = new OrderServiceClient\", \" ( \\n    new BasicHttpBinding (BasicHttpSecurityMode .None), \\n    new EndpointAddress (\\\"http://localh\", \"ost:5050/OrderService.svc\\\" )); \\nIf your organization has extensive services built using WCF that you\", \"r app relies on, consider migrating \\nthem to use gRPC instead. For more details on gRPC, why you may\", \" wish to migrate, and a detailed \\nmigration guide, consult the gRPC for WCF Developers  eBook.  \\nRef\", \"erences  \\n\\u2022 ASP.NET Web API Content Negotiation  \\n\\u2022 Format response data in ASP.NET Core Web API  \\n\\u2022\", \" Custom Model Binders in ASP.NET Web API  \\n\\u2022 Custom Model Binders in ASP.NET Core  \\n\\u2022 Media Formatte\", \"rs in ASP.NET Web API 2  \\n \\n\\u2022 Custom formatters in ASP.NET Core Web API  \\n\\u2022 Filters in ASP.NET Core \", \" \\n\\u2022 Route constraints in ASP.NET Web API 2  \\n\\u2022 Route constraints in ASP.NET MVC 5  \\n\\u2022 ASP.NET Core R\", \"oute Constraint Reference  \\n\\u2022 Custom message handlers in ASP.NET Web API 2  \\n\\u2022 Simple CORS control i\", \"n MVC 5 and Web API 2  \\n\\u2022 Enabling Cross -Origin Requests in Web API  \\n\\u2022 Enable Cross -Origin Reques\", \"ts (CORS) in ASP.NET Core  \\n\\u2022 Areas in ASP.NET Core  \\n\\u2022 Integration tests in ASP.NET Core   \\n81 CHAP\", \"TER 5 | Deployment scenarios when migrating to ASP.NET Core  \\n CHAPTER  5 \\nDeployment scenarios \\nwhe\", \"n migrating to \\nASP.NET Core  \\nExisting ASP.NET MVC and Web API apps run on IIS and Windows. Large a\", \"pps may require a phased \\nor side -by-side approach when porting to ASP.NET Core. In previous chapte\", \"rs, you learned a number \\nof strategies for migrating large .NET Framework apps to ASP.NET Core in p\", \"hases. In this chapter, you \\nwill see how different deployment s cenarios can be achieved when there\", \" is a need to maintain the \\noriginal app in production while migrating portions of it.  \\nSplit a lar\", \"ge web app  \\nConsider the common scenario of a large web app that currently is hosted on IIS in a si\", \"ngle web site. \\nWithin the large app, functionality is segmented into different routes and/or direct\", \"ories. The app is a \\nmix of MVC views and API endpoints. The MVC routes  include many different path\", \"s based on \\nfunctionality and all start from the root of the app using the standard /{controller}/{a\", \"ction}/{id?} route \\ntemplate. The API endpoints follow a similar pattern, but are all under an /api \", \"root.  \\nAssuming the task of porting the app is split such that either the MVC functionality or the \", \"API \\nfunctionality is migrated to ASP.NET Core first, how would the original site continue to functi\", \"on \\nseamlessly with the new ASP.NET Core app running somewhere els e? Users of the system should \\nco\", \"ntinue to see the same URLs they did prior to the migration, unless it\\u2019s absolutely necessary to \\nch\", \"ange them.  \\nFortunately, IIS is a feature -rich web server, and two features it has are URL Rewrite\", \" module  and \\nApplication Request Routing . Using these features, IIS can act as a reverse proxy , r\", \"outing client \\nrequests to the appropriate back -end web app. To configure IIS as a reverse proxy, c\", \"heck the Enable \\nproxy  checkbox in the Application Request Routing feature, then add a URL Rewrite \", \"rule like this one:  \\n<rule name=\\\"NetCoreProxy\\\" > \\n  <match url=\\\"(.*)>\\\" /> \\n  <action type=\\\"Rewrite\\\"\", \"  url=\\\"http://servername/{R:1}\\\"  /> \\n</rule> \\nAs a reverse proxy, IIS can route traffic matching cer\", \"tain patterns to entirely separate apps, potentially \\non different servers.   \\n82 CHAPTER 5 | Deploy\", \"ment scenarios when migrating to ASP.NET Core  \\n Using just the URL Rewrite module (perhaps combined\", \" with host headers), IIS can easily support \\nmultiple web sites, each potentially running different \", \"versions of .NET. A large web app might be \\ndeployed as a collection of individual sites, each respo\", \"nding t o different IP addresses and/or host \\nheaders, or as a single web site with one or more sub \", \"-applications in it responding to certain URL \\npaths (which doesn\\u2019t even require URL Rewrite).  \\nImp\", \"ortant  \\nSubdomains typically refer to the portion of a domain preceding the top two levels. For exa\", \"mple, in \\nthe domain api.contoso.com, api is a subdomain of the contoso.com domain (which itself is \", \"\\ncomposed of the contoso domain name and the .com top -level domain or TLD). URL paths refer to \\npor\", \"tion of the URL that follows the domain name, starting with a /. The URL https://contoso.com/api \\nha\", \"s a path of /api.  \\nThere are pros and cons to using the same or different subdomains (and domains) \", \"to host a single \\napp. Features like cookies and intra -app communication using mechanisms like CORS\", \"  may require \\nmore configuration to work properly in distributed apps. However, apps that use diffe\", \"rent \\nsubdomains can more easily use DNS to route requests to entirely different network destination\", \"s, and \\nso can more easily be deployed to many different ser vers (virtual or otherwise) without the\", \" need for \\nIIS to act as a reverse proxy.  \\nIn the example described above, assume the API endpoints\", \" are designated as the first part of the app \\nto be ported to ASP.NET Core. In this case, a new ASP.\", \"NET Core app is created and hosted in IIS as a \\nseparate web application  within the existing ASP.NE\", \"T MVC web site. Since it will be added as a child of \\nthe original web site and will be named api, i\", \"ts default route should no longer begin with api/. \\nKeeping this would result in it matching URLs of\", \" the form /api/api/endpoint.  \\nFigure 5 -1 shows how the ASP.NET Core 2.1 api app appears in IIS Man\", \"ager as a part of the existing \\nDotNetMvcApp  site.  \\n83 CHAPTER 5 | Deployment scenarios when migra\", \"ting to ASP.NET Core  \\n  \\nFigure 5 -1. .NET Framework Site with .NET Core app in IIS.  \\nThe DotNetMv\", \"cApp  site is hosted as an MVC 5 app running on .NET Framework 4.7.2. It has its own IIS \\napp pool c\", \"onfigured in integrated mode and running .NET CLR version 4.0.30319. The api app is an \\nASP.NET Core\", \" app running on .NET Framework 4.6.1 (net461). It was added to the DotNetMvcApp  as a \\nnew IIS app a\", \"nd configured to use its own Application Pool. Its Application Pool is also running in \\nintegrated m\", \"ode but is configured with a .NET CLR version of No Managed Code  since it will be \\nexecuted using t\", \"he ASP.NET Core Module . The version of the ASP.NET Core app is just an example. It \\ncould also be c\", \"onfigured to run on NET 5+. Though at that point, it would no longer be able to target \\n.NET Framewo\", \"rk libraries (see Choose the Right .NET Core Version ) \\nConfigured in this manner, the only change t\", \"hat must be made in order for the ASP.NET Core app\\u2019s \\nAPIs to be routed properly is to change its de\", \"fault route template from [Route(\\\"[api/controller]\\\")] to \\n[Route(\\\"[controller]\\\")].  \\nAlternately the\", \" ASP.NET Core app can be another top -level web site in IIS. In this case, you can \\nconfigure the or\", \"iginal site to use a rewrite rule (with URL Rewrite ) that will redirect to the other app if \\nthe pa\", \"th starts with /api. The ASP.NET Core app can use a different host header for its route so that it \\n\", \"doesn\\u2019t conflict with the main app but can still respond to requests using root -based routes.  \\nAs \", \"an example, the same ASP.NET Core app used in Figure 5 -1 can be deployed to another folder \\nconfigu\", \"red as an IIS web site. The site should use an app pool configured just as before, with No \\n \\n84 CHA\", \"PTER 5 | Deployment scenarios when migrating to ASP.NET Core  \\n Managed Code . Configure its binding\", \"s to respond to a unique host name on the server, such as \\napi.contoso.com. To configure URL Rewrite\", \" to rewrite requests matching /api just add a new inbound \\nrule at the IIS server (or individual sit\", \"e) level. Match the pattern ^/api(. *) and specify an Action type of \\nRewrite and a Rewrite URL of a\", \"pi.contoso.com/{R:1}. The combination of using (.*) in the matching \\npattern and {R:1} in the rewrit\", \"e URL will ensure the rest of the path gets used with the new URL. With \\nthis in pl ace, separate si\", \"tes on the same IIS server can coexist running separate versions of .NET, but \\nthey can be made to a\", \"ppear to the Internet as one web app. Figure 5 -2 shows the rewrite rule as \\nconfigured in IIS with \", \"the separate web site.  \\n \\nFigure 5 -2. Rewrite rule to rewrite subfolder requests to another web si\", \"te.  \\nIf your app requires single sign -on between different sites or apps within IIS, refer to the \", \"\\ndocumentation on how to share authentication cookies among ASP.NET apps  for detailed instructions \", \"\\non supporting this scenario.  \\nAnother alternative to IIS Rewrite rules is the use of a reverse pro\", \"xy like YARP , which can facilitate \\nincremental ASP.NET to ASP.NET Core Migration . \\nSummary  \\nA co\", \"mmon approach to porting large apps from .NET Framework to ASP.NET Core is to choose \\nindividual por\", \"tions of the app to migrate one by one. As each piece of the app is ported, the entire \\napp remains \", \"running and usable, with some parts of it running in i ts original configuration and other \\nparts ru\", \"nning on some version of .NET Core. By following this approach, a large app migration can be \\nperfor\", \"med incrementally. This approach results in limiting risk by providing more rapid feedback and \\n \\n85\", \" CHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core  \\n reducing total surface area invo\", \"lved in testing. It also allows for more rapid realization of benefits of \\n.NET Core, such as perfor\", \"mance increases. Although ASP.NET Core apps are no longer required to be \\nhosted on IIS, IIS remains\", \" a very flexible and power ful web server that can be configured to support a \\nvariety of hosting sc\", \"enarios involving both .NET Framework and ASP.NET Core apps on the same IIS \\ninstance or even hosted\", \" on different servers.  \\nReferences  \\n\\u2022 Host ASP.NET Core on Windows with IIS  \\n\\u2022 URL Rewrite module\", \" and Application Request Routing  \\n\\u2022 URL Rewrite  \\n\\u2022 ASP.NET Core Module  \\n\\u2022 Share authentication co\", \"okies among ASP.NET apps  \\n\\u2022 Samples used in this section  \\n\\u2022 Incremental ASP.NET to ASP.NET Core Mi\", \"gration  CHAPTER  \\n \\n86 CHAPTER 6 | Summary: Port existing ASP.NET Apps to .NET 7  \\n CHAPTER  \\n6 \\nSu\", \"mmary: Port existing \\nASP.NET Apps to .NET 7  \\nIn this book, you\\u2019ve been given the resources needed \", \"to decide whether it makes sense to port your \\norganization\\u2019s existing ASP.NET apps running on .NET \", \"Framework to ASP.NET Core. You\\u2019ve learned \\nabout important considerations  for choosing when it make\", \"s sense to migrate to .NET Core, and when \\nit may be appropriate to keep (parts of) your app on .NET\", \" Framework. There are differences between \\n.NET Core versions and their capabilities and compatibili\", \"ties with .NET Framework, and yo u learned \\nhow to choose the right version of .NET Core for your ap\", \"p . \\nPorting a large app often entails a fair amount of risk and effort. You learned how to mitigate\", \" this risk \\nby employing one or more incremental migration strategies  along with several deployment\", \" strategies  \\nfor keeping partially migrated apps running in production.  \\nThere are many architectu\", \"ral differences between ASP.NET and ASP.NET Core . In chapter 2, you \\nlearned about many of these di\", \"fferences and how they relate to your app\\u2019s migration. This chapter \\ncovered everything from app sta\", \"rtup  and low -level middleware  to high -level controller  and Web API \\ndifferences  and new featur\", \"es enabling much better testing scenarios . \\nLarge apps are often comprised of many projects and pac\", \"kages, and dependencies can play a major \\nrole in determining how easy or difficult migration may be\", \". Chapter 3  helped you identify the \\nsequence in which to migrate projects  and how to understand a\", \"nd update your app\\u2019s dependencies . It \\nalso detailed additional strategies for migrating apps while\", \" keeping them running in production . \\nIn chapter 4, you saw how a real ASP.NET MVC reference app wa\", \"s migrated to ASP.NET Core . This \\nchapter included a detailed breakdown of all the changes that wer\", \"e needed to take the existing app \\nand port it over to run on ASP.NET Core. Refer back to it if you \", \"have specific questions about the \\nporting process and some of its more specific detai ls. \\nFinally,\", \" chapter 5 detailed specific deployment scenarios focused on IIS . You saw how you can use \\nyour exi\", \"sting IIS web server to host parts of your app that have been ported to ASP.NET Core while \\nkeeping \", \"the app\\u2019s public URLs consistent. IIS includes great support for URL rewriting and request \\nrouting \", \"that enables it to host multiple versions of your site side by side or even on different servers, \\nw\", \"ith no change to the public -facing URLs the app exposes.  \"]"