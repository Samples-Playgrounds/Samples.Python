"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\fPUBLISHED BY \\n\\nMicrosoft Developer Divisi\", \"on, .NET, and Visual Studio product teams \\n\\nA division of Microsoft Corporation \\n\\nOne Microsoft Way \", \"\\n\\nRedmond, Washington 98052-6399 \\n\\nCopyright \\u00a9 2023 by Microsoft Corporation \\n\\nAll rights reserved. \", \"No part of this book\\u2019s contents may be reproduced or transmitted in any form or \\nby any means withou\", \"t the written permission of the publisher. \\n\\nThis book is provided \\u201cas-is\\u201d and expresses the author\\u2019\", \"s views and opinions. The views, opinions, and \\ninformation expressed in this book, including URL an\", \"d other Internet website references, may change \\nwithout notice. \\n\\nSome examples depicted herein are\", \" provided for illustration only and are fictitious. No real association \\nor connection is intended o\", \"r should be inferred. \\n\\nMicrosoft and the trademarks listed at https://www.microsoft.com on the \\u201cTra\", \"demarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies. \\n\\nMac and macOS are trademarks\", \" of Apple Inc. \\n\\nThe Docker whale logo is a registered trademark of Docker, Inc. Used by permission.\", \" \\n\\nAll other marks and logos are property of their respective owners. \\n\\nAuthors: \\n\\nSteve \\u201cardalis\\u201d S\", \"mith, Software Architect and Trainer - Ardalis.com \\n\\nParticipants and Reviewers: \\n\\nNish Anil, Senior\", \" Program Manager, .NET team, Microsoft \\n\\nMike Rousos, Principal Software Engineer, .NET team, Micros\", \"oft \\n\\nScott Addie, Senior Content Developer, .NET team, Microsoft \\n\\nDavid Pine, Senior Content Devel\", \"oper, .NET team, Microsoft \\n\\nVersion \\n\\nThis guide covers .NET 7 and updates related to the same tech\", \"nology \\u201cwave\\u201d (that is, Azure and other \\nthird-party technologies) coinciding in time with the .NET \", \"7 release. This book covers migration of \\napps that are currently running on .NET Framework 4.x. \\n\\nW\", \"ho should use this guide \\n\\nThis guide\\u2019s audience is developers, development leads, and architects wh\", \"o are interested in \\nmigrating their existing apps written for ASP.NET MVC and Web API (.NET Framewo\", \"rk 4.x) to the latest \\n\\n \\n\\f.NET version. ASP.NET Web Forms developers will benefit from this guide b\", \"ut should also read the \\nBlazor for ASP.NET Web Forms Developers e-book. \\n\\nA secondary audience is t\", \"echnical decision-makers planning when to move their apps to .NET 7. \\n\\nThe target audience for this \", \"book is .NET developers with large, existing apps that run on ASP.NET \\nMVC and Web API. Apps built o\", \"n ASP.NET Web Forms are outside of the focus of this book, though \\nmuch of the information comparing\", \" .NET Framework and .NET Core/latest may still be relevant. \\n\\nHow you can use this guide \\n\\nYou can r\", \"ead this book straight through, as we expect many readers to do. This book will provide you \\nfirst w\", \"ith considerations for whether you should port your app at all. That content is followed by \\narchite\", \"ctural differences between .NET Framework and .NET Core. From there, you\\u2019ll learn strategies \\nfor mi\", \"grating a large solution over time and how to port a real app. Next, the book includes \\ndeployment s\", \"cenarios that address the need to run different apps while appearing as a single app to \\nusers. The \", \"book concludes with two case studies describing real apps that have migrated from \\nASP.NET MVC to AS\", \"P.NET Core. \\n\\nWhether or not you choose to start from the first chapter, you can reference any of th\", \"ese chapters to \\nlearn about specific concepts: \\n\\n\\u2022 \\n\\nArchitectural differences \\n\\n\\u2022  Migrate large s\", \"olutions \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nSample migration \\n\\nDeployment scenarios \\n\\nThis guide is available both in PDF for\", \"m and online. Feel free to forward this document or links to its \\nonline version to your team to ens\", \"ure a common understanding of these concepts. \\n\\n \\n\\fContents \\n\\nIntroduction to porting apps to .NET 7\", \" ................................................................................ 1 \\n\\nReferences ...\", \"....................................................................................................\", \"........................................................................... 2 \\n\\nMigration considerat\", \"ions ...............................................................................................\", \"....................................................... 2 \\n\\nIs migration to .NET Core appropriate? .\", \"....................................................................................................\", \"................ 2 \\n\\nWhen is .NET Framework appropriate? ...........................................\", \"........................................................................... 3 \\n\\nReferences .........\", \"....................................................................................................\", \"................................................................. 4 \\n\\nMigrate to ASP.NET Core 2.1 ..\", \"....................................................................................................\", \"........................................ 4 \\n\\nShould apps run on .NET Framework with ASP.NET Core 2.1\", \" ........................................................................... 4 \\n\\nReferences ........\", \"....................................................................................................\", \".................................................................. 5 \\n\\nChoose the right .NET Core ve\", \"rsion ..............................................................................................\", \"................................... 5 \\n\\nReferences .................................................\", \"....................................................................................................\", \"......................... 5 \\n\\nStrategies for migrating incrementally ...............................\", \"............................................................................................. 6 \\n\\nMi\", \"grating slice by slice .............................................................................\", \"......................................................................... 6 \\n\\nMigrating layer by lay\", \"er .................................................................................................\", \"................................................... 6 \\n\\nReferences .................................\", \"....................................................................................................\", \"......................................... 7 \\n\\nStrategies for migrating ASP.NET Web Forms apps ......\", \"............................................................................................ 7 \\n\\nSep\", \"arate business logic and other concerns.............................................................\", \"............................................... 7 \\n\\nImplement client behavior and web APIs .........\", \"....................................................................................................\", \"..... 8 \\n\\nConsider Blazor ..........................................................................\", \".......................................................................................... 8 \\n\\nSumma\", \"ry .................................................................................................\", \"................................................................................ 8 \\n\\nReferences ....\", \"....................................................................................................\", \"...................................................................... 8 \\n\\nDeployment strategies ...\", \"....................................................................................................\", \".................................................... 8 \\n\\nCross-platform options ....................\", \"....................................................................................................\", \"............................. 8 \\n\\nCloud native development .........................................\", \"....................................................................................................\", \". 9 \\n\\nLeverage containers ..........................................................................\", \"................................................................................. 9 \\n\\nSide-by-side d\", \"eployment options ..................................................................................\", \".............................................. 9 \\n\\nIIS on Windows ..................................\", \"....................................................................................................\", \".............................. 9 \\n\\nOther options on Windows ........................................\", \"....................................................................................................\", \". 9 \\n\\ni \\n\\nContents \\n\\n \\n \\n\\fReferences ...............................................................\", \"....................................................................................................\", \"........... 9 \\n\\nAdditional migration resources .....................................................\", \".................................................................................. 10 \\n\\nOfficial doc\", \"umentation .........................................................................................\", \"......................................................... 10 \\n\\nGitHub ..............................\", \"....................................................................................................\", \"................................................ 10 \\n\\nStack Overflow ...............................\", \"....................................................................................................\", \"............................... 11 \\n\\nYouTube channels ..............................................\", \"....................................................................................................\", \".......... 11 \\n\\nTwitter, Gitter, Slack, and other community channels ...............................\", \"........................................................ 11 \\n\\nReferences ...........................\", \"....................................................................................................\", \"............................................ 11 \\n\\nArchitectural differences between ASP.NET MVC and \", \"ASP.NET Core ............................................... 12 \\n\\nBreaking changes .................\", \"....................................................................................................\", \"............................................. 12 \\n\\nApp startup differences between ASP.NET MVC and A\", \"SP.NET Core ............................................................... 12 \\n\\nASP.NET MVC Startup\", \" ...................................................................................................\", \"................................................. 13 \\n\\nASP.NET Core Startup ........................\", \"....................................................................................................\", \"......................... 13 \\n\\nPorting considerations ..............................................\", \"....................................................................................................\", \". 14 \\n\\nReferences ..................................................................................\", \"......................................................................................... 14 \\n\\nHosti\", \"ng differences between ASP.NET MVC and ASP.NET Core ................................................\", \"....................... 14 \\n\\nReferences ............................................................\", \"....................................................................................................\", \"........... 15 \\n\\nServe static files in ASP.NET MVC and ASP.NET Core ................................\", \"............................................................ 15 \\n\\nHost static files in ASP.NET MVC .\", \"....................................................................................................\", \".......................... 15 \\n\\nHost static files in ASP.NET Core ..................................\", \".............................................................................................. 15 \\n\\n\", \"References .........................................................................................\", \".................................................................................. 16 \\n\\nDependency i\", \"njection differences between ASP.NET MVC and ASP.NET Core ..........................................\", \". 16 \\n\\nDependency injection in ASP.NET Core ........................................................\", \".......................................................... 16 \\n\\nReferences .........................\", \"....................................................................................................\", \".............................................. 17 \\n\\nCompare middleware to modules and handlers .....\", \"................................................................................................. 17\", \" \\n\\nASP.NET modules and handlers ....................................................................\", \"............................................................. 17 \\n\\nASP.NET Core middleware .........\", \"....................................................................................................\", \"............................... 17 \\n\\nAccessing HttpContext..........................................\", \"....................................................................................................\", \"..... 17 \\n\\nReferences ..............................................................................\", \"............................................................................................. 18 \\n\\nC\", \"onfiguration differences between ASP.NET MVC and ASP.NET Core ......................................\", \"..................... 18 \\n\\nASP.NET MVC configuration ...............................................\", \"......................................................................................... 19 \\n\\nASP.N\", \"ET Core configuration ..............................................................................\", \".......................................................... 19 \\n\\nii \\n\\nContents \\n\\n \\n\\fMigrate configura\", \"tion ...............................................................................................\", \"..................................................... 20 \\n\\nReferences ..............................\", \"....................................................................................................\", \"......................................... 21 \\n\\nRouting differences between ASP.NET MVC and ASP.NET C\", \"ore ....................................................................... 21 \\n\\nRouting in ASP.NET \", \"MVC and Web API ....................................................................................\", \".............................. 21 \\n\\nRoute table ....................................................\", \"....................................................................................................\", \"................. 21 \\n\\nRouting in .NET 7 ...........................................................\", \".................................................................................................. 2\", \"3 \\n\\nReferences .....................................................................................\", \"...................................................................................... 24 \\n\\nLogging \", \"differences between ASP.NET MVC and ASP.NET Core ...................................................\", \"................... 25 \\n\\nASP.NET MVC logging .......................................................\", \"............................................................................................ 25 \\n\\nAS\", \"P.NET Core logging .................................................................................\", \"................................................................... 25 \\n\\nMigrate logging ...........\", \"....................................................................................................\", \"................................................. 26 \\n\\nReferences ..................................\", \"....................................................................................................\", \"..................................... 26 \\n\\nCompare Razor Pages to ASP.NET MVC ......................\", \"................................................................................................ 26 \", \"\\n\\nReferences .......................................................................................\", \".................................................................................... 27 \\n\\nCompare AS\", \"P.NET Web API 2 and ASP.NET Core ...................................................................\", \"................................ 27 \\n\\nReferences ...................................................\", \"....................................................................................................\", \".................... 27 \\n\\nCompare authentication and authorization between ASP.NET MVC and ASP.NET C\", \"ore ........................ 27 \\n\\nAuthorization ....................................................\", \"....................................................................................................\", \"............. 28 \\n\\nReferences ......................................................................\", \"....................................................................................................\", \". 28 \\n\\nCompare ASP.NET Identity and ASP.NET Core Identity ..........................................\", \".............................................. 28 \\n\\nMigrate from OWIN / Katana .....................\", \"....................................................................................................\", \"............. 29 \\n\\nReferences ......................................................................\", \"....................................................................................................\", \". 29 \\n\\nCompare controllers in ASP.NET MVC and Web API with controllers in ASP.NET Core .............\", \"............. 29 \\n\\nReferences ......................................................................\", \"....................................................................................................\", \". 30 \\n\\nCompare Razor usage in ASP.NET MVC and ASP.NET Core .........................................\", \"....................................... 30 \\n\\nTag Helpers ...........................................\", \"....................................................................................................\", \".......................... 30 \\n\\nRazor Pages ........................................................\", \"....................................................................................................\", \"............ 30 \\n\\nReferences .......................................................................\", \"....................................................................................................\", \" 31 \\n\\nCompare ASP.NET SignalR and ASP.NET Core SignalR .............................................\", \"............................................ 31 \\n\\nFeature differences ..............................\", \"....................................................................................................\", \"........................ 31 \\n\\nReferences ...........................................................\", \"....................................................................................................\", \"............ 31 \\n\\nCompare testing options between ASP.NET MVC and ASP.NET Core .....................\", \"....................................... 32 \\n\\niii \\n\\nContents \\n\\n \\n\\fReferences ........................\", \"....................................................................................................\", \"............................................... 32 \\n\\nMigrate large solutions to ASP.NET Core .......\", \".............................................................................................. 33 \\n\\n\", \"References .........................................................................................\", \"...................................................................................... 33 \\n\\nIdentify\", \" sequence of projects to migrate ...................................................................\", \"................................................. 33 \\n\\nUnit tests ..................................\", \"....................................................................................................\", \"........................................ 37 \\n\\nConsiderations for migrating many apps ...............\", \"................................................................................................ 37 \", \"\\n\\nSummary ..........................................................................................\", \".................................................................................... 38 \\n\\nReferences\", \" ...................................................................................................\", \"........................................................................ 38 \\n\\nUnderstand and update \", \"dependencies .......................................................................................\", \"................................. 38 \\n\\nUpdate class library dependencies............................\", \"................................................................................................ 38 \", \"\\n\\nUpdate NuGet package dependencies.................................................................\", \"................................................... 39 \\n\\nMigrate ASP.NET MVC projects ..............\", \"....................................................................................................\", \"................ 40 \\n\\nReferences ...................................................................\", \"....................................................................................................\", \".... 40 \\n\\nStrategies for migrating while running in production .....................................\", \"...................................................... 40 \\n\\nRefactor the .NET Framework solution ...\", \"....................................................................................................\", \"............. 40 \\n\\nExtract front-end assets to a CDN ...............................................\", \".............................................................................. 41 \\n\\nExtract and migr\", \"ate individual microservices .......................................................................\", \"................................ 41 \\n\\nDeploy multiple versions of the app side-by-side in IIS ......\", \"............................................................................. 41 \\n\\nApply the Strangl\", \"er pattern .........................................................................................\", \"................................................ 41 \\n\\nMulti-targeting approaches ...................\", \"....................................................................................................\", \".................. 42 \\n\\nSummary ....................................................................\", \"....................................................................................................\", \"...... 42 \\n\\nReferences .............................................................................\", \".............................................................................................. 42 \\n\\n\", \"Example migration of eShop to ASP.NET Core .........................................................\", \"................................. 43 \\n\\nRun ApiPort to identify problematic APIs.....................\", \"............................................................................................... 44 \\n\", \"\\nUpdate project files and NuGet reference syntax ...................................................\", \"................................................. 47 \\n\\nCreate new ASP.NET Core project .............\", \"....................................................................................................\", \"................. 49 \\n\\nMigrating NuGet Packages ....................................................\", \"...................................................................................... 51 \\n\\nMigrate \", \"static files .......................................................................................\", \"..................................................................... 53 \\n\\nMigrate C# files ........\", \"....................................................................................................\", \"..................................................... 54 \\n\\nMigrate views ...........................\", \"....................................................................................................\", \".......................................... 56 \\n\\nMigrate app startup components .....................\", \"....................................................................................................\", \"......... 58 \\n\\nConfigure MVC .......................................................................\", \"........................................................................................... 58 \\n\\niv \", \"\\n\\nContents \\n\\n \\n\\fData access considerations .........................................................\", \"...................................................................................... 63 \\n\\nMigrate \", \"to Entity Framework Core ...........................................................................\", \"................................................. 64 \\n\\nFix all TODO tasks ..........................\", \"....................................................................................................\", \"................................... 67 \\n\\nAdditional MVC customizations .............................\", \"....................................................................................................\", \"..... 68 \\n\\nOther dependencies ......................................................................\", \"...................................................................................... 69 \\n\\nReferenc\", \"es .................................................................................................\", \".............................................................................. 69 \\n\\nMore migration s\", \"cenarios ...........................................................................................\", \"...................................................... 69 \\n\\nMigrate ASP.NET MVC 5 and WebApi 2 to AS\", \"P.NET Core MVC ................................................................... 69 \\n\\nMigrate Http\", \"ResponseMessage to ASP.NET Core ....................................................................\", \".......................... 70 \\n\\nMigrate content negotiation from ASP.NET Web API to ASP.NET Core ...\", \"................................................. 71 \\n\\nCustom model binding ........................\", \"....................................................................................................\", \"...................... 71 \\n\\nMedia formatters .......................................................\", \"....................................................................................................\", \"... 73 \\n\\nCustom filters ............................................................................\", \"......................................................................................... 73 \\n\\nRoute\", \" constraints .......................................................................................\", \"...................................................................... 74 \\n\\nCustom route handlers ..\", \"....................................................................................................\", \"............................................ 75 \\n\\nCORS support .....................................\", \"....................................................................................................\", \"........................... 76 \\n\\nCustom areas ......................................................\", \"....................................................................................................\", \"........... 77 \\n\\nIntegration tests for ASP.NET MVC and ASP.NET Web API..............................\", \"............................................... 78 \\n\\nWCF client configuration ......................\", \"....................................................................................................\", \"..................... 80 \\n\\nReferences ..............................................................\", \"....................................................................................................\", \"......... 80 \\n\\nDeployment scenarios when migrating to ASP.NET Core .................................\", \".................................... 81 \\n\\nSplit a large web app ....................................\", \"....................................................................................................\", \"................... 81 \\n\\nSummary ...................................................................\", \"....................................................................................................\", \"........... 84 \\n\\nReferences ........................................................................\", \"....................................................................................................\", \"... 85 \\n\\nSummary: Port existing ASP.NET Apps to .NET 7 .............................................\", \"......................................... 86 \\n\\nv \\n\\nContents \\n\\n \\n\\fCHAPTER  1 \\n\\nIntroduction to portin\", \"g \\napps to .NET 7 \\n\\n.NET Core and its latest version, .NET 7, represent a revolutionary step forward\", \" from .NET Framework. \\nIt offers a host of advantages over .NET Framework across the board from prod\", \"uctivity to \\nperformance, from cross-platform support to developer satisfaction. ASP.NET Core was ev\", \"en voted \\nthe most-loved web framework (tied with Svelte) in the 2021 Stack Overflow developer surve\", \"y. Clearly \\nthere are strong reasons to consider migrating. \\n\\nEven before .NET 7 shipped, Microsoft \", \"was clear: .NET Core is the Future of .NET. To quote this article: \\n\\nNew apps should be built on .NE\", \"T Core. .NET Core is where future investments in .NET will happen. \\nExisting apps are safe to remain\", \" on .NET Framework which will be supported. Existing apps that want \\nto take advantage of the new fe\", \"atures in .NET should consider moving to .NET Core. As we plan into \\nthe future, we will be bringing\", \" in even more capabilities to the platform. \\n\\nToday, .NET 7 is what new apps should target, and if y\", \"ou\\u2019re migrating an existing app from .NET \\nFramework, .NET 7 is your ideal target framework. \\n\\nHowev\", \"er, upgrading your app to ASP.NET Core will require some effort. That effort should be \\nbalanced aga\", \"inst business value and goals. .NET Framework apps have a long life ahead of them, with \\nsupport bui\", \"lt into Windows for the foreseeable future. What are some of the questions you should \\nconsider befo\", \"re deciding migration to .NET 7 is appropriate? What are the expected advantages? \\nWhat are the trad\", \"eoffs? How much effort is involved? These obvious questions are just the beginning, \\nbut make for a \", \"great starting point as teams consider how to support their customers\\u2019 needs with \\napps today and to\", \"morrow. \\n\\n\\u2022 \\n\\nIs migration to .NET 7 appropriate? \\n\\n\\u2022  When does it make sense to remain on .NET Fra\", \"mework? \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nShould apps target ASP.NET Core 2.1 as a stepping stone? \\n\\nHow should teams choose\", \" the right .NET version to target? \\n\\n\\u2022  What strategies are recommended for incremental migration of\", \" large apps? \\n\\n\\u2022  What deployment strategies should be considered when porting to .NET 7? \\n\\n\\u2022  Where\", \" can we find additional resources? \\n\\nThis introductory chapter addresses all of these questions and \", \"more before moving on to more \\nspecific and technical considerations in future chapters. \\n\\n1 \\n\\nCHAPT\", \"ER 1 | Introduction to porting apps to .NET 7 \\n\\n \\n \\n\\fReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n2021 Stack Overflow develo\", \"per survey most loved web frameworks \\n\\n.NET Core is the Future of .NET \\n\\nMigration considerations \\n\\n\", \"The most fundamental question teams must answer when it comes to porting their apps to .NET Core \\nis\", \", should they port at all? In some cases, the best path forward is to remain on .NET Framework using\", \" \\nASP.NET MVC and/or Web API. This chapter considers reasons why moving to .NET Core makes sense. \\nT\", \"he chapter also considers scenarios and counterpoints for staying on .NET Framework. \\n\\nIs migration \", \"to .NET Core appropriate? \\n\\nLet\\u2019s start with some of the reasons why you might want to move to .NET \", \"Core/.NET 7. There are quite \\na few, so don\\u2019t consider this list exhaustive. \\n\\nCross-platform suppor\", \"t \\n\\nApps built on .NET Core are truly cross-platform and can run on Windows, Linux, and macOS. Not o\", \"nly \\ncan your developers use whatever hardware they want, but you can also host your app anywhere. \\n\", \"Examples range from local IIS to Azure in the cloud or from Linux Docker containers to IoT devices. \", \"\\n\\nPerformance and scalability \\n\\nApps built with .NET Core are running on one of the fastest tech sta\", \"cks available anywhere. ASP.NET \\nMVC apps often see performance improvements on ASP.NET Core, especi\", \"ally if they\\u2019re updated to \\ntake advantage of some new features available in .NET Core. \\n\\nCloud-nati\", \"ve \\n\\nFor the above reasons and others, .NET Core apps are well-suited to running in cloud hosting \\ne\", \"nvironments. Lightweight and fast, .NET Core apps can be deployed to Azure App Services or \\ncontaine\", \"rs and scaled horizontally as needed to meet immediate system demand. \\n\\nMaintainable \\n\\nFor many apps\", \", while they\\u2019ve continued to meet customer and business needs, technical debt has \\naccumulated and m\", \"aintaining the app has grown expensive. ASP.NET Core apps are more easily \\ntested than ASP.NET MVC a\", \"pps, making them easier to refactor and extend with confidence. \\n\\nModular \\n\\nASP.NET Core is modular,\", \" using NuGet packages as a first-class part of the framework. Apps built for \\n.NET Core all support \", \"dependency injection, making it easy to compose solutions from whatever \\nimplementations are needed \", \"for a given environment. Building microservices with .NET Core is easier \\n\\n2 \\n\\nCHAPTER 1 | Introduct\", \"ion to porting apps to .NET 7 \\n\\n \\n \\n\\fthan with ASP.NET MVC with its dependency on IIS, which opens u\", \"p additional options to break up \\nlarge apps into smaller modules. \\n\\nModern \\n\\nStaying on a modern, a\", \"ctively developed technology stack has a host of advantages. New features \\nand C# language features \", \"will only be added to .NET Core. The .NET Framework has had its last \\nrelease with version 4.8, and \", \"versions of C# beyond 8 won\\u2019t target .NET Framework. While ASP.NET \\nMVC will remain supported by Mic\", \"rosoft for many years, the best and brightest .NET software \\ndevelopers are likely looking to use th\", \"e more modern .NET Core framework, with all of the advantages \\nit offers (only some of which are sum\", \"marized above). Finding developers with the skills to maintain an \\nASP.NET MVC app will start to bec\", \"ome a challenge at some point, as will finding online training and \\ntroubleshooting assistance. Ther\", \"e probably aren\\u2019t that many new blog posts being written about \\nASP.NET MVC 5, while there are plent\", \"y being written for .NET 7, for example. \\n\\nThere are many compelling reasons to consider migrating t\", \"o .NET Core, which presumably is why \\nyou\\u2019re reading this book! But let\\u2019s consider some disadvantage\", \"s and reasons why it may make more \\nsense to remain on the .NET Framework. \\n\\nWhen is .NET Framework \", \"appropriate? \\n\\nThe biggest reason to stay on .NET Framework is when an app isn\\u2019t under active develo\", \"pment and \\nwouldn\\u2019t benefit substantially from the advantages listed above. In that case, there prob\", \"ably isn\\u2019t a \\ngood business case to incur the cost of porting the app. If your app might benefit fro\", \"m the \\nadvantages .NET Core offers, you may still need to stay on .NET Framework if you need certain\", \" \\ntechnologies that are unavailable on .NET Core. There are some .NET technologies that are unavaila\", \"ble \\non .NET Core, including AppDomains, Remoting, Code Access Security (CAS), Security Transparency\", \", \\nand System.EnterpriseServices. A brief summary of these technologies and their alternatives is \\ni\", \"ncluded here. For more detailed guidance, see the documentation. \\n\\nApplication domains \\n\\nApplication\", \" domains (AppDomains) isolate apps from one another. AppDomains require runtime \\nsupport and can be \", \"expensive. Creating additional app domains isn\\u2019t supported, and there are no \\nplans to add this capa\", \"bility to .NET Core in the future. For code isolation, use separate processes or \\ncontainers as an a\", \"lternative. Some customers use AppDomains as a way of unloading assemblies. In \\n.NET Core AssemblyLo\", \"adContext provides an alternative way to unload assemblies. \\n\\nWCF \\n\\n.NET Core and .NET 5+ support WC\", \"F clients. Server-side WCF is possible through CoreWCF, which is \\nofficially supported by Microsoft \", \"as of April 2022. Apps that require server-side WCF functionality can \\nalso consider a different com\", \"munication technology (such as gRPC or REST) as part of a migration. \\n\\nThere is a WCF client port av\", \"ailable from the .NET Foundation. It\\u2019s entirely open source, cross \\nplatform, and supported by Micro\", \"soft. \\n\\nTo learn more about migrating from WCF to gRPC, consult the gRPC for WCF Developers ebook. \\n\", \"\\n3 \\n\\nCHAPTER 1 | Introduction to porting apps to .NET 7 \\n\\n \\n \\n\\fRemoting \\n\\n.NET Remoting was identifi\", \"ed as a problematic architecture. It\\u2019s used for cross-AppDomain \\ncommunication, which is no longer s\", \"upported. Also, Remoting requires runtime support, which is \\nexpensive to maintain. For these reason\", \"s, .NET Remoting isn\\u2019t supported on .NET Core, and the \\nproduct team doesn\\u2019t plan on adding support \", \"for it in the future. There are several alternative \\nmessaging strategies and implementations you ca\", \"n use to replace remoting in your .NET Core apps. \\n\\nCode Access Security (CAS) and Security Transpar\", \"ency \\n\\nNeither of these technologies are supported by .NET Core. Instead, the recommendation is to u\", \"se \\nsecurity boundaries provided by the operating system. For example, virtualization, containers, o\", \"r user \\naccounts. Run processes with the minimal set of privileges necessary. \\n\\nReferences \\n\\n.NET Fr\", \"amework Technologies Unavailable on .NET Core \\n\\nMigrate to ASP.NET Core 2.1 \\n\\nASP.NET Core 2.1 is an\", \" interesting release because it\\u2019s the most recently supported ASP.NET Core \\nrelease that supported b\", \"oth .NET Core and .NET Framework runtimes. As such, it may offer an easier \\nupgrade path for some ap\", \"ps when compared to upgrading all parts of the app to .NET Core/.NET 7 at \\nonce. Although support fo\", \"r .NET Core 2.1 ended in August 2021, it may make sense as an interim step \\nfor some apps. Also, sup\", \"port for ASP.NET Core 2.1 running on .NET Framework will continue for as \\nlong as its underlying .NE\", \"T Framework is supported. A complete list of currently supported ASP.NET \\nCore 2.1 packages is avail\", \"able for reference. \\n\\nShould apps run on .NET Framework with ASP.NET Core 2.1 \\n\\nASP.NET Core 2.2 and\", \" earlier supported both .NET Core and .NET Framework runtimes. Does it make \\nsense to migrate some o\", \"r all of an app to ASP.NET Core 2.1 as a stepping stone, before porting over \\ncompletely to .NET Cor\", \"e? Apps, or subsets of apps, could see their front-end ASP.NET logic ported to \\nuse ASP.NET Core, wh\", \"ile still consuming .NET Framework libraries for business logic and infrastructure \\nconsumption. Thi\", \"s approach may make sense when there\\u2019s a relatively thin UI layer without much \\nbusiness logic, and \", \"a much larger set of functionality in class libraries. \\n\\nThe main benefit of porting just the front-\", \"end web layer to ASP.NET Core 2.1 is that the existing .NET \\nclass libraries can remain as is during\", \" the initial migration. They may be in continued use by other \\n.NET apps or simply don\\u2019t need to be \", \"in scope for the first iteration of a planned full migration to .NET \\nCore. Reducing the scope of th\", \"e initial migration for large apps helps provide incremental goals that \\nact as stepping stones towa\", \"rd the desired end state, which is often a complete port to .NET Core. \\n\\nIf you have an existing app\", \" that may use this strategy, some things you can do today to help prepare \\nfor the process are to mo\", \"ve as much business logic, data access, and other non-UI logic out of the \\nASP.NET projects and into\", \" separate class libraries as possible. It will also help if you have automated \\n\\n4 \\n\\nCHAPTER 1 | Int\", \"roduction to porting apps to .NET 7 \\n\\n \\n \\n\\ftest coverage of your system, so that you can verify beha\", \"vior remains consistent before and after the \\nmigration. \\n\\nIf your app is so large that you can\\u2019t mi\", \"grate the entire web app at once, and you need to be able to \\ndeploy the new ASP.NET Core app side-b\", \"y-side with the existing ASP.NET app, there are deployment \\nstrategies that can be used to achieve t\", \"his. These are covered in Chapter 5: Deployment Scenarios. \\n\\nKeep in mind that ASP.NET Core 2.1 was \", \"the last LTS release of .NET Core that supported running on \\n.NET Framework and consuming .NET Frame\", \"work libraries. Although the release is now unsupported \\non .NET Core, it continues to be supported \", \"for use with .NET Framework. It will remain supported for \\nas long as the specific .NET Framework ve\", \"rsion is supported. For more information, see ASP.NET Core \\n2.1 on .NET Framework. \\n\\nReferences \\n\\nMi\", \"grating from ASP.NET to ASP.NET Core 2.1 ASP.NET Core 2.1 on .NET Framework ASP.NET Core 2.1 \\nSuppor\", \"ted Packages \\n\\nChoose the right .NET Core version \\n\\nThe largest consideration for most organizations\", \" when choosing which version of .NET to target is the \\nsupport lifecycle. Long Term Support (LTS) re\", \"leases ship less frequently but have a longer support \\nwindow than Standard Term Support (STS) relea\", \"ses. Currently, LTS releases are scheduled to ship \\nevery other year. Customers can choose which rel\", \"eases to target, and can install different releases of \\n.NET side by side on the same machine. LTS r\", \"eleases will receive only critical and compatible fixes \\nthroughout their lifecycle. STS releases wi\", \"ll receive these same fixes and will also be updated with \\ncompatible innovations and features. LTS \", \"releases are supported for three years after their initial \\nrelease. STS releases are supported for \", \"six months after a subsequent STS or LTS release. \\n\\n.NET 7 is the latest STS release; .NET 6 is the \", \"latest LTS release. \\n\\nCustomers looking to migrate a large .NET Framework app to .NET today may be l\", \"ooking for a stable \\ndestination, given that they haven\\u2019t already made the move to an earlier versio\", \"n of .NET Core. In this \\ncase, the best .NET version to target for the migration is .NET 6, which is\", \" the most recent LTS version. \\nWhile support for .NET Core 3.1 ended in December 2022, support for .\", \"NET 6 will continue until \\nNovember 2024. \\n\\nOther customers may want to ensure they\\u2019re upgrading to \", \"the latest supported version, so that post-\\nmigration they\\u2019re not already behind a version. These cu\", \"stomers will want to target .NET 7 for the \\nmigration. \\n\\nIn either case, there is very little differ\", \"ence in the migration process. This book assumes .NET \\nFramework apps will be upgraded to .NET 7. \\n\\n\", \"References \\n\\n.NET and .NET Core Support Policy \\n\\n5 \\n\\nCHAPTER 1 | Introduction to porting apps to .NE\", \"T 7 \\n\\n \\n \\n\\fStrategies for migrating incrementally \\n\\nThe biggest challenge with migrating any large a\", \"pp is determining how to break the process into \\nsmaller tasks. There are several strategies that ca\", \"n be applied for this purpose, including breaking the \\napp into horizontal layers such as UI, data a\", \"ccess, business logic, or breaking up the app into separate, \\nsmaller apps. Another strategy is to u\", \"pgrade some or all of the app to different framework versions on \\nthe way to a recent .NET Core rele\", \"ase. One approach you could use is to migrate vertical slices of the \\napp, rather than attempting to\", \" migrate one horizontal layer at a time. Let\\u2019s consider each of these \\ndifferent approaches. \\n\\nMigra\", \"ting slice by slice \\n\\nOne successful approach to migrating is to identify vertical slices of functio\", \"nality and migrate them to \\nthe target platform one by one. The first step is to create a new ASP.NE\", \"T Core 7 app. Next, identify the \\nindividual page or API endpoint that will be migrated first. Build\", \" out just the necessary functionality to \\nsupport this one route in the new ASP.NET Core app. Then u\", \"se HTTP rewriting and/or a reverse proxy \\nto start sending requests for these pages or endpoints to \", \"the new app rather than the ASP.NET app. \\nThis approach is well-suited to API projects, but can also\", \" work for many MVC apps. \\n\\nWhen migrating slice by slice, the entire stack of the individual API end\", \"point or requested route is \\nrecreated in the new project or solution. The very first such slice typ\", \"ically requires the most effort, \\nsince it will typically need several projects to be created and de\", \"cisions to be made about data access \\nand solution organization. Once the first slice\\u2019s functionalit\", \"y mirrors the existing app\\u2019s, it can be \\ndeployed and the existing app can redirect to it or simply \", \"be removed. This approach is then repeated \\nuntil the entire app has been ported to the new structur\", \"e. \\n\\nSome specific guidance on how to follow this strategy using IIS is covered in Chapter 5, Deploy\", \"ment \\nScenarios. \\n\\nMigrating layer by layer \\n\\nConsider the challenge of migrating a large ASP.NET 4.\", \"5 app. One approach is to migrate the entire \\napp directly from .NET Framework 4.5 to .NET 7. Howeve\", \"r, this approach needs to account for every \\nbreaking change between the two frameworks and versions\", \", which are substantial. Performing this \\nwork on one project at a time provides a set of stepping s\", \"tones so that the entire solution doesn\\u2019t \\nneed to be moved at once. \\n\\nOne piece of the .NET ecosyst\", \"em that helps with interoperability between different .NET frameworks is \\n.NET Standard. .NET Standa\", \"rd allows libraries to build against an agreed upon set of common APIs, \\nensuring they can be used i\", \"n any .NET app. .NET Standard 2.0 is notable because it covers most base \\nclass library functionalit\", \"y used by most .NET Framework and .NET Core apps. Unfortunately, the \\nearliest version of .NET with \", \"support for .NET Standard 2.0 is .NET Framework 4.6.1, and there are a \\nnumber of updates in .NET Fr\", \"amework 4.8 that make it a compelling choice for initial upgrades. \\n\\nOne approach to incrementally u\", \"pgrade a .NET Framework 4.5 system layer-by-layer is to first update \\nits class library dependencies\", \" to .NET Framework 4.8. Then, modify these libraries to be .NET Standard \\nclass libraries. Use multi\", \"-targeting and conditional compilation, if necessary. This step can be helpful \\n\\n6 \\n\\nCHAPTER 1 | Int\", \"roduction to porting apps to .NET 7 \\n\\n \\n \\n\\fin scenarios where app dependencies require .NET Framewor\", \"k and cannot easily be ported directly to \\nuse .NET Standard and .NET Core. Since .NET Framework lib\", \"raries can be consumed by ASP.NET Core \\n2.1 apps, the next step is to migrate some or all of the web\", \" functionality of the app to ASP.NET Core \\n2.1 (as described in the previous chapter). This is a \\u201cbo\", \"ttom up\\u201d approach, starting with low level class \\nlibrary dependencies and working up to the web app\", \" entry point. \\n\\nOnce the app is running on ASP.NET Core 2.1, migrating it to .NET 7 in isolation is \", \"relatively \\nstraightforward. The most likely challenge during this step is updating incompatible dep\", \"endencies to \\nsupport .NET Core and possibly higher versions of .NET Standard. For apps that don\\u2019t h\", \"ave \\nproblematic dependencies on .NET Framework-only libraries, there\\u2019s little reason to upgrade to \", \"\\nASP.NET Core 2.1. Porting directly to ASP.NET Core 7 makes more sense and requires less effort. \\n\\n.\", \"NET 7 is the latest version of .NET and will be supported until six months after the next STS or LTS\", \" \\nrelease (scheduled for November 2023) - so most likely support will last at least until May 2024. \", \"Many \\nteams looking to migrate today will choose to upgrade to .NET 7. \\n\\nInstead of a \\u201cbottom up\\u201d ap\", \"proach, another alternative is to start with the web app (or even the entire \\nsolution) and use an a\", \"utomated tool to assist with the upgrade. The .NET Upgrade Assistant tool can \\nbe used to help upgra\", \"de .NET Framework apps to .NET Core / .NET 7. It automates many of the \\ncommon tasks related to upgr\", \"ading apps, such as modifying project file format, setting appropriate \\ntarget frameworks, updating \", \"NuGet dependencies, and more. \\n\\nReferences \\n\\n\\u2022  What is .NET Standard? \\n\\n\\u2022  Migrate from ASP.NET Cor\", \"e 6.0 to 7.0 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAnnouncing .NET 6 - The Fastest .NET Yet \\n\\nIntroducing .NET 5 \\n\\n\\u2022  Migrate fr\", \"om ASP.NET Core 3.1 to 6.0 LTS \\n\\n\\u2022 \\n\\n.NET Upgrade Assistant tool \\n\\nStrategies for migrating ASP.NET \", \"Web Forms apps \\n\\nThis book offers guidance for migrating large ASP.NET MVC and Web API apps to .NET \", \"Core. Some of \\nthese ASP.NET apps may also include Web Forms (.aspx) pages that must be addressed. A\", \"SP.NET Web \\nForms isn\\u2019t supported in ASP.NET Core (nor are ASP.NET Web Pages). Typically, the functi\", \"onality of \\nthese pages must be rewritten when porting to ASP.NET Core. There are, however, some str\", \"ategies \\nyou can apply before or during such migration to help reduce the overall effort required. \\n\", \"\\nWeb Forms will continue to be supported for quite some time. One option may be to keep this \\nfuncti\", \"onality in an ASP.NET 4.x app. \\n\\nSeparate business logic and other concerns \\n\\nThe less code in your \", \"ASP.NET Web Forms pages, the better. When possible, keep business logic and \\nother concerns like dat\", \"a access in separate classes, ideally in separate class libraries. These class \\nlibraries can be por\", \"ted to .NET Standard and consumed by any ASP.NET Core app. \\n\\n7 \\n\\nCHAPTER 1 | Introduction to porting\", \" apps to .NET 7 \\n\\n \\n \\n\\fImplement client behavior and web APIs \\n\\nConsider the choice between implemen\", \"ting logic in Web Forms or in the browser with the help of API \\ncalls. Favor the latter. Migrating A\", \"PIs to ASP.NET Core is supported. Client-side behavior should be \\nindependent of the server-side sta\", \"ck your app is using. Using this approach has the added benefit of \\nproviding a more responsive user\", \" experience. \\n\\nConsider Blazor \\n\\nBlazor lets you build interactive web UIs with C# instead of JavaSc\", \"ript. It can run on the server or in \\nthe browser using WebAssembly. ASP.NET Web Forms apps may be p\", \"orted page-by-page to Blazor \\napps. For more information on porting Web Forms apps to Blazor, see Bl\", \"azor for ASP.NET Web Forms \\nDevelopers. In addition, many Web Forms controls have been ported to Bla\", \"zor as part of an open-\\nsource community project, Blazor Web Forms Components. With these components\", \", you can more \\neasily port Web Forms pages to Blazor even if they use the built-in Web Forms contro\", \"ls. \\n\\nSummary \\n\\nMigrating directly from ASP.NET Web Forms to ASP.NET Core isn\\u2019t supported. However, \", \"there are \\nstrategies to make moving to ASP.NET Core easier. You can migrate your Web Forms function\", \"ality to \\nASP.NET Core successfully by: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nKeeping non-web functionality out of your proj\", \"ects. \\n\\nUsing web APIs wherever possible. \\n\\nConsidering Blazor as an option for a more modern UI. \\n\\n\", \"References \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nFree e-book: Blazor for ASP.NET Web Forms Developers \\n\\nBlazor Web Forms Compone\", \"nts (Community Project) \\n\\nDeployment strategies \\n\\nOne consideration as you plan the migration of you\", \"r large ASP.NET app to ASP.NET Core is how you\\u2019ll \\ndeploy the new app. With ASP.NET, deployment opti\", \"ons were limited to IIS on Windows. With \\nASP.NET Core, a much wider array of deployment options is \", \"available. \\n\\nCross-platform options \\n\\nBecause .NET Core runs on Linux, you\\u2019ll find some hosting opti\", \"ons available that weren\\u2019t a \\nconsideration previously. Linux-based hosting may be preferable for th\", \"e following reasons: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nYour organization has infrastructure or expertise. \\n\\nHosting provider\", \"s offer attractive features or pricing for Linux-based hosting. \\n\\n.NET Core opens the door to these \", \"options. \\n\\n8 \\n\\nCHAPTER 1 | Introduction to porting apps to .NET 7 \\n\\n \\n \\n\\fCloud native development \\n\\n\", \"Most organizations today are using cloud platforms for at least some of their software capabilities.\", \" \\nWith an app migration to .NET Core, it\\u2019s a good time to consider whether the app should be \\npurpos\", \"efully written with cloud hosting in mind. Such cloud native apps are better able to apply cloud \\nca\", \"pabilities like serverless, microservices, and can be less concerned with the low-level details of h\", \"ow \\nand where they may be deployed. \\n\\nLearn more about cloud native app development in this free e-b\", \"ook, Architecting Cloud Native .NET \\nApplications for Azure. \\n\\nLeverage containers \\n\\nModern apps oft\", \"en leverage containers as a means of reducing variation between hosting \\nenvironments. By deploying \", \"an app to a particular container, the container-hosted app will run the \\nsame whether it\\u2019s running o\", \"n a developer\\u2019s laptop or in production. As part of a migration to .NET \\nCore, it may make sense to \", \"consider whether the app would benefit from deployment via container, \\neither as a full monolith or \", \"broken up into multiple smaller containerized apps. \\n\\nSide-by-side deployment options \\n\\nMigrating la\", \"rge .NET Framework apps to .NET Core often requires a substantial effort. Most \\norganizations will w\", \"ant to be able to break this effort up in some fashion, so that pieces of the app \\ncan be migrated a\", \"nd deployed in production before the entire migration is complete. Running both \\nthe original ASP.NE\", \"T app and its newly-migrated ASP.NET Core sub-app(s) side by side is a frequently \\ncited goal. This \", \"can be achieved through a number of mechanisms including leveraging IIS routing, \\nwhich is covered i\", \"n chapter 5. Other options include leveraging app gateways or cloud design \\npatterns like backends f\", \"or frontends to manage sets of ASP.NET Web APIs and ASP.NET Core API \\nendpoints. \\n\\nIIS on Windows \\n\\n\", \"You can continue hosting your apps on IIS running on Windows. This is a fine option for customers \\nw\", \"ho want to take advantage of ASP.NET Core features without changing their current deployment \\nmodel.\", \" While moving to ASP.NET Core provides more options in terms of how and where to deploy \\nyour apps, \", \"it doesn\\u2019t require that you change from the status quo of using the proven combination of \\nIIS on Wi\", \"ndows. \\n\\nOther options on Windows \\n\\nYou can host apps side-by-side apps on Windows using any combina\", \"tion of Kestrel, HTTP.sys, and IIS \\nhosts, in addition to Docker containers, if needed. If your app \", \"requires a combination of Windows and \\nLinux services, hosting on a Windows server with WSL and/or L\", \"inux Docker containers provides a \\nsingle server solution to hosting all parts of the app. \\n\\nReferen\", \"ces \\n\\n\\u2022 \\n\\nHost and deploy ASP.NET Core \\n\\n9 \\n\\nCHAPTER 1 | Introduction to porting apps to .NET 7 \\n\\n \\n\", \" \\n\\f\\u2022 \\n\\n\\u2022 \\n\\nHost ASP.NET Core on Windows with IIS \\n\\nTroubleshooting ASP.NET Core on Azure App Service\", \" and IIS \\n\\nAdditional migration resources \\n\\nAs you\\u2019re planning and executing your migration from ASP\", \".NET MVC and/or Web API to ASP.NET \\nCore, there are a number of resources available to help beyond t\", \"his book. Make a note of these and \\nleverage them where appropriate to help you overcome obstacles y\", \"ou encounter on your migration \\njourney. \\n\\nOfficial documentation \\n\\nThe official documentation websi\", \"te, learn.microsoft.com, has the most up-to-date information \\navailable about versions, frameworks, \", \"breaking changes, and support options. You\\u2019ll find many links in \\nthis book to docs articles, but fo\", \"r any problem you\\u2019re facing it\\u2019s often worth at least doing a quick \\nsearch of the docs to see if th\", \"ere is already information covering the issue and offering a solution or \\nworkaround. \\n\\nGitHub \\n\\nBec\", \"ause .NET Core is an open-source project, many issues are discovered, reported, discussed, and \\nfixe\", \"d on GitHub. Microsoft has several GitHub organizations in which you\\u2019ll find repositories that may \\n\", \"be helpful. A partial list of these organizations and some of their public repositories are listed b\", \"elow: \\n\\n\\u2022  Microsoft \\n\\n\\u2013 \\n\\nASP.NET API Versioning \\n\\n\\u2022 \\n\\ndotnet \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\nASP\", \".NET Core \\n\\n.NET Runtime \\n\\nEntity Framework Core \\n\\nC# Language \\n\\nDocs \\n\\nDocs Samples \\n\\nTry Convert \\n\", \"\\n.NET Upgrade Assistant tool \\n\\n\\u2022 \\n\\n.NET Architecture Reference Apps \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\neShopModernizing \\n\", \"\\neShopOnWeb \\n\\neShopOnContainers \\n\\nIf you run into problems with your migration, these GitHub reposit\", \"ories are a good place to report \\nthem. The product teams watch the issues and typically respond qui\", \"ckly to bug reports (though \\u201chow \\nto\\u201d questions may be more appropriately directed to Stack Overflow\", \"). \\n\\n10 \\n\\nCHAPTER 1 | Introduction to porting apps to .NET 7 \\n\\n \\n \\n\\fStack Overflow \\n\\nStack Overflow \", \"has a wealth of information in the form of previous questions asked and answers \\ngiven, with the mos\", \"t helpful answers listed first and marked if they solved the problem. In addition to \\nsearching for \", \"an existing solution to a problem you may encounter, you can of course also ask a \\nquestion yourself\", \" and hope for some response from the .NET community. Don\\u2019t forget you can narrow \\ndown a search by u\", \"sing tags, and remember to use appropriate tags when you ask questions to \\nmaximize the chances of s\", \"omeone with the experience needed noticing your question. \\n\\nYouTube channels \\n\\nYouTube has a huge am\", \"ount of .NET and .NET Core video content, which may include useful tutorials \\nor walkthroughs coveri\", \"ng any scenario you may encounter. Consider searching it separately if your \\nother efforts to find h\", \"elp online come up short. Here are a few good places to get started: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\ndotnet \\n\\nVisual Studi\", \"o \\n\\nTwitter, Gitter, Slack, and other community channels \\n\\nYou\\u2019ll find many other ways to connect wi\", \"th .NET developers on the .NET Community page. You can \\nalso join the DotNetEvolution Discord server\", \". Additionally, many product teams and team members \\nare on Twitter as well as in various other comm\", \"unities. You can follow and communicate with the \\nauthor of this book on Twitter as well. \\n\\nReferenc\", \"es \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nOverview of porting from .NET Framework to .NET Core \\n\\n.NET Upgrade Assistant tool \\n\\n\\u2022 \", \" Migrate from ASP.NET to ASP.NET Core \\n\\n\\u2022 \\n\\n.NET Community Resources \\n\\n11 \\n\\nCHAPTER 1 | Introduction\", \" to porting apps to .NET 7 \\n\\n \\n \\n\\fCHAPTER  2 \\n\\nArchitectural differences \\nbetween ASP.NET MVC \\nand A\", \"SP.NET Core \\n\\nThere are many architectural differences between ASP.NET MVC on .NET Framework and ASP\", \".NET \\nCore. It\\u2019s important to have a broad understanding of these differences as teams evaluate the \", \"work \\ninvolved in porting their ASP.NET MVC apps to ASP.NET Core. This chapter looks at each of the \", \"ways \\nin which ASP.NET Core differs substantially from ASP.NET MVC. \\n\\nBreaking changes \\n\\n.NET Core i\", \"s a cross-platform rewrite of .NET Framework. There are many breaking changes between \\nthe two frame\", \"works. The following sections identify specific differences between how ASP.NET MVC \\nand ASP.NET Cor\", \"e apps are designed and developed. Take care to also examine the documentation to \\ndetermine which f\", \"ramework libraries you\\u2019re using that may need to change. In many cases, a \\nreplacement NuGet package\", \" exists to fill in any gaps left between .NET Framework and .NET Core. In \\nrare cases, you may need \", \"to find a third-party solution or implement new custom code to address \\nincompatibilities. \\n\\nApp sta\", \"rtup differences between ASP.NET MVC and \\nASP.NET Core \\n\\nASP.NET MVC apps lived entirely within Inte\", \"rnet Information Server (IIS), the primary web server \\navailable on Windows operating systems. Unlik\", \"e ASP.NET MVC, ASP.NET Core apps are executable \\napps. You can run them from the command line, using\", \" dotnet run. They have an entry point method \\nlike all C# programs, typically public static void Mai\", \"n() or a similar variation (perhaps with arguments \\nor async support). This is perhaps the biggest a\", \"rchitectural difference between ASP.NET Core and \\nASP.NET MVC, and is one of several differences tha\", \"t allows ASP.NET Core to run on non-Windows \\nsystems. \\n\\n12 \\n\\nCHAPTER 2 | Architectural differences b\", \"etween ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fASP.NET MVC Startup \\n\\nHosted within IIS, ASP.NET apps rel\", \"y on IIS to instantiate certain objects and call certain methods \\nwhen a request arrives. ASP.NET cr\", \"eates an instance of the Global.asax file\\u2019s class, which derives from \\nHttpApplication. When the fir\", \"st request is received, before handling the request itself, ASP.NET calls \\nthe Application_Start met\", \"hod in the Global.asax file\\u2019s class. Any logic that needs to run when the \\nASP.NET MVC app begins ca\", \"n be added to this method. \\n\\nMany NuGet packages for ASP.NET MVC and Web API use the WebActivator pa\", \"ckage to let them run \\nsome code during app startup. By convention, this code would typically be add\", \"ed to an App_Start \\nfolder and would be configured via attribute to run either immediately before or\", \" just after \\nApplication_Start. \\n\\nIt\\u2019s also possible to use the Open Web Interface for .NET (OWIN) a\", \"nd Project Katana with ASP.NET \\nMVC. When doing so, the app will include a Startup.cs file that is r\", \"esponsible for setting up request \\nmiddleware in a way that\\u2019s very similar to how ASP.NET Core behav\", \"es. \\n\\nIf you need to run code when your ASP.NET MVC app starts up, it will typically use one of thes\", \"e \\napproaches. \\n\\nASP.NET Core Startup \\n\\nAs noted previously, ASP.NET Core apps are standalone progra\", \"ms. As such, they typically include a \\nProgram.cs file containing the entry point for the app. A typ\", \"ical example of this file is shown in Figure \\n2-1. Notice that in .NET 7, this file is streamlined b\", \"y the use of implicit using statements and top-level \\nstatements, eliminating the need for a lot of \", \"\\u201cboiler plate\\u201d code. \\n\\nvar builder = WebApplication.CreateBuilder(args); \\n\\n// Add services to the co\", \"ntainer. \\nbuilder.Services.AddRazorPages(); \\n\\nvar app = builder.Build(); \\n\\n// Configure the HTTP req\", \"uest pipeline. \\nif (!app.Environment.IsDevelopment()) \\n{ \\n    app.UseExceptionHandler(\\\"/Error\\\"); \\n  \", \"  // The default HSTS value is 30 days. You may want to change this for production \\nscenarios, see h\", \"ttps://aka.ms/aspnetcore-hsts. \\n    app.UseHsts(); \\n} \\n\\napp.UseHttpsRedirection(); \\napp.UseStaticFil\", \"es(); \\n\\napp.UseRouting(); \\n\\napp.UseAuthorization(); \\n\\napp.MapRazorPages(); \\n\\napp.Run(); \\n\\nFigure 2-1\", \". A typical ASP.NET Core Program.cs file. \\n\\n13 \\n\\nCHAPTER 2 | Architectural differences between ASP.N\", \"ET MVC and ASP.NET Core \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\fThe code shown in Figure 2-1 uses a builder to config\", \"ure the host and its services. Then, it creates the \\nrequest pipeline for the app, which controls ho\", \"w every request to the app is handled. \\n\\nPrevious versions of .NET would use a separate Startup.cs f\", \"ile, referenced by Program.cs. This approach \\nis still supported in .NET 7, but is no longer the def\", \"ault approach. \\n\\nIn addition to code related to configuring the app\\u2019s services and request pipeline,\", \" apps may have \\nother code that must run when the app begins. Such code is typically placed in Progr\", \"am.cs or \\nregistered as an IHostedService, which will be started by the generic host when the app st\", \"arts. \\n\\nThe IHostedService interface just exposes two methods, StartAsync and StopAsync. You registe\", \"r the \\ninterface when configuring the app\\u2019s services and the host does the rest, calling the StartAs\", \"ync \\nmethod before the app starts up. \\n\\nPorting considerations \\n\\nTeams looking to migrate their apps\", \" from ASP.NET MVC to ASP.NET Core need to identify what code \\nis being run when their app starts up \", \"and determine the appropriate location for such code in their \\nASP.NET Core app. For custom code nee\", \"ded to run when the app starts up, especially async code, the \\nrecommended approach is typically to \", \"put such code into IHostedService implementations. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nASP.NET Application Li\", \"fe Cycle Overview for IIS 7 \\n\\nASP.NET Application Life Cycle Overview for IIS 5 and 6 \\n\\nGetting Star\", \"ted with OWIN and Katana \\n\\n\\u2022  WebActivator \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nApp Startup in ASP.NET Core \\n\\n.NET Generic \", \"Host in ASP.NET Core \\n\\nIHostedService \\n\\nHosting differences between ASP.NET MVC and \\nASP.NET Core \\n\\n\", \"ASP.NET MVC apps are hosted in IIS, and may rely on IIS configuration for their behavior. This often\", \" \\nincludes IIS modules. As part of reviewing an app to prepare to port it from ASP.NET MVC to ASP.NE\", \"T \\nCore, teams should identify which modules, if any, they\\u2019re using from the list of IIS Modules ins\", \"talled \\non their server. \\n\\nASP.NET Core apps can run on a number of different servers. The default c\", \"ross platform server, \\nKestrel, is a good default choice. Apps running in Kestrel can be hosted by I\", \"IS, running in a separate \\nprocess. On Windows, apps can also run in process on IIS or using HTTP.sy\", \"s. Kestrel is generally \\nrecommended for best performance. HTTP.sys can be used in scenarios where t\", \"he app is exposed to \\nthe Internet and required capabilities are supported by HTTP.sys but not Kestr\", \"el. \\n\\n14 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fKestrel\", \" does not have an equivalent to IIS modules (though apps hosted in IIS can still take advantage \\nof \", \"IIS modules). To achieve equivalent behavior, middleware configured in the ASP.NET Core app itself \\n\", \"is typically used. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nIIS Modules \\n\\nASP.NET Core Middleware \\n\\nASP.NET Core S\", \"ervers \\n\\nServe static files in ASP.NET MVC and ASP.NET Core \\n\\nMost web apps involve a combination of\", \" server-side logic and static files that must be sent to the \\nclient as-is. How should your migratio\", \"n from ASP.NET MVC to ASP.NET Core handle serving static \\nfiles? \\n\\nHost static files in ASP.NET MVC \", \"\\n\\nASP.NET MVC apps, hosted by IIS, typically host static files directly from the app. ASP.NET MVC \\ns\", \"upports placing static files side by side with files that should be kept private on the server. IIS \", \"and \\nASP.NET require explicitly restricting certain files or file extensions from being served from \", \"the folder \\nin which an ASP.NET app is hosted. \\n\\nFor many static files, using a content delivery net\", \"work (CDN) is a good practice. Static content hosting \\nallows better performance while reducing load\", \" and bandwidth from app servers. \\n\\nHost static files in ASP.NET Core \\n\\nIt may be surprising, but ASP\", \".NET Core doesn\\u2019t have built-in support for static files. This feature that \\nhas always existed as j\", \"ust a part of ASP.NET, enabled by IIS, isn\\u2019t intrinsic to ASP.NET Core or its \\nKestrel web server. T\", \"o serve static files from an ASP.NET Core app, you must configure static files \\nmiddleware. \\n\\nWith s\", \"tatic files middleware configured, an ASP.NET Core app will serve all files located in a certain \\nfo\", \"lder (typically /wwwroot). No other files in the app or project folder are at risk of being accident\", \"ally \\nexposed by the server. No special restrictions based on file names or extensions need to be \\nc\", \"onfigured, as is the case with IIS. Instead, developers explicitly choose to expose files publicly w\", \"hen \\nthey place them in the wwwroot folder. By default, files outside of this folder aren\\u2019t shared. \", \"\\n\\nBecause support for static files uses middleware, any other middleware can be applied as part of t\", \"he \\nsame request pipeline. Examples of middleware include authentication, caching, and compression. \", \"\\n\\nOf course, CDNs remain a good choice for ASP.NET Core apps for all the same reasons they\\u2019re used i\", \"n \\nASP.NET MVC apps. As part of preparing to migrate to .NET Core, if there are benefits your app co\", \"uld \\nrealize from using a CDN, it would be good to move static files to a CDN before migrating to .N\", \"ET \\nCore. Doing so reduces the migration effort\\u2019s overall scope for static assets. \\n\\n15 \\n\\nCHAPTER 2 \", \"| Architectural differences between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nStatic \", \"content hosting \\n\\nStatic files in ASP.NET Core \\n\\nDependency injection differences between ASP.NET \\nM\", \"VC and ASP.NET Core \\n\\nAlthough dependency injection (DI) isn\\u2019t built into ASP.NET MVC or Web API, ma\", \"ny apps enable it by \\nadding a NuGet package with an inversion of control (IOC) container. These are\", \" sometimes referred to \\nas DI containers, for dependency injection (or inversion). Some of the most \", \"popular containers used in \\nASP.NET MVC apps include: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAutofac \\n\\nUnity \\n\\nNinjec\", \"t \\n\\nStructureMap (deprecated) \\n\\nCastle Windsor \\n\\nIf your ASP.NET MVC app isn\\u2019t using DI, you will pr\", \"obably want to investigate the built-in support for \\nDI in ASP.NET Core. DI promotes loose coupling \", \"of modules in your app and enables better testability \\nand adherence to principles like SOLID. \\n\\nIf \", \"your app does use DI, then probably your best course of action is to see if the container you\\u2019re \\nus\", \"ing supports ASP.NET Core. If so, you may be able to continue using it and your custom \\nconfiguratio\", \"n rules describing your type mappings and lifetimes. \\n\\nEither way, you should consider using the bui\", \"lt-in support for DI that ships with ASP.NET Core, as it \\nmay meet your app\\u2019s needs. \\n\\nDependency in\", \"jection in ASP.NET Core \\n\\nASP.NET Core assumes apps will use DI. It\\u2019s not just built into the framew\", \"ork, but is required in order \\nto bring support for framework features into your ASP.NET Core apps. \", \"In app startup, calls are made \\nto configure services using the builder.Services property of the web\", \" host builder. This property works \\nwith the application\\u2019s DI container (service collection/service \", \"provider) and is used to create and inject \\nservice dependencies within the app. Built-in ASP.NET Co\", \"re features like Entity Framework Core, \\nIdentity, and even MVC are brought into the app by configur\", \"ing them as services during application \\nstartup. \\n\\nIn addition to using the default implementation,\", \" apps can still use custom containers. The \\ndocumentation covers how to replace the default service \", \"container. \\n\\nDI is fundamental to ASP.NET Core. If your team isn\\u2019t already well-versed in this pract\", \"ice, you\\u2019ll want \\nto understand it before porting your app. \\n\\n16 \\n\\nCHAPTER 2 | Architectural differe\", \"nces between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDependency Injection in .NET \\n\", \"\\nDependency Injection in ASP.NET Core \\n\\nCompare middleware to modules and handlers \\n\\nIf your existin\", \"g ASP.NET MVC or Web API app uses OWIN/Katana, you\\u2019re most likely already familiar \\nwith the concept\", \" of middleware and porting it to ASP.NET Core should be fairly straightforward. \\nHowever, most ASP.N\", \"ET apps rely on HTTP modules and HTTP handlers instead of middleware. \\nMigrating these to ASP.NET Co\", \"re requires extra effort. \\n\\nASP.NET modules and handlers \\n\\nHTTP modules and HTTP handlers are an int\", \"egral part of the ASP.NET architecture. While a request is \\nbeing processed, each request is process\", \"ed by multiple HTTP modules (for example, the \\nauthentication module and the session module) and is \", \"then processed by a single HTTP handler. After \\nthe handler has processed the request, the request f\", \"lows back through the HTTP modules. \\n\\nIf your app is using custom HTTP modules or HTTP handlers, you\", \"\\u2019ll need a plan to migrate them to \\nASP.NET Core. The most likely replacement in ASP.NET Core is mid\", \"dleware. \\n\\nASP.NET Core middleware \\n\\nASP.NET Core defines a request pipeline in each app\\u2019s Configure\", \" method. This request pipeline \\ndefines how an incoming request is handled by the app, with each met\", \"hod in the pipeline calling the \\nnext method until eventually a method terminates, and the chain of \", \"middleware terminates and \\nreturns back up the stack. Middleware can target all requests, or can be \", \"configured to only map to \\ncertain requests based on the requested path or other factors. It can be \", \"configured wholly in the \\nConfigure method of an app, or implemented in a separate class. \\n\\nBehavior\", \" in an ASP.NET MVC app that uses HTTP modules is probably best suited to custom \\nmiddleware. Custom \", \"HTTP handlers can be replaced with custom routes or endpoints that respond to \\nthe same path. \\n\\nAcce\", \"ssing HttpContext \\n\\nMany .NET apps reference the current request\\u2019s context through HttpContext.Curre\", \"nt. This static \\naccess can be a common source of problems with testing and other code usage outside\", \" of individual \\nrequests. When building ASP.NET Core apps, access to the current HttpContext should \", \"be provided as \\na method parameter on middleware, as this sample demonstrates: \\n\\npublic class Middle\", \"ware \\n{ \\n    private readonly RequestDelegate _next; \\n\\n    public Middleware(RequestDelegate next) \\n\", \"    { \\n        _next = next; \\n\\n17 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and AS\", \"P.NET Core \\n\\n \\n \\n \\n\\f    } \\n\\n    public Task Invoke(HttpContext httpContext) \\n    { \\n        return _\", \"next(httpContext); \\n    } \\n} \\n\\nSimilarly, ASP.NET Core filters pass a context argument to their meth\", \"ods, from which the current \\nHttpContext can be accessed: \\n\\npublic class MyActionFilterAttribute : A\", \"ctionFilterAttribute \\n{ \\n    public override void OnResultExecuting(ResultExecutingContext context) \", \"\\n    { \\n        var headers = context.HttpContext.Request.Headers; \\n        // do something based on\", \" a header \\n\\n        base.OnResultExecuting(context); \\n    } \\n} \\n\\nIf you have components or services \", \"that require access to HttpContext, rather than using a static call \\nlike HttpContext.Current you sh\", \"ould instead use constructor dependency injection and the \\nIHttpContextAccessor interface: \\n\\npublic \", \"class MyService \\n{ \\n    private readonly IHttpContextAccessor _httpContextAccessor; \\n\\n    public MyS\", \"ervice(IHttpContextAccessor httpContextAccessor) \\n    { \\n        _httpContextAccessor = httpContextA\", \"ccessor; \\n    } \\n\\n    public void DoSomething() \\n    { \\n        var currentContext = _httpContextAcc\", \"essor.HttpContext; \\n    } \\n} \\n\\nThis approach eliminates the static coupling of the method to the cur\", \"rent context while providing \\naccess in a testable fashion. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nASP.NET HTTP modu\", \"les and HTTP handlers \\n\\nASP.NET Core middleware \\n\\nConfiguration differences between ASP.NET MVC \\nand\", \" ASP.NET Core \\n\\nHow configuration values are stored and read changed dramatically between ASP.NET an\", \"d ASP.NET \\nCore. \\n\\n18 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core \\n\", \"\\n \\n \\n \\n \\n \\n \\n\\fASP.NET MVC configuration \\n\\nIn ASP.NET apps, configuration uses the built-in .NET conf\", \"iguration files, web.config in the app folder \\nand machine.config on the server. Most ASP.NET MVC an\", \"d Web API apps store their settings in the \\nconfiguration file\\u2019s appSettings or connectionStrings el\", \"ements. Some also use custom configuration \\nsections that can be mapped to a settings class. \\n\\nConfi\", \"guration in a .NET Framework app is accessed using the \\nSystem.Configuration.ConfigurationManager cl\", \"ass. Unfortunately, this class provides static access to \\nthe configuration elements. As a result, v\", \"ery few ASP.NET MVC apps tend to abstract access to their \\nconfiguration settings or inject them whe\", \"re needed. Instead, most .NET Framework apps tend to \\ndirectly access the configuration system anywh\", \"ere the app needs to use a setting. \\n\\nTypical ASP.NET MVC configuration access: \\n\\nstring connectionS\", \"tring = \\n    ConfigurationManager.ConnectionStrings[\\\"DefaultConnection\\\"] \\n        .ConnectionString;\", \" \\n\\nASP.NET Core configuration \\n\\nIn ASP.NET Core apps, configuration is, itself, configurable. Howeve\", \"r, most apps use a set of defaults \\nprovided as part of the standard project templates and the Confi\", \"gureWebHostDefaults method used \\nin them. The default settings use JSON formatted files, with the ab\", \"ility to override settings in the base \\nappsettings.json file with environment-specific files like a\", \"ppsettings.Development.json. Additionally, the \\ndefault configuration system further overrides all f\", \"ile-based settings with any environment variable \\nthat exists for the same named setting. This is us\", \"eful in many scenarios and is especially useful when \\ndeploying to a hosting environment, since it e\", \"liminates the need to worry about whether deploying \\nconfiguration files will accidentally overwrite\", \" important production configuration settings. \\nConfiguration values can also be provided as command \", \"line arguments. \\n\\nAccessing configuration values can be done in many ways in .NET Core. Because depe\", \"ndency injection \\nis built into .NET Core, configuration values are generally accessed through an in\", \"terface that is \\ninjected into classes that need them. This can involve passing a interface like ICo\", \"nfiguration, but \\nusually it\\u2019s better to pass just the settings required by the class using the opti\", \"ons pattern. \\n\\nFigure 2-2 shows how to pass IConfiguration into a Razor Page and access configuratio\", \"n settings from \\nit: \\n\\nusing Microsoft.Extensions.Configuration; \\n\\npublic class TestModel : PageMode\", \"l \\n{ \\n    private readonly IConfiguration _configuration; \\n\\n    public TestModel(IConfiguration conf\", \"iguration) \\n    { \\n        _configuration= configuration; \\n    } \\n\\n    public ContentResult OnGet() \", \"\\n    { \\n\\n19 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n \\n \\n \", \"\\n\\f        var myKeyValue = _configuration[\\\"MyKey\\\"]; \\n\\n        // ... \\n    } \\n} \\n\\nFigure 2-2. Accessi\", \"ng configuration values with IConfiguration. \\n\\nUsing the options pattern, settings access is similar\", \" but is strongly typed and more specific to the \\nsetting(s) needed by the consuming class, as Figure\", \" 2-3 demonstrates. \\n\\npublic class PositionOptions \\n{ \\n    public const string Position = nameof(Posi\", \"tion); \\n\\n    public string Title { get; set; } \\n    public string Name { get; set; } \\n} \\n\\npublic cla\", \"ss Test2Model : PageModel \\n{ \\n    private readonly PositionOptions _options; \\n\\n    public Test2Model\", \"(IOptions<PositionOptions> options) \\n    { \\n        _options = options.Value; \\n    } \\n\\n    public Co\", \"ntentResult OnGet() \\n    { \\n        return Content($\\\"Title: {_options.Title}\\\\nName: {_options.Name}\\\"\", \"); \\n    } \\n} \\n\\nFigure 2-3. Using the options pattern in ASP.NET Core. \\n\\nFor the options pattern to w\", \"ork, the options type must be configured in ConfigureServices when the \\napp starts up: \\n\\n// required\", \" in ConfigureServices \\nservices.Configure<PositionOptions>(Configuration.GetSection(PositionOptions.\", \"Position)); \\n\\nMigrate configuration \\n\\nWhen considering how to port an app\\u2019s configuration settings f\", \"rom .NET Framework to .NET Core, the \\nfirst step is to identify all of the configuration settings th\", \"at are being used. Most of these will be in the \\nweb.config file in the app\\u2019s root folder, but some \", \"apps expect settings to be found in the shared \\nmachine.config file as well. These settings will inc\", \"lude elements of the appSettings element, the \\nconnectionStrings element, and any custom configurati\", \"on elements as well. In .NET Core, all of these \\nsettings are typically stored in the appsettings.js\", \"on file. \\n\\nOnce all settings in the config files have been cataloged, the next step should be to ide\", \"ntify where \\nand how the settings are used in the app itself. If some settings aren\\u2019t being used, th\", \"ese can probably \\nbe omitted from the migration. For each setting, note all of the places it\\u2019s being\", \" used so you can be \\nsure you don\\u2019t miss any when you migrate the code. \\n\\n20 \\n\\nCHAPTER 2 | Architect\", \"ural differences between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n \\n \\n \\n \\n \\n\\fIf you\\u2019re still maintaining t\", \"he ASP.NET app, it may be helpful to avoid static references to \\nConfigurationManager and replace th\", \"em with access through interfaces. This will ease the transition \\nto ASP.NET Core\\u2019s configuration sy\", \"stem. In general, static access to external resources makes code \\nharder to test and maintain, so be\", \" on the lookout for anywhere else the app may be following this \\npattern. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nCon\", \"figuration in ASP.NET Core \\n\\nOptions pattern in ASP.NET Core \\n\\n\\u2022  Migrate configuration to ASP.NET C\", \"ore \\n\\n\\u2022 \\n\\nRefactoring Static Config Access \\n\\nRouting differences between ASP.NET MVC and \\nASP.NET Co\", \"re \\n\\nRouting is responsible for mapping incoming browser requests to particular controller actions (\", \"or \\nRazor Pages handlers). This section covers how routing differs between ASP.NET MVC (and Web API)\", \" \\nand ASP.NET Core (MVC, Razor Pages, and otherwise). \\n\\nRouting in ASP.NET MVC and Web API \\n\\nASP.NET\", \" MVC offers two approaches to routing: \\n\\n1. \\n\\n2. \\n\\nThe route table, which is a collection of routes \", \"that can be used to match incoming requests \\nto controller actions. \\n\\nAttribute routing, which perfo\", \"rms the same function but is achieved by decorating the actions \\nthemselves, rather than editing a g\", \"lobal route table. \\n\\nRoute table \\n\\nThe route table is configured when the app starts up. Typically, \", \"a static method call is used to \\nconfigure the global route collection, like so: \\n\\npublic class MvcA\", \"pplication : System.Web.HttpApplication \\n{ \\n    public static void RegisterRoutes(RouteCollection ro\", \"utes) \\n    { \\n        routes.IgnoreRoute(\\\"{resource}.axd/{*pathInfo}\\\"); \\n        routes.MapRoute( \\n \", \"           name: \\\"Default\\\", \\n            url: \\\"{controller}/{action}/{id}\\\", \\n            defaults: n\", \"ew { controller = \\\"Home\\\", action = \\\"Index\\\", id = \\\"\\\" }, \\n            constraints: new { id = \\\"\\\\\\\\d+\\\" }\", \" \\n        ); \\n    } \\n\\n    protected void Application_Start() \\n    { \\n\\n21 \\n\\nCHAPTER 2 | Architectural\", \" differences between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n \\n\\f        RegisterRoutes(RouteTable.Routes)\", \"; \\n    } \\n} \\n\\nIn the preceding code, the route table is managed by the RouteCollection type, which i\", \"s used to add \\nnew routes with MapRoute. Routes are named and include a route string, which can incl\", \"ude \\nparameters for controllers, actions, areas, and other placeholders. If an app follows a standar\", \"d \\nconvention, most of its actions can be handled by this single default route, with any exceptions \", \"to this \\nconvention configured using additional routes. \\n\\nAttribute routing in ASP.NET MVC \\n\\nRoutes \", \"that are defined with their actions may be easier to discover and reason about than routes \\ndefined \", \"in an external location. Using attribute routing, an individual action method can have its route \\nde\", \"fined with a [Route] attribute: \\n\\npublic class ProductsController \\n{ \\n    [Route(\\\"products\\\")] \\n    p\", \"ublic ActionResult Index() \\n    { \\n        return View(); \\n    } \\n\\n    [Route(\\\"products/{id}\\\")] \\n   \", \" public ActionResult Details(int id) \\n    { \\n        return View(); \\n    } \\n} \\n\\nAttribute routing in\", \" ASP.NET MVC 5 also supports defaults and prefixes, which can be added at the \\ncontroller level (and\", \" which are applied to all actions within that controller). Refer to the \\ndocumentation for details. \", \"\\n\\nSetting up attribute routing requires adding one line to the default route table configuration: \\n\\n\", \"routes.MapMvcAttributeRoutes(); \\n\\nAttribute routing can take advantage of route constraints, both bu\", \"ilt-in and custom, and supports \\nnamed routes and areas using the [RouteArea] attribute. If your app\", \" uses areas, you\\u2019ll need to \\nconfigure support for them in your route registration code by adding on\", \"e more line: \\n\\nroutes.MapMvcAttributeRoutes(); \\n\\nAreaRegistration.RegisterAllAreas(); \\n\\nAttribute ro\", \"uting in ASP.NET Web API 2 \\n\\nAttribute routing in ASP.NET Web API 2 is similar to routing in ASP.NET\", \" MVC 5, with minor differences. \\nConfiguring Web API 2 is typically done in its own class, which is \", \"called during app startup. Attribute \\nrouting configuration is handled in this class: \\n\\npublic stati\", \"c class WebApiConfig \\n{ \\n\\n22 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET\", \" Core \\n\\n \\n \\n \\n \\n\\f    public static void Register(HttpConfiguration config) \\n    { \\n        // Attrib\", \"ute routing. \\n        config.MapHttpAttributeRoutes(); \\n\\n        // Convention-based routing. \\n     \", \"   config.Routes.MapHttpRoute( \\n            name: \\\"DefaultApi\\\", \\n            routeTemplate: \\\"api/{co\", \"ntroller}/{id}\\\", \\n            defaults: new { id = RouteParameter.Optional } \\n        ); \\n    } \\n} \\n\", \"\\nAs shown in the preceding code, attribute routing may be combined with convention-based routing \\nin\", \" Web API apps. \\n\\nIn addition to attribute routing, ASP.NET Web API chooses which action to call base\", \"d on the HTTP \\nmethod (for example, GET or POST), the {action} placeholder in a route (if any), and \", \"parameters of the \\naction. In many cases, the name of the action will help determine whether it\\u2019s ma\", \"tched, since prefixing \\nthe action name with \\u201cGet\\u201d or \\u201cPost\\u201d is used to match the appropriate HTTP m\", \"ethod to it. \\nAlternatively, actions can be decorated with an appropriate HTTP method attribute, lik\", \"e [HttpGet], \\nallowing the use of action names that aren\\u2019t prefixed with an HTTP method. \\n\\npublic cl\", \"ass ProductsController : ApiController \\n{ \\n    // matched by name and (lack of) parameters \\n    publ\", \"ic IEnumerable<Product> GetAll() { } \\n\\n    // matched by GET and string parameter \\n    [HttpGet] \\n  \", \"  public IEnumerable<Product> FindProductsByName(string name) { } \\n} \\n\\nGiven the above controller, a\", \"n HTTP GET request to localhost:123/products/ matches the GetAll \\naction. An HTTP GET request to loc\", \"alhost:123/products?name=ardalis matches the \\nFindProductsByName action. \\n\\nRouting in .NET 7 \\n\\nIn AS\", \"P.NET Core, routing is handled by routing middleware, which matches the URLs of incoming \\nrequests t\", \"o actions or other endpoints. Controller actions are either conventionally routed or \\nattribute-rout\", \"ed. Conventional routing is similar to the route table approach used in ASP.NET MVC \\nand Web API. Wh\", \"ether you\\u2019re using conventional, attribute, or both, you need to configure your app \\nto use the rout\", \"ing middleware. To use the middleware, add the following code to your Program.cs file: \\n\\napp.UseRout\", \"ing(); \\n\\nConventional routing \\n\\nWith conventional routing, you set up one or more conventions that w\", \"ill be used to match incoming \\nURLs to endpoints in the app. In ASP.NET Core, these endpoints may be\", \" controller actions, like in \\nASP.NET MVC or Web API. The endpoints could also be Razor Pages, Healt\", \"h Checks, or SignalR hubs. \\nAll of these routable features are configured in a similar fashion using\", \" endpoints: \\n\\n23 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\", \" \\n \\n\\fapp.UseEndpoints(endpoints => \\n{ \\n    endpoints.MapHealthChecks(\\\"/healthz\\\").RequireAuthorizatio\", \"n(); \\n    endpoints.MapControllerRoute( \\n        name: \\\"default\\\", \\n        pattern: \\\"{controller=Hom\", \"e}/{action=Index}/{id?}\\\"); \\n    endpoints.MapRazorPages(); \\n}); \\n\\nThe preceding code is used (in add\", \"ition to UseRouting) to configure various endpoints, including \\nHealth Checks, controllers, and Razo\", \"r Pages. For controllers, the above configuration specifies a \\ndefault routing convention, which is \", \"the fairly standard {controller}/{action}/{id?} pattern that\\u2019s been \\nrecommended since the first ver\", \"sions of ASP.NET MVC. \\n\\nAttribute routing \\n\\nAttribute routing in ASP.NET Core is the preferred appro\", \"ach for configuring routing in controllers. If \\nyou\\u2019re building APIs, the [ApiController] attribute \", \"should be applied to your controllers. Among other \\nthings, this attribute requires the use of attri\", \"bute routing for actions in such controller classes. \\n\\nAttribute routing in ASP.NET Core behaves sim\", \"ilarly in ASP.NET MVC and Web API. In addition to \\nsupporting the [Route] attribute, however, route \", \"information can also be specified as part of the HTTP \\nmethod attribute: \\n\\n[HttpGet(\\\"api/products/{i\", \"d}\\\")] \\npublic async ActionResult<Product> Details(int id) \\n{ \\n    // ... \\n} \\n\\nAs with previous versi\", \"ons, you can specify a default route with placeholders, and add this at the \\ncontroller class level \", \"or even on a base class. You use the same [Route] attribute for all of these cases. \\nFor example, a \", \"base API controller class might look like this: \\n\\n[Route(\\\"api/{controller}/{action}/{id?:int}\\\")] \\npu\", \"blic abstract class BaseApiController : ControllerBase, IApiController \\n{ \\n    // ... \\n} \\n\\nUsing thi\", \"s attribute, classes inheriting from this type would route URLs to actions based on the \\ncontroller \", \"name, action name, and an optional integer id parameter. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nASP.\", \"NET MVC Routing Overview \\n\\nAttribute Routing in ASP.NET MVC 5 \\n\\nAttribute routing in ASP.NET Web API\", \" 2 \\n\\nRouting and Action Selection in ASP.NET Web API \\n\\nRouting in ASP.NET Core \\n\\nRouting to controll\", \"er actions in ASP.NET Core MVC \\n\\n24 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and \", \"ASP.NET Core \\n\\n \\n \\n\\fLogging differences between ASP.NET MVC and \\nASP.NET Core \\n\\nApplication logging \", \"provides important diagnostic information, especially for apps running in \\nproduction. ASP.NET Core \", \"introduces a new system for adding standardized logging to any app. \\nExisting ASP.NET MVC and Web AP\", \"I apps most likely use third-party logging solutions, which likely \\ncontinue to be supported on ASP.\", \"NET Core. \\n\\nASP.NET MVC logging \\n\\nThere\\u2019s no built-in logging solution in ASP.NET MVC and Web API ap\", \"ps. Instead, most apps use third-\\nparty logging solutions like log4net, NLog, or Serilog. Many teams\", \" also choose to roll their own \\nlogging solution. Logging frameworks typically support multiple \\u201csin\", \"ks\\u201d (or targets or appenders) for \\nlog output, such as text files, databases, or even emails. They u\", \"se configuration to determine which \\nlevels of log messages from which parts of the system are route\", \"d to different sinks. When considering \\nhow to migrate an app\\u2019s logging to .NET Core, review how log\", \"ging is performed and configured in the \\napp. \\n\\nASP.NET Core logging \\n\\nIn ASP.NET Core, logging is a\", \" built-in feature that can be configured and extended when the app \\nstarts up. Third-party loggers, \", \"including those mentioned above, can be integrated with ASP.NET Core \\nto enhance its functionality. \", \"\\n\\nASP.NET Core logging uses categories and levels to control what is logged and how. Classes typical\", \"ly \\nuse instances of the ILogger<T> interface, with the class\\u2019s type used as the generic T type. In \", \"this \\nscenario, the class\\u2019s fully qualified name is used as the category. Loggers can also be create\", \"d with a \\ncustom category using an ILoggerFactory. Log levels range from the most detailed, Trace, t\", \"o the most \\nimportant, Critical. Using configuration, apps can specify what minimum level of logging\", \" should be \\nincluded on a per-category (with wildcards) basis. \\n\\nA typical logging configuration cou\", \"ld log Information and above information by default, but only \\nWarning or above from Microsoft-prefi\", \"xed categories: \\n\\n{ \\n  \\\"Logging\\\": { \\n    \\\"LogLevel\\\": { \\n      \\\"Default\\\": \\\"Information\\\", \\n      \\\"Micr\", \"osoft\\\": \\\"Warning\\\" \\n    } \\n  } \\n} \\n\\nSupport for logging in ASP.NET Core is extensive and flexible. Fo\", \"r more detailed information, refer to \\nthe docs. \\n\\n25 \\n\\nCHAPTER 2 | Architectural differences betwee\", \"n ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fMigrate logging \\n\\nHow you migrate your .NET Framework app\\u2019s lo\", \"gging to .NET Core depends on how the app is \\nlogging now. If it\\u2019s using a third-party NuGet package\", \", refer to the upgrade documentation for that \\npackage. Most likely the upgrade path will be fairly \", \"straightforward. If you\\u2019re using your own logging \\nsolution, take one of the following actions: \\n\\n1.\", \"  Migrate the logging solution yourself \\n\\n2.  Migrate to a third-party logging solution \\n\\n3.  Use th\", \"e built-in logging support in ASP.NET Core \\n\\nYou can reference the Microsoft.Extensions.Logging pack\", \"age from .NET Framework apps as long as \\nthey\\u2019re using NuGet 4.3 or later and are on .NET Framework \", \"4.6.1 or later. Once your app has \\nreferenced this package, you can convert your logging statements \", \"to use the new extensions before \\nmigrating the app to .NET Core. This can provide a stepping stone \", \"toward full migration, since the app \\ncan continue running on .NET Framework while logging using the\", \" newer extensions package. \\n\\nReferences \\n\\n\\u2022 \\n\\nLogging in .NET Core and ASP.NET Core \\n\\n\\u2022  Microsoft.E\", \"xtensions.Logging NuGet Package \\n\\nCompare Razor Pages to ASP.NET MVC \\n\\nRazor Pages is the preferred \", \"way to create page- or form-based apps in ASP.NET Core. From the docs, \\n\\u201cRazor Pages can make coding\", \" page-focused scenarios easier and more productive than using \\ncontrollers and views.\\u201d If your ASP.N\", \"ET MVC app makes heavy use of views, you may want to consider \\nmigrating from actions and views to R\", \"azor Pages. \\n\\nA typical strongly typed view-based MVC app will use a controller to contain one or mo\", \"re actions. The \\ncontroller will interact with the domain or data model, and create an instance of a\", \" viewmodel class. \\nThen this viewmodel class is passed to the view associated with that action. Usin\", \"g this approach, \\ncoupled with the default folder structure of MVC apps, to add a new page to an app\", \" requires \\nmodifying a controller in one folder, a view in a nested subfolder in another folder, and\", \" a viewmodel \\nin yet another folder. \\n\\nRazor Pages group together the action (now a handler) and the\", \" viewmodel (called a PageModel) in \\none class, and link this class to the view (called a Razor Page)\", \". All Razor Pages go into a Pages folder in \\nthe root of the ASP.NET Core project. Razor Pages use a\", \" routing convention based on their name and \\nlocation within this folder. Handlers behave exactly li\", \"ke action methods but have the HTTP verb they \\nhandle in their name (for example, OnGet). They also \", \"don\\u2019t necessarily need to return, since by default \\nthey\\u2019re assumed to return the page they\\u2019re assoc\", \"iated with. This tends to keep Razor Pages and their \\nhandlers smaller and more focused while at the\", \" same time making it easier to find and work with all of \\nthe files needed to add or modify a partic\", \"ular part of an app. \\n\\nAs part of a move from ASP.NET MVC to ASP.NET Core, teams should consider whe\", \"ther they want to \\nmigrate controllers and views to ASP.NET Core controllers and views, or to Razor \", \"Pages. The former \\n\\n26 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core \", \"\\n\\n \\n \\n\\fwill most likely require slightly less overall effort, but won\\u2019t allow the team to take advan\", \"tage of the \\nbenefits of Razor Pages over traditional view-based file organization. \\n\\nReferences \\n\\n\\u2022\", \" \\n\\n\\u2022 \\n\\nIntroduction to Razor Pages in ASP.NET Core \\n\\nSimpler ASP.NET Core Apps with Razor Pages \\n\\nCo\", \"mpare ASP.NET Web API 2 and ASP.NET Core \\n\\nASP.NET Core offers iterative improvements to ASP.NET Web\", \" API 2, but should feel familiar to \\ndevelopers who have used Web API 2. ASP.NET Web API 2 was devel\", \"oped and shipped alongside \\nASP.NET MVC. This meant the two approaches had similar-but-different app\", \"roaches to things like \\nattribute routing and dependency injection. In ASP.NET Core, there\\u2019s no long\", \"er any distinction \\nbetween MVC and Web APIs. There\\u2019s only ASP.NET Core, which includes support for \", \"view-based \\nscenarios, API endpoints, Razor Pages, health checks, SignalR, and more. \\n\\nIn addition t\", \"o being consistent and unified within ASP.NET Core, APIs built in .NET Core are much \\neasier to test\", \" than those built on ASP.NET Web API 2. We\\u2019ll cover testing differences in more detail in \\na moment.\", \" The built-in support for hosting ASP.NET Core apps, in a test host that can create an \\nHttpClient t\", \"hat makes in-memory requests to the app, is a huge benefit when it comes to automated \\ntesting. \\n\\nSe\", \"e Incremental ASP.NET to ASP.NET Core migration for an incremental approach to migrating to \\nASP.NET\", \" Core. \\n\\nReferences \\n\\n\\u2022  Migrate from ASP.NET Web API to ASP.NET Core \\n\\n\\u2022 \\n\\nArdalis.ApiEndpoints NuG\", \"et package \\n\\nCompare authentication and authorization between \\nASP.NET MVC and ASP.NET Core \\n\\nIn ASP\", \".NET MVC 5, authentication is configured in Startup.Auth.cs in the App_Start folder. In ASP.NET \\nCor\", \"e MVC, this configuration occurs in Startup.cs or Program.cs, as part of configuring the app\\u2019s \\nserv\", \"ices and middleware. \\n\\nAuthentication and authorization are performed using middleware added to the \", \"request pipeline: \\n\\napp.UseRouting(); \\n\\napp.UseAuthentication(); \\napp.UseAuthorization(); \\n\\napp.UseE\", \"ndpoints(endpoints => \\n{ \\n\\n27 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET MVC and ASP.NE\", \"T Core \\n\\n \\n \\n \\n \\n\\f    endpoints.MapControllerRoute( \\n        name: \\\"default\\\", \\n        pattern: \\\"{co\", \"ntroller=Home}/{action=Index}/{id?}\\\"); \\n    endpoints.MapRazorPages(); \\n}); \\n\\nIt\\u2019s important to add \", \"the auth middleware in the appropriate order in the middleware pipeline. Only \\nrequests that make it\", \" to the middleware will be impacted by it. For instance, if a call to UseStaticFiles() \\nwere placed \", \"above the code shown here, it wouldn\\u2019t be protected by authentication and \\nauthorization. \\n\\nIn ASP.N\", \"ET MVC and Web API, apps often refer to the current user using the ClaimsPrincipal.Current \\nproperty\", \". This property isn\\u2019t set in ASP.NET Core, and any behavior in your app that depends on it will \\nnee\", \"d to migrate from ClaimsPrincipal.Current by using the User property on ControllerBase or getting \\na\", \"ccess to the current HttpContext and referencing its User property. If neither of these solutions is\", \" an \\noption, services can request the User as an argument, in which case it must be supplied from \\ne\", \"lsewhere in the app, or the IHttpContextAccessor can be requested and used to get the HttpContext. \\n\", \"\\nAuthorization \\n\\nAuthorization defines what a given user can do within the app. It\\u2019s separate from a\", \"uthentication, \\nwhich is concerned merely with identifying who the user is. ASP.NET Core provides a \", \"simple, \\ndeclarative role and a rich, policy-based model for authorization. Specifying that a resour\", \"ce requires \\nauthorization is often as simple as adding the [Authorize] attribute to the action or c\", \"ontroller. If you\\u2019re \\nmigrating to Razor Pages from MVC views, you should specify conventions for au\", \"thorization when \\nyou configure Razor Pages. \\n\\nAuthorization in ASP.NET Core may be as simple as pro\", \"hibiting anonymous users while allowing \\nauthenticated users. Or it can scale up to support role-bas\", \"ed, claims-based, or policy-based \\nauthorization approaches. For more information on these approache\", \"s, see the documentation on \\nauthorization in ASP.NET Core. You\\u2019ll likely find that one of them is c\", \"losely aligned with your current \\nauthorization approach. \\n\\nReferences \\n\\n\\u2022 \\n\\nSecurity, Authenticatio\", \"n, and Authorization with ASP.NET MVC \\n\\n\\u2022  Migrate Authentication and Identity to ASP.NET Core \\n\\n\\u2022  \", \"Migrate from ClaimsPrincipal.Current \\n\\n\\u2022 \\n\\nIntroduction to Authorization in ASP.NET Core \\n\\nCompare A\", \"SP.NET Identity and ASP.NET Core \\nIdentity \\n\\nIn ASP.NET MVC, identity features are typically configu\", \"red in IdentityConfig.cs in the App_Start folder. \\nReview how this is configured in the existing app\", \", and compare it to the configuration required for \\nASP.NET Core Identity in Program.cs. \\n\\n28 \\n\\nCHAP\", \"TER 2 | Architectural differences between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fASP.NET Identity is an\", \" API that supports user interface login functionality and manages users, \\npasswords, profile data, r\", \"oles, claims, tokens, email confirmations, and more. It supports external login \\nproviders like Face\", \"book, Google, Microsoft, and Twitter. \\n\\nIf your ASP.NET MVC app is using ASP.NET Membership, you\\u2019ll \", \"find a guide to migrate from ASP.NET \\nMembership authentication to ASP.NET Core 2.0 Identity. This i\", \"s mainly a data migration exercise, at \\nthe completion of which you should be able to use ASP.NET Co\", \"re Identity with your migrated user \\nrecords. \\n\\nIf you migrate your ASP.NET Identity users to ASP.NE\", \"T Core Identity, you may need to update their \\npassword hashes, or track which passwords are hashed \", \"with the new ASP.NET Core Identity approach \\nor the older ASP.NET Identity approach. This approach d\", \"escribed on Stack Overflow provides some \\noptions for migrating user password hashes over time, rath\", \"er than all at once. \\n\\nOne of the biggest differences when it comes to ASP.NET Core Identity compare\", \"d to ASP.NET Identity \\nis how little code you need to include in your project. ASP.NET Core Identity\", \" now ships as a Razor \\nClass Library, meaning its UI and logic are all available from a NuGet packag\", \"e. You can override the \\nexisting UI and logic by scaffolding the ASP.NET Core Identity files but ev\", \"en in this case you need only \\nscaffold the pages you want to modify, not every one that exists. \\n\\nM\", \"igrate from OWIN / Katana \\n\\nThe following resources offer some guidance for migrating from OWIN / Ka\", \"tana: \\n\\n\\u2022  Migration \\n\\n\\u2022 \\n\\nKatana to ASPNET 5 \\n\\nReferences \\n\\n\\u2022  Migrate Authentication and Identity \", \"to ASP.NET Core \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nIntroduction to Identity on ASP.NET Core \\n\\nConfigure ASP.NET Core Iden\", \"tity \\n\\nScaffold Identity in ASP.NET Core projects \\n\\nCompare controllers in ASP.NET MVC and Web API \\n\", \"with controllers in ASP.NET Core \\n\\nIn ASP.NET MVC 5 and Web API 2, there were two different Controll\", \"er base types. MVC controllers \\ninherited from Controller; Web API controllers inherited from ApiCon\", \"troller. In ASP.NET Core, this \\nobject hierarchy has been merged. It\\u2019s recommended that API controll\", \"ers in ASP.NET Core inherit \\nfrom ControllerBase and add the [ApiController] attribute. Standard vie\", \"w-based MVC controllers \\nshould inherit from Controller. \\n\\nIn both frameworks, controllers are used \", \"to organize sets of action methods. Filters and routes can be \\napplied on a controller level in addi\", \"tion to at the action level. These conventions can be extended \\nfurther by using custom base Control\", \"ler types with default behavior and attributes applied to them. \\n\\n29 \\n\\nCHAPTER 2 | Architectural dif\", \"ferences between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fIn ASP.NET MVC, content negotiation isn\\u2019t suppo\", \"rted. ASP.NET Web API 2 does support content \\nnegotiation, as does ASP.NET Core. Using content negot\", \"iation, the format of the content returned to a \\nrequest can be determined by headers the client pro\", \"vides indicating its preferred manner of receiving \\nthe content. \\n\\nWhen migrating ASP.NET Web API co\", \"ntrollers to ASP.NET Core, a few components need to be \\nchanged if they exist. These include referen\", \"ces to the ApiController base class, the System.Web.Http \\nnamespace, and the IHttpActionResult inter\", \"face. Refer to the documentation for recommendations on \\nhow to migrate these specific differences. \", \"Note that the preferred return type for API actions in \\nASP.NET Core is ActionResult<T>. \\n\\nIn additi\", \"on, the [ChildActionOnly] attribute isn\\u2019t supported in ASP.NET Core. In ASP.NET Core, similar \\nfunct\", \"ionality is achieved using View Components. \\n\\nASP.NET Core includes two new attributes: ConsumesAttr\", \"ibute and ProducesAttribute. These are used \\nto specify the type an action consumes or produces, whi\", \"ch can be helpful for routing and \\ndocumenting the API using tools like Swagger/OpenAPI. \\n\\nReference\", \"s \\n\\n\\u2022 \\n\\nFormat response data in ASP.NET Core Web API \\n\\n\\u2022  Migrate from ASP.NET Web API to ASP.NET Co\", \"re \\n\\nCompare Razor usage in ASP.NET MVC and \\nASP.NET Core \\n\\nThe basic syntax of Razor hasn\\u2019t changed\", \" substantially between ASP.NET MVC and ASP.NET Core. \\nHowever, there are certain differences, such a\", \"s the introduction of Tag Helpers and Razor Pages, that \\nshould be considered when migrating. If you\", \"r app makes heavy use of custom Razor functionality, \\nrefer to the Razor syntax reference for ASP.NE\", \"T Core to see what changes may be required when you \\nmigrate to ASP.NET Core. \\n\\nTag Helpers \\n\\nTag He\", \"lpers enable server-side code to participate in creating and rendering HTML elements in Razor \\nfiles\", \". They offer many advantages over HTML Helpers and should be used in place of HTML Helpers \\nwherever\", \" possible. They provide an HTML-friendly development experience, since they look like \\nstandard HTML\", \" and are ignored by most tooling designed to edit HTML. Within Visual Studio, there\\u2019s \\nrich IntelliS\", \"ense support for creating HTML and Razor markup with Tag Helpers. Tag Helpers can \\nprovide simple or\", \" complex behavior from declarative markup in Razor files. \\n\\nRazor Pages \\n\\nRazor Pages offer an alter\", \"native to controllers, actions, and views for page- and form-based apps. \\nRazor Pages were compared \", \"to ASP.NET MVC earlier in this chapter. \\n\\n30 \\n\\nCHAPTER 2 | Architectural differences between ASP.NET\", \" MVC and ASP.NET Core \\n\\n \\n \\n\\fReferences \\n\\n\\u2022  Migrate from ASP.NET MVC to ASP.NET Core MVC: Controlle\", \"rs and Views \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nTag Helpers in ASP.NET Core \\n\\nIntroduction to Razor Pages in ASP.NET Core\", \" \\n\\nRazor syntax reference for ASP.NET Core \\n\\nCompare ASP.NET SignalR and ASP.NET Core \\nSignalR \\n\\nASP\", \".NET Core SignalR is incompatible with clients or servers using ASP.NET SignalR. You\\u2019ll need to \\nupd\", \"ate both clients and server to use ASP.NET Core SignalR. Some differences are described in this \\nsec\", \"tion, while the full list is available in the docs. ASP.NET Core SignalR requires .NET Core 2.1 or \\n\", \"greater. \\n\\nFeature differences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nASP.NET SignalR automatical\", \"ly attempts to reconnect dropped connections; this behavior is \\nopt-in for ASP.NET Core SignalR clie\", \"nts. \\n\\nBoth frameworks support JSON; ASP.NET Core SignalR also supports a binary protocol based \\non \", \"MessagePack, and custom protocols can be created. \\n\\nThe Forever Frame transport, supported by ASP.NE\", \"T SignalR, isn\\u2019t supported in ASP.NET Core \\nSignalR. \\n\\nASP.NET Core SignalR must be configured by ad\", \"ding services.AddSignalR() and \\napp.UseEndpoints in Program.cs. \\n\\nASP.NET Core SignalR requires stic\", \"ky sessions; ASP.NET SignalR doesn\\u2019t. \\n\\nASP.NET Core simplifies the connection model; connections ar\", \"e only made to a single hub. \\n\\nASP.NET Core SignalR supports streaming data from the hub to the clie\", \"nt. \\n\\nASP.NET Core SignalR doesn\\u2019t support passing state between clients and the hub (but method \\nca\", \"lls still allow passing information between hubs and clients). \\n\\nThe PersistentConnection class does\", \"n\\u2019t exist in ASP.NET Core SignalR. \\n\\nASP.NET SignalR supports SQL Server and Redis. ASP.NET Core Sig\", \"nalR supports Azure \\nSignalR and Redis. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDifferences between ASP.NET SignalR a\", \"nd ASP.NET Core SignalR \\n\\nAzure SignalR Service \\n\\n31 \\n\\nCHAPTER 2 | Architectural differences between\", \" ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fCompare testing options between ASP.NET MVC \\nand ASP.NET Core \\n\", \"\\nASP.NET MVC apps support unit testing of controllers, but this approach often omits many MVC \\nfeatu\", \"res like routing, authorization, model binding, model validation, filters, and more. To test these \\n\", \"MVC features in addition to the logic within the controller action itself, frequently the app would \", \"need \\nto be deployed and then tested with a tool like Selenium. These tests are substantially more \\n\", \"expensive, more brittle, and slower than typical unit tests that can be run without the need for hos\", \"ting \\nand running the entire app. \\n\\nASP.NET Core controllers can be unit tested just like ASP.NET MV\", \"C controllers, but with the same \\nlimitations. However, ASP.NET Core supports fast, easy-to-author i\", \"ntegration tests as well. Integration \\ntests are hosted by a TestHost class and are typically config\", \"ured in a custom WebApplicationFactory \\nthat can override or replace app dependencies. For instance,\", \" frequently during integration tests the \\napp will target a different data source and may replace se\", \"rvices that send emails with fake or mock \\nimplementations. \\n\\nASP.NET MVC and Web API did not suppor\", \"t anything like the integration testing scenarios available in \\nASP.NET Core. In any migration effor\", \"t, you should allocate time to write some integration tests for \\nyour newly migrated system to ensur\", \"e it\\u2019s working as expected and continues to do so. Even if you \\nweren\\u2019t writing tests of your web ap\", \"p logic before the migration, you should strongly consider doing \\nso as you move to ASP.NET Core. \\n\\n\", \"References \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nCreating Unit Tests for ASP.NET MVC Applications \\n\\nUnit test controller log\", \"ic in ASP.NET Core \\n\\nIntegration tests in ASP.NET Core \\n\\n32 \\n\\nCHAPTER 2 | Architectural differences \", \"between ASP.NET MVC and ASP.NET Core \\n\\n \\n \\n\\fCHAPTER  3 \\n\\nMigrate large solutions to \\nASP.NET Core \\n\\n\", \"Migrating large solutions from .NET Framework to .NET Core requires some planning. Dependencies \\nmus\", \"t be migrated or updated before the projects that depend on them. There are tools that can \\nidentify\", \" dependencies and offer help with migrating to .NET Core. Depending on the app, its scope, \\nand curr\", \"ent usage patterns, different strategies may be employed when migrating. Do you migrate it \\nall at o\", \"nce, or over time, side-by-side with the current system? Do you wrap the current system in the \\nnew \", \"one, and incrementally replace its functionality? \\n\\nIn this chapter, you\\u2019ll learn how create a migra\", \"tion plan for a large solution, how to use tools to help \\nwith the migration, and some strategies to\", \" consider for the migration itself. \\n\\nReferences \\n\\n\\u2022  What topics are important to migrating large M\", \"VC and Web API apps to .NET Core? \\n\\n\\u2022 \\n\\nPorting from .NET Framework to .NET Core \\n\\nIdentify sequence\", \" of projects to migrate \\n\\nFor solutions that involve multiple front-end apps, it\\u2019s best to migrate t\", \"he apps one by one. For \\nexample, create a solution that only includes one front-end app and its dep\", \"endencies so you can \\neasily identify the scope of work involved. Solutions are lightweight, and you\", \" can include projects in \\nmultiple solutions if needed. Take advantage of solutions as an organizati\", \"onal tool when migrating. \\n\\nOnce you\\u2019ve identified the ASP.NET app to migrate and have its dependent\", \" projects located with it \\n(ideally in a solution), the next step is to identify framework and NuGet\", \" dependencies. Having \\nidentified all dependencies, the simplest migration approach is a \\u201cbottom up\\u201d\", \" approach. With this \\napproach, the lowest level of dependencies is migrated first. Then the next le\", \"vel of dependencies is \\nmigrated, until eventually the only thing left is the front-end app. Figure \", \"3-1 shows an example set of \\nprojects composing an app. The low-level class libraries are at the bot\", \"tom, and the ASP.NET MVC \\nproject is at the top. \\n\\n33 \\n\\nCHAPTER 3 | Migrate large solutions to ASP.N\", \"ET Core \\n\\n \\n \\n\\fFigure 3-1. Project dependencies graph. \\n\\nChoose a particular front-end app, an ASP.N\", \"ET MVC 5 / Web API 2 project. Identify its dependencies \\nin the solution, and map out their dependen\", \"cies until you have a complete list. A diagram like the one \\nshown in Figure 3-1 may be useful when \", \"mapping out project dependencies. Visual Studio can \\nproduce a dependency diagram for your solution,\", \" depending on which edition you\\u2019re using. The .NET \\nPortability Analyzer can also produce dependency\", \" diagrams. \\n\\nFigure 3-2 shows the installer for the .NET Portability Analyzer Visual Studio extensio\", \"n: \\n\\n34 \\n\\nCHAPTER 3 | Migrate large solutions to ASP.NET Core \\n\\n \\n \\n \\n\\fFigure 3-2. .NET Portability \", \"Analyzer installer. \\n\\nThe extension currently supports Visual Studio 2017 and 2019. Visual Studio 20\", \"22 support is planned. \\n\\nOnce installed, you configure it from the Analyze > Portability Analyzer Se\", \"ttings menu, as shown in \\nFigure 3-3. \\n\\n35 \\n\\nCHAPTER 3 | Migrate large solutions to ASP.NET Core \\n\\n \", \"\\n \\n \\n\\fFigure 3-3. Configure the .NET Portability Analyzer. \\n\\nThe analyzer produces a detailed report\", \" for each assembly. The report: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDescribes how compatible each project is with a given targ\", \"et framework, such as .NET 7 or \\n.NET Standard 2.0. \\n\\nHelps teams assess the effort required to port\", \" a particular project to a particular target \\nframework. \\n\\nThe details of this analysis are covered \", \"in the next section. \\n\\nOnce you\\u2019ve mapped out the projects and their relationships with one another,\", \" you\\u2019re ready to \\ndetermine the order in which you\\u2019ll migrate the projects. Begin with projects that\", \" have no \\ndependencies. Then, work your way up the tree to the projects that depend on these project\", \"s. \\n\\nIn the example shown in Figure 3-1, you would start with the Contoso.Utils project, since it do\", \"esn\\u2019t \\ndepend on any other projects. Next, Contoso.Data since it only depends on \\u201cUtils\\u201d. Then migra\", \"te the \\n\\u201cBusinessLogic\\u201d library, and finally the front-end ASP.NET \\u201cWeb\\u201d project. Following this \\u201cbo\", \"ttom up\\u201d \\napproach works well for relatively small and well-factored apps that can be migrated as a \", \"unit once all \\nof their projects have migrated. Larger apps with more complexity, or more code that \", \"will take longer \\nto migrate, may need to consider more incremental strategies. \\n\\n36 \\n\\nCHAPTER 3 | M\", \"igrate large solutions to ASP.NET Core \\n\\n \\n \\n \\n\\fUnit tests \\n\\nMissing from the previous diagrams are \", \"unit test projects. Hopefully there are tests covering at least \\nsome of the existing behavior of th\", \"e libraries being ported. \\n\\nIf you have unit tests, it\\u2019s best to convert those projects first. You\\u2019l\", \"l want to continue testing changes \\nin the project you\\u2019re working on. Remember that porting to .NET \", \"Core is a significant change to your \\ncodebase. \\n\\nMSTest, xUnit, and NUnit all work on .NET Core. If\", \" you don\\u2019t currently have tests for your app, \\nconsider building some characterization tests that ve\", \"rify the system\\u2019s current behavior. The benefit is \\nthat once the migration is complete, you can con\", \"firm the app\\u2019s behavior remains unchanged. \\n\\nConsiderations for migrating many apps \\n\\nSome organizat\", \"ions will have many different apps to migrate, and migrating each one by hand may \\nrequire too many \", \"resources to be tenable. In these situations, some degree of automation is \\nrecommended. The steps f\", \"ollowed in this chapter can be automated. Structural changes, like project \\nfile differences and upd\", \"ates to common packages, can be applied by scripts. These scripts can be \\nrefined as they\\u2019re run ite\", \"ratively on more projects. On each run, examine whatever manual steps are \\nrequired for each project\", \". Automate those manual steps, if possible. Using this approach, the \\norganization should grow faste\", \"r and better at porting their apps over time, with improved automation \\nsupport each step of the way\", \". \\n\\nWatch an overview of how to employ this approach in this dotNetConf presentation by Lizzy \\nGalla\", \"gher of Mastercard. The five phases employed in this presentation included: \\n\\n\\u2022  Migrate third-party\", \" NuGet dependencies \\n\\n\\u2022  Migrate apps to use new .csproj file format \\n\\n\\u2022 \\n\\nUpdate internal NuGet dep\", \"endencies to .NET Standard \\n\\n\\u2022  Migrate apps to ASP.NET Core (targeting .NET Framework) \\n\\n\\u2022 \\n\\nUpdate\", \" all apps to target .NET 7 \\n\\nWhen automating a large suite of apps, it helps significantly if they f\", \"ollow consistent coding \\nguidelines and project organization. Automation efforts rely on this consis\", \"tency to be effective. In \\naddition to parsing and migrating project files, common code patterns can\", \" be migrated automatically. \\nSome code pattern examples include differences in how controller action\", \"s are declared or how they \\nreturn results. \\n\\nFor example, a migration script could search files mat\", \"ching Controller.cs for lines of code matching \\none of these patterns: \\n\\n   return new HttpStatusCod\", \"eResult(200); \\n   // or \\n   return new HttpStatusCodeResult(HttpStatusCode.OK); \\n\\nIn ASP.NET Core, e\", \"ither of the preceding lines of code can be replaced with: \\n\\n    return Ok(); \\n\\n37 \\n\\nCHAPTER 3 | Mig\", \"rate large solutions to ASP.NET Core \\n\\n \\n \\n\\fSummary \\n\\nThe best approach to porting a large .NET Fram\", \"ework app to .NET Core is to: \\n\\n1. \\n\\n2. \\n\\n3. \\n\\nIdentify project dependencies. \\n\\nAnalyze what\\u2019s requi\", \"red to port each project. \\n\\nStart from the bottom up. \\n\\nYou can use the .NET Portability Analyzer to\", \" determine how compatible existing libraries may be with \\ntarget platforms. Automated tests will hel\", \"p ensure no breaking changes are introduced as the app is \\nported. These test projects should be amo\", \"ng the first projects ported. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nPorting from .NET Framework to .NET Core \\n\\n\", \"The .NET Portability Analyzer \\n\\n2 Years, 200 Apps: A .NET Core Migration at Scale (Video) \\n\\nUndersta\", \"nd and update dependencies \\n\\nAfter identifying the sequence in which the app\\u2019s individual projects m\", \"ust be migrated, the next step \\nis to understand each project\\u2019s dependencies and update them if nece\", \"ssary. For platform \\ndependencies, the best way to start is to run the .NET Portability Analyzer on \", \"the assembly in \\nquestion, and then look at the detailed results that are generated. You configure t\", \"he tool to specify \\none or more target platforms, such as .NET 7 or .NET Standard 2.0. Results are p\", \"rovided with details \\nfor each platform targeted. Figure 3-4 shows an example of the tool\\u2019s output. \", \"\\n\\nFigure 3-4. .NET Portability Analyzer report details. \\n\\nUpdate class library dependencies \\n\\nLarge \", \"apps typically involve multiple projects, and most projects other than the ASP.NET MVC web \\nproject \", \"are likely to be class libraries. Class libraries tend to be the easiest to port between .NET \\n\\n38 \\n\", \"\\nCHAPTER 3 | Migrate large solutions to ASP.NET Core \\n\\n \\n \\n \\n\\fplatforms, especially compared to ASP.\", \"NET projects, which are among the most difficult (and typically \\nneed to be re-created). \\n\\nTeams can\", \" consider the try-convert tool or the .NET Upgrade Assistant tool for migrating class \\nlibraries to \", \".NET Core. These tools analyze a .NET Framework project file and attempt to migrate it to \\nthe .NET \", \"Core project file format, making any modifications it can safely perform in the process. The \\ntools \", \"may require some manual assistance to work with ASP.NET projects, but can usually help speed \\nup the\", \" process of migrating class libraries. \\n\\nThe try-convert and Upgrade Assistant tools are deployed as\", \" .NET Core command line tools. They only \\nrun on Windows, since they\\u2019re designed to work with .NET F\", \"ramework apps. You can install try-\\nconvert by running the following command from a command prompt: \", \"\\n\\ndotnet tool install -g try-convert \\n\\nOnce you\\u2019ve successfully installed the tool, you can run try-\", \"convert in the folder where the class \\nlibrary\\u2019s project file is located. \\n\\nInstall the .NET Upgrade\", \" Assistant with the following command (after installing try-convert): \\n\\ndotnet tool install -g upgra\", \"de-assistant \\n\\nRun the tool with the command upgrade-assistant upgrade <project> in the folder where\", \" the project \\nfile is located. \\n\\nUpdate NuGet package dependencies \\n\\nAnalyze your use of third-party\", \" NuGet packages and determine if any of them don\\u2019t yet support .NET \\nStandard (or do support it but \", \"only with a new version). It can be helpful to update NuGet packages \\nto use <PackageReference> synt\", \"ax using Visual Studio\\u2019s converter tool, so that top-level \\ndependencies are visible. Next, check wh\", \"ether the current or later versions of these packages support \\n.NET Core or .NET Standard. This info\", \"rmation can be found on [nuget.org] or within Visual Studio for \\neach package. \\n\\nIf support exists u\", \"sing the version of the package the app currently uses, great! If not, see if a more \\nrecent version\", \" of the package has the support and research what would be involved in upgrading. \\nThere may be brea\", \"king changes in the package, especially if the major version of the package changes \\nbetween your cu\", \"rrently used version and the one to which you\\u2019re upgrading. \\n\\nIn some cases, no version of a given p\", \"ackage works with .NET Core. In that case, teams have a couple \\noptions. They can continue depending\", \" on the .NET Framework version, but this has limitations. The \\napp may only run on Windows, and the \", \"team may want to run Portability Analyzer on the package\\u2019s \\nbinaries to see if there are any issues \", \"likely to be encountered. Certainly the team will want to test \\nthoroughly, since if .NET Framework \", \"packages are used that reference APIs not available in .NET Core, \\na runtime exception will occur. T\", \"he other option is to find a different package or, if the required \\npackage is open source, upgrade \", \"it to .NET Standard or .NET Core themselves. \\n\\n39 \\n\\nCHAPTER 3 | Migrate large solutions to ASP.NET C\", \"ore \\n\\n \\n \\n\\fMigrate ASP.NET MVC projects \\n\\nThe System.Web namespace and types don\\u2019t exist in .NET Cor\", \"e. When you\\u2019re analyzing dependencies \\nand using tools like try-convert, you\\u2019ll find they don\\u2019t offe\", \"r many suggestions for automatic migration \\nof ASP.NET MVC projects and any code in them that refere\", \"nces System.Web. For these projects, you\\u2019ll \\nneed to start with a new ASP.NET Core web project and m\", \"anually migrate files to this project. \\n\\nIn general, it\\u2019s a good practice to minimize how much of an\", \" app\\u2019s business logic lives in its user \\ninterface layer. It\\u2019s also best to keep controllers and vie\", \"ws small. Apps that have followed this \\nguidance will be easier to port than those that have a signi\", \"ficant amount of their logic in the ASP.NET \\nweb project. If you have an app you\\u2019re considering port\", \"ing, but haven\\u2019t begun the process yet, keep \\nthis in mind as you maintain it. Any effort you put to\", \"ward minimizing how much code is in the \\nASP.NET MVC or Web API project will likely result in less w\", \"ork when the time comes to port the app. \\n\\nThe next chapter digs into details of how to migrate from\", \" ASP.NET MVC and Web API projects to \\nASP.NET Core projects. The previous chapter called out the big\", \"gest differences between the apps. \\nOnce the basic project structure is in place, migrating individu\", \"al controllers and views is usually \\nstraightforward, especially if they\\u2019re mainly focused on web re\", \"sponsibilities. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n.NET Upgrade Assistant tool \\n\\ntry-convert tool \\n\\napiport \", \"tool \\n\\nStrategies for migrating while running in production \\n\\nMany teams have .NET Framework apps th\", \"ey plan to migrate to .NET Core/.NET 7, but the app is so \\nlarge that the migration requires a signi\", \"ficant amount of time to complete. The original app needs to \\nlive on while the migration is done pi\", \"ece by piece. There needs to be a way for the old and new \\nversions of the app to work together side\", \"-by-side, or for the old version to be migrated in-place, at \\nleast some of the way, without breakin\", \"g it. Teams can employ many different strategies to support \\nthese goals. \\n\\nRefactor the .NET Framew\", \"ork solution \\n\\nA good place to start if you plan to port a .NET Framework app to .NET Core is to ref\", \"actor it to work \\nbetter with .NET Core. This means updating individual class libraries to target .N\", \"ET Standard and \\nmoving as much logic out of your ASP.NET MVC projects and into these class librarie\", \"s. Any code you \\nhave in .NET Standard libraries is immediately usable from both .NET Framework to .\", \"NET Core apps, \\nwhich is why this step is so valuable as part of a migration. \\n\\nWhen refactoring, ma\", \"ke sure you\\u2019re following good refactoring fundamentals. For example, create \\ntests that verify what \", \"the system does before you start refactoring. Run these tests when you\\u2019re done \\nto confirm you didn\\u2019\", \"t change the system\\u2019s behavior. You may need to add characterization tests to the \\nsystem if you don\", \"\\u2019t already have a good suite of automated tests you can rely on. \\n\\n40 \\n\\nCHAPTER 3 | Migrate large so\", \"lutions to ASP.NET Core \\n\\n \\n \\n\\fExtract front-end assets to a CDN \\n\\nIf your .NET Framework apps inclu\", \"de a lot of static assets, like scripts, CSS files, or images, you may be \\nable to migrate these to \", \"a separate CDN. Then, update the existing app to reference the CDN links for \\nthese assets. When you\", \" port the app to .NET Core, these static files won\\u2019t be part of the migration, \\nand you\\u2019ll just cont\", \"inue referencing them from the CDN in the ASP.NET Core app. \\n\\nExtract and migrate individual microse\", \"rvices \\n\\nLarge .NET Framework apps may already be comprised of separate front-end systems that can b\", \"e \\nmigrated individually. Or they may be candidates for migration to a microservices architecture, w\", \"ith \\nsome pieces of existing ASP.NET MVC apps being pulled out into new ASP.NET Core microservice \\ni\", \"mplementations. You can learn more about microservices in the associated ebook, .NET \\nMicroservices:\", \" Architecture for Containerized .NET Applications. \\n\\nFor example, the existing app might have a set \", \"of features it uses related to user sign-in and \\nregistration. These could be migrated to a separate\", \" microservice, which could be built and deployed \\nusing ASP.NET Core and then integrated into the le\", \"gacy .NET Framework app. Next, the app might \\nhave a few pages dedicated to tracking the individual \", \"user\\u2019s shopping cart. These pages could also be \\npulled out into their own separate microservice and\", \" again integrated into the existing app. In this way, \\nthe original .NET Framework app continues run\", \"ning in production, but with more and more of its \\nfeatures coming from modernized .NET Core microse\", \"rvices. \\n\\nDeploy multiple versions of the app side-by-side in IIS \\n\\nUsing a combination of host head\", \"ers and redirects, an existing ASP.NET MVC app can be configured \\nto run side by side with an ASP.NE\", \"T Core app on the same IIS server. As pieces of functionality, such \\nas individual controllers, are \", \"ported to ASP.NET Core, their routes and URLs are mapped within IIS to \\ntarget the ASP.NET Core web \", \"site or sub-application (IIS virtual directories aren\\u2019t supported with \\nASP.NET Core apps). An ASP.N\", \"ET Core app can be hosted as an IIS sub-application (sub-app). The \\nsub-app\\u2019s path becomes part of t\", \"he root app\\u2019s URL. \\n\\nApply the Strangler pattern \\n\\nLarge ASP.NET MVC apps can be gradually replaced \", \"with a new ASP.NET Core app by incrementally \\nmigrating pieces of functionality. One approach to thi\", \"s is called the strangler pattern, named for \\nstrangler vines that strangle and eventually tear down\", \" trees. This approach relies on first \\nimplementing a facade layer over top of the existing solution\", \". This facade should be built using the \\nnew approach to the problem, or an off-the-shelf solution s\", \"uch as an API gateway. \\n\\nOnce the facade is in place, you can route part of it to a new ASP.NET Core\", \" app. As you port more of \\nthe original .NET Framework app to .NET Core, you continue to update the \", \"facade layer accordingly, \\nsending more of the facade\\u2019s total functionality to the new system. Figur\", \"e 3-5 shows the strangler \\npattern progression over time. \\n\\n41 \\n\\nCHAPTER 3 | Migrate large solutions\", \" to ASP.NET Core \\n\\n \\n \\n\\fFigure 3-5. The Strangler pattern over time. \\n\\nEventually, the entire facade\", \" layer corresponds to the new, modern implementation. At this point, \\nboth the legacy system and the\", \" face layer can be retired. Microsoft has guidance on how to achieve \\nincremental ASP.NET to ASP.NET\", \" Core migration using the YARP reverse proxy. \\n\\nMulti-targeting approaches \\n\\nMulti-targeting is reco\", \"mmended for large apps that will be migrated over time and for teams \\napplying the Strangler pattern\", \" approach. This approach can address BindingRedirect and package \\nrestoration challenges that surfac\", \"e from mixing PackageReference and packages.config restore styles. \\nThere are two options available \", \"for code that must run in both .NET Framework and .NET Core \\nenvironments. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nPreprocessor di\", \"rectives (#if in C# or #If in Visual Basic) allow you to implement different \\nfunctionality or use d\", \"ifferent dependencies when run in .NET Framework versus .NET Core. \\n\\nProject files can use condition\", \"al globbing patterns, such as *.core.cs, to include different sets \\nof files based on which framewor\", \"k is being targeted. \\n\\nTypically you only follow these recommendations for class libraries. These te\", \"chniques allow a single \\ncommon codebase to be maintained while new functionality is added and featu\", \"res of the app are \\nincrementally ported to use .NET Core. \\n\\nSummary \\n\\nFrequently, large ASP.NET MVC\", \" and Web API apps won\\u2019t be ported to ASP.NET Core all at once, but \\nwill migrate incrementally over \", \"time. This section offers several strategies for performing this \\nincremental migration. Choose the \", \"one(s) that will work best for your organization and app. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n42 \\n\\n.N\", \"ET Microservices: Architecture for Containerized .NET Applications \\n\\neShopOnContainers Reference Mic\", \"roservices Application \\n\\nHost ASP.NET Core on Windows with IIS \\n\\nStrangler pattern \\n\\nIncremental ASP\", \".NET to ASP.NET Core Migration \\n\\nCHAPTER 3 | Migrate large solutions to ASP.NET Core \\n\\n \\n \\n \\n\\fCHAPTE\", \"R  4 \\n\\nExample migration of \\neShop to ASP.NET Core \\n\\nIn this chapter, you\\u2019ll see how to migrate a .N\", \"ET Framework app to .NET Core. The chapter examines a \\nsample online store app written for ASP.NET M\", \"VC 5. The app will use many of the concepts and tools \\ndescribed earlier in this book. You\\u2019ll find t\", \"he starting point app in the eShopModernizing GitHub \\nrepository. There are several different starti\", \"ng point apps. This chapter focuses on the \\neShopLegacyMVCSolution. \\n\\nThe initial version of the pro\", \"ject is shown in Figure 4-1. It\\u2019s a fairly standard ASP.NET MVC 5 app. \\n\\nFigure 4-1. The eShopModern\", \"izing MVC sample project structure. \\n\\n43 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n\", \" \\n \\n \\n\\fThis chapter demonstrates how to perform many of the upgrade steps by hand. Alternatively, yo\", \"u can \\nuse the .NET Upgrade Assistant tool to perform many of the initial steps, like converting the\", \" project \\nfile, changing the target framework, and updating NuGet packages. \\n\\nRun ApiPort to identif\", \"y problematic APIs \\n\\nThe first step in preparing to migrate is to run the ApiPort tool. The tool ide\", \"ntifies how many .NET \\nFramework APIs the app calls and how many of these have .NET Standard or .NET\", \" Core equivalents. \\nFocus primarily on your own app\\u2019s logic, not third-party dependencies, and pay a\", \"ttention to \\nSystem.Web dependencies that will need to be ported. The ApiPort tool was introduced in\", \" the last \\nchapter on understanding and updating dependencies. Note that currently it requires Visua\", \"l Studio \\n2019; Visual Studio 2022 support is planned. \\n\\nAfter installing and configuring the ApiPor\", \"t tool, run the analysis from within Visual Studio, as shown \\nin Figure 4-2. \\n\\n44 \\n\\nCHAPTER 4 | Exam\", \"ple migration of eShop to ASP.NET Core \\n\\n \\n \\n\\fFigure 4-2. Analyze assembly portability in Visual Stu\", \"dio. \\n\\nChoose the web project\\u2019s assembly from the project\\u2019s bin folder, as shown in Figure 4-3. \\n\\n45\", \" \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\fFigure 4-3. Choose the project\\u2019s \", \"web assembly. \\n\\nIf your solution includes several projects, you can choose all of them. The eShop sa\", \"mple includes just a \\nsingle MVC project. \\n\\nOnce the report is generated, open the file and review t\", \"he results. The summary provides a high-level \\nview of what percentage of .NET Framework calls your \", \"app is making have compatible versions. Figure \\n4-4 shows the summary for the eShop MVC project. \\n\\nF\", \"igure 4-4. ApiPort summary. \\n\\nFor this app, about 80 percent of the .NET Framework calls are compati\", \"ble. 20 percent of the calls \\nneed to be addressed during the porting process. Viewing the details r\", \"eveals that all of the \\nincompatible calls are part of System.Web, which is an expected incompatibil\", \"ity. The dependencies on \\nSystem.Web calls will be addressed when the app\\u2019s controllers and related \", \"classes are migrated in a \\nlater step. Figure 4-5 lists some of the specific types found by the tool\", \": \\n\\n46 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n\\fFigure 4-5. ApiPort incom\", \"patible type details. \\n\\nMost of the incompatible types refer to Controller and various related attri\", \"butes that have equivalents \\nin ASP.NET Core. \\n\\nUpdate project files and NuGet reference syntax \\n\\nNe\", \"xt, migrate from the older .csproj file structure to the newer, simpler structure introduced with .N\", \"ET \\nCore. In doing so, you\\u2019ll also migrate from using a packages.config file for NuGet references to\", \" using \\n<PackageReference> elements in the project file. Old-style project files may also use \\n<Pack\", \"ageReference> elements, so it usually makes sense to migrate all NuGet package references to \\nthis f\", \"ormat first, before upgrading to the new project file format. \\n\\nThe original project\\u2019s eShopLegacyMV\", \"C.csproj file is 418 lines long. A sample of the project file is \\nshown in Figure 4-6. To offer a se\", \"nse of its overall size and complexity, the right side of the image \\ncontains a miniature view of th\", \"e entire file. \\n\\n47 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\fFigure 4-6. Th\", \"e eShopLegacyMVC.csproj file structure. \\n\\nA common way to create a new project file for an existing \", \"ASP.NET project is to create a new ASP.NET \\nCore app using dotnet new or File > New > Project in Vis\", \"ual Studio. Then files can be copied from \\nthe old project to the new one to complete the migration.\", \" \\n\\nIn addition to the C# project file, NuGet dependencies are stored in a separate 45-line packages.\", \"config \\nfile, as shown in Figure 4-7. \\n\\n48 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \", \"\\n\\n \\n \\n \\n\\fFigure 4-7. The packages.config file. \\n\\nYou can migrate packages.config in class library pr\", \"ojects using Visual Studio. This functionality doesn\\u2019t \\nwork with ASP.NET projects, however. Learn m\", \"ore about migrating packages.config to \\n<PackageReference> in Visual Studio. If you have a large num\", \"ber of projects to migrate, this \\ncommunity tool may help. If you\\u2019re using a tool to migrate the pro\", \"ject file to the new format, you \\nshould do that after you\\u2019ve finished migrating all NuGet reference\", \"s to use <PackageReference>. \\n\\nCreate new ASP.NET Core project \\n\\nAdd a new ASP.NET Core project to t\", \"he existing app\\u2019s solution to make moving files easier, as most of \\nthe work can be done from within\", \" Visual Studio\\u2019s Solution Explorer. In Visual Studio, right-click on \\nyour app\\u2019s solution and choose\", \" Add New Project. Choose ASP.NET Core web application, and give \\nthe new project a name as shown in \", \"Figure 4-8. \\n\\n49 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\fFigure 4-8. Add n\", \"ew ASP.NET Core web application. \\n\\nThe next dialog will ask you to choose which template to use. Sel\", \"ect the Empty template. Be sure to \\nalso change the dropdown from .NET Core to .NET Framework. Selec\", \"t ASP.NET Core 2.2, as shown \\nin Figure 4-9. \\n\\n50 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NE\", \"T Core \\n\\n \\n \\n \\n\\fFigure 4-9. Choose an Empty project template targeting .NET Framework with ASP.NET C\", \"ore 2.2. \\n\\nMigrating NuGet Packages \\n\\nSince the built-in migration tool for migrating packages.confi\", \"g to <PackageReference> doesn\\u2019t work \\non ASP.NET projects, you can use a community tool instead, or \", \"migrate by hand. A community tool \\nI\\u2019ve used uses an XSL file to transform from one format to the ot\", \"her. To use it, first copy the \\npackages.config file to the newly created ASP.NET Core project folde\", \"r. Make a backup of your files, as \\nthis script removes the packages.config file from all folders un\", \"der where you run the script. Then run \\nthese commands from the project folder (or for the entire so\", \"lution if you prefer): \\n\\niwr \\nhttps://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7c9\", \"218bf9c/raw/7789\\n53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.ps1 -OutFile Conver\", \"t-\\nToPackageReference.ps1 \\niwr \\nhttps://gist.githubusercontent.com/aienabled/0bce5e4b17118122f2772e7\", \"c9218bf9c/raw/7789\\n53f89882877a7124894b47dccfb1ba3e80a0/Convert-ToPackageReference.xsl -OutFile  Con\", \"vert-\\nToPackageReference.xsl \\n./Convert-ToPackageReference.ps1 | Out-Null \\n\\nThe first two commands d\", \"ownload files so that they exist locally. The last line runs the script. After \\nrunning it, try to b\", \"uild the new project. You\\u2019ll most likely get some errors. To resolve them, you\\u2019ll want \\nto eliminate\", \" some references (like most of the Microsoft.AspNet and System packages), and you may \\nneed to remov\", \"e some xmlns attributes. \\n\\n51 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\fIn m\", \"ost ASP.NET MVC apps, many client-side dependencies like Bootstrap and jQuery were deployed \\nusing N\", \"uGet packages. In ASP.NET Core, NuGet packages are only used for server-side functionality. \\nClient \", \"files should be managed through other means. Review the list of <PackageReference> \\nelements added a\", \"nd remove and make note of any that are for client libraries, including: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nBootstrap \\n\\nj\", \"Query \\n\\njQuery.Validation \\n\\n\\u2022  Modernizr \\n\\n\\u2022 \\n\\n\\u2022 \\n\\npopper.js \\n\\nRespond \\n\\nThe static client files ins\", \"talled by NuGet for these packages will be copied over to the new project\\u2019s \\nwwwroot folder and host\", \"ed from there. It\\u2019s worth considering whether these files are still needed by \\nthe app, and whether \", \"it makes sense to continue hosting them or to use a content delivery network \\n(CDN) instead. These l\", \"ibrary versions can be managed at build time using tools like LibMan or npm. \\nFigure 4-10 shows the \", \"full eShopPorted.csproj file after migrating package references using the \\nconversion tool shown and\", \" removing unnecessary packages. \\n\\nFigure 4-10. Package references in the eShopPorted.csproj file. \\n\\n\", \"The package references can be further compacted by making the <Version>1.0.0.0</Version> \\nelement a \", \"Version=1.0.0.0 attribute on <PackageReference>. \\n\\n52 \\n\\nCHAPTER 4 | Example migration of eShop to AS\", \"P.NET Core \\n\\n \\n \\n \\n\\fMigrate static files \\n\\nAny static files the app uses, including third-party scri\", \"pts and frameworks but also custom images and \\nstylesheets, must be copied from the old project to t\", \"he new one. In ASP.NET MVC apps, files were \\ntypically accessed based on their location within the p\", \"roject folder. In ASP.NET Core apps, these static \\nfiles will be accessed based on their location wi\", \"thin the wwwroot folder. For the eShop project, there \\nare static files in the following folders: \\n\\n\", \"\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nContent \\n\\nfonts \\n\\nImages \\n\\nPics \\n\\nScripts \\n\\nThe Empty project template used in t\", \"he previous step doesn\\u2019t include this folder by default, or the \\nmiddleware needed for it to work. Y\", \"ou\\u2019ll need to add them. \\n\\nAdd a wwwroot folder to the root of the project. \\n\\nAdd version 2.2.0 of th\", \"e Microsoft.AspNetCore.StaticFiles NuGet package. \\n\\nIn Startup.cs, add a call to app.UseStaticFiles(\", \") in the Configure method: \\n\\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\", \" \\n{ \\n    if (env.IsDevelopment()) \\n    { \\n        app.UseDeveloperExceptionPage(); \\n    } \\n\\n    app.\", \"UseStaticFiles(); \\n\\n    // ... \\n} \\n\\nCopy the Content folder from the ASP.NET MVC app to the new proj\", \"ect\\u2019s wwwroot folder. \\n\\nRun the app and navigate to its /Content/base.css folder to verify that the \", \"static file is served correctly \\nfrom its expected path. Continue copying the rest of the folders co\", \"ntaining static files to the new \\nproject. You\\u2019ll also want to copy the favicon.ico file from the pr\", \"oject\\u2019s root to the wwwroot folder. \\nFigure 4-11 shows the results after these files and their folde\", \"rs have all been copied. \\n\\n53 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n\\fFi\", \"gure 4-11. Static folders copied over to wwwroot folder. \\n\\nMigrate C# files \\n\\nNext, copy over the C#\", \" files used by the app, including standard MVC folders and their contents like \\nControllers, Models,\", \" ViewModel, and Services. There will most likely be some changes needed in these \\nfiles. It\\u2019s best t\", \"o copy one folder (or subfolder) at a time and compile to see what errors need to be \\naddressed as y\", \"ou go. \\n\\nFor the eShop sample, the first folder I choose to migrate is the Models folder, which incl\", \"udes C# \\nentities and Entity Framework classes. This folder\\u2019s classes are used by most of the others\", \", so they \\nwon\\u2019t work until these classes have been copied. After copying the folder and building, t\", \"he compiler \\nrevealed errors related to missing namespace System.Web.Hosting, related access to \\nHos\", \"tingEnvironment, and a reference to ConfigurationManager.AppSettings. The solution to these \\nissues \", \"will be to pass in the necessary path data; for now the breaking lines are commented out and a \\nTODO\", \": comment is added to each one to track it. After changing five lines, the Task List shows five \\nite\", \"ms and the project builds. \\n\\nNext, the ViewModel folder, with its one class, is copied over. It\\u2019s an\", \" easy one, and builds immediately. \\n\\nThe Services folder is copied over. This folder\\u2019s classes depen\", \"d on Entity Framework classes from the \\nModels folder, which is why it needed to be copied after tha\", \"t folder. Fortunately, it too builds without \\nerrors. \\n\\n54 \\n\\nCHAPTER 4 | Example migration of eShop \", \"to ASP.NET Core \\n\\n \\n \\n \\n\\fThat leaves the Controllers folder and its two Controller classes. After co\", \"pying the folder to the new \\nproject and building, there are seven build errors. Four of them are re\", \"lated to ViewBag access and \\nreport an error of: \\n\\nMissing compiler required member 'Microsoft.CShar\", \"p.RuntimeBinder.CSharpArgumentInfo.Create' \\n\\nTo resolve this error, add a NuGet package reference to\", \" C#: \\n\\n<PackageReference Include=\\\"Microsoft.CSharp\\\" Version=\\\"4.7.0\\\" /> \\n\\nThe remaining three errors \", \"specify types that are defined in an assembly that isn\\u2019t referenced. \\nSpecifically these types: \\n\\n\\u2022 \", \"\\n\\n\\u2022 \\n\\n\\u2022 \\n\\nHttpServerUtilityBase \\n\\nRouteValueDictionary \\n\\nHttpRequestBase \\n\\nLet\\u2019s look at each error \", \"one by one. The first error occurs while trying to reference the Server property \\nof Controller, whi\", \"ch no longer exists. The goal of the operation is to get the path to an image file in \\nthe app: \\n\\nif\", \" (item != null) \\n{ \\n    var webRoot = Server.MapPath(\\\"~/Pics\\\"); // compiler error on this line \\n    \", \"var path = Path.Combine(webRoot, item.PictureFileName); \\n\\n    string imageFileExtension = Path.GetEx\", \"tension(item.PictureFileName); \\n    string mimetype = GetImageMimeTypeFromImageFileExtension(imageFi\", \"leExtension); \\n\\n    var buffer = System.IO.File.ReadAllBytes(path); \\n\\n    return File(buffer, mimety\", \"pe); \\n} \\n\\nThere are two possible solutions to this problem. The first is to keep the functionality a\", \"s it is. In this \\ncase, rather than using Server.MapPath, a fixed path referencing the image files\\u2019 \", \"location in wwwroot \\nshould be used. Alternately, since the only purpose of this action method is to\", \" return a static image \\nfile, the references to this action in view files can be updated to referenc\", \"e the static files directly, which \\nimproves runtime performance. Since no processing is being done \", \"as part of this action, there\\u2019s no \\nreason not to just serve the files directly. If it\\u2019s not tenable\", \" to update all references to this action, the \\naction could be rewritten to produce a redirect to th\", \"e static file\\u2019s location. \\n\\nThe next two errors both occur in the same private method in the same li\", \"ne of code: \\n\\nprivate void AddUriPlaceHolder(CatalogItem item) \\n{ \\n    item.PictureUri = this.Url.Ro\", \"uteUrl(PicController.GetPicRouteName, new { catalogItemId \\n= item.Id }, this.Request.Url.Scheme); \\n}\", \" \\n\\nBoth this.Url and this.Request cause compiler errors. Looking at how this code is used, its purpo\", \"se is \\nto build a link to the PicController action that renders image files. The same one we just di\", \"scovered \\ncould probably be replaced with direct links to the static files located in wwwroot. For n\", \"ow, it\\u2019s worth \\ncommenting out this code and adding a TODO: comment to reference the pics another wa\", \"y. \\n\\n55 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n \\n\\fIt\\u2019s worth noting that\", \" the base Controller class, used by the CatalogController class in which this code \\nappears, is stil\", \"l referring to System.Web.Mvc.Controller. There will undoubtedly be more errors to fix \\nonce we upda\", \"te this to use ASP.NET Core. First, remove the using System.Web.Mvc; line from the list \\nof using st\", \"atements in CatalogController. Next, add the NuGet package Microsoft.AspNetCore.Mvc. \\nFinally, add a\", \" using Microsoft.AspNetCore.Mvc; statement, and build the app again. \\n\\nThis time, there are 16 error\", \"s: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nInclude is not a valid named attribute argument (2) \\n\\nHttpStatusCodeResult not \", \"found (3) \\n\\nHttpNotFound does not exist (3) \\n\\nSelectList not found (8) \\n\\nOnce more, let\\u2019s review the\", \"se errors one by one. First, SelectList can be fixed by adding using \\nMicrosoft.AspNetCore.Mvc.Rende\", \"ring;, which eliminates half of the errors. \\n\\nAll references to return HttpNotFound(); should be rep\", \"laced with return NotFound();. \\n\\nAll references to return new HttpStatusCodeResult(HttpStatusCode.Ba\", \"dRequest); should be replaced \\nwith return BadRequest();. \\n\\nThat just leaves the use of Include with\", \" a [Bind] attribute on a couple of action methods that look like \\nthis: \\n\\n[HttpPost] \\n[ValidateAntiF\", \"orgeryToken] \\npublic ActionResult Create([Bind(Include = \\n\\\"Id,Name,Description,Price,PictureFileName\", \",CatalogTypeId,CatalogBrandId,AvailableStock,Rest\\nockThreshold,MaxStockThreshold,OnReorder\\\")] Catalo\", \"gItem catalogItem) \\n{ \\n\\nThe preceding code restricts model binding to the properties listed in the I\", \"nclude string. In ASP.NET \\nCore MVC, the [Bind] attribute still exists, but no longer needs the Incl\", \"ude = argument. Pass the list of \\nproperties directly to the [Bind] attribute: \\n\\n[HttpPost] \\n[Valida\", \"teAntiForgeryToken] \\npublic ActionResult \\nCreate([Bind(\\\"Id,Name,Description,Price,PictureFileName,Ca\", \"talogTypeId,CatalogBrandId,Availa\\nbleStock,RestockThreshold,MaxStockThreshold,OnReorder\\\")] CatalogIt\", \"em catalogItem) \\n{ \\n\\nWith these changes, the project compiles once more. It\\u2019s generally a better pra\", \"ctice to use separate \\nmodel types for controller inputs, rather than using model binding directly t\", \"o your domain model or \\ndata model types. \\n\\nMigrate views \\n\\nThe two biggest ASP.NET Core MVC feature\", \"s related to views are Razor Pages and Tag Helpers. For \\nthe initial migration, we won\\u2019t use either \", \"feature. You should, however, keep the features in mind if \\nyou continue supporting the app once it\\u2019\", \"s been migrated. The next step is to copy the Views folder \\nfrom the original project into the new o\", \"ne. After building, there are nine errors: \\n\\n56 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET \", \"Core \\n\\n \\n \\n\\f\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nHttpContext does not exist (2) \\n\\nScripts does not exist (5) \\n\\nStyles doe\", \"s not exist (1) \\n\\nHtmlString could not be found(1) \\n\\nInvestigating these errors finds that most of t\", \"hem are in the main *_Layout.cshtml, with several related \\nto rendering script and style tags, or di\", \"splaying when the server hosting the app was last restarted. The \\nfollowing code listing shows probl\", \"em areas in the _Layout.cshtml* file: \\n\\n// other lines omitted; only errors shown \\n@Styles.Render(\\\"~\", \"/Content/css\\\") \\n@Scripts.Render(\\\"~/bundles/modernizr\\\") \\n\\n@{ var sessionInfo = new HtmlString($\\\"{Http\", \"Context.Current.Session[\\\"MachineName\\\"]}, \\n{HttpContext.Current.Session[\\\"SessionStartTime\\\"]}\\\");} \\n\\n@S\", \"cripts.Render(\\\"~/bundles/jquery\\\") \\n@Scripts.Render(\\\"~/bundles/bootstrap\\\") \\n\\nThe reference to Moderni\", \"zr can be removed. The references to Bootstrap and jQuery can be replaced \\nwith CDN links to the app\", \"ropriate version. \\n\\nReplace @Styles.Render line with: \\n\\n<link rel=\\\"stylesheet\\\" \\nhref=\\\"https://stackp\", \"ath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\\\" \\nintegrity=\\\"sha384-ggOyR0iXCbMQv3Xipma34\", \"MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\\\" \\ncrossorigin=\\\"anonymous\\\"> \\n\\nReplace the last two Script\", \"s.Render lines with: \\n\\n<script src=\\\"https://code.jquery.com/jquery-3.3.1.slim.min.js\\\" integrity=\\\"sha\", \"384-\\nq8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\\\" \\ncrossorigin=\\\"anonymous\\\"></sc\", \"ript> \\n<script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\\\" \\ninte\", \"grity=\\\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\\\" \\ncrossorigin=\\\"anonym\", \"ous\\\"></script> \\n<script src=\\\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\\\"\", \" \\nintegrity=\\\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\\\" \\ncrossorigin=\\\"\", \"anonymous\\\"></script> \\n\\nFinally, after the Bootstrap <link>, add additional <link> elements for local\", \" styles your app uses. For \\neShop, the result is shown here: \\n\\n<link rel=\\\"stylesheet\\\" href=\\\"~/Conten\", \"t/custom.css\\\" /> \\n<link rel=\\\"stylesheet\\\" href=\\\"~/Content/base.css\\\" /> \\n<link rel=\\\"stylesheet\\\" href=\\\"\", \"~/Content/Site.css\\\" /> \\n\\nTo determine the order in which the <link> elements should appear, look at \", \"your original app\\u2019s \\nrendered HTML. Alternatively, review BundleConfig.cs, which for the eShop sampl\", \"e includes this code \\nindicating the appropriate sequence: \\n\\nbundles.Add(new StyleBundle(\\\"~/Content/\", \"css\\\").Include( \\n          \\\"~/Content/bootstrap.css\\\", \\n          \\\"~/Content/custom.css\\\", \\n\\n57 \\n\\nCHAPT\", \"ER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n\\f          \\\"~/Content/base.css\\\", \\n      \", \"    \\\"~/Content/site.css\\\")); \\n\\nBuilding again reveals one more error loading jQuery Validation on the\", \" Create and Edit views. Replace \\nit with this script: \\n\\n<script src=\\\"https://cdnjs.cloudflare.com/aj\", \"ax/libs/jquery-\\nvalidate/1.17.0/jquery.validate.min.js\\\" integrity=\\\"sha512-\\nO/nUTF5mdFkhEoQHFn9N5wmgY\", \"yW323JO6v8kr6ltSRKriZyTr/8417taVWeabVS4iONGk2V444QD0P2cwhuTkg==\\\" \\ncrossorigin=\\\"anonymous\\\"></script> \", \"\\n\\nThe last thing to fix in the views is the reference to Session to display how long the app has bee\", \"n \\nrunning, and on which machine. We can display this data directly in the site\\u2019s *_Layout.cshtml* b\", \"y \\nusing System.Environment.MachineName and \\nSystem.Diagnostics.Process.GetCurrentProcess().StartTim\", \"e: \\n\\n<section class=\\\"col-sm-6\\\"> \\n    <img class=\\\"esh-app-footer-text hidden-xs\\\" src=\\\"~/images/main_f\", \"ooter_text.png\\\" \\nwidth=\\\"335\\\" height=\\\"26\\\" alt=\\\"footer text image\\\" /> \\n    <br /> \\n<small>@Environment\", \".MachineName - \\n@System.Diagnostics.Process.GetCurrentProcess().StartTime.ToString() UTC</small> \\n</\", \"section> \\n\\nAt this point, the app once more builds successfully. However, trying to run it just yiel\", \"ds Hello World! \\nbecause the Empty ASP.NET Core template is only configured to display that in respo\", \"nse to any \\nrequest. In the next section, I complete the migration by configuring the app to use ASP\", \".NET Core \\nMVC, including dependency injection and configuration. Once that\\u2019s in place, the app shou\", \"ld run. \\nThen it will be time to fix the TODO: tasks that were created earlier. \\n\\nMigrate app startu\", \"p components \\n\\nThe last migration step is to take the app startup tasks from Global.asax, and the cl\", \"asses it calls, and \\nmigrate these to their ASP.NET Core equivalents. These tasks include configurat\", \"ion of MVC itself, \\nsetting up dependency injection, and working with the new configuration system. \", \"In ASP.NET Core, \\nthese tasks are handled in the Startup.cs file. \\n\\nConfigure MVC \\n\\nThe original ASP\", \".NET MVC app has the following code in its Application_Start in Global.asax, which \\nruns when the ap\", \"p starts up: \\n\\nprotected void Application_Start() \\n{ \\n    container = RegisterContainer(); \\n    Area\", \"Registration.RegisterAllAreas(); \\n    FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); \\n  \", \"  RouteConfig.RegisterRoutes(RouteTable.Routes); \\n    BundleConfig.RegisterBundles(BundleTable.Bundl\", \"es); \\n    ConfigDataBase(); \\n} \\n\\n58 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n\\f\", \"Looking at these lines one by one, the RegisterContainer method sets up dependency injection, which \", \"\\nwill be ported below. The next three lines configure different parts of MVC: areas, filters, and ro\", \"utes. \\nBundles are replaced by static files in the ported app. The last line sets up data access for\", \" the app, \\nwhich will be shown in a later section. \\n\\nSince this app isn\\u2019t actually using areas, ther\", \"e\\u2019s nothing that needs to be done to migrate the area \\nregistration call. If your app does need to m\", \"igrate areas, the docs specify how to configure areas in \\nASP.NET Core. \\n\\nThe call to register globa\", \"l filters invokes a helper on the FilterConfig class in the app\\u2019s App_Start \\nfolder: \\n\\npublic static\", \" void RegisterGlobalFilters(GlobalFilterCollection filters) \\n{ \\n    filters.Add(new HandleErrorAttri\", \"bute()); \\n} \\n\\nThe only attribute added to the app is the ASP.NET MVC filter, HandleErrorAttribute. T\", \"his filter ensures \\nthat when an exception occurs as part of a request, a default action and view ar\", \"e displayed, rather \\nthan the exception details. In ASP.NET Core, this same functionality is perform\", \"ed by the \\nUseExceptionHandler middleware. The detailed error messages aren\\u2019t enabled by default. Th\", \"ey must \\nbe configured using the UseDeveloperExceptionPage middleware. To configure this behavior to\", \" match \\nthe original app, the following code must be added to the start of the Configure method in S\", \"tartup.cs: \\n\\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) \\n{ \\n    if (env\", \".IsDevelopment()) \\n    { \\n        app.UseDeveloperExceptionPage(); \\n    } \\n    else \\n    { \\n        \", \"app.UseExceptionHandler(\\\"/Error\\\"); \\n    } \\n    // ... \\n} \\n\\nThis takes care of the only filter used b\", \"y the eShop app, and in this case it was done by using built-in \\nmiddleware. If you have global filt\", \"ers that must be configured in your app, this is done when MVC is \\nadded in Program.cs when you conf\", \"igure services, which is shown later in this chapter. \\n\\nThe last piece of MVC-related logic that nee\", \"ds to be migrated are the app\\u2019s default routes. The call to \\nRouteConfig.RegisterRoutes(RouteTable.R\", \"outes) passes the MVC route table to the RegisterRoutes \\nhelper method, where the following code is \", \"executed when the app starts up: \\n\\npublic static void RegisterRoutes(RouteCollection routes) \\n{ \\n   \", \" routes.MapMvcAttributeRoutes(); \\n    routes.IgnoreRoute(\\\"{resource}.axd/{*pathInfo}\\\"); \\n\\n    routes\", \".MapRoute( \\n        name: \\\"Default\\\", \\n        url: \\\"{controller}/{action}/{id}\\\", \\n        defaults: \", \"new { controller = \\\"Catalog\\\", action = \\\"Index\\\", id = \\nUrlParameter.Optional } \\n\\n59 \\n\\nCHAPTER 4 | Exa\", \"mple migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\f    ); \\n} \\n\\nTaking this code line-by-line, the firs\", \"t line sets up support for attribute routes. This is built into \\nASP.NET Core, so it\\u2019s unnecessary t\", \"o configure it separately. Likewise, {resource}.axd files aren\\u2019t used \\nwith ASP.NET Core, so there\\u2019s\", \" no need to ignore such routes. The MapRoute method configures the \\ndefault for MVC, which uses the \", \"typical {controller}/{action}/{id} route template. It also specifies the \\ndefaults for this template\", \", such that the CatalogController is the default controller used and the Index \\nmethod is the defaul\", \"t action. Larger apps will frequently include more calls to MapRoute to set up \\nadditional routes. \\n\", \"\\nASP.NET Core MVC supports conventional routing and attribute routing. Conventional routing is \\nanal\", \"ogous to how the route table is configured in the RegisterRoutes method listed previously. To set \\nu\", \"p conventional routing with a default route like the one used in the eShop app, add the following \\nc\", \"ode to the bottom of the Configure method in Startup.cs: \\n\\napp.UseMvc(routes => \\n{ \\n   routes.MapRou\", \"te(\\\"default\\\", \\\"{controller=Catalog}/{action=Index}/{id?}\\\"); \\n}); \\n\\nNote \\n\\nWith ASP.NET Core 3.0 and \", \"later, this is changed to use endpoints. For the initial port to ASP.NET Core \\n2.2, this is the prop\", \"er syntax for mapping conventional routes. \\n\\nWith these changes in place, the Configure method is al\", \"most done. The original template\\u2019s app.Run \\nmethod that prints Hello World! should be deleted. At th\", \"is point, the method is as shown here: \\n\\npublic void Configure(IApplicationBuilder app, IHostingEnvi\", \"ronment env) \\n{ \\n    if (env.IsDevelopment()) \\n    { \\n        app.UseDeveloperExceptionPage(); \\n    \", \"} \\n    else \\n    { \\n        app.UseExceptionHandler(\\\"/Home/Error\\\"); \\n    } \\n\\n    app.UseStaticFiles(\", \"); \\n\\n    app.UseMvc(routes => \\n    { \\n        routes.MapRoute(\\\"default\\\", \\\"{controller=Catalog}/{acti\", \"on=Index}/{id?}\\\"); \\n    }); \\n} \\n\\nNow it\\u2019s time to configure MVC services, followed by the rest of th\", \"e app\\u2019s support for dependency \\ninjection (DI). So far, the eShopPorted project\\u2019s Program.cs file ha\", \"sn\\u2019t added any service configuration. \\nNow it\\u2019s time to start adding necessary services. \\n\\nFirst, to\", \" get ASP.NET Core MVC to work properly, it needs to be added: \\n\\n60 \\n\\nCHAPTER 4 | Example migration o\", \"f eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n \\n \\n\\fbuilder.Services.AddMvc(); \\n\\nThe preceding code is the minima\", \"l configuration required to get MVC features working. There are \\nmany additional features that can b\", \"e configured from this call (some of which are detailed later in this \\nchapter), but for now this wi\", \"ll suffice to build the app. Running it now routes the default request \\nproperly, but since we\\u2019ve no\", \"t yet configured DI, an error occurs while activating CatalogController, \\nbecause no implementation \", \"of type ICatalogService has been provided yet. We\\u2019ll return to configure \\nMVC further in a moment. F\", \"or now, let\\u2019s migrate the app\\u2019s dependency injection. \\n\\nMigrate dependency injection configuration \\n\", \"\\nThe original app\\u2019s Global.asax file defines the following method, called when the app starts up: \\n\\n\", \"protected IContainer RegisterContainer() \\n{ \\n  var builder = new ContainerBuilder(); \\n\\n  builder.Reg\", \"isterControllers(typeof(MvcApplication).Assembly); \\n\\n  var mockData = bool.Parse(ConfigurationManage\", \"r.AppSettings[\\\"UseMockData\\\"]); \\n  builder.RegisterModule(new ApplicationModule(mockData)); \\n\\n  var c\", \"ontainer = builder.Build(); \\n  DependencyResolver.SetResolver(new AutofacDependencyResolver(containe\", \"r)); \\n\\n  return container; \\n} \\n\\nThis code configures an Autofac container, reads a config setting to\", \" determine whether real or mock \\ndata should be used, and passes this setting into an Autofac module\", \" (found in the app\\u2019s /Modules \\ndirectory). Fortunately, Autofac supports .NET Core, so the module ca\", \"n be migrated directly. Copy the \\nfolder into the new project and updates the class\\u2019s namespace and \", \"it should compile. \\n\\nASP.NET Core has built-in support for dependency injection, but you can wire up\", \" a third-party \\ncontainer such as Autofac easily if necessary. In this case, since the app is alread\", \"y configured to use \\nAutofac, the simplest solution is to maintain its usage. In Program.cs, simply \", \"configure the builder to \\nuse the AutofacServiceProviderFactory as shown: \\n\\n// using Autofac.Extensi\", \"ons.DependencyInjection \\nbuilder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory())\", \"; \\n// note: the factory calls builder.Populate so we don't need to here \\nbool useMockData = true; //\", \" TODO: read from config \\nbuilder.Host.ConfigureContainer<ContainerBuilder>(builder => \\n    builder.R\", \"egisterModule(new ApplicationModule(useMockData))); \\n\\nFor now, the setting for useMockData is set to\", \" true. This setting will be read from configuration in a \\nmoment. At this point, the app compiles an\", \"d should load successfully when run, as shown in Figure 4-\\n12. \\n\\n61 \\n\\nCHAPTER 4 | Example migration \", \"of eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n \\n \\n\\fFigure 4-12. Ported eShop app running locally with mock data\", \". \\n\\nMigrate app settings \\n\\nASP.NET Core uses a new configuration system, which by default uses an ap\", \"psettings.json file. By using \\nCreateDefaultBuilder in Program.cs, the default configuration is alre\", \"ady set up in the app. To access \\nconfiguration, classes just need to request it in their constructo\", \"r. In Program.cs, configuration is \\naccessible from builder.Configuration. \\n\\nThe original app refere\", \"nced its settings using ConfigurationManager.AppSettings. A quick search for \\nall references of this\", \" term yields the set of settings the new app needs. There are only two: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nUseMockData \\n\\nUseC\", \"ustomizationData \\n\\nIf your app has more complex configuration, especially if it\\u2019s using custom confi\", \"guration sections, \\nyou\\u2019ll probably want to create and bind objects to different parts of your app\\u2019s\", \" configuration. These \\ntypes can then be accessed using the options pattern. However, as noted in th\", \"e referenced doc, this \\npattern shouldn\\u2019t be used in Program.cs (or Startup.ConfigureServices). Inst\", \"ead the ported app will \\nreference the UseMockData configuration value directly. \\n\\nFirst, modify the\", \" ported app\\u2019s appsettings.json file and add the two settings in the root: \\n\\n{ \\n  \\\"Logging\\\": { \\n\\n62 \\n\", \"\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\f    \\\"LogLevel\\\": { \\n      \\\"Default\\\":\", \" \\\"Warning\\\" \\n    } \\n  }, \\n  \\\"AllowedHosts\\\": \\\"*\\\", \\n  \\\"UseMockData\\\": \\\"true\\\", \\n  \\\"UseCustomizationData\\\" \", \":  \\\"true\\\" \\n} \\n\\nNow, modify Program.cs to access the UseMockData setting from the builder.Configurati\", \"on property \\n(where previously we set the value to true): \\n\\nbool useMockData = builder.Configuration\", \".GetValue<bool>(\\\"UseMockData\\\"); \\n\\nAt this point, the setting is pulled from configuration. The other\", \" setting, UseCustomizationData, is \\nused by the CatalogDBInitializer class. When you first ported th\", \"is class, you commented out the access \\nto ConfigurationManager.AppSettings[\\\"UseCustomizationData\\\"].\", \" Now it\\u2019s time to modify it to use \\nASP.NET Core configuration. Modify the constructor of CatalogDBI\", \"nitializer as follows: \\n\\n  // add using Microsoft.Extensions.Configuration \\n  public CatalogDBInitia\", \"lizer(CatalogItemHiLoGenerator indexGenerator, \\n      IConfiguration configuration) \\n  { \\n      this\", \".indexGenerator = indexGenerator; \\n      useCustomizationData = configuration.GetValue<bool>(\\\"UseCus\", \"tomizationData\\\"); \\n  } \\n\\nAll access to configuration within the web app should be modified in this m\", \"anner to use the new \\nIConfiguration type. Dependencies that require access to .NET Framework config\", \"uration can include \\nsuch settings in an app.config file added to the web project. The dependent pro\", \"jects can work with \\nConfigurationManager to access settings, and shouldn\\u2019t require any changes if t\", \"hey already use this \\napproach. However, since ASP.NET Core apps run as their own executable, they d\", \"on\\u2019t reference \\nweb.config but rather app.config. By migrating settings from the legacy app\\u2019s web.co\", \"nfig file to a new \\napp.config file in the ASP.NET Core app, components that use ConfigurationManage\", \"r to access their \\nsettings will continue to function properly. \\n\\nThe app\\u2019s migration is nearly comp\", \"lete. The only remaining task is data access configuration. \\n\\nData access considerations \\n\\nASP.NET C\", \"ore apps running on .NET Framework can continue to use Entity Framework (EF). If \\nperforming an incr\", \"emental migration, getting the app working with EF 6 before trying to port its data \\naccess to use E\", \"F Core may be worthwhile. In this way, any problems with the app\\u2019s migration can be \\nidentified and \", \"addressed before another block of migration effort is begun. \\n\\nAs it happens, configuring EF 6 in th\", \"e eShop sample migration doesn\\u2019t require any special work, since \\nthis work was performed in the Aut\", \"ofac ApplicationModule. The only problem is that currently the \\nCatalogDBContext class tries to read\", \" its connection string from web.config. To address this, the \\nconnection details need to be added to\", \" appsettings.json. Then the connection string must be passed \\ninto CatalogDBContext when it\\u2019s create\", \"d. \\n\\nUpdate the appsettings.json to include the connection string. The full file is listed here: \\n\\n6\", \"3 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n\\f{ \\n  \\\"ConnectionStrings\\\": { \\n    \\\"\", \"DefaultConnection\\\": \\n\\\"Server=(localdb)\\\\\\\\mssqllocaldb;Database=eShopPorted;Trusted_Connection=True;Mu\", \"ltipleActive\\nResultSets=true\\\" \\n  }, \\n  \\\"Logging\\\": { \\n    \\\"LogLevel\\\": { \\n      \\\"Default\\\": \\\"Warning\\\" \\n\", \"    } \\n  }, \\n  \\\"AllowedHosts\\\": \\\"*\\\", \\n  \\\"UseMockData\\\": \\\"false\\\", \\n  \\\"UseCustomizationData\\\": \\\"true\\\" \\n} \", \"\\n\\nThe connection string must be passed into the constructor when the DbContext is created. Since the\", \" \\ninstances are created by Autofac, the change needs to be made in ApplicationModule. Modify the \\nmo\", \"dule to take in a connectionString in its constructor and assign it to a field. Then modify the \\nreg\", \"istration for CatalogDBContext to add connection string as a parameter: \\n\\nbuilder.RegisterType<Catal\", \"ogDBContext>() \\n  .WithParameter(\\\"connectionString\\\", _connectionString) \\n  .InstancePerLifetimeScope\", \"(); \\n\\nThe parameter must also be added to a new constructor overload in CatalogDBContext itself: \\n\\np\", \"ublic CatalogDBContext(string connectionString) : base(connectionString) \\n{ \\n} \\n\\nFinally, Program.cs\", \" must read the connection string from Configuration and pass it into the \\nApplicationModule when it \", \"instantiates it: \\n\\nbool useMockData = Configuration.GetValue<bool>(\\\"UseMockData\\\"); \\nstring connectio\", \"nString = Configuration.GetConnectionString(\\\"DefaultConnection\\\"); \\nbuilder.RegisterModule(new Applic\", \"ationModule(useMockData, connectionString)); \\n\\nWith this code in place, the app runs as it did befor\", \"e, connecting to a SQL Server database when \\nUseMockData is false. \\n\\nThe app can be deployed and run\", \" in production at this point, converted to ASP.NET Core but still \\nrunning on .NET Framework and EF \", \"6. If desired, the app can be migrated to run on .NET Core and \\nEntity Framework Core, which will br\", \"ing additional advantages described in earlier chapters. Specific \\nto Entity Framework, this documen\", \"tation compares EF Core and EF 6 and includes a grid showing \\nwhich library supports each of dozens \", \"of individual features. \\n\\nMigrate to Entity Framework Core \\n\\nAssuming a decision is made to migrate \", \"to EF Core, the steps can be fairly straightforward, especially \\nif the original app used a code-bas\", \"ed model approach. When preparing to port from EF 6 to EF Core, \\nreview the availability of features\", \" in the destination version of EF Core you\\u2019ll be using. Review the \\ndocumentation on porting from an\", \"d EDMX-based model versus porting from a code-based model. \\n\\n64 \\n\\nCHAPTER 4 | Example migration of e\", \"Shop to ASP.NET Core \\n\\n \\n \\n\\fTo upgrade to EF Core 2.2, the basic steps involved are to add the appro\", \"priate NuGet package(s) and \\nupdate namespaces. Then adjust how the connection string is passed to t\", \"he DbContext type and how \\nthey\\u2019re wired up for dependency injection. \\n\\nEF Core is added as a packag\", \"e reference to the project: \\n\\n<PackageReference Include=\\\"Microsoft.EntityFrameworkCore\\\" Version=\\\"2.2\", \".6\\\" /> \\n\\nThe reference to EF 6 is removed: \\n\\n<PackageReference Include=\\\"EntityFramework\\\" Version=\\\"6.\", \"2.0\\\" /> \\n\\nThe compiler will report errors in CatalogDBContext and CatalogDBInitializer. CatalogDbCon\", \"text \\nneeds to have the old namespaces removed and replaced with Microsoft.EntityFrameworkCore. Its \", \"\\nconstructors can be removed. DbModelBuilder should be replaced with ModelBuilder. The helper \\nmetho\", \"ds for configuring types are moved to separate classes implementing \\nIEntityTypeConfiguration<T>. Th\", \"en the CatalogDBContext class\\u2019s OnModelCreating method simply \\nbecomes: \\n\\nprotected override void On\", \"ModelCreating(ModelBuilder builder) \\n{ \\n    builder.ApplyConfigurationsFromAssembly(Assembly.GetExec\", \"utingAssembly()); \\n\\n    base.OnModelCreating(builder); \\n} \\n\\nOther changes involved include: \\n\\n\\u2022 \\n\\n\\u2022 \", \"\\n\\n\\u2022 \\n\\n\\u2022 \\n\\nHasDatabaseGeneratedOption(DatabaseGeneratedOption.None) replaced with \\nValueGeneratedNeve\", \"r() \\n\\nHasRequired<T> replaced with HasOne<T> \\n\\nInstalled Microsoft.EntityFrameworkCore.Relational pa\", \"ckage \\n\\nAdd a constructor to CatalogDBContext taking DbContextOptions and passing it to the base \\nco\", \"nstructor \\n\\nAn example configuration class for CatalogType is shown here: \\n\\nusing Microsoft.EntityFr\", \"ameworkCore; \\nusing Microsoft.EntityFrameworkCore.Metadata.Builders; \\n\\nnamespace eShopPorted.Models.\", \"Config \\n{ \\n    public class CatalogTypeConfig : IEntityTypeConfiguration<CatalogType> \\n    { \\n      \", \"  public void Configure(EntityTypeBuilder<CatalogType> builder) \\n        { \\n            builder.ToTa\", \"ble(nameof(CatalogType)); \\n\\n            builder.HasKey(ci => ci.Id); \\n\\n            builder.Property(\", \"ci => ci.Id) \\n               .IsRequired(); \\n\\n            builder.Property(cb => cb.Type) \\n         \", \"       .IsRequired() \\n                .HasMaxLength(100); \\n\\n65 \\n\\nCHAPTER 4 | Example migration of eS\", \"hop to ASP.NET Core \\n\\n \\n \\n \\n \\n \\n \\n \\n\\f        } \\n    } \\n} \\n\\nThe CatalogDBInitializer and its base cla\", \"ss, CreateDatabaseIfNotExists<T>, are incompatible with EF \\nCore. The purpose of this class is to cr\", \"eate and seed the database. Using EF Core will create and drop \\nthe associated database for a DbCont\", \"ext using these methods: \\n\\ndbContext.Database.EnsureDeleted(); \\ndbContext.Database.EnsureCreated(); \", \"\\n\\nSeeding data in EF Core can be done with manual scripts, or as part of the type configuration. Alo\", \"ng \\nwith other entity properties, seed data can be configured in IEntityTypeConfiguration classes by\", \" using \\nbuilder.HasData(). The original app loaded seed data from CSV files in the Setup directory. \", \"Given that \\nthere are only a handful of items, these data records can instead be added as part of th\", \"e entity \\nconfiguration. This approach works well for lookup data in tables that change infrequently\", \". Adding the \\nfollowing to CatalogTypeConfig\\u2019s Configure method ensures the associated rows are pres\", \"ent when \\nthe database is created: \\n\\nbuilder.HasData( \\n    new CatalogType { Id = 1, Type = \\\"Mug\\\" },\", \" \\n    new CatalogType { Id = 2, Type = \\\"T-Shirt\\\" }, \\n    new CatalogType { Id = 3, Type = \\\"Sheet\\\" },\", \" \\n    new CatalogType { Id = 4, Type = \\\"USB Memory Stick\\\" } \\n); \\n\\nThe initial app includes a Preconf\", \"iguredData class, which includes data for CatalogBrand and \\nCatalogType, so using this method the Ha\", \"sData call reduces to: \\n\\nbuilder.HasData( \\n    PreconfiguredData.GetPreconfiguredCatalogBrands() \\n);\", \" \\n\\nThe CatalogItem data can also be pulled from PreconfiguredData, and assuming the associated \\nimag\", \"es are kept in source control, that is the last table needed for the app to function. The \\nCatalogDB\", \"Initializer class can be removed, along with any references to it. The \\nCatalogItemHiLoGenerator cla\", \"ss and the SQL files in the Infrastructure directory are also removed, \\nalong with any references to\", \" them (in CatalogService, ApplicationModule). \\n\\nWith the elimination of the special key generator cl\", \"asses for CatalogItem, this code now is removed \\nfrom CatalogItemConfig: \\n\\nbuilder.Property(ci => ci\", \".Id) \\n    .ValueGeneratedNever() \\n    .IsRequired(); \\n\\nWith these modifications, the ASP.NET Core ap\", \"p builds, but it doesn\\u2019t yet work with EF Core, which \\nmust still be configured for dependency injec\", \"tion. With EF Core, the simplest way to configure it is in \\nProgram.cs: \\n\\nbuilder.Services.AddMvc();\", \" \\nbool useMockData = builder.Configuration.GetValue<bool>(\\\"UseMockData\\\"); \\nif (!useMockData) \\n{ \\n\\n66\", \" \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n\\f    string connectionString = \\nbuil\", \"der.Configuration.GetConnectionString(\\\"DefaultConnection\\\"); \\n\\n    builder.Services.AddDbContext<Cata\", \"logDBContext>(options => \\n        options.UseSqlServer(connectionString) \\n    ); \\n} \\n\\nThe final vers\", \"ion of Autofac\\u2019s ApplicationModule only configures one type, depending on whether the \\napp is config\", \"ured to use mock data: \\n\\npublic class ApplicationModule : Module \\n{ \\n    private bool _useMockData; \", \"\\n\\n    public ApplicationModule(bool useMockData) \\n    { \\n        _useMockData = useMockData; \\n    } \", \"\\n\\n    protected override void Load(ContainerBuilder builder) \\n    { \\n        if (_useMockData) \\n    \", \"    { \\n            builder.RegisterType<CatalogServiceMock>() \\n                .As<ICatalogService>(\", \") \\n                .SingleInstance(); \\n        } \\n        else \\n        { \\n            builder.Regis\", \"terType<CatalogService>() \\n                .As<ICatalogService>() \\n                .InstancePerLifet\", \"imeScope(); \\n        } \\n    } \\n} \\n\\nThe ported app runs, but doesn\\u2019t display any data if configured t\", \"o use non-mock data. The seed data \\nadded through HasData is only inserted when migrations are appli\", \"ed. The source app didn\\u2019t use \\nmigrations, and if it had, they wouldn\\u2019t migrate as-is. The best appr\", \"oach is to start with a new \\nmigration script. To do this, add a package reference for Microsoft.Ent\", \"ityFrameworkCore.Design and \\nopen a terminal window in the project root. Then run: \\n\\ndotnet ef migra\", \"tions add Initial \\n\\nDrop the existing eShopPorted database if it exists, then run: \\n\\ndotnet ef datab\", \"ase update \\n\\nThis creates and seeds the database. It\\u2019s now ready to run, with a few small updates le\", \"ft to address. \\n\\nFix all TODO tasks \\n\\nRunning the ported app at this point reveals that no pictures \", \"are shown on the page. This is because \\nthe PictureUri property of CatalogItem is never set. Looking\", \" at the list of TODO items we created \\n\\n67 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \", \"\\n\\n \\n \\n \\n \\n \\n\\fusing Visual Studio\\u2019s Task List, the only one that remains is in CatalogController, wit\", \"h a note to \\n\\u201cReference pic from wwwroot.\\u201d The code in question is: \\n\\nprivate void AddUriPlaceHolder\", \"(CatalogItem item) \\n{ \\n    //TODO: Reference pic from wwwroot \\n    //item.PictureUri = this.Url.Rout\", \"eUrl(PicController.GetPicRouteName, new { \\ncatalogItemId = item.Id }, this.Request.Url.Scheme); \\n} \\n\", \"\\nThe simplest fix is to reference the public image files in the site\\u2019s public wwwroot/Pics directory\", \". This \\ntask can be accomplished by replacing the method with the following code: \\n\\nprivate void Add\", \"UriPlaceHolder(CatalogItem item) \\n{ \\n    item.PictureUri = $\\\"/Pics/{item.Id}.png\\\"; \\n} \\n\\nWith this ch\", \"ange, running the app reveals the images work as before. \\n\\nAdditional MVC customizations \\n\\nThe eShop\", \"LegacyMVC app is fairly simple, so there isn\\u2019t much to configure in terms of default MVC \\nbehavior. \", \"However, if you do need to configure additional MVC components, such as CORS, filters, \\nand route co\", \"nstraints, you generally provide this information in Program.cs, where UseMvc is called. \\nFor exampl\", \"e, the following code listing configures CORS and sets up a global action filter: \\n\\nbuilder.Services\", \".AddCors(options => \\n{ \\n    options.AddPolicy(MyAllowSpecificOrigins, \\n        builder => \\n         \", \"   builder.WithOrigins(\\\"http://example.com\\\", \\\"http://www.contoso.com\\\") \\n                .AllowAnyHea\", \"der() \\n                .AllowAnyMethod()); \\n}); \\n\\nbuilder.Services.AddMvc(options => \\n{ \\n    options\", \".Filters.Add(new SampleGlobalActionFilter()); \\n}).SetCompatibilityVersion(CompatibilityVersion.Versi\", \"on_2_2); \\n\\nNote \\n\\nTo finish configuring CORS, you must also call app.UseCors() after building the ap\", \"plication. \\n\\nOther advanced scenarios, like adding custom model binders, formatters, and more are co\", \"vered in the \\ndetailed ASP.NET Core docs. Generally these can be applied on an individual controller\", \" or action basis, \\nor globally using the same options approach shown in the previous code listing. \\n\", \"\\n68 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n \\n\\fOther dependencies \\n\\nDepen\", \"dencies that use .NET Framework features that had a dependency on the legacy configuration \\nmodel, s\", \"uch as the WCF client type and tracing code, must be modified when ported. Rather than \\nhaving these\", \" types pull in their configuration information directly, they should be configured in code. \\nFor exa\", \"mple, a connection to a WCF service that was configured in an ASP.NET app\\u2019s web.config to use \\nbasic\", \"HttpBinding could instead be configured programmatically with the following code: \\n\\nvar binding = ne\", \"w BasicHttpBinding(); \\nbinding.MaxReceivedMessageSize = 2_000_000; \\n\\nvar endpointAddress = new Endpo\", \"intAddress(\\\"http://localhost:9200/ExampleService\\\"); \\n\\nvar myClient = new MyServiceClient(binding, en\", \"dpointAddress); \\n\\nRather than relying on config files for its settings, WCF clients and other .NET F\", \"ramework types should \\nhave their settings specified in code. Configured in this manner, these types\", \" can continue to work in \\nASP.NET Core 2.2 apps. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\neShopModernizing\", \" GitHub repository \\n\\n.NET Upgrade Assistant tool \\n\\nYour API and ViewModels Should Not Reference Doma\", \"in Models \\n\\nDeveloper Exception Page Middleware \\n\\nDeep Dive into EF Core HasData \\n\\nMore migration sc\", \"enarios \\n\\nThis section describes several different ASP.NET app scenarios, and offers specific techni\", \"ques for \\nsolving each of them. You can use this section to identify scenarios applicable to your ap\", \"p, and \\nevaluate which techniques will work for your app and its hosting environment. \\n\\nMigrate ASP.\", \"NET MVC 5 and WebApi 2 to ASP.NET Core MVC \\n\\nA common scenario in ASP.NET MVC 5 and Web API 2 apps w\", \"as for both products to be installed in \\nthe same application. This is a supported and relatively co\", \"mmon approach used by many teams, but \\nbecause the two products use different abstractions, there is\", \" some redundant effort needed. For \\nexample, setting up routes for ASP.NET MVC is done using methods\", \" on RouteCollection, such as \\nMapMvcAttributeRoutes() and MapRoute(). But ASP.NET Web API 2 routing \", \"is managed with \\nHttpConfiguration and methods like MapHttpAttributeRoutes() and MapHttpRoute(). \\n\\nT\", \"he eShopLegacyMVC app includes both ASP.NET MVC and Web API, and includes methods in its \\nApp_Start \", \"folder for setting up routes for both. It also supports dependency injection using Autofac, \\nwhich a\", \"lso requires two sets of similar work to configure: \\n\\n69 \\n\\nCHAPTER 4 | Example migration of eShop to\", \" ASP.NET Core \\n\\n \\n \\n \\n \\n\\fprotected IContainer RegisterContainer() \\n{ \\n    var builder = new Containe\", \"rBuilder(); \\n\\n    var thisAssembly = Assembly.GetExecutingAssembly(); \\n    builder.RegisterControlle\", \"rs(thisAssembly);      // MVC controllers \\n    builder.RegisterApiControllers(thisAssembly);   // We\", \"b API controllers \\n\\n    var mockData = bool.Parse(ConfigurationManager.AppSettings[\\\"UseMockData\\\"]); \", \"\\n    builder.RegisterModule(new ApplicationModule(mockData)); \\n\\n    var container = builder.Build();\", \" \\n\\n    // set mvc resolver \\n    DependencyResolver.SetResolver(new AutofacDependencyResolver(contain\", \"er)); \\n\\n    // set webapi resolver \\n    var resolver = new AutofacWebApiDependencyResolver(container\", \"); \\n    GlobalConfiguration.Configuration.DependencyResolver = resolver; \\n\\n    return container; \\n} \", \"\\n\\nWhen upgrading these apps to use ASP.NET Core, this duplicate effort and the confusion that \\nsomet\", \"imes accompanies it is eliminated. ASP.NET Core MVC is a unified framework with one set of \\nrules fo\", \"r routing, filters, and more. Dependency injection is built into .NET Core itself. All of this can b\", \"e \\nconfigured in Program.cs, as is shown in the eShopPorted app in the sample. \\n\\nMigrate HttpRespons\", \"eMessage to ASP.NET Core \\n\\nSome ASP.NET Web API apps may have action methods that return HttpRespons\", \"eMessage. This type \\ndoes not exist in ASP.NET Core. Below is an example of its usage in a Delete ac\", \"tion method, using the \\nResponseMessage helper method on the base ApiController: \\n\\n// DELETE api/<co\", \"ntroller>/5 \\n[HttpDelete] \\npublic IHttpActionResult Delete(int id) \\n{ \\n    var brandToDelete = _serv\", \"ice.GetCatalogBrands().FirstOrDefault(x => x.Id == id); \\n    if (brandToDelete == null) \\n    { \\n    \", \"    return ResponseMessage(new HttpResponseMessage(HttpStatusCode.NotFound)); \\n    } \\n\\n    // demo o\", \"nly - don't actually delete \\n    return ResponseMessage(new HttpResponseMessage(HttpStatusCode.OK));\", \" \\n} \\n\\nIn ASP.NET Core MVC, there are helper methods available for all of the common HTTP response st\", \"atus \\ncodes, so the above method would be ported to the following code: \\n\\n[HttpDelete(\\\"{id}\\\")] \\npubl\", \"ic IActionResult Delete(int id) \\n{ \\n    var brandToDelete = _service.GetCatalogBrands().FirstOrDefau\", \"lt(x => x.Id == id); \\n    if (brandToDelete == null) \\n    { \\n\\n70 \\n\\nCHAPTER 4 | Example migration of \", \"eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\f        return NotFound(); \\n    } \\n\\n    // demo only - do\", \"n't actually delete \\n    return Ok(); \\n} \\n\\nIf you do find that you need to return a custom status co\", \"de for which no helper exists, you can always \\nuse return StatusCode(int statusCode) to return any n\", \"umeric code you like. \\n\\nMigrate content negotiation from ASP.NET Web API to ASP.NET Core \\n\\nASP.NET W\", \"eb API 2 supports content negotiation natively. The sample app includes a \\nBrandsController that dem\", \"onstrates this support by listing its results in either XML or JSON. This is \\nbased on the request\\u2019s\", \" Accept header, and changes when it includes application/xml or \\napplication/json. \\n\\nASP.NET MVC 5 a\", \"pps do not have content negotiation support built in. \\n\\nContent negotiation is preferable to returni\", \"ng a specific encoding type, as it is more flexible and \\nmakes the API available to a larger number \", \"of clients. If you currently have action methods that return \\na specific format, you should consider\", \" modifying them to return a result type that supports content \\nnegotiation when you port the code to\", \" ASP.NET Core. \\n\\nThe following code returns data in JSON format regardless of client Accept header c\", \"ontent: \\n\\n[HttpGet] \\npublic ActionResult Index() \\n{ \\n    return Json(new { Message = \\\"Hello World!\\\" \", \"}); \\n} \\n\\nASP.NET Core MVC supports content negotiation natively, provided an appropriate return type\", \" is \\nused. Content negotiation is implemented by [ObjectResult] which is returned by the status code\", \"-\\nspecific action results returned by the controller helper methods. The previous action method, \\nim\", \"plemented in ASP.NET Core MVC and using content negotiation, would be: \\n\\npublic IActionResult Index(\", \") \\n{ \\n    return Ok(new { Message = \\\"Hello World!\\\"} ); \\n} \\n\\nThis will default to returning the data \", \"in JSON format. XML and other formats will be used if the app \\nhas been configured with the appropri\", \"ate formatter. \\n\\nCustom model binding \\n\\nMost ASP.NET MVC and Web API apps make use of model binding.\", \" The default model binding syntax \\nmigrates fairly seamlessly between these apps and ASP.NET Core MV\", \"C. However, in some cases \\ncustomers have written custom model binders to support specific model typ\", \"es or usage scenarios. \\nCustom model binders in ASP.NET MVC and Web API projects use separate IModel\", \"Binder interfaces \\ndefined in System.Web.Mvc and System.Web.Http namespaces, respectively. In both c\", \"ases, the custom \\n\\n71 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\fbinder expos\", \"es a Bind method that accepts a controller or action context and a model binding context \\nas argumen\", \"ts. \\n\\nOnce the custom binder is created, it must be registered with the app. This step requires crea\", \"ting \\nanother type, a ModelBinderProvider, which acts as a factory and creates the model binder duri\", \"ng a \\nrequest. Binders can be added during ApplicationStart in MVC apps as shown: \\n\\nModelBinderProvi\", \"ders.BinderProviders.Insert(0, new MyCustomBinderProvider()); // MVC \\n\\nIn Web API apps, custom binde\", \"rs can be referenced using attributes. The ModelBinder attribute can \\nbe added to action method para\", \"meters or to the parameter\\u2019s type definition, as shown: \\n\\n// attribute on action method parameter \\np\", \"ublic HttpResponseMessage([ModelBinder(typeof(MyCustomBinder))] CustomDTO custom) \\n{ \\n} \\n\\n// attribu\", \"te on type \\n[ModelBinder(typeof(MyCustomBinder))] \\npublic class CustomDTO \\n{ \\n} \\n\\nTo register a mode\", \"l binder globally in ASP.NET Web API, its provider must be added during app \\nstartup: \\n\\npublic stati\", \"c class WebApiConfig \\n{ \\n    public static void Register(HttpConfiguration config) \\n    { \\n        v\", \"ar provider = new CustomModelBinderProvider( \\n            typeof(CustomDTO), new CustomModelBinder()\", \"); \\n        config.Services.Insert(typeof(ModelBinderProvider), 0, provider); \\n\\n        // ... \\n    \", \"} \\n} \\n\\nWhen migrating custom model providers to ASP.NET Core, the Web API pattern is closer to the \\n\", \"ASP.NET Core approach than the ASP.NET MVC 5. The main differences between ASP.NET Core\\u2019s \\nIModelBin\", \"der interface and Web API\\u2019s is that the ASP.NET Core method is async (BindModelAsync) \\nand it only r\", \"equires a single BindingModelContext parameter instead of two parameters like Web \\nAPI\\u2019s version req\", \"uired. In ASP.NET Core, you can use a [ModelBinder] attribute on individual action \\nmethod parameter\", \"s or their associated types. You can also create a ModelBinderProvider that will be \\nused globally w\", \"ithin the app where appropriate. To configure such a provider, you would add code to \\nProgram.cs: \\n\\n\", \"builder.Services.AddControllers(options => \\n{ \\n    options.ModelBinderProviders.Insert(0, new Custom\", \"ModelBinderProvider()); \\n}); \\n\\n72 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n \", \"\\n\\fMedia formatters \\n\\nASP.NET Web API supports multiple media formats and can be extended by using cu\", \"stom media \\nformatters. The docs describe an example CSV Media Formatter that can be used to send da\", \"ta in a \\ncomma-separated value format. If your Web API app uses custom media formatters, you\\u2019ll need\", \" to \\nconvert them to ASP.NET Core custom formatters. \\n\\nTo create a custom formatter in Web API 2, yo\", \"u inherited from an appropriate base class and then \\nadded the formatter to the Web API pipeline usi\", \"ng the HttpConfiguration object: \\n\\npublic static void ConfigureApis(HttpConfiguration config) \\n{ \\n  \", \"  config.Formatters.Add(new ProductCsvFormatter()); \\n} \\n\\nIn ASP.NET Core, the process is similar. AS\", \"P.NET Core supports both input formatters (used by model \\nbinding) and output formatters (used to fo\", \"rmat responses). Adding a custom formatter to output \\nresponses in a specific way involves inheritin\", \"g from an appropriate base class and adding the \\nformatter to MVC in Program.cs: \\n\\nbuilder.Services.\", \"AddControllers(options => \\n{ \\n    options.InputFormatters.Insert(0, new CustomInputFormatter()); \\n  \", \"  options.OutputFormatters.Insert(0, new CustomOutputFormatter()); \\n}); \\n\\nYou\\u2019ll find a complete lis\", \"t of base classes in the Microsoft.AspNetCore.Mvc.Formatters namespace. \\n\\nThe steps to migrate from \", \"a Web API formatter to an ASP.NET Core MVC formatter are: \\n\\n1. \\n\\n2. \\n\\n3. \\n\\n4. \\n\\nIdentify an appropri\", \"ate base class for the new formatter. \\n\\nCreate a new instance of the base class and implement its re\", \"quired methods. \\n\\nCopy over the functionality from the Web API formatter to the new implementation. \", \"\\n\\nConfigure MVC in the ASP.NET Core App\\u2019s ConfigureServices method to use the new \\nformatter. \\n\\nCust\", \"om filters \\n\\nFilters are used in ASP.NET Core apps to execute code before and/or after certain stage\", \"s in the \\nrequest processing pipeline. ASP.NET MVC and Web API also use filters in much the same way\", \", but the \\ndetails vary. For instance, ASP.NET MVC supports four kinds of filters. ASP.NET Web API 2\", \" supports \\nsimilar filters, and both MVC and Web API included attributes to override filters. \\n\\nThe \", \"most common filter used in ASP.NET MVC and Web API apps is the action filter, which is defined \\nby a\", \"n IActionFilter interface. This interface provides methods for before (OnActionExecuting) and after \", \"\\n(OnActionExecuted) which can be used to execute code before and/or after an action executes, as \\nno\", \"ted for each method. \\n\\nASP.NET Core continues to support filters, and its unification of MVC and Web\", \" API means there is only \\none approach to their implementation. The docs include detailed coverage o\", \"f the five (5) kinds of \\nfilters built into ASP.NET Core MVC. All of the filter variants supported i\", \"n ASP.NET MVC and ASP.NET \\n\\n73 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n\\fWeb A\", \"PI have associated versions in ASP.NET Core, so migration is generally just a matter of \\nidentifying\", \" the appropriate interface and/or base class and migrating the code over. \\n\\nIn addition to the synch\", \"ronous interfaces, ASP.NET Core also provides async interfaces like \\nIAsyncActionFilter which provid\", \"e a single async method that can be used to incorporate code to run \\nboth before and after the actio\", \"n, as shown: \\n\\npublic class SampleAsyncActionFilter : IAsyncActionFilter \\n{ \\n    public async Task O\", \"nActionExecutionAsync( \\n        ActionExecutingContext context, \\n        ActionExecutionDelegate nex\", \"t) \\n    { \\n        // Do something before the action executes. \\n\\n        // next() calls the action \", \"method. \\n        var resultContext = await next(); \\n        // resultContext.Result is set. \\n       \", \" // Do something after the action executes. \\n    } \\n} \\n\\nWhen migrating async code (or code that shou\", \"ld be async), teams should consider leveraging the \\nbuilt in async types that are provided for this \", \"purpose. \\n\\nMost ASP.NET MVC and Web API apps do not use a large number of custom filters. Since the \", \"\\napproach to filters in ASP.NET Core MVC is closely aligned with filters in ASP.NET MVC and Web API,\", \" \\nthe migration of custom filters is generally fairly straightforward. Be sure to read the detailed \", \"\\ndocumentation on filters in ASP.NET Core\\u2019s docs, and once you\\u2019re sure you have a good \\nunderstandin\", \"g of them, port the logic from the old system to the new system\\u2019s filters. \\n\\nRoute constraints \\n\\nASP\", \".NET Core uses route constraints to help ensure requests are routed properly to route a request. \\nAS\", \"P.NET Core supports a large number of different route constraints for this purpose. Route \\nconstrain\", \"ts can be applied in the route table, but most apps built with ASP.NET MVC 5 and/or \\nASP.NET Web API\", \" 2 use inline route constraints applied to attribute routes. Inline route constraints use \\na format \", \"like this one: \\n\\n[Route(\\\"/customer/{id:int}\\\")] \\n\\nThe :int after the id route parameter constrains th\", \"e value to match the int type. One benefit of using \\nroute constraints is that they allow for two ot\", \"herwise-identical routes to exist where the parameters \\ndiffer only by their type. This allows for t\", \"he equivalent of method overloading of routes based solely \\non parameter type. \\n\\nThe set of route co\", \"nstraints, their syntax, and usage is very similar between all three approaches. \\nCustom route const\", \"raints are fairly rare in customer applications. If your app uses a custom route \\nconstraint and nee\", \"ds to port to ASP.NET Core, the docs include examples showing how to create \\ncustom route constraint\", \"s in ASP.NET Core. Essentially all that\\u2019s required is to implement \\nIRouteConstraint and its Match m\", \"ethod, and then add the custom constraint when configuring \\nrouting for the app: \\n\\n74 \\n\\nCHAPTER 4 | \", \"Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\fbuilder.Services.AddControllers(); \\n\\nbuilder.Ser\", \"vices.AddRouting(options => \\n{ \\n    options.ConstraintMap.Add(\\\"customName\\\", typeof(MyCustomConstrain\", \"t)); \\n}); \\n\\nThis is very similar to how custom constraints are used in ASP.NET Web API, which uses \\n\", \"IHttpRouteConstraint and configures it using a resolver and a call to \\nHttpConfiguration.MapHttpAttr\", \"ibuteRoutes: \\n\\npublic static class WebApiConfig \\n{ \\n    public static void Register(HttpConfiguratio\", \"n config) \\n    { \\n        var constraintResolver = new DefaultInlineConstraintResolver(); \\n        c\", \"onstraintResolver.ConstraintMap.Add(\\\"nonzero\\\", typeof(CustomConstraint)); \\n\\n        config.MapHttpAt\", \"tributeRoutes(constraintResolver); \\n    } \\n} \\n\\nASP.NET MVC 5 follows a very similar approach, using \", \"IRouteConstraint for its interface name and \\nconfiguring the constraint as part of route configurati\", \"on: \\n\\npublic class RouteConfig \\n{ \\n    public static void RegisterRoutes(RouteCollection routes) \\n  \", \"  { \\n        routes.IgnoreRoute(\\\"{resource}.axd/{*pathInfo}\\\"); \\n\\n        var constraintsResolver = n\", \"ew DefaultInlineConstraintResolver(); \\n        constraintsResolver.ConstraintMap.Add(\\\"values\\\", typeo\", \"f(ValuesConstraint)); \\n        routes.MapMvcAttributeRoutes(constraintsResolver); \\n    } \\n} \\n\\nMigrat\", \"ing route constraint usage as well as custom route constraints to ASP.NET Core is typically very \\nst\", \"raightforward. \\n\\nCustom route handlers \\n\\nAnother fairly advanced feature of ASP.NET MVC 5 is route h\", \"andlers. Custom route handlers \\nimplement IRouteHandler, which includes a single method that returns\", \" an IHttpHandler for a give \\nrequest. The IHttpHandler, in turn, exposes an IsReusable property and \", \"a single ProcessRequest \\nmethod. In ASP.NET MVC 5, you can configure a particular route in the route\", \" table to use your custom \\nhandler: \\n\\npublic static void RegisterRoutes(RouteCollection routes) \\n{ \\n\", \"    routes.IgnoreRoute(\\\"{resource}.axd/{*pathInfo}\\\"); \\n\\n    routes.Add(new Route(\\\"custom\\\", new Custo\", \"mRouteHandler())); \\n} \\n\\n75 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n \\n \\n \\n\\fT\", \"o migrate custom route handlers from ASP.NET MVC 5 to ASP.NET Core, you can either use a filter \\n(su\", \"ch as an action filter) or a custom IRouter. The filter approach is relatively straightforward, and \", \"can \\nbe added as a global filter when MVC is added to the app\\u2019s services during startup: \\n\\nbuilder.S\", \"ervices.AddMvc(options => \\n{ \\n    options.Filters.Add(typeof(CustomActionFilter)); \\n}); \\n\\nThe IRoute\", \"r option requires implementing the interface\\u2019s RouteAsync and GetVirtualPath methods. \\nThe custom ro\", \"uter is added to the request pipeline during app startup. \\n\\n// ... \\napp.UseMvc(routes => \\n{ \\n    rou\", \"tes.Routes.Add(new CustomRouter(routes.DefaultHandler)); \\n}); \\n\\nIn ASP.NET Web API, these handlers a\", \"re referred to as custom message handlers, rather than route \\nhandlers. Message handlers must derive\", \" from DelegatingHandler and override its SendAsync method. \\nMessage handlers can be chained together\", \" to form a pipeline in a fashion that is very similar to \\nASP.NET Core middleware and its request pi\", \"peline. \\n\\nASP.NET Core has no DelegatingHandler type or separate message handler pipeline. Instead, \", \"such \\nhandlers should be migrated using global filters, custom IRouter instances (see above), or cus\", \"tom \\nmiddleware. ASP.NET Core MVC filters and IRouter types have the advantage of having built-in ac\", \"cess \\nto MVC constructs like controllers and actions, while middleware is a lower level approach tha\", \"t has no \\nties to MVC. This makes it more flexible but also requires more effort if you need to acce\", \"ss MVC \\ncomponents. \\n\\nCORS support \\n\\nCORS, or Cross-Origin Resource Sharing, is a W3C standard that \", \"allows servers to accept requests that \\ndon\\u2019t originate from responses they\\u2019ve served. ASP.NET MVC 5\", \" and ASP.NET Web API 2 support CORS \\nin different ways. The simplest way to enable CORS support in A\", \"SP.NET MVC 5 is with an action filter \\nlike this one: \\n\\npublic class AllowCrossSiteAttribute : Actio\", \"nFilterAttribute \\n{ \\n    public override void OnActionExecuting(ActionExecutingContext filterContext\", \") \\n    { \\n        filterContext.RequestContext.HttpContext.Response.AddHeader( \\n            \\\"Access-\", \"Control-Allow-Origin\\\", \\\"example.com\\\"); \\n        base.OnActionExecuting(filterContext); \\n    } \\n} \\n\\nA\", \"SP.NET Web API can also use such a filter, but it has built-in support for enabling CORS as well: \\n\\n\", \"public static class WebApiConfig \\n{ \\n    public static void Register(HttpConfiguration config) \\n    \", \"{ \\n        config.EnableCors(); \\n\\n76 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n\", \"\\f        // ... \\n    } \\n} \\n\\nOnce this is added, you can configure allowed origins, headers, and meth\", \"ods using the EnableCors \\nattribute, like so: \\n\\n[EnableCors(origins: \\\"https://dot.net\\\", headers: \\\"*\\\"\", \", methods: \\\"*\\\")] \\npublic class TestController : ApiController \\n{ \\n    // Controller methods not show\", \"n... \\n} \\n\\nBefore migrating your CORS implementation from ASP.NET MVC 5 or ASP.NET Web API 2, be sure\", \" to \\nreview how CORS works and create some automated tests that demonstrate CORS is working as \\nexpe\", \"cted in your current system. \\n\\nIn ASP.NET Core, there are three built-in ways to enable CORS: \\n\\n\\u2022 \\n\\n\", \"\\u2022 \\n\\n\\u2022 \\n\\nConfigured via policy in ConfigureServices \\n\\nEnabled with endpoint routing \\n\\nEnabled with th\", \"e EnableCors attribute \\n\\nEach of these approaches is covered in detail in the docs, which are linked\", \" from the above options. \\nWhich one you choose will largely depend on how your existing app supports\", \" CORS. If the app uses \\nattributes, you can probably migrate to use the EnableCors attribute most ea\", \"sily. If your app uses \\nfilters, you could continue using that approach (though it\\u2019s not the typical\", \" approach used in ASP.NET \\nCore), or migrate to use attributes or policies. Endpoint routing is a re\", \"latively new feature introduced \\nwith ASP.NET Core 3 and as such it doesn\\u2019t have a close analog in A\", \"SP.NET MVC 5 or ASP.NET Web \\nAPI 2 apps. \\n\\nCustom areas \\n\\nMany ASP.NET MVC apps use Areas to organiz\", \"e the project. Areas typically reside in the root of the \\nproject in an Areas folder, and must be re\", \"gistered when the application starts, typically in \\nApplication_Start(): \\n\\nAreaRegistration.Register\", \"AllAreas(); \\n\\nAn alternative to registering all areas in startup is to use the RouteArea attribute o\", \"n individual \\ncontrollers: \\n\\n[RouteArea(\\\"Admin\\\")] \\npublic class SomeController : Controller \\nWhen us\", \"ing Areas, additional arguments are passed into HTML helper methods to generate \\nlinks to actions in\", \" different areas: \\n@Html.ActionLink(\\\"News\\\", \\\"Index\\\", \\\"News\\\", new { area = \\\"News\\\" }, null) \\n\\nASP.NET \", \"Web API apps don\\u2019t typically use areas explicitly, since their controllers can be placed in any \\nfol\", \"der in the project. Teams can use any folder structure they like to organize their API controllers. \", \"\\n\\n77 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n\\fAreas are supported in ASP.NET \", \"Core MVC. The approach used is nearly identical to the use of areas \\nin ASP.NET MVC 5. Developers mi\", \"grating code using areas should keep in mind the following \\ndifferences: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAreaRegistrat\", \"ion.RegisterAllAreas is not used in ASP.NET Core MVC \\n\\nAreas are applied using the [Area(\\\"name\\\")] at\", \"tribute (not RouteArea as in ASP.NET MVC 5) \\n\\nAreas can be added to the route table templates, if de\", \"sired (or they can use attribute routing) \\n\\nTo add area support to the route table in ASP.NET Core M\", \"VC, you would add the following during app \\nstartup: \\n\\napp.UseEndpoints(endpoints => \\n{ \\n    endpoin\", \"ts.MapControllerRoute( \\n        name: \\\"MyArea\\\", \\n        pattern: \\\"{area:exists}/{controller=Home}/{\", \"action=Index}/{id?}\\\"); \\n\\n    endpoints.MapControllerRoute( \\n        name: \\\"default\\\", \\n        patter\", \"n: \\\"{controller=Home}/{action=Index}/{id?}\\\"); \\n}); \\n\\nAreas can also be used with attribute routing, \", \"using the {area} keyword in the route definition (it\\u2019s one \\nof several reserved routing names that c\", \"an be used with route templates). \\n\\nTag helpers support areas with the asp-area attribute, which can\", \" be used to generate links in Razor \\nviews and pages: \\n\\n<ul> \\n    <li> \\n        <a asp-area=\\\"Product\", \"s\\\" asp-controller=\\\"Home\\\" asp-action=\\\"About\\\"> \\n            Products/Home/About \\n        </a> \\n    </l\", \"i> \\n    <li> \\n        <a asp-area=\\\"Services\\\" asp-controller=\\\"Home\\\" asp-action=\\\"About\\\"> \\n            \", \"Services About \\n        </a> \\n    </li> \\n    <li> \\n        <a asp-area=\\\"\\\" asp-controller=\\\"Home\\\" asp-\", \"action=\\\"About\\\"> \\n            /Home/About \\n        </a> \\n    </li> \\n</ul> \\n\\nIf you\\u2019re migrating to Ra\", \"zor Pages you will need to use an Areas folder in your Pages folder. For more \\ninformation, see Area\", \"s with Razor Pages. \\n\\nIn addition to the above guidance, teams should review how routing in ASP.NET \", \"Core works with \\nareas as part of their migration planning process. \\n\\nIntegration tests for ASP.NET \", \"MVC and ASP.NET Web API \\n\\nIntegration tests are automated tests that verify several different parts \", \"of an app work together \\ncorrectly. Writing integration tests for ASP.NET MVC and ASP.NET Web API us\", \"ually involved deploying \\n\\n78 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\fthe \", \"app to a real web server, such as a local instance of IIS or IIS Express, and then making requests t\", \"o \\nthis hosted application using an HTTP client. Some of these tests may interact with the client-si\", \"de user \\ninterface using browser automation tools like Selenium, though often these are referred to \", \"as UI tests \\nrather than integration tests. \\n\\nIf your migrated app shares the same behavior as its o\", \"riginal version, whatever existing technology \\nthe team is using to perform integration tests (and U\", \"I tests) should continue to work just as it did \\nbefore. These tests are usually indifferent to the \", \"underlying technology used to host the app they\\u2019re \\ntesting, and interact with it only through HTTP \", \"requests. Where things may get more challenging is \\nwith how the tests interact with the app to get \", \"it into a known good state prior to each test. This may \\nrequire some migration effort, since config\", \"uration and startup are significantly different in ASP.NET \\nCore compared to ASP.NET MVC or ASP.NET \", \"Web API. \\n\\nTeams should strongly consider migrating their integration tests to use ASP.NET Core\\u2019s bu\", \"ilt-in \\nintegration testing support. In ASP.NET Core, apps can be tested by deploying them to a Test\", \"Host, \\nwhich is configured using a WebApplicationFactory. There\\u2019s a little bit of setup required to \", \"host the \\napp for testing, but once this is in place, creating individual integration tests is very \", \"straightforward. \\n\\nOne of the best features of ASP.NET Core\\u2019s integration testing support is that th\", \"e app is hosted in \\nmemory. There\\u2019s no need to configure a real webserver to host the app. There\\u2019s n\", \"o need to use a \\nbrowser automation tool (if you\\u2019re only testing ASP.NET Core and not client-side be\", \"havior). Many of \\nthe problems that can be encountered when trying to use a real web server for auto\", \"mated integration \\ntests, such as firewall issues or process start/stop issues, are eliminated with \", \"this approach. Since the \\nrequests are all made in memory with no network requirement, the tests als\", \"o tend to run much faster \\nthan tests that must set up a separate webserver and communicate with it \", \"over the network (even if \\nit\\u2019s running on the same machine). \\n\\nBelow you can see an example ASP.NET\", \" Core integration test (sometimes referred to as functional \\ntests to distinguish them from lower-le\", \"vel integration tests) from the eShopOnWeb reference \\napplication: \\n\\npublic class GetByIdEndpoint : \", \"IClassFixture<ApiTestFixture> \\n{ \\n    JsonSerializerOptions _jsonOptions = new JsonSerializerOptions\", \" { \\nPropertyNameCaseInsensitive = true }; \\n\\n    public GetByIdEndpoint(ApiTestFixture factory) \\n    \", \"{ \\n        Client = factory.CreateClient(); \\n    } \\n\\n    public HttpClient Client { get; } \\n\\n    [Fa\", \"ct] \\n    public async Task ReturnsItemGivenValidId() \\n    { \\n        var response = await Client.Get\", \"Async(\\\"api/catalog-items/5\\\"); \\n        response.EnsureSuccessStatusCode(); \\n        var stringRespon\", \"se = await response.Content.ReadAsStringAsync(); \\n        var model = stringResponse.FromJson<GetByI\", \"dCatalogItemResponse>(); \\n\\n        Assert.Equal(5, model.CatalogItem.Id); \\n        Assert.Equal(\\\"Ros\", \"lyn Red Sheet\\\", model.CatalogItem.Name); \\n\\n79 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Co\", \"re \\n\\n \\n \\n \\n \\n \\n \\n\\f    } \\n} \\n\\nIf the app being migrated has no integration tests, the migration proce\", \"ss can be a great opportunity \\nto add some. These tests can verify that the migrated app behaves as \", \"the team expects. When such \\ntests are in place early in a migration, they can ensure that later mig\", \"ration efforts do not break \\npreviously migrated portions of the app. Given how easy it is to set up\", \" and run integration tests in \\nASP.NET Core, the return on the investment spent setting up such test\", \"s is usually pretty high. \\n\\nWCF client configuration \\n\\nIf your app currently relies on WCF services \", \"as a client, this scenario is supported. However, you will \\nneed to migrate your configuration from \", \"web.config to use the new appsettings.json file. Another \\noption is to add any necessary configurati\", \"on to your clients programmatically when you create them. \\nFor example: \\n\\nvar wcfClient = new OrderS\", \"erviceClient( \\n    new BasicHttpBinding(BasicHttpSecurityMode.None), \\n    new EndpointAddress(\\\"http:\", \"//localhost:5050/OrderService.svc\\\")); \\n\\nIf your organization has extensive services built using WCF \", \"that your app relies on, consider migrating \\nthem to use gRPC instead. For more details on gRPC, why\", \" you may wish to migrate, and a detailed \\nmigration guide, consult the gRPC for WCF Developers eBook\", \". \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nASP.NET Web API Content Negotiation \\n\\nFormat response data in ASP.N\", \"ET Core Web API \\n\\nCustom Model Binders in ASP.NET Web API \\n\\nCustom Model Binders in ASP.NET Core \\n\\n\\u2022\", \"  Media Formatters in ASP.NET Web API 2 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nCustom formatt\", \"ers in ASP.NET Core Web API \\n\\nFilters in ASP.NET Core \\n\\nRoute constraints in ASP.NET Web API 2 \\n\\nRou\", \"te constraints in ASP.NET MVC 5 \\n\\nASP.NET Core Route Constraint Reference \\n\\nCustom message handlers \", \"in ASP.NET Web API 2 \\n\\nSimple CORS control in MVC 5 and Web API 2 \\n\\nEnabling Cross-Origin Requests i\", \"n Web API \\n\\nEnable Cross-Origin Requests (CORS) in ASP.NET Core \\n\\nAreas in ASP.NET Core \\n\\nIntegratio\", \"n tests in ASP.NET Core \\n\\n80 \\n\\nCHAPTER 4 | Example migration of eShop to ASP.NET Core \\n\\n \\n \\n \\n\\fCHAPT\", \"ER  5 \\n\\nDeployment scenarios \\nwhen migrating to \\nASP.NET Core \\n\\nExisting ASP.NET MVC and Web API app\", \"s run on IIS and Windows. Large apps may require a phased \\nor side-by-side approach when porting to \", \"ASP.NET Core. In previous chapters, you learned a number \\nof strategies for migrating large .NET Fra\", \"mework apps to ASP.NET Core in phases. In this chapter, you \\nwill see how different deployment scena\", \"rios can be achieved when there is a need to maintain the \\noriginal app in production while migratin\", \"g portions of it. \\n\\nSplit a large web app \\n\\nConsider the common scenario of a large web app that cur\", \"rently is hosted on IIS in a single web site. \\nWithin the large app, functionality is segmented into\", \" different routes and/or directories. The app is a \\nmix of MVC views and API endpoints. The MVC rout\", \"es include many different paths based on \\nfunctionality and all start from the root of the app using\", \" the standard /{controller}/{action}/{id?} route \\ntemplate. The API endpoints follow a similar patte\", \"rn, but are all under an /api root. \\n\\nAssuming the task of porting the app is split such that either\", \" the MVC functionality or the API \\nfunctionality is migrated to ASP.NET Core first, how would the or\", \"iginal site continue to function \\nseamlessly with the new ASP.NET Core app running somewhere else? U\", \"sers of the system should \\ncontinue to see the same URLs they did prior to the migration, unless it\\u2019\", \"s absolutely necessary to \\nchange them. \\n\\nFortunately, IIS is a feature-rich web server, and two fea\", \"tures it has are URL Rewrite module and \\nApplication Request Routing. Using these features, IIS can \", \"act as a reverse proxy, routing client \\nrequests to the appropriate back-end web app. To configure I\", \"IS as a reverse proxy, check the Enable \\nproxy checkbox in the Application Request Routing feature, \", \"then add a URL Rewrite rule like this one: \\n\\n<rule name=\\\"NetCoreProxy\\\"> \\n  <match url=\\\"(.*)>\\\" /> \\n  \", \"<action type=\\\"Rewrite\\\" url=\\\"http://servername/{R:1}\\\" /> \\n</rule> \\n\\nAs a reverse proxy, IIS can route\", \" traffic matching certain patterns to entirely separate apps, potentially \\non different servers. \\n\\n8\", \"1 \\n\\nCHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core \\n\\n \\n \\n\\fUsing just the URL Rewrit\", \"e module (perhaps combined with host headers), IIS can easily support \\nmultiple web sites, each pote\", \"ntially running different versions of .NET. A large web app might be \\ndeployed as a collection of in\", \"dividual sites, each responding to different IP addresses and/or host \\nheaders, or as a single web s\", \"ite with one or more sub-applications in it responding to certain URL \\npaths (which doesn\\u2019t even req\", \"uire URL Rewrite). \\n\\nImportant \\n\\nSubdomains typically refer to the portion of a domain preceding the\", \" top two levels. For example, in \\nthe domain api.contoso.com, api is a subdomain of the contoso.com \", \"domain (which itself is \\ncomposed of the contoso domain name and the .com top-level domain or TLD). \", \"URL paths refer to \\nportion of the URL that follows the domain name, starting with a /. The URL http\", \"s://contoso.com/api \\nhas a path of /api. \\n\\nThere are pros and cons to using the same or different su\", \"bdomains (and domains) to host a single \\napp. Features like cookies and intra-app communication usin\", \"g mechanisms like CORS may require \\nmore configuration to work properly in distributed apps. However\", \", apps that use different \\nsubdomains can more easily use DNS to route requests to entirely differen\", \"t network destinations, and \\nso can more easily be deployed to many different servers (virtual or ot\", \"herwise) without the need for \\nIIS to act as a reverse proxy. \\n\\nIn the example described above, assu\", \"me the API endpoints are designated as the first part of the app \\nto be ported to ASP.NET Core. In t\", \"his case, a new ASP.NET Core app is created and hosted in IIS as a \\nseparate web application within \", \"the existing ASP.NET MVC web site. Since it will be added as a child of \\nthe original web site and w\", \"ill be named api, its default route should no longer begin with api/. \\nKeeping this would result in \", \"it matching URLs of the form /api/api/endpoint. \\n\\nFigure 5-1 shows how the ASP.NET Core 2.1 api app \", \"appears in IIS Manager as a part of the existing \\nDotNetMvcApp site. \\n\\n82 \\n\\nCHAPTER 5 | Deployment s\", \"cenarios when migrating to ASP.NET Core \\n\\n \\n \\n\\fFigure 5-1. .NET Framework Site with .NET Core app in\", \" IIS. \\n\\nThe DotNetMvcApp site is hosted as an MVC 5 app running on .NET Framework 4.7.2. It has its \", \"own IIS \\napp pool configured in integrated mode and running .NET CLR version 4.0.30319. The api app \", \"is an \\nASP.NET Core app running on .NET Framework 4.6.1 (net461). It was added to the DotNetMvcApp a\", \"s a \\nnew IIS app and configured to use its own Application Pool. Its Application Pool is also runnin\", \"g in \\nintegrated mode but is configured with a .NET CLR version of No Managed Code since it will be \", \"\\nexecuted using the ASP.NET Core Module. The version of the ASP.NET Core app is just an example. It \", \"\\ncould also be configured to run on NET 5+. Though at that point, it would no longer be able to targ\", \"et \\n.NET Framework libraries (see Choose the Right .NET Core Version) \\n\\nConfigured in this manner, t\", \"he only change that must be made in order for the ASP.NET Core app\\u2019s \\nAPIs to be routed properly is \", \"to change its default route template from [Route(\\\"[api/controller]\\\")] to \\n[Route(\\\"[controller]\\\")]. \\n\", \"\\nAlternately the ASP.NET Core app can be another top-level web site in IIS. In this case, you can \\nc\", \"onfigure the original site to use a rewrite rule (with URL Rewrite) that will redirect to the other \", \"app if \\nthe path starts with /api. The ASP.NET Core app can use a different host header for its rout\", \"e so that it \\ndoesn\\u2019t conflict with the main app but can still respond to requests using root-based \", \"routes. \\n\\nAs an example, the same ASP.NET Core app used in Figure 5-1 can be deployed to another fol\", \"der \\nconfigured as an IIS web site. The site should use an app pool configured just as before, with \", \"No \\n\\n83 \\n\\nCHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core \\n\\n \\n \\n \\n\\fManaged Code. Con\", \"figure its bindings to respond to a unique host name on the server, such as \\napi.contoso.com. To con\", \"figure URL Rewrite to rewrite requests matching /api just add a new inbound \\nrule at the IIS server \", \"(or individual site) level. Match the pattern ^/api(.*) and specify an Action type of \\nRewrite and a\", \" Rewrite URL of api.contoso.com/{R:1}. The combination of using (.*) in the matching \\npattern and {R\", \":1} in the rewrite URL will ensure the rest of the path gets used with the new URL. With \\nthis in pl\", \"ace, separate sites on the same IIS server can coexist running separate versions of .NET, but \\nthey \", \"can be made to appear to the Internet as one web app. Figure 5-2 shows the rewrite rule as \\nconfigur\", \"ed in IIS with the separate web site. \\n\\nFigure 5-2. Rewrite rule to rewrite subfolder requests to an\", \"other web site. \\n\\nIf your app requires single sign-on between different sites or apps within IIS, re\", \"fer to the \\ndocumentation on how to share authentication cookies among ASP.NET apps for detailed ins\", \"tructions \\non supporting this scenario. \\n\\nAnother alternative to IIS Rewrite rules is the use of a r\", \"everse proxy like YARP, which can facilitate \\nincremental ASP.NET to ASP.NET Core Migration. \\n\\nSumma\", \"ry \\n\\nA common approach to porting large apps from .NET Framework to ASP.NET Core is to choose \\nindiv\", \"idual portions of the app to migrate one by one. As each piece of the app is ported, the entire \\napp\", \" remains running and usable, with some parts of it running in its original configuration and other \\n\", \"parts running on some version of .NET Core. By following this approach, a large app migration can be\", \" \\nperformed incrementally. This approach results in limiting risk by providing more rapid feedback a\", \"nd \\n\\n84 \\n\\nCHAPTER 5 | Deployment scenarios when migrating to ASP.NET Core \\n\\n \\n \\n \\n\\freducing total su\", \"rface area involved in testing. It also allows for more rapid realization of benefits of \\n.NET Core,\", \" such as performance increases. Although ASP.NET Core apps are no longer required to be \\nhosted on I\", \"IS, IIS remains a very flexible and powerful web server that can be configured to support a \\nvariety\", \" of hosting scenarios involving both .NET Framework and ASP.NET Core apps on the same IIS \\ninstance \", \"or even hosted on different servers. \\n\\nReferences \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nHost ASP.NET Core on\", \" Windows with IIS \\n\\nURL Rewrite module and Application Request Routing \\n\\nURL Rewrite \\n\\nASP.NET Core \", \"Module \\n\\nShare authentication cookies among ASP.NET apps \\n\\nSamples used in this section \\n\\nIncrementa\", \"l ASP.NET to ASP.NET Core Migration \\n\\n85 \\n\\nCHAPTER 5 | Deployment scenarios when migrating to ASP.NE\", \"T Core \\n\\n \\n \\n\\fCHAPTER \\n\\nCHAPTER  6 \\n\\nSummary: Port existing \\nASP.NET Apps to .NET 7 \\n\\nIn this book, \", \"you\\u2019ve been given the resources needed to decide whether it makes sense to port your \\norganization\\u2019s\", \" existing ASP.NET apps running on .NET Framework to ASP.NET Core. You\\u2019ve learned \\nabout important co\", \"nsiderations for choosing when it makes sense to migrate to .NET Core, and when \\nit may be appropria\", \"te to keep (parts of) your app on .NET Framework. There are differences between \\n.NET Core versions \", \"and their capabilities and compatibilities with .NET Framework, and you learned \\nhow to choose the r\", \"ight version of .NET Core for your app. \\n\\nPorting a large app often entails a fair amount of risk an\", \"d effort. You learned how to mitigate this risk \\nby employing one or more incremental migration stra\", \"tegies along with several deployment strategies \\nfor keeping partially migrated apps running in prod\", \"uction. \\n\\nThere are many architectural differences between ASP.NET and ASP.NET Core. In chapter 2, y\", \"ou \\nlearned about many of these differences and how they relate to your app\\u2019s migration. This chapte\", \"r \\ncovered everything from app startup and low-level middleware to high-level controller and Web API\", \" \\ndifferences and new features enabling much better testing scenarios. \\n\\nLarge apps are often compri\", \"sed of many projects and packages, and dependencies can play a major \\nrole in determining how easy o\", \"r difficult migration may be. Chapter 3 helped you identify the \\nsequence in which to migrate projec\", \"ts and how to understand and update your app\\u2019s dependencies. It \\nalso detailed additional strategies\", \" for migrating apps while keeping them running in production. \\n\\nIn chapter 4, you saw how a real ASP\", \".NET MVC reference app was migrated to ASP.NET Core. This \\nchapter included a detailed breakdown of \", \"all the changes that were needed to take the existing app \\nand port it over to run on ASP.NET Core. \", \"Refer back to it if you have specific questions about the \\nporting process and some of its more spec\", \"ific details. \\n\\nFinally, chapter 5 detailed specific deployment scenarios focused on IIS. You saw ho\", \"w you can use \\nyour existing IIS web server to host parts of your app that have been ported to ASP.N\", \"ET Core while \\nkeeping the app\\u2019s public URLs consistent. IIS includes great support for URL rewritin\", \"g and request \\nrouting that enables it to host multiple versions of your site side by side or even o\", \"n different servers, \\nwith no change to the public-facing URLs the app exposes. \\n\\n86 \\n\\nCHAPTER 6 | S\", \"ummary: Port existing ASP.NET Apps to .NET 7 \\n\\n \\n \\n\\f\"]"