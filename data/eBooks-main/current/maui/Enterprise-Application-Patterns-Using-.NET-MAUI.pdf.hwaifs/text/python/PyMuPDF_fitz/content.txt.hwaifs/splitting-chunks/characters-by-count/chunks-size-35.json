"[\" \\n \\n \\nDOWNLOAD available at: https://aka.ms/maui-ebook \\nEDITION v2.0 \\nPUBLISHED BY \\nMicrosoft Develo\", \"per Division, .NET, and Visual Studio product teams \\nA division of Microsoft Corporation \\nOne Micros\", \"oft Way \\nRedmond, Washington 98052-6399 \\nCopyright \\u00a9 2022 by Microsoft Corporation \\nAll rights reser\", \"ved. No part of the contents of this book may be reproduced or transmitted in any \\nform or by any me\", \"ans without the written permission of the publisher. \\nThis book is provided \\u201cas-is\\u201d and expresses th\", \"e author\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in this book, includi\", \"ng URL and other Internet website references, may change \\nwithout notice. \\nSome examples depicted he\", \"rein are provided for illustration only and are fictitious. No real association \\nor connection is in\", \"tended or should be inferred. \\nMicrosoft and the trademarks listed at https://www.microsoft.com on t\", \"he \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies. \\nMac and macOS are trad\", \"emarks of Apple Inc. \\nAll other marks and logos are property of their respective owners. \\nAuthors: \\n\", \"Michael Stonis, Mobile Software Architect, Eight-Bot \\nReviewers: \\nJames Montemagno, Principal Lead P\", \"rogram Manager, Microsoft Corp. \\nDavid Pine, Developer Relations, Microsoft Corp. \\nAcknowledgments \\n\", \"This book originated from the excellent Enterprise Application Patterns using Xamarin.Forms eBook by\", \" \\nDavid Britch and Javier Suarez Ruiz. Without their hard work, detailed information, and excellent \", \"\\nexamples, this book would not be possible. \\nIntroduction \\nEnterprise applications face a number of \", \"difficult problems to solve including ever changing business \\nrequirements, the need for quick turn \", \"around time, support for multiple platforms, and integration \\nwith multiple systems. Due to the vary\", \"ing nature of these problems, it\\u2019s important that our \\napplication\\u2019s architecture allows it to be mo\", \"dular, modifiable and extensible over time. \\nThis book takes provides real world solutions for addre\", \"ssing these issues when building an enterprise \\napplication using .NET MAUI. This book uses a pre-bu\", \"ilt .NET MAUI application that serves as the \\nfront-end of an online eCommerce application as a refe\", \"rence and a guide for common enterprise \\ndesign patterns. This book covers topics such as the MVVM p\", \"attern, dependency injection, navigation, \\nconfiguration, the loose-coupling of components and addit\", \"ional enterprise concerns. The content of \\nthis book is helpful for anyone looking to build a new ap\", \"plication for this business or looking to solve \\nthe problems of applications that evolve over time.\", \" \\nWho should use the book \\nThis book is for .NET MAUI developers that are already familiar with the \", \"framework, but that are \\nlooking for guidance on architecture and implementation when building enter\", \"prise applications. This \\nbook can help developers solve common problems using tried and true patter\", \"ns. \\nHow to use the book \\nThis book focuses on building cross-platform enterprise apps using .NET MA\", \"UI. As such, it should be \\nread in its entirety to provide a foundation of understanding such apps a\", \"nd their technical \\nconsiderations. The book, along with its sample app, can also serve as a startin\", \"g point or reference for \\ncreating a new enterprise app. Use the associated sample app as a template\", \" for the new app, or to see \\nhow to organize an app\\u2019s component parts. Then, refer back to this guid\", \"e for architectural guidance. \\nYou can find the sample app on GitHub. \\nWhat this book doesn\\u2019t cover \", \"\\nThis book is aimed at readers who are already familiar with .NET MAUI. It does cover some concepts \", \"\\nof .NET MAUI to help better illustrate the topic, but it does not cover most controls and concepts \", \"in \\nany detail. For general guidance on building a new .NET MAUI app, please refer to the Building y\", \"our \\nfirst app guide in the .NET MAUI documentation. \\nAdditional resources \\nFor official .NET MAUI c\", \"ontent, see .NET MAUI docs. .NET MAUI is developed as an open-source \\nproject and is available on Gi\", \"tHub at dotnet/maui. For code samples developed with .NET MAUI, see \\nthe dotnet/maui-samples repo. \\n\", \" \\ni \\nContents \\n \\nContents \\nPurpose .................................................................\", \".................................................................... 1 \\nWhat\\u2019s left out of this guid\", \"e\\u2019s scope ..........................................................................................\", \"...................................... 1 \\nWho should use this guide ................................\", \"....................................................................................................\", \".............. 1 \\nHow to use this guide ............................................................\", \"................................................................................................ 2 \\n\", \"Introduction to .NET MAUI ..........................................................................\", \".......................... 3 \\nSample application ...................................................\", \"....................................................................................................\", \"........... 4 \\nSample application architecture .....................................................\", \"................................................................................... 5 \\nMulti-Platfor\", \"m app ..............................................................................................\", \".................................................................... 6 \\nMulti-Platform app solution \", \"....................................................................................................\", \"............................................ 7 \\neShop project ......................................\", \"....................................................................................................\", \".................................. 7 \\nSummary ......................................................\", \"....................................................................................................\", \"........................... 8 \\nModel-View-ViewModel (MVVM) .........................................\", \"................................................ 9 \\nThe MVVM pattern ...............................\", \"....................................................................................................\", \"............................... 9 \\nView ............................................................\", \"....................................................................................................\", \"....................... 10 \\nViewModel ..............................................................\", \"....................................................................................................\", \"........ 11 \\nModel .................................................................................\", \"................................................................................................... \", \"11 \\nConnecting view models to views ................................................................\", \".................................................................. 12 \\nCreating a view model declara\", \"tively .............................................................................................\", \"................................ 12 \\nCreating a view model programmatically ........................\", \"........................................................................................... 13 \\nUpda\", \"ting views in response to changes in the underlying view model or model.............................\", \"......... 13 \\nMVVM Frameworks ......................................................................\", \"........................................................................................ 15 \\nUI inte\", \"raction using commands and behaviors ...............................................................\", \"......................................... 15 \\nImplementing commands ................................\", \"....................................................................................................\", \"............. 16 \\nInvoking commands from a view ....................................................\", \"............................................................................... 17 \\nImplementing beh\", \"aviors .............................................................................................\", \"....................................................... 17 \\nInvoking behaviors from a view .........\", \"....................................................................................................\", \"......................... 20 \\nSummary ..............................................................\", \"....................................................................................................\", \"................ 20 \\nDependency injection ..........................................................\", \"................................................. 21 \\n \\nii \\nContents \\nIntroduction to dependency inj\", \"ection .............................................................................................\", \"............................. 21 \\nRegistration .....................................................\", \"....................................................................................................\", \".................... 23 \\nResolution ................................................................\", \"....................................................................................................\", \"............ 25 \\nSummary ...........................................................................\", \"....................................................................................................\", \"... 26 \\nCommunicating between loosely coupled components ...........................................\", \"........ 27 \\nIntroduction to MVVM Toolkit Messenger ................................................\", \"................................................................. 27 \\nDefining a message ...........\", \"....................................................................................................\", \"............................................... 29 \\nPublishing a message ...........................\", \"....................................................................................................\", \"........................... 29 \\nSubscribing to a message............................................\", \"....................................................................................................\", \".. 30 \\nUnsubscribing from a message ................................................................\", \"....................................................................... 30 \\nSummary ................\", \"....................................................................................................\", \".............................................................. 31 \\nNavigation ......................\", \"....................................................................................................\", \".... 32 \\nNavigating between pages ..................................................................\", \"............................................................................. 33 \\nCreating the MauiN\", \"avigationService instance ..........................................................................\", \"................................ 34 \\nHandling navigation requests ..................................\", \"....................................................................................................\", \".... 34 \\nNavigating when the app is launched .......................................................\", \"................................................................... 36 \\nPassing parameters during na\", \"vigation ...........................................................................................\", \".............................. 36 \\nInvoking navigation using behaviors .............................\", \"............................................................................................... 37 \\n\", \"Confirming or cancelling navigation ................................................................\", \"............................................................. 38 \\nSummary ..........................\", \"....................................................................................................\", \".................................................... 38 \\nValidation ................................\", \"............................................................................................... 39 \\n\", \"Specifying validation rules ........................................................................\", \"........................................................................ 40 \\nAdding validation rules\", \" to a property .....................................................................................\", \"..................................... 42 \\nTriggering validation ....................................\", \"....................................................................................................\", \"................... 42 \\nTriggering validation manually .............................................\", \"...................................................................................... 42 \\nTriggerin\", \"g validation when properties change ................................................................\", \".................................... 43 \\nDisplaying validation errors ..............................\", \"....................................................................................................\", \"............ 43 \\nHighlighting a control that contains invalid data .................................\", \"............................................................... 44 \\nDisplaying error messages ......\", \"....................................................................................................\", \"................................. 45 \\nSummary ......................................................\", \"....................................................................................................\", \"........................ 45 \\nApplication settings management .......................................\", \"............................................... 46 \\n \\niii \\nContents \\nCreating a Settings Interface .\", \"....................................................................................................\", \"....................................... 46 \\nAdding Settings ........................................\", \"....................................................................................................\", \"......................... 47 \\nData binding to user settings.........................................\", \".................................................................................................. 4\", \"8 \\nSummary .........................................................................................\", \"......................................................................................... 49 \\nContai\", \"nerized microservices ..............................................................................\", \".................. 50 \\nMicroservices ...............................................................\", \"....................................................................................................\", \"....... 51 \\nContainerization .......................................................................\", \"............................................................................................. 53 \\nCo\", \"mmunication between client and microservices .......................................................\", \"......................................... 56 \\nCommunication between microservices ..................\", \"....................................................................................................\", \" 57 \\nSummary .......................................................................................\", \"........................................................................................... 59 \\nAcce\", \"ssing remote data ..................................................................................\", \"........................ 60 \\nIntroduction to Representational State Transfer .......................\", \"............................................................................... 60 \\nConsuming RESTfu\", \"l APIs .............................................................................................\", \"....................................................... 61 \\nMaking web requests ....................\", \"....................................................................................................\", \".................................. 61 \\nMaking a GET request ........................................\", \"....................................................................................................\", \"............. 61 \\nMaking a POST request ............................................................\", \".......................................................................................... 64 \\nMakin\", \"g a DELETE request .................................................................................\", \"................................................................. 67 \\nCaching data .................\", \"....................................................................................................\", \"...................................................... 68 \\nManaging data expiration ................\", \"....................................................................................................\", \"............................. 69 \\nCaching images ...................................................\", \"....................................................................................................\", \".............. 69 \\nIncreasing resilience ...........................................................\", \".................................................................................................. 7\", \"0 \\nRetry pattern ...................................................................................\", \"........................................................................................ 70 \\nCircuit\", \" breaker pattern ...................................................................................\", \"..................................................................... 71 \\nSummary ..................\", \"....................................................................................................\", \"............................................................ 72 \\nAuthentication and authorization ..\", \"..................................................................................... 73 \\nAuthentica\", \"tion ...............................................................................................\", \"......................................................................... 73 \\nIssuing bearer tokens \", \"using IdentityServer ...............................................................................\", \"............................. 74 \\nAdding IdentityServer to a web application .......................\", \"................................................................................... 75 \\nConfiguring \", \"IdentityServer .....................................................................................\", \"...................................................... 75 \\nConfiguring API resources ...............\", \"....................................................................................................\", \"......................... 76 \\nConfiguring identity resources .......................................\", \"............................................................................................ 76 \\n \\ni\", \"v \\nContents \\nConfiguring clients ...................................................................\", \"....................................................................................... 77 \\nConfigur\", \"ing the authentication flow ........................................................................\", \"................................................ 78 \\nPerforming authentication .....................\", \"....................................................................................................\", \".................. 79 \\nSigning-in ..................................................................\", \"....................................................................................................\", \"...... 80 \\nSigning-out .............................................................................\", \"............................................................................................ 83 \\nAut\", \"horization .........................................................................................\", \"................................................................................. 84 \\nConfiguring Id\", \"entityServer to perform authorization ..............................................................\", \".............................. 85 \\nMaking access requests to APIs ..................................\", \"....................................................................................................\", \" 86 \\nSummary .......................................................................................\", \"........................................................................................... 87 \\nMVVM\", \" Toolkit Features ..................................................................................\", \"...................... 88 \\nMVVM Toolkit ............................................................\", \"....................................................................................................\", \"........ 88 \\nObservableObject ......................................................................\", \"........................................................................................... 89 \\nRela\", \"yCommand and AsyncRelayCommand .....................................................................\", \".......................................... 90 \\nSource Generators ...................................\", \"....................................................................................................\", \"......................... 91 \\nSummary ..............................................................\", \"....................................................................................................\", \"................ 93 \\nUnit testing ..................................................................\", \".......................................................... 94 \\nDependency injection and unit testing\", \" ...................................................................................................\", \"..................... 95 \\nTesting MVVM applications ................................................\", \".............................................................................................. 95 \\nT\", \"esting asynchronous functionality ..................................................................\", \"............................................................. 96 \\nTesting INotifyPropertyChanged imp\", \"lementations .......................................................................................\", \"......... 97 \\nTesting message-based communication ..................................................\", \"................................................................... 97 \\nTesting exception handling .\", \"....................................................................................................\", \"......................................... 98 \\nTesting validation ...................................\", \"....................................................................................................\", \"........................... 98 \\nSummary ............................................................\", \"....................................................................................................\", \".................. 99 \\n \\n1 \\nCHAPTER 1 | Purpose \\n \\nCHAPTER 1 \\nPurpose \\nThis eBook provides guidance \", \"on building cross-platform enterprise apps using .NET MAUI. .NET \\nMAUI is a cross-platform UI toolki\", \"t that allows developers to easily create native user interface layouts \\nthat can be shared across p\", \"latforms, including iOS, macOS, Android, and Windows. It provides a \\ncomprehensive solution for Busi\", \"ness to Employee (B2E), Business to Business (B2B), and Business to \\nConsumer (B2C) apps, providing \", \"the ability to share code across all target platforms and helping to \\nlower the total cost of owners\", \"hip (TCO). \\nThe guide provides architectural guidance for developing adaptable, maintainable, and te\", \"stable .NET \\nMAUI enterprise apps. Guidance is provided on how to implement MVVM, dependency injecti\", \"on, \\nnavigation, validation, and configuration management, while maintaining loose coupling. In addi\", \"tion, \\nthere\\u2019s also guidance on performing authentication and authorization with IdentityServer, acc\", \"essing \\ndata from containerized microservices, and unit testing. \\nThe guide comes with source code f\", \"or the eShop multi-platform app, and source code for the eShop \\nreference app. The eShop multi-platf\", \"orm app is a cross-platform enterprise app developed using .NET \\nMAUI, which connects to a series of\", \" containerized microservices known as the eShop reference app. \\nHowever, the eShop multi-platform ap\", \"p can be configured to consume data from mock services for \\nthose who wish to avoid deploying the co\", \"ntainerized microservices. \\nWhat\\u2019s left out of this guide\\u2019s scope \\nThis guide is aimed at readers wh\", \"o are already familiar with .NET MAUI. For a detailed introduction to \\n.NET MAUI, see the .NET MAUI \", \"documentation. \\nWho should use this guide \\nThe audience for this guide is mainly developers and arch\", \"itects who would like to learn how to \\narchitect and implement cross-platform enterprise apps using \", \".NET MAUI. \\nA secondary audience is technical decision-makers who would like to receive an architect\", \"ural and \\ntechnology overview before deciding on what approach to select for cross-platform enterpri\", \"se app \\ndevelopment using .NET MAUI. \\n \\n2 \\nCHAPTER 1 | Purpose \\n \\nHow to use this guide \\nThis guide \", \"focuses on building cross-platform enterprise apps using .NET MAUI. As such, it should be \\nread in i\", \"ts entirety to provide a foundation of understanding such apps and their technical \\nconsiderations. \", \"The guide and its sample app can also serve as a starting point or reference for \\ncreating a new ent\", \"erprise app. Use the associated sample app as a template for the new app or see \\nhow to organize an \", \"app\\u2019s component parts. Then, refer back to this guide for architectural guidance. \\nFeel free to forw\", \"ard this guide to team members to help ensure a common understanding of cross-\\nplatform enterprise a\", \"pp development using .NET MAUI. Having everybody working from a common \\nset of terminologies and und\", \"erlying principles will help ensure a consistent application of architectural \\npatterns and practice\", \"s. \\n \\n3 \\nCHAPTER 2 | Introduction to .NET MAUI \\n \\nCHAPTER 2 \\nIntroduction to .NET MAUI \\nRegardless o\", \"f platform, developers of enterprise apps face several challenges: \\n\\u2022 \\nApp requirements that can cha\", \"nge over time. \\n\\u2022 \\nNew business opportunities and challenges. \\n\\u2022 \\nOngoing feedback during developmen\", \"t that can significantly affect the scope and \\nrequirements of the app. \\nWith these in mind, it\\u2019s im\", \"portant to build apps that can be easily modified or extended over time. \\nDesigning for such adaptab\", \"ility can be difficult as it requires an architecture that allows individual \\nparts of the app to be\", \" independently developed and tested in isolation without affecting the rest of \\nthe app. \\nMany enter\", \"prise apps are sufficiently complex to require more than one developer. It can be a \\nsignificant cha\", \"llenge to decide how to design an app so that multiple developers can work effectively \\non different\", \" pieces of the app independently, while ensuring that the pieces come together seamlessly \\nwhen inte\", \"grated into the app. \\nThe traditional approach to designing and building an app results in what is r\", \"eferred to as a \\nmonolithic app, where components are tightly coupled with no clear separation betwe\", \"en them. \\nTypically, this monolithic approach leads to apps that are difficult and inefficient to ma\", \"intain, because \\nit can be difficult to resolve bugs without breaking other components in the app, a\", \"nd it can be \\ndifficult to add new features or to replace existing features. \\nAn effective remedy fo\", \"r these challenges is to partition an app into discrete, loosely coupled \\ncomponents that can be eas\", \"ily integrated together into an app. Such an approach offers several \\nbenefits: \\n\\u2022 \\nIt allows indivi\", \"dual functionality to be developed, tested, extended, and maintained by \\ndifferent individuals or te\", \"ams. \\n\\u2022 \\nIt promotes reuse and a clean separation of concerns between the app\\u2019s horizontal \\ncapabili\", \"ties, such as authentication and data access, and the vertical capabilities, such as app \\nspecific b\", \"usiness functionality. This allows the dependencies and interactions between app \\ncomponents to be m\", \"ore easily managed. \\n\\u2022 \\nIt helps maintain a separation of roles by allowing different individuals, o\", \"r teams, to focus on \\na specific task or piece of functionality according to their expertise. In par\", \"ticular, it provides a \\ncleaner separation between the user interface and the app\\u2019s business logic. \", \"\\nHowever, there are many issues that must be resolved when partitioning an app into discrete, loosel\", \"y \\ncoupled components. These include: \\n \\n4 \\nCHAPTER 2 | Introduction to .NET MAUI \\n \\n\\u2022 \\nDeciding how\", \" to provide a clean separation of concerns between the user interface controls \\nand their logic. One\", \" of the most important decisions when creating a .NET MAUI enterprise \\napp is whether to place busin\", \"ess logic in code-behind files, or whether to create a clean \\nseparation of concerns between the use\", \"r interface controls and their logic, in order to make \\nthe app more maintainable and testable. For \", \"more information, see Model-View-ViewModel. \\n\\u2022 \\nDetermining whether to use a dependency injection co\", \"ntainer. Dependency injection \\ncontainers reduce the dependency coupling between objects by providin\", \"g a facility to \\nconstruct instances of classes with their dependencies injected, and manage their l\", \"ifetime \\nbased on the configuration of the container. For more information, see Dependency injection\", \". \\n\\u2022 \\nChoosing between platform provided eventing and loosely coupled message-based \\ncommunication b\", \"etween components that are inconvenient to link by object and type \\nreferences. For more information\", \", see Introduction to Communicating between loosely \\ncoupled components. \\n\\u2022 \\nDeciding how to navigat\", \"e between pages, including how to invoke navigation, and where \\nnavigation logic should reside. For \", \"more information, see Navigation. \\n\\u2022 \\nDetermining how to validate user input for correctness. The de\", \"cision must include how to \\nvalidate user input, and how to notify the user about validation errors.\", \" For more information, \\nsee Validation. \\n\\u2022 \\nDeciding how to perform authentication, and how to prote\", \"ct resources with authorization. For \\nmore information, see Authentication and authorization. \\n\\u2022 \\nDe\", \"termining how to access remote data from web services, including how to reliably retrieve \\ndata, and\", \" how to cache data. For more information, see Accessing remote data. \\n\\u2022 \\nDeciding how to test the ap\", \"p. For more information, see Unit testing. \\nThis guide provides guidance on these issues, and focuse\", \"s on the core patterns and architecture for \\nbuilding a cross-platform enterprise app using .NET MAU\", \"I. The guidance aims to help to produce \\nadaptable, maintainable, and testable code, by addressing c\", \"ommon .NET MAUI enterprise app \\ndevelopment scenarios, and by separating the concerns of presentatio\", \"n, presentation logic, and \\nentities through support for the Model-View-ViewModel (MVVM) pattern. \\nS\", \"ample application \\nThis guide includes a sample application, eShop, that\\u2019s an online store that incl\", \"udes the following \\nfunctionality: \\n\\u2022 \\nAuthenticating and authorizing against a backend service. \\n\\u2022 \", \"\\nBrowsing a catalog of items. \\n\\u2022 \\nFiltering the catalog. \\n\\u2022 \\nOrdering items from the catalog. \\n\\u2022 \\nVi\", \"ewing the user\\u2019s order history. \\n\\u2022 \\nConfiguration of settings. \\n \\n5 \\nCHAPTER 2 | Introduction to .NE\", \"T MAUI \\n \\nSample application architecture \\nBelow is a high-level overview of the architecture of the\", \" sample application. \\n \\nThe sample application ships with: \\n\\u2022 \\n.NET Aspire App Hosting & Orchestrati\", \"on \\n\\u2022 \\nAn Blazor web application developed with ASP.NET Core. \\n\\u2022 \\nA multi-platform app developed wit\", \"h .NET MAUI, which supports iOS, Android, macOS via \\nMac Catalyst, and Windows. \\nThe sample applicat\", \"ion includes the following backend services: \\n\\u2022 \\nAn identity microservice, which uses ASP.NET Core I\", \"dentity and IdentityServer. \\n\\u2022 \\nA catalog microservice, which is a data-driven create, read, update,\", \" delete (CRUD) service that \\nconsumes an SQL Server database using EntityFramework Core. \\n\\u2022 \\nAn orde\", \"ring microservice, which is a domain-driven service that uses domain-driven design \\npatterns. \\n\\u2022 \\nA \", \"basket microservice, which is a data-driven CRUD service that uses Redis Cache. \\nThese backend servi\", \"ces are implemented as microservices using ASP.NET Core, and are deployed as \\nunique containers with\", \" .NET Aspire. Collectively, these backend services are referred to as the eShop \\nreference applicati\", \"on. Client apps communicate with the backend services through a Representational \\nState Transfer (RE\", \"ST) web interface. For more information about microservices and conainers, see \\nContainerized micros\", \"ervices. \\n \\n6 \\nCHAPTER 2 | Introduction to .NET MAUI \\n \\nMulti-Platform app \\nThis guide focuses on bu\", \"ilding cross-platform enterprise apps using .NET MAUI, and uses the eShop \\nmulti-platform app as an \", \"example. The image below shows the pages from the eShop multi-platform \\napp that provide the functio\", \"nality outlined earlier. \\n \\nThe multi-platform app consumes the backend services provided by the eSh\", \"op reference application. \\nHowever, it can be configured to consume data from mock services for thos\", \"e who wish to avoid \\ndeploying the backend services. \\nThe eShop multi-platform app exercises the fol\", \"lowing .NET MAUI functionality: \\n \\n7 \\nCHAPTER 2 | Introduction to .NET MAUI \\n \\n\\u2022 \\nXAML \\n\\u2022 \\nControls \", \"\\n\\u2022 \\nBindings \\n\\u2022 \\nConverters \\n\\u2022 \\nStyles \\n\\u2022 \\nAnimations \\n\\u2022 \\nCommands \\n\\u2022 \\nBehaviors \\n\\u2022 \\nTriggers \\n\\u2022 \\nEf\", \"fects \\n\\u2022 \\nCustom Controls \\nFor more information about this functionality, see the .NET MAUI document\", \"ation. \\nIn addition, unit tests are provided for some of the classes in the eShop multi-platform app\", \". \\nMulti-Platform app solution \\nThe eShop multi-platform app solution organizes the source code and \", \"other resources into a multiple \\nprojects. All of the core mobile components are contained in a sing\", \"ular project named \\neShopContainers. This is a feature introduced with .NET 6 that allows a project \", \"to target multiple \\noutputs which helps eliminate the need for multiple platform projects that we wo\", \"uld have used in \\nXamarin.Forms and earlier .NET versions. An additional project is included for uni\", \"t testing. \\nWhile this project has all of its components stored in a singular project, it is worth c\", \"onsidering \\nseparating it into multiple projects based on your needs. For example, if you have multi\", \"ple \\nimplementations of service providers based off of a service with their own dependencies, it may\", \" make \\nsense to break those service provider implementations out into their own separate project. Go\", \"od \\ncandidates for project separation include shared models, service implementations, api client \\nco\", \"mponents, database or caching layers. Any place where you feel that the business could re-use a \\ncom\", \"ponent in another project is a potential candidate for separation. These projects can then be \\npacka\", \"ged via NuGet for easy distribution and versioning. \\nAll of the projects use folders to organize the\", \" source code and other resources into categories. The \\nclasses from the eShop multi-platform app can\", \" be re-used in any .NET MAUI app with little or no \\nmodification. \\neShop project \\nThe eShop project \", \"contains the following folders: \\nFolder \\nDescription \\nAnimations \\nContains classes that enable anima\", \"tions to be consumed in XAML. \\nBehaviors \\nContains behaviors that are exposed to view classes. \\n \\n8 \", \"\\nCHAPTER 2 | Introduction to .NET MAUI \\n \\nFolder \\nDescription \\nControls \\nContains custom controls us\", \"ed by the app. \\nConverters \\nContains value converters that apply custom logic to a binding. \\nExcepti\", \"ons \\nContains the custom ServiceAuthenticationException. \\nExtensions \\nContains extension methods for\", \" the VisualElement and IEnumerable<T> classes. \\nHelpers \\nContains helper classes for the app. \\nModel\", \"s \\nContains the model classes for the app. \\nProperties \\nContains AssemblyInfo.cs, a .NET assembly me\", \"tadata file. \\nServices \\nContains interfaces and classes that implement services that are provided to\", \" the \\napp. \\nTriggers \\nContains the BeginAnimation trigger, which is used to invoke an animation in X\", \"AML. \\nValidations \\nContains classes involved in validating data input. \\nViewModels \\nContains the app\", \"lication logic that\\u2019s exposed to pages. \\nViews \\nContains the pages for the app. \\nSummary \\nMicrosoft\\u2019\", \"s cross-platform multi-platform app development tools and platforms provide a \\ncomprehensive solutio\", \"n for B2E, B2B, and B2C mobile client apps, providing the ability to share code \\nacross all target p\", \"latforms (iOS, macOS, Android, and Windows) and helping to lower the total cost of \\nownership. Apps \", \"can share their user interface and app logic code, while retaining the native platform \\nlook and fee\", \"l. \\nDevelopers of enterprise apps face several challenges that can alter the architecture of the app\", \" during \\ndevelopment. Therefore, it\\u2019s important to build an app so that it can be modified or extend\", \"ed over \\ntime. Designing for such adaptability can be difficult, but typically involves partitioning\", \" an app into \\ndiscrete, loosely coupled components that can be easily integrated together into an ap\", \"p. \\n \\n9 \\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n \\nCHAPTER 3 \\nModel-View-ViewModel \\n(MVVM) \\nThe .NE\", \"T MAUI developer experience typically involves creating a user interface in XAML, and then \\nadding c\", \"ode-behind that operates on the user interface. Complex maintenance issues can arise as \\napps are mo\", \"dified and grow in size and scope. These issues include the tight coupling between the UI \\ncontrols \", \"and the business logic, which increases the cost of making UI modifications, and the difficulty \\nof \", \"unit testing such code. \\nThe MVVM pattern helps cleanly separate an application\\u2019s business and prese\", \"ntation logic from its \\nuser interface (UI). Maintaining a clean separation between application logi\", \"c and the UI helps address \\nnumerous development issues and makes an application easier to test, mai\", \"ntain, and evolve. It can \\nalso significantly improve code re-use opportunities and allows developer\", \"s and UI designers to \\ncollaborate more easily when developing their respective parts of an app. \\nTh\", \"e MVVM pattern \\nThere are three core components in the MVVM pattern: the model, the view, and the vi\", \"ew model. \\nEach serves a distinct purpose. The diagram below shows the relationships between the thr\", \"ee \\ncomponents. \\n \\nIn addition to understanding the responsibilities of each component, it\\u2019s also im\", \"portant to understand \\nhow they interact. At a high level, the view \\u201cknows about\\u201d the view model, an\", \"d the view model \\u201cknows \\nabout\\u201d the model, but the model is unaware of the view model, and the view \", \"model is unaware of the \\nview. Therefore, the view model isolates the view from the model, and allow\", \"s the model to evolve \\nindependently of the view. \\nThe benefits of using the MVVM pattern are as fol\", \"lows: \\n \\n10 \\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n \\n\\u2022 \\nIf an existing model implementation encap\", \"sulates existing business logic, it can be difficult or \\nrisky to change it. In this scenario, the v\", \"iew model acts as an adapter for the model classes \\nand prevents you from making major changes to th\", \"e model code. \\n\\u2022 \\nDevelopers can create unit tests for the view model and the model, without using t\", \"he view. \\nThe unit tests for the view model can exercise exactly the same functionality as used by t\", \"he \\nview. \\n\\u2022 \\nThe app UI can be redesigned without touching the view model and model code, provided \", \"\\nthat the view is implemented entirely in XAML or C#. Therefore, a new version of the view \\nshould w\", \"ork with the existing view model. \\n\\u2022 \\nDesigners and developers can work independently and concurrent\", \"ly on their components \\nduring development. Designers can focus on the view, while developers can wo\", \"rk on the view \\nmodel and model components. \\nThe key to using MVVM effectively lies in understanding\", \" how to factor app code into the correct \\nclasses and how the classes interact. The following sectio\", \"ns discuss the responsibilities of each of the \\nclasses in the MVVM pattern. \\nView \\nThe view is resp\", \"onsible for defining the structure, layout, and appearance of what the user sees on \\nscreen. Ideally\", \", each view is defined in XAML, with a limited code-behind that does not contain \\nbusiness logic. Ho\", \"wever, in some cases, the code-behind might contain UI logic that implements \\nvisual behavior that i\", \"s difficult to express in XAML, such as animations. \\nIn a .NET MAUI application, a view is typically\", \" a ContentPage-derived or ContentView-derived class. \\nHowever, views can also be represented by a da\", \"ta template, which specifies the UI elements to be \\nused to visually represent an object when it\\u2019s d\", \"isplayed. A data template as a view does not have any \\ncode-behind, and is designed to bind to a spe\", \"cific view model type. \\nTip \\nAvoid enabling and disabling UI elements in the code-behind. \\nEnsure th\", \"at the view models are responsible for defining logical state changes that affect some \\naspects of t\", \"he view\\u2019s display, such as whether a command is available, or an indication that an \\noperation is pe\", \"nding. Therefore, enable and disable UI elements by binding to view model properties, \\nrather than e\", \"nabling and disabling them in code-behind. \\nThere are several options for executing code on the view\", \" model in response to interactions on the \\nview, such as a button click or item selection. If a cont\", \"rol supports commands, the control\\u2019s Command \\nproperty can be data-bound to an ICommand property on \", \"the view model. When the control\\u2019s \\ncommand is invoked, the code in the view model will be executed.\", \" In addition to commands, \\nbehaviors can be attached to an object in the view and can listen for eit\", \"her a command to be invoked \\nor the event to be raised. In response, the behavior can then invoke an\", \" ICommand on the view model \\nor a method on the view model. \\n \\n11 \\nCHAPTER 3 | Model-View-ViewModel \", \"(MVVM) \\n \\nViewModel \\nThe view model implements properties and commands to which the view can data bi\", \"nd to, and \\nnotifies the view of any state changes through change notification events. The propertie\", \"s and \\ncommands that the view model provides define the functionality to be offered by the UI, but t\", \"he view \\ndetermines how that functionality is to be displayed. \\nTip \\nKeep the UI responsive with asy\", \"nchronous operations. \\nMulti-platform apps should keep the UI thread unblocked to improve the user\\u2019s\", \" perception of \\nperformance. Therefore, in the view model, use asynchronous methods for I/O operatio\", \"ns and raise \\nevents to asynchronously notify views of property changes. \\nThe view model is also res\", \"ponsible for coordinating the view\\u2019s interactions with any model classes that \\nare required. There\\u2019s\", \" typically a one-to-many relationship between the view model and the model \\nclasses. The view model \", \"might choose to expose model classes directly to the view so that controls in \\nthe view can data bin\", \"d directly to them. In this case, the model classes will need to be designed to \\nsupport data bindin\", \"g and change notification events. \\nEach view model provides data from a model in a form that the vie\", \"w can easily consume. To \\naccomplish this, the view model sometimes performs data conversion. Placin\", \"g this data conversion in \\nthe view model is a good idea because it provides properties that the vie\", \"w can bind to. For example, \\nthe view model might combine the values of two properties to make it ea\", \"sier to display by the view. \\nTip \\nCentralize data conversions in a conversion layer. \\nIt\\u2019s also pos\", \"sible to use converters as a separate data conversion layer that sits between the view \\nmodel and th\", \"e view. This can be necessary, for example, when data requires special formatting that \\nthe view mod\", \"el doesn\\u2019t provide. \\nIn order for the view model to participate in two-way data binding with the vie\", \"w, its properties must \\nraise the PropertyChanged event. View models satisfy this requirement by imp\", \"lementing the \\nINotifyPropertyChanged interface, and raising the PropertyChanged event when a proper\", \"ty is \\nchanged. \\nFor collections, the view-friendly ObservableCollection<T> is provided. This collec\", \"tion implements \\ncollection changed notification, relieving the developer from having to implement t\", \"he \\nINotifyCollectionChanged interface on collections. \\nModel \\nModel classes are non-visual classes \", \"that encapsulate the app\\u2019s data. Therefore, the model can be \\nthought of as representing the app\\u2019s d\", \"omain model, which usually includes a data model along with \\nbusiness and validation logic. Examples\", \" of model objects include data transfer objects (DTOs), Plain \\nOld CLR Objects (POCOs), and generate\", \"d entity and proxy objects. \\n \\n12 \\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n \\nModel classes are typi\", \"cally used in conjunction with services or repositories that encapsulate data \\naccess and caching. \\n\", \"Connecting view models to views \\nView models can be connected to views by using the data-binding cap\", \"abilities of .NET MAUI. There \\nare many approaches that can be used to construct views and view mode\", \"ls and associate them at \\nruntime. These approaches fall into two categories, known as view first co\", \"mposition, and view model \\nfirst composition. Choosing between view first composition and view model\", \" first composition is an \\nissue of preference and complexity. However, all approaches share the same\", \" aim, which is for the view \\nto have a view model assigned to its BindingContext property. \\nWith vie\", \"w first composition the app is conceptually composed of views that connect to the view \\nmodels they \", \"depend on. The primary benefit of this approach is that it makes it easy to construct \\nloosely coupl\", \"ed, unit testable apps because the view models have no dependence on the views \\nthemselves. It\\u2019s als\", \"o easy to understand the structure of the app by following its visual structure, \\nrather than having\", \" to track code execution to understand how classes are created and associated. In \\naddition, view fi\", \"rst construction aligns with the Microsoft Maui\\u2019s navigation system that\\u2019s responsible \\nfor construc\", \"ting pages when navigation occurs, which makes a view model first composition complex \\nand misaligne\", \"d with the platform. \\nWith view model first composition, the app is conceptually composed of view mo\", \"dels, with a service \\nresponsible for locating the view for a view model. View model first compositi\", \"on feels more natural to \\nsome developers, since the view creation can be abstracted away, allowing \", \"them to focus on the \\nlogical non-UI structure of the app. In addition, it allows view models to be \", \"created by other view \\nmodels. However, this approach is often complex, and it can become difficult \", \"to understand how the \\nvarious parts of the app are created and associated. \\nTip \\nKeep view models a\", \"nd views independent. \\nThe binding of views to a property in a data source should be the view\\u2019s prin\", \"cipal dependency on its \\ncorresponding view model. Specifically, don\\u2019t reference view types, such as\", \" Button and ListView, from \\nview models. By following the principles outlined here, view models can \", \"be tested in isolation, \\ntherefore reducing the likelihood of software defects by limiting scope. \\nT\", \"he following sections discuss the main approaches to connecting view models to views. \\nCreating a vi\", \"ew model declaratively \\nThe simplest approach is for the view to declaratively instantiate its corre\", \"sponding view model in \\nXAML. When the view is constructed, the corresponding view model object will\", \" also be constructed. \\nThis approach is demonstrated in the following code example: \\n<ContentPage xm\", \"lns:local=\\\"clr-namespace:eShop\\\"> \\n    <ContentPage.BindingContext> \\n \\n13 \\nCHAPTER 3 | Model-View-Vie\", \"wModel (MVVM) \\n \\n        <local:LoginViewModel /> \\n    </ContentPage.BindingContext> \\n    <!-- Omitt\", \"ed for brevity... --> \\n</ContentPage> \\nWhen the ContentPage is created, an instance of the LoginView\", \"Model is automatically constructed \\nand set as the view\\u2019s BindingContext. \\nThis declarative construc\", \"tion and assignment of the view model by the view has the advantage that \\nit\\u2019s simple, but has the d\", \"isadvantage that it requires a default (parameter-less) constructor in the view \\nmodel. \\nCreating a \", \"view model programmatically \\nA view can have code in the code-behind file, resulting in the view-mod\", \"el being assigned to its \\nBindingContext property. This is often accomplished in the view\\u2019s construc\", \"tor, as shown in the \\nfollowing code example: \\npublic LoginView() \\n{ \\n    InitializeComponent(); \\n  \", \"  BindingContext = new LoginViewModel(navigationService); \\n} \\nThe programmatic construction and assi\", \"gnment of the view model within the view\\u2019s code-behind has \\nthe advantage that it\\u2019s simple. However,\", \" the main disadvantage of this approach is that the view \\nneeds to provide the view model with any r\", \"equired dependencies. Using a dependency injection \\ncontainer can help to maintain loose coupling be\", \"tween the view and view model. For more \\ninformation, see Dependency injection. \\nUpdating views in r\", \"esponse to changes in the \\nunderlying view model or model \\nAll view model and model classes that are\", \" accessible to a view should implement the \\n[INotifyPropertyChanged interface. Implementing this int\", \"erface in a view model or model class allows \\nthe class to provide change notifications to any data-\", \"bound controls in the view when the underlying \\nproperty value changes. \\nApp\\u2019s should be architected\", \" for the correct use of property change notification, by meeting the \\nfollowing requirements: \\n\\u2022 \\nAl\", \"ways raising a PropertyChanged event if a public property\\u2019s value changes. Do not assume \\nthat raisi\", \"ng the PropertyChanged event can be ignored because of knowledge of how XAML \\nbinding occurs. \\n\\u2022 \\nAl\", \"ways raising a PropertyChanged event for any calculated properties whose values are used \\nby other p\", \"roperties in the view model or model. \\n\\u2022 \\nAlways raising the PropertyChanged event at the end of the\", \" method that makes a property \\nchange, or when the object is known to be in a safe state. Raising th\", \"e event interrupts the \\n \\n14 \\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n \\noperation by invoking the e\", \"vent\\u2019s handlers synchronously. If this happens in the middle of an \\noperation, it might expose the o\", \"bject to callback functions when it is in an unsafe, partially \\nupdated state. In addition, it\\u2019s pos\", \"sible for cascading changes to be triggered by \\nPropertyChanged events. Cascading changes generally \", \"require updates to be complete before \\nthe cascading change is safe to execute. \\n\\u2022 \\nNever raising a \", \"PropertyChanged event if the property does not change. This means that you \\nmust compare the old and\", \" new values before raising the PropertyChanged event. \\n\\u2022 \\nNever raising the PropertyChanged event du\", \"ring a view model\\u2019s constructor if you are \\ninitializing a property. Data-bound controls in the view\", \" will not have subscribed to receive \\nchange notifications at this point. \\n\\u2022 \\nNever raising more tha\", \"n one PropertyChanged event with the same property name argument \\nwithin a single synchronous invoca\", \"tion of a public method of a class. For example, given a \\nNumberOfItems property whose backing store\", \" is the _numberOfItems field, if a method \\nincrements _numberOfItems fifty times during the executio\", \"n of a loop, it should only raise \\nproperty change notification on the NumberOfItems property once, \", \"after all the work is \\ncomplete. For asynchronous methods, raise the PropertyChanged event for a giv\", \"en property \\nname in each synchronous segment of an asynchronous continuation chain. \\nA simple way t\", \"o provide this functionality would be to create an extension of the BindableObject class. \\nIn this e\", \"xample, the ExtendedBindableObject class provides change notifications, which is shown in \\nthe follo\", \"wing code example: \\npublic abstract class ExtendedBindableObject : BindableObject \\n{ \\n    public voi\", \"d RaisePropertyChanged<T>(Expression<Func<T>> property) \\n    { \\n        var name = GetMemberInfo(pro\", \"perty).Name; \\n        OnPropertyChanged(name); \\n    } \\n \\n    private MemberInfo GetMemberInfo(Expres\", \"sion expression) \\n    { \\n        // Omitted for brevity ... \\n    } \\n} \\n.NET MAUI\\u2019s BindableObject cl\", \"ass implements the INotifyPropertyChanged interface, and provides an \\nOnPropertyChanged method. The \", \"ExtendedBindableObject class provides the RaisePropertyChanged \\nmethod to invoke property change not\", \"ification, and in doing so uses the functionality provided by the \\nBindableObject class. \\nView model\", \" classes can then derive from the ExtendedBindableObject class. Therefore, each view \\nmodel class us\", \"es the RaisePropertyChanged method in the ExtendedBindableObject class to provide \\nproperty change n\", \"otification. The following code example shows how the eShop multi-platform app \\ninvokes property cha\", \"nge notification by using a lambda expression: \\npublic bool IsLogin \\n{ \\n    get => _isLogin; \\n    se\", \"t \\n    { \\n        _isLogin = value; \\n        RaisePropertyChanged(() => IsLogin); \\n \\n15 \\nCHAPTER 3 |\", \" Model-View-ViewModel (MVVM) \\n \\n    } \\n} \\nUsing a lambda expression in this way involves a small per\", \"formance cost because the lambda \\nexpression has to be evaluated for each call. Although the perform\", \"ance cost is small and would not \\ntypically impact an app, the costs can accrue when there are many \", \"change notifications. However, the \\nbenefit of this approach is that it provides compile-time type s\", \"afety and refactoring support when \\nrenaming properties. \\nMVVM Frameworks \\nThe MVVM pattern is well \", \"established in .NET, and the community has created many frameworks \\nwhich help ease this development\", \". Each framework provides a different set of features, but it is \\nstandard for them to provide a com\", \"mon view model with an implementation of the \\nINotifyPropertyChanged interface. Additional features \", \"of MVVM frameworks include custom \\ncommands, navigation helpers, dependency injection/service locato\", \"r components, and UI platform \\nintegration. While it is not necessary to use these frameworks, they \", \"can speed up and standardize \\nyour development. The eShop multi-platform app uses the .NET Community\", \" MVVM Toolkit. When \\nchoosing a framework, you should consider your application\\u2019s needs and your tea\", \"m\\u2019s strengths. The \\nlist below includes some of the more common MVVM frameworks for .NET MAUI. \\n\\u2022 \\n.\", \"NET Community MVVM Toolkit \\n\\u2022 \\nReactiveUI \\n\\u2022 \\nPrism Library \\nUI interaction using commands and behav\", \"iors \\nIn multi-platform apps, actions are typically invoked in response to a user action, such as a \", \"button \\nclick, that can be implemented by creating an event handler in the code-behind file. However\", \", in the \\nMVVM pattern, the responsibility for implementing the action lies with the view model, and\", \" placing \\ncode in the code-behind should be avoided. \\nCommands provide a convenient way to represent\", \" actions that can be bound to controls in the UI. \\nThey encapsulate the code that implements the act\", \"ion and help to keep it decoupled from its visual \\nrepresentation in the view. This way, your view m\", \"odels become more portable to new platforms, as \\nthey do not have a direct dependency on events prov\", \"ided by the platform\\u2019s UI framework. .NET MAUI \\nincludes controls that can be declaratively connecte\", \"d to a command, and these controls will invoke \\nthe command when the user interacts with the control\", \". \\nBehaviors also allow controls to be declaratively connected to a command. However, behaviors can \", \"be \\nused to invoke an action that\\u2019s associated with a range of events raised by a control. Therefore\", \", \\nbehaviors address many of the same scenarios as command-enabled controls, while providing a \\ngrea\", \"ter degree of flexibility and control. In addition, behaviors can also be used to associate command \", \"\\nobjects or methods with controls that were not specifically designed to interact with commands. \\n \\n\", \"16 \\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n \\nImplementing commands \\nView models typically expose p\", \"ublic properties, for binding from the view, which implement the \\nICommand interface. Many .NET MAUI\", \" controls and gestures provide a Command property, which can \\nbe data bound to an ICommand object pr\", \"ovided by the view model. The button control is one of the \\nmost commonly used controls, providing a\", \" command property that executes when the button is \\nclicked. \\nNote \\nWhile it\\u2019s possible to expose th\", \"e actual implementation of the ICommand interface that your view \\nmodel uses (for example, Command<T\", \"> or RelayCommand), it is recommended to expose your \\ncommands publicly as ICommand. This way, if yo\", \"u ever need to change the implementation at a later \\ndate, it can easily be swapped out. \\nThe IComma\", \"nd interface defines an Execute method, which encapsulates the operation itself, a \\nCanExecute metho\", \"d, which indicates whether the command can be invoked, and a \\nCanExecuteChanged event that occurs wh\", \"en changes occur that affect whether the command should \\nexecute. In most cases, we will only supply\", \" the Execute method for our commands. For a more \\ndetailed overview of ICommand, refer to the Comman\", \"ding documentation for .NET MAUI. \\nProvided with .NET MAUI are the Command and Command<T> classes th\", \"at implement the \\nICommand interface, where T is the type of the arguments to Execute and CanExecute\", \". Command and \\nCommand<T> are basic implementations that provide the minimal set of functionality ne\", \"eded for the \\nICommand interface. \\nNote \\nMany MVVM frameworks offer more feature rich implementation\", \"s of the ICommand interface. \\nThe Command or Command<T> constructor requires an Action callback obje\", \"ct that\\u2019s called when the \\nICommand.Execute method is invoked. The CanExecute method is an optional \", \"constructor parameter, \\nand is a Func that returns a bool. \\nThe eShop multi-platform app uses the Re\", \"layCommand and AsyncRelayCommand. The primary \\nbenefit for modern applications is that the AsyncRela\", \"yCommand provides better functionality for \\nasynchronous operations. \\nThe following code shows how a\", \" Command instance, which represents a register command, is \\nconstructed by specifying a delegate to \", \"the Register view model method: \\npublic ICommand RegisterCommand { get; } \\nThe command is exposed to\", \" the view through a property that returns a reference to an ICommand. \\nWhen the Execute method is ca\", \"lled on the Command object, it simply forwards the call to the method \\nin the view model via the del\", \"egate that was specified in the Command constructor. An asynchronous \\nmethod can be invoked by a com\", \"mand by using the async and await keywords when specifying the \\ncommand\\u2019s Execute delegate. This ind\", \"icates that the callback is a Task and should be awaited. For \\n \\n17 \\nCHAPTER 3 | Model-View-ViewMode\", \"l (MVVM) \\n \\nexample, the following code shows how an ICommand instance, which represents a sign-in c\", \"ommand, \\nis constructed by specifying a delegate to the SignInAsync view model method: \\npublic IComm\", \"and SignInCommand { get; } \\n... \\nSignInCommand = new AsyncRelayCommand(async () => await SignInAsync\", \"()); \\nParameters can be passed to the Execute and CanExecute actions by using the \\nAsyncRelayCommand\", \"<T> class to instantiate the command. For example, the following code shows \\nhow an AsyncRelayComman\", \"d<T> instance is used to indicate that the NavigateAsync method will \\nrequire an argument of type st\", \"ring: \\npublic ICommand NavigateCommand { get; } \\n \\n... \\nNavigateCommand = new AsyncRelayCommand<stri\", \"ng>(NavigateAsync); \\nIn both the RelayCommand and RelayCommand<T> classes, the delegate to the CanEx\", \"ecute method \\nin each constructor is optional. If a delegate isn\\u2019t specified, the Command will retur\", \"n true for \\nCanExecute. However, the view model can indicate a change in the command\\u2019s CanExecute st\", \"atus by \\ncalling the ChangeCanExecute method on the Command object. This causes the CanExecuteChange\", \"d \\nevent to be raised. Any UI controls bound to the command will then update their enabled status to\", \" \\nreflect the availability of the data-bound command. \\nInvoking commands from a view \\nThe following \", \"code example shows how a Grid in the LoginView binds to the RegisterCommand in the \\nLoginViewModel c\", \"lass by using a TapGestureRecognizer instance: \\n<Grid Grid.Column=\\\"1\\\" HorizontalOptions=\\\"Center\\\"> \\n \", \"   <Label Text=\\\"REGISTER\\\" TextColor=\\\"Gray\\\"/> \\n    <Grid.GestureRecognizers> \\n        <TapGestureReco\", \"gnizer Command=\\\"{Binding RegisterCommand}\\\" NumberOfTapsRequired=\\\"1\\\" \\n/> \\n    </Grid.GestureRecognize\", \"rs> \\n</Grid> \\nA command parameter can also be optionally defined using the CommandParameter property\", \". The \\ntype of the expected argument is specified in the Execute and CanExecute target methods. The \", \"\\nTapGestureRecognizer will automatically invoke the target command when the user interacts with the \", \"\\nattached control. The CommandParameter, if provided, will be passed as the argument to the \\ncommand\", \"\\u2019s Execute delegate. \\nImplementing behaviors \\nBehaviors allow functionality to be added to UI contro\", \"ls without having to subclass them. Instead, the \\nfunctionality is implemented in a behavior class a\", \"nd attached to the control as if it was part of the \\ncontrol itself. Behaviors enable you to impleme\", \"nt code that you would typically have to write as code-\\nbehind, because it directly interacts with t\", \"he API of the control, in such a way that it can be concisely \\n \\n18 \\nCHAPTER 3 | Model-View-ViewMode\", \"l (MVVM) \\n \\nattached to the control, and packaged for reuse across more than one view or app. In the\", \" context of \\nMVVM, behaviors are a useful approach for connecting controls to commands. \\nA behavior \", \"that\\u2019s attached to a control through attached properties is known as an attached behavior. \\nThe beha\", \"vior can then use the exposed API of the element to which it is attached to add functionality \\nto th\", \"at control, or other controls, in the visual tree of the view. \\nA .NET MAUI behavior is a class that\", \" derives from the Behavior or Behavior<T> class, where T is the \\ntype of the control to which the be\", \"havior should apply. These classes provide OnAttachedTo and \\nOnDetachingFrom methods, which should b\", \"e overridden to provide logic that will be executed when \\nthe behavior is attached to and detached f\", \"rom controls. \\nIn the eShop multi-platform app, the BindableBehavior<T> class derives from the Behav\", \"ior<T> class. \\nThe purpose of the BindableBehavior<T> class is to provide a base class for .NET MAUI\", \" behaviors that \\nrequire the BindingContext of the behavior to be set to the attached control. \\nThe \", \"BindableBehavior<T> class provides an overridable OnAttachedTo method that sets the \\nBindingContext \", \"of the behavior, and an overridable OnDetachingFrom method that cleans up the \\nBindingContext. \\nThe \", \"eShop multi-platform app includes an EventToCommandBehavior class which is provided by the \\nMAUI Com\", \"munity toolkit. EventToCommandBehavior executes a command in response to an event \\noccurring. This c\", \"lass derives from the BaseBehavior<View> class so that the behavior can bind to and \\nexecute an ICom\", \"mand specified by a Command property when the behavior is consumed. The \\nfollowing code example show\", \"s the EventToCommandBehavior class: \\n/// <summary> \\n/// The <see cref=\\\"EventToCommandBehavior\\\"/> is \", \"a behavior that allows the user to invoke a \\n<see cref=\\\"ICommand\\\"/> through an event. It is designed\", \" to associate Commands to events \\nexposed by controls that were not designed to support Commands. It\", \" allows you to map any \\narbitrary event on a control to a Command. \\n/// </summary> \\npublic class Eve\", \"ntToCommandBehavior : BaseBehavior<VisualElement> \\n{ \\n    // Omitted for brevity... \\n \\n    /// <inhe\", \"ritdoc/> \\n    protected override void OnAttachedTo(VisualElement bindable) \\n    { \\n        base.OnAt\", \"tachedTo(bindable); \\n        RegisterEvent(); \\n    } \\n \\n    /// <inheritdoc/> \\n    protected overrid\", \"e void OnDetachingFrom(VisualElement bindable) \\n    { \\n        UnregisterEvent(); \\n        base.OnDe\", \"tachingFrom(bindable); \\n    } \\n \\n    static void OnEventNamePropertyChanged(BindableObject bindable,\", \" object oldValue, object \\nnewValue) \\n        => ((EventToCommandBehavior)bindable).RegisterEvent(); \", \"\\n \\n    void RegisterEvent() \\n    { \\n \\n19 \\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n \\n        Unregis\", \"terEvent(); \\n \\n        var eventName = EventName; \\n        if (View is null || string.IsNullOrWhiteS\", \"pace(eventName)) \\n        { \\n            return; \\n        } \\n \\n        eventInfo = View.GetType()?.G\", \"etRuntimeEvent(eventName) ?? \\n            throw new ArgumentException($\\\"{nameof(EventToCommandBehavi\", \"or)}: Couldn't \\nresolve the event.\\\", nameof(EventName)); \\n \\n        ArgumentNullException.ThrowIfNul\", \"l(eventInfo.EventHandlerType); \\n        ArgumentNullException.ThrowIfNull(eventHandlerMethodInfo); \\n\", \" \\n        eventHandler = eventHandlerMethodInfo.CreateDelegate(eventInfo.EventHandlerType, \\nthis) ??\", \" \\n            throw new ArgumentException($\\\"{nameof(EventToCommandBehavior)}: Couldn't create \\nevent\", \" handler.\\\", nameof(EventName)); \\n \\n        eventInfo.AddEventHandler(View, eventHandler); \\n    } \\n \\n\", \"    void UnregisterEvent() \\n    { \\n        if (eventInfo is not null && eventHandler is not null) \\n \", \"       { \\n            eventInfo.RemoveEventHandler(View, eventHandler); \\n        } \\n \\n        eventI\", \"nfo = null; \\n        eventHandler = null; \\n    } \\n \\n    /// <summary> \\n    /// Virtual method that e\", \"xecutes when a Command is invoked \\n    /// </summary> \\n    /// <param name=\\\"sender\\\"></param> \\n    //\", \"/ <param name=\\\"eventArgs\\\"></param> \\n    [Microsoft.Maui.Controls.Internals.Preserve(Conditional = tr\", \"ue)] \\n    protected virtual void OnTriggerHandled(object? sender = null, object? eventArgs = \\nnull) \", \"\\n    { \\n        var parameter = CommandParameter \\n            ?? EventArgsConverter?.Convert(eventAr\", \"gs, typeof(object), null, null); \\n \\n        var command = Command; \\n        if (command?.CanExecute(\", \"parameter) ?? false) \\n        { \\n            command.Execute(parameter); \\n        } \\n    } \\n} \\nThe O\", \"nAttachedTo and OnDetachingFrom methods are used to register and deregister an event \\nhandler for th\", \"e event defined in the EventName property. Then, when the event fires, the \\nOnTriggerHandled method \", \"is invoked, which executes the command. \\n \\n20 \\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n \\nThe advant\", \"age of using the EventToCommandBehavior to execute a command when an event fires, is \\nthat commands \", \"can be associated with controls that weren\\u2019t designed to interact with commands. In \\naddition, this \", \"moves event-handling code to view models, where it can be unit tested. \\nInvoking behaviors from a vi\", \"ew \\nThe EventToCommandBehavior is particularly useful for attaching a command to a control that \\ndoe\", \"sn\\u2019t support commands. For example, the LoginView uses the EventToCommandBehavior to \\nexecute the Va\", \"lidateCommand when the user changes the value of their password, as shown in the \\nfollowing code: \\n<\", \"Entry \\n    IsPassword=\\\"True\\\" \\n    Text=\\\"{Binding Password.Value, Mode=TwoWay}\\\"> \\n    <!-- Omitted fo\", \"r brevity... --> \\n    <Entry.Behaviors> \\n        <mct:EventToCommandBehavior \\n            EventName=\", \"\\\"TextChanged\\\" \\n            Command=\\\"{Binding ValidateCommand}\\\" /> \\n    </Entry.Behaviors> \\n    <!-- \", \"Omitted for brevity... --> \\n</Entry> \\nAt runtime, the EventToCommandBehavior will respond to interac\", \"tion with the Entry. When a user \\ntypes into the Entry field, the TextChanged event will fire, which\", \" will execute the ValidateCommand in \\nthe LoginViewModel. By default, the event arguments for the ev\", \"ent are passed to the command. If \\nneeded, the EventArgsConverter property can be used to convert th\", \"e EventArgs provided by the event \\ninto a value that the command expects as input. \\nFor more informa\", \"tion about behaviors, see Behaviors on the .NET MAUI Developer Center. \\nSummary \\nThe Model-View-View\", \"Model (MVVM) pattern helps cleanly separate an application\\u2019s business and \\npresentation logic from i\", \"ts user interface (UI). Maintaining a clean separation between application \\nlogic and the UI helps a\", \"ddress numerous development issues and makes an application easier to test, \\nmaintain, and evolve. I\", \"t can also significantly improve code re-use opportunities and allows \\ndevelopers and UI designers t\", \"o collaborate more easily when developing their respective parts of an \\napp. \\nUsing the MVVM pattern\", \", the UI of the app and the underlying presentation and business logic are \\nseparated into three sep\", \"arate classes: the view, which encapsulates the UI and UI logic; the view \\nmodel, which encapsulates\", \" presentation logic and state; and the model, which encapsulates the app\\u2019s \\nbusiness logic and data.\", \" \\n \\n21 \\nCHAPTER 4 | Dependency injection \\n \\nCHAPTER 4 \\nDependency injection \\nTypically, a class cons\", \"tructor is invoked when instantiating an object, and any values that the object \\nneeds are passed as\", \" arguments to the constructor. This is an example of dependency injection known \\nas constructor inje\", \"ction. The dependencies the object needs are injected into the constructor. \\nBy specifying dependenc\", \"ies as interface types, dependency injection enables decoupling the concrete \\ntypes from the code th\", \"at depends on these types. It generally uses a container that holds a list of \\nregistrations and map\", \"pings between interfaces and abstract types, and the concrete types that \\nimplement or extend these \", \"types. \\nThere are also other types of dependency injection, such as property setter injection and me\", \"thod call \\ninjection, but they are less commonly seen. Therefore, this chapter will focus solely on \", \"performing \\nconstructor injection with a dependency injection container. \\nIntroduction to dependency\", \" injection \\nDependency injection is a specialized version of the Inversion of Control (IoC) pattern,\", \" where the \\nconcern being inverted is the process of obtaining the required dependency. With depende\", \"ncy \\ninjection, another class is responsible for injecting dependencies into an object at runtime. T\", \"he \\nfollowing code example shows how the ProfileViewModel class is structured when using dependency \", \"\\ninjection: \\nprivate readonly ISettingsService _settingsService; \\nprivate readonly IAppEnvironmentSe\", \"rvice _appEnvironmentService; \\n \\npublic ProfileViewModel( \\n    IAppEnvironmentService appEnvironment\", \"Service, \\n    IDialogService dialogService,  \\n    INavigationService navigationService,  \\n    ISetti\", \"ngsService settingsService) \\n    : base(dialogService, navigationService, settingsService) \\n{ \\n    _\", \"appEnvironmentService = appEnvironmentService; \\n    _settingsService = settingsService; \\n \\n    // Om\", \"itted for brevity \\n} \\nThe ProfileViewModel constructor receives multiple interface object instances \", \"as arguments injected \\nby another class. The only dependency in the ProfileViewModel class is on the\", \" interface types. \\nTherefore, the ProfileViewModel class doesn\\u2019t have any knowledge of the class tha\", \"t\\u2019s responsible for \\ninstantiating the interface objects. The class that\\u2019s responsible for instantia\", \"ting the interface objects, \\nand inserting it into the ProfileViewModel class, is known as the depen\", \"dency injection container. \\n \\n22 \\nCHAPTER 4 | Dependency injection \\n \\nDependency injection container\", \"s reduce the coupling between objects by providing a facility to \\ninstantiate class instances and ma\", \"nage their lifetime based on the configuration of the container. \\nDuring object creation, the contai\", \"ner injects any dependencies that the object requires into it. If those \\ndependencies have not yet b\", \"een created, the container creates and resolves their dependencies first. \\nThere are several advanta\", \"ges to using a dependency injection container: \\n\\u2022 \\nA container removes the need for a class to locat\", \"e its dependencies and manage its lifetimes. \\n\\u2022 \\nA container allows the mapping of implemented depen\", \"dencies without affecting the class. \\n\\u2022 \\nA container facilitates testability by allowing dependencie\", \"s to be mocked. \\n\\u2022 \\nA container increases maintainability by allowing new classes to be easily added\", \" to the app. \\nIn the context of a .NET MAUI app that uses MVVM, a dependency injection container wil\", \"l typically be \\nused for registering and resolving views, registering and resolving view models, and\", \" for registering \\nservices and injecting them into view models. \\nThere are many dependency injection\", \" containers available in .NET; the eShop multi-platform app uses \\nMicrosoft.Extensions.DependencyInj\", \"ection to manage the instantiation of views, view models, and \\nservice classes in the app. Microsoft\", \".Extensions.DependencyInjection facilitates building loosely \\ncoupled apps, and provides all of the \", \"features commonly found in dependency injection containers, \\nincluding methods to register type mapp\", \"ings and object instances, resolve objects, manage object \\nlifetimes, and inject dependent objects i\", \"nto constructors of objects that it resolves. For more \\ninformation about Microsoft.Extensions.Depen\", \"dencyInjection, see Dependency injection in .NET. \\nIn .NET MAUI, the MauiProgram class will call int\", \"o the CreateMauiApp method to create a \\nMauiAppBuilder object. The MauiAppBuilder object has a Servi\", \"ces property of type IServiceCollection, \\nwhich provides a place to register our components, such as\", \" views, view models, and services for \\ndependency injection. Any components registered with the Serv\", \"ices property will be provided to the \\ndependency injection container when the MauiAppBuilder.Build \", \"method is called. \\nAt runtime, the container must know which implementation of the services are bein\", \"g requested in \\norder to instantiate them for the requested objects. In the eShop multi-platform app\", \", the \\nIAppEnvironmentService, IDialogService , INavigationService, and ISettingsService interfaces \", \"need to \\nbe resolved before it can instantiate a ProfileViewModel object. This involves the containe\", \"r performing \\nthe following actions: \\n\\u2022 \\nDeciding how to instantiate an object that implements the i\", \"nterface. This is known as \\nregistration. \\n\\u2022 \\nInstantiating the object that implements the required \", \"interface and the ProfileViewModel \\nobject. This is known as resolution. \\nEventually, the app will f\", \"inish using the ProfileViewModel object, and it will become available for \\ngarbage collection. At th\", \"is point, the garbage collector should dispose of any short-lived interface \\nimplementations if othe\", \"r classes do not share the same instance. \\n \\n23 \\nCHAPTER 4 | Dependency injection \\n \\nRegistration \\nB\", \"efore dependencies can be injected into an object, the types of the dependencies must first be \\nregi\", \"stered with the container. Registering a type involves passing the container an interface and a \\ncon\", \"crete type that implements the interface. \\nThere are two ways of registering types and objects in th\", \"e container through code: \\n\\u2022 \\nRegister a type or mapping with the container. This is known as transi\", \"ent registration. When \\nrequired, the container will build an instance of the specified type. \\n\\u2022 \\nRe\", \"gister an existing object in the container as a singleton. When required, the container will \\nreturn\", \" a reference to the existing object. \\nNote \\nDependency injection containers are not always suitable.\", \" Dependency injection introduces additional \\ncomplexity and requirements that might not be appropria\", \"te or useful to small apps. If a class does not \\nhave any dependencies, or is not a dependency for o\", \"ther types, it might not make sense to put it in \\nthe container. In addition, if a class has a singl\", \"e set of dependencies that are integral to the type and \\nwill never change, it might not make sense \", \"to put it in the container. \\nThe registration of types requiring dependency injection should be perf\", \"ormed in a single method in \\nan app. This method should be invoked early in the app\\u2019s lifecycle to e\", \"nsure it is aware of the \\ndependencies between its classes. The eShop multi-platform app performs th\", \"is the \\nMauiProgram.CreateMauiApp method. The following code example shows how the eShop multi-\\nplat\", \"form app declares the CreateMauiApp in the MauiProgram class: \\npublic static class MauiProgram \\n{ \\n \", \"   public static MauiApp CreateMauiApp() \\n        => MauiApp.CreateBuilder() \\n            .UseMauiAp\", \"p<App>() \\n            // Omitted for brevity             \\n            .RegisterAppServices() \\n      \", \"      .RegisterViewModels() \\n            .RegisterViews() \\n            .Build(); \\n} \\nThe MauiApp.Cre\", \"ateBuilder method creates a MauiAppBuilder object that we can use to register our \\ndependencies. Man\", \"y dependencies in the eShop multi-platform app need to be registered, so the \\nextension methods Regi\", \"sterAppServices, RegisterViewModels, and RegisterViews were created to help \\nprovide an organized an\", \"d maintainable registration workflow. The following code shows the \\nRegisterViewModels method: \\npubl\", \"ic static MauiAppBuilder RegisterViewModels(this MauiAppBuilder mauiAppBuilder) \\n{ \\n    mauiAppBuild\", \"er.Services.AddSingleton<ViewModels.MainViewModel>(); \\n    mauiAppBuilder.Services.AddSingleton<View\", \"Models.LoginViewModel>(); \\n    mauiAppBuilder.Services.AddSingleton<ViewModels.BasketViewModel>(); \\n\", \"    mauiAppBuilder.Services.AddSingleton<ViewModels.CatalogViewModel>(); \\n    mauiAppBuilder.Service\", \"s.AddSingleton<ViewModels.ProfileViewModel>(); \\n \\n \\n24 \\nCHAPTER 4 | Dependency injection \\n \\n    maui\", \"AppBuilder.Services.AddTransient<ViewModels.CheckoutViewModel>(); \\n    mauiAppBuilder.Services.AddTr\", \"ansient<ViewModels.OrderDetailViewModel>(); \\n    mauiAppBuilder.Services.AddTransient<ViewModels.Set\", \"tingsViewModel>(); \\n    mauiAppBuilder.Services.AddTransient<ViewModels.CampaignViewModel>(); \\n    m\", \"auiAppBuilder.Services.AddTransient<ViewModels.CampaignDetailsViewModel>(); \\n \\n    return mauiAppBui\", \"lder; \\n} \\nThis method receives an instance of MauiAppBuilder, and we can use the Services property t\", \"o register \\nour view models. Depending on the needs of your application, you may need to add service\", \"s with \\ndifferent lifetimes. The following table provides information on when you may want to choose\", \" these \\ndifferent registration lifetimes: \\nMethod \\nDescription \\nAddSingleton<T> \\nWill create a singl\", \"e instance of the object which \\nwill be remain for the lifetime of the application. \\nAddTransient<T>\", \" \\nWill create a new instance of the object when \\nrequested during resolution. Transient objects \\ndo \", \"not have a pre-defined lifetime, but will \\ntypically follow the lifetime of their host. \\nNote \\nThe v\", \"iew models do not inherit from an interface, so they only need their concrete type provided to \\nthe \", \"AddSingleton<T> and AddTransient<T> methods. \\nThe CatalogViewModel is used near the application\\u2019s ro\", \"ot and should always be available, so \\nregistering it with AddSingleton<T> is beneficial. Other view\", \" models, such as CheckoutViewModel \\nand OrderDetailViewModel are situationally navigated to or are u\", \"sed later in the application. Suppose \\nyou know that you have a component that may not always be use\", \"d. In that case, if it is memory or \\ncomputationally intensive or requires just-in-time data, it may\", \" be a better candidate for \\nAddTransient<T> registration. \\nAnother common way to add services is usi\", \"ng the AddSingleton<TService, TImplementation> and \\nAddTransient<TService, TImplementation> methods.\", \" These methods take two input types: the \\ninterface definition and the concrete implementation. This\", \" type of registration is best for cases where \\nyou are implementing services based on interfaces. In\", \" the code example below, we register our \\nISettingsService interface using the SettingsService imple\", \"mentation: \\npublic static MauiAppBuilder RegisterAppServices(this MauiAppBuilder mauiAppBuilder) \\n{ \", \"\\n    mauiAppBuilder.Services.AddSingleton<ISettingsService, SettingsService>(); \\n    // Omitted for \", \"brevity... \\n} \\nOnce all services have been registered, the MauiAppBuilder.Build method should be cal\", \"led to create \\nour MauiApp and populate our dependency injection container with all the registered s\", \"ervices. \\n \\n25 \\nCHAPTER 4 | Dependency injection \\n \\nImportant \\nOnce the Build method has been called\", \", the dependency injection container is immutable and can no \\nlonger be updated or modified. Ensure \", \"that all services that you need within your application have \\nbeen registered before you call Build.\", \" \\nResolution \\nAfter a type is registered, it can be resolved or injected as a dependency. When a typ\", \"e is being \\nresolved, and the container needs to create a new instance, it injects any dependencies \", \"into the \\ninstance. \\nGenerally, when a type is resolved, one of three things happens: \\n1. \\nIf the ty\", \"pe hasn\\u2019t been registered, the container throws an exception. \\n2. \\nIf the type has been registered a\", \"s a singleton, the container returns the singleton instance. If \\nthis is the first time the type is \", \"called for, the container creates it if required and maintains a \\nreference to it. \\n3. \\nIf the type \", \"has been registered as transient, the container returns a new instance and doesn\\u2019t \\nmaintain a refer\", \"ence to it. \\n.NET MAUI offers a number of ways to resolve registered components based on your needs.\", \" The most \\ndirect way to gain access to the dependency injection container is from an Element using \", \"the \\nHandler.MauiContext.Services. An example of this is shown below: \\nvar settingsService = this.Ha\", \"ndler.MauiContext.Services.GetServices<ISettingsService>(); \\nThis can be helpful if you need to reso\", \"lve a service from within an Element or from outside of the \\nconstructor of your Element. \\nCaution \\n\", \"There is a possibility that the Handler property of your Element may be null, so be aware that you m\", \"ay \\nneed to handle those situations. For more information, please refer to Handler lifecycle on the \", \"\\nMicrosoft Documentation Center. \\nIf using the Shell control for .NET MAUI, it will implicitly call \", \"into the dependency injection container \\nto create our objects during navigation. When setting up ou\", \"r Shell control, the Routing.RegisterRoute \\nmethod will tie a route path to a View as shown in the e\", \"xample below: \\nRouting.RegisterRoute(\\\"Filter\\\", typeof(FiltersView)); \\nDuring Shell navigation, it wi\", \"ll look for registrations of the FiltersView, and if any are found, it will \\ncreate that view and in\", \"ject any dependencies into the constructor. As shown in the code example \\nbelow, the CatalogViewMode\", \"l will be injected into the FiltersView: \\nnamespace eShop.Views; \\n \\npublic partial class FiltersView\", \" : ContentPage \\n{ \\n \\n26 \\nCHAPTER 4 | Dependency injection \\n \\n    public FiltersView(CatalogViewModel\", \" viewModel) \\n    { \\n        BindingContext = viewModel; \\n \\n        InitializeComponent(); \\n    } \\n} \", \"\\n \\n \\nTip \\nThe dependency injection container is great for creating view model instances. If a view m\", \"odel has \\ndependencies, it will handle the creation and injection of any required services. Just mak\", \"e sure that \\nyou register your view models and any dependencies that they may have with the CreateMa\", \"uiApp \\nmethod in the MauiProgram class. \\nSummary \\nDependency injection enables the decoupling of con\", \"crete types from the code that depends on these \\ntypes. It typically uses a container that holds a l\", \"ist of registrations and mappings between interfaces \\nand abstract types, and the concrete types tha\", \"t implement or extend these types. \\nMicrosoft.Extensions.DependencyInjection facilitates building lo\", \"osely coupled apps and provides all of \\nthe features commonly found in dependency injection containe\", \"rs, including methods to register type \\nmappings and object instances, resolve objects, manage objec\", \"t lifetimes, and inject dependent objects \\ninto constructors of objects it resolves. \\n \\n27 \\nCHAPTER \", \"5 | Communicating between loosely coupled components \\n \\nCHAPTER 5 \\nCommunicating between \\nloosely co\", \"upled \\ncomponents \\nThe publish-subscribe pattern is a messaging pattern in which publishers send mes\", \"sages without \\nknowing any receivers, known as subscribers. Similarly, subscribers listen for specif\", \"ic messages, \\nwithout knowing any publishers. \\nEvents in .NET implement the publish-subscribe patter\", \"n and are the most simple approach for a \\ncommunication layer between components if loose coupling i\", \"s not required, such as a control and the \\npage that contains it. However, the publisher and subscri\", \"ber lifetimes are coupled by object \\nreferences to each other, and the subscriber type must have a r\", \"eference to the publisher type. This \\ncan create memory management issues, especially when there are\", \" short-lived objects that subscribe \\nto an event of a static or long-lived object. If the event hand\", \"ler isn\\u2019t removed, the subscriber will be \\nkept alive by the reference to it in the publisher, and t\", \"his will prevent or delay the garbage collection \\nof the subscriber. \\nIntroduction to MVVM Toolkit M\", \"essenger \\nThe MVVM Toolkit IMessenger interface describes the publish-subscribe pattern, allowing me\", \"ssage-\\nbased communication between components that are inconvenient to link by object and type \\nrefe\", \"rences. This mechanism allows publishers and subscribers to communicate without having a direct \\nref\", \"erence to each other, helping to reduce dependencies between components, while also allowing \\ncompon\", \"ents to be independently developed and tested. \\nNote \\nThe MVVM Toolkit Messenger is part of the Comm\", \"unityToolkit.Mvvm package. For information on \\nhow to add the package to your project, see Introduct\", \"ion to the MVVM Toolkit on the Microsoft \\nDeveloper Center. \\n \\n \\n \\n28 \\nCHAPTER 5 | Communicating bet\", \"ween loosely coupled components \\n \\nWarning \\n.NET MAUI contains a built-in MessagingCenter class that\", \"\\u2019s no longer recommended for use. Use the \\nMVVM Toolkit Messenger instead. \\nThe IMessenger interface\", \" allows for multicast publish-subscribe functionality. This means that there \\ncan be multiple publis\", \"hers that publish a single message, and there can be multiple subscribers \\nlistening to the same mes\", \"sage. The image below illustrates this relationship: \\n \\nThere are two implementations of the IMessen\", \"ger interface that come with the \\nCommunityToolkit.Mvvm package. The WeakReferenceMessenger uses wea\", \"k references which can \\nresult in easier cleanup for message subscribers. This is a good option if y\", \"our subscribers do not have \\na clearly defined lifecycle. The StrongReferenceMessenger uses strong r\", \"eferences which can result in \\nbetter performance and a more clearly controlled lifetime of the subs\", \"cription. If you have a workflow \\nwith a very controlled lifetime (for example, a subscription that \", \"is bound to a page\\u2019s OnAppearing and \\nOnDisappearing methods), the StrongReferenceManager may be a b\", \"etter option, if performance is a \\nconcern. Both of these implementations are available with default\", \" implementations ready to use by \\nreferencing either WeakReferenceMessenger.Default or StrongReferen\", \"ceMessenger.Default. \\nNote \\nWhile the IMessenger interface permits communication between loosely-cou\", \"pled classes, it does not \\noffer the only architectural solution to this issue. For example, communi\", \"cation between a view model \\nand a view can also be achieved by the binding engine and through prope\", \"rty change notifications. In \\naddition, communication between two view models can also be achieved b\", \"y passing data during \\nnavigation. \\nThe eShop multi-platform app uses the WeakReferenceMessenger cla\", \"ss to communicate between \\nloosely coupled components. The app defines a single message named AddPro\", \"ductMessage. The \\nAddProductMessage is published by the CatalogViewModel class when an item is added\", \" to the \\nshopping basket. In return, the CatalogView class subscribes to the message and uses this t\", \"o highlight \\nthe product adds with animation in response. \\nIn the eShop multi-platform app, WeakRefe\", \"renceMessenger is used to update the UI in response to \\nan action occurring in another class. Theref\", \"ore, messages are published from the thread that the class \\nis executing on, with subscribers receiv\", \"ing the message on the same thread. \\n \\n29 \\nCHAPTER 5 | Communicating between loosely coupled compone\", \"nts \\n \\nTip \\nMarshal to the UI or main thread when performing UI updates. If updates to user interfac\", \"es are not \\nmade on this thread, it can cause the application to crash or become unstable. \\nIf a mes\", \"sage that\\u2019s sent from a background thread is required to update the UI, process the message \\non the \", \"UI thread in the subscriber by invoking the MainThread.BeginInvokeOnMainThread method. \\nFor more inf\", \"ormation about Messenger, see Messenger on the Microsoft Developer Center. \\nDefining a message \\nIMes\", \"senger messages are custom objects that provide custom payloads. The following code example \\nshows t\", \"he AddProductMessage message defined within the eShop multi-platform app: \\npublic class AddProductMe\", \"ssage : ValueChangedMessage<int> \\n{ \\n    public AddProductMessage(int count) : base(count) \\n    { \\n \", \"   } \\n} \\nThe base class is defined using ValueChangedMessage<T> where T can be of any type needed to\", \" \\npass data. Both message publishers and subscribers can expect messages of a specific type (for \\nex\", \"ample, AddProductMessage). This can help ensure that both parties have agreed to a messaging \\ncontra\", \"ct and that the data provided with that contract will be consistent. Additionally, this approach \\npr\", \"ovides compile-time type safety and refactoring support. \\nPublishing a message \\nTo publish a message\", \", we will need to use the IMessenger.Send method. This can be accessed most \\ncommonly through WeakRe\", \"ferenceMessenger.Default.Send or \\nStrongReferenceMessenger.Default.Send. The message sent can be of \", \"any object type. The following \\ncode example demonstrates publishing the AddProduct message: \\nWeakRe\", \"ferenceMessenger.Default.Send(new Messages.AddProductMessage(BadgeCount)); \\nIn this example, the Sen\", \"d method specifies provides a new instance of the AddProductMessage object \\nfor downstream subscribe\", \"rs to receive. An additional second token parameter can be added to use \\nwhen multiple different sub\", \"scribers need to receive messages of the same type without receiving the \\nwrong message. \\nThe Send m\", \"ethod will publish the message, and its payload data, using a fire-and-forget approach. \\nTherefore, \", \"the message is sent even if there are no subscribers registered to receive the message. In \\nthis sit\", \"uation, the sent message is ignored. \\n \\n30 \\nCHAPTER 5 | Communicating between loosely coupled compon\", \"ents \\n \\nSubscribing to a message \\nSubscribers can register to receive a message using one of the IMe\", \"ssenger.Register<T> overloads. \\nThe following code example demonstrates how the eShop multi-platform\", \" app subscribes to, and \\nprocesses, the AddProductMessage message: \\nWeakReferenceMessenger.Default \\n\", \"    .Register<CatalogView, Messages.AddProductMessage>( \\n        this, \\n        async (recipient, me\", \"ssage) => \\n        { \\n            await recipient.Dispatcher.DispatchAsync( \\n                async (\", \") => \\n                { \\n                    await recipient.badge.ScaleTo(1.2); \\n                  \", \"  await recipient.badge.ScaleTo(1.0); \\n                }); \\n        }); \\nIn the preceding example, t\", \"he Register method subscribes to the AddProductMessage message and \\nexecutes a callback delegate in \", \"response to receiving the message. This callback delegate, specified as \\na lambda expression, execut\", \"es code that updates the UI. \\nNote \\nAvoid the use of this within your callback delegate to avoid cap\", \"turing that object within the delegate. \\nThis can help improve performance. Instead, use the recipie\", \"nt parameter. \\nIf payload data is supplied, don\\u2019t attempt to modify the payload data from within a c\", \"allback delegate \\nbecause several threads could be accessing the received data simultaneously. In th\", \"is scenario, the \\npayload data should be immutable to avoid concurrency errors. \\nUnsubscribing from \", \"a message \\nSubscribers can unsubscribe from messages they no longer want to receive. This is achieve\", \"d with one \\nof the IMessenger.Unregister overloads, as demonstrated in the following code example: \\n\", \"WeakReferenceMessenger.Default.Unregister<Messages.AddProductMessage>(this); \\n \\n \\nNote \\nIn this exam\", \"ple, it isn\\u2019t fully necessary to call Unregister as the WeakReferenceMessenger will allow \\nunused ob\", \"jects to be garbage collected. If the StrongReferenceMessenger were used, it would be \\nadvised to ca\", \"ll Unregister for any subscriptions that are no longer in use. \\nIn this example, the Unsubscribe met\", \"hod syntax specifies the type argument of the message and the \\nrecipient object that is listening fo\", \"r messages. \\n \\n31 \\nCHAPTER 5 | Communicating between loosely coupled components \\n \\nSummary \\nThe MVVM\", \" Toolkit IMessenger interface describes the publish-subscribe pattern, allowing message-\\nbased commu\", \"nication between components that are inconvenient to link by object and type \\nreferences. This mecha\", \"nism allows publishers and subscribers to communicate without having a \\nreference to each other, hel\", \"ping to reduce dependencies between components, while also allowing \\ncomponents to be independently \", \"developed and tested. \\n \\n32 \\nCHAPTER 6 | Navigation \\n \\nCHAPTER 6 \\nNavigation \\n.NET MAUI includes sup\", \"port for page navigation, which typically results from the user\\u2019s interaction \\nwith the UI or from t\", \"he app itself as a result of internal logic-driven state changes. However, \\nnavigation can be comple\", \"x to implement in apps that use the Model-View-ViewModel (MVVM) \\npattern, as the following challenge\", \"s must be met: \\n\\u2022 \\nIdentifying the view to be navigated to using an approach that does not introduce\", \" tight \\ncoupling and dependencies between views. \\n\\u2022 \\nCoordinating the process by which the view to b\", \"e navigated to is instantiated and initialized. \\nWhen using MVVM, the view and view-model need to be\", \" instantiated and associated with \\neach other via the view\\u2019s binding context. When an app is using a\", \" dependency injection \\ncontainer, the instantiation of views and view-models might require a specifi\", \"c construction \\nmechanism. \\n\\u2022 \\nWhether to perform view-first navigation, or view-model-first navigat\", \"ion. With view-first \\nnavigation, the page to navigate to refers to the name of the view type. Durin\", \"g navigation, \\nthe specified view is instantiated, along with its corresponding view-model and other\", \" \\ndependent services. An alternative approach is to use view-model-first navigation, where the \\npage\", \" to navigate to refers to the name of the view-model type. \\n\\u2022 \\nDetermining how to cleanly separate t\", \"he navigational behavior of the app across the views \\nand view-models. The MVVM pattern separates th\", \"e app\\u2019s UI and its presentation and business \\nlogic, but it doesn\\u2019t provide a direct mechanism for t\", \"ying them together. However, the \\nnavigation behavior of an app will often span the UI and presentat\", \"ion parts of the app. The \\nuser will often initiate navigation from a view, and the view will be rep\", \"laced as a result of the \\nnavigation. However, navigation might often also need to be initiated or c\", \"oordinated from \\nwithin the view-model. \\n\\u2022 \\nDetermining how to pass parameters during navigation for\", \" initialization purposes. For \\nexample, if the user navigates to a view to update order details, the\", \" order data will have to be \\npassed to the view so that it can display the correct data. \\n\\u2022 \\nCoordin\", \"ating navigation to ensure that specific business rules are obeyed. For example, users \\nmight be pro\", \"mpted before navigating away from a view so that they can correct any invalid \\ndata or be prompted t\", \"o submit or discard any data changes that were made within the view. \\nThis chapter addresses these c\", \"hallenges by presenting a navigation service class named \\nMauiNavigationService that\\u2019s used to perfo\", \"rm view-model-first page navigation. \\nNote \\nThe MauiNavigationService used by the app is simplistic \", \"and does not cover all possible navigation \\ntypes. The types of navigation needed by your applicatio\", \"n may require additional functionality. \\n \\n33 \\nCHAPTER 6 | Navigation \\n \\nNavigating between pages \\nN\", \"avigation logic can reside in a view\\u2019s code-behind or a data-bound view-model. While placing \\nnaviga\", \"tion logic in a view might be the most straightforward approach, it is not easily testable \\nthrough \", \"unit tests. Putting navigation logic in view-model classes means that the logic can be verified \\nthr\", \"ough unit tests. In addition, the view-model can then implement logic to control navigation to \\nensu\", \"re that certain business rules are enforced. For example, an app might not allow the user to \\nnaviga\", \"te away from a page without first ensuring that the entered data is valid. \\nA navigation service is \", \"typically invoked from view-models, in order to promote testability. However, \\nnavigating to views f\", \"rom view-models would require the view-models to reference views, and \\nparticularly views that the a\", \"ctive view-model isn\\u2019t associated with, which is not recommended. \\nTherefore, the MauiNavigationServ\", \"ice presented here specifies the view-model type as the target to \\nnavigate to. \\nThe eShop multi-pla\", \"tform app uses the MauiNavigationService class to provide view-model-first \\nnavigation. This class i\", \"mplements the INavigationService interface, which is shown in the following \\ncode example: \\npublic i\", \"nterface INavigationService \\n{ \\n    Task InitializeAsync(); \\n \\n    Task NavigateToAsync(string route\", \", IDictionary<string, object> routeParameters = null); \\n \\n    Task PopAsync(); \\n} \\nThis interface sp\", \"ecifies that an implementing class must provide the following methods: \\nMethod \\nPurpose \\nInitializeA\", \"sync \\nPerforms navigation to one of two pages when \\nthe app is launched. \\nNavigateToAsync(string rou\", \"te, \\nIDictionary<string, object> routeParameters = \\nnull) \\nPerforms hierarchical navigation to a spe\", \"cified \\npage using a registered navigation route. Can \\noptionally pass named route parameters to use\", \" \\nfor processing on the destination page \\nPopAsync \\nRemoves the current page from the navigation \\nst\", \"ack. \\nNote \\nAn INavigationService interface would usually also specify a GoBackAsync method, which i\", \"s used to \\nprogrammatically return to the previous page in the navigation stack. However, this metho\", \"d is missing \\nfrom the eShop multi-platform app because it\\u2019s not required. \\n \\n34 \\nCHAPTER 6 | Naviga\", \"tion \\n \\nCreating the MauiNavigationService instance \\nThe MauiNavigationService class, which implemen\", \"ts the INavigationService interface, is registered as a \\nsingleton with the dependency injection con\", \"tainer in the MauiProgram.CreateMauiApp() method, as \\ndemonstrated in the following code example: \\nm\", \"auiAppBuilder.Services.AddSingleton<INavigationService, MauiNavigationService>();; \\nThe INavigationS\", \"ervice interface can then be resolved by adding it to the constructor of our views and \\nview-models,\", \" as demonstrated in the following code example: \\npublic AppShell(INavigationService navigationServic\", \"e) \\nThis returns a reference to the MauiNavigationService object that\\u2019s stored in the dependency inj\", \"ection \\ncontainer. \\nThe ViewModelBase class stores the MauiNavigationService instance in a Navigatio\", \"nService property, \\nof type INavigationService. Therefore, all view-model classes, which derive from\", \" the ViewModelBase \\nclass, can use the NavigationService property to access the methods specified by\", \" the \\nINavigationService interface. \\nHandling navigation requests \\n.NET MAUI provides multiple ways \", \"to navigate within an application. The traditional way to navigate is \\nwith the NavigationPage class\", \", which implements a hierarchical navigation experience in which the \\nuser can navigate through page\", \"s, forward and backward, as desired. The eShop app uses the Shell \\ncomponent as the root container f\", \"or the application and as a navigation host. For more information \\nabout Shell navigation, see Shell\", \" Navigation on the Microsoft Developer Center. \\nNavigation is performed inside view-model classes by\", \" invoking one of the NavigateToAsync methods, \\nspecifying the route path for the page being navigate\", \"d to, as demonstrated in the following code \\nexample: \\nawait NavigationService.NavigateToAsync(\\\"//Ma\", \"in\\\"); \\nThe following code example shows the NavigateToAsync method provided by the \\nMauiNavigationSe\", \"rvice class: \\npublic Task NavigateToAsync(string route, IDictionary<string, object> routeParameters \", \"= \\nnull) \\n{ \\n    return \\n        routeParameters != null \\n            ? Shell.Current.GoToAsync(rout\", \"e, routeParameters) \\n            : Shell.Current.GoToAsync(route); \\n} \\nThe .NET MAUI Shell control i\", \"s already familiar with route-based navigation, so the NavigateToAsync \\nmethod works to mask this fu\", \"nctionality. The NavigateToAsync method allows navigation data to be \\n \\n35 \\nCHAPTER 6 | Navigation \\n\", \" \\nspecified as an argument that\\u2019s passed to the view-model being navigated to, where it\\u2019s typically \", \"used \\nto perform initialization. For more information, see Passing parameters during navigation. \\nIm\", \"portant \\nThere are multiple ways to perform navigation in .NET MAUI. The MauiNavigationService is sp\", \"ecifically \\nbuild to work with Shell. If you are using a NavigationPage or TabbedPage or a different\", \" navigation \\nmechanism, this routing service would have to be updated to work using those components\", \". \\nIn order to register routes for the MauiNavigationService we need to supply route information fro\", \"m \\nXAML or in the code-behind. The following example shows registration of routes via XAML. \\n<?xml v\", \"ersion=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> \\n<Shell \\n    xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" \", \"\\n    xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" \\n    xmlns:views=\\\"clr-namespace:eShop.Vi\", \"ews\\\" \\n    x:Class=\\\"eShop.AppShell\\\"> \\n \\n    <!-- Omitted for brevity --> \\n \\n    <FlyoutItem > \\n      \", \"  <ShellContent x:Name=\\\"login\\\" ContentTemplate=\\\"{DataTemplate views:LoginView}\\\" \\nRoute=\\\"Login\\\" /> \\n \", \"   </FlyoutItem> \\n \\n    <TabBar x:Name=\\\"main\\\" Route=\\\"Main\\\"> \\n        <ShellContent Title=\\\"CATALOG\\\" R\", \"oute=\\\"Catalog\\\" Icon=\\\"{StaticResource \\nCatalogIconImageSource}\\\" ContentTemplate=\\\"{DataTemplate views:\", \"CatalogView}\\\" /> \\n        <ShellContent Title=\\\"PROFILE\\\" Route=\\\"Profile\\\" Icon=\\\"{StaticResource \\nProfi\", \"leIconImageSource}\\\" ContentTemplate=\\\"{DataTemplate views:ProfileView}\\\" /> \\n    </TabBar> \\n</Shell> \\n\", \"In this example, the ShellContent and TabBar user interface objects are setting their Route property\", \". \\nThis is the preferred method of registering routes for user interface objects that are controlled\", \" by a \\nShell. \\nIf we have objects that will be added to the navigation stack at a later time, then w\", \"e will need to add \\nthose via code-behind. The following example show registration of routes in code\", \"-behind. \\nRouting.RegisterRoute(\\\"Filter\\\", typeof(FiltersView)); \\nRouting.RegisterRoute(\\\"Basket\\\", typ\", \"eof(BasketView)); \\nIn code-behind, we will call the Routing.RegisterRoute method which takes a route\", \" name as the first \\nparameter and a view type as the second parameter. When a view-model uses the Na\", \"vigationService \\nproperty to navigate, the application\\u2019s Shell object will look for registered route\", \"s and push them onto \\nthe navigation stack. \\nAfter the view is created and navigated to, the ApplyQu\", \"eryAttributes and InitializeAsync methods of \\nthe view\\u2019s associated view-model are executed. For mor\", \"e information, see Passing parameters during \\nnavigation. \\n \\n36 \\nCHAPTER 6 | Navigation \\n \\nNavigatin\", \"g when the app is launched \\nWhen the app is launched, a Shell object is set as the root view of the \", \"application. Once set, the Shell \\nwill be used to control route registration and will be present at \", \"the root of our application going \\nforward. Once the Shell has been created, we can wait for it to b\", \"e attached to the application using \\nthe OnParentSet method to initialize our navigation route. The \", \"following code example shows this \\nmethod: \\nprotected override async void OnParentSet() \\n{ \\n    base\", \".OnParentSet(); \\n \\n    if (Parent is not null) \\n    { \\n        await _navigationService.InitializeAs\", \"ync(); \\n    } \\n} \\nThe method uses an instance of INavigationService which is provided the constructo\", \"r from \\ndependency injection and invokes its InitializeAsync method. \\nThe following code example sho\", \"ws the implementation of the MauiNavigationService.InitializeAsync \\nmethod: \\npublic Task InitializeA\", \"sync() \\n{ \\n    return NavigateToAsync(string.IsNullOrEmpty(_settingsService.AuthAccessToken) \\n      \", \"  ? \\\"//Login\\\" \\n        : \\\"//Main/Catalog\\\"); \\n} \\nThe //Main/Catalog route is navigated to if the app \", \"has a cached access token, which is used for \\nauthentication. Otherwise, the //Login route is naviga\", \"ted to. \\nPassing parameters during navigation \\nThe NavigateToAsync method, specified by the INavigat\", \"ionService interface, enables navigation data \\nto be specified as an IDictionary<string, object> of \", \"data that\\u2019s passed to the view-model being \\nnavigated to, where it\\u2019s typically used to perform initi\", \"alization. \\nFor example, the ProfileViewModel class contains an OrderDetailCommand that\\u2019s executed w\", \"hen the \\nuser selects an order on the ProfileView page. In turn, this executes the OrderDetailAsync \", \"method, \\nwhich is shown in the following code example: \\nprivate async Task OrderDetailAsync(Order or\", \"der) \\n{ \\n    if (order is null) \\n    { \\n        return; \\n    } \\n \\n    await NavigationService.Naviga\", \"teToAsync( \\n        \\\"OrderDetail\\\", \\n \\n37 \\nCHAPTER 6 | Navigation \\n \\n        new Dictionary<string, o\", \"bject>{ { \\\"OrderNumber\\\", order.OrderNumber } }); \\n} \\nThis method invokes navigation to the OrderDeta\", \"il route, passing order number information the order \\nthat the user selected. When the dependency in\", \"jection framework creates the OrderDetailView for the \\nOrderDetail route along with the OrderDetailV\", \"iewModel class which is assigned to the view\\u2019s \\nBindingContext. The OrderDetailViewModel has an attr\", \"ibute added to it that allows it to receive data \\nfrom the navigation service as shown in the code e\", \"xample below. \\n[QueryProperty(nameof(OrderNumber), \\\"OrderNumber\\\")] \\npublic class OrderDetailViewMode\", \"l : ViewModelBase \\n{ \\n    public int OrderNumber { get; set; } \\n} \\nThe QueryProperty attribute allow\", \"s us to provide a parameter for a property to map values to and a \\nkey to find values from the query\", \" parameters dictionary. In this example, the key \\u201cOrderNumber\\u201d and \\norder number value were provided\", \" during the NavigateToAsync call. The view-model found the \\n\\u201cOrderNumber\\u201d key and mapped the value t\", \"o the OrderNumber property. The OrderNumber property \\ncan then be used at a later time to retrieve t\", \"he full order details from the OrderService instance. \\nInvoking navigation using behaviors \\nNavigati\", \"on is usually triggered from a view by a user interaction. For example, the LoginView performs \\nnavi\", \"gation following successful authentication. The following code example shows how the navigation \\nis \", \"invoked by a behavior: \\n<WebView> \\n    <WebView.Behaviors> \\n        <behaviors:EventToCommandBehavio\", \"r \\n            EventName=\\\"Navigating\\\" \\n            EventArgsConverter=\\\"{StaticResource WebNavigating\", \"EventArgsConverter}\\\" \\n            Command=\\\"{Binding NavigateCommand}\\\" /> \\n    </WebView.Behaviors> \\n\", \"</WebView> \\nAt runtime, the EventToCommandBehavior will respond to interaction with the WebView. Whe\", \"n the \\nWebView navigates to a web page, the Navigating event will fire, which will execute the \\nNavi\", \"gateCommand in the LoginViewModel. By default, the event arguments for the event are passed \\nto the \", \"command. This data is converted as it\\u2019s passed between source and target by the converter \\nspecified\", \" in the EventArgsConverter property, which returns the Url from the \\nWebNavigatingEventArgs. Therefo\", \"re, when the NavigationCommand is executed, the Url of the web \\npage is passed as a parameter to the\", \" registered Action. \\nIn turn, the NavigationCommand executes the NavigateAsync method, which is show\", \"n in the \\nfollowing code example: \\nprivate async Task NavigateAsync(string url) \\n{ \\n    // Omitted f\", \"or brevity. \\n    if (!string.IsNullOrWhiteSpace(accessToken)) \\n    { \\n \\n38 \\nCHAPTER 6 | Navigation \\n\", \" \\n        _settingsService.AuthAccessToken = accessToken; \\n        _settingsService.AuthIdToken = au\", \"thResponse.IdentityToken; \\n        await NavigationService.NavigateToAsync(\\\"//Main/Catalog\\\"); \\n    }\", \" \\n} \\nThis method invokes NavigationService route the application to the //Main/Catalog route. \\nConfi\", \"rming or cancelling navigation \\nAn app might need to interact with the user during a navigation oper\", \"ation, so that the user can \\nconfirm or cancel navigation. This might be necessary, for example, whe\", \"n the user attempts to \\nnavigate before having fully completed a data entry page. In this situation,\", \" an app should provide a \\nnotification that allows the user to navigate away from the page, or to ca\", \"ncel the navigation operation \\nbefore it occurs. This can be achieved in a view-model class by using\", \" the response from a notification \\nto control whether or not navigation is invoked. \\nSummary \\n.NET M\", \"AUI includes support for page navigation, which typically results from the user\\u2019s interaction \\nwith \", \"the UI, or from the app itself, as a result of internal logic-driven state changes. However, \\nnaviga\", \"tion can be complex to implement in apps that use the MVVM pattern. \\nThis chapter presented a Naviga\", \"tionService class, which is used to perform view-model-first \\nnavigation from view-models. Placing n\", \"avigation logic in view-model classes means that the logic can \\nbe exercised through automated tests\", \". In addition, the view-model can then implement logic to \\ncontrol navigation to ensure that certain\", \" business rules are enforced. \\n \\n39 \\nCHAPTER 7 | Validation \\n \\nCHAPTER 7 \\nValidation \\nAny app that a\", \"ccepts input from users should ensure that the input is valid. An app could, for \\nexample, check for\", \" input that contains only characters in a particular range, is of a certain length, or \\nmatches a pa\", \"rticular format. Without validation, a user can supply data that causes the app to fail. \\nProper val\", \"idation enforces business rules and could help to prevent an attacker from injecting \\nmalicious data\", \". \\nIn the context of the Model-View-ViewModel (MVVM) pattern, a view model or model will often be \\nr\", \"equired to perform data validation and signal any validation errors to the view so that the user can\", \" \\ncorrect them. The eShop multi-platform app performs synchronous client-side validation of view \\nmo\", \"del properties and notifies the user of any validation errors by highlighting the control that \\ncont\", \"ains the invalid data, and by displaying error messages that inform the user of why the data is \\ninv\", \"alid. The image below shows the classes involved in performing validation in the eShop multi-\\nplatfo\", \"rm app. \\n \\nView model properties that require validation are of type ValidatableObject<T>, and each \", \"\\nValidatableObject<T> instance has validation rules added to its Validations property. Validation is\", \" \\n \\n40 \\nCHAPTER 7 | Validation \\n \\ninvoked from the view model by calling the Validate method of the \", \"ValidatableObject<T> instance, \\nwhich retrieves the validation rules and executes them against the V\", \"alidatableObject<T>.Value \\nproperty. Any validation errors are placed into the Errors property of th\", \"e ValidatableObject<T> \\ninstance, and the IsValid property of the ValidatableObject<T> instance is u\", \"pdated to indicate \\nwhether the validation succeeded or failed. The following code shows the impleme\", \"ntation of the \\nValidatableObject<T>: \\nusing CommunityToolkit.Mvvm.ComponentModel; \\nnamespace eShop.\", \"Validations; \\npublic class ValidatableObject<T> : ObservableObject, IValidity \\n{ \\n    private IEnume\", \"rable<string> _errors; \\n    private bool _isValid; \\n    private T _value; \\n    public List<IValidati\", \"onRule<T>> Validations { get; } = new(); \\n    public IEnumerable<string> Errors \\n    { \\n        get \", \"=> _errors; \\n        private set => SetProperty(ref _errors, value); \\n    } \\n    public bool IsValid\", \" \\n    { \\n        get => _isValid; \\n        private set => SetProperty(ref _isValid, value); \\n    } \\n\", \"    public T Value \\n    { \\n        get => _value; \\n        set => SetProperty(ref _value, value); \\n \", \"   } \\n    public ValidatableObject() \\n    { \\n        _isValid = true; \\n        _errors = Enumerable.\", \"Empty<string>(); \\n    } \\n    public bool Validate() \\n    { \\n        Errors = Validations \\n          \", \"  ?.Where(v => !v.Check(Value)) \\n            ?.Select(v => v.ValidationMessage) \\n            ?.ToArr\", \"ay() \\n            ?? Enumerable.Empty<string>(); \\n        IsValid = !Errors.Any(); \\n        return I\", \"sValid; \\n    } \\n} \\nProperty change notification is provided by the ObservableObject class, and so an\", \" Entry control can \\nbind to the IsValid property of ValidatableObject<T> instance in the view model \", \"class to be notified of \\nwhether or not the entered data is valid. \\nSpecifying validation rules \\nVal\", \"idation rules are specified by creating a class that derives from the IValidationRule<T> interface, \", \"\\nwhich is shown in the following code example: \\n \\n41 \\nCHAPTER 7 | Validation \\n \\npublic interface IVa\", \"lidationRule<T> \\n{ \\n    string ValidationMessage { get; set; } \\n    bool Check(T value); \\n} \\nThis in\", \"terface specifies that a validation rule class must provide a boolean Check method that is used \\nto \", \"perform the required validation, and a ValidationMessage property whose value is the validation \\nerr\", \"or message that will be displayed if validation fails. \\nThe following code example shows the IsNotNu\", \"llOrEmptyRule<T> validation rule, which is used to \\nperform validation of the username and password \", \"entered by the user on the LoginView when using \\nmock services in the eShop multi-platform app: \\npub\", \"lic class IsNotNullOrEmptyRule<T> : IValidationRule<T> \\n{ \\n    public string ValidationMessage { get\", \"; set; } \\n \\n    public bool Check(T value) => \\n        value is string str && !string.IsNullOrWhiteS\", \"pace(str); \\n} \\nThe Check method returns a boolean indicating whether the value argument is null, emp\", \"ty, or consists \\nonly of whitespace characters. \\nAlthough not used by the eShop multi-platform app, \", \"the following code example shows a validation \\nrule for validating email addresses: \\npublic class Em\", \"ailRule<T> : IValidationRule<T> \\n{ \\n    private readonly Regex _regex = new(@\\\"^([w.-]+)@([w-]+)((.(w\", \"){2,3})+)$\\\"); \\n \\n    public string ValidationMessage { get; set; } \\n \\n    public bool Check(T value)\", \" => \\n        value is string str && _regex.IsMatch(str); \\n} \\nThe Check method returns a boolean indi\", \"cating whether or not the value argument is a valid email \\naddress. This is achieved by searching th\", \"e value argument for the first occurrence of the regular \\nexpression pattern specified in the Regex \", \"constructor. Whether the regular expression pattern has \\nbeen found in the input string can be deter\", \"mined by checking the value against Regex.IsMatch. \\nNote \\nProperty validation can sometimes involve \", \"dependent properties. An example of dependent \\nproperties is when the set of valid values for proper\", \"ty A depends on the particular value that has been \\nset in property B. To check that the value of pr\", \"operty A is one of the allowed values would involve \\nretrieving the value of property B. In addition\", \", when the value of property B changes, property A \\nwould need to be revalidated. \\n \\n42 \\nCHAPTER 7 |\", \" Validation \\n \\nAdding validation rules to a property \\nIn the eShop multi-platform app, view model pr\", \"operties that require validation are declared to be of \\ntype ValidatableObject<T>, where T is the ty\", \"pe of the data to be validated. The following code \\nexample shows an example of two such properties:\", \" \\npublic ValidatableObject<string> UserName { get; private set; } \\npublic ValidatableObject<string> \", \"Password { get; private set; } \\nFor validation to occur, validation rules must be added to the Valid\", \"ations collection of \\neach ValidatableObject<T> instance, as demonstrated in the following code exam\", \"ple: \\nprivate void AddValidations() \\n{ \\n    UserName.Validations.Add(new IsNotNullOrEmptyRule<string\", \">  \\n    {  \\n        ValidationMessage = \\\"A username is required.\\\"  \\n    }); \\n \\n    Password.Validati\", \"ons.Add(new IsNotNullOrEmptyRule<string>  \\n    {  \\n        ValidationMessage = \\\"A password is requir\", \"ed.\\\"  \\n    }); \\n} \\nThis method adds the IsNotNullOrEmptyRule<T> validation rule to the Validations c\", \"ollection of each \\nValidatableObject<T> instance, specifying values for the validation rule\\u2019s Valida\", \"tionMessage property, \\nwhich specifies the validation error message that will be displayed if valida\", \"tion fails. \\nTriggering validation \\nThe validation approach used in the eShop multi-platform app can\", \" manually trigger validation of a \\nproperty, and automatically trigger validation when a property ch\", \"anges. \\nTriggering validation manually \\nValidation can be triggered manually for a view model proper\", \"ty. For example, this occurs in the eShop \\nmulti-platform app when the user taps the Login button on\", \" the LoginView, when using mock services. \\nThe command delegate calls the MockSignInAsync method in \", \"the LoginViewModel, which invokes \\nvalidation by executing the Validate method, which is shown in th\", \"e following code example: \\nprivate bool Validate() \\n{ \\n    bool isValidUser = ValidateUserName(); \\n \", \"   bool isValidPassword = ValidatePassword(); \\n    return isValidUser && isValidPassword; \\n} \\n \\npriv\", \"ate bool ValidateUserName() \\n{ \\n    return _userName.Validate(); \\n} \\n \\nprivate bool ValidatePassword\", \"() \\n{ \\n \\n43 \\nCHAPTER 7 | Validation \\n \\n    return _password.Validate(); \\n} \\nThe Validate method perf\", \"orms validation of the username and password entered by the user on the \\nLoginView, by invoking the \", \"Validate method on each ValidatableObject<T> instance. The following \\ncode example shows the Validat\", \"e method from the ValidatableObject<T> class: \\npublic bool Validate() \\n{ \\n    Errors = _validations \", \"\\n        ?.Where(v => !v.Check(Value)) \\n        ?.Select(v => v.ValidationMessage) \\n        ?.ToArra\", \"y() \\n        ?? Enumerable.Empty<string>(); \\n \\n    IsValid = !Errors.Any(); \\n \\n    return IsValid; \\n\", \"} \\nThis method retrieves any validation rules that were added to the object\\u2019s Validations collection\", \". The \\nCheck method for each retrieved validation rule is executed, and the ValidationMessage proper\", \"ty \\nvalue for any validation rule that fails to validate the data is added to the Errors collection \", \"of the \\nValidatableObject<T> instance. Finally, the IsValid property is set, and its value is return\", \"ed to the \\ncalling method, indicating whether validation succeeded or failed. \\nTriggering validation\", \" when properties change \\nValidation is also automatically triggered whenever a bound property change\", \"s. For example, when a \\ntwo-way binding in the LoginView sets the UserName or Password property, val\", \"idation is triggered. \\nThe following code example demonstrates how this occurs: \\n<Entry Text=\\\"{Bindi\", \"ng UserName.Value, Mode=TwoWay}\\\"> \\n    <Entry.Behaviors> \\n        <behaviors:EventToCommandBehavior \", \"\\n            EventName=\\\"TextChanged\\\" \\n            Command=\\\"{Binding ValidateUserNameCommand}\\\" /> \\n  \", \"  </Entry.Behaviors> \\n</Entry> \\nThe Entry control binds to the UserName.Value property of the Valida\", \"tableObject<T> instance, and \\nthe control\\u2019s Behaviors collection has an EventToCommandBehavior insta\", \"nce added to it. This \\nbehavior executes the ValidateUserNameCommand in response to the TextChanged \", \"event firing on \\nthe Entry, which is raised when the text in the Entry changes. In turn, the Validat\", \"eUserNameCommand \\ndelegate executes the ValidateUserName method, which executes the Validate method \", \"on the \\nValidatableObject<T> instance. Therefore, every time the user enters a character in the Entr\", \"y control \\nfor the username, validation of the entered data is performed. \\nDisplaying validation err\", \"ors \\nThe eShop multi-platform app notifies the user of any validation errors by highlighting the con\", \"trol \\nthat contains the invalid data with a red background, and by displaying an error message that \", \"informs \\n \\n44 \\nCHAPTER 7 | Validation \\n \\nthe user why the data is invalid below the control containi\", \"ng the invalid data. When the invalid data is \\ncorrected, the background changes back to the default\", \" state and the error message is removed. The \\nimage below shows the LoginView in the eShop multi-pla\", \"tform app when validation errors are \\npresent. \\n \\nHighlighting a control that contains invalid data \", \"\\n.NET MAUI offers a number of ways to present validation information to end-users, but one of the \\nm\", \"ost straight-forward ways is through the use of Triggers. Triggers provide us a way to change the \\ns\", \"tate of our controls, typically for appearance, based on an event or data change that occurs for a \\n\", \"control. For validation, we will be using a DataTrigger which will listen to changes raised from a b\", \"ound \\nproperty and respond to the changes. The Entry controls on the LoginView are setup using the \\n\", \"following code: \\n<Entry Text=\\\"{Binding UserName.Value, Mode=TwoWay}\\\"> \\n    <Entry.Style> \\n        <O\", \"nPlatform x:TypeArguments=\\\"Style\\\"> \\n            <On Platform=\\\"iOS, Android\\\" Value=\\\"{StaticResource E\", \"ntryStyle}\\\" /> \\n            <On Platform=\\\"WinUI\\\" Value=\\\"{StaticResource WinUIEntryStyle}\\\" /> \\n      \", \"  </OnPlatform> \\n    </Entry.Style> \\n    <Entry.Behaviors> \\n        <mct:EventToCommandBehavior \\n   \", \"         EventName=\\\"TextChanged\\\" \\n            Command=\\\"{Binding ValidateCommand}\\\" /> \\n    </Entry.Be\", \"haviors> \\n    <Entry.Triggers> \\n        <DataTrigger  \\n            TargetType=\\\"Entry\\\" \\n            B\", \"inding=\\\"{Binding UserName.IsValid}\\\" \\n            Value=\\\"False\\\"> \\n            <Setter Property=\\\"Backg\", \"roundColor\\\" Value=\\\"{StaticResource ErrorColor}\\\" /> \\n        </DataTrigger> \\n    </Entry.Triggers> \\n<\", \"/Entry> \\nThe DataTrigger specifies the following properties: \\n \\n45 \\nCHAPTER 7 | Validation \\n \\nProper\", \"ty \\nDescription \\nTargetType \\nThe control type that the trigger belongs to. \\nBinding \\nThe data Bindin\", \"g markup which will provide \\nchange notifications and value for the trigger \\ncondition. \\nValue \\nThe \", \"data value to specify when the trigger\\u2019s \\ncondition has been met. \\nFor this Entry, we will be listen\", \"ing for changes to the LoginViewModel.UserName.IsValid property. \\nEach time this property raises a c\", \"hange, the value will be compared against the Value property set in \\nthe DataTrigger. If the values \", \"are equal, then the trigger condition will be met and any Setter objects \\nprovided to the DataTrigge\", \"r will be executed. This control has a single Setter object that updates the \\nBackgroundColor proper\", \"ty to a custom color defined using the StaticResource markup. When a \\nTrigger condition is no longer\", \" met, the control will revert the properties set by the Setter object to \\ntheir previous state. For \", \"more information about Triggers, see .NET MAUI Docs: Triggers. \\nDisplaying error messages \\nThe UI di\", \"splays validation error messages in Label controls below each control whose data failed \\nvalidation.\", \" The following code example shows the Label that displays a validation error message, if the \\nuser h\", \"as not entered a valid username: \\n<Label \\n    \\nText=\\\"{Binding UserName.Errors, Converter={StaticReso\", \"urce FirstValidationErrorConverter}\\\" \\n    Style=\\\"{StaticResource ValidationErrorLabelStyle}\\\" /> \\nEac\", \"h Label binds to the Errors property of the view model object that\\u2019s being validated. The Errors \\npr\", \"operty is provided by the ValidatableObject<T> class, and is of type IEnumerable<string>. Because \\nt\", \"he Errors property can contain multiple validation errors, the FirstValidationErrorConverter instanc\", \"e is \\nused to retrieve the first error from the collection for display. \\nSummary \\nThe eShop multi-pl\", \"atform app performs synchronous client-side validation of view model properties \\nand notifies the us\", \"er of any validation errors by highlighting the control that contains the invalid data, \\nand by disp\", \"laying error messages that inform the user why the data is invalid. \\nView model properties that requ\", \"ire validation are of type ValidatableObject<T>, and each \\nValidatableObject<T> instance has validat\", \"ion rules added to its Validations property. Validation is \\ninvoked from the view model by calling t\", \"he Validate method of the ValidatableObject<T> instance, \\nwhich retrieves the validation rules and e\", \"xecutes them against the ValidatableObject<T> Value \\nproperty. Any validation errors are placed into\", \" the Errors property of the ValidatableObject<T> \\ninstance, and the IsValid property of the Validata\", \"bleObject<T> instance is updated to indicate \\nwhether validation succeeded or failed. \\n \\n46 \\nCHAPTER\", \" 8 | Application settings management \\n \\nCHAPTER 8 \\nApplication settings \\nmanagement \\nSettings allow \", \"the separation of data that configures the behavior of an app from the code, allowing \\nthe behavior \", \"to be changed without rebuilding the app. There are two types of settings: app settings \\nand user se\", \"ttings. \\nApp settings are data that an app creates and manages. It can include data such as fixed we\", \"b service \\nendpoints, API keys, and runtime state. App settings are tied to core functionality and a\", \"re only \\nmeaningful to that app. \\nUser settings are the customizable settings of an app that affect \", \"the app\\u2019s behavior and don\\u2019t require \\nfrequent re-adjustment. For example, an app might let the user\", \" specify where to retrieve data and \\nhow to display it on the screen. \\nCreating a Settings Interface\", \" \\nWhile the preferences manager can be used directly in your application, it does come with the \\ndra\", \"wback of making your application tightly coupled to the preferences manager implementation. \\nThis co\", \"upling means that creating unit tests or extending the functionality of preferences \\nmanagement will\", \" be limited since your application will not have a direct way to intercept the behavior. \\nTo address\", \" this concern, an interface can be created to work as a proxy for preferences management. \\nThe inter\", \"face will allow us to supply an implementation that fits our needs. For example, when writing \\na uni\", \"t test, we may want to set specific settings, and the interface will give us an easy way to \\nconsist\", \"ently set this data for the test. The following code example shows the ISettingsService interface \\ni\", \"n the eShop multi-platform app: \\nnamespace eShop.Services.Settings; \\n \\npublic interface ISettingsSer\", \"vice \\n{ \\n    string AuthAccessToken { get; set; } \\n    string AuthIdToken { get; set; } \\n    bool Us\", \"eMocks { get; set; } \\n    string IdentityEndpointBase { get; set; } \\n    string GatewayShoppingEndpo\", \"intBase { get; set; } \\n    string GatewayMarketingEndpointBase { get; set; } \\n    bool UseFakeLocati\", \"on { get; set; } \\n    string Latitude { get; set; } \\n    string Longitude { get; set; } \\n \\n47 \\nCHAPT\", \"ER 8 | Application settings management \\n \\n    bool AllowGpsLocation { get; set; } \\n} \\nAdding Setting\", \"s \\n.NET MAUI includes a preferences manager that provides a way to store runtime settings for a user\", \". \\nThis feature can be accessed from anywhere within your application using the \\nMicrosoft.Maui.Stor\", \"age.Preferences class. The preferences manager provides a consistent, type-safe, \\ncross-platform app\", \"roach for persisting and retrieving app and user settings, while using the native \\nsettings manageme\", \"nt provided by each platform. In addition, it\\u2019s straightforward to use data binding \\nto access setti\", \"ngs data exposed by the library. For more information, see the Preferences on the \\nMicrosoft Develop\", \"er Center. \\nTip \\nPreferences is meant for storing relatively small data. If you need to store larger\", \" or more complex \\ndata, consider using a local database or filesystem to store the data. \\nOur applic\", \"ation will use the Preferences class need to implement the ISettingsService interface. The \\ncode bel\", \"ow shows how the eShop multi-platform app\\u2019s SettingsService implements the \\nAuthTokenAccess and UseM\", \"ocks properties: \\npublic sealed class SettingsService : ISettingsService \\n{ \\n    private const strin\", \"g AccessToken = \\\"access_token\\\"; \\n    private const string AccessTokenDefault = string.Empty; \\n \\n    \", \"private const string IdUseMocks = \\\"use_mocks\\\"; \\n    private const bool UseMocksDefault = true; \\n \\n  \", \"  public string AuthAccessToken \\n    { \\n        get => Preferences.Get(AccessToken, AccessTokenDefau\", \"lt); \\n        set => Preferences.Set(AccessToken, value); \\n    } \\n \\n    public bool UseMocks \\n    { \", \"\\n        get => Preferences.Get(IdUseMocks, UseMocksDefault); \\n        set => Preferences.Set(IdUseM\", \"ocks, value); \\n    } \\n} \\nEach setting consists of a private key, a private default value, and a publ\", \"ic property. The key is always \\na const string that defines a unique name, with the default value fo\", \"r the setting being a static read-\\nonly or constant value of the required type. Providing a default \", \"value ensures that a valid value is \\navailable if an unset setting is retrieved. This service implem\", \"entation can be provided via dependency \\ninjection to our application for use in view-models or othe\", \"r services throughout the application. \\n \\n48 \\nCHAPTER 8 | Application settings management \\n \\nData bi\", \"nding to user settings \\nIn the eShop multi-platform app, the SettingsView exposes multiple settings \", \"the user can configure at \\nruntime. These settings include allowing configuration of whether the app\", \" should retrieve data from \\nmicroservices deployed as Docker containers or whether the app should re\", \"trieve data from mock \\nservices that don\\u2019t require an internet connection. When retrieving data from\", \" containerized \\nmicroservices, a base endpoint URL for the microservices must be specified. The imag\", \"e below shows \\nthe SettingsView when the user has chosen to retrieve data from containerized microse\", \"rvices. \\n \\nData binding can be used to retrieve and set settings exposed by the ISettingService inte\", \"rface. This is \\nachieved by controls on the view binding to view model properties that in turn acces\", \"s properties in \\nthe ISettingService interface and raising a property changed notification if the va\", \"lue has changed. \\nThe following code example shows the Entry control from the SettingsView that allo\", \"ws the user to \\nenter a base identity endpoint URL for the containerized microservices: \\n<Entry Text\", \"=\\\"{Binding IdentityEndpoint, Mode=TwoWay}\\\" /> \\nThis Entry control binds to the IdentityEndpoint prop\", \"erty of the SettingsViewModel class, using a two-\\nway binding. The following code example shows the \", \"IdentityEndpoint property: \\nprivate readonly ISettingsService _settingsService; \\n \\nprivate string _i\", \"dentityEndpoint; \\n \\npublic SettingsViewModel( \\n    ILocationService locationService, IAppEnvironment\", \"Service appEnvironmentService, \\n    IDialogService dialogService, INavigationService navigationServi\", \"ce, ISettingsService \\nsettingsService) \\n    : base(dialogService, navigationService, settingsService\", \") \\n{ \\n    _settingsService = settingsService; \\n \\n    _identityEndpoint = _settingsService.IdentityEn\", \"dpointBase; \\n} \\n \\npublic string IdentityEndpoint \\n \\n49 \\nCHAPTER 8 | Application settings management \", \"\\n \\n{ \\n    get => _identityEndpoint; \\n    set \\n    { \\n        SetProperty(ref _identityEndpoint, valu\", \"e); \\n \\n        if (!string.IsNullOrWhiteSpace(value)) \\n        { \\n            UpdateIdentityEndpoint\", \"(); \\n        } \\n    } \\n} \\nWhen the IdentityEndpoint property is set, the UpdateIdentityEndpoint meth\", \"od is called, provided \\nthat the supplied value is valid. The following code example shows the Updat\", \"eIdentityEndpoint \\nmethod: \\nprivate void UpdateIdentityEndpoint() \\n{ \\n    _settingsService.IdentityE\", \"ndpointBase = _identityEndpoint; \\n} \\nThis method updates the IdentityEndpointBase property in the IS\", \"ettingService interface \\nimplementation with the base endpoint URL value entered by the user. If the\", \" SettingsService class is \\nprovided as the implementation for _settingsService, the value will persi\", \"st to platform-specific storage. \\nSummary \\nSettings allow the separation of data that configures the\", \" behavior of an app from the code, allowing \\nthe behavior to be changed without rebuilding the app. \", \"App settings are data that an app creates and \\nmanages, and user settings are the customizable setti\", \"ngs of an app that affect the app\\u2019s behavior and \\ndon\\u2019t require frequent re-adjustment. \\nThe Microso\", \"ft.Maui.Storage.Preferences class provides a consistent, type-safe, cross-platform \\napproach for per\", \"sisting and retrieving app and user settings. \\n \\n50 \\nCHAPTER 9 | Containerized microservices \\n \\nCHAP\", \"TER 9 \\nContainerized \\nmicroservices \\nDeveloping client-server applications has resulted in a focus o\", \"n building tiered applications that use \\nspecific technologies in each tier. Such applications are o\", \"ften referred to as monolithic and are \\npackaged onto hardware pre-scaled for peak loads. The main d\", \"rawbacks of this development \\napproach are the tight coupling between components within each tier, t\", \"hat individual components \\ncan\\u2019t be easily scaled, and the cost of testing. A simple update can have\", \" unforeseen effects on the rest \\nof the tier, so a change to an application component requires its e\", \"ntire tier to be retested and \\nredeployed. \\nParticularly concerning, in the age of the cloud, is tha\", \"t individual components can\\u2019t be easily scaled. A \\nmonolithic application contains domain-specific f\", \"unctionality and is typically divided by functional \\nlayers such as front-end, business logic, and d\", \"ata storage. The image below illustrates that a \\nmonolithic application is scaled by cloning the ent\", \"ire application onto multiple machines. \\n \\n51 \\nCHAPTER 9 | Containerized microservices \\n \\n \\nMicroser\", \"vices \\nMicroservices offer a different approach to application development and deployment, an approa\", \"ch \\nthat\\u2019s suited to the agility, scale, and reliability requirements of modern cloud applications. \", \"A \\nmicroservices application is split into independent components that work together to deliver the \", \"\\napplication\\u2019s overall functionality. The term microservice emphasizes that applications should be \\n\", \"composed of services small enough to reflect particular concerns, so each microservice implements a \", \"\\nsingle function. In addition, each microservice has well-defined contracts with which other \\nmicros\", \"ervices communicate and share data. Typical examples of microservices include shopping carts, \\ninven\", \"tory processing, purchase subsystems, and payment processing. \\nMicroservices can scale independently\", \" compared to giant monolithic applications that scale together. \\nThis means that a specific function\", \"al area that requires more processing power or network bandwidth \\nto support demand can be scaled ra\", \"ther than unnecessarily scaling out other application areas. The \\nimage below illustrates this appro\", \"ach, where microservices are deployed and scaled independently, \\ncreating instances of services acro\", \"ss machines. \\n \\n52 \\nCHAPTER 9 | Containerized microservices \\n \\n \\nMicroservice scale-out can be nearl\", \"y instantaneous, allowing an application to adapt to changing \\nloads. For example, a single microser\", \"vice in the web-facing functionality of an application might be \\nthe only microservice that needs to\", \" scale out to handle additional incoming traffic. \\nThe classic model for application scalability is \", \"to have a load-balanced, stateless tier with a shared \\nexternal datastore to store persistent data. \", \"Stateful microservices manage their own persistent data, \\nusually storing it locally on the servers \", \"on which they are placed, to avoid the overhead of network \\naccess and complexity of cross-service o\", \"perations. This enables the fastest possible processing of data \\nand can eliminate the need for cach\", \"ing systems. In addition, scalable stateful microservices usually \\npartition data among their instan\", \"ces, in order to manage data size and transfer throughput beyond \\nwhich a single server can support.\", \" \\nMicroservices also support independent updates. This loose coupling between microservices provides\", \" \\na rapid and reliable application evolution. Their independent, distributed nature helps rolling up\", \"dates, \\nwhere only a subset of instances of a single microservice will update at any given time. The\", \"refore, if a \\nproblem is detected, a buggy update can be rolled back, before all instances update wi\", \"th the faulty \\ncode or configuration. Similarly, microservices typically use schema versioning, so t\", \"hat clients see a \\nconsistent version when updates are being applied, regardless of which microservi\", \"ce instance is being \\ncommunicated with. \\nTherefore, microservice applications have many benefits ov\", \"er monolithic applications: \\n\\u2022 \\nEach microservice is relatively small, easy to manage and evolve. \\n\\u2022\", \" \\nEach microservice can be developed and deployed independently of other services. \\n\\u2022 \\nEach microser\", \"vice can be scaled-out independently. For example, a catalog service or \\nshopping basket service mig\", \"ht need to be scaled-out more than an ordering service. \\n \\n53 \\nCHAPTER 9 | Containerized microservic\", \"es \\n \\nTherefore, the resulting infrastructure will more efficiently consume resources when scaling \\n\", \"out. \\n\\u2022 \\nEach microservice isolates any issues. For example, if there is an issue in a service it on\", \"ly \\nimpacts that service. The other services can continue to handle requests. \\n\\u2022 \\nEach microservice \", \"can use the latest technologies. Because microservices are autonomous and \\nrun side-by-side, the lat\", \"est technologies and frameworks can be used, rather than being \\nforced to use an older framework tha\", \"t might be used by a monolithic application. \\nHowever, a microservice-based solution also has potent\", \"ial drawbacks: \\n\\u2022 \\nChoosing how to partition an application into microservices can be challenging, a\", \"s each \\nmicroservice has to be completely autonomous, end-to-end, including responsibility for its \\n\", \"data sources. \\n\\u2022 \\nDevelopers must implement inter-service communication, which adds complexity and l\", \"atency \\nto the application. \\n\\u2022 \\nAtomic transactions between multiple microservices usually aren\\u2019t po\", \"ssible. Therefore, \\nbusiness requirements must embrace eventual consistency between microservices. \\n\", \"\\u2022 \\nIn production, there is an operational complexity in deploying and managing a system \\ncompromised\", \" of many independent services. \\n\\u2022 \\nDirect client-to-microservice communication can make it difficult\", \" to refactor the contracts of \\nmicroservices. For example, over time how the system is partitioned i\", \"nto services might need \\nto change. A single service might split into two or more services, and two \", \"services might \\nmerge. When clients communicate directly with microservices, this refactoring work c\", \"an break \\ncompatibility with client apps. \\nContainerization \\nContainerization is an approach to soft\", \"ware development in which an application and its versioned set \\nof dependencies, plus its environmen\", \"t configuration abstracted as deployment manifest files, are \\npackaged together as a container image\", \", tested as a unit, and deployed to a host operating system. \\nA container is an isolated, resource c\", \"ontrolled, and portable operating environment, where an \\napplication can run without touching the re\", \"sources of other containers, or the host. Therefore, a \\ncontainer looks and acts like a newly instal\", \"led physical computer or a virtual machine. \\nThere are many similarities between containers and virt\", \"ual machines, as illustrated below. \\n \\n54 \\nCHAPTER 9 | Containerized microservices \\n \\n \\nA container \", \"runs an operating system, has a file system, and can be accessed over a network as if it \\nwere a phy\", \"sical or virtual machine. However, the technology and concepts used by containers are very \\ndifferen\", \"t from virtual machines. Virtual machines include the applications, the required dependencies, \\nand \", \"a full guest operating system. Containers include the application and its dependencies, but share \\nt\", \"he operating system with other containers, running as isolated processes on the host operating \\nsyst\", \"em (aside from Hyper-V containers which run inside of a special virtual machine per container). \\nThe\", \"refore, containers share resources and typically require fewer resources than virtual machines. \\nThe\", \" advantage of a container-oriented development and deployment approach is that it eliminates \\nmost o\", \"f the issues that arise from inconsistent environment setups and the problems that come with \\nthem. \", \"In addition, containers permit fast application scale-up functionality by instancing new \\ncontainers\", \" as required. \\nThe key concepts when creating and working with containers are: \\nConcept \\nDescription\", \" \\nContainer Host \\nThe physical or virtual machine configured to \\nhost containers. The container host\", \" will run one \\nor more containers. \\nContainer Image \\nAn image consists of a union of layered \\nfilesy\", \"stems stacked on top of each other, and is \\nthe basis of a container. An image does not \\nhave state \", \"and it never changes as it\\u2019s deployed \\nto different environments. \\nContainer \\nA container is a runti\", \"me instance of an image. \\n \\n55 \\nCHAPTER 9 | Containerized microservices \\n \\nConcept \\nDescription \\nCon\", \"tainer OS Image \\nContainers are deployed from images. The \\ncontainer operating system image is the f\", \"irst \\nlayer in potentially many image layers that make \\nup a container. A container operating system\", \" is \\nimmutable, and can\\u2019t be modified. \\nContainer Repository \\nEach time a container image is created\", \", the \\nimage and its dependencies are stored in a local \\nrepository. These images can be reused many\", \" \\ntimes on the container host. The container \\nimages can also be stored in a public or private \\nregi\", \"stry, such as Docker Hub, so that they can \\nbe used across different container hosts. \\nEnterprises a\", \"re increasingly adopting containers when implementing microservice-based applications, \\nand Docker h\", \"as become the standard container implementation that has been adopted by most \\nsoftware platforms an\", \"d cloud vendors. \\nThe eShop reference application uses Docker to host four containerized back-end mi\", \"croservices, as \\nillustrated in the diagram below. \\n \\n56 \\nCHAPTER 9 | Containerized microservices \\n \", \"\\n \\nThe architecture of the back-end services in the reference application is decomposed into multipl\", \"e \\nautonomous sub-systems in the form of collaborating microservices and containers. Each microservi\", \"ce \\nprovides a single area of functionality: an identity service, a catalog service, an ordering ser\", \"vice, and a \\nbasket service. \\nEach microservice has its own database, allowing it to be fully decoup\", \"led from the other \\nmicroservices. Where necessary, consistency between databases from different mic\", \"roservices is \\nachieved using application-level events. For more information, see Communication betw\", \"een \\nmicroservices. \\nCommunication between client and microservices \\nThe eShop multi-platform app co\", \"mmunicates with the containerized back-end microservices using \\ndirect client-to-microservice commun\", \"ication, as shown below. \\n \\n57 \\nCHAPTER 9 | Containerized microservices \\n \\n \\nWith direct client-to-m\", \"icroservice communication, the multi-platform app makes requests to each \\nmicroservice directly thro\", \"ugh its public endpoint, with a different TCP port per microservice. In \\nproduction, the endpoint wo\", \"uld typically map to the microservice\\u2019s load balancer, which distributes \\nrequests across the availa\", \"ble instances. \\nTip \\nConsider using API gateway communication. \\nDirect client-to-microservice commun\", \"ication can have drawbacks when building a large and complex \\nmicroservice-based application, but it\", \"\\u2019s more than adequate for a small application. Consider using \\nAPI gateway communication when design\", \"ing a large microservice-based application with tens of \\nmicroservices. \\nCommunication between micro\", \"services \\nA microservices-based application is a distributed system, potentially running on multiple\", \" machines. \\nEach service instance is typically a process. Therefore, services must interact using an\", \" inter-process \\ncommunication protocol, such as HTTP, TCP, Advanced Message Queuing Protocol (AMQP),\", \" or binary \\nprotocols, depending on the nature of each service. \\nThe two common approaches for micro\", \"service-to-microservice communication are HTTP-based REST \\ncommunication when querying for data, and\", \" lightweight asynchronous messaging when \\ncommunicating updates across multiple microservices. \\nAsyn\", \"chronous messaging-based event-driven communication is critical when propagating changes \\nacross mul\", \"tiple microservices. With this approach, a microservice publishes an event when something \\nnotable h\", \"appens, for example, when it updates a business entity. Other microservices subscribe to \\nthese even\", \"ts. Then, when a microservice receives an event, it updates its own business entities, which \\nmight,\", \" in turn, lead to more events being published. This publish-subscribe functionality is usually \\nachi\", \"eved with an event bus. \\n \\n58 \\nCHAPTER 9 | Containerized microservices \\n \\nAn event bus allows publis\", \"h-subscribe communication between microservices without requiring the \\ncomponents to be explicitly a\", \"ware of each other, as shown below. \\n \\nFrom an application perspective, the event bus is simply a pu\", \"blish-subscribe channel exposed via an \\ninterface. However, the way the event bus is implemented can\", \" vary. For example, an event bus \\nimplementation could use RabbitMQ, Azure Service Bus, or other ser\", \"vice buses such as NServiceBus \\nand MassTransit. The diagram below shows how an event bus is used in\", \" the eShop reference \\napplication. \\n \\nThe eShop event bus, implemented using RabbitMQ, provides one-\", \"to-many asynchronous publish-\\nsubscribe functionality. This means that after publishing an event, th\", \"ere can be multiple subscribers \\nlistening for the same event. The diagram below illustrates this re\", \"lationship. \\n \\n59 \\nCHAPTER 9 | Containerized microservices \\n \\n \\nThis one-to-many communication appro\", \"ach uses events to implement business transactions that span \\nmultiple services, ensuring eventual c\", \"onsistency between the services. An eventual-consistent \\ntransaction consists of a series of distrib\", \"uted steps. Therefore, when the user-profile microservice \\nreceives the UpdateUser command, it updat\", \"es the user\\u2019s details in its database and publishes the \\nUserUpdated event to the event bus. Both th\", \"e basket microservice and the ordering microservice have \\nsubscribed to receive this event, and in r\", \"esponse, update their buyer information in their respective \\ndatabases. \\nSummary \\nMicroservices offe\", \"r an approach to application development and deployment that\\u2019s suited to the \\nagility, scale, and re\", \"liability requirements of modern cloud applications. One of the main advantages \\nof microservices is\", \" that they can be scaled-out independently, which means that a specific functional \\narea can be scal\", \"ed that requires more processing power or network bandwidth to support demand \\nwithout unnecessarily\", \" scaling areas of the application that are not experiencing increased demand. \\nA container is an iso\", \"lated, resource-controlled, and portable operating environment where an \\napplication can run without\", \" touching the resources of other containers or the host. Enterprises are \\nincreasingly adopting cont\", \"ainers when implementing microservice-based applications, and Docker \\nhas become the standard contai\", \"ner implementation that most software platforms and cloud vendors \\nhave adopted. \\n \\n60 \\nCHAPTER 10 |\", \" Accessing remote data \\n \\nCHAPTER 10 \\nAccessing remote data \\nMany modern web-based solutions make us\", \"e of web services, hosted by web servers, to provide \\nfunctionality for remote client applications. \", \"The operations that a web service exposes constitute a \\nweb API. \\nClient apps should be able to util\", \"ize the web API without knowing how the data or operations that the \\nAPI exposes are implemented. Th\", \"is requires that the API abides by common standards that enable a \\nclient app and web service to agr\", \"ee on which data formats to use, and the structure of the data that is \\nexchanged between client app\", \"s and the web service. \\nIntroduction to Representational State Transfer \\nRepresentational State Tran\", \"sfer (REST) is an architectural style for building distributed systems based \\non hypermedia. A prima\", \"ry advantage of the REST model is that it\\u2019s based on open standards and \\ndoesn\\u2019t bind the implementa\", \"tion of the model or the client apps that access it to any specific \\nimplementation. Therefore, a RE\", \"ST web service could be implemented using Microsoft ASP.NET Core, \\nand client apps could be developi\", \"ng using any language and toolset that can generate HTTP requests \\nand parse HTTP responses. \\nThe RE\", \"ST model uses a navigational scheme to represent objects and services over a network, referred \\nto a\", \"s resources. Systems that implement REST typically use the HTTP protocol to transmit requests to \\nac\", \"cess these resources. In such systems, a client app submits a request in the form of a URI that \\nide\", \"ntifies a resource, and an HTTP method (such as GET, POST, PUT, or DELETE) that indicates the \\nopera\", \"tion to be performed on that resource. The body of the HTTP request contains any data required \\nto p\", \"erform the operation. \\nNote \\nREST defines a stateless request model. Therefore, HTTP requests must b\", \"e independent and might \\noccur in any order. \\nThe response from a REST request makes use of standard\", \" HTTP status codes. For example, a request \\nthat returns valid data should include the HTTP response\", \" code 200 (OK), while a request that fails to \\nfind or delete a specified resource should return a r\", \"esponse that includes the HTTP status code 404 \\n(Not Found). \\nA RESTful web API exposes a set of con\", \"nected resources, and provides the core operations that \\nenable an app to manipulate those resources\", \" and easily navigate between them. For this reason, the \\nURIs that constitute a typical RESTful web \", \"API are oriented towards the data that it exposes, and use \\nthe facilities provided by HTTP to opera\", \"te on this data. \\n \\n61 \\nCHAPTER 10 | Accessing remote data \\n \\nThe data included by a client app in a\", \"n HTTP request, and the corresponding response messages from \\nthe web server, could be presented in \", \"a variety of formats, known as media types. When a client app \\nsends a request that returns data in \", \"the body of a message, it can specify the media types it can \\nhandle in the Accept header of the req\", \"uest. If the web server supports this media type, it can reply \\nwith a response that includes the Co\", \"ntent-Type header that specifies the format of the data in the \\nbody of the message. It\\u2019s then the r\", \"esponsibility of the client app to parse the response message and \\ninterpret the results in the mess\", \"age body appropriately. \\nFor more information about REST, see API design and API implementation on M\", \"icrosoft Docs. \\nConsuming RESTful APIs \\nThe eShop multi-platform app uses the Model-View-ViewModel (\", \"MVVM) pattern, and the model \\nelements of the pattern represent the domain entities used in the app.\", \" The controller and repository \\nclasses in the eShop reference application accept and return many of\", \" these model objects. Therefore, \\nthey are used as data transfer objects (DTOs) that hold all the da\", \"ta that is passed between the app \\nand the containerized microservices. The main benefit of using DT\", \"Os to pass data to and receive data \\nfrom a web service is that by transmitting more data in a singl\", \"e remote call, the app can reduce the \\nnumber of remote calls that need to be made. \\nMaking web requ\", \"ests \\nThe eShop multi-platform app uses the HttpClient class to make requests over HTTP, with JSON b\", \"eing \\nused as the media type. This class provides functionality for asynchronously sending HTTP requ\", \"ests \\nand receiving HTTP responses from a URI identified resource. The HttpResponseMessage class \\nre\", \"presents an HTTP response message received from a REST API after an HTTP request has been \\nmade. It \", \"contains information about the response, including the status code, headers, and any body. \\nThe Http\", \"Content class represents the HTTP body and content headers, such as Content-Type and \\nContent-Encodi\", \"ng. The content can be read using any of the ReadAs methods, such as \\nReadAsStringAsync and ReadAsBy\", \"teArrayAsync, depending on the format of the data. \\nMaking a GET request \\nThe CatalogService class i\", \"s used to manage the data retrieval process from the catalog microservice. \\nIn the RegisterViewModel\", \"s method in the MauiProgram class, the CatalogService class is registered as \\na type mapping against\", \" the ICatalogService type with the dependency injection container. Then, when \\nan instance of the Ca\", \"talogViewModel class is created, its constructor accepts an ICatalogService type, \\nwhich the depende\", \"ncy injection container resolves, returning an instance of the CatalogService class. \\nFor more infor\", \"mation about dependency injection, see Dependency Injection. \\nThe image below shows the interaction \", \"of classes that read catalog data from the catalog microservice \\nfor displaying by the CatalogView. \", \"\\n \\n62 \\nCHAPTER 10 | Accessing remote data \\n \\n \\nWhen the CatalogView is navigated to, the OnInitializ\", \"e method in the CatalogViewModel class is \\ncalled. This method retrieves catalog data from the catal\", \"og microservice, as demonstrated in the \\nfollowing code example: \\npublic override async Task Initial\", \"izeAsync() \\n{ \\n    Products = await _productsService.GetCatalogAsync(); \\n}  \\nThis method calls the G\", \"etCatalogAsync method of the CatalogService instance that was injected into \\nthe CatalogViewModel by\", \" the dependency injection container. The following code example shows the \\nGetCatalogAsync method: \\n\", \"public async Task<ObservableCollection<CatalogItem>> GetCatalogAsync() \\n{ \\n    UriBuilder builder = \", \"new UriBuilder(GlobalSetting.Instance.CatalogEndpoint); \\n    builder.Path = \\\"api/v1/catalog/items\\\"; \", \"\\n    string uri = builder.ToString(); \\n \\n    CatalogRoot? catalog = await _requestProvider.GetAsync<\", \"CatalogRoot>(uri); \\n \\n    return catalog?.Data;           \\n}  \\n \\n63 \\nCHAPTER 10 | Accessing remote d\", \"ata \\n \\nThis method builds the URI that identifies the resource the request will be sent to, and uses\", \" the \\nRequestProvider class to invoke the GET HTTP method on the resource, before returning the resu\", \"lts to \\nthe CatalogViewModel. The RequestProvider class contains functionality that submits a reques\", \"t in the \\nform of a URI that identifies a resource, an HTTP method that indicates the operation to b\", \"e performed \\non that resource, and a body that contains any data required to perform the operation. \", \"For \\ninformation about how the RequestProvider class is injected into the CatalogService class, see \", \"\\nDependency Injection. \\nThe following code example shows the GetAsync method in the RequestProvider \", \"class: \\npublic async Task<TResult> GetAsync<TResult>(string uri, string token = \\\"\\\") \\n{ \\n    HttpClie\", \"nt httpClient = GetOrCreateHttpClient(token); \\n    HttpResponseMessage response = await httpClient.G\", \"etAsync(uri); \\n \\n    await HandleResponse(response); \\n    TResult result = await response.Content.Re\", \"adFromJsonAsync<TResult>(); \\n \\n    return result; \\n} \\nThis method calls the GetOrCreateHttpClient me\", \"thod, which returns an instance of the HttpClient class \\nwith the appropriate headers set. It then s\", \"ubmits an asynchronous GET request to the resource \\nidentified by the URI, with the response being s\", \"tored in the HttpResponseMessage instance. The \\nHandleResponse method is then invoked, which throws \", \"an exception if the response doesn\\u2019t include a \\nsuccess HTTP status code. Then the response is read \", \"as a string, converted from JSON to a \\nCatalogRoot object, and returned to the CatalogService. \\nThe \", \"GetOrCreateHttpClient method is shown in the following code example: \\nprivate readonly Lazy<HttpClie\", \"nt> _httpClient = \\n    new Lazy<HttpClient>( \\n        () => \\n        { \\n            var httpClient =\", \" new HttpClient(); \\n            httpClient.DefaultRequestHeaders.Accept.Add(new \\nMediaTypeWithQualit\", \"yHeaderValue(\\\"application/json\\\")); \\n            return httpClient; \\n        }, \\n        LazyThreadSa\", \"fetyMode.ExecutionAndPublication); \\n \\nprivate HttpClient GetOrCreateHttpClient(string token = \\\"\\\") \\n \", \"   { \\n        var httpClient = _httpClient.Value; \\n \\n        if (!string.IsNullOrEmpty(token)) \\n    \", \"    { \\n            httpClient.DefaultRequestHeaders.Authorization = new \\nAuthenticationHeaderValue(\\\"\", \"Bearer\\\", token); \\n        } \\n        else \\n        { \\n            httpClient.DefaultRequestHeaders.A\", \"uthorization = null; \\n        } \\n \\n \\n64 \\nCHAPTER 10 | Accessing remote data \\n \\n        return httpCl\", \"ient; \\n    } \\nThis method uses creates a new instance or retrieves a cached instance of the HttpClie\", \"nt class, and \\nsets the Accept header of any requests made by the HttpClient instance to application\", \"/json, which \\nindicates that it expects the content of any response to be formatted using JSON. Then\", \", if an access \\ntoken was passed as an argument to the GetOrCreateHttpClient method, it\\u2019s added to t\", \"he \\nAuthorization header of any requests made by the HttpClient instance, prefixed with the string B\", \"earer. \\nFor more information about authorization, see Authorization. \\nTip \\nIt is highly recommended \", \"to cache and reuse instances of the HttpClient for better application \\nperformance. Creating a new H\", \"ttpClient for each operation can lead to issue with socket exhaustion. \\nFor more information, see Ht\", \"tpClient Instancing on the Microsoft Developer Center. \\nWhen the GetAsync method in the RequestProvi\", \"der class calls HttpClient.GetAsync, the Items method \\nin the CatalogController class in the Catalog\", \".API project is invoked, which is shown in the following \\ncode example: \\n[HttpGet] \\n[Route(\\\"[action]\", \"\\\")] \\npublic async Task<IActionResult> Items( \\n    [FromQuery]int pageSize = 10, [FromQuery]int pageI\", \"ndex = 0) \\n{ \\n    var totalItems = await _catalogContext.CatalogItems \\n        .LongCountAsync(); \\n \", \"\\n    var itemsOnPage = await _catalogContext.CatalogItems \\n        .OrderBy(c => c.Name) \\n        .S\", \"kip(pageSize * pageIndex) \\n        .Take(pageSize) \\n        .ToListAsync(); \\n \\n    itemsOnPage = Com\", \"posePicUri(itemsOnPage); \\n    var model = new PaginatedItemsViewModel<CatalogItem>( \\n        pageInd\", \"ex, pageSize, totalItems, itemsOnPage);            \\n \\n    return Ok(model); \\n} \\nThis method retrieve\", \"s the catalog data from the SQL database using EntityFramework, and returns it \\nas a response messag\", \"e that includes a success HTTP status code, and a collection of JSON formatted \\nCatalogItem instance\", \"s. \\nMaking a POST request \\nThe BasketService class is used to manage the data retrieval and update p\", \"rocess with the basket \\nmicroservice. In the RegisterAppServices method in the MauiProgram class, th\", \"e BasketService class is \\nregistered as a type mapping against the IBasketService type with the depe\", \"ndency injection container. \\nThen, when an instance of the BasketViewModel class is created, its con\", \"structor accepts an \\n \\n65 \\nCHAPTER 10 | Accessing remote data \\n \\nIBasketService type, which the depe\", \"ndency injection container resolves, returning an instance of the \\nBasketService class. For more inf\", \"ormation about dependency injection, see Dependency Injection. \\nThe image below shows the interactio\", \"n of classes that send the basket data displayed by the \\nBasketView, to the basket microservice. \\n \\n\", \"When an item is added to the shopping basket, the ReCalculateTotalAsync method in the \\nBasketViewMod\", \"el class is called. This method updates the total value of items in the basket, and sends \\nthe baske\", \"t data to the basket microservice, as demonstrated in the following code example: \\nprivate async Tas\", \"k ReCalculateTotalAsync() \\n{ \\n    // Omitted for brevity... \\n \\n    await _basketService.UpdateBasket\", \"Async( \\n        new CustomerBasket \\n        { \\n            BuyerId = userInfo.UserId,  \\n            \", \"Items = BasketItems.ToList() \\n        },  \\n        authToken); \\n} \\n \\n66 \\nCHAPTER 10 | Accessing remo\", \"te data \\n \\nThis method calls the UpdateBasketAsync method of the BasketService instance that was inj\", \"ected into \\nthe BasketViewModel by the dependency injection container. The following method shows th\", \"e \\nUpdateBasketAsync method: \\npublic async Task<CustomerBasket> UpdateBasketAsync( \\n    CustomerBask\", \"et customerBasket, string token) \\n{ \\n    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.\", \"BasketEndpoint); \\n    string uri = builder.ToString(); \\n    var result = await _requestProvider.Post\", \"Async(uri, customerBasket, token); \\n    return result; \\n} \\nThis method builds the URI that identifie\", \"s the resource the request will be sent to, and uses the \\nRequestProvider class to invoke the POST H\", \"TTP method on the resource, before returning the results \\nto the BasketViewModel. Note that an acces\", \"s token, obtained from IdentityServer during the \\nauthentication process, is required to authorize r\", \"equests to the basket microservice. For more \\ninformation about authorization, see Authorization. \\nT\", \"he following code example shows one of the PostAsync methods in the RequestProvider class: \\npublic a\", \"sync Task<TResult> PostAsync<TResult>( \\n    string uri, TResult data, string token = \\\"\\\", string head\", \"er = \\\"\\\") \\n{ \\n    HttpClient httpClient = GetOrCreateHttpClient(token); \\n \\n    var content = new Stri\", \"ngContent(JsonSerializer.Serialize(data)); \\n    content.Headers.ContentType = new MediaTypeHeaderVal\", \"ue(\\\"application/json\\\"); \\n    HttpResponseMessage response = await httpClient.PostAsync(uri, content)\", \"; \\n \\n    await HandleResponse(response); \\n    TResult result = await response.Content.ReadFromJsonAs\", \"ync<TResult>(); \\n     \\n    return result; \\n} \\nThis method calls the GetOrCreateHttpClient method, wh\", \"ich returns an instance of the HttpClient class \\nwith the appropriate headers set. It then submits a\", \"n asynchronous POST request to the resource \\nidentified by the URI, with the serialized basket data \", \"being sent in JSON format, and the response \\nbeing stored in the HttpResponseMessage instance. The H\", \"andleResponse method is then invoked, \\nwhich throws an exception if the response doesn\\u2019t include a s\", \"uccess HTTP status code. Then, the \\nresponse is read as a string, converted from JSON to a CustomerB\", \"asket object, and returned to the \\nBasketService. For more information about the GetOrCreateHttpClie\", \"nt method, see Making a GET \\nrequest. \\nWhen the PostAsync method in the RequestProvider class calls \", \"HttpClient.PostAsync, the Post method \\nin the BasketController class in the Basket.API project is in\", \"voked, which is shown in the following code \\nexample: \\n[HttpPost] \\npublic async Task<IActionResult> \", \"Post([FromBody] CustomerBasket value) \\n{ \\n    var basket = await _repository.UpdateBasketAsync(value\", \"); \\n    return Ok(basket); \\n}  \\n \\n67 \\nCHAPTER 10 | Accessing remote data \\n \\nThis method uses an inst\", \"ance of the RedisBasketRepository class to persist the basket data to the \\nRedis cache, and returns \", \"it as a response message that includes a success HTTP status code, and a \\nJSON formatted CustomerBas\", \"ket instance. \\nMaking a DELETE request \\nThe image below shows the interactions of classes that delet\", \"e basket data from the basket \\nmicroservice, for the CheckoutView. \\n \\nWhen the checkout process is i\", \"nvoked, the CheckoutAsync method in the CheckoutViewModel class is \\ncalled. This method creates a ne\", \"w order, before clearing the shopping basket, as demonstrated in the \\nfollowing code example: \\npriva\", \"te async Task CheckoutAsync() \\n{ \\n    // Omitted for brevity... \\n \\n    await _basketService.ClearBas\", \"ketAsync( \\n        _shippingAddress.Id.ToString(), authToken); \\n} \\nThis method calls the ClearBasket\", \"Async method of the BasketService instance that was injected into \\nthe CheckoutViewModel by the depe\", \"ndency injection container. The following method shows the \\nClearBasketAsync method: \\npublic async T\", \"ask ClearBasketAsync(string guidUser, string token) \\n{ \\n    UriBuilder builder = new(GlobalSetting.I\", \"nstance.BasketEndpoint); \\n    builder.Path = guidUser; \\n    string uri = builder.ToString(); \\n    aw\", \"ait _requestProvider.DeleteAsync(uri, token); \\n} \\n \\n68 \\nCHAPTER 10 | Accessing remote data \\n \\nThis m\", \"ethod builds the URI that identifies the resource that the request will be sent to, and uses the \\nRe\", \"questProvider class to invoke the DELETE HTTP method on the resource. Note that an access token, \\nob\", \"tained from IdentityServer during the authentication process, is required to authorize requests to \\n\", \"the basket microservice. For more information about authorization, see Authorization. \\nThe following\", \" code example shows the DeleteAsync method in the RequestProvider class: \\npublic async Task DeleteAs\", \"ync(string uri, string token = \\\"\\\") \\n{ \\n    HttpClient httpClient = GetOrCreateHttpClient(token); \\n  \", \"  await httpClient.DeleteAsync(uri); \\n} \\nThis method calls the GetOrCreateHttpClient method, which r\", \"eturns an instance of the HttpClient class \\nwith the appropriate headers set. It then submits an asy\", \"nchronous DELETE request to the resource \\nidentified by the URI. For more information about the GetO\", \"rCreateHttpClient method, see Making a \\nGET request. \\nWhen the DeleteAsync method in the RequestProv\", \"ider class calls HttpClient.DeleteAsync, the Delete \\nmethod in the BasketController class in the Bas\", \"ket.API project is invoked, which is shown in the \\nfollowing code example: \\n[HttpDelete(\\\"{id}\\\")] \\npu\", \"blic void Delete(string id) => \\n    _repository.DeleteBasketAsync(id); \\nThis method uses an instance\", \" of the RedisBasketRepository class to delete the basket data from the \\nRedis cache. \\nCaching data \\n\", \"The performance of an app can be improved by caching frequently accessed data to fast storage \\nthat\\u2019\", \"s located close to the app. If the fast storage is located closer to the app than the original sourc\", \"e, \\nthen caching can significantly improve response times when retrieving data. \\nThe most common for\", \"m of caching is read-through caching, where an app retrieves data by \\nreferencing the cache. If the \", \"data isn\\u2019t in the cache, it\\u2019s retrieved from the data store and added to the \\ncache. Apps can implem\", \"ent read-through caching with the cache-aside pattern. This pattern \\ndetermines whether the item is \", \"currently in the cache. If the item isn\\u2019t in the cache, it\\u2019s read from the \\ndata store and added to \", \"the cache. For more information, see the Cache-Aside pattern on Microsoft \\nDocs. \\nTip \\nCache data th\", \"at\\u2019s read frequently and changes infrequently. \\nThis data can be added to the cache on demand the fi\", \"rst time it is retrieved by an app. This means \\nthat the app needs to fetch the data only once from \", \"the data store, and that subsequent access can \\nbe satisfied by using the cache. \\n \\n69 \\nCHAPTER 10 |\", \" Accessing remote data \\n \\nDistributed applications, such as the eShop reference application, should \", \"provide either or both of the \\nfollowing caches: \\n\\u2022 \\nA shared cache, which can be accessed by multip\", \"le processes or machines. \\n\\u2022 \\nA private cache, where data is held locally on the device running the \", \"app. \\nThe eShop multi-platform app uses a private cache, where data is held locally on the device th\", \"at\\u2019s \\nrunning an instance of the app. \\nTip \\nThink of the cache as a transient data store that could \", \"disappear at any time. \\nEnsure that data is maintained in the original data store as well as the cac\", \"he. The chances of losing \\ndata are then minimized if the cache becomes unavailable. \\nManaging data \", \"expiration \\nIt\\u2019s impractical to expect that cached data will always be consistent with the original \", \"data. Data in the \\noriginal data store might change after it\\u2019s been cached, causing the cached data \", \"to become stale. \\nTherefore, apps should implement a strategy that helps to ensure that the data in \", \"the cache is as up-\\nto-date as possible, but can also detect and handle situations that arise when t\", \"he data in the cache \\nhas become stale. Most caching mechanisms enable the cache to be configured to\", \" expire data, and \\nhence reduce the period for which data might be out of date. \\nTip \\nSet a default \", \"expiration time when configuring a cache. \\nMany caches implement expiration, which invalidates data \", \"and removes it from the cache if it\\u2019s not \\naccessed for a specified period. However, care must be ta\", \"ken when choosing the expiration period. If \\nit\\u2019s made too short, data will expire too quickly and t\", \"he benefits of caching will be reduced. If it\\u2019s \\nmade too long, the data risks becoming stale. There\", \"fore, the expiration time should match the pattern \\nof access for apps that use the data. \\nWhen cach\", \"ed data expires, it should be removed from the cache, and the app must retrieve the data \\nfrom the o\", \"riginal data store and place it back into the cache. \\nIt\\u2019s also possible that a cache might fill up \", \"if data is allowed to remain for too long a period. Therefore, \\nrequests to add new items to the cac\", \"he might be required to remove some items in a process known \\nas eviction. Caching services typicall\", \"y evict data on a least-recently-used basis. However, there are \\nother eviction policies, including \", \"most-recently-used, and first-in-first-out. For more information, see \\nCaching Guidance on Microsoft\", \" Docs. \\nCaching images \\nThe eShop multi-platform app consumes remote product images that benefit fro\", \"m being cached. \\nThese images are displayed by the Image control. The .NET MAUI Image control suppor\", \"ts caching of \\n \\n70 \\nCHAPTER 10 | Accessing remote data \\n \\ndownloaded images which has caching enabl\", \"ed by default, and will store the image locally for 24 \\nhours. In addition, the expiration time can \", \"be configured with the CacheValidity property. For more \\ninformation, see Downloaded Image Caching o\", \"n the Microsoft Developer Center. \\nIncreasing resilience \\nAll apps that communicate with remote serv\", \"ices and resources must be sensitive to transient faults. \\nTransient faults include the momentary lo\", \"ss of network connectivity to services, the temporary \\nunavailability of a service, or timeouts that\", \" arise when a service is busy. These faults are often self-\\ncorrecting, and if the action is repeate\", \"d after a suitable delay it\\u2019s likely to succeed. \\nTransient faults can have a huge impact on the per\", \"ceived quality of an app, even if it has been \\nthoroughly tested under all foreseeable circumstances\", \". To ensure that an app that communicates with \\nremote services operates reliably, it must be able t\", \"o do all of the following: \\n\\u2022 \\nDetect faults when they occur, and determine if the faults are likely\", \" to be transient. \\n\\u2022 \\nRetry the operation if it determines that the fault is likely to be transient \", \"and keep track of the \\nnumber of times the operation was retried. \\n\\u2022 \\nUse an appropriate retry strat\", \"egy, which specifies the number of retries, the delay between \\neach attempt, and the actions to take\", \" after a failed attempt. \\nThis transient fault handling can be achieved by wrapping all attempts to \", \"access a remote service in \\ncode that implements the retry pattern. \\nRetry pattern \\nIf an app detect\", \"s a failure when it tries to send a request to a remote service, it can handle the failure \\nin any o\", \"f the following ways: \\n\\u2022 \\nRetrying the operation. The app could retry the failing request immediatel\", \"y. \\n\\u2022 \\nRetrying the operation after a delay. The app should wait for a suitable amount of time befor\", \"e \\nretrying the request. \\n\\u2022 \\nCancelling the operation. The application should cancel the operation a\", \"nd report an \\nexception. \\nThe retry strategy should be tuned to match the business requirements of t\", \"he app. For example, it\\u2019s \\nimportant to optimize the retry count and retry interval to the operation\", \" being attempted. If the \\noperation is part of a user interaction, the retry interval should be shor\", \"t and only a few retries \\nattempted to avoid making users wait for a response. If the operation is p\", \"art of a long running \\nworkflow, where cancelling or restarting the workflow is expensive or time-co\", \"nsuming, it\\u2019s appropriate \\nto wait longer between attempts and to retry more times. \\nNote \\nAn aggres\", \"sive retry strategy with minimal delay between attempts, and a large number of retries, \\ncould degra\", \"de a remote service that\\u2019s running close to or at capacity. In addition, such a retry strategy \\ncoul\", \"d also affect the responsiveness of the app if it\\u2019s continually trying to perform a failing operatio\", \"n. \\n \\n71 \\nCHAPTER 10 | Accessing remote data \\n \\nIf a request still fails after a number of retries, \", \"it\\u2019s better for the app to prevent further requests going \\nto the same resource and to report a fail\", \"ure. Then, after a set period, the app can make one or more \\nrequests to the resource to see if they\", \"\\u2019re successful. For more information, see Circuit breaker pattern. \\nTip \\nNever implement an endless \", \"retry mechanism. Instead, prefer an exponential backoff. \\nUse a finite number of retries, or impleme\", \"nt the Circuit Breaker pattern to allow a service to recover. \\nThe eShop reference application does \", \"implement the retry pattern. \\nFor more information about the retry pattern, see the Retry pattern on\", \" Microsoft Docs. \\nCircuit breaker pattern \\nIn some situations, faults can occur due to anticipated e\", \"vents that take longer to fix. These faults can \\nrange from a partial loss of connectivity to the co\", \"mplete failure of a service. In these situations, it\\u2019s \\npointless for an app to retry an operation t\", \"hat\\u2019s unlikely to succeed, and instead should accept that \\nthe operation has failed and handle this \", \"failure accordingly. \\nThe circuit breaker pattern can prevent an app from repeatedly trying to execu\", \"te an operation that\\u2019s \\nlikely to fail, while also enabling the app to detect whether the fault has \", \"been resolved. \\nNote \\nThe purpose of the circuit breaker pattern is different from the retry pattern\", \". The retry pattern enables \\nan app to retry an operation in the expectation that it\\u2019ll succeed. The\", \" circuit breaker pattern prevents \\nan app from performing an operation that\\u2019s likely to fail. \\nA cir\", \"cuit breaker acts as a proxy for operations that might fail. The proxy should monitor the number \\nof\", \" recent failures that have occurred, and use this information to decide whether to allow the \\noperat\", \"ion to proceed, or to return an exception immediately. \\nThe eShop multi-platform app does not curren\", \"tly implement the circuit breaker pattern. However, the \\neShop does. \\nTip \\nCombine the retry and cir\", \"cuit breaker patterns. \\nAn app can combine the retry and circuit breaker patterns by using the retry\", \" pattern to invoke an \\noperation through a circuit breaker. However, the retry logic should be sensi\", \"tive to any exceptions \\nreturned by the circuit breaker and abandon retry attempts if the circuit br\", \"eaker indicates that a fault \\nis not transient. \\nFor more information about the circuit breaker patt\", \"ern, see the Circuit Breaker pattern on Microsoft \\nDocs. \\n \\n72 \\nCHAPTER 10 | Accessing remote data \\n\", \" \\nSummary \\nMany modern web-based solutions make use of web services, hosted by web servers, to provi\", \"de \\nfunctionality for remote client applications. The operations that a web service exposes constitu\", \"te a \\nweb API, and client apps should be able to utilize the web API without knowing how the data or\", \" \\noperations that the API exposes are implemented. \\nThe performance of an app can be improved by cac\", \"hing frequently accessed data to fast storage \\nthat\\u2019s located close to the app. Apps can implement r\", \"ead-through caching with the cache-aside \\npattern. This pattern determines whether the item is curre\", \"ntly in the cache. If the item isn\\u2019t in the \\ncache, it\\u2019s read from the data store and added to the c\", \"ache. \\nWhen communicating with web APIs, apps must be sensitive to transient faults. Transient fault\", \"s \\ninclude the momentary loss of network connectivity to services, the temporary unavailability of a\", \" \\nservice, or timeouts that arise when a service is busy. These faults are often self-correcting, an\", \"d if the \\naction is repeated after a suitable delay, then it\\u2019s likely to succeed. Therefore, apps sh\", \"ould wrap all \\nattempts to access a web API in code that implements a transient fault handling mecha\", \"nism. \\n \\n73 \\nCHAPTER 11 | Authentication and authorization \\n \\nCHAPTER 11 \\nAuthentication and \\nauthor\", \"ization \\nAuthentication is the process of obtaining identification credentials such as name and pass\", \"word from \\na user and validating those credentials against an authority. The entity that submitted t\", \"he credentials \\nis considered an authenticated identity if the credentials are valid. Once an identi\", \"ty has been \\nestablished, an authorization process determines whether that identity has access to a \", \"given resource. \\nThere are many approaches to integrating authentication and authorization into a .N\", \"ET MAUI app that \\ncommunicates with an ASP.NET web application, including using ASP.NET Core Identit\", \"y, external \\nauthentication providers such as Microsoft, Google, Facebook, or Twitter, and authentic\", \"ation \\nmiddleware. The eShop multi-platform app performs authentication and authorization with a \\nco\", \"ntainerized identity microservice that uses IdentityServer. The app requests security tokens from \\nI\", \"dentityServer to authenticate a user or access a resource. For IdentityServer to issue tokens on beh\", \"alf \\nof a user, the user must sign in to IdentityServer. However, IdentityServer doesn\\u2019t provide a u\", \"ser \\ninterface or database for authentication. Therefore, in the eShop reference application, ASP.NE\", \"T Core \\nIdentity is used for this purpose. \\nAuthentication \\nAuthentication is required when an appli\", \"cation needs to know the current user\\u2019s identity. ASP.NET \\nCore\\u2019s primary mechanism for identifying \", \"users is the ASP.NET Core Identity membership system, \\nwhich stores user information in a data store\", \" configured by the developer. Typically, this data store \\nwill be an EntityFramework store, though c\", \"ustom stores or third-party packages can be used to store \\nidentity information in Azure storage, Do\", \"cumentDB, or other locations. \\nFor authentication scenarios that use a local user datastore and pers\", \"ist identity information between \\nrequests via cookies (as is typical in ASP.NET web applications), \", \"ASP.NET Core Identity is a suitable \\nsolution. However, cookies are not always a natural means of pe\", \"rsisting and transmitting data. For \\nexample, an ASP.NET Core web application that exposes RESTful e\", \"ndpoints that are accessed from an \\napp will typically need to use bearer token authentication since\", \" cookies can\\u2019t be used in this scenario. \\nHowever, bearer tokens can easily be retrieved and include\", \"d in the authorization header of web \\nrequests made from the app. \\n \\n74 \\nCHAPTER 11 | Authentication\", \" and authorization \\n \\nIssuing bearer tokens using IdentityServer \\nIdentityServer is an open-source O\", \"penID Connect and OAuth 2.0 framework for ASP.NET Core, which \\ncan be used for many authentication a\", \"nd authorization scenarios, including issuing security tokens for \\nlocal ASP.NET Core Identity users\", \". \\nNote \\nOpenID Connect and OAuth 2.0 are very similar, while having different responsibilities. \\nOp\", \"enID Connect is an authentication layer on top of the OAuth 2.0 protocol. OAuth 2 is a protocol \\ntha\", \"t allows applications to request access tokens from a security token service and use them to \\ncommun\", \"icate with APIs. This delegation reduces complexity in both client applications and APIs since \\nauth\", \"entication and authorization can be centralized. \\nOpenID Connect and OAuth 2.0 combine the two funda\", \"mental security concerns of authentication \\nand API access, and IdentityServer is an implementation \", \"of these protocols. \\nIn applications that use direct client-to-microservice communication, such as t\", \"he eShop reference \\napplication, a dedicated authentication microservice acting as a Security Token \", \"Service (STS) can be \\nused to authenticate users, as shown in the following diagram. For more inform\", \"ation about direct \\nclient-to-microservice communication, see Microservices. \\n \\nThe eShop multi-plat\", \"form app communicates with the identity microservice, which uses IdentityServer \\nto perform authenti\", \"cation, and access control for APIs. Therefore, the multi-platform app requests \\ntokens from Identit\", \"yServer, either for authenticating a user or for accessing a resource: \\n\\u2022 \\nAuthenticating users with\", \" IdentityServer is achieved by the multi-platform app requesting an \\nidentity token, representing an\", \" authentication process\\u2019s outcome. At a minimum, it contains \\nan identifier for the user and informa\", \"tion about how and when the user is authenticated. It \\ncan also include additional identity data. \\n\\u2022\", \" \\nAccessing a resource with IdentityServer is achieved by the multi-platform app requesting an \\nacce\", \"ss token, which allows access to an API resource. Clients request access tokens and \\nforward them to\", \" the API. Access tokens contain information about the client and the user, if \\npresent. APIs then us\", \"e that information to authorize access to their data. \\nNote \\nA client must be registered with Identi\", \"tyServer before it can successfully request tokens. For more \\ninformation on adding clients, see Def\", \"ining Clients. \\n \\n75 \\nCHAPTER 11 | Authentication and authorization \\n \\nAdding IdentityServer to a we\", \"b application \\nIn order for an ASP.NET Core web application to use IdentityServer, it must be added \", \"to the web \\napplication\\u2019s Visual Studio solution. For more information, see Setup and Overview in th\", \"e \\nIdentityServer documentation. Once IdentityServer is included in the web application\\u2019s Visual Stu\", \"dio \\nsolution, it must be added to its HTTP request processing pipeline to serve requests to OpenID \", \"\\nConnect and OAuth 2.0 endpoints. This is configured in the Identity.API project\\u2019s Program.cs, as \\nd\", \"emonstrated in the following code example: \\n \\n... \\n \\napp.UseIdentityServer(); \\nOrder matters in the \", \"web application\\u2019s HTTP request processing pipeline. Therefore, IdentityServer \\nmust be added to the \", \"pipeline before the UI framework that implements the login screen. \\nConfiguring IdentityServer \\nIden\", \"tityServer should be configured in the ConfigureServices method in the web application\\u2019s Startup \\ncl\", \"ass by calling the services.AddIdentityServer method, as demonstrated in the following code \\nexample\", \" from the eShop reference application: \\npublic void ConfigureServices(IServiceCollection services) \\n\", \"{ \\n    services \\n        .AddIdentityServer(x => x.IssuerUri = \\\"null\\\") \\n        .AddSigningCredentia\", \"l(Certificate.Get()) \\n        .AddAspNetIdentity<ApplicationUser>() \\n        .AddConfigurationStore(\", \"builder => \\n            builder.UseSqlServer(connectionString, options => \\n                options.M\", \"igrationsAssembly(migrationsAssembly))) \\n        .AddOperationalStore(builder => \\n            builde\", \"r.UseSqlServer(connectionString, options => \\n                options.MigrationsAssembly(migrationsAs\", \"sembly))) \\n        .Services.AddTransient<IProfileService, ProfileService>(); \\n} \\nAfter calling the \", \"services.AddIdentityServer method, additional fluent APIs are called to configure the \\nfollowing: \\n\\u2022\", \" \\nCredentials used for signing. \\n\\u2022 \\nAPI and identity resources that users might request access to. \\n\", \"\\u2022 \\nClients that will be connecting to request tokens. \\n\\u2022 \\nASP.NET Core Identity. \\nTip \\nDynamically l\", \"oad the IdentityServer configuration. IdentityServer\\u2019s APIs allow for configuring \\nIdentityServer fr\", \"om an in-memory list of configuration objects. In the eShop reference application, \\nthese in-memory \", \"collections are hard-coded into the application. However, in production scenarios \\nthey can be loade\", \"d dynamically from a configuration file or from a database. \\n \\n76 \\nCHAPTER 11 | Authentication and a\", \"uthorization \\n \\nFor information about configuring IdentityServer to use ASP.NET Core Identity, see U\", \"sing ASP.NET \\nCore Identity in the IdentityServer documentation. \\nConfiguring API resources \\nWhen co\", \"nfiguring API resources, the AddInMemoryApiResources method expects an \\nIEnumerable<ApiResource> col\", \"lection. The following code example shows the GetApis method that \\nprovides this collection in the e\", \"Shop reference application: \\npublic static IEnumerable<ApiResource> GetApis() \\n{ \\n    return new Lis\", \"t<ApiResource> \\n    { \\n        new ApiScope(\\\"orders\\\", \\\"Orders Service\\\"), \\n        new ApiScope(\\\"bask\", \"et\\\", \\\"Basket Service\\\"), \\n        new ApiScope(\\\"webhooks\\\", \\\"Webhooks registration Service\\\"), \\n    }; \", \"\\n} \\nThis method specifies that IdentityServer should protect the orders and basket APIs. Therefore, \", \"\\nIdentityServer-managed access tokens will be required when making calls to these APIs. For more \\nin\", \"formation about the ApiResource type, see API Resource in the IdentityServer documentation. \\nConfigu\", \"ring identity resources \\nWhen configuring identity resources, the AddInMemoryIdentityResources metho\", \"d expects an \\nIEnumerable<IdentityResource> collection. Identity resources are data such as user ID,\", \" name, or email \\naddress. Each identity resource has a unique name, and arbitrary claim types can be\", \" assigned to it, \\nwhich will be included in the identity token for the user. The following code exam\", \"ple shows the \\nGetResources method that provides this collection in the eShop reference application:\", \" \\npublic static IEnumerable<IdentityResource> GetResources() \\n{ \\n    return new List<IdentityResourc\", \"e> \\n    { \\n        new IdentityResources.OpenId(), \\n        new IdentityResources.Profile() \\n    }; \", \"\\n} \\nThe OpenID Connect specification specifies some standard identity resources. The minimum \\nrequir\", \"ement is that support is provided for emitting a unique ID for users. This is achieved by \\nexposing \", \"the IdentityResources.OpenId identity resource. \\nNote \\nThe IdentityResources class supports all of t\", \"he scopes defined in the OpenID Connect specification \\n(openid, email, profile, telephone, and addre\", \"ss). \\nIdentityServer also supports defining custom identity resources. For more information, see Def\", \"ining \\ncustom identity resources in the IdentityServer documentation. For more information about the\", \" \\nIdentityResource type, see Identity Resource in the IdentityServer documentation. \\n \\n77 \\nCHAPTER 1\", \"1 | Authentication and authorization \\n \\nConfiguring clients \\nClients are applications that can reque\", \"st tokens from IdentityServer. Typically, the following settings \\nmust be defined for each client as\", \" a minimum: \\n\\u2022 \\nA unique client ID. \\n\\u2022 \\nThe allowed interactions with the token service (known as th\", \"e grant type). \\n\\u2022 \\nThe location where identity and access tokens are sent to (known as a redirect UR\", \"I). \\n\\u2022 \\nA list of resources that the client is allowed access to (known as scopes). \\nWhen configurin\", \"g clients, the AddInMemoryClients method expects an IEnumerable<Client> \\ncollection. The following c\", \"ode example shows the configuration for the eShop multi-platform app in \\nthe GetClients method that \", \"provides this collection in the eShop reference application: \\npublic static IEnumerable<Client> GetC\", \"lients(Dictionary<string,string> clientsUrl) \\n{ \\n    return new List<Client> \\n    { \\n        // Omit\", \"ted for brevity \\n        new Client \\n        { \\n            ClientId = \\\"maui\\\", \\n            ClientNa\", \"me = \\\"eShop .NET MAUI OpenId Client\\\", \\n            AllowedGrantTypes = GrantTypes.Hybrid, \\n         \", \"   ClientSecrets = \\n            { \\n                new Secret(\\\"secret\\\".Sha256()) \\n            }, \\n  \", \"          RedirectUris = { clientsUrl[\\\"maui\\\"] }, \\n            RequireConsent = false, \\n            R\", \"equirePkce = true, \\n            PostLogoutRedirectUris = { $\\\"{clientsUrl[\\\"maui\\\"]}/Account/Redirectin\", \"g\\\" }, \\n            AllowedCorsOrigins = { \\\"http://eshopmaui\\\" }, \\n            AllowedScopes = new Lis\", \"t<string> \\n            { \\n                IdentityServerConstants.StandardScopes.OpenId, \\n          \", \"      IdentityServerConstants.StandardScopes.Profile, \\n                IdentityServerConstants.Stand\", \"ardScopes.OfflineAccess, \\n                \\\"orders\\\", \\n                \\\"basket\\\" \\n            }, \\n     \", \"       AllowOfflineAccess = true, \\n            AllowAccessTokensViaBrowser = true, \\n            Acce\", \"ssTokenLifetime = 60 * 60 * 2, // 2 hours \\n            IdentityTokenLifetime = 60 * 60 * 2 // 2 hour\", \"s \\n        } \\n    }; \\n} \\nThis configuration specifies data for the following properties: \\nProperty \\n\", \"Description \\nClientId \\nA unique ID for the client. \\nClientName \\nThe client display name, which is us\", \"ed for \\nlogging and the consent screen. \\n \\n78 \\nCHAPTER 11 | Authentication and authorization \\n \\nProp\", \"erty \\nDescription \\nAllowedGrantTypes \\nSpecifies how a client wants to interact with \\nIdentityServer.\", \" For more information see \\nConfiguring the authentication flow. \\nClientSecrets \\nSpecifies the client\", \" secret credentials that are \\nused when requesting tokens from the token \\nendpoint. \\nRedirectUris \\nS\", \"pecifies the allowed URIs to which to return \\ntokens or authorization codes. \\nRequireConsent \\nSpecif\", \"ies whether a consent screen is required. \\nRequirePkce \\nSpecifies whether clients using an authoriza\", \"tion \\ncode must send a proof key. \\nPostLogoutRedirectUris \\nSpecifies the allowed URIs to redirect to\", \" after \\nlogout. \\nAllowedCorsOrigins \\nSpecifies the origin of the client so that \\nIdentityServer can \", \"allow cross-origin calls from \\nthe origin. \\nAllowedScopes \\nSpecifies the resources the client has ac\", \"cess to. \\nBy default, a client has no access to any \\nresources. \\nAllowOfflineAccess \\nSpecifies wheth\", \"er the client can request refresh \\ntokens. \\nAllowAccessTokensViaBrowser \\nSpecifies whether the clien\", \"t can receive access \\ntokens from a browser window. \\nAlwaysIncludeUserClaimsInIdToken \\nSpecifies tha\", \"t the user claims will always be \\nadded to the id token. By default, these would \\nhave to be retriev\", \"ed using the userinfo \\nendpoint. \\nAccessTokenLifetime \\nSpecifies the lifetime of the access token in\", \" \\nseconds. \\nIdentityTokenLifetime \\nSpecifies the lifetime of the identity token in \\nseconds. \\nConfig\", \"uring the authentication flow \\nThe authentication flow between a client and IdentityServer can be co\", \"nfigured by specifying the grant \\ntypes in the Client.AllowedGrantTypes property. The OpenID Connect\", \" and OAuth 2.0 specifications \\ndefine several authentication flows, including: \\n \\n79 \\nCHAPTER 11 | A\", \"uthentication and authorization \\n \\nAuthentication Flow \\nDescription \\nImplicit \\nThis flow is optimize\", \"d for browser-based \\napplications and should be used either for user \\nauthentication-only, or authen\", \"tication and \\naccess token requests. All tokens are \\ntransmitted via the browser, and therefore \\nadv\", \"anced features like refresh tokens are not \\npermitted. \\nAuthorization code \\nThis flow provides the a\", \"bility to retrieve tokens \\non a back channel, as opposed to the browser \\nfront channel, while also s\", \"upporting client \\nauthentication. \\nHybrid \\nThis flow is a combination of the implicit and \\nauthoriza\", \"tion code grant types. The identity \\ntoken is transmitted via the browser channel \\nand contains the \", \"signed protocol response and \\nother artifacts such as the authorization code. \\nAfter successfully va\", \"lidating the response, the \\nback channel should be used to retrieve the \\naccess and refresh token. \\n\", \"Tip \\nConsider using the hybrid authentication flow. The hybrid authentication flow mitigates a numbe\", \"r of \\nattacks that apply to the browser channel, and is the recommended flow for native applications\", \" that \\nwant to retrieve access tokens (and possibly refresh tokens). \\nFor more information about aut\", \"hentication flows, see Grant Types in the IdentityServer \\ndocumentation. \\nPerforming authentication \", \"\\nFor IdentityServer to issue tokens on behalf of a user, the user must sign in to IdentityServer. Ho\", \"wever, \\nIdentityServer doesn\\u2019t provide a user interface or database for authentication. Therefore, i\", \"n the eShop \\nreference application, ASP.NET Core Identity is used for this purpose. \\nThe eShop multi\", \"-platform app authenticates with IdentityServer with the hybrid authentication flow, \\nwhich is illus\", \"trated in the diagram below. \\n \\n80 \\nCHAPTER 11 | Authentication and authorization \\n \\n \\nA sign in req\", \"uest is made to <base endpoint>:5105/connect/authorize. Following successful \\nauthentication, Identi\", \"tyServer returns an authentication response containing an authorization code \\nand an identity token.\", \" The authorization code is sent to <base endpoint>:5105/connect/token, which \\nresponds with access, \", \"identity, and refresh tokens. \\nThe eShop multi-platform app signs out of IdentityServer by sending a\", \" request to <base \\nendpoint>:5105/connect/endsession with additional parameters. After sign-out, Ide\", \"ntityServer \\nresponds by sending a post-logout redirecting URI back to the multi-platform app. The d\", \"iagram \\nbelow illustrates this process. \\n \\nIn the eShop multi-platform app, communication with Ident\", \"ityServer is performed by the \\nIdentityService class, which implements the IIdentityService interfac\", \"e. This interface specifies that the \\nimplementing class must provide SignInAsync, SignOutAsync, Get\", \"UserInfoAsync and \\nGetAuthTokenAsync methods. \\nSigning-in \\nWhen the user taps the LOGIN button on th\", \"e LoginView, the SignInCommand in the LoginViewModel \\nclass is executed, which in turn executes the \", \"SignInAsync method. The following code example shows \\nthis method: \\n[RelayCommand] \\nprivate async Ta\", \"sk SignInAsync() \\n{ \\n    await IsBusyFor( \\n        async () => \\n        { \\n            var loginSucc\", \"ess = await _appEnvironmentService.IdentityService.SignInAsync(); \\n \\n            if (loginSuccess) \\n\", \"            { \\n                await NavigationService.NavigateToAsync(\\\"//Main/Catalog\\\"); \\n         \", \"   } \\n \\n81 \\nCHAPTER 11 | Authentication and authorization \\n \\n        }); \\n} \\nThis method invokes the\", \" SignInAsync method in the IdentityService class, as shown in the following \\ncode example: \\npublic a\", \"sync Task<bool> SignInAsync() \\n{ \\n    var response = await GetClient().LoginAsync(new LoginRequest()\", \").ConfigureAwait(false); \\n \\n    if (response.IsError) \\n    { \\n        return false; \\n    } \\n \\n    aw\", \"ait _settingsService \\n        .SetUserTokenAsync( \\n            new UserToken \\n            { \\n       \", \"         AccessToken = response.AccessToken, \\n                IdToken = response.IdentityToken, \\n   \", \"             RefreshToken = response.RefreshToken, \\n                ExpiresAt = response.AccessToken\", \"Expiration \\n            }) \\n        .ConfigureAwait(false); \\n \\n    return !response.IsError; \\n} \\nThe\", \" IdentityService makes use of the OidcClient provided with the IdentityModel.OidcClient NuGet \\npacka\", \"ge. This client displays the authentication web view to the user in the application and captures \\nth\", \"e authentication result. The client connects to the URI for IdentityServer\\u2019s authorization endpoint \", \"\\nwith the required parameters. The authorization endpoint is at /connect/authorize on port 5105 of t\", \"he \\nbase endpoint exposed as a user setting. For more information about user settings, see Configura\", \"tion \\nManagement. \\nNote \\nThe attack surface of the eShop multi-platform app is reduced by implementi\", \"ng the Proof Key for \\nCode Exchange (PKCE) extension to OAuth. PKCE protects the authorization code \", \"from being used if \\nit\\u2019s intercepted. This is achieved by the client generating a secret verifier, a\", \" hash of which is passed in \\nthe authorization request, and which is presented unhashed when redeemi\", \"ng the authorization code. \\nFor more information about PKCE, see Proof Key for Code Exchange by OAut\", \"h Public Clients on the \\nInternet Engineering Task Force web site. \\n \\n82 \\nCHAPTER 11 | Authenticatio\", \"n and authorization \\n \\n \\nIf the token endpoint receives valid authentication information, authorizat\", \"ion code, and PKCE secret \\nverifier, it responds with an access token, identity token, and refresh t\", \"oken. The access token (which \\nallows access to API resources) and identity token are stored as appl\", \"ication settings, and page \\nnavigation is performed. Therefore, the overall effect in the eShop mult\", \"i-platform app is this: provided \\nthat users are able to successfully authenticate with IdentityServ\", \"er, they are navigated to the \\n//Main/Catalog route, which is a TabbedPage that displays the Catalog\", \"View as its selected tab. \\n \\n83 \\nCHAPTER 11 | Authentication and authorization \\n \\nFor information ab\", \"out page navigation, see Navigation. For information about how WebView \\nnavigation causes a view mod\", \"el method to be executed, see Invoking navigation using behaviors. For \\ninformation about applicatio\", \"n settings, see Configuration management. \\nNote \\nThe eShop also allows a mock sign in when the app i\", \"s configured to use mock services in the \\nSettingsView. In this mode, the app doesn\\u2019t communicate wi\", \"th IdentityServer, instead allowing the \\nuser to sign in using any credentials. \\nSigning-out \\nWhen t\", \"he user taps the LOG OUT button in the ProfileView, the LogoutCommand in the \\nProfileViewModel class\", \" is executed, which executes the LogoutAsync method. This method performs \\npage navigation to the Lo\", \"ginView page, passing a Logout query parameter set to true. \\nThat parameter is evaluated in the Appl\", \"yQueryAttributes method. If the Logout parameter is present \\nwith a true value, the PerformLogoutAsy\", \"nc method of the LoginViewModel class is executed, which is \\nshown in the following code example: \\np\", \"rivate async Task PerformLogoutAsync() \\n{ \\n    await _appEnvironmentService.IdentityService.SignOutA\", \"sync(); \\n \\n    _settingsService.UseFakeLocation = false; \\n \\n    UserName.Value = string.Empty; \\n    \", \"Password.Value = string.Empty; \\n} \\nThis method invokes the SignOutAsync method in the IdentityServic\", \"e class, which invokes the \\nOidcClient to end the user\\u2019s session and clears any saved user tokens. F\", \"or more information about \\napplication settings, see Configuration management. The following code ex\", \"ample shows the \\nSignOutAsync method: \\npublic async Task<bool> SignOutAsync() \\n{ \\n    var response =\", \" await GetClient().LogoutAsync(new \\nLogoutRequest()).ConfigureAwait(false); \\n \\n    if (response.IsEr\", \"ror) \\n    { \\n        return false; \\n    } \\n \\n    await _settingsService.SetUserTokenAsync(default); \", \"\\n \\n    return !response.IsError; \\n} \\nThis method uses the OidcClient to call the URI to IdentityServ\", \"er\\u2019s end session endpoint with the \\nrequired parameters. The end session endpoint is at /connect/end\", \"session on port 5105 of the base \\nendpoint exposed as a user setting. Once the user has successfully\", \" signed out, LoginView is presented \\nto the user, and any saved user information will be cleared. \\n \", \"\\n84 \\nCHAPTER 11 | Authentication and authorization \\n \\nFor information about page navigation, see Nav\", \"igation. For information about how WebView \\nnavigation causes a view model method to be executed, se\", \"e Invoking navigation using behaviors. For \\ninformation about application settings, see Configuratio\", \"n management. \\nNote \\nThe eShop also allows a mock sign-out when the app is configured to use mock se\", \"rvices in the \\nSettingsView. In this mode, the app doesn\\u2019t communicate with IdentityServer, and inst\", \"ead clears any \\nstored tokens from application settings. \\nAuthorization \\nAfter authentication, ASP.N\", \"ET Core web APIs often need to authorize access, which allows a service to \\nmake APIs available to s\", \"ome authenticated users but not to all. \\nRestricting access to an ASP.NET Core route can be achieved\", \" by applying an Authorize attribute to a \\ncontroller or action, which limits access to the controlle\", \"r or action to authenticated users, as shown in \\nthe following code example: \\n[Authorize] \\npublic se\", \"aled class BasketController : Controller \\n{ \\n    // Omitted for brevity \\n} \\nIf an unauthorized user \", \"attempts to access a controller or action marked with the Authorize attribute, \\nthe API framework re\", \"turns a 401 (unauthorized) HTTP status code. \\nNote \\nParameters can be specified on the Authorize att\", \"ribute to restrict an API to specific users. For more \\ninformation, see ASP.NET Core Docs: Authoriza\", \"tion. \\nIdentityServer can be integrated into the authorization workflow so that the access tokens pr\", \"ovide \\ncontrol authorization. This approach is shown in the diagram below. \\n \\n85 \\nCHAPTER 11 | Authe\", \"ntication and authorization \\n \\n \\nThe eShop multi-platform app communicates with the identity microse\", \"rvice and requests an access \\ntoken as part of the authentication process. The access token is then \", \"forwarded to the APIs exposed \\nby the ordering and basket microservices as part of the access reques\", \"ts. Access tokens contain \\ninformation about the client and the user. APIs then use that information\", \" to authorize access to their \\ndata. For information about how to configure IdentityServer to protec\", \"t APIs, see Configuring API \\nresources. \\nConfiguring IdentityServer to perform authorization \\nTo per\", \"form authorization with IdentityServer, its authorization middleware must be added to the web \\nappli\", \"cation\\u2019s HTTP request pipeline. The middleware is added in the AddDefaultAuthentication \\nextension m\", \"ethod, which is invoked from the AddApplicationServices method in the Program class \\nand is demonstr\", \"ated in the following code example from the eShop reference application: \\npublic static IServiceColl\", \"ection AddDefaultAuthentication(this IHostApplicationBuilder \\nbuilder) \\n{ \\n    var services = builde\", \"r.Services; \\n    var configuration = builder.Configuration; \\n \\n    var identitySection = configurati\", \"on.GetSection(\\\"Identity\\\"); \\n \\n    if (!identitySection.Exists()) \\n    { \\n        // No identity sect\", \"ion, so no authentication \\n        return services; \\n    } \\n \\n    // prevent from mapping \\\"sub\\\" clai\", \"m to nameidentifier. \\n    JsonWebTokenHandler.DefaultInboundClaimTypeMap.Remove(\\\"sub\\\"); \\n \\n    servi\", \"ces.AddAuthentication().AddJwtBearer(options => \\n    { \\n \\n86 \\nCHAPTER 11 | Authentication and author\", \"ization \\n \\n        var identityUrl = identitySection.GetRequiredValue(\\\"Url\\\"); \\n        var audience \", \"= identitySection.GetRequiredValue(\\\"Audience\\\"); \\n \\n        options.Authority = identityUrl; \\n       \", \" options.RequireHttpsMetadata = false; \\n        options.Audience = audience; \\n        options.TokenV\", \"alidationParameters.ValidIssuers = [identityUrl]; \\n        options.TokenValidationParameters.Validat\", \"eAudience = false; \\n    }); \\n \\n    services.AddAuthorization(); \\n \\n    return services; \\n} \\nThis met\", \"hod ensures that the API can only be accessed with a valid access token. The middleware \\nvalidates t\", \"he incoming token to ensure that it\\u2019s sent from a trusted issuer and validates that the token \\nis va\", \"lid to be used with the API that receives it. Therefore, browsing to the ordering or basket \\ncontrol\", \"ler will return a 401 (unauthorized) HTTP status code, indicating that an access token is \\nrequired.\", \" \\nMaking access requests to APIs \\nWhen making requests to the ordering and basket microservices, the\", \" access token obtained from \\nIdentityServer during the authentication process must be included in th\", \"e request, as shown in the \\nfollowing code example: \\npublic async Task CreateOrderAsync(Models.Order\", \"s.Order newOrder) \\n{ \\n    var authToken = await _identityService.GetAuthTokenAsync().ConfigureAwait(\", \"false); \\n \\n    if (string.IsNullOrEmpty(authToken)) \\n    { \\n        return; \\n    } \\n \\n    var uri = \", \"$\\\"{UriHelper.CombineUri(_settingsService.GatewayOrdersEndpointBase, \\nApiUrlBase)}?api-version=1.0\\\"; \", \"\\n \\n    var success = await _requestProvider.PostAsync(uri, newOrder, authToken, \\\"x-\\nrequestid\\\").Conf\", \"igureAwait(false); \\n} \\nThe access token is stored with the IIdentityService implementation and can b\", \"e retrieved using the \\nGetAuthTokenAsync method. \\nSimilarly, the access token must be included when \", \"sending data to an IdentityServer protected API, as \\nshown in the following code example: \\npublic as\", \"ync Task ClearBasketAsync() \\n{ \\n    var authToken = await _identityService.GetAuthTokenAsync().Confi\", \"gureAwait(false); \\n \\n    if (string.IsNullOrEmpty(authToken)) \\n    { \\n        return; \\n \\n87 \\nCHAPTER\", \" 11 | Authentication and authorization \\n \\n    } \\n \\n    await GetBasketClient().DeleteBasketAsync(new\", \" DeleteBasketRequest(), \\nCreateAuthenticationHeaders(authToken)) \\n        .ConfigureAwait(false); \\n}\", \" \\nThe access token is retrieved from the IIdentityService and included in the call to the ClearBaske\", \"tAsync \\nmethod in the BasketService class. \\nThe RequestProvider class in the eShop multi-platform ap\", \"p uses the HttpClient class to make requests \\nto the RESTful APIs exposed by the eShop reference app\", \"lication. When making requests to the \\nordering and basket APIs, which require authorization, a vali\", \"d access token must be included with the \\nrequest. This is achieved by adding the access token to th\", \"e headers of the HttpClient instance, as \\ndemonstrated in the following code example: \\nhttpClient.De\", \"faultRequestHeaders.Authorization = new AuthenticationHeaderValue(\\\"Bearer\\\", to\\nken); \\nThe DefaultReq\", \"uestHeaders property of the HttpClient class exposes the headers that are sent with \\neach request, a\", \"nd the access token is added to the Authorization header prefixed with the string \\nBearer. When the \", \"request is sent to a RESTful API, the value of the Authorization header is extracted \\nand validated \", \"to ensure that it\\u2019s sent from a trusted issuer and used to determine whether the user \\nhas permissio\", \"n to invoke the API that receives it. \\nFor more information about how the eShop multi-platform app m\", \"akes web requests, see Accessing \\nremote data. \\nSummary \\nThere are many approaches to integrating au\", \"thentication and authorization into a .NET MAUI app that \\ncommunicates with an ASP.NET web applicati\", \"on. The eShop multi-platform app performs \\nauthentication and authorization with a containerized ide\", \"ntity microservice that uses IdentityServer. \\nIdentityServer is an open-source OpenID Connect and OA\", \"uth 2.0 framework for ASP.NET Core that \\nintegrates with ASP.NET Core Identity to perform bearer tok\", \"en authentication. \\nThe multi-platform app requests security tokens from IdentityServer to authentic\", \"ate a user or access a \\nresource. When accessing a resource, an access token must be included in the\", \" request to APIs that \\nrequire authorization. IdentityServer\\u2019s middleware validates incoming access \", \"tokens to ensure that \\nthey are sent from a trusted issuer and that they are valid to be used with t\", \"he API that receives them. \\n \\n88 \\nCHAPTER 12 | MVVM Toolkit Features \\n \\nCHAPTER 12 \\nMVVM Toolkit Fea\", \"tures \\nMVVM Toolkit \\nThe Model-View-ViewModel (MVVM) pattern is a great structural basis for creatin\", \"g our applications. \\nIn this pattern, the ViewModel becomes the backbone of our application as it pr\", \"ovides \\ncommunication to our front-end user interface and backing components. To provide integration\", \" with \\nthe user interface, we will rely on the ViewModel\\u2019s properties and commands. As detailed in U\", \"pdating \\nviews in response to changes in the underlying view model or model, the INotifyPropertyChan\", \"ged \\ninterface on our ViewModel to allows changes to our properties to notify when the value is chan\", \"ged. \\nImplementing all of these features means that our ViewModel can end up becoming very verbose. \", \"For \\nexample, the following code shows a simple ViewModel with properties that raise changes: \\npubli\", \"c class SampleViewModel : INotifyPropertyChanged \\n{ \\n    private string _name; \\n    private int _val\", \"ue; \\n \\n    public event PropertyChangedEventHandler PropertyChanged; \\n \\n    public string Name \\n    \", \"{ \\n        get => _name; \\n        set => SetPropertyValue(ref _name, value); \\n    } \\n \\n    public in\", \"t Value \\n    { \\n        get => _value; \\n        set => SetPropertyValue(ref _value, value); \\n    } \\n\", \" \\n    protected void SetPropertyValue<T>(ref T storageField, T newValue, [CallerMemberName] \\nstring \", \"propertyName = \\\"\\\") \\n    { \\n        if (Equals(storageField, newValue)) \\n            return; \\n \\n     \", \"   storageField = newValue; \\n        RaisePropertyChanged(propertyName); \\n    } \\n \\n    protected vir\", \"tual void RaisePropertyChanged([CallerMemberName] string propertyName = \\n\\\"\\\") \\n    { \\n        Propert\", \"yChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); \\n    } \\n} \\n \\n89 \\nCHAPTER 12 | MV\", \"VM Toolkit Features \\n \\nWhile some optimizations could be made over time, we will still end up with a\", \" fairly verbose set of \\ncode for defining our ViewModel. This code can be difficult to maintain and \", \"becomes error-prone. \\nThe CommunityToolkit.Mvvm NuGet Package (aka MVVM Toolkit) can be used to help\", \" address and \\nsimplify these common MVVM patterns. The MVVM Toolkit, along with newer features to th\", \"e .NET \\nlanguage, allows for simplified logic, easy adoption into a project, and runtime independenc\", \"e. The \\nexample below shows the same ViewModel using components that come with the MVVM Toolkit: \\npu\", \"blic partial class SampleViewModel : ObservableObject \\n{ \\n    [ObservableProperty] \\n    private stri\", \"ng _name; \\n \\n    [ObservableProperty] \\n    private int _value; \\n} \\n \\n \\nNote \\nThe MVVM Toolkit is pro\", \"vided with the CommunityToolkit.Mvvm package. For information on how to \\nadd the package to your pro\", \"ject, see Introduction to the MVVM Toolkit on the Microsoft Developer \\nCenter. \\nIn comparison to the\", \" original example, we were able to drastically reduce the overall complexity and \\nsimplify the maint\", \"ainability of our ViewModel. The MVVM Toolkit comes with many pre-built common \\ncomponents and featu\", \"res, such as the ObservableObject shown above, that simplifies and \\nstandardizes the code that we ha\", \"ve throughout the application. \\nObservableObject \\nThe MVVM Toolkit provides ObservableObject which i\", \"s intended for use as the base of our \\nViewModel objects or any object that needs to raise change no\", \"tifications. It implements \\nINotifyPropertyChanged and INotifyPropertyChanging along with helper met\", \"hods for setting \\nproperties and raising changes. Below is an example of a standard ViewModel using \", \"\\nObservableObject: \\npublic class SampleViewModel : ObservableObject \\n{ \\n    private string _name; \\n \", \"   private int _value; \\n \\n    public string Name \\n    { \\n        get => _name; \\n        set => SetPr\", \"operty(ref _name, value); \\n    } \\n \\n    public int Value \\n    { \\n        get => _value; \\n        set\", \" => SetProperty(ref _value, value); \\n \\n90 \\nCHAPTER 12 | MVVM Toolkit Features \\n \\n    } \\n} \\nObservabl\", \"eObject handles all of the logic needed for raising change notifications by using the \\nSetProperty m\", \"ethod in your property setter. If you have a property that returns a Task<T>, the \\nSetPropertyAndNot\", \"ifyOnCompletion method can be used to delay publishing a property change until \\nthe task has been co\", \"mpleted. The methods OnPropertyChanged and OnPropertyChanging that can \\nalso be used for raising pro\", \"perty changes where needed in your object. \\nFor more detailed information on ObservableObject, see O\", \"bservableObject in the MVVM Toolkit \\nDeveloper Center. \\nRelayCommand and AsyncRelayCommand \\nInteract\", \"ion between .NET MAUI controls (for example, tapping a button or selecting an item from a \\ncollectio\", \"n) and the ViewModel is done with the ICommand interface. .NET MAUI comes with a default \\nimplementa\", \"tion of ICommand with the Command object. .NET MAUI\\u2019s Command is fairly basic and \\nlacks support for\", \" more advanced features, such as supporting asynchronous work and command \\nexecution status. \\nThe MV\", \"VM Toolkit comes with two commands, RelayCommand and AsyncRelayCommand. \\nRelayCommand is intended fo\", \"r situations where you have synchronous code to execute and has a \\nfairly similar implementation to \", \"the .NET MAUI Command object. \\nNote \\nEven though the .NET MAUI Command and RelayCommand are similar,\", \" using RelayCommand allows \\nfor decoupling your ViewModel from any direct .NET MAUI references. This\", \" means that your \\nViewModel is more portable, leading to easier reuse across projects. \\nAsyncRelayCo\", \"mmand provides many additional features when working with asynchronous workflows. \\nThis is quite com\", \"mon in our ViewModel as we are typically communicating with repositories, APIs, \\ndatabases, and othe\", \"r systems that utilize async/await. The AsyncRelayCommand constructor takes in \\nan execution task de\", \"fined as a Func<Task> or a delegate returning Task as part of the constructor. \\nWhile the execution \", \"task is running, AsyncRelayCommand will monitor the state of the task and \\nprovides updates using th\", \"e IsRunning property. The IsRunning property can be bound to the UI which \\nhelps manage control stat\", \"es such as showing loading with an ActivityIndicator or disabling/enabling a \\ncontrol. While the exe\", \"cution task is being executed, the Cancel method can be called to attempt \\ncancellation of the execu\", \"tion task, if supported. \\nBy default, AsyncRelayCommand doesn\\u2019t allow concurrent execution. This is \", \"very helpful in situations \\nwhere a user could unintentionally tap a control multiple times to execu\", \"te a long-running or costly \\noperation. During task execution, AsyncRelayCommand will automatically \", \"call the CanExecuteChanged \\nevent. In .NET MAUI, controls that support the Command and CommandParame\", \"ter properties, such as \\nButton, will listen to this event and automatically enable or disable it du\", \"ring execution. This \\nfunctionality can be overridden by using a custom canExecute parameter or sett\", \"ing the \\nAsyncRelayCommandOptions.AllowConcurrentExecutions flag in the constructor. \\n \\n91 \\nCHAPTER \", \"12 | MVVM Toolkit Features \\n \\nFor more detailed information on implementing commands, see the sectio\", \"n Implementing commands \\nin the MVVM chapter. Detailed information for the RelayCommand and AsyncRel\", \"ayCommand is \\navailable in the Commanding of the MVVM Toolkit Developer Center. \\nSource Generators \\n\", \"Using the MVVM Toolkit components out-of-the-box allows you to greatly simplify our ViewModel. \\nThe \", \"MVVM Toolkit allows you to simplify common code use cases even further by using Source \\nGenerators. \", \"The MVVM Toolkit source generators look for specific attributes in our code and can \\ngenerate wrappe\", \"rs for properties and commands. \\nImportant \\nThe MVVM Toolkit Source Generators generate code that is\", \" additive to our existing objects. Because \\nof this, any object that is leveraging a source generato\", \"r will need to be marked as partial. \\nThe MVVM Toolkit ObservableProperty attribute can be applied t\", \"o fields in objects that inherit from \\nObservableObject and will wrap a private field with a propert\", \"y that generates changes. The following \\ncode shows an example of using the ObservableObject attribu\", \"te on the _name field: \\npublic partial class SampleViewModel : ObservableObject \\n{ \\n    [ObservableP\", \"roperty] \\n    private string _name; \\n} \\nWith the ObservableProperty attribute applied to the _name f\", \"ield, the source generator will run and \\ngenerate another partial class with the following code: \\npa\", \"rtial class SampleViewModel \\n{ \\n    public string Name \\n    { \\n        get => _name; \\n        set \\n \", \"       { \\n            if (!EqualityComparer<string>.Default.Equals(_name, value)) \\n            { \\n  \", \"              OnNameChanging(value); \\n                OnPropertyChanging(\\\"Name\\\"); \\n                _\", \"name = value; \\n                OnNameChanged(value); \\n                OnPropertyChanged(\\\"Name\\\"); \\n  \", \"          } \\n        } \\n    } \\n} \\nThe generated SampleViewModel has used the private _name field and\", \" generated a new Name \\nproperty that implements all of the logic needed for raising change notificat\", \"ions. \\n \\n92 \\nCHAPTER 12 | MVVM Toolkit Features \\n \\nThe MVVM Toolkit RelayCommand attribute can be ap\", \"plied to methods within an ObservableObject \\nand will create a corresponding RelayCommand or AsyncRe\", \"layCommand. The following code shows \\nexamples of using the RelayCommand attribute: \\npublic partial \", \"class SampleViewModel : ObservableObject \\n{ \\n    public INavigationService NavigationService { get; \", \"set; } \\n \\n    [ObservableProperty] \\n    private string _name; \\n \\n    [ObservableProperty] \\n    bool \", \"_isValid; \\n \\n    [RelayCommand] \\n    private Task SettingsAsync() \\n    { \\n        return NavigationS\", \"ervice.NavigateToAsync(\\\"Settings\\\"); \\n    } \\n \\n    [RelayCommand] \\n    private void Validate() \\n    {\", \" \\n        IsValid = !string.IsNullOrEmpty(Name); \\n    } \\n} \\nThe RelayCommand applied to the Validate\", \" method will generate a RelayCommand validate \\nValidateCommand because it has a void return and the \", \"SettingsAsync method will generate an \\nAsyncRelayCommand named SettingsCommand. The source generator\", \" will generate the following \\ncode in other partial classes: \\npartial class SampleViewModel \\n{ \\n    \", \"private AsyncRelayCommand? settingsCommand; \\n \\n    SettingsCommand => settingsCommand ??= new AsyncR\", \"elayCommand(SettingsAsync); \\n} \\n \\npartial class SampleViewModel \\n{ \\n    private RelayCommand? valida\", \"teCommand; \\n \\n    public IRelayCommand ValidateCommand => validateCommand ??= new RelayCommand(Valid\", \"ate); \\n} \\nAll of the complexity of wrapping our ViewModel\\u2019s methods with an ICommand implementation \", \"has \\nbeen handled by the source generator. \\nFor more detailed information on MVVM Toolkit Source Gen\", \"erators, see MVVM source generators in \\nthe MVVM Toolkit Developer Center. \\n \\n93 \\nCHAPTER 12 | MVVM \", \"Toolkit Features \\n \\nSummary \\nThe MVVM Toolkit is a great way to standardize and simplify our ViewMod\", \"el code. The MVVM toolkit \\noffers great implementations of standard MVVM components such as Observab\", \"leObject and \\nAsync/RelayCommand. The source generators help simplify our ViewModel properties and c\", \"ommands \\nby generating all of the boilerplate code needed for user interface interactions. The MVVM \", \"Toolkit \\noffers even more features outside of what has been shown in this chapter. For more informat\", \"ion on \\nthe MVVM Toolkit, see Introduction to the MVVM Toolkit in the MVVM Toolkit Developer Center.\", \" \\n \\n94 \\nCHAPTER 13 | Unit testing \\n \\nCHAPTER 13 \\nUnit testing \\nmulti-platform apps experience proble\", \"ms similar to both desktop and web-based applications. Mobile \\nusers will differ by their devices, n\", \"etwork connectivity, availability of services, and various other factors. \\nTherefore, multi-platform\", \" apps should be tested as they would be used in the real world to improve \\ntheir quality, reliabilit\", \"y, and performance. Many types of testing should be performed on an app, \\nincluding unit testing, in\", \"tegration testing, and user interface testing. Unit testing is the most common \\nform and essential t\", \"o building high-quality applications. \\nA unit test takes a small unit of the app, typically a method\", \", isolates it from the remainder of the code, \\nand verifies that it behaves as expected. Its goal is\", \" to check that each unit of functionality performs as \\nexpected, so errors don\\u2019t propagate throughou\", \"t the app. Detecting a bug where it occurs is more \\nefficient that observing the effect of a bug ind\", \"irectly at a secondary point of failure. \\nUnit testing has the most significant effect on code quali\", \"ty when it\\u2019s an integral part of the software \\ndevelopment workflow. Unit tests can act as design do\", \"cumentation and functional specifications for \\nan application. As soon as a method has been written,\", \" unit tests should be written that verify the \\nmethod\\u2019s behavior in response to standard, boundary, \", \"and incorrect input data cases and check any \\nexplicit or implicit assumptions made by the code. Alt\", \"ernatively, with test-driven development, unit \\ntests are written before the code. For more informat\", \"ion on test-driven development and how to \\nimplement it, see Walkthrough: Test-driven development us\", \"ing Test Explorer. \\nNote \\nUnit tests are very effective against regression. That is, functionality t\", \"hat used to work, but has been \\ndisturbed by a faulty update. \\nUnit tests typically use the arrange-\", \"act-assert pattern: \\nStep \\nDescription \\nArrange \\nInitializes objects and sets the value of the data \", \"\\nthat is passed to the method under test. \\nAct \\nInvokes the method under test with the required \\narg\", \"uments. \\nAssert \\nVerifies that the action of the method under test \\nbehaves as expected. \\nThis patte\", \"rn ensures that unit tests are readable, self-describing, and consistent. \\n \\n95 \\nCHAPTER 13 | Unit t\", \"esting \\n \\nDependency injection and unit testing \\nOne of the motivations for adopting a loosely-coupl\", \"ed architecture is that it facilitates unit testing. \\nOne of the types registered with the dependenc\", \"y injection service is the IAppEnvironmentService \\ninterface. The following code example shows an ou\", \"tline of this class: \\npublic class OrderDetailViewModel : ViewModelBase \\n{ \\n    private IAppEnvironm\", \"entService _appEnvironmentService; \\n \\n    public OrderDetailViewModel( \\n        IAppEnvironmentServi\", \"ce appEnvironmentService, \\n        IDialogService dialogService, INavigationService navigationServic\", \"e, \\nISettingsService settingsService) \\n        : base(dialogService, navigationService, settingsServ\", \"ice) \\n    { \\n        _appEnvironmentService = appEnvironmentService; \\n    } \\n} \\nThe OrderDetailViewM\", \"odel class has a dependency on the IAppEnvironmentService type, which the \\ndependency injection cont\", \"ainer resolves when it instantiates an OrderDetailViewModel object. \\nHowever, rather than create an \", \"IAppEnvironmentService object which utilizes real servers, devices and \\nconfigurations to unit test \", \"the OrderDetailViewModel class, instead, replace the \\nIAppEnvironmentService object with a mock obje\", \"ct for the purpose of the tests. A mock object is one \\nthat has the same signature of an object or a\", \"n interface, but is created in a specific manner to help \\nwith unit testing. It is often used with d\", \"ependency injection to provide specific implementations of \\ninterfaces for testing different data an\", \"d workflow scenarios. \\nThis approach allows the IAppEnvironmentService object to be passed into the \", \"OrderDetailViewModel \\nclass at runtime, and in the interests of testability, it allows a mock class \", \"to be passed into the \\nOrderDetailViewModel class at test time. The main advantage of this approach \", \"is that it enables unit \\ntests to be executed without requiring unwieldy resources such as runtime p\", \"latform features, web \\nservices, or databases. \\nTesting MVVM applications \\nTesting models and view m\", \"odels from MVVM applications is identical to testing any other class, and \\nuses the same tools and t\", \"echniques; this includes features such as unit testing and mocking. However, \\nsome patterns that are\", \" typical to model and view model classes can benefit from specific unit testing \\ntechniques. \\nTip \\nT\", \"est one thing with each unit test. As the complexity of a test expands, it makes verification of tha\", \"t \\ntest more difficult. By limiting a unit test to a single concern, we can ensure that our tests ar\", \"e more \\nrepeatable, isolated, and have a smaller execution time. See \\nUnit testing best practices wi\", \"th .NET for more best practices. \\n \\n96 \\nCHAPTER 13 | Unit testing \\n \\nDon\\u2019t be tempted to make a unit\", \" test exercise more than one aspect of the unit\\u2019s behavior. Doing so \\nleads to tests that are diffic\", \"ult to read and update. It can also lead to confusion when interpreting a \\nfailure. \\nThe eShop multi\", \"-platform app uses MSTest to perform unit testing, which supports two different \\ntypes of unit tests\", \": \\nTesting Type \\nAttribute \\nDescription \\nTestMethod \\nTestMethod \\nDefines the actual test method to r\", \"un.. \\nDataSource \\nDataSource \\nTests that are only true for a particular set of data. \\nThe unit tests\", \" included with the eShop multi-platform app are TestMethod, so each unit test method \\nis decorated w\", \"ith the TestMethod attribute. In addition to MSTest there are several other testing \\nframeworks avai\", \"lable including NUnit and xUnit. \\nTesting asynchronous functionality \\nWhen implementing the MVVM pat\", \"tern, view models usually invoke operations on services, often \\nasynchronously. Tests for code that \", \"invokes these operations typically use mocks as replacements for \\nthe actual services. The following\", \" code example demonstrates testing asynchronous functionality by \\npassing a mock service into a view\", \" model: \\n[TestMethod] \\npublic async Task OrderPropertyIsNotNullAfterViewModelInitializationTest() \\n{\", \" \\n    // Arrange \\n    var orderService = new OrderMockService(); \\n    var orderViewModel = new Order\", \"DetailViewModel(orderService); \\n \\n    // Act \\n    var order = await orderService.GetOrderAsync(1, Gl\", \"obalSetting.Instance.AuthToken); \\n    await orderViewModel.InitializeAsync(order); \\n \\n    // Assert \", \"\\n    Assert.IsNotNull(orderViewModel.Order); \\n} \\nThis unit test checks that the Order property of th\", \"e OrderDetailViewModel instance will have a value \\nafter the InitializeAsync method has been invoked\", \". The InitializeAsync method is invoked when the \\nview model\\u2019s corresponding view is navigated to. F\", \"or more information about navigation, see \\nNavigation. \\nWhen the OrderDetailViewModel instance is cr\", \"eated, it expects an IOrderService instance to be \\nspecified as an argument. However, the OrderServi\", \"ce retrieves data from a web service. Therefore, an \\nOrderMockService instance, a mock version of th\", \"e OrderService class, is specified as the argument to \\nthe OrderDetailViewModel constructor. Then, m\", \"ock data is retrieved rather than communicating with \\na web service when the view model\\u2019s Initialize\", \"Async method is invoked, which uses IOrderService \\noperations. \\n \\n97 \\nCHAPTER 13 | Unit testing \\n \\nT\", \"esting INotifyPropertyChanged implementations \\nImplementing the INotifyPropertyChanged interface all\", \"ows views to react to changes that originate \\nfrom view models and models. These changes are not lim\", \"ited to data shown in controls \\u2013 they are also \\nused to control the view, such as view model states \", \"that cause animations to be started or controls to \\nbe disabled. \\nProperties that can be updated dir\", \"ectly by the unit test can be tested by attaching an event handler to \\nthe PropertyChanged event and\", \" checking whether the event is raised after setting a new value for the \\nproperty. The following cod\", \"e example shows such a test: \\n[TestMethod] \\npublic async Task SettingOrderPropertyShouldRaisePropert\", \"yChanged() \\n{ \\n    var invoked = false; \\n    var orderService = new OrderMockService(); \\n    var ord\", \"erViewModel = new OrderDetailViewModel(orderService); \\n \\n    orderViewModel.PropertyChanged += (send\", \"er, e) => \\n    { \\n        if (e.PropertyName.Equals(\\\"Order\\\")) \\n            invoked = true; \\n    }; \\n\", \"    var order = await orderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken); \\n    await or\", \"derViewModel.InitializeAsync(order); \\n \\n    Assert.IsTrue(invoked); \\n} \\nThis unit test invokes the I\", \"nitializeAsync method of the OrderViewModel class, which causes its Order \\nproperty to be updated. T\", \"he unit test will pass, provided that the PropertyChanged event is raised for \\nthe Order property. \\n\", \"Testing message-based communication \\nView models that use the MessagingCenter class to communicate b\", \"etween loosely coupled classes \\ncan be unit tested by subscribing to the message being sent by the c\", \"ode under test, as demonstrated \\nin the following code example: \\n[TestMethod] \\npublic void AddCatalo\", \"gItemCommandSendsAddProductMessageTest() \\n{ \\n    var messageReceived = false; \\n    var catalogServic\", \"e = new CatalogMockService(); \\n    var catalogViewModel = new CatalogViewModel(catalogService); \\n \\n \", \"   MessagingCenter.Subscribe<CatalogViewModel, CatalogItem>( \\n        this, MessageKeys.AddProduct, \", \"(sender, arg) => \\n    { \\n        messageReceived = true; \\n    }); \\n    catalogViewModel.AddCatalogIt\", \"emCommand.Execute(null); \\n \\n \\n98 \\nCHAPTER 13 | Unit testing \\n \\n    Assert.IsTrue(messageReceived); \\n\", \"} \\nThis unit test checks that the CatalogViewModel publishes the AddProduct message in response to i\", \"ts \\nAddCatalogItemCommand being executed. Because the MessagingCenter class supports multicast \\nmess\", \"age subscriptions, the unit test can subscribe to the AddProduct message and execute a callback \\ndel\", \"egate in response to receiving it. This callback delegate, specified as a lambda expression, sets a \", \"\\nboolean field that\\u2019s used by the Assert statement to verify the behavior of the test. \\nTesting exce\", \"ption handling \\nUnit tests can also be written that check that specific exceptions are thrown for in\", \"valid actions or \\ninputs, as demonstrated in the following code example: \\n[TestMethod] \\npublic void \", \"InvalidEventNameShouldThrowArgumentExceptionText() \\n{ \\n    var behavior = new MockEventToCommandBeha\", \"vior \\n    { \\n        EventName = \\\"OnItemTapped\\\" \\n    }; \\n    var listView = new ListView(); \\n \\n    A\", \"ssert.Throws<ArgumentException>(() => listView.Behaviors.Add(behavior)); \\n} \\nThis unit test will thr\", \"ow an exception because the ListView control does not have an event named \\nOnItemTapped. The Assert.\", \"Throws<T> method is a generic method where T is the type of the \\nexpected exception. The argument pa\", \"ssed to the Assert.Throws<T> method is a lambda expression \\nthat will throw the exception. Therefore\", \", the unit test will pass provided that the lambda expression \\nthrows an ArgumentException. \\nTip \\nAv\", \"oid writing unit tests that examine exception message strings. Exception message strings might \\nchan\", \"ge over time, and so unit tests that rely on their presence are regarded as brittle. \\nTesting valida\", \"tion \\nThere are two aspects to testing the validation implementation: testing that any validation ru\", \"les are \\ncorrectly implemented and testing that the ValidatableObject<T> class performs as expected.\", \" \\nValidation logic is usually simple to test, because it is typically a self-contained process where\", \" the \\noutput depends on the input. There should be tests on the results of invoking the Validate met\", \"hod on \\neach property that has at least one associated validation rule, as demonstrated in the follo\", \"wing code \\nexample: \\n[TestMethod] \\npublic void CheckValidationPassesWhenBothPropertiesHaveDataTest()\", \" \\n{ \\n \\n99 \\nCHAPTER 13 | Unit testing \\n \\n    var mockViewModel = new MockViewModel(); \\n    mockViewMo\", \"del.Forename.Value = \\\"John\\\"; \\n    mockViewModel.Surname.Value = \\\"Smith\\\"; \\n \\n    var isValid = mockVi\", \"ewModel.Validate(); \\n \\n    Assert.IsTrue(isValid); \\n} \\nThis unit test checks that validation succeed\", \"s when the two ValidatableObject<T> properties in the \\nMockViewModel instance both have data. \\nAs we\", \"ll as checking that validation succeeds, validation unit tests should also check the values of the \\n\", \"Value, IsValid, and Errors property of each ValidatableObject<T> instance, to verify that the class \", \"\\nperforms as expected. The following code example demonstrates a unit test that does this: \\n[TestMet\", \"hod] \\npublic void CheckValidationFailsWhenOnlyForenameHasDataTest() \\n{ \\n    var mockViewModel = new \", \"MockViewModel(); \\n    mockViewModel.Forename.Value = \\\"John\\\"; \\n \\n    bool isValid = mockViewModel.Val\", \"idate(); \\n \\n    Assert.IsFalse(isValid); \\n    Assert.IsNotNull(mockViewModel.Forename.Value); \\n    A\", \"ssert.IsNull(mockViewModel.Surname.Value); \\n    Assert.IsTrue(mockViewModel.Forename.IsValid); \\n    \", \"Assert.IsFalse(mockViewModel.Surname.IsValid); \\n    Assert.AreEqual(mockViewModel.Forename.Errors.Co\", \"unt(), 0); \\n    Assert.AreNotEqual(mockViewModel.Surname.Errors.Count(), 0); \\n} \\nThis unit test chec\", \"ks that validation fails when the Surname property of the MockViewModel doesn\\u2019t \\nhave any data, and \", \"the Value, IsValid, and Errors property of each ValidatableObject<T> instance are \\ncorrectly set. \\nS\", \"ummary \\nA unit test takes a small unit of the app, typically a method, isolates it from the remainde\", \"r of the code, \\nand verifies that it behaves as expected. Its goal is to check that each unit of fun\", \"ctionality performs as \\nexpected, so errors don\\u2019t propagate throughout the app. \\nThe behavior of an \", \"object under test can be isolated by replacing dependent objects with mock \\nobjects that simulate th\", \"e behavior of the dependent objects. This enables unit tests to be executed \\nwithout requiring unwie\", \"ldy resources such as runtime platform features, web services, or databases \\nTesting models and view\", \" models from MVVM applications is identical to testing any other classes, and \\nthe same tools and te\", \"chniques can be used. \\n\"]"