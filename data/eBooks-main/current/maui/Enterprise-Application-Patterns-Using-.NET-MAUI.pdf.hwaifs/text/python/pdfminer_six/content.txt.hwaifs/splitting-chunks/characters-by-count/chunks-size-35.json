"[\" \\n \\n \\n\\fDOWNLOAD available at: https://aka.ms/maui-ebook \\n\\nEDITION v2.0 \\n\\nPUBLISHED BY \\n\\nMicrosoft De\", \"veloper Division, .NET, and Visual Studio product teams \\n\\nA division of Microsoft Corporation \\n\\nOne \", \"Microsoft Way \\n\\nRedmond, Washington 98052-6399 \\n\\nCopyright \\u00a9 2022 by Microsoft Corporation \\n\\nAll rig\", \"hts reserved. No part of the contents of this book may be reproduced or transmitted in any \\nform or \", \"by any means without the written permission of the publisher. \\n\\nThis book is provided \\u201cas-is\\u201d and ex\", \"presses the author\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in this boo\", \"k, including URL and other Internet website references, may change \\nwithout notice. \\n\\nSome examples \", \"depicted herein are provided for illustration only and are fictitious. No real association \\nor conne\", \"ction is intended or should be inferred. \\n\\nMicrosoft and the trademarks listed at https://www.micros\", \"oft.com on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies. \\n\\nMac and m\", \"acOS are trademarks of Apple Inc. \\n\\nAll other marks and logos are property of their respective owner\", \"s. \\n\\nAuthors: \\n\\nMichael Stonis, Mobile Software Architect, Eight-Bot \\n\\nReviewers: \\n\\nJames Montemagno\", \", Principal Lead Program Manager, Microsoft Corp. \\n\\nDavid Pine, Developer Relations, Microsoft Corp.\", \" \\n\\nAcknowledgments \\n\\nThis book originated from the excellent Enterprise Application Patterns using X\", \"amarin.Forms eBook by \\nDavid Britch and Javier Suarez Ruiz. Without their hard work, detailed inform\", \"ation, and excellent \\nexamples, this book would not be possible. \\n\\nIntroduction \\n\\nEnterprise applica\", \"tions face a number of difficult problems to solve including ever changing business \\nrequirements, t\", \"he need for quick turn around time, support for multiple platforms, and integration \\nwith multiple s\", \"ystems. Due to the varying nature of these problems, it\\u2019s important that our \\napplication\\u2019s architec\", \"ture allows it to be modular, modifiable and extensible over time. \\n\\n\\fThis book takes provides real \", \"world solutions for addressing these issues when building an enterprise \\napplication using .NET MAUI\", \". This book uses a pre-built .NET MAUI application that serves as the \\nfront-end of an online eComme\", \"rce application as a reference and a guide for common enterprise \\ndesign patterns. This book covers \", \"topics such as the MVVM pattern, dependency injection, navigation, \\nconfiguration, the loose-couplin\", \"g of components and additional enterprise concerns. The content of \\nthis book is helpful for anyone \", \"looking to build a new application for this business or looking to solve \\nthe problems of applicatio\", \"ns that evolve over time. \\n\\nWho should use the book \\n\\nThis book is for .NET MAUI developers that are\", \" already familiar with the framework, but that are \\nlooking for guidance on architecture and impleme\", \"ntation when building enterprise applications. This \\nbook can help developers solve common problems \", \"using tried and true patterns. \\n\\nHow to use the book \\n\\nThis book focuses on building cross-platform \", \"enterprise apps using .NET MAUI. As such, it should be \\nread in its entirety to provide a foundation\", \" of understanding such apps and their technical \\nconsiderations. The book, along with its sample app\", \", can also serve as a starting point or reference for \\ncreating a new enterprise app. Use the associ\", \"ated sample app as a template for the new app, or to see \\nhow to organize an app\\u2019s component parts. \", \"Then, refer back to this guide for architectural guidance. \\nYou can find the sample app on GitHub. \\n\", \"\\nWhat this book doesn\\u2019t cover \\n\\nThis book is aimed at readers who are already familiar with .NET MAU\", \"I. It does cover some concepts \\nof .NET MAUI to help better illustrate the topic, but it does not co\", \"ver most controls and concepts in \\nany detail. For general guidance on building a new .NET MAUI app,\", \" please refer to the Building your \\nfirst app guide in the .NET MAUI documentation. \\n\\nAdditional res\", \"ources \\n\\nFor official .NET MAUI content, see .NET MAUI docs. .NET MAUI is developed as an open-sourc\", \"e \\nproject and is available on GitHub at dotnet/maui. For code samples developed with .NET MAUI, see\", \" \\nthe dotnet/maui-samples repo. \\n\\n\\fContents \\n\\nPurpose ..............................................\", \"....................................................................................... 1 \\n\\nWhat\\u2019s l\", \"eft out of this guide\\u2019s scope ......................................................................\", \".......................................................... 1 \\n\\nWho should use this guide ...........\", \"....................................................................................................\", \"................................... 1 \\n\\nHow to use this guide ......................................\", \"....................................................................................................\", \".................. 2 \\n\\nIntroduction to .NET MAUI ...................................................\", \"................................................. 3 \\n\\nSample application ...........................\", \"....................................................................................................\", \"................................... 4 \\n\\nSample application architecture ............................\", \"....................................................................................................\", \"........ 5 \\n\\nMulti-Platform app ....................................................................\", \".............................................................................................. 6 \\n\\nM\", \"ulti-Platform app solution .........................................................................\", \"....................................................................... 7 \\n\\neShop project ..........\", \"....................................................................................................\", \".............................................................. 7 \\n\\nSummary .........................\", \"....................................................................................................\", \"........................................................ 8 \\n\\nModel-View-ViewModel (MVVM) ...........\", \".............................................................................. 9 \\n\\nThe MVVM pattern \", \"....................................................................................................\", \".............................................................. 9 \\n\\nView ............................\", \"....................................................................................................\", \"....................................................... 10 \\n\\nViewModel .............................\", \"....................................................................................................\", \"......................................... 11 \\n\\nModel ...............................................\", \"....................................................................................................\", \"................................. 11 \\n\\nConnecting view models to views .............................\", \"....................................................................................................\", \". 12 \\n\\nCreating a view model declaratively .........................................................\", \".................................................................... 12 \\n\\nCreating a view model prog\", \"rammatically .......................................................................................\", \"............................ 13 \\n\\nUpdating views in response to changes in the underlying view model\", \" or model...................................... 13 \\n\\nMVVM Frameworks ...............................\", \"....................................................................................................\", \"........................... 15 \\n\\nUI interaction using commands and behaviors .......................\", \"................................................................................. 15 \\n\\nImplementing \", \"commands ...........................................................................................\", \"...................................................... 16 \\n\\nInvoking commands from a view ..........\", \"....................................................................................................\", \"..................... 17 \\n\\nImplementing behaviors ..................................................\", \".................................................................................................. 1\", \"7 \\n\\nInvoking behaviors from a view .................................................................\", \"..................................................................... 20 \\n\\nSummary .................\", \"....................................................................................................\", \"............................................................. 20 \\n\\nDependency injection ............\", \"............................................................................................... 21 \\n\", \"\\ni \\n\\nContents \\n\\n \\n \\n\\fIntroduction to dependency injection ..........................................\", \"................................................................................ 21 \\n\\nRegistration .\", \"....................................................................................................\", \"........................................................................ 23 \\n\\nResolution ...........\", \"....................................................................................................\", \"................................................................. 25 \\n\\nSummary .....................\", \"....................................................................................................\", \"......................................................... 26 \\n\\nCommunicating between loosely coupled\", \" components ................................................... 27 \\n\\nIntroduction to MVVM Toolkit Me\", \"ssenger ............................................................................................\", \"..................... 27 \\n\\nDefining a message ......................................................\", \"....................................................................................................\", \".... 29 \\n\\nPublishing a message .....................................................................\", \"..................................................................................... 29 \\n\\nSubscribi\", \"ng to a message.....................................................................................\", \"............................................................. 30 \\n\\nUnsubscribing from a message ....\", \"....................................................................................................\", \"............................... 30 \\n\\nSummary .......................................................\", \"....................................................................................................\", \"....................... 31 \\n\\nNavigation ............................................................\", \".................................................................. 32 \\n\\nNavigating between pages ...\", \"....................................................................................................\", \"........................................ 33 \\n\\nCreating the MauiNavigationService instance ..........\", \"................................................................................................ 34 \", \"\\n\\nHandling navigation requests .....................................................................\", \"..................................................................... 34 \\n\\nNavigating when the app i\", \"s launched .........................................................................................\", \"................................. 36 \\n\\nPassing parameters during navigation ........................\", \"................................................................................................. 36\", \" \\n\\nInvoking navigation using behaviors .............................................................\", \"............................................................... 37 \\n\\nConfirming or cancelling naviga\", \"tion ...............................................................................................\", \".............................. 38 \\n\\nSummary ........................................................\", \"....................................................................................................\", \"...................... 38 \\n\\nValidation .............................................................\", \".................................................................. 39 \\n\\nSpecifying validation rules \", \"....................................................................................................\", \"............................................ 40 \\n\\nAdding validation rules to a property ............\", \"....................................................................................................\", \".......... 42 \\n\\nTriggering validation ..............................................................\", \"............................................................................................. 42 \\n\\nT\", \"riggering validation manually ......................................................................\", \"............................................................. 42 \\n\\nTriggering validation when proper\", \"ties change ........................................................................................\", \"............ 43 \\n\\nDisplaying validation errors .....................................................\", \"......................................................................................... 43 \\n\\nHighl\", \"ighting a control that contains invalid data .......................................................\", \"......................................... 44 \\n\\nDisplaying error messages ...........................\", \"....................................................................................................\", \"............ 45 \\n\\nSummary ..........................................................................\", \"....................................................................................................\", \".... 45 \\n\\nApplication settings management ..........................................................\", \"............................ 46 \\n\\nii \\n\\nContents \\n\\n \\n\\fCreating a Settings Interface .................\", \"....................................................................................................\", \"....................... 46 \\n\\nAdding Settings .......................................................\", \"....................................................................................................\", \".......... 47 \\n\\nData binding to user settings.......................................................\", \".................................................................................... 48 \\n\\nSummary ..\", \"....................................................................................................\", \"............................................................................ 49 \\n\\nContainerized micr\", \"oservices ..........................................................................................\", \"...... 50 \\n\\nMicroservices ..........................................................................\", \"................................................................................................ 51 \", \"\\n\\nContainerization .................................................................................\", \"................................................................................... 53 \\n\\nCommunicati\", \"on between client and microservices ................................................................\", \"................................ 56 \\n\\nCommunication between microservices ..........................\", \"............................................................................................ 57 \\n\\nSu\", \"mmary ..............................................................................................\", \".................................................................................... 59 \\n\\nAccessing \", \"remote data ........................................................................................\", \".................. 60 \\n\\nIntroduction to Representational State Transfer ............................\", \".......................................................................... 60 \\n\\nConsuming RESTful AP\", \"Is .................................................................................................\", \"................................................... 61 \\n\\nMaking web requests .......................\", \"....................................................................................................\", \"............................... 61 \\n\\nMaking a GET request ..........................................\", \"....................................................................................................\", \"........... 61 \\n\\nMaking a POST request .............................................................\", \"......................................................................................... 64 \\n\\nMakin\", \"g a DELETE request .................................................................................\", \"................................................................. 67 \\n\\nCaching data ................\", \"....................................................................................................\", \"....................................................... 68 \\n\\nManaging data expiration ..............\", \"....................................................................................................\", \"............................... 69 \\n\\nCaching images ................................................\", \"....................................................................................................\", \"................. 69 \\n\\nIncreasing resilience .......................................................\", \"....................................................................................................\", \".. 70 \\n\\nRetry pattern ..............................................................................\", \"............................................................................................. 70 \\n\\nC\", \"ircuit breaker pattern .............................................................................\", \"........................................................................... 71 \\n\\nSummary ...........\", \"....................................................................................................\", \"................................................................... 72 \\n\\nAuthentication and authoriz\", \"ation ....................................................................................... 73 \\n\\nA\", \"uthentication ......................................................................................\", \".................................................................................. 73 \\n\\nIssuing bear\", \"er tokens using IdentityServer .....................................................................\", \"....................................... 74 \\n\\nAdding IdentityServer to a web application ............\", \".............................................................................................. 75 \\n\\n\", \"Configuring IdentityServer .........................................................................\", \".................................................................. 75 \\n\\nConfiguring API resources ..\", \"....................................................................................................\", \"...................................... 76 \\n\\nConfiguring identity resources .........................\", \"....................................................................................................\", \"...... 76 \\n\\niii \\n\\nContents \\n\\n \\n\\fConfiguring clients ................................................\", \"....................................................................................................\", \"...... 77 \\n\\nConfiguring the authentication flow ....................................................\", \".................................................................... 78 \\n\\nPerforming authentication \", \"....................................................................................................\", \"....................................... 79 \\n\\nSigning-in ............................................\", \"....................................................................................................\", \"............................ 80 \\n\\nSigning-out ......................................................\", \"....................................................................................................\", \"............... 83 \\n\\nAuthorization .................................................................\", \"....................................................................................................\", \"..... 84 \\n\\nConfiguring IdentityServer to perform authorization .....................................\", \"....................................................... 85 \\n\\nMaking access requests to APIs ........\", \"....................................................................................................\", \".......................... 86 \\n\\nSummary ............................................................\", \"....................................................................................................\", \".................. 87 \\n\\nMVVM Toolkit Features ......................................................\", \".................................................. 88 \\n\\nMVVM Toolkit ...............................\", \"....................................................................................................\", \"..................................... 88 \\n\\nObservableObject ........................................\", \"....................................................................................................\", \"..................... 89 \\n\\nRelayCommand and AsyncRelayCommand ......................................\", \"......................................................................... 90 \\n\\nSource Generators ...\", \"....................................................................................................\", \"......................................................... 91 \\n\\nSummary .............................\", \"....................................................................................................\", \"................................................. 93 \\n\\nUnit testing ................................\", \"............................................................................................ 94 \\n\\nDe\", \"pendency injection and unit testing ................................................................\", \"........................................................ 95 \\n\\nTesting MVVM applications ............\", \"....................................................................................................\", \".............................. 95 \\n\\nTesting asynchronous functionality .............................\", \".................................................................................................. 9\", \"6 \\n\\nTesting INotifyPropertyChanged implementations .................................................\", \"............................................... 97 \\n\\nTesting message-based communication ...........\", \"....................................................................................................\", \"...... 97 \\n\\nTesting exception handling .............................................................\", \"................................................................................. 98 \\n\\nTesting valid\", \"ation ..............................................................................................\", \".................................................................... 98 \\n\\nSummary ..................\", \"....................................................................................................\", \"............................................................ 99 \\n\\niv \\n\\nContents \\n\\n \\n\\fCHAPTER  1 \\n\\nPu\", \"rpose \\n\\nThis eBook provides guidance on building cross-platform enterprise apps using .NET MAUI. .NE\", \"T \\nMAUI is a cross-platform UI toolkit that allows developers to easily create native user interface\", \" layouts \\nthat can be shared across platforms, including iOS, macOS, Android, and Windows. It provid\", \"es a \\ncomprehensive solution for Business to Employee (B2E), Business to Business (B2B), and Busines\", \"s to \\nConsumer (B2C) apps, providing the ability to share code across all target platforms and helpi\", \"ng to \\nlower the total cost of ownership (TCO). \\n\\nThe guide provides architectural guidance for deve\", \"loping adaptable, maintainable, and testable .NET \\nMAUI enterprise apps. Guidance is provided on how\", \" to implement MVVM, dependency injection, \\nnavigation, validation, and configuration management, whi\", \"le maintaining loose coupling. In addition, \\nthere\\u2019s also guidance on performing authentication and \", \"authorization with IdentityServer, accessing \\ndata from containerized microservices, and unit testin\", \"g. \\n\\nThe guide comes with source code for the eShop multi-platform app, and source code for the eSho\", \"p \\nreference app. The eShop multi-platform app is a cross-platform enterprise app developed using .N\", \"ET \\nMAUI, which connects to a series of containerized microservices known as the eShop reference app\", \". \\nHowever, the eShop multi-platform app can be configured to consume data from mock services for \\nt\", \"hose who wish to avoid deploying the containerized microservices. \\n\\nWhat\\u2019s left out of this guide\\u2019s \", \"scope \\n\\nThis guide is aimed at readers who are already familiar with .NET MAUI. For a detailed intro\", \"duction to \\n.NET MAUI, see the .NET MAUI documentation. \\n\\nWho should use this guide \\n\\nThe audience f\", \"or this guide is mainly developers and architects who would like to learn how to \\narchitect and impl\", \"ement cross-platform enterprise apps using .NET MAUI. \\n\\nA secondary audience is technical decision-m\", \"akers who would like to receive an architectural and \\ntechnology overview before deciding on what ap\", \"proach to select for cross-platform enterprise app \\ndevelopment using .NET MAUI. \\n\\n1 \\n\\nCHAPTER 1 | P\", \"urpose \\n\\n \\n \\n\\fHow to use this guide \\n\\nThis guide focuses on building cross-platform enterprise apps \", \"using .NET MAUI. As such, it should be \\nread in its entirety to provide a foundation of understandin\", \"g such apps and their technical \\nconsiderations. The guide and its sample app can also serve as a st\", \"arting point or reference for \\ncreating a new enterprise app. Use the associated sample app as a tem\", \"plate for the new app or see \\nhow to organize an app\\u2019s component parts. Then, refer back to this gui\", \"de for architectural guidance. \\n\\nFeel free to forward this guide to team members to help ensure a co\", \"mmon understanding of cross-\\nplatform enterprise app development using .NET MAUI. Having everybody w\", \"orking from a common \\nset of terminologies and underlying principles will help ensure a consistent a\", \"pplication of architectural \\npatterns and practices. \\n\\n2 \\n\\nCHAPTER 1 | Purpose \\n\\n \\n \\n\\fCHAPTER  2 \\n\\nI\", \"ntroduction to .NET MAUI \\n\\nRegardless of platform, developers of enterprise apps face several challe\", \"nges: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nApp requirements that can change over time. \\n\\nNew business opportunities and cha\", \"llenges. \\n\\nOngoing feedback during development that can significantly affect the scope and \\nrequirem\", \"ents of the app. \\n\\nWith these in mind, it\\u2019s important to build apps that can be easily modified or e\", \"xtended over time. \\nDesigning for such adaptability can be difficult as it requires an architecture \", \"that allows individual \\nparts of the app to be independently developed and tested in isolation witho\", \"ut affecting the rest of \\nthe app. \\n\\nMany enterprise apps are sufficiently complex to require more t\", \"han one developer. It can be a \\nsignificant challenge to decide how to design an app so that multipl\", \"e developers can work effectively \\non different pieces of the app independently, while ensuring that\", \" the pieces come together seamlessly \\nwhen integrated into the app. \\n\\nThe traditional approach to de\", \"signing and building an app results in what is referred to as a \\nmonolithic app, where components ar\", \"e tightly coupled with no clear separation between them. \\nTypically, this monolithic approach leads \", \"to apps that are difficult and inefficient to maintain, because \\nit can be difficult to resolve bugs\", \" without breaking other components in the app, and it can be \\ndifficult to add new features or to re\", \"place existing features. \\n\\nAn effective remedy for these challenges is to partition an app into disc\", \"rete, loosely coupled \\ncomponents that can be easily integrated together into an app. Such an approa\", \"ch offers several \\nbenefits: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nIt allows individual functionality to be developed, teste\", \"d, extended, and maintained by \\ndifferent individuals or teams. \\n\\nIt promotes reuse and a clean sepa\", \"ration of concerns between the app\\u2019s horizontal \\ncapabilities, such as authentication and data acces\", \"s, and the vertical capabilities, such as app \\nspecific business functionality. This allows the depe\", \"ndencies and interactions between app \\ncomponents to be more easily managed. \\n\\nIt helps maintain a s\", \"eparation of roles by allowing different individuals, or teams, to focus on \\na specific task or piec\", \"e of functionality according to their expertise. In particular, it provides a \\ncleaner separation be\", \"tween the user interface and the app\\u2019s business logic. \\n\\nHowever, there are many issues that must be\", \" resolved when partitioning an app into discrete, loosely \\ncoupled components. These include: \\n\\n3 \\n\\n\", \"CHAPTER 2 | Introduction to .NET MAUI \\n\\n \\n \\n\\f\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDeciding how to provide\", \" a clean separation of concerns between the user interface controls \\nand their logic. One of the mos\", \"t important decisions when creating a .NET MAUI enterprise \\napp is whether to place business logic i\", \"n code-behind files, or whether to create a clean \\nseparation of concerns between the user interface\", \" controls and their logic, in order to make \\nthe app more maintainable and testable. For more inform\", \"ation, see Model-View-ViewModel. \\n\\nDetermining whether to use a dependency injection container. Depe\", \"ndency injection \\ncontainers reduce the dependency coupling between objects by providing a facility \", \"to \\nconstruct instances of classes with their dependencies injected, and manage their lifetime \\nbase\", \"d on the configuration of the container. For more information, see Dependency injection. \\n\\nChoosing \", \"between platform provided eventing and loosely coupled message-based \\ncommunication between componen\", \"ts that are inconvenient to link by object and type \\nreferences. For more information, see Introduct\", \"ion to Communicating between loosely \\ncoupled components. \\n\\nDeciding how to navigate between pages, \", \"including how to invoke navigation, and where \\nnavigation logic should reside. For more information,\", \" see Navigation. \\n\\nDetermining how to validate user input for correctness. The decision must include\", \" how to \\nvalidate user input, and how to notify the user about validation errors. For more informati\", \"on, \\nsee Validation. \\n\\nDeciding how to perform authentication, and how to protect resources with aut\", \"horization. For \\nmore information, see Authentication and authorization. \\n\\nDetermining how to access\", \" remote data from web services, including how to reliably retrieve \\ndata, and how to cache data. For\", \" more information, see Accessing remote data. \\n\\nDeciding how to test the app. For more information, \", \"see Unit testing. \\n\\nThis guide provides guidance on these issues, and focuses on the core patterns a\", \"nd architecture for \\nbuilding a cross-platform enterprise app using .NET MAUI. The guidance aims to \", \"help to produce \\nadaptable, maintainable, and testable code, by addressing common .NET MAUI enterpri\", \"se app \\ndevelopment scenarios, and by separating the concerns of presentation, presentation logic, a\", \"nd \\nentities through support for the Model-View-ViewModel (MVVM) pattern. \\n\\nSample application \\n\\nThi\", \"s guide includes a sample application, eShop, that\\u2019s an online store that includes the following \\nfu\", \"nctionality: \\n\\nAuthenticating and authorizing against a backend service. \\n\\nBrowsing a catalog of ite\", \"ms. \\n\\nFiltering the catalog. \\n\\nOrdering items from the catalog. \\n\\nViewing the user\\u2019s order history. \", \"\\n\\nConfiguration of settings. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n4 \\n\\nCHAPTER 2 | Introduction to .NET MAUI \\n\\n \", \"\\n \\n\\fSample application architecture \\n\\nBelow is a high-level overview of the architecture of the samp\", \"le application. \\n\\nThe sample application ships with: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n.NET Aspire App Hosting & Orchest\", \"ration \\n\\nAn Blazor web application developed with ASP.NET Core. \\n\\nA multi-platform app developed wit\", \"h .NET MAUI, which supports iOS, Android, macOS via \\nMac Catalyst, and Windows. \\n\\nThe sample applica\", \"tion includes the following backend services: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAn identity microservice, which uses\", \" ASP.NET Core Identity and IdentityServer. \\n\\nA catalog microservice, which is a data-driven create, \", \"read, update, delete (CRUD) service that \\nconsumes an SQL Server database using EntityFramework Core\", \". \\n\\nAn ordering microservice, which is a domain-driven service that uses domain-driven design \\npatte\", \"rns. \\n\\nA basket microservice, which is a data-driven CRUD service that uses Redis Cache. \\n\\nThese bac\", \"kend services are implemented as microservices using ASP.NET Core, and are deployed as \\nunique conta\", \"iners with .NET Aspire. Collectively, these backend services are referred to as the eShop \\nreference\", \" application. Client apps communicate with the backend services through a Representational \\nState Tr\", \"ansfer (REST) web interface. For more information about microservices and conainers, see \\nContaineri\", \"zed microservices. \\n\\n5 \\n\\nCHAPTER 2 | Introduction to .NET MAUI \\n\\n \\n \\n \\n\\fMulti-Platform app \\n\\nThis gu\", \"ide focuses on building cross-platform enterprise apps using .NET MAUI, and uses the eShop \\nmulti-pl\", \"atform app as an example. The image below shows the pages from the eShop multi-platform \\napp that pr\", \"ovide the functionality outlined earlier. \\n\\nThe multi-platform app consumes the backend services pro\", \"vided by the eShop reference application. \\nHowever, it can be configured to consume data from mock s\", \"ervices for those who wish to avoid \\ndeploying the backend services. \\n\\nThe eShop multi-platform app \", \"exercises the following .NET MAUI functionality: \\n\\n6 \\n\\nCHAPTER 2 | Introduction to .NET MAUI \\n\\n \\n \\n \", \"\\n\\f\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nXAML \\n\\nControls \\n\\nBindings \\n\\nConverters \\n\\nStyles \\n\\nAni\", \"mations \\n\\nCommands \\n\\nBehaviors \\n\\nTriggers \\n\\nEffects \\n\\nCustom Controls \\n\\nFor more information about t\", \"his functionality, see the .NET MAUI documentation. \\n\\nIn addition, unit tests are provided for some \", \"of the classes in the eShop multi-platform app. \\n\\nMulti-Platform app solution \\n\\nThe eShop multi-plat\", \"form app solution organizes the source code and other resources into a multiple \\nprojects. All of th\", \"e core mobile components are contained in a singular project named \\neShopContainers. This is a featu\", \"re introduced with .NET 6 that allows a project to target multiple \\noutputs which helps eliminate th\", \"e need for multiple platform projects that we would have used in \\nXamarin.Forms and earlier .NET ver\", \"sions. An additional project is included for unit testing. \\n\\nWhile this project has all of its compo\", \"nents stored in a singular project, it is worth considering \\nseparating it into multiple projects ba\", \"sed on your needs. For example, if you have multiple \\nimplementations of service providers based off\", \" of a service with their own dependencies, it may make \\nsense to break those service provider implem\", \"entations out into their own separate project. Good \\ncandidates for project separation include share\", \"d models, service implementations, api client \\ncomponents, database or caching layers. Any place whe\", \"re you feel that the business could re-use a \\ncomponent in another project is a potential candidate \", \"for separation. These projects can then be \\npackaged via NuGet for easy distribution and versioning.\", \" \\n\\nAll of the projects use folders to organize the source code and other resources into categories. \", \"The \\nclasses from the eShop multi-platform app can be re-used in any .NET MAUI app with little or no\", \" \\nmodification. \\n\\neShop project \\n\\nThe eShop project contains the following folders: \\n\\nFolder \\n\\nDescr\", \"iption \\n\\nAnimations \\n\\nContains classes that enable animations to be consumed in XAML. \\n\\nBehaviors \\n\\n\", \"Contains behaviors that are exposed to view classes. \\n\\n7 \\n\\nCHAPTER 2 | Introduction to .NET MAUI \\n\\n \", \"\\n \\n\\fFolder \\n\\nDescription \\n\\nControls \\n\\nContains custom controls used by the app. \\n\\nConverters \\n\\nConta\", \"ins value converters that apply custom logic to a binding. \\n\\nExceptions \\n\\nContains the custom Servic\", \"eAuthenticationException. \\n\\nExtensions \\n\\nContains extension methods for the VisualElement and IEnume\", \"rable<T> classes. \\n\\nHelpers \\n\\nContains helper classes for the app. \\n\\nModels \\n\\nContains the model cla\", \"sses for the app. \\n\\nProperties \\n\\nContains AssemblyInfo.cs, a .NET assembly metadata file. \\n\\nServices\", \" \\n\\nContains interfaces and classes that implement services that are provided to the \\napp. \\n\\nTriggers\", \" \\n\\nContains the BeginAnimation trigger, which is used to invoke an animation in XAML. \\n\\nValidations \", \"\\n\\nContains classes involved in validating data input. \\n\\nViewModels  Contains the application logic t\", \"hat\\u2019s exposed to pages. \\n\\nViews \\n\\nContains the pages for the app. \\n\\nSummary \\n\\nMicrosoft\\u2019s cross-plat\", \"form multi-platform app development tools and platforms provide a \\ncomprehensive solution for B2E, B\", \"2B, and B2C mobile client apps, providing the ability to share code \\nacross all target platforms (iO\", \"S, macOS, Android, and Windows) and helping to lower the total cost of \\nownership. Apps can share th\", \"eir user interface and app logic code, while retaining the native platform \\nlook and feel. \\n\\nDevelop\", \"ers of enterprise apps face several challenges that can alter the architecture of the app during \\nde\", \"velopment. Therefore, it\\u2019s important to build an app so that it can be modified or extended over \\nti\", \"me. Designing for such adaptability can be difficult, but typically involves partitioning an app int\", \"o \\ndiscrete, loosely coupled components that can be easily integrated together into an app. \\n\\n8 \\n\\nCH\", \"APTER 2 | Introduction to .NET MAUI \\n\\n \\n \\n\\fCHAPTER  3 \\n\\nModel-View-ViewModel \\n(MVVM) \\n\\nThe .NET MAUI\", \" developer experience typically involves creating a user interface in XAML, and then \\nadding code-be\", \"hind that operates on the user interface. Complex maintenance issues can arise as \\napps are modified\", \" and grow in size and scope. These issues include the tight coupling between the UI \\ncontrols and th\", \"e business logic, which increases the cost of making UI modifications, and the difficulty \\nof unit t\", \"esting such code. \\n\\nThe MVVM pattern helps cleanly separate an application\\u2019s business and presentati\", \"on logic from its \\nuser interface (UI). Maintaining a clean separation between application logic and\", \" the UI helps address \\nnumerous development issues and makes an application easier to test, maintain\", \", and evolve. It can \\nalso significantly improve code re-use opportunities and allows developers and\", \" UI designers to \\ncollaborate more easily when developing their respective parts of an app. \\n\\nThe MV\", \"VM pattern \\n\\nThere are three core components in the MVVM pattern: the model, the view, and the view \", \"model. \\nEach serves a distinct purpose. The diagram below shows the relationships between the three \", \"\\ncomponents. \\n\\nIn addition to understanding the responsibilities of each component, it\\u2019s also import\", \"ant to understand \\nhow they interact. At a high level, the view \\u201cknows about\\u201d the view model, and th\", \"e view model \\u201cknows \\nabout\\u201d the model, but the model is unaware of the view model, and the view mode\", \"l is unaware of the \\nview. Therefore, the view model isolates the view from the model, and allows th\", \"e model to evolve \\nindependently of the view. \\n\\nThe benefits of using the MVVM pattern are as follow\", \"s: \\n\\n9 \\n\\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n\\n \\n \\n \\n\\f\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nIf an existing model imple\", \"mentation encapsulates existing business logic, it can be difficult or \\nrisky to change it. In this \", \"scenario, the view model acts as an adapter for the model classes \\nand prevents you from making majo\", \"r changes to the model code. \\n\\nDevelopers can create unit tests for the view model and the model, wi\", \"thout using the view. \\nThe unit tests for the view model can exercise exactly the same functionality\", \" as used by the \\nview. \\n\\nThe app UI can be redesigned without touching the view model and model code\", \", provided \\nthat the view is implemented entirely in XAML or C#. Therefore, a new version of the vie\", \"w \\nshould work with the existing view model. \\n\\nDesigners and developers can work independently and c\", \"oncurrently on their components \\nduring development. Designers can focus on the view, while develope\", \"rs can work on the view \\nmodel and model components. \\n\\nThe key to using MVVM effectively lies in und\", \"erstanding how to factor app code into the correct \\nclasses and how the classes interact. The follow\", \"ing sections discuss the responsibilities of each of the \\nclasses in the MVVM pattern. \\n\\nView \\n\\nThe \", \"view is responsible for defining the structure, layout, and appearance of what the user sees on \\nscr\", \"een. Ideally, each view is defined in XAML, with a limited code-behind that does not contain \\nbusine\", \"ss logic. However, in some cases, the code-behind might contain UI logic that implements \\nvisual beh\", \"avior that is difficult to express in XAML, such as animations. \\n\\nIn a .NET MAUI application, a view\", \" is typically a ContentPage-derived or ContentView-derived class. \\nHowever, views can also be repres\", \"ented by a data template, which specifies the UI elements to be \\nused to visually represent an objec\", \"t when it\\u2019s displayed. A data template as a view does not have any \\ncode-behind, and is designed to \", \"bind to a specific view model type. \\n\\nTip \\n\\nAvoid enabling and disabling UI elements in the code-beh\", \"ind. \\n\\nEnsure that the view models are responsible for defining logical state changes that affect so\", \"me \\naspects of the view\\u2019s display, such as whether a command is available, or an indication that an \", \"\\noperation is pending. Therefore, enable and disable UI elements by binding to view model properties\", \", \\nrather than enabling and disabling them in code-behind. \\n\\nThere are several options for executing\", \" code on the view model in response to interactions on the \\nview, such as a button click or item sel\", \"ection. If a control supports commands, the control\\u2019s Command \\nproperty can be data-bound to an ICom\", \"mand property on the view model. When the control\\u2019s \\ncommand is invoked, the code in the view model \", \"will be executed. In addition to commands, \\nbehaviors can be attached to an object in the view and c\", \"an listen for either a command to be invoked \\nor the event to be raised. In response, the behavior c\", \"an then invoke an ICommand on the view model \\nor a method on the view model. \\n\\n10 \\n\\nCHAPTER 3 | Mode\", \"l-View-ViewModel (MVVM) \\n\\n \\n \\n\\fViewModel \\n\\nThe view model implements properties and commands to whic\", \"h the view can data bind to, and \\nnotifies the view of any state changes through change notification\", \" events. The properties and \\ncommands that the view model provides define the functionality to be of\", \"fered by the UI, but the view \\ndetermines how that functionality is to be displayed. \\n\\nTip \\n\\nKeep th\", \"e UI responsive with asynchronous operations. \\n\\nMulti-platform apps should keep the UI thread unbloc\", \"ked to improve the user\\u2019s perception of \\nperformance. Therefore, in the view model, use asynchronous\", \" methods for I/O operations and raise \\nevents to asynchronously notify views of property changes. \\n\\n\", \"The view model is also responsible for coordinating the view\\u2019s interactions with any model classes t\", \"hat \\nare required. There\\u2019s typically a one-to-many relationship between the view model and the model\", \" \\nclasses. The view model might choose to expose model classes directly to the view so that controls\", \" in \\nthe view can data bind directly to them. In this case, the model classes will need to be design\", \"ed to \\nsupport data binding and change notification events. \\n\\nEach view model provides data from a m\", \"odel in a form that the view can easily consume. To \\naccomplish this, the view model sometimes perfo\", \"rms data conversion. Placing this data conversion in \\nthe view model is a good idea because it provi\", \"des properties that the view can bind to. For example, \\nthe view model might combine the values of t\", \"wo properties to make it easier to display by the view. \\n\\nTip \\n\\nCentralize data conversions in a con\", \"version layer. \\n\\nIt\\u2019s also possible to use converters as a separate data conversion layer that sits \", \"between the view \\nmodel and the view. This can be necessary, for example, when data requires special\", \" formatting that \\nthe view model doesn\\u2019t provide. \\n\\nIn order for the view model to participate in tw\", \"o-way data binding with the view, its properties must \\nraise the PropertyChanged event. View models \", \"satisfy this requirement by implementing the \\nINotifyPropertyChanged interface, and raising the Prop\", \"ertyChanged event when a property is \\nchanged. \\n\\nFor collections, the view-friendly ObservableCollec\", \"tion<T> is provided. This collection implements \\ncollection changed notification, relieving the deve\", \"loper from having to implement the \\nINotifyCollectionChanged interface on collections. \\n\\nModel \\n\\nMod\", \"el classes are non-visual classes that encapsulate the app\\u2019s data. Therefore, the model can be \\nthou\", \"ght of as representing the app\\u2019s domain model, which usually includes a data model along with \\nbusin\", \"ess and validation logic. Examples of model objects include data transfer objects (DTOs), Plain \\nOld\", \" CLR Objects (POCOs), and generated entity and proxy objects. \\n\\n11 \\n\\nCHAPTER 3 | Model-View-ViewMode\", \"l (MVVM) \\n\\n \\n \\n\\fModel classes are typically used in conjunction with services or repositories that e\", \"ncapsulate data \\naccess and caching. \\n\\nConnecting view models to views \\n\\nView models can be connecte\", \"d to views by using the data-binding capabilities of .NET MAUI. There \\nare many approaches that can \", \"be used to construct views and view models and associate them at \\nruntime. These approaches fall int\", \"o two categories, known as view first composition, and view model \\nfirst composition. Choosing betwe\", \"en view first composition and view model first composition is an \\nissue of preference and complexity\", \". However, all approaches share the same aim, which is for the view \\nto have a view model assigned t\", \"o its BindingContext property. \\n\\nWith view first composition the app is conceptually composed of vie\", \"ws that connect to the view \\nmodels they depend on. The primary benefit of this approach is that it \", \"makes it easy to construct \\nloosely coupled, unit testable apps because the view models have no depe\", \"ndence on the views \\nthemselves. It\\u2019s also easy to understand the structure of the app by following \", \"its visual structure, \\nrather than having to track code execution to understand how classes are crea\", \"ted and associated. In \\naddition, view first construction aligns with the Microsoft Maui\\u2019s navigatio\", \"n system that\\u2019s responsible \\nfor constructing pages when navigation occurs, which makes a view model\", \" first composition complex \\nand misaligned with the platform. \\n\\nWith view model first composition, t\", \"he app is conceptually composed of view models, with a service \\nresponsible for locating the view fo\", \"r a view model. View model first composition feels more natural to \\nsome developers, since the view \", \"creation can be abstracted away, allowing them to focus on the \\nlogical non-UI structure of the app.\", \" In addition, it allows view models to be created by other view \\nmodels. However, this approach is o\", \"ften complex, and it can become difficult to understand how the \\nvarious parts of the app are create\", \"d and associated. \\n\\nTip \\n\\nKeep view models and views independent. \\n\\nThe binding of views to a proper\", \"ty in a data source should be the view\\u2019s principal dependency on its \\ncorresponding view model. Spec\", \"ifically, don\\u2019t reference view types, such as Button and ListView, from \\nview models. By following t\", \"he principles outlined here, view models can be tested in isolation, \\ntherefore reducing the likelih\", \"ood of software defects by limiting scope. \\n\\nThe following sections discuss the main approaches to c\", \"onnecting view models to views. \\n\\nCreating a view model declaratively \\n\\nThe simplest approach is for\", \" the view to declaratively instantiate its corresponding view model in \\nXAML. When the view is const\", \"ructed, the corresponding view model object will also be constructed. \\nThis approach is demonstrated\", \" in the following code example: \\n\\n<ContentPage xmlns:local=\\\"clr-namespace:eShop\\\"> \\n    <ContentPage.\", \"BindingContext> \\n\\n12 \\n\\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n\\n \\n \\n\\f        <local:LoginViewModel \", \"/> \\n    </ContentPage.BindingContext> \\n    <!-- Omitted for brevity... --> \\n</ContentPage> \\n\\nWhen th\", \"e ContentPage is created, an instance of the LoginViewModel is automatically constructed \\nand set as\", \" the view\\u2019s BindingContext. \\n\\nThis declarative construction and assignment of the view model by the \", \"view has the advantage that \\nit\\u2019s simple, but has the disadvantage that it requires a default (param\", \"eter-less) constructor in the view \\nmodel. \\n\\nCreating a view model programmatically \\n\\nA view can hav\", \"e code in the code-behind file, resulting in the view-model being assigned to its \\nBindingContext pr\", \"operty. This is often accomplished in the view\\u2019s constructor, as shown in the \\nfollowing code exampl\", \"e: \\n\\npublic LoginView() \\n{ \\n    InitializeComponent(); \\n    BindingContext = new LoginViewModel(navi\", \"gationService); \\n} \\n\\nThe programmatic construction and assignment of the view model within the view\\u2019\", \"s code-behind has \\nthe advantage that it\\u2019s simple. However, the main disadvantage of this approach i\", \"s that the view \\nneeds to provide the view model with any required dependencies. Using a dependency \", \"injection \\ncontainer can help to maintain loose coupling between the view and view model. For more \\n\", \"information, see Dependency injection. \\n\\nUpdating views in response to changes in the \\nunderlying vi\", \"ew model or model \\n\\nAll view model and model classes that are accessible to a view should implement \", \"the \\n[INotifyPropertyChanged interface. Implementing this interface in a view model or model class a\", \"llows \\nthe class to provide change notifications to any data-bound controls in the view when the und\", \"erlying \\nproperty value changes. \\n\\nApp\\u2019s should be architected for the correct use of property chang\", \"e notification, by meeting the \\nfollowing requirements: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n13 \\n\\nAlways raising a Property\", \"Changed event if a public property\\u2019s value changes. Do not assume \\nthat raising the PropertyChanged \", \"event can be ignored because of knowledge of how XAML \\nbinding occurs. \\n\\nAlways raising a PropertyCh\", \"anged event for any calculated properties whose values are used \\nby other properties in the view mod\", \"el or model. \\n\\nAlways raising the PropertyChanged event at the end of the method that makes a proper\", \"ty \\nchange, or when the object is known to be in a safe state. Raising the event interrupts the \\n\\nCH\", \"APTER 3 | Model-View-ViewModel (MVVM) \\n\\n \\n \\n\\f\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\noperation by invoking the event\\u2019s handlers \", \"synchronously. If this happens in the middle of an \\noperation, it might expose the object to callbac\", \"k functions when it is in an unsafe, partially \\nupdated state. In addition, it\\u2019s possible for cascad\", \"ing changes to be triggered by \\nPropertyChanged events. Cascading changes generally require updates \", \"to be complete before \\nthe cascading change is safe to execute. \\n\\nNever raising a PropertyChanged ev\", \"ent if the property does not change. This means that you \\nmust compare the old and new values before\", \" raising the PropertyChanged event. \\n\\nNever raising the PropertyChanged event during a view model\\u2019s \", \"constructor if you are \\ninitializing a property. Data-bound controls in the view will not have subsc\", \"ribed to receive \\nchange notifications at this point. \\n\\nNever raising more than one PropertyChanged \", \"event with the same property name argument \\nwithin a single synchronous invocation of a public metho\", \"d of a class. For example, given a \\nNumberOfItems property whose backing store is the _numberOfItems\", \" field, if a method \\nincrements _numberOfItems fifty times during the execution of a loop, it should\", \" only raise \\nproperty change notification on the NumberOfItems property once, after all the work is \", \"\\ncomplete. For asynchronous methods, raise the PropertyChanged event for a given property \\nname in e\", \"ach synchronous segment of an asynchronous continuation chain. \\n\\nA simple way to provide this functi\", \"onality would be to create an extension of the BindableObject class. \\nIn this example, the ExtendedB\", \"indableObject class provides change notifications, which is shown in \\nthe following code example: \\n\\n\", \"public abstract class ExtendedBindableObject : BindableObject \\n{ \\n    public void RaisePropertyChang\", \"ed<T>(Expression<Func<T>> property) \\n    { \\n        var name = GetMemberInfo(property).Name; \\n      \", \"  OnPropertyChanged(name); \\n    } \\n\\n    private MemberInfo GetMemberInfo(Expression expression) \\n   \", \" { \\n        // Omitted for brevity ... \\n    } \\n} \\n\\n.NET MAUI\\u2019s BindableObject class implements the I\", \"NotifyPropertyChanged interface, and provides an \\nOnPropertyChanged method. The ExtendedBindableObje\", \"ct class provides the RaisePropertyChanged \\nmethod to invoke property change notification, and in do\", \"ing so uses the functionality provided by the \\nBindableObject class. \\n\\nView model classes can then d\", \"erive from the ExtendedBindableObject class. Therefore, each view \\nmodel class uses the RaisePropert\", \"yChanged method in the ExtendedBindableObject class to provide \\nproperty change notification. The fo\", \"llowing code example shows how the eShop multi-platform app \\ninvokes property change notification by\", \" using a lambda expression: \\n\\npublic bool IsLogin \\n{ \\n    get => _isLogin; \\n    set \\n    { \\n        \", \"_isLogin = value; \\n        RaisePropertyChanged(() => IsLogin); \\n\\n14 \\n\\nCHAPTER 3 | Model-View-ViewMo\", \"del (MVVM) \\n\\n \\n \\n \\n\\f    } \\n} \\n\\nUsing a lambda expression in this way involves a small performance co\", \"st because the lambda \\nexpression has to be evaluated for each call. Although the performance cost i\", \"s small and would not \\ntypically impact an app, the costs can accrue when there are many change noti\", \"fications. However, the \\nbenefit of this approach is that it provides compile-time type safety and r\", \"efactoring support when \\nrenaming properties. \\n\\nMVVM Frameworks \\n\\nThe MVVM pattern is well establish\", \"ed in .NET, and the community has created many frameworks \\nwhich help ease this development. Each fr\", \"amework provides a different set of features, but it is \\nstandard for them to provide a common view \", \"model with an implementation of the \\nINotifyPropertyChanged interface. Additional features of MVVM f\", \"rameworks include custom \\ncommands, navigation helpers, dependency injection/service locator compone\", \"nts, and UI platform \\nintegration. While it is not necessary to use these frameworks, they can speed\", \" up and standardize \\nyour development. The eShop multi-platform app uses the .NET Community MVVM Too\", \"lkit. When \\nchoosing a framework, you should consider your application\\u2019s needs and your team\\u2019s stren\", \"gths. The \\nlist below includes some of the more common MVVM frameworks for .NET MAUI. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\", \".NET Community MVVM Toolkit \\n\\nReactiveUI \\n\\nPrism Library \\n\\nUI interaction using commands and behavio\", \"rs \\n\\nIn multi-platform apps, actions are typically invoked in response to a user action, such as a b\", \"utton \\nclick, that can be implemented by creating an event handler in the code-behind file. However,\", \" in the \\nMVVM pattern, the responsibility for implementing the action lies with the view model, and \", \"placing \\ncode in the code-behind should be avoided. \\n\\nCommands provide a convenient way to represent\", \" actions that can be bound to controls in the UI. \\nThey encapsulate the code that implements the act\", \"ion and help to keep it decoupled from its visual \\nrepresentation in the view. This way, your view m\", \"odels become more portable to new platforms, as \\nthey do not have a direct dependency on events prov\", \"ided by the platform\\u2019s UI framework. .NET MAUI \\nincludes controls that can be declaratively connecte\", \"d to a command, and these controls will invoke \\nthe command when the user interacts with the control\", \". \\n\\nBehaviors also allow controls to be declaratively connected to a command. However, behaviors can\", \" be \\nused to invoke an action that\\u2019s associated with a range of events raised by a control. Therefor\", \"e, \\nbehaviors address many of the same scenarios as command-enabled controls, while providing a \\ngre\", \"ater degree of flexibility and control. In addition, behaviors can also be used to associate command\", \" \\nobjects or methods with controls that were not specifically designed to interact with commands. \\n\\n\", \"15 \\n\\nCHAPTER 3 | Model-View-ViewModel (MVVM) \\n\\n \\n \\n\\fImplementing commands \\n\\nView models typically ex\", \"pose public properties, for binding from the view, which implement the \\nICommand interface. Many .NE\", \"T MAUI controls and gestures provide a Command property, which can \\nbe data bound to an ICommand obj\", \"ect provided by the view model. The button control is one of the \\nmost commonly used controls, provi\", \"ding a command property that executes when the button is \\nclicked. \\n\\nNote \\n\\nWhile it\\u2019s possible to e\", \"xpose the actual implementation of the ICommand interface that your view \\nmodel uses (for example, C\", \"ommand<T> or RelayCommand), it is recommended to expose your \\ncommands publicly as ICommand. This wa\", \"y, if you ever need to change the implementation at a later \\ndate, it can easily be swapped out. \\n\\nT\", \"he ICommand interface defines an Execute method, which encapsulates the operation itself, a \\nCanExec\", \"ute method, which indicates whether the command can be invoked, and a \\nCanExecuteChanged event that \", \"occurs when changes occur that affect whether the command should \\nexecute. In most cases, we will on\", \"ly supply the Execute method for our commands. For a more \\ndetailed overview of ICommand, refer to t\", \"he Commanding documentation for .NET MAUI. \\n\\nProvided with .NET MAUI are the Command and Command<T> \", \"classes that implement the \\nICommand interface, where T is the type of the arguments to Execute and \", \"CanExecute. Command and \\nCommand<T> are basic implementations that provide the minimal set of functi\", \"onality needed for the \\nICommand interface. \\n\\nNote \\n\\nMany MVVM frameworks offer more feature rich im\", \"plementations of the ICommand interface. \\n\\nThe Command or Command<T> constructor requires an Action \", \"callback object that\\u2019s called when the \\nICommand.Execute method is invoked. The CanExecute method is\", \" an optional constructor parameter, \\nand is a Func that returns a bool. \\n\\nThe eShop multi-platform a\", \"pp uses the RelayCommand and AsyncRelayCommand. The primary \\nbenefit for modern applications is that\", \" the AsyncRelayCommand provides better functionality for \\nasynchronous operations. \\n\\nThe following c\", \"ode shows how a Command instance, which represents a register command, is \\nconstructed by specifying\", \" a delegate to the Register view model method: \\n\\npublic ICommand RegisterCommand { get; } \\n\\nThe comm\", \"and is exposed to the view through a property that returns a reference to an ICommand. \\nWhen the Exe\", \"cute method is called on the Command object, it simply forwards the call to the method \\nin the view \", \"model via the delegate that was specified in the Command constructor. An asynchronous \\nmethod can be\", \" invoked by a command by using the async and await keywords when specifying the \\ncommand\\u2019s Execute d\", \"elegate. This indicates that the callback is a Task and should be awaited. For \\n\\n16 \\n\\nCHAPTER 3 | Mo\", \"del-View-ViewModel (MVVM) \\n\\n \\n \\n\\fexample, the following code shows how an ICommand instance, which r\", \"epresents a sign-in command, \\nis constructed by specifying a delegate to the SignInAsync view model \", \"method: \\n\\npublic ICommand SignInCommand { get; } \\n... \\nSignInCommand = new AsyncRelayCommand(async (\", \") => await SignInAsync()); \\n\\nParameters can be passed to the Execute and CanExecute actions by using\", \" the \\nAsyncRelayCommand<T> class to instantiate the command. For example, the following code shows \\n\", \"how an AsyncRelayCommand<T> instance is used to indicate that the NavigateAsync method will \\nrequire\", \" an argument of type string: \\n\\npublic ICommand NavigateCommand { get; } \\n\\n... \\nNavigateCommand = new\", \" AsyncRelayCommand<string>(NavigateAsync); \\n\\nIn both the RelayCommand and RelayCommand<T> classes, t\", \"he delegate to the CanExecute method \\nin each constructor is optional. If a delegate isn\\u2019t specified\", \", the Command will return true for \\nCanExecute. However, the view model can indicate a change in the\", \" command\\u2019s CanExecute status by \\ncalling the ChangeCanExecute method on the Command object. This cau\", \"ses the CanExecuteChanged \\nevent to be raised. Any UI controls bound to the command will then update\", \" their enabled status to \\nreflect the availability of the data-bound command. \\n\\nInvoking commands fr\", \"om a view \\n\\nThe following code example shows how a Grid in the LoginView binds to the RegisterComman\", \"d in the \\nLoginViewModel class by using a TapGestureRecognizer instance: \\n\\n<Grid Grid.Column=\\\"1\\\" Hor\", \"izontalOptions=\\\"Center\\\"> \\n    <Label Text=\\\"REGISTER\\\" TextColor=\\\"Gray\\\"/> \\n    <Grid.GestureRecognizer\", \"s> \\n        <TapGestureRecognizer Command=\\\"{Binding RegisterCommand}\\\" NumberOfTapsRequired=\\\"1\\\" \\n/> \\n\", \"    </Grid.GestureRecognizers> \\n</Grid> \\n\\nA command parameter can also be optionally defined using t\", \"he CommandParameter property. The \\ntype of the expected argument is specified in the Execute and Can\", \"Execute target methods. The \\nTapGestureRecognizer will automatically invoke the target command when \", \"the user interacts with the \\nattached control. The CommandParameter, if provided, will be passed as \", \"the argument to the \\ncommand\\u2019s Execute delegate. \\n\\nImplementing behaviors \\n\\nBehaviors allow function\", \"ality to be added to UI controls without having to subclass them. Instead, the \\nfunctionality is imp\", \"lemented in a behavior class and attached to the control as if it was part of the \\ncontrol itself. B\", \"ehaviors enable you to implement code that you would typically have to write as code-\\nbehind, becaus\", \"e it directly interacts with the API of the control, in such a way that it can be concisely \\n\\n17 \\n\\nC\", \"HAPTER 3 | Model-View-ViewModel (MVVM) \\n\\n \\n \\n \\n\\fattached to the control, and packaged for reuse acro\", \"ss more than one view or app. In the context of \\nMVVM, behaviors are a useful approach for connectin\", \"g controls to commands. \\n\\nA behavior that\\u2019s attached to a control through attached properties is kno\", \"wn as an attached behavior. \\nThe behavior can then use the exposed API of the element to which it is\", \" attached to add functionality \\nto that control, or other controls, in the visual tree of the view. \", \"\\n\\nA .NET MAUI behavior is a class that derives from the Behavior or Behavior<T> class, where T is th\", \"e \\ntype of the control to which the behavior should apply. These classes provide OnAttachedTo and \\nO\", \"nDetachingFrom methods, which should be overridden to provide logic that will be executed when \\nthe \", \"behavior is attached to and detached from controls. \\n\\nIn the eShop multi-platform app, the BindableB\", \"ehavior<T> class derives from the Behavior<T> class. \\nThe purpose of the BindableBehavior<T> class i\", \"s to provide a base class for .NET MAUI behaviors that \\nrequire the BindingContext of the behavior t\", \"o be set to the attached control. \\n\\nThe BindableBehavior<T> class provides an overridable OnAttached\", \"To method that sets the \\nBindingContext of the behavior, and an overridable OnDetachingFrom method t\", \"hat cleans up the \\nBindingContext. \\n\\nThe eShop multi-platform app includes an EventToCommandBehavior\", \" class which is provided by the \\nMAUI Community toolkit. EventToCommandBehavior executes a command i\", \"n response to an event \\noccurring. This class derives from the BaseBehavior<View> class so that the \", \"behavior can bind to and \\nexecute an ICommand specified by a Command property when the behavior is c\", \"onsumed. The \\nfollowing code example shows the EventToCommandBehavior class: \\n\\n/// <summary> \\n/// Th\", \"e <see cref=\\\"EventToCommandBehavior\\\"/> is a behavior that allows the user to invoke a \\n<see cref=\\\"IC\", \"ommand\\\"/> through an event. It is designed to associate Commands to events \\nexposed by controls that\", \" were not designed to support Commands. It allows you to map any \\narbitrary event on a control to a \", \"Command. \\n/// </summary> \\npublic class EventToCommandBehavior : BaseBehavior<VisualElement> \\n{ \\n    \", \"// Omitted for brevity... \\n\\n    /// <inheritdoc/> \\n    protected override void OnAttachedTo(VisualEl\", \"ement bindable) \\n    { \\n        base.OnAttachedTo(bindable); \\n        RegisterEvent(); \\n    } \\n\\n    \", \"/// <inheritdoc/> \\n    protected override void OnDetachingFrom(VisualElement bindable) \\n    { \\n     \", \"   UnregisterEvent(); \\n        base.OnDetachingFrom(bindable); \\n    } \\n\\n    static void OnEventNameP\", \"ropertyChanged(BindableObject bindable, object oldValue, object \\nnewValue) \\n        => ((EventToComm\", \"andBehavior)bindable).RegisterEvent(); \\n\\n    void RegisterEvent() \\n    { \\n\\n18 \\n\\nCHAPTER 3 | Model-Vi\", \"ew-ViewModel (MVVM) \\n\\n \\n \\n \\n \\n \\n \\n\\f        UnregisterEvent(); \\n\\n        var eventName = EventName; \\n\", \"        if (View is null || string.IsNullOrWhiteSpace(eventName)) \\n        { \\n            return; \\n \", \"       } \\n\\n        eventInfo = View.GetType()?.GetRuntimeEvent(eventName) ?? \\n            throw new \", \"ArgumentException($\\\"{nameof(EventToCommandBehavior)}: Couldn't \\nresolve the event.\\\", nameof(EventNam\", \"e)); \\n\\n        ArgumentNullException.ThrowIfNull(eventInfo.EventHandlerType); \\n        ArgumentNullE\", \"xception.ThrowIfNull(eventHandlerMethodInfo); \\n\\n        eventHandler = eventHandlerMethodInfo.Create\", \"Delegate(eventInfo.EventHandlerType, \\nthis) ?? \\n            throw new ArgumentException($\\\"{nameof(Ev\", \"entToCommandBehavior)}: Couldn't create \\nevent handler.\\\", nameof(EventName)); \\n\\n        eventInfo.Ad\", \"dEventHandler(View, eventHandler); \\n    } \\n\\n    void UnregisterEvent() \\n    { \\n        if (eventInfo\", \" is not null && eventHandler is not null) \\n        { \\n            eventInfo.RemoveEventHandler(View,\", \" eventHandler); \\n        } \\n\\n        eventInfo = null; \\n        eventHandler = null; \\n    } \\n\\n    //\", \"/ <summary> \\n    /// Virtual method that executes when a Command is invoked \\n    /// </summary> \\n   \", \" /// <param name=\\\"sender\\\"></param> \\n    /// <param name=\\\"eventArgs\\\"></param> \\n    [Microsoft.Maui.Co\", \"ntrols.Internals.Preserve(Conditional = true)] \\n    protected virtual void OnTriggerHandled(object? \", \"sender = null, object? eventArgs = \\nnull) \\n    { \\n        var parameter = CommandParameter \\n        \", \"    ?? EventArgsConverter?.Convert(eventArgs, typeof(object), null, null); \\n\\n        var command = C\", \"ommand; \\n        if (command?.CanExecute(parameter) ?? false) \\n        { \\n            command.Execut\", \"e(parameter); \\n        } \\n    } \\n} \\n\\nThe OnAttachedTo and OnDetachingFrom methods are used to regist\", \"er and deregister an event \\nhandler for the event defined in the EventName property. Then, when the \", \"event fires, the \\nOnTriggerHandled method is invoked, which executes the command. \\n\\n19 \\n\\nCHAPTER 3 |\", \" Model-View-ViewModel (MVVM) \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\fThe advantage of using the EventToCommandBehav\", \"ior to execute a command when an event fires, is \\nthat commands can be associated with controls that\", \" weren\\u2019t designed to interact with commands. In \\naddition, this moves event-handling code to view mo\", \"dels, where it can be unit tested. \\n\\nInvoking behaviors from a view \\n\\nThe EventToCommandBehavior is \", \"particularly useful for attaching a command to a control that \\ndoesn\\u2019t support commands. For example\", \", the LoginView uses the EventToCommandBehavior to \\nexecute the ValidateCommand when the user change\", \"s the value of their password, as shown in the \\nfollowing code: \\n\\n<Entry \\n    IsPassword=\\\"True\\\" \\n   \", \" Text=\\\"{Binding Password.Value, Mode=TwoWay}\\\"> \\n    <!-- Omitted for brevity... --> \\n    <Entry.Beha\", \"viors> \\n        <mct:EventToCommandBehavior \\n            EventName=\\\"TextChanged\\\" \\n            Comman\", \"d=\\\"{Binding ValidateCommand}\\\" /> \\n    </Entry.Behaviors> \\n    <!-- Omitted for brevity... --> \\n</Ent\", \"ry> \\n\\nAt runtime, the EventToCommandBehavior will respond to interaction with the Entry. When a user\", \" \\ntypes into the Entry field, the TextChanged event will fire, which will execute the ValidateComman\", \"d in \\nthe LoginViewModel. By default, the event arguments for the event are passed to the command. I\", \"f \\nneeded, the EventArgsConverter property can be used to convert the EventArgs provided by the even\", \"t \\ninto a value that the command expects as input. \\n\\nFor more information about behaviors, see Behav\", \"iors on the .NET MAUI Developer Center. \\n\\nSummary \\n\\nThe Model-View-ViewModel (MVVM) pattern helps cl\", \"eanly separate an application\\u2019s business and \\npresentation logic from its user interface (UI). Maint\", \"aining a clean separation between application \\nlogic and the UI helps address numerous development i\", \"ssues and makes an application easier to test, \\nmaintain, and evolve. It can also significantly impr\", \"ove code re-use opportunities and allows \\ndevelopers and UI designers to collaborate more easily whe\", \"n developing their respective parts of an \\napp. \\n\\nUsing the MVVM pattern, the UI of the app and the \", \"underlying presentation and business logic are \\nseparated into three separate classes: the view, whi\", \"ch encapsulates the UI and UI logic; the view \\nmodel, which encapsulates presentation logic and stat\", \"e; and the model, which encapsulates the app\\u2019s \\nbusiness logic and data. \\n\\n20 \\n\\nCHAPTER 3 | Model-Vi\", \"ew-ViewModel (MVVM) \\n\\n \\n \\n\\fCHAPTER  4 \\n\\nDependency injection \\n\\nTypically, a class constructor is inv\", \"oked when instantiating an object, and any values that the object \\nneeds are passed as arguments to \", \"the constructor. This is an example of dependency injection known \\nas constructor injection. The dep\", \"endencies the object needs are injected into the constructor. \\n\\nBy specifying dependencies as interf\", \"ace types, dependency injection enables decoupling the concrete \\ntypes from the code that depends on\", \" these types. It generally uses a container that holds a list of \\nregistrations and mappings between\", \" interfaces and abstract types, and the concrete types that \\nimplement or extend these types. \\n\\nTher\", \"e are also other types of dependency injection, such as property setter injection and method call \\ni\", \"njection, but they are less commonly seen. Therefore, this chapter will focus solely on performing \\n\", \"constructor injection with a dependency injection container. \\n\\nIntroduction to dependency injection \", \"\\n\\nDependency injection is a specialized version of the Inversion of Control (IoC) pattern, where the\", \" \\nconcern being inverted is the process of obtaining the required dependency. With dependency \\ninjec\", \"tion, another class is responsible for injecting dependencies into an object at runtime. The \\nfollow\", \"ing code example shows how the ProfileViewModel class is structured when using dependency \\ninjection\", \": \\n\\nprivate readonly ISettingsService _settingsService; \\nprivate readonly IAppEnvironmentService _ap\", \"pEnvironmentService; \\n\\npublic ProfileViewModel( \\n    IAppEnvironmentService appEnvironmentService, \\n\", \"    IDialogService dialogService,  \\n    INavigationService navigationService,  \\n    ISettingsService\", \" settingsService) \\n    : base(dialogService, navigationService, settingsService) \\n{ \\n    _appEnviron\", \"mentService = appEnvironmentService; \\n    _settingsService = settingsService; \\n\\n    // Omitted for b\", \"revity \\n} \\n\\nThe ProfileViewModel constructor receives multiple interface object instances as argumen\", \"ts injected \\nby another class. The only dependency in the ProfileViewModel class is on the interface\", \" types. \\nTherefore, the ProfileViewModel class doesn\\u2019t have any knowledge of the class that\\u2019s respon\", \"sible for \\ninstantiating the interface objects. The class that\\u2019s responsible for instantiating the i\", \"nterface objects, \\nand inserting it into the ProfileViewModel class, is known as the dependency inje\", \"ction container. \\n\\n21 \\n\\nCHAPTER 4 | Dependency injection \\n\\n \\n \\n \\n \\n\\fDependency injection containers \", \"reduce the coupling between objects by providing a facility to \\ninstantiate class instances and mana\", \"ge their lifetime based on the configuration of the container. \\nDuring object creation, the containe\", \"r injects any dependencies that the object requires into it. If those \\ndependencies have not yet bee\", \"n created, the container creates and resolves their dependencies first. \\n\\nThere are several advantag\", \"es to using a dependency injection container: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nA container removes the need for a c\", \"lass to locate its dependencies and manage its lifetimes. \\n\\nA container allows the mapping of implem\", \"ented dependencies without affecting the class. \\n\\nA container facilitates testability by allowing de\", \"pendencies to be mocked. \\n\\nA container increases maintainability by allowing new classes to be easil\", \"y added to the app. \\n\\nIn the context of a .NET MAUI app that uses MVVM, a dependency injection conta\", \"iner will typically be \\nused for registering and resolving views, registering and resolving view mod\", \"els, and for registering \\nservices and injecting them into view models. \\n\\nThere are many dependency \", \"injection containers available in .NET; the eShop multi-platform app uses \\nMicrosoft.Extensions.Depe\", \"ndencyInjection to manage the instantiation of views, view models, and \\nservice classes in the app. \", \"Microsoft.Extensions.DependencyInjection facilitates building loosely \\ncoupled apps, and provides al\", \"l of the features commonly found in dependency injection containers, \\nincluding methods to register \", \"type mappings and object instances, resolve objects, manage object \\nlifetimes, and inject dependent \", \"objects into constructors of objects that it resolves. For more \\ninformation about Microsoft.Extensi\", \"ons.DependencyInjection, see Dependency injection in .NET. \\n\\nIn .NET MAUI, the MauiProgram class wil\", \"l call into the CreateMauiApp method to create a \\nMauiAppBuilder object. The MauiAppBuilder object h\", \"as a Services property of type IServiceCollection, \\nwhich provides a place to register our component\", \"s, such as views, view models, and services for \\ndependency injection. Any components registered wit\", \"h the Services property will be provided to the \\ndependency injection container when the MauiAppBuil\", \"der.Build method is called. \\n\\nAt runtime, the container must know which implementation of the servic\", \"es are being requested in \\norder to instantiate them for the requested objects. In the eShop multi-p\", \"latform app, the \\nIAppEnvironmentService, IDialogService , INavigationService, and ISettingsService \", \"interfaces need to \\nbe resolved before it can instantiate a ProfileViewModel object. This involves t\", \"he container performing \\nthe following actions: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDeciding how to instantiate an object that\", \" implements the interface. This is known as \\nregistration. \\n\\nInstantiating the object that implement\", \"s the required interface and the ProfileViewModel \\nobject. This is known as resolution. \\n\\nEventually\", \", the app will finish using the ProfileViewModel object, and it will become available for \\ngarbage c\", \"ollection. At this point, the garbage collector should dispose of any short-lived interface \\nimpleme\", \"ntations if other classes do not share the same instance. \\n\\n22 \\n\\nCHAPTER 4 | Dependency injection \\n\\n\", \" \\n \\n\\fRegistration \\n\\nBefore dependencies can be injected into an object, the types of the dependencie\", \"s must first be \\nregistered with the container. Registering a type involves passing the container an\", \" interface and a \\nconcrete type that implements the interface. \\n\\nThere are two ways of registering t\", \"ypes and objects in the container through code: \\n\\nRegister a type or mapping with the container. Thi\", \"s is known as transient registration. When \\nrequired, the container will build an instance of the sp\", \"ecified type. \\n\\nRegister an existing object in the container as a singleton. When required, the cont\", \"ainer will \\nreturn a reference to the existing object. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nNote \\n\\nDependency injection contain\", \"ers are not always suitable. Dependency injection introduces additional \\ncomplexity and requirements\", \" that might not be appropriate or useful to small apps. If a class does not \\nhave any dependencies, \", \"or is not a dependency for other types, it might not make sense to put it in \\nthe container. In addi\", \"tion, if a class has a single set of dependencies that are integral to the type and \\nwill never chan\", \"ge, it might not make sense to put it in the container. \\n\\nThe registration of types requiring depend\", \"ency injection should be performed in a single method in \\nan app. This method should be invoked earl\", \"y in the app\\u2019s lifecycle to ensure it is aware of the \\ndependencies between its classes. The eShop m\", \"ulti-platform app performs this the \\nMauiProgram.CreateMauiApp method. The following code example sh\", \"ows how the eShop multi-\\nplatform app declares the CreateMauiApp in the MauiProgram class: \\n\\npublic \", \"static class MauiProgram \\n{ \\n    public static MauiApp CreateMauiApp() \\n        => MauiApp.CreateBui\", \"lder() \\n            .UseMauiApp<App>() \\n            // Omitted for brevity             \\n            \", \".RegisterAppServices() \\n            .RegisterViewModels() \\n            .RegisterViews() \\n           \", \" .Build(); \\n} \\n\\nThe MauiApp.CreateBuilder method creates a MauiAppBuilder object that we can use to \", \"register our \\ndependencies. Many dependencies in the eShop multi-platform app need to be registered,\", \" so the \\nextension methods RegisterAppServices, RegisterViewModels, and RegisterViews were created t\", \"o help \\nprovide an organized and maintainable registration workflow. The following code shows the \\nR\", \"egisterViewModels method: \\n\\npublic static MauiAppBuilder RegisterViewModels(this MauiAppBuilder maui\", \"AppBuilder) \\n{ \\n    mauiAppBuilder.Services.AddSingleton<ViewModels.MainViewModel>(); \\n    mauiAppBu\", \"ilder.Services.AddSingleton<ViewModels.LoginViewModel>(); \\n    mauiAppBuilder.Services.AddSingleton<\", \"ViewModels.BasketViewModel>(); \\n    mauiAppBuilder.Services.AddSingleton<ViewModels.CatalogViewModel\", \">(); \\n    mauiAppBuilder.Services.AddSingleton<ViewModels.ProfileViewModel>(); \\n\\n23 \\n\\nCHAPTER 4 | De\", \"pendency injection \\n\\n \\n \\n \\n\\f    mauiAppBuilder.Services.AddTransient<ViewModels.CheckoutViewModel>()\", \"; \\n    mauiAppBuilder.Services.AddTransient<ViewModels.OrderDetailViewModel>(); \\n    mauiAppBuilder.\", \"Services.AddTransient<ViewModels.SettingsViewModel>(); \\n    mauiAppBuilder.Services.AddTransient<Vie\", \"wModels.CampaignViewModel>(); \\n    mauiAppBuilder.Services.AddTransient<ViewModels.CampaignDetailsVi\", \"ewModel>(); \\n\\n    return mauiAppBuilder; \\n} \\n\\nThis method receives an instance of MauiAppBuilder, an\", \"d we can use the Services property to register \\nour view models. Depending on the needs of your appl\", \"ication, you may need to add services with \\ndifferent lifetimes. The following table provides inform\", \"ation on when you may want to choose these \\ndifferent registration lifetimes: \\n\\nMethod \\n\\nDescription\", \" \\n\\nAddSingleton<T> \\n\\nAddTransient<T> \\n\\nNote \\n\\nWill create a single instance of the object which \\nwil\", \"l be remain for the lifetime of the application. \\n\\nWill create a new instance of the object when \\nre\", \"quested during resolution. Transient objects \\ndo not have a pre-defined lifetime, but will \\ntypicall\", \"y follow the lifetime of their host. \\n\\nThe view models do not inherit from an interface, so they onl\", \"y need their concrete type provided to \\nthe AddSingleton<T> and AddTransient<T> methods. \\n\\nThe Catal\", \"ogViewModel is used near the application\\u2019s root and should always be available, so \\nregistering it w\", \"ith AddSingleton<T> is beneficial. Other view models, such as CheckoutViewModel \\nand OrderDetailView\", \"Model are situationally navigated to or are used later in the application. Suppose \\nyou know that yo\", \"u have a component that may not always be used. In that case, if it is memory or \\ncomputationally in\", \"tensive or requires just-in-time data, it may be a better candidate for \\nAddTransient<T> registratio\", \"n. \\n\\nAnother common way to add services is using the AddSingleton<TService, TImplementation> and \\nAd\", \"dTransient<TService, TImplementation> methods. These methods take two input types: the \\ninterface de\", \"finition and the concrete implementation. This type of registration is best for cases where \\nyou are\", \" implementing services based on interfaces. In the code example below, we register our \\nISettingsSer\", \"vice interface using the SettingsService implementation: \\n\\npublic static MauiAppBuilder RegisterAppS\", \"ervices(this MauiAppBuilder mauiAppBuilder) \\n{ \\n    mauiAppBuilder.Services.AddSingleton<ISettingsSe\", \"rvice, SettingsService>(); \\n    // Omitted for brevity... \\n} \\n\\nOnce all services have been registere\", \"d, the MauiAppBuilder.Build method should be called to create \\nour MauiApp and populate our dependen\", \"cy injection container with all the registered services. \\n\\n24 \\n\\nCHAPTER 4 | Dependency injection \\n\\n \", \"\\n \\n \\n\\fImportant \\n\\nOnce the Build method has been called, the dependency injection container is immut\", \"able and can no \\nlonger be updated or modified. Ensure that all services that you need within your a\", \"pplication have \\nbeen registered before you call Build. \\n\\nResolution \\n\\nAfter a type is registered, i\", \"t can be resolved or injected as a dependency. When a type is being \\nresolved, and the container nee\", \"ds to create a new instance, it injects any dependencies into the \\ninstance. \\n\\nGenerally, when a typ\", \"e is resolved, one of three things happens: \\n\\n1. \\n\\n2. \\n\\n3. \\n\\nIf the type hasn\\u2019t been registered, the\", \" container throws an exception. \\n\\nIf the type has been registered as a singleton, the container retu\", \"rns the singleton instance. If \\nthis is the first time the type is called for, the container creates\", \" it if required and maintains a \\nreference to it. \\n\\nIf the type has been registered as transient, th\", \"e container returns a new instance and doesn\\u2019t \\nmaintain a reference to it. \\n\\n.NET MAUI offers a num\", \"ber of ways to resolve registered components based on your needs. The most \\ndirect way to gain acces\", \"s to the dependency injection container is from an Element using the \\nHandler.MauiContext.Services. \", \"An example of this is shown below: \\n\\nvar settingsService = this.Handler.MauiContext.Services.GetServ\", \"ices<ISettingsService>(); \\n\\nThis can be helpful if you need to resolve a service from within an Elem\", \"ent or from outside of the \\nconstructor of your Element. \\n\\nCaution \\n\\nThere is a possibility that the\", \" Handler property of your Element may be null, so be aware that you may \\nneed to handle those situat\", \"ions. For more information, please refer to Handler lifecycle on the \\nMicrosoft Documentation Center\", \". \\n\\nIf using the Shell control for .NET MAUI, it will implicitly call into the dependency injection \", \"container \\nto create our objects during navigation. When setting up our Shell control, the Routing.R\", \"egisterRoute \\nmethod will tie a route path to a View as shown in the example below: \\n\\nRouting.Regist\", \"erRoute(\\\"Filter\\\", typeof(FiltersView)); \\n\\nDuring Shell navigation, it will look for registrations of\", \" the FiltersView, and if any are found, it will \\ncreate that view and inject any dependencies into t\", \"he constructor. As shown in the code example \\nbelow, the CatalogViewModel will be injected into the \", \"FiltersView: \\n\\nnamespace eShop.Views; \\n\\npublic partial class FiltersView : ContentPage \\n{ \\n\\n25 \\n\\nCHA\", \"PTER 4 | Dependency injection \\n\\n \\n \\n \\n\\f    public FiltersView(CatalogViewModel viewModel) \\n    { \\n  \", \"      BindingContext = viewModel; \\n\\n        InitializeComponent(); \\n    } \\n} \\n\\nTip \\n\\nThe dependency \", \"injection container is great for creating view model instances. If a view model has \\ndependencies, i\", \"t will handle the creation and injection of any required services. Just make sure that \\nyou register\", \" your view models and any dependencies that they may have with the CreateMauiApp \\nmethod in the Maui\", \"Program class. \\n\\nSummary \\n\\nDependency injection enables the decoupling of concrete types from the co\", \"de that depends on these \\ntypes. It typically uses a container that holds a list of registrations an\", \"d mappings between interfaces \\nand abstract types, and the concrete types that implement or extend t\", \"hese types. \\n\\nMicrosoft.Extensions.DependencyInjection facilitates building loosely coupled apps and\", \" provides all of \\nthe features commonly found in dependency injection containers, including methods \", \"to register type \\nmappings and object instances, resolve objects, manage object lifetimes, and injec\", \"t dependent objects \\ninto constructors of objects it resolves. \\n\\n26 \\n\\nCHAPTER 4 | Dependency injecti\", \"on \\n\\n \\n \\n \\n \\n \\n\\fCHAPTER  5 \\n\\nCommunicating between \\nloosely coupled \\ncomponents \\n\\nThe publish-subscr\", \"ibe pattern is a messaging pattern in which publishers send messages without \\nknowing any receivers,\", \" known as subscribers. Similarly, subscribers listen for specific messages, \\nwithout knowing any pub\", \"lishers. \\n\\nEvents in .NET implement the publish-subscribe pattern and are the most simple approach f\", \"or a \\ncommunication layer between components if loose coupling is not required, such as a control an\", \"d the \\npage that contains it. However, the publisher and subscriber lifetimes are coupled by object \", \"\\nreferences to each other, and the subscriber type must have a reference to the publisher type. This\", \" \\ncan create memory management issues, especially when there are short-lived objects that subscribe \", \"\\nto an event of a static or long-lived object. If the event handler isn\\u2019t removed, the subscriber wi\", \"ll be \\nkept alive by the reference to it in the publisher, and this will prevent or delay the garbag\", \"e collection \\nof the subscriber. \\n\\nIntroduction to MVVM Toolkit Messenger \\n\\nThe MVVM Toolkit IMessen\", \"ger interface describes the publish-subscribe pattern, allowing message-\\nbased communication between\", \" components that are inconvenient to link by object and type \\nreferences. This mechanism allows publ\", \"ishers and subscribers to communicate without having a direct \\nreference to each other, helping to r\", \"educe dependencies between components, while also allowing \\ncomponents to be independently developed\", \" and tested. \\n\\nNote \\n\\nThe MVVM Toolkit Messenger is part of the CommunityToolkit.Mvvm package. For i\", \"nformation on \\nhow to add the package to your project, see Introduction to the MVVM Toolkit on the M\", \"icrosoft \\nDeveloper Center. \\n\\n27 \\n\\nCHAPTER 5 | Communicating between loosely coupled components \\n\\n \\n\", \" \\n \\n \\n\\fWarning \\n\\n.NET MAUI contains a built-in MessagingCenter class that\\u2019s no longer recommended fo\", \"r use. Use the \\nMVVM Toolkit Messenger instead. \\n\\nThe IMessenger interface allows for multicast publ\", \"ish-subscribe functionality. This means that there \\ncan be multiple publishers that publish a single\", \" message, and there can be multiple subscribers \\nlistening to the same message. The image below illu\", \"strates this relationship: \\n\\nThere are two implementations of the IMessenger interface that come wit\", \"h the \\nCommunityToolkit.Mvvm package. The WeakReferenceMessenger uses weak references which can \\nres\", \"ult in easier cleanup for message subscribers. This is a good option if your subscribers do not have\", \" \\na clearly defined lifecycle. The StrongReferenceMessenger uses strong references which can result \", \"in \\nbetter performance and a more clearly controlled lifetime of the subscription. If you have a wor\", \"kflow \\nwith a very controlled lifetime (for example, a subscription that is bound to a page\\u2019s OnAppe\", \"aring and \\nOnDisappearing methods), the StrongReferenceManager may be a better option, if performanc\", \"e is a \\nconcern. Both of these implementations are available with default implementations ready to u\", \"se by \\nreferencing either WeakReferenceMessenger.Default or StrongReferenceMessenger.Default. \\n\\nNote\", \" \\n\\nWhile the IMessenger interface permits communication between loosely-coupled classes, it does not\", \" \\noffer the only architectural solution to this issue. For example, communication between a view mod\", \"el \\nand a view can also be achieved by the binding engine and through property change notifications.\", \" In \\naddition, communication between two view models can also be achieved by passing data during \\nna\", \"vigation. \\n\\nThe eShop multi-platform app uses the WeakReferenceMessenger class to communicate betwee\", \"n \\nloosely coupled components. The app defines a single message named AddProductMessage. The \\nAddPro\", \"ductMessage is published by the CatalogViewModel class when an item is added to the \\nshopping basket\", \". In return, the CatalogView class subscribes to the message and uses this to highlight \\nthe product\", \" adds with animation in response. \\n\\nIn the eShop multi-platform app, WeakReferenceMessenger is used \", \"to update the UI in response to \\nan action occurring in another class. Therefore, messages are publi\", \"shed from the thread that the class \\nis executing on, with subscribers receiving the message on the \", \"same thread. \\n\\n28 \\n\\nCHAPTER 5 | Communicating between loosely coupled components \\n\\n \\n \\n \\n\\fTip \\n\\nMars\", \"hal to the UI or main thread when performing UI updates. If updates to user interfaces are not \\nmade\", \" on this thread, it can cause the application to crash or become unstable. \\n\\nIf a message that\\u2019s sen\", \"t from a background thread is required to update the UI, process the message \\non the UI thread in th\", \"e subscriber by invoking the MainThread.BeginInvokeOnMainThread method. \\n\\nFor more information about\", \" Messenger, see Messenger on the Microsoft Developer Center. \\n\\nDefining a message \\n\\nIMessenger messa\", \"ges are custom objects that provide custom payloads. The following code example \\nshows the AddProduc\", \"tMessage message defined within the eShop multi-platform app: \\n\\npublic class AddProductMessage : Val\", \"ueChangedMessage<int> \\n{ \\n    public AddProductMessage(int count) : base(count) \\n    { \\n    } \\n} \\n\\nT\", \"he base class is defined using ValueChangedMessage<T> where T can be of any type needed to \\npass dat\", \"a. Both message publishers and subscribers can expect messages of a specific type (for \\nexample, Add\", \"ProductMessage). This can help ensure that both parties have agreed to a messaging \\ncontract and tha\", \"t the data provided with that contract will be consistent. Additionally, this approach \\nprovides com\", \"pile-time type safety and refactoring support. \\n\\nPublishing a message \\n\\nTo publish a message, we wil\", \"l need to use the IMessenger.Send method. This can be accessed most \\ncommonly through WeakReferenceM\", \"essenger.Default.Send or \\nStrongReferenceMessenger.Default.Send. The message sent can be of any obje\", \"ct type. The following \\ncode example demonstrates publishing the AddProduct message: \\n\\nWeakReference\", \"Messenger.Default.Send(new Messages.AddProductMessage(BadgeCount)); \\n\\nIn this example, the Send meth\", \"od specifies provides a new instance of the AddProductMessage object \\nfor downstream subscribers to \", \"receive. An additional second token parameter can be added to use \\nwhen multiple different subscribe\", \"rs need to receive messages of the same type without receiving the \\nwrong message. \\n\\nThe Send method\", \" will publish the message, and its payload data, using a fire-and-forget approach. \\nTherefore, the m\", \"essage is sent even if there are no subscribers registered to receive the message. In \\nthis situatio\", \"n, the sent message is ignored. \\n\\n29 \\n\\nCHAPTER 5 | Communicating between loosely coupled components \", \"\\n\\n \\n \\n\\fSubscribing to a message \\n\\nSubscribers can register to receive a message using one of the IMe\", \"ssenger.Register<T> overloads. \\nThe following code example demonstrates how the eShop multi-platform\", \" app subscribes to, and \\nprocesses, the AddProductMessage message: \\n\\nWeakReferenceMessenger.Default \", \"\\n    .Register<CatalogView, Messages.AddProductMessage>( \\n        this, \\n        async (recipient, m\", \"essage) => \\n        { \\n            await recipient.Dispatcher.DispatchAsync( \\n                async \", \"() => \\n                { \\n                    await recipient.badge.ScaleTo(1.2); \\n                 \", \"   await recipient.badge.ScaleTo(1.0); \\n                }); \\n        }); \\n\\nIn the preceding example,\", \" the Register method subscribes to the AddProductMessage message and \\nexecutes a callback delegate i\", \"n response to receiving the message. This callback delegate, specified as \\na lambda expression, exec\", \"utes code that updates the UI. \\n\\nNote \\n\\nAvoid the use of this within your callback delegate to avoid\", \" capturing that object within the delegate. \\nThis can help improve performance. Instead, use the rec\", \"ipient parameter. \\n\\nIf payload data is supplied, don\\u2019t attempt to modify the payload data from withi\", \"n a callback delegate \\nbecause several threads could be accessing the received data simultaneously. \", \"In this scenario, the \\npayload data should be immutable to avoid concurrency errors. \\n\\nUnsubscribing\", \" from a message \\n\\nSubscribers can unsubscribe from messages they no longer want to receive. This is \", \"achieved with one \\nof the IMessenger.Unregister overloads, as demonstrated in the following code exa\", \"mple: \\n\\nWeakReferenceMessenger.Default.Unregister<Messages.AddProductMessage>(this); \\n\\nNote \\n\\nIn thi\", \"s example, it isn\\u2019t fully necessary to call Unregister as the WeakReferenceMessenger will allow \\nunu\", \"sed objects to be garbage collected. If the StrongReferenceMessenger were used, it would be \\nadvised\", \" to call Unregister for any subscriptions that are no longer in use. \\n\\nIn this example, the Unsubscr\", \"ibe method syntax specifies the type argument of the message and the \\nrecipient object that is liste\", \"ning for messages. \\n\\n30 \\n\\nCHAPTER 5 | Communicating between loosely coupled components \\n\\n \\n \\n \\n \\n\\fSu\", \"mmary \\n\\nThe MVVM Toolkit IMessenger interface describes the publish-subscribe pattern, allowing mess\", \"age-\\nbased communication between components that are inconvenient to link by object and type \\nrefere\", \"nces. This mechanism allows publishers and subscribers to communicate without having a \\nreference to\", \" each other, helping to reduce dependencies between components, while also allowing \\ncomponents to b\", \"e independently developed and tested. \\n\\n31 \\n\\nCHAPTER 5 | Communicating between loosely coupled compo\", \"nents \\n\\n \\n \\n\\fCHAPTER  6 \\n\\nNavigation \\n\\n.NET MAUI includes support for page navigation, which typical\", \"ly results from the user\\u2019s interaction \\nwith the UI or from the app itself as a result of internal l\", \"ogic-driven state changes. However, \\nnavigation can be complex to implement in apps that use the Mod\", \"el-View-ViewModel (MVVM) \\npattern, as the following challenges must be met: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nIdentifying th\", \"e view to be navigated to using an approach that does not introduce tight \\ncoupling and dependencies\", \" between views. \\n\\nCoordinating the process by which the view to be navigated to is instantiated and \", \"initialized. \\nWhen using MVVM, the view and view-model need to be instantiated and associated with \\n\", \"each other via the view\\u2019s binding context. When an app is using a dependency injection \\ncontainer, t\", \"he instantiation of views and view-models might require a specific construction \\nmechanism. \\n\\n\\u2022  Whe\", \"ther to perform view-first navigation, or view-model-first navigation. With view-first \\n\\nnavigation,\", \" the page to navigate to refers to the name of the view type. During navigation, \\nthe specified view\", \" is instantiated, along with its corresponding view-model and other \\ndependent services. An alternat\", \"ive approach is to use view-model-first navigation, where the \\npage to navigate to refers to the nam\", \"e of the view-model type. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDetermining how to cleanly separate the navigational behavio\", \"r of the app across the views \\nand view-models. The MVVM pattern separates the app\\u2019s UI and its pres\", \"entation and business \\nlogic, but it doesn\\u2019t provide a direct mechanism for tying them together. How\", \"ever, the \\nnavigation behavior of an app will often span the UI and presentation parts of the app. T\", \"he \\nuser will often initiate navigation from a view, and the view will be replaced as a result of th\", \"e \\nnavigation. However, navigation might often also need to be initiated or coordinated from \\nwithin\", \" the view-model. \\n\\nDetermining how to pass parameters during navigation for initialization purposes.\", \" For \\nexample, if the user navigates to a view to update order details, the order data will have to \", \"be \\npassed to the view so that it can display the correct data. \\n\\nCoordinating navigation to ensure \", \"that specific business rules are obeyed. For example, users \\nmight be prompted before navigating awa\", \"y from a view so that they can correct any invalid \\ndata or be prompted to submit or discard any dat\", \"a changes that were made within the view. \\n\\nThis chapter addresses these challenges by presenting a \", \"navigation service class named \\nMauiNavigationService that\\u2019s used to perform view-model-first page n\", \"avigation. \\n\\nNote \\n\\nThe MauiNavigationService used by the app is simplistic and does not cover all p\", \"ossible navigation \\ntypes. The types of navigation needed by your application may require additional\", \" functionality. \\n\\n32 \\n\\nCHAPTER 6 | Navigation \\n\\n \\n \\n\\fNavigating between pages \\n\\nNavigation logic can\", \" reside in a view\\u2019s code-behind or a data-bound view-model. While placing \\nnavigation logic in a vie\", \"w might be the most straightforward approach, it is not easily testable \\nthrough unit tests. Putting\", \" navigation logic in view-model classes means that the logic can be verified \\nthrough unit tests. In\", \" addition, the view-model can then implement logic to control navigation to \\nensure that certain bus\", \"iness rules are enforced. For example, an app might not allow the user to \\nnavigate away from a page\", \" without first ensuring that the entered data is valid. \\n\\nA navigation service is typically invoked \", \"from view-models, in order to promote testability. However, \\nnavigating to views from view-models wo\", \"uld require the view-models to reference views, and \\nparticularly views that the active view-model i\", \"sn\\u2019t associated with, which is not recommended. \\nTherefore, the MauiNavigationService presented here\", \" specifies the view-model type as the target to \\nnavigate to. \\n\\nThe eShop multi-platform app uses th\", \"e MauiNavigationService class to provide view-model-first \\nnavigation. This class implements the INa\", \"vigationService interface, which is shown in the following \\ncode example: \\n\\npublic interface INaviga\", \"tionService \\n{ \\n    Task InitializeAsync(); \\n\\n    Task NavigateToAsync(string route, IDictionary<str\", \"ing, object> routeParameters = null); \\n\\n    Task PopAsync(); \\n} \\n\\nThis interface specifies that an i\", \"mplementing class must provide the following methods: \\n\\nMethod \\n\\nPurpose \\n\\nInitializeAsync \\n\\nNavigat\", \"eToAsync(string route, \\nIDictionary<string, object> routeParameters = \\nnull) \\n\\nPopAsync \\n\\nNote \\n\\nPer\", \"forms navigation to one of two pages when \\nthe app is launched. \\n\\nPerforms hierarchical navigation t\", \"o a specified \\npage using a registered navigation route. Can \\noptionally pass named route parameters\", \" to use \\nfor processing on the destination page \\n\\nRemoves the current page from the navigation \\nstac\", \"k. \\n\\nAn INavigationService interface would usually also specify a GoBackAsync method, which is used \", \"to \\nprogrammatically return to the previous page in the navigation stack. However, this method is mi\", \"ssing \\nfrom the eShop multi-platform app because it\\u2019s not required. \\n\\n33 \\n\\nCHAPTER 6 | Navigation \\n\\n\", \" \\n \\n \\n \\n\\fCreating the MauiNavigationService instance \\n\\nThe MauiNavigationService class, which implem\", \"ents the INavigationService interface, is registered as a \\nsingleton with the dependency injection c\", \"ontainer in the MauiProgram.CreateMauiApp() method, as \\ndemonstrated in the following code example: \", \"\\n\\nmauiAppBuilder.Services.AddSingleton<INavigationService, MauiNavigationService>();; \\n\\nThe INavigat\", \"ionService interface can then be resolved by adding it to the constructor of our views and \\nview-mod\", \"els, as demonstrated in the following code example: \\n\\npublic AppShell(INavigationService navigationS\", \"ervice) \\n\\nThis returns a reference to the MauiNavigationService object that\\u2019s stored in the dependen\", \"cy injection \\ncontainer. \\n\\nThe ViewModelBase class stores the MauiNavigationService instance in a Na\", \"vigationService property, \\nof type INavigationService. Therefore, all view-model classes, which deri\", \"ve from the ViewModelBase \\nclass, can use the NavigationService property to access the methods speci\", \"fied by the \\nINavigationService interface. \\n\\nHandling navigation requests \\n\\n.NET MAUI provides multi\", \"ple ways to navigate within an application. The traditional way to navigate is \\nwith the NavigationP\", \"age class, which implements a hierarchical navigation experience in which the \\nuser can navigate thr\", \"ough pages, forward and backward, as desired. The eShop app uses the Shell \\ncomponent as the root co\", \"ntainer for the application and as a navigation host. For more information \\nabout Shell navigation, \", \"see Shell Navigation on the Microsoft Developer Center. \\n\\nNavigation is performed inside view-model \", \"classes by invoking one of the NavigateToAsync methods, \\nspecifying the route path for the page bein\", \"g navigated to, as demonstrated in the following code \\nexample: \\n\\nawait NavigationService.NavigateTo\", \"Async(\\\"//Main\\\"); \\n\\nThe following code example shows the NavigateToAsync method provided by the \\nMaui\", \"NavigationService class: \\n\\npublic Task NavigateToAsync(string route, IDictionary<string, object> rou\", \"teParameters = \\nnull) \\n{ \\n    return \\n        routeParameters != null \\n            ? Shell.Current.G\", \"oToAsync(route, routeParameters) \\n            : Shell.Current.GoToAsync(route); \\n} \\n\\nThe .NET MAUI S\", \"hell control is already familiar with route-based navigation, so the NavigateToAsync \\nmethod works t\", \"o mask this functionality. The NavigateToAsync method allows navigation data to be \\n\\n34 \\n\\nCHAPTER 6 \", \"| Navigation \\n\\n \\n \\n\\fspecified as an argument that\\u2019s passed to the view-model being navigated to, whe\", \"re it\\u2019s typically used \\nto perform initialization. For more information, see Passing parameters duri\", \"ng navigation. \\n\\nImportant \\n\\nThere are multiple ways to perform navigation in .NET MAUI. The MauiNav\", \"igationService is specifically \\nbuild to work with Shell. If you are using a NavigationPage or Tabbe\", \"dPage or a different navigation \\nmechanism, this routing service would have to be updated to work us\", \"ing those components. \\n\\nIn order to register routes for the MauiNavigationService we need to supply \", \"route information from \\nXAML or in the code-behind. The following example shows registration of rout\", \"es via XAML. \\n\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> \\n<Shell \\n    xmlns=\\\"http://schemas.microsoft.\", \"com/dotnet/2021/maui\\\" \\n    xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" \\n    xmlns:views=\\\"\", \"clr-namespace:eShop.Views\\\" \\n    x:Class=\\\"eShop.AppShell\\\"> \\n\\n    <!-- Omitted for brevity --> \\n\\n    <\", \"FlyoutItem > \\n        <ShellContent x:Name=\\\"login\\\" ContentTemplate=\\\"{DataTemplate views:LoginView}\\\" \", \"\\nRoute=\\\"Login\\\" /> \\n    </FlyoutItem> \\n\\n    <TabBar x:Name=\\\"main\\\" Route=\\\"Main\\\"> \\n        <ShellConten\", \"t Title=\\\"CATALOG\\\" Route=\\\"Catalog\\\" Icon=\\\"{StaticResource \\nCatalogIconImageSource}\\\" ContentTemplate=\\\"{\", \"DataTemplate views:CatalogView}\\\" /> \\n        <ShellContent Title=\\\"PROFILE\\\" Route=\\\"Profile\\\" Icon=\\\"{St\", \"aticResource \\nProfileIconImageSource}\\\" ContentTemplate=\\\"{DataTemplate views:ProfileView}\\\" /> \\n    </\", \"TabBar> \\n</Shell> \\n\\nIn this example, the ShellContent and TabBar user interface objects are setting \", \"their Route property. \\nThis is the preferred method of registering routes for user interface objects\", \" that are controlled by a \\nShell. \\n\\nIf we have objects that will be added to the navigation stack at\", \" a later time, then we will need to add \\nthose via code-behind. The following example show registrat\", \"ion of routes in code-behind. \\n\\nRouting.RegisterRoute(\\\"Filter\\\", typeof(FiltersView)); \\nRouting.Regis\", \"terRoute(\\\"Basket\\\", typeof(BasketView)); \\n\\nIn code-behind, we will call the Routing.RegisterRoute met\", \"hod which takes a route name as the first \\nparameter and a view type as the second parameter. When a\", \" view-model uses the NavigationService \\nproperty to navigate, the application\\u2019s Shell object will lo\", \"ok for registered routes and push them onto \\nthe navigation stack. \\n\\nAfter the view is created and n\", \"avigated to, the ApplyQueryAttributes and InitializeAsync methods of \\nthe view\\u2019s associated view-mod\", \"el are executed. For more information, see Passing parameters during \\nnavigation. \\n\\n35 \\n\\nCHAPTER 6 |\", \" Navigation \\n\\n \\n \\n \\n \\n \\n\\fNavigating when the app is launched \\n\\nWhen the app is launched, a Shell obj\", \"ect is set as the root view of the application. Once set, the Shell \\nwill be used to control route r\", \"egistration and will be present at the root of our application going \\nforward. Once the Shell has be\", \"en created, we can wait for it to be attached to the application using \\nthe OnParentSet method to in\", \"itialize our navigation route. The following code example shows this \\nmethod: \\n\\nprotected override a\", \"sync void OnParentSet() \\n{ \\n    base.OnParentSet(); \\n\\n    if (Parent is not null) \\n    { \\n        aw\", \"ait _navigationService.InitializeAsync(); \\n    } \\n} \\n\\nThe method uses an instance of INavigationServ\", \"ice which is provided the constructor from \\ndependency injection and invokes its InitializeAsync met\", \"hod. \\n\\nThe following code example shows the implementation of the MauiNavigationService.InitializeAs\", \"ync \\nmethod: \\n\\npublic Task InitializeAsync() \\n{ \\n    return NavigateToAsync(string.IsNullOrEmpty(_se\", \"ttingsService.AuthAccessToken) \\n        ? \\\"//Login\\\" \\n        : \\\"//Main/Catalog\\\"); \\n} \\n\\nThe //Main/Ca\", \"talog route is navigated to if the app has a cached access token, which is used for \\nauthentication.\", \" Otherwise, the //Login route is navigated to. \\n\\nPassing parameters during navigation \\n\\nThe Navigate\", \"ToAsync method, specified by the INavigationService interface, enables navigation data \\nto be specif\", \"ied as an IDictionary<string, object> of data that\\u2019s passed to the view-model being \\nnavigated to, w\", \"here it\\u2019s typically used to perform initialization. \\n\\nFor example, the ProfileViewModel class contai\", \"ns an OrderDetailCommand that\\u2019s executed when the \\nuser selects an order on the ProfileView page. In\", \" turn, this executes the OrderDetailAsync method, \\nwhich is shown in the following code example: \\n\\np\", \"rivate async Task OrderDetailAsync(Order order) \\n{ \\n    if (order is null) \\n    { \\n        return; \\n\", \"    } \\n\\n    await NavigationService.NavigateToAsync( \\n        \\\"OrderDetail\\\", \\n\\n36 \\n\\nCHAPTER 6 | Navi\", \"gation \\n\\n \\n \\n \\n \\n\\f        new Dictionary<string, object>{ { \\\"OrderNumber\\\", order.OrderNumber } }); \\n\", \"} \\n\\nThis method invokes navigation to the OrderDetail route, passing order number information the or\", \"der \\nthat the user selected. When the dependency injection framework creates the OrderDetailView for\", \" the \\nOrderDetail route along with the OrderDetailViewModel class which is assigned to the view\\u2019s \\nB\", \"indingContext. The OrderDetailViewModel has an attribute added to it that allows it to receive data \", \"\\nfrom the navigation service as shown in the code example below. \\n\\n[QueryProperty(nameof(OrderNumber\", \"), \\\"OrderNumber\\\")] \\npublic class OrderDetailViewModel : ViewModelBase \\n{ \\n    public int OrderNumber\", \" { get; set; } \\n} \\n\\nThe QueryProperty attribute allows us to provide a parameter for a property to m\", \"ap values to and a \\nkey to find values from the query parameters dictionary. In this example, the ke\", \"y \\u201cOrderNumber\\u201d and \\norder number value were provided during the NavigateToAsync call. The view-mode\", \"l found the \\n\\u201cOrderNumber\\u201d key and mapped the value to the OrderNumber property. The OrderNumber pro\", \"perty \\ncan then be used at a later time to retrieve the full order details from the OrderService ins\", \"tance. \\n\\nInvoking navigation using behaviors \\n\\nNavigation is usually triggered from a view by a user\", \" interaction. For example, the LoginView performs \\nnavigation following successful authentication. T\", \"he following code example shows how the navigation \\nis invoked by a behavior: \\n\\n<WebView> \\n    <WebV\", \"iew.Behaviors> \\n        <behaviors:EventToCommandBehavior \\n            EventName=\\\"Navigating\\\" \\n     \", \"       EventArgsConverter=\\\"{StaticResource WebNavigatingEventArgsConverter}\\\" \\n            Command=\\\"{\", \"Binding NavigateCommand}\\\" /> \\n    </WebView.Behaviors> \\n</WebView> \\n\\nAt runtime, the EventToCommandB\", \"ehavior will respond to interaction with the WebView. When the \\nWebView navigates to a web page, the\", \" Navigating event will fire, which will execute the \\nNavigateCommand in the LoginViewModel. By defau\", \"lt, the event arguments for the event are passed \\nto the command. This data is converted as it\\u2019s pas\", \"sed between source and target by the converter \\nspecified in the EventArgsConverter property, which \", \"returns the Url from the \\nWebNavigatingEventArgs. Therefore, when the NavigationCommand is executed,\", \" the Url of the web \\npage is passed as a parameter to the registered Action. \\n\\nIn turn, the Navigati\", \"onCommand executes the NavigateAsync method, which is shown in the \\nfollowing code example: \\n\\nprivat\", \"e async Task NavigateAsync(string url) \\n{ \\n    // Omitted for brevity. \\n    if (!string.IsNullOrWhit\", \"eSpace(accessToken)) \\n    { \\n\\n37 \\n\\nCHAPTER 6 | Navigation \\n\\n \\n \\n\\f        _settingsService.AuthAccess\", \"Token = accessToken; \\n        _settingsService.AuthIdToken = authResponse.IdentityToken; \\n        aw\", \"ait NavigationService.NavigateToAsync(\\\"//Main/Catalog\\\"); \\n    } \\n} \\n\\nThis method invokes NavigationS\", \"ervice route the application to the //Main/Catalog route. \\n\\nConfirming or cancelling navigation \\n\\nAn\", \" app might need to interact with the user during a navigation operation, so that the user can \\nconfi\", \"rm or cancel navigation. This might be necessary, for example, when the user attempts to \\nnavigate b\", \"efore having fully completed a data entry page. In this situation, an app should provide a \\nnotifica\", \"tion that allows the user to navigate away from the page, or to cancel the navigation operation \\nbef\", \"ore it occurs. This can be achieved in a view-model class by using the response from a notification \", \"\\nto control whether or not navigation is invoked. \\n\\nSummary \\n\\n.NET MAUI includes support for page na\", \"vigation, which typically results from the user\\u2019s interaction \\nwith the UI, or from the app itself, \", \"as a result of internal logic-driven state changes. However, \\nnavigation can be complex to implement\", \" in apps that use the MVVM pattern. \\n\\nThis chapter presented a NavigationService class, which is use\", \"d to perform view-model-first \\nnavigation from view-models. Placing navigation logic in view-model c\", \"lasses means that the logic can \\nbe exercised through automated tests. In addition, the view-model c\", \"an then implement logic to \\ncontrol navigation to ensure that certain business rules are enforced. \\n\", \"\\n38 \\n\\nCHAPTER 6 | Navigation \\n\\n \\n \\n\\fCHAPTER  7 \\n\\nValidation \\n\\nAny app that accepts input from users \", \"should ensure that the input is valid. An app could, for \\nexample, check for input that contains onl\", \"y characters in a particular range, is of a certain length, or \\nmatches a particular format. Without\", \" validation, a user can supply data that causes the app to fail. \\nProper validation enforces busines\", \"s rules and could help to prevent an attacker from injecting \\nmalicious data. \\n\\nIn the context of th\", \"e Model-View-ViewModel (MVVM) pattern, a view model or model will often be \\nrequired to perform data\", \" validation and signal any validation errors to the view so that the user can \\ncorrect them. The eSh\", \"op multi-platform app performs synchronous client-side validation of view \\nmodel properties and noti\", \"fies the user of any validation errors by highlighting the control that \\ncontains the invalid data, \", \"and by displaying error messages that inform the user of why the data is \\ninvalid. The image below s\", \"hows the classes involved in performing validation in the eShop multi-\\nplatform app. \\n\\nView model pr\", \"operties that require validation are of type ValidatableObject<T>, and each \\nValidatableObject<T> in\", \"stance has validation rules added to its Validations property. Validation is \\n\\n39 \\n\\nCHAPTER 7 | Vali\", \"dation \\n\\n \\n \\n \\n\\finvoked from the view model by calling the Validate method of the ValidatableObject<\", \"T> instance, \\nwhich retrieves the validation rules and executes them against the ValidatableObject<T\", \">.Value \\nproperty. Any validation errors are placed into the Errors property of the ValidatableObjec\", \"t<T> \\ninstance, and the IsValid property of the ValidatableObject<T> instance is updated to indicate\", \" \\nwhether the validation succeeded or failed. The following code shows the implementation of the \\nVa\", \"lidatableObject<T>: \\n\\nusing CommunityToolkit.Mvvm.ComponentModel; \\nnamespace eShop.Validations; \\npub\", \"lic class ValidatableObject<T> : ObservableObject, IValidity \\n{ \\n    private IEnumerable<string> _er\", \"rors; \\n    private bool _isValid; \\n    private T _value; \\n    public List<IValidationRule<T>> Valida\", \"tions { get; } = new(); \\n    public IEnumerable<string> Errors \\n    { \\n        get => _errors; \\n    \", \"    private set => SetProperty(ref _errors, value); \\n    } \\n    public bool IsValid \\n    { \\n        \", \"get => _isValid; \\n        private set => SetProperty(ref _isValid, value); \\n    } \\n    public T Valu\", \"e \\n    { \\n        get => _value; \\n        set => SetProperty(ref _value, value); \\n    } \\n    public \", \"ValidatableObject() \\n    { \\n        _isValid = true; \\n        _errors = Enumerable.Empty<string>(); \", \"\\n    } \\n    public bool Validate() \\n    { \\n        Errors = Validations \\n            ?.Where(v => !v\", \".Check(Value)) \\n            ?.Select(v => v.ValidationMessage) \\n            ?.ToArray() \\n           \", \" ?? Enumerable.Empty<string>(); \\n        IsValid = !Errors.Any(); \\n        return IsValid; \\n    } \\n}\", \" \\n\\nProperty change notification is provided by the ObservableObject class, and so an Entry control c\", \"an \\nbind to the IsValid property of ValidatableObject<T> instance in the view model class to be noti\", \"fied of \\nwhether or not the entered data is valid. \\n\\nSpecifying validation rules \\n\\nValidation rules \", \"are specified by creating a class that derives from the IValidationRule<T> interface, \\nwhich is show\", \"n in the following code example: \\n\\n40 \\n\\nCHAPTER 7 | Validation \\n\\n \\n \\n\\fpublic interface IValidationRu\", \"le<T> \\n{ \\n    string ValidationMessage { get; set; } \\n    bool Check(T value); \\n} \\n\\nThis interface s\", \"pecifies that a validation rule class must provide a boolean Check method that is used \\nto perform t\", \"he required validation, and a ValidationMessage property whose value is the validation \\nerror messag\", \"e that will be displayed if validation fails. \\n\\nThe following code example shows the IsNotNullOrEmpt\", \"yRule<T> validation rule, which is used to \\nperform validation of the username and password entered \", \"by the user on the LoginView when using \\nmock services in the eShop multi-platform app: \\n\\npublic cla\", \"ss IsNotNullOrEmptyRule<T> : IValidationRule<T> \\n{ \\n    public string ValidationMessage { get; set; \", \"} \\n\\n    public bool Check(T value) => \\n        value is string str && !string.IsNullOrWhiteSpace(str\", \"); \\n} \\n\\nThe Check method returns a boolean indicating whether the value argument is null, empty, or \", \"consists \\nonly of whitespace characters. \\n\\nAlthough not used by the eShop multi-platform app, the fo\", \"llowing code example shows a validation \\nrule for validating email addresses: \\n\\npublic class EmailRu\", \"le<T> : IValidationRule<T> \\n{ \\n    private readonly Regex _regex = new(@\\\"^([w.-]+)@([w-]+)((.(w){2,3\", \"})+)$\\\"); \\n\\n    public string ValidationMessage { get; set; } \\n\\n    public bool Check(T value) => \\n  \", \"      value is string str && _regex.IsMatch(str); \\n} \\n\\nThe Check method returns a boolean indicating\", \" whether or not the value argument is a valid email \\naddress. This is achieved by searching the valu\", \"e argument for the first occurrence of the regular \\nexpression pattern specified in the Regex constr\", \"uctor. Whether the regular expression pattern has \\nbeen found in the input string can be determined \", \"by checking the value against Regex.IsMatch. \\n\\nNote \\n\\nProperty validation can sometimes involve depe\", \"ndent properties. An example of dependent \\nproperties is when the set of valid values for property A\", \" depends on the particular value that has been \\nset in property B. To check that the value of proper\", \"ty A is one of the allowed values would involve \\nretrieving the value of property B. In addition, wh\", \"en the value of property B changes, property A \\nwould need to be revalidated. \\n\\n41 \\n\\nCHAPTER 7 | Val\", \"idation \\n\\n \\n \\n \\n \\n \\n\\fAdding validation rules to a property \\n\\nIn the eShop multi-platform app, view m\", \"odel properties that require validation are declared to be of \\ntype ValidatableObject<T>, where T is\", \" the type of the data to be validated. The following code \\nexample shows an example of two such prop\", \"erties: \\n\\npublic ValidatableObject<string> UserName { get; private set; } \\npublic ValidatableObject<\", \"string> Password { get; private set; } \\nFor validation to occur, validation rules must be added to t\", \"he Validations collection of \\neach ValidatableObject<T> instance, as demonstrated in the following c\", \"ode example: \\nprivate void AddValidations() \\n{ \\n    UserName.Validations.Add(new IsNotNullOrEmptyRul\", \"e<string>  \\n    {  \\n        ValidationMessage = \\\"A username is required.\\\"  \\n    }); \\n\\n    Password.V\", \"alidations.Add(new IsNotNullOrEmptyRule<string>  \\n    {  \\n        ValidationMessage = \\\"A password is\", \" required.\\\"  \\n    }); \\n} \\n\\nThis method adds the IsNotNullOrEmptyRule<T> validation rule to the Valid\", \"ations collection of each \\nValidatableObject<T> instance, specifying values for the validation rule\\u2019\", \"s ValidationMessage property, \\nwhich specifies the validation error message that will be displayed i\", \"f validation fails. \\n\\nTriggering validation \\n\\nThe validation approach used in the eShop multi-platfo\", \"rm app can manually trigger validation of a \\nproperty, and automatically trigger validation when a p\", \"roperty changes. \\n\\nTriggering validation manually \\n\\nValidation can be triggered manually for a view \", \"model property. For example, this occurs in the eShop \\nmulti-platform app when the user taps the Log\", \"in button on the LoginView, when using mock services. \\nThe command delegate calls the MockSignInAsyn\", \"c method in the LoginViewModel, which invokes \\nvalidation by executing the Validate method, which is\", \" shown in the following code example: \\n\\nprivate bool Validate() \\n{ \\n    bool isValidUser = ValidateU\", \"serName(); \\n    bool isValidPassword = ValidatePassword(); \\n    return isValidUser && isValidPasswor\", \"d; \\n} \\n\\nprivate bool ValidateUserName() \\n{ \\n    return _userName.Validate(); \\n} \\n\\nprivate bool Valid\", \"atePassword() \\n{ \\n\\n42 \\n\\nCHAPTER 7 | Validation \\n\\n \\n \\n \\n \\n \\n\\f    return _password.Validate(); \\n} \\n\\nTh\", \"e Validate method performs validation of the username and password entered by the user on the \\nLogin\", \"View, by invoking the Validate method on each ValidatableObject<T> instance. The following \\ncode exa\", \"mple shows the Validate method from the ValidatableObject<T> class: \\n\\npublic bool Validate() \\n{ \\n   \", \" Errors = _validations \\n        ?.Where(v => !v.Check(Value)) \\n        ?.Select(v => v.ValidationMes\", \"sage) \\n        ?.ToArray() \\n        ?? Enumerable.Empty<string>(); \\n\\n    IsValid = !Errors.Any(); \\n\\n\", \"    return IsValid; \\n} \\n\\nThis method retrieves any validation rules that were added to the object\\u2019s \", \"Validations collection. The \\nCheck method for each retrieved validation rule is executed, and the Va\", \"lidationMessage property \\nvalue for any validation rule that fails to validate the data is added to \", \"the Errors collection of the \\nValidatableObject<T> instance. Finally, the IsValid property is set, a\", \"nd its value is returned to the \\ncalling method, indicating whether validation succeeded or failed. \", \"\\n\\nTriggering validation when properties change \\n\\nValidation is also automatically triggered whenever\", \" a bound property changes. For example, when a \\ntwo-way binding in the LoginView sets the UserName o\", \"r Password property, validation is triggered. \\nThe following code example demonstrates how this occu\", \"rs: \\n\\n<Entry Text=\\\"{Binding UserName.Value, Mode=TwoWay}\\\"> \\n    <Entry.Behaviors> \\n        <behavior\", \"s:EventToCommandBehavior \\n            EventName=\\\"TextChanged\\\" \\n            Command=\\\"{Binding Validat\", \"eUserNameCommand}\\\" /> \\n    </Entry.Behaviors> \\n</Entry> \\n\\nThe Entry control binds to the UserName.Va\", \"lue property of the ValidatableObject<T> instance, and \\nthe control\\u2019s Behaviors collection has an Ev\", \"entToCommandBehavior instance added to it. This \\nbehavior executes the ValidateUserNameCommand in re\", \"sponse to the TextChanged event firing on \\nthe Entry, which is raised when the text in the Entry cha\", \"nges. In turn, the ValidateUserNameCommand \\ndelegate executes the ValidateUserName method, which exe\", \"cutes the Validate method on the \\nValidatableObject<T> instance. Therefore, every time the user ente\", \"rs a character in the Entry control \\nfor the username, validation of the entered data is performed. \", \"\\n\\nDisplaying validation errors \\n\\nThe eShop multi-platform app notifies the user of any validation er\", \"rors by highlighting the control \\nthat contains the invalid data with a red background, and by displ\", \"aying an error message that informs \\n\\n43 \\n\\nCHAPTER 7 | Validation \\n\\n \\n \\n \\n \\n\\fthe user why the data i\", \"s invalid below the control containing the invalid data. When the invalid data is \\ncorrected, the ba\", \"ckground changes back to the default state and the error message is removed. The \\nimage below shows \", \"the LoginView in the eShop multi-platform app when validation errors are \\npresent. \\n\\nHighlighting a \", \"control that contains invalid data \\n\\n.NET MAUI offers a number of ways to present validation informa\", \"tion to end-users, but one of the \\nmost straight-forward ways is through the use of Triggers. Trigge\", \"rs provide us a way to change the \\nstate of our controls, typically for appearance, based on an even\", \"t or data change that occurs for a \\ncontrol. For validation, we will be using a DataTrigger which wi\", \"ll listen to changes raised from a bound \\nproperty and respond to the changes. The Entry controls on\", \" the LoginView are setup using the \\nfollowing code: \\n\\n<Entry Text=\\\"{Binding UserName.Value, Mode=Two\", \"Way}\\\"> \\n    <Entry.Style> \\n        <OnPlatform x:TypeArguments=\\\"Style\\\"> \\n            <On Platform=\\\"i\", \"OS, Android\\\" Value=\\\"{StaticResource EntryStyle}\\\" /> \\n            <On Platform=\\\"WinUI\\\" Value=\\\"{Static\", \"Resource WinUIEntryStyle}\\\" /> \\n        </OnPlatform> \\n    </Entry.Style> \\n    <Entry.Behaviors> \\n   \", \"     <mct:EventToCommandBehavior \\n            EventName=\\\"TextChanged\\\" \\n            Command=\\\"{Binding\", \" ValidateCommand}\\\" /> \\n    </Entry.Behaviors> \\n    <Entry.Triggers> \\n        <DataTrigger  \\n        \", \"    TargetType=\\\"Entry\\\" \\n            Binding=\\\"{Binding UserName.IsValid}\\\" \\n            Value=\\\"False\\\">\", \" \\n            <Setter Property=\\\"BackgroundColor\\\" Value=\\\"{StaticResource ErrorColor}\\\" /> \\n        </D\", \"ataTrigger> \\n    </Entry.Triggers> \\n</Entry> \\n\\nThe DataTrigger specifies the following properties: \\n\", \"\\n44 \\n\\nCHAPTER 7 | Validation \\n\\n \\n \\n \\n\\fProperty \\n\\nDescription \\n\\nTargetType \\n\\nBinding \\n\\nValue \\n\\nThe co\", \"ntrol type that the trigger belongs to. \\n\\nThe data Binding markup which will provide \\nchange notific\", \"ations and value for the trigger \\ncondition. \\n\\nThe data value to specify when the trigger\\u2019s \\nconditi\", \"on has been met. \\n\\nFor this Entry, we will be listening for changes to the LoginViewModel.UserName.I\", \"sValid property. \\nEach time this property raises a change, the value will be compared against the Va\", \"lue property set in \\nthe DataTrigger. If the values are equal, then the trigger condition will be me\", \"t and any Setter objects \\nprovided to the DataTrigger will be executed. This control has a single Se\", \"tter object that updates the \\nBackgroundColor property to a custom color defined using the StaticRes\", \"ource markup. When a \\nTrigger condition is no longer met, the control will revert the properties set\", \" by the Setter object to \\ntheir previous state. For more information about Triggers, see .NET MAUI D\", \"ocs: Triggers. \\n\\nDisplaying error messages \\n\\nThe UI displays validation error messages in Label cont\", \"rols below each control whose data failed \\nvalidation. The following code example shows the Label th\", \"at displays a validation error message, if the \\nuser has not entered a valid username: \\n\\n<Label \\n\\nTe\", \"xt=\\\"{Binding UserName.Errors, Converter={StaticResource FirstValidationErrorConverter}\\\" \\n    Style=\\\"\", \"{StaticResource ValidationErrorLabelStyle}\\\" /> \\n\\nEach Label binds to the Errors property of the view\", \" model object that\\u2019s being validated. The Errors \\nproperty is provided by the ValidatableObject<T> c\", \"lass, and is of type IEnumerable<string>. Because \\nthe Errors property can contain multiple validati\", \"on errors, the FirstValidationErrorConverter instance is \\nused to retrieve the first error from the \", \"collection for display. \\n\\nSummary \\n\\nThe eShop multi-platform app performs synchronous client-side va\", \"lidation of view model properties \\nand notifies the user of any validation errors by highlighting th\", \"e control that contains the invalid data, \\nand by displaying error messages that inform the user why\", \" the data is invalid. \\n\\nView model properties that require validation are of type ValidatableObject<\", \"T>, and each \\nValidatableObject<T> instance has validation rules added to its Validations property. \", \"Validation is \\ninvoked from the view model by calling the Validate method of the ValidatableObject<T\", \"> instance, \\nwhich retrieves the validation rules and executes them against the ValidatableObject<T>\", \" Value \\nproperty. Any validation errors are placed into the Errors property of the ValidatableObject\", \"<T> \\ninstance, and the IsValid property of the ValidatableObject<T> instance is updated to indicate \", \"\\nwhether validation succeeded or failed. \\n\\n45 \\n\\nCHAPTER 7 | Validation \\n\\n \\n \\n    \\n\\fCHAPTER  8 \\n\\nAppl\", \"ication settings \\nmanagement \\n\\nSettings allow the separation of data that configures the behavior of\", \" an app from the code, allowing \\nthe behavior to be changed without rebuilding the app. There are tw\", \"o types of settings: app settings \\nand user settings. \\n\\nApp settings are data that an app creates an\", \"d manages. It can include data such as fixed web service \\nendpoints, API keys, and runtime state. Ap\", \"p settings are tied to core functionality and are only \\nmeaningful to that app. \\n\\nUser settings are \", \"the customizable settings of an app that affect the app\\u2019s behavior and don\\u2019t require \\nfrequent re-ad\", \"justment. For example, an app might let the user specify where to retrieve data and \\nhow to display \", \"it on the screen. \\n\\nCreating a Settings Interface \\n\\nWhile the preferences manager can be used direct\", \"ly in your application, it does come with the \\ndrawback of making your application tightly coupled t\", \"o the preferences manager implementation. \\nThis coupling means that creating unit tests or extending\", \" the functionality of preferences \\nmanagement will be limited since your application will not have a\", \" direct way to intercept the behavior. \\nTo address this concern, an interface can be created to work\", \" as a proxy for preferences management. \\nThe interface will allow us to supply an implementation tha\", \"t fits our needs. For example, when writing \\na unit test, we may want to set specific settings, and \", \"the interface will give us an easy way to \\nconsistently set this data for the test. The following co\", \"de example shows the ISettingsService interface \\nin the eShop multi-platform app: \\n\\nnamespace eShop.\", \"Services.Settings; \\n\\npublic interface ISettingsService \\n{ \\n    string AuthAccessToken { get; set; } \", \"\\n    string AuthIdToken { get; set; } \\n    bool UseMocks { get; set; } \\n    string IdentityEndpointB\", \"ase { get; set; } \\n    string GatewayShoppingEndpointBase { get; set; } \\n    string GatewayMarketing\", \"EndpointBase { get; set; } \\n    bool UseFakeLocation { get; set; } \\n    string Latitude { get; set; \", \"} \\n    string Longitude { get; set; } \\n\\n46 \\n\\nCHAPTER 8 | Application settings management \\n\\n \\n \\n \\n\\f  \", \"  bool AllowGpsLocation { get; set; } \\n} \\n\\nAdding Settings \\n\\n.NET MAUI includes a preferences manage\", \"r that provides a way to store runtime settings for a user. \\nThis feature can be accessed from anywh\", \"ere within your application using the \\nMicrosoft.Maui.Storage.Preferences class. The preferences man\", \"ager provides a consistent, type-safe, \\ncross-platform approach for persisting and retrieving app an\", \"d user settings, while using the native \\nsettings management provided by each platform. In addition,\", \" it\\u2019s straightforward to use data binding \\nto access settings data exposed by the library. For more \", \"information, see the Preferences on the \\nMicrosoft Developer Center. \\n\\nTip \\n\\nPreferences is meant fo\", \"r storing relatively small data. If you need to store larger or more complex \\ndata, consider using a\", \" local database or filesystem to store the data. \\n\\nOur application will use the Preferences class ne\", \"ed to implement the ISettingsService interface. The \\ncode below shows how the eShop multi-platform a\", \"pp\\u2019s SettingsService implements the \\nAuthTokenAccess and UseMocks properties: \\n\\npublic sealed class \", \"SettingsService : ISettingsService \\n{ \\n    private const string AccessToken = \\\"access_token\\\"; \\n    p\", \"rivate const string AccessTokenDefault = string.Empty; \\n\\n    private const string IdUseMocks = \\\"use_\", \"mocks\\\"; \\n    private const bool UseMocksDefault = true; \\n\\n    public string AuthAccessToken \\n    { \\n\", \"        get => Preferences.Get(AccessToken, AccessTokenDefault); \\n        set => Preferences.Set(Acc\", \"essToken, value); \\n    } \\n\\n    public bool UseMocks \\n    { \\n        get => Preferences.Get(IdUseMock\", \"s, UseMocksDefault); \\n        set => Preferences.Set(IdUseMocks, value); \\n    } \\n} \\n\\nEach setting co\", \"nsists of a private key, a private default value, and a public property. The key is always \\na const \", \"string that defines a unique name, with the default value for the setting being a static read-\\nonly \", \"or constant value of the required type. Providing a default value ensures that a valid value is \\nava\", \"ilable if an unset setting is retrieved. This service implementation can be provided via dependency \", \"\\ninjection to our application for use in view-models or other services throughout the application. \\n\", \"\\n47 \\n\\nCHAPTER 8 | Application settings management \\n\\n \\n \\n \\n \\n \\n\\fData binding to user settings \\n\\nIn th\", \"e eShop multi-platform app, the SettingsView exposes multiple settings the user can configure at \\nru\", \"ntime. These settings include allowing configuration of whether the app should retrieve data from \\nm\", \"icroservices deployed as Docker containers or whether the app should retrieve data from mock \\nservic\", \"es that don\\u2019t require an internet connection. When retrieving data from containerized \\nmicroservices\", \", a base endpoint URL for the microservices must be specified. The image below shows \\nthe SettingsVi\", \"ew when the user has chosen to retrieve data from containerized microservices. \\n\\nData binding can be\", \" used to retrieve and set settings exposed by the ISettingService interface. This is \\nachieved by co\", \"ntrols on the view binding to view model properties that in turn access properties in \\nthe ISettingS\", \"ervice interface and raising a property changed notification if the value has changed. \\n\\nThe followi\", \"ng code example shows the Entry control from the SettingsView that allows the user to \\nenter a base \", \"identity endpoint URL for the containerized microservices: \\n\\n<Entry Text=\\\"{Binding IdentityEndpoint,\", \" Mode=TwoWay}\\\" /> \\n\\nThis Entry control binds to the IdentityEndpoint property of the SettingsViewMod\", \"el class, using a two-\\nway binding. The following code example shows the IdentityEndpoint property: \", \"\\n\\nprivate readonly ISettingsService _settingsService; \\n\\nprivate string _identityEndpoint; \\n\\npublic S\", \"ettingsViewModel( \\n    ILocationService locationService, IAppEnvironmentService appEnvironmentServic\", \"e, \\n    IDialogService dialogService, INavigationService navigationService, ISettingsService \\nsettin\", \"gsService) \\n    : base(dialogService, navigationService, settingsService) \\n{ \\n    _settingsService =\", \" settingsService; \\n\\n    _identityEndpoint = _settingsService.IdentityEndpointBase; \\n} \\n\\npublic strin\", \"g IdentityEndpoint \\n\\n48 \\n\\nCHAPTER 8 | Application settings management \\n\\n \\n \\n \\n \\n \\n \\n \\n\\f{ \\n    get =>\", \" _identityEndpoint; \\n    set \\n    { \\n        SetProperty(ref _identityEndpoint, value); \\n\\n        if\", \" (!string.IsNullOrWhiteSpace(value)) \\n        { \\n            UpdateIdentityEndpoint(); \\n        } \\n \", \"   } \\n} \\n\\nWhen the IdentityEndpoint property is set, the UpdateIdentityEndpoint method is called, pr\", \"ovided \\nthat the supplied value is valid. The following code example shows the UpdateIdentityEndpoin\", \"t \\nmethod: \\n\\nprivate void UpdateIdentityEndpoint() \\n{ \\n    _settingsService.IdentityEndpointBase = _\", \"identityEndpoint; \\n} \\n\\nThis method updates the IdentityEndpointBase property in the ISettingService \", \"interface \\nimplementation with the base endpoint URL value entered by the user. If the SettingsServi\", \"ce class is \\nprovided as the implementation for _settingsService, the value will persist to platform\", \"-specific storage. \\n\\nSummary \\n\\nSettings allow the separation of data that configures the behavior of\", \" an app from the code, allowing \\nthe behavior to be changed without rebuilding the app. App settings\", \" are data that an app creates and \\nmanages, and user settings are the customizable settings of an ap\", \"p that affect the app\\u2019s behavior and \\ndon\\u2019t require frequent re-adjustment. \\n\\nThe Microsoft.Maui.Sto\", \"rage.Preferences class provides a consistent, type-safe, cross-platform \\napproach for persisting and\", \" retrieving app and user settings. \\n\\n49 \\n\\nCHAPTER 8 | Application settings management \\n\\n \\n \\n \\n\\fCHAPT\", \"ER  9 \\n\\nContainerized \\nmicroservices \\n\\nDeveloping client-server applications has resulted in a focus\", \" on building tiered applications that use \\nspecific technologies in each tier. Such applications are\", \" often referred to as monolithic and are \\npackaged onto hardware pre-scaled for peak loads. The main\", \" drawbacks of this development \\napproach are the tight coupling between components within each tier,\", \" that individual components \\ncan\\u2019t be easily scaled, and the cost of testing. A simple update can ha\", \"ve unforeseen effects on the rest \\nof the tier, so a change to an application component requires its\", \" entire tier to be retested and \\nredeployed. \\n\\nParticularly concerning, in the age of the cloud, is \", \"that individual components can\\u2019t be easily scaled. A \\nmonolithic application contains domain-specifi\", \"c functionality and is typically divided by functional \\nlayers such as front-end, business logic, an\", \"d data storage. The image below illustrates that a \\nmonolithic application is scaled by cloning the \", \"entire application onto multiple machines. \\n\\n50 \\n\\nCHAPTER 9 | Containerized microservices \\n\\n \\n \\n\\fMic\", \"roservices \\n\\nMicroservices offer a different approach to application development and deployment, an \", \"approach \\nthat\\u2019s suited to the agility, scale, and reliability requirements of modern cloud applicat\", \"ions. A \\nmicroservices application is split into independent components that work together to delive\", \"r the \\napplication\\u2019s overall functionality. The term microservice emphasizes that applications shoul\", \"d be \\ncomposed of services small enough to reflect particular concerns, so each microservice impleme\", \"nts a \\nsingle function. In addition, each microservice has well-defined contracts with which other \\n\", \"microservices communicate and share data. Typical examples of microservices include shopping carts, \", \"\\ninventory processing, purchase subsystems, and payment processing. \\n\\nMicroservices can scale indepe\", \"ndently compared to giant monolithic applications that scale together. \\nThis means that a specific f\", \"unctional area that requires more processing power or network bandwidth \\nto support demand can be sc\", \"aled rather than unnecessarily scaling out other application areas. The \\nimage below illustrates thi\", \"s approach, where microservices are deployed and scaled independently, \\ncreating instances of servic\", \"es across machines. \\n\\n51 \\n\\nCHAPTER 9 | Containerized microservices \\n\\n \\n \\n \\n\\fMicroservice scale-out c\", \"an be nearly instantaneous, allowing an application to adapt to changing \\nloads. For example, a sing\", \"le microservice in the web-facing functionality of an application might be \\nthe only microservice th\", \"at needs to scale out to handle additional incoming traffic. \\n\\nThe classic model for application sca\", \"lability is to have a load-balanced, stateless tier with a shared \\nexternal datastore to store persi\", \"stent data. Stateful microservices manage their own persistent data, \\nusually storing it locally on \", \"the servers on which they are placed, to avoid the overhead of network \\naccess and complexity of cro\", \"ss-service operations. This enables the fastest possible processing of data \\nand can eliminate the n\", \"eed for caching systems. In addition, scalable stateful microservices usually \\npartition data among \", \"their instances, in order to manage data size and transfer throughput beyond \\nwhich a single server \", \"can support. \\n\\nMicroservices also support independent updates. This loose coupling between microserv\", \"ices provides \\na rapid and reliable application evolution. Their independent, distributed nature hel\", \"ps rolling updates, \\nwhere only a subset of instances of a single microservice will update at any gi\", \"ven time. Therefore, if a \\nproblem is detected, a buggy update can be rolled back, before all instan\", \"ces update with the faulty \\ncode or configuration. Similarly, microservices typically use schema ver\", \"sioning, so that clients see a \\nconsistent version when updates are being applied, regardless of whi\", \"ch microservice instance is being \\ncommunicated with. \\n\\nTherefore, microservice applications have ma\", \"ny benefits over monolithic applications: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n52 \\n\\nEach microservice is relatively small, \", \"easy to manage and evolve. \\n\\nEach microservice can be developed and deployed independently of other \", \"services. \\n\\nEach microservice can be scaled-out independently. For example, a catalog service or \\nsh\", \"opping basket service might need to be scaled-out more than an ordering service. \\n\\nCHAPTER 9 | Conta\", \"inerized microservices \\n\\n \\n \\n \\n\\f\\u2022 \\n\\n\\u2022 \\n\\nTherefore, the resulting infrastructure will more efficientl\", \"y consume resources when scaling \\nout. \\n\\nEach microservice isolates any issues. For example, if ther\", \"e is an issue in a service it only \\nimpacts that service. The other services can continue to handle \", \"requests. \\n\\nEach microservice can use the latest technologies. Because microservices are autonomous \", \"and \\nrun side-by-side, the latest technologies and frameworks can be used, rather than being \\nforced\", \" to use an older framework that might be used by a monolithic application. \\n\\nHowever, a microservice\", \"-based solution also has potential drawbacks: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nChoosing how to partition an app\", \"lication into microservices can be challenging, as each \\nmicroservice has to be completely autonomou\", \"s, end-to-end, including responsibility for its \\ndata sources. \\n\\nDevelopers must implement inter-ser\", \"vice communication, which adds complexity and latency \\nto the application. \\n\\nAtomic transactions bet\", \"ween multiple microservices usually aren\\u2019t possible. Therefore, \\nbusiness requirements must embrace \", \"eventual consistency between microservices. \\n\\nIn production, there is an operational complexity in d\", \"eploying and managing a system \\ncompromised of many independent services. \\n\\nDirect client-to-microse\", \"rvice communication can make it difficult to refactor the contracts of \\nmicroservices. For example, \", \"over time how the system is partitioned into services might need \\nto change. A single service might \", \"split into two or more services, and two services might \\nmerge. When clients communicate directly wi\", \"th microservices, this refactoring work can break \\ncompatibility with client apps. \\n\\nContainerizatio\", \"n \\n\\nContainerization is an approach to software development in which an application and its versione\", \"d set \\nof dependencies, plus its environment configuration abstracted as deployment manifest files, \", \"are \\npackaged together as a container image, tested as a unit, and deployed to a host operating syst\", \"em. \\n\\nA container is an isolated, resource controlled, and portable operating environment, where an \", \"\\napplication can run without touching the resources of other containers, or the host. Therefore, a \\n\", \"container looks and acts like a newly installed physical computer or a virtual machine. \\n\\nThere are \", \"many similarities between containers and virtual machines, as illustrated below. \\n\\n53 \\n\\nCHAPTER 9 | \", \"Containerized microservices \\n\\n \\n \\n\\fA container runs an operating system, has a file system, and can \", \"be accessed over a network as if it \\nwere a physical or virtual machine. However, the technology and\", \" concepts used by containers are very \\ndifferent from virtual machines. Virtual machines include the\", \" applications, the required dependencies, \\nand a full guest operating system. Containers include the\", \" application and its dependencies, but share \\nthe operating system with other containers, running as\", \" isolated processes on the host operating \\nsystem (aside from Hyper-V containers which run inside of\", \" a special virtual machine per container). \\nTherefore, containers share resources and typically requ\", \"ire fewer resources than virtual machines. \\n\\nThe advantage of a container-oriented development and d\", \"eployment approach is that it eliminates \\nmost of the issues that arise from inconsistent environmen\", \"t setups and the problems that come with \\nthem. In addition, containers permit fast application scal\", \"e-up functionality by instancing new \\ncontainers as required. \\n\\nThe key concepts when creating and w\", \"orking with containers are: \\n\\nConcept \\n\\nDescription \\n\\nContainer Host \\n\\nContainer Image \\n\\nThe physica\", \"l or virtual machine configured to \\nhost containers. The container host will run one \\nor more contai\", \"ners. \\n\\nAn image consists of a union of layered \\nfilesystems stacked on top of each other, and is \\nt\", \"he basis of a container. An image does not \\nhave state and it never changes as it\\u2019s deployed \\nto dif\", \"ferent environments. \\n\\nContainer \\n\\nA container is a runtime instance of an image. \\n\\n54 \\n\\nCHAPTER 9 |\", \" Containerized microservices \\n\\n \\n \\n \\n\\fConcept \\n\\nDescription \\n\\nContainer OS Image \\n\\nContainer Reposit\", \"ory \\n\\nContainers are deployed from images. The \\ncontainer operating system image is the first \\nlayer\", \" in potentially many image layers that make \\nup a container. A container operating system is \\nimmuta\", \"ble, and can\\u2019t be modified. \\n\\nEach time a container image is created, the \\nimage and its dependencie\", \"s are stored in a local \\nrepository. These images can be reused many \\ntimes on the container host. T\", \"he container \\nimages can also be stored in a public or private \\nregistry, such as Docker Hub, so tha\", \"t they can \\nbe used across different container hosts. \\n\\nEnterprises are increasingly adopting contai\", \"ners when implementing microservice-based applications, \\nand Docker has become the standard containe\", \"r implementation that has been adopted by most \\nsoftware platforms and cloud vendors. \\n\\nThe eShop re\", \"ference application uses Docker to host four containerized back-end microservices, as \\nillustrated i\", \"n the diagram below. \\n\\n55 \\n\\nCHAPTER 9 | Containerized microservices \\n\\n \\n \\n\\fThe architecture of the b\", \"ack-end services in the reference application is decomposed into multiple \\nautonomous sub-systems in\", \" the form of collaborating microservices and containers. Each microservice \\nprovides a single area o\", \"f functionality: an identity service, a catalog service, an ordering service, and a \\nbasket service.\", \" \\n\\nEach microservice has its own database, allowing it to be fully decoupled from the other \\nmicrose\", \"rvices. Where necessary, consistency between databases from different microservices is \\nachieved usi\", \"ng application-level events. For more information, see Communication between \\nmicroservices. \\n\\nCommu\", \"nication between client and microservices \\n\\nThe eShop multi-platform app communicates with the conta\", \"inerized back-end microservices using \\ndirect client-to-microservice communication, as shown below. \", \"\\n\\n56 \\n\\nCHAPTER 9 | Containerized microservices \\n\\n \\n \\n \\n\\fWith direct client-to-microservice communica\", \"tion, the multi-platform app makes requests to each \\nmicroservice directly through its public endpoi\", \"nt, with a different TCP port per microservice. In \\nproduction, the endpoint would typically map to \", \"the microservice\\u2019s load balancer, which distributes \\nrequests across the available instances. \\n\\nTip \", \"\\n\\nConsider using API gateway communication. \\n\\nDirect client-to-microservice communication can have d\", \"rawbacks when building a large and complex \\nmicroservice-based application, but it\\u2019s more than adequ\", \"ate for a small application. Consider using \\nAPI gateway communication when designing a large micros\", \"ervice-based application with tens of \\nmicroservices. \\n\\nCommunication between microservices \\n\\nA micr\", \"oservices-based application is a distributed system, potentially running on multiple machines. \\nEach\", \" service instance is typically a process. Therefore, services must interact using an inter-process \\n\", \"communication protocol, such as HTTP, TCP, Advanced Message Queuing Protocol (AMQP), or binary \\nprot\", \"ocols, depending on the nature of each service. \\n\\nThe two common approaches for microservice-to-micr\", \"oservice communication are HTTP-based REST \\ncommunication when querying for data, and lightweight as\", \"ynchronous messaging when \\ncommunicating updates across multiple microservices. \\n\\nAsynchronous messa\", \"ging-based event-driven communication is critical when propagating changes \\nacross multiple microser\", \"vices. With this approach, a microservice publishes an event when something \\nnotable happens, for ex\", \"ample, when it updates a business entity. Other microservices subscribe to \\nthese events. Then, when\", \" a microservice receives an event, it updates its own business entities, which \\nmight, in turn, lead\", \" to more events being published. This publish-subscribe functionality is usually \\nachieved with an e\", \"vent bus. \\n\\n57 \\n\\nCHAPTER 9 | Containerized microservices \\n\\n \\n \\n \\n\\fAn event bus allows publish-subscr\", \"ibe communication between microservices without requiring the \\ncomponents to be explicitly aware of \", \"each other, as shown below. \\n\\nFrom an application perspective, the event bus is simply a publish-sub\", \"scribe channel exposed via an \\ninterface. However, the way the event bus is implemented can vary. Fo\", \"r example, an event bus \\nimplementation could use RabbitMQ, Azure Service Bus, or other service buse\", \"s such as NServiceBus \\nand MassTransit. The diagram below shows how an event bus is used in the eSho\", \"p reference \\napplication. \\n\\nThe eShop event bus, implemented using RabbitMQ, provides one-to-many as\", \"ynchronous publish-\\nsubscribe functionality. This means that after publishing an event, there can be\", \" multiple subscribers \\nlistening for the same event. The diagram below illustrates this relationship\", \". \\n\\n58 \\n\\nCHAPTER 9 | Containerized microservices \\n\\n \\n \\n \\n \\n\\fThis one-to-many communication approach \", \"uses events to implement business transactions that span \\nmultiple services, ensuring eventual consi\", \"stency between the services. An eventual-consistent \\ntransaction consists of a series of distributed\", \" steps. Therefore, when the user-profile microservice \\nreceives the UpdateUser command, it updates t\", \"he user\\u2019s details in its database and publishes the \\nUserUpdated event to the event bus. Both the ba\", \"sket microservice and the ordering microservice have \\nsubscribed to receive this event, and in respo\", \"nse, update their buyer information in their respective \\ndatabases. \\n\\nSummary \\n\\nMicroservices offer \", \"an approach to application development and deployment that\\u2019s suited to the \\nagility, scale, and reli\", \"ability requirements of modern cloud applications. One of the main advantages \\nof microservices is t\", \"hat they can be scaled-out independently, which means that a specific functional \\narea can be scaled\", \" that requires more processing power or network bandwidth to support demand \\nwithout unnecessarily s\", \"caling areas of the application that are not experiencing increased demand. \\n\\nA container is an isol\", \"ated, resource-controlled, and portable operating environment where an \\napplication can run without \", \"touching the resources of other containers or the host. Enterprises are \\nincreasingly adopting conta\", \"iners when implementing microservice-based applications, and Docker \\nhas become the standard contain\", \"er implementation that most software platforms and cloud vendors \\nhave adopted. \\n\\n59 \\n\\nCHAPTER 9 | C\", \"ontainerized microservices \\n\\n \\n \\n \\n\\fCHAPTER  10 \\n\\nAccessing remote data \\n\\nMany modern web-based solu\", \"tions make use of web services, hosted by web servers, to provide \\nfunctionality for remote client a\", \"pplications. The operations that a web service exposes constitute a \\nweb API. \\n\\nClient apps should b\", \"e able to utilize the web API without knowing how the data or operations that the \\nAPI exposes are i\", \"mplemented. This requires that the API abides by common standards that enable a \\nclient app and web \", \"service to agree on which data formats to use, and the structure of the data that is \\nexchanged betw\", \"een client apps and the web service. \\n\\nIntroduction to Representational State Transfer \\n\\nRepresentat\", \"ional State Transfer (REST) is an architectural style for building distributed systems based \\non hyp\", \"ermedia. A primary advantage of the REST model is that it\\u2019s based on open standards and \\ndoesn\\u2019t bin\", \"d the implementation of the model or the client apps that access it to any specific \\nimplementation.\", \" Therefore, a REST web service could be implemented using Microsoft ASP.NET Core, \\nand client apps c\", \"ould be developing using any language and toolset that can generate HTTP requests \\nand parse HTTP re\", \"sponses. \\n\\nThe REST model uses a navigational scheme to represent objects and services over a networ\", \"k, referred \\nto as resources. Systems that implement REST typically use the HTTP protocol to transmi\", \"t requests to \\naccess these resources. In such systems, a client app submits a request in the form o\", \"f a URI that \\nidentifies a resource, and an HTTP method (such as GET, POST, PUT, or DELETE) that ind\", \"icates the \\noperation to be performed on that resource. The body of the HTTP request contains any da\", \"ta required \\nto perform the operation. \\n\\nNote \\n\\nREST defines a stateless request model. Therefore, H\", \"TTP requests must be independent and might \\noccur in any order. \\n\\nThe response from a REST request m\", \"akes use of standard HTTP status codes. For example, a request \\nthat returns valid data should inclu\", \"de the HTTP response code 200 (OK), while a request that fails to \\nfind or delete a specified resour\", \"ce should return a response that includes the HTTP status code 404 \\n(Not Found). \\n\\nA RESTful web API\", \" exposes a set of connected resources, and provides the core operations that \\nenable an app to manip\", \"ulate those resources and easily navigate between them. For this reason, the \\nURIs that constitute a\", \" typical RESTful web API are oriented towards the data that it exposes, and use \\nthe facilities prov\", \"ided by HTTP to operate on this data. \\n\\n60 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n\\fThe data incl\", \"uded by a client app in an HTTP request, and the corresponding response messages from \\nthe web serve\", \"r, could be presented in a variety of formats, known as media types. When a client app \\nsends a requ\", \"est that returns data in the body of a message, it can specify the media types it can \\nhandle in the\", \" Accept header of the request. If the web server supports this media type, it can reply \\nwith a resp\", \"onse that includes the Content-Type header that specifies the format of the data in the \\nbody of the\", \" message. It\\u2019s then the responsibility of the client app to parse the response message and \\ninterpre\", \"t the results in the message body appropriately. \\n\\nFor more information about REST, see API design a\", \"nd API implementation on Microsoft Docs. \\n\\nConsuming RESTful APIs \\n\\nThe eShop multi-platform app use\", \"s the Model-View-ViewModel (MVVM) pattern, and the model \\nelements of the pattern represent the doma\", \"in entities used in the app. The controller and repository \\nclasses in the eShop reference applicati\", \"on accept and return many of these model objects. Therefore, \\nthey are used as data transfer objects\", \" (DTOs) that hold all the data that is passed between the app \\nand the containerized microservices. \", \"The main benefit of using DTOs to pass data to and receive data \\nfrom a web service is that by trans\", \"mitting more data in a single remote call, the app can reduce the \\nnumber of remote calls that need \", \"to be made. \\n\\nMaking web requests \\n\\nThe eShop multi-platform app uses the HttpClient class to make r\", \"equests over HTTP, with JSON being \\nused as the media type. This class provides functionality for as\", \"ynchronously sending HTTP requests \\nand receiving HTTP responses from a URI identified resource. The\", \" HttpResponseMessage class \\nrepresents an HTTP response message received from a REST API after an HT\", \"TP request has been \\nmade. It contains information about the response, including the status code, he\", \"aders, and any body. \\nThe HttpContent class represents the HTTP body and content headers, such as Co\", \"ntent-Type and \\nContent-Encoding. The content can be read using any of the ReadAs methods, such as \\n\", \"ReadAsStringAsync and ReadAsByteArrayAsync, depending on the format of the data. \\n\\nMaking a GET requ\", \"est \\n\\nThe CatalogService class is used to manage the data retrieval process from the catalog microse\", \"rvice. \\nIn the RegisterViewModels method in the MauiProgram class, the CatalogService class is regis\", \"tered as \\na type mapping against the ICatalogService type with the dependency injection container. T\", \"hen, when \\nan instance of the CatalogViewModel class is created, its constructor accepts an ICatalog\", \"Service type, \\nwhich the dependency injection container resolves, returning an instance of the Catal\", \"ogService class. \\nFor more information about dependency injection, see Dependency Injection. \\n\\nThe i\", \"mage below shows the interaction of classes that read catalog data from the catalog microservice \\nfo\", \"r displaying by the CatalogView. \\n\\n61 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n\\fWhen the CatalogVi\", \"ew is navigated to, the OnInitialize method in the CatalogViewModel class is \\ncalled. This method re\", \"trieves catalog data from the catalog microservice, as demonstrated in the \\nfollowing code example: \", \"\\n\\npublic override async Task InitializeAsync() \\n{ \\n    Products = await _productsService.GetCatalogA\", \"sync(); \\n}  \\n\\nThis method calls the GetCatalogAsync method of the CatalogService instance that was i\", \"njected into \\nthe CatalogViewModel by the dependency injection container. The following code example\", \" shows the \\nGetCatalogAsync method: \\n\\npublic async Task<ObservableCollection<CatalogItem>> GetCatalo\", \"gAsync() \\n{ \\n    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.CatalogEndpoint); \\n    b\", \"uilder.Path = \\\"api/v1/catalog/items\\\"; \\n    string uri = builder.ToString(); \\n\\n    CatalogRoot? catal\", \"og = await _requestProvider.GetAsync<CatalogRoot>(uri); \\n\\n    return catalog?.Data;           \\n}  \\n\\n\", \"62 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n \\n \\n \\n\\fThis method builds the URI that identifies the \", \"resource the request will be sent to, and uses the \\nRequestProvider class to invoke the GET HTTP met\", \"hod on the resource, before returning the results to \\nthe CatalogViewModel. The RequestProvider clas\", \"s contains functionality that submits a request in the \\nform of a URI that identifies a resource, an\", \" HTTP method that indicates the operation to be performed \\non that resource, and a body that contain\", \"s any data required to perform the operation. For \\ninformation about how the RequestProvider class i\", \"s injected into the CatalogService class, see \\nDependency Injection. \\n\\nThe following code example sh\", \"ows the GetAsync method in the RequestProvider class: \\n\\npublic async Task<TResult> GetAsync<TResult>\", \"(string uri, string token = \\\"\\\") \\n{ \\n    HttpClient httpClient = GetOrCreateHttpClient(token); \\n    H\", \"ttpResponseMessage response = await httpClient.GetAsync(uri); \\n\\n    await HandleResponse(response); \", \"\\n    TResult result = await response.Content.ReadFromJsonAsync<TResult>(); \\n\\n    return result; \\n} \\n\", \"\\nThis method calls the GetOrCreateHttpClient method, which returns an instance of the HttpClient cla\", \"ss \\nwith the appropriate headers set. It then submits an asynchronous GET request to the resource \\ni\", \"dentified by the URI, with the response being stored in the HttpResponseMessage instance. The \\nHandl\", \"eResponse method is then invoked, which throws an exception if the response doesn\\u2019t include a \\nsucce\", \"ss HTTP status code. Then the response is read as a string, converted from JSON to a \\nCatalogRoot ob\", \"ject, and returned to the CatalogService. \\n\\nThe GetOrCreateHttpClient method is shown in the followi\", \"ng code example: \\n\\nprivate readonly Lazy<HttpClient> _httpClient = \\n    new Lazy<HttpClient>( \\n     \", \"   () => \\n        { \\n            var httpClient = new HttpClient(); \\n            httpClient.DefaultR\", \"equestHeaders.Accept.Add(new \\nMediaTypeWithQualityHeaderValue(\\\"application/json\\\")); \\n            ret\", \"urn httpClient; \\n        }, \\n        LazyThreadSafetyMode.ExecutionAndPublication); \\n\\nprivate HttpCl\", \"ient GetOrCreateHttpClient(string token = \\\"\\\") \\n    { \\n        var httpClient = _httpClient.Value; \\n\\n\", \"        if (!string.IsNullOrEmpty(token)) \\n        { \\n            httpClient.DefaultRequestHeaders.A\", \"uthorization = new \\nAuthenticationHeaderValue(\\\"Bearer\\\", token); \\n        } \\n        else \\n        { \", \"\\n            httpClient.DefaultRequestHeaders.Authorization = null; \\n        } \\n\\n63 \\n\\nCHAPTER 10 | A\", \"ccessing remote data \\n\\n \\n \\n \\n \\n \\n \\n \\n\\f        return httpClient; \\n    } \\n\\nThis method uses creates a\", \" new instance or retrieves a cached instance of the HttpClient class, and \\nsets the Accept header of\", \" any requests made by the HttpClient instance to application/json, which \\nindicates that it expects \", \"the content of any response to be formatted using JSON. Then, if an access \\ntoken was passed as an a\", \"rgument to the GetOrCreateHttpClient method, it\\u2019s added to the \\nAuthorization header of any requests\", \" made by the HttpClient instance, prefixed with the string Bearer. \\nFor more information about autho\", \"rization, see Authorization. \\n\\nTip \\n\\nIt is highly recommended to cache and reuse instances of the Ht\", \"tpClient for better application \\nperformance. Creating a new HttpClient for each operation can lead \", \"to issue with socket exhaustion. \\nFor more information, see HttpClient Instancing on the Microsoft D\", \"eveloper Center. \\n\\nWhen the GetAsync method in the RequestProvider class calls HttpClient.GetAsync, \", \"the Items method \\nin the CatalogController class in the Catalog.API project is invoked, which is sho\", \"wn in the following \\ncode example: \\n\\n[HttpGet] \\n[Route(\\\"[action]\\\")] \\npublic async Task<IActionResult\", \"> Items( \\n    [FromQuery]int pageSize = 10, [FromQuery]int pageIndex = 0) \\n{ \\n    var totalItems = a\", \"wait _catalogContext.CatalogItems \\n        .LongCountAsync(); \\n\\n    var itemsOnPage = await _catalog\", \"Context.CatalogItems \\n        .OrderBy(c => c.Name) \\n        .Skip(pageSize * pageIndex) \\n        .T\", \"ake(pageSize) \\n        .ToListAsync(); \\n\\n    itemsOnPage = ComposePicUri(itemsOnPage); \\n    var mode\", \"l = new PaginatedItemsViewModel<CatalogItem>( \\n        pageIndex, pageSize, totalItems, itemsOnPage)\", \";            \\n\\n    return Ok(model); \\n} \\n\\nThis method retrieves the catalog data from the SQL databa\", \"se using EntityFramework, and returns it \\nas a response message that includes a success HTTP status \", \"code, and a collection of JSON formatted \\nCatalogItem instances. \\n\\nMaking a POST request \\n\\nThe Baske\", \"tService class is used to manage the data retrieval and update process with the basket \\nmicroservice\", \". In the RegisterAppServices method in the MauiProgram class, the BasketService class is \\nregistered\", \" as a type mapping against the IBasketService type with the dependency injection container. \\nThen, w\", \"hen an instance of the BasketViewModel class is created, its constructor accepts an \\n\\n64 \\n\\nCHAPTER 1\", \"0 | Accessing remote data \\n\\n \\n \\n \\n \\n \\n\\fIBasketService type, which the dependency injection container\", \" resolves, returning an instance of the \\nBasketService class. For more information about dependency \", \"injection, see Dependency Injection. \\n\\nThe image below shows the interaction of classes that send th\", \"e basket data displayed by the \\nBasketView, to the basket microservice. \\n\\nWhen an item is added to t\", \"he shopping basket, the ReCalculateTotalAsync method in the \\nBasketViewModel class is called. This m\", \"ethod updates the total value of items in the basket, and sends \\nthe basket data to the basket micro\", \"service, as demonstrated in the following code example: \\n\\nprivate async Task ReCalculateTotalAsync()\", \" \\n{ \\n    // Omitted for brevity... \\n\\n    await _basketService.UpdateBasketAsync( \\n        new Custom\", \"erBasket \\n        { \\n            BuyerId = userInfo.UserId,  \\n            Items = BasketItems.ToList\", \"() \\n        },  \\n        authToken); \\n} \\n\\n65 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n \\n \\n\\fThis me\", \"thod calls the UpdateBasketAsync method of the BasketService instance that was injected into \\nthe Ba\", \"sketViewModel by the dependency injection container. The following method shows the \\nUpdateBasketAsy\", \"nc method: \\n\\npublic async Task<CustomerBasket> UpdateBasketAsync( \\n    CustomerBasket customerBasket\", \", string token) \\n{ \\n    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.BasketEndpoint); \", \"\\n    string uri = builder.ToString(); \\n    var result = await _requestProvider.PostAsync(uri, custom\", \"erBasket, token); \\n    return result; \\n} \\n\\nThis method builds the URI that identifies the resource t\", \"he request will be sent to, and uses the \\nRequestProvider class to invoke the POST HTTP method on th\", \"e resource, before returning the results \\nto the BasketViewModel. Note that an access token, obtaine\", \"d from IdentityServer during the \\nauthentication process, is required to authorize requests to the b\", \"asket microservice. For more \\ninformation about authorization, see Authorization. \\n\\nThe following co\", \"de example shows one of the PostAsync methods in the RequestProvider class: \\n\\npublic async Task<TRes\", \"ult> PostAsync<TResult>( \\n    string uri, TResult data, string token = \\\"\\\", string header = \\\"\\\") \\n{ \\n \", \"   HttpClient httpClient = GetOrCreateHttpClient(token); \\n\\n    var content = new StringContent(JsonS\", \"erializer.Serialize(data)); \\n    content.Headers.ContentType = new MediaTypeHeaderValue(\\\"application\", \"/json\\\"); \\n    HttpResponseMessage response = await httpClient.PostAsync(uri, content); \\n\\n    await H\", \"andleResponse(response); \\n    TResult result = await response.Content.ReadFromJsonAsync<TResult>(); \", \"\\n\\n    return result; \\n} \\n\\nThis method calls the GetOrCreateHttpClient method, which returns an insta\", \"nce of the HttpClient class \\nwith the appropriate headers set. It then submits an asynchronous POST \", \"request to the resource \\nidentified by the URI, with the serialized basket data being sent in JSON f\", \"ormat, and the response \\nbeing stored in the HttpResponseMessage instance. The HandleResponse method\", \" is then invoked, \\nwhich throws an exception if the response doesn\\u2019t include a success HTTP status c\", \"ode. Then, the \\nresponse is read as a string, converted from JSON to a CustomerBasket object, and re\", \"turned to the \\nBasketService. For more information about the GetOrCreateHttpClient method, see Makin\", \"g a GET \\nrequest. \\n\\nWhen the PostAsync method in the RequestProvider class calls HttpClient.PostAsyn\", \"c, the Post method \\nin the BasketController class in the Basket.API project is invoked, which is sho\", \"wn in the following code \\nexample: \\n\\n[HttpPost] \\npublic async Task<IActionResult> Post([FromBody] Cu\", \"stomerBasket value) \\n{ \\n    var basket = await _repository.UpdateBasketAsync(value); \\n    return Ok(\", \"basket); \\n}  \\n\\n66 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n \\n \\n     \\n\\fThis method uses an instance\", \" of the RedisBasketRepository class to persist the basket data to the \\nRedis cache, and returns it a\", \"s a response message that includes a success HTTP status code, and a \\nJSON formatted CustomerBasket \", \"instance. \\n\\nMaking a DELETE request \\n\\nThe image below shows the interactions of classes that delete \", \"basket data from the basket \\nmicroservice, for the CheckoutView. \\n\\nWhen the checkout process is invo\", \"ked, the CheckoutAsync method in the CheckoutViewModel class is \\ncalled. This method creates a new o\", \"rder, before clearing the shopping basket, as demonstrated in the \\nfollowing code example: \\n\\nprivate\", \" async Task CheckoutAsync() \\n{ \\n    // Omitted for brevity... \\n\\n    await _basketService.ClearBasket\", \"Async( \\n        _shippingAddress.Id.ToString(), authToken); \\n} \\n\\nThis method calls the ClearBasketAs\", \"ync method of the BasketService instance that was injected into \\nthe CheckoutViewModel by the depend\", \"ency injection container. The following method shows the \\nClearBasketAsync method: \\n\\npublic async Ta\", \"sk ClearBasketAsync(string guidUser, string token) \\n{ \\n    UriBuilder builder = new(GlobalSetting.In\", \"stance.BasketEndpoint); \\n    builder.Path = guidUser; \\n    string uri = builder.ToString(); \\n    awa\", \"it _requestProvider.DeleteAsync(uri, token); \\n} \\n\\n67 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n \\n \\n\", \"\\fThis method builds the URI that identifies the resource that the request will be sent to, and uses \", \"the \\nRequestProvider class to invoke the DELETE HTTP method on the resource. Note that an access tok\", \"en, \\nobtained from IdentityServer during the authentication process, is required to authorize reques\", \"ts to \\nthe basket microservice. For more information about authorization, see Authorization. \\n\\nThe f\", \"ollowing code example shows the DeleteAsync method in the RequestProvider class: \\n\\npublic async Task\", \" DeleteAsync(string uri, string token = \\\"\\\") \\n{ \\n    HttpClient httpClient = GetOrCreateHttpClient(to\", \"ken); \\n    await httpClient.DeleteAsync(uri); \\n} \\n\\nThis method calls the GetOrCreateHttpClient metho\", \"d, which returns an instance of the HttpClient class \\nwith the appropriate headers set. It then subm\", \"its an asynchronous DELETE request to the resource \\nidentified by the URI. For more information abou\", \"t the GetOrCreateHttpClient method, see Making a \\nGET request. \\n\\nWhen the DeleteAsync method in the \", \"RequestProvider class calls HttpClient.DeleteAsync, the Delete \\nmethod in the BasketController class\", \" in the Basket.API project is invoked, which is shown in the \\nfollowing code example: \\n\\n[HttpDelete(\", \"\\\"{id}\\\")] \\npublic void Delete(string id) => \\n    _repository.DeleteBasketAsync(id); \\n\\nThis method use\", \"s an instance of the RedisBasketRepository class to delete the basket data from the \\nRedis cache. \\n\\n\", \"Caching data \\n\\nThe performance of an app can be improved by caching frequently accessed data to fast\", \" storage \\nthat\\u2019s located close to the app. If the fast storage is located closer to the app than the\", \" original source, \\nthen caching can significantly improve response times when retrieving data. \\n\\nThe\", \" most common form of caching is read-through caching, where an app retrieves data by \\nreferencing th\", \"e cache. If the data isn\\u2019t in the cache, it\\u2019s retrieved from the data store and added to the \\ncache.\", \" Apps can implement read-through caching with the cache-aside pattern. This pattern \\ndetermines whet\", \"her the item is currently in the cache. If the item isn\\u2019t in the cache, it\\u2019s read from the \\ndata sto\", \"re and added to the cache. For more information, see the Cache-Aside pattern on Microsoft \\nDocs. \\n\\nT\", \"ip \\n\\nCache data that\\u2019s read frequently and changes infrequently. \\n\\nThis data can be added to the cac\", \"he on demand the first time it is retrieved by an app. This means \\nthat the app needs to fetch the d\", \"ata only once from the data store, and that subsequent access can \\nbe satisfied by using the cache. \", \"\\n\\n68 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n\\fDistributed applications, such as the eShop referen\", \"ce application, should provide either or both of the \\nfollowing caches: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nA shared cache, wh\", \"ich can be accessed by multiple processes or machines. \\n\\nA private cache, where data is held locally\", \" on the device running the app. \\n\\nThe eShop multi-platform app uses a private cache, where data is h\", \"eld locally on the device that\\u2019s \\nrunning an instance of the app. \\n\\nTip \\n\\nThink of the cache as a tr\", \"ansient data store that could disappear at any time. \\n\\nEnsure that data is maintained in the origina\", \"l data store as well as the cache. The chances of losing \\ndata are then minimized if the cache becom\", \"es unavailable. \\n\\nManaging data expiration \\n\\nIt\\u2019s impractical to expect that cached data will always\", \" be consistent with the original data. Data in the \\noriginal data store might change after it\\u2019s been\", \" cached, causing the cached data to become stale. \\nTherefore, apps should implement a strategy that \", \"helps to ensure that the data in the cache is as up-\\nto-date as possible, but can also detect and ha\", \"ndle situations that arise when the data in the cache \\nhas become stale. Most caching mechanisms ena\", \"ble the cache to be configured to expire data, and \\nhence reduce the period for which data might be \", \"out of date. \\n\\nTip \\n\\nSet a default expiration time when configuring a cache. \\n\\nMany caches implement\", \" expiration, which invalidates data and removes it from the cache if it\\u2019s not \\naccessed for a specif\", \"ied period. However, care must be taken when choosing the expiration period. If \\nit\\u2019s made too short\", \", data will expire too quickly and the benefits of caching will be reduced. If it\\u2019s \\nmade too long, \", \"the data risks becoming stale. Therefore, the expiration time should match the pattern \\nof access fo\", \"r apps that use the data. \\n\\nWhen cached data expires, it should be removed from the cache, and the a\", \"pp must retrieve the data \\nfrom the original data store and place it back into the cache. \\n\\nIt\\u2019s als\", \"o possible that a cache might fill up if data is allowed to remain for too long a period. Therefore,\", \" \\nrequests to add new items to the cache might be required to remove some items in a process known \\n\", \"as eviction. Caching services typically evict data on a least-recently-used basis. However, there ar\", \"e \\nother eviction policies, including most-recently-used, and first-in-first-out. For more informati\", \"on, see \\nCaching Guidance on Microsoft Docs. \\n\\nCaching images \\n\\nThe eShop multi-platform app consume\", \"s remote product images that benefit from being cached. \\nThese images are displayed by the Image con\", \"trol. The .NET MAUI Image control supports caching of \\n\\n69 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n\", \" \\n\\fdownloaded images which has caching enabled by default, and will store the image locally for 24 \\n\", \"hours. In addition, the expiration time can be configured with the CacheValidity property. For more \", \"\\ninformation, see Downloaded Image Caching on the Microsoft Developer Center. \\n\\nIncreasing resilienc\", \"e \\n\\nAll apps that communicate with remote services and resources must be sensitive to transient faul\", \"ts. \\nTransient faults include the momentary loss of network connectivity to services, the temporary \", \"\\nunavailability of a service, or timeouts that arise when a service is busy. These faults are often \", \"self-\\ncorrecting, and if the action is repeated after a suitable delay it\\u2019s likely to succeed. \\n\\nTra\", \"nsient faults can have a huge impact on the perceived quality of an app, even if it has been \\nthorou\", \"ghly tested under all foreseeable circumstances. To ensure that an app that communicates with \\nremot\", \"e services operates reliably, it must be able to do all of the following: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDetect fault\", \"s when they occur, and determine if the faults are likely to be transient. \\n\\nRetry the operation if \", \"it determines that the fault is likely to be transient and keep track of the \\nnumber of times the op\", \"eration was retried. \\n\\nUse an appropriate retry strategy, which specifies the number of retries, the\", \" delay between \\neach attempt, and the actions to take after a failed attempt. \\n\\nThis transient fault\", \" handling can be achieved by wrapping all attempts to access a remote service in \\ncode that implemen\", \"ts the retry pattern. \\n\\nRetry pattern \\n\\nIf an app detects a failure when it tries to send a request \", \"to a remote service, it can handle the failure \\nin any of the following ways: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nRetrying\", \" the operation. The app could retry the failing request immediately. \\n\\nRetrying the operation after \", \"a delay. The app should wait for a suitable amount of time before \\nretrying the request. \\n\\nCancellin\", \"g the operation. The application should cancel the operation and report an \\nexception. \\n\\nThe retry s\", \"trategy should be tuned to match the business requirements of the app. For example, it\\u2019s \\nimportant \", \"to optimize the retry count and retry interval to the operation being attempted. If the \\noperation i\", \"s part of a user interaction, the retry interval should be short and only a few retries \\nattempted t\", \"o avoid making users wait for a response. If the operation is part of a long running \\nworkflow, wher\", \"e cancelling or restarting the workflow is expensive or time-consuming, it\\u2019s appropriate \\nto wait lo\", \"nger between attempts and to retry more times. \\n\\nNote \\n\\nAn aggressive retry strategy with minimal de\", \"lay between attempts, and a large number of retries, \\ncould degrade a remote service that\\u2019s running \", \"close to or at capacity. In addition, such a retry strategy \\ncould also affect the responsiveness of\", \" the app if it\\u2019s continually trying to perform a failing operation. \\n\\n70 \\n\\nCHAPTER 10 | Accessing re\", \"mote data \\n\\n \\n \\n\\fIf a request still fails after a number of retries, it\\u2019s better for the app to prev\", \"ent further requests going \\nto the same resource and to report a failure. Then, after a set period, \", \"the app can make one or more \\nrequests to the resource to see if they\\u2019re successful. For more inform\", \"ation, see Circuit breaker pattern. \\n\\nTip \\n\\nNever implement an endless retry mechanism. Instead, pre\", \"fer an exponential backoff. \\n\\nUse a finite number of retries, or implement the Circuit Breaker patte\", \"rn to allow a service to recover. \\n\\nThe eShop reference application does implement the retry pattern\", \". \\n\\nFor more information about the retry pattern, see the Retry pattern on Microsoft Docs. \\n\\nCircuit\", \" breaker pattern \\n\\nIn some situations, faults can occur due to anticipated events that take longer t\", \"o fix. These faults can \\nrange from a partial loss of connectivity to the complete failure of a serv\", \"ice. In these situations, it\\u2019s \\npointless for an app to retry an operation that\\u2019s unlikely to succee\", \"d, and instead should accept that \\nthe operation has failed and handle this failure accordingly. \\n\\nT\", \"he circuit breaker pattern can prevent an app from repeatedly trying to execute an operation that\\u2019s \", \"\\nlikely to fail, while also enabling the app to detect whether the fault has been resolved. \\n\\nNote \\n\", \"\\nThe purpose of the circuit breaker pattern is different from the retry pattern. The retry pattern e\", \"nables \\nan app to retry an operation in the expectation that it\\u2019ll succeed. The circuit breaker patt\", \"ern prevents \\nan app from performing an operation that\\u2019s likely to fail. \\n\\nA circuit breaker acts as\", \" a proxy for operations that might fail. The proxy should monitor the number \\nof recent failures tha\", \"t have occurred, and use this information to decide whether to allow the \\noperation to proceed, or t\", \"o return an exception immediately. \\n\\nThe eShop multi-platform app does not currently implement the c\", \"ircuit breaker pattern. However, the \\neShop does. \\n\\nTip \\n\\nCombine the retry and circuit breaker patt\", \"erns. \\n\\nAn app can combine the retry and circuit breaker patterns by using the retry pattern to invo\", \"ke an \\noperation through a circuit breaker. However, the retry logic should be sensitive to any exce\", \"ptions \\nreturned by the circuit breaker and abandon retry attempts if the circuit breaker indicates \", \"that a fault \\nis not transient. \\n\\nFor more information about the circuit breaker pattern, see the Ci\", \"rcuit Breaker pattern on Microsoft \\nDocs. \\n\\n71 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n\\fSummary \\n\", \"\\nMany modern web-based solutions make use of web services, hosted by web servers, to provide \\nfuncti\", \"onality for remote client applications. The operations that a web service exposes constitute a \\nweb \", \"API, and client apps should be able to utilize the web API without knowing how the data or \\noperatio\", \"ns that the API exposes are implemented. \\n\\nThe performance of an app can be improved by caching freq\", \"uently accessed data to fast storage \\nthat\\u2019s located close to the app. Apps can implement read-throu\", \"gh caching with the cache-aside \\npattern. This pattern determines whether the item is currently in t\", \"he cache. If the item isn\\u2019t in the \\ncache, it\\u2019s read from the data store and added to the cache. \\n\\nW\", \"hen communicating with web APIs, apps must be sensitive to transient faults. Transient faults \\ninclu\", \"de the momentary loss of network connectivity to services, the temporary unavailability of a \\nservic\", \"e, or timeouts that arise when a service is busy. These faults are often self-correcting, and if the\", \" \\naction is repeated after a suitable delay, then it\\u2019s likely to succeed. Therefore, apps should wra\", \"p all \\nattempts to access a web API in code that implements a transient fault handling mechanism. \\n\\n\", \"72 \\n\\nCHAPTER 10 | Accessing remote data \\n\\n \\n \\n\\fCHAPTER  11 \\n\\nAuthentication and \\nauthorization \\n\\nAut\", \"hentication is the process of obtaining identification credentials such as name and password from \\na\", \" user and validating those credentials against an authority. The entity that submitted the credentia\", \"ls \\nis considered an authenticated identity if the credentials are valid. Once an identity has been \", \"\\nestablished, an authorization process determines whether that identity has access to a given resour\", \"ce. \\n\\nThere are many approaches to integrating authentication and authorization into a .NET MAUI app\", \" that \\ncommunicates with an ASP.NET web application, including using ASP.NET Core Identity, external\", \" \\nauthentication providers such as Microsoft, Google, Facebook, or Twitter, and authentication \\nmidd\", \"leware. The eShop multi-platform app performs authentication and authorization with a \\ncontainerized\", \" identity microservice that uses IdentityServer. The app requests security tokens from \\nIdentityServ\", \"er to authenticate a user or access a resource. For IdentityServer to issue tokens on behalf \\nof a u\", \"ser, the user must sign in to IdentityServer. However, IdentityServer doesn\\u2019t provide a user \\ninterf\", \"ace or database for authentication. Therefore, in the eShop reference application, ASP.NET Core \\nIde\", \"ntity is used for this purpose. \\n\\nAuthentication \\n\\nAuthentication is required when an application ne\", \"eds to know the current user\\u2019s identity. ASP.NET \\nCore\\u2019s primary mechanism for identifying users is \", \"the ASP.NET Core Identity membership system, \\nwhich stores user information in a data store configur\", \"ed by the developer. Typically, this data store \\nwill be an EntityFramework store, though custom sto\", \"res or third-party packages can be used to store \\nidentity information in Azure storage, DocumentDB,\", \" or other locations. \\n\\nFor authentication scenarios that use a local user datastore and persist iden\", \"tity information between \\nrequests via cookies (as is typical in ASP.NET web applications), ASP.NET \", \"Core Identity is a suitable \\nsolution. However, cookies are not always a natural means of persisting\", \" and transmitting data. For \\nexample, an ASP.NET Core web application that exposes RESTful endpoints\", \" that are accessed from an \\napp will typically need to use bearer token authentication since cookies\", \" can\\u2019t be used in this scenario. \\nHowever, bearer tokens can easily be retrieved and included in the\", \" authorization header of web \\nrequests made from the app. \\n\\n73 \\n\\nCHAPTER 11 | Authentication and aut\", \"horization \\n\\n \\n \\n\\fIssuing bearer tokens using IdentityServer \\n\\nIdentityServer is an open-source Open\", \"ID Connect and OAuth 2.0 framework for ASP.NET Core, which \\ncan be used for many authentication and \", \"authorization scenarios, including issuing security tokens for \\nlocal ASP.NET Core Identity users. \\n\", \"\\nNote \\n\\nOpenID Connect and OAuth 2.0 are very similar, while having different responsibilities. \\n\\nOp\", \"enID Connect is an authentication layer on top of the OAuth 2.0 protocol. OAuth 2 is a protocol \\ntha\", \"t allows applications to request access tokens from a security token service and use them to \\ncommun\", \"icate with APIs. This delegation reduces complexity in both client applications and APIs since \\nauth\", \"entication and authorization can be centralized. \\n\\nOpenID Connect and OAuth 2.0 combine the two fund\", \"amental security concerns of authentication \\nand API access, and IdentityServer is an implementation\", \" of these protocols. \\n\\nIn applications that use direct client-to-microservice communication, such as\", \" the eShop reference \\napplication, a dedicated authentication microservice acting as a Security Toke\", \"n Service (STS) can be \\nused to authenticate users, as shown in the following diagram. For more info\", \"rmation about direct \\nclient-to-microservice communication, see Microservices. \\n\\nThe eShop multi-pla\", \"tform app communicates with the identity microservice, which uses IdentityServer \\nto perform authent\", \"ication, and access control for APIs. Therefore, the multi-platform app requests \\ntokens from Identi\", \"tyServer, either for authenticating a user or for accessing a resource: \\n\\nAuthenticating users with \", \"IdentityServer is achieved by the multi-platform app requesting an \\nidentity token, representing an \", \"authentication process\\u2019s outcome. At a minimum, it contains \\nan identifier for the user and informat\", \"ion about how and when the user is authenticated. It \\ncan also include additional identity data. \\n\\nA\", \"ccessing a resource with IdentityServer is achieved by the multi-platform app requesting an \\naccess \", \"token, which allows access to an API resource. Clients request access tokens and \\nforward them to th\", \"e API. Access tokens contain information about the client and the user, if \\npresent. APIs then use t\", \"hat information to authorize access to their data. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nNote \\n\\nA client must be registered with\", \" IdentityServer before it can successfully request tokens. For more \\ninformation on adding clients, \", \"see Defining Clients. \\n\\n74 \\n\\nCHAPTER 11 | Authentication and authorization \\n\\n \\n \\n \\n\\fAdding IdentityS\", \"erver to a web application \\n\\nIn order for an ASP.NET Core web application to use IdentityServer, it \", \"must be added to the web \\napplication\\u2019s Visual Studio solution. For more information, see Setup and \", \"Overview in the \\nIdentityServer documentation. Once IdentityServer is included in the web applicatio\", \"n\\u2019s Visual Studio \\nsolution, it must be added to its HTTP request processing pipeline to serve reque\", \"sts to OpenID \\nConnect and OAuth 2.0 endpoints. This is configured in the Identity.API project\\u2019s Pro\", \"gram.cs, as \\ndemonstrated in the following code example: \\n\\n... \\n\\napp.UseIdentityServer(); \\n\\nOrder ma\", \"tters in the web application\\u2019s HTTP request processing pipeline. Therefore, IdentityServer \\nmust be \", \"added to the pipeline before the UI framework that implements the login screen. \\n\\nConfiguring Identi\", \"tyServer \\n\\nIdentityServer should be configured in the ConfigureServices method in the web applicatio\", \"n\\u2019s Startup \\nclass by calling the services.AddIdentityServer method, as demonstrated in the followin\", \"g code \\nexample from the eShop reference application: \\n\\npublic void ConfigureServices(IServiceCollec\", \"tion services) \\n{ \\n    services \\n        .AddIdentityServer(x => x.IssuerUri = \\\"null\\\") \\n        .Add\", \"SigningCredential(Certificate.Get()) \\n        .AddAspNetIdentity<ApplicationUser>() \\n        .AddCon\", \"figurationStore(builder => \\n            builder.UseSqlServer(connectionString, options => \\n         \", \"       options.MigrationsAssembly(migrationsAssembly))) \\n        .AddOperationalStore(builder => \\n  \", \"          builder.UseSqlServer(connectionString, options => \\n                options.MigrationsAssem\", \"bly(migrationsAssembly))) \\n        .Services.AddTransient<IProfileService, ProfileService>(); \\n} \\n\\nA\", \"fter calling the services.AddIdentityServer method, additional fluent APIs are called to configure t\", \"he \\nfollowing: \\n\\nCredentials used for signing. \\n\\nAPI and identity resources that users might request\", \" access to. \\n\\nClients that will be connecting to request tokens. \\n\\nASP.NET Core Identity. \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\", \"\\u2022 \\n\\n\\u2022 \\n\\nTip \\n\\nDynamically load the IdentityServer configuration. IdentityServer\\u2019s APIs allow for con\", \"figuring \\nIdentityServer from an in-memory list of configuration objects. In the eShop reference app\", \"lication, \\nthese in-memory collections are hard-coded into the application. However, in production s\", \"cenarios \\nthey can be loaded dynamically from a configuration file or from a database. \\n\\n75 \\n\\nCHAPTE\", \"R 11 | Authentication and authorization \\n\\n \\n \\n \\n \\n\\fFor information about configuring IdentityServer \", \"to use ASP.NET Core Identity, see Using ASP.NET \\nCore Identity in the IdentityServer documentation. \", \"\\n\\nConfiguring API resources \\n\\nWhen configuring API resources, the AddInMemoryApiResources method exp\", \"ects an \\nIEnumerable<ApiResource> collection. The following code example shows the GetApis method th\", \"at \\nprovides this collection in the eShop reference application: \\n\\npublic static IEnumerable<ApiReso\", \"urce> GetApis() \\n{ \\n    return new List<ApiResource> \\n    { \\n        new ApiScope(\\\"orders\\\", \\\"Orders \", \"Service\\\"), \\n        new ApiScope(\\\"basket\\\", \\\"Basket Service\\\"), \\n        new ApiScope(\\\"webhooks\\\", \\\"Web\", \"hooks registration Service\\\"), \\n    }; \\n} \\n\\nThis method specifies that IdentityServer should protect \", \"the orders and basket APIs. Therefore, \\nIdentityServer-managed access tokens will be required when m\", \"aking calls to these APIs. For more \\ninformation about the ApiResource type, see API Resource in the\", \" IdentityServer documentation. \\n\\nConfiguring identity resources \\n\\nWhen configuring identity resource\", \"s, the AddInMemoryIdentityResources method expects an \\nIEnumerable<IdentityResource> collection. Ide\", \"ntity resources are data such as user ID, name, or email \\naddress. Each identity resource has a uniq\", \"ue name, and arbitrary claim types can be assigned to it, \\nwhich will be included in the identity to\", \"ken for the user. The following code example shows the \\nGetResources method that provides this colle\", \"ction in the eShop reference application: \\n\\npublic static IEnumerable<IdentityResource> GetResources\", \"() \\n{ \\n    return new List<IdentityResource> \\n    { \\n        new IdentityResources.OpenId(), \\n      \", \"  new IdentityResources.Profile() \\n    }; \\n} \\n\\nThe OpenID Connect specification specifies some stand\", \"ard identity resources. The minimum \\nrequirement is that support is provided for emitting a unique I\", \"D for users. This is achieved by \\nexposing the IdentityResources.OpenId identity resource. \\n\\nNote \\n\\n\", \"The IdentityResources class supports all of the scopes defined in the OpenID Connect specification \\n\", \"(openid, email, profile, telephone, and address). \\n\\nIdentityServer also supports defining custom ide\", \"ntity resources. For more information, see Defining \\ncustom identity resources in the IdentityServer\", \" documentation. For more information about the \\nIdentityResource type, see Identity Resource in the \", \"IdentityServer documentation. \\n\\n76 \\n\\nCHAPTER 11 | Authentication and authorization \\n\\n \\n \\n\\fConfigurin\", \"g clients \\n\\nClients are applications that can request tokens from IdentityServer. Typically, the fol\", \"lowing settings \\nmust be defined for each client as a minimum: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nA unique client ID.\", \" \\n\\nThe allowed interactions with the token service (known as the grant type). \\n\\nThe location where i\", \"dentity and access tokens are sent to (known as a redirect URI). \\n\\nA list of resources that the clie\", \"nt is allowed access to (known as scopes). \\n\\nWhen configuring clients, the AddInMemoryClients method\", \" expects an IEnumerable<Client> \\ncollection. The following code example shows the configuration for \", \"the eShop multi-platform app in \\nthe GetClients method that provides this collection in the eShop re\", \"ference application: \\n\\npublic static IEnumerable<Client> GetClients(Dictionary<string,string> client\", \"sUrl) \\n{ \\n    return new List<Client> \\n    { \\n        // Omitted for brevity \\n        new Client \\n  \", \"      { \\n            ClientId = \\\"maui\\\", \\n            ClientName = \\\"eShop .NET MAUI OpenId Client\\\", \\n\", \"            AllowedGrantTypes = GrantTypes.Hybrid, \\n            ClientSecrets = \\n            { \\n    \", \"            new Secret(\\\"secret\\\".Sha256()) \\n            }, \\n            RedirectUris = { clientsUrl[\\\"\", \"maui\\\"] }, \\n            RequireConsent = false, \\n            RequirePkce = true, \\n            PostLog\", \"outRedirectUris = { $\\\"{clientsUrl[\\\"maui\\\"]}/Account/Redirecting\\\" }, \\n            AllowedCorsOrigins =\", \" { \\\"http://eshopmaui\\\" }, \\n            AllowedScopes = new List<string> \\n            { \\n             \", \"   IdentityServerConstants.StandardScopes.OpenId, \\n                IdentityServerConstants.StandardS\", \"copes.Profile, \\n                IdentityServerConstants.StandardScopes.OfflineAccess, \\n             \", \"   \\\"orders\\\", \\n                \\\"basket\\\" \\n            }, \\n            AllowOfflineAccess = true, \\n    \", \"        AllowAccessTokensViaBrowser = true, \\n            AccessTokenLifetime = 60 * 60 * 2, // 2 hou\", \"rs \\n            IdentityTokenLifetime = 60 * 60 * 2 // 2 hours \\n        } \\n    }; \\n} \\n\\nThis configur\", \"ation specifies data for the following properties: \\n\\nProperty \\n\\nDescription \\n\\nClientId \\n\\nClientName \", \"\\n\\nA unique ID for the client. \\n\\nThe client display name, which is used for \\nlogging and the consent \", \"screen. \\n\\n77 \\n\\nCHAPTER 11 | Authentication and authorization \\n\\n \\n \\n\\fProperty \\n\\nDescription \\n\\nAllowed\", \"GrantTypes \\n\\nClientSecrets \\n\\nRedirectUris \\n\\nRequireConsent \\n\\nRequirePkce \\n\\nPostLogoutRedirectUris \\n\\n\", \"AllowedCorsOrigins \\n\\nAllowedScopes \\n\\nAllowOfflineAccess \\n\\nAllowAccessTokensViaBrowser \\n\\nAlwaysInclud\", \"eUserClaimsInIdToken \\n\\nAccessTokenLifetime \\n\\nIdentityTokenLifetime \\n\\nSpecifies how a client wants to\", \" interact with \\nIdentityServer. For more information see \\nConfiguring the authentication flow. \\n\\nSpe\", \"cifies the client secret credentials that are \\nused when requesting tokens from the token \\nendpoint.\", \" \\n\\nSpecifies the allowed URIs to which to return \\ntokens or authorization codes. \\n\\nSpecifies whether\", \" a consent screen is required. \\n\\nSpecifies whether clients using an authorization \\ncode must send a \", \"proof key. \\n\\nSpecifies the allowed URIs to redirect to after \\nlogout. \\n\\nSpecifies the origin of the \", \"client so that \\nIdentityServer can allow cross-origin calls from \\nthe origin. \\n\\nSpecifies the resour\", \"ces the client has access to. \\nBy default, a client has no access to any \\nresources. \\n\\nSpecifies whe\", \"ther the client can request refresh \\ntokens. \\n\\nSpecifies whether the client can receive access \\ntoke\", \"ns from a browser window. \\n\\nSpecifies that the user claims will always be \\nadded to the id token. By\", \" default, these would \\nhave to be retrieved using the userinfo \\nendpoint. \\n\\nSpecifies the lifetime o\", \"f the access token in \\nseconds. \\n\\nSpecifies the lifetime of the identity token in \\nseconds. \\n\\nConfig\", \"uring the authentication flow \\n\\nThe authentication flow between a client and IdentityServer can be c\", \"onfigured by specifying the grant \\ntypes in the Client.AllowedGrantTypes property. The OpenID Connec\", \"t and OAuth 2.0 specifications \\ndefine several authentication flows, including: \\n\\n78 \\n\\nCHAPTER 11 | \", \"Authentication and authorization \\n\\n \\n \\n\\fAuthentication Flow \\n\\nDescription \\n\\nImplicit \\n\\nAuthorization\", \" code \\n\\nHybrid \\n\\nTip \\n\\nThis flow is optimized for browser-based \\napplications and should be used eit\", \"her for user \\nauthentication-only, or authentication and \\naccess token requests. All tokens are \\ntra\", \"nsmitted via the browser, and therefore \\nadvanced features like refresh tokens are not \\npermitted. \\n\", \"\\nThis flow provides the ability to retrieve tokens \\non a back channel, as opposed to the browser \\nfr\", \"ont channel, while also supporting client \\nauthentication. \\n\\nThis flow is a combination of the impli\", \"cit and \\nauthorization code grant types. The identity \\ntoken is transmitted via the browser channel \", \"\\nand contains the signed protocol response and \\nother artifacts such as the authorization code. \\nAft\", \"er successfully validating the response, the \\nback channel should be used to retrieve the \\naccess an\", \"d refresh token. \\n\\nConsider using the hybrid authentication flow. The hybrid authentication flow mit\", \"igates a number of \\nattacks that apply to the browser channel, and is the recommended flow for nativ\", \"e applications that \\nwant to retrieve access tokens (and possibly refresh tokens). \\n\\nFor more inform\", \"ation about authentication flows, see Grant Types in the IdentityServer \\ndocumentation. \\n\\nPerforming\", \" authentication \\n\\nFor IdentityServer to issue tokens on behalf of a user, the user must sign in to I\", \"dentityServer. However, \\nIdentityServer doesn\\u2019t provide a user interface or database for authenticat\", \"ion. Therefore, in the eShop \\nreference application, ASP.NET Core Identity is used for this purpose.\", \" \\n\\nThe eShop multi-platform app authenticates with IdentityServer with the hybrid authentication flo\", \"w, \\nwhich is illustrated in the diagram below. \\n\\n79 \\n\\nCHAPTER 11 | Authentication and authorization \", \"\\n\\n \\n \\n\\fA sign in request is made to <base endpoint>:5105/connect/authorize. Following successful \\nau\", \"thentication, IdentityServer returns an authentication response containing an authorization code \\nan\", \"d an identity token. The authorization code is sent to <base endpoint>:5105/connect/token, which \\nre\", \"sponds with access, identity, and refresh tokens. \\n\\nThe eShop multi-platform app signs out of Identi\", \"tyServer by sending a request to <base \\nendpoint>:5105/connect/endsession with additional parameters\", \". After sign-out, IdentityServer \\nresponds by sending a post-logout redirecting URI back to the mult\", \"i-platform app. The diagram \\nbelow illustrates this process. \\n\\nIn the eShop multi-platform app, comm\", \"unication with IdentityServer is performed by the \\nIdentityService class, which implements the IIden\", \"tityService interface. This interface specifies that the \\nimplementing class must provide SignInAsyn\", \"c, SignOutAsync, GetUserInfoAsync and \\nGetAuthTokenAsync methods. \\n\\nSigning-in \\n\\nWhen the user taps \", \"the LOGIN button on the LoginView, the SignInCommand in the LoginViewModel \\nclass is executed, which\", \" in turn executes the SignInAsync method. The following code example shows \\nthis method: \\n\\n[RelayCom\", \"mand] \\nprivate async Task SignInAsync() \\n{ \\n    await IsBusyFor( \\n        async () => \\n        { \\n  \", \"          var loginSuccess = await _appEnvironmentService.IdentityService.SignInAsync(); \\n\\n         \", \"   if (loginSuccess) \\n            { \\n                await NavigationService.NavigateToAsync(\\\"//Main\", \"/Catalog\\\"); \\n            } \\n\\n80 \\n\\nCHAPTER 11 | Authentication and authorization \\n\\n \\n \\n \\n \\n \\n\\f       \", \" }); \\n} \\n\\nThis method invokes the SignInAsync method in the IdentityService class, as shown in the f\", \"ollowing \\ncode example: \\n\\npublic async Task<bool> SignInAsync() \\n{ \\n    var response = await GetClie\", \"nt().LoginAsync(new LoginRequest()).ConfigureAwait(false); \\n\\n    if (response.IsError) \\n    { \\n     \", \"   return false; \\n    } \\n\\n    await _settingsService \\n        .SetUserTokenAsync( \\n            new U\", \"serToken \\n            { \\n                AccessToken = response.AccessToken, \\n                IdToke\", \"n = response.IdentityToken, \\n                RefreshToken = response.RefreshToken, \\n                \", \"ExpiresAt = response.AccessTokenExpiration \\n            }) \\n        .ConfigureAwait(false); \\n\\n    re\", \"turn !response.IsError; \\n} \\n\\nThe IdentityService makes use of the OidcClient provided with the Ident\", \"ityModel.OidcClient NuGet \\npackage. This client displays the authentication web view to the user in \", \"the application and captures \\nthe authentication result. The client connects to the URI for Identity\", \"Server\\u2019s authorization endpoint \\nwith the required parameters. The authorization endpoint is at /con\", \"nect/authorize on port 5105 of the \\nbase endpoint exposed as a user setting. For more information ab\", \"out user settings, see Configuration \\nManagement. \\n\\nNote \\n\\nThe attack surface of the eShop multi-pla\", \"tform app is reduced by implementing the Proof Key for \\nCode Exchange (PKCE) extension to OAuth. PKC\", \"E protects the authorization code from being used if \\nit\\u2019s intercepted. This is achieved by the clie\", \"nt generating a secret verifier, a hash of which is passed in \\nthe authorization request, and which \", \"is presented unhashed when redeeming the authorization code. \\nFor more information about PKCE, see P\", \"roof Key for Code Exchange by OAuth Public Clients on the \\nInternet Engineering Task Force web site.\", \" \\n\\n81 \\n\\nCHAPTER 11 | Authentication and authorization \\n\\n \\n \\n \\n \\n \\n\\fIf the token endpoint receives va\", \"lid authentication information, authorization code, and PKCE secret \\nverifier, it responds with an a\", \"ccess token, identity token, and refresh token. The access token (which \\nallows access to API resour\", \"ces) and identity token are stored as application settings, and page \\nnavigation is performed. There\", \"fore, the overall effect in the eShop multi-platform app is this: provided \\nthat users are able to s\", \"uccessfully authenticate with IdentityServer, they are navigated to the \\n//Main/Catalog route, which\", \" is a TabbedPage that displays the CatalogView as its selected tab. \\n\\n82 \\n\\nCHAPTER 11 | Authenticati\", \"on and authorization \\n\\n \\n \\n \\n\\fFor information about page navigation, see Navigation. For information\", \" about how WebView \\nnavigation causes a view model method to be executed, see Invoking navigation us\", \"ing behaviors. For \\ninformation about application settings, see Configuration management. \\n\\nNote \\n\\nT\", \"he eShop also allows a mock sign in when the app is configured to use mock services in the \\nSettings\", \"View. In this mode, the app doesn\\u2019t communicate with IdentityServer, instead allowing the \\nuser to s\", \"ign in using any credentials. \\n\\nSigning-out \\n\\nWhen the user taps the LOG OUT button in the ProfileVi\", \"ew, the LogoutCommand in the \\nProfileViewModel class is executed, which executes the LogoutAsync met\", \"hod. This method performs \\npage navigation to the LoginView page, passing a Logout query parameter s\", \"et to true. \\n\\nThat parameter is evaluated in the ApplyQueryAttributes method. If the Logout paramete\", \"r is present \\nwith a true value, the PerformLogoutAsync method of the LoginViewModel class is execut\", \"ed, which is \\nshown in the following code example: \\n\\nprivate async Task PerformLogoutAsync() \\n{ \\n   \", \" await _appEnvironmentService.IdentityService.SignOutAsync(); \\n\\n    _settingsService.UseFakeLocation\", \" = false; \\n\\n    UserName.Value = string.Empty; \\n    Password.Value = string.Empty; \\n} \\n\\nThis method \", \"invokes the SignOutAsync method in the IdentityService class, which invokes the \\nOidcClient to end t\", \"he user\\u2019s session and clears any saved user tokens. For more information about \\napplication settings\", \", see Configuration management. The following code example shows the \\nSignOutAsync method: \\n\\npublic \", \"async Task<bool> SignOutAsync() \\n{ \\n    var response = await GetClient().LogoutAsync(new \\nLogoutRequ\", \"est()).ConfigureAwait(false); \\n\\n    if (response.IsError) \\n    { \\n        return false; \\n    } \\n\\n   \", \" await _settingsService.SetUserTokenAsync(default); \\n\\n    return !response.IsError; \\n} \\n\\nThis method\", \" uses the OidcClient to call the URI to IdentityServer\\u2019s end session endpoint with the \\nrequired par\", \"ameters. The end session endpoint is at /connect/endsession on port 5105 of the base \\nendpoint expos\", \"ed as a user setting. Once the user has successfully signed out, LoginView is presented \\nto the user\", \", and any saved user information will be cleared. \\n\\n83 \\n\\nCHAPTER 11 | Authentication and authorizati\", \"on \\n\\n \\n \\n \\n \\n \\n \\n \\n\\fFor information about page navigation, see Navigation. For information about how\", \" WebView \\nnavigation causes a view model method to be executed, see Invoking navigation using behavi\", \"ors. For \\ninformation about application settings, see Configuration management. \\n\\nNote \\n\\nThe eShop a\", \"lso allows a mock sign-out when the app is configured to use mock services in the \\nSettingsView. In \", \"this mode, the app doesn\\u2019t communicate with IdentityServer, and instead clears any \\nstored tokens fr\", \"om application settings. \\n\\nAuthorization \\n\\nAfter authentication, ASP.NET Core web APIs often need to\", \" authorize access, which allows a service to \\nmake APIs available to some authenticated users but no\", \"t to all. \\n\\nRestricting access to an ASP.NET Core route can be achieved by applying an Authorize att\", \"ribute to a \\ncontroller or action, which limits access to the controller or action to authenticated \", \"users, as shown in \\nthe following code example: \\n\\n[Authorize] \\npublic sealed class BasketController \", \": Controller \\n{ \\n    // Omitted for brevity \\n} \\n\\nIf an unauthorized user attempts to access a contro\", \"ller or action marked with the Authorize attribute, \\nthe API framework returns a 401 (unauthorized) \", \"HTTP status code. \\n\\nNote \\n\\nParameters can be specified on the Authorize attribute to restrict an API\", \" to specific users. For more \\ninformation, see ASP.NET Core Docs: Authorization. \\n\\nIdentityServer ca\", \"n be integrated into the authorization workflow so that the access tokens provide \\ncontrol authoriza\", \"tion. This approach is shown in the diagram below. \\n\\n84 \\n\\nCHAPTER 11 | Authentication and authorizat\", \"ion \\n\\n \\n \\n\\fThe eShop multi-platform app communicates with the identity microservice and requests an \", \"access \\ntoken as part of the authentication process. The access token is then forwarded to the APIs \", \"exposed \\nby the ordering and basket microservices as part of the access requests. Access tokens cont\", \"ain \\ninformation about the client and the user. APIs then use that information to authorize access t\", \"o their \\ndata. For information about how to configure IdentityServer to protect APIs, see Configurin\", \"g API \\nresources. \\n\\nConfiguring IdentityServer to perform authorization \\n\\nTo perform authorization w\", \"ith IdentityServer, its authorization middleware must be added to the web \\napplication\\u2019s HTTP reques\", \"t pipeline. The middleware is added in the AddDefaultAuthentication \\nextension method, which is invo\", \"ked from the AddApplicationServices method in the Program class \\nand is demonstrated in the followin\", \"g code example from the eShop reference application: \\n\\npublic static IServiceCollection AddDefaultAu\", \"thentication(this IHostApplicationBuilder \\nbuilder) \\n{ \\n    var services = builder.Services; \\n    va\", \"r configuration = builder.Configuration; \\n\\n    var identitySection = configuration.GetSection(\\\"Ident\", \"ity\\\"); \\n\\n    if (!identitySection.Exists()) \\n    { \\n        // No identity section, so no authentica\", \"tion \\n        return services; \\n    } \\n\\n    // prevent from mapping \\\"sub\\\" claim to nameidentifier. \\n\", \"    JsonWebTokenHandler.DefaultInboundClaimTypeMap.Remove(\\\"sub\\\"); \\n\\n    services.AddAuthentication()\", \".AddJwtBearer(options => \\n    { \\n\\n85 \\n\\nCHAPTER 11 | Authentication and authorization \\n\\n \\n \\n \\n \\n \\n \\n \", \"\\n\\f        var identityUrl = identitySection.GetRequiredValue(\\\"Url\\\"); \\n        var audience = identit\", \"ySection.GetRequiredValue(\\\"Audience\\\"); \\n\\n        options.Authority = identityUrl; \\n        options.R\", \"equireHttpsMetadata = false; \\n        options.Audience = audience; \\n        options.TokenValidationP\", \"arameters.ValidIssuers = [identityUrl]; \\n        options.TokenValidationParameters.ValidateAudience \", \"= false; \\n    }); \\n\\n    services.AddAuthorization(); \\n\\n    return services; \\n} \\n\\nThis method ensures\", \" that the API can only be accessed with a valid access token. The middleware \\nvalidates the incoming\", \" token to ensure that it\\u2019s sent from a trusted issuer and validates that the token \\nis valid to be u\", \"sed with the API that receives it. Therefore, browsing to the ordering or basket \\ncontroller will re\", \"turn a 401 (unauthorized) HTTP status code, indicating that an access token is \\nrequired. \\n\\nMaking a\", \"ccess requests to APIs \\n\\nWhen making requests to the ordering and basket microservices, the access t\", \"oken obtained from \\nIdentityServer during the authentication process must be included in the request\", \", as shown in the \\nfollowing code example: \\n\\npublic async Task CreateOrderAsync(Models.Orders.Order \", \"newOrder) \\n{ \\n    var authToken = await _identityService.GetAuthTokenAsync().ConfigureAwait(false); \", \"\\n\\n    if (string.IsNullOrEmpty(authToken)) \\n    { \\n        return; \\n    } \\n\\n    var uri = $\\\"{UriHelp\", \"er.CombineUri(_settingsService.GatewayOrdersEndpointBase, \\nApiUrlBase)}?api-version=1.0\\\"; \\n\\n    var \", \"success = await _requestProvider.PostAsync(uri, newOrder, authToken, \\\"x-\\nrequestid\\\").ConfigureAwait(\", \"false); \\n} \\n\\nThe access token is stored with the IIdentityService implementation and can be retrieve\", \"d using the \\nGetAuthTokenAsync method. \\n\\nSimilarly, the access token must be included when sending d\", \"ata to an IdentityServer protected API, as \\nshown in the following code example: \\n\\npublic async Task\", \" ClearBasketAsync() \\n{ \\n    var authToken = await _identityService.GetAuthTokenAsync().ConfigureAwai\", \"t(false); \\n\\n    if (string.IsNullOrEmpty(authToken)) \\n    { \\n        return; \\n\\n86 \\n\\nCHAPTER 11 | Aut\", \"hentication and authorization \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\f    } \\n\\n    await GetBasketClient().DeleteBasketA\", \"sync(new DeleteBasketRequest(), \\nCreateAuthenticationHeaders(authToken)) \\n        .ConfigureAwait(fa\", \"lse); \\n} \\n\\nThe access token is retrieved from the IIdentityService and included in the call to the C\", \"learBasketAsync \\nmethod in the BasketService class. \\n\\nThe RequestProvider class in the eShop multi-p\", \"latform app uses the HttpClient class to make requests \\nto the RESTful APIs exposed by the eShop ref\", \"erence application. When making requests to the \\nordering and basket APIs, which require authorizati\", \"on, a valid access token must be included with the \\nrequest. This is achieved by adding the access t\", \"oken to the headers of the HttpClient instance, as \\ndemonstrated in the following code example: \\n\\nht\", \"tpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\\\"Bearer\\\", to\\nken); \\n\\nTh\", \"e DefaultRequestHeaders property of the HttpClient class exposes the headers that are sent with \\neac\", \"h request, and the access token is added to the Authorization header prefixed with the string \\nBeare\", \"r. When the request is sent to a RESTful API, the value of the Authorization header is extracted \\nan\", \"d validated to ensure that it\\u2019s sent from a trusted issuer and used to determine whether the user \\nh\", \"as permission to invoke the API that receives it. \\n\\nFor more information about how the eShop multi-p\", \"latform app makes web requests, see Accessing \\nremote data. \\n\\nSummary \\n\\nThere are many approaches to\", \" integrating authentication and authorization into a .NET MAUI app that \\ncommunicates with an ASP.NE\", \"T web application. The eShop multi-platform app performs \\nauthentication and authorization with a co\", \"ntainerized identity microservice that uses IdentityServer. \\nIdentityServer is an open-source OpenID\", \" Connect and OAuth 2.0 framework for ASP.NET Core that \\nintegrates with ASP.NET Core Identity to per\", \"form bearer token authentication. \\n\\nThe multi-platform app requests security tokens from IdentitySer\", \"ver to authenticate a user or access a \\nresource. When accessing a resource, an access token must be\", \" included in the request to APIs that \\nrequire authorization. IdentityServer\\u2019s middleware validates \", \"incoming access tokens to ensure that \\nthey are sent from a trusted issuer and that they are valid t\", \"o be used with the API that receives them. \\n\\n87 \\n\\nCHAPTER 11 | Authentication and authorization \\n\\n \\n\", \" \\n \\n\\fCHAPTER  12 \\n\\nMVVM Toolkit Features \\n\\nMVVM Toolkit \\n\\nThe Model-View-ViewModel (MVVM) pattern is\", \" a great structural basis for creating our applications. \\nIn this pattern, the ViewModel becomes the\", \" backbone of our application as it provides \\ncommunication to our front-end user interface and backi\", \"ng components. To provide integration with \\nthe user interface, we will rely on the ViewModel\\u2019s prop\", \"erties and commands. As detailed in Updating \\nviews in response to changes in the underlying view mo\", \"del or model, the INotifyPropertyChanged \\ninterface on our ViewModel to allows changes to our proper\", \"ties to notify when the value is changed. \\nImplementing all of these features means that our ViewMod\", \"el can end up becoming very verbose. For \\nexample, the following code shows a simple ViewModel with \", \"properties that raise changes: \\n\\npublic class SampleViewModel : INotifyPropertyChanged \\n{ \\n    priva\", \"te string _name; \\n    private int _value; \\n\\n    public event PropertyChangedEventHandler PropertyCha\", \"nged; \\n\\n    public string Name \\n    { \\n        get => _name; \\n        set => SetPropertyValue(ref _n\", \"ame, value); \\n    } \\n\\n    public int Value \\n    { \\n        get => _value; \\n        set => SetPropert\", \"yValue(ref _value, value); \\n    } \\n\\n    protected void SetPropertyValue<T>(ref T storageField, T new\", \"Value, [CallerMemberName] \\nstring propertyName = \\\"\\\") \\n    { \\n        if (Equals(storageField, newVal\", \"ue)) \\n            return; \\n\\n        storageField = newValue; \\n        RaisePropertyChanged(propertyN\", \"ame); \\n    } \\n\\n    protected virtual void RaisePropertyChanged([CallerMemberName] string propertyNam\", \"e = \\n\\\"\\\") \\n    { \\n        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); \", \"\\n    } \\n} \\n\\n88 \\n\\nCHAPTER 12 | MVVM Toolkit Features \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n\\fWhile some optimizations coul\", \"d be made over time, we will still end up with a fairly verbose set of \\ncode for defining our ViewMo\", \"del. This code can be difficult to maintain and becomes error-prone. \\n\\nThe CommunityToolkit.Mvvm NuG\", \"et Package (aka MVVM Toolkit) can be used to help address and \\nsimplify these common MVVM patterns. \", \"The MVVM Toolkit, along with newer features to the .NET \\nlanguage, allows for simplified logic, easy\", \" adoption into a project, and runtime independence. The \\nexample below shows the same ViewModel usin\", \"g components that come with the MVVM Toolkit: \\n\\npublic partial class SampleViewModel : ObservableObj\", \"ect \\n{ \\n    [ObservableProperty] \\n    private string _name; \\n\\n    [ObservableProperty] \\n    private \", \"int _value; \\n} \\n\\nNote \\n\\nThe MVVM Toolkit is provided with the CommunityToolkit.Mvvm package. For inf\", \"ormation on how to \\nadd the package to your project, see Introduction to the MVVM Toolkit on the Mic\", \"rosoft Developer \\nCenter. \\n\\nIn comparison to the original example, we were able to drastically reduc\", \"e the overall complexity and \\nsimplify the maintainability of our ViewModel. The MVVM Toolkit comes \", \"with many pre-built common \\ncomponents and features, such as the ObservableObject shown above, that \", \"simplifies and \\nstandardizes the code that we have throughout the application. \\n\\nObservableObject \\n\\n\", \"The MVVM Toolkit provides ObservableObject which is intended for use as the base of our \\nViewModel o\", \"bjects or any object that needs to raise change notifications. It implements \\nINotifyPropertyChanged\", \" and INotifyPropertyChanging along with helper methods for setting \\nproperties and raising changes. \", \"Below is an example of a standard ViewModel using \\nObservableObject: \\n\\npublic class SampleViewModel \", \": ObservableObject \\n{ \\n    private string _name; \\n    private int _value; \\n\\n    public string Name \\n\", \"    { \\n        get => _name; \\n        set => SetProperty(ref _name, value); \\n    } \\n\\n    public int \", \"Value \\n    { \\n        get => _value; \\n        set => SetProperty(ref _value, value); \\n\\n89 \\n\\nCHAPTER \", \"12 | MVVM Toolkit Features \\n\\n \\n \\n \\n \\n \\n \\n \\n\\f    } \\n} \\n\\nObservableObject handles all of the logic nee\", \"ded for raising change notifications by using the \\nSetProperty method in your property setter. If yo\", \"u have a property that returns a Task<T>, the \\nSetPropertyAndNotifyOnCompletion method can be used t\", \"o delay publishing a property change until \\nthe task has been completed. The methods OnPropertyChang\", \"ed and OnPropertyChanging that can \\nalso be used for raising property changes where needed in your o\", \"bject. \\n\\nFor more detailed information on ObservableObject, see ObservableObject in the MVVM Toolkit\", \" \\nDeveloper Center. \\n\\nRelayCommand and AsyncRelayCommand \\n\\nInteraction between .NET MAUI controls (f\", \"or example, tapping a button or selecting an item from a \\ncollection) and the ViewModel is done with\", \" the ICommand interface. .NET MAUI comes with a default \\nimplementation of ICommand with the Command\", \" object. .NET MAUI\\u2019s Command is fairly basic and \\nlacks support for more advanced features, such as \", \"supporting asynchronous work and command \\nexecution status. \\n\\nThe MVVM Toolkit comes with two comman\", \"ds, RelayCommand and AsyncRelayCommand. \\nRelayCommand is intended for situations where you have sync\", \"hronous code to execute and has a \\nfairly similar implementation to the .NET MAUI Command object. \\n\\n\", \"Note \\n\\nEven though the .NET MAUI Command and RelayCommand are similar, using RelayCommand allows \\nfo\", \"r decoupling your ViewModel from any direct .NET MAUI references. This means that your \\nViewModel is\", \" more portable, leading to easier reuse across projects. \\n\\nAsyncRelayCommand provides many additiona\", \"l features when working with asynchronous workflows. \\nThis is quite common in our ViewModel as we ar\", \"e typically communicating with repositories, APIs, \\ndatabases, and other systems that utilize async/\", \"await. The AsyncRelayCommand constructor takes in \\nan execution task defined as a Func<Task> or a de\", \"legate returning Task as part of the constructor. \\nWhile the execution task is running, AsyncRelayCo\", \"mmand will monitor the state of the task and \\nprovides updates using the IsRunning property. The IsR\", \"unning property can be bound to the UI which \\nhelps manage control states such as showing loading wi\", \"th an ActivityIndicator or disabling/enabling a \\ncontrol. While the execution task is being executed\", \", the Cancel method can be called to attempt \\ncancellation of the execution task, if supported. \\n\\nBy\", \" default, AsyncRelayCommand doesn\\u2019t allow concurrent execution. This is very helpful in situations \\n\", \"where a user could unintentionally tap a control multiple times to execute a long-running or costly \", \"\\noperation. During task execution, AsyncRelayCommand will automatically call the CanExecuteChanged \\n\", \"event. In .NET MAUI, controls that support the Command and CommandParameter properties, such as \\nBut\", \"ton, will listen to this event and automatically enable or disable it during execution. This \\nfuncti\", \"onality can be overridden by using a custom canExecute parameter or setting the \\nAsyncRelayCommandOp\", \"tions.AllowConcurrentExecutions flag in the constructor. \\n\\n90 \\n\\nCHAPTER 12 | MVVM Toolkit Features \\n\", \"\\n \\n \\n\\fFor more detailed information on implementing commands, see the section Implementing commands \", \"\\nin the MVVM chapter. Detailed information for the RelayCommand and AsyncRelayCommand is \\navailable \", \"in the Commanding of the MVVM Toolkit Developer Center. \\n\\nSource Generators \\n\\nUsing the MVVM Toolkit\", \" components out-of-the-box allows you to greatly simplify our ViewModel. \\nThe MVVM Toolkit allows yo\", \"u to simplify common code use cases even further by using Source \\nGenerators. The MVVM Toolkit sourc\", \"e generators look for specific attributes in our code and can \\ngenerate wrappers for properties and \", \"commands. \\n\\nImportant \\n\\nThe MVVM Toolkit Source Generators generate code that is additive to our exi\", \"sting objects. Because \\nof this, any object that is leveraging a source generator will need to be ma\", \"rked as partial. \\n\\nThe MVVM Toolkit ObservableProperty attribute can be applied to fields in objects\", \" that inherit from \\nObservableObject and will wrap a private field with a property that generates ch\", \"anges. The following \\ncode shows an example of using the ObservableObject attribute on the _name fie\", \"ld: \\n\\npublic partial class SampleViewModel : ObservableObject \\n{ \\n    [ObservableProperty] \\n    priv\", \"ate string _name; \\n} \\n\\nWith the ObservableProperty attribute applied to the _name field, the source \", \"generator will run and \\ngenerate another partial class with the following code: \\n\\npartial class Samp\", \"leViewModel \\n{ \\n    public string Name \\n    { \\n        get => _name; \\n        set \\n        { \\n      \", \"      if (!EqualityComparer<string>.Default.Equals(_name, value)) \\n            { \\n                On\", \"NameChanging(value); \\n                OnPropertyChanging(\\\"Name\\\"); \\n                _name = value; \\n \", \"               OnNameChanged(value); \\n                OnPropertyChanged(\\\"Name\\\"); \\n            } \\n   \", \"     } \\n    } \\n} \\n\\nThe generated SampleViewModel has used the private _name field and generated a ne\", \"w Name \\nproperty that implements all of the logic needed for raising change notifications. \\n\\n91 \\n\\nCH\", \"APTER 12 | MVVM Toolkit Features \\n\\n \\n \\n\\fThe MVVM Toolkit RelayCommand attribute can be applied to me\", \"thods within an ObservableObject \\nand will create a corresponding RelayCommand or AsyncRelayCommand.\", \" The following code shows \\nexamples of using the RelayCommand attribute: \\n\\npublic partial class Samp\", \"leViewModel : ObservableObject \\n{ \\n    public INavigationService NavigationService { get; set; } \\n\\n \", \"   [ObservableProperty] \\n    private string _name; \\n\\n    [ObservableProperty] \\n    bool _isValid; \\n\\n\", \"    [RelayCommand] \\n    private Task SettingsAsync() \\n    { \\n        return NavigationService.Naviga\", \"teToAsync(\\\"Settings\\\"); \\n    } \\n\\n    [RelayCommand] \\n    private void Validate() \\n    { \\n        IsVa\", \"lid = !string.IsNullOrEmpty(Name); \\n    } \\n} \\n\\nThe RelayCommand applied to the Validate method will \", \"generate a RelayCommand validate \\nValidateCommand because it has a void return and the SettingsAsync\", \" method will generate an \\nAsyncRelayCommand named SettingsCommand. The source generator will generat\", \"e the following \\ncode in other partial classes: \\n\\npartial class SampleViewModel \\n{ \\n    private Asyn\", \"cRelayCommand? settingsCommand; \\n\\n    SettingsCommand => settingsCommand ??= new AsyncRelayCommand(S\", \"ettingsAsync); \\n} \\n\\npartial class SampleViewModel \\n{ \\n    private RelayCommand? validateCommand; \\n\\n \", \"   public IRelayCommand ValidateCommand => validateCommand ??= new RelayCommand(Validate); \\n} \\n\\nAll \", \"of the complexity of wrapping our ViewModel\\u2019s methods with an ICommand implementation has \\nbeen hand\", \"led by the source generator. \\n\\nFor more detailed information on MVVM Toolkit Source Generators, see \", \"MVVM source generators in \\nthe MVVM Toolkit Developer Center. \\n\\n92 \\n\\nCHAPTER 12 | MVVM Toolkit Featu\", \"res \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\fSummary \\n\\nThe MVVM Toolkit is a great way to standardize and simplify our V\", \"iewModel code. The MVVM toolkit \\noffers great implementations of standard MVVM components such as Ob\", \"servableObject and \\nAsync/RelayCommand. The source generators help simplify our ViewModel properties\", \" and commands \\nby generating all of the boilerplate code needed for user interface interactions. The\", \" MVVM Toolkit \\noffers even more features outside of what has been shown in this chapter. For more in\", \"formation on \\nthe MVVM Toolkit, see Introduction to the MVVM Toolkit in the MVVM Toolkit Developer C\", \"enter. \\n\\n93 \\n\\nCHAPTER 12 | MVVM Toolkit Features \\n\\n \\n \\n\\fCHAPTER  13 \\n\\nUnit testing \\n\\nmulti-platform \", \"apps experience problems similar to both desktop and web-based applications. Mobile \\nusers will diff\", \"er by their devices, network connectivity, availability of services, and various other factors. \\nThe\", \"refore, multi-platform apps should be tested as they would be used in the real world to improve \\nthe\", \"ir quality, reliability, and performance. Many types of testing should be performed on an app, \\nincl\", \"uding unit testing, integration testing, and user interface testing. Unit testing is the most common\", \" \\nform and essential to building high-quality applications. \\n\\nA unit test takes a small unit of the \", \"app, typically a method, isolates it from the remainder of the code, \\nand verifies that it behaves a\", \"s expected. Its goal is to check that each unit of functionality performs as \\nexpected, so errors do\", \"n\\u2019t propagate throughout the app. Detecting a bug where it occurs is more \\nefficient that observing \", \"the effect of a bug indirectly at a secondary point of failure. \\n\\nUnit testing has the most signific\", \"ant effect on code quality when it\\u2019s an integral part of the software \\ndevelopment workflow. Unit te\", \"sts can act as design documentation and functional specifications for \\nan application. As soon as a \", \"method has been written, unit tests should be written that verify the \\nmethod\\u2019s behavior in response\", \" to standard, boundary, and incorrect input data cases and check any \\nexplicit or implicit assumptio\", \"ns made by the code. Alternatively, with test-driven development, unit \\ntests are written before the\", \" code. For more information on test-driven development and how to \\nimplement it, see Walkthrough: Te\", \"st-driven development using Test Explorer. \\n\\nNote \\n\\nUnit tests are very effective against regression\", \". That is, functionality that used to work, but has been \\ndisturbed by a faulty update. \\n\\nUnit tests\", \" typically use the arrange-act-assert pattern: \\n\\nStep \\n\\nDescription \\n\\nArrange \\n\\nAct \\n\\nAssert \\n\\nIniti\", \"alizes objects and sets the value of the data \\nthat is passed to the method under test. \\n\\nInvokes th\", \"e method under test with the required \\narguments. \\n\\nVerifies that the action of the method under tes\", \"t \\nbehaves as expected. \\n\\nThis pattern ensures that unit tests are readable, self-describing, and co\", \"nsistent. \\n\\n94 \\n\\nCHAPTER 13 | Unit testing \\n\\n \\n \\n\\fDependency injection and unit testing \\n\\nOne of the\", \" motivations for adopting a loosely-coupled architecture is that it facilitates unit testing. \\nOne o\", \"f the types registered with the dependency injection service is the IAppEnvironmentService \\ninterfac\", \"e. The following code example shows an outline of this class: \\n\\npublic class OrderDetailViewModel : \", \"ViewModelBase \\n{ \\n    private IAppEnvironmentService _appEnvironmentService; \\n\\n    public OrderDetai\", \"lViewModel( \\n        IAppEnvironmentService appEnvironmentService, \\n        IDialogService dialogSer\", \"vice, INavigationService navigationService, \\nISettingsService settingsService) \\n        : base(dialo\", \"gService, navigationService, settingsService) \\n    { \\n        _appEnvironmentService = appEnvironmen\", \"tService; \\n    } \\n} \\n\\nThe OrderDetailViewModel class has a dependency on the IAppEnvironmentService \", \"type, which the \\ndependency injection container resolves when it instantiates an OrderDetailViewMode\", \"l object. \\nHowever, rather than create an IAppEnvironmentService object which utilizes real servers,\", \" devices and \\nconfigurations to unit test the OrderDetailViewModel class, instead, replace the \\nIApp\", \"EnvironmentService object with a mock object for the purpose of the tests. A mock object is one \\ntha\", \"t has the same signature of an object or an interface, but is created in a specific manner to help \\n\", \"with unit testing. It is often used with dependency injection to provide specific implementations of\", \" \\ninterfaces for testing different data and workflow scenarios. \\n\\nThis approach allows the IAppEnvir\", \"onmentService object to be passed into the OrderDetailViewModel \\nclass at runtime, and in the intere\", \"sts of testability, it allows a mock class to be passed into the \\nOrderDetailViewModel class at test\", \" time. The main advantage of this approach is that it enables unit \\ntests to be executed without req\", \"uiring unwieldy resources such as runtime platform features, web \\nservices, or databases. \\n\\nTesting \", \"MVVM applications \\n\\nTesting models and view models from MVVM applications is identical to testing an\", \"y other class, and \\nuses the same tools and techniques; this includes features such as unit testing \", \"and mocking. However, \\nsome patterns that are typical to model and view model classes can benefit fr\", \"om specific unit testing \\ntechniques. \\n\\nTip \\n\\nTest one thing with each unit test. As the complexity \", \"of a test expands, it makes verification of that \\ntest more difficult. By limiting a unit test to a \", \"single concern, we can ensure that our tests are more \\nrepeatable, isolated, and have a smaller exec\", \"ution time. See \\n\\nUnit testing best practices with .NET for more best practices. \\n\\n95 \\n\\nCHAPTER 13 |\", \" Unit testing \\n\\n \\n \\n \\n\\fDon\\u2019t be tempted to make a unit test exercise more than one aspect of the uni\", \"t\\u2019s behavior. Doing so \\nleads to tests that are difficult to read and update. It can also lead to co\", \"nfusion when interpreting a \\nfailure. \\n\\nThe eShop multi-platform app uses MSTest to perform unit tes\", \"ting, which supports two different \\ntypes of unit tests: \\n\\nTesting Type \\n\\nAttribute \\n\\nDescription \\n\\n\", \"TestMethod \\n\\nTestMethod  Defines the actual test method to run.. \\n\\nDataSource \\n\\nDataSource \\n\\nTests t\", \"hat are only true for a particular set of data. \\n\\nThe unit tests included with the eShop multi-platf\", \"orm app are TestMethod, so each unit test method \\nis decorated with the TestMethod attribute. In add\", \"ition to MSTest there are several other testing \\nframeworks available including NUnit and xUnit. \\n\\nT\", \"esting asynchronous functionality \\n\\nWhen implementing the MVVM pattern, view models usually invoke o\", \"perations on services, often \\nasynchronously. Tests for code that invokes these operations typically\", \" use mocks as replacements for \\nthe actual services. The following code example demonstrates testing\", \" asynchronous functionality by \\npassing a mock service into a view model: \\n\\n[TestMethod] \\npublic asy\", \"nc Task OrderPropertyIsNotNullAfterViewModelInitializationTest() \\n{ \\n    // Arrange \\n    var orderSe\", \"rvice = new OrderMockService(); \\n    var orderViewModel = new OrderDetailViewModel(orderService); \\n\\n\", \"    // Act \\n    var order = await orderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken); \\n\", \"    await orderViewModel.InitializeAsync(order); \\n\\n    // Assert \\n    Assert.IsNotNull(orderViewMode\", \"l.Order); \\n} \\n\\nThis unit test checks that the Order property of the OrderDetailViewModel instance wi\", \"ll have a value \\nafter the InitializeAsync method has been invoked. The InitializeAsync method is in\", \"voked when the \\nview model\\u2019s corresponding view is navigated to. For more information about navigati\", \"on, see \\nNavigation. \\n\\nWhen the OrderDetailViewModel instance is created, it expects an IOrderServic\", \"e instance to be \\nspecified as an argument. However, the OrderService retrieves data from a web serv\", \"ice. Therefore, an \\nOrderMockService instance, a mock version of the OrderService class, is specifie\", \"d as the argument to \\nthe OrderDetailViewModel constructor. Then, mock data is retrieved rather than\", \" communicating with \\na web service when the view model\\u2019s InitializeAsync method is invoked, which us\", \"es IOrderService \\noperations. \\n\\n96 \\n\\nCHAPTER 13 | Unit testing \\n\\n \\n \\n \\n \\n\\fTesting INotifyPropertyCha\", \"nged implementations \\n\\nImplementing the INotifyPropertyChanged interface allows views to react to ch\", \"anges that originate \\nfrom view models and models. These changes are not limited to data shown in co\", \"ntrols \\u2013 they are also \\nused to control the view, such as view model states that cause animations to\", \" be started or controls to \\nbe disabled. \\n\\nProperties that can be updated directly by the unit test \", \"can be tested by attaching an event handler to \\nthe PropertyChanged event and checking whether the e\", \"vent is raised after setting a new value for the \\nproperty. The following code example shows such a \", \"test: \\n\\n[TestMethod] \\npublic async Task SettingOrderPropertyShouldRaisePropertyChanged() \\n{ \\n    var\", \" invoked = false; \\n    var orderService = new OrderMockService(); \\n    var orderViewModel = new Orde\", \"rDetailViewModel(orderService); \\n\\n    orderViewModel.PropertyChanged += (sender, e) => \\n    { \\n     \", \"   if (e.PropertyName.Equals(\\\"Order\\\")) \\n            invoked = true; \\n    }; \\n    var order = await o\", \"rderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken); \\n    await orderViewModel.Initialize\", \"Async(order); \\n\\n    Assert.IsTrue(invoked); \\n} \\n\\nThis unit test invokes the InitializeAsync method o\", \"f the OrderViewModel class, which causes its Order \\nproperty to be updated. The unit test will pass,\", \" provided that the PropertyChanged event is raised for \\nthe Order property. \\n\\nTesting message-based \", \"communication \\n\\nView models that use the MessagingCenter class to communicate between loosely couple\", \"d classes \\ncan be unit tested by subscribing to the message being sent by the code under test, as de\", \"monstrated \\nin the following code example: \\n\\n[TestMethod] \\npublic void AddCatalogItemCommandSendsAdd\", \"ProductMessageTest() \\n{ \\n    var messageReceived = false; \\n    var catalogService = new CatalogMockS\", \"ervice(); \\n    var catalogViewModel = new CatalogViewModel(catalogService); \\n\\n    MessagingCenter.Su\", \"bscribe<CatalogViewModel, CatalogItem>( \\n        this, MessageKeys.AddProduct, (sender, arg) => \\n   \", \" { \\n        messageReceived = true; \\n    }); \\n    catalogViewModel.AddCatalogItemCommand.Execute(nul\", \"l); \\n\\n97 \\n\\nCHAPTER 13 | Unit testing \\n\\n \\n \\n \\n \\n \\n \\n\\f    Assert.IsTrue(messageReceived); \\n} \\n\\nThis un\", \"it test checks that the CatalogViewModel publishes the AddProduct message in response to its \\nAddCat\", \"alogItemCommand being executed. Because the MessagingCenter class supports multicast \\nmessage subscr\", \"iptions, the unit test can subscribe to the AddProduct message and execute a callback \\ndelegate in r\", \"esponse to receiving it. This callback delegate, specified as a lambda expression, sets a \\nboolean f\", \"ield that\\u2019s used by the Assert statement to verify the behavior of the test. \\n\\nTesting exception han\", \"dling \\n\\nUnit tests can also be written that check that specific exceptions are thrown for invalid ac\", \"tions or \\ninputs, as demonstrated in the following code example: \\n\\n[TestMethod] \\npublic void Invalid\", \"EventNameShouldThrowArgumentExceptionText() \\n{ \\n    var behavior = new MockEventToCommandBehavior \\n \", \"   { \\n        EventName = \\\"OnItemTapped\\\" \\n    }; \\n    var listView = new ListView(); \\n\\n    Assert.Th\", \"rows<ArgumentException>(() => listView.Behaviors.Add(behavior)); \\n} \\n\\nThis unit test will throw an e\", \"xception because the ListView control does not have an event named \\nOnItemTapped. The Assert.Throws<\", \"T> method is a generic method where T is the type of the \\nexpected exception. The argument passed to\", \" the Assert.Throws<T> method is a lambda expression \\nthat will throw the exception. Therefore, the u\", \"nit test will pass provided that the lambda expression \\nthrows an ArgumentException. \\n\\nTip \\n\\nAvoid w\", \"riting unit tests that examine exception message strings. Exception message strings might \\nchange ov\", \"er time, and so unit tests that rely on their presence are regarded as brittle. \\n\\nTesting validation\", \" \\n\\nThere are two aspects to testing the validation implementation: testing that any validation rules\", \" are \\ncorrectly implemented and testing that the ValidatableObject<T> class performs as expected. \\n\\n\", \"Validation logic is usually simple to test, because it is typically a self-contained process where t\", \"he \\noutput depends on the input. There should be tests on the results of invoking the Validate metho\", \"d on \\neach property that has at least one associated validation rule, as demonstrated in the followi\", \"ng code \\nexample: \\n\\n[TestMethod] \\npublic void CheckValidationPassesWhenBothPropertiesHaveDataTest() \", \"\\n{ \\n\\n98 \\n\\nCHAPTER 13 | Unit testing \\n\\n \\n \\n \\n\\f    var mockViewModel = new MockViewModel(); \\n    mockV\", \"iewModel.Forename.Value = \\\"John\\\"; \\n    mockViewModel.Surname.Value = \\\"Smith\\\"; \\n\\n    var isValid = mo\", \"ckViewModel.Validate(); \\n\\n    Assert.IsTrue(isValid); \\n} \\n\\nThis unit test checks that validation suc\", \"ceeds when the two ValidatableObject<T> properties in the \\nMockViewModel instance both have data. \\n\\n\", \"As well as checking that validation succeeds, validation unit tests should also check the values of \", \"the \\nValue, IsValid, and Errors property of each ValidatableObject<T> instance, to verify that the c\", \"lass \\nperforms as expected. The following code example demonstrates a unit test that does this: \\n\\n[T\", \"estMethod] \\npublic void CheckValidationFailsWhenOnlyForenameHasDataTest() \\n{ \\n    var mockViewModel \", \"= new MockViewModel(); \\n    mockViewModel.Forename.Value = \\\"John\\\"; \\n\\n    bool isValid = mockViewMode\", \"l.Validate(); \\n\\n    Assert.IsFalse(isValid); \\n    Assert.IsNotNull(mockViewModel.Forename.Value); \\n \", \"   Assert.IsNull(mockViewModel.Surname.Value); \\n    Assert.IsTrue(mockViewModel.Forename.IsValid); \\n\", \"    Assert.IsFalse(mockViewModel.Surname.IsValid); \\n    Assert.AreEqual(mockViewModel.Forename.Error\", \"s.Count(), 0); \\n    Assert.AreNotEqual(mockViewModel.Surname.Errors.Count(), 0); \\n} \\n\\nThis unit test\", \" checks that validation fails when the Surname property of the MockViewModel doesn\\u2019t \\nhave any data,\", \" and the Value, IsValid, and Errors property of each ValidatableObject<T> instance are \\ncorrectly se\", \"t. \\n\\nSummary \\n\\nA unit test takes a small unit of the app, typically a method, isolates it from the r\", \"emainder of the code, \\nand verifies that it behaves as expected. Its goal is to check that each unit\", \" of functionality performs as \\nexpected, so errors don\\u2019t propagate throughout the app. \\n\\nThe behavio\", \"r of an object under test can be isolated by replacing dependent objects with mock \\nobjects that sim\", \"ulate the behavior of the dependent objects. This enables unit tests to be executed \\nwithout requiri\", \"ng unwieldy resources such as runtime platform features, web services, or databases \\n\\nTesting models\", \" and view models from MVVM applications is identical to testing any other classes, and \\nthe same too\", \"ls and techniques can be used. \\n\\n99 \\n\\nCHAPTER 13 | Unit testing \\n\\n \\n \\n \\n \\n \\n \\n\\f\"]"