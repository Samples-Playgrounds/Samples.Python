"[\" \\n  \\nDOWNLOAD  available at: https://aka.ms/maui -ebook  \\nEDITION v2.0  \\nPUBLISHED BY  \\nMicrosoft De\", \"veloper Division, .NET, and Visual Studio product teams  \\nA division of Microsoft Corporation  \\nOne \", \"Microsoft Way  \\nRedmond, Washington 98052 -6399  \\nCopyright \\u00a9 2022 by Microsoft Corporation  \\nAll ri\", \"ghts reserved. No part of the contents of this book may be reproduced or transmitted in any \\nform or\", \" by any means without the written permission of the publisher.  \\nThis book is provided \\u201cas -is\\u201d and \", \"expresses the author\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in this b\", \"ook, including URL and other Internet website references, may change \\nwithout notice.  \\nSome example\", \"s depicted herein are provided for illustration only and are fictitious. No real association \\nor con\", \"nection is intended or should be inferred.  \\nMicrosoft and the trademarks listed at https://www.micr\", \"osoft.com  on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies.  \\nMac an\", \"d macOS are trademarks of Apple Inc.  \\nAll other marks and logos are property of their respective ow\", \"ners.  \\nAuthors:  \\nMichael Stonis , Mobile Software Architect, Eight -Bot \\nReviewers:  \\nJames Montem\", \"agno , Principal Lead Program Manager, Microsoft Corp.  \\nDavid Pine , Developer Relations, Microsoft\", \" Corp.  \\nAcknowledgments  \\nThis book originated from the excellent Enterprise Application Patterns u\", \"sing Xamarin.Forms eBook by \\nDavid Britch  and Javier Suarez Ruiz . Without their hard work, detaile\", \"d information, and excellent \\nexamples, this book would not be possible.  \\nIntroduction  \\nEnterprise\", \" applications face a number of difficult problems to solve including ever changing business \\nrequire\", \"ments, the need for quick turn around time, support for multiple platforms, and integration \\nwith mu\", \"ltiple systems. Due to the varying nature of the se problems, it\\u2019s important that our \\napplication\\u2019s\", \" architecture allows it to be modular, modifiable and extensible over time.  This book takes provide\", \"s real world solutions for addressing these issues when building an enterprise \\napplication using .N\", \"ET MAUI. This book uses a pre -built .NET MAUI application that serves as the \\nfront -end of an onli\", \"ne eCommerce application as a referen ce and a guide for common enterprise \\ndesign patterns. This bo\", \"ok covers topics such as the MVVM pattern, dependency injection, navigation, \\nconfiguration, the loo\", \"se -coupling of components and additional enterprise concerns. The content of \\nthis book is helpfu l\", \" for anyone looking to build a new application for this business or looking to solve \\nthe problems o\", \"f applications that evolve over time.  \\nWho should use the book  \\nThis book is for .NET MAUI develop\", \"ers that are already familiar with the framework, but that are \\nlooking for guidance on architecture\", \" and implementation when building enterprise applications. This \\nbook can help developers solve comm\", \"on problems using tried and true patterns.  \\nHow to use the book  \\nThis book focuses on building cro\", \"ss -platform enterprise apps using .NET MAUI. As such, it should be \\nread in its entirety to provide\", \" a foundation of understanding such apps and their technical \\nconsiderations. The book, along with i\", \"ts sample app, can also se rve as a starting point or reference for \\ncreating a new enterprise app. \", \"Use the associated sample app as a template for the new app, or to see \\nhow to organize an app\\u2019s com\", \"ponent parts. Then, refer back to this guide for architectural guidance. \\nYou can find  the sample a\", \"pp on GitHub . \\nWhat this book doesn\\u2019t cover  \\nThis book is aimed at readers who are already familia\", \"r with .NET MAUI. It does cover some concepts \\nof .NET MAUI to help better illustrate the topic, but\", \" it does not cover most controls and concepts in \\nany detail. For general guidance on building a new\", \" .NET  MAUI app, please refer to the Building your \\nfirst app  guide in the .NET MAUI documentation.\", \"  \\nAdditional resources  \\nFor official .NET MAUI content, see .NET MAUI docs . .NET MAUI is develope\", \"d as an open -source \\nproject and is available on GitHub at dotnet/maui . For code samples developed\", \" with .NET MAUI, see \\nthe dotnet/maui -samples  repo.   \\ni Contents   \\nContents  \\nPurpose  .........\", \"....................... ................................ ................................ ..........\", \"...................... ..... 1 \\nWhat\\u2019s left out of this guide\\u2019s scope  .............................\", \"... ................................ ................................ ..............................\", \"..  1 \\nWho should use this guide  ................................ ................................ \", \"................................ ................................ ..................  1 \\nHow to use \", \"this guide  ................................ ................................ ......................\", \".......... ................................ ............................  2 \\nIntroduction to .NET MA\", \"UI  ................................ ................................ ..............................\", \".. .... 3 \\nSample application  ................................ ................................ ...\", \"............................. ................................ ................................ .. 4\", \" \\nSample application architecture  ................................ ................................\", \" ................................ ................................ ........ 5 \\nMulti -Platform app  \", \"................................ ................................ ................................ .\", \"............................... ................................ .. 6 \\nMulti -Platform app solution \", \" ................................ ................................ ................................ \", \"................................ ................  7 \\neShop project  ...............................\", \". ................................ ................................ ................................\", \" ................................ ............  7 \\nSummary  ................................ .......\", \"......................... ................................ ................................ ........\", \"........................ .....................  8 \\nModel -View -ViewModel (MVVM)  ..................\", \".............. ................................ .........................  9 \\nThe MVVM pattern  ....\", \"............................ ................................ ................................ .....\", \"........................... ................................ .. 9 \\nView  ...........................\", \"..... ................................ ................................ ............................\", \".... ................................ .......................  10 \\nViewModel  ......................\", \".......... ................................ ................................ .......................\", \"......... ................................ ..........  11 \\nModel  ................................ .\", \"............................... ................................ ................................ ..\", \".............................. ....................  11 \\nConnecting view models to views  ..........\", \"...................... ................................ ................................ ...........\", \"..................... .. 12 \\nCreating a view model declaratively  ................................ .\", \"............................... ................................ .............................  12 \\n\", \"Creating a view model programmatically  ................................ ...........................\", \"..... ................................ ...................  13 \\nUpdating views in response to change\", \"s in the underlying view model or model ................................ ...... 13 \\nMVVM Frameworks \", \" ................................ ................................ ................................ \", \"................................ ..............................  15 \\nUI interaction using commands a\", \"nd behaviors  ................................ ................................ ....................\", \"............ ........ 15 \\nImplementing commands  ................................ ..................\", \".............. ................................ ................................ .................  \", \"16 \\nInvoking commands from a view  ................................ ................................\", \" ................................ ................................ ... 17 \\nImplementing behaviors  .\", \"............................... ................................ ................................ ..\", \".............................. ....................  17 \\nInvoking behaviors from a view  ...........\", \"..................... ................................ ................................ ............\", \".................... ...... 20 \\nSummary  ................................ ..........................\", \"...... ................................ ................................ ...........................\", \"..... ..................  20 \\nDependency injection  ................................ ...............\", \"................. ................................ ...........  21  \\nii Contents  Introduction to de\", \"pendency injection  ................................ ................................ ..............\", \".................. ..........................  21 \\nRegistration  ................................ ..\", \".............................. ................................ ................................ ...\", \"............................. .............  23 \\nResolution  ................................ ......\", \".......................... ................................ ................................ .......\", \"......................... ................  25 \\nSummary  ................................ ..........\", \"...................... ................................ ................................ ...........\", \"..................... ..................  26 \\nCommunicating between loosely coupled components  ....\", \"............................ ...................  27 \\nIntroduction to MVVM Toolkit Messenger  ......\", \".......................... ................................ ................................ .......\", \"..........  27 \\nDefining a message  ................................ ...............................\", \". ................................ ................................ ..............................  \", \"29 \\nPublishing a message  ................................ ................................ ........\", \"........................ ................................ ..........................  29 \\nSubscribin\", \"g to a message ................................ ................................ ...................\", \"............. ................................ ..................  30 \\nUnsubscribing from a message \", \" ................................ ................................ ................................ \", \"................................ ....... 30 \\nSummary  ................................ .............\", \"................... ................................ ................................ ..............\", \".................. ..................  31 \\nNavigation  ................................ ............\", \".................... ................................ ..............................  32 \\nNavigating\", \" between pages  ................................ ................................ ..................\", \".............. ................................ ...............  33 \\nCreating the MauiNavigationServ\", \"ice instance  ................................ ................................ ....................\", \"............ ..........  34 \\nHandling navigation requests  ................................ ........\", \"........................ ................................ ................................ .........\", \".  34 \\nNavigating when the app is launched  ................................ .......................\", \"......... ................................ ..........................  36 \\nPassing parameters during\", \" navigation  ................................ ................................ .....................\", \"........... .........................  36 \\nInvoking navigation using behaviors  ....................\", \"............ ................................ ................................ .....................\", \".......  37 \\nConfirming or cancelling navigation  ................................ .................\", \"............... ................................ .............................  38 \\nSummary  .......\", \"......................... ................................ ................................ ........\", \"........................ ................................ ..................  38 \\nValidation  ......\", \".......................... ................................ ................................ .......\", \"........................  39 \\nSpecifying validation rules  ................................ ........\", \"........................ ................................ ................................ .........\", \".......  40 \\nAdding validation rules to a property  ................................ ...............\", \"................. ................................ ..........................  42 \\nTriggering valida\", \"tion  ................................ ................................ ............................\", \".... ................................ ...........................  42 \\nTriggering validation manuall\", \"y  ................................ ................................ ...............................\", \". ................................ ... 42 \\nTriggering validation when properties change  ...........\", \"..................... ................................ ................................ .... 43 \\nDis\", \"playing validation errors  ................................ ................................ .......\", \"......................... ................................ ..............  43 \\nHighlighting a contro\", \"l that contains invalid data  ................................ ................................ ....\", \"............................  44 \\nDisplaying error messages  ................................ ......\", \".......................... ................................ ................................ .......\", \"....  45 \\nSummary  ................................ ................................ ...............\", \"................. ................................ ................................ ................\", \"..  45 \\nApplication settings management  ................................ ..........................\", \"...... ......................  46  \\niii Contents  Creating a Settings Interface  ...................\", \"............. ................................ ................................ ....................\", \"............ ............  46 \\nAdding Settings  ................................ ...................\", \"............. ................................ ................................ ....................\", \"............ ..... 47 \\nData binding to user settings ................................ ..............\", \".................. ................................ ................................ ...........  48\", \" \\nSummary  ................................ ................................ .......................\", \"......... ................................ ................................ ..................  49 \\n\", \"Containerized microservices  ................................ ................................ .....\", \"...........................  50 \\nMicroservices  ................................ ...................\", \"............. ................................ ................................ ....................\", \"............ ..........  51 \\nContainerization  ................................ ....................\", \"............ ................................ ................................ .....................\", \"........... .... 53 \\nCommunication between client and microservices  ...............................\", \". ................................ ................................  56 \\nCommunication between micro\", \"services  ................................ ................................ ........................\", \"........ ......................  57 \\nSummary  ................................ .....................\", \"........... ................................ ................................ ......................\", \".......... ..................  59 \\nAccessing remote data  ................................ .........\", \"....................... ................................ ..........  60 \\nIntroduction to Representat\", \"ional State Transfer  ................................ ................................ ............\", \".................... ...... 60 \\nConsuming RESTful APIs  ................................ ...........\", \"..................... ................................ ................................ ............\", \"........  61 \\nMaking web requests  ................................ ................................\", \" ................................ ................................ ..........................  61 \\nM\", \"aking a GET request  ................................ ................................ .............\", \"................... ................................ .........................  61 \\nMaking a POST re\", \"quest  ................................ ................................ ...........................\", \"..... ................................ ......................  64 \\nMaking a DELETE request  ........\", \"........................ ................................ ................................ .........\", \"....................... ..................  67 \\nCaching data  ................................ .....\", \"........................... ................................ ................................ ......\", \".......................... ...........  68 \\nManaging data expiration  ..............................\", \".. ................................ ................................ ...............................\", \". .................  69 \\nCaching images  ................................ ..........................\", \"...... ................................ ................................ ...........................\", \"..... ..... 69 \\nIncreasing resilience  ................................ ............................\", \".... ................................ ................................ .............................\", \"  70 \\nRetry pattern  ................................ ................................ .............\", \"................... ................................ ................................ ...........  7\", \"0 \\nCircuit breaker pattern  ................................ ................................ ......\", \".......................... ................................ ........................  71 \\nSummary  .\", \"............................... ................................ ................................ ..\", \".............................. ................................ ..................  72 \\nAuthenticati\", \"on and authorization  ................................ ................................ ............\", \"...........  73 \\nAuthentication  ................................ ................................ .\", \"............................... ................................ ................................ ..\", \"...... 73 \\nIssuing bearer tokens using IdentityServer  ................................ ............\", \".................... ................................ ............  74 \\nAdding IdentityServer to a w\", \"eb application  ................................ ................................ ..................\", \".............. ..........  75 \\nConfiguring IdentityServer  ................................ ........\", \"........................ ................................ ................................ .........\", \"..  75 \\nConfiguring API resources  ................................ ................................\", \" ................................ ................................ ............  76 \\nConfiguring ide\", \"ntity resources  ................................ ................................ .................\", \"............... ................................ ... 76  \\niv Contents  Configuring clients  ........\", \"........................ ................................ ................................ .........\", \"....................... ..........................  77 \\nConfiguring the authentication flow  .......\", \"......................... ................................ ................................ ........\", \"................  78 \\nPerforming authentication  ................................ ..................\", \".............. ................................ ................................ ...........  79 \\nSi\", \"gning -in ................................ ................................ ........................\", \"........ ................................ ................................ ............  80 \\nSigning\", \" -out ................................ ................................ ............................\", \".... ................................ ................................ ......... 83 \\nAuthorization  \", \"................................ ................................ ................................ .\", \"............................... ................................ ..........  84 \\nConfiguring Identit\", \"yServer to perform authorization  ................................ ................................ \", \"............................  85 \\nMaking access requests to APIs  ................................ .\", \"............................... ................................ ................................ ..\", \".... 86 \\nSummary  ................................ ................................ ................\", \"................ ................................ ................................ .................\", \".  87 \\nMVVM Toolkit Features  ................................ ................................ ....\", \"............................ ........  88 \\nMVVM Toolkit  ................................ ..........\", \"...................... ................................ ................................ ...........\", \"..................... ........ 88 \\nObservableObject  ................................ ..............\", \".................. ................................ ................................ ...............\", \"................. . 89 \\nRelayCommand and AsyncRelayCommand  ................................ .......\", \"......................... ................................ ...............  90 \\nSource Generators  .\", \"............................... ................................ ................................ ..\", \".............................. ................................  91 \\nSummary  ......................\", \".......... ................................ ................................ .......................\", \"......... ................................ ..................  93 \\nUnit testing  ...................\", \"............. ................................ ................................ ....................\", \"........  94 \\nDependency injection and unit testing  ................................ ..............\", \".................. ................................ ........................  95 \\nTesting MVVM appli\", \"cations  ................................ ................................ .........................\", \"....... ................................ ..............  95 \\nTesting asynchronous functionality  ...\", \"............................. ................................ ................................ ....\", \"...........................  96 \\nTesting INotifyPropertyChanged implementations  ...................\", \"............. ................................ ................................  97 \\nTesting message\", \" -based communication  ................................ ................................ ...........\", \"..................... .....................  97 \\nTesting exception handling  .......................\", \"......... ................................ ................................ ........................\", \"........ ..............  98 \\nTesting validation  ................................ ..................\", \".............. ................................ ................................ ...................\", \"............. .. 98 \\nSummary  ................................ ................................ ....\", \"............................ ................................ ................................ .....\", \".............  99  \\n1 CHAPTER 1 | Purpose  \\n CHAPTER  1 \\nPurpose  \\nThis eBook provides guidance on b\", \"uilding cross -platform enterprise apps using .NET MAUI. .NET \\nMAUI is a cross -platform UI toolkit \", \"that allows developers to easily create native user interface layouts \\nthat can be shared across pla\", \"tforms, including iOS, macOS, Android, and Windows. It provides a \\ncomprehensive solution for Busine\", \" ss to Employee (B2E), Business to Business (B2B), and Business to \\nConsumer (B2C) apps, providing t\", \"he ability to share code across all target platforms and helping to \\nlower the total cost of ownersh\", \"ip (TCO).  \\nThe guide provides architectural guidance for developing adaptable, maintainable, and te\", \"stable .NET \\nMAUI enterprise apps. Guidance is provided on how to implement MVVM, dependency injecti\", \"on, \\nnavigation, validation, and configuration management, while maint aining loose coupling. In add\", \"ition, \\nthere\\u2019s also guidance on performing authentication and authorization with IdentityServer, ac\", \"cessing \\ndata from containerized microservices, and unit testing.  \\nThe guide comes with source code\", \" for the eShop multi -platform app , and source code for the eShop \\nreference app . The eShop multi \", \"-platform app is a cross -platform enterprise app developed using .NET \\nMAUI, which connects to a se\", \"ries of containerized microservices known as the eShop reference app. \\nHowever, the eShop multi -pla\", \"tform app can be configured to consume data  from mock services for \\nthose who wish to avoid deployi\", \"ng the containerized microservices.  \\nWhat\\u2019s left out of this guide\\u2019s scope  \\nThis guide is aimed at\", \" readers who are already familiar with .NET MAUI. For a detailed introduction to \\n.NET MAUI, see the\", \" .NET MAUI documentation . \\nWho should use this guide  \\nThe audience for this guide is mainly develo\", \"pers and architects who would like to learn how to \\narchitect and implement cross -platform enterpri\", \"se apps using .NET MAUI.  \\nA secondary audience is technical decision -makers who would like to rece\", \"ive an architectural and \\ntechnology overview before deciding on what approach to select for cross -\", \"platform enterprise app \\ndevelopment using .NET MAUI.   \\n2 CHAPTER 1 | Purpose  \\n How to use this gu\", \"ide  \\nThis guide focuses on building cross -platform enterprise apps using .NET MAUI. As such, it sh\", \"ould be \\nread in its entirety to provide a foundation of understanding such apps and their technical\", \" \\nconsiderations. The guide and its sample app can also serve as a starting point or reference for \\n\", \"creating a new enterprise app. Use the associated sample app as a template for the new app or see \\nh\", \"ow to organize an app\\u2019s component parts. Then, refer back to this guide for architectural guidance. \", \" \\nFeel free to forward this guide to team members to help ensure a common understanding of cross -\\np\", \"latform enterprise app development using .NET MAUI. Having everybody working from a common \\nset of t\", \"erminologies and underlying principles will help ensure a con sistent application of architectural \\n\", \"patterns and practices.   \\n3 CHAPTER 2 | Introduction to .NET MAUI  \\n CHAPTER  2 \\nIntroduction to .N\", \"ET MAUI  \\nRegardless of platform, developers of enterprise apps face several challenges:  \\n\\u2022 App req\", \"uirements that can change over time.  \\n\\u2022 New business opportunities and challenges.  \\n\\u2022 Ongoing feed\", \"back during development that can significantly affect the scope and \\nrequirements of the app.  \\nWith\", \" these in mind, it\\u2019s important to build apps that can be easily modified or extended over time. \\nDes\", \"igning for such adaptability can be difficult as it requires an architecture that allows individual \", \"\\nparts of the app to be independently developed and tested in isolation without affecting the rest o\", \"f \\nthe app.  \\nMany enterprise apps are sufficiently complex to require more than one developer. It c\", \"an be a \\nsignificant challenge to decide how to design an app so that multiple developers can work e\", \"ffectively \\non different pieces of the app independently, while ensuring  that the pieces come toget\", \"her seamlessly \\nwhen integrated into the app.  \\nThe traditional approach to designing and building a\", \"n app results in what is referred to as a \\nmonolithic  app, where components are tightly coupled wit\", \"h no clear separation between them. \\nTypically, this monolithic approach leads to apps that are diff\", \"icult and inefficient to maintain, because \\nit can be difficult to resolve bugs without breaking oth\", \"er component s in the app, and it can be \\ndifficult to add new features or to replace existing featu\", \"res.  \\nAn effective remedy for these challenges is to partition an app into discrete, loosely couple\", \"d \\ncomponents that can be easily integrated together into an app. Such an approach offers several \\nb\", \"enefits:  \\n\\u2022 It allows individual functionality to be developed, tested, extended, and maintained by\", \" \\ndifferent individuals or teams.  \\n\\u2022 It promotes reuse and a clean separation of concerns between t\", \"he app\\u2019s horizontal \\ncapabilities, such as authentication and data access, and the vertical capabili\", \"ties, such as app \\nspecific business functionality. This allows the dependencies and interaction s b\", \"etween app \\ncomponents to be more easily managed.  \\n\\u2022 It helps maintain a separation of roles by all\", \"owing different individuals, or teams, to focus on \\na specific task or piece of functionality accord\", \"ing to their expertise. In particular, it provides a \\ncleaner separation between the user interface \", \"and the app\\u2019 s business logic.  \\nHowever, there are many issues that must be resolved when partition\", \"ing an app into discrete, loosely \\ncoupled components. These include:   \\n4 CHAPTER 2 | Introduction \", \"to .NET MAUI  \\n \\u2022 Deciding how to provide a clean separation of concerns between the user interface \", \"controls \\nand their logic. One of the most important decisions when creating a .NET MAUI enterprise \", \"\\napp is whether to place business logic in code -behind files, or whether to create a clean \\nseparat\", \"ion of concerns between the user interface controls and their logic, in order to make \\nthe app more \", \"maintainable and testable. For more information, see Model -View -ViewModel . \\n\\u2022 Determining whether\", \" to use a dependency injection container. Dependency injection \\ncontainers reduce the dependency cou\", \"pling between objects by providing a facility to \\nconstruct instances of classes with their dependen\", \"cies injected, and manage their lifetim e \\nbased on the configuration of the container. For more inf\", \"ormation, see Dependency injection . \\n\\u2022 Choosing between platform provided eventing and loosely coup\", \"led message -based \\ncommunication between components that are inconvenient to link by object and typ\", \"e \\nreferences. For more information, see Introduction to Communicating between loosely \\ncoupled comp\", \"onents . \\n\\u2022 Deciding how to navigate between pages, including how to invoke navigation, and where \\nn\", \"avigation logic should reside. For more information, see Navigation . \\n\\u2022 Determining how to validate\", \" user input for correctness. The decision must include how to \\nvalidate user input, and how to notif\", \"y the user about validation errors. For more information, \\nsee Validation . \\n\\u2022 Deciding how to perfo\", \"rm authentication, and how to protect resources with authorization. For \\nmore information, see Authe\", \"ntication and authorization . \\n\\u2022 Determining how to access remote data from web services, including \", \"how to reliably retrieve \\ndata, and how to cache data. For more information, see Accessing remote da\", \"ta . \\n\\u2022 Deciding how to test the app. For more information, see Unit testing . \\nThis guide provides \", \"guidance on these issues, and focuses on the core patterns and architecture for \\nbuilding a cross -p\", \"latform enterprise app using .NET MAUI. The guidance aims to help to produce \\nadaptable, maintainabl\", \"e, and testable code, by addressing com mon .NET MAUI enterprise app \\ndevelopment scenarios, and by \", \"separating the concerns of presentation, presentation logic, and \\nentities through support for the M\", \"odel -View -ViewModel (MVVM) pattern.  \\nSample application  \\nThis guide includes a sample applicatio\", \"n, eShop, that\\u2019s an online store that includes the following \\nfunctionality:  \\n\\u2022 Authenticating and \", \"authorizing against a backend service.  \\n\\u2022 Browsing a catalog of items.  \\n\\u2022 Filtering the catalog.  \", \"\\n\\u2022 Ordering items from the catalog.  \\n\\u2022 Viewing the user\\u2019s order history.  \\n\\u2022 Configuration of setti\", \"ngs.   \\n5 CHAPTER 2 | Introduction to .NET MAUI  \\n Sample application architecture  \\nBelow is a high\", \" -level overview of the architecture of the sample application.  \\n \\nThe sample application ships wit\", \"h:  \\n\\u2022 .NET Aspire App Hosting & Orchestration  \\n\\u2022 An Blazor web application developed with ASP.NET \", \"Core.  \\n\\u2022 A multi -platform app developed with .NET MAUI, which supports iOS, Android, macOS via \\nMa\", \"c Catalyst, and Windows.  \\nThe sample application includes the following backend services:  \\n\\u2022 An id\", \"entity microservice, which uses ASP.NET Core Identity and IdentityServer.  \\n\\u2022 A catalog microservice\", \", which is a data -driven create, read, update, delete (CRUD) service that \\nconsumes an SQL Server d\", \"atabase using EntityFramework Core.  \\n\\u2022 An ordering microservice, which is a domain -driven service \", \"that uses domain -driven design \\npatterns.  \\n\\u2022 A basket microservice, which is a data -driven CRUD s\", \"ervice that uses Redis Cache.  \\nThese backend services are implemented as microservices using ASP.NE\", \"T Core, and are deployed as \\nunique containers with .NET Aspire. Collectively, these backend service\", \"s are referred to as the eShop \\nreference application. Client apps communicate with the ba ckend ser\", \"vices through a Representational \\nState Transfer (REST) web interface. For more information about mi\", \"croservices and conainers, see \\nContainerized microservices . \\n \\n6 CHAPTER 2 | Introduction to .NET \", \"MAUI  \\n Multi -Platform app  \\nThis guide focuses on building cross -platform enterprise apps using .\", \"NET MAUI, and uses the eShop \\nmulti -platform app as an example. The image below shows the pages fro\", \"m the eShop multi -platform \\napp that provide the functionality outlined earlier.  \\n \\nThe multi -pla\", \"tform app consumes the backend services provided by the eShop reference application. \\nHowever, it ca\", \"n be configured to consume data from mock services for those who wish to avoid \\ndeploying the backen\", \"d services.  \\nThe eShop multi -platform app exercises the following .NET MAUI functionality:  \\n \\n7 C\", \"HAPTER 2 | Introduction to .NET MAUI  \\n \\u2022 XAML  \\n\\u2022 Controls  \\n\\u2022 Bindings  \\n\\u2022 Converters  \\n\\u2022 Styles  \", \"\\n\\u2022 Animations  \\n\\u2022 Commands  \\n\\u2022 Behaviors  \\n\\u2022 Triggers  \\n\\u2022 Effects  \\n\\u2022 Custom Controls  \\nFor more inf\", \"ormation about this functionality, see the .NET MAUI documentation . \\nIn addition, unit tests are pr\", \"ovided for some of the classes in the eShop multi -platform app.  \\nMulti -Platform app solution  \\nTh\", \"e eShop multi -platform app solution organizes the source code and other resources into a multiple \\n\", \"projects. All of the core mobile components are contained in a singular project named \\neShopContaine\", \"rs. This is a feature introduced with .NET 6 that allows a project to target multiple \\noutputs which\", \" helps eliminate the need for multiple platform projects that we would have used in \\nXamarin.Forms a\", \"nd earlier .NET versions. An additional project is included for unit testing.  \\nWhile this project h\", \"as all of its components stored in a singular project, it is worth considering \\nseparating it into m\", \"ultiple projects based on your needs. For example, if you have multiple \\nimplementations of service \", \"providers based off of a service with their own dependencies, it may make \\nsense to break those serv\", \"ice provider implementations out into their own separate project. Good \\ncandidates for project separ\", \"ation include shared models, service implementations, api client \\ncomponents, database or caching  l\", \"ayers. Any place where you feel that the business could re -use a \\ncomponent in another project is a\", \" potential candidate for separation. These projects can then be \\npackaged via NuGet  for easy distri\", \"bution and versioning.  \\nAll of the projects use folders to organize the source code and other resou\", \"rces into categories. The \\nclasses from the eShop multi -platform app can be re -used in any .NET MA\", \"UI app with little or no \\nmodification.  \\neShop project  \\nThe eShop project contains the following f\", \"olders:  \\nFolder  Description  \\nAnimations  Contains classes that enable animations to be consumed i\", \"n XAML.  \\nBehaviors  Contains behaviors that are exposed to view classes.   \\n8 CHAPTER 2 | Introduct\", \"ion to .NET MAUI  \\n Folder  Description  \\nControls  Contains custom controls used by the app.  \\nConv\", \"erters  Contains value converters that apply custom logic to a binding.  \\nExceptions  Contains the c\", \"ustom ServiceAuthenticationException.  \\nExtensions  Contains extension methods for the VisualElement\", \" and IEnumerable<T> classes.  \\nHelpers  Contains helper classes for the app.  \\nModels  Contains the \", \"model classes for the app.  \\nProperties  Contains AssemblyInfo.cs, a .NET assembly metadata file.  \\n\", \"Services  Contains interfaces and classes that implement services that are provided to the \\napp. \\nTr\", \"iggers  Contains the BeginAnimation trigger, which is used to invoke an animation in XAML.  \\nValidat\", \"ions  Contains classes involved in validating data input.  \\nViewModels  Contains the application log\", \"ic that\\u2019s exposed to pages.  \\nViews  Contains the pages for the app.  \\nSummary  \\nMicrosoft\\u2019s cross -\", \"platform multi -platform app development tools and platforms provide a \\ncomprehensive solution for B\", \"2E, B2B, and B2C mobile client apps, providing the ability to share code \\nacross all target platform\", \"s (iOS, macOS, Android, and Windows) and helping to lower the total cost of \\nownership. Apps can sha\", \"re their user interface and app logic code, while retaining the native platform \\nlook and feel.  \\nDe\", \"velopers of enterprise apps face several challenges that can alter the architecture of the app durin\", \"g \\ndevelopment. Therefore, it\\u2019s important to build an app so that it can be modified or extended ove\", \"r \\ntime. Designing for such adaptability can be difficul t, but typically involves partitioning an a\", \"pp into \\ndiscrete, loosely coupled components that can be easily integrated together into an app.   \", \"\\n9 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n CHAP TER 3 \\nModel -View-ViewModel \\n(MVVM)  \\nThe .NET\", \" MAUI developer experience typically involves creating a user interface in XAML, and then \\nadding co\", \"de -behind that operates on the user interface. Complex maintenance issues can arise as \\napps are mo\", \"dified and grow in size and scope. These issues inc lude the tight coupling between the UI \\ncontrols\", \" and the business logic, which increases the cost of making UI modifications, and the difficulty \\nof\", \" unit testing such code.  \\nThe MVVM pattern helps cleanly separate an application\\u2019s business and pre\", \"sentation logic from its \\nuser interface (UI). Maintaining a clean separation between application lo\", \"gic and the UI helps address \\nnumerous development issues and makes an application ea sier to test, \", \"maintain, and evolve. It can \\nalso significantly improve code re -use opportunities and allows devel\", \"opers and UI designers to \\ncollaborate more easily when developing their respective parts of an app.\", \"  \\nThe MVVM pattern  \\nThere are three core components in the MVVM pattern: the model, the view, and \", \"the view model. \\nEach serves a distinct purpose. The diagram below shows the relationships between t\", \"he three \\ncomponents.  \\n \\nIn addition to understanding the responsibilities of each component, it\\u2019s \", \"also important to understand \\nhow they interact. At a high level, the view \\u201cknows about\\u201d the view mo\", \"del, and the view model \\u201cknows \\nabout\\u201d the model, but the model is unaware of the vi ew model, and t\", \"he view model is unaware of the \\nview. Therefore, the view model isolates the view from the model, a\", \"nd allows the model to evolve \\nindependently of the view.  \\nThe benefits of using the MVVM pattern a\", \"re as follows:  \\n \\n10 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n \\u2022 If an existing model implementa\", \"tion encapsulates existing business logic, it can be difficult or \\nrisky to change it. In this scena\", \"rio, the view model acts as an adapter for the model classes \\nand prevents you from making major cha\", \"nges to the model code.  \\n\\u2022 Developers can create unit tests for the view model and the model, witho\", \"ut using the view. \\nThe unit tests for the view model can exercise exactly the same functionality as\", \" used by the \\nview.  \\n\\u2022 The app UI can be redesigned without touching the view model and model code,\", \" provided \\nthat the view is implemented entirely in XAML or C#. Therefore, a new version of the view\", \" \\nshould work with the existing view model.  \\n\\u2022 Designers and developers can work independently and \", \"concurrently on their components \\nduring development. Designers can focus on the view, while develop\", \"ers can work on the view \\nmodel and model components.  \\nThe key to using MVVM effectively lies in un\", \"derstanding how to factor app code into the correct \\nclasses and how the classes interact. The follo\", \"wing sections discuss the responsibilities of each of the \\nclasses in the MVVM pattern.  \\nView  \\nThe\", \" view is responsible for defining the structure, layout, and appearance of what the user sees on \\nsc\", \"reen. Ideally, each view is defined in XAML, with a limited code -behind that does not contain \\nbusi\", \"ness logic. However, in some cases, the code -behind might contain UI logic that implements \\nvisual \", \"behavior that is difficult to expres s in XAML, such as animations.  \\nIn a .NET MAUI application, a \", \"view is typically a ContentPage -derived or ContentView -derived class. \\nHowever, views can also be \", \"represented by a data template, which specifies the UI elements to be \\nused to visually represent an\", \" object when it\\u2019s displayed. A  data template as a view does not have any \\ncode -behind, and is desi\", \"gned to bind to a specific view model type.  \\nTip \\nAvoid enabling and disabling UI elements in the c\", \"ode -behind.  \\nEnsure that the view models are responsible for defining logical state changes that a\", \"ffect some \\naspects of the view\\u2019s display, such as whether a command is available, or an indication \", \"that an \\noperation is pending. Therefore, enable and disable UI elements by binding to view model pr\", \"opert ies, \\nrather than enabling and disabling them in code -behind.  \\nThere are several options for\", \" executing code on the view model in response to interactions on the \\nview, such as a button click o\", \"r item selection. If a control supports commands, the control\\u2019s Command \\nproperty can be data -bound\", \" to an ICommand property on th e view model. When the control\\u2019s \\ncommand is invoked, the code in the\", \" view model will be executed. In addition to commands, \\nbehaviors can be attached to an object in th\", \"e view and can listen for either a command to be invoked \\nor the event to be raised. In re sponse, t\", \"he behavior can then invoke an ICommand on the view model \\nor a method on the view model.   \\n11 CHAP\", \"TER 3 | Model -View -ViewModel (MVVM)  \\n ViewModel  \\nThe view model implements properties and comman\", \"ds to which the view can data bind to, and \\nnotifies the view of any state changes through change no\", \"tification events. The properties and \\ncommands that the view model provides define the functionalit\", \"y to be off ered by the UI, but the view \\ndetermines how that functionality is to be displayed.  \\nTi\", \"p \\nKeep the UI responsive with asynchronous operations.  \\nMulti -platform apps should keep the UI th\", \"read unblocked to improve the user\\u2019s perception of \\nperformance. Therefore, in the view model, use a\", \"synchronous methods for I/O operations and raise \\nevents to asynchronously notify views of property \", \"changes.  \\nThe view model is also responsible for coordinating the view\\u2019s interactions with any mode\", \"l classes that \\nare required. There\\u2019s typically a one -to-many relationship between the view model a\", \"nd the model \\nclasses. The view model might choose to expose model cla sses directly to the view so \", \"that controls in \\nthe view can data bind directly to them. In this case, the model classes will need\", \" to be designed to \\nsupport data binding and change notification events.  \\nEach view model provides \", \"data from a model in a form that the view can easily consume. To \\naccomplish this, the view model so\", \"metimes performs data conversion. Placing this data conversion in \\nthe view model is a good idea bec\", \"ause it provides properties that the view can bind to. For example, \\nthe view model might combine th\", \"e values of two properties to make it easier to display by the view.  \\nTip \\nCentralize data conversi\", \"ons in a conversion layer.  \\nIt\\u2019s also possible to use converters as a separate data conversion laye\", \"r that sits between the view \\nmodel and the view. This can be necessary, for example, when data requ\", \"ires special formatting that \\nthe view model doesn\\u2019t provide.  \\nIn order for the view model to parti\", \"cipate in two -way data binding with the view, its properties must \\nraise the PropertyChanged event.\", \" View models satisfy this requirement by implementing the \\nINotifyPropertyChanged interface, and rai\", \"sing the PropertyChange d event when a property is \\nchanged.  \\nFor collections, the view -friendly O\", \"bservableCollection<T> is provided. This collection implements \\ncollection changed notification, rel\", \"ieving the developer from having to implement the \\nINotifyCollectionChanged interface on collections\", \".  \\nModel  \\nModel classes are non -visual classes that encapsulate the app\\u2019s data. Therefore, the mo\", \"del can be \\nthought of as representing the app\\u2019s domain model, which usually includes a data model a\", \"long with \\nbusiness and validation logic. Examples of model objects inc lude data transfer objects (\", \"DTOs), Plain \\nOld CLR Objects (POCOs), and generated entity and proxy objects.   \\n12 CHAPTER 3 | Mod\", \"el -View -ViewModel (MVVM)  \\n Model classes are typically used in conjunction with services or repos\", \"itories that encapsulate data \\naccess and caching.  \\nConnecting view models to views  \\nView models c\", \"an be connected to views by using the data -binding capabilities of .NET MAUI. There \\nare many appro\", \"aches that can be used to construct views and view models and associate them at \\nruntime. These appr\", \"oaches fall into two categories, known as view  first composition, and view model \\nfirst composition\", \". Choosing between view first composition and view model first composition is an \\nissue of preferenc\", \"e and complexity. However, all approaches share the same aim, which is for the view \\nto have a view \", \"model assigned to its BindingContext property.  \\nWith view first composition the app is conceptually\", \" composed of views that connect to the view \\nmodels they depend on. The primary benefit of this appr\", \"oach is that it makes it easy to construct \\nloosely coupled, unit testable apps because the view mod\", \"els hav e no dependence on the views \\nthemselves. It\\u2019s also easy to understand the structure of the \", \"app by following its visual structure, \\nrather than having to track code execution to understand how\", \" classes are created and associated. In \\naddition, view first const ruction aligns with the Microsof\", \"t Maui\\u2019s navigation system that\\u2019s responsible \\nfor constructing pages when navigation occurs, which \", \"makes a view model first composition complex \\nand misaligned with the platform.  \\nWith view model fi\", \"rst composition, the app is conceptually composed of view models, with a service \\nresponsible for lo\", \"cating the view for a view model. View model first composition feels more natural to \\nsome developer\", \"s, since the view creation can be abstra cted away, allowing them to focus on the \\nlogical non -UI s\", \"tructure of the app. In addition, it allows view models to be created by other view \\nmodels. However\", \", this approach is often complex, and it can become difficult to understand how the \\nvarious parts o\", \"f  the app are created and associated.  \\nTip \\nKeep view models and views independent.  \\nThe binding \", \"of views to a property in a data source should be the view\\u2019s principal dependency on its \\ncorrespond\", \"ing view model. Specifically, don\\u2019t reference view types, such as Button and ListView, from \\nview mo\", \"dels. By following the principles outlined her e, view models can be tested in isolation, \\ntherefore\", \" reducing the likelihood of software defects by limiting scope.  \\nThe following sections discuss the\", \" main approaches to connecting view models to views.  \\nCreating a view model declaratively  \\nThe sim\", \"plest approach is for the view to declaratively instantiate its corresponding view model in \\nXAML. W\", \"hen the view is constructed, the corresponding view model object will also be constructed. \\nThis app\", \"roach is demonstrated in the following code example : \\n<ContentPage xmlns:local=\\\"clr -namespace:eSho\", \"p\\\">  \\n    <ContentPage.BindingContext>   \\n13 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n         <l\", \"ocal:LoginViewModel  /> \\n    </ContentPage.BindingContext>  \\n    <!-- Omitted for brevity... --> \\n</\", \"ContentPage>  \\nWhen the ContentPage is created, an instance of the LoginViewModel is automatically c\", \"onstructed \\nand set as the view\\u2019s BindingContext.  \\nThis declarative construction and assignment of \", \"the view model by the view has the advantage that \\nit\\u2019s simple, but has the disadvantage that it req\", \"uires a default (parameter -less) constructor in the view \\nmodel.  \\nCreating a view model programmat\", \"ically  \\nA view can have code in the code -behind file, resulting in the view -model being assigned \", \"to its \\nBindingContext property. This is often accomplished in the view\\u2019s constructor, as shown in t\", \"he \\nfollowing code example:  \\npublic LoginView () \\n{ \\n    InitializeComponent (); \\n    BindingContex\", \"t  = new LoginViewModel (navigationService ); \\n} \\nThe programmatic construction and assignment of th\", \"e view model within the view\\u2019s code -behind has \\nthe advantage that it\\u2019s simple. However, the main d\", \"isadvantage of this approach is that the view \\nneeds to provide the view model with any required dep\", \"endencies . Using a dependency injection \\ncontainer can help to maintain loose coupling between the \", \"view and view model. For more \\ninformation, see Dependency injection . \\nUpdating views in response t\", \"o changes in the \\nunderlying view model or model  \\nAll view model and model classes that are accessi\", \"ble to a view should implement the \\n[INotifyPropertyChanged  interface. Implementing this interface \", \"in a view model or model class allows \\nthe class to provide change notifications to any data -bound \", \"controls in the view when the underlying \\nproperty value changes.  \\nApp\\u2019s should be architected for \", \"the correct use of property change notification, by meeting the \\nfollowing requirements:  \\n\\u2022 Always \", \"raising a PropertyChanged event if a public property\\u2019s value changes. Do not assume \\nthat raising th\", \"e PropertyChanged event can be ignored because of knowledge of how XAML \\nbinding occurs.  \\n\\u2022 Always \", \"raising a PropertyChanged event for any calculated properties whose values are used \\nby other proper\", \"ties in the view model or model.  \\n\\u2022 Always raising the PropertyChanged event at the end of the meth\", \"od that makes a property \\nchange, or when the object is known to be in a safe state. Raising the eve\", \"nt interrupts the  \\n14 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n operation by invoking the event\\u2019\", \"s handlers synchronously. If this happens in the middle of an \\noperation, it might expose the object\", \" to callback functions when it is in an unsafe, partially \\nupdated state. In addition, it\\u2019s possible\", \" for cascading changes to be triggered by \\nPropertyChanged events. Cascading changes generally requi\", \"re updates to be complete before \\nthe cascading change is safe to execute.  \\n\\u2022 Never raising a Prope\", \"rtyChanged event if the property does not change. This means that you \\nmust compare the old and new \", \"values before raising the PropertyChanged event.  \\n\\u2022 Never raising the PropertyChanged event during \", \"a view model\\u2019s constructor if you are \\ninitializing a property. Data -bound controls in the view wil\", \"l not have subscribed to receive \\nchange notifications at this point.  \\n\\u2022 Never raising more than on\", \"e PropertyChanged event with the same property name argument \\nwithin a single synchronous invocation\", \" of a public method of a class. For example, given a \\nNumberOfItems property whose backing store is \", \"the _numberOfItems field, if a m ethod \\nincrements _numberOfItems fifty times during the execution o\", \"f a loop, it should only raise \\nproperty change notification on the NumberOfItems property once, aft\", \"er all the work is \\ncomplete. For asynchronous methods, raise the PropertyChanged event for a given \", \"property \\nname in each synchronous segment of an asynchronous continuation chain.  \\nA simple way to \", \"provide this functionality would be to create an extension of the BindableObject class. \\nIn this exa\", \"mple, the ExtendedBindableObject class provides change notifications, which is shown in \\nthe followi\", \"ng code example:  \\npublic abstract  class ExtendedBindableObject  : BindableObject  \\n{ \\n    public v\", \"oid RaisePropertyChanged <T>(Expression <Func<T>> property ) \\n    { \\n        var name = GetMemberInf\", \"o (property ).Name; \\n        OnPropertyChanged (name); \\n    } \\n \\n    private MemberInfo  GetMemberIn\", \"fo (Expression  expression ) \\n    { \\n        // Omitted for brevity ...  \\n    } \\n} \\n.NET MAUI\\u2019s Bind\", \"ableObject class implements the INotifyPropertyChanged interface, and provides an \\nOnPropertyChanged\", \" method. The ExtendedBindableObject class provides the RaisePropertyChanged \\nmethod to invoke proper\", \"ty change notification, and in doing so uses the functionality provided by the \\nBindableObject class\", \".  \\nView model classes can then derive from the ExtendedBindableObject class. Therefore, each view \\n\", \"model class uses the RaisePropertyChanged method in the ExtendedBindableObject class to provide \\npro\", \"perty change notification. The following code example shows ho w the eShop multi -platform app \\ninvo\", \"kes property change notification by using a lambda expression:  \\npublic bool IsLogin \\n{ \\n    get => \", \"_isLogin ; \\n    set \\n    { \\n        _isLogin  = value; \\n        RaisePropertyChanged (() => IsLogin)\", \";  \\n15 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n     } \\n} \\nUsing a lambda expression in this way \", \"involves a small performance cost because the lambda \\nexpression has to be evaluated for each call. \", \"Although the performance cost is small and would not \\ntypically impact an app, the costs can accrue \", \"when there are many change notifications. However, the \\nbenefit of this approach is that it provides\", \" compile -time type safety and refactoring support when \\nrenaming properties.  \\nMVVM Frameworks  \\nTh\", \"e MVVM pattern is well established in .NET, and the community has created many frameworks \\nwhich hel\", \"p ease this development. Each framework provides a different set of features, but it is \\nstandard fo\", \"r them to provide a common view model with an implementa tion of the \\nINotifyPropertyChanged interfa\", \"ce. Additional features of MVVM frameworks include custom \\ncommands, navigation helpers, dependency \", \"injection/service locator components, and UI platform \\nintegration. While it is not necessary to use\", \" these framework s, they can speed up and standardize \\nyour development. The eShop multi -platform a\", \"pp uses the .NET Community MVVM Toolkit . When \\nchoosing a framework, you should consider your appli\", \"cation\\u2019s needs and your team\\u2019s strengths. The \\nlist below includes some of the more common MVVM fram\", \"eworks for .NET MAUI.  \\n\\u2022 .NET Community MVVM Toolkit  \\n\\u2022 ReactiveUI  \\n\\u2022 Prism Library  \\nUI interact\", \"ion using commands and behaviors  \\nIn multi -platform apps, actions are typically invoked in respons\", \"e to a user action, such as a button \\nclick, that can be implemented by creating an event handler in\", \" the code -behind file. However, in the \\nMVVM pattern, the responsibility for implementing the actio\", \"n lies with the view model, and placing \\ncode in the code -behind should be avoided.  \\nCommands prov\", \"ide a convenient way to represent actions that can be bound to controls in the UI. \\nThey encapsulate\", \" the code that implements the action and help to keep it decoupled from its visual \\nrepresentation i\", \"n the view. This way, your view models become  more portable to new platforms, as \\nthey do not have \", \"a direct dependency on events provided by the platform\\u2019s UI framework. .NET MAUI \\nincludes controls \", \"that can be declaratively connected to a command, and these controls will invoke \\nthe command when t\", \"he us er interacts with the control.  \\nBehaviors also allow controls to be declaratively connected t\", \"o a command. However, behaviors can be \\nused to invoke an action that\\u2019s associated with a range of e\", \"vents raised by a control. Therefore, \\nbehaviors address many of the same scenarios as command -enab\", \"led controls, while providing a \\ngreater degree of flexibility and control. In addition, behaviors c\", \"an also be used to associate command \\nobjects or methods with controls that were not specifically de\", \"signed to interact with commands.   \\n16 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n Implementing co\", \"mmands  \\nView models typically expose public properties, for binding from the view, which implement \", \"the \\nICommand interface. Many .NET MAUI controls and gestures provide a Command property, which can \", \"\\nbe data bound to an ICommand object provided by the view model. Th e button control is one of the \\n\", \"most commonly used controls, providing a command property that executes when the button is \\nclicked.\", \"  \\nNote  \\nWhile it\\u2019s possible to expose the actual implementation of the ICommand interface that you\", \"r view \\nmodel uses (for example, Command<T> or RelayCommand), it is recommended to expose your \\ncomm\", \"ands publicly as ICommand. This way, if you ever need to change the implementation at a later \\ndate,\", \" it can easily be swapped out.  \\nThe ICommand interface defines an Execute method, which encapsulate\", \"s the operation itself, a \\nCanExecute method, which indicates whether the command can be invoked, an\", \"d a \\nCanExecuteChanged event that occurs when changes occur that affect whether the command  should \", \"\\nexecute. In most cases, we will only supply the Execute method for our commands. For a more \\ndetail\", \"ed overview of ICommand, refer to the Commanding  documentation for .NET MAUI.  \\nProvided with .NET \", \"MAUI are the Command and Command<T> classes that implement the \\nICommand interface, where T is the t\", \"ype of the arguments to Execute and CanExecute. Command and \\nCommand<T> are basic implementations th\", \"at provide the minimal set of functiona lity needed for the \\nICommand interface.  \\nNote  \\nMany MVVM \", \"frameworks offer more feature rich implementations of the ICommand interface.  \\nThe Command or Comma\", \"nd<T> constructor requires an Action callback object that\\u2019s called when the \\nICommand.Execute method\", \" is invoked. The CanExecute method is an optional constructor parameter, \\nand is a Func that returns\", \" a bool.  \\nThe eShop multi -platform app uses the RelayCommand  and AsyncRelayCommand . The primary \", \"\\nbenefit for modern applications is that the AsyncRelayCommand provides better functionality for \\nas\", \"ynchronous operations.  \\nThe following code shows how a Command instance, which represents a registe\", \"r command, is \\nconstructed by specifying a delegate to the Register view model method:  \\npublic ICom\", \"mand  RegisterCommand { get; } \\nThe command is exposed to the view through a property that returns a\", \" reference to an ICommand. \\nWhen the Execute method is called on the Command object, it simply forwa\", \"rds the call to the method \\nin the view model via the delegate that was specified in the C ommand co\", \"nstructor. An asynchronous \\nmethod can be invoked by a command by using the async and await keywords\", \" when specifying the \\ncommand\\u2019s Execute delegate. This indicates that the callback is a Task and sho\", \"uld be awaited. For  \\n17 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n example, the following code sh\", \"ows how an ICommand instance, which represents a sign -in command, \\nis constructed by specifying a d\", \"elegate to the SignInAsync view model method:  \\npublic ICommand  SignInCommand { get; } \\n... \\nSignIn\", \"Command = new AsyncRelayCommand (async () => await SignInAsync ()); \\nParameters can be passed to the\", \" Execute and CanExecute actions by using the \\nAsyncRelayCommand<T> class to instantiate the command.\", \" For example, the following code shows \\nhow an AsyncRelayCommand<T> instance is used to indicate tha\", \"t the NavigateAsync method will \\nrequire an argument of type string:  \\npublic ICommand  NavigateComm\", \"and { get; } \\n \\n... \\nNavigateCommand = new AsyncRelayCommand <string>(NavigateAsync ); \\nIn both the \", \"RelayCommand and RelayCommand<T> classes, the delegate to the CanExecute method \\nin each constructor\", \" is optional. If a delegate isn\\u2019t specified, the Command will return true for \\nCanExecute. However, \", \"the view model can indicate a change in the co mmand\\u2019s CanExecute status by \\ncalling the ChangeCanEx\", \"ecute method on the Command object. This causes the CanExecuteChanged \\nevent to be raised. Any UI co\", \"ntrols bound to the command will then update their enabled status to \\nreflect the availability of th\", \"e data -bound command.  \\nInvoking commands from a view  \\nThe following code example shows how a Grid\", \" in the LoginView binds to the RegisterCommand in the \\nLoginViewModel class by using a TapGestureRec\", \"ognizer instance:  \\n<Grid Grid.Column= \\\"1\\\" HorizontalOptions= \\\"Center\\\" > \\n    <Label Text=\\\"REGISTER\\\"\", \"  TextColor= \\\"Gray\\\"/> \\n    <Grid.GestureRecognizers > \\n        <TapGestureRecognizer  Command= \\\"{Bin\", \"ding  RegisterCommand}\\\"  NumberOfTapsRequired= \\\"1\\\" \\n/> \\n    </Grid.GestureRecognizers > \\n</Grid> \\nA \", \"command parameter can also be optionally defined using the CommandParameter property. The \\ntype of t\", \"he expected argument is specified in the Execute and CanExecute target methods. The \\nTapGestureRecog\", \"nizer will automatically invoke the target command when the user interacts with the \\nattached contro\", \"l. The CommandParameter, if provided, will be passed as the argument to the \\ncommand\\u2019s Execute deleg\", \"ate.  \\nImplementing behaviors  \\nBehaviors allow functionality to be added to UI controls without hav\", \"ing to subclass them. Instead, the \\nfunctionality is implemented in a behavior class and attached to\", \" the control as if it was part of the \\ncontrol itself. Behaviors enable you to implement c ode that \", \"you would typically have to write as code -\\nbehind, because it directly interacts with the API of th\", \"e control, in such a way that it can be concisely  \\n18 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n \", \"attached to the control, and packaged for reuse across more than one view or app. In the context of \", \"\\nMVVM, behaviors are a useful approach for connecting controls to commands.  \\nA behavior that\\u2019s atta\", \"ched to a control through attached properties is known as an attached behavior . \\nThe behavior can t\", \"hen use the exposed API of the element to which it is attached to add functionality \\nto that control\", \", or other controls, in the visual tree of the view.  \\nA .NET MAUI behavior is a class that derives \", \"from the Behavior or Behavior<T> class, where T is the \\ntype of the control to which the behavior sh\", \"ould apply. These classes provide OnAttachedTo and \\nOnDetachingFrom methods, which should be overrid\", \"den to provid e logic that will be executed when \\nthe behavior is attached to and detached from cont\", \"rols.  \\nIn the eShop multi -platform app, the BindableBehavior<T> class derives from the Behavior<T>\", \" class. \\nThe purpose of the BindableBehavior<T> class is to provide a base class for .NET MAUI behav\", \"iors that \\nrequire the BindingContext of the behavior to be set to the attached control.  \\nThe Binda\", \"bleBehavior<T> class provides an overridable OnAttachedTo method that sets the \\nBindingContext of th\", \"e behavior, and an overridable OnDetachingFrom method that cleans up the \\nBindingContext.  \\nThe eSho\", \"p multi -platform app includes an EventToCommandBehavior  class which is provided by the \\nMAUI Commu\", \"nity toolkit. EventToCommandBehavior executes a command in response to an event \\noccurring. This cla\", \"ss derives from the BaseBehavior<View> class so that the behavior can bind to and \\nexecute an IComma\", \"nd specified by a Command property when the behavior is consumed. The \\nfollowing code example shows \", \"the EventToCommandBehavior class:  \\n/// <summary>  \\n/// The <see cref=\\\"EventToCommandBehavior\\\" /> is\", \" a behavior that allows the user to invoke a \\n<see cref=\\\"ICommand\\\" /> through an event. It is design\", \"ed to associate Commands to events \\nexposed by controls that were not designed to support Commands. \", \"It allows you to map any \\narbitrary event on a control to a Command.  \\n/// </summary>  \\npublic class\", \" EventToCommandBehavior : BaseBehavior <VisualElement > \\n{ \\n    // Omitted for brevity...  \\n \\n    //\", \"/ <inheritdoc/>  \\n    protected  override  void OnAttachedTo (VisualElement bindable ) \\n    { \\n     \", \"   base.OnAttachedTo (bindable ); \\n        RegisterEvent (); \\n    } \\n \\n    /// <inheritdoc/>  \\n    p\", \"rotected  override  void OnDetachingFrom (VisualElement bindable ) \\n    { \\n        UnregisterEvent (\", \"); \\n        base.OnDetachingFrom (bindable ); \\n    } \\n \\n    static void OnEventNamePropertyChanged (\", \"BindableObject bindable , object oldValue , object \\nnewValue ) \\n        => ((EventToCommandBehavior \", \")bindable ).RegisterEvent (); \\n \\n    void RegisterEvent () \\n    {  \\n19 CHAPTER 3 | Model -View -View\", \"Model (MVVM)  \\n         UnregisterEvent (); \\n \\n        var eventName = EventName ; \\n        if (View\", \" is null || string.IsNullOrWhiteSpace (eventName )) \\n        { \\n            return; \\n        } \\n \\n  \", \"      eventInfo = View.GetType()?.GetRuntimeEvent (eventName ) ?? \\n            throw new ArgumentExc\", \"eption ($\\\"{nameof(EventToCommandBehavior)}: Couldn't \\nresolve the event.\\\" , nameof(EventName )); \\n \\n\", \"        ArgumentNullException .ThrowIfNull (eventInfo .EventHandlerType ); \\n        ArgumentNullExce\", \"ption .ThrowIfNull (eventHandlerMethodInfo ); \\n \\n        eventHandler = eventHandlerMethodInfo .Crea\", \"teDelegate (eventInfo .EventHandlerType , \\nthis) ?? \\n            throw new ArgumentException ($\\\"{nam\", \"eof(EventToCommandBehavior)}: Couldn't create \\nevent handler.\\\" , nameof(EventName )); \\n \\n        eve\", \"ntInfo .AddEventHandler (View, eventHandler ); \\n    } \\n \\n    void UnregisterEvent () \\n    { \\n       \", \" if (eventInfo is not null && eventHandler is not null) \\n        { \\n            eventInfo .RemoveEve\", \"ntHandler (View, eventHandler ); \\n        } \\n \\n        eventInfo = null; \\n        eventHandler = nul\", \"l; \\n    } \\n \\n    /// <summary>  \\n    /// Virtual method that executes when a Command is invoked  \\n  \", \"  /// </summary>  \\n    /// <param name=\\\"sender\\\" ></param>  \\n    /// <param name=\\\"eventArgs\\\" ></param\", \">  \\n    [Microsoft .Maui.Controls .Internals .Preserve (Conditional = true)] \\n    protected  virtual\", \" void OnTriggerHandled (object? sender = null, object? eventArgs = \\nnull) \\n    { \\n        var parame\", \"ter = CommandParameter  \\n            ?? EventArgsConverter ?.Convert(eventArgs , typeof(object), nul\", \"l, null); \\n \\n        var command = Command; \\n        if (command?.CanExecute (parameter ) ?? false) \", \"\\n        { \\n            command.Execute(parameter ); \\n        } \\n    } \\n} \\nThe OnAttachedTo and OnDe\", \"tachingFrom methods are used to register and deregister an event \\nhandler for the event defined in t\", \"he EventName property. Then, when the event fires, the \\nOnTriggerHandled method is invoked, which ex\", \"ecutes the command.   \\n20 CHAPTER 3 | Model -View -ViewModel (MVVM)  \\n The advantage of using the Ev\", \"entToCommandBehavior to execute a command when an event fires, is \\nthat commands can be associated w\", \"ith controls that weren\\u2019t designed to interact with commands. In \\naddition, this moves event -handli\", \"ng code to view models, where it can be unit tested.  \\nInvoking behaviors from a view  \\nThe EventToC\", \"ommandBehavior is particularly useful for attaching a command to a control that \\ndoesn\\u2019t support com\", \"mands. For example, the LoginView uses the EventToCommandBehavior to \\nexecute the ValidateCommand wh\", \"en the user changes the value of their passwor d, as shown in the \\nfollowing code:  \\n<Entry \\n    IsP\", \"assword=\\\"True\\\"  \\n    Text=\\\"{Binding Password.Value, Mode=TwoWay}\\\">  \\n    <!-- Omitted for brevity...\", \" --> \\n    <Entry.Behaviors>  \\n        <mct:EventToCommandBehavior  \\n            EventName=\\\"TextChang\", \"ed\\\"  \\n            Command=\\\"{Binding ValidateCommand}\\\"  /> \\n    </Entry.Behaviors>  \\n    <!-- Omitted\", \" for brevity... --> \\n</Entry>  \\nAt runtime, the EventToCommandBehavior will respond to interaction w\", \"ith the Entry. When a user \\ntypes into the Entry field, the TextChanged event will fire, which will \", \"execute the ValidateCommand in \\nthe LoginViewModel. By default, the event arguments for th e event a\", \"re passed to the command. If \\nneeded, the EventArgsConverter property can be used to convert the Eve\", \"ntArgs provided by the event \\ninto a value that the command expects as input.  \\nFor more information\", \" about behaviors, see Behaviors  on the .NET MAUI Developer Center.  \\nSummary  \\nThe Model -View -Vie\", \"wModel (MVVM) pattern helps cleanly separate an application\\u2019s business and \\npresentation logic from \", \"its user interface (UI). Maintaining a clean separation between application \\nlogic and the UI helps \", \"address numerous development issues and makes an application easier to test, \\nmaintain, and evolve. \", \"It can also significantly improve code re -use opportunities and allows \\ndevelopers and UI designers\", \" to collaborate more easily when developing their respective parts of an \\napp. \\nUsing the MVVM patte\", \"rn, the UI of the app and the underlying presentation and business logic are \\nseparated into three s\", \"eparate classes: the view, which encapsulates the UI and UI logic; the view \\nmodel, which encapsulat\", \"es presentation logic and state; and t he model, which encapsulates the app\\u2019s \\nbusiness logic and da\", \"ta.   \\n21 CHAPTER 4 | Dependency injection  \\n CHAPTER  4 \\nDependency injection  \\nTypically, a class \", \"constructor is invoked when instantiating an object, and any values that the object \\nneeds are passe\", \"d as arguments to the constructor. This is an example of dependency injection known \\nas constructor \", \"injection . The dependencies the object needs are injected into the constructor.  \\nBy specifying dep\", \"endencies as interface types, dependency injection enables decoupling the concrete \\ntypes from the c\", \"ode that depends on these types. It generally uses a container that holds a list of \\nregistrations a\", \"nd mappings between interfaces and abstra ct types, and the concrete types that \\nimplement or extend\", \" these types.  \\nThere are also other types of dependency injection, such as property setter injectio\", \"n  and method call \\ninjection , but they are less commonly seen. Therefore, this chapter will focus \", \"solely on performing \\nconstructor injection with a dependency injection container.  \\nIntroduction to\", \" dependency injection  \\nDependency injection is a specialized version of the Inversion of Control (I\", \"oC) pattern, where the \\nconcern being inverted is the process of obtaining the required dependency. \", \"With dependency \\ninjection, another class is responsible for injecting dependencies into an object a\", \"t runtim e. The \\nfollowing code example shows how the ProfileViewModel class is structured when usin\", \"g dependency \\ninjection:  \\nprivate readonly  ISettingsService _settingsService ; \\nprivate readonly  \", \"IAppEnvironmentService _appEnvironmentService ; \\n \\npublic ProfileViewModel ( \\n    IAppEnvironmentSer\", \"vice appEnvironmentService , \\n    IDialogService dialogService ,  \\n    INavigationService navigation\", \"Service ,  \\n    ISettingsService settingsService ) \\n    : base(dialogService , navigationService , s\", \"ettingsService ) \\n{ \\n    _appEnvironmentService = appEnvironmentService ; \\n    _settingsService = se\", \"ttingsService ; \\n \\n    // Omitted for brevity  \\n} \\nThe ProfileViewModel constructor receives multipl\", \"e interface object instances as arguments injected \\nby another class. The only dependency in the Pro\", \"fileViewModel class is on the interface types. \\nTherefore, the ProfileViewModel class doesn\\u2019t have a\", \"ny knowle dge of the class that\\u2019s responsible for \\ninstantiating the interface objects. The class th\", \"at\\u2019s responsible for instantiating the interface objects, \\nand inserting it into the ProfileViewMode\", \"l class, is known as the dependency injection container .  \\n22 CHAPTER 4 | Dependency injection  \\n D\", \"ependency injection containers reduce the coupling between objects by providing a facility to \\ninsta\", \"ntiate class instances and manage their lifetime based on the configuration of the container. \\nDurin\", \"g object creation, the container injects any dependencies  that the object requires into it. If thos\", \"e \\ndependencies have not yet been created, the container creates and resolves their dependencies fir\", \"st.  \\nThere are several advantages to using a dependency injection container:  \\n\\u2022 A container remove\", \"s the need for a class to locate its dependencies and manage its lifetimes.  \\n\\u2022 A container allows t\", \"he mapping of implemented dependencies without affecting the class.  \\n\\u2022 A container facilitates test\", \"ability by allowing dependencies to be mocked.  \\n\\u2022 A container increases maintainability by allowing\", \" new classes to be easily added to the app.  \\nIn the context of a .NET MAUI app that uses MVVM, a de\", \"pendency injection container will typically be \\nused for registering and resolving views, registerin\", \"g and resolving view models, and for registering \\nservices and injecting them into view models.  \\nTh\", \"ere are many dependency injection containers available in .NET; the eShop multi -platform app uses \\n\", \"Microsoft.Extensions.DependencyInjection to manage the instantiation of views, view models, and \\nser\", \"vice classes in the app. Microsoft.Extensions.DependencyI njection facilitates building loosely \\ncou\", \"pled apps, and provides all of the features commonly found in dependency injection containers, \\nincl\", \"uding methods to register type mappings and object instances, resolve objects, manage object \\nlifeti\", \"mes, and inject d ependent objects into constructors of objects that it resolves. For more \\ninformat\", \"ion about Microsoft.Extensions.DependencyInjection, see Dependency injection in .NET . \\nIn .NET MAUI\", \", the MauiProgram class will call into the CreateMauiApp method to create a \\nMauiAppBuilder object. \", \"The MauiAppBuilder object has a Services property of type IServiceCollection, \\nwhich provides a plac\", \"e to register our components, such as views, view models, and services for \\ndependency injection. An\", \"y components registered with the Services property will be provided to the \\ndependency injection con\", \"tainer when the MauiAppBuilder.Build method is called.  \\nAt runtime, the container must know which i\", \"mplementation of the services are being requested in \\norder to instantiate them for the requested ob\", \"jects. In the eShop multi -platform app, the \\nIAppEnvironmentService, IDialogService , INavigationSe\", \"rvice, and ISett ingsService interfaces need to \\nbe resolved before it can instantiate a ProfileView\", \"Model object. This involves the container performing \\nthe following actions:  \\n\\u2022 Deciding how to ins\", \"tantiate an object that implements the interface. This is known as \\nregistration . \\n\\u2022 Instantiating \", \"the object that implements the required interface and the ProfileViewModel \\nobject. This is known as\", \" resolution . \\nEventually, the app will finish using the ProfileViewModel object, and it will become\", \" available for \\ngarbage collection. At this point, the garbage collector should dispose of any short\", \" -lived interface \\nimplementations if other classes do not share the same instance.   \\n23 CHAPTER 4 \", \"| Dependency injection  \\n Registration  \\nBefore dependencies can be injected into an object, the typ\", \"es of the dependencies must first be \\nregistered with the container. Registering a type involves pas\", \"sing the container an interface and a \\nconcrete type that implements the interface.  \\nThere are two \", \"ways of registering types and objects in the container through code:  \\n\\u2022 Register a type or mapping \", \"with the container. This is known as transient registration. When \\nrequired, the container will buil\", \"d an instance of the specified type.  \\n\\u2022 Register an existing object in the container as a singleton\", \". When required, the container will \\nreturn a reference to the existing object.  \\nNote  \\nDependency \", \"injection containers are not always suitable. Dependency injection introduces additional \\ncomplexity\", \" and requirements that might not be appropriate or useful to small apps. If a class does not \\nhave a\", \"ny dependencies, or is not a dependency for oth er types, it might not make sense to put it in \\nthe \", \"container. In addition, if a class has a single set of dependencies that are integral to the type an\", \"d \\nwill never change, it might not make sense to put it in the container.  \\nThe registration of type\", \"s requiring dependency injection should be performed in a single method in \\nan app. This method shou\", \"ld be invoked early in the app\\u2019s lifecycle to ensure it is aware of the \\ndependencies between its cl\", \"asses. The eShop multi -platform ap p performs this the \\nMauiProgram.CreateMauiApp method. The follo\", \"wing code example shows how the eShop multi -\\nplatform app declares the CreateMauiApp in the MauiPro\", \"gram class:  \\npublic static class MauiProgram  \\n{ \\n    public static MauiApp CreateMauiApp () \\n     \", \"   => MauiApp.CreateBuilder () \\n            .UseMauiApp <App>() \\n            // Omitted for brevity \", \"            \\n            .RegisterAppServices () \\n            .RegisterViewModels () \\n            .R\", \"egisterViews () \\n            .Build(); \\n} \\nThe MauiApp.CreateBuilder method creates a MauiAppBuilder\", \" object that we can use to register our \\ndependencies. Many dependencies in the eShop multi -platfor\", \"m app need to be registered, so the \\nextension methods RegisterAppServices, RegisterViewModels, and \", \"RegisterViews were created to help \\nprovide an  organized and maintainable registration workflow. Th\", \"e following code shows the \\nRegisterViewModels method:  \\npublic static MauiAppBuilder RegisterViewMo\", \"dels (this MauiAppBuilder mauiAppBuilder ) \\n{ \\n    mauiAppBuilder .Services .AddSingleton <ViewModel\", \"s .MainViewModel >(); \\n    mauiAppBuilder .Services .AddSingleton <ViewModels .LoginViewModel >(); \\n\", \"    mauiAppBuilder .Services .AddSingleton <ViewModels .BasketViewModel >(); \\n    mauiAppBuilder .Se\", \"rvices .AddSingleton <ViewModels .CatalogViewModel >(); \\n    mauiAppBuilder .Services .AddSingleton \", \"<ViewModels .ProfileViewModel >(); \\n  \\n24 CHAPTER 4 | Dependency injection  \\n     mauiAppBuilder .Se\", \"rvices .AddTransient <ViewModels .CheckoutViewModel >(); \\n    mauiAppBuilder .Services .AddTransient\", \" <ViewModels .OrderDetailViewModel >(); \\n    mauiAppBuilder .Services .AddTransient <ViewModels .Set\", \"tingsViewModel >(); \\n    mauiAppBuilder .Services .AddTransient <ViewModels .CampaignViewModel >(); \", \"\\n    mauiAppBuilder .Services .AddTransient <ViewModels .CampaignDetailsViewModel >(); \\n \\n    return\", \" mauiAppBuilder ; \\n} \\nThis method receives an instance of MauiAppBuilder, and we can use the Service\", \"s property to register \\nour view models. Depending on the needs of your application, you may need to\", \" add services with \\ndifferent lifetimes. The following table provides informatio n on when you may w\", \"ant to choose these \\ndifferent registration lifetimes:  \\nMethod  Description  \\nAddSingleton<T>  Will\", \" create a single instance of the object which \\nwill be remain for the lifetime of the application.  \", \"\\nAddTransient<T>  Will create a new instance of the object when \\nrequested during resolution. Transi\", \"ent objects \\ndo not have a pre -defined lifetime, but will \\ntypically follow the lifetime of their h\", \"ost.  \\nNote  \\nThe view models do not inherit from an interface, so they only need their concrete typ\", \"e provided to \\nthe AddSingleton<T> and AddTransient<T> methods.  \\nThe CatalogViewModel is used near \", \"the application\\u2019s root and should always be available, so \\nregistering it with AddSingleton<T> is be\", \"neficial. Other view models, such as CheckoutViewModel \\nand OrderDetailViewModel are situationally n\", \"avigated to or are used later in the application. Suppose \\nyou know that you have a component that m\", \"ay not always be used. In that case, if it is memory or \\ncomputationally intensive or requires just \", \"-in-time data, it may be a better candidate for \\nAddTransient<T> registration.  \\nAnother common way \", \"to add services is using the AddSingleton<TService, TImplementation> and \\nAddTransient<TService, TIm\", \"plementation> methods. These methods take two input types: the \\ninterface definition and the concret\", \"e implementation. This type of registra tion is best for cases where \\nyou are implementing services \", \"based on interfaces. In the code example below, we register our \\nISettingsService interface using th\", \"e SettingsService implementation:  \\npublic static MauiAppBuilder RegisterAppServices (this MauiAppBu\", \"ilder mauiAppBuilder ) \\n{ \\n    mauiAppBuilder .Services .AddSingleton <ISettingsService , SettingsSe\", \"rvice >(); \\n    // Omitted for brevity...  \\n} \\nOnce all services have been registered, the MauiAppBu\", \"ilder.Build method should be called to create \\nour MauiApp and populate our dependency injection con\", \"tainer with all the registered services.   \\n25 CHAPTER 4 | Dependency injection  \\n Important  \\nOnce \", \"the Build method has been called, the dependency injection container is immutable and can no \\nlonger\", \" be updated or modified. Ensure that all services that you need within your application have \\nbeen r\", \"egistered before you call Build.  \\nResolution  \\nAfter a type is registered, it can be resolved or in\", \"jected as a dependency. When a type is being \\nresolved, and the container needs to create a new inst\", \"ance, it injects any dependencies into the \\ninstance.  \\nGenerally, when a type is resolved, one of t\", \"hree things happens:  \\n1. If the type hasn\\u2019t been registered, the container throws an exception.  \\n2\", \". If the type has been registered as a singleton, the container returns the singleton instance. If \\n\", \"this is the first time the type is called for, the container creates it if required and maintains a \", \"\\nreference to it.  \\n3. If the type has been registered as transient, the container returns a new ins\", \"tance and doesn\\u2019t \\nmaintain a reference to it.  \\n.NET MAUI offers a number of ways to resolve regist\", \"ered components based on your needs. The most \\ndirect way to gain access to the dependency injection\", \" container is from an Element using the \\nHandler.MauiContext.Services. An example of this is shown b\", \"elow:  \\nvar settingsService = this.Handler.MauiContext .Services .GetServices <ISettingsService >();\", \" \\nThis can be helpful if you need to resolve a service from within an Element or from outside of the\", \" \\nconstructor of your Element.  \\nCaution  \\nThere is a possibility that the Handler property of your \", \"Element may be null, so be aware that you may \\nneed to handle those situations. For more information\", \", please refer to Handler lifecycle  on the \\nMicrosoft Documentation Center.  \\nIf using the Shell co\", \"ntrol for .NET MAUI, it will implicitly call into the dependency injection container \\nto create our \", \"objects during navigation. When setting up our Shell control, the Routing.RegisterRoute \\nmethod will\", \" tie a route path to a View as shown in the example below:  \\nRouting.RegisterRoute (\\\"Filter\\\" , typeo\", \"f(FiltersView )); \\nDuring Shell navigation, it will look for registrations of the FiltersView, and i\", \"f any are found, it will \\ncreate that view and inject any dependencies into the constructor. As show\", \"n in the code example \\nbelow, the CatalogViewModel will be injected into the FiltersView:  \\nnamespac\", \"e  eShop.Views; \\n \\npublic partial class FiltersView : ContentPage  \\n{  \\n26 CHAPTER 4 | Dependency in\", \"jection  \\n     public FiltersView (CatalogViewModel viewModel ) \\n    { \\n        BindingContext = vie\", \"wModel ; \\n \\n        InitializeComponent (); \\n    } \\n} \\n \\n \\nTip \\nThe dependency injection container i\", \"s great for creating view model instances. If a view model has \\ndependencies, it will handle the cre\", \"ation and injection of any required services. Just make sure that \\nyou register your view models and\", \" any dependencies that  they may have with the CreateMauiApp \\nmethod in the MauiProgram class.  \\nSum\", \"mary  \\nDependency injection enables the decoupling of concrete types from the code that depends on t\", \"hese \\ntypes. It typically uses a container that holds a list of registrations and mappings between i\", \"nterfaces \\nand abstract types, and the concrete types that implem ent or extend these types.  \\nMicro\", \"soft.Extensions.DependencyInjection facilitates building loosely coupled apps and provides all of \\nt\", \"he features commonly found in dependency injection containers, including methods to register type \\nm\", \"appings and object instances, resolve objects, manage  object lifetimes, and inject dependent object\", \"s \\ninto constructors of objects it resolves.   \\n27 CHAPTER 5 | Communicating between loosely coupled\", \" components  \\n CHAPTER  5 \\nCommunicating between \\nloosely coupled \\ncomponents  \\nThe publish -subscri\", \"be pattern is a messaging pattern in which publishers send messages without \\nknowing any receivers, \", \"known as subscribers. Similarly, subscribers listen for specific messages, \\nwithout knowing any publ\", \"ishers.  \\nEvents in .NET implement the publish -subscribe pattern and are the most simple approach f\", \"or a \\ncommunication layer between components if loose coupling is not required, such as a control an\", \"d the \\npage that contains it. However, the publisher and subscriber l ifetimes are coupled by object\", \" \\nreferences to each other, and the subscriber type must have a reference to the publisher type. Thi\", \"s \\ncan create memory management issues, especially when there are short -lived objects that subscrib\", \"e \\nto an event of a static or long-lived object. If the event handler isn\\u2019t removed, the subscriber \", \"will be \\nkept alive by the reference to it in the publisher, and this will prevent or delay the garb\", \"age collection \\nof the subscriber.  \\nIntroduction to MVVM Toolkit Messenger  \\nThe MVVM Toolkit IMess\", \"enger interface describes the publish -subscribe pattern, allowing message -\\nbased communication bet\", \"ween components that are inconvenient to link by object and type \\nreferences. This mechanism allows \", \"publishers and subscribers to communic ate without having a direct \\nreference to each other, helping\", \" to reduce dependencies between components, while also allowing \\ncomponents to be independently deve\", \"loped and tested.  \\nNote  \\nThe MVVM Toolkit Messenger is part of the CommunityToolkit.Mvvm package. \", \"For information on \\nhow to add the package to your project, see Introduction to the MVVM Toolkit  on\", \" the Microsoft \\nDeveloper Center.  \\n \\n  \\n28 CHAPTER 5 | Communicating between loosely coupled compon\", \"ents  \\n Warning  \\n.NET MAUI contains a built -in MessagingCenter class that\\u2019s no longer recommended \", \"for use. Use the \\nMVVM Toolkit Messenger instead.  \\nThe IMessenger interface allows for multicast pu\", \"blish -subscribe functionality. This means that there \\ncan be multiple publishers that publish a sin\", \"gle message, and there can be multiple subscribers \\nlistening to the same message. The image below i\", \"llustrates this relationship:  \\n \\nThere are two implementations of the IMessenger interface that com\", \"e with the \\nCommunityToolkit.Mvvm package. The WeakReferenceMessenger uses weak references which can\", \" \\nresult in easier cleanup for message subscribers. This is a good option if your subscriber s do no\", \"t have \\na clearly defined lifecycle. The StrongReferenceMessenger uses strong references which can r\", \"esult in \\nbetter performance and a more clearly controlled lifetime of the subscription. If you have\", \" a workflow \\nwith a very controlled lifetime (for ex ample, a subscription that is bound to a page\\u2019s\", \" OnAppearing and \\nOnDisappearing methods), the StrongReferenceManager may be a better option, if per\", \"formance is a \\nconcern. Both of these implementations are available with default implementations rea\", \"dy to use b y \\nreferencing either WeakReferenceMessenger.Default or StrongReferenceMessenger.Default\", \".  \\nNote  \\nWhile the IMessenger interface permits communication between loosely -coupled classes, it\", \" does not \\noffer the only architectural solution to this issue. For example, communication between a\", \" view model \\nand a view can also be achieved by the binding engine and  through property change noti\", \"fications. In \\naddition, communication between two view models can also be achieved by passing data \", \"during \\nnavigation.  \\nThe eShop multi -platform app uses the WeakReferenceMessenger class to communi\", \"cate between \\nloosely coupled components. The app defines a single message named AddProductMessage. \", \"The \\nAddProductMessage is published by the CatalogViewModel class when an item is added to the \\nshop\", \"ping basket. In return, the CatalogView class subscr ibes to the message and uses this to highlight \", \"\\nthe product adds with animation in response.  \\nIn the eShop multi -platform app, WeakReferenceMesse\", \"nger is used to update the UI in response to \\nan action occurring in another class. Therefore, messa\", \"ges are published from the thread that the class \\nis executing on, with subscribers receiving the me\", \"ssage o n the same thread.  \\n \\n29 CHAPTER 5 | Communicating between loosely coupled components  \\n Ti\", \"p \\nMarshal to the UI or main thread when performing UI updates. If updates to user interfaces are no\", \"t \\nmade on this thread, it can cause the application to crash or become unstable.  \\nIf a message tha\", \"t\\u2019s sent from a background thread is required to update the UI, process the message \\non the UI threa\", \"d in the subscriber by invoking the MainThread.BeginInvokeOnMainThread method.  \\nFor more informatio\", \"n about Messenger, see Messenger  on the Microsoft Developer Center.  \\nDefining a message  \\nIMesseng\", \"er messages are custom objects that provide custom payloads. The following code example \\nshows the A\", \"ddProductMessage message defined within the eShop multi -platform app:  \\npublic class AddProductMess\", \"age : ValueChangedMessage <int> \\n{ \\n    public AddProductMessage (int count) : base(count) \\n    { \\n \", \"   } \\n} \\nThe base class is defined using ValueChangedMessage<T> where T can be of any type needed to\", \" \\npass data. Both message publishers and subscribers can expect messages of a specific type (for \\nex\", \"ample, AddProductMessage). This can help ensure that both parties h ave agreed to a messaging \\ncontr\", \"act and that the data provided with that contract will be consistent. Additionally, this approach \\np\", \"rovides compile -time type safety and refactoring support.  \\nPublishing a message  \\nTo publish a mes\", \"sage, we will need to use the IMessenger.Send method. This can be accessed most \\ncommonly through We\", \"akReferenceMessenger.Default.Send or \\nStrongReferenceMessenger.Default.Send. The message sent can be\", \" of any object type. The following \\ncode ex ample demonstrates publishing the AddProduct message:  \\n\", \"WeakReferenceMessenger .Default.Send(new Messages .AddProductMessage (BadgeCount )); \\nIn this exampl\", \"e, the Send method specifies provides a new instance of the AddProductMessage object \\nfor downstream\", \" subscribers to receive. An additional second token parameter can be added to use \\nwhen multiple dif\", \"ferent subscribers need to receive messages of the same type without receiving the \\nwrong message.  \", \"\\nThe Send method will publish the message, and its payload data, using a fire -and-forget approach. \", \"\\nTherefore, the message is sent even if there are no subscribers registered to receive the message. \", \"In \\nthis situation, the sent message is ignored.   \\n30 CHAPTER 5 | Communicating between loosely cou\", \"pled components  \\n Subscribing to a message  \\nSubscribers can register to receive a message using on\", \"e of the IMessenger.Register<T> overloads. \\nThe following code example demonstrates how the eShop mu\", \"lti -platform app subscribes to, and \\nprocesses, the AddProductMessage message:  \\nWeakReferenceMesse\", \"nger .Default \\n    .Register <CatalogView , Messages .AddProductMessage >( \\n        this, \\n        a\", \"sync (recipient , message) => \\n        { \\n            await recipient .Dispatcher .DispatchAsync ( \\n\", \"                async () => \\n                { \\n                    await recipient .badge.ScaleTo(1\", \".2); \\n                    await recipient .badge.ScaleTo(1.0); \\n                }); \\n        }); \\nIn\", \" the preceding example, the Register method subscribes to the AddProductMessage message and \\nexecute\", \"s a callback delegate in response to receiving the message. This callback delegate, specified as \\na \", \"lambda expression, executes code that updates the UI.  \\nNote  \\nAvoid the use of this within your cal\", \"lback delegate to avoid capturing that object within the delegate. \\nThis can help improve performanc\", \"e. Instead, use the recipient parameter.  \\nIf payload data is supplied, don\\u2019t attempt to modify the \", \"payload data from within a callback delegate \\nbecause several threads could be accessing the receive\", \"d data simultaneously. In this scenario, the \\npayload data should be immutable to avoid concurrency \", \"errors.  \\nUnsubscribing from a message  \\nSubscribers can unsubscribe from messages they no longer wa\", \"nt to receive. This is achieved with one \\nof the IMessenger.Unregister overloads, as demonstrated in\", \" the following code example:  \\nWeakReferenceMessenger .Default.Unregister <Messages .AddProductMessa\", \"ge >(this); \\n \\n \\nNote  \\nIn this example, it isn\\u2019t fully necessary to call Unregister as the WeakRefe\", \"renceMessenger will allow \\nunused objects to be garbage collected. If the StrongReferenceMessenger w\", \"ere used, it would be \\nadvised to call Unregister for any subscriptions that are n o longer in use. \", \" \\nIn this example, the Unsubscribe method syntax specifies the type argument of the message and the \", \"\\nrecipient object that is listening for messages.   \\n31 CHAPTER 5 | Communicating between loosely co\", \"upled components  \\n Summary  \\nThe MVVM Toolkit IMessenger interface describes the publish -subscribe\", \" pattern, allowing message -\\nbased communication between components that are inconvenient to link by\", \" object and type \\nreferences. This mechanism allows publishers and subscribers to communic ate witho\", \"ut having a \\nreference to each other, helping to reduce dependencies between components, while also \", \"allowing \\ncomponents to be independently developed and tested.   \\n32 CHAPTER 6 | Navigation  \\n CHAPT\", \"ER  6 \\nNavigation  \\n.NET MAUI includes support for page navigation, which typically results from the\", \" user\\u2019s interaction \\nwith the UI or from the app itself as a result of internal logic -driven state \", \"changes. However, \\nnavigation can be complex to implement in apps that use the Model -View -ViewMode\", \"l (MVVM) \\npattern, as the following challenges must be met:  \\n\\u2022 Identifying the view to be navigated\", \" to using an approach that does not introduce tight \\ncoupling and dependencies between views.  \\n\\u2022 Co\", \"ordinating the process by which the view to be navigated to is instantiated and initialized. \\nWhen u\", \"sing MVVM, the view and view -model need to be instantiated and associated with \\neach other via the \", \"view\\u2019s binding context. When an app is using a dependency  injection \\ncontainer, the instantiation o\", \"f views and view -models might require a specific construction \\nmechanism.  \\n\\u2022 Whether to perform vi\", \"ew -first navigation, or view -model -first navigation. With view -first \\nnavigation, the page to na\", \"vigate to refers to the name of the view type. During navigation, \\nthe specified view is instantiate\", \"d, along with its corresponding view -mode l and other \\ndependent services. An alternative approach \", \"is to use view -model -first navigation, where the \\npage to navigate to refers to the name of the vi\", \"ew -model type.  \\n\\u2022 Determining how to cleanly separate the navigational behavior of the app across \", \"the views \\nand view -models. The MVVM pattern separates the app\\u2019s UI and its presentation and busine\", \"ss \\nlogic, but it doesn\\u2019t provide a direct mechanism for tying them together. H owever, the \\nnavigat\", \"ion behavior of an app will often span the UI and presentation parts of the app. The \\nuser will ofte\", \"n initiate navigation from a view, and the view will be replaced as a result of the \\nnavigation. How\", \"ever, navigation might often also need to be initiated or coordinated from \\nwithin the view -model. \", \" \\n\\u2022 Determining how to pass parameters during navigation for initialization purposes. For \\nexample, \", \"if the user navigates to a view to update order details, the order data will have to be \\npassed to t\", \"he view so that it can display the correct data.  \\n\\u2022 Coordinating navigation to ensure that specific\", \" business rules are obeyed. For example, users \\nmight be prompted before navigating away from a view\", \" so that they can correct any invalid \\ndata or be prompted to submit or discard any data changes tha\", \"t were made  within the view.  \\nThis chapter addresses these challenges by presenting a navigation s\", \"ervice class named \\nMauiNavigationService that\\u2019s used to perform view -model -first page navigation.\", \"  \\nNote  \\nThe MauiNavigationService used by the app is simplistic and does not cover all possible na\", \"vigation \\ntypes. The types of navigation needed by your application may require additional functiona\", \"lity.   \\n33 CHAPTER 6 | Navigation  \\n Navigating between pages  \\nNavigation logic can reside in a vi\", \"ew\\u2019s code -behind or a data -bound view -model. While placing \\nnavigation logic in a view might be t\", \"he most straightforward approach, it is not easily testable \\nthrough unit tests. Putting navigation \", \"logic in view -model classe s means that the logic can be verified \\nthrough unit tests. In addition,\", \" the view -model can then implement logic to control navigation to \\nensure that certain business rul\", \"es are enforced. For example, an app might not allow the user to \\nnavigate away from a p age without\", \" first ensuring that the entered data is valid.  \\nA navigation service is typically invoked from vie\", \"w -models, in order to promote testability. However, \\nnavigating to views from view -models would re\", \"quire the view -models to reference views, and \\nparticularly views that the active view -model isn\\u2019t\", \" associated with, which is not recommended. \\nTherefore, the MauiNavigationService presented here spe\", \"cifies the view -model type as the target to \\nnavigate to.  \\nThe eShop multi -platform app uses the \", \"MauiNavigationService class to provide view -model -first \\nnavigation. This class implements the INa\", \"vigationService interface, which is shown in the following \\ncode example:  \\npublic interface  INavig\", \"ationService  \\n{ \\n    Task InitializeAsync (); \\n \\n    Task NavigateToAsync (string route, IDictionar\", \"y <string, object> routeParameters = null); \\n \\n    Task PopAsync (); \\n} \\nThis interface specifies th\", \"at an implementing class must provide the following methods:  \\nMethod  Purpose  \\nInitializeAsync  Pe\", \"rforms navigation to one of two pages when \\nthe app is launched.  \\nNavigateToAsync(string route, \\nID\", \"ictionary<string, object> routeParameters = \\nnull) Performs hierarchical navigation to a specified \\n\", \"page using a registered navigation route. Can \\noptionally pass named route parameters to use \\nfor pr\", \"ocessing on the destination page  \\nPopAsync  Removes the current page from the navigation \\nstack.  \\n\", \"Note  \\nAn INavigationService interface would usually also specify a GoBackAsync method, which is use\", \"d to \\nprogrammatically return to the previous page in the navigation stack. However, this method is \", \"missing \\nfrom the eShop multi -platform app because it\\u2019s not required.   \\n34 CHAPTER 6 | Navigation \", \" \\n Creating the MauiNavigationService instance  \\nThe MauiNavigationService class, which implements t\", \"he INavigationService interface, is registered as a \\nsingleton with the dependency injection contain\", \"er in the MauiProgram.CreateMauiApp() method, as \\ndemonstrated in the following code example:  \\nmaui\", \"AppBuilder .Services .AddSingleton <INavigationService , MauiNavigationService >();; \\nThe INavigatio\", \"nService interface can then be resolved by adding it to the constructor of our views and \\nview-model\", \"s, as demonstrated in the following code example:  \\npublic AppShell (INavigationService navigationSe\", \"rvice ) \\nThis returns a reference to the MauiNavigationService object that\\u2019s stored in the dependenc\", \"y injection \\ncontainer.  \\nThe ViewModelBase class stores the MauiNavigationService instance in a Nav\", \"igationService property, \\nof type INavigationService. Therefore, all view -model classes, which deri\", \"ve from the ViewModelBase \\nclass, can use the NavigationService property to access th e methods spec\", \"ified by the \\nINavigationService interface.  \\nHandling navigation requests  \\n.NET MAUI provides mult\", \"iple ways to navigate within an application. The traditional way to navigate is \\nwith the Navigation\", \"Page class, which implements a hierarchical navigation experience in which the \\nuser can navigate th\", \"rough pages, forward and backward, as desired. The eShop app uses the Shell \\ncomponent as the root c\", \"ontainer for the application and as a navigation host. For more information \\nabout Shell navigation,\", \" see Shell Navigation  on the Microsoft Developer Center.  \\nNavigation is performed inside view -mod\", \"el classes by invoking one of the NavigateToAsync methods, \\nspecifying the route path for the page b\", \"eing navigated to, as demonstrated in the following code \\nexample:  \\nawait NavigationService .Naviga\", \"teToAsync (\\\"//Main\\\" ); \\nThe following code example shows the NavigateToAsync method provided by the \", \"\\nMauiNavigationService class:  \\npublic Task NavigateToAsync (string route, IDictionary <string, obje\", \"ct> routeParameters = \\nnull) \\n{ \\n    return \\n        routeParameters != null \\n            ? Shell.Cu\", \"rrent.GoToAsync (route, routeParameters ) \\n            : Shell.Current.GoToAsync (route); \\n} \\nThe .N\", \"ET MAUI Shell control is already familiar with route -based navigation, so the NavigateToAsync \\nmeth\", \"od works to mask this functionality. The NavigateToAsync method allows navigation data to be  \\n35 CH\", \"APTER 6 | Navigation  \\n specified as an argument that\\u2019s passed to the view -model being navigated to\", \", where it\\u2019s typically used \\nto perform initialization. For more information, see Passing parameters\", \" during navigation . \\nImportant  \\nThere are multiple ways to perform navigation in .NET MAUI. The Ma\", \"uiNavigationService is specifically \\nbuild to work with Shell. If you are using a NavigationPage or \", \"TabbedPage or a different navigation \\nmechanism, this routing service would have to be updat ed to w\", \"ork using those components.  \\nIn order to register routes for the MauiNavigationService we need to s\", \"upply route information from \\nXAML or in the code -behind. The following example shows registration \", \"of routes via XAML.  \\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF -8\\\" ?> \\n<Shell \\n    xmlns=\\\"http://schemas.mi\", \"crosoft.com/dotnet/2021/maui\\\"  \\n    xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\"  \\n    xml\", \"ns:views=\\\"clr -namespace:eShop.Views\\\"  \\n    x:Class=\\\"eShop.AppShell\\\">  \\n \\n    <!-- Omitted for brevi\", \"ty --> \\n \\n    <FlyoutItem >  \\n        <ShellContent x:Name=\\\"login\\\" ContentTemplate=\\\"{DataTemplate vi\", \"ews:LoginView}\\\" \\nRoute=\\\"Login\\\" />  \\n    </FlyoutItem>  \\n \\n    <TabBar x:Name=\\\"main\\\" Route=\\\"Main\\\">  \\n\", \"        <ShellContent Title=\\\"CATALOG\\\" Route=\\\"Catalog\\\" Icon= \\\"{StaticResource \\nCatalogIconImageSource\", \"}\\\" ContentTemplate=\\\"{DataTemplate views:CatalogView}\\\" />  \\n        <ShellContent Title=\\\"PROFILE\\\" Rou\", \"te=\\\"Profile\\\" Icon=\\\"{StaticResource \\nProfileIconImageSource}\\\" ContentTemplate=\\\"{DataTemplate views:Pr\", \"ofileView}\\\" />  \\n    </TabBar>  \\n</Shell>  \\nIn this example, the ShellContent and TabBar user interf\", \"ace objects are setting their Route property. \\nThis is the preferred method of registering routes fo\", \"r user interface objects that are controlled by a \\nShell.  \\nIf we have objects that will be added to\", \" the navigation stack at a later time, then we will need to add \\nthose via code -behind. The followi\", \"ng example show registration of routes in code -behind.  \\nRouting.RegisterRoute (\\\"Filter\\\" , typeof(F\", \"iltersView )); \\nRouting.RegisterRoute (\\\"Basket\\\" , typeof(BasketView )); \\nIn code -behind, we will ca\", \"ll the Routing.RegisterRoute method which takes a route name as the first \\nparameter and a view type\", \" as the second parameter. When a view -model uses the NavigationService \\nproperty to navigate, the a\", \"pplication\\u2019s Shell object will look for registered routes and push them onto \\nthe navigation stack. \", \" \\nAfter the view is created and navigated to, the ApplyQueryAttributes and InitializeAsync methods o\", \"f \\nthe view\\u2019s associated view -model are executed. For more information, see Passing parameters duri\", \"ng \\nnavigation .  \\n36 CHAPTER 6 | Navigation  \\n Navigating when the app is launched  \\nWhen the app i\", \"s launched, a Shell object is set as the root view of the application. Once set, the Shell \\nwill be \", \"used to control route registration and will be present at the root of our application going \\nforward\", \". Once the Shell has been created, we can wa it for it to be attached to the application using \\nthe \", \"OnParentSet method to initialize our navigation route. The following code example shows this \\nmethod\", \":  \\nprotected  override  async void OnParentSet () \\n{ \\n    base.OnParentSet (); \\n \\n    if (Parent is\", \" not null) \\n    { \\n        await _navigationService .InitializeAsync (); \\n    } \\n} \\nThe method uses \", \"an instance of INavigationService which is provided the constructor from \\ndependency injection and i\", \"nvokes its InitializeAsync method.  \\nThe following code example shows the implementation of the Maui\", \"NavigationService.InitializeAsync \\nmethod:  \\npublic Task InitializeAsync () \\n{ \\n    return NavigateT\", \"oAsync (string.IsNullOrEmpty (_settingsService .AuthAccessToken ) \\n        ? \\\"//Login\\\"  \\n        : \\\"\", \"//Main/Catalog\\\" ); \\n} \\nThe //Main/Catalog route is navigated to if the app has a cached access token\", \", which is used for \\nauthentication. Otherwise, the //Login route is navigated to.  \\nPassing paramet\", \"ers during navigation  \\nThe NavigateToAsync method, specified by the INavigationService interface, e\", \"nables navigation data \\nto be specified as an IDictionary<string, object> of data that\\u2019s passed to t\", \"he view -model being \\nnavigated to, where it\\u2019s typically used to perform initializa tion. \\nFor examp\", \"le, the ProfileViewModel class contains an OrderDetailCommand that\\u2019s executed when the \\nuser selects\", \" an order on the ProfileView page. In turn, this executes the OrderDetailAsync method, \\nwhich is sho\", \"wn in the following code example:  \\nprivate async Task OrderDetailAsync (Order order ) \\n{ \\n    if (o\", \"rder is null) \\n    { \\n        return; \\n    } \\n \\n    await NavigationService .NavigateToAsync ( \\n    \", \"    \\\"OrderDetail\\\" ,  \\n37 CHAPTER 6 | Navigation  \\n         new Dictionary <string, object>{ { \\\"Order\", \"Number\\\" , order.OrderNumber  } }); \\n} \\nThis method invokes navigation to the OrderDetail route, pass\", \"ing order number information the order \\nthat the user selected. When the dependency injection framew\", \"ork creates the OrderDetailView for the \\nOrderDetail route along with the OrderDetailViewModel class\", \" which is assigned to the view\\u2019s \\nBindingContext. The OrderDeta ilViewModel has an attribute added t\", \"o it that allows it to receive data \\nfrom the navigation service as shown in the code example below.\", \"  \\n[QueryProperty (nameof(OrderNumber ), \\\"OrderNumber\\\" )] \\npublic class OrderDetailViewModel : ViewM\", \"odelBase  \\n{ \\n    public int OrderNumber { get; set; } \\n} \\nThe QueryProperty attribute allows us to \", \"provide a parameter for a property to map values to and a \\nkey to find values from the query paramet\", \"ers dictionary. In this example, the key \\u201cOrderNumber\\u201d and \\norder number value were provided during \", \"the NavigateToAsy nc call. The view -model found the \\n\\u201cOrderNumber\\u201d key and mapped the value to the \", \"OrderNumber property. The OrderNumber property \\ncan then be used at a later time to retrieve the ful\", \"l order details from the OrderService instance.  \\nInvoking navigation using behaviors  \\nNavigation i\", \"s usually triggered from a view by a user interaction. For example, the LoginView performs \\nnavigati\", \"on following successful authentication. The following code example shows how the navigation \\nis invo\", \"ked by a behavior:  \\n<WebView> \\n    <WebView.Behaviors > \\n        <behaviors:EventToCommandBehavior \", \" \\n            EventName= \\\"Navigating\\\"  \\n            EventArgsConverter= \\\"{StaticResource  WebNavigat\", \"ingEventArgsConverter}\\\"  \\n            Command= \\\"{Binding  NavigateCommand}\\\"  /> \\n    </WebView.Behav\", \"iors > \\n</WebView> \\nAt runtime, the EventToCommandBehavior will respond to interaction with the WebV\", \"iew. When the \\nWebView navigates to a web page, the Navigating event will fire, which will execute t\", \"he \\nNavigateCommand in the LoginViewModel. By default, the event arguments for  the event are passed\", \" \\nto the command. This data is converted as it\\u2019s passed between source and target by the converter \\n\", \"specified in the EventArgsConverter property, which returns the Url from the \\nWebNavigatingEventArgs\", \". Therefore, when the NavigationComman d is executed, the Url of the web \\npage is passed as a parame\", \"ter to the registered Action.  \\nIn turn, the NavigationCommand executes the NavigateAsync method, wh\", \"ich is shown in the \\nfollowing code example:  \\nprivate async Task NavigateAsync (string url) \\n{ \\n   \", \" // Omitted for brevity.  \\n    if (!string.IsNullOrWhiteSpace (accessToken )) \\n    {  \\n38 CHAPTER 6 \", \"| Navigation  \\n         _settingsService .AuthAccessToken  = accessToken ; \\n        _settingsService\", \" .AuthIdToken  = authResponse .IdentityToken ; \\n        await NavigationService .NavigateToAsync (\\\"/\", \"/Main/Catalog\\\" ); \\n    } \\n} \\nThis method invokes NavigationService route the application to the //Ma\", \"in/Catalog route.  \\nConfirming or cancelling navigation  \\nAn app might need to interact with the use\", \"r during a navigation operation, so that the user can \\nconfirm or cancel navigation. This might be n\", \"ecessary, for example, when the user attempts to \\nnavigate before having fully completed a data entr\", \"y page. In this situation, an app should provide a \\nnotification that allows the user to navigate aw\", \"ay from the page, or to cancel the navigation operation \\nbefore it occurs. This can be achieved in a\", \" view -model class by using the response from a notification \\nto control whe ther or not navigation \", \"is invoked.  \\nSummary  \\n.NET MAUI includes support for page navigation, which typically results from\", \" the user\\u2019s interaction \\nwith the UI, or from the app itself, as a result of internal logic -driven \", \"state changes. However, \\nnavigation can be complex to implement in apps that use th e MVVM pattern. \", \" \\nThis chapter presented a NavigationService class, which is used to perform view -model -first \\nnav\", \"igation from view -models. Placing navigation logic in view -model classes means that the logic can \", \"\\nbe exercised through automated tests. In addition, the view -model can then implement logic to \\ncon\", \"trol navigation to ensure that certain business rules are enforced.   \\n39 CHAPTER 7 | Validation  \\n \", \"CHAPTER  7 \\nValidation  \\nAny app that accepts input from users should ensure that the input is valid\", \". An app could, for \\nexample, check for input that contains only characters in a particular range, i\", \"s of a certain length, or \\nmatches a particular format. Without validation, a user can supply data t\", \"hat causes the app to fail. \\nProper validation enforces business rules and could help to prevent an \", \"attacker from injecting \\nmalicious data.  \\nIn the context of the Model -View -ViewModel (MVVM) patte\", \"rn, a view model or model will often be \\nrequired to perform data validation and signal any validati\", \"on errors to the view so that the user can \\ncorrect them. The eShop multi -platform app performs syn\", \"chro nous client -side validation of view \\nmodel properties and notifies the user of any validation \", \"errors by highlighting the control that \\ncontains the invalid data, and by displaying error messages\", \" that inform the user of why the data is \\ninvalid. The image belo w shows the classes involved in pe\", \"rforming validation in the eShop multi -\\nplatform app.  \\n \\nView model properties that require valida\", \"tion are of type ValidatableObject<T>, and each \\nValidatableObject<T> instance has validation rules \", \"added to its Validations property. Validation is \\n \\n40 CHAPTER 7 | Validation  \\n invoked from the vi\", \"ew model by calling the Validate method of the ValidatableObject<T> instance, \\nwhich retrieves the v\", \"alidation rules and executes them against the ValidatableObject<T>.Value \\nproperty. Any validation e\", \"rrors are placed into the Errors proper ty of the ValidatableObject<T> \\ninstance, and the IsValid pr\", \"operty of the ValidatableObject<T> instance is updated to indicate \\nwhether the validation succeeded\", \" or failed. The following code shows the implementation of the \\nValidatableObject<T>:  \\nusing Commun\", \"ityToolkit .Mvvm.ComponentModel ; \\nnamespace  eShop.Validations ; \\npublic class ValidatableObject <T\", \"> : ObservableObject , IValidity  \\n{ \\n    private IEnumerable <string> _errors; \\n    private bool _i\", \"sValid ; \\n    private T _value ; \\n    public List<IValidationRule <T>> Validations { get; } = new();\", \" \\n    public IEnumerable <string> Errors \\n    { \\n        get => _errors; \\n        private set => Set\", \"Property (ref _errors, value); \\n    } \\n    public bool IsValid \\n    { \\n        get => _isValid ; \\n  \", \"      private set => SetProperty (ref _isValid , value); \\n    } \\n    public T Value \\n    { \\n        \", \"get => _value; \\n        set => SetProperty (ref _value, value); \\n    } \\n    public ValidatableObject\", \" () \\n    { \\n        _isValid = true; \\n        _errors = Enumerable .Empty<string>(); \\n    } \\n    pub\", \"lic bool Validate () \\n    { \\n        Errors = Validations  \\n            ?.Where(v => !v.Check(Value)\", \") \\n            ?.Select(v => v.ValidationMessage ) \\n            ?.ToArray() \\n            ?? Enumerab\", \"le .Empty<string>(); \\n        IsValid = !Errors.Any(); \\n        return IsValid; \\n    } \\n} \\nProperty \", \"change notification is provided by the ObservableObject class, and so an Entry control can \\nbind to \", \"the IsValid property of ValidatableObject<T> instance in the view model class to be notified of \\nwhe\", \"ther or not the entered data is valid.  \\nSpecifying validation rules  \\nValidation rules are specifie\", \"d by creating a class that derives from the IValidationRule<T> interface, \\nwhich is shown in the fol\", \"lowing code example:   \\n41 CHAPTER 7 | Validation  \\n public interface  IValidationRule <T> \\n{ \\n    s\", \"tring ValidationMessage  { get; set; } \\n    bool Check(T value); \\n} \\nThis interface specifies that a\", \" validation rule class must provide a boolean Check method that is used \\nto perform the required val\", \"idation, and a ValidationMessage property whose value is the validation \\nerror message that will be \", \"displayed if validation fai ls. \\nThe following code example shows the IsNotNullOrEmptyRule<T> valida\", \"tion rule, which is used to \\nperform validation of the username and password entered by the user on \", \"the LoginView when using \\nmock services in the eShop multi -platform app:  \\npublic class IsNotNullOr\", \"EmptyRule <T> : IValidationRule <T> \\n{ \\n    public string ValidationMessage  { get; set; } \\n \\n    pu\", \"blic bool Check(T value) => \\n        value is string str && !string.IsNullOrWhiteSpace (str); \\n} \\nTh\", \"e Check method returns a boolean indicating whether the value argument is null, empty, or consists \\n\", \"only of whitespace characters.  \\nAlthough not used by the eShop multi -platform app, the following c\", \"ode example shows a validation \\nrule for validating email addresses:  \\npublic class EmailRule <T> : \", \"IValidationRule <T> \\n{ \\n    private readonly  Regex _regex = new(@\\\"^([w.-]+)@([w-]+)((.(w){2,3})+)$\\\"\", \" ); \\n \\n    public string ValidationMessage  { get; set; } \\n \\n    public bool Check(T value) => \\n    \", \"    value is string str && _regex.IsMatch(str); \\n} \\nThe Check method returns a boolean indicating wh\", \"ether or not the value argument is a valid email \\naddress. This is achieved by searching the value a\", \"rgument for the first occurrence of the regular \\nexpression pattern specified in the Regex construct\", \"or. Whether the regu lar expression pattern has \\nbeen found in the input string can be determined by\", \" checking the value against Regex.IsMatch . \\nNote  \\nProperty validation can sometimes involve depend\", \"ent properties. An example of dependent \\nproperties is when the set of valid values for property A d\", \"epends on the particular value that has been \\nset in property B. To check that the value of property\", \" A is one of the allowed values would involve \\nretrieving the value of property B. In addition, when\", \" the value of property B changes, property A \\nwould need to be revalidated.   \\n42 CHAPTER 7 | Valida\", \"tion  \\n Adding validation rules to a property  \\nIn the eShop multi -platform app, view model propert\", \"ies that require validation are declared to be of \\ntype ValidatableObject<T>, where T is the type of\", \" the data to be validated. The following code \\nexample shows an example of two such properties:  \\npu\", \"blic ValidatableObject <string> UserName { get; private set; } \\npublic ValidatableObject <string> Pa\", \"ssword { get; private set; } \\nFor validation to occur, validation rules must be added to the Validat\", \"ions collection of \\neach ValidatableObject<T> instance, as demonstrated in the following code exampl\", \"e:  \\nprivate void AddValidations () \\n{ \\n    UserName .Validations .Add(new IsNotNullOrEmptyRule <str\", \"ing>  \\n    {  \\n        ValidationMessage  = \\\"A username  is required.\\\"   \\n    }); \\n \\n    Password .V\", \"alidations .Add(new IsNotNullOrEmptyRule <string>  \\n    {  \\n        ValidationMessage  = \\\"A password\", \"  is required.\\\"   \\n    }); \\n} \\nThis method adds the IsNotNullOrEmptyRule<T> validation rule to the V\", \"alidations collection of each \\nValidatableObject<T> instance, specifying values for the validation r\", \"ule\\u2019s ValidationMessage property, \\nwhich specifies the validation error message that will be display\", \"ed if validation fails.  \\nTriggering validation  \\nThe validation approach used in the eShop multi -p\", \"latform app can manually trigger validation of a \\nproperty, and automatically trigger validation whe\", \"n a property changes.  \\nTriggering validation manually  \\nValidation can be triggered manually for a \", \"view model property. For example, this occurs in the eShop \\nmulti -platform app when the user taps t\", \"he Login button on the LoginView, when using mock services. \\nThe command delegate calls the MockSign\", \"InAsync method i n the LoginViewModel, which invokes \\nvalidation by executing the Validate method, w\", \"hich is shown in the following code example:  \\nprivate bool Validate () \\n{ \\n    bool isValidUser  = \", \"ValidateUserName (); \\n    bool isValidPassword  = ValidatePassword (); \\n    return isValidUser  && i\", \"sValidPassword ; \\n} \\n \\nprivate bool ValidateUserName () \\n{ \\n    return _userName .Validate (); \\n} \\n \", \"\\nprivate bool ValidatePassword () \\n{  \\n43 CHAPTER 7 | Validation  \\n     return _password .Validate (\", \"); \\n} \\nThe Validate method performs validation of the username and password entered by the user on t\", \"he \\nLoginView, by invoking the Validate method on each ValidatableObject<T> instance. The following \", \"\\ncode example shows the Validate method from the ValidatableObjec t<T> class:  \\npublic bool Validate\", \" () \\n{ \\n    Errors = _validations  \\n        ?.Where(v => !v.Check(Value)) \\n        ?.Select(v => v.V\", \"alidationMessage ) \\n        ?.ToArray() \\n        ?? Enumerable .Empty<string>(); \\n \\n    IsValid = !E\", \"rrors.Any(); \\n \\n    return IsValid; \\n} \\nThis method retrieves any validation rules that were added t\", \"o the object\\u2019s Validations collection. The \\nCheck method for each retrieved validation rule is execu\", \"ted, and the ValidationMessage property \\nvalue for any validation rule that fails to validate the da\", \"ta is added to the Error s collection of the \\nValidatableObject<T> instance. Finally, the IsValid pr\", \"operty is set, and its value is returned to the \\ncalling method, indicating whether validation succe\", \"eded or failed.  \\nTriggering validation when properties change  \\nValidation is also automatically tr\", \"iggered whenever a bound property changes. For example, when a \\ntwo-way binding in the LoginView set\", \"s the UserName or Password property, validation is triggered. \\nThe following code example demonstrat\", \"es how this occurs:  \\n<Entry Text=\\\"{Binding  UserName.Value,  Mode=TwoWay}\\\" > \\n    <Entry.Behaviors \", \"> \\n        <behaviors:EventToCommandBehavior  \\n            EventName= \\\"TextChanged\\\"  \\n            Co\", \"mmand= \\\"{Binding  ValidateUserNameCommand}\\\"  /> \\n    </Entry.Behaviors > \\n</Entry> \\nThe Entry contro\", \"l binds to the UserName.Value property of the ValidatableObject<T> instance, and \\nthe control\\u2019s Beha\", \"viors collection has an EventToCommandBehavior instance added to it. This \\nbehavior executes the Val\", \"idateUserNameCommand in response to the TextChanged event firing on \\nthe E ntry, which is raised whe\", \"n the text in the Entry changes. In turn, the ValidateUserNameCommand \\ndelegate executes the Validat\", \"eUserName method, which executes the Validate method on the \\nValidatableObject<T> instance. Therefor\", \"e, every time the user enters a c haracter in the Entry control \\nfor the username, validation of the\", \" entered data is performed.  \\nDisplaying validation errors  \\nThe eShop multi -platform app notifies \", \"the user of any validation errors by highlighting the control \\nthat contains the invalid data with a\", \" red background, and by displaying an error message that informs  \\n44 CHAPTER 7 | Validation  \\n the \", \"user why the data is invalid below the control containing the invalid data. When the invalid data is\", \" \\ncorrected, the background changes back to the default state and the error message is removed. The \", \"\\nimage below shows the LoginView in the eShop multi -platform app when validation errors are \\npresen\", \"t.  \\n \\nHighlighting a control that contains invalid data  \\n.NET MAUI offers a number of ways to pres\", \"ent validation information to end-users, but one of the \\nmost straight -forward ways is through the \", \"use of Triggers. Triggers provide us a way to change the \\nstate of our controls, typically for appea\", \"rance, based on an event or data change that occurs for a \\ncontrol. For validation, we wil l be usin\", \"g a DataTrigger which will listen to changes raised from a bound \\nproperty and respond to the change\", \"s. The Entry controls on the LoginView are setup using the \\nfollowing code:  \\n<Entry Text=\\\"{Binding \", \"UserName.Value, Mode=TwoWay}\\\" > \\n    <Entry.Style > \\n        <OnPlatform  x:TypeArguments= \\\"Style\\\"> \", \"\\n            <On Platform= \\\"iOS, Android\\\"  Value=\\\"{StaticResource EntryStyle}\\\"  /> \\n            <On \", \"Platform= \\\"WinUI\\\" Value=\\\"{StaticResource WinUIEntryStyle}\\\"  /> \\n        </OnPlatform > \\n    </Entry.\", \"Style > \\n    <Entry.Behaviors > \\n        <mct:EventToCommandBehavior  \\n            EventName= \\\"TextC\", \"hanged\\\"  \\n            Command= \\\"{Binding ValidateCommand}\\\"  /> \\n    </Entry.Behaviors > \\n    <Entry.\", \"Triggers > \\n        <DataTrigger   \\n            TargetType= \\\"Entry\\\" \\n            Binding= \\\"{Binding \", \"UserName.IsValid}\\\"  \\n            Value=\\\"False\\\"> \\n            <Setter Property= \\\"BackgroundColor\\\"  Va\", \"lue=\\\"{StaticResource ErrorColor}\\\"  /> \\n        </DataTrigger > \\n    </Entry.Triggers > \\n</Entry> \\nTh\", \"e DataTrigger specifies the following properties:  \\n \\n45 CHAPTER 7 | Validation  \\n Property  Descrip\", \"tion  \\nTargetType  The control type that the trigger belongs to.  \\nBinding  The data Binding markup \", \"which will provide \\nchange notifications and value for the trigger \\ncondition.  \\nValue  The data val\", \"ue to specify when the trigger\\u2019s \\ncondition has been met.  \\nFor this Entry, we will be listening for\", \" changes to the LoginViewModel.UserName.IsValid property. \\nEach time this property raises a change, \", \"the value will be compared against the Value property set in \\nthe DataTrigger. If the values are equ\", \"al, then the trigg er condition will be met and any Setter objects \\nprovided to the DataTrigger will\", \" be executed. This control has a single Setter object that updates the \\nBackgroundColor property to \", \"a custom color defined using the StaticResource markup. When a \\nTrigger condit ion is no longer met,\", \" the control will revert the properties set by the Setter object to \\ntheir previous state. For more \", \"information about Triggers, see .NET MAUI Docs: Triggers . \\nDisplaying error messages  \\nThe UI displ\", \"ays validation error messages in Label controls below each control whose data failed \\nvalidation. Th\", \"e following code example shows the Label that displays a validation error message, if the \\nuser has \", \"not entered a valid username:  \\n<Label \\n    \\nText=\\\"{Binding  UserName.Errors,  Converter={StaticReso\", \"urce  FirstValidationErrorConverter}\\\"  \\n    Style=\\\"{StaticResource  ValidationErrorLabelStyle}\\\"  /> \", \"\\nEach Label binds to the Errors property of the view model object that\\u2019s being validated. The Errors\", \" \\nproperty is provided by the ValidatableObject<T> class, and is of type IEnumerable<string>. Becaus\", \"e \\nthe Errors property can contain multiple validation erro rs, the FirstValidationErrorConverter in\", \"stance is \\nused to retrieve the first error from the collection for display.  \\nSummary  \\nThe eShop m\", \"ulti -platform app performs synchronous client -side validation of view model properties \\nand notifi\", \"es the user of any validation errors by highlighting the control that contains the invalid data, \\nan\", \"d by displaying error messages that inform the user why the data is invalid.  \\nView model properties\", \" that require validation are of type ValidatableObject<T>, and each \\nValidatableObject<T> instance h\", \"as validation rules added to its Validations property. Validation is \\ninvoked from the view model by\", \" calling the Validate method of the V alidatableObject<T> instance, \\nwhich retrieves the validation \", \"rules and executes them against the ValidatableObject<T> Value \\nproperty. Any validation errors are \", \"placed into the Errors property of the ValidatableObject<T> \\ninstance, and the IsValid property o f \", \"the ValidatableObject<T> instance is updated to indicate \\nwhether validation succeeded or failed.   \", \"\\n46 CHAPTER 8 | Application settings management  \\n CHAPTER  8 \\nApplication settings \\nmanagement  \\nSe\", \"ttings allow the separation of data that configures the behavior of an app from the code, allowing \\n\", \"the behavior to be changed without rebuilding the app. There are two types of settings: app settings\", \" \\nand user settings.  \\nApp settings are data that an app creates and manages. It can include data su\", \"ch as fixed web service \\nendpoints, API keys, and runtime state. App settings are tied to core funct\", \"ionality and are only \\nmeaningful to that app.  \\nUser settings are the customizable settings of an a\", \"pp that affect the app\\u2019s behavior and don\\u2019t require \\nfrequent re -adjustment. For example, an app mi\", \"ght let the user specify where to retrieve data and \\nhow to display it on the screen.  \\nCreating a S\", \"ettings Interface  \\nWhile the preferences manager can be used directly in your application, it does \", \"come with the \\ndrawback of making your application tightly coupled to the preferences manager implem\", \"entation. \\nThis coupling means that creating unit tests or extending the funct ionality of preferenc\", \"es \\nmanagement will be limited since your application will not have a direct way to intercept the be\", \"havior. \\nTo address this concern, an interface can be created to work as a proxy for preferences man\", \"agement. \\nThe interface will allow us to supply an implementation that fits our needs. For example, \", \"when writing \\na unit test, we may want to set specific settings, and the interface will give us an e\", \"asy way to \\nconsistently set this data for the test. The following code example shows the ISetti ngs\", \"Service interface \\nin the eShop multi -platform app:  \\nnamespace  eShop.Services .Settings ; \\n \\npubl\", \"ic interface  ISettingsService  \\n{ \\n    string AuthAccessToken { get; set; } \\n    string AuthIdToken\", \" { get; set; } \\n    bool UseMocks { get; set; } \\n    string IdentityEndpointBase { get; set; } \\n    \", \"string GatewayShoppingEndpointBase { get; set; } \\n    string GatewayMarketingEndpointBase { get; set\", \"; } \\n    bool UseFakeLocation { get; set; } \\n    string Latitude { get; set; } \\n    string Longitude\", \" { get; set; }  \\n47 CHAPTER 8 | Application settings management  \\n     bool AllowGpsLocation { get; \", \"set; } \\n} \\nAdding Settings  \\n.NET MAUI includes a preferences manager that provides a way to store r\", \"untime settings for a user. \\nThis feature can be accessed from anywhere within your application usin\", \"g the \\nMicrosoft.Maui.Storage.Preferences class. The preferences manager provides a con sistent, typ\", \"e -safe, \\ncross -platform approach for persisting and retrieving app and user settings, while using \", \"the native \\nsettings management provided by each platform. In addition, it\\u2019s straightforward to use \", \"data binding \\nto access settings data exposed by the library. For more information, see the Preferen\", \"ces  on the \\nMicrosoft Developer Center.  \\nTip \\nPreferences is meant for storing relatively small da\", \"ta. If you need to store larger or more complex \\ndata, consider using a local database or filesystem\", \" to store the data.  \\nOur application will use the Preferences class need to implement the ISettings\", \"Service interface. The \\ncode below shows how the eShop multi -platform app\\u2019s SettingsService impleme\", \"nts the \\nAuthTokenAccess and UseMocks properties:  \\npublic sealed class SettingsService : ISettingsS\", \"ervice  \\n{ \\n    private const string AccessToken = \\\"access_token\\\" ; \\n    private const string Access\", \"TokenDefault = string.Empty; \\n \\n    private const string IdUseMocks = \\\"use_mocks\\\" ; \\n    private con\", \"st bool UseMocksDefault = true; \\n \\n    public string AuthAccessToken  \\n    { \\n        get => Prefere\", \"nces .Get(AccessToken , AccessTokenDefault ); \\n        set => Preferences .Set(AccessToken , value);\", \" \\n    } \\n \\n    public bool UseMocks  \\n    { \\n        get => Preferences .Get(IdUseMocks , UseMocksDe\", \"fault ); \\n        set => Preferences .Set(IdUseMocks , value); \\n    } \\n} \\nEach setting consists of a\", \" private key, a private default value, and a public property. The key is always \\na const string that\", \" defines a unique name, with the default value for the setting being a static read -\\nonly or constan\", \"t value of the required type. Providing a default value ensures that a valid value is \\navailable if \", \"an unset setting is retrieved. This service implementation can be provided via dependency \\ninjection\", \" to our application for use in view -models or other services throughout the application.   \\n48 CHAP\", \"TER 8 | Application settings management  \\n Data binding to user settings  \\nIn the eShop multi -platf\", \"orm app, the SettingsView exposes multiple settings the user can configure at \\nruntime. These settin\", \"gs include allowing configuration of whether the app should retrieve data from \\nmicroservices deploy\", \"ed as Docker containers or whether  the app should retrieve data from mock \\nservices that don\\u2019t requ\", \"ire an internet connection. When retrieving data from containerized \\nmicroservices, a base endpoint \", \"URL for the microservices must be specified. The image below shows \\nthe SettingsView when the user h\", \"as chosen to retrieve data from containerized microservices.  \\n \\nData binding can be used to retriev\", \"e and set settings exposed by the ISettingService interface. This is \\nachieved by controls on the vi\", \"ew binding to view model properties that in turn access properties in \\nthe ISettingService interface\", \" and raising a property  changed notification if the value has changed.  \\nThe following code example\", \" shows the Entry control from the SettingsView that allows the user to \\nenter a base identity endpoi\", \"nt URL for the containerized microservices:  \\n<Entry Text=\\\"{Binding  IdentityEndpoint,  Mode=TwoWay}\", \"\\\"  /> \\nThis Entry control binds to the IdentityEndpoint property of the SettingsViewModel class, usi\", \"ng a two -\\nway binding. The following code example shows the IdentityEndpoint property:  \\nprivate re\", \"adonly  ISettingsService _settingsService ; \\n \\nprivate string _identityEndpoint ; \\n \\npublic Settings\", \"ViewModel ( \\n    ILocationService locationService , IAppEnvironmentService appEnvironmentService , \\n\", \"    IDialogService dialogService , INavigationService navigationService , ISettingsService \\nsettings\", \"Service ) \\n    : base(dialogService , navigationService , settingsService ) \\n{ \\n    _settingsService\", \" = settingsService ; \\n \\n    _identityEndpoint = _settingsService .IdentityEndpointBase ; \\n} \\n \\npubli\", \"c string IdentityEndpoint  \\n \\n49 CHAPTER 8 | Application settings management  \\n { \\n    get => _ident\", \"ityEndpoint ; \\n    set \\n    { \\n        SetProperty (ref _identityEndpoint , value); \\n \\n        if (!\", \"string.IsNullOrWhiteSpace (value)) \\n        { \\n            UpdateIdentityEndpoint (); \\n        } \\n  \", \"  } \\n} \\nWhen the IdentityEndpoint property is set, the UpdateIdentityEndpoint method is called, prov\", \"ided \\nthat the supplied value is valid. The following code example shows the UpdateIdentityEndpoint \", \"\\nmethod:  \\nprivate void UpdateIdentityEndpoint () \\n{ \\n    _settingsService .IdentityEndpointBase  = \", \"_identityEndpoint ; \\n} \\nThis method updates the IdentityEndpointBase property in the ISettingService\", \" interface \\nimplementation with the base endpoint URL value entered by the user. If the SettingsServ\", \"ice class is \\nprovided as the implementation for _settingsService, the value will persist to platfor\", \"m -specific storage.  \\nSummary  \\nSettings allow the separation of data that configures the behavior \", \"of an app from the code, allowing \\nthe behavior to be changed without rebuilding the app. App settin\", \"gs are data that an app creates and \\nmanages, and user settings are the customizable settin gs of an\", \" app that affect the app\\u2019s behavior and \\ndon\\u2019t require frequent re -adjustment.  \\nThe Microsoft.Maui\", \".Storage.Preferences class provides a consistent, type -safe, cross -platform \\napproach for persisti\", \"ng and retrieving app and user settings.   \\n50 CHAPTER 9 | Containerized microservices  \\n CHAPTER  9\", \" \\nContainerized \\nmicroservices  \\nDeveloping client -server applications has resulted in a focus on b\", \"uilding tiered applications that use \\nspecific technologies in each tier. Such applications are ofte\", \"n referred to as monolithic  and are \\npackaged onto hardware pre -scaled for peak loads. The main dr\", \"awbacks of this development \\napproach are the tight coupling between components within each tier, th\", \"at individual components \\ncan\\u2019t be easily scaled, and the cost of testing. A simple upda te can have\", \" unforeseen effects on the rest \\nof the tier, so a cha nge to an application component requires its \", \"entire tier to be retested and \\nredeployed.  \\nParticularly concerning, in the age of the cloud, is t\", \"hat individual components can\\u2019t be easily scaled. A \\nmonolithic application contains domain -specifi\", \"c functionality and is typically divided by functional \\nlayers such as front -end, business logic, a\", \"nd dat a storage. The image below illustrates that a \\nmonolithic application is scaled by cloning th\", \"e entire application onto multiple machines.   \\n51 CHAPTER 9 | Containerized microservices  \\n  \\nMicr\", \"oservices  \\nMicroservices offer a different approach to application development and deployment, an a\", \"pproach \\nthat\\u2019s suited to the agility, scale, and reliability requirements of modern cloud applicati\", \"ons. A \\nmicroservices application is split into independent components  that work together to delive\", \"r the \\napplication\\u2019s overall functionality. The term microservice emphasizes that applications shoul\", \"d be \\ncomposed of services small enough to reflect particular concerns, so each microservice impleme\", \"nts a \\nsingle function. In add ition, each microservice has well -defined contracts with which other\", \" \\nmicroservices communicate and share data. Typical examples of microservices include shopping carts\", \", \\ninventory processing, purchase subsystems, and payment processing.  \\nMicroservices can scale inde\", \"pendently compared to giant monolithic applications that scale together. \\nThis means that a specific\", \" functional area that requires more processing power or network bandwidth \\nto support demand can be \", \"scaled rather than unnecessari ly scaling out other application areas. The \\nimage below illustrates \", \"this approach, where microservices are deployed and scaled independently, \\ncreating instances of ser\", \"vices across machines.  \\n \\n52 CHAPTER 9 | Containerized microservices  \\n  \\nMicroservice scale -out c\", \"an be nearly instantaneous, allowing an application to adapt to changing \\nloads. For example, a sing\", \"le microservice in the web -facing functionality of an application might be \\nthe only microservice t\", \"hat needs to scale out to handle ad ditional incoming traffic.  \\nThe classic model for application s\", \"calability is to have a load -balanced, stateless tier with a shared \\nexternal datastore to store pe\", \"rsistent data. Stateful microservices manage their own persistent data, \\nusually storing it locally \", \"on the servers on which they are placed, to avoid the overhead of network \\naccess and complexity of \", \"cross -service operations. This enables the fastest possible processing of data \\nand can eliminate t\", \"he need for caching systems. In addition, scalable stateful microservices usually \\npartition data am\", \"ong their instances, in order to manage data size and transfer throughput beyond \\nwhich a single ser\", \"ver can support.  \\nMicroservices also support independent updates. This loose coupling between micro\", \"services provides \\na rapid and reliable application evolution. Their independent, distributed nature\", \" helps rolling updates, \\nwhere only a subset of instances of a single microse rvice will update at a\", \"ny given time. Therefore, if a \\nproblem is detected, a buggy update can be rolled back, before all i\", \"nstances update with the faulty \\ncode or configuration. Similarly, microservices typically use schem\", \"a versioning, so that clients see a \\nconsistent version when updates are being applied, regardless o\", \"f which microservice instance is being \\ncommunicated with.  \\nTherefore, microservice applications ha\", \"ve many benefits over monolithic applications:  \\n\\u2022 Each microservice is relatively small, easy to ma\", \"nage and evolve.  \\n\\u2022 Each microservice can be developed and deployed independently of other services\", \".  \\n\\u2022 Each microservice can be scaled -out independently. For example, a catalog service or \\nshoppin\", \"g basket service might need to be scaled -out more than an ordering service. \\n \\n53 CHAPTER 9 | Conta\", \"inerized microservices  \\n Therefore, the resulting infrastructure will more efficiently consume reso\", \"urces when scaling \\nout. \\n\\u2022 Each microservice isolates any issues. For example, if there is an issue\", \" in a service it only \\nimpacts that service. The other services can continue to handle requests.  \\n\\u2022\", \" Each microservice can use the latest technologies. Because microservices are autonomous and \\nrun si\", \"de -by-side, the latest technologies and frameworks can be used, rather than being \\nforced to use an\", \" older framework that might be used by a monolithic applicat ion. \\nHowever, a microservice -based so\", \"lution also has potential drawbacks:  \\n\\u2022 Choosing how to partition an application into microservices\", \" can be challenging, as each \\nmicroservice has to be completely autonomous, end -to-end, including r\", \"esponsibility for its \\ndata sources.  \\n\\u2022 Developers must implement inter -service communication, whi\", \"ch adds complexity and latency \\nto the application.  \\n\\u2022 Atomic transactions between multiple microse\", \"rvices usually aren\\u2019t possible. Therefore, \\nbusiness requirements must embrace eventual consistency \", \"between microservices.  \\n\\u2022 In production, there is an operational complexity in deploying and managi\", \"ng a system \\ncompromised of many independent services.  \\n\\u2022 Direct client -to-microservice communicat\", \"ion can make it difficult to refactor the contracts of \\nmicroservices. For example, over time how th\", \"e system is partitioned into services might need \\nto change. A single service might split into two o\", \"r more services, a nd two services might \\nmerge. When clients communicate directly with microservice\", \"s, this refactoring work can break \\ncompatibility with client apps.  \\nContainerization  \\nContaineriz\", \"ation is an approach to software development in which an application and its versioned set \\nof depen\", \"dencies, plus its environment configuration abstracted as deployment manifest files, are \\npackaged t\", \"ogether as a container image, tested as a unit,  and deployed to a host operating system.  \\nA contai\", \"ner is an isolated, resource controlled, and portable operating environment, where an \\napplication c\", \"an run without touching the resources of other containers, or the host. Therefore, a \\ncontainer look\", \"s and acts like a newly installed physical compute r or a virtual machine.  \\nThere are many similari\", \"ties between containers and virtual machines, as illustrated below.   \\n54 CHAPTER 9 | Containerized \", \"microservices  \\n  \\nA container runs an operating system, has a file system, and can be accessed over\", \" a network as if it \\nwere a physical or virtual machine. However, the technology and concepts used b\", \"y containers are very \\ndifferent from virtual machines. Virtual machines incl ude the applications, \", \"the required dependencies, \\nand a full guest operating system. Containers include the application an\", \"d its dependencies, but share \\nthe operating system with other containers, running as isolated proce\", \"sses on the host operating \\nsystem (a side from Hyper -V containers which run inside of a special vi\", \"rtual machine per container). \\nTherefore, containers share resources and typically require fewer res\", \"ources than virtual machines.  \\nThe advantage of a container -oriented development and deployment ap\", \"proach is that it eliminates \\nmost of the issues that arise from inconsistent environment setups and\", \" the problems that come with \\nthem. In addition, containers permit fast application scale -up functi\", \"onality by instancing new \\ncontainers as required.  \\nThe key concepts when creating and working with\", \" containers are:  \\nConcept  Description  \\nContainer Host  The physical or virtual machine configured\", \" to \\nhost containers. The container host will run one \\nor more containers.  \\nContainer Image  An ima\", \"ge consists of a union of layered \\nfilesystems stacked on top of each other, and is \\nthe basis of a \", \"container. An image does not \\nhave state and it never changes as it\\u2019s deployed \\nto different environ\", \"ments.  \\nContainer  A container is a runtime instance of an image.  \\n \\n55 CHAPTER 9 | Containerized \", \"microservices  \\n Concept  Description  \\nContainer OS Image  Containers are deployed from images. The\", \" \\ncontainer operating system image is the first \\nlayer in potentially many image layers that make \\nu\", \"p a container. A container operating system is \\nimmutable, and can\\u2019t be modified.  \\nContainer Reposi\", \"tory  Each time a container image is created, the \\nimage and its dependencies are stored in a local \", \"\\nrepository. These images can be reused many \\ntimes on the container host. The container \\nimages can\", \" also be stored in a public or private \\nregistry, such as Docker Hub , so that they can \\nbe used acr\", \"oss different container hosts.  \\nEnterprises are increasingly adopting containers when implementing \", \"microservice -based applications, \\nand Docker has become the standard container implementation that \", \"has been adopted by most \\nsoftware platforms and cloud vendors.  \\nThe eShop reference application us\", \"es Docker to host four containerized back -end microservices, as \\nillustrated in the diagram below. \", \"  \\n56 CHAPTER 9 | Containerized microservices  \\n  \\nThe architecture of the back -end services in the\", \" reference application is decomposed into multiple \\nautonomous sub -systems in the form of collabora\", \"ting microservices and containers. Each microservice \\nprovides a single area of functionality: an id\", \"entity serv ice, a catalog service, an ordering service, and a \\nbasket service.  \\nEach microservice \", \"has its own database, allowing it to be fully decoupled from the other \\nmicroservices. Where necessa\", \"ry, consistency between databases from different microservices is \\nachieved using application -level\", \" events. For more information, see Communication between \\nmicroservices . \\nCommunication between cli\", \"ent and microservices  \\nThe eShop multi -platform app communicates with the containerized back -end \", \"microservices using \\ndirect client -to-microservice  communication, as shown below.  \\n \\n57 CHAPTER 9\", \" | Containerized microservices  \\n  \\nWith direct client -to-microservice communication, the multi -pl\", \"atform app makes requests to each \\nmicroservice directly through its public endpoint, with a differe\", \"nt TCP port per microservice. In \\nproduction, the endpoint would typically map to the microservice\\u2019s\", \" load balancer, which distributes \\nrequests across the available instances.  \\nTip \\nConsider using AP\", \"I gateway communication.  \\nDirect client -to-microservice communication can have drawbacks when buil\", \"ding a large and complex \\nmicroservice -based application, but it\\u2019s more than adequate for a small a\", \"pplication. Consider using \\nAPI gateway communication when designing a large microservi ce-based app\", \"lication with tens of \\nmicroservices.  \\nCommunication between microservices  \\nA microservices -based\", \" application is a distributed system, potentially running on multiple machines. \\nEach service instan\", \"ce is typically a process. Therefore, services must interact using an inter -process \\ncommunication \", \"protocol, such as HTTP, TCP, Advanced Message Queuing Protocol (AMQP), or binary \\nprotocols, dependi\", \"ng on the nature of each service.  \\nThe two common approaches for microservice -to-microservice comm\", \"unication are HTTP -based REST \\ncommunication when querying for data, and lightweight asynchronous m\", \"essaging when \\ncommunicating updates across multiple microservices.  \\nAsynchronous messaging -based \", \"event -driven communication is critical when propagating changes \\nacross multiple microservices. Wit\", \"h this approach, a microservice publishes an event when something \\nnotable happens, for example, whe\", \"n it updates a business entity . Other microservices subscribe to \\nthese events. Then, when a micros\", \"ervice receives an event, it updates its own business entities, which \\nmight, in turn, lead to more \", \"events being published. This publish -subscribe functionality is usually \\nachieved with an event bus\", \".  \\n \\n58 CHAPTER 9 | Containerized microservices  \\n An event bus allows publish -subscribe communica\", \"tion between microservices without requiring the \\ncomponents to be explicitly aware of each other, a\", \"s shown below.  \\n \\nFrom an application perspective, the event bus is simply a publish -subscribe cha\", \"nnel exposed via an \\ninterface. However, the way the event bus is implemented can vary. For example,\", \" an event bus \\nimplementation could use RabbitMQ, Azure Service Bus, or other service buses such as \", \"NServiceBus \\nand MassTransit. The diagram below shows how an event bus is used in the eShop referenc\", \"e \\napplication.  \\n \\nThe eShop event bus, implemented using RabbitMQ, provides one -to-many asynchron\", \"ous publish -\\nsubscribe functionality. This means that after publishing an event, there can be multi\", \"ple subscribers \\nlistening for the same event. The diagram below illustrates thi s relationship.  \\n \", \"\\n59 CHAPTER 9 | Containerized microservices  \\n  \\nThis one -to-many communication approach uses event\", \"s to implement business transactions that span \\nmultiple services, ensuring eventual consistency bet\", \"ween the services. An eventual -consistent \\ntransaction consists of a series of distributed steps. T\", \"herefore,  when the user -profile microservice \\nreceives the UpdateUser command, it updates the user\", \"\\u2019s details in its database and publishes the \\nUserUpdated event to the event bus. Both the basket mi\", \"croservice and the ordering microservice have \\nsubscribed to receive t his event, and in response, u\", \"pdate their buyer information in their respective \\ndatabases.  \\nSummary  \\nMicroservices offer an app\", \"roach to application development and deployment that\\u2019s suited to the \\nagility, scale, and reliabilit\", \"y requirements of modern cloud applications. One of the main advantages \\nof microservices is that th\", \"ey can be scaled -out independent ly, which means that a specific functional \\narea can be scaled tha\", \"t requires more processing power or network bandwidth to support demand \\nwithout unnecessarily scali\", \"ng areas of the application that are not experiencing increased demand.  \\nA container is an isolated\", \", resource -controlled, and portable operating environment where an \\napplication can run without tou\", \"ching the resources of other containers or the host. Enterprises are \\nincreasingly adopting containe\", \"rs when implementing microservice -based applications, and Docker \\nhas become the standard container\", \" implementation that most software platforms and cloud vendors \\nhave adopted.  \\n \\n60 CHAPTER 10 | Ac\", \"cessing remote data  \\n CHAPTER  10 \\nAccessing remote data  \\nMany modern web -based solutions make us\", \"e of web services, hosted by web servers, to provide \\nfunctionality for remote client applications. \", \"The operations that a web service exposes constitute a \\nweb API.  \\nClient apps should be able to uti\", \"lize the web API without knowing how the data or operations that the \\nAPI exposes are implemented. T\", \"his requires that the API abides by common standards that enable a \\nclient app and web service to ag\", \"ree on which data formats  to use, and the structure of the data that is \\nexchanged between client a\", \"pps and the web service.  \\nIntroduction to Representational State Transfer  \\nRepresentational State \", \"Transfer (REST) is an architectural style for building distributed systems based \\non hypermedia. A p\", \"rimary advantage of the REST model is that it\\u2019s based on open standards and \\ndoesn\\u2019t bind the implem\", \"entation of the model or the client  apps that access it to any specific \\nimplementation. Therefore,\", \" a REST web service could be implemented using Microsoft ASP.NET Core , \\nand client apps could be de\", \"veloping using any language and toolset that can generate HTTP requests \\nand parse HTTP responses.  \", \"\\nThe REST model uses a navigational scheme to represent objects and services over a network, referre\", \"d \\nto as resources. Systems that implement REST typically use the HTTP protocol to transmit requests\", \" to \\naccess these resources. In such systems, a client app submits a request in the form of a URI th\", \"at \\nidentifies a resource, and an HTTP method (such as GET, POST, PUT, or DELETE) that indicates the\", \" \\noperation to be performed on that resource. The body of the HTTP request contains any data require\", \"d \\nto perform the operation.  \\nNote  \\nREST defines a stateless request model. Therefore, HTTP reques\", \"ts must be independent and might \\noccur in any order.  \\nThe response from a REST request makes use o\", \"f standard HTTP status codes. For example, a request \\nthat returns valid data should include the HTT\", \"P response code 200 (OK), while a request that fails to \\nfind or delete a specified resource should \", \"return a respo nse that includes the HTTP status code 404 \\n(Not Found).  \\nA RESTful web API exposes \", \"a set of connected resources, and provides the core operations that \\nenable an app to manipulate tho\", \"se resources and easily navigate between them. For this reason, the \\nURIs that constitute a typical \", \"RESTful web API are oriented tow ards the data that it exposes, and use \\nthe facilities provided by \", \"HTTP to operate on this data.   \\n61 CHAPTER 10 | Accessing remote data  \\n The data included by a cli\", \"ent app in an HTTP request, and the corresponding response messages from \\nthe web server, could be p\", \"resented in a variety of formats, known as media types. When a client app \\nsends a request that retu\", \"rns data in the body of a messag e, it can specify the media types it can \\nhandle in the Accept head\", \"er of the request. If the web server supports this media type, it can reply \\nwith a response that in\", \"cludes the Content -Type header that specifies the format of the data in the \\nbody of the mes sage. \", \"It\\u2019s then the responsibility of the client app to parse the response message and \\ninterpret the resu\", \"lts in the message body appropriately.  \\nFor more information about REST, see API design  and API im\", \"plementation  on Microsoft Docs.  \\nConsuming RESTful APIs  \\nThe eShop multi -platform app uses the M\", \"odel -View -ViewModel (MVVM) pattern, and the model \\nelements of the pattern represent the domain en\", \"tities used in the app. The controller and repository \\nclasses in the eShop reference application ac\", \"cept and return many of these model objects. Therefore, \\nthey are used as data transfer objects (DTO\", \"s) that hold all the data that is passed between the app \\nand the containerized microservices. The m\", \"ain benefit of using DTOs to pass data to and receive data \\nfrom a web service i s that by transmitt\", \"ing more data in a single remote call, the app can reduce the \\nnumber of remote calls that need to b\", \"e made.  \\nMaking web requests  \\nThe eShop multi -platform app uses the HttpClient class to make requ\", \"ests over HTTP, with JSON being \\nused as the media type. This class provides functionality for async\", \"hronously sending HTTP requests \\nand receiving HTTP responses from a URI identified resourc e. The H\", \"ttpResponseMessage class \\nrepresents an HTTP response message received from a REST API after an HTTP\", \" request has been \\nmade. It contains information about the response, including the status code, head\", \"ers, and any body. \\nThe HttpContent class represent s the HTTP body and content headers, such as Con\", \"tent -Type and \\nContent -Encoding. The content can be read using any of the ReadAs methods, such as \", \"\\nReadAsStringAsync and ReadAsByteArrayAsync, depending on the format of the data.  \\nMaking a GET req\", \"uest  \\nThe CatalogService class is used to manage the data retrieval process from the catalog micros\", \"ervice. \\nIn the RegisterViewModels method in the MauiProgram class, the CatalogService class is regi\", \"stered as \\na type mapping against the ICatalogService type with the dependency injection container. \", \"T hen, when \\nan instance of the CatalogViewModel class is created, its constructor accepts an ICatal\", \"ogService type, \\nwhich the dependency injection container resolves, returning an instance of the Cat\", \"alogService class. \\nFor more information about dependency inj ection, see Dependency Injection . \\nTh\", \"e image below shows the interaction of classes that read catalog data from the catalog microservice \", \"\\nfor displaying by the CatalogView.   \\n62 CHAPTER 10 | Accessing remote data  \\n  \\nWhen the CatalogVi\", \"ew is navigated to, the OnInitialize method in the CatalogViewModel class is \\ncalled. This method re\", \"trieves catalog data from the catalog microservice, as demonstrated in the \\nfollowing code example: \", \" \\npublic override  async Task InitializeAsync () \\n{ \\n    Products = await _productsService .GetCatal\", \"ogAsync (); \\n}  \\nThis method calls the GetCatalogAsync method of the CatalogService instance that wa\", \"s injected into \\nthe CatalogViewModel by the dependency injection container. The following code exam\", \"ple shows the \\nGetCatalogAsync method:  \\npublic async Task <ObservableCollection <CatalogItem >> Get\", \"CatalogAsync () \\n{ \\n    UriBuilder builder = new UriBuilder (GlobalSetting .Instance .CatalogEndpoin\", \"t ); \\n    builder.Path = \\\"api/v1/catalog/items\\\" ; \\n    string uri = builder.ToString (); \\n \\n    Cata\", \"logRoot ? catalog = await _requestProvider .GetAsync <CatalogRoot >(uri); \\n \\n    return catalog?.Dat\", \"a;           \\n}  \\n \\n63 CHAPTER 10 | Accessing remote data  \\n This method builds the URI that identif\", \"ies the resource the request will be sent to, and uses the \\nRequestProvider class to invoke the GET \", \"HTTP method on the resource, before returning the results to \\nthe CatalogViewModel. The RequestProvi\", \"der class contains functionality that submits a request in the \\nform of a URI that identifies a reso\", \"urce, an HTTP method that indicates the operation to be performed \\non that resource, and a body that\", \" contains any data required to perform the operation. For \\ninformation about h ow the RequestProvide\", \"r class is injected into the CatalogService class, see \\nDependency Injection . \\nThe following code e\", \"xample shows the GetAsync method in the RequestProvider class:  \\npublic async Task <TResult> GetAsyn\", \"c <TResult>(string uri, string token = \\\"\\\") \\n{ \\n    HttpClient httpClient = GetOrCreateHttpClient (to\", \"ken); \\n    HttpResponseMessage response = await httpClient .GetAsync (uri); \\n \\n    await HandleRespo\", \"nse (response ); \\n    TResult result = await response .Content.ReadFromJsonAsync <TResult>(); \\n \\n   \", \" return result; \\n} \\nThis method calls the GetOrCreateHttpClient method, which returns an instance of\", \" the HttpClient class \\nwith the appropriate headers set. It then submits an asynchronous GET request\", \" to the resource \\nidentified by the URI, with the response being stored in the  HttpResponseMessage \", \"instance. The \\nHandleResponse method is then invoked, which throws an exception if the response does\", \"n\\u2019t include a \\nsuccess HTTP status code. Then the response is read as a string, converted from JSON \", \"to a \\nCatalogRoot object, and returned  to the CatalogService.  \\nThe GetOrCreateHttpClient method is\", \" shown in the following code example:  \\nprivate readonly  Lazy<HttpClient > _httpClient = \\n    new L\", \"azy<HttpClient >( \\n        () => \\n        { \\n            var httpClient = new HttpClient (); \\n      \", \"      httpClient .DefaultRequestHeaders .Accept.Add(new \\nMediaTypeWithQualityHeaderValue (\\\"applicati\", \"on/json\\\" )); \\n            return httpClient ; \\n        }, \\n        LazyThreadSafetyMode .ExecutionAn\", \"dPublication ); \\n \\nprivate HttpClient GetOrCreateHttpClient (string token = \\\"\\\") \\n    { \\n        var \", \"httpClient = _httpClient .Value; \\n \\n        if (!string.IsNullOrEmpty (token)) \\n        { \\n         \", \"   httpClient .DefaultRequestHeaders .Authorization  = new \\nAuthenticationHeaderValue (\\\"Bearer\\\" , to\", \"ken); \\n        } \\n        else \\n        { \\n            httpClient .DefaultRequestHeaders .Authorizat\", \"ion  = null; \\n        } \\n  \\n64 CHAPTER 10 | Accessing remote data  \\n         return httpClient ; \\n  \", \"  } \\nThis method uses creates a new instance or retrieves a cached instance of the HttpClient class,\", \" and \\nsets the Accept header of any requests made by the HttpClient instance to application/json, wh\", \"ich \\nindicates that it expects the content of any response to b e formatted using JSON. Then, if an \", \"access \\ntoken was passed as an argument to the GetOrCreateHttpClient method, it\\u2019s added to the \\nAuth\", \"orization header of any requests made by the HttpClient instance, prefixed with the string Bearer. \\n\", \"For more information ab out authorization, see Authorization . \\nTip \\nIt is highly recommended to cac\", \"he and reuse instances of the HttpClient for better application \\nperformance. Creating a new HttpCli\", \"ent for each operation can lead to issue with socket exhaustion. \\nFor more information, see HttpClie\", \"nt Instancing  on the Microsoft Developer Center.  \\nWhen the GetAsync method in the RequestProvider \", \"class calls HttpClient.GetAsync, the Items method \\nin the CatalogController class in the Catalog.API\", \" project is invoked, which is shown in the following \\ncode example:  \\n[HttpGet] \\n[Route(\\\"[action]\\\" )\", \"] \\npublic async Task <IActionResult > Items( \\n    [FromQuery ]int pageSize = 10, [FromQuery ]int pag\", \"eIndex = 0) \\n{ \\n    var totalItems = await _catalogContext .CatalogItems  \\n        .LongCountAsync (\", \"); \\n \\n    var itemsOnPage = await _catalogContext .CatalogItems  \\n        .OrderBy(c => c.Name) \\n   \", \"     .Skip(pageSize * pageIndex ) \\n        .Take(pageSize ) \\n        .ToListAsync (); \\n \\n    itemsOn\", \"Page = ComposePicUri (itemsOnPage ); \\n    var model = new PaginatedItemsViewModel <CatalogItem >( \\n \", \"       pageIndex , pageSize , totalItems , itemsOnPage );            \\n \\n    return Ok(model); \\n} \\nTh\", \"is method retrieves the catalog data from the SQL database using EntityFramework , and returns it \\na\", \"s a response message that includes a success HTTP status code, and a collection of JSON formatted \\nC\", \"atalogItem instances.  \\nMaking a POST request  \\nThe BasketService class is used to manage the data r\", \"etrieval and update process with the basket \\nmicroservice. In the RegisterAppServices method in the \", \"MauiProgram class, the BasketService class is \\nregistered as a type mapping against the IBasketServi\", \"ce typ e with the dependency injection container. \\nThen, when an instance of the BasketViewModel cla\", \"ss is created, its constructor accepts an  \\n65 CHAPTER 10 | Accessing remote data  \\n IBasketService \", \"type, which the dependency injection container resolves, returning an instance of the \\nBasketService\", \" class. For more information about dependency injection, see Dependency Injection . \\nThe image below\", \" shows the interaction of classes that send the basket data displayed by the \\nBasketView, to the bas\", \"ket microservice.  \\n \\nWhen an item is added to the shopping basket, the ReCalculateTotalAsync method\", \" in the \\nBasketViewModel class is called. This method updates the total value of items in the basket\", \", and sends \\nthe basket data to the basket microservice, as demonstrated in the following code examp\", \"le:  \\nprivate async Task ReCalculateTotalAsync () \\n{ \\n    // Omitted for brevity...  \\n \\n    await _b\", \"asketService .UpdateBasketAsync ( \\n        new CustomerBasket  \\n        { \\n            BuyerId = use\", \"rInfo .UserId,  \\n            Items = BasketItems .ToList() \\n        },  \\n        authToken ); \\n} \\n \\n\", \"66 CHAPTER 10 | Accessing remote data  \\n This method calls the UpdateBasketAsync method of the Baske\", \"tService instance that was injected into \\nthe BasketViewModel by the dependency injection container.\", \" The following method shows the \\nUpdateBasketAsync method:  \\npublic async Task <CustomerBasket > Upd\", \"ateBasketAsync ( \\n    CustomerBasket customerBasket , string token) \\n{ \\n    UriBuilder builder = new\", \" UriBuilder (GlobalSetting .Instance .BasketEndpoint ); \\n    string uri = builder.ToString (); \\n    \", \"var result = await _requestProvider .PostAsync (uri, customerBasket , token); \\n    return result; \\n}\", \" \\nThis method builds the URI that identifies the resource the request will be sent to, and uses the \", \"\\nRequestProvider class to invoke the POST HTTP method on the resource, before returning the results \", \"\\nto the BasketViewModel. Note that an access token, obtained  from IdentityServer during the \\nauthen\", \"tication process, is required to authorize requests to the basket microservice. For more \\ninformatio\", \"n about authorization, see Authorization . \\nThe following code example shows one of the PostAsync me\", \"thods in the RequestProvider class:  \\npublic async Task <TResult> PostAsync <TResult>( \\n    string u\", \"ri, TResult data , string token = \\\"\\\", string header = \\\"\\\") \\n{ \\n    HttpClient httpClient = GetOrCreat\", \"eHttpClient (token); \\n \\n    var content = new StringContent (JsonSerializer .Serialize (data)); \\n   \", \" content.Headers.ContentType  = new MediaTypeHeaderValue (\\\"application/json\\\" ); \\n    HttpResponseMes\", \"sage response = await httpClient .PostAsync (uri, content); \\n \\n    await HandleResponse (response );\", \" \\n    TResult result = await response .Content.ReadFromJsonAsync <TResult>(); \\n     \\n    return resu\", \"lt; \\n} \\nThis method calls the GetOrCreateHttpClient method, which returns an instance of the HttpCli\", \"ent class \\nwith the appropriate headers set. It then submits an asynchronous POST request to the res\", \"ource \\nidentified by the URI, with the serialized basket data bein g sent in JSON format, and the re\", \"sponse \\nbeing stored in the HttpResponseMessage instance. The HandleResponse method is then invoked,\", \" \\nwhich throws an exception if the response doesn\\u2019t include a success HTTP status code. Then, the \\nr\", \"esponse is read as a strin g, converted from JSON to a CustomerBasket object, and returned to the \\nB\", \"asketService. For more information about the GetOrCreateHttpClient method, see Making a GET \\nrequest\", \" . \\nWhen the PostAsync method in the RequestProvider class calls HttpClient.PostAsync, the Post meth\", \"od \\nin the BasketController class in the Basket.API project is invoked, which is shown in the follow\", \"ing code \\nexample:  \\n[HttpPost ] \\npublic async Task <IActionResult > Post([FromBody ] CustomerBasket\", \" value ) \\n{ \\n    var basket = await _repository .UpdateBasketAsync (value); \\n    return Ok(basket); \", \"\\n}   \\n67 CHAPTER 10 | Accessing remote data  \\n This method uses an instance of the RedisBasketReposi\", \"tory class to persist the basket data to the \\nRedis cache, and returns it as a response message that\", \" includes a success HTTP status code, and a \\nJSON formatted CustomerBasket instance.  \\nMaking a DELE\", \"TE request  \\nThe image below shows the interactions of classes that delete basket data from the bask\", \"et \\nmicroservice, for the CheckoutView.  \\n \\nWhen the checkout process is invoked, the CheckoutAsync \", \"method in the CheckoutViewModel class is \\ncalled. This method creates a new order, before clearing t\", \"he shopping basket, as demonstrated in the \\nfollowing code example:  \\nprivate async Task CheckoutAsy\", \"nc () \\n{ \\n    // Omitted for brevity...  \\n \\n    await _basketService .ClearBasketAsync ( \\n        _s\", \"hippingAddress .Id.ToString (), authToken ); \\n} \\nThis method calls the ClearBasketAsync method of th\", \"e BasketService instance that was injected into \\nthe CheckoutViewModel by the dependency injection c\", \"ontainer. The following method shows the \\nClearBasketAsync method:  \\npublic async Task ClearBasketAs\", \"ync (string guidUser , string token) \\n{ \\n    UriBuilder builder = new(GlobalSetting .Instance .Baske\", \"tEndpoint ); \\n    builder.Path = guidUser ; \\n    string uri = builder.ToString (); \\n    await _reque\", \"stProvider .DeleteAsync (uri, token); \\n} \\n \\n68 CHAPTER 10 | Accessing remote data  \\n This method bui\", \"lds the URI that identifies the resource that the request will be sent to, and uses the \\nRequestProv\", \"ider class to invoke the DELETE HTTP method on the resource. Note that an access token, \\nobtained fr\", \"om IdentityServer during the authentication  process, is required to authorize requests to \\nthe bask\", \"et microservice. For more information about authorization, see Authorization . \\nThe following code e\", \"xample shows the DeleteAsync method in the RequestProvider class:  \\npublic async Task DeleteAsync (s\", \"tring uri, string token = \\\"\\\") \\n{ \\n    HttpClient httpClient = GetOrCreateHttpClient (token); \\n    aw\", \"ait httpClient .DeleteAsync (uri); \\n} \\nThis method calls the GetOrCreateHttpClient method, which ret\", \"urns an instance of the HttpClient class \\nwith the appropriate headers set. It then submits an async\", \"hronous DELETE request to the resource \\nidentified by the URI. For more information about the Get Or\", \"CreateHttpClient method, see Making a \\nGET request . \\nWhen the DeleteAsync method in the RequestProv\", \"ider class calls HttpClient.DeleteAsync, the Delete \\nmethod in the BasketController class in the Bas\", \"ket.API project is invoked, which is shown in the \\nfollowing code example:  \\n[HttpDelete (\\\"{id}\\\")] \\n\", \"public void Delete(string id) => \\n    _repository .DeleteBasketAsync (id); \\nThis method uses an inst\", \"ance of the RedisBasketRepository class to delete the basket data from the \\nRedis cache.  \\nCaching d\", \"ata  \\nThe performance of an app can be improved by caching frequently accessed data to fast storage \", \"\\nthat\\u2019s located close to the app. If the fast storage is located closer to the app than the original\", \" source, \\nthen caching can significantly improve response times when retrieving data.  \\nThe most com\", \"mon form of caching is read -through caching, where an app retrieves data by \\nreferencing the cache.\", \" If the data isn\\u2019t in the cache, it\\u2019s retrieved from the data store and added to the \\ncache. Apps ca\", \"n implement read -through caching with the cache -aside pattern. This pattern \\ndetermines whether th\", \"e item is currently in the cache. If the item isn\\u2019t in the cache, it\\u2019s read from the \\ndata store and\", \" added to the cache. For more information, see the Cache -Aside  pattern on Microsoft \\nDocs.  \\nTip \\n\", \"Cache data that\\u2019s read frequently and changes infrequently.  \\nThis data can be added to the cache on\", \" demand the first time it is retrieved by an app. This means \\nthat the app needs to fetch the data o\", \"nly once from the data store, and that subsequent access can \\nbe satisfied by using the cache.   \\n69\", \" CHAPTER 10 | Accessing remote data  \\n Distributed applications, such as the eShop reference applica\", \"tion, should provide either or both of the \\nfollowing caches:  \\n\\u2022 A shared cache, which can be acces\", \"sed by multiple processes or machines.  \\n\\u2022 A private cache, where data is held locally on the device\", \" running the app.  \\nThe eShop multi -platform app uses a private cache, where data is held locally o\", \"n the device that\\u2019s \\nrunning an instance of the app.  \\nTip \\nThink of the cache as a transient data s\", \"tore that could disappear at any time.  \\nEnsure that data is maintained in the original data store a\", \"s well as the cache. The chances of losing \\ndata are then minimized if the cache becomes unavailable\", \".  \\nManaging data expiration  \\nIt\\u2019s impractical to expect that cached data will always be consistent\", \" with the original data. Data in the \\noriginal data store might change after it\\u2019s been cached, causi\", \"ng the cached data to become stale. \\nTherefore, apps should implement a strategy that helps to ensur\", \"e that the data in the cache is as up -\\nto-date as possible, but can also detect and handle situatio\", \"ns that ari se when the data in the cache \\nhas become stale. Most caching mechanisms enable the cach\", \"e to be configured to expire data, and \\nhence reduce the period for which data might be out of date.\", \"  \\nTip \\nSet a default expiration time when configuring a cache.  \\nMany caches implement expiration, \", \"which invalidates data and removes it from the cache if it\\u2019s not \\naccessed for a specified period. H\", \"owever, care must be taken when choosing the expiration period. If \\nit\\u2019s made too short, data will e\", \"xpire too quickly and th e benefits of caching will be reduced. If it\\u2019s \\nmade too long, the data ris\", \"ks becoming stale. Therefore, the expiration time should match the pattern \\nof access for apps that \", \"use the data.  \\nWhen cached data expires, it should be removed from the cache, and the app must retr\", \"ieve the data \\nfrom the original data store and place it back into the cache.  \\nIt\\u2019s also possible t\", \"hat a cache might fill up if data is allowed to remain for too long a period. Therefore, \\nrequests t\", \"o add new items to the cache might be required to remove some items in a process known \\nas eviction \", \". Caching services typically evict data on a least -recently -used basis. However, there are \\nother \", \"eviction policies, including most -recently -used, and first -in-first-out. For more information, se\", \"e \\nCaching Guidance  on Microsoft Docs.  \\nCaching images  \\nThe eShop multi -platform app consumes re\", \"mote product images that benefit from being cached. \\nThese images are displayed by the Image control\", \". The .NET MAUI Image control supports caching of  \\n70 CHAPTER 10 | Accessing remote data  \\n downloa\", \"ded images which has caching enabled by default, and will store the image locally for 24 \\nhours. In \", \"addition, the expiration time can be configured with the CacheValidity property. For more \\ninformati\", \"on, see Downloaded Image Caching  on the Microsoft Developer Center.  \\nIncreasing resilience  \\nAll a\", \"pps that communicate with remote services and resources must be sensitive to transient faults. \\nTran\", \"sient faults include the momentary loss of network connectivity to services, the temporary \\nunavaila\", \"bility of a service, or timeouts that arise when a se rvice is busy. These faults are often self -\\nc\", \"orrecting, and if the action is repeated after a suitable delay it\\u2019s likely to succeed.  \\nTransient \", \"faults can have a huge impact on the perceived quality of an app, even if it has been \\nthoroughly te\", \"sted under all foreseeable circumstances. To ensure that an app that communicates with \\nremote servi\", \"ces operates reliably, it must be able to do all  of the following:  \\n\\u2022 Detect faults when they occu\", \"r, and determine if the faults are likely to be transient.  \\n\\u2022 Retry the operation if it determines \", \"that the fault is likely to be transient and keep track of the \\nnumber of times the operation was re\", \"tried.  \\n\\u2022 Use an appropriate retry strategy, which specifies the number of retries, the delay betwe\", \"en \\neach attempt, and the actions to take after a failed attempt.  \\nThis transient fault handling ca\", \"n be achieved by wrapping all attempts to access a remote service in \\ncode that implements the retry\", \" pattern.  \\nRetry pattern  \\nIf an app detects a failure when it tries to send a request to a remote \", \"service, it can handle the failure \\nin any of the following ways:  \\n\\u2022 Retrying the operation. The ap\", \"p could retry the failing request immediately.  \\n\\u2022 Retrying the operation after a delay. The app sho\", \"uld wait for a suitable amount of time before \\nretrying the request.  \\n\\u2022 Cancelling the operation. T\", \"he application should cancel the operation and report an \\nexception.  \\nThe retry strategy should be \", \"tuned to match the business requirements of the app. For example, it\\u2019s \\nimportant to optimize the re\", \"try count and retry interval to the operation being attempted. If the \\noperation is part of a user i\", \"nteraction, the retry interval should be short and only a few retries \\nattempted to avoid making use\", \"rs wait for a response. If the operation is part of a long running \\nworkf low, where cancelling or r\", \"estarting the workflow is expensive or time -consuming, it\\u2019s appropriate \\nto wait longer between att\", \"empts and to retry more times.  \\nNote  \\nAn aggressive retry strategy with minimal delay between atte\", \"mpts, and a large number of retries, \\ncould degrade a remote service that\\u2019s running close to or at c\", \"apacity. In addition, such a retry strategy \\ncould also affect the responsiveness of the app if it \\u2019\", \"s continually trying to perform a failing operation.   \\n71 CHAPTER 10 | Accessing remote data  \\n If \", \"a request still fails after a number of retries, it\\u2019s better for the app to prevent further requests\", \" going \\nto the same resource and to report a failure. Then, after a set period, the app can make one\", \" or more \\nrequests to the resource to see if they\\u2019re su ccessful. For more information, see Circuit \", \"breaker pattern . \\nTip \\nNever implement an endless retry mechanism. Instead, prefer an exponential b\", \"ackoff.  \\nUse a finite number of retries, or implement the Circuit Breaker  pattern to allow a servi\", \"ce to recover.  \\nThe eShop reference application does implement the retry pattern.  \\nFor more inform\", \"ation about the retry pattern, see the Retry  pattern on Microsoft Docs.  \\nCircuit breaker pattern  \", \"\\nIn some situations, faults can occur due to anticipated events that take longer to fix. These fault\", \"s can \\nrange from a partial loss of connectivity to the complete failure of a service. In these situ\", \"ations, it\\u2019s \\npointless for an app to retry an operation th at\\u2019s unlikely to succeed, and instead sh\", \"ould accept that \\nthe operation has failed and handle this failure accordingly.  \\nThe circuit breake\", \"r pattern can prevent an app from repeatedly trying to execute an operation that\\u2019s \\nlikely to fail, \", \"while also enabling the app to detect whether the fault has been resolved.  \\nNote  \\nThe purpose of t\", \"he circuit breaker pattern is different from the retry pattern. The retry pattern enables \\nan app to\", \" retry an operation in the expectation that it\\u2019ll succeed. The circuit breaker pattern prevents \\nan \", \"app from performing an operation that\\u2019s li kely to fail.  \\nA circuit breaker acts as a proxy for ope\", \"rations that might fail. The proxy should monitor the number \\nof recent failures that have occurred,\", \" and use this information to decide whether to allow the \\noperation to proceed, or to return an exce\", \"ption immediately . \\nThe eShop multi -platform app does not currently implement the circuit breaker \", \"pattern. However, the \\neShop does.  \\nTip \\nCombine the retry and circuit breaker patterns.  \\nAn app c\", \"an combine the retry and circuit breaker patterns by using the retry pattern to invoke an \\noperation\", \" through a circuit breaker. However, the retry logic should be sensitive to any exceptions \\nreturned\", \" by the circuit breaker and abandon retry attempts  if the circuit breaker indicates that a fault \\ni\", \"s not transient.  \\nFor more information about the circuit breaker pattern, see the Circuit Breaker  \", \"pattern on Microsoft \\nDocs.   \\n72 CHAPTER 10 | Accessing remote data  \\n Summary  \\nMany modern web -b\", \"ased solutions make use of web services, hosted by web servers, to provide \\nfunctionality for remote\", \" client applications. The operations that a web service exposes constitute a \\nweb API, and client ap\", \"ps should be able to utilize the web API without knowing how the data or \\noperations that the API ex\", \"poses are implemented.  \\nThe performance of an app can be improved by caching frequently accessed da\", \"ta to fast storage \\nthat\\u2019s located close to the app. Apps can implement read -through caching with t\", \"he cache -aside \\npattern. This pattern determines whether the item is currently in th e cache. If th\", \"e item isn\\u2019t in the \\ncache, it\\u2019s read from the data store and added to the cache.  \\nWhen communicati\", \"ng with web APIs, apps must be sensitive to transient faults. Transient faults \\ninclude the momentar\", \"y loss of network connectivity to services, the temporary unavailability of a \\nservice, or timeouts \", \"that arise when a service is busy. These f aults are often self -correcting, and if the \\naction is r\", \"epeated after a suitable delay, then it\\u2019s likely to succeed. Therefore, apps should wrap all \\nattemp\", \"ts to access a web API in code that implements a transient fault handling mechanism.   \\n73 CHAPTER 1\", \"1 | Authentication and authorization  \\n CHAPTER  11 \\nAuthentication and \\nauthorization  \\nAuthenticat\", \"ion is the process of obtaining identification credentials such as name and password from \\na user an\", \"d validating those credentials against an authority. The entity that submitted the credentials \\nis c\", \"onsidered an authenticated identity if the cred entials are valid. Once an identity has been \\nestabl\", \"ished, an authorization process determines whether that identity has access to a given resource.  \\nT\", \"here are many approaches to integrating authentication and authorization into a .NET MAUI app that \\n\", \"communicates with an ASP.NET web application, including using ASP.NET Core Identity, external \\nauthe\", \"ntication providers such as Microsoft, Google, Facebook, or Twitter, and authentication \\nmiddleware.\", \" The eShop multi -platform app performs authentication and authorization with a \\ncontainerized ident\", \"ity microservice that uses IdentityServer. The app requests security tokens from \\nIdentityServer to \", \"authenticate a us er or access a resource. For IdentityServer to issue tokens on behalf \\nof a user, \", \"the user must sign in to IdentityServer. However, IdentityServer doesn\\u2019t provide a user \\ninterface o\", \"r database for authentication. Therefore, in the eShop reference application , ASP.NET Core \\nIdentit\", \"y is used for this purpose.  \\nAuthentication  \\nAuthentication is required when an application needs \", \"to know the current user\\u2019s identity. ASP.NET \\nCore\\u2019s primary mechanism for identifying users is the \", \"ASP.NET Core Identity membership system, \\nwhich stores user information in a data store configured b\", \"y the  developer. Typically, this data store \\nwill be an EntityFramework store, though custom stores\", \" or third -party packages can be used to store \\nidentity information in Azure storage, DocumentDB, o\", \"r other locations.  \\nFor authentication scenarios that use a local user datastore and persist identi\", \"ty information between \\nrequests via cookies (as is typical in ASP.NET web applications), ASP.NET Co\", \"re Identity is a suitable \\nsolution. However, cookies are not always a natural means of persisting a\", \"nd transmitting data. For \\nexample, an ASP.NET Core web application that exposes RESTful endpoints t\", \"hat are accessed from an \\napp will typically need to use bearer token authentication since cookies c\", \"an\\u2019t be used in this scenario. \\nHoweve r, bearer tokens can easily be retrieved and included in the \", \"authorization header of web \\nrequests made from the app.   \\n74 CHAPTER 11 | Authentication and autho\", \"rization  \\n Issuing bearer tokens using IdentityServer  \\nIdentityServer  is an open -source OpenID C\", \"onnect and OAuth 2.0 framework for ASP.NET Core, which \\ncan be used for many authentication and auth\", \"orization scenarios, including issuing security tokens for \\nlocal ASP.NET Core Identity users.  \\nNot\", \"e  \\nOpenID Connect and OAuth 2.0 are very similar, while having different responsibilities.  \\nOpenID\", \" Connect is an authentication layer on top of the OAuth 2.0 protocol. OAuth 2 is a protocol \\nthat al\", \"lows applications to request access tokens from a security token service and use them to \\ncommunicat\", \"e with APIs. This delegation reduces complexity in both client applications and APIs since \\nauthenti\", \"cation and authorization can be centralized.  \\nOpenID Connect and OAuth 2.0 combine the two fundamen\", \"tal security concerns of authentication \\nand API access, and IdentityServer is an implementation of \", \"these protocols.  \\nIn applications that use direct client -to-microservice communication, such as th\", \"e eShop reference \\napplication, a dedicated authentication microservice acting as a Security Token S\", \"ervice (STS) can be \\nused to authenticate users, as shown in the following dia gram. For more inform\", \"ation about direct \\nclient -to-microservice communication, see Microservices . \\n \\nThe eShop multi -p\", \"latform app communicates with the identity microservice, which uses IdentityServer \\nto perform authe\", \"ntication, and access control for APIs. Therefore, the multi -platform app requests \\ntokens from Ide\", \"ntityServer, either for authenticating a u ser or for accessing a resource:  \\n\\u2022 Authenticating users\", \" with IdentityServer is achieved by the multi -platform app requesting an \\nidentity  token, represen\", \"ting an authentication process\\u2019s outcome. At a minimum, it contains \\nan identifier for the user and \", \"information about how and when the user is authenticated. It \\ncan also include additional identity d\", \"ata.  \\n\\u2022 Accessing a resource with IdentityServer is achieved by the multi -platform app requesting \", \"an \\naccess  token, which allows access to an API resource. Clients request access tokens and \\nforwar\", \"d them to the API. Access tokens contain information about the client and the user, if \\npresent. API\", \"s then use that information to authorize access to their data.  \\nNote  \\nA client must be registered \", \"with IdentityServer before it can successfully request tokens. For more \\ninformation on adding clien\", \"ts, see Defining Clients . \\n \\n75 CHAPTER 11 | Authentication and authorization  \\n Adding IdentitySer\", \"ver to a web application  \\nIn order for an ASP.NET Core web application to use IdentityServer, it mu\", \"st be added to the web \\napplication\\u2019s Visual Studio solution. For more information, see Setup and Ov\", \"erview  in the \\nIdentityServer documentation. Once IdentityServer is included in the web application\", \"\\u2019s Visual Studio \\nsolution, it must be added to its HTTP request processing pipeline to serve reques\", \"ts to OpenID \\nConnect and OAuth 2.0 endpoints. This is configured in the Identity.API project\\u2019s Prog\", \"ram.cs, as \\ndemonstrated in the following code example:  \\n \\n... \\n \\napp.UseIdentityServer (); \\nOrder \", \"matters in the web application\\u2019s HTTP request processing pipeline. Therefore, IdentityServer \\nmust b\", \"e added to the pipeline before the UI framework that implements the login screen.  \\nConfiguring Iden\", \"tityServer  \\nIdentityServer should be configured in the ConfigureServices method in the web applicat\", \"ion\\u2019s Startup \\nclass by calling the services.AddIdentityServer method, as demonstrated in the follow\", \"ing code \\nexample from the eShop reference application:  \\npublic void ConfigureServices (IServiceCol\", \"lection  services ) \\n{ \\n    services  \\n        .AddIdentityServer (x => x.IssuerUri  = \\\"null\\\") \\n    \", \"    .AddSigningCredential (Certificate .Get()) \\n        .AddAspNetIdentity <ApplicationUser >() \\n   \", \"     .AddConfigurationStore (builder => \\n            builder.UseSqlServer (connectionString , option\", \"s => \\n                options.MigrationsAssembly (migrationsAssembly ))) \\n        .AddOperationalSto\", \"re (builder => \\n            builder.UseSqlServer (connectionString , options => \\n                opt\", \"ions.MigrationsAssembly (migrationsAssembly ))) \\n        .Services .AddTransient <IProfileService , \", \"ProfileService >(); \\n} \\nAfter calling the services.AddIdentityServer method, additional fluent APIs \", \"are called to configure the \\nfollowing:  \\n\\u2022 Credentials used for signing.  \\n\\u2022 API and identity resou\", \"rces that users might request access to.  \\n\\u2022 Clients that will be connecting to request tokens.  \\n\\u2022 \", \"ASP.NET Core Identity.  \\nTip \\nDynamically load the IdentityServer configuration. IdentityServer\\u2019s AP\", \"Is allow for configuring \\nIdentityServer from an in -memory list of configuration objects. In the eS\", \"hop reference application, \\nthese in -memory collections are hard -coded into the applicati on. Howe\", \"ver, in production scenarios \\nthey can be loaded dynamically from a configuration file or from a dat\", \"abase.   \\n76 CHAPTER 11 | Authentication and authorization  \\n For information about configuring Iden\", \"tityServer to use ASP.NET Core Identity, see Using ASP.NET \\nCore Identity  in the IdentityServer doc\", \"umentation.  \\nConfiguring API resources  \\nWhen configuring API resources, the AddInMemoryApiResource\", \"s method expects an \\nIEnumerable<ApiResource> collection. The following code example shows the GetAp\", \"is method that \\nprovides this collection in the eShop reference application:  \\npublic static IEnumer\", \"able <ApiResource > GetApis() \\n{ \\n    return new List<ApiResource > \\n    { \\n        new ApiScope (\\\"o\", \"rders\\\" , \\\"Orders Service\\\" ), \\n        new ApiScope (\\\"basket\\\" , \\\"Basket Service\\\" ), \\n        new ApiS\", \"cope (\\\"webhooks\\\" , \\\"Webhooks registration Service\\\" ), \\n    }; \\n} \\nThis method specifies that Identit\", \"yServer should protect the orders and basket APIs. Therefore, \\nIdentityServer -managed access tokens\", \" will be required when making calls to these APIs. For more \\ninformation about the ApiResource type,\", \" see API Resource  in the IdentityServer documentation.  \\nConfiguring identity resources  \\nWhen conf\", \"iguring identity resources, the AddInMemoryIdentityResources method expects an \\nIEnumerable<Identity\", \"Resource> collection. Identity resources are data such as user ID, name, or email \\naddress. Each ide\", \"ntity resource has a unique name, and arbitrary c laim types can be assigned to it, \\nwhich will be i\", \"ncluded in the identity token for the user. The following code example shows the \\nGetResources metho\", \"d that provides this collection in the eShop reference application:  \\npublic static IEnumerable <Ide\", \"ntityResource > GetResources () \\n{ \\n    return new List<IdentityResource > \\n    { \\n        new Ident\", \"ityResources .OpenId(), \\n        new IdentityResources .Profile() \\n    }; \\n} \\nThe OpenID Connect spe\", \"cification specifies some standard identity resources . The minimum \\nrequirement is that support is \", \"provided for emitting a unique ID for users. This is achieved by \\nexposing the IdentityResources.Ope\", \"nId identity resource.  \\nNote  \\nThe IdentityResources class supports all of the scopes defined in th\", \"e OpenID Connect specification \\n(openid, email, profile, telephone, and address).  \\nIdentityServer a\", \"lso supports defining custom identity resources. For more information, see Defining \\ncustom identity\", \" resources  in the IdentityServer documentation. For more information about the \\nIdentityResource ty\", \"pe, see Identity Resource  in the IdentityServer documentation.   \\n77 CHAPTER 11 | Authentication an\", \"d authorization  \\n Configuring clients  \\nClients are applications that can request tokens from Ident\", \"ityServer. Typically, the following settings \\nmust be defined for each client as a minimum:  \\n\\u2022 A un\", \"ique client ID.  \\n\\u2022 The allowed interactions with the token service (known as the grant type).  \\n\\u2022 T\", \"he location where identity and access tokens are sent to (known as a redirect URI).  \\n\\u2022 A list of re\", \"sources that the client is allowed access to (known as scopes).  \\nWhen configuring clients, the AddI\", \"nMemoryClients method expects an IEnumerable<Client> \\ncollection. The following code example shows t\", \"he configuration for the eShop multi -platform app in \\nthe GetClients method that provides this coll\", \"ection in the eShop refer ence application:  \\npublic static IEnumerable <Client> GetClients (Diction\", \"ary <string,string> clientsUrl ) \\n{ \\n    return new List<Client> \\n    { \\n        // Omitted for brev\", \"ity  \\n        new Client \\n        { \\n            ClientId  = \\\"maui\\\", \\n            ClientName  = \\\"eSh\", \"op .NET MAUI  OpenId Client\\\", \\n            AllowedGrantTypes  = GrantTypes .Hybrid, \\n            Cli\", \"entSecrets  = \\n            { \\n                new Secret(\\\"secret\\\" .Sha256()) \\n            }, \\n      \", \"      RedirectUris  = { clientsUrl [\\\"maui\\\"] }, \\n            RequireConsent  = false, \\n            Re\", \"quirePkce  = true, \\n            PostLogoutRedirectUris  = { $\\\"{clientsUrl[\\\" maui\\\"]}/Account/Redirect\", \"ing\\\"  }, \\n            AllowedCorsOrigins  = { \\\"http://eshopmaui\\\"  }, \\n            AllowedScopes  = n\", \"ew List<string> \\n            { \\n                IdentityServerConstants .StandardScopes .OpenId, \\n  \", \"              IdentityServerConstants .StandardScopes .Profile, \\n                IdentityServerConst\", \"ants .StandardScopes .OfflineAccess , \\n                \\\"orders\\\" , \\n                \\\"basket\\\"  \\n      \", \"      }, \\n            AllowOfflineAccess  = true, \\n            AllowAccessTokensViaBrowser  = true, \", \"\\n            AccessTokenLifetime = 60 * 60 * 2, // 2 hours  \\n            IdentityTokenLifetime = 60 \", \"* 60 * 2 // 2 hours  \\n        } \\n    }; \\n} \\nThis configuration specifies data for the following prop\", \"erties:  \\nProperty  Description  \\nClientId  A unique ID for the client.  \\nClientName  The client dis\", \"play name, which is used for \\nlogging and the consent screen.   \\n78 CHAPTER 11 | Authentication and \", \"authorization  \\n Property  Description  \\nAllowedGrantTypes  Specifies how a client wants to interact\", \" with \\nIdentityServer. For more information see \\nConfiguring the authentication flow . \\nClientSecret\", \"s  Specifies the client secret credentials that are \\nused when requesting tokens from the token \\nend\", \"point.  \\nRedirectUris  Specifies the allowed URIs to which to return \\ntokens or authorization codes.\", \"  \\nRequireConsent  Specifies whether a consent screen is required.  \\nRequirePkce  Specifies whether \", \"clients using an authorization \\ncode must send a proof key.  \\nPostLogoutRedirectUris  Specifies the \", \"allowed URIs to redirect to after \\nlogout.  \\nAllowedCorsOrigins  Specifies the origin of the client \", \"so that \\nIdentityServer can allow cross -origin calls from \\nthe origin.  \\nAllowedScopes  Specifies t\", \"he resources the client has access to. \\nBy default, a client has no access to any \\nresources.  \\nAllo\", \"wOfflineAccess  Specifies whether the client can request refresh \\ntokens.  \\nAllowAccessTokensViaBrow\", \"ser  Specifies whether the client can receive access \\ntokens from a browser window.  \\nAlwaysIncludeU\", \"serClaimsInIdToken  Specifies that the user claims will always be \\nadded to the id token. By default\", \", these would \\nhave to be retrieved using the userinfo \\nendpoint.  \\nAccessTokenLifetime  Specifies t\", \"he lifetime of the access token in \\nseconds.  \\nIdentityTokenLifetime  Specifies the lifetime of the \", \"identity token in \\nseconds.  \\nConfiguring the authentication flow  \\nThe authentication flow between \", \"a client and IdentityServer can be configured by specifying the grant \\ntypes in the Client.AllowedGr\", \"antTypes property. The OpenID Connect and OAuth 2.0 specifications \\ndefine several authentication fl\", \"ows, including:   \\n79 CHAPTER 11 | Authentication and authorization  \\n Authentication Flow  Descript\", \"ion  \\nImplicit  This flow is optimized for browser -based \\napplications and should be used either fo\", \"r user \\nauthentication -only, or authentication and \\naccess token requests. All tokens are \\ntransmit\", \"ted via the browser, and therefore \\nadvanced features like refresh tokens are n ot \\npermitted.  \\nAut\", \"horization code  This flow provides the ability to retrieve tokens \\non a back channel, as opposed to\", \" the browser \\nfront channel, while also supporting client \\nauthentication.  \\nHybrid  This flow is a \", \"combination of the implicit and \\nauthorization code grant types. The identity \\ntoken is transmitted \", \"via the browser channel \\nand contains the signed protocol response and \\nother artifacts such as the \", \"authorization code. \\nAfter successfully valida ting the response, the \\nback channel should be used t\", \"o retrieve the \\naccess and refresh token.  \\nTip \\nConsider using the hybrid authentication flow. The \", \"hybrid authentication flow mitigates a number of \\nattacks that apply to the browser channel, and is \", \"the recommended flow for native applications that \\nwant to retrieve access tokens (and possibly refr\", \"esh tok ens). \\nFor more information about authentication flows, see Grant Types  in the IdentityServ\", \"er \\ndocumentation.  \\nPerforming authentication  \\nFor IdentityServer to issue tokens on behalf of a u\", \"ser, the user must sign in to IdentityServer. However, \\nIdentityServer doesn\\u2019t provide a user interf\", \"ace or database for authentication. Therefore, in the eShop \\nreference application, ASP.NET Core Ide\", \"ntity i s used for this purpose.  \\nThe eShop multi -platform app authenticates with IdentityServer w\", \"ith the hybrid authentication flow, \\nwhich is illustrated in the diagram below.   \\n80 CHAPTER 11 | A\", \"uthentication and authorization  \\n  \\nA sign in request is made to <base endpoint>:5105/connect/autho\", \"rize. Following successful \\nauthentication, IdentityServer returns an authentication response contai\", \"ning an authorization code \\nand an identity token. The authorization code is sent to <base endp oint\", \">:5105/connect/token, which \\nresponds with access, identity, and refresh tokens.  \\nThe eShop multi -\", \"platform app signs out of IdentityServer by sending a request to <base \\nendpoint>:5105/connect/endse\", \"ssion with additional parameters. After sign -out, IdentityServer \\nresponds by sending a post -logou\", \"t redirecting URI back to the multi -platform  app. The diagram \\nbelow illustrates this process.  \\n \", \"\\nIn the eShop multi -platform app, communication with IdentityServer is performed by the \\nIdentitySe\", \"rvice class, which implements the IIdentityService interface. This interface specifies that the \\nimp\", \"lementing class must provide SignInAsync, SignOutAsync, GetUserInfoAsync and \\nGetAuthTokenAsync meth\", \"ods.  \\nSigning -in \\nWhen the user taps the LOGIN button on the LoginView, the SignInCommand in the L\", \"oginViewModel \\nclass is executed, which in turn executes the SignInAsync method. The following code \", \"example shows \\nthis method:  \\n[RelayCommand ] \\nprivate async Task SignInAsync () \\n{ \\n    await IsBus\", \"yFor ( \\n        async () => \\n        { \\n            var loginSuccess = await _appEnvironmentService \", \".IdentityService .SignInAsync (); \\n \\n            if (loginSuccess ) \\n            { \\n                \", \"await NavigationService .NavigateToAsync (\\\"//Main/Catalog\\\" ); \\n            } \\n \\n81 CHAPTER 11 | Auth\", \"entication and authorization  \\n         }); \\n} \\nThis method invokes the SignInAsync method in the Id\", \"entityService class, as shown in the following \\ncode example:  \\npublic async Task <bool> SignInAsync\", \" () \\n{ \\n    var response = await GetClient ().LoginAsync (new LoginRequest ()).ConfigureAwait (false\", \"); \\n \\n    if (response .IsError) \\n    { \\n        return false; \\n    } \\n \\n    await _settingsService \", \" \\n        .SetUserTokenAsync ( \\n            new UserToken  \\n            { \\n                AccessTok\", \"en = response .AccessToken , \\n                IdToken = response .IdentityToken , \\n                R\", \"efreshToken = response .RefreshToken , \\n                ExpiresAt = response .AccessTokenExpiration \", \" \\n            }) \\n        .ConfigureAwait (false); \\n \\n    return !response .IsError; \\n} \\nThe Identit\", \"yService makes use of the OidcClient provided with the IdentityModel.OidcClient NuGet \\npackage. This\", \" client displays the authentication web view to the user in the application and captures \\nthe authen\", \"tication result. The client connects to the URI  for IdentityServer\\u2019s authorization endpoint  \\nwith \", \"the required parameters. The authorization endpoint is at /connect/authorize on port 5105 of the \\nba\", \"se endpoint exposed as a user setting. For more information about user settings, see Configuration \\n\", \"Management . \\nNote  \\nThe attack surface of the eShop multi -platform app is reduced by implementing \", \"the Proof Key for \\nCode Exchange (PKCE) extension to OAuth. PKCE protects the authorization code fro\", \"m being used if \\nit\\u2019s intercepted. This is achieved by the client generating a s ecret verifier, a h\", \"ash of which is passed in \\nthe authorization request, and which is presented unhashed when redeeming\", \" the authorization code. \\nFor more information about PKCE, see Proof Key for Code Exchange by OAuth \", \"Public Clients  on the \\nInternet Engineering Task Force web site.   \\n82 CHAPTER 11 | Authentication \", \"and authorization  \\n  \\nIf the token endpoint receives valid authentication information, authorizatio\", \"n code, and PKCE secret \\nverifier, it responds with an access token, identity token, and refresh tok\", \"en. The access token (which \\nallows access to API resources) and identity token a re stored as appli\", \"cation settings, and page \\nnavigation is performed. Therefore, the overall effect in the eShop multi\", \" -platform app is this: provided \\nthat users are able to successfully authenticate with IdentityServ\", \"er, they are navigated to the \\n//Main/Cata log route, which is a TabbedPage that displays the Catalo\", \"gView as its selected tab.  \\n \\n83 CHAPTER 11 | Authentication and authorization  \\n For information a\", \"bout page navigation, see Navigation . For information about how WebView \\nnavigation causes a view m\", \"odel method to be executed, see Invoking navigation using behaviors . For \\ninformation about applica\", \"tion settings, see Configuration management . \\nNote  \\nThe eShop also allows a mock sign in when the \", \"app is configured to use mock services in the \\nSettingsView. In this mode, the app doesn\\u2019t communica\", \"te with IdentityServer, instead allowing the \\nuser to sign in using any credentials.  \\nSigning -out \", \"\\nWhen the user taps the LOG OUT button in the ProfileView, the LogoutCommand in the \\nProfileViewMode\", \"l class is executed, which executes the LogoutAsync method. This method performs \\npage navigation to\", \" the LoginView page, passing a Logout query parameter set t o true.  \\nThat parameter is evaluated in\", \" the ApplyQueryAttributes method. If the Logout parameter is present \\nwith a true value, the Perform\", \"LogoutAsync method of the LoginViewModel class is executed, which is \\nshown in the following code ex\", \"ample:  \\nprivate async Task PerformLogoutAsync () \\n{ \\n    await _appEnvironmentService .IdentityServ\", \"ice .SignOutAsync (); \\n \\n    _settingsService .UseFakeLocation  = false; \\n \\n    UserName .Value = st\", \"ring.Empty; \\n    Password .Value = string.Empty; \\n} \\nThis method invokes the SignOutAsync method in \", \"the IdentityService class, which invokes the \\nOidcClient to end the user\\u2019s session and clears any sa\", \"ved user tokens. For more information about \\napplication settings, see Configuration management . Th\", \"e following code example shows the \\nSignOutAsync method:  \\npublic async Task <bool> SignOutAsync () \", \"\\n{ \\n    var response = await GetClient ().LogoutAsync (new \\nLogoutRequest ()).ConfigureAwait (false)\", \"; \\n \\n    if (response .IsError) \\n    { \\n        return false; \\n    } \\n \\n    await _settingsService .\", \"SetUserTokenAsync (default); \\n \\n    return !response .IsError; \\n} \\nThis method uses the OidcClient t\", \"o call the URI to IdentityServer\\u2019s end session endpoint  with the \\nrequired parameters. The end sess\", \"ion endpoint is at /connect/endsession on port 5105 of the base \\nendpoint exposed as a user setting.\", \" Once the user has successfully signed out, LoginView is presented \\nto the user, and any saved user \", \"information wil l be cleared.   \\n84 CHAPTER 11 | Authentication and authorization  \\n For information\", \" about page navigation, see Navigation . For information about how WebView \\nnavigation causes a view\", \" model method to be executed, see Invoking navigation using behaviors . For \\ninformation about appli\", \"cation settings, see Configuration management . \\nNote  \\nThe eShop also allows a mock sign -out when \", \"the app is configured to use mock services in the \\nSettingsView. In this mode, the app doesn\\u2019t commu\", \"nicate with IdentityServer, and instead clears any \\nstored tokens from application settings.  \\nAutho\", \"rization  \\nAfter authentication, ASP.NET Core web APIs often need to authorize access, which allows \", \"a service to \\nmake APIs available to some authenticated users but not to all.  \\nRestricting access t\", \"o an ASP.NET Core route can be achieved by applying an Authorize attribute to a \\ncontroller or actio\", \"n, which limits access to the controller or action to authenticated users, as shown in \\nthe followin\", \"g code example:  \\n[Authorize ] \\npublic sealed class  BasketController  : Controller  \\n{ \\n    // Omit\", \"ted for brevity  \\n} \\nIf an unauthorized user attempts to access a controller or action marked with t\", \"he Authorize attribute, \\nthe API framework returns a 401 (unauthorized) HTTP status code.  \\nNote  \\nP\", \"arameters can be specified on the Authorize attribute to restrict an API to specific users. For more\", \" \\ninformation, see ASP.NET Core Docs: Authorization . \\nIdentityServer can be integrated into the aut\", \"horization workflow so that the access tokens provide \\ncontrol authorization. This approach is shown\", \" in the diagram below.   \\n85 CHAPTER 11 | Authentication and authorization  \\n  \\nThe eShop multi -pla\", \"tform app communicates with the identity microservice and requests an access \\ntoken as part of the a\", \"uthentication process. The access token is then forwarded to the APIs exposed \\nby the ordering and b\", \"asket microservices as part of the acce ss requests. Access tokens contain \\ninformation about the cl\", \"ient and the user. APIs then use that information to authorize access to their \\ndata. For informatio\", \"n about how to configure IdentityServer to protect APIs, see Configuring API \\nresources . \\nConfiguri\", \"ng IdentityServer to perform authorization  \\nTo perform authorization with IdentityServer, its autho\", \"rization middleware must be added to the web \\napplication\\u2019s HTTP request pipeline. The middleware is\", \" added in the AddDefaultAuthentication \\nextension method, which is invoked from the AddApplicationSe\", \"rvi ces method in the Program class \\nand is demonstrated in the following code example from the eSho\", \"p reference application:  \\npublic static IServiceCollection AddDefaultAuthentication (this IHostAppl\", \"icationBuilder \\nbuilder) \\n{ \\n    var services = builder.Services ; \\n    var configuration = builder.\", \"Configuration ; \\n \\n    var identitySection = configuration .GetSection (\\\"Identity\\\" ); \\n \\n    if (!id\", \"entitySection .Exists()) \\n    { \\n        // No identity section, so no authentication  \\n        retu\", \"rn services ; \\n    } \\n \\n    // prevent from mapping \\\"sub\\\" claim to nameidentifier.  \\n    JsonWebToke\", \"nHandler .DefaultInboundClaimTypeMap .Remove(\\\"sub\\\"); \\n \\n    services .AddAuthentication ().AddJwtBea\", \"rer (options => \\n    { \\n \\n86 CHAPTER 11 | Authentication and authorization  \\n         var identityUr\", \"l = identitySection .GetRequiredValue (\\\"Url\\\"); \\n        var audience = identitySection .GetRequiredV\", \"alue (\\\"Audience\\\" ); \\n \\n        options.Authority  = identityUrl ; \\n        options.RequireHttpsMetad\", \"ata  = false; \\n        options.Audience  = audience ; \\n        options.TokenValidationParameters .Va\", \"lidIssuers  = [identityUrl ]; \\n        options.TokenValidationParameters .ValidateAudience  = false;\", \" \\n    }); \\n \\n    services .AddAuthorization (); \\n \\n    return services ; \\n} \\nThis method ensures tha\", \"t the API can only be accessed with a valid access token. The middleware \\nvalidates the incoming tok\", \"en to ensure that it\\u2019s sent from a trusted issuer and validates that the token \\nis valid to be used \", \"with the API that receives it. Ther efore, browsing to the ordering or basket \\ncontroller will retur\", \"n a 401 (unauthorized) HTTP status code, indicating that an access token is \\nrequired.  \\nMaking acce\", \"ss requests to APIs  \\nWhen making requests to the ordering and basket microservices, the access toke\", \"n obtained from \\nIdentityServer during the authentication process must be included in the request, a\", \"s shown in the \\nfollowing code example:  \\npublic async Task CreateOrderAsync (Models.Orders.Order ne\", \"wOrder ) \\n{ \\n    var authToken = await _identityService .GetAuthTokenAsync ().ConfigureAwait (false)\", \"; \\n \\n    if (string.IsNullOrEmpty (authToken )) \\n    { \\n        return; \\n    } \\n \\n    var uri = $\\\"{U\", \"riHelper.CombineUri(_settingsService.GatewayOrdersEndpointBase, \\nApiUrlBase)}?api -version=1.0\\\" ; \\n \", \"\\n    var success = await _requestProvider .PostAsync (uri, newOrder , authToken , \\\"x-\\nrequestid\\\" ).C\", \"onfigureAwait (false); \\n} \\nThe access token is stored with the IIdentityService implementation and c\", \"an be retrieved using the \\nGetAuthTokenAsync method.  \\nSimilarly, the access token must be included \", \"when sending data to an IdentityServer protected API, as \\nshown in the following code example:  \\npub\", \"lic async Task ClearBasketAsync () \\n{ \\n    var authToken = await _identityService .GetAuthTokenAsync\", \" ().ConfigureAwait (false); \\n \\n    if (string.IsNullOrEmpty (authToken )) \\n    { \\n        return;  \\n\", \"87 CHAPTER 11 | Authentication and authorization  \\n     } \\n \\n    await GetBasketClient ().DeleteBask\", \"etAsync (new DeleteBasketRequest (), \\nCreateAuthenticationHeaders (authToken )) \\n        .ConfigureA\", \"wait (false); \\n} \\nThe access token is retrieved from the IIdentityService and included in the call t\", \"o the ClearBasketAsync \\nmethod in the BasketService class.  \\nThe RequestProvider class in the eShop \", \"multi -platform app uses the HttpClient class to make requests \\nto the RESTful APIs exposed by the e\", \"Shop reference application. When making requests to the \\nordering and basket APIs, which require aut\", \"horization, a valid access token must be included with the \\nrequest. This is achieved by adding the \", \"access token to the headers of the HttpClient instance, as \\ndemonstrated in the following code examp\", \"le:  \\nhttpClient .DefaultRequestHeaders .Authorization  = new AuthenticationHeaderValue (\\\"Bearer\\\" , \", \"to\\nken); \\nThe DefaultRequestHeaders property of the HttpClient class exposes the headers that are se\", \"nt with \\neach request, and the access token is added to the Authorization header prefixed with the s\", \"tring \\nBearer. When the request is sent to a RESTful API, the value of the Authorization header is e\", \"xtracted \\nand validated to ensure that it\\u2019s sent from a trusted issuer and used to determine whether\", \" the user \\nhas permission to invoke the API that receives it.  \\nFor more information about how the e\", \"Shop multi -platform app makes web requests, see Accessing \\nremote data . \\nSummary  \\nThere are many \", \"approaches to integrating authentication and authorization into a .NET MAUI app that \\ncommunicates w\", \"ith an ASP.NET web application. The eShop multi -platform app performs \\nauthentication and authoriza\", \"tion with a containerized identity microserv ice that uses IdentityServer. \\nIdentityServer is an ope\", \"n -source OpenID Connect and OAuth 2.0 framework for ASP.NET Core that \\nintegrates with ASP.NET Core\", \" Identity to perform bearer token authentication.  \\nThe multi -platform app requests security tokens\", \" from IdentityServer to authenticate a user or access a \\nresource. When accessing a resource, an acc\", \"ess token must be included in the request to APIs that \\nrequire authorization. IdentityServer\\u2019s midd\", \"leware vali dates incoming access tokens to ensure that \\nthey are sent from a trusted issuer and tha\", \"t they are valid to be used with the API that receives them.   \\n88 CHAPTER 12 | MVVM Toolkit Feature\", \"s  \\n CHAPTER  12 \\nMVVM Toolkit Features  \\nMVVM Toolkit  \\nThe Model -View -ViewModel (MVVM)  pattern \", \"is a great structural basis for creating our applications. \\nIn this pattern, the ViewModel becomes t\", \"he backbone of our application as it provides \\ncommunication to our front -end user interface and ba\", \"cking components. To provide integration with \\nthe user interface, we will rely on the ViewModel\\u2019s p\", \"roperties and commands. As detailed in Updating \\nviews in response to changes in the underlying view\", \" model or model , the INotifyPropertyChanged \\ninterface on our ViewModel to allows changes to our pr\", \"operties to notify when the value is changed. \\nImplementing all of these features means that our Vie\", \"wModel can end up becoming very verbose. For \\nexample, the following code shows a  simple ViewModel \", \"with properties that raise changes:  \\npublic class SampleViewModel : INotifyPropertyChanged  \\n{ \\n   \", \" private string _name; \\n    private int _value; \\n \\n    public event PropertyChangedEventHandler Prop\", \"ertyChanged ; \\n \\n    public string Name \\n    { \\n        get => _name; \\n        set => SetPropertyVal\", \"ue (ref _name, value); \\n    } \\n \\n    public int Value \\n    { \\n        get => _value; \\n        set =>\", \" SetPropertyValue (ref _value, value); \\n    } \\n \\n    protected  void SetPropertyValue <T>(ref T stor\", \"ageField , T newValue , [CallerMemberName ] \\nstring propertyName = \\\"\\\") \\n    { \\n        if (Equals(st\", \"orageField , newValue )) \\n            return; \\n \\n        storageField = newValue ; \\n        RaisePro\", \"pertyChanged (propertyName ); \\n    } \\n \\n    protected  virtual void RaisePropertyChanged ([CallerMem\", \"berName ] string propertyName = \\n\\\"\\\") \\n    { \\n        PropertyChanged ?.Invoke(this, new PropertyChan\", \"gedEventArgs (propertyName )); \\n    } \\n}  \\n89 CHAPTER 12 | MVVM Toolkit Features  \\n While some optim\", \"izations could be made over time, we will still end up with a fairly verbose set of \\ncode for defini\", \"ng our ViewModel. This code can be difficult to maintain and becomes error -prone.  \\nThe CommunityTo\", \"olkit.Mvvm NuGet Package  (aka MVVM Toolkit) can be used to help address and \\nsimplify these common \", \"MVVM patterns. The MVVM Toolkit, along with newer features to the .NET \\nlanguage, allows for simplif\", \"ied logic, easy adoption into a project, and runtime independence. The \\nexample belo w shows the sam\", \"e ViewModel using components that come with the MVVM Toolkit:  \\npublic partial class SampleViewModel\", \" : ObservableObject  \\n{ \\n    [ObservableProperty ] \\n    private string _name; \\n \\n    [ObservableProp\", \"erty ] \\n    private int _value; \\n} \\n \\n \\nNote  \\nThe MVVM Toolkit is provided with the CommunityToolki\", \"t.Mvvm package. For information on how to \\nadd the package to your project, see Introduction to the \", \"MVVM Toolkit  on the Microsoft Developer \\nCenter.  \\nIn comparison to the original example, we were a\", \"ble to drastically reduce the overall complexity and \\nsimplify the maintainability of our ViewModel.\", \" The MVVM Toolkit comes with many pre -built common \\ncomponents and features, such as the Observable\", \"Object shown above, that simplifies and \\nstandardizes the code that we have throughout the applicati\", \"on.  \\nObservableObject  \\nThe MVVM Toolkit provides ObservableObject which is intended for use as the\", \" base of our \\nViewModel objects or any object that needs to raise change notifications. It implement\", \"s \\nINotifyPropertyChanged and INotifyPropertyChanging along with helper methods for  setting \\nproper\", \"ties and raising changes. Below is an example of a standard ViewModel using \\nObservableObject:  \\npub\", \"lic class SampleViewModel : ObservableObject  \\n{ \\n    private string _name; \\n    private int _value;\", \" \\n \\n    public string Name \\n    { \\n        get => _name; \\n        set => SetProperty (ref _name, val\", \"ue); \\n    } \\n \\n    public int Value \\n    { \\n        get => _value; \\n        set => SetProperty (ref \", \"_value, value);  \\n90 CHAPTER 12 | MVVM Toolkit Features  \\n     } \\n} \\nObservableObject handles all of\", \" the logic needed for raising change notifications by using the \\nSetProperty method in your property\", \" setter. If you have a property that returns a Task<T>, the \\nSetPropertyAndNotifyOnCompletion method\", \" can be used to delay publishing a property change until \\nthe task has been completed. The methods O\", \"nPropertyChanged and OnPropertyChanging that can \\nalso be used for raising property changes where ne\", \"eded i n your object.  \\nFor more detailed information on ObservableObject, see ObservableObject  in \", \"the MVVM Toolkit \\nDeveloper Center.  \\nRelayCommand and AsyncRelayCommand  \\nInteraction between .NET \", \"MAUI controls (for example, tapping a button or selecting an item from a \\ncollection) and the ViewMo\", \"del is done with the ICommand interface. .NET MAUI comes with a default \\nimplementation of ICommand \", \"with the Command object. .NET MAU I\\u2019s Command is fairly basic and \\nlacks support for more advanced f\", \"eatures, such as supporting asynchronous work and command \\nexecution status.  \\nThe MVVM Toolkit come\", \"s with two commands, RelayCommand and AsyncRelayCommand. \\nRelayCommand is intended for situations wh\", \"ere you have synchronous code to execute and has a \\nfairly similar implementation to the .NET MAUI C\", \"ommand object.  \\nNote  \\nEven though the .NET MAUI Command and RelayCommand are similar, using RelayC\", \"ommand allows \\nfor decoupling your ViewModel from any direct .NET MAUI references. This means that y\", \"our \\nViewModel is more portable, leading to easier reuse across projects.  \\nAsyncRelayCommand provid\", \"es many additional features when working with asynchronous workflows. \\nThis is quite common in our V\", \"iewModel as we are typically communicating with repositories, APIs, \\ndatabases, and other systems th\", \"at utilize async/await. The AsyncR elayCommand constructor takes in \\nan execution task defined as a \", \"Func<Task> or a delegate returning Task as part of the constructor. \\nWhile the execution task is run\", \"ning, AsyncRelayCommand will monitor the state of the task and \\nprovides updates using the IsR unnin\", \"g property. The IsRunning property can be bound to the UI which \\nhelps manage control states such as\", \" showing loading with an ActivityIndicator or disabling/enabling a \\ncontrol. While the execution tas\", \"k is being executed, the Cancel method can be called to attempt \\ncancellation of the execution task,\", \" if supported.  \\nBy default, AsyncRelayCommand doesn\\u2019t allow concurrent execution. This is very help\", \"ful in situations \\nwhere a user could unintentionally tap a control multiple times to execute a long\", \" -running or costly \\noperation. During task execution, AsyncRelayCommand wil l automatically call th\", \"e CanExecuteChanged \\nevent. In .NET MAUI, controls that support the Command and CommandParameter pro\", \"perties, such as \\nButton, will listen to this event and automatically enable or disable it during ex\", \"ecution. This \\nfunctionality can be overridden by using a custom canExecute parameter or setting the\", \" \\nAsyncRelayCommandOptions.AllowConcurrentExecutions flag in the constructor.   \\n91 CHAPTER 12 | MVV\", \"M Toolkit Features  \\n For more detailed information on implementing commands, see the section Implem\", \"enting commands  \\nin the MVVM chapter. Detailed information for the RelayCommand and AsyncRelayComma\", \"nd is \\navailable in the Commanding  of the MVVM Toolkit Developer Center.  \\nSource Generators  \\nUsin\", \"g the MVVM Toolkit components out -of-the-box allows you to greatly simplify our ViewModel. \\nThe MVV\", \"M Toolkit allows you to simplify common code use cases even further by using Source \\nGenerators . Th\", \"e MVVM Toolkit source generators look for specific attributes in our code and can \\ngenerate wrappers\", \" for properties and commands.  \\nImportant  \\nThe MVVM Toolkit Source Generators generate code that is\", \" additive to our existing objects. Because \\nof this, any object that is leveraging a source generato\", \"r will need to be marked as partial.  \\nThe MVVM Toolkit ObservableProperty attribute can be applied \", \"to fields in objects that inherit from \\nObservableObject and will wrap a private field with a proper\", \"ty that generates changes. The following \\ncode shows an example of using the ObservableObject att ri\", \"bute on the _name field:  \\npublic partial class SampleViewModel : ObservableObject  \\n{ \\n    [Observa\", \"bleProperty ] \\n    private string _name; \\n} \\nWith the ObservableProperty attribute applied to the _n\", \"ame field, the source generator will run and \\ngenerate another partial class with the following code\", \":  \\npartial class SampleViewModel  \\n{ \\n    public string Name \\n    { \\n        get => _name; \\n       \", \" set \\n        { \\n            if (!EqualityComparer <string>.Default.Equals(_name, value)) \\n         \", \"   { \\n                OnNameChanging (value); \\n                OnPropertyChanging (\\\"Name\\\"); \\n       \", \"         _name = value; \\n                OnNameChanged (value); \\n                OnPropertyChanged (\", \"\\\"Name\\\"); \\n            } \\n        } \\n    } \\n} \\nThe generated SampleViewModel has used the private _na\", \"me field and generated a new Name \\nproperty that implements all of the logic needed for raising chan\", \"ge notifications.   \\n92 CHAPTER 12 | MVVM Toolkit Features  \\n The MVVM Toolkit RelayCommand attribut\", \"e can be applied to methods within an ObservableObject \\nand will create a corresponding RelayCommand\", \" or AsyncRelayCommand. The following code shows \\nexamples of using the RelayCommand attribute:  \\npub\", \"lic partial class SampleViewModel : ObservableObject  \\n{ \\n    public INavigationService NavigationSe\", \"rvice { get; set; } \\n \\n    [ObservableProperty ] \\n    private string _name; \\n \\n    [ObservableProper\", \"ty ] \\n    bool _isValid ; \\n \\n    [RelayCommand ] \\n    private Task SettingsAsync () \\n    { \\n        \", \"return NavigationService .NavigateToAsync (\\\"Settings\\\" ); \\n    } \\n \\n    [RelayCommand ] \\n    private \", \"void Validate () \\n    { \\n        IsValid = !string.IsNullOrEmpty (Name); \\n    } \\n} \\nThe RelayCommand\", \" applied to the Validate method will generate a RelayCommand validate \\nValidateCommand because it ha\", \"s a void return and the SettingsAsync method will generate an \\nAsyncRelayCommand named SettingsComma\", \"nd. The source generator will generate the fol lowing \\ncode in other partial classes:  \\npartial clas\", \"s SampleViewModel  \\n{ \\n    private AsyncRelayCommand ? settingsCommand ; \\n \\n    SettingsCommand => s\", \"ettingsCommand ??= new AsyncRelayCommand (SettingsAsync ); \\n} \\n \\npartial class SampleViewModel  \\n{ \\n\", \"    private RelayCommand ? validateCommand ; \\n \\n    public IRelayCommand ValidateCommand => validate\", \"Command ??= new RelayCommand (Validate ); \\n} \\nAll of the complexity of wrapping our ViewModel\\u2019s meth\", \"ods with an ICommand implementation has \\nbeen handled by the source generator.  \\nFor more detailed i\", \"nformation on MVVM Toolkit Source Generators, see MVVM source generators  in \\nthe MVVM Toolkit Devel\", \"oper Center.   \\n93 CHAPTER 12 | MVVM Toolkit Features  \\n Summary  \\nThe MVVM Toolkit is a great way t\", \"o standardize and simplify our ViewModel code. The MVVM toolkit \\noffers great implementations of sta\", \"ndard MVVM components such as ObservableObject and \\nAsync/RelayCommand. The source generators help s\", \"implify our ViewModel pro perties and commands \\nby generating all of the boilerplate code needed for\", \" user interface interactions. The MVVM Toolkit \\noffers even more features outside of what has been s\", \"hown in this chapter. For more information on \\nthe MVVM Toolkit, see Introduction to the MVVM Toolki\", \"t  in the MVVM Toolkit Developer Center.   \\n94 CHAPTER 13 | Unit testing  \\n CHAPTER  13 \\nUnit testin\", \"g  \\nmulti -platform apps experience problems similar to both desktop and web -based applications. Mo\", \"bile \\nusers will differ by their devices, network connectivity, availability of services, and variou\", \"s other factors. \\nTherefore, multi -platform apps should be teste d as they would be used in the rea\", \"l world to improve \\ntheir quality, reliability, and performance. Many types of testing should be per\", \"formed on an app, \\nincluding unit testing, integration testing, and user interface testing. Unit tes\", \"ting is the most common \\nform and essential to building high -quality applications.  \\nA unit test ta\", \"kes a small unit of the app, typically a method, isolates it from the remainder of the code, \\nand ve\", \"rifies that it behaves as expected. Its goal is to check that each unit of functionality performs as\", \" \\nexpected, so errors don\\u2019t propagate throug hout the app. Detecting a bug where it occurs is more \\n\", \"efficient that observing the effect of a bug indirectly at a secondary point of failure.  \\nUnit test\", \"ing has the most significant effect on code quality when it\\u2019s an integral part of the software \\ndeve\", \"lopment workflow. Unit tests can act as design documentation and functional specifications for \\nan a\", \"pplication. As soon as a method has been written,  unit tests should be written that verify the \\nmet\", \"hod\\u2019s behavior in response to standard, boundary, and incorrect input data cases and check any \\nexpl\", \"icit or implicit assumptions made by the code. Alternatively, with test -driven development, unit \\nt\", \"ests are w ritten before the code. For more information on test -driven development and how to \\nimpl\", \"ement it, see Walkthrough: Test -driven development using Test Explorer.  \\nNote  \\nUnit tests are ver\", \"y effective against regression. That is, functionality that used to work, but has been \\ndisturbed by\", \" a faulty update.  \\nUnit tests typically use the arrange -act-assert pattern:  \\nStep  Description  \\n\", \"Arrange  Initializes objects and sets the value of the data \\nthat is passed to the method under test\", \".  \\nAct Invokes the method under test with the required \\narguments.  \\nAssert  Verifies that the acti\", \"on of the method under test \\nbehaves as expected.  \\nThis pattern ensures that unit tests are readabl\", \"e, self -describing, and consistent.   \\n95 CHAPTER 13 | Unit testing  \\n Dependency injection and uni\", \"t testing  \\nOne of the motivations for adopting a loosely -coupled architecture is that it facilitat\", \"es unit testing. \\nOne of the types registered with the dependency injection service is the IAppEnvir\", \"onmentService \\ninterface. The following code example shows an outline o f this class:  \\npublic class\", \" OrderDetailViewModel  : ViewModelBase  \\n{ \\n    private IAppEnvironmentService  _appEnvironmentServi\", \"ce ; \\n \\n    public OrderDetailViewModel ( \\n        IAppEnvironmentService appEnvironmentService , \\n \", \"       IDialogService dialogService , INavigationService navigationService , \\nISettingsService setti\", \"ngsService ) \\n        : base(dialogService , navigationService , settingsService ) \\n    { \\n        _\", \"appEnvironmentService = appEnvironmentService ; \\n    } \\n} \\nThe OrderDetailViewModel class has a depe\", \"ndency on the IAppEnvironmentService type, which the \\ndependency injection container resolves when i\", \"t instantiates an OrderDetailViewModel object. \\nHowever, rather than create an IAppEnvironmentServic\", \"e object which ut ilizes real servers, devices and \\nconfigurations to unit test the OrderDetailViewM\", \"odel class, instead, replace the \\nIAppEnvironmentService object with a mock object for the purpose o\", \"f the tests. A mock object is one \\nthat has the same signature of an object o r an interface, but is\", \" created in a specific manner to help \\nwith unit testing. It is often used with dependency injection\", \" to provide specific implementations of \\ninterfaces for testing different data and workflow scenario\", \"s.  \\nThis approach allows the IAppEnvironmentService object to be passed into the OrderDetailViewMod\", \"el \\nclass at runtime, and in the interests of testability, it allows a mock class to be passed into \", \"the \\nOrderDetailViewModel class at test time. The main advantag e of this approach is that it enable\", \"s unit \\ntests to be executed without requiring unwieldy resources such as runtime platform features,\", \" web \\nservices, or databases.  \\nTesting MVVM applications  \\nTesting models and view models from MVVM\", \" applications is identical to testing any other class, and \\nuses the same tools and techniques; this\", \" includes features such as unit testing and mocking. However, \\nsome patterns that are typical to mod\", \"el and view model classes can benefit from specific unit testing \\ntechniques.  \\nTip \\nTest one thing \", \"with each unit test. As the complexity of a test expands, it makes verification of that \\ntest more d\", \"ifficult. By limiting a unit test to a single concern, we can ensure that our tests are more \\nrepeat\", \"able, isolated, and have a smaller executio n time. See  \\nUnit testing best practices with .NET  for\", \" more best practices.   \\n96 CHAPTER 13 | Unit testing  \\n Don\\u2019t be tempted to make a unit test exerci\", \"se more than one aspect of the unit\\u2019s behavior. Doing so \\nleads to tests that are difficult to read \", \"and update. It can also lead to confusion when interpreting a \\nfailure.  \\nThe eShop multi -platform \", \"app uses MSTest  to perform unit testing, which supports two different \\ntypes of unit tests:  \\nTesti\", \"ng Type  Attribute  Description  \\nTestMethod  TestMethod  Defines the actual test method to run..  \\n\", \"DataSource  DataSource  Tests that are only true for a particular set of data.  \\nThe unit tests incl\", \"uded with the eShop multi -platform app are TestMethod, so each unit test method \\nis decorated with \", \"the TestMethod attribute. In addition to MSTest there are several other testing \\nframeworks availabl\", \"e including NUnit  and xUnit . \\nTesting asynchronous functionality  \\nWhen implementing the MVVM patt\", \"ern, view models usually invoke operations on services, often \\nasynchronously. Tests for code that i\", \"nvokes these operations typically use mocks as replacements for \\nthe actual services. The following \", \"code example demonstrates testing asynchronous functionality by \\npassing a mock service into a view \", \"model:  \\n[TestMethod ] \\npublic async Task OrderPropertyIsNotNullAfterViewModelInitializationTest () \", \"\\n{ \\n    // Arrange  \\n    var orderService = new OrderMockService (); \\n    var orderViewModel = new O\", \"rderDetailViewModel (orderService ); \\n \\n    // Act \\n    var order = await orderService .GetOrderAsyn\", \"c (1, GlobalSetting .Instance .AuthToken ); \\n    await orderViewModel .InitializeAsync (order); \\n \\n \", \"   // Assert  \\n    Assert.IsNotNull (orderViewModel .Order); \\n} \\nThis unit test checks that the Orde\", \"r property of the OrderDetailViewModel instance will have a value \\nafter the InitializeAsync method \", \"has been invoked. The InitializeAsync method is invoked when the \\nview model\\u2019s corresponding view is\", \" navigated to. For more  information about navigation, see \\nNavigation . \\nWhen the OrderDetailViewMo\", \"del instance is created, it expects an IOrderService instance to be \\nspecified as an argument. Howev\", \"er, the OrderService retrieves data from a web service. Therefore, an \\nOrderMockService instance, a \", \"mock version of the OrderService  class, is specified as the argument to \\nthe OrderDetailViewModel c\", \"onstructor. Then, mock data is retrieved rather than communicating with \\na web service when the view\", \" model\\u2019s InitializeAsync method is invoked, which uses IOrderService \\noperations.   \\n97 CHAPTER 13 |\", \" Unit testing  \\n Testing INotifyPropertyChanged implementations  \\nImplementing the INotifyPropertyCh\", \"anged interface allows views to react to changes that originate \\nfrom view models and models. These \", \"changes are not limited to data shown in controls \\u2013 they are also \\nused to control the view, such as\", \" view model states that cause animations to be started or controls to \\nbe disabled.  \\nProperties tha\", \"t can be updated directly by the unit test can be tested by attaching an event handler to \\nthe Prope\", \"rtyChanged event and checking whether the event is raised after setting a new value for the \\npropert\", \"y. The following code example shows such a t est: \\n[TestMethod ] \\npublic async Task SettingOrderProp\", \"ertyShouldRaisePropertyChanged () \\n{ \\n    var invoked = false; \\n    var orderService  = new OrderMoc\", \"kService (); \\n    var orderViewModel  = new OrderDetailViewModel (orderService ); \\n \\n    orderViewMo\", \"del .PropertyChanged  += (sender, e) => \\n    { \\n        if (e.PropertyName .Equals(\\\"Order\\\")) \\n      \", \"      invoked = true; \\n    }; \\n    var order = await orderService .GetOrderAsync (1, GlobalSetting .\", \"Instance .AuthToken ); \\n    await orderViewModel .InitializeAsync (order); \\n \\n    Assert.IsTrue(invo\", \"ked); \\n} \\nThis unit test invokes the InitializeAsync method of the OrderViewModel class, which cause\", \"s its Order \\nproperty to be updated. The unit test will pass, provided that the PropertyChanged even\", \"t is raised for \\nthe Order property.  \\nTesting message -based communication  \\nView models that use t\", \"he MessagingCenter class to communicate between loosely coupled classes \\ncan be unit tested by subsc\", \"ribing to the message being sent by the code under test, as demonstrated \\nin the following code exam\", \"ple:  \\n[TestMethod ] \\npublic void AddCatalogItemCommandSendsAddProductMessageTest () \\n{ \\n    var mes\", \"sageReceived  = false; \\n    var catalogService  = new CatalogMockService (); \\n    var catalogViewMod\", \"el  = new CatalogViewModel (catalogService ); \\n \\n    MessagingCenter .Subscribe <CatalogViewModel , \", \"CatalogItem >( \\n        this, MessageKeys .AddProduct , (sender, arg) => \\n    { \\n        messageRece\", \"ived  = true; \\n    }); \\n    catalogViewModel .AddCatalogItemCommand .Execute(null); \\n  \\n98 CHAPTER 1\", \"3 | Unit testing  \\n     Assert.IsTrue(messageReceived ); \\n} \\nThis unit test checks that the CatalogV\", \"iewModel publishes the AddProduct message in response to its \\nAddCatalogItemCommand being executed. \", \"Because the MessagingCenter class supports multicast \\nmessage subscriptions, the unit test can subsc\", \"ribe to the AddProd uct message and execute a callback \\ndelegate in response to receiving it. This c\", \"allback delegate, specified as a lambda expression, sets a \\nboolean field that\\u2019s used by the Assert \", \"statement to verify the behavior of the test.  \\nTesting exception handling  \\nUnit tests can also be \", \"written that check that specific exceptions are thrown for invalid actions or \\ninputs, as demonstrat\", \"ed in the following code example:  \\n[TestMethod ] \\npublic void InvalidEventNameShouldThrowArgumentEx\", \"ceptionText () \\n{ \\n    var behavior  = new MockEventToCommandBehavior  \\n    { \\n        EventName  = \", \"\\\"OnItemTapped\\\"  \\n    }; \\n    var listView  = new ListView (); \\n \\n    Assert.Throws<ArgumentException\", \" >(() => listView .Behaviors .Add(behavior )); \\n} \\nThis unit test will throw an exception because th\", \"e ListView control does not have an event named \\nOnItemTapped. The Assert.Throws<T> method is a gene\", \"ric method where T is the type of the \\nexpected exception. The argument passed to the Assert.Throws<\", \"T> method  is a lambda expression \\nthat will throw the exception. Therefore, the unit test will pass\", \" provided that the lambda expression \\nthrows an ArgumentException.  \\nTip \\nAvoid writing unit tests t\", \"hat examine exception message strings. Exception message strings might \\nchange over time, and so uni\", \"t tests that rely on their presence are regarded as brittle.  \\nTesting validation  \\nThere are two as\", \"pects to testing the validation implementation: testing that any validation rules are \\ncorrectly imp\", \"lemented and testing that the ValidatableObject<T> class performs as expected.  \\nValidation logic is\", \" usually simple to test, because it is typically a self -contained process where the \\noutput depends\", \" on the input. There should be tests on the results of invoking the Validate method on \\neach propert\", \"y that has at least one associated valid ation rule, as demonstrated in the following code \\nexample:\", \"  \\n[TestMethod ] \\npublic void CheckValidationPassesWhenBothPropertiesHaveDataTest () \\n{  \\n99 CHAPTER\", \" 13 | Unit testing  \\n     var mockViewModel  = new MockViewModel (); \\n    mockViewModel .Forename .V\", \"alue = \\\"John\\\"; \\n    mockViewModel .Surname.Value = \\\"Smith\\\"; \\n \\n    var isValid = mockViewModel .Vali\", \"date (); \\n \\n    Assert.IsTrue(isValid); \\n} \\nThis unit test checks that validation succeeds when the \", \"two ValidatableObject<T> properties in the \\nMockViewModel instance both have data.  \\nAs well as chec\", \"king that validation succeeds, validation unit tests should also check the values of the \\nValue, IsV\", \"alid, and Errors property of each ValidatableObject<T> instance, to verify that the class \\nperforms \", \"as expected. The following code example dem onstrates a unit test that does this:  \\n[TestMethod ] \\np\", \"ublic void CheckValidationFailsWhenOnlyForenameHasDataTest () \\n{ \\n    var mockViewModel  = new MockV\", \"iewModel (); \\n    mockViewModel .Forename .Value = \\\"John\\\"; \\n \\n    bool isValid = mockViewModel .Vali\", \"date (); \\n \\n    Assert.IsFalse(isValid); \\n    Assert.IsNotNull (mockViewModel .Forename .Value); \\n  \", \"  Assert.IsNull(mockViewModel .Surname.Value); \\n    Assert.IsTrue(mockViewModel .Forename .IsValid);\", \" \\n    Assert.IsFalse(mockViewModel .Surname.IsValid); \\n    Assert.AreEqual (mockViewModel .Forename \", \".Errors.Count(), 0); \\n    Assert.AreNotEqual (mockViewModel .Surname.Errors.Count(), 0); \\n} \\nThis un\", \"it test checks that validation fails when the Surname property of the MockViewModel doesn\\u2019t \\nhave an\", \"y data, and the Value, IsValid, and Errors property of each ValidatableObject<T> instance are \\ncorre\", \"ctly set.  \\nSummary  \\nA unit test takes a small unit of the app, typically a method, isolates it fro\", \"m the remainder of the code, \\nand verifies that it behaves as expected. Its goal is to check that ea\", \"ch unit of functionality performs as \\nexpected, so errors don\\u2019t propagate throughout the app.  \\nThe \", \"behavior of an object under test can be isolated by replacing dependent objects with mock \\nobjects t\", \"hat simulate the behavior of the dependent objects. This enables unit tests to be executed \\nwithout \", \"requiring unwieldy resources such as runtime platform features, web services, or databases  \\nTesting\", \" models and view models from MVVM applications is identical to testing any other classes, and \\nthe s\", \"ame tools and techniques can be used.  \"]"