{'Unordered list': [[{'text': 'App requirements that can change over time.', 'task_item': False}, {'text': 'New business opportunities and challenges.', 'task_item': False}, {'text': 'Ongoing feedback during development that can significantly affect the scope and\nrequirements of the app.', 'task_item': False}, {'text': 'With these in mind, it’s important to build apps that can be easily modified or extended over time.\nDesigning for such adaptability can be difficult as it requires an architecture that allows individual\nparts of the app to be independently developed and tested in isolation without affecting the rest of\nthe app.', 'task_item': False}, {'text': 'Many enterprise apps are sufficiently complex to require more than one developer. It can be a\nsignificant challenge to decide how to design an app so that multiple developers can work effectively\non different pieces of the app independently, while ensuring that the pieces come together seamlessly\nwhen integrated into the app.', 'task_item': False}, {'text': 'The traditional approach to designing and building an app results in what is referred to as a\n_monolithic_ app, where components are tightly coupled with no clear separation between them.\nTypically, this monolithic approach leads to apps that are difficult and inefficient to maintain, because\nit can be difficult to resolve bugs without breaking other components in the app, and it can be\ndifficult to add new features or to replace existing features.', 'task_item': False}, {'text': 'An effective remedy for these challenges is to partition an app into discrete, loosely coupled\ncomponents that can be easily integrated together into an app. Such an approach offers several\nbenefits:', 'task_item': False}, {'text': 'It allows individual functionality to be developed, tested, extended, and maintained by\ndifferent individuals or teams.', 'task_item': False}, {'text': 'It promotes reuse and a clean separation of concerns between the app’s horizontal\ncapabilities, such as authentication and data access, and the vertical capabilities, such as app\nspecific business functionality. This allows the dependencies and interactions between app\ncomponents to be more easily managed.', 'task_item': False}, {'text': 'It helps maintain a separation of roles by allowing different individuals, or teams, to focus on\na specific task or piece of functionality according to their expertise. In particular, it provides a\ncleaner separation between the user interface and the app’s business logic.', 'task_item': False}, {'text': 'However, there are many issues that must be resolved when partitioning an app into discrete, loosely\ncoupled components. These include:', 'task_item': False}, {'text': '3 CHAPTER 2 | Introduction to .NET MAUI', 'task_item': False}, {'text': 'Deciding how to provide a clean separation of concerns between the user interface controls\nand their logic. One of the most important decisions when creating a .NET MAUI enterprise\napp is whether to place business logic in code-behind files, or whether to create a clean\nseparation of concerns between the user interface controls and their logic, in order to make\nthe app more maintainable and testable. For more information, see Model-View-ViewModel.', 'task_item': False}, {'text': 'Determining whether to use a dependency injection container. Dependency injection\ncontainers reduce the dependency coupling between objects by providing a facility to\nconstruct instances of classes with their dependencies injected, and manage their lifetime\nbased on the configuration of the container. For more information, see Dependency injection.', 'task_item': False}, {'text': 'Choosing between platform provided eventing and loosely coupled message-based\ncommunication between components that are inconvenient to link by object and type\nreferences. For more information, see Introduction to Communicating between loosely\ncoupled components.', 'task_item': False}, {'text': 'Deciding how to navigate between pages, including how to invoke navigation, and where\nnavigation logic should reside. For more information, see Navigation.', 'task_item': False}, {'text': 'Determining how to validate user input for correctness. The decision must include how to\nvalidate user input, and how to notify the user about validation errors. For more information,\nsee Validation.', 'task_item': False}, {'text': 'Deciding how to perform authentication, and how to protect resources with authorization. For\nmore information, see Authentication and authorization.', 'task_item': False}, {'text': 'Determining how to access remote data from web services, including how to reliably retrieve\ndata, and how to cache data. For more information, see Accessing remote data.', 'task_item': False}, {'text': 'Deciding how to test the app. For more information, see Unit testing.', 'task_item': False}, {'text': 'This guide provides guidance on these issues, and focuses on the core patterns and architecture for\nbuilding a cross-platform enterprise app using .NET MAUI. The guidance aims to help to produce\nadaptable, maintainable, and testable code, by addressing common .NET MAUI enterprise app\ndevelopment scenarios, and by separating the concerns of presentation, presentation logic, and\nentities through support for the Model-View-ViewModel (MVVM) pattern.', 'task_item': False}], [{'text': 'Authenticating and authorizing against a backend service.', 'task_item': False}, {'text': 'Browsing a catalog of items.', 'task_item': False}, {'text': 'Filtering the catalog.', 'task_item': False}, {'text': 'Ordering items from the catalog.', 'task_item': False}, {'text': 'Viewing the user’s order history.', 'task_item': False}, {'text': 'Configuration of settings.', 'task_item': False}, {'text': '4 CHAPTER 2 | Introduction to .NET MAUI', 'task_item': False}], [{'text': '.NET Aspire App Hosting & Orchestration', 'task_item': False}, {'text': 'An Blazor web application developed with ASP.NET Core.', 'task_item': False}, {'text': 'A multi-platform app developed with .NET MAUI, which supports iOS, Android, macOS via\nMac Catalyst, and Windows.', 'task_item': False}, {'text': 'The sample application includes the following backend services:', 'task_item': False}, {'text': 'An identity microservice, which uses ASP.NET Core Identity and IdentityServer.', 'task_item': False}, {'text': 'A catalog microservice, which is a data-driven create, read, update, delete (CRUD) service that\nconsumes an SQL Server database using EntityFramework Core.', 'task_item': False}, {'text': 'An ordering microservice, which is a domain-driven service that uses domain-driven design\npatterns.', 'task_item': False}, {'text': 'A basket microservice, which is a data-driven CRUD service that uses Redis Cache.', 'task_item': False}, {'text': 'These backend services are implemented as microservices using ASP.NET Core, and are deployed as\nunique containers with .NET Aspire. Collectively, these backend services are referred to as the eShop\nreference application. Client apps communicate with the backend services through a Representational\nState Transfer (REST) web interface. For more information about microservices and conainers, see\nContainerized microservices.', 'task_item': False}, {'text': '5 CHAPTER 2 | Introduction to .NET MAUI', 'task_item': False}], [{'text': 'XAML', 'task_item': False}, {'text': 'Controls', 'task_item': False}, {'text': 'Bindings', 'task_item': False}, {'text': 'Converters', 'task_item': False}, {'text': 'Styles', 'task_item': False}, {'text': 'Animations', 'task_item': False}, {'text': 'Commands', 'task_item': False}, {'text': 'Behaviors', 'task_item': False}, {'text': 'Triggers', 'task_item': False}, {'text': 'Effects', 'task_item': False}, {'text': 'Custom Controls', 'task_item': False}, {'text': '[For more information about this functionality, see the .NET MAUI documentation.](https://docs.microsoft.com/dotnet/maui)', 'task_item': False}, {'text': 'In addition, unit tests are provided for some of the classes in the eShop multi-platform app.', 'task_item': False}], [{'text': 'If an existing model implementation encapsulates existing business logic, it can be difficult or\nrisky to change it. In this scenario, the view model acts as an adapter for the model classes\nand prevents you from making major changes to the model code.', 'task_item': False}, {'text': 'Developers can create unit tests for the view model and the model, without using the view.\nThe unit tests for the view model can exercise exactly the same functionality as used by the\nview.', 'task_item': False}, {'text': 'The app UI can be redesigned without touching the view model and model code, provided\nthat the view is implemented entirely in XAML or C#. Therefore, a new version of the view\nshould work with the existing view model.', 'task_item': False}, {'text': 'Designers and developers can work independently and concurrently on their components\nduring development. Designers can focus on the view, while developers can work on the view\nmodel and model components.', 'task_item': False}, {'text': 'The key to using MVVM effectively lies in understanding how to factor app code into the correct\nclasses and how the classes interact. The following sections discuss the responsibilities of each of the\nclasses in the MVVM pattern.', 'task_item': False}], [{'text': 'Always raising a PropertyChanged event if a public property’s value changes. Do not assume\nthat raising the PropertyChanged event can be ignored because of knowledge of how XAML\nbinding occurs.', 'task_item': False}, {'text': 'Always raising a PropertyChanged event for any calculated properties whose values are used\nby other properties in the view model or model.', 'task_item': False}, {'text': 'Always raising the PropertyChanged event at the end of the method that makes a property\nchange, or when the object is known to be in a safe state. Raising the event interrupts the', 'task_item': False}, {'text': '13 CHAPTER 3 | Model-View-ViewModel (MVVM)', 'task_item': False}, {'text': 'operation by invoking the event’s handlers synchronously. If this happens in the middle of an\noperation, it might expose the object to callback functions when it is in an unsafe, partially\nupdated state. In addition, it’s possible for cascading changes to be triggered by\nPropertyChanged events. Cascading changes generally require updates to be complete before\nthe cascading change is safe to execute.', 'task_item': False}, {'text': 'Never raising a PropertyChanged event if the property does not change. This means that you\nmust compare the old and new values before raising the PropertyChanged event.', 'task_item': False}, {'text': 'Never raising the PropertyChanged event during a view model’s constructor if you are\ninitializing a property. Data-bound controls in the view will not have subscribed to receive\nchange notifications at this point.', 'task_item': False}, {'text': 'Never raising more than one PropertyChanged event with the same property name argument\nwithin a single synchronous invocation of a public method of a class. For example, given a\nNumberOfItems property whose backing store is the _numberOfItems field, if a method\nincrements _numberOfItems fifty times during the execution of a loop, it should only raise\nproperty change notification on the NumberOfItems property once, after all the work is\ncomplete. For asynchronous methods, raise the PropertyChanged event for a given property\nname in each synchronous segment of an asynchronous continuation chain.', 'task_item': False}, {'text': 'A simple way to provide this functionality would be to create an extension of the BindableObject class.\nIn this example, the ExtendedBindableObject class provides change notifications, which is shown in\nthe following code example:', 'task_item': False}, {'text': '.NET MAUI’s BindableObject class implements the INotifyPropertyChanged interface, and provides an\nOnPropertyChanged method. The ExtendedBindableObject class provides the RaisePropertyChanged\nmethod to invoke property change notification, and in doing so uses the functionality provided by the\nBindableObject class.', 'task_item': False}, {'text': 'View model classes can then derive from the ExtendedBindableObject class. Therefore, each view\nmodel class uses the RaisePropertyChanged method in the ExtendedBindableObject class to provide\nproperty change notification. The following code example shows how the eShop multi-platform app\ninvokes property change notification by using a lambda expression:', 'task_item': False}, {'text': '14 CHAPTER 3 | Model-View-ViewModel (MVVM)', 'task_item': False}, {'text': 'Using a lambda expression in this way involves a small performance cost because the lambda\nexpression has to be evaluated for each call. Although the performance cost is small and would not\ntypically impact an app, the costs can accrue when there are many change notifications. However, the\nbenefit of this approach is that it provides compile-time type safety and refactoring support when\nrenaming properties.', 'task_item': False}], [{'text': '[.NET Community MVVM Toolkit](https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/introduction/)', 'task_item': False}, {'text': '[ReactiveUI](https://www.reactiveui.net/)', 'task_item': False}, {'text': '[Prism Library](https://prismlibrary.com/)', 'task_item': False}], [{'text': 'A container removes the need for a class to locate its dependencies and manage its lifetimes.', 'task_item': False}, {'text': 'A container allows the mapping of implemented dependencies without affecting the class.', 'task_item': False}, {'text': 'A container facilitates testability by allowing dependencies to be mocked.', 'task_item': False}, {'text': 'A container increases maintainability by allowing new classes to be easily added to the app.', 'task_item': False}, {'text': 'In the context of a .NET MAUI app that uses MVVM, a dependency injection container will typically be\nused for registering and resolving views, registering and resolving view models, and for registering\nservices and injecting them into view models.', 'task_item': False}, {'text': 'There are many dependency injection containers available in .NET; the eShop multi-platform app uses\nMicrosoft.Extensions.DependencyInjection to manage the instantiation of views, view models, and\nservice classes in the app. Microsoft.Extensions.DependencyInjection facilitates building loosely\ncoupled apps, and provides all of the features commonly found in dependency injection containers,\nincluding methods to register type mappings and object instances, resolve objects, manage object\nlifetimes, and inject dependent objects into constructors of objects that it resolves. For more\n[information about Microsoft.Extensions.DependencyInjection, see Dependency injection in .NET.](https://docs.microsoft.com/dotnet/core/extensions/dependency-injection)', 'task_item': False}, {'text': 'In .NET MAUI, the MauiProgram class will call into the CreateMauiApp method to create a\nMauiAppBuilder object. The MauiAppBuilder object has a Services property of type IServiceCollection,\nwhich provides a place to register our components, such as views, view models, and services for\ndependency injection. Any components registered with the Services property will be provided to the\ndependency injection container when the MauiAppBuilder.Build method is called.', 'task_item': False}, {'text': 'At runtime, the container must know which implementation of the services are being requested in\norder to instantiate them for the requested objects. In the eShop multi-platform app, the\nIAppEnvironmentService, IDialogService, INavigationService, and ISettingsService interfaces need to\nbe resolved before it can instantiate a ProfileViewModel object. This involves the container performing\nthe following actions:', 'task_item': False}, {'text': 'Deciding how to instantiate an object that implements the interface. This is known as\n_registration_ .', 'task_item': False}, {'text': 'Instantiating the object that implements the required interface and the ProfileViewModel\nobject. This is known as _resolution_ .', 'task_item': False}, {'text': 'Eventually, the app will finish using the ProfileViewModel object, and it will become available for\ngarbage collection. At this point, the garbage collector should dispose of any short-lived interface\nimplementations if other classes do not share the same instance.', 'task_item': False}, {'text': '22 CHAPTER 4 | Dependency injection', 'task_item': False}], [{'text': 'Register a type or mapping with the container. This is known as transient registration. When\nrequired, the container will build an instance of the specified type.', 'task_item': False}, {'text': 'Register an existing object in the container as a singleton. When required, the container will\nreturn a reference to the existing object.', 'task_item': False}, {'text': 'The registration of types requiring dependency injection should be performed in a single method in\nan app. This method should be invoked early in the app’s lifecycle to ensure it is aware of the\ndependencies between its classes. The eShop multi-platform app performs this the\nMauiProgram.CreateMauiApp method. The following code example shows how the eShop multiplatform app declares the CreateMauiApp in the MauiProgram class:', 'task_item': False}, {'text': 'The MauiApp.CreateBuilder method creates a MauiAppBuilder object that we can use to register our\ndependencies. Many dependencies in the eShop multi-platform app need to be registered, so the\nextension methods RegisterAppServices, RegisterViewModels, and RegisterViews were created to help\nprovide an organized and maintainable registration workflow. The following code shows the\nRegisterViewModels method:', 'task_item': False}, {'text': '23 CHAPTER 4 | Dependency injection', 'task_item': False}, {'text': 'This method receives an instance of MauiAppBuilder, and we can use the Services property to register\nour view models. Depending on the needs of your application, you may need to add services with\ndifferent lifetimes. The following table provides information on when you may want to choose these', 'task_item': False}, {'text': '|different registration lifetimes:|Col2|\n|---|---|\n|**Method**|**Description**|\n|AddSingleton<T>|Will create a single instance of the object which<br>will be remain for the lifetime of the application.|\n|AddTransient<T>|Will create a new instance of the object when<br>requested during resolution. Transient objects<br>do not have a pre-defined lifetime, but will<br>typically follow the lifetime of their host.|', 'task_item': False}, {'text': 'The CatalogViewModel is used near the application’s root and should always be available, so\nregistering it with AddSingleton<T> is beneficial. Other view models, such as CheckoutViewModel\nand OrderDetailViewModel are situationally navigated to or are used later in the application. Suppose\nyou know that you have a component that may not always be used. In that case, if it is memory or\ncomputationally intensive or requires just-in-time data, it may be a better candidate for\nAddTransient<T> registration.', 'task_item': False}, {'text': 'Another common way to add services is using the AddSingleton<TService, TImplementation> and\nAddTransient<TService, TImplementation> methods. These methods take two input types: the\ninterface definition and the concrete implementation. This type of registration is best for cases where\nyou are implementing services based on interfaces. In the code example below, we register our\nISettingsService interface using the SettingsService implementation:', 'task_item': False}, {'text': 'Once all services have been registered, the MauiAppBuilder.Build method should be called to create\nour MauiApp and populate our dependency injection container with all the registered services.', 'task_item': False}, {'text': '24 CHAPTER 4 | Dependency injection', 'task_item': False}], [{'text': 'Identifying the view to be navigated to using an approach that does not introduce tight\ncoupling and dependencies between views.', 'task_item': False}, {'text': 'Coordinating the process by which the view to be navigated to is instantiated and initialized.\nWhen using MVVM, the view and view-model need to be instantiated and associated with\neach other via the view’s binding context. When an app is using a dependency injection\ncontainer, the instantiation of views and view-models might require a specific construction\nmechanism.', 'task_item': False}, {'text': 'Whether to perform view-first navigation, or view-model-first navigation. With view-first\nnavigation, the page to navigate to refers to the name of the view type. During navigation,\nthe specified view is instantiated, along with its corresponding view-model and other\ndependent services. An alternative approach is to use view-model-first navigation, where the\npage to navigate to refers to the name of the view-model type.', 'task_item': False}, {'text': 'Determining how to cleanly separate the navigational behavior of the app across the views\nand view-models. The MVVM pattern separates the app’s UI and its presentation and business\nlogic, but it doesn’t provide a direct mechanism for tying them together. However, the\nnavigation behavior of an app will often span the UI and presentation parts of the app. The\nuser will often initiate navigation from a view, and the view will be replaced as a result of the\nnavigation. However, navigation might often also need to be initiated or coordinated from\nwithin the view-model.', 'task_item': False}, {'text': 'Determining how to pass parameters during navigation for initialization purposes. For\nexample, if the user navigates to a view to update order details, the order data will have to be\npassed to the view so that it can display the correct data.', 'task_item': False}, {'text': 'Coordinating navigation to ensure that specific business rules are obeyed. For example, users\nmight be prompted before navigating away from a view so that they can correct any invalid\ndata or be prompted to submit or discard any data changes that were made within the view.', 'task_item': False}, {'text': 'This chapter addresses these challenges by presenting a navigation service class named\nMauiNavigationService that’s used to perform view-model-first page navigation.', 'task_item': False}, {'text': '32 CHAPTER 6 | Navigation', 'task_item': False}], [{'text': 'Each microservice is relatively small, easy to manage and evolve.', 'task_item': False}, {'text': 'Each microservice can be developed and deployed independently of other services.', 'task_item': False}, {'text': 'Each microservice can be scaled-out independently. For example, a catalog service or\nshopping basket service might need to be scaled-out more than an ordering service.', 'task_item': False}, {'text': '52 CHAPTER 9 | Containerized microservices', 'task_item': False}, {'text': 'Therefore, the resulting infrastructure will more efficiently consume resources when scaling\nout.', 'task_item': False}, {'text': 'Each microservice isolates any issues. For example, if there is an issue in a service it only\nimpacts that service. The other services can continue to handle requests.', 'task_item': False}, {'text': 'Each microservice can use the latest technologies. Because microservices are autonomous and\nrun side-by-side, the latest technologies and frameworks can be used, rather than being\nforced to use an older framework that might be used by a monolithic application.', 'task_item': False}, {'text': 'However, a microservice-based solution also has potential drawbacks:', 'task_item': False}, {'text': 'Choosing how to partition an application into microservices can be challenging, as each\nmicroservice has to be completely autonomous, end-to-end, including responsibility for its\ndata sources.', 'task_item': False}, {'text': 'Developers must implement inter-service communication, which adds complexity and latency\nto the application.', 'task_item': False}, {'text': 'Atomic transactions between multiple microservices usually aren’t possible. Therefore,\nbusiness requirements must embrace eventual consistency between microservices.', 'task_item': False}, {'text': 'In production, there is an operational complexity in deploying and managing a system\ncompromised of many independent services.', 'task_item': False}, {'text': 'Direct client-to-microservice communication can make it difficult to refactor the contracts of\nmicroservices. For example, over time how the system is partitioned into services might need\nto change. A single service might split into two or more services, and two services might\nmerge. When clients communicate directly with microservices, this refactoring work can break\ncompatibility with client apps.', 'task_item': False}], [{'text': 'A shared cache, which can be accessed by multiple processes or machines.', 'task_item': False}, {'text': 'A private cache, where data is held locally on the device running the app.', 'task_item': False}, {'text': 'The eShop multi-platform app uses a private cache, where data is held locally on the device that’s\nrunning an instance of the app.', 'task_item': False}, {'text': 'Ensure that data is maintained in the original data store as well as the cache. The chances of losing\ndata are then minimized if the cache becomes unavailable.', 'task_item': False}], [{'text': 'Detect faults when they occur, and determine if the faults are likely to be transient.', 'task_item': False}, {'text': 'Retry the operation if it determines that the fault is likely to be transient and keep track of the\nnumber of times the operation was retried.', 'task_item': False}, {'text': 'Use an appropriate retry strategy, which specifies the number of retries, the delay between\neach attempt, and the actions to take after a failed attempt.', 'task_item': False}, {'text': 'This transient fault handling can be achieved by wrapping all attempts to access a remote service in\ncode that implements the retry pattern.', 'task_item': False}], [{'text': 'Retrying the operation. The app could retry the failing request immediately.', 'task_item': False}, {'text': 'Retrying the operation after a delay. The app should wait for a suitable amount of time before\nretrying the request.', 'task_item': False}, {'text': 'Cancelling the operation. The application should cancel the operation and report an\nexception.', 'task_item': False}, {'text': 'The retry strategy should be tuned to match the business requirements of the app. For example, it’s\nimportant to optimize the retry count and retry interval to the operation being attempted. If the\noperation is part of a user interaction, the retry interval should be short and only a few retries\nattempted to avoid making users wait for a response. If the operation is part of a long running\nworkflow, where cancelling or restarting the workflow is expensive or time-consuming, it’s appropriate\nto wait longer between attempts and to retry more times.', 'task_item': False}, {'text': '70 CHAPTER 10 | Accessing remote data', 'task_item': False}, {'text': 'If a request still fails after a number of retries, it’s better for the app to prevent further requests going\nto the same resource and to report a failure. Then, after a set period, the app can make one or more\nrequests to the resource to see if they’re successful. For more information, see Circuit breaker pattern.', 'task_item': False}, {'text': '[Use a finite number of retries, or implement the Circuit Breaker](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) pattern to allow a service to recover.', 'task_item': False}, {'text': 'The eShop reference application does implement the retry pattern.', 'task_item': False}, {'text': '[For more information about the retry pattern, see the Retry](https://docs.microsoft.com/azure/architecture/patterns/retry) pattern on Microsoft Docs.', 'task_item': False}], [{'text': 'Authenticating users with IdentityServer is achieved by the multi-platform app requesting an\n_identity_ token, representing an authentication process’s outcome. At a minimum, it contains\nan identifier for the user and information about how and when the user is authenticated. It\ncan also include additional identity data.', 'task_item': False}, {'text': 'Accessing a resource with IdentityServer is achieved by the multi-platform app requesting an\n_access_ token, which allows access to an API resource. Clients request access tokens and\nforward them to the API. Access tokens contain information about the client and the user, if\npresent. APIs then use that information to authorize access to their data.', 'task_item': False}, {'text': '74 CHAPTER 11 | Authentication and authorization', 'task_item': False}], [{'text': 'Credentials used for signing.', 'task_item': False}, {'text': 'API and identity resources that users might request access to.', 'task_item': False}, {'text': 'Clients that will be connecting to request tokens.', 'task_item': False}, {'text': 'ASP.NET Core Identity.', 'task_item': False}, {'text': '75 CHAPTER 11 | Authentication and authorization', 'task_item': False}, {'text': '[For information about configuring IdentityServer to use ASP.NET Core Identity, see Using ASP.NET](https://docs.duendesoftware.com/identityserver/v7/quickstarts/5_aspnetid/)\n[Core Identity](https://docs.duendesoftware.com/identityserver/v7/quickstarts/5_aspnetid/) in the IdentityServer documentation.', 'task_item': False}], [{'text': 'A unique client ID.', 'task_item': False}, {'text': 'The allowed interactions with the token service (known as the grant type).', 'task_item': False}, {'text': 'The location where identity and access tokens are sent to (known as a redirect URI).', 'task_item': False}, {'text': 'A list of resources that the client is allowed access to (known as scopes).', 'task_item': False}, {'text': 'When configuring clients, the AddInMemoryClients method expects an IEnumerable<Client>\ncollection. The following code example shows the configuration for the eShop multi-platform app in\nthe GetClients method that provides this collection in the eShop reference application:', 'task_item': False}, {'text': 'This configuration specifies data for the following properties:', 'task_item': False}, {'text': '|Property|Description|\n|---|---|\n|ClientId|A unique ID for the client.|\n|ClientName|The client display name, which is used for<br>logging and the consent screen.|', 'task_item': False}, {'text': '77 CHAPTER 11 | Authentication and authorization', 'task_item': False}, {'text': '|Property|Description|\n|---|---|\n|AllowedGrantTypes|Specifies how a client wants to interact with<br>IdentityServer. For more information see<br>Configuring the authentication flow.|\n|ClientSecrets|Specifies the client secret credentials that are<br>used when requesting tokens from the token<br>endpoint.|\n|RedirectUris|Specifies the allowed URIs to which to return<br>tokens or authorization codes.|\n|RequireConsent|Specifies whether a consent screen is required.|\n|RequirePkce|Specifies whether clients using an authorization<br>code must send a proof key.|\n|PostLogoutRedirectUris|Specifies the allowed URIs to redirect to after<br>logout.|\n|AllowedCorsOrigins|Specifies the origin of the client so that<br>IdentityServer can allow cross-origin calls from<br>the origin.|\n|AllowedScopes|Specifies the resources the client has access to.<br>By default, a client has no access to any<br>resources.|\n|AllowOfflineAccess|Specifies whether the client can request refresh<br>tokens.|\n|AllowAccessTokensViaBrowser|Specifies whether the client can receive access<br>tokens from a browser window.|\n|AlwaysIncludeUserClaimsInIdToken|Specifies that the user claims will always be<br>added to the id token. By default, these would<br>have to be retrieved using the userinfo<br>endpoint.|\n|AccessTokenLifetime|Specifies the lifetime of the access token in<br>seconds.|\n|IdentityTokenLifetime|Specifies the lifetime of the identity token in<br>seconds.|', 'task_item': False}]], 'Ordered list': [[{'text': 'If the type hasn’t been registered, the container throws an exception.', 'task_item': False}, {'text': 'If the type has been registered as a singleton, the container returns the singleton instance. If\nthis is the first time the type is called for, the container creates it if required and maintains a\nreference to it.', 'task_item': False}, {'text': 'If the type has been registered as transient, the container returns a new instance and doesn’t\nmaintain a reference to it.', 'task_item': False}, {'text': '.NET MAUI offers a number of ways to resolve registered components based on your needs. The most\ndirect way to gain access to the dependency injection container is from an Element using the\nHandler.MauiContext.Services. An example of this is shown below:', 'task_item': False}]]}