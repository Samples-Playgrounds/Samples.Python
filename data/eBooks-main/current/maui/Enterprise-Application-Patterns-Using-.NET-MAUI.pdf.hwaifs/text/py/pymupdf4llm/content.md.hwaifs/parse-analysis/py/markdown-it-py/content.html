<p><a href="https://aka.ms/maui-ebook">DOWNLOAD available at: https://aka.ms/maui-ebook</a></p>
<p><strong>EDITION v2.0</strong></p>
<p>PUBLISHED BY</p>
<p>Microsoft Developer Division, .NET, and Visual Studio product teams</p>
<p>A division of Microsoft Corporation</p>
<p>One Microsoft Way</p>
<p>Redmond, Washington 98052-6399</p>
<p>Copyright © 2022 by Microsoft Corporation</p>
<p>All rights reserved. No part of the contents of this book may be reproduced or transmitted in any<br />
form or by any means without the written permission of the publisher.</p>
<p>This book is provided “as-is” and expresses the author’s views and opinions. The views, opinions, and<br />
information expressed in this book, including URL and other Internet website references, may change<br />
without notice.</p>
<p>Some examples depicted herein are provided for illustration only and are fictitious. No real association<br />
or connection is intended or should be inferred.</p>
<p><a href="https://www.microsoft.com/">Microsoft and the trademarks listed at https://www.microsoft.com</a> on the “Trademarks” webpage are<br />
trademarks of the Microsoft group of companies.</p>
<p>Mac and macOS are trademarks of Apple Inc.</p>
<p>All other marks and logos are property of their respective owners.</p>
<p>Authors:</p>
<p><strong><a href="https://github.com/michaelstonis">Michael Stonis</a></strong> <a href="https://eightbot.com/">, Mobile Software Architect, Eight-Bot</a></p>
<p>Reviewers:</p>
<p><strong><a href="https://github.com/jamesmontemagno">James Montemagno</a></strong>, Principal Lead Program Manager, Microsoft Corp.</p>
<p><strong><a href="https://github.com/IEvangelist">David Pine</a></strong>, Developer Relations, Microsoft Corp.</p>
<h3>Acknowledgments</h3>
<p>This book originated from the excellent Enterprise Application Patterns using Xamarin.Forms eBook by<br />
<a href="https://github.com/davidbritch">David Britch</a> <a href="https://github.com/jsuarezruiz">and Javier Suarez Ruiz. Without their hard work, detailed information, and excellent</a><br />
examples, this book would not be possible.</p>
<h3>Introduction</h3>
<p>Enterprise applications face a number of difficult problems to solve including ever changing business<br />
requirements, the need for quick turn around time, support for multiple platforms, and integration<br />
with multiple systems. Due to the varying nature of these problems, it’s important that our<br />
application’s architecture allows it to be modular, modifiable and extensible over time.</p>
<p>This book takes provides real world solutions for addressing these issues when building an enterprise<br />
application using .NET MAUI. This book uses a pre-built .NET MAUI application that serves as the<br />
front-end of an online eCommerce application as a reference and a guide for common enterprise<br />
design patterns. This book covers topics such as the MVVM pattern, dependency injection, navigation,<br />
configuration, the loose-coupling of components and additional enterprise concerns. The content of<br />
this book is helpful for anyone looking to build a new application for this business or looking to solve<br />
the problems of applications that evolve over time.</p>
<h3>Who should use the book</h3>
<p>This book is for .NET MAUI developers that are already familiar with the framework, but that are<br />
looking for guidance on architecture and implementation when building enterprise applications. This<br />
book can help developers solve common problems using tried and true patterns.</p>
<h3>How to use the book</h3>
<p>This book focuses on building cross-platform enterprise apps using .NET MAUI. As such, it should be<br />
read in its entirety to provide a foundation of understanding such apps and their technical<br />
considerations. The book, along with its sample app, can also serve as a starting point or reference for<br />
creating a new enterprise app. Use the associated sample app as a template for the new app, or to see<br />
how to organize an app’s component parts. Then, refer back to this guide for architectural guidance.<br />
<a href="https://github.com/dotnet/eshop">You can find the sample app on GitHub.</a></p>
<h3>What this book doesn’t cover</h3>
<p>This book is aimed at readers who are already familiar with .NET MAUI. It does cover some concepts<br />
of .NET MAUI to help better illustrate the topic, but it does not cover most controls and concepts in<br />
<a href="https://docs.microsoft.com/dotnet/maui/get-started/first-app">any detail. For general guidance on building a new .NET MAUI app, please refer to the Building your</a><br />
<a href="https://docs.microsoft.com/dotnet/maui/get-started/first-app">first app</a> guide in the .NET MAUI documentation.</p>
<h4><strong>Additional resources</strong></h4>
<p><a href="https://docs.microsoft.com/dotnet/maui">For official .NET MAUI content, see .NET MAUI docs. .NET MAUI is developed as an open-source</a><br />
<a href="https://github.com/dotnet/maui">project and is available on GitHub at dotnet/maui. For code samples developed with .NET MAUI, see</a><br />
<a href="https://github.com/dotnet/maui-samples">the dotnet/maui-samples repo.</a></p>
<h2>Contents</h2>
<p><strong>Purpose ..................................................................................................................................... 1</strong></p>
<p>What’s left out of this guide’s scope ................................................................................................................................ 1</p>
<p>Who should use this guide .................................................................................................................................................. 1</p>
<p>How to use this guide ............................................................................................................................................................ 2</p>
<p><strong>Introduction to .NET MAUI .................................................................................................... 3</strong></p>
<p>Sample application .................................................................................................................................................................. 4</p>
<p>Sample application architecture ........................................................................................................................................ 5</p>
<p>Multi-Platform app .................................................................................................................................................................. 6</p>
<p>Multi-Platform app solution ................................................................................................................................................ 7</p>
<p>eShop project ............................................................................................................................................................................ 7</p>
<p>Summary ..................................................................................................................................................................................... 8</p>
<p><strong>Model-View-ViewModel (MVVM) ......................................................................................... 9</strong></p>
<p>The MVVM pattern .................................................................................................................................................................. 9</p>
<p>View ....................................................................................................................................................................................... 10</p>
<p>ViewModel .......................................................................................................................................................................... 11</p>
<p>Model .................................................................................................................................................................................... 11</p>
<p>Connecting view models to views .................................................................................................................................. 12</p>
<p>Creating a view model declaratively ............................................................................................................................. 12</p>
<p>Creating a view model programmatically ................................................................................................................... 13</p>
<p>Updating views in response to changes in the underlying view model or model...................................... 13</p>
<p>MVVM Frameworks .............................................................................................................................................................. 15</p>
<p>UI interaction using commands and behaviors ........................................................................................................ 15</p>
<p>Implementing commands ................................................................................................................................................. 16</p>
<p>Invoking commands from a view ................................................................................................................................... 17</p>
<p>Implementing behaviors .................................................................................................................................................... 17</p>
<p>Invoking behaviors from a view ...................................................................................................................................... 20</p>
<p>Summary .................................................................................................................................................................................. 20</p>
<p><strong>Dependency injection ........................................................................................................... 21</strong></p>
<p>i Contents</p>
<p>Introduction to dependency injection .......................................................................................................................... 21</p>
<p>Registration ............................................................................................................................................................................. 23</p>
<p>Resolution ................................................................................................................................................................................ 25</p>
<p>Summary .................................................................................................................................................................................. 26</p>
<p><strong>Communicating between loosely coupled components ................................................... 27</strong></p>
<p>Introduction to MVVM Toolkit Messenger ................................................................................................................. 27</p>
<p>Defining a message .............................................................................................................................................................. 29</p>
<p>Publishing a message .......................................................................................................................................................... 29</p>
<p>Subscribing to a message.................................................................................................................................................. 30</p>
<p>Unsubscribing from a message ....................................................................................................................................... 30</p>
<p>Summary .................................................................................................................................................................................. 31</p>
<p><strong>Navigation .............................................................................................................................. 32</strong></p>
<p>Navigating between pages ............................................................................................................................................... 33</p>
<p>Creating the MauiNavigationService instance .......................................................................................................... 34</p>
<p>Handling navigation requests .......................................................................................................................................... 34</p>
<p>Navigating when the app is launched .......................................................................................................................... 36</p>
<p>Passing parameters during navigation ......................................................................................................................... 36</p>
<p>Invoking navigation using behaviors ............................................................................................................................ 37</p>
<p>Confirming or cancelling navigation ............................................................................................................................. 38</p>
<p>Summary .................................................................................................................................................................................. 38</p>
<p><strong>Validation ............................................................................................................................... 39</strong></p>
<p>Specifying validation rules ................................................................................................................................................ 40</p>
<p>Adding validation rules to a property .......................................................................................................................... 42</p>
<p>Triggering validation ........................................................................................................................................................... 42</p>
<p>Triggering validation manually ................................................................................................................................... 42</p>
<p>Triggering validation when properties change .................................................................................................... 43</p>
<p>Displaying validation errors .............................................................................................................................................. 43</p>
<p>Highlighting a control that contains invalid data ................................................................................................ 44</p>
<p>Displaying error messages ........................................................................................................................................... 45</p>
<p>Summary .................................................................................................................................................................................. 45</p>
<p><strong>Application settings management ...................................................................................... 46</strong></p>
<p>ii Contents</p>
<p>Creating a Settings Interface ............................................................................................................................................ 46</p>
<p>Adding Settings ..................................................................................................................................................................... 47</p>
<p>Data binding to user settings........................................................................................................................................... 48</p>
<p>Summary .................................................................................................................................................................................. 49</p>
<p><strong>Containerized microservices ................................................................................................ 50</strong></p>
<p>Microservices .......................................................................................................................................................................... 51</p>
<p>Containerization .................................................................................................................................................................... 53</p>
<p>Communication between client and microservices ................................................................................................ 56</p>
<p>Communication between microservices ...................................................................................................................... 57</p>
<p>Summary .................................................................................................................................................................................. 59</p>
<p><strong>Accessing remote data .......................................................................................................... 60</strong></p>
<p>Introduction to Representational State Transfer ...................................................................................................... 60</p>
<p>Consuming RESTful APIs .................................................................................................................................................... 61</p>
<p>Making web requests .......................................................................................................................................................... 61</p>
<p>Making a GET request ......................................................................................................................................................... 61</p>
<p>Making a POST request ...................................................................................................................................................... 64</p>
<p>Making a DELETE request .................................................................................................................................................. 67</p>
<p>Caching data ........................................................................................................................................................................... 68</p>
<p>Managing data expiration ................................................................................................................................................. 69</p>
<p>Caching images ..................................................................................................................................................................... 69</p>
<p>Increasing resilience ............................................................................................................................................................. 70</p>
<p>Retry pattern ........................................................................................................................................................................... 70</p>
<p>Circuit breaker pattern ........................................................................................................................................................ 71</p>
<p>Summary .................................................................................................................................................................................. 72</p>
<p><strong>Authentication and authorization ....................................................................................... 73</strong></p>
<p>Authentication ........................................................................................................................................................................ 73</p>
<p>Issuing bearer tokens using IdentityServer ............................................................................................................ 74</p>
<p>Adding IdentityServer to a web application .......................................................................................................... 75</p>
<p>Configuring IdentityServer ........................................................................................................................................... 75</p>
<p>Configuring API resources ............................................................................................................................................ 76</p>
<p>Configuring identity resources ................................................................................................................................... 76</p>
<p>iii Contents</p>
<p>Configuring clients .......................................................................................................................................................... 77</p>
<p>Configuring the authentication flow ........................................................................................................................ 78</p>
<p>Performing authentication ........................................................................................................................................... 79</p>
<p>Signing-in ............................................................................................................................................................................ 80</p>
<p>Signing-out ......................................................................................................................................................................... 83</p>
<p>Authorization .......................................................................................................................................................................... 84</p>
<p>Configuring IdentityServer to perform authorization ............................................................................................ 85</p>
<p>Making access requests to APIs ...................................................................................................................................... 86</p>
<p>Summary .................................................................................................................................................................................. 87</p>
<p><strong>MVVM Toolkit Features ........................................................................................................ 88</strong></p>
<p>MVVM Toolkit ........................................................................................................................................................................ 88</p>
<p>ObservableObject ................................................................................................................................................................. 89</p>
<p>RelayCommand and AsyncRelayCommand ............................................................................................................... 90</p>
<p>Source Generators ................................................................................................................................................................ 91</p>
<p>Summary .................................................................................................................................................................................. 93</p>
<p><strong>Unit testing ............................................................................................................................ 94</strong></p>
<p>Dependency injection and unit testing ........................................................................................................................ 95</p>
<p>Testing MVVM applications .............................................................................................................................................. 95</p>
<p>Testing asynchronous functionality ............................................................................................................................... 96</p>
<p>Testing INotifyPropertyChanged implementations ................................................................................................ 97</p>
<p>Testing message-based communication ..................................................................................................................... 97</p>
<p>Testing exception handling .............................................................................................................................................. 98</p>
<p>Testing validation .................................................................................................................................................................. 98</p>
<p>Summary .................................................................................................................................................................................. 99</p>
<p>iv Contents</p>
<p><strong>CHAPTER</strong></p>
<h1>1</h1>
<h2>Purpose</h2>
<p>This eBook provides guidance on building cross-platform enterprise apps using .NET MAUI. .NET<br />
MAUI is a cross-platform UI toolkit that allows developers to easily create native user interface layouts<br />
that can be shared across platforms, including iOS, macOS, Android, and Windows. It provides a<br />
comprehensive solution for Business to Employee (B2E), Business to Business (B2B), and Business to<br />
Consumer (B2C) apps, providing the ability to share code across all target platforms and helping to<br />
lower the total cost of ownership (TCO).</p>
<p>The guide provides architectural guidance for developing adaptable, maintainable, and testable .NET<br />
MAUI enterprise apps. Guidance is provided on how to implement MVVM, dependency injection,<br />
navigation, validation, and configuration management, while maintaining loose coupling. In addition,<br />
there’s also guidance on performing authentication and authorization with IdentityServer, accessing<br />
data from containerized microservices, and unit testing.</p>
<p><a href="https://github.com/dotnet/eShop/tree/main/src/ClientApp">The guide comes with source code for the eShop multi-platform app, and source code for the eShop</a><br />
<a href="https://github.com/dotnet/eShop">reference app. The eShop multi-platform app is a cross-platform enterprise app developed using .NET</a><br />
MAUI, which connects to a series of containerized microservices known as the eShop reference app.<br />
However, the eShop multi-platform app can be configured to consume data from mock services for<br />
those who wish to avoid deploying the containerized microservices.</p>
<h3>What’s left out of this guide’s scope</h3>
<p>This guide is aimed at readers who are already familiar with .NET MAUI. For a detailed introduction to<br />
<a href="https://docs.microsoft.com/dotnet/maui/">.NET MAUI, see the .NET MAUI documentation.</a></p>
<h3>Who should use this guide</h3>
<p>The audience for this guide is mainly developers and architects who would like to learn how to<br />
architect and implement cross-platform enterprise apps using .NET MAUI.</p>
<p>A secondary audience is technical decision-makers who would like to receive an architectural and<br />
technology overview before deciding on what approach to select for cross-platform enterprise app<br />
development using .NET MAUI.</p>
<p>1 CHAPTER 1 | Purpose</p>
<h3>How to use this guide</h3>
<p>This guide focuses on building cross-platform enterprise apps using .NET MAUI. As such, it should be<br />
read in its entirety to provide a foundation of understanding such apps and their technical<br />
considerations. The guide and its sample app can also serve as a starting point or reference for<br />
creating a new enterprise app. Use the associated sample app as a template for the new app or see<br />
how to organize an app’s component parts. Then, refer back to this guide for architectural guidance.</p>
<p>Feel free to forward this guide to team members to help ensure a common understanding of crossplatform enterprise app development using .NET MAUI. Having everybody working from a common<br />
set of terminologies and underlying principles will help ensure a consistent application of architectural<br />
patterns and practices.</p>
<p>2 CHAPTER 1 | Purpose</p>
<p><strong>CHAPTER</strong></p>
<h1>2</h1>
<h2>Introduction to .NET MAUI</h2>
<p>Regardless of platform, developers of enterprise apps face several challenges:</p>
<ul>
<li>
<p>App requirements that can change over time.</p>
</li>
<li>
<p>New business opportunities and challenges.</p>
</li>
<li>
<p>Ongoing feedback during development that can significantly affect the scope and<br />
requirements of the app.</p>
</li>
</ul>
<p>With these in mind, it’s important to build apps that can be easily modified or extended over time.<br />
Designing for such adaptability can be difficult as it requires an architecture that allows individual<br />
parts of the app to be independently developed and tested in isolation without affecting the rest of<br />
the app.</p>
<p>Many enterprise apps are sufficiently complex to require more than one developer. It can be a<br />
significant challenge to decide how to design an app so that multiple developers can work effectively<br />
on different pieces of the app independently, while ensuring that the pieces come together seamlessly<br />
when integrated into the app.</p>
<p>The traditional approach to designing and building an app results in what is referred to as a<br />
<em>monolithic</em> app, where components are tightly coupled with no clear separation between them.<br />
Typically, this monolithic approach leads to apps that are difficult and inefficient to maintain, because<br />
it can be difficult to resolve bugs without breaking other components in the app, and it can be<br />
difficult to add new features or to replace existing features.</p>
<p>An effective remedy for these challenges is to partition an app into discrete, loosely coupled<br />
components that can be easily integrated together into an app. Such an approach offers several<br />
benefits:</p>
<ul>
<li>
<p>It allows individual functionality to be developed, tested, extended, and maintained by<br />
different individuals or teams.</p>
</li>
<li>
<p>It promotes reuse and a clean separation of concerns between the app’s horizontal<br />
capabilities, such as authentication and data access, and the vertical capabilities, such as app<br />
specific business functionality. This allows the dependencies and interactions between app<br />
components to be more easily managed.</p>
</li>
<li>
<p>It helps maintain a separation of roles by allowing different individuals, or teams, to focus on<br />
a specific task or piece of functionality according to their expertise. In particular, it provides a<br />
cleaner separation between the user interface and the app’s business logic.</p>
</li>
</ul>
<p>However, there are many issues that must be resolved when partitioning an app into discrete, loosely<br />
coupled components. These include:</p>
<p>3 CHAPTER 2 | Introduction to .NET MAUI</p>
<ul>
<li>
<p>Deciding how to provide a clean separation of concerns between the user interface controls<br />
and their logic. One of the most important decisions when creating a .NET MAUI enterprise<br />
app is whether to place business logic in code-behind files, or whether to create a clean<br />
separation of concerns between the user interface controls and their logic, in order to make<br />
the app more maintainable and testable. For more information, see Model-View-ViewModel.</p>
</li>
<li>
<p>Determining whether to use a dependency injection container. Dependency injection<br />
containers reduce the dependency coupling between objects by providing a facility to<br />
construct instances of classes with their dependencies injected, and manage their lifetime<br />
based on the configuration of the container. For more information, see Dependency injection.</p>
</li>
<li>
<p>Choosing between platform provided eventing and loosely coupled message-based<br />
communication between components that are inconvenient to link by object and type<br />
references. For more information, see Introduction to Communicating between loosely<br />
coupled components.</p>
</li>
<li>
<p>Deciding how to navigate between pages, including how to invoke navigation, and where<br />
navigation logic should reside. For more information, see Navigation.</p>
</li>
<li>
<p>Determining how to validate user input for correctness. The decision must include how to<br />
validate user input, and how to notify the user about validation errors. For more information,<br />
see Validation.</p>
</li>
<li>
<p>Deciding how to perform authentication, and how to protect resources with authorization. For<br />
more information, see Authentication and authorization.</p>
</li>
<li>
<p>Determining how to access remote data from web services, including how to reliably retrieve<br />
data, and how to cache data. For more information, see Accessing remote data.</p>
</li>
<li>
<p>Deciding how to test the app. For more information, see Unit testing.</p>
</li>
</ul>
<p>This guide provides guidance on these issues, and focuses on the core patterns and architecture for<br />
building a cross-platform enterprise app using .NET MAUI. The guidance aims to help to produce<br />
adaptable, maintainable, and testable code, by addressing common .NET MAUI enterprise app<br />
development scenarios, and by separating the concerns of presentation, presentation logic, and<br />
entities through support for the Model-View-ViewModel (MVVM) pattern.</p>
<h3>Sample application</h3>
<p>This guide includes a sample application, eShop, that’s an online store that includes the following<br />
functionality:</p>
<ul>
<li>
<p>Authenticating and authorizing against a backend service.</p>
</li>
<li>
<p>Browsing a catalog of items.</p>
</li>
<li>
<p>Filtering the catalog.</p>
</li>
<li>
<p>Ordering items from the catalog.</p>
</li>
<li>
<p>Viewing the user’s order history.</p>
</li>
<li>
<p>Configuration of settings.</p>
</li>
</ul>
<p>4 CHAPTER 2 | Introduction to .NET MAUI</p>
<h3>Sample application architecture</h3>
<p>Below is a high-level overview of the architecture of the sample application.</p>
<p>The sample application ships with:</p>
<ul>
<li>
<p>.NET Aspire App Hosting &amp; Orchestration</p>
</li>
<li>
<p>An Blazor web application developed with ASP.NET Core.</p>
</li>
<li>
<p>A multi-platform app developed with .NET MAUI, which supports iOS, Android, macOS via<br />
Mac Catalyst, and Windows.</p>
</li>
</ul>
<p>The sample application includes the following backend services:</p>
<ul>
<li>
<p>An identity microservice, which uses ASP.NET Core Identity and IdentityServer.</p>
</li>
<li>
<p>A catalog microservice, which is a data-driven create, read, update, delete (CRUD) service that<br />
consumes an SQL Server database using EntityFramework Core.</p>
</li>
<li>
<p>An ordering microservice, which is a domain-driven service that uses domain-driven design<br />
patterns.</p>
</li>
<li>
<p>A basket microservice, which is a data-driven CRUD service that uses Redis Cache.</p>
</li>
</ul>
<p>These backend services are implemented as microservices using ASP.NET Core, and are deployed as<br />
unique containers with .NET Aspire. Collectively, these backend services are referred to as the eShop<br />
reference application. Client apps communicate with the backend services through a Representational<br />
State Transfer (REST) web interface. For more information about microservices and conainers, see<br />
Containerized microservices.</p>
<p>5 CHAPTER 2 | Introduction to .NET MAUI</p>
<h3>Multi-Platform app</h3>
<p>This guide focuses on building cross-platform enterprise apps using .NET MAUI, and uses the eShop<br />
multi-platform app as an example. The image below shows the pages from the eShop multi-platform<br />
app that provide the functionality outlined earlier.</p>
<p>The multi-platform app consumes the backend services provided by the eShop reference application.<br />
However, it can be configured to consume data from mock services for those who wish to avoid<br />
deploying the backend services.</p>
<p>The eShop multi-platform app exercises the following .NET MAUI functionality:</p>
<p>6 CHAPTER 2 | Introduction to .NET MAUI</p>
<ul>
<li>
<p>XAML</p>
</li>
<li>
<p>Controls</p>
</li>
<li>
<p>Bindings</p>
</li>
<li>
<p>Converters</p>
</li>
<li>
<p>Styles</p>
</li>
<li>
<p>Animations</p>
</li>
<li>
<p>Commands</p>
</li>
<li>
<p>Behaviors</p>
</li>
<li>
<p>Triggers</p>
</li>
<li>
<p>Effects</p>
</li>
<li>
<p>Custom Controls</p>
</li>
</ul>
<p><a href="https://docs.microsoft.com/dotnet/maui">For more information about this functionality, see the .NET MAUI documentation.</a></p>
<p>In addition, unit tests are provided for some of the classes in the eShop multi-platform app.</p>
<h3>Multi-Platform app solution</h3>
<p>The eShop multi-platform app solution organizes the source code and other resources into a multiple<br />
projects. All of the core mobile components are contained in a singular project named<br />
eShopContainers. This is a feature introduced with .NET 6 that allows a project to target multiple<br />
outputs which helps eliminate the need for multiple platform projects that we would have used in<br />
Xamarin.Forms and earlier .NET versions. An additional project is included for unit testing.</p>
<p>While this project has all of its components stored in a singular project, it is worth considering<br />
separating it into multiple projects based on your needs. For example, if you have multiple<br />
implementations of service providers based off of a service with their own dependencies, it may make<br />
sense to break those service provider implementations out into their own separate project. Good<br />
candidates for project separation include shared models, service implementations, api client<br />
components, database or caching layers. Any place where you feel that the business could re-use a<br />
component in another project is a potential candidate for separation. These projects can then be<br />
<a href="https://docs.microsoft.com/nuget/">packaged via NuGet</a> for easy distribution and versioning.</p>
<p>All of the projects use folders to organize the source code and other resources into categories. The<br />
classes from the eShop multi-platform app can be re-used in any .NET MAUI app with little or no<br />
modification.</p>
<h3>eShop project</h3>
<p>The eShop project contains the following folders:</p>
<table>
<thead>
<tr>
<th>Folder</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Animations</em></td>
<td>Contains classes that enable animations to be consumed in XAML.</td>
</tr>
<tr>
<td><em>Behaviors</em></td>
<td>Contains behaviors that are exposed to view classes.</td>
</tr>
</tbody>
</table>
<p>7 CHAPTER 2 | Introduction to .NET MAUI</p>
<table>
<thead>
<tr>
<th>Folder</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Controls</em></td>
<td>Contains custom controls used by the app.</td>
</tr>
<tr>
<td><em>Converters</em></td>
<td>Contains value converters that apply custom logic to a binding.</td>
</tr>
<tr>
<td><em>Exceptions</em></td>
<td>Contains the custom ServiceAuthenticationException.</td>
</tr>
<tr>
<td><em>Extensions</em></td>
<td>Contains extension methods for the VisualElement and IEnumerable<T> classes.</td>
</tr>
<tr>
<td><em>Helpers</em></td>
<td>Contains helper classes for the app.</td>
</tr>
<tr>
<td><em>Models</em></td>
<td>Contains the model classes for the app.</td>
</tr>
<tr>
<td><em>Properties</em></td>
<td>Contains AssemblyInfo.cs, a .NET assembly metadata file.</td>
</tr>
<tr>
<td><em>Services</em></td>
<td>Contains interfaces and classes that implement services that are provided to the<br>app.</td>
</tr>
<tr>
<td><em>Triggers</em></td>
<td>Contains the BeginAnimation trigger, which is used to invoke an animation in XAML.</td>
</tr>
<tr>
<td><em>Validations</em></td>
<td>Contains classes involved in validating data input.</td>
</tr>
<tr>
<td><em>ViewModels</em></td>
<td>Contains the application logic that’s exposed to pages.</td>
</tr>
<tr>
<td><em>Views</em></td>
<td>Contains the pages for the app.</td>
</tr>
</tbody>
</table>
<h3>Summary</h3>
<p>Microsoft’s cross-platform multi-platform app development tools and platforms provide a<br />
comprehensive solution for B2E, B2B, and B2C mobile client apps, providing the ability to share code<br />
across all target platforms (iOS, macOS, Android, and Windows) and helping to lower the total cost of<br />
ownership. Apps can share their user interface and app logic code, while retaining the native platform<br />
look and feel.</p>
<p>Developers of enterprise apps face several challenges that can alter the architecture of the app during<br />
development. Therefore, it’s important to build an app so that it can be modified or extended over<br />
time. Designing for such adaptability can be difficult, but typically involves partitioning an app into<br />
discrete, loosely coupled components that can be easily integrated together into an app.</p>
<p>8 CHAPTER 2 | Introduction to .NET MAUI</p>
<p><strong>CHAPTER</strong></p>
<h1>3</h1>
<h2>Model-View-ViewModel (MVVM)</h2>
<p>The .NET MAUI developer experience typically involves creating a user interface in XAML, and then<br />
adding code-behind that operates on the user interface. Complex maintenance issues can arise as<br />
apps are modified and grow in size and scope. These issues include the tight coupling between the UI<br />
controls and the business logic, which increases the cost of making UI modifications, and the difficulty<br />
of unit testing such code.</p>
<p>The MVVM pattern helps cleanly separate an application’s business and presentation logic from its<br />
user interface (UI). Maintaining a clean separation between application logic and the UI helps address<br />
numerous development issues and makes an application easier to test, maintain, and evolve. It can<br />
also significantly improve code re-use opportunities and allows developers and UI designers to<br />
collaborate more easily when developing their respective parts of an app.</p>
<h3>The MVVM pattern</h3>
<p>There are three core components in the MVVM pattern: the model, the view, and the view model.<br />
Each serves a distinct purpose. The diagram below shows the relationships between the three<br />
components.</p>
<p>In addition to understanding the responsibilities of each component, it’s also important to understand<br />
how they interact. At a high level, the view “knows about” the view model, and the view model “knows<br />
about” the model, but the model is unaware of the view model, and the view model is unaware of the<br />
view. Therefore, the view model isolates the view from the model, and allows the model to evolve<br />
independently of the view.</p>
<p>The benefits of using the MVVM pattern are as follows:</p>
<p>9 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<ul>
<li>
<p>If an existing model implementation encapsulates existing business logic, it can be difficult or<br />
risky to change it. In this scenario, the view model acts as an adapter for the model classes<br />
and prevents you from making major changes to the model code.</p>
</li>
<li>
<p>Developers can create unit tests for the view model and the model, without using the view.<br />
The unit tests for the view model can exercise exactly the same functionality as used by the<br />
view.</p>
</li>
<li>
<p>The app UI can be redesigned without touching the view model and model code, provided<br />
that the view is implemented entirely in XAML or C#. Therefore, a new version of the view<br />
should work with the existing view model.</p>
</li>
<li>
<p>Designers and developers can work independently and concurrently on their components<br />
during development. Designers can focus on the view, while developers can work on the view<br />
model and model components.</p>
</li>
</ul>
<p>The key to using MVVM effectively lies in understanding how to factor app code into the correct<br />
classes and how the classes interact. The following sections discuss the responsibilities of each of the<br />
classes in the MVVM pattern.</p>
<h4><strong>View</strong></h4>
<p>The view is responsible for defining the structure, layout, and appearance of what the user sees on<br />
screen. Ideally, each view is defined in XAML, with a limited code-behind that does not contain<br />
business logic. However, in some cases, the code-behind might contain UI logic that implements<br />
visual behavior that is difficult to express in XAML, such as animations.</p>
<p>In a .NET MAUI application, a view is typically a ContentPage-derived or ContentView-derived class.<br />
However, views can also be represented by a data template, which specifies the UI elements to be<br />
used to visually represent an object when it’s displayed. A data template as a view does not have any<br />
code-behind, and is designed to bind to a specific view model type.</p>
<p>Ensure that the view models are responsible for defining logical state changes that affect some<br />
aspects of the view’s display, such as whether a command is available, or an indication that an<br />
operation is pending. Therefore, enable and disable UI elements by binding to view model properties,<br />
rather than enabling and disabling them in code-behind.</p>
<p>There are several options for executing code on the view model in response to interactions on the<br />
view, such as a button click or item selection. If a control supports commands, the control’s Command<br />
property can be data-bound to an ICommand property on the view model. When the control’s<br />
command is invoked, the code in the view model will be executed. In addition to commands,<br />
behaviors can be attached to an object in the view and can listen for either a command to be invoked<br />
or the event to be raised. In response, the behavior can then invoke an ICommand on the view model<br />
or a method on the view model.</p>
<p>10 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<h4><strong>ViewModel</strong></h4>
<p>The view model implements properties and commands to which the view can data bind to, and<br />
notifies the view of any state changes through change notification events. The properties and<br />
commands that the view model provides define the functionality to be offered by the UI, but the view<br />
determines how that functionality is to be displayed.</p>
<p>Multi-platform apps should keep the UI thread unblocked to improve the user’s perception of<br />
performance. Therefore, in the view model, use asynchronous methods for I/O operations and raise<br />
events to asynchronously notify views of property changes.</p>
<p>The view model is also responsible for coordinating the view’s interactions with any model classes that<br />
are required. There’s typically a one-to-many relationship between the view model and the model<br />
classes. The view model might choose to expose model classes directly to the view so that controls in<br />
the view can data bind directly to them. In this case, the model classes will need to be designed to<br />
support data binding and change notification events.</p>
<p>Each view model provides data from a model in a form that the view can easily consume. To<br />
accomplish this, the view model sometimes performs data conversion. Placing this data conversion in<br />
the view model is a good idea because it provides properties that the view can bind to. For example,<br />
the view model might combine the values of two properties to make it easier to display by the view.</p>
<p>It’s also possible to use converters as a separate data conversion layer that sits between the view<br />
model and the view. This can be necessary, for example, when data requires special formatting that<br />
the view model doesn’t provide.</p>
<p>In order for the view model to participate in two-way data binding with the view, its properties must<br />
raise the PropertyChanged event. View models satisfy this requirement by implementing the<br />
INotifyPropertyChanged interface, and raising the PropertyChanged event when a property is<br />
changed.</p>
<p>For collections, the view-friendly ObservableCollection<T> is provided. This collection implements<br />
collection changed notification, relieving the developer from having to implement the<br />
INotifyCollectionChanged interface on collections.</p>
<h4><strong>Model</strong></h4>
<p>Model classes are non-visual classes that encapsulate the app’s data. Therefore, the model can be<br />
thought of as representing the app’s domain model, which usually includes a data model along with<br />
business and validation logic. Examples of model objects include data transfer objects (DTOs), Plain<br />
Old CLR Objects (POCOs), and generated entity and proxy objects.</p>
<p>11 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p>Model classes are typically used in conjunction with services or repositories that encapsulate data<br />
access and caching.</p>
<h3>Connecting view models to views</h3>
<p>View models can be connected to views by using the data-binding capabilities of .NET MAUI. There<br />
are many approaches that can be used to construct views and view models and associate them at<br />
runtime. These approaches fall into two categories, known as view first composition, and view model<br />
first composition. Choosing between view first composition and view model first composition is an<br />
issue of preference and complexity. However, all approaches share the same aim, which is for the view<br />
to have a view model assigned to its BindingContext property.</p>
<p>With view first composition the app is conceptually composed of views that connect to the view<br />
models they depend on. The primary benefit of this approach is that it makes it easy to construct<br />
loosely coupled, unit testable apps because the view models have no dependence on the views<br />
themselves. It’s also easy to understand the structure of the app by following its visual structure,<br />
rather than having to track code execution to understand how classes are created and associated. In<br />
addition, view first construction aligns with the Microsoft Maui’s navigation system that’s responsible<br />
for constructing pages when navigation occurs, which makes a view model first composition complex<br />
and misaligned with the platform.</p>
<p>With view model first composition, the app is conceptually composed of view models, with a service<br />
responsible for locating the view for a view model. View model first composition feels more natural to<br />
some developers, since the view creation can be abstracted away, allowing them to focus on the<br />
logical non-UI structure of the app. In addition, it allows view models to be created by other view<br />
models. However, this approach is often complex, and it can become difficult to understand how the<br />
various parts of the app are created and associated.</p>
<p>The binding of views to a property in a data source should be the view’s principal dependency on its<br />
corresponding view model. Specifically, don’t reference view types, such as Button and ListView, from<br />
view models. By following the principles outlined here, view models can be tested in isolation,<br />
therefore reducing the likelihood of software defects by limiting scope.</p>
<p>The following sections discuss the main approaches to connecting view models to views.</p>
<h3>Creating a view model declaratively</h3>
<p>The simplest approach is for the view to declaratively instantiate its corresponding view model in<br />
XAML. When the view is constructed, the corresponding view model object will also be constructed.<br />
This approach is demonstrated in the following code example:</p>
<p>12 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p>When the ContentPage is created, an instance of the LoginViewModel is automatically constructed<br />
and set as the view’s BindingContext.</p>
<p>This declarative construction and assignment of the view model by the view has the advantage that<br />
it’s simple, but has the disadvantage that it requires a default (parameter-less) constructor in the view<br />
model.</p>
<h3>Creating a view model programmatically</h3>
<p>A view can have code in the code-behind file, resulting in the view-model being assigned to its<br />
BindingContext property. This is often accomplished in the view’s constructor, as shown in the<br />
following code example:</p>
<p>The programmatic construction and assignment of the view model within the view’s code-behind has<br />
the advantage that it’s simple. However, the main disadvantage of this approach is that the view<br />
needs to provide the view model with any required dependencies. Using a dependency injection<br />
container can help to maintain loose coupling between the view and view model. For more<br />
information, see Dependency injection.</p>
<h3>Updating views in response to changes in the underlying view model or model</h3>
<p>All view model and model classes that are accessible to a view should implement the</p>
<p>[<a href="https://docs.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged">INotifyPropertyChanged interface. Implementing this interface in a view model or model class allows</a><br />
the class to provide change notifications to any data-bound controls in the view when the underlying<br />
property value changes.</p>
<p>App’s should be architected for the correct use of property change notification, by meeting the<br />
following requirements:</p>
<ul>
<li>
<p>Always raising a PropertyChanged event if a public property’s value changes. Do not assume<br />
that raising the PropertyChanged event can be ignored because of knowledge of how XAML<br />
binding occurs.</p>
</li>
<li>
<p>Always raising a PropertyChanged event for any calculated properties whose values are used<br />
by other properties in the view model or model.</p>
</li>
<li>
<p>Always raising the PropertyChanged event at the end of the method that makes a property<br />
change, or when the object is known to be in a safe state. Raising the event interrupts the</p>
</li>
</ul>
<p>13 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p>operation by invoking the event’s handlers synchronously. If this happens in the middle of an<br />
operation, it might expose the object to callback functions when it is in an unsafe, partially<br />
updated state. In addition, it’s possible for cascading changes to be triggered by<br />
PropertyChanged events. Cascading changes generally require updates to be complete before<br />
the cascading change is safe to execute.</p>
<ul>
<li>
<p>Never raising a PropertyChanged event if the property does not change. This means that you<br />
must compare the old and new values before raising the PropertyChanged event.</p>
</li>
<li>
<p>Never raising the PropertyChanged event during a view model’s constructor if you are<br />
initializing a property. Data-bound controls in the view will not have subscribed to receive<br />
change notifications at this point.</p>
</li>
<li>
<p>Never raising more than one PropertyChanged event with the same property name argument<br />
within a single synchronous invocation of a public method of a class. For example, given a<br />
NumberOfItems property whose backing store is the _numberOfItems field, if a method<br />
increments _numberOfItems fifty times during the execution of a loop, it should only raise<br />
property change notification on the NumberOfItems property once, after all the work is<br />
complete. For asynchronous methods, raise the PropertyChanged event for a given property<br />
name in each synchronous segment of an asynchronous continuation chain.</p>
</li>
</ul>
<p>A simple way to provide this functionality would be to create an extension of the BindableObject class.<br />
In this example, the ExtendedBindableObject class provides change notifications, which is shown in<br />
the following code example:</p>
<p>.NET MAUI’s BindableObject class implements the INotifyPropertyChanged interface, and provides an<br />
OnPropertyChanged method. The ExtendedBindableObject class provides the RaisePropertyChanged<br />
method to invoke property change notification, and in doing so uses the functionality provided by the<br />
BindableObject class.</p>
<p>View model classes can then derive from the ExtendedBindableObject class. Therefore, each view<br />
model class uses the RaisePropertyChanged method in the ExtendedBindableObject class to provide<br />
property change notification. The following code example shows how the eShop multi-platform app<br />
invokes property change notification by using a lambda expression:</p>
<p>14 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p>Using a lambda expression in this way involves a small performance cost because the lambda<br />
expression has to be evaluated for each call. Although the performance cost is small and would not<br />
typically impact an app, the costs can accrue when there are many change notifications. However, the<br />
benefit of this approach is that it provides compile-time type safety and refactoring support when<br />
renaming properties.</p>
<h3>MVVM Frameworks</h3>
<p>The MVVM pattern is well established in .NET, and the community has created many frameworks<br />
which help ease this development. Each framework provides a different set of features, but it is<br />
standard for them to provide a common view model with an implementation of the<br />
INotifyPropertyChanged interface. Additional features of MVVM frameworks include custom<br />
commands, navigation helpers, dependency injection/service locator components, and UI platform<br />
integration. While it is not necessary to use these frameworks, they can speed up and standardize<br />
<a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/introduction">your development. The eShop multi-platform app uses the .NET Community MVVM Toolkit. When</a><br />
choosing a framework, you should consider your application’s needs and your team’s strengths. The<br />
list below includes some of the more common MVVM frameworks for .NET MAUI.</p>
<ul>
<li>
<p><a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/introduction/">.NET Community MVVM Toolkit</a></p>
</li>
<li>
<p><a href="https://www.reactiveui.net/">ReactiveUI</a></p>
</li>
<li>
<p><a href="https://prismlibrary.com/">Prism Library</a></p>
</li>
</ul>
<h3>UI interaction using commands and behaviors</h3>
<p>In multi-platform apps, actions are typically invoked in response to a user action, such as a button<br />
click, that can be implemented by creating an event handler in the code-behind file. However, in the<br />
MVVM pattern, the responsibility for implementing the action lies with the view model, and placing<br />
code in the code-behind should be avoided.</p>
<p>Commands provide a convenient way to represent actions that can be bound to controls in the UI.<br />
They encapsulate the code that implements the action and help to keep it decoupled from its visual<br />
representation in the view. This way, your view models become more portable to new platforms, as<br />
they do not have a direct dependency on events provided by the platform’s UI framework. .NET MAUI<br />
includes controls that can be declaratively connected to a command, and these controls will invoke<br />
the command when the user interacts with the control.</p>
<p>Behaviors also allow controls to be declaratively connected to a command. However, behaviors can be<br />
used to invoke an action that’s associated with a range of events raised by a control. Therefore,<br />
behaviors address many of the same scenarios as command-enabled controls, while providing a<br />
greater degree of flexibility and control. In addition, behaviors can also be used to associate command<br />
objects or methods with controls that were not specifically designed to interact with commands.</p>
<p>15 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<h3>Implementing commands</h3>
<p>View models typically expose public properties, for binding from the view, which implement the<br />
ICommand interface. Many .NET MAUI controls and gestures provide a Command property, which can<br />
be data bound to an ICommand object provided by the view model. The button control is one of the<br />
most commonly used controls, providing a command property that executes when the button is<br />
clicked.</p>
<p>The ICommand interface defines an Execute method, which encapsulates the operation itself, a<br />
CanExecute method, which indicates whether the command can be invoked, and a<br />
CanExecuteChanged event that occurs when changes occur that affect whether the command should<br />
execute. In most cases, we will only supply the Execute method for our commands. For a more<br />
<a href="https://docs.microsoft.com/dotnet/maui/fundamentals/data-binding/commanding">detailed overview of ICommand, refer to the Commanding</a> documentation for .NET MAUI.</p>
<p>Provided with .NET MAUI are the Command and Command<T> classes that implement the<br />
ICommand interface, where T is the type of the arguments to Execute and CanExecute. Command and<br />
Command<T> are basic implementations that provide the minimal set of functionality needed for the<br />
ICommand interface.</p>
<p>The Command or Command<T> constructor requires an Action callback object that’s called when the<br />
ICommand.Execute method is invoked. The CanExecute method is an optional constructor parameter,<br />
and is a Func that returns a bool.</p>
<p><a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/relaycommand">The eShop multi-platform app uses the RelayCommand</a> <a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/asyncrelaycommand">and AsyncRelayCommand. The primary</a><br />
benefit for modern applications is that the AsyncRelayCommand provides better functionality for<br />
asynchronous operations.</p>
<p>The following code shows how a Command instance, which represents a register command, is<br />
constructed by specifying a delegate to the Register view model method:</p>
<pre><code>public ICommand RegisterCommand { get ; }

</code></pre>
<p>The command is exposed to the view through a property that returns a reference to an ICommand.<br />
When the Execute method is called on the Command object, it simply forwards the call to the method<br />
in the view model via the delegate that was specified in the Command constructor. An asynchronous<br />
method can be invoked by a command by using the async and await keywords when specifying the<br />
command’s Execute delegate. This indicates that the callback is a Task and should be awaited. For</p>
<p>16 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p>example, the following code shows how an ICommand instance, which represents a sign-in command,<br />
is constructed by specifying a delegate to the SignInAsync view model method:</p>
<p>Parameters can be passed to the Execute and CanExecute actions by using the<br />
AsyncRelayCommand<T> class to instantiate the command. For example, the following code shows<br />
how an AsyncRelayCommand<T> instance is used to indicate that the NavigateAsync method will<br />
require an argument of type string:</p>
<p>In both the RelayCommand and RelayCommand<T> classes, the delegate to the CanExecute method<br />
in each constructor is optional. If a delegate isn’t specified, the Command will return true for<br />
CanExecute. However, the view model can indicate a change in the command’s CanExecute status by<br />
calling the ChangeCanExecute method on the Command object. This causes the CanExecuteChanged<br />
event to be raised. Any UI controls bound to the command will then update their enabled status to<br />
reflect the availability of the data-bound command.</p>
<h3>Invoking commands from a view</h3>
<p>The following code example shows how a Grid in the LoginView binds to the RegisterCommand in the<br />
LoginViewModel class by using a TapGestureRecognizer instance:</p>
<p>A command parameter can also be optionally defined using the CommandParameter property. The<br />
type of the expected argument is specified in the Execute and CanExecute target methods. The<br />
TapGestureRecognizer will automatically invoke the target command when the user interacts with the<br />
attached control. The CommandParameter, if provided, will be passed as the argument to the<br />
command’s Execute delegate.</p>
<h3>Implementing behaviors</h3>
<p>Behaviors allow functionality to be added to UI controls without having to subclass them. Instead, the<br />
functionality is implemented in a behavior class and attached to the control as if it was part of the<br />
control itself. Behaviors enable you to implement code that you would typically have to write as codebehind, because it directly interacts with the API of the control, in such a way that it can be concisely</p>
<p>17 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p>attached to the control, and packaged for reuse across more than one view or app. In the context of<br />
MVVM, behaviors are a useful approach for connecting controls to commands.</p>
<p>A behavior that’s attached to a control through attached properties is known as an <em>attached behavior</em> .<br />
The behavior can then use the exposed API of the element to which it is attached to add functionality<br />
to that control, or other controls, in the visual tree of the view.</p>
<p>A .NET MAUI behavior is a class that derives from the Behavior or Behavior<T> class, where T is the<br />
type of the control to which the behavior should apply. These classes provide OnAttachedTo and<br />
OnDetachingFrom methods, which should be overridden to provide logic that will be executed when<br />
the behavior is attached to and detached from controls.</p>
<p>In the eShop multi-platform app, the BindableBehavior<T> class derives from the Behavior<T> class.<br />
The purpose of the BindableBehavior<T> class is to provide a base class for .NET MAUI behaviors that<br />
require the BindingContext of the behavior to be set to the attached control.</p>
<p>The BindableBehavior<T> class provides an overridable OnAttachedTo method that sets the<br />
BindingContext of the behavior, and an overridable OnDetachingFrom method that cleans up the<br />
BindingContext.</p>
<p><a href="https://docs.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior">The eShop multi-platform app includes an EventToCommandBehavior</a> class which is provided by the<br />
MAUI Community toolkit. EventToCommandBehavior executes a command in response to an event<br />
occurring. This class derives from the BaseBehavior<View> class so that the behavior can bind to and<br />
execute an ICommand specified by a Command property when the behavior is consumed. The<br />
following code example shows the EventToCommandBehavior class:</p>
<p>18 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p>The OnAttachedTo and OnDetachingFrom methods are used to register and deregister an event<br />
handler for the event defined in the EventName property. Then, when the event fires, the<br />
OnTriggerHandled method is invoked, which executes the command.</p>
<p>19 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p>The advantage of using the EventToCommandBehavior to execute a command when an event fires, is<br />
that commands can be associated with controls that weren’t designed to interact with commands. In<br />
addition, this moves event-handling code to view models, where it can be unit tested.</p>
<h3>Invoking behaviors from a view</h3>
<p>The EventToCommandBehavior is particularly useful for attaching a command to a control that<br />
doesn’t support commands. For example, the LoginView uses the EventToCommandBehavior to<br />
execute the ValidateCommand when the user changes the value of their password, as shown in the<br />
following code:</p>
<p>At runtime, the EventToCommandBehavior will respond to interaction with the Entry. When a user<br />
types into the Entry field, the TextChanged event will fire, which will execute the ValidateCommand in<br />
the LoginViewModel. By default, the event arguments for the event are passed to the command. If<br />
needed, the EventArgsConverter property can be used to convert the EventArgs provided by the event<br />
into a value that the command expects as input.</p>
<p><a href="https://docs.microsoft.com/dotnet/maui/fundamentals/behaviors">For more information about behaviors, see Behaviors</a> on the .NET MAUI Developer Center.</p>
<h3>Summary</h3>
<p>The Model-View-ViewModel (MVVM) pattern helps cleanly separate an application’s business and<br />
presentation logic from its user interface (UI). Maintaining a clean separation between application<br />
logic and the UI helps address numerous development issues and makes an application easier to test,<br />
maintain, and evolve. It can also significantly improve code re-use opportunities and allows<br />
developers and UI designers to collaborate more easily when developing their respective parts of an<br />
app.</p>
<p>Using the MVVM pattern, the UI of the app and the underlying presentation and business logic are<br />
separated into three separate classes: the view, which encapsulates the UI and UI logic; the view<br />
model, which encapsulates presentation logic and state; and the model, which encapsulates the app’s<br />
business logic and data.</p>
<p>20 CHAPTER 3 | Model-View-ViewModel (MVVM)</p>
<p><strong>CHAPTER</strong></p>
<h1>4</h1>
<h2>Dependency injection</h2>
<p>Typically, a class constructor is invoked when instantiating an object, and any values that the object<br />
needs are passed as arguments to the constructor. This is an example of dependency injection known<br />
as <em>constructor injection</em> . The dependencies the object needs are injected into the constructor.</p>
<p>By specifying dependencies as interface types, dependency injection enables decoupling the concrete<br />
types from the code that depends on these types. It generally uses a container that holds a list of<br />
registrations and mappings between interfaces and abstract types, and the concrete types that<br />
implement or extend these types.</p>
<p>There are also other types of dependency injection, such as <em>property setter injection</em> and <em>method call</em><br />
<em>injection</em>, but they are less commonly seen. Therefore, this chapter will focus solely on performing<br />
constructor injection with a dependency injection container.</p>
<h3>Introduction to dependency injection</h3>
<p>Dependency injection is a specialized version of the Inversion of Control (IoC) pattern, where the<br />
concern being inverted is the process of obtaining the required dependency. With dependency<br />
injection, another class is responsible for injecting dependencies into an object at runtime. The<br />
following code example shows how the ProfileViewModel class is structured when using dependency<br />
injection:</p>
<p>The ProfileViewModel constructor receives multiple interface object instances as arguments injected<br />
by another class. The only dependency in the ProfileViewModel class is on the interface types.<br />
Therefore, the ProfileViewModel class doesn’t have any knowledge of the class that’s responsible for<br />
instantiating the interface objects. The class that’s responsible for instantiating the interface objects,<br />
and inserting it into the ProfileViewModel class, is known as the <em>dependency injection container</em> .</p>
<p>21 CHAPTER 4 | Dependency injection</p>
<p>Dependency injection containers reduce the coupling between objects by providing a facility to<br />
instantiate class instances and manage their lifetime based on the configuration of the container.<br />
During object creation, the container injects any dependencies that the object requires into it. If those<br />
dependencies have not yet been created, the container creates and resolves their dependencies first.</p>
<p>There are several advantages to using a dependency injection container:</p>
<ul>
<li>
<p>A container removes the need for a class to locate its dependencies and manage its lifetimes.</p>
</li>
<li>
<p>A container allows the mapping of implemented dependencies without affecting the class.</p>
</li>
<li>
<p>A container facilitates testability by allowing dependencies to be mocked.</p>
</li>
<li>
<p>A container increases maintainability by allowing new classes to be easily added to the app.</p>
</li>
</ul>
<p>In the context of a .NET MAUI app that uses MVVM, a dependency injection container will typically be<br />
used for registering and resolving views, registering and resolving view models, and for registering<br />
services and injecting them into view models.</p>
<p>There are many dependency injection containers available in .NET; the eShop multi-platform app uses<br />
Microsoft.Extensions.DependencyInjection to manage the instantiation of views, view models, and<br />
service classes in the app. Microsoft.Extensions.DependencyInjection facilitates building loosely<br />
coupled apps, and provides all of the features commonly found in dependency injection containers,<br />
including methods to register type mappings and object instances, resolve objects, manage object<br />
lifetimes, and inject dependent objects into constructors of objects that it resolves. For more<br />
<a href="https://docs.microsoft.com/dotnet/core/extensions/dependency-injection">information about Microsoft.Extensions.DependencyInjection, see Dependency injection in .NET.</a></p>
<p>In .NET MAUI, the MauiProgram class will call into the CreateMauiApp method to create a<br />
MauiAppBuilder object. The MauiAppBuilder object has a Services property of type IServiceCollection,<br />
which provides a place to register our components, such as views, view models, and services for<br />
dependency injection. Any components registered with the Services property will be provided to the<br />
dependency injection container when the MauiAppBuilder.Build method is called.</p>
<p>At runtime, the container must know which implementation of the services are being requested in<br />
order to instantiate them for the requested objects. In the eShop multi-platform app, the<br />
IAppEnvironmentService, IDialogService, INavigationService, and ISettingsService interfaces need to<br />
be resolved before it can instantiate a ProfileViewModel object. This involves the container performing<br />
the following actions:</p>
<ul>
<li>
<p>Deciding how to instantiate an object that implements the interface. This is known as<br />
<em>registration</em> .</p>
</li>
<li>
<p>Instantiating the object that implements the required interface and the ProfileViewModel<br />
object. This is known as <em>resolution</em> .</p>
</li>
</ul>
<p>Eventually, the app will finish using the ProfileViewModel object, and it will become available for<br />
garbage collection. At this point, the garbage collector should dispose of any short-lived interface<br />
implementations if other classes do not share the same instance.</p>
<p>22 CHAPTER 4 | Dependency injection</p>
<h3>Registration</h3>
<p>Before dependencies can be injected into an object, the types of the dependencies must first be<br />
registered with the container. Registering a type involves passing the container an interface and a<br />
concrete type that implements the interface.</p>
<p>There are two ways of registering types and objects in the container through code:</p>
<ul>
<li>
<p>Register a type or mapping with the container. This is known as transient registration. When<br />
required, the container will build an instance of the specified type.</p>
</li>
<li>
<p>Register an existing object in the container as a singleton. When required, the container will<br />
return a reference to the existing object.</p>
</li>
</ul>
<p>The registration of types requiring dependency injection should be performed in a single method in<br />
an app. This method should be invoked early in the app’s lifecycle to ensure it is aware of the<br />
dependencies between its classes. The eShop multi-platform app performs this the<br />
MauiProgram.CreateMauiApp method. The following code example shows how the eShop multiplatform app declares the CreateMauiApp in the MauiProgram class:</p>
<p>The MauiApp.CreateBuilder method creates a MauiAppBuilder object that we can use to register our<br />
dependencies. Many dependencies in the eShop multi-platform app need to be registered, so the<br />
extension methods RegisterAppServices, RegisterViewModels, and RegisterViews were created to help<br />
provide an organized and maintainable registration workflow. The following code shows the<br />
RegisterViewModels method:</p>
<p>23 CHAPTER 4 | Dependency injection</p>
<p>This method receives an instance of MauiAppBuilder, and we can use the Services property to register<br />
our view models. Depending on the needs of your application, you may need to add services with<br />
different lifetimes. The following table provides information on when you may want to choose these</p>
<table>
<thead>
<tr>
<th>different registration lifetimes:</th>
<th>Col2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>AddSingleton<T></td>
<td>Will create a single instance of the object which<br>will be remain for the lifetime of the application.</td>
</tr>
<tr>
<td>AddTransient<T></td>
<td>Will create a new instance of the object when<br>requested during resolution. Transient objects<br>do not have a pre-defined lifetime, but will<br>typically follow the lifetime of their host.</td>
</tr>
</tbody>
</table>
<p>The CatalogViewModel is used near the application’s root and should always be available, so<br />
registering it with AddSingleton<T> is beneficial. Other view models, such as CheckoutViewModel<br />
and OrderDetailViewModel are situationally navigated to or are used later in the application. Suppose<br />
you know that you have a component that may not always be used. In that case, if it is memory or<br />
computationally intensive or requires just-in-time data, it may be a better candidate for<br />
AddTransient<T> registration.</p>
<p>Another common way to add services is using the AddSingleton&lt;TService, TImplementation&gt; and<br />
AddTransient&lt;TService, TImplementation&gt; methods. These methods take two input types: the<br />
interface definition and the concrete implementation. This type of registration is best for cases where<br />
you are implementing services based on interfaces. In the code example below, we register our<br />
ISettingsService interface using the SettingsService implementation:</p>
<p>Once all services have been registered, the MauiAppBuilder.Build method should be called to create<br />
our MauiApp and populate our dependency injection container with all the registered services.</p>
<p>24 CHAPTER 4 | Dependency injection</p>
<h3>Resolution</h3>
<p>After a type is registered, it can be resolved or injected as a dependency. When a type is being<br />
resolved, and the container needs to create a new instance, it injects any dependencies into the<br />
instance.</p>
<p>Generally, when a type is resolved, one of three things happens:</p>
<ol>
<li>
<p>If the type hasn’t been registered, the container throws an exception.</p>
</li>
<li>
<p>If the type has been registered as a singleton, the container returns the singleton instance. If<br />
this is the first time the type is called for, the container creates it if required and maintains a<br />
reference to it.</p>
</li>
<li>
<p>If the type has been registered as transient, the container returns a new instance and doesn’t<br />
maintain a reference to it.</p>
</li>
</ol>
<p>.NET MAUI offers a number of ways to resolve registered components based on your needs. The most<br />
direct way to gain access to the dependency injection container is from an Element using the<br />
Handler.MauiContext.Services. An example of this is shown below:</p>
<pre><code>var settingsService = this .Handler.MauiContext.Services.GetServices&lt;ISettingsService&gt;();

</code></pre>
<p>This can be helpful if you need to resolve a service from within an Element or from outside of the<br />
constructor of your Element.</p>
<p>If using the Shell control for .NET MAUI, it will implicitly call into the dependency injection container<br />
to create our objects during navigation. When setting up our Shell control, the Routing.RegisterRoute<br />
method will tie a route path to a View as shown in the example below:</p>
<pre><code>Routing.RegisterRoute(&quot;Filter&quot;, typeof (FiltersView));

</code></pre>
<p>During Shell navigation, it will look for registrations of the FiltersView, and if any are found, it will<br />
create that view and inject any dependencies into the constructor. As shown in the code example<br />
below, the CatalogViewModel will be injected into the FiltersView:</p>
<p>25 CHAPTER 4 | Dependency injection</p>
<h3>Summary</h3>
<p>Dependency injection enables the decoupling of concrete types from the code that depends on these<br />
types. It typically uses a container that holds a list of registrations and mappings between interfaces<br />
and abstract types, and the concrete types that implement or extend these types.</p>
<p>Microsoft.Extensions.DependencyInjection facilitates building loosely coupled apps and provides all of<br />
the features commonly found in dependency injection containers, including methods to register type<br />
mappings and object instances, resolve objects, manage object lifetimes, and inject dependent objects<br />
into constructors of objects it resolves.</p>
<p>26 CHAPTER 4 | Dependency injection</p>
<p><strong>CHAPTER</strong></p>
<h1>5</h1>
<h2>Communicating between loosely coupled components</h2>
<p>The publish-subscribe pattern is a messaging pattern in which publishers send messages without<br />
knowing any receivers, known as subscribers. Similarly, subscribers listen for specific messages,<br />
without knowing any publishers.</p>
<p>Events in .NET implement the publish-subscribe pattern and are the most simple approach for a<br />
communication layer between components if loose coupling is not required, such as a control and the<br />
page that contains it. However, the publisher and subscriber lifetimes are coupled by object<br />
references to each other, and the subscriber type must have a reference to the publisher type. This<br />
can create memory management issues, especially when there are short-lived objects that subscribe<br />
to an event of a static or long-lived object. If the event handler isn’t removed, the subscriber will be<br />
kept alive by the reference to it in the publisher, and this will prevent or delay the garbage collection<br />
of the subscriber.</p>
<h3>Introduction to MVVM Toolkit Messenger</h3>
<p>The MVVM Toolkit IMessenger interface describes the publish-subscribe pattern, allowing messagebased communication between components that are inconvenient to link by object and type<br />
references. This mechanism allows publishers and subscribers to communicate without having a direct<br />
reference to each other, helping to reduce dependencies between components, while also allowing<br />
components to be independently developed and tested.</p>
<p>27 CHAPTER 5 | Communicating between loosely coupled components</p>
<p>The IMessenger interface allows for multicast publish-subscribe functionality. This means that there<br />
can be multiple publishers that publish a single message, and there can be multiple subscribers<br />
listening to the same message. The image below illustrates this relationship:</p>
<p>There are two implementations of the IMessenger interface that come with the<br />
CommunityToolkit.Mvvm package. The WeakReferenceMessenger uses weak references which can<br />
result in easier cleanup for message subscribers. This is a good option if your subscribers do not have<br />
a clearly defined lifecycle. The StrongReferenceMessenger uses strong references which can result in<br />
better performance and a more clearly controlled lifetime of the subscription. If you have a workflow<br />
with a very controlled lifetime (for example, a subscription that is bound to a page’s OnAppearing and<br />
OnDisappearing methods), the StrongReferenceManager may be a better option, if performance is a<br />
concern. Both of these implementations are available with default implementations ready to use by<br />
referencing either WeakReferenceMessenger.Default or StrongReferenceMessenger.Default.</p>
<p>The eShop multi-platform app uses the WeakReferenceMessenger class to communicate between<br />
loosely coupled components. The app defines a single message named AddProductMessage. The<br />
AddProductMessage is published by the CatalogViewModel class when an item is added to the<br />
shopping basket. In return, the CatalogView class subscribes to the message and uses this to highlight<br />
the product adds with animation in response.</p>
<p>In the eShop multi-platform app, WeakReferenceMessenger is used to update the UI in response to<br />
an action occurring in another class. Therefore, messages are published from the thread that the class<br />
is executing on, with subscribers receiving the message on the same thread.</p>
<p>28 CHAPTER 5 | Communicating between loosely coupled components</p>
<p>If a message that’s sent from a background thread is required to update the UI, process the message<br />
on the UI thread in the subscriber by invoking the MainThread.BeginInvokeOnMainThread method.</p>
<p><a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/messenger">For more information about Messenger, see Messenger</a> on the Microsoft Developer Center.</p>
<h3>Defining a message</h3>
<p>IMessenger messages are custom objects that provide custom payloads. The following code example<br />
shows the AddProductMessage message defined within the eShop multi-platform app:</p>
<p>The base class is defined using ValueChangedMessage<T> where T can be of any type needed to<br />
pass data. Both message publishers and subscribers can expect messages of a specific type (for<br />
example, AddProductMessage). This can help ensure that both parties have agreed to a messaging<br />
contract and that the data provided with that contract will be consistent. Additionally, this approach<br />
provides compile-time type safety and refactoring support.</p>
<h3>Publishing a message</h3>
<p>To publish a message, we will need to use the IMessenger.Send method. This can be accessed most<br />
commonly through WeakReferenceMessenger.Default.Send or<br />
StrongReferenceMessenger.Default.Send. The message sent can be of any object type. The following<br />
code example demonstrates publishing the AddProduct message:</p>
<pre><code>WeakReferenceMessenger.Default.Send( new Messages.AddProductMessage(BadgeCount));

</code></pre>
<p>In this example, the Send method specifies provides a new instance of the AddProductMessage object<br />
for downstream subscribers to receive. An additional second token parameter can be added to use<br />
when multiple different subscribers need to receive messages of the same type without receiving the<br />
wrong message.</p>
<p>The Send method will publish the message, and its payload data, using a fire-and-forget approach.<br />
Therefore, the message is sent even if there are no subscribers registered to receive the message. In<br />
this situation, the sent message is ignored.</p>
<p>29 CHAPTER 5 | Communicating between loosely coupled components</p>
<h3>Subscribing to a message</h3>
<p>Subscribers can register to receive a message using one of the IMessenger.Register<T> overloads.<br />
The following code example demonstrates how the eShop multi-platform app subscribes to, and<br />
processes, the AddProductMessage message:</p>
<p>In the preceding example, the Register method subscribes to the AddProductMessage message and<br />
executes a callback delegate in response to receiving the message. This callback delegate, specified as<br />
a lambda expression, executes code that updates the UI.</p>
<p>If payload data is supplied, don’t attempt to modify the payload data from within a callback delegate<br />
because several threads could be accessing the received data simultaneously. In this scenario, the<br />
payload data should be immutable to avoid concurrency errors.</p>
<h3>Unsubscribing from a message</h3>
<p>Subscribers can unsubscribe from messages they no longer want to receive. This is achieved with one<br />
of the IMessenger.Unregister overloads, as demonstrated in the following code example:</p>
<pre><code>WeakReferenceMessenger.Default.Unregister&lt;Messages.AddProductMessage&gt;( this );

</code></pre>
<p>In this example, the Unsubscribe method syntax specifies the type argument of the message and the<br />
recipient object that is listening for messages.</p>
<p>30 CHAPTER 5 | Communicating between loosely coupled components</p>
<h3>Summary</h3>
<p>The MVVM Toolkit IMessenger interface describes the publish-subscribe pattern, allowing messagebased communication between components that are inconvenient to link by object and type<br />
references. This mechanism allows publishers and subscribers to communicate without having a<br />
reference to each other, helping to reduce dependencies between components, while also allowing<br />
components to be independently developed and tested.</p>
<p>31 CHAPTER 5 | Communicating between loosely coupled components</p>
<p><strong>CHAPTER</strong></p>
<h1>6</h1>
<h2>Navigation</h2>
<p>.NET MAUI includes support for page navigation, which typically results from the user’s interaction<br />
with the UI or from the app itself as a result of internal logic-driven state changes. However,<br />
navigation can be complex to implement in apps that use the Model-View-ViewModel (MVVM)<br />
pattern, as the following challenges must be met:</p>
<ul>
<li>
<p>Identifying the view to be navigated to using an approach that does not introduce tight<br />
coupling and dependencies between views.</p>
</li>
<li>
<p>Coordinating the process by which the view to be navigated to is instantiated and initialized.<br />
When using MVVM, the view and view-model need to be instantiated and associated with<br />
each other via the view’s binding context. When an app is using a dependency injection<br />
container, the instantiation of views and view-models might require a specific construction<br />
mechanism.</p>
</li>
<li>
<p>Whether to perform view-first navigation, or view-model-first navigation. With view-first<br />
navigation, the page to navigate to refers to the name of the view type. During navigation,<br />
the specified view is instantiated, along with its corresponding view-model and other<br />
dependent services. An alternative approach is to use view-model-first navigation, where the<br />
page to navigate to refers to the name of the view-model type.</p>
</li>
<li>
<p>Determining how to cleanly separate the navigational behavior of the app across the views<br />
and view-models. The MVVM pattern separates the app’s UI and its presentation and business<br />
logic, but it doesn’t provide a direct mechanism for tying them together. However, the<br />
navigation behavior of an app will often span the UI and presentation parts of the app. The<br />
user will often initiate navigation from a view, and the view will be replaced as a result of the<br />
navigation. However, navigation might often also need to be initiated or coordinated from<br />
within the view-model.</p>
</li>
<li>
<p>Determining how to pass parameters during navigation for initialization purposes. For<br />
example, if the user navigates to a view to update order details, the order data will have to be<br />
passed to the view so that it can display the correct data.</p>
</li>
<li>
<p>Coordinating navigation to ensure that specific business rules are obeyed. For example, users<br />
might be prompted before navigating away from a view so that they can correct any invalid<br />
data or be prompted to submit or discard any data changes that were made within the view.</p>
</li>
</ul>
<p>This chapter addresses these challenges by presenting a navigation service class named<br />
MauiNavigationService that’s used to perform view-model-first page navigation.</p>
<p>32 CHAPTER 6 | Navigation</p>
<h3>Navigating between pages</h3>
<p>Navigation logic can reside in a view’s code-behind or a data-bound view-model. While placing<br />
navigation logic in a view might be the most straightforward approach, it is not easily testable<br />
through unit tests. Putting navigation logic in view-model classes means that the logic can be verified<br />
through unit tests. In addition, the view-model can then implement logic to control navigation to<br />
ensure that certain business rules are enforced. For example, an app might not allow the user to<br />
navigate away from a page without first ensuring that the entered data is valid.</p>
<p>A navigation service is typically invoked from view-models, in order to promote testability. However,<br />
navigating to views from view-models would require the view-models to reference views, and<br />
particularly views that the active view-model isn’t associated with, which is not recommended.<br />
Therefore, the MauiNavigationService presented here specifies the view-model type as the target to<br />
navigate to.</p>
<p>The eShop multi-platform app uses the MauiNavigationService class to provide view-model-first<br />
navigation. This class implements the INavigationService interface, which is shown in the following<br />
code example:</p>
<p>This interface specifies that an implementing class must provide the following methods:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>InitializeAsync</td>
<td>Performs navigation to one of two pages when<br>the app is launched.</td>
</tr>
<tr>
<td>NavigateToAsync(string route,<br>IDictionary&lt;string, object&gt; routeParameters =<br>null)</td>
<td>Performs hierarchical navigation to a specified<br>page using a registered navigation route. Can<br>optionally pass named route parameters to use<br>for processing on the destination page</td>
</tr>
<tr>
<td>PopAsync</td>
<td>Removes the current page from the navigation<br>stack.</td>
</tr>
</tbody>
</table>
<p>33 CHAPTER 6 | Navigation</p>
<h3>Creating the MauiNavigationService instance</h3>
<p>The MauiNavigationService class, which implements the INavigationService interface, is registered as a<br />
singleton with the dependency injection container in the MauiProgram.CreateMauiApp() method, as<br />
demonstrated in the following code example:</p>
<pre><code>mauiAppBuilder.Services.AddSingleton&lt;INavigationService, MauiNavigationService&gt;();;

</code></pre>
<p>The INavigationService interface can then be resolved by adding it to the constructor of our views and<br />
view-models, as demonstrated in the following code example:</p>
<pre><code>public AppShell(INavigationService navigationService)

</code></pre>
<p>This returns a reference to the MauiNavigationService object that’s stored in the dependency injection<br />
container.</p>
<p>The ViewModelBase class stores the MauiNavigationService instance in a NavigationService property,<br />
of type INavigationService. Therefore, all view-model classes, which derive from the ViewModelBase<br />
class, can use the NavigationService property to access the methods specified by the<br />
INavigationService interface.</p>
<h3>Handling navigation requests</h3>
<p>.NET MAUI provides multiple ways to navigate within an application. The traditional way to navigate is<br />
with the NavigationPage class, which implements a hierarchical navigation experience in which the<br />
user can navigate through pages, forward and backward, as desired. The eShop app uses the Shell<br />
component as the root container for the application and as a navigation host. For more information<br />
<a href="https://docs.microsoft.com/dotnet/maui/fundamentals/shell/navigation">about Shell navigation, see Shell Navigation</a> on the Microsoft Developer Center.</p>
<p>Navigation is performed inside view-model classes by invoking one of the NavigateToAsync methods,<br />
specifying the route path for the page being navigated to, as demonstrated in the following code<br />
example:</p>
<pre><code>await NavigationService.NavigateToAsync(&quot;//Main&quot;);

</code></pre>
<p>The following code example shows the NavigateToAsync method provided by the<br />
MauiNavigationService class:</p>
<p>The .NET MAUI Shell control is already familiar with route-based navigation, so the NavigateToAsync<br />
method works to mask this functionality. The NavigateToAsync method allows navigation data to be</p>
<p>34 CHAPTER 6 | Navigation</p>
<p>specified as an argument that’s passed to the view-model being navigated to, where it’s typically used<br />
to perform initialization. For more information, see Passing parameters during navigation.</p>
<p>In order to register routes for the MauiNavigationService we need to supply route information from<br />
XAML or in the code-behind. The following example shows registration of routes via XAML.</p>
<p>In this example, the ShellContent and TabBar user interface objects are setting their Route property.<br />
This is the preferred method of registering routes for user interface objects that are controlled by a<br />
Shell.</p>
<p>If we have objects that will be added to the navigation stack at a later time, then we will need to add<br />
those via code-behind. The following example show registration of routes in code-behind.</p>
<p>In code-behind, we will call the Routing.RegisterRoute method which takes a route name as the first<br />
parameter and a view type as the second parameter. When a view-model uses the NavigationService<br />
property to navigate, the application’s Shell object will look for registered routes and push them onto<br />
the navigation stack.</p>
<p>After the view is created and navigated to, the ApplyQueryAttributes and InitializeAsync methods of<br />
the view’s associated view-model are executed. For more information, see Passing parameters during<br />
navigation.</p>
<p>35 CHAPTER 6 | Navigation</p>
<h3>Navigating when the app is launched</h3>
<p>When the app is launched, a Shell object is set as the root view of the application. Once set, the Shell<br />
will be used to control route registration and will be present at the root of our application going<br />
forward. Once the Shell has been created, we can wait for it to be attached to the application using<br />
the OnParentSet method to initialize our navigation route. The following code example shows this<br />
method:</p>
<p>The method uses an instance of INavigationService which is provided the constructor from<br />
dependency injection and invokes its InitializeAsync method.</p>
<p>The following code example shows the implementation of the MauiNavigationService.InitializeAsync<br />
method:</p>
<p>The //Main/Catalog route is navigated to if the app has a cached access token, which is used for<br />
authentication. Otherwise, the //Login route is navigated to.</p>
<h3>Passing parameters during navigation</h3>
<p>The NavigateToAsync method, specified by the INavigationService interface, enables navigation data<br />
to be specified as an IDictionary&lt;string, object&gt; of data that’s passed to the view-model being<br />
navigated to, where it’s typically used to perform initialization.</p>
<p>For example, the ProfileViewModel class contains an OrderDetailCommand that’s executed when the<br />
user selects an order on the ProfileView page. In turn, this executes the OrderDetailAsync method,<br />
which is shown in the following code example:</p>
<p>36 CHAPTER 6 | Navigation</p>
<p>This method invokes navigation to the OrderDetail route, passing order number information the order<br />
that the user selected. When the dependency injection framework creates the OrderDetailView for the<br />
OrderDetail route along with the OrderDetailViewModel class which is assigned to the view’s<br />
BindingContext. The OrderDetailViewModel has an attribute added to it that allows it to receive data<br />
from the navigation service as shown in the code example below.</p>
<p>The QueryProperty attribute allows us to provide a parameter for a property to map values to and a<br />
key to find values from the query parameters dictionary. In this example, the key “OrderNumber” and<br />
order number value were provided during the NavigateToAsync call. The view-model found the<br />
“OrderNumber” key and mapped the value to the OrderNumber property. The OrderNumber property<br />
can then be used at a later time to retrieve the full order details from the OrderService instance.</p>
<h3>Invoking navigation using behaviors</h3>
<p>Navigation is usually triggered from a view by a user interaction. For example, the LoginView performs<br />
navigation following successful authentication. The following code example shows how the navigation<br />
is invoked by a behavior:</p>
<p>At runtime, the EventToCommandBehavior will respond to interaction with the WebView. When the<br />
WebView navigates to a web page, the Navigating event will fire, which will execute the<br />
NavigateCommand in the LoginViewModel. By default, the event arguments for the event are passed<br />
to the command. This data is converted as it’s passed between source and target by the converter<br />
specified in the EventArgsConverter property, which returns the Url from the<br />
WebNavigatingEventArgs. Therefore, when the NavigationCommand is executed, the Url of the web<br />
page is passed as a parameter to the registered Action.</p>
<p>In turn, the NavigationCommand executes the NavigateAsync method, which is shown in the<br />
following code example:</p>
<p>37 CHAPTER 6 | Navigation</p>
<p>This method invokes NavigationService route the application to the //Main/Catalog route.</p>
<h3>Confirming or cancelling navigation</h3>
<p>An app might need to interact with the user during a navigation operation, so that the user can<br />
confirm or cancel navigation. This might be necessary, for example, when the user attempts to<br />
navigate before having fully completed a data entry page. In this situation, an app should provide a<br />
notification that allows the user to navigate away from the page, or to cancel the navigation operation<br />
before it occurs. This can be achieved in a view-model class by using the response from a notification<br />
to control whether or not navigation is invoked.</p>
<h3>Summary</h3>
<p>.NET MAUI includes support for page navigation, which typically results from the user’s interaction<br />
with the UI, or from the app itself, as a result of internal logic-driven state changes. However,<br />
navigation can be complex to implement in apps that use the MVVM pattern.</p>
<p>This chapter presented a NavigationService class, which is used to perform view-model-first<br />
navigation from view-models. Placing navigation logic in view-model classes means that the logic can<br />
be exercised through automated tests. In addition, the view-model can then implement logic to<br />
control navigation to ensure that certain business rules are enforced.</p>
<p>38 CHAPTER 6 | Navigation</p>
<p><strong>CHAPTER</strong></p>
<h1>7</h1>
<h2>Validation</h2>
<p>Any app that accepts input from users should ensure that the input is valid. An app could, for<br />
example, check for input that contains only characters in a particular range, is of a certain length, or<br />
matches a particular format. Without validation, a user can supply data that causes the app to fail.<br />
Proper validation enforces business rules and could help to prevent an attacker from injecting<br />
malicious data.</p>
<p>In the context of the Model-View-ViewModel (MVVM) pattern, a view model or model will often be<br />
required to perform data validation and signal any validation errors to the view so that the user can<br />
correct them. The eShop multi-platform app performs synchronous client-side validation of view<br />
model properties and notifies the user of any validation errors by highlighting the control that<br />
contains the invalid data, and by displaying error messages that inform the user of why the data is<br />
invalid. The image below shows the classes involved in performing validation in the eShop multiplatform app.</p>
<p>View model properties that require validation are of type ValidatableObject<T>, and each<br />
ValidatableObject<T> instance has validation rules added to its Validations property. Validation is</p>
<p>39 CHAPTER 7 | Validation</p>
<p>invoked from the view model by calling the Validate method of the ValidatableObject<T> instance,<br />
which retrieves the validation rules and executes them against the ValidatableObject<T>.Value<br />
property. Any validation errors are placed into the Errors property of the ValidatableObject<T><br />
instance, and the IsValid property of the ValidatableObject<T> instance is updated to indicate<br />
whether the validation succeeded or failed. The following code shows the implementation of the<br />
ValidatableObject<T>:</p>
<p>Property change notification is provided by the ObservableObject class, and so an Entry control can<br />
bind to the IsValid property of ValidatableObject<T> instance in the view model class to be notified of<br />
whether or not the entered data is valid.</p>
<h3>Specifying validation rules</h3>
<p>Validation rules are specified by creating a class that derives from the IValidationRule<T> interface,<br />
which is shown in the following code example:</p>
<p>40 CHAPTER 7 | Validation</p>
<p>This interface specifies that a validation rule class must provide a boolean Check method that is used<br />
to perform the required validation, and a ValidationMessage property whose value is the validation<br />
error message that will be displayed if validation fails.</p>
<p>The following code example shows the IsNotNullOrEmptyRule<T> validation rule, which is used to<br />
perform validation of the username and password entered by the user on the LoginView when using<br />
mock services in the eShop multi-platform app:</p>
<p>The Check method returns a boolean indicating whether the value argument is null, empty, or consists<br />
only of whitespace characters.</p>
<p>Although not used by the eShop multi-platform app, the following code example shows a validation<br />
rule for validating email addresses:</p>
<p>The Check method returns a boolean indicating whether or not the value argument is a valid email<br />
address. This is achieved by searching the value argument for the first occurrence of the regular<br />
expression pattern specified in the Regex constructor. Whether the regular expression pattern has<br />
<a href="https://docs.microsoft.com/dotnet/api/system.text.regularexpressions.regex.ismatch">been found in the input string can be determined by checking the value against Regex.IsMatch.</a></p>
<p>41 CHAPTER 7 | Validation</p>
<h3>Adding validation rules to a property</h3>
<p>In the eShop multi-platform app, view model properties that require validation are declared to be of<br />
type ValidatableObject<T>, where T is the type of the data to be validated. The following code<br />
example shows an example of two such properties:</p>
<p>This method adds the IsNotNullOrEmptyRule<T> validation rule to the Validations collection of each<br />
ValidatableObject<T> instance, specifying values for the validation rule’s ValidationMessage property,<br />
which specifies the validation error message that will be displayed if validation fails.</p>
<h3>Triggering validation</h3>
<p>The validation approach used in the eShop multi-platform app can manually trigger validation of a<br />
property, and automatically trigger validation when a property changes.</p>
<h4><strong>Triggering validation manually</strong></h4>
<p>Validation can be triggered manually for a view model property. For example, this occurs in the eShop<br />
multi-platform app when the user taps the Login button on the LoginView, when using mock services.<br />
The command delegate calls the MockSignInAsync method in the LoginViewModel, which invokes<br />
validation by executing the Validate method, which is shown in the following code example:</p>
<p>42 CHAPTER 7 | Validation</p>
<p>The Validate method performs validation of the username and password entered by the user on the<br />
LoginView, by invoking the Validate method on each ValidatableObject<T> instance. The following<br />
code example shows the Validate method from the ValidatableObject<T> class:</p>
<p>This method retrieves any validation rules that were added to the object’s Validations collection. The<br />
Check method for each retrieved validation rule is executed, and the ValidationMessage property<br />
value for any validation rule that fails to validate the data is added to the Errors collection of the<br />
ValidatableObject<T> instance. Finally, the IsValid property is set, and its value is returned to the<br />
calling method, indicating whether validation succeeded or failed.</p>
<h4><strong>Triggering validation when properties change</strong></h4>
<p>Validation is also automatically triggered whenever a bound property changes. For example, when a<br />
two-way binding in the LoginView sets the UserName or Password property, validation is triggered.<br />
The following code example demonstrates how this occurs:</p>
<p>The Entry control binds to the UserName.Value property of the ValidatableObject<T> instance, and<br />
the control’s Behaviors collection has an EventToCommandBehavior instance added to it. This<br />
behavior executes the ValidateUserNameCommand in response to the TextChanged event firing on<br />
the Entry, which is raised when the text in the Entry changes. In turn, the ValidateUserNameCommand<br />
delegate executes the ValidateUserName method, which executes the Validate method on the<br />
ValidatableObject<T> instance. Therefore, every time the user enters a character in the Entry control<br />
for the username, validation of the entered data is performed.</p>
<h3>Displaying validation errors</h3>
<p>The eShop multi-platform app notifies the user of any validation errors by highlighting the control<br />
that contains the invalid data with a red background, and by displaying an error message that informs</p>
<p>43 CHAPTER 7 | Validation</p>
<p>the user why the data is invalid below the control containing the invalid data. When the invalid data is<br />
corrected, the background changes back to the default state and the error message is removed. The<br />
image below shows the LoginView in the eShop multi-platform app when validation errors are<br />
present.</p>
<h4><strong>Highlighting a control that contains invalid data</strong></h4>
<p>.NET MAUI offers a number of ways to present validation information to end-users, but one of the<br />
most straight-forward ways is through the use of Triggers. Triggers provide us a way to change the<br />
state of our controls, typically for appearance, based on an event or data change that occurs for a<br />
control. For validation, we will be using a DataTrigger which will listen to changes raised from a bound<br />
property and respond to the changes. The Entry controls on the LoginView are setup using the<br />
following code:</p>
<p>The DataTrigger specifies the following properties:</p>
<p>44 CHAPTER 7 | Validation</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>TargetType</td>
<td>The control type that the trigger belongs to.</td>
</tr>
<tr>
<td>Binding</td>
<td>The data Binding markup which will provide<br>change notifications and value for the trigger<br>condition.</td>
</tr>
<tr>
<td>Value</td>
<td>The data value to specify when the trigger’s<br>condition has been met.</td>
</tr>
</tbody>
</table>
<p>For this Entry, we will be listening for changes to the LoginViewModel.UserName.IsValid property.<br />
Each time this property raises a change, the value will be compared against the Value property set in<br />
the DataTrigger. If the values are equal, then the trigger condition will be met and any Setter objects<br />
provided to the DataTrigger will be executed. This control has a single Setter object that updates the<br />
BackgroundColor property to a custom color defined using the StaticResource markup. When a<br />
Trigger condition is no longer met, the control will revert the properties set by the Setter object to<br />
<a href="https://docs.microsoft.com/dotnet/maui/fundamentals/triggers">their previous state. For more information about Triggers, see .NET MAUI Docs: Triggers.</a></p>
<h4><strong>Displaying error messages</strong></h4>
<p>The UI displays validation error messages in Label controls below each control whose data failed<br />
validation. The following code example shows the Label that displays a validation error message, if the<br />
user has not entered a valid username:</p>
<p>Each Label binds to the Errors property of the view model object that’s being validated. The Errors<br />
property is provided by the ValidatableObject<T> class, and is of type IEnumerable<string>. Because<br />
the Errors property can contain multiple validation errors, the FirstValidationErrorConverter instance is<br />
used to retrieve the first error from the collection for display.</p>
<h3>Summary</h3>
<p>The eShop multi-platform app performs synchronous client-side validation of view model properties<br />
and notifies the user of any validation errors by highlighting the control that contains the invalid data,<br />
and by displaying error messages that inform the user why the data is invalid.</p>
<p>View model properties that require validation are of type ValidatableObject<T>, and each<br />
ValidatableObject<T> instance has validation rules added to its Validations property. Validation is<br />
invoked from the view model by calling the Validate method of the ValidatableObject<T> instance,<br />
which retrieves the validation rules and executes them against the ValidatableObject<T> Value<br />
property. Any validation errors are placed into the Errors property of the ValidatableObject<T><br />
instance, and the IsValid property of the ValidatableObject<T> instance is updated to indicate<br />
whether validation succeeded or failed.</p>
<p>45 CHAPTER 7 | Validation</p>
<p><strong>CHAPTER</strong></p>
<h1>8</h1>
<h2>Application settings management</h2>
<p>Settings allow the separation of data that configures the behavior of an app from the code, allowing<br />
the behavior to be changed without rebuilding the app. There are two types of settings: app settings<br />
and user settings.</p>
<p>App settings are data that an app creates and manages. It can include data such as fixed web service<br />
endpoints, API keys, and runtime state. App settings are tied to core functionality and are only<br />
meaningful to that app.</p>
<p>User settings are the customizable settings of an app that affect the app’s behavior and don’t require<br />
frequent re-adjustment. For example, an app might let the user specify where to retrieve data and<br />
how to display it on the screen.</p>
<h3>Creating a Settings Interface</h3>
<p>While the preferences manager can be used directly in your application, it does come with the<br />
drawback of making your application tightly coupled to the preferences manager implementation.<br />
This coupling means that creating unit tests or extending the functionality of preferences<br />
management will be limited since your application will not have a direct way to intercept the behavior.<br />
To address this concern, an interface can be created to work as a proxy for preferences management.<br />
The interface will allow us to supply an implementation that fits our needs. For example, when writing<br />
a unit test, we may want to set specific settings, and the interface will give us an easy way to<br />
consistently set this data for the test. The following code example shows the ISettingsService interface<br />
in the eShop multi-platform app:</p>
<p>46 CHAPTER 8 | Application settings management</p>
<h3>Adding Settings</h3>
<p>.NET MAUI includes a preferences manager that provides a way to store runtime settings for a user.<br />
This feature can be accessed from anywhere within your application using the<br />
Microsoft.Maui.Storage.Preferences class. The preferences manager provides a consistent, type-safe,<br />
cross-platform approach for persisting and retrieving app and user settings, while using the native<br />
settings management provided by each platform. In addition, it’s straightforward to use data binding<br />
<a href="https://docs.microsoft.com/dotnet/maui/platform-integration/storage/preferences">to access settings data exposed by the library. For more information, see the Preferences on the</a><br />
Microsoft Developer Center.</p>
<p>Our application will use the Preferences class need to implement the ISettingsService interface. The<br />
code below shows how the eShop multi-platform app’s SettingsService implements the<br />
AuthTokenAccess and UseMocks properties:</p>
<p>Each setting consists of a private key, a private default value, and a public property. The key is always<br />
a const string that defines a unique name, with the default value for the setting being a static readonly or constant value of the required type. Providing a default value ensures that a valid value is<br />
available if an unset setting is retrieved. This service implementation can be provided via dependency<br />
injection to our application for use in view-models or other services throughout the application.</p>
<p>47 CHAPTER 8 | Application settings management</p>
<h3>Data binding to user settings</h3>
<p>In the eShop multi-platform app, the SettingsView exposes multiple settings the user can configure at<br />
runtime. These settings include allowing configuration of whether the app should retrieve data from<br />
microservices deployed as Docker containers or whether the app should retrieve data from mock<br />
services that don’t require an internet connection. When retrieving data from containerized<br />
microservices, a base endpoint URL for the microservices must be specified. The image below shows<br />
the SettingsView when the user has chosen to retrieve data from containerized microservices.</p>
<p>Data binding can be used to retrieve and set settings exposed by the ISettingService interface. This is<br />
achieved by controls on the view binding to view model properties that in turn access properties in<br />
the ISettingService interface and raising a property changed notification if the value has changed.</p>
<p>The following code example shows the Entry control from the SettingsView that allows the user to<br />
enter a base identity endpoint URL for the containerized microservices:</p>
<pre><code>&lt; Entry Text=&quot;{Binding IdentityEndpoint, Mode=TwoWay}&quot; /&gt;

</code></pre>
<p>This Entry control binds to the IdentityEndpoint property of the SettingsViewModel class, using a twoway binding. The following code example shows the IdentityEndpoint property:</p>
<p>48 CHAPTER 8 | Application settings management</p>
<p>When the IdentityEndpoint property is set, the UpdateIdentityEndpoint method is called, provided<br />
that the supplied value is valid. The following code example shows the UpdateIdentityEndpoint<br />
method:</p>
<p>This method updates the IdentityEndpointBase property in the ISettingService interface<br />
implementation with the base endpoint URL value entered by the user. If the SettingsService class is<br />
provided as the implementation for _settingsService, the value will persist to platform-specific storage.</p>
<h3>Summary</h3>
<p>Settings allow the separation of data that configures the behavior of an app from the code, allowing<br />
the behavior to be changed without rebuilding the app. App settings are data that an app creates and<br />
manages, and user settings are the customizable settings of an app that affect the app’s behavior and<br />
don’t require frequent re-adjustment.</p>
<p>The Microsoft.Maui.Storage.Preferences class provides a consistent, type-safe, cross-platform<br />
approach for persisting and retrieving app and user settings.</p>
<p>49 CHAPTER 8 | Application settings management</p>
<p><strong>CHAPTER</strong></p>
<h1>9</h1>
<h2>Containerized microservices</h2>
<p>Developing client-server applications has resulted in a focus on building tiered applications that use<br />
specific technologies in each tier. Such applications are often referred to as <em>monolithic</em> and are<br />
packaged onto hardware pre-scaled for peak loads. The main drawbacks of this development<br />
approach are the tight coupling between components within each tier, that individual components<br />
can’t be easily scaled, and the cost of testing. A simple update can have unforeseen effects on the rest<br />
of the tier, so a change to an application component requires its entire tier to be retested and<br />
redeployed.</p>
<p>Particularly concerning, in the age of the cloud, is that individual components can’t be easily scaled. A<br />
monolithic application contains domain-specific functionality and is typically divided by functional<br />
layers such as front-end, business logic, and data storage. The image below illustrates that a<br />
monolithic application is scaled by cloning the entire application onto multiple machines.</p>
<p>50 CHAPTER 9 | Containerized microservices</p>
<h3>Microservices</h3>
<p>Microservices offer a different approach to application development and deployment, an approach<br />
that’s suited to the agility, scale, and reliability requirements of modern cloud applications. A<br />
microservices application is split into independent components that work together to deliver the<br />
application’s overall functionality. The term microservice emphasizes that applications should be<br />
composed of services small enough to reflect particular concerns, so each microservice implements a<br />
single function. In addition, each microservice has well-defined contracts with which other<br />
microservices communicate and share data. Typical examples of microservices include shopping carts,<br />
inventory processing, purchase subsystems, and payment processing.</p>
<p>Microservices can scale independently compared to giant monolithic applications that scale together.<br />
This means that a specific functional area that requires more processing power or network bandwidth<br />
to support demand can be scaled rather than unnecessarily scaling out other application areas. The<br />
image below illustrates this approach, where microservices are deployed and scaled independently,<br />
creating instances of services across machines.</p>
<p>51 CHAPTER 9 | Containerized microservices</p>
<p>Microservice scale-out can be nearly instantaneous, allowing an application to adapt to changing<br />
loads. For example, a single microservice in the web-facing functionality of an application might be<br />
the only microservice that needs to scale out to handle additional incoming traffic.</p>
<p>The classic model for application scalability is to have a load-balanced, stateless tier with a shared<br />
external datastore to store persistent data. Stateful microservices manage their own persistent data,<br />
usually storing it locally on the servers on which they are placed, to avoid the overhead of network<br />
access and complexity of cross-service operations. This enables the fastest possible processing of data<br />
and can eliminate the need for caching systems. In addition, scalable stateful microservices usually<br />
partition data among their instances, in order to manage data size and transfer throughput beyond<br />
which a single server can support.</p>
<p>Microservices also support independent updates. This loose coupling between microservices provides<br />
a rapid and reliable application evolution. Their independent, distributed nature helps rolling updates,<br />
where only a subset of instances of a single microservice will update at any given time. Therefore, if a<br />
problem is detected, a buggy update can be rolled back, before all instances update with the faulty<br />
code or configuration. Similarly, microservices typically use schema versioning, so that clients see a<br />
consistent version when updates are being applied, regardless of which microservice instance is being<br />
communicated with.</p>
<p>Therefore, microservice applications have many benefits over monolithic applications:</p>
<ul>
<li>
<p>Each microservice is relatively small, easy to manage and evolve.</p>
</li>
<li>
<p>Each microservice can be developed and deployed independently of other services.</p>
</li>
<li>
<p>Each microservice can be scaled-out independently. For example, a catalog service or<br />
shopping basket service might need to be scaled-out more than an ordering service.</p>
</li>
</ul>
<p>52 CHAPTER 9 | Containerized microservices</p>
<p>Therefore, the resulting infrastructure will more efficiently consume resources when scaling<br />
out.</p>
<ul>
<li>
<p>Each microservice isolates any issues. For example, if there is an issue in a service it only<br />
impacts that service. The other services can continue to handle requests.</p>
</li>
<li>
<p>Each microservice can use the latest technologies. Because microservices are autonomous and<br />
run side-by-side, the latest technologies and frameworks can be used, rather than being<br />
forced to use an older framework that might be used by a monolithic application.</p>
</li>
</ul>
<p>However, a microservice-based solution also has potential drawbacks:</p>
<ul>
<li>
<p>Choosing how to partition an application into microservices can be challenging, as each<br />
microservice has to be completely autonomous, end-to-end, including responsibility for its<br />
data sources.</p>
</li>
<li>
<p>Developers must implement inter-service communication, which adds complexity and latency<br />
to the application.</p>
</li>
<li>
<p>Atomic transactions between multiple microservices usually aren’t possible. Therefore,<br />
business requirements must embrace eventual consistency between microservices.</p>
</li>
<li>
<p>In production, there is an operational complexity in deploying and managing a system<br />
compromised of many independent services.</p>
</li>
<li>
<p>Direct client-to-microservice communication can make it difficult to refactor the contracts of<br />
microservices. For example, over time how the system is partitioned into services might need<br />
to change. A single service might split into two or more services, and two services might<br />
merge. When clients communicate directly with microservices, this refactoring work can break<br />
compatibility with client apps.</p>
</li>
</ul>
<h3>Containerization</h3>
<p>Containerization is an approach to software development in which an application and its versioned set<br />
of dependencies, plus its environment configuration abstracted as deployment manifest files, are<br />
packaged together as a container image, tested as a unit, and deployed to a host operating system.</p>
<p>A container is an isolated, resource controlled, and portable operating environment, where an<br />
application can run without touching the resources of other containers, or the host. Therefore, a<br />
container looks and acts like a newly installed physical computer or a virtual machine.</p>
<p>There are many similarities between containers and virtual machines, as illustrated below.</p>
<p>53 CHAPTER 9 | Containerized microservices</p>
<p>A container runs an operating system, has a file system, and can be accessed over a network as if it<br />
were a physical or virtual machine. However, the technology and concepts used by containers are very<br />
different from virtual machines. Virtual machines include the applications, the required dependencies,<br />
and a full guest operating system. Containers include the application and its dependencies, but share<br />
the operating system with other containers, running as isolated processes on the host operating<br />
system (aside from Hyper-V containers which run inside of a special virtual machine per container).<br />
Therefore, containers share resources and typically require fewer resources than virtual machines.</p>
<p>The advantage of a container-oriented development and deployment approach is that it eliminates<br />
most of the issues that arise from inconsistent environment setups and the problems that come with<br />
them. In addition, containers permit fast application scale-up functionality by instancing new<br />
containers as required.</p>
<p>The key concepts when creating and working with containers are:</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Container Host</td>
<td>The physical or virtual machine configured to<br>host containers. The container host will run one<br>or more containers.</td>
</tr>
<tr>
<td>Container Image</td>
<td>An image consists of a union of layered<br>filesystems stacked on top of each other, and is<br>the basis of a container. An image does not<br>have state and it never changes as it’s deployed<br>to different environments.</td>
</tr>
<tr>
<td>Container</td>
<td>A container is a runtime instance of an image.</td>
</tr>
</tbody>
</table>
<p>54 CHAPTER 9 | Containerized microservices</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Container OS Image</td>
<td>Containers are deployed from images. The<br>container operating system image is the first<br>layer in potentially many image layers that make<br>up a container. A container operating system is<br>immutable, and can’t be modified.</td>
</tr>
<tr>
<td>Container Repository</td>
<td>Each time a container image is created, the<br>image and its dependencies are stored in a local<br>repository. These images can be reused many<br>times on the container host. The container<br>images can also be stored in a public or private<br>registry, such asDocker Hub, so that they can<br>be used across different container hosts.</td>
</tr>
</tbody>
</table>
<p>Enterprises are increasingly adopting containers when implementing microservice-based applications,<br />
and Docker has become the standard container implementation that has been adopted by most<br />
software platforms and cloud vendors.</p>
<p>The eShop reference application uses Docker to host four containerized back-end microservices, as<br />
illustrated in the diagram below.</p>
<p>55 CHAPTER 9 | Containerized microservices</p>
<p>The architecture of the back-end services in the reference application is decomposed into multiple<br />
autonomous sub-systems in the form of collaborating microservices and containers. Each microservice<br />
provides a single area of functionality: an identity service, a catalog service, an ordering service, and a<br />
basket service.</p>
<p>Each microservice has its own database, allowing it to be fully decoupled from the other<br />
microservices. Where necessary, consistency between databases from different microservices is<br />
achieved using application-level events. For more information, see Communication between<br />
microservices.</p>
<h3>Communication between client and microservices</h3>
<p>The eShop multi-platform app communicates with the containerized back-end microservices using<br />
<em>direct client-to-microservice</em> communication, as shown below.</p>
<p>56 CHAPTER 9 | Containerized microservices</p>
<p>With direct client-to-microservice communication, the multi-platform app makes requests to each<br />
microservice directly through its public endpoint, with a different TCP port per microservice. In<br />
production, the endpoint would typically map to the microservice’s load balancer, which distributes<br />
requests across the available instances.</p>
<p>Direct client-to-microservice communication can have drawbacks when building a large and complex<br />
microservice-based application, but it’s more than adequate for a small application. Consider using<br />
API gateway communication when designing a large microservice-based application with tens of<br />
microservices.</p>
<h3>Communication between microservices</h3>
<p>A microservices-based application is a distributed system, potentially running on multiple machines.<br />
Each service instance is typically a process. Therefore, services must interact using an inter-process<br />
communication protocol, such as HTTP, TCP, Advanced Message Queuing Protocol (AMQP), or binary<br />
protocols, depending on the nature of each service.</p>
<p>The two common approaches for microservice-to-microservice communication are HTTP-based REST<br />
communication when querying for data, and lightweight asynchronous messaging when<br />
communicating updates across multiple microservices.</p>
<p>Asynchronous messaging-based event-driven communication is critical when propagating changes<br />
across multiple microservices. With this approach, a microservice publishes an event when something<br />
notable happens, for example, when it updates a business entity. Other microservices subscribe to<br />
these events. Then, when a microservice receives an event, it updates its own business entities, which<br />
might, in turn, lead to more events being published. This publish-subscribe functionality is usually<br />
achieved with an event bus.</p>
<p>57 CHAPTER 9 | Containerized microservices</p>
<p>An event bus allows publish-subscribe communication between microservices without requiring the<br />
components to be explicitly aware of each other, as shown below.</p>
<p>From an application perspective, the event bus is simply a publish-subscribe channel exposed via an<br />
interface. However, the way the event bus is implemented can vary. For example, an event bus<br />
implementation could use RabbitMQ, Azure Service Bus, or other service buses such as NServiceBus<br />
and MassTransit. The diagram below shows how an event bus is used in the eShop reference<br />
application.</p>
<p>The eShop event bus, implemented using RabbitMQ, provides one-to-many asynchronous publishsubscribe functionality. This means that after publishing an event, there can be multiple subscribers<br />
listening for the same event. The diagram below illustrates this relationship.</p>
<p>58 CHAPTER 9 | Containerized microservices</p>
<p>This one-to-many communication approach uses events to implement business transactions that span<br />
multiple services, ensuring eventual consistency between the services. An eventual-consistent<br />
transaction consists of a series of distributed steps. Therefore, when the user-profile microservice<br />
receives the UpdateUser command, it updates the user’s details in its database and publishes the<br />
UserUpdated event to the event bus. Both the basket microservice and the ordering microservice have<br />
subscribed to receive this event, and in response, update their buyer information in their respective<br />
databases.</p>
<h3>Summary</h3>
<p>Microservices offer an approach to application development and deployment that’s suited to the<br />
agility, scale, and reliability requirements of modern cloud applications. One of the main advantages<br />
of microservices is that they can be scaled-out independently, which means that a specific functional<br />
area can be scaled that requires more processing power or network bandwidth to support demand<br />
without unnecessarily scaling areas of the application that are not experiencing increased demand.</p>
<p>A container is an isolated, resource-controlled, and portable operating environment where an<br />
application can run without touching the resources of other containers or the host. Enterprises are<br />
increasingly adopting containers when implementing microservice-based applications, and Docker<br />
has become the standard container implementation that most software platforms and cloud vendors<br />
have adopted.</p>
<p>59 CHAPTER 9 | Containerized microservices</p>
<p><strong>CHAPTER</strong></p>
<h1>10</h1>
<h2>Accessing remote data</h2>
<p>Many modern web-based solutions make use of web services, hosted by web servers, to provide<br />
functionality for remote client applications. The operations that a web service exposes constitute a<br />
web API.</p>
<p>Client apps should be able to utilize the web API without knowing how the data or operations that the<br />
API exposes are implemented. This requires that the API abides by common standards that enable a<br />
client app and web service to agree on which data formats to use, and the structure of the data that is<br />
exchanged between client apps and the web service.</p>
<h3>Introduction to Representational State Transfer</h3>
<p>Representational State Transfer (REST) is an architectural style for building distributed systems based<br />
on hypermedia. A primary advantage of the REST model is that it’s based on open standards and<br />
doesn’t bind the implementation of the model or the client apps that access it to any specific<br />
<a href="https://docs.microsoft.com/aspnet/core/introduction-to-aspnet-core">implementation. Therefore, a REST web service could be implemented using Microsoft ASP.NET Core,</a><br />
and client apps could be developing using any language and toolset that can generate HTTP requests<br />
and parse HTTP responses.</p>
<p>The REST model uses a navigational scheme to represent objects and services over a network, referred<br />
to as resources. Systems that implement REST typically use the HTTP protocol to transmit requests to<br />
access these resources. In such systems, a client app submits a request in the form of a URI that<br />
identifies a resource, and an HTTP method (such as GET, POST, PUT, or DELETE) that indicates the<br />
operation to be performed on that resource. The body of the HTTP request contains any data required<br />
to perform the operation.</p>
<p>The response from a REST request makes use of standard HTTP status codes. For example, a request<br />
that returns valid data should include the HTTP response code 200 (OK), while a request that fails to<br />
find or delete a specified resource should return a response that includes the HTTP status code 404<br />
(Not Found).</p>
<p>A RESTful web API exposes a set of connected resources, and provides the core operations that<br />
enable an app to manipulate those resources and easily navigate between them. For this reason, the<br />
URIs that constitute a typical RESTful web API are oriented towards the data that it exposes, and use<br />
the facilities provided by HTTP to operate on this data.</p>
<p>60 CHAPTER 10 | Accessing remote data</p>
<p>The data included by a client app in an HTTP request, and the corresponding response messages from<br />
the web server, could be presented in a variety of formats, known as media types. When a client app<br />
sends a request that returns data in the body of a message, it can specify the media types it can<br />
handle in the Accept header of the request. If the web server supports this media type, it can reply<br />
with a response that includes the Content-Type header that specifies the format of the data in the<br />
body of the message. It’s then the responsibility of the client app to parse the response message and<br />
interpret the results in the message body appropriately.</p>
<p><a href="https://docs.microsoft.com/azure/architecture/best-practices/api-design">For more information about REST, see API design</a> <a href="https://docs.microsoft.com/azure/architecture/best-practices/api-implementation">and API implementation</a> on Microsoft Docs.</p>
<h3>Consuming RESTful APIs</h3>
<p>The eShop multi-platform app uses the Model-View-ViewModel (MVVM) pattern, and the model<br />
elements of the pattern represent the domain entities used in the app. The controller and repository<br />
classes in the eShop reference application accept and return many of these model objects. Therefore,<br />
they are used as data transfer objects (DTOs) that hold all the data that is passed between the app<br />
and the containerized microservices. The main benefit of using DTOs to pass data to and receive data<br />
from a web service is that by transmitting more data in a single remote call, the app can reduce the<br />
number of remote calls that need to be made.</p>
<h3>Making web requests</h3>
<p>The eShop multi-platform app uses the HttpClient class to make requests over HTTP, with JSON being<br />
used as the media type. This class provides functionality for asynchronously sending HTTP requests<br />
and receiving HTTP responses from a URI identified resource. The HttpResponseMessage class<br />
represents an HTTP response message received from a REST API after an HTTP request has been<br />
made. It contains information about the response, including the status code, headers, and any body.<br />
The HttpContent class represents the HTTP body and content headers, such as Content-Type and<br />
Content-Encoding. The content can be read using any of the ReadAs methods, such as<br />
ReadAsStringAsync and ReadAsByteArrayAsync, depending on the format of the data.</p>
<h3>Making a GET request</h3>
<p>The CatalogService class is used to manage the data retrieval process from the catalog microservice.<br />
In the RegisterViewModels method in the MauiProgram class, the CatalogService class is registered as<br />
a type mapping against the ICatalogService type with the dependency injection container. Then, when<br />
an instance of the CatalogViewModel class is created, its constructor accepts an ICatalogService type,<br />
which the dependency injection container resolves, returning an instance of the CatalogService class.<br />
For more information about dependency injection, see Dependency Injection.</p>
<p>The image below shows the interaction of classes that read catalog data from the catalog microservice<br />
for displaying by the CatalogView.</p>
<p>61 CHAPTER 10 | Accessing remote data</p>
<p>When the CatalogView is navigated to, the OnInitialize method in the CatalogViewModel class is<br />
called. This method retrieves catalog data from the catalog microservice, as demonstrated in the<br />
following code example:</p>
<p>This method calls the GetCatalogAsync method of the CatalogService instance that was injected into<br />
the CatalogViewModel by the dependency injection container. The following code example shows the<br />
GetCatalogAsync method:</p>
<p>62 CHAPTER 10 | Accessing remote data</p>
<p>This method builds the URI that identifies the resource the request will be sent to, and uses the<br />
RequestProvider class to invoke the GET HTTP method on the resource, before returning the results to<br />
the CatalogViewModel. The RequestProvider class contains functionality that submits a request in the<br />
form of a URI that identifies a resource, an HTTP method that indicates the operation to be performed<br />
on that resource, and a body that contains any data required to perform the operation. For<br />
information about how the RequestProvider class is injected into the CatalogService class, see<br />
Dependency Injection.</p>
<p>The following code example shows the GetAsync method in the RequestProvider class:</p>
<p>This method calls the GetOrCreateHttpClient method, which returns an instance of the HttpClient class<br />
with the appropriate headers set. It then submits an asynchronous GET request to the resource<br />
identified by the URI, with the response being stored in the HttpResponseMessage instance. The<br />
HandleResponse method is then invoked, which throws an exception if the response doesn’t include a<br />
success HTTP status code. Then the response is read as a string, converted from JSON to a<br />
CatalogRoot object, and returned to the CatalogService.</p>
<p>The GetOrCreateHttpClient method is shown in the following code example:</p>
<p>63 CHAPTER 10 | Accessing remote data</p>
<p>This method uses creates a new instance or retrieves a cached instance of the HttpClient class, and<br />
sets the Accept header of any requests made by the HttpClient instance to application/json, which<br />
indicates that it expects the content of any response to be formatted using JSON. Then, if an access<br />
token was passed as an argument to the GetOrCreateHttpClient method, it’s added to the<br />
Authorization header of any requests made by the HttpClient instance, prefixed with the string Bearer.<br />
For more information about authorization, see Authorization.</p>
<p>When the GetAsync method in the RequestProvider class calls HttpClient.GetAsync, the Items method<br />
in the CatalogController class in the Catalog.API project is invoked, which is shown in the following<br />
code example:</p>
<p><a href="https://docs.microsoft.com/ef/">This method retrieves the catalog data from the SQL database using EntityFramework, and returns it</a><br />
as a response message that includes a success HTTP status code, and a collection of JSON formatted<br />
CatalogItem instances.</p>
<h3>Making a POST request</h3>
<p>The BasketService class is used to manage the data retrieval and update process with the basket<br />
microservice. In the RegisterAppServices method in the MauiProgram class, the BasketService class is<br />
registered as a type mapping against the IBasketService type with the dependency injection container.<br />
Then, when an instance of the BasketViewModel class is created, its constructor accepts an</p>
<p>64 CHAPTER 10 | Accessing remote data</p>
<p>IBasketService type, which the dependency injection container resolves, returning an instance of the<br />
BasketService class. For more information about dependency injection, see Dependency Injection.</p>
<p>The image below shows the interaction of classes that send the basket data displayed by the<br />
BasketView, to the basket microservice.</p>
<p>When an item is added to the shopping basket, the ReCalculateTotalAsync method in the<br />
BasketViewModel class is called. This method updates the total value of items in the basket, and sends<br />
the basket data to the basket microservice, as demonstrated in the following code example:</p>
<p>65 CHAPTER 10 | Accessing remote data</p>
<p>This method calls the UpdateBasketAsync method of the BasketService instance that was injected into<br />
the BasketViewModel by the dependency injection container. The following method shows the<br />
UpdateBasketAsync method:</p>
<p>This method builds the URI that identifies the resource the request will be sent to, and uses the<br />
RequestProvider class to invoke the POST HTTP method on the resource, before returning the results<br />
to the BasketViewModel. Note that an access token, obtained from IdentityServer during the<br />
authentication process, is required to authorize requests to the basket microservice. For more<br />
information about authorization, see Authorization.</p>
<p>The following code example shows one of the PostAsync methods in the RequestProvider class:</p>
<p>This method calls the GetOrCreateHttpClient method, which returns an instance of the HttpClient class<br />
with the appropriate headers set. It then submits an asynchronous POST request to the resource<br />
identified by the URI, with the serialized basket data being sent in JSON format, and the response<br />
being stored in the HttpResponseMessage instance. The HandleResponse method is then invoked,<br />
which throws an exception if the response doesn’t include a success HTTP status code. Then, the<br />
response is read as a string, converted from JSON to a CustomerBasket object, and returned to the<br />
BasketService. For more information about the GetOrCreateHttpClient method, see Making a GET<br />
request.</p>
<p>When the PostAsync method in the RequestProvider class calls HttpClient.PostAsync, the Post method<br />
in the BasketController class in the Basket.API project is invoked, which is shown in the following code<br />
example:</p>
<p>66 CHAPTER 10 | Accessing remote data</p>
<p>This method uses an instance of the RedisBasketRepository class to persist the basket data to the<br />
Redis cache, and returns it as a response message that includes a success HTTP status code, and a<br />
JSON formatted CustomerBasket instance.</p>
<h3>Making a DELETE request</h3>
<p>The image below shows the interactions of classes that delete basket data from the basket<br />
microservice, for the CheckoutView.</p>
<p>When the checkout process is invoked, the CheckoutAsync method in the CheckoutViewModel class is<br />
called. This method creates a new order, before clearing the shopping basket, as demonstrated in the<br />
following code example:</p>
<p>This method calls the ClearBasketAsync method of the BasketService instance that was injected into<br />
the CheckoutViewModel by the dependency injection container. The following method shows the<br />
ClearBasketAsync method:</p>
<p>67 CHAPTER 10 | Accessing remote data</p>
<p>This method builds the URI that identifies the resource that the request will be sent to, and uses the<br />
RequestProvider class to invoke the DELETE HTTP method on the resource. Note that an access token,<br />
obtained from IdentityServer during the authentication process, is required to authorize requests to<br />
the basket microservice. For more information about authorization, see Authorization.</p>
<p>The following code example shows the DeleteAsync method in the RequestProvider class:</p>
<p>This method calls the GetOrCreateHttpClient method, which returns an instance of the HttpClient class<br />
with the appropriate headers set. It then submits an asynchronous DELETE request to the resource<br />
identified by the URI. For more information about the GetOrCreateHttpClient method, see Making a<br />
GET request.</p>
<p>When the DeleteAsync method in the RequestProvider class calls HttpClient.DeleteAsync, the Delete<br />
method in the BasketController class in the Basket.API project is invoked, which is shown in the<br />
following code example:</p>
<p>This method uses an instance of the RedisBasketRepository class to delete the basket data from the<br />
Redis cache.</p>
<h3>Caching data</h3>
<p>The performance of an app can be improved by caching frequently accessed data to fast storage<br />
that’s located close to the app. If the fast storage is located closer to the app than the original source,<br />
then caching can significantly improve response times when retrieving data.</p>
<p>The most common form of caching is read-through caching, where an app retrieves data by<br />
referencing the cache. If the data isn’t in the cache, it’s retrieved from the data store and added to the<br />
cache. Apps can implement read-through caching with the cache-aside pattern. This pattern<br />
determines whether the item is currently in the cache. If the item isn’t in the cache, it’s read from the<br />
<a href="https://docs.microsoft.com/azure/architecture/patterns/cache-aside">data store and added to the cache. For more information, see the Cache-Aside pattern on Microsoft</a><br />
Docs.</p>
<p>This data can be added to the cache on demand the first time it is retrieved by an app. This means<br />
that the app needs to fetch the data only once from the data store, and that subsequent access can<br />
be satisfied by using the cache.</p>
<p>68 CHAPTER 10 | Accessing remote data</p>
<p>Distributed applications, such as the eShop reference application, should provide either or both of the<br />
following caches:</p>
<ul>
<li>
<p>A shared cache, which can be accessed by multiple processes or machines.</p>
</li>
<li>
<p>A private cache, where data is held locally on the device running the app.</p>
</li>
</ul>
<p>The eShop multi-platform app uses a private cache, where data is held locally on the device that’s<br />
running an instance of the app.</p>
<p>Ensure that data is maintained in the original data store as well as the cache. The chances of losing<br />
data are then minimized if the cache becomes unavailable.</p>
<h3>Managing data expiration</h3>
<p>It’s impractical to expect that cached data will always be consistent with the original data. Data in the<br />
original data store might change after it’s been cached, causing the cached data to become stale.<br />
Therefore, apps should implement a strategy that helps to ensure that the data in the cache is as upto-date as possible, but can also detect and handle situations that arise when the data in the cache<br />
has become stale. Most caching mechanisms enable the cache to be configured to expire data, and<br />
hence reduce the period for which data might be out of date.</p>
<p>Many caches implement expiration, which invalidates data and removes it from the cache if it’s not<br />
accessed for a specified period. However, care must be taken when choosing the expiration period. If<br />
it’s made too short, data will expire too quickly and the benefits of caching will be reduced. If it’s<br />
made too long, the data risks becoming stale. Therefore, the expiration time should match the pattern<br />
of access for apps that use the data.</p>
<p>When cached data expires, it should be removed from the cache, and the app must retrieve the data<br />
from the original data store and place it back into the cache.</p>
<p>It’s also possible that a cache might fill up if data is allowed to remain for too long a period. Therefore,<br />
requests to add new items to the cache might be required to remove some items in a process known<br />
as <em>eviction</em> . Caching services typically evict data on a least-recently-used basis. However, there are<br />
other eviction policies, including most-recently-used, and first-in-first-out. For more information, see<br />
<a href="https://docs.microsoft.com/azure/architecture/best-practices/caching">Caching Guidance</a> on Microsoft Docs.</p>
<h3>Caching images</h3>
<p>The eShop multi-platform app consumes remote product images that benefit from being cached.<br />
These images are displayed by the Image control. The .NET MAUI Image control supports caching of</p>
<p>69 CHAPTER 10 | Accessing remote data</p>
<p>downloaded images which has caching enabled by default, and will store the image locally for 24<br />
hours. In addition, the expiration time can be configured with the CacheValidity property. For more<br />
<a href="https://docs.microsoft.com/dotnet/maui/user-interface/controls/image#image-caching">information, see Downloaded Image Caching on the Microsoft Developer Center.</a></p>
<h3>Increasing resilience</h3>
<p>All apps that communicate with remote services and resources must be sensitive to transient faults.<br />
Transient faults include the momentary loss of network connectivity to services, the temporary<br />
unavailability of a service, or timeouts that arise when a service is busy. These faults are often selfcorrecting, and if the action is repeated after a suitable delay it’s likely to succeed.</p>
<p>Transient faults can have a huge impact on the perceived quality of an app, even if it has been<br />
thoroughly tested under all foreseeable circumstances. To ensure that an app that communicates with<br />
remote services operates reliably, it must be able to do all of the following:</p>
<ul>
<li>
<p>Detect faults when they occur, and determine if the faults are likely to be transient.</p>
</li>
<li>
<p>Retry the operation if it determines that the fault is likely to be transient and keep track of the<br />
number of times the operation was retried.</p>
</li>
<li>
<p>Use an appropriate retry strategy, which specifies the number of retries, the delay between<br />
each attempt, and the actions to take after a failed attempt.</p>
</li>
</ul>
<p>This transient fault handling can be achieved by wrapping all attempts to access a remote service in<br />
code that implements the retry pattern.</p>
<h3>Retry pattern</h3>
<p>If an app detects a failure when it tries to send a request to a remote service, it can handle the failure<br />
in any of the following ways:</p>
<ul>
<li>
<p>Retrying the operation. The app could retry the failing request immediately.</p>
</li>
<li>
<p>Retrying the operation after a delay. The app should wait for a suitable amount of time before<br />
retrying the request.</p>
</li>
<li>
<p>Cancelling the operation. The application should cancel the operation and report an<br />
exception.</p>
</li>
</ul>
<p>The retry strategy should be tuned to match the business requirements of the app. For example, it’s<br />
important to optimize the retry count and retry interval to the operation being attempted. If the<br />
operation is part of a user interaction, the retry interval should be short and only a few retries<br />
attempted to avoid making users wait for a response. If the operation is part of a long running<br />
workflow, where cancelling or restarting the workflow is expensive or time-consuming, it’s appropriate<br />
to wait longer between attempts and to retry more times.</p>
<p>70 CHAPTER 10 | Accessing remote data</p>
<p>If a request still fails after a number of retries, it’s better for the app to prevent further requests going<br />
to the same resource and to report a failure. Then, after a set period, the app can make one or more<br />
requests to the resource to see if they’re successful. For more information, see Circuit breaker pattern.</p>
<p><a href="https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker">Use a finite number of retries, or implement the Circuit Breaker</a> pattern to allow a service to recover.</p>
<p>The eShop reference application does implement the retry pattern.</p>
<p><a href="https://docs.microsoft.com/azure/architecture/patterns/retry">For more information about the retry pattern, see the Retry</a> pattern on Microsoft Docs.</p>
<h3>Circuit breaker pattern</h3>
<p>In some situations, faults can occur due to anticipated events that take longer to fix. These faults can<br />
range from a partial loss of connectivity to the complete failure of a service. In these situations, it’s<br />
pointless for an app to retry an operation that’s unlikely to succeed, and instead should accept that<br />
the operation has failed and handle this failure accordingly.</p>
<p>The circuit breaker pattern can prevent an app from repeatedly trying to execute an operation that’s<br />
likely to fail, while also enabling the app to detect whether the fault has been resolved.</p>
<p>A circuit breaker acts as a proxy for operations that might fail. The proxy should monitor the number<br />
of recent failures that have occurred, and use this information to decide whether to allow the<br />
operation to proceed, or to return an exception immediately.</p>
<p>The eShop multi-platform app does not currently implement the circuit breaker pattern. However, the<br />
eShop does.</p>
<p>An app can combine the retry and circuit breaker patterns by using the retry pattern to invoke an<br />
operation through a circuit breaker. However, the retry logic should be sensitive to any exceptions<br />
returned by the circuit breaker and abandon retry attempts if the circuit breaker indicates that a fault<br />
is not transient.</p>
<p><a href="https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker">For more information about the circuit breaker pattern, see the Circuit Breaker pattern on Microsoft</a><br />
Docs.</p>
<p>71 CHAPTER 10 | Accessing remote data</p>
<h3>Summary</h3>
<p>Many modern web-based solutions make use of web services, hosted by web servers, to provide<br />
functionality for remote client applications. The operations that a web service exposes constitute a<br />
web API, and client apps should be able to utilize the web API without knowing how the data or<br />
operations that the API exposes are implemented.</p>
<p>The performance of an app can be improved by caching frequently accessed data to fast storage<br />
that’s located close to the app. Apps can implement read-through caching with the cache-aside<br />
pattern. This pattern determines whether the item is currently in the cache. If the item isn’t in the<br />
cache, it’s read from the data store and added to the cache.</p>
<p>When communicating with web APIs, apps must be sensitive to transient faults. Transient faults<br />
include the momentary loss of network connectivity to services, the temporary unavailability of a<br />
service, or timeouts that arise when a service is busy. These faults are often self-correcting, and if the<br />
action is repeated after a suitable delay, then it’s likely to succeed. Therefore, apps should wrap all<br />
attempts to access a web API in code that implements a transient fault handling mechanism.</p>
<p>72 CHAPTER 10 | Accessing remote data</p>
<p><strong>CHAPTER</strong></p>
<h1>11</h1>
<h2>Authentication and authorization</h2>
<p>Authentication is the process of obtaining identification credentials such as name and password from<br />
a user and validating those credentials against an authority. The entity that submitted the credentials<br />
is considered an authenticated identity if the credentials are valid. Once an identity has been<br />
established, an authorization process determines whether that identity has access to a given resource.</p>
<p>There are many approaches to integrating authentication and authorization into a .NET MAUI app that<br />
communicates with an ASP.NET web application, including using ASP.NET Core Identity, external<br />
authentication providers such as Microsoft, Google, Facebook, or Twitter, and authentication<br />
middleware. The eShop multi-platform app performs authentication and authorization with a<br />
containerized identity microservice that uses IdentityServer. The app requests security tokens from<br />
IdentityServer to authenticate a user or access a resource. For IdentityServer to issue tokens on behalf<br />
of a user, the user must sign in to IdentityServer. However, IdentityServer doesn’t provide a user<br />
interface or database for authentication. Therefore, in the eShop reference application, ASP.NET Core<br />
Identity is used for this purpose.</p>
<h3>Authentication</h3>
<p>Authentication is required when an application needs to know the current user’s identity. ASP.NET<br />
Core’s primary mechanism for identifying users is the ASP.NET Core Identity membership system,<br />
which stores user information in a data store configured by the developer. Typically, this data store<br />
will be an EntityFramework store, though custom stores or third-party packages can be used to store<br />
identity information in Azure storage, DocumentDB, or other locations.</p>
<p>For authentication scenarios that use a local user datastore and persist identity information between<br />
requests via cookies (as is typical in ASP.NET web applications), ASP.NET Core Identity is a suitable<br />
solution. However, cookies are not always a natural means of persisting and transmitting data. For<br />
example, an ASP.NET Core web application that exposes RESTful endpoints that are accessed from an<br />
app will typically need to use bearer token authentication since cookies can’t be used in this scenario.<br />
However, bearer tokens can easily be retrieved and included in the authorization header of web<br />
requests made from the app.</p>
<p>73 CHAPTER 11 | Authentication and authorization</p>
<h4><strong>Issuing bearer tokens using IdentityServer</strong></h4>
<p><a href="https://github.com/DuendeSoftware/IdentityServer">IdentityServer</a> is an open-source OpenID Connect and OAuth 2.0 framework for ASP.NET Core, which<br />
can be used for many authentication and authorization scenarios, including issuing security tokens for<br />
local ASP.NET Core Identity users.</p>
<p>OpenID Connect is an authentication layer on top of the OAuth 2.0 protocol. OAuth 2 is a protocol<br />
that allows applications to request access tokens from a security token service and use them to<br />
communicate with APIs. This delegation reduces complexity in both client applications and APIs since<br />
authentication and authorization can be centralized.</p>
<p>OpenID Connect and OAuth 2.0 combine the two fundamental security concerns of authentication<br />
and API access, and IdentityServer is an implementation of these protocols.</p>
<p>In applications that use direct client-to-microservice communication, such as the eShop reference<br />
application, a dedicated authentication microservice acting as a Security Token Service (STS) can be<br />
used to authenticate users, as shown in the following diagram. For more information about direct<br />
client-to-microservice communication, see Microservices.</p>
<p>The eShop multi-platform app communicates with the identity microservice, which uses IdentityServer<br />
to perform authentication, and access control for APIs. Therefore, the multi-platform app requests<br />
tokens from IdentityServer, either for authenticating a user or for accessing a resource:</p>
<ul>
<li>
<p>Authenticating users with IdentityServer is achieved by the multi-platform app requesting an<br />
<em>identity</em> token, representing an authentication process’s outcome. At a minimum, it contains<br />
an identifier for the user and information about how and when the user is authenticated. It<br />
can also include additional identity data.</p>
</li>
<li>
<p>Accessing a resource with IdentityServer is achieved by the multi-platform app requesting an<br />
<em>access</em> token, which allows access to an API resource. Clients request access tokens and<br />
forward them to the API. Access tokens contain information about the client and the user, if<br />
present. APIs then use that information to authorize access to their data.</p>
</li>
</ul>
<p>74 CHAPTER 11 | Authentication and authorization</p>
<h4><strong>Adding IdentityServer to a web application</strong></h4>
<p>In order for an ASP.NET Core web application to use IdentityServer, it must be added to the web<br />
<a href="https://docs.duendesoftware.com/identityserver/v7/quickstarts/">application’s Visual Studio solution. For more information, see Setup and Overview</a> in the<br />
IdentityServer documentation. Once IdentityServer is included in the web application’s Visual Studio<br />
solution, it must be added to its HTTP request processing pipeline to serve requests to OpenID<br />
Connect and OAuth 2.0 endpoints. This is configured in the Identity.API project’s Program.cs, as<br />
demonstrated in the following code example:</p>
<p>Order matters in the web application’s HTTP request processing pipeline. Therefore, IdentityServer<br />
must be added to the pipeline before the UI framework that implements the login screen.</p>
<h4><strong>Configuring IdentityServer</strong></h4>
<p>IdentityServer should be configured in the ConfigureServices method in the web application’s Startup<br />
class by calling the services.AddIdentityServer method, as demonstrated in the following code<br />
example from the eShop reference application:</p>
<p>After calling the services.AddIdentityServer method, additional fluent APIs are called to configure the<br />
following:</p>
<ul>
<li>
<p>Credentials used for signing.</p>
</li>
<li>
<p>API and identity resources that users might request access to.</p>
</li>
<li>
<p>Clients that will be connecting to request tokens.</p>
</li>
<li>
<p>ASP.NET Core Identity.</p>
</li>
</ul>
<p>75 CHAPTER 11 | Authentication and authorization</p>
<p><a href="https://docs.duendesoftware.com/identityserver/v7/quickstarts/5_aspnetid/">For information about configuring IdentityServer to use ASP.NET Core Identity, see Using ASP.NET</a><br />
<a href="https://docs.duendesoftware.com/identityserver/v7/quickstarts/5_aspnetid/">Core Identity</a> in the IdentityServer documentation.</p>
<h4><strong>Configuring API resources</strong></h4>
<p>When configuring API resources, the AddInMemoryApiResources method expects an<br />
IEnumerable<ApiResource> collection. The following code example shows the GetApis method that<br />
provides this collection in the eShop reference application:</p>
<p>This method specifies that IdentityServer should protect the orders and basket APIs. Therefore,<br />
IdentityServer-managed access tokens will be required when making calls to these APIs. For more<br />
<a href="https://docs.duendesoftware.com/identityserver/v7/fundamentals/resources/api_resources/">information about the ApiResource type, see API Resource</a> in the IdentityServer documentation.</p>
<h4><strong>Configuring identity resources</strong></h4>
<p>When configuring identity resources, the AddInMemoryIdentityResources method expects an<br />
IEnumerable<IdentityResource> collection. Identity resources are data such as user ID, name, or email<br />
address. Each identity resource has a unique name, and arbitrary claim types can be assigned to it,<br />
which will be included in the identity token for the user. The following code example shows the<br />
GetResources method that provides this collection in the eShop reference application:</p>
<p><a href="https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims">The OpenID Connect specification specifies some standard identity resources. The minimum</a><br />
requirement is that support is provided for emitting a unique ID for users. This is achieved by<br />
exposing the IdentityResources.OpenId identity resource.</p>
<p><a href="https://identityserver4.readthedocs.io/en/latest/topics/resources.html#defining-custom-identity-resources">IdentityServer also supports defining custom identity resources. For more information, see Defining</a><br />
<a href="https://identityserver4.readthedocs.io/en/latest/topics/resources.html#defining-custom-identity-resources">custom identity resources in the IdentityServer documentation. For more information about the</a><br />
<a href="https://docs.duendesoftware.com/identityserver/v7/fundamentals/resources/identity/">IdentityResource type, see Identity Resource</a> in the IdentityServer documentation.</p>
<p>76 CHAPTER 11 | Authentication and authorization</p>
<h4><strong>Configuring clients</strong></h4>
<p>Clients are applications that can request tokens from IdentityServer. Typically, the following settings<br />
must be defined for each client as a minimum:</p>
<ul>
<li>
<p>A unique client ID.</p>
</li>
<li>
<p>The allowed interactions with the token service (known as the grant type).</p>
</li>
<li>
<p>The location where identity and access tokens are sent to (known as a redirect URI).</p>
</li>
<li>
<p>A list of resources that the client is allowed access to (known as scopes).</p>
</li>
</ul>
<p>When configuring clients, the AddInMemoryClients method expects an IEnumerable<Client><br />
collection. The following code example shows the configuration for the eShop multi-platform app in<br />
the GetClients method that provides this collection in the eShop reference application:</p>
<p>This configuration specifies data for the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClientId</td>
<td>A unique ID for the client.</td>
</tr>
<tr>
<td>ClientName</td>
<td>The client display name, which is used for<br>logging and the consent screen.</td>
</tr>
</tbody>
</table>
<p>77 CHAPTER 11 | Authentication and authorization</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AllowedGrantTypes</td>
<td>Specifies how a client wants to interact with<br>IdentityServer. For more information see<br>Configuring the authentication flow.</td>
</tr>
<tr>
<td>ClientSecrets</td>
<td>Specifies the client secret credentials that are<br>used when requesting tokens from the token<br>endpoint.</td>
</tr>
<tr>
<td>RedirectUris</td>
<td>Specifies the allowed URIs to which to return<br>tokens or authorization codes.</td>
</tr>
<tr>
<td>RequireConsent</td>
<td>Specifies whether a consent screen is required.</td>
</tr>
<tr>
<td>RequirePkce</td>
<td>Specifies whether clients using an authorization<br>code must send a proof key.</td>
</tr>
<tr>
<td>PostLogoutRedirectUris</td>
<td>Specifies the allowed URIs to redirect to after<br>logout.</td>
</tr>
<tr>
<td>AllowedCorsOrigins</td>
<td>Specifies the origin of the client so that<br>IdentityServer can allow cross-origin calls from<br>the origin.</td>
</tr>
<tr>
<td>AllowedScopes</td>
<td>Specifies the resources the client has access to.<br>By default, a client has no access to any<br>resources.</td>
</tr>
<tr>
<td>AllowOfflineAccess</td>
<td>Specifies whether the client can request refresh<br>tokens.</td>
</tr>
<tr>
<td>AllowAccessTokensViaBrowser</td>
<td>Specifies whether the client can receive access<br>tokens from a browser window.</td>
</tr>
<tr>
<td>AlwaysIncludeUserClaimsInIdToken</td>
<td>Specifies that the user claims will always be<br>added to the id token. By default, these would<br>have to be retrieved using the userinfo<br>endpoint.</td>
</tr>
<tr>
<td>AccessTokenLifetime</td>
<td>Specifies the lifetime of the access token in<br>seconds.</td>
</tr>
<tr>
<td>IdentityTokenLifetime</td>
<td>Specifies the lifetime of the identity token in<br>seconds.</td>
</tr>
</tbody>
</table>
<h4><strong>Configuring the authentication flow</strong></h4>
<p>The authentication flow between a client and IdentityServer can be configured by specifying the grant<br />
types in the Client.AllowedGrantTypes property. The OpenID Connect and OAuth 2.0 specifications<br />
define several authentication flows, including:</p>
<p>78 CHAPTER 11 | Authentication and authorization</p>
<table>
<thead>
<tr>
<th>Authentication Flow</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implicit</td>
<td>This flow is optimized for browser-based<br>applications and should be used either for user<br>authentication-only, or authentication and<br>access token requests. All tokens are<br>transmitted via the browser, and therefore<br>advanced features like refresh tokens are not<br>permitted.</td>
</tr>
<tr>
<td>Authorization code</td>
<td>This flow provides the ability to retrieve tokens<br>on a back channel, as opposed to the browser<br>front channel, while also supporting client<br>authentication.</td>
</tr>
<tr>
<td>Hybrid</td>
<td>This flow is a combination of the implicit and<br>authorization code grant types. The identity<br>token is transmitted via the browser channel<br>and contains the signed protocol response and<br>other artifacts such as the authorization code.<br>After successfully validating the response, the<br>back channel should be used to retrieve the<br>access and refresh token.</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.duendesoftware.com/identityserver/v7/data/operational/grants/">For more information about authentication flows, see Grant Types</a> in the IdentityServer<br />
documentation.</p>
<h4><strong>Performing authentication</strong></h4>
<p>For IdentityServer to issue tokens on behalf of a user, the user must sign in to IdentityServer. However,<br />
IdentityServer doesn’t provide a user interface or database for authentication. Therefore, in the eShop<br />
reference application, ASP.NET Core Identity is used for this purpose.</p>
<p>The eShop multi-platform app authenticates with IdentityServer with the hybrid authentication flow,<br />
which is illustrated in the diagram below.</p>
<p>79 CHAPTER 11 | Authentication and authorization</p>
<p>A sign in request is made to <base endpoint>:5105/connect/authorize. Following successful<br />
authentication, IdentityServer returns an authentication response containing an authorization code<br />
and an identity token. The authorization code is sent to <base endpoint>:5105/connect/token, which<br />
responds with access, identity, and refresh tokens.</p>
<p>The eShop multi-platform app signs out of IdentityServer by sending a request to <base
endpoint>:5105/connect/endsession with additional parameters. After sign-out, IdentityServer<br />
responds by sending a post-logout redirecting URI back to the multi-platform app. The diagram<br />
below illustrates this process.</p>
<p>In the eShop multi-platform app, communication with IdentityServer is performed by the<br />
IdentityService class, which implements the IIdentityService interface. This interface specifies that the<br />
implementing class must provide SignInAsync, SignOutAsync, GetUserInfoAsync and<br />
GetAuthTokenAsync methods.</p>
<h4><strong>Signing-in</strong></h4>
<p>When the user taps the LOGIN button on the LoginView, the SignInCommand in the LoginViewModel<br />
class is executed, which in turn executes the SignInAsync method. The following code example shows<br />
this method:</p>
<p>80 CHAPTER 11 | Authentication and authorization</p>
<p>This method invokes the SignInAsync method in the IdentityService class, as shown in the following<br />
code example:</p>
<p>The IdentityService makes use of the OidcClient provided with the IdentityModel.OidcClient NuGet<br />
package. This client displays the authentication web view to the user in the application and captures<br />
<a href="https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/authorize/">the authentication result. The client connects to the URI for IdentityServer’s authorization endpoint</a><br />
with the required parameters. The authorization endpoint is at /connect/authorize on port 5105 of the<br />
base endpoint exposed as a user setting. For more information about user settings, see Configuration<br />
Management.</p>
<p>81 CHAPTER 11 | Authentication and authorization</p>
<p>If the token endpoint receives valid authentication information, authorization code, and PKCE secret<br />
verifier, it responds with an access token, identity token, and refresh token. The access token (which<br />
allows access to API resources) and identity token are stored as application settings, and page<br />
navigation is performed. Therefore, the overall effect in the eShop multi-platform app is this: provided<br />
that users are able to successfully authenticate with IdentityServer, they are navigated to the<br />
//Main/Catalog route, which is a TabbedPage that displays the CatalogView as its selected tab.</p>
<p>82 CHAPTER 11 | Authentication and authorization</p>
<p>For information about page navigation, see Navigation. For information about how WebView<br />
navigation causes a view model method to be executed, see Invoking navigation using behaviors. For<br />
information about application settings, see Configuration management.</p>
<h4><strong>Signing-out</strong></h4>
<p>When the user taps the LOG OUT button in the ProfileView, the LogoutCommand in the<br />
ProfileViewModel class is executed, which executes the LogoutAsync method. This method performs<br />
page navigation to the LoginView page, passing a Logout query parameter set to true.</p>
<p>That parameter is evaluated in the ApplyQueryAttributes method. If the Logout parameter is present<br />
with a true value, the PerformLogoutAsync method of the LoginViewModel class is executed, which is<br />
shown in the following code example:</p>
<p>This method invokes the SignOutAsync method in the IdentityService class, which invokes the<br />
OidcClient to end the user’s session and clears any saved user tokens. For more information about<br />
application settings, see Configuration management. The following code example shows the<br />
SignOutAsync method:</p>
<p><a href="https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/end_session/">This method uses the OidcClient to call the URI to IdentityServer’s end session endpoint with the</a><br />
required parameters. The end session endpoint is at /connect/endsession on port 5105 of the base<br />
endpoint exposed as a user setting. Once the user has successfully signed out, LoginView is presented<br />
to the user, and any saved user information will be cleared.</p>
<p>83 CHAPTER 11 | Authentication and authorization</p>
<p>For information about page navigation, see Navigation. For information about how WebView<br />
navigation causes a view model method to be executed, see Invoking navigation using behaviors. For<br />
information about application settings, see Configuration management.</p>
<h3>Authorization</h3>
<p>After authentication, ASP.NET Core web APIs often need to authorize access, which allows a service to<br />
make APIs available to some authenticated users but not to all.</p>
<p>Restricting access to an ASP.NET Core route can be achieved by applying an Authorize attribute to a<br />
controller or action, which limits access to the controller or action to authenticated users, as shown in<br />
the following code example:</p>
<p>If an unauthorized user attempts to access a controller or action marked with the Authorize attribute,<br />
the API framework returns a 401 (unauthorized) HTTP status code.</p>
<p>IdentityServer can be integrated into the authorization workflow so that the access tokens provide<br />
control authorization. This approach is shown in the diagram below.</p>
<p>84 CHAPTER 11 | Authentication and authorization</p>
<p>The eShop multi-platform app communicates with the identity microservice and requests an access<br />
token as part of the authentication process. The access token is then forwarded to the APIs exposed<br />
by the ordering and basket microservices as part of the access requests. Access tokens contain<br />
information about the client and the user. APIs then use that information to authorize access to their<br />
data. For information about how to configure IdentityServer to protect APIs, see Configuring API<br />
resources.</p>
<h3>Configuring IdentityServer to perform authorization</h3>
<p>To perform authorization with IdentityServer, its authorization middleware must be added to the web<br />
application’s HTTP request pipeline. The middleware is added in the AddDefaultAuthentication<br />
extension method, which is invoked from the AddApplicationServices method in the Program class<br />
and is demonstrated in the following code example from the eShop reference application:</p>
<p>85 CHAPTER 11 | Authentication and authorization</p>
<p>This method ensures that the API can only be accessed with a valid access token. The middleware<br />
validates the incoming token to ensure that it’s sent from a trusted issuer and validates that the token<br />
is valid to be used with the API that receives it. Therefore, browsing to the ordering or basket<br />
controller will return a 401 (unauthorized) HTTP status code, indicating that an access token is<br />
required.</p>
<h3>Making access requests to APIs</h3>
<p>When making requests to the ordering and basket microservices, the access token obtained from<br />
IdentityServer during the authentication process must be included in the request, as shown in the<br />
following code example:</p>
<p>The access token is stored with the IIdentityService implementation and can be retrieved using the<br />
GetAuthTokenAsync method.</p>
<p>Similarly, the access token must be included when sending data to an IdentityServer protected API, as<br />
shown in the following code example:</p>
<p>86 CHAPTER 11 | Authentication and authorization</p>
<p>The access token is retrieved from the IIdentityService and included in the call to the ClearBasketAsync<br />
method in the BasketService class.</p>
<p>The RequestProvider class in the eShop multi-platform app uses the HttpClient class to make requests<br />
to the RESTful APIs exposed by the eShop reference application. When making requests to the<br />
ordering and basket APIs, which require authorization, a valid access token must be included with the<br />
request. This is achieved by adding the access token to the headers of the HttpClient instance, as<br />
demonstrated in the following code example:</p>
<p>The DefaultRequestHeaders property of the HttpClient class exposes the headers that are sent with<br />
each request, and the access token is added to the Authorization header prefixed with the string<br />
Bearer. When the request is sent to a RESTful API, the value of the Authorization header is extracted<br />
and validated to ensure that it’s sent from a trusted issuer and used to determine whether the user<br />
has permission to invoke the API that receives it.</p>
<p>For more information about how the eShop multi-platform app makes web requests, see Accessing<br />
remote data.</p>
<h3>Summary</h3>
<p>There are many approaches to integrating authentication and authorization into a .NET MAUI app that<br />
communicates with an ASP.NET web application. The eShop multi-platform app performs<br />
authentication and authorization with a containerized identity microservice that uses IdentityServer.<br />
IdentityServer is an open-source OpenID Connect and OAuth 2.0 framework for ASP.NET Core that<br />
integrates with ASP.NET Core Identity to perform bearer token authentication.</p>
<p>The multi-platform app requests security tokens from IdentityServer to authenticate a user or access a<br />
resource. When accessing a resource, an access token must be included in the request to APIs that<br />
require authorization. IdentityServer’s middleware validates incoming access tokens to ensure that<br />
they are sent from a trusted issuer and that they are valid to be used with the API that receives them.</p>
<p>87 CHAPTER 11 | Authentication and authorization</p>
<p><strong>CHAPTER</strong></p>
<h1>12</h1>
<h2>MVVM Toolkit Features</h2>
<h3>MVVM Toolkit</h3>
<p>The Model-View-ViewModel (MVVM) pattern is a great structural basis for creating our applications.<br />
In this pattern, the ViewModel becomes the backbone of our application as it provides<br />
communication to our front-end user interface and backing components. To provide integration with<br />
the user interface, we will rely on the ViewModel’s properties and commands. As detailed in Updating<br />
views in response to changes in the underlying view model or model, the INotifyPropertyChanged<br />
interface on our ViewModel to allows changes to our properties to notify when the value is changed.<br />
Implementing all of these features means that our ViewModel can end up becoming very verbose. For<br />
example, the following code shows a simple ViewModel with properties that raise changes:</p>
<p>88 CHAPTER 12 | MVVM Toolkit Features</p>
<p>While some optimizations could be made over time, we will still end up with a fairly verbose set of<br />
code for defining our ViewModel. This code can be difficult to maintain and becomes error-prone.</p>
<p><a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/">The CommunityToolkit.Mvvm NuGet Package (aka MVVM Toolkit) can be used to help address and</a><br />
simplify these common MVVM patterns. The MVVM Toolkit, along with newer features to the .NET<br />
language, allows for simplified logic, easy adoption into a project, and runtime independence. The<br />
example below shows the same ViewModel using components that come with the MVVM Toolkit:</p>
<p>In comparison to the original example, we were able to drastically reduce the overall complexity and<br />
simplify the maintainability of our ViewModel. The MVVM Toolkit comes with many pre-built common<br />
components and features, such as the ObservableObject shown above, that simplifies and<br />
standardizes the code that we have throughout the application.</p>
<h3>ObservableObject</h3>
<p>The MVVM Toolkit provides ObservableObject which is intended for use as the base of our<br />
ViewModel objects or any object that needs to raise change notifications. It implements<br />
INotifyPropertyChanged and INotifyPropertyChanging along with helper methods for setting<br />
properties and raising changes. Below is an example of a standard ViewModel using<br />
ObservableObject:</p>
<p>89 CHAPTER 12 | MVVM Toolkit Features</p>
<p>ObservableObject handles all of the logic needed for raising change notifications by using the<br />
SetProperty method in your property setter. If you have a property that returns a Task<T>, the<br />
SetPropertyAndNotifyOnCompletion method can be used to delay publishing a property change until<br />
the task has been completed. The methods OnPropertyChanged and OnPropertyChanging that can<br />
also be used for raising property changes where needed in your object.</p>
<p><a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/observableobject">For more detailed information on ObservableObject, see ObservableObject</a> in the MVVM Toolkit<br />
Developer Center.</p>
<h3>RelayCommand and AsyncRelayCommand</h3>
<p>Interaction between .NET MAUI controls (for example, tapping a button or selecting an item from a<br />
collection) and the ViewModel is done with the ICommand interface. .NET MAUI comes with a default<br />
implementation of ICommand with the Command object. .NET MAUI’s Command is fairly basic and<br />
lacks support for more advanced features, such as supporting asynchronous work and command<br />
execution status.</p>
<p>The MVVM Toolkit comes with two commands, RelayCommand and AsyncRelayCommand.<br />
RelayCommand is intended for situations where you have synchronous code to execute and has a<br />
fairly similar implementation to the .NET MAUI Command object.</p>
<p>AsyncRelayCommand provides many additional features when working with asynchronous workflows.<br />
This is quite common in our ViewModel as we are typically communicating with repositories, APIs,<br />
databases, and other systems that utilize async/await. The AsyncRelayCommand constructor takes in<br />
an execution task defined as a Func<Task> or a delegate returning Task as part of the constructor.<br />
While the execution task is running, AsyncRelayCommand will monitor the state of the task and<br />
provides updates using the IsRunning property. The IsRunning property can be bound to the UI which<br />
helps manage control states such as showing loading with an ActivityIndicator or disabling/enabling a<br />
control. While the execution task is being executed, the Cancel method can be called to attempt<br />
cancellation of the execution task, if supported.</p>
<p>By default, AsyncRelayCommand doesn’t allow concurrent execution. This is very helpful in situations<br />
where a user could unintentionally tap a control multiple times to execute a long-running or costly<br />
operation. During task execution, AsyncRelayCommand will automatically call the CanExecuteChanged<br />
event. In .NET MAUI, controls that support the Command and CommandParameter properties, such as<br />
Button, will listen to this event and automatically enable or disable it during execution. This<br />
functionality can be overridden by using a custom canExecute parameter or setting the<br />
AsyncRelayCommandOptions.AllowConcurrentExecutions flag in the constructor.</p>
<p>90 CHAPTER 12 | MVVM Toolkit Features</p>
<p>For more detailed information on implementing commands, see the section Implementing commands<br />
in the MVVM chapter. Detailed information for the RelayCommand and AsyncRelayCommand is<br />
<a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/relaycommand">available in the Commanding of the MVVM Toolkit Developer Center.</a></p>
<h3>Source Generators</h3>
<p>Using the MVVM Toolkit components out-of-the-box allows you to greatly simplify our ViewModel.<br />
<a href="https://docs.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview">The MVVM Toolkit allows you to simplify common code use cases even further by using Source</a><br />
<a href="https://docs.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview">Generators. The MVVM Toolkit source generators look for specific attributes in our code and can</a><br />
generate wrappers for properties and commands.</p>
<p>The MVVM Toolkit ObservableProperty attribute can be applied to fields in objects that inherit from<br />
ObservableObject and will wrap a private field with a property that generates changes. The following<br />
code shows an example of using the ObservableObject attribute on the _name field:</p>
<p>With the ObservableProperty attribute applied to the _name field, the source generator will run and<br />
generate another partial class with the following code:</p>
<p>The generated SampleViewModel has used the private _name field and generated a new Name<br />
property that implements all of the logic needed for raising change notifications.</p>
<p>91 CHAPTER 12 | MVVM Toolkit Features</p>
<p>The MVVM Toolkit RelayCommand attribute can be applied to methods within an ObservableObject<br />
and will create a corresponding RelayCommand or AsyncRelayCommand. The following code shows<br />
examples of using the RelayCommand attribute:</p>
<p>The RelayCommand applied to the Validate method will generate a RelayCommand validate<br />
ValidateCommand because it has a void return and the SettingsAsync method will generate an<br />
AsyncRelayCommand named SettingsCommand. The source generator will generate the following<br />
code in other partial classes:</p>
<p>All of the complexity of wrapping our ViewModel’s methods with an ICommand implementation has<br />
been handled by the source generator.</p>
<p><a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview">For more detailed information on MVVM Toolkit Source Generators, see MVVM source generators in</a><br />
the MVVM Toolkit Developer Center.</p>
<p>92 CHAPTER 12 | MVVM Toolkit Features</p>
<h3>Summary</h3>
<p>The MVVM Toolkit is a great way to standardize and simplify our ViewModel code. The MVVM toolkit<br />
offers great implementations of standard MVVM components such as ObservableObject and<br />
Async/RelayCommand. The source generators help simplify our ViewModel properties and commands<br />
by generating all of the boilerplate code needed for user interface interactions. The MVVM Toolkit<br />
offers even more features outside of what has been shown in this chapter. For more information on<br />
<a href="https://docs.microsoft.com/dotnet/communitytoolkit/mvvm/">the MVVM Toolkit, see Introduction to the MVVM Toolkit</a> in the MVVM Toolkit Developer Center.</p>
<p>93 CHAPTER 12 | MVVM Toolkit Features</p>
<p><strong>CHAPTER</strong></p>
<h1>13</h1>
<h2>Unit testing</h2>
<p>multi-platform apps experience problems similar to both desktop and web-based applications. Mobile<br />
users will differ by their devices, network connectivity, availability of services, and various other factors.<br />
Therefore, multi-platform apps should be tested as they would be used in the real world to improve<br />
their quality, reliability, and performance. Many types of testing should be performed on an app,<br />
including unit testing, integration testing, and user interface testing. Unit testing is the most common<br />
form and essential to building high-quality applications.</p>
<p>A unit test takes a small unit of the app, typically a method, isolates it from the remainder of the code,<br />
and verifies that it behaves as expected. Its goal is to check that each unit of functionality performs as<br />
expected, so errors don’t propagate throughout the app. Detecting a bug where it occurs is more<br />
efficient that observing the effect of a bug indirectly at a secondary point of failure.</p>
<p>Unit testing has the most significant effect on code quality when it’s an integral part of the software<br />
development workflow. Unit tests can act as design documentation and functional specifications for<br />
an application. As soon as a method has been written, unit tests should be written that verify the<br />
method’s behavior in response to standard, boundary, and incorrect input data cases and check any<br />
explicit or implicit assumptions made by the code. Alternatively, with test-driven development, unit<br />
tests are written before the code. For more information on test-driven development and how to<br />
<a href="https://docs.microsoft.com/visualstudio/test/quick-start-test-driven-development-with-test-explorer">implement it, see Walkthrough: Test-driven development using Test Explorer.</a></p>
<p>Unit tests typically use the arrange-act-assert pattern:</p>
<table>
<thead>
<tr>
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arrange</td>
<td>Initializes objects and sets the value of the data<br>that is passed to the method under test.</td>
</tr>
<tr>
<td>Act</td>
<td>Invokes the method under test with the required<br>arguments.</td>
</tr>
<tr>
<td>Assert</td>
<td>Verifies that the action of the method under test<br>behaves as expected.</td>
</tr>
</tbody>
</table>
<p>This pattern ensures that unit tests are readable, self-describing, and consistent.</p>
<p>94 CHAPTER 13 | Unit testing</p>
<h3>Dependency injection and unit testing</h3>
<p>One of the motivations for adopting a loosely-coupled architecture is that it facilitates unit testing.<br />
One of the types registered with the dependency injection service is the IAppEnvironmentService<br />
interface. The following code example shows an outline of this class:</p>
<p>The OrderDetailViewModel class has a dependency on the IAppEnvironmentService type, which the<br />
dependency injection container resolves when it instantiates an OrderDetailViewModel object.<br />
However, rather than create an IAppEnvironmentService object which utilizes real servers, devices and<br />
configurations to unit test the OrderDetailViewModel class, instead, replace the<br />
IAppEnvironmentService object with a mock object for the purpose of the tests. A mock object is one<br />
that has the same signature of an object or an interface, but is created in a specific manner to help<br />
with unit testing. It is often used with dependency injection to provide specific implementations of<br />
interfaces for testing different data and workflow scenarios.</p>
<p>This approach allows the IAppEnvironmentService object to be passed into the OrderDetailViewModel<br />
class at runtime, and in the interests of testability, it allows a mock class to be passed into the<br />
OrderDetailViewModel class at test time. The main advantage of this approach is that it enables unit<br />
tests to be executed without requiring unwieldy resources such as runtime platform features, web<br />
services, or databases.</p>
<h3>Testing MVVM applications</h3>
<p>Testing models and view models from MVVM applications is identical to testing any other class, and<br />
uses the same tools and techniques; this includes features such as unit testing and mocking. However,<br />
some patterns that are typical to model and view model classes can benefit from specific unit testing<br />
techniques.</p>
<p><a href="https://docs.microsoft.com/dotnet/core/testing/unit-testing-best-practices">Unit testing best practices with .NET for more best practices.</a></p>
<p>95 CHAPTER 13 | Unit testing</p>
<p>Don’t be tempted to make a unit test exercise more than one aspect of the unit’s behavior. Doing so<br />
leads to tests that are difficult to read and update. It can also lead to confusion when interpreting a<br />
failure.</p>
<p><a href="https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-mstest">The eShop multi-platform app uses MSTest</a> to perform unit testing, which supports two different</p>
<table>
<thead>
<tr>
<th>types of unit tests:</th>
<th>Col2</th>
<th>Col3</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Testing Type</strong></td>
<td><strong>Attribute</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>TestMethod</td>
<td>TestMethod</td>
<td>Defines the actual test method to run..</td>
</tr>
<tr>
<td>DataSource</td>
<td>DataSource</td>
<td>Tests that are only true for a particular set of data.</td>
</tr>
</tbody>
</table>
<p>The unit tests included with the eShop multi-platform app are TestMethod, so each unit test method<br />
is decorated with the TestMethod attribute. In addition to MSTest there are several other testing<br />
<a href="https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-nunit">frameworks available including NUnit</a> <a href="https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test">and xUnit.</a></p>
<h3>Testing asynchronous functionality</h3>
<p>When implementing the MVVM pattern, view models usually invoke operations on services, often<br />
asynchronously. Tests for code that invokes these operations typically use mocks as replacements for<br />
the actual services. The following code example demonstrates testing asynchronous functionality by<br />
passing a mock service into a view model:</p>
<p>This unit test checks that the Order property of the OrderDetailViewModel instance will have a value<br />
after the InitializeAsync method has been invoked. The InitializeAsync method is invoked when the<br />
view model’s corresponding view is navigated to. For more information about navigation, see<br />
Navigation.</p>
<p>When the OrderDetailViewModel instance is created, it expects an IOrderService instance to be<br />
specified as an argument. However, the OrderService retrieves data from a web service. Therefore, an<br />
OrderMockService instance, a mock version of the OrderService class, is specified as the argument to<br />
the OrderDetailViewModel constructor. Then, mock data is retrieved rather than communicating with<br />
a web service when the view model’s InitializeAsync method is invoked, which uses IOrderService<br />
operations.</p>
<p>96 CHAPTER 13 | Unit testing</p>
<h3>Testing INotifyPropertyChanged implementations</h3>
<p>Implementing the INotifyPropertyChanged interface allows views to react to changes that originate<br />
from view models and models. These changes are not limited to data shown in controls – they are also<br />
used to control the view, such as view model states that cause animations to be started or controls to<br />
be disabled.</p>
<p>Properties that can be updated directly by the unit test can be tested by attaching an event handler to<br />
the PropertyChanged event and checking whether the event is raised after setting a new value for the<br />
property. The following code example shows such a test:</p>
<p>This unit test invokes the InitializeAsync method of the OrderViewModel class, which causes its Order<br />
property to be updated. The unit test will pass, provided that the PropertyChanged event is raised for<br />
the Order property.</p>
<h3>Testing message-based communication</h3>
<p>View models that use the MessagingCenter class to communicate between loosely coupled classes<br />
can be unit tested by subscribing to the message being sent by the code under test, as demonstrated<br />
in the following code example:</p>
<p>97 CHAPTER 13 | Unit testing</p>
<p>This unit test checks that the CatalogViewModel publishes the AddProduct message in response to its<br />
AddCatalogItemCommand being executed. Because the MessagingCenter class supports multicast<br />
message subscriptions, the unit test can subscribe to the AddProduct message and execute a callback<br />
delegate in response to receiving it. This callback delegate, specified as a lambda expression, sets a<br />
boolean field that’s used by the Assert statement to verify the behavior of the test.</p>
<h3>Testing exception handling</h3>
<p>Unit tests can also be written that check that specific exceptions are thrown for invalid actions or<br />
inputs, as demonstrated in the following code example:</p>
<p>This unit test will throw an exception because the ListView control does not have an event named<br />
OnItemTapped. The Assert.Throws<T> method is a generic method where T is the type of the<br />
expected exception. The argument passed to the Assert.Throws<T> method is a lambda expression<br />
that will throw the exception. Therefore, the unit test will pass provided that the lambda expression<br />
throws an ArgumentException.</p>
<h3>Testing validation</h3>
<p>There are two aspects to testing the validation implementation: testing that any validation rules are<br />
correctly implemented and testing that the ValidatableObject<T> class performs as expected.</p>
<p>Validation logic is usually simple to test, because it is typically a self-contained process where the<br />
output depends on the input. There should be tests on the results of invoking the Validate method on<br />
each property that has at least one associated validation rule, as demonstrated in the following code<br />
example:</p>
<p>98 CHAPTER 13 | Unit testing</p>
<p>This unit test checks that validation succeeds when the two ValidatableObject<T> properties in the<br />
MockViewModel instance both have data.</p>
<p>As well as checking that validation succeeds, validation unit tests should also check the values of the<br />
Value, IsValid, and Errors property of each ValidatableObject<T> instance, to verify that the class<br />
performs as expected. The following code example demonstrates a unit test that does this:</p>
<p>This unit test checks that validation fails when the Surname property of the MockViewModel doesn’t<br />
have any data, and the Value, IsValid, and Errors property of each ValidatableObject<T> instance are<br />
correctly set.</p>
<h3>Summary</h3>
<p>A unit test takes a small unit of the app, typically a method, isolates it from the remainder of the code,<br />
and verifies that it behaves as expected. Its goal is to check that each unit of functionality performs as<br />
expected, so errors don’t propagate throughout the app.</p>
<p>The behavior of an object under test can be isolated by replacing dependent objects with mock<br />
objects that simulate the behavior of the dependent objects. This enables unit tests to be executed<br />
without requiring unwieldy resources such as runtime platform features, web services, or databases</p>
<p>Testing models and view models from MVVM applications is identical to testing any other classes, and<br />
the same tools and techniques can be used.</p>
<p>99 CHAPTER 13 | Unit testing</p>
