{"1": {"Tools and downloads": {"Prerequisites": "The following subscriptions are required:\n\n['[Azure \u2014 If you don\u2019t have an account, get a free trial.](https://azure.microsoft.com/free/dotnet/)', 'Azure DevOps Services \u2014 your Azure DevOps subscription and organization is created in\\nChapter 4.', '[GitHub \u2014 If you don\u2019t have an account, sign up for free.](https://github.com/join)']\n\nThe following tools are required:\n\n['[Git](https://git-scm.com/downloads)  - A fundamental understanding of Git is recommended for this guide. Review the Git\\n[documentation, specifically git remote](https://git-scm.com/doc) [and git push.](https://git-scm.com/docs/git-push)']\n\n['[.NET Core SDK](https://dotnet.microsoft.com/download/)  - Version 2.1.300 or later is required to build and run the sample app. If\\nVisual Studio is installed with the **.NET Core cross-platform development** workload, the\\n.NET Core SDK is already installed.']\n\nVerify your .NET Core SDK installation. Open a command shell, and run the following\ncommand:\n\n:::{custom-style=CodeBox} dotnetcli  dotnet --version :::", "Recommended tools (Windows only)": ["[Visual Studio\u2019s robust Azure tools provide a GUI for most of the functionality described in this](https://visualstudio.microsoft.com/)\nguide. Any edition of Visual Studio will work, including the free Visual Studio Community\nEdition. The tutorials are written to demonstrate development, deployment, and DevOps both\nwith and without Visual Studio."]}}, "2": {"Deploy an app to App Service": {"Download and test the app": "[The app used in this guide is a pre-built ASP.NET Core app, Simple Feed Reader. It\u2019s an ASP.NET Core](https://github.com/dotnet-architecture/simple-feed-reader/)\nRazor Pages app that uses the Microsoft.SyndicationFeed.ReaderWriter API to retrieve an RSS/Atom\nfeed and display the news items in a list.\n\nFeel free to review the code, but it\u2019s important to understand that there\u2019s nothing special about this\napp. It\u2019s just a simple ASP.NET Core app for illustrative purposes.\n\nFrom a command shell, download the code, build the project, and run it as follows.\n\n['Clone the code to a folder on your local machine.']\n\n3 CHAPTER 2 | Deploy an app to App Service\n\n:::{custom-style=CodeBox} console git clone https://github.com/dotnet-architecture/simplefeed-reader/ :::\n\n['Change your working folder to the _simple-feed-reader_ folder that was created.']\n\n:::{custom-style=CodeBox} console cd .\\simple-feed-reader\\SimpleFeedReader :::\n\n['Restore the packages, and build the solution.']\n\n:::{custom-style=CodeBox} dotnetcli dotnet build :::\n\n['Run the app.']\n\n:::{custom-style=CodeBox} dotnetcli dotnet run :::\n\n['Open a browser and navigate to http://localhost:5000. The app allows you to type or paste a\\nsyndication feed URL and view a list of news items.']\n\n4 CHAPTER 2 | Deploy an app to App Service\n\n['Once you\u2019re satisfied the app is working correctly, shut it down by pressing Ctrl+C in the\\ncommand shell.']", "Create the Azure App Service Web App": "[To deploy the app, you\u2019ll need to create an App Service Web App. After creation of the Web App,](https://docs.microsoft.com/azure/app-service/app-service-web-overview)\nyou\u2019ll deploy to it from your local machine using Git.\n\n['[Sign in to the Azure Cloud Shell. Note: When you sign in for the first time, Cloud Shell](https://shell.azure.com/bash)\\nprompts to create a storage account for configuration files. Accept the defaults or provide a\\nunique name.']\n\n['Use the Cloud Shell for the following steps.']\n\na. Declare a variable to store your web app\u2019s name. The name must be unique to be\nused in the default URL. Using the $RANDOM Bash function to construct the name\nguarantees uniqueness and results in the format webappname99999.\n\n:::{custom-style=CodeBox} console webappname=mywebapp$RANDOM :::\n\nb. Create a resource group. Resource groups provide a means to aggregate Azure\nresources to be managed as a group.\n\n:::{custom-style=CodeBox} azurecli az group create --location centralus --name AzureTutorial\n:::\n\n[The az command invokes the Azure CLI. The CLI can be run locally, but using it in the Cloud](https://docs.microsoft.com/cli/azure/)\nShell saves time and configuration.\n\nc. Create an App Service plan in the S1 tier. An App Service plan is a grouping of web\napps that share the same pricing tier. The S1 tier isn\u2019t free, but it\u2019s required for the\nstaging slots feature.\n\n:::{custom-style=CodeBox} azurecli az appservice plan create --name $webappname -resource-group AzureTutorial --sku S1 :::\n\nd. Create the web app resource using the App Service plan in the same resource group.\n\n:::{custom-style=CodeBox} azurecli az webapp create --name $webappname --resourcegroup AzureTutorial --plan $webappname :::\n\ne. Set the deployment branch to main in the appsettings configuration.\n\n:::{custom-style=CodeBox} azurecli az webapp config appsettings set --name $webappname -resource-group AzureTutorial --settings DEPLOYMENT_BRANCH=main :::\n\nf. Set the deployment credentials. These deployment credentials apply to all the web\napps in your subscription. Don\u2019t use special characters in the user name.\n\n:::{custom-style=CodeBox} azurecli az webapp deployment user set --user-name\nREPLACE_WITH_USER_NAME --password REPLACE_WITH_PASSWORD :::\n\n5 CHAPTER 2 | Deploy an app to App Service\n\ng. Configure the web app to accept deployments from local Git and display the _Git_\n_deployment URL_ . **Note this URL for reference later** .\n\n:::{custom-style=CodeBox} azurecli echo Git deployment URL: $(az webapp deployment\nsource config-local-git --name $webappname --resource-group AzureTutorial --query url -output tsv) :::\n\nh. Display the _web app URL_ . Browse to this URL to see the blank web app. **Note this**\n**URL for reference later** .\n\n:::{custom-style=CodeBox} console echo Web app URL:\nhttp://$webappname.azurewebsites.net :::\n\n['Using a command shell on your local machine, navigate to the web app\u2019s project folder (for\\nexample, *.-feed-reader). Execute the following commands to set up Git to push to the\\ndeployment URL:']\n\na. Add the remote URL to the local repository.\n\n:::{custom-style=CodeBox} console git remote add azure-prod GIT_DEPLOYMENT_URL :::\n\nb. Push the local default branch ( _main_ ) to the _azure-prod_ remote\u2019s deployment branch\n( _main_ ).\n\n:::{custom-style=CodeBox} console git push azure-prod main :::\n\nYou\u2019ll be prompted for the deployment credentials you created earlier. Observe the output in\nthe command shell. Azure builds the ASP.NET Core app remotely.\n\n['In a browser, navigate to the _Web app URL_ and note the app has been built and deployed.\\nAdditional changes can be committed to the local Git repository with git commit. These\\nchanges are pushed to Azure with the preceding git push command.']", "Deployment with Visual Studio": "The app has already been deployed from the command shell. Let\u2019s use Visual Studio\u2019s integrated tools\nto deploy an update to the app. Behind the scenes, Visual Studio accomplishes the same thing as the\ncommand line tooling, but within Visual Studio\u2019s familiar UI.\n\n['Open _SimpleFeedReader.sln_ in Visual Studio.', 'In Solution Explorer, open _Pages.cshtml_ . Change <h2>Simple Feed Reader</h2> to']\n\n<h2>Simple Feed Reader - V2</h2>.\n\n['Press Ctrl+Shift+B to build the app.', 'In Solution Explorer, right-click on the project and click **Publish** .']\n\n6 CHAPTER 2 | Deploy an app to App Service\n\n['Visual Studio can create a new App Service resource, but this update will be published over\\nthe existing deployment. In the **Pick a publish target** dialog, select **App Service** from the list\\non the left, and then select **Select Existing** . Click **Publish** .', 'In the **App Service** dialog, confirm that the Microsoft or Organizational account used to\\ncreate your Azure subscription is displayed in the upper right. If it\u2019s not, click the drop-down\\nand add it.', 'Confirm that the correct Azure **Subscription** is selected. For **View**, select **Resource Group** .\\nExpand the **AzureTutorial** resource group and then select the existing web app. Click **OK** .']\n\nVisual Studio builds and deploys the app to Azure. Browse to the web app URL. Validate that the\n\n<h2> element modification is live.\n\n7 CHAPTER 2 | Deploy an app to App Service", "Deployment slots": "Deployment slots support the staging of changes without impacting the app running in production.\nOnce the staged version of the app is validated by a quality assurance team, the production and\nstaging slots can be swapped. The app in staging is promoted to production in this manner. The\nfollowing steps create a staging slot, deploy some changes to it, and swap the staging slot with\nproduction after verification.\n\n['[Sign in to the Azure Cloud Shell, if not already signed in.](https://shell.azure.com/bash)']\n\n['Create the staging slot.']\n\na. Create a deployment slot with the name _staging_ .\n\n:::{custom-style=CodeBox} azurecli az webapp deployment slot create --name $webappname\n--resource-group AzureTutorial --slot staging :::\n\nb. Set the deployment branch to main in the appsettings configuration.\n\n:::{custom-style=CodeBox} azurecli az webapp config appsettings set --name $webappname -resource-group AzureTutorial --slot staging --settings DEPLOYMENT_BRANCH=main :::\n\nc. Configure the staging slot to use deployment from local Git and get the **staging**\ndeployment URL. **Note this URL for reference later** .\n\n:::{custom-style=CodeBox} azurecli echo Git deployment URL for staging: $(az webapp\ndeployment source config-local-git --name $webappname --resource-group AzureTutorial -slot staging --query url --output tsv) :::\n\nd. Display the staging slot\u2019s URL. Browse to the URL to see the empty staging slot. **Note**\n**this URL for reference later** .\n\n8 CHAPTER 2 | Deploy an app to App Service\n\n:::{custom-style=CodeBox} console echo Staging web app URL: http://$webappnamestaging.azurewebsites.net :::\n\n['In a text editor or Visual Studio, modify _Pages/Index.cshtml_ again so that the <h2> element\\nreads <h2>Simple Feed Reader - V3</h2> and save the file.']\n\n['Commit the file to the local Git repository, using either the **Changes** page in Visual Studio\u2019s\\n_Team Explorer_ tab, or by entering the following using the local machine\u2019s command shell:']\n\n:::{custom-style=CodeBox} console git commit -a -m \"upgraded to V3\" :::\n\n['Using the local machine\u2019s command shell, add the staging deployment URL as a Git remote\\nand push the committed changes:']\n\na. Add the remote URL for staging to the local Git repository.\n\n:::{custom-style=CodeBox} console git remote add azure-staging\n<Git_staging_deployment_URL> :::\n\nb. Push the local default branch ( _main_ ) to the _azure-staging_ remote\u2019s deployment\nbranch ( _main_ ).\n\n:::{custom-style=CodeBox} console git push azure-staging main :::\n\nWait while Azure builds and deploys the app.\n\n['To verify that V3 has been deployed to the staging slot, open two browser windows. In one\\nwindow, navigate to the original web app URL. In the other window, navigate to the staging\\nweb app URL. The production URL serves V2 of the app. The staging URL serves V3 of the\\napp.']\n\n['In the Cloud Shell, swap the verified/warmed-up staging slot into production.']\n\n9 CHAPTER 2 | Deploy an app to App Service\n\n:::{custom-style=CodeBox} azurecli az webapp deployment slot swap --name $webappname -resource-group AzureTutorial --slot staging :::\n\n['Verify that the swap occurred by refreshing the two browser windows.']", "Summary": "In this section, the following tasks were completed:\n\n['Downloaded and built the sample app.', 'Created an Azure App Service Web App using the Azure Cloud Shell.', 'Deployed the sample app to Azure using Git.', 'Deployed a change to the app using Visual Studio.', 'Added a staging slot to the web app.', 'Deployed an update to the staging slot.', 'Swapped the staging and production slots.']\n\nIn the next section, you\u2019ll learn how to build a DevOps pipeline with Azure Pipelines.", "Additional reading": ["[Web Apps overview](https://docs.microsoft.com/azure/app-service/app-service-web-overview)", "[Build a .NET Core and SQL Database web app in Azure App Service](https://docs.microsoft.com/azure/app-service/tutorial-dotnetcore-sqldb-app)", "[Configure deployment credentials for Azure App Service](https://docs.microsoft.com/azure/app-service/app-service-deployment-credentials)", "[Set up staging environments in Azure App Service](https://docs.microsoft.com/azure/app-service/web-sites-staged-publishing)"]}}, "3": {"Continuous integration and deployment with Azure DevOps": {"Publish the app\u2019s code to GitHub": ["Open a browser window, and navigate to https://github.com.", "Click the **+** drop-down in the header, and select **New repository** :"], "Disconnect local Git deployment": "Remove the local Git deployment with the following steps. Azure Pipelines (an Azure DevOps service)\nboth replaces and augments that functionality.\n\n['[Open the Azure portal, and navigate to the](https://portal.azure.com/) _staging (mywebapp<unique_number>/staging)_\\nWeb App. The Web App can be quickly located by entering _staging_ in the portal\u2019s search box:']\n\n12 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n```\nClick Deployment Center . A new panel appears. Click Disconnect to remove the local Git\nsource control configuration that was added in the previous chapter. Confirm the\nremoval operation by clicking the Yes button.\n\n```\n\n['Navigate to the _mywebapp_ App Service. As a reminder, the portal\u2019s search box can be used to\\nquickly locate the App Service.', 'Click **Deployment Center** . A new panel appears. Click **Disconnect** to remove the local Git\\nsource control configuration that was added in the previous chapter. Confirm the removal\\noperation by clicking the **Yes** button.']", "Create an Azure DevOps organization": ["[Open a browser, and navigate to the Azure DevOps organization creation page.](https://go.microsoft.com/fwlink/?LinkId=307137)", "Select **New organization**", "Confirm the information, and then select **Continue** .", "Sign in to your organization at any time, https://dev.azure.com/{yourorganization}"], "Create a team project in Azure DevOps organization": ["Choose the organization, and then select **New project** .", "Enter the project name as _MyFirstProject_ and select the **Visibility** as _Private_", "Select **Create project** ."], "Configure a self-hosted agent if necessary": "To build your code or deploy your software using Azure Pipelines, you need at least one agent. In\nAzure Pipelines, you can run parallel jobs on either **Microsoft-hosted** or **self-hosted** agent. But with\nthe recent change in Azure Pipelines free grant of parallel jobs is temporarily disable for the public\n[projects.For more details, refer Configure and pay for parallel jobs.](https://docs.microsoft.com/azure/devops/pipelines/licensing/concurrent-jobs?view=azure-devops&tabs=ms-hosted&preserve-view=true)\n\nGo to **Organization Settings** and then **Pipelines** - **Parallel jobs** . If you see value **0** under **Microsoft-**\n**hosted** that means you need a **Self-hosted** agent to run your pipeline.\n\n13 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n[You can create that by following details mentioned in Self-hosted agents. After successful](https://docs.microsoft.com/azure/devops/pipelines/agents/agents?view=azure-devops&tabs=browser&preserve-view=true#install)\nconfiguration, you\u2019ll be able to see available agent under **Organization Settings** - **Agent pools** **{youragentname}**", "Configure the Azure Pipelines pipeline": {"**Grant Azure DevOps access to the GitHub repository**": ["In your project, navigate to the **Pipelines** page. Then choose the action to create a new\npipeline:"], "**Create the build definition**": ["From the template selection page, enter _ASP.NET Core_ in the search box:"], "**Create the release pipeline**": ["Click the **Releases** tab of your team project. Click the **New pipeline** button."]}, "Commit changes to GitHub and automatically deploy to Azure": ["Open _SimpleFeedReader.sln_ in Visual Studio."], "Examine the Azure Pipelines pipeline": {"**Build definition**": "A build definition was created with the name _MyFirstProject-ASP.NET Core-CI_ . Upon completion, the\nbuild produces a _.zip_ file including the assets to be published. The release pipeline deploys those\nassets to Azure.\n\nThe build definition\u2019s **Tasks** tab lists the individual steps being used. There are five build tasks.\n\n23 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['**Restore**  - Executes the dotnet restore command to restore the app\u2019s NuGet packages. The\\ndefault package feed used is nuget.org.']\n\n['**Build**  - Executes the dotnet build --configuration release command to compile the app\u2019s\\ncode. This --configuration option is used to produce an optimized version of the code, which\\nis suitable for deployment to a production environment. Modify the _BuildConfiguration_\\nvariable on the build definition\u2019s **Variables** tab if, for example, a debug configuration is\\nneeded.']\n\n['**Test**  - Executes the dotnet test --configuration release --logger trx --results-directory\\n<local_path_on_build_agent> command to run the app\u2019s unit tests. Unit tests are executed\\nwithin any C# project matching the ** _/_ Tests/ _.csproj_ glob pattern. Test results are saved in a _.trx_\\nfile at the location specified by the --results-directory option. If any tests fail, the build fails\\nand isn\u2019t deployed.']\n\n24 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n[!NOTE] To verify the unit tests work, modify _SimpleFeedReader.Tests.cs_ to purposefully break\none of the tests. For example, change Assert.True(result.Count > 0); to\nAssert.False(result.Count > 0); in the Returns_News_Stories_Given_Valid_Uri method. Commit\nand push the change to GitHub. The build is triggered and fails. The build pipeline status\nchanges to **failed** . Revert the change, commit, and push again. The build succeeds.\n\n['**Publish**  - Executes the dotnet publish --configuration release --output\\n<local_path_on_build_agent> command to produce a _.zip_ file with the artifacts to be\\ndeployed. The --output option specifies the publish location of the _.zip_ file. That location is\\n[specified by passing a predefined variable](https://docs.microsoft.com/azure/devops/pipelines/build/variables) named $(build.artifactstagingdirectory). That\\nvariable expands to a local path, such as *c:_work\\\\1, on the build agent.']\n\n['**Publish Artifact**  - Publishes the _.zip_ file produced by the **Publish** task. The task accepts the\\n_.zip_ file location as a parameter, which is the predefined variable\\n$(build.artifactstagingdirectory). The _.zip_ file is published as a folder named _drop_ .']\n\nClick the build definition\u2019s **Summary** link to view a history of builds with the definition:\n\nOn the resulting page, click the individual build for more details.\n\nA summary of this specific build is displayed. Click the **published** link, and notice the _drop_ folder\nproduced by the build is listed:\n\n25 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nUse the ellipsis and click on **Downloads artifacts** links to inspect the published artifacts.", "**Release pipeline**": "A release pipeline was created with the name _MyFirstProject-ASP.NET Core-CD_ :\n\nThe two major components of the release pipeline are the **Artifacts** and the **Stages** . Clicking the box\nin the **Artifacts** section reveals the following panel:\n\n26 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nThe **Source (Build definition)** value represents the build definition to which this release pipeline is\nlinked. The _.zip_ file produced by a successful run of the build definition is provided to the _Production_\nenvironment for deployment to Azure. Click the _1 phase, 2 tasks_ link in the _Production_ environment\nbox to view the release pipeline tasks:\n\nThe release pipeline consists of two tasks: _Deploy Azure App Service to Slot_ and _Manage Azure App_\n_Service - Slot Swap_ . Clicking the first task reveals the following task configuration:\n\n27 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nThe Azure subscription, service type, web app name, resource group, and deployment slot are defined\nin the deployment task. The **Package or folder** textbox holds the _.zip_ file path to be extracted and\ndeployed to the _staging_ slot of the _mywebapp<unique_number>_ web app.\n\nClicking the slot swap task reveals the following task configuration:\n\n28 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nThe subscription, resource group, service type, web app name, and deployment slot details are\nprovided. The **Swap with Production** check box is checked. Consequently, the bits deployed to the\n_staging_ slot are swapped into the production environment."}, "Additional reading": ["[Create your first pipeline with Azure Pipelines](https://docs.microsoft.com/azure/devops/pipelines/create-first-pipeline)", "[Build and .NET Core project](https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core)", "[Deploy a web app with Azure Pipelines](https://docs.microsoft.com/azure/devops/pipelines/targets/webapp)"], "Continuous integration and deployment with Azure DevOps": {"**Publish the app\u2019s code to GitHub**": ["Open a browser window, and navigate to https://github.com.", "Click the **+** drop-down in the header, and select **New repository** :"], "**Disconnect local Git deployment**": "Remove the local Git deployment with the following steps. Azure Pipelines (an Azure DevOps service)\nboth replaces and augments that functionality.\n\n['[Open the Azure portal, and navigate to the](https://portal.azure.com/) _staging (mywebapp<unique_number>/staging)_\\nWeb App. The Web App can be quickly located by entering _staging_ in the portal\u2019s search box:']\n\n['Click **Deployment Center** . A new panel appears. Click **Disconnect** to remove the local Git\\nsource control configuration that was added in the previous chapter. Confirm the removal\\noperation by clicking the **Yes** button.', 'Navigate to the _mywebapp_ App Service. As a reminder, the portal\u2019s search box can be used to\\nquickly locate the App Service.', 'Click **Deployment Center** . A new panel appears. Click **Disconnect** to remove the local Git\\nsource control configuration that was added in the previous chapter. Confirm the removal\\noperation by clicking the **Yes** button.']", "**Create an Azure DevOps organization**": ["[Open a browser, and navigate to the Azure DevOps organization creation page.](https://go.microsoft.com/fwlink/?LinkId=307137)", "Select **New organization**", "Confirm the information, and then select **Continue** ."], "**Create a team project in Azure DevOps organization**": ["Choose the organization, and then select **New project** .", "Enter the project name as _MyFirstProject_ and select the **Visibility** as _Private_", "Select **Create project** ."], "**Configure a self-hosted agent if necessary**": "To build your code or deploy your software using Azure Pipelines, you need at least one agent. In\nAzure Pipelines, you can run parallel jobs on either **Microsoft-hosted** or **self-hosted** agent. But with\nthe recent change in Azure Pipelines free grant of parallel jobs is temporarily disable for the public\n[projects.For more details, refer Configure and pay for parallel jobs.](https://docs.microsoft.com/azure/devops/pipelines/licensing/concurrent-jobs?view=azure-devops&tabs=ms-hosted&preserve-view=true)\n\nGo to **Organization Settings** and then **Pipelines** - **Parallel jobs** . If you see value **0** under **Microsoft-**\n**hosted** that means you need a **Self-hosted** agent to run your pipeline.\n\n[You can create that by following details mentioned in Self-hosted agents. After successful](https://docs.microsoft.com/azure/devops/pipelines/agents/agents?view=azure-devops&tabs=browser&preserve-view=true#install)\nconfiguration, you\u2019ll be able to see available agent under **Organization Settings** - **Agent pools** **{youragentname}**", "**Configure the Azure Pipelines pipeline**": "There are three distinct steps to complete. Completing the steps in the following three sections results\nin an operational DevOps pipeline.\n\n32 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n**Grant Azure DevOps access to the GitHub repository**\n\n['In your project, navigate to the **Pipelines** page. Then choose the action to create a new\\npipeline:']\n\n['Use Use the classic editor to create the pipeline.']\n\n['Select the **GitHub** option from the **Select a source** section::']\n\n['Authorization is required before Azure DevOps can access your GitHub repository. Enter\\n_GitHub connection_ in the **Connection name** textbox. For example:']\n\n33 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['If two-factor authentication is enabled on your GitHub account, a personal access token is\\nrequired. In that case, click the **Authorize with a GitHub personal access token** link. See the\\n[official GitHub personal access token creation instructions](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) for help. Only the _repo_ scope of\\npermissions is needed. Otherwise, click the **Authorize using OAuth** button.', 'When prompted, sign in to your GitHub account. Then select Authorize to grant access to\\nyour Azure DevOps organization. If successful, a new service endpoint is created.', 'Click the ellipsis button next to the **Repository** button. Select the _/simple-feed-reader_\\nrepository from the list. Click the **Select** button.', 'Select the default branch ( _main_ ) from the **Default branch for manual and scheduled builds**\\ndrop-down. Click the **Continue** button. The template selection page appears.']\n\n**Create the build definition**\n\n['From the template selection page, enter _ASP.NET Core_ in the search box:']\n\n```\nThe template search results appear. Hover over the ASP.NET Core template, and click\nthe Apply button.\n\n```\n\n['The **Tasks** tab of the build definition appears. Select the self-hosted **Agent pool** if you have\\ncreated that in the earlier step.']\n\n34 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n```\n> [!NOTE]\n> If you are using MS-hosted agent then select the *Hosted > Azure Pipelines* from\ndrop down.\n\n```\n\n['Click the **Triggers** tab.', 'Check the **Enable continuous integration** box. Under the **Branch filters** section, confirm\\nthat the **Type** drop-down is set to _Include_ . Set the **Branch specification** drop-down to _main_ .']\n\n```\nThese settings cause a build to trigger when any change is pushed to the default\nbranch (*main*) of the GitHub repository. Continuous integration is tested in the\n[Commit changes to GitHub and automatically deploy to Azure](#commit-changes-togithub-and-automatical) section.\n\n```\n\n['Click the **Save & queue** button, and select the **Save** option:']\n\n35 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['The following modal dialog appears:']\n\n```\nUse the default folder of *\\\\*, and click the **Save** button.\n\n```\n\n**Create the release pipeline**\n\n['Click the **Releases** tab of your team project. Click the **New pipeline** button.']\n\n36 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n```\nThe template selection pane appears.\n\n```\n\n['From the template selection page, enter _App Service Deployment_ in the search box:']\n\n['The template search results appear. Hover over the **Azure App Service Deployment with**\\n**Slot** template, and click the **Apply** button. The **Pipeline** tab of the release pipeline appears.']\n\n['Click the **Add** button in the **Artifacts** box. The **Add artifact** panel appears:']\n\n37 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Select the **Build** tile from the **Source type** section. This type allows for the linking of the\\nrelease pipeline to the build definition.', 'Select _MyFirstProject_ from the **Project** drop-down.', 'Select the build definition name, _MyFirstProject-ASP.NET Core-CI_, from the **Source (Build**\\n**definition)** drop-down.', 'Select _Latest_ from the **Default version** drop-down. This option builds the artifacts produced\\nby the latest run of the build definition.', 'Replace the text in the **Source alias** textbox with _Drop_ .', 'Click the **Add** button. The **Artifacts** section updates to display the changes.', 'Click the lightning bolt icon to enable continuous deployments:']\n\n```\nWith this option enabled, a deployment occurs each time a new build is available.\n\n```\n\n['A **Continuous deployment trigger** panel appears to the right. Click the toggle button to\\nenable the feature. It isn\u2019t necessary to enable the **Pull request trigger** .', 'Click the **Add** drop-down in the **Build branch filters** section. Choose the **Build Definition\u2019s**\\n**default branch** option. This filter causes the release to trigger only for a build from the\\nGitHub repository\u2019s default branch ( _main_ ).', 'Click the **Save** button. Click the **OK** button in the resulting **Save** modal dialog.', 'Click the **Stage 1** box. An **Stage** panel appears to the right. Change the _Stage 1_ text in the\\n**Stage name** textbox to _Production_ .']\n\n38 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Click the **1 phase, 2 tasks** link in the **Production** box:']\n\n```\nThe **Tasks** tab of the environment appears.\n\n```\n\n['Click the **Deploy Azure App Service to Slot** task. Its settings appear in a panel to the right.', 'Select the Azure subscription associated with the App Service from the **Azure subscription**\\ndrop-down. Once selected, click the **Authorize** button.', 'Select _Web App_ from the **App type** drop-down.', 'Select _mywebapp/_ from the **App service name** drop-down.', 'Select _AzureTutorial_ from the **Resource group** drop-down.', 'Select _staging_ from the **Slot** drop-down.', 'Select **Run on agent**  - under **Tasks** . On the right pane, you\u2019ll see **Agent Job** .', 'Select the self-hosted **Agent pool** if you have created that in the earlier step.']\n\n39 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n```\n> [!NOTE]\n> If you are using MS-hosted agent then select the *Hosted > Azure Pipelines* from\ndrop down.\n\n```\n\n['Click the **Save** button.', 'Hover over the default release pipeline name. Click the pencil icon to edit it. Use\\n_MyFirstProject-ASP.NET Core-CD_ as the name.']\n\n['Click the **Save** button.']", "**Commit changes to GitHub and automatically deploy to Azure**": ["Open _SimpleFeedReader.sln_ in Visual Studio."], "**Examine the Azure Pipelines pipeline**": "**Build definition**\n\nA build definition was created with the name _MyFirstProject-ASP.NET Core-CI_ . Upon completion, the\nbuild produces a _.zip_ file including the assets to be published. The release pipeline deploys those\nassets to Azure.\n\nThe build definition\u2019s **Tasks** tab lists the individual steps being used. There are five build tasks.\n\n41 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['**Restore**  - Executes the dotnet restore command to restore the app\u2019s NuGet packages. The\\ndefault package feed used is nuget.org.']\n\n['**Build**  - Executes the dotnet build --configuration release command to compile the app\u2019s\\ncode. This --configuration option is used to produce an optimized version of the code, which\\nis suitable for deployment to a production environment. Modify the _BuildConfiguration_\\nvariable on the build definition\u2019s **Variables** tab if, for example, a debug configuration is\\nneeded.']\n\n['**Test**  - Executes the dotnet test --configuration release --logger trx --results-directory\\n<local_path_on_build_agent> command to run the app\u2019s unit tests. Unit tests are executed\\nwithin any C# project matching the ** _/_ Tests/ _.csproj_ glob pattern. Test results are saved in a _.trx_\\nfile at the location specified by the --results-directory option. If any tests fail, the build fails\\nand isn\u2019t deployed.']\n\n42 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n[!NOTE] To verify the unit tests work, modify _SimpleFeedReader.Tests.cs_ to purposefully break\none of the tests. For example, change Assert.True(result.Count > 0); to\nAssert.False(result.Count > 0); in the Returns_News_Stories_Given_Valid_Uri method. Commit\nand push the change to GitHub. The build is triggered and fails. The build pipeline status\nchanges to **failed** . Revert the change, commit, and push again. The build succeeds.\n\n['**Publish**  - Executes the dotnet publish --configuration release --output\\n<local_path_on_build_agent> command to produce a _.zip_ file with the artifacts to be\\ndeployed. The --output option specifies the publish location of the _.zip_ file. That location is\\n[specified by passing a predefined variable](https://docs.microsoft.com/azure/devops/pipelines/build/variables) named $(build.artifactstagingdirectory). That\\nvariable expands to a local path, such as *c:_work\\\\1, on the build agent.']\n\n['**Publish Artifact**  - Publishes the _.zip_ file produced by the **Publish** task. The task accepts the\\n_.zip_ file location as a parameter, which is the predefined variable\\n$(build.artifactstagingdirectory). The _.zip_ file is published as a folder named _drop_ .']\n\nClick the build definition\u2019s **Summary** link to view a history of builds with the definition:\n\nOn the resulting page, click the individual build for more details.\n\nA summary of this specific build is displayed. Click the **published** link, and notice the _drop_ folder\nproduced by the build is listed:\n\n43 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nUse the ellipsis and click on **Downloads artifacts** links to inspect the published artifacts.\n\n**Release pipeline**\n\nA release pipeline was created with the name _MyFirstProject-ASP.NET Core-CD_ :\n\nThe two major components of the release pipeline are the **Artifacts** and the **Stages** . Clicking the box\nin the **Artifacts** section reveals the following panel:\n\n44 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nThe **Source (Build definition)** value represents the build definition to which this release pipeline is\nlinked. The _.zip_ file produced by a successful run of the build definition is provided to the _Production_\nenvironment for deployment to Azure. Click the _1 phase, 2 tasks_ link in the _Production_ environment\nbox to view the release pipeline tasks:\n\nThe release pipeline consists of two tasks: _Deploy Azure App Service to Slot_ and _Manage Azure App_\n_Service - Slot Swap_ . Clicking the first task reveals the following task configuration:\n\n45 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nThe Azure subscription, service type, web app name, resource group, and deployment slot are defined\nin the deployment task. The **Package or folder** textbox holds the _.zip_ file path to be extracted and\ndeployed to the _staging_ slot of the _mywebapp<unique_number>_ web app.\n\nClicking the slot swap task reveals the following task configuration:\n\n46 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nThe subscription, resource group, service type, web app name, and deployment slot details are\nprovided. The **Swap with Production** check box is checked. Consequently, the bits deployed to the\n_staging_ slot are swapped into the production environment.", "**Additional reading**": ["[Create your first pipeline with Azure Pipelines](https://docs.microsoft.com/azure/devops/pipelines/create-first-pipeline)", "[Build and .NET Core project](https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core)", "[Deploy a web app with Azure Pipelines](https://docs.microsoft.com/azure/devops/pipelines/targets/webapp)"]}, "Continuous integration and deployment with GitHub Actions": {"**GitHub Actions**": "GitHub Actions is a workflow engine that can automate workflows for nearly all events that occur on\nGitHub. Actions is a great solution for Continuous Integration/Continuous Deployment (CI/CD)\npipelines.\n\nIn this section of articles, you\u2019ll learn how to create an Actions workflow. The workflow will build, test,\nand deploy a .NET web app to Azure Web Apps.\n\nIn the Build article, you\u2019ll create the initial workflow to build and test the .NET app. You\u2019ll:\n\n[!div class=\u201cchecklist\u201d]\n\n['Learn the basic structure of a GitHub Action workflow YAML file.', 'Use a template to create a basic build workflow that builds a .NET app and executes unit tests.', 'Publish the compiled app so that it\u2019s ready for deployment.']\n\nIn the Deploy article, you\u2019ll:\n\n[!div class=\u201cchecklist\u201d]\n\n['Learn about environments in GitHub Actions.']\n\n49 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Create two environments and specify environment protection rules.', 'Create environment secrets for managing environment-specific configuration.', 'Extend the workflow YAML file to add deployment steps.', 'Add a manual dispatch trigger.']", "**Secure code with CodeQL**": "[In addition to building and deploying code, GitHub Advanced Security offers tools for \u201cshifting left\u201d](https://docs.github.com/github/getting-started-with-github/about-github-advanced-security)\n[with security. That is, integrating security early on in the software delivery lifecycle. CodeQL is a code](https://codeql.github.com/docs/codeql-overview/about-codeql/)\nscanning language that runs queries to find potential vulnerabilities or quality issues in your code.\nCodeQL is run using an Actions workflow.\n\nIn the CodeQL article, you\u2019ll:\n\n[!div class=\u201cchecklist\u201d]\n\n['Create a Code Scanning Action.', 'Edit the workflow file to include custom scan settings.', 'See scanning results.']", "**Compare and contrast GitHub Actions and Azure Pipelines**": "GitHub Actions and Azure Pipelines have a common lineage and are similar in many respects.\nHowever, you should understand the differences before selecting a platform for building, testing, and\ndeploying apps. In the Comparison article, you\u2019ll deep dive into these platforms and compare and\ncontrast them. You\u2019ll also learn how to select the correct platform for your CI/CD needs."}, "Compare and contrast GitHub Actions and Azure Pipelines": {"**Pipelines as code**": "Before you compare GitHub Actions and Azure Pipelines, you should consider the benefits of _pipelines_\n_as code_ . Pipelines as code:\n\n[!div class=\u201cchecklist\u201d]\n\n['Benefit from standard source control practices (such as code reviews via pull request and\\nversioning).', 'Can be audited for changes just like any other files in the repository.', 'Don\u2019t require accessing a separate system or UI to edit.', 'Can fully codify the build, test, and deploy process for code.']\n\n50 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Can usually be templatized to empower teams to create standard processes across multiple\\nrepositories.']", "**Agents and runners**": "Before you examine pipelines themselves, you should consider how these pipelines _execute_ . Both\nGitHub Actions and Azure Pipelines are really _orchestration engines_ . When a pipeline is triggered, the\nsystem finds an \u201cagent\u201d and tells the agent to execute the jobs defined in the pipeline file.\n\nAzure Pipelines run on _agents_ . The agent is written in .NET, so it will run wherever .NET can run:\n[Windows, macOS, and Linux. Agents can even run in containers. Agents are registered to a pool](https://docs.microsoft.com/azure/devops/pipelines/agents/pools-queues) in\nAzure Pipelines or to a repository or organization in GitHub. Agents can be _hosted_ or _private_ .\n\nGitHub Workflows execute on _runners_ . The runner code is essentially a fork of the Azure Pipelines\ncode, so it\u2019s very similar. It\u2019s also cross-platform and you can also use _hosted_ or _self-hosted_ runners.\n\n**Hosted agents and runners**\n\nHosted agents (Azure Pipelines) and hosted runners (GitHub) are agents that are spun up and\nmanaged by Azure DevOps or GitHub respectively. You don\u2019t need to maintain any build\ninfrastructure. When a pipeline triggers that targets a hosted agent, an instance of the specified agent\nimage is created. The job is run by the agent on the instance, and once the job completes, the\ninstance is destroyed. The same applies for hosted runners running GitHub workflows.\n\n**Private agents and self-hosted runners**\n\nThere are times when you can\u2019t use hosted images. For example, when you:\n\n['Require SDKs or other software that isn\u2019t installed on the images.', 'Need to access resources that aren\u2019t public (such as an internal SonarQube server or an\\ninternal Artifactory instance).', 'Need to deploy to private networks.', 'Need to install licenses for third-party software required for building your code.', 'Need more storage or memory than is provided to the hosted agent images.', 'Need more time than the maximum build time limit for hosted agents.']\n\n51 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n**Azure DevOps agents**\n\nEvery Azure DevOps account has a hosted pool with a single agent that can run one job at a time.\nAlso included is a set number of free build minutes. You may purchase additional \u201chosted pipelines\u201d in\nAzure DevOps. When you purchase an additional hosted pipeline, you\u2019re really removing the build\nminutes limit and adding _concurrency_ . One pipeline can run one job at a time. Two pipelines can run\ntwo jobs simultaneously, and so on.\n\n**Comparison of agents**\n\n|Feature|GitHub|Azure Pipelines|Links|\n|---|---|---|---|\n|Hosted agents for<br>public<br>repos/projects|Free|Up to 10 free Microsoft-hosted parallel jobs<br>that can run for up to 360 minutes (6 hours)<br>each time with no overall time limit per<br>month. You aren\u2019t given this free grant by<br>default, you have tosubmit a request|Azure<br>Pipelines <br>GitHub|\n|Hosted agents for<br>private<br>repos/projects|2,000 minutes<br>free per month,<br>3,000 minutes<br>for Pro and<br>Team licenses,<br>50,000 minutes<br>for Enterprise<br>license.<br>Additional<br>minutes may be<br>purchased.|One free parallel job that can run for up to<br>60 minutes each time, until you\u2019ve used<br>1,800 minutes (30 hours) per month. You<br>can pay for additional capacity per parallel<br>job. Paid parallel jobs remove the monthly<br>time limit and allow you to run each job for<br>up to 360 minutes (6 hours).||\n|Cross-platform|Yes|Yes||\n|Scale set agents|No|Yes|Azure virtual<br>machine<br>scale set<br>agents|", "**Comparison of GitHub Actions and Azure Pipelines**": "Azure Pipelines (YAML pipelines) provide a mature set of features. Some of the features include:\n\n['Approvals', 'Artifact storage']\n\n52 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Deployment jobs', 'Environments', 'Gates', 'Stages', 'Templates', 'Triggers', 'Variable groups']\n\n[For a full list of Azure Pipelines features, refer to the Feature availability](https://docs.microsoft.com/azure/devops/pipelines/get-started/pipelines-get-started?view=azure-devops&preserve-view=true#feature-availability) table.\n\nGitHub Actions are evolving rapidly and provide features such as triggers for almost all GitHub events,\nartifact storage, environments and environment rules, starter templates, and matrices. Read more\n[about the entire feature set refer GitHub Actions.](https://docs.github.com/actions)\n\n**Feature comparison**\n\nThe following table is current as of January 2023 and is not an exhaustive list of features.\n\n|Feature|Description|GitHub Actions|Azure Pipelines|\n|---|---|---|---|\n|Approvals|Define approval<br>conditions before<br>moving further in the<br>pipeline|Yes|Yes|\n|Artifacts|Upload, store, and<br>download artifacts<br>from jobs|Yes|Yes|\n|Caching|Cache folders or files<br>for subsequent runs|Yes|Yes|\n|Conditions|Specify conditions<br>for steps or jobs|Yes|Yes|\n|Container<br>Jobs|Run jobs inside a<br>container|Yes|Yes|\n|Demands|Specify demands<br>that must be met to<br>match jobs to agents|Yes|Yes|\n|Dependenci<br>es|Specify<br>dependencies<br>between jobs or<br>stages|Yes|Yes|\n|Deployment<br>Groups|A logical set of target<br>machines for<br>deployments|No|Yes|\n|Deployment<br>Jobs|Job that targets a<br>deployment group|No|Yes|\n\n53 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n|Feature|Description|GitHub Actions|Azure Pipelines|\n|---|---|---|---|\n|Environment<br>s|A collection of<br>resources to target<br>or a logical<br>environment|Yes|Yes|\n|Gates/Check<br>s|Automatic collection<br>and evaluation of<br>signals to control<br>continuation|Yes|Yes|\n|Jobs|Sequence of steps<br>that are executed on<br>an agent|Yes|Yes|\n|Service<br>Containers|Manage the lifecycle<br>of a containerized<br>service instance<br>available during a<br>job|Yes|Yes|\n|Service<br>Connections|Abstract credentials<br>to external systems|No|Yes|\n|Passwordles<br>s <br>connections<br>to cloud<br>providers|Provide technologies<br>and support use<br>cases that reduce<br>and potentially<br>eliminate the use of<br>passwords|Yes|No|\n|Stages|Group jobs in a<br>pipeline|No|Yes|\n|Templates|Define reusable,<br>parameterized<br>building blocks for<br>steps, jobs, or<br>variables|Yes|Yes|\n|Starter<br>Templates|Defines a starter<br>workflow based on<br>the type of code<br>detected in a<br>repository|Yes|No|\n|Triggers|Set of events that<br>cause the pipeline to<br>trigger|Yes|Yes|\n\n54 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n|Feature|Description|GitHub Actions|Azure Pipelines|\n|---|---|---|---|\n|Variables|Variables that can be<br>passed in, statically<br>or dynamically<br>defined|Yes|Yes|\n|Variable<br>Groups|Store values for use<br>across multiple<br>pipelines|No|Yes|"}, "Build a .NET web app using GitHub Actions": {"**Workflow structure**": "Workflows are defined in YAML files, and contain several common nodes:\n\n['a name', 'a trigger, defined by an on section', 'one or more job sections composed of one or more steps', 'optional attributes such as environment variables']\n\nJobs are run on _runners_ . You can use _hosted runners_, which are spun up by GitHub during the\nworkflow and then thrown away. Hosted runners are great because you don\u2019t have to maintain your\nown build infrastructure. For workflows that require a specific build environment, or for running\nworkflows on a private network, you can also use _private_ runners. To create a private runner, install the\nrunner on any machine that supports .NET.\n\nEach job will specify what runner GitHub should use to execute the steps. You can also specify\ndependencies between jobs using the needs attribute. Deployment jobs can also specify an\nenvironment to target.\n\n55 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nThe steps node can be as easy as inline commands, or they can be actions. Most CI workflows will\nhave a combination of run steps (for executing scripts) and actions. Individual actions are pulled into\nthe workflow by referencing the GitHub Action repository (and optionally a tag or commit hash for\nspecific versions) and specifying any parameters using the with keyword.\n\n[From a workflow file, you\u2019re able to run any of the available .NET CLI commands. For example, if you\u2019re](https://docs.microsoft.com/en-us/dotnet/core/tools/)\nrequired to build, test, and deploy an ASP.NET Core Blazor WebAssembly app with Ahead-of-Time\n(AoT) compilation, you\u2019d use the following commands:\n\n['[dotnet workload install](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-workload-install)', '[dotnet restore](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-restore)', '[dotnet build](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-build)', '[dotnet test](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-test)', '[dotnet publish](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish)']\n\n**The .NET SDK is a workflow necessity**\n\n[All .NET workflows require the .NET SDK, and this can be set up by the actions/setup-dotnet GitHub](https://github.com/actions/setup-dotnet)\n[Action. This action sets up a .NET CLI environment for use in actions. Some GitHub hosted runners](https://github.com/actions/setup-dotnet)\nhave the .NET SDK preinstalled, but that\u2019s subject to change. As a best practice, use the actions/setupdotnet action to ensure the proper version is available.", "**Create a basic build workflow**": "A primary principle of effective DevOps is to \u201cbuild once, and deploy many times\u201d. You\u2019ll start by\ncreating a workflow to build a basic .NET app. In the next step, you\u2019ll publish the output to prepare for\ndeployment.\n\n['Navigate to your GitHub repository and select the **Actions** tab.', 'GitHub detects that there\u2019s .NET code in the repository and suggests a .NET workflow\\ntemplate. Select **Set up this workflow** to create a new YAML workflow file:']\n\n```\n**Figure 1**: Creating a new workflow.\n\n```\n\n56 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Commit the file onto the main branch. Since you\u2019ve defined a trigger condition for _commits to_\\n_main_, this commit should trigger the workflow to run.']\n\n```\n**Figure 2**: Commit the YAML file.\n\n```\n\n['Select the **Actions** tab again. You should see a running workflow. Once the workflow has\\ncompleted, you should see a successful run.']\n\n```\n**Figure 3**: Successful build view.\n\n```\n\n['Opening the logs, you can see that the .NET build succeeded and the tests ran and passed.']\n\n```\n**Figure 4**: Checking the logs.\n\n```\n\n57 CHAPTER 3 | Continuous integration and deployment with Azure DevOps", "**Dissect the workflow file**": "Let\u2019s examine the workflow YAML file you have so far:\n\nNotice the following things:\n\n['There\u2019s a name that names the workflow.', 'The on object specifies when this workflow should run. This workflow has two events that\\ntrigger it: push to main and pull_request to main. Each time someone commits to main or\\ncreates a pull request (PR) to main, this workflow will execute.', 'There\u2019s a single job called build. This build should run on a hosted agent. ubuntu_latest\\nspecifies the most recent Ubuntu hosted agent.', 'There are five steps:', 'actions/checkout@v3 is an action that checks out the code in the repository onto the\\nrunner.', 'actions/setup-dotnet@v3 is an action that sets up the .NET CLI. This step also\\nspecifies a name attribute for the logs and the dotnet-version parameter within the\\nwith object.', 'Three run steps that execute dotnet restore, dotnet build, and dotnet test. name\\nattributes are also specified for these run steps to make the logs look pretty.']\n\n58 CHAPTER 3 | Continuous integration and deployment with Azure DevOps", "**Publish the output**": "Now that you\u2019ve successfully built and tested the code, add steps that publish the output so you can\ndeploy the web app.\n\n['Navigate to the _.github/workflows/dotnet.yml_ file and select the pencil icon to edit']\n\n```\n**Figure 5**: Edit the YAML file.\n\n```\n\n['Add the following Publish step below the Test step. The step runs the dotnet publish\\ncommand to publish the web app:']\n\n:::{custom-style=CodeBox} ```yml\n\n - name: Test run: dotnet test \u2013no-build \u2013verbosity normal # <\u2013 this is the current\n\nbottom line\n\n - name: Publish run: dotnet publish SimpleFeedReader/SimpleFeedReader.csproj -c\n\nRelease -o website ``` :::\n\n['This publishes the web app to a folder on the hosted agent. Now you\u2019ll want to _upload_ the\\nsite as a build artifact that can be deployed to Azure. To complete this activity, you\u2019ll use an\\nexisting action.']\n\n['On the list of actions in the **Actions Helper** pane on the right, search for artifact. Select on\\nthe Upload a Build Artifact (By actions) action.']\n\n```\n**Figure 6**: Accessing the snippet helper.\n\n```\n\n59 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Edit the version to v2.2.2 to display a sample snippet. Select the clipboard icon to copy the\\nsnippet and paste it into the workflow below the publish step.']\n\n```\n**Figure 7**: Copying a snippet.\n\n```\n\n['Edit the YAML for this step to look as follows:']\n\n:::{custom-style=CodeBox} ```yml\n\n - name: Upload a Build Artifact uses: actions/upload-artifact@v3 with: name: website\n\npath: SimpleFeedReader/website/** if-no-files-found: error ``` :::\n\n['Commit the file.']\n\n['Once the workflow completes, you\u2019ll see the artifact from the **Home** tab:']\n\n```\n**Figure 8**: Viewing artifacts in the summary page.\n\n```\n\n60 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n**Final workflow file**\n\nThe final workflow file should look something like this:"}, "Deploy a .NET web app using GitHub Actions": {"**Environments**": "Now that you\u2019ve published an artifact that\u2019s _potentially deployable_, you\u2019ll add _deployment_ jobs to the\nworkflow. There\u2019s nothing special about a deployment job, other than the fact that it references an\n\n61 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n_environment_ . Environments are _logical_ constructs that allow you to specify environment protection\nrules, such as approvals, on any group of resources that you\u2019re targeting.\n\nIn this walkthrough, you\u2019ll be deploying to two environments: PRE-PROD and PROD. In a typical\ndevelopment lifecycle, you\u2019ll want to deploy the latest code to a _soft_ environment (typically DEV) that\nis expected to be a bit unstable. You\u2019ll use PRE-PROD as this _soft_ environment. The \u201chigher\u201d\nenvironments (like UAT and PROD) are _harder_ environments that are expected to be more stable. To\nenforce this, you can build protection rules into higher environments. You\u2019ll configure an approval\nprotection rule on the PROD environment: whenever a deployment job targets an environment with\nan approval rule, it will pause until approval is granted before executing.\n\nGitHub environments are _logical_ . They represent the physical (or virtual) resources that you\u2019re\ndeploying to. In this case, the PRE-PROD is just a deployment slot on the Azure Web App. PROD is the\nproduction slot. The PRE-PROD deployment job will deploy the published .NET app to the staging\nslot. The PROD deployment job will swap the slots.\n\nOnce you have these steps in place, you\u2019ll update the workflow to handle environment-specific\nconfiguration using environment secrets.", "**Azure authentication**": "To perform actions such as deploying code to an Azure resource, you need the correct permissions.\nFor deployment to Azure Web Apps, you can use a publishing profile. If you want to deploy to a\nstaging slot, then you\u2019ll need the publishing profile for the slot too. Instead, you can use a service\nprincipal (SPN) and assign permission to this service principal. You can then authenticate using\ncredentials for the SPN before using any commands that the SPN has permissions to perform.\n\n[Once you have an SPN, you\u2019ll create a repository secret](https://docs.github.com/actions/reference/encrypted-secrets) to securely store the credentials. You can then\nrefer to the secret whenever you need to authenticate. The secret is encrypted and once it has been\nsaved, can never be viewed or edited (only deleted or re-created).\n\n**Create an SPN**\n\n['In your terminal or Cloud Shell, run the following command to create a service principal with\\ncontributor permissions to the web app you created earlier:']\n\n:::{custom-style=CodeBox} azurecli az ad sp create-for-rbac --name \"{sp-name}\" --sdk-auth -role contributor \\ --scopes /subscriptions/{subscription-id}/resourceGroups/{resourcegroup}/providers/Microsoft.Web/sites/{webappname} :::\n\n['The command should output JSON that has credentials embedded:']\n\n:::{custom-style=CodeBox} json {  \"clientId\": \"<GUID>\",  \"clientSecret\": \"<GUID>\",\n\"subscriptionId\": \"<GUID>\",  \"tenantId\": \"<GUID>\",  ... } :::\n\n62 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Make sure to record the clientId, clientSecret, subscription, and tenantId. You can also leave\\nthe terminal open for copy/paste later.']\n\n**Create a repository secret**\n\n['Now you\u2019re going to create an encrypted secret to store the credentials. You\u2019ll create this\\nsecret at the repository level.', 'Navigate to GitHub and select your repository **Settings** tab. Then select **Secrets** . Select **New**\\n**repository secret** :']\n\n```\n**Figure 1**: Create a secret.\n\n```\n\n['Copy and paste the JSON from the az ad sp create-for-rbac command into the body of the\\nsecret. You can create this JSON by hand too if you have the relevant fields for your SPN. The\\nsecret should be named AZURE_CREDENTIALS. Select **Add secret** to save the new secret:']\n\n```\n**Figure 2**: Add Azure credentials.\n\n```\n\n['You\u2019ll consume this secret in a workflow in later steps. To access it, use the variable notation\\n${{}}. In this case, ${{ AZURE_CREDENTIAL }} will be populated with the JSON you saved.']", "**Add environments**": "[Environments](https://docs.github.com/actions/reference/environments) are used as a _logical boundary_ . You can add approvals to environments to ensure\nquality. You can also track deployments to environments and specify environment-specific values\n(secrets) for configuration.\n\n63 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\nFor this example, you\u2019re going to split the actual Azure environment into two _logical_ environments\ncalled PRE-PROD and PROD. When you deploy the web app, you\u2019ll deploy to the staging slot of the\nAzure web app, represented by the PRE-PROD environment. When you\u2019re ready to deploy to PROD,\nyou\u2019ll just perform a slot swap.\n\nIn this case, the only difference between the environments is the slot that you\u2019re deploying to. In real\nlife, there would typically be different web apps (and separate web app plans), separate resource\ngroups, and even separate subscriptions. Typically, there\u2019s an SPN per environment. You may want to\noverride the AZURE_CREDENTIAL value that you saved as a repository secret by creating it as an\n_environment secret_ .\n\n['Select **Settings** and then **Environments** in your repository. Select **New Environment** :']\n\n```\n**Figure 3**: Create an environment.\n\n```\n\n['Enter PRE-PROD and select **Configure environment** :']\n\n```\n**Figure 4**: Name the environment.\n\n```\n\n64 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n['Since deploying to a staging slot doesn\u2019t affect the web app, you can safely deploy to the slot\\nwithout requiring an approval first. A reviewer could be added if desired. For this example,\\nleave the Environment protection rules empty.']\n\n[!NOTE] If you target an environment in a workflow and it does not exist, an \u201cempty\u201d\nenvironment is created automatically. The environment would look exactly the same as the\nPRE-PROD environment - it would exist, but would not have any protection rules enabled.\n\n['Select **Environments** again and again select **New Environment** . Now enter PROD as the\\nname and select **Configure environment** .']\n\n['Check the **Required reviewers** rule and add yourself as a reviewer. Don\u2019t forget to select\\n**Save protection rules** :']\n\n```\n**Figure 5**: Add protection rules.\n\n#### **Deploy to staging**\n\n```\n\nYou can now add additional jobs to the workflow to deploy to the environments! You\u2019ll start by\nadding a deployment to the PRE-PROD environment, which in this case is the web app staging slot.\n\n['Navigate to the _.github/workflows/dotnet.yml_ file and select the pencil icon to edit the file.']\n\n['You\u2019re going to use the web app name a few times in this workflow, and will need the name\\nof the resource group too. You\u2019ll define the app and resource group names as variables. With\\nthe variables, you can maintain the values in one place in the workflow file.']\n\n['Add this snippet below the on block and above the jobs block:']\n\n:::{custom-style=CodeBox} ```yml env: app-name: \u201c\u201d rg-name: \u201c\u201d\n\njobs: # <\u2013 this is the existing jobs line ``` :::\n\n[!WARNING] You\u2019ll need to replace <name of your web app> with the actual name of your\nweb app, and <name of your resource group> with the actual name of your resource group.\n\n['Add a new job below the build job as follows:']\n\n65 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n:::{custom-style=CodeBox} ```yml if-no-files-found: error # <\u2013 last line of build job: insert\nbelow this line\n\ndeploy_staging: needs: build runs-on: ubuntu-latest\n\n```\n\n\nThe preceding workflow defines several steps:\n\n\n1. You\u2019re creating a new job called deploy_staging.\n2. You specify a dependency using needs. This job needs the build job to complete\nsuccessfully before it starts.\n\n\n3. This job also runs on the latest Ubuntu hosted agent, as specified with the runs-on\nattribute.\n\n4. You specify that this job is targeting the PRE-PROD environment using the\nenvironment object. You also specify the url property. This URL will be displayed in\nthe workflow diagram, giving users an easy way to navigate to the environment. The\nvalue of this property is set as the output of the step with id deploywebapp, which is\ndefined below.\n\n5. You\u2019re executing a download-artifact step to download the artifact (compiled web\napp) from the build job.\n\n6. You then login to Azure using the AZURE_CREDENTIALS secret you saved earlier.\nNote the ${{ }} notation for dereferencing variables.\n\n7. You then perform a webapp-deploy, specifying the app-name, slot-name, and path to\nthe downloaded artifact (package). This action also defines an output parameter that\nyou use to set the url of the environment above.\n\n\n66 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n8. Finally, you execute a logout to log out of the Azure context.\n\n\n5. Commit the file.\n\n\n6. When the run completes, you should see two successful jobs. The URL for the PRE-PROD\nstage has been set and selecting it will navigate you to your web app staging slot:\n\n```\n\n**Figure 6**: Deployment to PRE-PROD is successful.\n\n```\n\n1. Notice how the staging slot\u2019s direct URL contains -staging:\n\n```\n\n**Figure 7**: The staging slot running.\n\n```\n\n1. You can also now see deployments. Navigate to https://{your repository url}/deployments to\nview your deployments:\n\n\n67 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n```\n\n**Figure 8**: View deployments.", "**Deploy to production**": "```\n\nNow that you\u2019ve deployed successfully to PRE-PROD, you\u2019ll want to deploy to PROD. Deployment to\nPROD will be slightly different since you don\u2019t need to copy the website again - you just need to swap\nthe staging slot with the production slot. You\u2019ll do this using an Azure CLI (az) command.\n\n\n1. Navigate to the _.github/workflows/dotnet.yml_ file and select the pencil icon to edit the file.\n\n\n2. Add a new job below the deploy_staging job as follows:\n\n\n:::{custom-style=CodeBox} ```yml run: az logout # <\u2013 last line of previous job: insert below this\nline\n\n\ndeploy_prod: needs: deploy_staging runs-on: ubuntu-latest\n\n\nThe deployment to the PROD environment workflow specifies several steps:\n\n\n1. Once again, you specify a new job deploy_prod that needs deploy_staging to\ncomplete before starting.\n\n2. You\u2019re targeting the PROD environment this time. Also, the url value is different from\nbefore.\n\n\n68 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n3. For the steps, you don\u2019t need to download the artifact since you\u2019re just going to\nperform a slot swap. You start by executing a login to the Azure context.\n\n4. The Swap staging slot into production step is a multi-line run command (note the use\nof the pipe symbol |). You also specify an id for this step so that you can refer to it\n(you refer to it in the url property of the environment). The first line executes the slot\nswap using the variables you defined above in the workflow. The second line uses an\naz webapp show command to extract the URL of the target web app. This final line\nuses ::set-output in an echo to create an output variable for this task, setting the value\nto the web app URL.\n\n\n[!NOTE] The URL _must_ start with http:// or https:// or it won\u2019t render.\n\n\n3. Commit the file.\n\n\n4. Let the workflow run for a couple minutes until it has deployed to PRE-PROD. At this point,\nthe workflow will pause and wait for the required approval since you\u2019re targeting the PROD\nenvironment, which requires an approval as defined earlier:\n\n```\n\n**Figure 9**: Waiting for an approval.\n\n```\n\n1. Select **Review deployments**, select the **PROD** checkbox, optionally add a comment, and then\nselect **Approve and deploy** to start the PROD job.\n\n```\n\n**Figure 10**: Approve the PROD deployment.\n\n```\n\n1. The deployment should only take a few seconds. Once it has completed, the URL for the\nPROD environment will update.\n\n\n69 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n```\n\n**Figure 11**: PROD deployment completed.\n\n```\n\n1. Selecting the PROD URL will navigate you to the PROD site.\n\n```\n\n**Figure 12**: The PROD site.", "**Add a manual queue option**": "```\n\nYou now have an end-to-end build and deploy workflow, including approvals. One more change you\ncan make is to add a manual trigger to the workflow so that the workflow can be triggered from\nwithin the **Actions** tab of the repository.\n\n\n1. Navigate to the _.github/workflows/dotnet.yml_ file and select the pencil icon to edit the file.\n\n\n2. Add a new trigger between on and push on lines 3 and 4:\n\n\n:::{custom-style=CodeBox} yml on:  workflow_dispatch:  # <-- this is the new line  push: :::\n\n\n3. The workflow_dispatch trigger displays a Run workflow button in the **Actions** tab of the\nrepository\u2014 _but only if the trigger is defined in the default branch_ . However, once this trigger is\ndefined in the workflow, you can select the branch for the run.\n\n\n4. Commit the file.\n\n\n70 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n5. To see the **Run workflow** button, select the **Actions** tab. Select the .NET workflow in the list\nof workflows. At the top of the list of runs, you\u2019ll see the **Run workflow** button. If you select\nit, you can choose the branch to run the workflow against and queue it:\n\n```\n\n**Figure 13**: Manual dispatch.", "**Handle environment configuration**": "```\n\nYour workflow is deploying the same binary to each environment. This concept is important to ensure\nthat the binaries you test in one environment are the same that you deploy to the next. However,\nenvironments typically have different settings like database connection strings. You want to ensure\nthat the DEV app is using DEV settings and the PROD app is using PROD settings.\n\n\nFor this simple app, there\u2019s no database connection string. However, there\u2019s an example configuration\nsetting that you can modify for each environment. If you open the _simple-feed-_\n_reader/SimpleFeedReader/appsettings.json_ file, you\u2019ll see that the configuration includes a setting for\nthe Header text on the Index page:\n\n\nTo show how environment configuration can be handled, you\u2019re going to add a secret to each\nenvironment and then substitute that value into the settings as you deploy.\n\n\n**Add environment secrets**\n\n\n1. On your repository, select **Settings**  - **Environments**  - **PRE-PROD** .\n\n2. Select **Add secret** and add a secret called index_header with the value PRE PROD News\nReader. Select **Add secret** .\n\n\n71 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n```\n\n**Figure 14**: Add an environment secret.\n\n```\n\n1. Repeat these steps to add a secret called index_header with the value PROD News Reader for\nthe PROD environment.\n\n2. If you select **Settings**  - **Secrets** in the repository, you\u2019ll see the changes. They should look\nsomething like this:\n\n```\n\n**Figure 15**: View secrets.\n\n```\n\n**Update the workflow to handle configuration**\n\n\n1. Navigate to the _.github/workflows/dotnet.yml_ file and select the pencil icon to edit the file.\n\n\n2. Add the following step before the az cli logout step in the deploy_staging job:\n\n\n:::{custom-style=CodeBox} ```yml - name: Update config uses: Azure/appservice-settings@v1\nwith: app-name: ${{ env.app-name }} slot-name: staging app-settings-json: | [ { \"name\":\n\"UI:Index:Header\", \"value\": \"${{ secrets.INDEX_HEADER }}\u201c,\u201dslotSetting\u201d: true } ]\n\n```\n\n- name: az cli logout  # <-- this exists already\n\n\n```\n\n``` :::\n\n\n72 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n3. Add almost the same code to the deploy_prod job above its az cli logout step. The only\ndifference is that you don\u2019t specify a slot-name, since you\u2019re targeting the production slot:\n\n\n:::{custom-style=CodeBox} ```yml - name: Update config uses: Azure/appservice-settings@v1\nwith: app-name: ${{ env.app-name }} app-settings-json: | [ { \"name\": \"UI:Index:Header\",\n\"value\": \"${{ secrets.INDEX_HEADER }}\u201c,\u201dslotSetting\u201d: true } ]\n\n```\n\n- name: az cli logout # <-- this exists already\n\n\n```\n\n``` :::\n\n\n4. Commit the file.\n\n\n5. Let the workflow run and approve the deployment to PROD once the approval is reached.\n\n\n6. You should see the following headers on the index page for both sites:\n\n```\n\n**Figure 16**: Settings changed in the environments.", "**Final workflow file**": "```\n\nThe final workflow file should look like this:\n\n\n73 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n74 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n### Secure .NET Code with CodeQL and GitHub Actions\n\n[CodeQL](https://codeql.github.com/docs/codeql-overview/about-codeql/) is a static code analysis engine that can automate security and quality checks. With CodeQL,\nyou can perform _variant analysis_, which uses known vulnerabilities as seeds to find similar issues.\n[CodeQL is part of GitHub Advanced Security that includes:](https://docs.github.com/github/getting-started-with-github/about-github-advanced-security)\n\n\n[!div class=\u201cchecklist\u201d]\n\n\n75 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n  - Code scanning\u2014find potential security vulnerabilities in your code.\n\n  - Secret scanning\u2014detect secrets and tokens that are committed.\n\n  - Dependency scanning\u2014detect vulnerabilities in packages that you consume.\n\n\n[CodeQL supports some of the most popular programming languages and compilers:](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/)\n\n\n  - C/C++\n\n  - Java\n\n  - C#\n\n  - Python\n\n  - Go\n\n  - JavaScript\n\n  - TypeScript\n\n\nCodeQL is a powerful language and security professionals can create custom queries using CodeQL.\nHowever, teams can benefit immensely from the large open-source collection of queries that the\nsecurity community has created without having to write any custom CodeQL.\n\n\nIn this article, you\u2019ll set up a GitHub workflow that will scan code in your repository using CodeQL.\nYou will:\n\n\n[!div class=\u201cchecklist\u201d]\n\n\n  - Create a code scanning action.\n\n  - Edit the workflow file to include custom scan settings.\n\n  - See scanning results.\n\n\n\n\n\n\n#### **Create the code scanning workflow**\n\nYou can use a starter workflow for code scanning by navigating to the **Security** tab of your repository.\n\n\n1. Navigate to your GitHub repository and select the **Security**  - **Code Scanning Alerts** . The top\nrecommended workflow should be CodeQL Analysis. Select **Set up this workflow** .\n\n```\n\n**Figure 1:** Create a new code scanning workflow.\n\n```\n\n76 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n1. A new workflow file is created in your _.github/workflows_ folder.\n\n2. Select **Start Commit** on the upper right to save the default workflow. You can commit to the\nmain branch.\n\n```\n\n**Figure 2:** Commit the file.\n\n```\n\n1. Select the **Actions** tab. In the left-hand tree, you\u2019ll see a **CodeQL** node. Select this node to\nfilter for CodeQL workflow runs.\n\n```\n\n**Figure 3:** View the CodeQL workflow runs.\n\n```\n\nTake a look at the workflow file while it runs. If you remove the comments from the file, you\u2019ll see the\nfollowing YAML:\n\n\n77 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\nNotice the following things:\n\n\n1. The workflow name is CodeQL.\n\n\n2. This workflow triggers on push and pull_request events to the main branch. There\u2019s also a\ncron trigger. The cron trigger lets you define a schedule for triggering this workflow and is\nrandomly generated for you. In this case, this workflow will run at 14:40 UTC every Saturday.\n\n\n[!TIP] If you edit the workflow file and hover over the cron expression, a tooltip will show you\nthe English text for the cron expression.\n\n\n3. There\u2019s a single job called analyze that runs on the ubuntu-latest hosted agent.\n\n\n4. This workflow defines a strategy with a matrix on the array of language. In this case, there\u2019s\nonly csharp. If the repository contained other languages, you could add them to this array.\nThis causes the job to \u201cfan out\u201d and create an instance per value of the matrix.\n\n\n5. There are four steps, starting with checkout.\n\n\n6. The second step initializes the CodeQL scanner for the language this job is going to scan.\nCodeQL intercepts calls to the compiler to build a database of the code while the code is\nbeing built.\n\n\n7. The Autobuild step will attempt to automatically build the source code using common\nconventions. If this step fails, you can replace it with your own custom build steps.\n\n\n8. After building, the CodeQL analysis is performed, where suites of queries are run against the\ncode database.\n\n\n9. The run should complete successfully. However, there appear to be no issues.\n\n\n78 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n```\n\n**Figure 4:** No results to the initial scan.", "**Customize CodeQL settings**": "```\n\nThe CodeQL scan isn\u2019t reporting any security issues. That\u2019s expected with this basic sample. CodeQL\ncan also scan for _quality_ issues. The current workflow is using the default security-extended suite. You\ncan add quality scanning in by adding a configuration file to customize the scanning suites. In this\nstep, you\u2019ll configure CodeQL to use the security-and-quality suites.\n\n\n[[!INFORMATION] For other CodeQL configuration options, see Configuring CodeQL code scanning in](https://docs.github.com/code-security/code-scanning/using-codeql-code-scanning-with-your-existing-ci-system/configuring-codeql-cli-in-your-ci-system)\n[your CI system.](https://docs.github.com/code-security/code-scanning/using-codeql-code-scanning-with-your-existing-ci-system/configuring-codeql-cli-in-your-ci-system)\n\n\n1. Navigate to the _.github_ folder in the **Code** tab and select **Add File** :\n\n```\n\n**Figure 5:** Create a new file.\n\n```\n\n1. Enter _codeql/codeql-config.yml_ as the name. This creates the file in a folder. Paste in the\nfollowing code:\n\n\n:::{custom-style=CodeBox} ```yml name: \u201cSecurity and Quality\u201d\n\n\nqueries:\n\n\n     - uses: security-and-quality ``` :::\n\n\n79 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n```\n\n**Figure 6:** Create the CodeQL configuration file.\n\n```\n\n1. Select **Commit to main** at bottom of the editor to commit the file.\n\n2. Edit the CodeQL workflow to use the new configuration file. Navigate to\n_.github/workflows/codeql-analysis.yml_ and select the pencil icon. Add a new property to the\nwith section as shown below:\n\n:::{custom-style=CodeBox} yml  - name: Initialize CodeQL   uses: github/codeql-action/init@v1\nwith:    languages: ${{ matrix.language }}    config-file: ./.github/codeql/codeql-config.yml # <-add this line :::\n\n\n1. Select **Start Commit** and commit to the main branch.\n\n#### **Review the security alerts**\n\n\n\n\n\n\n\nWhen the last CodeQL workflow run completes, you should see two issues in the **Security** tab:\n\n\n80 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n_Figure 7: View security alerts._\n\n\n1. Select the first alert to open it.\n\n2. In this case, the alert is for a generated file that isn\u2019t committed to the repository. For that\nreason, the preview is unavailable.\n\n3. Notice the tags that are applied. These tags can be used for filtering issues.\n\n4. Select **Show more** under the rule information to show help and recommendations.\n\n```\n\n**Figure 8:** Open an alert.\n\n```\n\n1. Selecting **Dismiss** will open options for dismissing this issue:\n\n\n81 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n```\n\n**Figure 9:** Dismiss an alert.\n\n```\n\n82 CHAPTER 3 | Continuous integration and deployment with Azure DevOps\n\n\n**CHAPTER**\n# 4\n\n## Monitor and debug\n\n\nHaving deployed the app and built a DevOps pipeline, it\u2019s important to understand how to monitor\nand troubleshoot the app.\n\n\nIn this section, you\u2019ll complete the following tasks:\n\n\n[!div class=\u201cchecklist\u201d]\n\n\n  - Find basic monitoring and troubleshooting data in the Azure portal\n\n  - Learn how Azure Monitor provides a deeper look at metrics across all Azure services\n\n  - Connect the web app with Application Insights for app profiling\n\n  - Turn on logging and learn where to download logs\n\n  - Stream logs in real time\n\n  - Learn where to set up alerts\n\n  - Learn about remote debugging Azure App Service web apps.\n\n### Basic monitoring and troubleshooting\n\n\nApp Service web apps are easily monitored in real time. The Azure portal renders metrics in easy-tounderstand charts and graphs.\n\n\n1. [Open the Azure portal, and then navigate to the](https://portal.azure.com/) _mywebapp<unique_number>_ App Service.\n\n\n2. The **Overview** tab displays useful \u201cat-a-glance\u201d information, including graphs displaying\nrecent metrics.\n\n\n83 CHAPTER 4 | Monitor and debug\n\n\n```\n\n['**Http 5xx**: Count of server-side errors, usually exceptions in ASP.NET Core code.', '**Data In**: Data ingress coming into your web app.', '**Data Out**: Data egress from your web app to clients.', '**Requests**: Count of HTTP requests.', '**Average Response Time**: Average time for the web app to respond to HTTP requests.']\n\nSeveral self-service tools for troubleshooting and optimization are also found on this\npage.\n\n['**Diagnose and solve problems** is a self-service troubleshooter.', '**Application Insights** is for profiling performance and app behavior, and is\\ndiscussed later in this section.', '**App Service Advisor** makes recommendations to tune your app experience.']"}, "Advanced monitoring": "```\n\n[Azure Monitor](https://docs.microsoft.com/azure/monitoring-and-diagnostics/) is the centralized service for monitoring all metrics and setting alerts across Azure\nservices. Within Azure Monitor, administrators can granularly track performance and identify trends.\n[Each Azure service offers its own set of metrics](https://docs.microsoft.com/azure/monitoring-and-diagnostics/monitoring-supported-metrics#microsoftwebsites-excluding-functions) to Azure Monitor.\n\n### Profile with Application Insights\n\n\n[Application Insights](https://docs.microsoft.com/azure/application-insights/app-insights-overview) is an Azure service for analyzing the performance and stability of web apps and\nhow users use them. The data from Application Insights is broader and deeper than that of Azure\nMonitor. The data can provide developers and administrators with key information for improving\napps. Application Insights can be added to an Azure App Service resource without code changes.\n\n\n1. [Open the Azure portal, and then navigate to the](https://portal.azure.com/) _mywebapp<unique_number>_ App Service.\n\n2. From the **Overview** tab, click the **Application Insights** tile.\n\n\n84 CHAPTER 4 | Monitor and debug\n\n\n1. Select the **Create new resource** radio button. Use the default resource name, and select the\nlocation for the Application Insights resource. The location doesn\u2019t need to match that of your\nweb app.\n\n\n1. For **Runtime/Framework**, select **ASP.NET Core** . Accept the default settings.\n\n2. Select **OK** . If prompted to confirm, select **Continue** .\n\n3. After the resource has been created, click the name of Application Insights resource to\nnavigate directly to the Application Insights page.\n\n\nAs the app is used, data accumulates. Select **Refresh** to reload the blade with new data.\n\n\n85 CHAPTER 4 | Monitor and debug\n\n\nApplication Insights provides useful server-side information with no additional configuration. To get\n[the most value from Application Insights, instrument your app with the Application Insights SDK.](https://docs.microsoft.com/azure/application-insights/app-insights-asp-net-core)\nWhen properly configured, the service provides end-to-end monitoring across the web server and\n\n\n86 CHAPTER 4 | Monitor and debug\n\n\n[browser, including client-side performance. For more information, see the Application Insights](https://docs.microsoft.com/azure/application-insights/app-insights-overview)\n[documentation.](https://docs.microsoft.com/azure/application-insights/app-insights-overview)\n\n### Logging\n\n\nWeb server and app logs are disabled by default in Azure App Service. Enable the logs with the\nfollowing steps:\n\n\n1. [Open the Azure portal, and navigate to the](https://portal.azure.com/) _mywebapp<unique_number>_ App Service.\n\n2. In the menu to the left, scroll down to the **Monitoring** section. Select **Diagnostics logs** .\n\n\n1. Turn on **Application Logging (Filesystem)** . If prompted, click the box to install the\nextensions to enable app logging in the web app.\n\n2. Set **Web server logging** to **File System** .\n\n3. Enter the **Retention Period** in days. For example, 30.\n\n4. Click **Save** .\n\n\nASP.NET Core and web server (App Service) logs are generated for the web app. They can be\ndownloaded using the FTP/FTPS information displayed. The password is the same as the deployment\n[credentials created earlier in this guide. The logs can be streamed directly to your local machine with](https://docs.microsoft.com/azure/app-service/web-sites-enable-diagnostic-log#download)\n[PowerShell or Azure CLI. Logs can also be viewed in Application Insights.](https://docs.microsoft.com/azure/app-service/web-sites-enable-diagnostic-log#download)\n\n### Log streaming\n\n\nApp and web server logs can be streamed in real time through the portal.\n\n\n1. [Open the Azure portal, and navigate to the](https://portal.azure.com/) _mywebapp<unique_number>_ App Service.\n\n2. In the menu to the left, scroll down to the **Monitoring** section and select **Log stream** .\n\n\n87 CHAPTER 4 | Monitor and debug\n\n\n[Logs can also be streamed via Azure CLI or Azure PowerShell, including through the Cloud Shell.](https://docs.microsoft.com/azure/app-service/web-sites-enable-diagnostic-log#streamlogs)\n\n### Alerts\n\n\n[Azure Monitor also provides real time alerts based on metrics, administrative events, and other](https://docs.microsoft.com/azure/monitoring-and-diagnostics/insights-alerts-portal)\ncriteria.\n\n\n\n\n\n\n\n[The Alerts (classic) service can be found in Azure Monitor or under the](https://docs.microsoft.com/azure/monitoring-and-diagnostics/monitor-quick-resource-metric-alert-portal) **Monitoring** section of the App\nService settings.\n\n### Live debugging\n\n\n[Azure App Service can be debugged remotely with Visual Studio](https://docs.microsoft.com/azure/app-service/web-sites-dotnet-troubleshoot-visual-studio#remotedebug) when logs don\u2019t provide enough\ninformation. However, remote debugging requires the app to be compiled with debug symbols.\nDebugging shouldn\u2019t be done in production, except as a last resort.\n\n\n88 CHAPTER 4 | Monitor and debug\n\n\n### Conclusion\n\nIn this section, you completed the following tasks:\n\n\n[!div class=\u201cchecklist\u201d]\n\n\n  - Find basic monitoring and troubleshooting data in the Azure portal\n\n  - Learn how Azure Monitor provides a deeper look at metrics across all Azure services\n\n  - Connect the web app with Application Insights for app profiling\n\n  - Turn on logging and learn where to download logs\n\n  - Stream logs in real time\n\n  - Learn where to set up alerts\n\n  - Learn about remote debugging Azure App Service web apps.\n\n### Additional reading\n\n\n  - [Troubleshooting ASP.NET Core on Azure App Service and IIS](https://docs.microsoft.com/aspnet/core/test/troubleshoot-azure-iis)\n\n  - [Common errors reference for Azure App Service and IIS with ASP.NET Core](https://docs.microsoft.com/aspnet/core/host-and-deploy/azure-iis-errors-reference)\n\n  - [Monitor Azure web app performance with Application Insights](https://docs.microsoft.com/azure/application-insights/app-insights-azure-web-apps)\n\n  - [Enable diagnostics logging for web apps in Azure App Service](https://docs.microsoft.com/azure/app-service/web-sites-enable-diagnostic-log)\n\n  - [Troubleshoot a web app in Azure App Service using Visual Studio](https://docs.microsoft.com/azure/app-service/web-sites-dotnet-troubleshoot-visual-studio)\n\n  - [Create classic metric alerts in Azure Monitor for Azure services - Azure portal](https://docs.microsoft.com/azure/monitoring-and-diagnostics/insights-alerts-portal)\n\n\n89 CHAPTER 4 | Monitor and debug\n\n\n**CHAPTER**\n# 5\n\n## Next steps\n\n\nIn this guide, you created a DevOps pipeline for an ASP.NET Core sample app. Congratulations! We\nhope you enjoyed learning to publish ASP.NET Core web apps to Azure App Service and automate the\ncontinuous integration of changes.\n\n\nBeyond web hosting and DevOps, Azure has a wide array of Platform-as-a-Service (PaaS) services\nuseful to ASP.NET Core developers. This section gives a brief overview of some of the most commonly\nused services.\n\n### Storage and databases\n\n\n[Redis Cache](https://docs.microsoft.com/azure/redis-cache/) is high-throughput, low-latency data caching available as a service. It can be used for\ncaching page output, reducing database requests, and providing ASP.NET Core session state across\nmultiple instances of an app.\n\n\n[Azure Storage](https://docs.microsoft.com/azure/storage/) [is Azure\u2019s massively scalable cloud storage. Developers can take advantage of Queue](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction)\n[Storage](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) [for reliable message queuing, and Table Storage](https://docs.microsoft.com/azure/storage/tables/table-storage-overview) is a NoSQL key-value store designed for\nrapid development using massive, semi-structured data sets.\n\n\n[Azure SQL Database](https://docs.microsoft.com/azure/sql-database/) provides familiar relational database functionality as a service using the Microsoft\nSQL Server Engine.\n\n\n[Cosmos DB](https://docs.microsoft.com/azure/cosmos-db/) globally distributed, multi-model NoSQL database service. Multiple APIs are available,\nincluding SQL API (formerly called DocumentDB), Cassandra, and MongoDB.\n\n### Identity\n\n\n[Azure Active Directory](https://docs.microsoft.com/azure/active-directory/) [and Azure Active Directory B2C](https://docs.microsoft.com/azure/active-directory-b2c/) are both identity services. Azure Active\nDirectory is designed for enterprise scenarios and enables Azure AD B2B (business-to-business)\ncollaboration, while Azure Active Directory B2C is intended business-to-customer scenarios, including\nsocial network sign-in.\n\n### Mobile\n\n\n[Notification Hubs](https://docs.microsoft.com/azure/notification-hubs/) is a multi-platform, scalable push-notification engine to quickly send millions of\nmessages to apps running on various types of devices.\n\n\n90 CHAPTER 5 | Next steps\n\n\n### Web infrastructure\n\n[Azure Container Service](https://docs.microsoft.com/azure/aks/) manages your hosted Kubernetes environment, making it quick and easy to\ndeploy and manage containerized apps without container orchestration expertise.\n\n\n[Azure Search](https://docs.microsoft.com/azure/search/) is used to create an enterprise search solution over private, heterogenous content.\n\n\n[Service Fabric](https://docs.microsoft.com/azure/service-fabric/) is a distributed systems platform that makes it easy to package, deploy, and manage\nscalable and reliable microservices and containers.\n\n\n91 CHAPTER 5 | Next steps\n\n```"}}}