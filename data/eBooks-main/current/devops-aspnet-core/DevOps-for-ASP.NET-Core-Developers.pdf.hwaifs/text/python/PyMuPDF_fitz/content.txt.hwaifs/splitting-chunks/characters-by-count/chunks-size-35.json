"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\nEDITION v1.1.0 \\nRefer changelog for the \", \"book updates and community contributions. \\nThis guide is available as a downloadable PDF e-book. \\nPU\", \"BLISHED BY \\nMicrosoft Developer Division, .NET, and Visual Studio product teams \\nA division of Micro\", \"soft Corporation \\nOne Microsoft Way \\nRedmond, Washington 98052-6399 \\nCopyright \\u00a9 2022 by Microsoft C\", \"orporation \\nAll rights reserved. No part of the contents of this book may be reproduced or transmitt\", \"ed in any \\nform or by any means without the written permission of the publisher. \\nThis book is provi\", \"ded \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions, and \\ninformation exp\", \"ressed in this book, including URL and other Internet website references, may change \\nwithout notice\", \". \\nSome examples depicted herein are provided for illustration only and are fictitious. No real asso\", \"ciation \\nor connection is intended or should be inferred. \\nMicrosoft and the trademarks listed at ht\", \"tps://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of compan\", \"ies. \\nMac and macOS are trademarks of Apple Inc. \\nThe Docker whale logo is a registered trademark of\", \" Docker, Inc. Used by permission. \\nAll other marks and logos are property of their respective owners\", \". \\nCredits \\nAuthors: \\nCam Soper \\nScott Addie \\nColin Dembovsky \\nWelcome \\nWelcome to the Azure Develop\", \"ment Lifecycle guide for .NET! This guide introduces the basic concepts \\nof building a development l\", \"ifecycle around Azure using .NET tools and processes. After finishing this \\nguide, you\\u2019ll reap the b\", \"enefits of a mature DevOps toolchain. \\nWho this guide is for \\n \\nYou should be an experienced ASP.NET\", \" Core developer (200-300 level). You don\\u2019t need to know \\nanything about Azure, as we\\u2019ll cover that i\", \"n this introduction. This guide may also be useful for \\nDevOps engineers who are more focused on ope\", \"rations than development. \\nThis guide targets Windows developers. However, Linux and macOS are fully\", \" supported by .NET Core. \\nTo adapt this guide for Linux/macOS, watch for callouts for Linux/macOS di\", \"fferences. \\nWhat this guide doesn\\u2019t cover \\nThis guide is focused on an end-to-end continuous deploym\", \"ent experience for .NET developers. It\\u2019s \\nnot an exhaustive guide to all things Azure, and it doesn\\u2019\", \"t focus extensively on .NET APIs for Azure \\nservices. The emphasis is all around continuous integrat\", \"ion, deployment, monitoring, and debugging. \\nNear the end of the guide, recommendations for next ste\", \"ps are offered. Included in the suggestions \\nare Azure platform services that are useful to ASP.NET \", \"Core developers. \\nWhat\\u2019s in this guide \\nTools and downloads \\nLearn where to acquire the tools used i\", \"n this guide. \\nDeploy to App Service \\nLearn the various methods for deploying an ASP.NET Core app to\", \" Azure App Service. \\nContinuous integration and deployment with Azure DevOps \\nBuild an end-to-end co\", \"ntinuous integration and deployment solution for your ASP.NET Core app with \\nGitHub, Azure DevOps Se\", \"rvices, and Azure. \\nContinuous integration and deployment with GitHub Actions \\nBuild an end-to-end c\", \"ontinuous integration and deployment solution for your ASP.NET Core app with \\nGitHub, GitHub Actions\", \", and Azure, including code scanning for security and quality using CodeQL. \\nMonitor and debug \\nUse \", \"Azure\\u2019s tools to monitor, troubleshoot, and tune your application. \\nNext steps \\nOther learning paths\", \" for the ASP.NET Core developer learning Azure. \\nAdditional introductory reading \\nIf this is your fi\", \"rst exposure to cloud computing, these articles explain the basics. \\n\\u2022 \\nWhat is Cloud Computing? \\n\\u2022 \", \"\\nExamples of Cloud Computing \\n \\n\\u2022 \\nWhat is IaaS? \\n\\u2022 \\nWhat is PaaS? \\n \\ni \\nContents \\n \\nContents \\nTools\", \" and downloads .....................................................................................\", \"......................... 1 \\nPrerequisites .........................................................\", \"....................................................................................................\", \"................. 1 \\nRecommended tools (Windows only)...............................................\", \"............................................................................... 1 \\nDeploy an app to \", \"App Service ........................................................................................\", \"........ 3 \\nDownload and test the app ..............................................................\", \"................................................................................... 3 \\nCreate the Az\", \"ure App Service Web App ............................................................................\", \"............................................. 5 \\nDeployment with Visual Studio .....................\", \"....................................................................................................\", \"................. 6 \\nDeployment slots ..............................................................\", \"....................................................................................................\", \"... 8 \\nSummary .....................................................................................\", \"............................................................................................. 10 \\nAd\", \"ditional reading ...................................................................................\", \"............................................................................. 10 \\nContinuous integra\", \"tion and deployment with Azure DevOps ......................................... 11 \\nPublish the app\\u2019\", \"s code to GitHub ...................................................................................\", \"............................................... 12 \\nDisconnect local Git deployment ................\", \"....................................................................................................\", \"............... 12 \\nCreate an Azure DevOps organization ............................................\", \"............................................................................. 13 \\nCreate a team proj\", \"ect in Azure DevOps organization ...................................................................\", \"........................ 13 \\nConfigure a self-hosted agent if necessary ............................\", \".................................................................................... 13 \\nConfigure t\", \"he Azure Pipelines pipeline ........................................................................\", \"................................................ 14 \\nGrant Azure DevOps access to the GitHub reposit\", \"ory ...................................................................................... 14 \\nCreat\", \"e the build definition .............................................................................\", \".............................................................. 16 \\nCreate the release pipeline .....\", \"....................................................................................................\", \".................................. 18 \\nCommit changes to GitHub and automatically deploy to Azure ..\", \"..................................................................... 22 \\nExamine the Azure Pipeline\", \"s pipeline .........................................................................................\", \".................................. 23 \\nBuild definition ............................................\", \"....................................................................................................\", \".................. 23 \\nRelease pipeline ............................................................\", \"....................................................................................................\", \" 26 \\nAdditional reading ............................................................................\", \".................................................................................... 29 \\nContinuous \", \"integration and deployment with Azure DevOps .......................................................\", \".................... 30 \\nPublish the app\\u2019s code to GitHub ..........................................\", \".................................................................................... 30 \\nDisconnect \", \"local Git deployment ...............................................................................\", \"................................................ 31 \\n \\nii \\nContents \\nCreate an Azure DevOps organiza\", \"tion ...............................................................................................\", \"..................... 31 \\nCreate a team project in Azure DevOps organization .......................\", \"................................................................ 32 \\nConfigure a self-hosted agent i\", \"f necessary ........................................................................................\", \"................... 32 \\nConfigure the Azure Pipelines pipeline .....................................\", \".............................................................................. 32 \\nCommit changes to\", \" GitHub and automatically deploy to Azure ..........................................................\", \"........ 40 \\nExamine the Azure Pipelines pipeline ..................................................\", \".................................................................... 41 \\nAdditional reading ........\", \"....................................................................................................\", \"............................................... 47 \\nContinuous integration and deployment with GitHu\", \"b Actions .......................................................................... 48 \\nGitHub Acti\", \"ons ................................................................................................\", \".................................................................. 48 \\nSecure code with CodeQL .....\", \"....................................................................................................\", \"................................... 48 \\nCompare and contrast GitHub Actions and Azure Pipelines ....\", \"...................................................................... 49 \\nContinuous integration an\", \"d deployment with GitHub Actions ...................................................................\", \"....... 49 \\nGitHub Actions .........................................................................\", \"......................................................................................... 49 \\nSecure\", \" code with CodeQL ..................................................................................\", \".......................................................... 50 \\nCompare and contrast GitHub Actions a\", \"nd Azure Pipelines .......................................................................... 50 \\nCo\", \"mpare and contrast GitHub Actions and Azure Pipelines ..............................................\", \"................................. 50 \\nPipelines as code ............................................\", \"....................................................................................................\", \".............. 50 \\nAgents and runners ..............................................................\", \"........................................................................................... 51 \\nComp\", \"arison of GitHub Actions and Azure Pipelines .......................................................\", \".................................. 52 \\nBuild a .NET web app using GitHub Actions ...................\", \"........................................................................................... 55 \\nWork\", \"flow structure .....................................................................................\", \"..................................................................... 55 \\nCreate a basic build workf\", \"low ................................................................................................\", \"..................................... 56 \\nDissect the workflow file ................................\", \"....................................................................................................\", \"........... 58 \\nPublish the output .................................................................\", \".......................................................................................... 59 \\nDeplo\", \"y a .NET web app using GitHub Actions ..............................................................\", \"............................................ 61 \\nEnvironments ......................................\", \"....................................................................................................\", \"........................... 61 \\nAzure authentication................................................\", \"....................................................................................................\", \"... 62 \\nAdd environments ...........................................................................\", \"................................................................................ 63 \\nDeploy to stagi\", \"ng..................................................................................................\", \"........................................................... 65 \\nDeploy to production ...............\", \"....................................................................................................\", \".................................. 68 \\nAdd a manual queue option ...................................\", \"....................................................................................................\", \". 70 \\nHandle environment configuration..............................................................\", \"............................................................. 71 \\n \\niii \\nContents \\nFinal workflow fi\", \"le .................................................................................................\", \"........................................................... 73 \\nSecure .NET Code with CodeQL and Git\", \"Hub Actions ........................................................................................\", \"..... 75 \\nCreate the code scanning workflow ........................................................\", \"................................................................. 76 \\nCustomize CodeQL settings ....\", \"....................................................................................................\", \"................................. 79 \\nReview the security alerts ...................................\", \"....................................................................................................\", \"...... 80 \\nMonitor and debug .......................................................................\", \"........................................ 83 \\nBasic monitoring and troubleshooting ..................\", \"....................................................................................................\", \".. 83 \\nAdvanced monitoring .........................................................................\", \"................................................................................ 84 \\nProfile with Ap\", \"plication Insights .................................................................................\", \".................................................... 84 \\nLogging ...................................\", \"....................................................................................................\", \".............................................. 87 \\nLog streaming ...................................\", \"....................................................................................................\", \"................................. 87 \\nAlerts .......................................................\", \"....................................................................................................\", \"............................... 88 \\nLive debugging .................................................\", \"....................................................................................................\", \"................. 88 \\nConclusion ...................................................................\", \"....................................................................................................\", \"........ 89 \\nAdditional reading ....................................................................\", \"............................................................................................ 89 \\nNex\", \"t steps ............................................................................................\", \".................................. 90 \\nStorage and databases .......................................\", \"....................................................................................................\", \"............ 90 \\nIdentity ..........................................................................\", \"....................................................................................................\", \"........ 90 \\nMobile ................................................................................\", \"....................................................................................................\", \"... 90 \\nWeb infrastructure .........................................................................\", \"....................................................................................... 91 \\n \\n1 \\nCHA\", \"PTER 1 | Tools and downloads \\n \\nCHAPTER 1 \\nTools and downloads \\nAzure has several interfaces for pro\", \"visioning and managing resources, such as the Azure portal, Azure \\nCLI, Azure PowerShell, Azure Clou\", \"d Shell, and Visual Studio. This guide takes a minimalist approach \\nand uses the Azure Cloud Shell w\", \"henever possible to reduce the steps required. However, the Azure \\nportal must be used for some port\", \"ions. \\nPrerequisites \\nThe following subscriptions are required: \\n\\u2022 \\nAzure \\u2014 If you don\\u2019t have an acc\", \"ount, get a free trial. \\n\\u2022 \\nAzure DevOps Services \\u2014 your Azure DevOps subscription and organization \", \"is created in \\nChapter 4. \\n\\u2022 \\nGitHub \\u2014 If you don\\u2019t have an account, sign up for free. \\nThe followin\", \"g tools are required: \\n\\u2022 \\nGit \\u2014 A fundamental understanding of Git is recommended for this guide. Re\", \"view the Git \\ndocumentation, specifically git remote and git push. \\n\\u2022 \\n.NET Core SDK \\u2014 Version 2.1.3\", \"00 or later is required to build and run the sample app. If \\nVisual Studio is installed with the .NE\", \"T Core cross-platform development workload, the \\n.NET Core SDK is already installed. \\n  \\nVerify your\", \" .NET Core SDK installation. Open a command shell, and run the following \\ncommand: \\n  \\n:::{custom-st\", \"yle=CodeBox} dotnetcli   dotnet --version ::: \\nRecommended tools (Windows only) \\n\\u2022 \\nVisual Studio\\u2019s \", \"robust Azure tools provide a GUI for most of the functionality described in this \\nguide. Any edition\", \" of Visual Studio will work, including the free Visual Studio Community \\nEdition. The tutorials are \", \"written to demonstrate development, deployment, and DevOps both \\nwith and without Visual Studio. \\n  \", \"\\nConfirm that Visual Studio has the following workloads installed: \\n\\u2013 \\nASP.NET and web development \\n\", \"\\u2013 \\nAzure development \\n \\n2 \\nCHAPTER 1 | Tools and downloads \\n \\n\\u2013 \\n.NET Core cross-platform developmen\", \"t \\n \\n3 \\nCHAPTER 2 | Deploy an app to App Service \\n \\nCHAPTER 2 \\nDeploy an app to App \\nService \\nAzure \", \"App Service is Azure\\u2019s web hosting platform. Deploying a web app to Azure App Service can be \\ndone m\", \"anually or by an automated process. This section of the guide discusses deployment methods \\nthat can\", \" be triggered manually or by script using the command line, or triggered manually using \\nVisual Stud\", \"io. \\nIn this section, you\\u2019ll accomplish the following tasks: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nDownload \", \"and build the sample app. \\n\\u2022 \\nCreate an Azure App Service Web App using the Azure Cloud Shell. \\n\\u2022 \\nD\", \"eploy the sample app to Azure using Git. \\n\\u2022 \\nDeploy a change to the app using Visual Studio. \\n\\u2022 \\nAdd\", \" a staging slot to the web app. \\n\\u2022 \\nDeploy an update to the staging slot. \\n\\u2022 \\nSwap the staging and p\", \"roduction slots. \\nDownload and test the app \\nThe app used in this guide is a pre-built ASP.NET Core \", \"app, Simple Feed Reader. It\\u2019s an ASP.NET Core \\nRazor Pages app that uses the Microsoft.SyndicationFe\", \"ed.ReaderWriter API to retrieve an RSS/Atom \\nfeed and display the news items in a list. \\nFeel free t\", \"o review the code, but it\\u2019s important to understand that there\\u2019s nothing special about this \\napp. It\", \"\\u2019s just a simple ASP.NET Core app for illustrative purposes. \\nFrom a command shell, download the cod\", \"e, build the project, and run it as follows. \\nNote \\nLinux and macOS users should make appropriate ch\", \"anges for paths, for example, using forward slash \\n(/) rather than back slash (\\\\).* \\n1. \\nClone the c\", \"ode to a folder on your local machine. \\n \\n4 \\nCHAPTER 2 | Deploy an app to App Service \\n \\n  \\n:::{cust\", \"om-style=CodeBox} console  git clone https://github.com/dotnet-architecture/simple-\\nfeed-reader/ :::\", \" \\n2. \\nChange your working folder to the simple-feed-reader folder that was created. \\n  \\n:::{custom-s\", \"tyle=CodeBox} console  cd .\\\\simple-feed-reader\\\\SimpleFeedReader ::: \\n3. \\nRestore the packages, and b\", \"uild the solution. \\n  \\n:::{custom-style=CodeBox} dotnetcli  dotnet build ::: \\n4. \\nRun the app. \\n  \\n:\", \"::{custom-style=CodeBox} dotnetcli  dotnet run ::: \\n         \\n \\n5. \\nOpen a browser and navigate to h\", \"ttp://localhost:5000. The app allows you to type or paste a \\nsyndication feed URL and view a list of\", \" news items. \\n     \\n \\n \\n \\n5 \\nCHAPTER 2 | Deploy an app to App Service \\n \\n6. \\nOnce you\\u2019re satisfied t\", \"he app is working correctly, shut it down by pressing Ctrl+C in the \\ncommand shell. \\nCreate the Azur\", \"e App Service Web App \\nTo deploy the app, you\\u2019ll need to create an App Service Web App. After creati\", \"on of the Web App, \\nyou\\u2019ll deploy to it from your local machine using Git. \\n1. \\nSign in to the Azure\", \" Cloud Shell. Note: When you sign in for the first time, Cloud Shell \\nprompts to create a storage ac\", \"count for configuration files. Accept the defaults or provide a \\nunique name. \\n2. \\nUse the Cloud She\", \"ll for the following steps. \\na. \\nDeclare a variable to store your web app\\u2019s name. The name must be u\", \"nique to be \\nused in the default URL. Using the $RANDOM Bash function to construct the name \\nguarant\", \"ees uniqueness and results in the format webappname99999. \\n  \\n:::{custom-style=CodeBox} console  web\", \"appname=mywebapp$RANDOM ::: \\nb. \\nCreate a resource group. Resource groups provide a means to aggrega\", \"te Azure \\nresources to be managed as a group. \\n  \\n:::{custom-style=CodeBox} azurecli  az group creat\", \"e --location centralus --name AzureTutorial \\n::: \\n  \\nThe az command invokes the Azure CLI. The CLI c\", \"an be run locally, but using it in the Cloud \\nShell saves time and configuration. \\nc. \\nCreate an App\", \" Service plan in the S1 tier. An App Service plan is a grouping of web \\napps that share the same pri\", \"cing tier. The S1 tier isn\\u2019t free, but it\\u2019s required for the \\nstaging slots feature. \\n  \\n:::{custom-\", \"style=CodeBox} azurecli  az appservice plan create --name $webappname --\\nresource-group AzureTutoria\", \"l --sku S1 ::: \\nd. \\nCreate the web app resource using the App Service plan in the same resource grou\", \"p. \\n  \\n:::{custom-style=CodeBox} azurecli  az webapp create --name $webappname --resource-\\ngroup Azu\", \"reTutorial --plan $webappname ::: \\ne. \\nSet the deployment branch to main in the appsettings configur\", \"ation. \\n  \\n:::{custom-style=CodeBox} azurecli  az webapp config appsettings set --name $webappname -\", \"\\n-resource-group AzureTutorial --settings DEPLOYMENT_BRANCH=main ::: \\nf. \\nSet the deployment credent\", \"ials. These deployment credentials apply to all the web \\napps in your subscription. Don\\u2019t use specia\", \"l characters in the user name. \\n  \\n:::{custom-style=CodeBox} azurecli  az webapp deployment user set\", \" --user-name \\nREPLACE_WITH_USER_NAME --password REPLACE_WITH_PASSWORD ::: \\n \\n6 \\nCHAPTER 2 | Deploy a\", \"n app to App Service \\n \\ng. \\nConfigure the web app to accept deployments from local Git and display t\", \"he Git \\ndeployment URL. Note this URL for reference later. \\n  \\n:::{custom-style=CodeBox} azurecli  e\", \"cho Git deployment URL: $(az webapp deployment \\nsource config-local-git --name $webappname --resourc\", \"e-group AzureTutorial --query url --\\noutput tsv) ::: \\nh. \\nDisplay the web app URL. Browse to this UR\", \"L to see the blank web app. Note this \\nURL for reference later. \\n  \\n:::{custom-style=CodeBox} consol\", \"e  echo Web app URL: \\nhttp://$webappname.azurewebsites.net ::: \\n3. \\nUsing a command shell on your lo\", \"cal machine, navigate to the web app\\u2019s project folder (for \\nexample, *.-feed-reader). Execute the fo\", \"llowing commands to set up Git to push to the \\ndeployment URL: \\na. \\nAdd the remote URL to the local \", \"repository. \\n  \\n:::{custom-style=CodeBox} console  git remote add azure-prod GIT_DEPLOYMENT_URL ::: \", \"\\nb. \\nPush the local default branch (main) to the azure-prod remote\\u2019s deployment branch \\n(main). \\n  \\n\", \":::{custom-style=CodeBox} console  git push azure-prod main ::: \\n  \\nYou\\u2019ll be prompted for the deplo\", \"yment credentials you created earlier. Observe the output in \\nthe command shell. Azure builds the AS\", \"P.NET Core app remotely. \\n4. \\nIn a browser, navigate to the Web app URL and note the app has been bu\", \"ilt and deployed. \\nAdditional changes can be committed to the local Git repository with git commit. \", \"These \\nchanges are pushed to Azure with the preceding git push command. \\nDeployment with Visual Stud\", \"io \\nNote \\nThis section applies to Windows only. Linux and macOS users should make the change describ\", \"ed in \\nstep 2 below. Save the file, and commit the change to the local repository with git commit. F\", \"inally, \\npush the change with git push, as in the first section.* \\nThe app has already been deployed\", \" from the command shell. Let\\u2019s use Visual Studio\\u2019s integrated tools \\nto deploy an update to the app.\", \" Behind the scenes, Visual Studio accomplishes the same thing as the \\ncommand line tooling, but with\", \"in Visual Studio\\u2019s familiar UI. \\n1. \\nOpen SimpleFeedReader.sln in Visual Studio. \\n2. \\nIn Solution Ex\", \"plorer, open Pages.cshtml. Change <h2>Simple Feed Reader</h2> to \\n<h2>Simple Feed Reader - V2</h2>. \", \"\\n3. \\nPress Ctrl+Shift+B to build the app. \\n4. \\nIn Solution Explorer, right-click on the project and \", \"click Publish. \\n \\n7 \\nCHAPTER 2 | Deploy an app to App Service \\n \\n       \\n \\n    \\n5. \\nVisual Studio ca\", \"n create a new App Service resource, but this update will be published over \\nthe existing deployment\", \". In the Pick a publish target dialog, select App Service from the list \\non the left, and then selec\", \"t Select Existing. Click Publish. \\n6. \\nIn the App Service dialog, confirm that the Microsoft or Orga\", \"nizational account used to \\ncreate your Azure subscription is displayed in the upper right. If it\\u2019s \", \"not, click the drop-down \\nand add it. \\n7. \\nConfirm that the correct Azure Subscription is selected. \", \"For View, select Resource Group. \\nExpand the AzureTutorial resource group and then select the existi\", \"ng web app. Click OK. \\n            \\n \\nVisual Studio builds and deploys the app to Azure. Browse to t\", \"he web app URL. Validate that the \\n<h2> element modification is live. \\n \\n8 \\nCHAPTER 2 | Deploy an ap\", \"p to App Service \\n \\n \\nDeployment slots \\nDeployment slots support the staging of changes without impa\", \"cting the app running in production. \\nOnce the staged version of the app is validated by a quality a\", \"ssurance team, the production and \\nstaging slots can be swapped. The app in staging is promoted to p\", \"roduction in this manner. The \\nfollowing steps create a staging slot, deploy some changes to it, and\", \" swap the staging slot with \\nproduction after verification. \\n1. \\nSign in to the Azure Cloud Shell, i\", \"f not already signed in. \\n2. \\nCreate the staging slot. \\na. \\nCreate a deployment slot with the name s\", \"taging. \\n  \\n:::{custom-style=CodeBox} azurecli  az webapp deployment slot create --name $webappname \", \"\\n--resource-group AzureTutorial --slot staging ::: \\nb. \\nSet the deployment branch to main in the app\", \"settings configuration. \\n  \\n:::{custom-style=CodeBox} azurecli  az webapp config appsettings set --n\", \"ame $webappname -\\n-resource-group AzureTutorial --slot staging --settings DEPLOYMENT_BRANCH=main :::\", \" \\nc. \\nConfigure the staging slot to use deployment from local Git and get the staging \\ndeployment UR\", \"L. Note this URL for reference later. \\n  \\n:::{custom-style=CodeBox} azurecli  echo Git deployment UR\", \"L for staging: $(az webapp \\ndeployment source config-local-git --name $webappname --resource-group A\", \"zureTutorial --\\nslot staging --query url --output tsv) ::: \\nd. \\nDisplay the staging slot\\u2019s URL. Brow\", \"se to the URL to see the empty staging slot. Note \\nthis URL for reference later. \\n \\n9 \\nCHAPTER 2 | D\", \"eploy an app to App Service \\n \\n  \\n:::{custom-style=CodeBox} console  echo Staging web app URL: http:\", \"//$webappname-\\nstaging.azurewebsites.net ::: \\n3. \\nIn a text editor or Visual Studio, modify Pages/In\", \"dex.cshtml again so that the <h2> element \\nreads <h2>Simple Feed Reader - V3</h2> and save the file.\", \" \\n4. \\nCommit the file to the local Git repository, using either the Changes page in Visual Studio\\u2019s \", \"\\nTeam Explorer tab, or by entering the following using the local machine\\u2019s command shell: \\n  \\n:::{cu\", \"stom-style=CodeBox} console  git commit -a -m \\\"upgraded to V3\\\" ::: \\n5. \\nUsing the local machine\\u2019s co\", \"mmand shell, add the staging deployment URL as a Git remote \\nand push the committed changes: \\na. \\nAd\", \"d the remote URL for staging to the local Git repository. \\n  \\n:::{custom-style=CodeBox} console  git\", \" remote add azure-staging \\n<Git_staging_deployment_URL> ::: \\nb. \\nPush the local default branch (main\", \") to the azure-staging remote\\u2019s deployment \\nbranch (main). \\n  \\n:::{custom-style=CodeBox} console  gi\", \"t push azure-staging main ::: \\n  \\nWait while Azure builds and deploys the app. \\n6. \\nTo verify that V\", \"3 has been deployed to the staging slot, open two browser windows. In one \\nwindow, navigate to the o\", \"riginal web app URL. In the other window, navigate to the staging \\nweb app URL. The production URL s\", \"erves V2 of the app. The staging URL serves V3 of the \\napp. \\n \\n \\n7. \\nIn the Cloud Shell, swap the ve\", \"rified/warmed-up staging slot into production. \\n \\n10 \\nCHAPTER 2 | Deploy an app to App Service \\n \\n  \", \"\\n:::{custom-style=CodeBox} azurecli  az webapp deployment slot swap --name $webappname -\\n-resource-g\", \"roup AzureTutorial --slot staging ::: \\n8. \\nVerify that the swap occurred by refreshing the two brows\", \"er windows. \\n \\n       \\n \\nSummary \\nIn this section, the following tasks were completed: \\n\\u2022 \\nDownloade\", \"d and built the sample app. \\n\\u2022 \\nCreated an Azure App Service Web App using the Azure Cloud Shell. \\n\\u2022\", \" \\nDeployed the sample app to Azure using Git. \\n\\u2022 \\nDeployed a change to the app using Visual Studio. \", \"\\n\\u2022 \\nAdded a staging slot to the web app. \\n\\u2022 \\nDeployed an update to the staging slot. \\n\\u2022 \\nSwapped the\", \" staging and production slots. \\nIn the next section, you\\u2019ll learn how to build a DevOps pipeline wit\", \"h Azure Pipelines. \\nAdditional reading \\n\\u2022 \\nWeb Apps overview \\n\\u2022 \\nBuild a .NET Core and SQL Database \", \"web app in Azure App Service \\n\\u2022 \\nConfigure deployment credentials for Azure App Service \\n\\u2022 \\nSet up s\", \"taging environments in Azure App Service \\n \\n11 \\nCHAPTER 3 | Continuous integration and deployment wi\", \"th Azure DevOps \\n \\nCHAPTER 3 \\nContinuous integration \\nand deployment with \\nAzure DevOps \\nNote \\nThis \", \"section details continuous integration and deployment with Azure DevOps. You can achieve that \\nwith \", \"GitHub Actions as well. GitHub Actions is a workflow engine built into GitHub that can also be \\nused\", \" for continuous integration and deployment. To follow the guide for building and deploying to \\nAzure\", \" using GitHub, complete the Publish the app\\u2019s code to GitHub and Disconnect local Git \\ndeployment se\", \"ctions below and then proceed to the GitHub Actions section. \\nIn the previous chapter, you created a\", \" local Git repository for the Simple Feed Reader app. In this \\nchapter, you\\u2019ll publish that code to \", \"a GitHub repository and construct an Azure DevOps Services \\npipeline using Azure Pipelines. The pipe\", \"line enables continuous builds and deployments of the app. \\nAny commit to the GitHub repository trig\", \"gers a build and a deployment to the Azure Web App\\u2019s \\nstaging slot. \\nIn this section, you\\u2019ll complet\", \"e the following tasks: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nPublish the app\\u2019s code to GitHub \\n\\u2022 \\nDisconnect\", \" local Git deployment \\n\\u2022 \\nCreate an Azure DevOps organization \\n\\u2022 \\nCreate a team project in Azure Dev\", \"Ops organization \\n\\u2022 \\nConfigure a self-hosted agent if necessary \\n\\u2022 \\nCreate a build definition \\n\\u2022 \\nCr\", \"eate a release pipeline \\n\\u2022 \\nCommit changes to GitHub and automatically deploy to Azure \\n\\u2022 \\nExamine t\", \"he Azure Pipelines pipeline \\n \\n12 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevO\", \"ps \\n \\nPublish the app\\u2019s code to GitHub \\n1. \\nOpen a browser window, and navigate to https://github.co\", \"m. \\n2. \\nClick the + drop-down in the header, and select New repository: \\n       \\n \\n       \\n1. \\nSelec\", \"t your account in the Owner drop-down, and enter simple-feed-reader in the Repository \\nname textbox.\", \" \\n2. \\nClick the Create repository button. \\n3. \\nOpen your local machine\\u2019s command shell. Navigate to \", \"the directory in which the simple-feed-\\nreader Git repository is stored. \\n4. \\nRename the existing or\", \"igin remote to upstream. Execute the following command: \\n  \\n:::{custom-style=CodeBox} console  git r\", \"emote rename origin upstream ::: \\n5. \\nAdd a new origin remote pointing to your copy of the repositor\", \"y on GitHub. Execute the \\nfollowing command: \\n  \\n:::{custom-style=CodeBox} console  git remote add o\", \"rigin \\nhttps://github.com/<GitHub_username>/simple-feed-reader/ ::: \\n6. \\nPublish your local Git repo\", \"sitory to the newly created GitHub repository. Execute the following \\ncommand: \\n  \\n:::{custom-style=\", \"CodeBox} console  git push -u origin main ::: \\n7. \\nOpen a browser window, and navigate to https://gi\", \"thub.com/<GitHub_username>/simple-\\nfeed-reader/. Validate that your code appears in the GitHub repos\", \"itory. \\nDisconnect local Git deployment \\nRemove the local Git deployment with the following steps. A\", \"zure Pipelines (an Azure DevOps service) \\nboth replaces and augments that functionality. \\n1. \\nOpen t\", \"he Azure portal, and navigate to the staging (mywebapp<unique_number>/staging) \\nWeb App. The Web App\", \" can be quickly located by entering staging in the portal\\u2019s search box: \\n \\n \\n13 \\nCHAPTER 3 | Continu\", \"ous integration and deployment with Azure DevOps \\n \\n \\n \\nClick Deployment Center. A new panel appears\", \". Click Disconnect to remove the local Git \\nsource control configuration that was added in the previ\", \"ous chapter. Confirm the \\nremoval operation by clicking the Yes button. \\n1. \\nNavigate to the mywebap\", \"p App Service. As a reminder, the portal\\u2019s search box can be used to \\nquickly locate the App Service\", \". \\n2. \\nClick Deployment Center. A new panel appears. Click Disconnect to remove the local Git \\nsourc\", \"e control configuration that was added in the previous chapter. Confirm the removal \\noperation by cl\", \"icking the Yes button. \\nCreate an Azure DevOps organization \\n1. \\nOpen a browser, and navigate to the\", \" Azure DevOps organization creation page. \\n2. \\nSelect New organization \\n3. \\nConfirm the information,\", \" and then select Continue. \\n4. \\nSign in to your organization at any time, https://dev.azure.com/{you\", \"rorganization} \\nCreate a team project in Azure DevOps organization \\n1. \\nChoose the organization, and\", \" then select New project. \\n2. \\nEnter the project name as MyFirstProject and select the Visibility as\", \" Private \\n3. \\nSelect Create project. \\nFor more information, see Create a project \\nConfigure a self-h\", \"osted agent if necessary \\nTo build your code or deploy your software using Azure Pipelines, you need\", \" at least one agent. In \\nAzure Pipelines, you can run parallel jobs on either Microsoft-hosted or se\", \"lf-hosted agent. But with \\nthe recent change in Azure Pipelines free grant of parallel jobs is tempo\", \"rarily disable for the public \\nprojects.For more details, refer Configure and pay for parallel jobs.\", \" \\nGo to Organization Settings and then Pipelines > Parallel jobs. If you see value 0 under Microsoft\", \"-\\nhosted that means you need a Self-hosted agent to run your pipeline. \\n \\n14 \\nCHAPTER 3 | Continuous\", \" integration and deployment with Azure DevOps \\n \\n \\nYou can create that by following details mentione\", \"d in Self-hosted agents. After successful \\nconfiguration, you\\u2019ll be able to see available agent unde\", \"r Organization Settings > Agent pools > \\n{youragentname} \\n \\nConfigure the Azure Pipelines pipeline \\n\", \"There are three distinct steps to complete. Completing the steps in the following three sections res\", \"ults \\nin an operational DevOps pipeline. \\nGrant Azure DevOps access to the GitHub repository \\n1. \\nIn\", \" your project, navigate to the Pipelines page. Then choose the action to create a new \\npipeline: \\n \\n\", \" \\n \\n15 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n1. \\nUse Use the class\", \"ic editor to create the pipeline. \\n             \\n \\n1. \\nSelect the GitHub option from the Select a so\", \"urce section:: \\n \\n            \\n1. \\nAuthorization is required before Azure DevOps can access your Git\", \"Hub repository. Enter  \\nGitHub connection in the Connection name textbox. For example: \\n       \\n \\n \\n\", \"1. \\nIf two-factor authentication is enabled on your GitHub account, a personal access token is \\nrequ\", \"ired. In that case, click the Authorize with a GitHub personal access token link. See the \\nofficial \", \"GitHub personal access token creation instructions for help. Only the repo scope of \\npermissions is \", \"needed. Otherwise, click the Authorize using OAuth button. \\n \\n16 \\nCHAPTER 3 | Continuous integration\", \" and deployment with Azure DevOps \\n \\n2. \\nWhen prompted, sign in to your GitHub account. Then select \", \"Authorize to grant access to \\nyour Azure DevOps organization. If successful, a new service endpoint \", \"is created. \\n3. \\nClick the ellipsis button next to the Repository button. Select the /simple-feed-re\", \"ader \\nrepository from the list. Click the Select button. \\n4. \\nSelect the default branch (main) from \", \"the Default branch for manual and scheduled builds \\ndrop-down. Click the Continue button. The templa\", \"te selection page appears. \\nCreate the build definition \\n1. \\nFrom the template selection page, enter\", \" ASP.NET Core in the search box: \\n \\n \\n1. \\nThe template search results appear. Hover over the ASP.NET\", \" Core template, and click the \\nApply button. \\n2. \\nThe Tasks tab of the build definition appears. Sel\", \"ect the self-hosted Agent pool if you have \\ncreated that in the earlier step. \\n       \\n \\n \\n> [!NOTE]\", \" \\n> If you are using MS-hosted agent then select the *Hosted > Azure Pipelines* from \\ndrop down. \\n \\n\", \"17 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n1. \\nClick the Triggers ta\", \"b. \\n2. \\nCheck the Enable continuous integration box. Under the Branch filters section, confirm \\nthat\", \" the Type drop-down is set to Include. Set the Branch specification drop-down to main. \\n \\nThese sett\", \"ings cause a build to trigger when any change is pushed to the default \\nbranch (*main*) of the GitHu\", \"b repository. Continuous integration is tested in the \\n[Commit changes to GitHub and automatically d\", \"eploy to Azure](#commit-changes-to-\\ngithub-and-automatical) section. \\n1. \\nClick the Save & queue but\", \"ton, and select the Save option: \\n      \\n \\n1. \\nThe following modal dialog appears: \\n \\nUse the defaul\", \"t folder of *\\\\\\\\*, and click the **Save** button. \\n \\n18 \\nCHAPTER 3 | Continuous integration and deplo\", \"yment with Azure DevOps \\n \\nCreate the release pipeline \\n1. \\nClick the Releases tab of your team proj\", \"ect. Click the New pipeline button. \\n \\nThe template selection pane appears. \\n1. \\nFrom the template s\", \"election page, enter App Service Deployment in the search box: \\n             \\n \\n \\n1. \\nThe template s\", \"earch results appear. Hover over the Azure App Service Deployment with \\nSlot template, and click the\", \" Apply button. The Pipeline tab of the release pipeline appears. \\n \\n19 \\nCHAPTER 3 | Continuous integ\", \"ration and deployment with Azure DevOps \\n \\n \\n \\n1. \\nClick the Add button in the Artifacts box. The Ad\", \"d artifact panel appears: \\n \\n \\n \\n1. \\nSelect the Build tile from the Source type section. This type a\", \"llows for the linking of the \\nrelease pipeline to the build definition. \\n2. \\nSelect MyFirstProject f\", \"rom the Project drop-down. \\n3. \\nSelect the build definition name, MyFirstProject-ASP.NET Core-CI, fr\", \"om the Source (Build \\ndefinition) drop-down. \\n4. \\nSelect Latest from the Default version drop-down. \", \"This option builds the artifacts produced \\nby the latest run of the build definition. \\n \\n20 \\nCHAPTER\", \" 3 | Continuous integration and deployment with Azure DevOps \\n \\n5. \\nReplace the text in the Source a\", \"lias textbox with Drop. \\n6. \\nClick the Add button. The Artifacts section updates to display the chan\", \"ges. \\n7. \\nClick the lightning bolt icon to enable continuous deployments: \\n      \\n \\n \\nWith this opti\", \"on enabled, a deployment occurs each time a new build is available. \\n1. \\nA Continuous deployment tri\", \"gger panel appears to the right. Click the toggle button to \\nenable the feature. It isn\\u2019t necessary \", \"to enable the Pull request trigger. \\n2. \\nClick the Add drop-down in the Build branch filters section\", \". Choose the Build Definition\\u2019s \\ndefault branch option. This filter causes the release to trigger on\", \"ly for a build from the \\nGitHub repository\\u2019s default branch (main). \\n3. \\nClick the Save button. Clic\", \"k the OK button in the resulting Save modal dialog. \\n4. \\nClick the Stage 1 box. An Stage panel appea\", \"rs to the right. Change the Stage 1 text in the \\nStage name textbox to Production. \\n \\n1. \\nClick the \", \"1 phase, 2 tasks link in the Production box: \\n \\n21 \\nCHAPTER 3 | Continuous integration and deploymen\", \"t with Azure DevOps \\n \\n \\nThe **Tasks** tab of the environment appears. \\n1. \\nClick the Deploy Azure A\", \"pp Service to Slot task. Its settings appear in a panel to the right. \\n2. \\nSelect the Azure subscrip\", \"tion associated with the App Service from the Azure subscription \\ndrop-down. Once selected, click th\", \"e Authorize button. \\n3. \\nSelect Web App from the App type drop-down. \\n4. \\nSelect mywebapp/ from the \", \"App service name drop-down. \\n5. \\nSelect AzureTutorial from the Resource group drop-down. \\n6. \\nSelect\", \" staging from the Slot drop-down. \\n7. \\nSelect Run on agent* under Tasks. On the right pane, you\\u2019ll s\", \"ee Agent Job. \\n8. \\nSelect the self-hosted Agent pool if you have created that in the earlier step. \\n\", \" \\n \\n> [!NOTE] \\n> If you are using MS-hosted agent then select the *Hosted > Azure Pipelines* from \\nd\", \"rop down. \\n1. \\nClick the Save button. \\n2. \\nHover over the default release pipeline name. Click the p\", \"encil icon to edit it. Use \\nMyFirstProject-ASP.NET Core-CD as the name. \\n \\n22 \\nCHAPTER 3 | Continuou\", \"s integration and deployment with Azure DevOps \\n \\n       \\n \\n \\n1. \\nClick the Save button. \\nCommit cha\", \"nges to GitHub and automatically \\ndeploy to Azure \\n1. \\nOpen SimpleFeedReader.sln in Visual Studio. \\n\", \"2. \\nIn Solution Explorer, open Pages.cshtml. Change <h2>Simple Feed Reader - V3</h2> to \\n<h2>Simple \", \"Feed Reader - V4</h2>. \\n3. \\nPress Ctrl+Shift+B to build the app. \\n4. \\nCommit the file to the GitHub \", \"repository. Use either the Changes page in Visual Studio\\u2019s \\nTeam Explorer tab, or execute the follow\", \"ing using the local machine\\u2019s command shell: \\n  \\n:::{custom-style=CodeBox} console  git commit -a -m\", \" \\\"upgraded to V4\\\" ::: \\n5. \\nPush the change in the default branch (main) to the origin remote of your\", \" GitHub repository. \\nIn the following command, replace the placeholder {BRANCH} with the default bra\", \"nch (use \\nmain): \\n  \\n:::{custom-style=CodeBox} console  git push origin {BRANCH} ::: \\n  \\nThe commit \", \"appears in the GitHub repository\\u2019s default branch (main). You\\u2019ll be able to see the \\ncommit history \", \"in https://github.com/<GitHub_username>/simple-feed-\\nreader/commits/main. \\n  \\nThe build is triggered\", \", since continuous integration is enabled in the build definition\\u2019s \\nTriggers tab: \\n  \\n \\n \\n \\n23 \\nCHA\", \"PTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n1. \\nNavigate to the Pipelines. Y\", \"ou\\u2019ll see the CI pipeline details and monitor each steps if you drill \\ndown Jobs details. \\n \\n1. \\nSim\", \"ilarly, go to the Releases tab to see the details of CD pipeline. You can always drill down \\nfurther\", \" to see more details of each step. \\n \\n1. \\nOnce the build succeeds, a deployment to Azure occurs. Nav\", \"igate to the app in the browser. \\nNotice that the \\u201cV4\\u201d text appears in the heading: \\n \\nExamine the A\", \"zure Pipelines pipeline \\nBuild definition \\nA build definition was created with the name MyFirstProje\", \"ct-ASP.NET Core-CI. Upon completion, the \\nbuild produces a .zip file including the assets to be publ\", \"ished. The release pipeline deploys those \\nassets to Azure. \\nThe build definition\\u2019s Tasks tab lists \", \"the individual steps being used. There are five build tasks. \\n \\n24 \\nCHAPTER 3 | Continuous integrati\", \"on and deployment with Azure DevOps \\n \\n \\n1. \\nRestore \\u2014 Executes the dotnet restore command to restor\", \"e the app\\u2019s NuGet packages. The \\ndefault package feed used is nuget.org. \\n2. \\nBuild \\u2014 Executes the d\", \"otnet build --configuration release command to compile the app\\u2019s \\ncode. This --configuration option \", \"is used to produce an optimized version of the code, which \\nis suitable for deployment to a producti\", \"on environment. Modify the BuildConfiguration \\nvariable on the build definition\\u2019s Variables tab if, \", \"for example, a debug configuration is \\nneeded. \\n3. \\nTest \\u2014 Executes the dotnet test --configuration \", \"release --logger trx --results-directory \\n<local_path_on_build_agent> command to run the app\\u2019s unit \", \"tests. Unit tests are executed \\nwithin any C# project matching the **/Tests/.csproj glob pattern. Te\", \"st results are saved in a .trx \\nfile at the location specified by the --results-directory option. If\", \" any tests fail, the build fails \\nand isn\\u2019t deployed. \\n \\n25 \\nCHAPTER 3 | Continuous integration and \", \"deployment with Azure DevOps \\n \\n  \\n[!NOTE] To verify the unit tests work, modify SimpleFeedReader.Te\", \"sts.cs to purposefully break \\none of the tests. For example, change Assert.True(result.Count > 0); t\", \"o \\nAssert.False(result.Count > 0); in the Returns_News_Stories_Given_Valid_Uri method. Commit \\nand p\", \"ush the change to GitHub. The build is triggered and fails. The build pipeline status \\nchanges to fa\", \"iled. Revert the change, commit, and push again. The build succeeds. \\n4. \\nPublish \\u2014 Executes the dot\", \"net publish --configuration release --output \\n<local_path_on_build_agent> command to produce a .zip \", \"file with the artifacts to be \\ndeployed. The --output option specifies the publish location of the .\", \"zip file. That location is \\nspecified by passing a predefined variable named $(build.artifactstaging\", \"directory). That \\nvariable expands to a local path, such as *c:_work\\\\1, on the build agent. \\n5. \\nPub\", \"lish Artifact \\u2014 Publishes the .zip file produced by the Publish task. The task accepts the \\n.zip fil\", \"e location as a parameter, which is the predefined variable \\n$(build.artifactstagingdirectory). The \", \".zip file is published as a folder named drop. \\nClick the build definition\\u2019s Summary link to view a \", \"history of builds with the definition: \\n \\nOn the resulting page, click the individual build for more\", \" details. \\n \\nA summary of this specific build is displayed. Click the published link, and notice the\", \" drop folder \\nproduced by the build is listed: \\n \\n26 \\nCHAPTER 3 | Continuous integration and deploym\", \"ent with Azure DevOps \\n \\n \\n \\nUse the ellipsis and click on Downloads artifacts links to inspect the \", \"published artifacts. \\nRelease pipeline \\nA release pipeline was created with the name MyFirstProject-\", \"ASP.NET Core-CD: \\n \\nThe two major components of the release pipeline are the Artifacts and the Stage\", \"s. Clicking the box \\nin the Artifacts section reveals the following panel: \\n \\n27 \\nCHAPTER 3 | Contin\", \"uous integration and deployment with Azure DevOps \\n \\n \\nThe Source (Build definition) value represent\", \"s the build definition to which this release pipeline is \\nlinked. The .zip file produced by a succes\", \"sful run of the build definition is provided to the Production \\nenvironment for deployment to Azure.\", \" Click the 1 phase, 2 tasks link in the Production environment \\nbox to view the release pipeline tas\", \"ks: \\n \\nThe release pipeline consists of two tasks: Deploy Azure App Service to Slot and Manage Azure\", \" App \\nService - Slot Swap. Clicking the first task reveals the following task configuration: \\n \\n28 \\n\", \"CHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n \\nThe Azure subscription, ser\", \"vice type, web app name, resource group, and deployment slot are defined \\nin the deployment task. Th\", \"e Package or folder textbox holds the .zip file path to be extracted and \\ndeployed to the staging sl\", \"ot of the mywebapp<unique_number> web app. \\nClicking the slot swap task reveals the following task c\", \"onfiguration: \\n \\n29 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n \\nThe su\", \"bscription, resource group, service type, web app name, and deployment slot details are \\nprovided. T\", \"he Swap with Production check box is checked. Consequently, the bits deployed to the \\nstaging slot a\", \"re swapped into the production environment. \\nAdditional reading \\n\\u2022 \\nCreate your first pipeline with \", \"Azure Pipelines \\n\\u2022 \\nBuild and .NET Core project \\n\\u2022 \\nDeploy a web app with Azure Pipelines \\n \\n30 \\nCHA\", \"PTER 3 | Continuous integration and deployment with Azure DevOps \\n \\nContinuous integration and deplo\", \"yment with Azure \\nDevOps \\nNote \\nThis section details continuous integration and deployment with Azur\", \"e DevOps. You can achieve that \\nwith GitHub Actions as well. GitHub Actions is a workflow engine bui\", \"lt into GitHub that can also be \\nused for continuous integration and deployment. To follow the guide\", \" for building and deploying to \\nAzure using GitHub, complete the Publish the app\\u2019s code to GitHub an\", \"d Disconnect local Git \\ndeployment sections below and then proceed to the GitHub Actions section. \\nI\", \"n the previous chapter, you created a local Git repository for the Simple Feed Reader app. In this \\n\", \"chapter, you\\u2019ll publish that code to a GitHub repository and construct an Azure DevOps Services \\npip\", \"eline using Azure Pipelines. The pipeline enables continuous builds and deployments of the app. \\nAny\", \" commit to the GitHub repository triggers a build and a deployment to the Azure Web App\\u2019s \\nstaging s\", \"lot. \\nIn this section, you\\u2019ll complete the following tasks: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nPublish th\", \"e app\\u2019s code to GitHub \\n\\u2022 \\nDisconnect local Git deployment \\n\\u2022 \\nCreate an Azure DevOps organization \\n\", \"\\u2022 \\nCreate a team project in Azure DevOps organization \\n\\u2022 \\nConfigure a self-hosted agent if necessary\", \" \\n\\u2022 \\nCreate a build definition \\n\\u2022 \\nCreate a release pipeline \\n\\u2022 \\nCommit changes to GitHub and automa\", \"tically deploy to Azure \\n\\u2022 \\nExamine the Azure Pipelines pipeline \\nPublish the app\\u2019s code to GitHub \\n\", \"1. \\nOpen a browser window, and navigate to https://github.com. \\n2. \\nClick the + drop-down in the hea\", \"der, and select New repository: \\n \\n \\n31 \\nCHAPTER 3 | Continuous integration and deployment with Azur\", \"e DevOps \\n \\n1. \\nSelect your account in the Owner drop-down, and enter simple-feed-reader in the Repo\", \"sitory \\nname textbox. \\n2. \\nClick the Create repository button. \\n3. \\nOpen your local machine\\u2019s comman\", \"d shell. Navigate to the directory in which the simple-feed-\\nreader Git repository is stored. \\n4. \\nR\", \"ename the existing origin remote to upstream. Execute the following command: \\n  \\n:::{custom-style=Co\", \"deBox} console  git remote rename origin upstream ::: \\n5. \\nAdd a new origin remote pointing to your \", \"copy of the repository on GitHub. Execute the \\nfollowing command: \\n  \\n:::{custom-style=CodeBox} cons\", \"ole  git remote add origin \\nhttps://github.com/<GitHub_username>/simple-feed-reader/ ::: \\n6. \\nPublis\", \"h your local Git repository to the newly created GitHub repository. Execute the following \\ncommand: \", \"\\n  \\n:::{custom-style=CodeBox} console  git push -u origin main ::: \\n7. \\nOpen a browser window, and n\", \"avigate to https://github.com/<GitHub_username>/simple-\\nfeed-reader/. Validate that your code appear\", \"s in the GitHub repository. \\nDisconnect local Git deployment \\nRemove the local Git deployment with t\", \"he following steps. Azure Pipelines (an Azure DevOps service) \\nboth replaces and augments that funct\", \"ionality. \\n1. \\nOpen the Azure portal, and navigate to the staging (mywebapp<unique_number>/staging) \", \"\\nWeb App. The Web App can be quickly located by entering staging in the portal\\u2019s search box: \\n \\n \\n1.\", \" \\nClick Deployment Center. A new panel appears. Click Disconnect to remove the local Git \\nsource con\", \"trol configuration that was added in the previous chapter. Confirm the removal \\noperation by clickin\", \"g the Yes button. \\n2. \\nNavigate to the mywebapp App Service. As a reminder, the portal\\u2019s search box \", \"can be used to \\nquickly locate the App Service. \\n3. \\nClick Deployment Center. A new panel appears. C\", \"lick Disconnect to remove the local Git \\nsource control configuration that was added in the previous\", \" chapter. Confirm the removal \\noperation by clicking the Yes button. \\nCreate an Azure DevOps organiz\", \"ation \\n1. \\nOpen a browser, and navigate to the Azure DevOps organization creation page. \\n2. \\nSelect \", \"New organization \\n3. \\nConfirm the information, and then select Continue. \\n \\n32 \\nCHAPTER 3 | Continuo\", \"us integration and deployment with Azure DevOps \\n \\n4. \\nSign in to your organization at any time, htt\", \"ps://dev.azure.com/{yourorganization} \\nCreate a team project in Azure DevOps organization \\n1. \\nChoos\", \"e the organization, and then select New project. \\n2. \\nEnter the project name as MyFirstProject and s\", \"elect the Visibility as Private \\n3. \\nSelect Create project. \\nFor more information, see Create a proj\", \"ect \\nConfigure a self-hosted agent if necessary \\nTo build your code or deploy your software using Az\", \"ure Pipelines, you need at least one agent. In \\nAzure Pipelines, you can run parallel jobs on either\", \" Microsoft-hosted or self-hosted agent. But with \\nthe recent change in Azure Pipelines free grant of\", \" parallel jobs is temporarily disable for the public \\nprojects.For more details, refer Configure and\", \" pay for parallel jobs. \\nGo to Organization Settings and then Pipelines > Parallel jobs. If you see \", \"value 0 under Microsoft-\\nhosted that means you need a Self-hosted agent to run your pipeline. \\n \\nYou\", \" can create that by following details mentioned in Self-hosted agents. After successful \\nconfigurati\", \"on, you\\u2019ll be able to see available agent under Organization Settings > Agent pools > \\n{youragentnam\", \"e} \\n \\nConfigure the Azure Pipelines pipeline \\nThere are three distinct steps to complete. Completing\", \" the steps in the following three sections results \\nin an operational DevOps pipeline. \\n \\n33 \\nCHAPTE\", \"R 3 | Continuous integration and deployment with Azure DevOps \\n \\nGrant Azure DevOps access to the Gi\", \"tHub repository \\n1. \\nIn your project, navigate to the Pipelines page. Then choose the action to crea\", \"te a new \\npipeline: \\n \\n1. \\nUse Use the classic editor to create the pipeline. \\n \\n \\n1. \\nSelect the Gi\", \"tHub option from the Select a source section:: \\n \\n \\n1. \\nAuthorization is required before Azure DevOp\", \"s can access your GitHub repository. Enter  \\nGitHub connection in the Connection name textbox. For e\", \"xample: \\n \\n34 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n \\n \\n1. \\nIf two\", \"-factor authentication is enabled on your GitHub account, a personal access token is \\nrequired. In t\", \"hat case, click the Authorize with a GitHub personal access token link. See the \\nofficial GitHub per\", \"sonal access token creation instructions for help. Only the repo scope of \\npermissions is needed. Ot\", \"herwise, click the Authorize using OAuth button. \\n2. \\nWhen prompted, sign in to your GitHub account.\", \" Then select Authorize to grant access to \\nyour Azure DevOps organization. If successful, a new serv\", \"ice endpoint is created. \\n3. \\nClick the ellipsis button next to the Repository button. Select the /s\", \"imple-feed-reader \\nrepository from the list. Click the Select button. \\n4. \\nSelect the default branch\", \" (main) from the Default branch for manual and scheduled builds \\ndrop-down. Click the Continue butto\", \"n. The template selection page appears. \\nCreate the build definition \\n1. \\nFrom the template selectio\", \"n page, enter ASP.NET Core in the search box: \\n \\nThe template search results appear. Hover over the \", \"ASP.NET Core template, and click \\nthe Apply button. \\n1. \\nThe Tasks tab of the build definition appea\", \"rs. Select the self-hosted Agent pool if you have \\ncreated that in the earlier step. \\n \\n35 \\nCHAPTER \", \"3 | Continuous integration and deployment with Azure DevOps \\n \\n \\n \\n> [!NOTE] \\n> If you are using MS-\", \"hosted agent then select the *Hosted > Azure Pipelines* from \\ndrop down. \\n1. \\nClick the Triggers tab\", \". \\n2. \\nCheck the Enable continuous integration box. Under the Branch filters section, confirm \\nthat \", \"the Type drop-down is set to Include. Set the Branch specification drop-down to main. \\n \\nThese setti\", \"ngs cause a build to trigger when any change is pushed to the default \\nbranch (*main*) of the GitHub\", \" repository. Continuous integration is tested in the \\n[Commit changes to GitHub and automatically de\", \"ploy to Azure](#commit-changes-to-\\ngithub-and-automatical) section. \\n1. \\nClick the Save & queue butt\", \"on, and select the Save option: \\n \\n36 \\nCHAPTER 3 | Continuous integration and deployment with Azure \", \"DevOps \\n \\n \\n \\n1. \\nThe following modal dialog appears: \\n \\nUse the default folder of *\\\\\\\\*, and click t\", \"he **Save** button. \\nCreate the release pipeline \\n1. \\nClick the Releases tab of your team project. C\", \"lick the New pipeline button. \\n \\n \\n37 \\nCHAPTER 3 | Continuous integration and deployment with Azure \", \"DevOps \\n \\nThe template selection pane appears. \\n1. \\nFrom the template selection page, enter App Serv\", \"ice Deployment in the search box: \\n \\n \\n1. \\nThe template search results appear. Hover over the Azure \", \"App Service Deployment with \\nSlot template, and click the Apply button. The Pipeline tab of the rele\", \"ase pipeline appears. \\n \\n1. \\nClick the Add button in the Artifacts box. The Add artifact panel appea\", \"rs: \\n \\n \\n38 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n1. \\nSelect the B\", \"uild tile from the Source type section. This type allows for the linking of the \\nrelease pipeline to\", \" the build definition. \\n2. \\nSelect MyFirstProject from the Project drop-down. \\n3. \\nSelect the build \", \"definition name, MyFirstProject-ASP.NET Core-CI, from the Source (Build \\ndefinition) drop-down. \\n4. \", \"\\nSelect Latest from the Default version drop-down. This option builds the artifacts produced \\nby the\", \" latest run of the build definition. \\n5. \\nReplace the text in the Source alias textbox with Drop. \\n6\", \". \\nClick the Add button. The Artifacts section updates to display the changes. \\n7. \\nClick the lightn\", \"ing bolt icon to enable continuous deployments: \\n \\nWith this option enabled, a deployment occurs eac\", \"h time a new build is available. \\n1. \\nA Continuous deployment trigger panel appears to the right. Cl\", \"ick the toggle button to \\nenable the feature. It isn\\u2019t necessary to enable the Pull request trigger.\", \" \\n2. \\nClick the Add drop-down in the Build branch filters section. Choose the Build Definition\\u2019s \\nde\", \"fault branch option. This filter causes the release to trigger only for a build from the \\nGitHub rep\", \"ository\\u2019s default branch (main). \\n3. \\nClick the Save button. Click the OK button in the resulting Sa\", \"ve modal dialog. \\n4. \\nClick the Stage 1 box. An Stage panel appears to the right. Change the Stage 1\", \" text in the \\nStage name textbox to Production. \\n \\n39 \\nCHAPTER 3 | Continuous integration and deploy\", \"ment with Azure DevOps \\n \\n \\n1. \\nClick the 1 phase, 2 tasks link in the Production box: \\n \\n \\nThe **Ta\", \"sks** tab of the environment appears. \\n1. \\nClick the Deploy Azure App Service to Slot task. Its sett\", \"ings appear in a panel to the right. \\n2. \\nSelect the Azure subscription associated with the App Serv\", \"ice from the Azure subscription \\ndrop-down. Once selected, click the Authorize button. \\n3. \\nSelect W\", \"eb App from the App type drop-down. \\n4. \\nSelect mywebapp/ from the App service name drop-down. \\n5. \\n\", \"Select AzureTutorial from the Resource group drop-down. \\n6. \\nSelect staging from the Slot drop-down.\", \" \\n7. \\nSelect Run on agent* under Tasks. On the right pane, you\\u2019ll see Agent Job. \\n8. \\nSelect the sel\", \"f-hosted Agent pool if you have created that in the earlier step. \\n \\n \\n40 \\nCHAPTER 3 | Continuous in\", \"tegration and deployment with Azure DevOps \\n \\n> [!NOTE] \\n> If you are using MS-hosted agent then sel\", \"ect the *Hosted > Azure Pipelines* from \\ndrop down. \\n1. \\nClick the Save button. \\n2. \\nHover over the \", \"default release pipeline name. Click the pencil icon to edit it. Use \\nMyFirstProject-ASP.NET Core-CD\", \" as the name. \\n \\n1. \\nClick the Save button. \\nCommit changes to GitHub and automatically deploy to Az\", \"ure \\n1. \\nOpen SimpleFeedReader.sln in Visual Studio. \\n2. \\nIn Solution Explorer, open Pages.cshtml. C\", \"hange <h2>Simple Feed Reader - V3</h2> to \\n<h2>Simple Feed Reader - V4</h2>. \\n3. \\nPress Ctrl+Shift+B\", \" to build the app. \\n4. \\nCommit the file to the GitHub repository. Use either the Changes page in Vis\", \"ual Studio\\u2019s \\nTeam Explorer tab, or execute the following using the local machine\\u2019s command shell: \\n\", \"  \\n:::{custom-style=CodeBox} console  git commit -a -m \\\"upgraded to V4\\\" ::: \\n5. \\nPush the change in \", \"the default branch (main) to the origin remote of your GitHub repository. \\nIn the following command,\", \" replace the placeholder {BRANCH} with the default branch (use \\nmain): \\n  \\n:::{custom-style=CodeBox}\", \" console  git push origin {BRANCH} ::: \\n  \\nThe commit appears in the GitHub repository\\u2019s default bra\", \"nch (main). You\\u2019ll be able to see the \\ncommit history in https://github.com/<GitHub_username>/simple\", \"-feed-\\nreader/commits/main. \\n  \\nThe build is triggered, since continuous integration is enabled in t\", \"he build definition\\u2019s \\nTriggers tab: \\n  \\n \\n \\n41 \\nCHAPTER 3 | Continuous integration and deployment w\", \"ith Azure DevOps \\n \\n1. \\nNavigate to the Pipelines. You\\u2019ll see the CI pipeline details and monitor ea\", \"ch steps if you drill \\ndown Jobs details. \\n \\n1. \\nSimilarly, go to the Releases tab to see the detail\", \"s of CD pipeline. You can always drill down \\nfurther to see more details of each step. \\n \\n1. \\nOnce t\", \"he build succeeds, a deployment to Azure occurs. Navigate to the app in the browser. \\nNotice that th\", \"e \\u201cV4\\u201d text appears in the heading: \\n \\nExamine the Azure Pipelines pipeline \\nBuild definition \\nA bui\", \"ld definition was created with the name MyFirstProject-ASP.NET Core-CI. Upon completion, the \\nbuild \", \"produces a .zip file including the assets to be published. The release pipeline deploys those \\nasset\", \"s to Azure. \\nThe build definition\\u2019s Tasks tab lists the individual steps being used. There are five \", \"build tasks. \\n \\n42 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n \\n1. \\nRes\", \"tore \\u2014 Executes the dotnet restore command to restore the app\\u2019s NuGet packages. The \\ndefault package\", \" feed used is nuget.org. \\n2. \\nBuild \\u2014 Executes the dotnet build --configuration release command to c\", \"ompile the app\\u2019s \\ncode. This --configuration option is used to produce an optimized version of the c\", \"ode, which \\nis suitable for deployment to a production environment. Modify the BuildConfiguration \\nv\", \"ariable on the build definition\\u2019s Variables tab if, for example, a debug configuration is \\nneeded. \\n\", \"3. \\nTest \\u2014 Executes the dotnet test --configuration release --logger trx --results-directory \\n<local\", \"_path_on_build_agent> command to run the app\\u2019s unit tests. Unit tests are executed \\nwithin any C# pr\", \"oject matching the **/Tests/.csproj glob pattern. Test results are saved in a .trx \\nfile at the loca\", \"tion specified by the --results-directory option. If any tests fail, the build fails \\nand isn\\u2019t depl\", \"oyed. \\n \\n43 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n  \\n[!NOTE] To ve\", \"rify the unit tests work, modify SimpleFeedReader.Tests.cs to purposefully break \\none of the tests. \", \"For example, change Assert.True(result.Count > 0); to \\nAssert.False(result.Count > 0); in the Return\", \"s_News_Stories_Given_Valid_Uri method. Commit \\nand push the change to GitHub. The build is triggered\", \" and fails. The build pipeline status \\nchanges to failed. Revert the change, commit, and push again.\", \" The build succeeds. \\n4. \\nPublish \\u2014 Executes the dotnet publish --configuration release --output \\n<l\", \"ocal_path_on_build_agent> command to produce a .zip file with the artifacts to be \\ndeployed. The --o\", \"utput option specifies the publish location of the .zip file. That location is \\nspecified by passing\", \" a predefined variable named $(build.artifactstagingdirectory). That \\nvariable expands to a local pa\", \"th, such as *c:_work\\\\1, on the build agent. \\n5. \\nPublish Artifact \\u2014 Publishes the .zip file produced\", \" by the Publish task. The task accepts the \\n.zip file location as a parameter, which is the predefin\", \"ed variable \\n$(build.artifactstagingdirectory). The .zip file is published as a folder named drop. \\n\", \"Click the build definition\\u2019s Summary link to view a history of builds with the definition: \\n \\nOn the\", \" resulting page, click the individual build for more details. \\n \\nA summary of this specific build is\", \" displayed. Click the published link, and notice the drop folder \\nproduced by the build is listed: \\n\", \" \\n44 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n \\n \\nUse the ellipsis an\", \"d click on Downloads artifacts links to inspect the published artifacts. \\nRelease pipeline \\nA releas\", \"e pipeline was created with the name MyFirstProject-ASP.NET Core-CD: \\n \\nThe two major components of \", \"the release pipeline are the Artifacts and the Stages. Clicking the box \\nin the Artifacts section re\", \"veals the following panel: \\n \\n45 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOp\", \"s \\n \\n \\nThe Source (Build definition) value represents the build definition to which this release pip\", \"eline is \\nlinked. The .zip file produced by a successful run of the build definition is provided to \", \"the Production \\nenvironment for deployment to Azure. Click the 1 phase, 2 tasks link in the Producti\", \"on environment \\nbox to view the release pipeline tasks: \\n \\nThe release pipeline consists of two task\", \"s: Deploy Azure App Service to Slot and Manage Azure App \\nService - Slot Swap. Clicking the first ta\", \"sk reveals the following task configuration: \\n \\n46 \\nCHAPTER 3 | Continuous integration and deploymen\", \"t with Azure DevOps \\n \\n \\nThe Azure subscription, service type, web app name, resource group, and dep\", \"loyment slot are defined \\nin the deployment task. The Package or folder textbox holds the .zip file \", \"path to be extracted and \\ndeployed to the staging slot of the mywebapp<unique_number> web app. \\nClic\", \"king the slot swap task reveals the following task configuration: \\n \\n47 \\nCHAPTER 3 | Continuous inte\", \"gration and deployment with Azure DevOps \\n \\n \\nThe subscription, resource group, service type, web ap\", \"p name, and deployment slot details are \\nprovided. The Swap with Production check box is checked. Co\", \"nsequently, the bits deployed to the \\nstaging slot are swapped into the production environment. \\nAdd\", \"itional reading \\n\\u2022 \\nCreate your first pipeline with Azure Pipelines \\n\\u2022 \\nBuild and .NET Core project \", \"\\n\\u2022 \\nDeploy a web app with Azure Pipelines \\n \\n48 \\nCHAPTER 3 | Continuous integration and deployment w\", \"ith Azure DevOps \\n \\nContinuous integration and deployment with \\nGitHub Actions \\nGitHub has long been\", \" the home for millions of open-source developers around the globe. Most \\ndevelopers associate source\", \" control with GitHub. However, GitHub is an evolving platform that can be \\nused for more than just s\", \"ynchronizing Git repositories. \\nGitHub Actions \\nGitHub Actions is a workflow engine that can automat\", \"e workflows for nearly all events that occur on \\nGitHub. Actions is a great solution for Continuous \", \"Integration/Continuous Deployment (CI/CD) \\npipelines. \\nIn this section of articles, you\\u2019ll learn how\", \" to create an Actions workflow. The workflow will build, test, \\nand deploy a .NET web app to Azure W\", \"eb Apps. \\nNote \\nBefore you begin, complete the Publish the app\\u2019s code to GitHub and Disconnect local\", \" Git \\ndeployment sections of the Continuous integration and deployment with Azure DevOps section to \", \"\\npublish your code to GitHub. Then proceed to the Build article. \\nIn the Build article, you\\u2019ll creat\", \"e the initial workflow to build and test the .NET app. You\\u2019ll: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nLearn t\", \"he basic structure of a GitHub Action workflow YAML file. \\n\\u2022 \\nUse a template to create a basic build\", \" workflow that builds a .NET app and executes unit tests. \\n\\u2022 \\nPublish the compiled app so that it\\u2019s \", \"ready for deployment. \\nIn the Deploy article, you\\u2019ll: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nLearn about envi\", \"ronments in GitHub Actions. \\n\\u2022 \\nCreate two environments and specify environment protection rules. \\n\\u2022\", \" \\nCreate environment secrets for managing environment-specific configuration. \\n\\u2022 \\nExtend the workflo\", \"w YAML file to add deployment steps. \\n\\u2022 \\nAdd a manual dispatch trigger. \\nSecure code with CodeQL \\nIn\", \" addition to building and deploying code, GitHub Advanced Security offers tools for \\u201cshifting left\\u201d \", \"\\nwith security. That is, integrating security early on in the software delivery lifecycle. CodeQL is\", \" a code \\nscanning language that runs queries to find potential vulnerabilities or quality issues in \", \"your code. \\nCodeQL is run using an Actions workflow. \\nIn the CodeQL article, you\\u2019ll: \\n \\n49 \\nCHAPTER \", \"3 | Continuous integration and deployment with Azure DevOps \\n \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nCreate a\", \" Code Scanning Action. \\n\\u2022 \\nEdit the workflow file to include custom scan settings. \\n\\u2022 \\nSee scanning \", \"results. \\nCompare and contrast GitHub Actions and Azure Pipelines \\nGitHub Actions and Azure Pipeline\", \"s have a common lineage and are similar in many respects. \\nHowever, you should understand the differ\", \"ences before selecting a platform for building, testing, and \\ndeploying apps. In the Comparison arti\", \"cle, you\\u2019ll deep dive into these platforms and compare and \\ncontrast them. You\\u2019ll also learn how to \", \"select the correct platform for your CI/CD needs. \\nContinuous integration and deployment with \\nGitHu\", \"b Actions \\nGitHub has long been the home for millions of open-source developers around the globe. Mo\", \"st \\ndevelopers associate source control with GitHub. However, GitHub is an evolving platform that ca\", \"n be \\nused for more than just synchronizing Git repositories. \\nGitHub Actions \\nGitHub Actions is a w\", \"orkflow engine that can automate workflows for nearly all events that occur on \\nGitHub. Actions is a\", \" great solution for Continuous Integration/Continuous Deployment (CI/CD) \\npipelines. \\nIn this sectio\", \"n of articles, you\\u2019ll learn how to create an Actions workflow. The workflow will build, test, \\nand d\", \"eploy a .NET web app to Azure Web Apps. \\nNote \\nBefore you begin, complete the Publish the app\\u2019s code\", \" to GitHub and Disconnect local Git \\ndeployment sections of the Continuous integration and deploymen\", \"t with Azure DevOps section to \\npublish your code to GitHub. Then proceed to the Build article. \\nIn \", \"the Build article, you\\u2019ll create the initial workflow to build and test the .NET app. You\\u2019ll: \\n[!div\", \" class=\\u201cchecklist\\u201d] \\n\\u2022 \\nLearn the basic structure of a GitHub Action workflow YAML file. \\n\\u2022 \\nUse a t\", \"emplate to create a basic build workflow that builds a .NET app and executes unit tests. \\n\\u2022 \\nPublish\", \" the compiled app so that it\\u2019s ready for deployment. \\nIn the Deploy article, you\\u2019ll: \\n[!div class=\\u201cc\", \"hecklist\\u201d] \\n\\u2022 \\nLearn about environments in GitHub Actions. \\n \\n50 \\nCHAPTER 3 | Continuous integration\", \" and deployment with Azure DevOps \\n \\n\\u2022 \\nCreate two environments and specify environment protection r\", \"ules. \\n\\u2022 \\nCreate environment secrets for managing environment-specific configuration. \\n\\u2022 \\nExtend the\", \" workflow YAML file to add deployment steps. \\n\\u2022 \\nAdd a manual dispatch trigger. \\nSecure code with Co\", \"deQL \\nIn addition to building and deploying code, GitHub Advanced Security offers tools for \\u201cshiftin\", \"g left\\u201d \\nwith security. That is, integrating security early on in the software delivery lifecycle. C\", \"odeQL is a code \\nscanning language that runs queries to find potential vulnerabilities or quality is\", \"sues in your code. \\nCodeQL is run using an Actions workflow. \\nIn the CodeQL article, you\\u2019ll: \\n[!div \", \"class=\\u201cchecklist\\u201d] \\n\\u2022 \\nCreate a Code Scanning Action. \\n\\u2022 \\nEdit the workflow file to include custom s\", \"can settings. \\n\\u2022 \\nSee scanning results. \\nCompare and contrast GitHub Actions and Azure Pipelines \\nGi\", \"tHub Actions and Azure Pipelines have a common lineage and are similar in many respects. \\nHowever, y\", \"ou should understand the differences before selecting a platform for building, testing, and \\ndeployi\", \"ng apps. In the Comparison article, you\\u2019ll deep dive into these platforms and compare and \\ncontrast \", \"them. You\\u2019ll also learn how to select the correct platform for your CI/CD needs. \\nCompare and contra\", \"st GitHub Actions and Azure \\nPipelines \\nGitHub Actions and Azure Pipelines have a common history. In\", \" fact, the Actions agent is a fork of the \\nPipelines agent. There are many similarities between GitH\", \"ub Actions and Azure Pipelines and it\\u2019s \\nworth comparing and contrasting them. \\nPipelines as code \\nB\", \"efore you compare GitHub Actions and Azure Pipelines, you should consider the benefits of pipelines \", \"\\nas code. Pipelines as code: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nBenefit from standard source control prac\", \"tices (such as code reviews via pull request and \\nversioning). \\n\\u2022 \\nCan be audited for changes just l\", \"ike any other files in the repository. \\n\\u2022 \\nDon\\u2019t require accessing a separate system or UI to edit. \", \"\\n\\u2022 \\nCan fully codify the build, test, and deploy process for code. \\n \\n51 \\nCHAPTER 3 | Continuous int\", \"egration and deployment with Azure DevOps \\n \\n\\u2022 \\nCan usually be templatized to empower teams to creat\", \"e standard processes across multiple \\nrepositories. \\nNote \\nThe term \\u201cpipelines\\u201d can also be referred\", \" to by several different interchangeable words: pipeline, \\nworkflow, and build are common terms. In \", \"this article, references to Azure Pipelines are referring to \\nYAML Pipelines, and not the older UI-b\", \"ased Classic Pipelines. \\nAgents and runners \\nBefore you examine pipelines themselves, you should con\", \"sider how these pipelines execute. Both \\nGitHub Actions and Azure Pipelines are really orchestration\", \" engines. When a pipeline is triggered, the \\nsystem finds an \\u201cagent\\u201d and tells the agent to execute \", \"the jobs defined in the pipeline file. \\nAzure Pipelines run on agents. The agent is written in .NET,\", \" so it will run wherever .NET can run: \\nWindows, macOS, and Linux. Agents can even run in containers\", \". Agents are registered to a pool in \\nAzure Pipelines or to a repository or organization in GitHub. \", \"Agents can be hosted or private. \\nGitHub Workflows execute on runners. The runner code is essentiall\", \"y a fork of the Azure Pipelines \\ncode, so it\\u2019s very similar. It\\u2019s also cross-platform and you can al\", \"so use hosted or self-hosted runners. \\nHosted agents and runners \\nHosted agents (Azure Pipelines) an\", \"d hosted runners (GitHub) are agents that are spun up and \\nmanaged by Azure DevOps or GitHub respect\", \"ively. You don\\u2019t need to maintain any build \\ninfrastructure. When a pipeline triggers that targets a\", \" hosted agent, an instance of the specified agent \\nimage is created. The job is run by the agent on \", \"the instance, and once the job completes, the \\ninstance is destroyed. The same applies for hosted ru\", \"nners running GitHub workflows. \\nNote \\nThe list of software installed on Azure Pipelines images is l\", \"isted in this repository. You can select the \\nplatform folder and examine the README.md files. You c\", \"an find information on GitHub hosted \\nrunners. \\nPrivate agents and self-hosted runners \\nThere are ti\", \"mes when you can\\u2019t use hosted images. For example, when you: \\n\\u2022 \\nRequire SDKs or other software that\", \" isn\\u2019t installed on the images. \\n\\u2022 \\nNeed to access resources that aren\\u2019t public (such as an internal\", \" SonarQube server or an \\ninternal Artifactory instance). \\n\\u2022 \\nNeed to deploy to private networks. \\n\\u2022 \", \"\\nNeed to install licenses for third-party software required for building your code. \\n\\u2022 \\nNeed more st\", \"orage or memory than is provided to the hosted agent images. \\n\\u2022 \\nNeed more time than the maximum bui\", \"ld time limit for hosted agents. \\n \\n52 \\nCHAPTER 3 | Continuous integration and deployment with Azure\", \" DevOps \\n \\nImportant \\nIt\\u2019s possible to install tools and SDKs when running pipelines on hosted agent\", \"s. If the install steps \\ndon\\u2019t take long, this is viable. However, if the tools/software take a long\", \" time to install, then you may \\nbe better off with a private agent or self-hosted runner, since the \", \"install steps will need to execute for \\nevery run of the workflow. \\nAzure DevOps agents \\nEvery Azure\", \" DevOps account has a hosted pool with a single agent that can run one job at a time. \\nAlso included\", \" is a set number of free build minutes. You may purchase additional \\u201chosted pipelines\\u201d in \\nAzure Dev\", \"Ops. When you purchase an additional hosted pipeline, you\\u2019re really removing the build \\nminutes limi\", \"t and adding concurrency. One pipeline can run one job at a time. Two pipelines can run \\ntwo jobs si\", \"multaneously, and so on. \\nComparison of agents \\nFeature \\nGitHub \\nAzure Pipelines \\nLinks \\nHosted agen\", \"ts for \\npublic \\nrepos/projects \\nFree \\nUp to 10 free Microsoft-hosted parallel jobs \\nthat can run for\", \" up to 360 minutes (6 hours) \\neach time with no overall time limit per \\nmonth. You aren\\u2019t given this\", \" free grant by \\ndefault, you have to submit a request \\nAzure \\nPipelines \\nGitHub \\nHosted agents for \\n\", \"private \\nrepos/projects \\n2,000 minutes \\nfree per month, \\n3,000 minutes \\nfor Pro and \\nTeam licenses, \", \"\\n50,000 minutes \\nfor Enterprise \\nlicense. \\nAdditional \\nminutes may be \\npurchased. \\nOne free parallel\", \" job that can run for up to \\n60 minutes each time, until you\\u2019ve used \\n1,800 minutes (30 hours) per m\", \"onth. You \\ncan pay for additional capacity per parallel \\njob. Paid parallel jobs remove the monthly \", \"\\ntime limit and allow you to run each job for \\nup to 360 minutes (6 hours). \\n \\nCross-platform \\nYes \\n\", \"Yes \\n \\nScale set agents \\nNo \\nYes \\nAzure virtual \\nmachine \\nscale set \\nagents \\nComparison of GitHub Ac\", \"tions and Azure Pipelines \\nAzure Pipelines (YAML pipelines) provide a mature set of features. Some o\", \"f the features include: \\n\\u2022 \\nApprovals \\n\\u2022 \\nArtifact storage \\n \\n53 \\nCHAPTER 3 | Continuous integration\", \" and deployment with Azure DevOps \\n \\n\\u2022 \\nDeployment jobs \\n\\u2022 \\nEnvironments \\n\\u2022 \\nGates \\n\\u2022 \\nStages \\n\\u2022 \\nTe\", \"mplates \\n\\u2022 \\nTriggers \\n\\u2022 \\nVariable groups \\nFor a full list of Azure Pipelines features, refer to the \", \"Feature availability table. \\nGitHub Actions are evolving rapidly and provide features such as trigge\", \"rs for almost all GitHub events, \\nartifact storage, environments and environment rules, starter temp\", \"lates, and matrices. Read more \\nabout the entire feature set refer GitHub Actions. \\nFeature comparis\", \"on \\nThe following table is current as of January 2023 and is not an exhaustive list of features. \\nFe\", \"ature \\nDescription \\nGitHub Actions \\nAzure Pipelines \\nApprovals \\nDefine approval \\nconditions before \\n\", \"moving further in the \\npipeline \\nYes \\nYes \\nArtifacts \\nUpload, store, and \\ndownload artifacts \\nfrom j\", \"obs \\nYes \\nYes \\nCaching \\nCache folders or files \\nfor subsequent runs \\nYes \\nYes \\nConditions \\nSpecify c\", \"onditions \\nfor steps or jobs \\nYes \\nYes \\nContainer \\nJobs \\nRun jobs inside a \\ncontainer \\nYes \\nYes \\nDem\", \"ands \\nSpecify demands \\nthat must be met to \\nmatch jobs to agents \\nYes \\nYes \\nDependenci\\nes \\nSpecify \\n\", \"dependencies \\nbetween jobs or \\nstages \\nYes \\nYes \\nDeployment \\nGroups \\nA logical set of target \\nmachin\", \"es for \\ndeployments \\nNo \\nYes \\nDeployment \\nJobs \\nJob that targets a \\ndeployment group \\nNo \\nYes \\n \\n54 \", \"\\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\nFeature \\nDescription \\nGitHub\", \" Actions \\nAzure Pipelines \\nEnvironment\\ns \\nA collection of \\nresources to target \\nor a logical \\nenviro\", \"nment \\nYes \\nYes \\nGates/Check\\ns \\nAutomatic collection \\nand evaluation of \\nsignals to control \\ncontinu\", \"ation \\nYes \\nYes \\nJobs \\nSequence of steps \\nthat are executed on \\nan agent \\nYes \\nYes \\nService \\nContain\", \"ers \\nManage the lifecycle \\nof a containerized \\nservice instance \\navailable during a \\njob \\nYes \\nYes \\n\", \"Service \\nConnections \\nAbstract credentials \\nto external systems \\nNo \\nYes \\nPasswordles\\ns \\nconnections\", \" \\nto cloud \\nproviders \\nProvide technologies \\nand support use \\ncases that reduce \\nand potentially \\nel\", \"iminate the use of \\npasswords \\nYes \\nNo \\nStages \\nGroup jobs in a \\npipeline \\nNo \\nYes \\nTemplates \\nDefin\", \"e reusable, \\nparameterized \\nbuilding blocks for \\nsteps, jobs, or \\nvariables \\nYes \\nYes \\nStarter \\nTemp\", \"lates \\nDefines a starter \\nworkflow based on \\nthe type of code \\ndetected in a \\nrepository \\nYes \\nNo \\nT\", \"riggers \\nSet of events that \\ncause the pipeline to \\ntrigger \\nYes \\nYes \\n \\n55 \\nCHAPTER 3 | Continuous \", \"integration and deployment with Azure DevOps \\n \\nFeature \\nDescription \\nGitHub Actions \\nAzure Pipeline\", \"s \\nVariables \\nVariables that can be \\npassed in, statically \\nor dynamically \\ndefined \\nYes \\nYes \\nVaria\", \"ble \\nGroups \\nStore values for use \\nacross multiple \\npipelines \\nNo \\nYes \\nImportant \\nGitHub Actions is\", \" rapidly evolving. Be sure to check documentation carefully before deciding which \\nplatform is right\", \" for you. \\nBuild a .NET web app using GitHub Actions \\nGitHub Actions allow you to automate workflows\", \" in response to events that are triggered in GitHub. A \\ncommon workflow is Continuous Integration (C\", \"I), but Actions can automate other processes. For \\nexample, sending welcome emails when people join \", \"a repository. \\nTo explore moving code to the cloud, you\\u2019ll build a GitHub Actions workflow file. The\", \" workflow file will \\nbe used for the Simple Feed Reader app you\\u2019ve already deployed to Azure App Ser\", \"vice. \\nIn this article, you will: > [!div class=\\u201cchecklist\\u201d] > > * Learn the basic structure of a Gi\", \"tHub Action \\nworkflow YAML file. > * Use a template to create a basic build workflow that builds the\", \" .NET app and \\nexecutes unit tests. > * Publish the compiled app so that it\\u2019s ready for deployment. \", \"\\nWorkflow structure \\nWorkflows are defined in YAML files, and contain several common nodes: \\n\\u2022 \\na na\", \"me \\n\\u2022 \\na trigger, defined by an on section \\n\\u2022 \\none or more job sections composed of one or more step\", \"s \\n\\u2022 \\noptional attributes such as environment variables \\nJobs are run on runners. You can use hosted\", \" runners, which are spun up by GitHub during the \\nworkflow and then thrown away. Hosted runners are \", \"great because you don\\u2019t have to maintain your \\nown build infrastructure. For workflows that require \", \"a specific build environment, or for running \\nworkflows on a private network, you can also use priva\", \"te runners. To create a private runner, install the \\nrunner on any machine that supports .NET. \\nEach\", \" job will specify what runner GitHub should use to execute the steps. You can also specify \\ndependen\", \"cies between jobs using the needs attribute. Deployment jobs can also specify an \\nenvironment to tar\", \"get. \\n \\n56 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\nThe steps node ca\", \"n be as easy as inline commands, or they can be actions. Most CI workflows will \\nhave a combination \", \"of run steps (for executing scripts) and actions. Individual actions are pulled into \\nthe workflow b\", \"y referencing the GitHub Action repository (and optionally a tag or commit hash for \\nspecific versio\", \"ns) and specifying any parameters using the with keyword. \\nTip \\nFor more information, see GitHub Act\", \"ions YAML syntax. \\nFrom a workflow file, you\\u2019re able to run any of the available .NET CLI commands. \", \"For example, if you\\u2019re \\nrequired to build, test, and deploy an ASP.NET Core Blazor WebAssembly app w\", \"ith Ahead-of-Time \\n(AoT) compilation, you\\u2019d use the following commands: \\n\\u2022 \\ndotnet workload install \", \"\\n\\u2022 \\ndotnet restore \\n\\u2022 \\ndotnet build \\n\\u2022 \\ndotnet test \\n\\u2022 \\ndotnet publish \\nThe .NET SDK is a workflow n\", \"ecessity \\nAll .NET workflows require the .NET SDK, and this can be set up by the actions/setup-dotne\", \"t GitHub \\nAction. This action sets up a .NET CLI environment for use in actions. Some GitHub hosted \", \"runners \\nhave the .NET SDK preinstalled, but that\\u2019s subject to change. As a best practice, use the a\", \"ctions/setup-\\ndotnet action to ensure the proper version is available. \\nCreate a basic build workflo\", \"w \\nA primary principle of effective DevOps is to \\u201cbuild once, and deploy many times\\u201d. You\\u2019ll start b\", \"y \\ncreating a workflow to build a basic .NET app. In the next step, you\\u2019ll publish the output to pre\", \"pare for \\ndeployment. \\n1. \\nNavigate to your GitHub repository and select the Actions tab. \\n2. \\nGitHu\", \"b detects that there\\u2019s .NET code in the repository and suggests a .NET workflow \\ntemplate. Select Se\", \"t up this workflow to create a new YAML workflow file: \\n \\n**Figure 1**: Creating a new workflow. \\n \\n\", \"57 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n1. \\nCommit the file onto \", \"the main branch. Since you\\u2019ve defined a trigger condition for commits to \\nmain, this commit should t\", \"rigger the workflow to run. \\n \\n**Figure 2**: Commit the YAML file. \\n1. \\nSelect the Actions tab again\", \". You should see a running workflow. Once the workflow has \\ncompleted, you should see a successful r\", \"un. \\n \\n**Figure 3**: Successful build view. \\n1. \\nOpening the logs, you can see that the .NET build s\", \"ucceeded and the tests ran and passed. \\n \\n**Figure 4**: Checking the logs. \\n \\n58 \\nCHAPTER 3 | Contin\", \"uous integration and deployment with Azure DevOps \\n \\nNote \\nIf any of the tests fail, the workflow wi\", \"ll fail. \\nDissect the workflow file \\nLet\\u2019s examine the workflow YAML file you have so far: \\nname: .N\", \"ET \\n \\non: \\n  push: \\n    branches: [ main ] \\n  pull_request: \\n    branches: [ main ] \\n \\njobs: \\n  buil\", \"d: \\n \\n    runs-on: ubuntu-latest \\n \\n    steps: \\n    - uses: actions/checkout@v3 \\n    - name: Setup .\", \"NET \\n      uses: actions/setup-dotnet@v3 \\n      with: \\n        dotnet-version: 6.0.x \\n    - name: Re\", \"store dependencies \\n      run: dotnet restore \\n    - name: Build \\n      run: dotnet build --no-resto\", \"re \\n    - name: Test \\n      run: dotnet test --no-build --verbosity normal \\nNotice the following thi\", \"ngs: \\n1. \\nThere\\u2019s a name that names the workflow. \\n2. \\nThe on object specifies when this workflow sh\", \"ould run. This workflow has two events that \\ntrigger it: push to main and pull_request to main. Each\", \" time someone commits to main or \\ncreates a pull request (PR) to main, this workflow will execute. \\n\", \"3. \\nThere\\u2019s a single job called build. This build should run on a hosted agent. ubuntu_latest \\nspeci\", \"fies the most recent Ubuntu hosted agent. \\n4. \\nThere are five steps: \\n1. \\nactions/checkout@v3 is an \", \"action that checks out the code in the repository onto the \\nrunner. \\n2. \\nactions/setup-dotnet@v3 is \", \"an action that sets up the .NET CLI. This step also \\nspecifies a name attribute for the logs and the\", \" dotnet-version parameter within the \\nwith object. \\n3. \\nThree run steps that execute dotnet restore,\", \" dotnet build, and dotnet test. name \\nattributes are also specified for these run steps to make the \", \"logs look pretty. \\n \\n59 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\nPubl\", \"ish the output \\nNow that you\\u2019ve successfully built and tested the code, add steps that publish the o\", \"utput so you can \\ndeploy the web app. \\n1. \\nNavigate to the .github/workflows/dotnet.yml file and sel\", \"ect the pencil icon to edit  \\n \\n**Figure 5**: Edit the YAML file. \\n1. \\nAdd the following Publish ste\", \"p below the Test step. The step runs the dotnet publish \\ncommand to publish the web app: \\n  \\n:::{cus\", \"tom-style=CodeBox} ```yml \\n\\u2013 \\nname: Test run: dotnet test \\u2013no-build \\u2013verbosity normal # <\\u2013 this is t\", \"he current \\nbottom line \\n\\u2013 \\nname: Publish run: dotnet publish SimpleFeedReader/SimpleFeedReader.cspr\", \"oj -c \\nRelease -o website ``` ::: \\n2. \\nThis publishes the web app to a folder on the hosted agent. N\", \"ow you\\u2019ll want to upload the \\nsite as a build artifact that can be deployed to Azure. To complete th\", \"is activity, you\\u2019ll use an \\nexisting action. \\n3. \\nOn the list of actions in the Actions Helper pane \", \"on the right, search for artifact. Select on \\nthe Upload a Build Artifact (By actions) action. \\n   \\n\", \" \\n**Figure 6**: Accessing the snippet helper. \\n \\n60 \\nCHAPTER 3 | Continuous integration and deployme\", \"nt with Azure DevOps \\n \\n1. \\nEdit the version to v2.2.2 to display a sample snippet. Select the clipb\", \"oard icon to copy the \\nsnippet and paste it into the workflow below the publish step. \\n \\n**Figure 7*\", \"*: Copying a snippet. \\n1. \\nEdit the YAML for this step to look as follows: \\n  \\n:::{custom-style=Code\", \"Box} ```yml \\n\\u2013 \\nname: Upload a Build Artifact uses: actions/upload-artifact@v3 with: name: website \\n\", \"path: SimpleFeedReader/website/** if-no-files-found: error ``` ::: \\n2. \\nCommit the file. \\n3. \\nOnce t\", \"he workflow completes, you\\u2019ll see the artifact from the Home tab: \\n \\n**Figure 8**: Viewing artifacts\", \" in the summary page. \\n \\n61 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n\", \"Final workflow file \\nThe final workflow file should look something like this: \\nname: .NET \\n \\non: \\n  \", \"push: \\n    branches: [ main ] \\n  pull_request: \\n    branches: [ main ] \\n \\njobs: \\n  build: \\n \\n    run\", \"s-on: ubuntu-latest \\n \\n    steps: \\n    - uses: actions/checkout@v3 \\n    - name: Setup .NET \\n      us\", \"es: actions/setup-dotnet@v3 \\n      with: \\n        dotnet-version: 6.0.x \\n    - name: Restore depende\", \"ncies \\n      run: dotnet restore \\n    - name: Build \\n      run: dotnet build --no-restore \\n    - nam\", \"e: Test \\n      run: dotnet test --no-build --verbosity normal \\n    - name: Publish \\n      run: dotne\", \"t publish SimpleFeedReader/SimpleFeedReader.csproj -c Release -o website \\n    - name: Upload a Build\", \" Artifact \\n      uses: actions/upload-artifact@v3 \\n      with: \\n        name: website \\n        path:\", \" SimpleFeedReader/website/** \\n        if-no-files-found: error \\nDeploy a .NET web app using GitHub A\", \"ctions \\nWarning \\nPlease complete the Build tutorial before starting this lab. \\nIn this article, you\\u2019\", \"ll: > [!div class=\\u201cchecklist\\u201d] > > * Learn about Environments in GitHub Actions. > * \\nCreate two env\", \"ironments and specify environment protection rules. > * Create environment secrets \\nfor managing env\", \"ironment-specific configuration. > * Extend the workflow YAML file to add \\ndeployment steps. > * Add\", \" a manual dispatch trigger. \\nEnvironments \\nNow that you\\u2019ve published an artifact that\\u2019s potentially \", \"deployable, you\\u2019ll add deployment jobs to the \\nworkflow. There\\u2019s nothing special about a deployment \", \"job, other than the fact that it references an \\n \\n62 \\nCHAPTER 3 | Continuous integration and deploym\", \"ent with Azure DevOps \\n \\nenvironment. Environments are logical constructs that allow you to specify \", \"environment protection \\nrules, such as approvals, on any group of resources that you\\u2019re targeting. \\n\", \"In this walkthrough, you\\u2019ll be deploying to two environments: PRE-PROD and PROD. In a typical \\ndevel\", \"opment lifecycle, you\\u2019ll want to deploy the latest code to a soft environment (typically DEV) that \\n\", \"is expected to be a bit unstable. You\\u2019ll use PRE-PROD as this soft environment. The \\u201chigher\\u201d \\nenviro\", \"nments (like UAT and PROD) are harder environments that are expected to be more stable. To \\nenforce \", \"this, you can build protection rules into higher environments. You\\u2019ll configure an approval \\nprotect\", \"ion rule on the PROD environment: whenever a deployment job targets an environment with \\nan approval\", \" rule, it will pause until approval is granted before executing. \\nGitHub environments are logical. T\", \"hey represent the physical (or virtual) resources that you\\u2019re \\ndeploying to. In this case, the PRE-P\", \"ROD is just a deployment slot on the Azure Web App. PROD is the \\nproduction slot. The PRE-PROD deplo\", \"yment job will deploy the published .NET app to the staging \\nslot. The PROD deployment job will swap\", \" the slots. \\nOnce you have these steps in place, you\\u2019ll update the workflow to handle environment-sp\", \"ecific \\nconfiguration using environment secrets. \\nNote \\nFor more information, see GitHub Actions - E\", \"nvironments. \\nAzure authentication \\nTo perform actions such as deploying code to an Azure resource, \", \"you need the correct permissions. \\nFor deployment to Azure Web Apps, you can use a publishing profil\", \"e. If you want to deploy to a \\nstaging slot, then you\\u2019ll need the publishing profile for the slot to\", \"o. Instead, you can use a service \\nprincipal (SPN) and assign permission to this service principal. \", \"You can then authenticate using \\ncredentials for the SPN before using any commands that the SPN has \", \"permissions to perform. \\nOnce you have an SPN, you\\u2019ll create a repository secret to securely store t\", \"he credentials. You can then \\nrefer to the secret whenever you need to authenticate. The secret is e\", \"ncrypted and once it has been \\nsaved, can never be viewed or edited (only deleted or re-created). \\nC\", \"reate an SPN \\n1. \\nIn your terminal or Cloud Shell, run the following command to create a service pri\", \"ncipal with \\ncontributor permissions to the web app you created earlier: \\n  \\n:::{custom-style=CodeBo\", \"x} azurecli  az ad sp create-for-rbac --name \\\"{sp-name}\\\" --sdk-auth --\\nrole contributor \\\\  --scopes \", \"/subscriptions/{subscription-id}/resourceGroups/{resource-\\ngroup}/providers/Microsoft.Web/sites/{web\", \"appname} ::: \\n2. \\nThe command should output JSON that has credentials embedded: \\n  \\n:::{custom-style\", \"=CodeBox} json  {    \\\"clientId\\\": \\\"<GUID>\\\",    \\\"clientSecret\\\": \\\"<GUID>\\\",    \\n\\\"subscriptionId\\\": \\\"<GUID\", \">\\\",    \\\"tenantId\\\": \\\"<GUID>\\\",    ...  } ::: \\n \\n63 \\nCHAPTER 3 | Continuous integration and deployment \", \"with Azure DevOps \\n \\n3. \\nMake sure to record the clientId, clientSecret, subscription, and tenantId.\", \" You can also leave \\nthe terminal open for copy/paste later. \\nCreate a repository secret \\n1. \\nNow yo\", \"u\\u2019re going to create an encrypted secret to store the credentials. You\\u2019ll create this \\nsecret at the\", \" repository level. \\n2. \\nNavigate to GitHub and select your repository Settings tab. Then select Secr\", \"ets. Select New \\nrepository secret: \\n  \\n \\n**Figure 1**: Create a secret. \\n1. \\nCopy and paste the JSO\", \"N from the az ad sp create-for-rbac command into the body of the \\nsecret. You can create this JSON b\", \"y hand too if you have the relevant fields for your SPN. The \\nsecret should be named AZURE_CREDENTIA\", \"LS. Select Add secret to save the new secret: \\n  \\n \\n**Figure 2**: Add Azure credentials. \\n1. \\nYou\\u2019ll\", \" consume this secret in a workflow in later steps. To access it, use the variable notation \\n${{}}. I\", \"n this case, ${{ AZURE_CREDENTIAL }} will be populated with the JSON you saved. \\nAdd environments \\nE\", \"nvironments are used as a logical boundary. You can add approvals to environments to ensure \\nquality\", \". You can also track deployments to environments and specify environment-specific values \\n(secrets) \", \"for configuration. \\n \\n64 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\nFor\", \" this example, you\\u2019re going to split the actual Azure environment into two logical environments \\ncal\", \"led PRE-PROD and PROD. When you deploy the web app, you\\u2019ll deploy to the staging slot of the \\nAzure \", \"web app, represented by the PRE-PROD environment. When you\\u2019re ready to deploy to PROD, \\nyou\\u2019ll just \", \"perform a slot swap. \\nIn this case, the only difference between the environments is the slot that yo\", \"u\\u2019re deploying to. In real \\nlife, there would typically be different web apps (and separate web app \", \"plans), separate resource \\ngroups, and even separate subscriptions. Typically, there\\u2019s an SPN per en\", \"vironment. You may want to \\noverride the AZURE_CREDENTIAL value that you saved as a repository secre\", \"t by creating it as an \\nenvironment secret. \\nNote \\nPrecedence works from Environment to repository. \", \"If a targeted environment has a secret called \\nMY_SECRET, then that value is used. If not, the repos\", \"itory value of MY_SECRET (if any) is used. \\n1. \\nSelect Settings and then Environments in your reposi\", \"tory. Select New Environment: \\n    \\n \\n**Figure 3**: Create an environment. \\n1. \\nEnter PRE-PROD and s\", \"elect Configure environment: \\n \\n**Figure 4**: Name the environment. \\n \\n65 \\nCHAPTER 3 | Continuous in\", \"tegration and deployment with Azure DevOps \\n \\n1. \\nSince deploying to a staging slot doesn\\u2019t affect t\", \"he web app, you can safely deploy to the slot \\nwithout requiring an approval first. A reviewer could\", \" be added if desired. For this example, \\nleave the Environment protection rules empty. \\n  \\n[!NOTE] I\", \"f you target an environment in a workflow and it does not exist, an \\u201cempty\\u201d \\nenvironment is created \", \"automatically. The environment would look exactly the same as the \\nPRE-PROD environment - it would e\", \"xist, but would not have any protection rules enabled. \\n2. \\nSelect Environments again and again sele\", \"ct New Environment. Now enter PROD as the \\nname and select Configure environment. \\n3. \\nCheck the Req\", \"uired reviewers rule and add yourself as a reviewer. Don\\u2019t forget to select \\nSave protection rules: \", \"\\n  \\n \\n**Figure 5**: Add protection rules. \\nDeploy to staging \\nYou can now add additional jobs to the\", \" workflow to deploy to the environments! You\\u2019ll start by \\nadding a deployment to the PRE-PROD enviro\", \"nment, which in this case is the web app staging slot. \\n1. \\nNavigate to the .github/workflows/dotnet\", \".yml file and select the pencil icon to edit the file. \\n2. \\nYou\\u2019re going to use the web app name a f\", \"ew times in this workflow, and will need the name \\nof the resource group too. You\\u2019ll define the app \", \"and resource group names as variables. With \\nthe variables, you can maintain the values in one place\", \" in the workflow file. \\n3. \\nAdd this snippet below the on block and above the jobs block: \\n  \\n:::{cu\", \"stom-style=CodeBox} ```yml env: app-name: \\u201c\\u201d rg-name: \\u201c\\u201d \\n  \\njobs: # <\\u2013 this is the existing jobs li\", \"ne ``` ::: \\n  \\n[!WARNING] You\\u2019ll need to replace <name of your web app> with the actual name of your\", \" \\nweb app, and <name of your resource group> with the actual name of your resource group. \\n4. \\nAdd a\", \" new job below the build job as follows: \\n \\n66 \\nCHAPTER 3 | Continuous integration and deployment wi\", \"th Azure DevOps \\n \\n  \\n:::{custom-style=CodeBox} ```yml if-no-files-found: error # <\\u2013 last line of bu\", \"ild job: insert \\nbelow this line \\n  \\ndeploy_staging: needs: build runs-on: ubuntu-latest \\n environme\", \"nt: \\n   name: PRE-PROD \\n   url: ${{ steps.deploywebapp.outputs.webapp-url }} \\n \\n steps: \\n - name: Do\", \"wnload a Build Artifact \\n   uses: actions/download-artifact@v3 \\n   with: \\n     name: website \\n     p\", \"ath: website \\n \\n - name: Login via Azure CLI \\n   uses: azure/login@v1 \\n   with: \\n     creds: ${{ sec\", \"rets.AZURE_CREDENTIALS }} \\n \\n - name: Deploy web app \\n   id: deploywebapp \\n   uses: azure/webapps-de\", \"ploy@v2 \\n   with: \\n     app-name: ${{ env.app-name }} \\n     slot-name: staging \\n     package: websit\", \"e \\n \\n - name: az cli logout \\n   run: az logout \\n  \\n``` ::: \\nThe preceding workflow defines several s\", \"teps: \\n1. \\nYou\\u2019re creating a new job called deploy_staging. \\n2. \\nYou specify a dependency using need\", \"s. This job needs the build job to complete \\nsuccessfully before it starts. \\n3. \\nThis job also runs \", \"on the latest Ubuntu hosted agent, as specified with the runs-on \\nattribute. \\n4. \\nYou specify that t\", \"his job is targeting the PRE-PROD environment using the \\nenvironment object. You also specify the ur\", \"l property. This URL will be displayed in \\nthe workflow diagram, giving users an easy way to navigat\", \"e to the environment. The \\nvalue of this property is set as the output of the step with id deployweb\", \"app, which is \\ndefined below. \\n5. \\nYou\\u2019re executing a download-artifact step to download the artifac\", \"t (compiled web \\napp) from the build job. \\n6. \\nYou then login to Azure using the AZURE_CREDENTIALS s\", \"ecret you saved earlier. \\nNote the ${{ }} notation for dereferencing variables. \\n7. \\nYou then perfor\", \"m a webapp-deploy, specifying the app-name, slot-name, and path to \\nthe downloaded artifact (package\", \"). This action also defines an output parameter that \\nyou use to set the url of the environment abov\", \"e. \\n \\n67 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n8. \\nFinally, you ex\", \"ecute a logout to log out of the Azure context. \\n5. \\nCommit the file. \\n6. \\nWhen the run completes, y\", \"ou should see two successful jobs. The URL for the PRE-PROD \\nstage has been set and selecting it wil\", \"l navigate you to your web app staging slot: \\n    \\n \\n**Figure 6**: Deployment to PRE-PROD is success\", \"ful. \\n1. \\nNotice how the staging slot\\u2019s direct URL contains -staging: \\n  \\n \\n**Figure 7**: The stagin\", \"g slot running. \\n1. \\nYou can also now see deployments. Navigate to https://{your repository url}/dep\", \"loyments to \\nview your deployments: \\n \\n68 \\nCHAPTER 3 | Continuous integration and deployment with Az\", \"ure DevOps \\n \\n  \\n \\n**Figure 8**: View deployments. \\nDeploy to production \\nNow that you\\u2019ve deployed s\", \"uccessfully to PRE-PROD, you\\u2019ll want to deploy to PROD. Deployment to \\nPROD will be slightly differe\", \"nt since you don\\u2019t need to copy the website again - you just need to swap \\nthe staging slot with the\", \" production slot. You\\u2019ll do this using an Azure CLI (az) command. \\n1. \\nNavigate to the .github/workf\", \"lows/dotnet.yml file and select the pencil icon to edit the file. \\n2. \\nAdd a new job below the deplo\", \"y_staging job as follows: \\n  \\n:::{custom-style=CodeBox} ```yml run: az logout # <\\u2013 last line of prev\", \"ious job: insert below this \\nline \\n  \\ndeploy_prod: needs: deploy_staging runs-on: ubuntu-latest \\n en\", \"vironment: \\n   name: PROD \\n   url: ${{ steps.slot_swap.outputs.url }} \\n \\n steps: \\n - name: Login via\", \" Azure CLI \\n   uses: azure/login@v1 \\n   with: \\n     creds: ${{ secrets.AZURE_CREDENTIALS }} \\n \\n - na\", \"me: Swap staging slot into production \\n   id: slot_swap \\n   run: | \\n     az webapp deployment slot s\", \"wap -g ${{ env.rg-name }} -n ${{ env.app-name }} -s staging \\n     url=$(az webapp show -g ${{ env.rg\", \"-name }} -n ${{ env.app-name }} --query \\n\\\"defaultHostName\\\" -o tsv) \\n     echo \\\"::set-output name=url\", \"::http://$url\\\" \\n \\n - name: az cli logout \\n   run: az logout \\n``` ::: \\n  \\nThe deployment to the PROD \", \"environment workflow specifies several steps: \\n1. \\nOnce again, you specify a new job deploy_prod tha\", \"t needs deploy_staging to \\ncomplete before starting. \\n2. \\nYou\\u2019re targeting the PROD environment this\", \" time. Also, the url value is different from \\nbefore. \\n \\n69 \\nCHAPTER 3 | Continuous integration and \", \"deployment with Azure DevOps \\n \\n3. \\nFor the steps, you don\\u2019t need to download the artifact since you\", \"\\u2019re just going to \\nperform a slot swap. You start by executing a login to the Azure context. \\n4. \\nTh\", \"e Swap staging slot into production step is a multi-line run command (note the use \\nof the pipe symb\", \"ol |). You also specify an id for this step so that you can refer to it \\n(you refer to it in the url\", \" property of the environment). The first line executes the slot \\nswap using the variables you define\", \"d above in the workflow. The second line uses an \\naz webapp show command to extract the URL of the t\", \"arget web app. This final line \\nuses ::set-output in an echo to create an output variable for this t\", \"ask, setting the value \\nto the web app URL. \\n  \\n[!NOTE] The URL must start with http:// or https:// \", \"or it won\\u2019t render. \\n3. \\nCommit the file. \\n4. \\nLet the workflow run for a couple minutes until it ha\", \"s deployed to PRE-PROD. At this point, \\nthe workflow will pause and wait for the required approval s\", \"ince you\\u2019re targeting the PROD \\nenvironment, which requires an approval as defined earlier: \\n  \\n \\n**\", \"Figure 9**: Waiting for an approval. \\n1. \\nSelect Review deployments, select the PROD checkbox, optio\", \"nally add a comment, and then \\nselect Approve and deploy to start the PROD job. \\n \\n**Figure 10**: Ap\", \"prove the PROD deployment. \\n1. \\nThe deployment should only take a few seconds. Once it has completed\", \", the URL for the \\nPROD environment will update. \\n \\n70 \\nCHAPTER 3 | Continuous integration and deplo\", \"yment with Azure DevOps \\n \\n  \\n \\n**Figure 11**: PROD deployment completed. \\n1. \\nSelecting the PROD UR\", \"L will navigate you to the PROD site. \\n  \\n \\n**Figure 12**: The PROD site. \\nAdd a manual queue option\", \" \\nYou now have an end-to-end build and deploy workflow, including approvals. One more change you \\nca\", \"n make is to add a manual trigger to the workflow so that the workflow can be triggered from \\nwithin\", \" the Actions tab of the repository. \\n1. \\nNavigate to the .github/workflows/dotnet.yml file and selec\", \"t the pencil icon to edit the file. \\n2. \\nAdd a new trigger between on and push on lines 3 and 4: \\n  \", \"\\n:::{custom-style=CodeBox} yml  on:    workflow_dispatch:   # <-- this is the new line    push: ::: \", \"\\n3. \\nThe workflow_dispatch trigger displays a Run workflow button in the Actions tab of the \\nreposit\", \"ory\\u2014but only if the trigger is defined in the default branch. However, once this trigger is \\ndefined\", \" in the workflow, you can select the branch for the run. \\n4. \\nCommit the file. \\n \\n71 \\nCHAPTER 3 | Co\", \"ntinuous integration and deployment with Azure DevOps \\n \\n5. \\nTo see the Run workflow button, select \", \"the Actions tab. Select the .NET workflow in the list \\nof workflows. At the top of the list of runs,\", \" you\\u2019ll see the Run workflow button. If you select \\nit, you can choose the branch to run the workflo\", \"w against and queue it: \\n  \\n \\n**Figure 13**: Manual dispatch. \\nHandle environment configuration \\nYou\", \"r workflow is deploying the same binary to each environment. This concept is important to ensure \\nth\", \"at the binaries you test in one environment are the same that you deploy to the next. However, \\nenvi\", \"ronments typically have different settings like database connection strings. You want to ensure \\ntha\", \"t the DEV app is using DEV settings and the PROD app is using PROD settings. \\nFor this simple app, t\", \"here\\u2019s no database connection string. However, there\\u2019s an example configuration \\nsetting that you ca\", \"n modify for each environment. If you open the simple-feed-\\nreader/SimpleFeedReader/appsettings.json\", \" file, you\\u2019ll see that the configuration includes a setting for \\nthe Header text on the Index page: \", \"\\n  \\\"UI\\\": { \\n    \\\"Index\\\": { \\n      \\\"Header\\\": \\\"Simple News Reader\\\" \\n    } \\n  }, \\nTo show how environme\", \"nt configuration can be handled, you\\u2019re going to add a secret to each \\nenvironment and then substitu\", \"te that value into the settings as you deploy. \\nAdd environment secrets \\n1. \\nOn your repository, sel\", \"ect Settings > Environments > PRE-PROD. \\n2. \\nSelect Add secret and add a secret called index_header \", \"with the value PRE PROD News \\nReader. Select Add secret. \\n \\n72 \\nCHAPTER 3 | Continuous integration a\", \"nd deployment with Azure DevOps \\n \\n  \\n \\n**Figure 14**: Add an environment secret. \\n1. \\nRepeat these \", \"steps to add a secret called index_header with the value PROD News Reader for \\nthe PROD environment.\", \" \\n2. \\nIf you select Settings > Secrets in the repository, you\\u2019ll see the changes. They should look \\n\", \"something like this: \\n  \\n \\n**Figure 15**: View secrets. \\nUpdate the workflow to handle configuration\", \" \\n1. \\nNavigate to the .github/workflows/dotnet.yml file and select the pencil icon to edit the file.\", \" \\n2. \\nAdd the following step before the az cli logout step in the deploy_staging job: \\n  \\n:::{custom\", \"-style=CodeBox} ```yml - name: Update config uses: Azure/appservice-settings@v1 \\nwith: app-name: ${{\", \" env.app-name }}  slot-name: staging  app-settings-json: |  [  {  \\\"name\\\": \\n\\\"UI:Index:Header\\\",  \\\"valu\", \"e\\\": \\\"${{ secrets.INDEX_HEADER }}\\u201c,\\u201dslotSetting\\u201d: true } ] \\n  \\n - name: az cli logout   # <-- this ex\", \"ists already \\n  \\n``` ::: \\n \\n73 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \", \"\\n \\n3. \\nAdd almost the same code to the deploy_prod job above its az cli logout step. The only \\ndiffe\", \"rence is that you don\\u2019t specify a slot-name, since you\\u2019re targeting the production slot: \\n  \\n:::{cus\", \"tom-style=CodeBox} ```yml - name: Update config uses: Azure/appservice-settings@v1 \\nwith: app-name: \", \"${{ env.app-name }}  app-settings-json: |  [  {  \\\"name\\\": \\\"UI:Index:Header\\\",  \\n\\\"value\\\": \\\"${{ secrets.\", \"INDEX_HEADER }}\\u201c,\\u201dslotSetting\\u201d: true } ] \\n  \\n - name: az cli logout # <-- this exists already \\n  \\n``\", \"` ::: \\n4. \\nCommit the file. \\n5. \\nLet the workflow run and approve the deployment to PROD once the ap\", \"proval is reached. \\n6. \\nYou should see the following headers on the index page for both sites: \\n  \\n \", \"\\n**Figure 16**: Settings changed in the environments. \\nFinal workflow file \\nThe final workflow file \", \"should look like this: \\nname: .NET \\n \\non: \\n  workflow_dispatch: \\n    inputs: \\n      reason: \\n       \", \" description: 'The reason for running the workflow' \\n        required: true \\n        default: 'Manua\", \"l build from GitHub UI' \\n  push: \\n    branches: [ main ] \\n  pull_request: \\n    branches: [ main ] \\n \", \"\\nenv: \\n  app-name: \\\"cd-simplefeedreader\\\" \\n  rg-name: \\\"cd-dotnetactions\\\" \\n \\njobs: \\n  build: \\n \\n \\n74 \\n\", \"CHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n    runs-on: ubuntu-latest \\n \", \"\\n    steps: \\n    - uses: actions/checkout@v3 \\n    - name: 'Print manual run reason' \\n      if: ${{ g\", \"ithub.event_name == 'workflow_dispatch' }} \\n      run: | \\n        echo 'Reason: ${{ github.event.inp\", \"uts.reason }}' \\n    - name: Setup .NET \\n      uses: actions/setup-dotnet@v3 \\n      with: \\n        do\", \"tnet-version: 6.0.x \\n    - name: Restore dependencies \\n      run: dotnet restore \\n    - name: Build \", \"\\n      run: dotnet build --no-restore \\n    - name: Test \\n      run: dotnet test --no-build --verbosi\", \"ty normal \\n    - name: Publish \\n      run: dotnet publish SimpleFeedReader/SimpleFeedReader.csproj -\", \"c Release -o website \\n    - name: Upload a Build Artifact \\n      uses: actions/upload-artifact@v3 \\n \", \"     with: \\n        name: website \\n        path: SimpleFeedReader/website/** \\n        if-no-files-fo\", \"und: error \\n   \\n  deploy_staging: \\n    needs: build \\n    runs-on: ubuntu-latest \\n \\n    environment: \", \"\\n      name: STAGING \\n      url: ${{ steps.deploywebapp.outputs.webapp-url }} \\n \\n    steps: \\n    - n\", \"ame: Download a Build Artifact \\n      uses: actions/download-artifact@v3 \\n      with: \\n        name:\", \" website \\n        path: website \\n \\n    - name: Login via Azure CLI \\n      uses: azure/login@v1 \\n    \", \"  with: \\n        creds: ${{ secrets.AZURE_CREDENTIALS }} \\n \\n    - name: Deploy web app \\n      id: de\", \"ploywebapp \\n      uses: azure/webapps-deploy@v2 \\n      with: \\n        app-name: ${{ env.app-name }} \", \"\\n        slot-name: staging \\n        package: website \\n \\n    - name: Update config \\n      uses: Azur\", \"e/appservice-settings@v1 \\n      with: \\n       app-name: ${{ env.app-name }} \\n       slot-name: stagi\", \"ng \\n       app-settings-json: | \\n \\n75 \\nCHAPTER 3 | Continuous integration and deployment with Azure \", \"DevOps \\n \\n         [ \\n             { \\n                 \\\"name\\\": \\\"UI:Index:Header\\\", \\n                 \", \"\\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\\", \\n                 \\\"slotSetting\\\": true \\n             } \\n     \", \"    ] \\n \\n    - name: az cli logout \\n      run: az logout \\n \\n  deploy_prod: \\n    needs: deploy_stagin\", \"g \\n    runs-on: ubuntu-latest \\n \\n    environment: \\n      name: PROD \\n      url: ${{ steps.slot_swap.\", \"outputs.url }} \\n \\n    steps: \\n    - name: Login via Azure CLI \\n      uses: azure/login@v1 \\n      wit\", \"h: \\n        creds: ${{ secrets.AZURE_CREDENTIALS }} \\n \\n    - name: Swap staging slot into production\", \" \\n      id: slot_swap \\n      run: | \\n        az webapp deployment slot swap -g ${{ env.rg-name }} -n\", \" ${{ env.app-name }} -s \\nstaging \\n        url=$(az webapp show -g ${{ env.rg-name }} -n ${{ env.app-\", \"name }} --query \\n\\\"defaultHostName\\\" -o tsv) \\n        echo \\\"::set-output name=url::http://$url\\\" \\n \\n   \", \" - name: Update config \\n      uses: Azure/appservice-settings@v1 \\n      with: \\n       app-name: ${{ \", \"env.app-name }} \\n       app-settings-json: | \\n         [ \\n             { \\n                 \\\"name\\\": \\\"\", \"UI:Index:Header\\\", \\n                 \\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\\", \\n                 \\\"slotS\", \"etting\\\": true \\n             } \\n         ] \\n \\n    - name: az cli logout \\n      run: az logout \\nSecure\", \" .NET Code with CodeQL and GitHub Actions \\nCodeQL is a static code analysis engine that can automate\", \" security and quality checks. With CodeQL, \\nyou can perform variant analysis, which uses known vulne\", \"rabilities as seeds to find similar issues. \\nCodeQL is part of GitHub Advanced Security that include\", \"s: \\n[!div class=\\u201cchecklist\\u201d] \\n \\n76 \\nCHAPTER 3 | Continuous integration and deployment with Azure Dev\", \"Ops \\n \\n\\u2022 \\nCode scanning\\u2014find potential security vulnerabilities in your code. \\n\\u2022 \\nSecret scanning\\u2014de\", \"tect secrets and tokens that are committed. \\n\\u2022 \\nDependency scanning\\u2014detect vulnerabilities in packag\", \"es that you consume. \\nCodeQL supports some of the most popular programming languages and compilers: \", \"\\n\\u2022 \\nC/C++ \\n\\u2022 \\nJava \\n\\u2022 \\nC# \\n\\u2022 \\nPython \\n\\u2022 \\nGo \\n\\u2022 \\nJavaScript \\n\\u2022 \\nTypeScript \\nCodeQL is a powerful lang\", \"uage and security professionals can create custom queries using CodeQL. \\nHowever, teams can benefit \", \"immensely from the large open-source collection of queries that the \\nsecurity community has created \", \"without having to write any custom CodeQL. \\nIn this article, you\\u2019ll set up a GitHub workflow that wi\", \"ll scan code in your repository using CodeQL. \\nYou will: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nCreate a code\", \" scanning action. \\n\\u2022 \\nEdit the workflow file to include custom scan settings. \\n\\u2022 \\nSee scanning resul\", \"ts. \\nNote \\nTo see security alerts for your repository, you must be a repository owner. \\nCreate the c\", \"ode scanning workflow \\nYou can use a starter workflow for code scanning by navigating to the Securit\", \"y tab of your repository. \\n1. \\nNavigate to your GitHub repository and select the Security > Code Sca\", \"nning Alerts. The top \\nrecommended workflow should be CodeQL Analysis. Select Set up this workflow. \", \"\\n  \\n \\n**Figure 1:** Create a new code scanning workflow. \\n \\n77 \\nCHAPTER 3 | Continuous integration a\", \"nd deployment with Azure DevOps \\n \\n1. \\nA new workflow file is created in your .github/workflows fold\", \"er. \\n2. \\nSelect Start Commit on the upper right to save the default workflow. You can commit to the \", \"\\nmain branch. \\n  \\n \\n**Figure 2:** Commit the file. \\n1. \\nSelect the Actions tab. In the left-hand tre\", \"e, you\\u2019ll see a CodeQL node. Select this node to \\nfilter for CodeQL workflow runs. \\n  \\n \\n**Figure 3:\", \"** View the CodeQL workflow runs. \\nTake a look at the workflow file while it runs. If you remove the\", \" comments from the file, you\\u2019ll see the \\nfollowing YAML: \\nname: \\\"CodeQL\\\" \\n \\non: \\n  push: \\n    branch\", \"es: [ main ] \\n  pull_request: \\n    branches: [ main ] \\n  schedule: \\n    - cron: '40 14 * * 6' \\n \\njob\", \"s: \\n  analyze: \\n    name: Analyze \\n    runs-on: ubuntu-latest \\n \\n    strategy: \\n      fail-fast: fal\", \"se \\n \\n78 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n      matrix: \\n    \", \"    language: [ 'csharp' ] \\n \\n    steps: \\n    - name: Checkout repository \\n      uses: actions/check\", \"out@v3 \\n \\n    - name: Initialize CodeQL \\n      uses: github/codeql-action/init@v1 \\n      with: \\n    \", \"    languages: ${{ matrix.language }} \\n \\n    - name: Autobuild \\n      uses: github/codeql-action/aut\", \"obuild@v1 \\n \\n    - name: Perform CodeQL Analysis \\n      uses: github/codeql-action/analyze@v1 \\nNotic\", \"e the following things: \\n1. \\nThe workflow name is CodeQL. \\n2. \\nThis workflow triggers on push and pu\", \"ll_request events to the main branch. There\\u2019s also a \\ncron trigger. The cron trigger lets you define\", \" a schedule for triggering this workflow and is \\nrandomly generated for you. In this case, this work\", \"flow will run at 14:40 UTC every Saturday. \\n  \\n[!TIP] If you edit the workflow file and hover over t\", \"he cron expression, a tooltip will show you \\nthe English text for the cron expression. \\n3. \\nThere\\u2019s \", \"a single job called analyze that runs on the ubuntu-latest hosted agent. \\n4. \\nThis workflow defines \", \"a strategy with a matrix on the array of language. In this case, there\\u2019s \\nonly csharp. If the reposi\", \"tory contained other languages, you could add them to this array. \\nThis causes the job to \\u201cfan out\\u201d \", \"and create an instance per value of the matrix. \\n5. \\nThere are four steps, starting with checkout. \\n\", \"6. \\nThe second step initializes the CodeQL scanner for the language this job is going to scan. \\nCode\", \"QL intercepts calls to the compiler to build a database of the code while the code is \\nbeing built. \", \"\\n7. \\nThe Autobuild step will attempt to automatically build the source code using common \\nconvention\", \"s. If this step fails, you can replace it with your own custom build steps. \\n8. \\nAfter building, the\", \" CodeQL analysis is performed, where suites of queries are run against the \\ncode database. \\n9. \\nThe \", \"run should complete successfully. However, there appear to be no issues. \\n \\n79 \\nCHAPTER 3 | Continuo\", \"us integration and deployment with Azure DevOps \\n \\n  \\n \\n**Figure 4:** No results to the initial scan\", \". \\nCustomize CodeQL settings \\nThe CodeQL scan isn\\u2019t reporting any security issues. That\\u2019s expected w\", \"ith this basic sample. CodeQL \\ncan also scan for quality issues. The current workflow is using the d\", \"efault security-extended suite. You \\ncan add quality scanning in by adding a configuration file to c\", \"ustomize the scanning suites. In this \\nstep, you\\u2019ll configure CodeQL to use the security-and-quality\", \" suites. \\n[!INFORMATION] For other CodeQL configuration options, see Configuring CodeQL code scannin\", \"g in \\nyour CI system. \\n1. \\nNavigate to the .github folder in the Code tab and select Add File: \\n  \\n \", \"\\n**Figure 5:** Create a new file. \\n1. \\nEnter codeql/codeql-config.yml as the name. This creates the \", \"file in a folder. Paste in the \\nfollowing code: \\n  \\n:::{custom-style=CodeBox} ```yml name: \\u201cSecurity\", \" and Quality\\u201d \\n  \\nqueries: \\n\\u2013 \\nuses: security-and-quality ``` ::: \\n \\n80 \\nCHAPTER 3 | Continuous inte\", \"gration and deployment with Azure DevOps \\n \\n  \\n \\n**Figure 6:** Create the CodeQL configuration file.\", \" \\n1. \\nSelect Commit to main at bottom of the editor to commit the file. \\n2. \\nEdit the CodeQL workflo\", \"w to use the new configuration file. Navigate to \\n.github/workflows/codeql-analysis.yml and select t\", \"he pencil icon. Add a new property to the \\nwith section as shown below: \\n:::{custom-style=CodeBox} y\", \"ml   - name: Initialize CodeQL     uses: github/codeql-action/init@v1     \\nwith:       languages: ${\", \"{ matrix.language }}       config-file: ./.github/codeql/codeql-config.yml  # <-- \\nadd this line :::\", \" \\n1. \\nSelect Start Commit and commit to the main branch. \\nReview the security alerts \\nImportant \\nYou\", \" must be a repository owner to view security alerts. \\nThis sample repository is small. As such, it d\", \"oesn\\u2019t contain any major security or quality issues. \\nHowever, \\u201creal world\\u201d repositories will likely\", \" have some issues. \\nWhen the last CodeQL workflow run completes, you should see two issues in the Se\", \"curity tab: \\n \\n81 \\nCHAPTER 3 | Continuous integration and deployment with Azure DevOps \\n \\n \\nFigure 7\", \": View security alerts. \\n1. \\nSelect the first alert to open it. \\n2. \\nIn this case, the alert is for \", \"a generated file that isn\\u2019t committed to the repository. For that \\nreason, the preview is unavailabl\", \"e. \\n3. \\nNotice the tags that are applied. These tags can be used for filtering issues. \\n4. \\nSelect S\", \"how more under the rule information to show help and recommendations. \\n  \\n \\n**Figure 8:** Open an al\", \"ert. \\n1. \\nSelecting Dismiss will open options for dismissing this issue: \\n \\n82 \\nCHAPTER 3 | Continuo\", \"us integration and deployment with Azure DevOps \\n \\n  \\n \\n**Figure 9:** Dismiss an alert. \\n \\n83 \\nCHAPT\", \"ER 4 | Monitor and debug \\n \\nCHAPTER 4 \\nMonitor and debug \\nHaving deployed the app and built a DevOps\", \" pipeline, it\\u2019s important to understand how to monitor \\nand troubleshoot the app. \\nIn this section, \", \"you\\u2019ll complete the following tasks: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nFind basic monitoring and trouble\", \"shooting data in the Azure portal \\n\\u2022 \\nLearn how Azure Monitor provides a deeper look at metrics acro\", \"ss all Azure services \\n\\u2022 \\nConnect the web app with Application Insights for app profiling \\n\\u2022 \\nTurn o\", \"n logging and learn where to download logs \\n\\u2022 \\nStream logs in real time \\n\\u2022 \\nLearn where to set up al\", \"erts \\n\\u2022 \\nLearn about remote debugging Azure App Service web apps. \\nBasic monitoring and troubleshoot\", \"ing \\nApp Service web apps are easily monitored in real time. The Azure portal renders metrics in eas\", \"y-to-\\nunderstand charts and graphs. \\n1. \\nOpen the Azure portal, and then navigate to the mywebapp<un\", \"ique_number> App Service. \\n2. \\nThe Overview tab displays useful \\u201cat-a-glance\\u201d information, including\", \" graphs displaying \\nrecent metrics. \\n        \\n \\n \\n84 \\nCHAPTER 4 | Monitor and debug \\n \\n* **Http 5xx*\", \"*: Count of server-side errors, usually exceptions in ASP.NET Core code. \\n* **Data In**: Data ingres\", \"s coming into your web app. \\n* **Data Out**: Data egress from your web app to clients. \\n* **Requests\", \"**: Count of HTTP requests. \\n* **Average Response Time**: Average time for the web app to respond to\", \" HTTP requests. \\n \\nSeveral self-service tools for troubleshooting and optimization are also found on\", \" this \\npage. \\n \\n \\n \\n* **Diagnose and solve problems** is a self-service troubleshooter. \\n* **Applica\", \"tion Insights** is for profiling performance and app behavior, and is \\ndiscussed later in this secti\", \"on. \\n* **App Service Advisor** makes recommendations to tune your app experience. \\nAdvanced monitori\", \"ng \\nAzure Monitor is the centralized service for monitoring all metrics and setting alerts across Az\", \"ure \\nservices. Within Azure Monitor, administrators can granularly track performance and identify tr\", \"ends. \\nEach Azure service offers its own set of metrics to Azure Monitor. \\nProfile with Application \", \"Insights \\nApplication Insights is an Azure service for analyzing the performance and stability of we\", \"b apps and \\nhow users use them. The data from Application Insights is broader and deeper than that o\", \"f Azure \\nMonitor. The data can provide developers and administrators with key information for improv\", \"ing \\napps. Application Insights can be added to an Azure App Service resource without code changes. \", \"\\n1. \\nOpen the Azure portal, and then navigate to the mywebapp<unique_number> App Service. \\n2. \\nFrom \", \"the Overview tab, click the Application Insights tile. \\n \\n85 \\nCHAPTER 4 | Monitor and debug \\n \\n \\n \\n1\", \". \\nSelect the Create new resource radio button. Use the default resource name, and select the \\nlocat\", \"ion for the Application Insights resource. The location doesn\\u2019t need to match that of your \\nweb app.\", \" \\n      \\n \\n1. \\nFor Runtime/Framework, select ASP.NET Core. Accept the default settings. \\n2. \\nSelect \", \"OK. If prompted to confirm, select Continue. \\n3. \\nAfter the resource has been created, click the nam\", \"e of Application Insights resource to \\nnavigate directly to the Application Insights page. \\n \\nAs the\", \" app is used, data accumulates. Select Refresh to reload the blade with new data. \\n \\n86 \\nCHAPTER 4 |\", \" Monitor and debug \\n \\n \\nApplication Insights provides useful server-side information with no additio\", \"nal configuration. To get \\nthe most value from Application Insights, instrument your app with the Ap\", \"plication Insights SDK. \\nWhen properly configured, the service provides end-to-end monitoring across\", \" the web server and \\n \\n87 \\nCHAPTER 4 | Monitor and debug \\n \\nbrowser, including client-side performan\", \"ce. For more information, see the Application Insights \\ndocumentation. \\nLogging \\nWeb server and app \", \"logs are disabled by default in Azure App Service. Enable the logs with the \\nfollowing steps: \\n1. \\nO\", \"pen the Azure portal, and navigate to the mywebapp<unique_number> App Service. \\n2. \\nIn the menu to t\", \"he left, scroll down to the Monitoring section. Select Diagnostics logs. \\n      \\n  \\n1. \\nTurn on Appl\", \"ication Logging (Filesystem). If prompted, click the box to install the \\nextensions to enable app lo\", \"gging in the web app. \\n2. \\nSet Web server logging to File System. \\n3. \\nEnter the Retention Period in\", \" days. For example, 30. \\n4. \\nClick Save. \\nASP.NET Core and web server (App Service) logs are generat\", \"ed for the web app. They can be \\ndownloaded using the FTP/FTPS information displayed. The password i\", \"s the same as the deployment \\ncredentials created earlier in this guide. The logs can be streamed di\", \"rectly to your local machine with \\nPowerShell or Azure CLI. Logs can also be viewed in Application I\", \"nsights. \\nLog streaming \\nApp and web server logs can be streamed in real time through the portal. \\n1\", \". \\nOpen the Azure portal, and navigate to the mywebapp<unique_number> App Service. \\n2. \\nIn the menu \", \"to the left, scroll down to the Monitoring section and select Log stream. \\n \\n88 \\nCHAPTER 4 | Monitor\", \" and debug \\n \\n    \\n \\nLogs can also be streamed via Azure CLI or Azure PowerShell, including through \", \"the Cloud Shell. \\nAlerts \\nAzure Monitor also provides real time alerts based on metrics, administrat\", \"ive events, and other \\ncriteria. \\nNote \\nCurrently alerting on web app metrics is only available in t\", \"he Alerts (classic) service. \\nThe Alerts (classic) service can be found in Azure Monitor or under th\", \"e Monitoring section of the App \\nService settings. \\n \\nLive debugging \\nAzure App Service can be debug\", \"ged remotely with Visual Studio when logs don\\u2019t provide enough \\ninformation. However, remote debuggi\", \"ng requires the app to be compiled with debug symbols. \\nDebugging shouldn\\u2019t be done in production, e\", \"xcept as a last resort. \\n \\n89 \\nCHAPTER 4 | Monitor and debug \\n \\nConclusion \\nIn this section, you com\", \"pleted the following tasks: \\n[!div class=\\u201cchecklist\\u201d] \\n\\u2022 \\nFind basic monitoring and troubleshooting \", \"data in the Azure portal \\n\\u2022 \\nLearn how Azure Monitor provides a deeper look at metrics across all Az\", \"ure services \\n\\u2022 \\nConnect the web app with Application Insights for app profiling \\n\\u2022 \\nTurn on logging\", \" and learn where to download logs \\n\\u2022 \\nStream logs in real time \\n\\u2022 \\nLearn where to set up alerts \\n\\u2022 \\n\", \"Learn about remote debugging Azure App Service web apps. \\nAdditional reading \\n\\u2022 \\nTroubleshooting ASP\", \".NET Core on Azure App Service and IIS \\n\\u2022 \\nCommon errors reference for Azure App Service and IIS wit\", \"h ASP.NET Core \\n\\u2022 \\nMonitor Azure web app performance with Application Insights \\n\\u2022 \\nEnable diagnostic\", \"s logging for web apps in Azure App Service \\n\\u2022 \\nTroubleshoot a web app in Azure App Service using Vi\", \"sual Studio \\n\\u2022 \\nCreate classic metric alerts in Azure Monitor for Azure services - Azure portal \\n \\n9\", \"0 \\nCHAPTER 5 | Next steps \\n \\nCHAPTER 5 \\nNext steps \\nIn this guide, you created a DevOps pipeline for\", \" an ASP.NET Core sample app. Congratulations! We \\nhope you enjoyed learning to publish ASP.NET Core \", \"web apps to Azure App Service and automate the \\ncontinuous integration of changes. \\nBeyond web hosti\", \"ng and DevOps, Azure has a wide array of Platform-as-a-Service (PaaS) services \\nuseful to ASP.NET Co\", \"re developers. This section gives a brief overview of some of the most commonly \\nused services. \\nSto\", \"rage and databases \\nRedis Cache is high-throughput, low-latency data caching available as a service.\", \" It can be used for \\ncaching page output, reducing database requests, and providing ASP.NET Core ses\", \"sion state across \\nmultiple instances of an app. \\nAzure Storage is Azure\\u2019s massively scalable cloud \", \"storage. Developers can take advantage of Queue \\nStorage for reliable message queuing, and Table Sto\", \"rage is a NoSQL key-value store designed for \\nrapid development using massive, semi-structured data \", \"sets. \\nAzure SQL Database provides familiar relational database functionality as a service using the\", \" Microsoft \\nSQL Server Engine. \\nCosmos DB globally distributed, multi-model NoSQL database service. \", \"Multiple APIs are available, \\nincluding SQL API (formerly called DocumentDB), Cassandra, and MongoDB\", \". \\nIdentity \\nAzure Active Directory and Azure Active Directory B2C are both identity services. Azure\", \" Active \\nDirectory is designed for enterprise scenarios and enables Azure AD B2B (business-to-busine\", \"ss) \\ncollaboration, while Azure Active Directory B2C is intended business-to-customer scenarios, inc\", \"luding \\nsocial network sign-in. \\nMobile \\nNotification Hubs is a multi-platform, scalable push-notifi\", \"cation engine to quickly send millions of \\nmessages to apps running on various types of devices. \\n \\n\", \"91 \\nCHAPTER 5 | Next steps \\n \\nWeb infrastructure \\nAzure Container Service manages your hosted Kubern\", \"etes environment, making it quick and easy to \\ndeploy and manage containerized apps without containe\", \"r orchestration expertise. \\nAzure Search is used to create an enterprise search solution over privat\", \"e, heterogenous content. \\nService Fabric is a distributed systems platform that makes it easy to pac\", \"kage, deploy, and manage \\nscalable and reliable microservices and containers. \\n\"]"