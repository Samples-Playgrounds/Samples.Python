"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\nEDITION v1.1.0  \\nRefer changelog  for th\", \"e book updates and community contributions.  \\nThis guide is available as a downloadable PDF e -book \", \". \\nPUBLISHED BY  \\nMicrosoft Developer Division, .NET, and Visual Studio product teams  \\nA division o\", \"f Microsoft Corporation  \\nOne Microsoft Way  \\nRedmond, Washington 98052 -6399  \\nCopyright \\u00a9 2022 by \", \"Microsoft Corporation  \\nAll rights reserved. No part of the contents of this book may be reproduced \", \"or transmitted in any \\nform or by any means without the written permission of the publisher.  \\nThis \", \"book is provided \\u201cas -is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions, and \\ni\", \"nformation expressed in this book, including URL and other Internet website references, may change \\n\", \"without notice.  \\nSome examples depicted herein are provided for illustration only and are fictitiou\", \"s. No real association \\nor connection is intended or should be inferred.  \\nMicrosoft and the tradema\", \"rks listed at https://www.microsoft.com  on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsof\", \"t group of companies.  \\nMac and macOS are trademarks of Apple Inc.  \\nThe Docker whale logo is a regi\", \"stered trademark of Docker, Inc.  Used by permission.  \\nAll other marks and logos are property of th\", \"eir respective owners.  \\nCredits  \\nAuthors:  \\nCam Soper  \\nScott Addie  \\nColin Dembovsky  \\nWelcome  \\n\", \"Welcome to the Azure Development Lifecycle guide for .NET! This guide introduces the basic concepts \", \"\\nof building a development lifecycle around Azure using .NET tools and processes. After finishing th\", \"is \\nguide, you\\u2019ll reap the benefits of a mature DevOps too lchain.  \\nWho this guide is for   \\nYou sh\", \"ould be an experienced ASP.NET Core developer (200 -300 level). You don\\u2019t need to know \\nanything abo\", \"ut Azure, as we\\u2019ll cover that in this introduction. This guide may also be useful for \\nDevOps engine\", \"ers who are more focused on operations than developme nt. \\nThis guide targets Windows developers. Ho\", \"wever, Linux and macOS are fully supported by .NET Core. \\nTo adapt this guide for Linux/macOS, watch\", \" for callouts for Linux/macOS differences.  \\nWhat this guide doesn\\u2019t cover  \\nThis guide is focused o\", \"n an end -to-end continuous deployment experience for .NET developers. It\\u2019s \\nnot an exhaustive guide\", \" to all things Azure, and it doesn\\u2019t focus extensively on .NET APIs for Azure \\nservices. The emphasi\", \"s is all around continuous integrati on, deployment, monitoring, and debugging. \\nNear the end of the\", \" guide, recommendations for next steps are offered. Included in the suggestions \\nare Azure platform \", \"services that are useful to ASP.NET Core developers.  \\nWhat\\u2019s in this guide  \\nTools and downloads  \\n\", \"Learn where to acquire the tools used in this guide.  \\nDeploy to App Service  \\nLearn the various met\", \"hods for deploying an ASP.NET Core app to Azure App Service.  \\nContinuous integration and deployment\", \" with Azure DevOps  \\nBuild an end -to-end continuous integration and deployment solution for your AS\", \"P.NET Core app with \\nGitHub, Azure DevOps Services, and Azure.  \\nContinuous integration and deployme\", \"nt with GitHub Actions  \\nBuild an end -to-end continuous integration and deployment solution for you\", \"r ASP.NET Core app with \\nGitHub, GitHub Actions, and Azure, including code scanning for security and\", \" quality using CodeQL.  \\nMonitor and debug  \\nUse Azure\\u2019s tools to monitor, troubleshoot, and tune yo\", \"ur application.  \\nNext steps  \\nOther learning paths for the ASP.NET Core developer learning Azure.  \", \"\\nAdditional introductory reading  \\nIf this is your first exposure to cloud computing, these articles\", \" explain the basics.  \\n\\u2022 What is Cloud Computing?  \\n\\u2022 Examples of Cloud Computing   \\n\\u2022 What is IaaS?\", \"  \\n\\u2022 What is PaaS?   \\ni Contents   \\nContents  \\nTools and downloads  ................................\", \" ................................ ................................ ..............  1 \\nPrerequisites \", \" ................................ ................................ ................................ \", \"................................ ................................ ..............  1 \\nRecommended too\", \"ls (Windows only) ................................ ................................ ................\", \"................ ..............................  1 \\nDeploy an app to App Service  ..................\", \".............. ................................ ................................  3 \\nDownload and te\", \"st the app  ................................ ................................ ......................\", \".......... ................................ .................  3 \\nCreate the Azure App Service Web A\", \"pp  ................................ ................................ ..............................\", \".. .........................  5 \\nDeployment with Visual Studio  ................................ ...\", \"............................. ................................ ................................ ....\", \"......  6 \\nDeployment slots  ................................ ................................ .....\", \"........................... ................................ ................................ ..... \", \"8 \\nSummary  ................................ ................................ ......................\", \".......... ................................ ................................ ..................  10 \", \"\\nAdditional reading  ................................ ................................ .............\", \"................... ................................ ................................  10 \\nContinuou\", \"s integration and deployment with Azure DevOps  ................................ .........  11 \\nPubl\", \"ish the app\\u2019s code to GitHub  ................................ ................................ ....\", \"............................ ................................ .. 12 \\nDisconnect local Git deployment\", \"  ................................ ................................ ................................\", \" ................................ ... 12 \\nCreate an Azure DevOps organization  .....................\", \"........... ................................ ................................ ......................\", \"...  13 \\nCreate a team project in Azure DevOps organization  ................................ ......\", \".......................... ...........................  13 \\nConfigure a self -hosted agent if necess\", \"ary  ................................ ................................ .............................\", \"... ................  13 \\nConfigure the Azure Pipelines pipeline  ................................ .\", \"............................... ................................ ........................  14 \\nGrant\", \" Azure DevOps access to the GitHub repository  ................................ ....................\", \"............ ......................  14 \\nCreate the build definition  ..............................\", \".. ................................ ................................ ...............................\", \". ...........  16 \\nCreate the release pipeline  ................................ ...................\", \"............. ................................ ................................ ...........  18 \\nCom\", \"mit changes to GitHub and automatically deploy to Azure  ................................ ..........\", \"...................... ....... 22 \\nExamine the Azure Pipelines pipeline  ...........................\", \"..... ................................ ................................ ........................... \", \" 23 \\nBuild definition  ................................ ................................ ...........\", \"..................... ................................ ................................ .. 23 \\nRelea\", \"se pipeline  ................................ ................................ .....................\", \"........... ................................ ................................  26 \\nAdditional readin\", \"g  ................................ ................................ ...............................\", \". ................................ ................................  29 \\nContinuous integration and \", \"deployment with Azure DevOps  ................................ ................................ ....\", \".......  30 \\nPublish the app\\u2019s code to GitHub  ................................ ....................\", \"............ ................................ ..............................  30 \\nDisconnect local G\", \"it deployment  ................................ ................................ ...................\", \"............. ...............................  31  \\nii Contents  Create an Azure DevOps organization\", \"  ................................ ................................ ................................\", \" ....................  31 \\nCreate a team project in Azure DevOps organization  .....................\", \"........... ................................ .......................  32 \\nConfigure a self -hosted a\", \"gent if necessary  ................................ ................................ ...............\", \"................. ...........  32 \\nConfigure the Azure Pipelines pipeline  .........................\", \"....... ................................ ................................ ...................  32 \\nC\", \"ommit changes to GitHub and automatically deploy to Azure  ................................ ........\", \"........................ .. 40 \\nExamine the Azure Pipelines pipeline  ..............................\", \".. ................................ ................................ ......................  41 \\nAdd\", \"itional reading  ................................ ................................ .................\", \"............... ................................ ...........................  47 \\nContinuous integra\", \"tion and deployment with GitHub Actions  ................................ ..........................\", \"...... ..........  48 \\nGitHub Actions  ................................ ............................\", \".... ................................ ................................ .............................\", \"... .. 48 \\nSecure code with CodeQL  ................................ ...............................\", \". ................................ ................................ ............  48 \\nCompare and co\", \"ntrast GitHub Actions and Azure Pipelines  ................................ ........................\", \"........ ..........  49 \\nContinuous integration and deployment with GitHub Actions  ................\", \"................ ................................ ..........  49 \\nGitHub Actions  ..................\", \".............. ................................ ................................ ...................\", \"............. ................................ .. 49 \\nSecure code with CodeQL  .....................\", \"........... ................................ ................................ ......................\", \".......... ............  50 \\nCompare and contrast GitHub Actions and Azure Pipelines  ..............\", \".................. ................................ ..........  50 \\nCompare and contrast GitHub Acti\", \"ons and Azure Pipelines  ................................ ................................ .........\", \"......  50 \\nPipelines as code  ................................ ................................ ...\", \"............................. ................................ ..............................  50 \\nA\", \"gents and runners  ................................ ................................ ...............\", \"................. ................................ .........................  51 \\nComparison of GitH\", \"ub Actions and Azure Pipelines  ................................ ................................ ..\", \".......................  52 \\nBuild a .NET web app using GitHub Actions  ............................\", \".... ................................ ................................ ..............  55 \\nWorkflow \", \"structure  ................................ ................................ .......................\", \"......... ................................ ..........................  55 \\nCreate a basic build work\", \"flow  ................................ ................................ ............................\", \".... ................................ ..... 56 \\nDissect the workflow file  .........................\", \"....... ................................ ................................ ..........................\", \"...... ...............  58 \\nPublish the output  ................................ ...................\", \"............. ................................ ................................ ....................\", \".......  59 \\nDeploy a .NET web app using GitHub Actions  ................................ ..........\", \"...................... ................................ ..........  61 \\nEnvironments  ..............\", \".................. ................................ ................................ ...............\", \"................. ................................ ..... 61 \\nAzure authentication ..................\", \".............. ................................ ................................ ...................\", \"............. .......................  62 \\nAdd environments  ................................ ......\", \".......................... ................................ ................................ .......\", \"....................  63 \\nDeploy to staging ................................ .......................\", \"......... ................................ ................................ ........................\", \".....  65 \\nDeploy to production  ................................ ................................ .\", \"............................... ................................ .....................  68 \\nAdd a ma\", \"nual queue option  ................................ ................................ ...............\", \"................. ................................ ........ 70 \\nHandle environment configuration ...\", \"............................. ................................ ................................ ....\", \".......................  71  \\niii Contents  Final workflow file  ................................ ..\", \".............................. ................................ ................................ ...\", \".........................  73 \\nSecure .NET Code with CodeQL and GitHub Actions  ....................\", \"............ ................................ .............................  75 \\nCreate the code sca\", \"nning workflow  ................................ ................................ ..................\", \".............. .........................  76 \\nCustomize CodeQL settings  ...........................\", \"..... ................................ ................................ ............................\", \".... ......... 79 \\nReview the security alerts  ................................ ....................\", \"............ ................................ ................................ .............  80 \\nMo\", \"nitor and debug  ................................ ................................ .................\", \"............... ...............  83 \\nBasic monitoring and troubleshooting  .........................\", \"....... ................................ ................................ ........................  \", \"83 \\nAdvanced monitoring  ................................ ................................ .........\", \"....................... ................................ .........................  84 \\nProfile with\", \" Application Insights  ................................ ................................ ...........\", \"..................... ................................ ..... 84 \\nLogging  ..........................\", \"...... ................................ ................................ ...........................\", \"..... ................................ .....................  87 \\nLog streaming  ...................\", \"............. ................................ ................................ ....................\", \"............ ................................ ........ 87 \\nAlerts  ................................ \", \"................................ ................................ ................................ .\", \"............................... ..........................  88 \\nLive debugging  ....................\", \"............ ................................ ................................ .....................\", \"........... ................................ ...... 88 \\nConclusion  ................................\", \" ................................ ................................ ................................ \", \"................................ ...............  89 \\nAdditional reading  ..........................\", \"...... ................................ ................................ ...........................\", \"..... ................................  89 \\nNext steps  ................................ ...........\", \"..................... ................................ ..............................  90 \\nStorage a\", \"nd databases  ................................ ................................ ....................\", \"............ ................................ .......................  90 \\nIdentity  ...............\", \"................. ................................ ................................ ................\", \"................ ................................ ......................  90 \\nMobile  ..............\", \".................. ................................ ................................ ...............\", \"................. ................................ .......................  90 \\nWeb infrastructure  \", \"................................ ................................ ................................ .\", \"............................... ................................  91  \\n1 CHAPTER 1 | Tools and downl\", \"oads  \\n CHAPTER  1 \\nTools and downloads  \\nAzure has several interfaces for provisioning and managing\", \" resources, such as the Azure portal , Azure \\nCLI, Azure PowerShell , Azure Cloud Shell , and Visual\", \" Studio. This guide takes a minimalist approach \\nand uses the Azure Cloud Shell whenever possible to\", \" reduce the steps required. However, the Azure \\nportal must be used for some portions.  \\nPrerequisit\", \"es  \\nThe following subscriptions are required:  \\n\\u2022 Azure \\u2014 If you don\\u2019t have an account, get a free \", \"trial . \\n\\u2022 Azure DevOps Services \\u2014 your Azure DevOps subscription and organization is created in \\nCh\", \"apter 4.  \\n\\u2022 GitHub \\u2014 If you don\\u2019t have an account, sign up for free . \\nThe following tools are requ\", \"ired:  \\n\\u2022 Git \\u2014 A fundamental understanding of Git is recommended for this guide. Review the Git \\ndo\", \"cumentation , specifically git remote  and git push . \\n\\u2022 .NET Core SDK  \\u2014 Version 2.1.300 or later i\", \"s required to build and run the sample app. If \\nVisual Studio is installed with the .NET Core cross \", \"-platform development  workload, the \\n.NET Core SDK is already installed.  \\n  Verify your .NET Core \", \"SDK installation. Open a command shell, and run the following \\ncommand:  \\n  :::{custom -style=CodeBo\", \"x} dotnetcli   dotnet --version :::  \\nRecommended tools (Windows only)  \\n\\u2022 Visual Studio \\u2019s robust A\", \"zure tools provide a GUI for most of the functionality described in this \\nguide. Any edition of Visu\", \"al Studio will work, including the free Visual Studio Community \\nEdition. The tutorials are written \", \"to demonstrate development, deployment, and Dev Ops both \\nwith and without Visual Studio.  \\n  Confir\", \"m that Visual Studio has the following workloads  installed:  \\n\\u2013 ASP.NET and web development  \\n\\u2013 Azu\", \"re development   \\n2 CHAPTER 1 | Tools and downloads  \\n \\u2013 .NET Core cross -platform development   \\n3 \", \"CHAPTER 2 | Deploy an app to App Service  \\n CHAPTER  2 \\nDeploy an app to App \\nService  \\nAzure App Se\", \"rvice  is Azure\\u2019s web hosting platform. Deploying a web app to Azure App Service can be \\ndone manual\", \"ly or by an automated process. This section of the guide discusses deployment methods \\nthat can be t\", \"riggered manually or by script using the command line, or trigge red manually using \\nVisual Studio. \", \" \\nIn this section, you\\u2019ll accomplish the following tasks:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 Download an\", \"d build the sample app.  \\n\\u2022 Create an Azure App Service Web App using the Azure Cloud Shell.  \\n\\u2022 Dep\", \"loy the sample app to Azure using Git.  \\n\\u2022 Deploy a change to the app using Visual Studio.  \\n\\u2022 Add a\", \" staging slot to the web app.  \\n\\u2022 Deploy an update to the staging slot.  \\n\\u2022 Swap the staging and pro\", \"duction slots.  \\nDownload and test the app  \\nThe app used in this guide is a pre -built ASP.NET Core\", \" app, Simple Feed Reader . It\\u2019s an ASP.NET Core \\nRazor Pages app that uses the Microsoft.Syndication\", \"Feed.ReaderWriter API to retrieve an RSS/Atom \\nfeed and display the news items in a list.  \\nFeel fre\", \"e to review the code, but it\\u2019s important to understand that there\\u2019s nothing special about this \\napp.\", \" It\\u2019s just a simple ASP.NET Core app for illustrative purposes.  \\nFrom a command shell, download the\", \" code, build the project, and run it as follows.  \\nNote  \\nLinux and macOS users should make appropri\", \"ate changes for paths, for example, using forward slash \\n(/) rather than back slash ( \\\\).* \\n1. Clone\", \" the code to a folder on your local machine.   \\n4 CHAPTER 2 | Deploy an app to App Service  \\n   :::{\", \"custom -style=CodeBox} console  git clone https://github.com/dotnet -architecture/simple -\\nfeed-read\", \"er/ :::  \\n2. Change your working folder to the simple -feed-reader  folder that was created.  \\n  :::\", \"{custom -style=CodeBox} console  cd . \\\\simple -feed-reader \\\\SimpleFeedReader :::  \\n3. Restore the pa\", \"ckages, and build the solution.  \\n  :::{custom -style=CodeBox} dotnetcli  dotnet build :::  \\n4. Run \", \"the app.  \\n  :::{custom -style=CodeBox} dotnetcli  dotnet run :::  \\n          \\n5. Open a browser and\", \" navigate to http://localhost:5000. The app allows you to type or paste a \\nsyndication feed URL and \", \"view a list of news items.  \\n      \\n \\n \\n5 CHAPTER 2 | Deploy an app to App Service  \\n 6. Once you\\u2019re\", \" satisfied the app is working correctly, shut it down by pressing Ctrl+C in the \\ncommand shell.  \\nCr\", \"eate the Azure App Service Web App  \\nTo deploy the app, you\\u2019ll need to create an App Service Web App\", \" . After creation of the Web App, \\nyou\\u2019ll deploy to it from your local machine using Git.  \\n1. Sign \", \"in to the Azure Cloud Shell . Note: When you sign in for the first time, Cloud Shell \\nprompts to cre\", \"ate a storage account for configuration files. Accept the defaults or provide a \\nunique name.  \\n2. U\", \"se the Cloud Shell for the following steps.  \\na. Declare a variable to store your web app\\u2019s name. Th\", \"e name must be unique to be \\nused in the default URL. Using the $RANDOM Bash function to construct t\", \"he name \\nguarantees uniqueness and results in the format webappname99999.  \\n  :::{custom -style=Code\", \"Box} console  webappname=mywebapp$RANDOM :::  \\nb. Create a resource group. Resource groups provide a\", \" means to aggregate Azure \\nresources to be managed as a group.  \\n  :::{custom -style=CodeBox} azurec\", \"li  az group create --location centralus --name AzureTutorial \\n::: \\n  The az command invokes the Azu\", \"re CLI . The CLI can be run locally, but using it in the Cloud \\nShell saves time and configuration. \", \" \\nc. Create an App Service plan in the S1 tier. An App Service plan is a grouping of web \\napps that \", \"share the same pricing tier. The S1 tier isn\\u2019t free, but it\\u2019s required for the \\nstaging slots featur\", \"e.  \\n  :::{custom -style=CodeBox} azurecli  az appservice plan create --name $webappname --\\nresource\", \" -group AzureTutorial --sku S1 :::  \\nd. Create the web app resource using the App Service plan in th\", \"e same resource group.  \\n  :::{custom -style=CodeBox} azurecli  az webapp create --name $webappname \", \"--resource -\\ngroup AzureTutorial --plan $webappname :::  \\ne. Set the deployment branch to main in th\", \"e appsettings configuration.  \\n  :::{custom -style=CodeBox} azurecli  az webapp config appsettings s\", \"et --name $webappname -\\n-resource -group AzureTutorial --settings DEPLOYMENT_BRANCH=main :::  \\nf. Se\", \"t the deployment credentials. These deployment credentials apply to all the web \\napps in your subscr\", \"iption. Don\\u2019t use special characters in the user name.  \\n  :::{custom -style=CodeBox} azurecli  az w\", \"ebapp deployment user set --user-name \\nREPLACE_WITH_USER_NAME --password REPLACE_WITH_PASSWORD :::  \", \" \\n6 CHAPTER 2 | Deploy an app to App Service  \\n g. Configure the web app to accept deployments from \", \"local Git and display the Git \\ndeployment URL . Note this URL for reference later . \\n  :::{custom -s\", \"tyle=CodeBox} azurecli  echo Git deployment URL: $(az webapp deployment \\nsource config -local-git --\", \"name $webappname --resource -group AzureTutorial --query url --\\noutput tsv) :::  \\nh. Display the web\", \" app URL . Browse to this URL to see the blank web app. Note this \\nURL for reference later . \\n  :::{\", \"custom -style=CodeBox} console  echo Web app URL: \\nhttp://$webappname.azurewebsites.net :::  \\n3. Usi\", \"ng a command shell on your local machine, navigate to the web app\\u2019s project folder (for \\nexample, *.\", \" -feed-reader). Execute the following commands to set up Git to push to the \\ndeployment URL:  \\na. Ad\", \"d the remote URL to the local repository.  \\n  :::{custom -style=CodeBox} console  git remote add azu\", \"re -prod GIT_DEPLOYMENT_URL :::  \\nb. Push the local default branch ( main ) to the azure -prod remot\", \"e\\u2019s deployment branch \\n(main ). \\n  :::{custom -style=CodeBox} console  git push azure -prod main :::\", \"  \\n  You\\u2019ll be prompted for the deployment credentials you created earlier. Observe the output in \\nt\", \"he command shell. Azure builds the ASP.NET Core app remotely.  \\n4. In a browser, navigate to the Web\", \" app URL  and note the app has been built and deployed. \\nAdditional changes can be committed to the \", \"local Git repository with git commit. These \\nchanges are pushed to Azure with the preceding git push\", \" command.  \\nDeployment with Visual Studio  \\nNote  \\nThis section applies to Windows only. Linux and m\", \"acOS users should make the change described in \\nstep 2 below. Save the file, and commit the change t\", \"o the local repository with git commit. Finally, \\npush the change with git push, as in the first sec\", \"tion.*  \\nThe app has already been deployed from the command shell. Let\\u2019s use Visual Studio\\u2019s integra\", \"ted tools \\nto deploy an update to the app. Behind the scenes, Visual Studio accomplishes the same th\", \"ing as the \\ncommand line tooling, but within Visual Studio\\u2019s famili ar UI.  \\n1. Open SimpleFeedReade\", \"r.sln  in Visual Studio.  \\n2. In Solution Explorer, open Pages.cshtml . Change <h2>Simple Feed Reade\", \"r</h2> to \\n<h2>Simple Feed Reader - V2</h2>.  \\n3. Press Ctrl+Shift+B to build the app.  \\n4. In Solut\", \"ion Explorer, right -click on the project and click Publish .  \\n7 CHAPTER 2 | Deploy an app to App S\", \"ervice  \\n         \\n    \\n5. Visual Studio can create a new App Service resource, but this update will\", \" be published over \\nthe existing deployment. In the Pick a publish target  dialog, select App Servic\", \"e  from the list \\non the left, and then select Select Existing . Click Publish . \\n6. In the App Serv\", \"ice  dialog, confirm that the Microsoft or Organizational account used to \\ncreate your Azure subscri\", \"ption is displayed in the upper right. If it\\u2019s not, click the drop -down \\nand add it.  \\n7. Confirm t\", \"hat the correct Azure Subscription  is selected. For View , select Resource Group . \\nExpand the Azur\", \"eTutorial  resource group and then select the existing web app. Click OK. \\n             \\nVisual Stud\", \"io builds and deploys the app to Azure. Browse to the web app URL. Validate that the \\n<h2> element m\", \"odification is live.  \\n \\n8 CHAPTER 2 | Deploy an app to App Service  \\n  \\nDeployment slots  \\nDeployme\", \"nt slots support the staging of changes without impacting the app running in production. \\nOnce the s\", \"taged version of the app is validated by a quality assurance team, the production and \\nstaging slots\", \" can be swapped. The app in staging is promoted to production in this manner. The \\nfollowing steps c\", \"reate a staging slot, deploy some changes to it, and swap the staging slot with \\nproduction after ve\", \"rification.  \\n1. Sign in to the Azure Cloud Shell , if not already signed in.  \\n2. Create the stagin\", \"g slot.  \\na. Create a deployment slot with the name staging . \\n  :::{custom -style=CodeBox} azurecli\", \"  az webapp deployment slot create --name $webappname \\n--resource -group AzureTutorial --slot stagin\", \"g :::  \\nb. Set the deployment branch to main in the appsettings configuration.  \\n  :::{custom -style\", \"=CodeBox} azurecli  az webapp config appsettings set --name $webappname -\\n-resource -group AzureTuto\", \"rial --slot staging --settings DEPLOYMENT_BRANCH=main :::  \\nc. Configure the staging slot to use dep\", \"loyment from local Git and get the staging  \\ndeployment URL. Note this URL for reference later . \\n  \", \":::{custom -style=CodeBox} azurecli  echo Git deployment URL for staging: $(az webapp \\ndeployment so\", \"urce config -local-git --name $webappname --resource -group AzureTutorial --\\nslot staging --query ur\", \"l --output tsv) :::  \\nd. Display the staging slot\\u2019s URL. Browse to the URL to see the empty staging \", \"slot. Note \\nthis URL for reference later . \\n \\n9 CHAPTER 2 | Deploy an app to App Service  \\n   :::{cu\", \"stom -style=CodeBox} console  echo Staging web app URL: http://$webappname -\\nstaging.azurewebsites.n\", \"et :::  \\n3. In a text editor or Visual Studio, modify Pages/Index.cshtml  again so that the <h2> ele\", \"ment \\nreads <h2>Simple Feed Reader - V3</h2> and save the file.  \\n4. Commit the file to the local Gi\", \"t repository, using either the Changes  page in Visual Studio\\u2019s \\nTeam Explorer  tab, or by entering \", \"the following using the local machine\\u2019s command shell:  \\n  :::{custom -style=CodeBox} console  git c\", \"ommit -a -m \\\"upgraded to V3\\\" :::  \\n5. Using the local machine\\u2019s command shell, add the staging deplo\", \"yment URL as a Git remote \\nand push the committed changes:  \\na. Add the remote URL for staging to th\", \"e local Git repository.  \\n  :::{custom -style=CodeBox} console  git remote add azure -staging \\n<Git_\", \"staging_deployment_URL> :::  \\nb. Push the local default branch ( main ) to the azure -staging  remot\", \"e\\u2019s deployment \\nbranch ( main ). \\n  :::{custom -style=CodeBox} console  git push azure -staging main\", \" :::  \\n  Wait while Azure builds and deploys the app.  \\n6. To verify that V3 has been deployed to th\", \"e staging slot, open two browser windows. In one \\nwindow, navigate to the original web app URL. In t\", \"he other window, navigate to the staging \\nweb app URL. The production URL serves V2 of the app. The \", \"staging URL serve s V3 of the \\napp. \\n \\n \\n7. In the Cloud Shell, swap the verified/warmed -up staging\", \" slot into production.  \\n \\n10 CHAPTER 2 | Deploy an app to App Service  \\n   :::{custom -style=CodeBo\", \"x} azurecli  az webapp deployment slot swap --name $webappname -\\n-resource -group AzureTutorial --sl\", \"ot staging :::  \\n8. Verify that the swap occurred by refreshing the two browser windows.  \\n \\n       \", \" \\nSummary  \\nIn this section, the following tasks were completed:  \\n\\u2022 Downloaded and built the sample\", \" app.  \\n\\u2022 Created an Azure App Service Web App using the Azure Cloud Shell.  \\n\\u2022 Deployed the sample \", \"app to Azure using Git.  \\n\\u2022 Deployed a change to the app using Visual Studio.  \\n\\u2022 Added a staging sl\", \"ot to the web app.  \\n\\u2022 Deployed an update to the staging slot.  \\n\\u2022 Swapped the staging and productio\", \"n slots.  \\nIn the next section, you\\u2019ll learn how to build a DevOps pipeline with Azure Pipelines.  \\n\", \"Additional reading  \\n\\u2022 Web Apps overview  \\n\\u2022 Build a .NET Core and SQL Database web app in Azure App\", \" Service  \\n\\u2022 Configure deployment credentials for Azure App Service  \\n\\u2022 Set up staging environments \", \"in Azure App Service  \\n \\n11 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n C\", \"HAPTER  3 \\nContinuous integration \\nand deployment with \\nAzure DevOps  \\nNote  \\nThis section details c\", \"ontinuous integration and deployment with Azure DevOps. You can achieve that \\nwith GitHub Actions as\", \" well. GitHub Actions is a workflow engine built into GitHub that can also be \\nused for continuous i\", \"ntegration and deployment. To follow  the guide for building and deploying to \\nAzure using GitHub, c\", \"omplete the Publish the app\\u2019s code to GitHub  and Disconnect local Git \\ndeployment  sections below a\", \"nd then proceed to the GitHub Actions section . \\nIn the previous chapter, you created a local Git re\", \"pository for the Simple Feed Reader app. In this \\nchapter, you\\u2019ll publish that code to a GitHub repo\", \"sitory and construct an Azure DevOps Services \\npipeline using Azure Pipelines. The pipeline enables \", \"continu ous builds and deployments of the app. \\nAny commit to the GitHub repository triggers a build\", \" and a deployment to the Azure Web App\\u2019s \\nstaging slot.  \\nIn this section, you\\u2019ll complete the follo\", \"wing tasks:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 Publish the app\\u2019s code to GitHub  \\n\\u2022 Disconnect local Git\", \" deployment  \\n\\u2022 Create an Azure DevOps organization  \\n\\u2022 Create a team project in Azure DevOps organi\", \"zation  \\n\\u2022 Configure a self -hosted agent if necessary  \\n\\u2022 Create a build definition  \\n\\u2022 Create a re\", \"lease pipeline  \\n\\u2022 Commit changes to GitHub and automatically deploy to Azure  \\n\\u2022 Examine the Azure \", \"Pipelines pipeline   \\n12 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n Publ\", \"ish the app\\u2019s code to GitHub  \\n1. Open a browser window, and navigate to https://github.com.  \\n2. Cl\", \"ick the + drop -down in the header, and select New repository : \\n        \\n       \\n1. Select your acc\", \"ount in the Owner  drop -down, and enter simple -feed-reader  in the Repository \\nname  textbox.  \\n2.\", \" Click the Create repository  button.  \\n3. Open your local machine\\u2019s command shell. Navigate to the \", \"directory in which the simple -feed-\\nreader  Git repository is stored.  \\n4. Rename the existing orig\", \"in  remote to upstream . Execute the following command:  \\n  :::{custom -style=CodeBox} console  git \", \"remote rename origin upstream :::  \\n5. Add a new origin  remote pointing to your copy of the reposit\", \"ory on GitHub. Execute the \\nfollowing command:  \\n  :::{custom -style=CodeBox} console  git remote ad\", \"d origin \\nhttps://github.com/<GitHub_username>/simple -feed-reader/ :::  \\n6. Publish your local Git \", \"repository to the newly created GitHub repository. Execute the following \\ncommand:  \\n  :::{custom -s\", \"tyle=CodeBox} console  git push -u origin main :::  \\n7. Open a browser window, and navigate to https\", \"://github.com/<GitHub_username>/simple -\\nfeed-reader/. Validate that your code appears in the GitHub\", \" repository.  \\nDisconnect local Git deployment  \\nRemove the local Git deployment with the following \", \"steps. Azure Pipelines (an Azure DevOps service) \\nboth replaces and augments that functionality.  \\n1\", \". Open the Azure portal , and navigate to the staging (mywebapp<unique_number>/staging)  \\nWeb App. T\", \"he Web App can be quickly located by entering staging  in the portal\\u2019s search box:  \\n \\n \\n13 CHAPTER \", \"3 | Continuous integration and deployment with Azure DevOps  \\n  \\n \\nClick Deployment Center . A new p\", \"anel appears. Click Disconnect  to remove the local Git \\nsource control configuration that was added\", \" in the previous chapter. Confirm the \\nremoval operation by clicking the Yes button. \\n1. Navigate to\", \" the mywebapp  App Service. As a reminder, the portal\\u2019s search box can be used to \\nquickly locate th\", \"e App Service.  \\n2. Click Deployment Center . A new panel appears. Click Disconnect  to remove the l\", \"ocal Git \\nsource control configuration that was added in the previous chapter. Confirm the removal \\n\", \"operation by clicking the Yes button.  \\nCreate an Azure DevOps organization  \\n1. Open a browser, and\", \" navigate to the Azure DevOps organization creation page . \\n2. Select New organization  \\n3. Confirm \", \"the information, and then select Continue . \\n4. Sign in to your organization at any time, https://de\", \"v.azure.com/{yourorganization}  \\nCreate a team project in Azure DevOps organization  \\n1. Choose the \", \"organization, and then select New project . \\n2. Enter the project name as MyFirstProject  and select\", \" the Visibility  as Private  \\n3. Select Create project . \\nFor more information, see Create a project\", \"  \\nConfigure a self -hosted agent if necessary  \\nTo build your code or deploy your software using Az\", \"ure Pipelines, you need at least one agent. In \\nAzure Pipelines, you can run parallel jobs on either\", \" Microsoft -hosted  or self-hosted  agent. But with \\nthe recent change in Azure Pipelines free grant\", \" of parallel jobs is temporarily disable for the public \\nprojects.For more details, refer Configure \", \"and pay for parallel jobs . \\nGo to Organization Settings  and then Pipelines  > Parallel jobs . If y\", \"ou see value 0 under Microsoft -\\nhosted  that means you need a Self-hosted  agent to run your pipeli\", \"ne.  \\n \\n14 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n  \\nYou can create t\", \"hat by following details mentioned in Self-hosted agents . After successful \\nconfiguration, you\\u2019ll b\", \"e able to see available agent under Organization Settings  > Agent pools  > \\n{youragentname}  \\n \\nCon\", \"figure the Azure Pipelines pipeline  \\nThere are three distinct steps to complete. Completing the ste\", \"ps in the following three sections results \\nin an operational DevOps pipeline.  \\nGrant Azure DevOps \", \"access to the GitHub repository  \\n1. In your project, navigate to the Pipelines  page. Then choose t\", \"he action to create a new \\npipeline:  \\n \\n \\n \\n15 CHAPTER 3 | Continuous integration and deployment wi\", \"th Azure DevOps  \\n 1. Use Use the classic editor to create the pipeline.  \\n              \\n1. Select \", \"the GitHub  option from the Select a source  section::  \\n \\n            \\n1. Authorization is required\", \" before Azure DevOps can access your GitHub repository. Enter  \\nGitHub connection  in the Connection\", \" name  textbox. For example:  \\n        \\n \\n1. If two -factor authentication is enabled on your GitHub\", \" account, a personal access token is \\nrequired. In that case, click the Authorize with a GitHub pers\", \"onal access token  link. See the \\nofficial GitHub personal access token creation instructions  for h\", \"elp. Only the repo scope of \\npermissions is needed. Otherwise, click the Authorize using OAuth  butt\", \"on.  \\n \\n16 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n 2. When prompted, \", \"sign in to your GitHub account. Then select Authorize to grant access to \\nyour Azure DevOps organiza\", \"tion. If successful, a new service endpoint is created.  \\n3. Click the ellipsis button next to the R\", \"epository  button. Select the /simple -feed-reader  \\nrepository from the list. Click the Select  but\", \"ton.  \\n4. Select the default branch ( main ) from the Default branch for manual and scheduled builds\", \"  \\ndrop -down. Click the Continue  button. The template selection page appears.  \\nCreate the build d\", \"efinition  \\n1. From the template selection page, enter ASP.NET Core  in the search box:  \\n \\n \\n1. The\", \" template search results appear. Hover over the ASP.NET Core  template, and click the \\nApply  button\", \".  \\n2. The Tasks  tab of the build definition appears. Select the self -hosted Agent pool  if you ha\", \"ve \\ncreated that in the earlier step.  \\n        \\n \\n> [!NOTE]  \\n> If you are using MS -hosted agent t\", \"hen select the *Hosted > Azure Pipelines* from \\ndrop down.  \\n \\n17 CHAPTER 3 | Continuous integration\", \" and deployment with Azure DevOps  \\n 1. Click the Triggers  tab. \\n2. Check the Enable continuous int\", \"egration  box. Under the Branch filters  section, confirm \\nthat the Type  drop -down is set to Inclu\", \"de . Set the Branch specification  drop -down to main . \\n \\nThese settings cause a build to trigger w\", \"hen any change is pushed to the default \\nbranch (*main*) of the GitHub repository. Continuous integr\", \"ation is tested in the \\n[Commit changes to GitHub and automatically deploy to Azure](#commit -change\", \"s-to-\\ngithub-and-automatical) section.  \\n1. Click the Save & queue  button, and select the Save  opt\", \"ion:  \\n       \\n1. The following modal dialog appears:  \\n \\nUse the default folder of * \\\\\\\\*, and click\", \" the **Save** button.  \\n \\n18 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n \", \"Create the release pipeline  \\n1. Click the Releases  tab of your team project. Click the New pipelin\", \"e  button.  \\n \\nThe template selection pane appears.  \\n1. From the template selection page, enter App\", \" Service Deployment  in the search box:  \\n              \\n \\n1. The template search results appear. Ho\", \"ver over the Azure App Service Deployment with \\nSlot template, and click the Apply  button. The Pipe\", \"line  tab of the release pipeline appears.  \\n \\n19 CHAPTER 3 | Continuous integration and deployment \", \"with Azure DevOps  \\n  \\n \\n1. Click the Add button in the Artifacts  box. The Add artifact  panel appe\", \"ars:  \\n  \\n \\n1. Select the Build  tile from the Source type  section. This type allows for the linkin\", \"g of the \\nrelease pipeline to the build definition.  \\n2. Select MyFirstProject  from the Project  dr\", \"op -down.  \\n3. Select the build definition name, MyFirstProject -ASP.NET Core -CI, from the Source (\", \"Build \\ndefinition)  drop -down.  \\n4. Select Latest  from the Default version  drop -down. This optio\", \"n builds the artifacts produced \\nby the latest run of the build definition.  \\n \\n20 CHAPTER 3 | Conti\", \"nuous integration and deployment with Azure DevOps  \\n 5. Replace the text in the Source alias  textb\", \"ox with Drop . \\n6. Click the Add button. The Artifacts  section updates to display the changes.  \\n7.\", \" Click the lightning bolt icon to enable continuous deployments:  \\n       \\n \\nWith this option enable\", \"d, a deployment occurs each time a new build is available.  \\n1. A Continuous deployment trigger  pan\", \"el appears to the right. Click the toggle button to \\nenable the feature. It isn\\u2019t necessary to enabl\", \"e the Pull request trigger . \\n2. Click the Add drop -down in the Build branch filters  section. Choo\", \"se the Build Definition\\u2019s \\ndefault branch  option. This filter causes the release to trigger only fo\", \"r a build from the \\nGitHub repository\\u2019s default branch ( main ). \\n3. Click the Save  button. Click t\", \"he OK button in the resulting Save  modal dialog.  \\n4. Click the Stage 1  box. An Stage  panel appea\", \"rs to the right. Change the Stage 1  text in the \\nStage name  textbox to Production . \\n \\n1. Click th\", \"e 1 phase, 2 tasks  link in the Production  box: \\n \\n21 CHAPTER 3 | Continuous integration and deploy\", \"ment with Azure DevOps  \\n  \\nThe **Tasks** tab of the environment appears.  \\n1. Click the Deploy Azur\", \"e App Service to Slot  task. Its settings appear in a panel to the right.  \\n2. Select the Azure subs\", \"cription associated with the App Service from the Azure subscription  \\ndrop -down. Once selected, cl\", \"ick the Authorize  button.  \\n3. Select Web App  from the App type  drop -down.  \\n4. Select mywebapp/\", \"  from the App service name  drop -down.  \\n5. Select AzureTutorial  from the Resource group  drop -d\", \"own.  \\n6. Select staging  from the Slot drop -down.  \\n7. Select Run on agent * under Tasks . On the \", \"right pane, you\\u2019ll see Agent Job . \\n8. Select the self -hosted Agent pool  if you have created that \", \"in the earlier step.  \\n \\n \\n> [!NOTE]  \\n> If you are using MS -hosted agent then select the *Hosted >\", \" Azure Pipelines* from \\ndrop down.  \\n1. Click the Save  button.  \\n2. Hover over the default release \", \"pipeline name. Click the pencil icon to edit it. Use \\nMyFirstProject -ASP.NET Core -CD as the name. \", \" \\n \\n22 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n         \\n \\n1. Click th\", \"e Save  button.  \\nCommit changes to GitHub and automatically \\ndeploy to Azure  \\n1. Open SimpleFeedRe\", \"ader.sln  in Visual Studio.  \\n2. In Solution Explorer, open Pages.cshtml . Change <h2>Simple Feed Re\", \"ader - V3</h2> to \\n<h2>Simple Feed Reader - V4</h2>.  \\n3. Press Ctrl+Shift+B to build the app.  \\n4. \", \"Commit the file to the GitHub repository. Use either the Changes  page in Visual Studio\\u2019s \\nTeam Expl\", \"orer  tab, or execute the following using the local machine\\u2019s command shell:  \\n  :::{custom -style=C\", \"odeBox} console  git commit -a -m \\\"upgraded to V4\\\" :::  \\n5. Push the change in the default branch ( \", \"main ) to the origin  remote of your GitHub repository. \\nIn the following command, replace the place\", \"holder {BRANCH} with the default branch (use \\nmain):  \\n  :::{custom -style=CodeBox} console  git pus\", \"h origin {BRANCH} :::  \\n  The commit appears in the GitHub repository\\u2019s default branch ( main ). You\", \"\\u2019ll be able to see the \\ncommit history in https://github.com/<GitHub_username>/simple -feed-\\nreader/\", \"commits/main.  \\n  The build is triggered, since continuous integration is enabled in the build defin\", \"ition\\u2019s \\nTriggers  tab: \\n   \\n \\n \\n23 CHAPTER 3 | Continuous integration and deployment with Azure Dev\", \"Ops  \\n 1. Navigate to the Pipelines . You\\u2019ll see the CI pipeline details and monitor each steps if y\", \"ou drill \\ndown Jobs  details.  \\n \\n1. Similarly, go to the Releases  tab to see the details of CD pip\", \"eline. You can always drill down \\nfurther to see more details of each step.  \\n \\n1. Once the build su\", \"cceeds, a deployment to Azure occurs. Navigate to the app in the browser. \\nNotice that the \\u201cV4\\u201d text\", \" appears in the heading:  \\n \\nExamine the Azure Pipelines pipeline  \\nBuild definition  \\nA build defin\", \"ition was created with the name MyFirstProject -ASP.NET Core -CI. Upon completion, the \\nbuild produc\", \"es a .zip file including the assets to be published. The release pipeline deploys those \\nassets to A\", \"zure.  \\nThe build definition\\u2019s Tasks  tab lists the individual steps being used. There are five buil\", \"d tasks.  \\n \\n24 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n  \\n1. Restore \", \" \\u2014 Executes the dotnet restore command to restore the app\\u2019s NuGet packages. The \\ndefault package fee\", \"d used is nuget.org.  \\n2. Build  \\u2014 Executes the dotnet build --configuration release command to comp\", \"ile the app\\u2019s \\ncode. This --configuration option is used to produce an optimized version of the code\", \", which \\nis suitable for deployment to a production environment. Modify the BuildConfiguration  \\nvar\", \"iable on the build definition\\u2019s Variables  tab if, for example, a debug configuration is \\nneeded.  \\n\", \"3. Test \\u2014 Executes the dotnet test --configuration release --logger trx --results -directory \\n<local\", \"_path_on_build_agent> command to run the app\\u2019s unit tests. Unit tests are executed \\nwithin any C# pr\", \"oject matching the ** /Tests/ .csproj  glob pattern. Test results are saved in a .trx \\nfile at the l\", \"ocation specified by the --results -directory option. If any tests fail, the build fails \\nand isn\\u2019t \", \"deployed.  \\n \\n25 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n   [!NOTE] To\", \" verify the unit tests work, modify SimpleFeedReader.Tests.cs  to purposefully break \\none of the tes\", \"ts. For example, change Assert.True(result.Count > 0); to \\nAssert.False(result.Count > 0); in the Re\", \"turns_News_Stories_Given_Valid_Uri method. Commit \\nand push the change to GitHub. The build is trigg\", \"ered and fails. The b uild pipeline status \\nchanges to failed . Revert the change, commit, and push \", \"again. The build succeeds.  \\n4. Publish  \\u2014 Executes the dotnet publish --configuration release --out\", \"put \\n<local_path_on_build_agent> command to produce a .zip file with the artifacts to be \\ndeployed. \", \"The --output option specifies the publish location of the .zip file. That location is \\nspecified by \", \"passing a predefined variable  named $(build.artifactstagingdirectory). That \\nvariable expands to a \", \"local path, such as *c:_work \\\\1, on the build agent.  \\n5. Publish Artifact  \\u2014 Publishes the .zip fil\", \"e produced by the Publish  task. The task accepts the \\n.zip file location as a parameter, which is t\", \"he predefined variable \\n$(build.artifactstagingdirectory). The .zip file is published as a folder na\", \"med drop. \\nClick the build definition\\u2019s Summary  link to view a history of builds with the definitio\", \"n:  \\n \\nOn the resulting page, click the individual build for more details.  \\n \\nA summary of this spe\", \"cific build is displayed. Click the published  link, and notice the drop folder \\nproduced by the bui\", \"ld is listed:  \\n \\n26 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n  \\n \\nUse \", \"the ellipsis and click on Downloads artifacts  links to inspect the published artifacts.  \\nRelease p\", \"ipeline  \\nA release pipeline was created with the name MyFirstProject -ASP.NET Core -CD: \\n \\nThe two \", \"major components of the release pipeline are the Artifacts  and the Stages . Clicking the box \\nin th\", \"e Artifacts  section reveals the following panel:  \\n \\n27 CHAPTER 3 | Continuous integration and depl\", \"oyment with Azure DevOps  \\n  \\nThe Source (Build definition)  value represents the build definition t\", \"o which this release pipeline is \\nlinked. The .zip file produced by a successful run of the build de\", \"finition is provided to the Production  \\nenvironment for deployment to Azure. Click the 1 phase, 2 t\", \"asks  link in the Production  environment \\nbox to view the release pipeline tasks:  \\n \\nThe release p\", \"ipeline consists of two tasks: Deploy Azure App Service to Slot  and Manage Azure App \\nService - Slo\", \"t Swap . Clicking the first task reveals the following task configuration:  \\n \\n28 CHAPTER 3 | Contin\", \"uous integration and deployment with Azure DevOps  \\n  \\nThe Azure subscription, service type, web app\", \" name, resource group, and deployment slot are defined \\nin the deployment task. The Package or folde\", \"r  textbox holds the .zip file path to be extracted and \\ndeployed to the staging  slot of the myweba\", \"pp<unique_number>  web app.  \\nClicking the slot swap task reveals the following task configuration: \", \" \\n \\n29 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n  \\nThe subscription, re\", \"source group, service type, web app name, and deployment slot details are \\nprovided. The Swap with P\", \"roduction  check box is checked. Consequently, the bits deployed to the \\nstaging  slot are swapped i\", \"nto the production environment.  \\nAdditional reading  \\n\\u2022 Create your first pipeline with Azure Pipel\", \"ines  \\n\\u2022 Build and .NET Core project  \\n\\u2022 Deploy a web app with Azure Pipelines  \\n \\n30 CHAPTER 3 | Co\", \"ntinuous integration and deployment with Azure DevOps  \\n Continuous integration and deployment with \", \"Azure \\nDevOps  \\nNote  \\nThis section details continuous integration and deployment with Azure DevOps.\", \" You can achieve that \\nwith GitHub Actions as well. GitHub Actions is a workflow engine built into G\", \"itHub that can also be \\nused for continuous integration and deployment. To follow  the guide for bui\", \"lding and deploying to \\nAzure using GitHub, complete the Publish the app\\u2019s code to GitHub  and Disco\", \"nnect local Git \\ndeployment  sections below and then proceed to the GitHub Actions section . \\nIn the\", \" previous chapter, you created a local Git repository for the Simple Feed Reader app. In this \\nchapt\", \"er, you\\u2019ll publish that code to a GitHub repository and construct an Azure DevOps Services \\npipeline\", \" using Azure Pipelines. The pipeline enables continu ous builds and deployments of the app. \\nAny com\", \"mit to the GitHub repository triggers a build and a deployment to the Azure Web App\\u2019s \\nstaging slot.\", \"  \\nIn this section, you\\u2019ll complete the following tasks:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 Publish the \", \"app\\u2019s code to GitHub  \\n\\u2022 Disconnect local Git deployment  \\n\\u2022 Create an Azure DevOps organization  \\n\\u2022\", \" Create a team project in Azure DevOps organization  \\n\\u2022 Configure a self -hosted agent if necessary \", \" \\n\\u2022 Create a build definition  \\n\\u2022 Create a release pipeline  \\n\\u2022 Commit changes to GitHub and automat\", \"ically deploy to Azure  \\n\\u2022 Examine the Azure Pipelines pipeline  \\nPublish the app\\u2019s code to GitHub  \", \"\\n1. Open a browser window, and navigate to https://github.com.  \\n2. Click the + drop -down in the he\", \"ader, and select New repository : \\n \\n \\n31 CHAPTER 3 | Continuous integration and deployment with Azu\", \"re DevOps  \\n 1. Select your account in the Owner  drop -down, and enter simple -feed-reader  in the \", \"Repository \\nname  textbox.  \\n2. Click the Create repository  button.  \\n3. Open your local machine\\u2019s \", \"command shell. Navigate to the directory in which the simple -feed-\\nreader  Git repository is stored\", \".  \\n4. Rename the existing origin  remote to upstream . Execute the following command:  \\n  :::{custo\", \"m -style=CodeBox} console  git remote rename origin upstream :::  \\n5. Add a new origin  remote point\", \"ing to your copy of the repository on GitHub. Execute the \\nfollowing command:  \\n  :::{custom -style=\", \"CodeBox} console  git remote add origin \\nhttps://github.com/<GitHub_username>/simple -feed-reader/ :\", \"::  \\n6. Publish your local Git repository to the newly created GitHub repository. Execute the follow\", \"ing \\ncommand:  \\n  :::{custom -style=CodeBox} console  git push -u origin main :::  \\n7. Open a browse\", \"r window, and navigate to https://github.com/<GitHub_username>/simple -\\nfeed-reader/. Validate that \", \"your code appears in the GitHub repository.  \\nDisconnect local Git deployment  \\nRemove the local Git\", \" deployment with the following steps. Azure Pipelines (an Azure DevOps service) \\nboth replaces and a\", \"ugments that functionality.  \\n1. Open the Azure portal , and navigate to the staging (mywebapp<uniqu\", \"e_number>/staging)  \\nWeb App. The Web App can be quickly located by entering staging  in the portal\\u2019\", \"s search box:  \\n \\n \\n1. Click Deployment Center . A new panel appears. Click Disconnect  to remove th\", \"e local Git \\nsource control configuration that was added in the previous chapter. Confirm the remova\", \"l \\noperation by clicking the Yes button.  \\n2. Navigate to the mywebapp  App Service. As a reminder, \", \"the portal\\u2019s search box can be used to \\nquickly locate the App Service.  \\n3. Click Deployment Center\", \" . A new panel appears. Click Disconnect  to remove the local Git \\nsource control configuration that\", \" was added in the previous chapter. Confirm the removal \\noperation by clicking the Yes button.  \\nCre\", \"ate an Azure DevOps organization  \\n1. Open a browser, and navigate to the Azure DevOps organization \", \"creation page . \\n2. Select New organization  \\n3. Confirm the information, and then select Continue .\", \" \\n \\n32 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n 4. Sign in to your org\", \"anization at any time, https://dev.azure.com/{yourorganization}  \\nCreate a team project in Azure Dev\", \"Ops organization  \\n1. Choose the organization, and then select New project . \\n2. Enter the project n\", \"ame as MyFirstProject  and select the Visibility  as Private  \\n3. Select Create project . \\nFor more \", \"information, see Create a project  \\nConfigure a self -hosted agent if necessary  \\nTo build your code\", \" or deploy your software using Azure Pipelines, you need at least one agent. In \\nAzure Pipelines, yo\", \"u can run parallel jobs on either Microsoft -hosted  or self-hosted  agent. But with \\nthe recent cha\", \"nge in Azure Pipelines free grant of parallel jobs is temporarily disable for the public \\nprojects.F\", \"or more details, refer Configure and pay for parallel jobs . \\nGo to Organization Settings  and then \", \"Pipelines  > Parallel jobs . If you see value 0 under Microsoft -\\nhosted  that means you need a Self\", \"-hosted  agent to run your pipeline.  \\n \\nYou can create that by following details mentioned in Self-\", \"hosted agents . After successful \\nconfiguration, you\\u2019ll be able to see available agent under Organiz\", \"ation Settings  > Agent pools  > \\n{youragentname}  \\n \\nConfigure the Azure Pipelines pipeline  \\nThere\", \" are three distinct steps to complete. Completing the steps in the following three sections results \", \"\\nin an operational DevOps pipeline.  \\n \\n33 CHAPTER 3 | Continuous integration and deployment with Az\", \"ure DevOps  \\n Grant Azure DevOps access to the GitHub repository  \\n1. In your project, navigate to t\", \"he Pipelines  page. Then choose the action to create a new \\npipeline:  \\n \\n1. Use Use the classic edi\", \"tor to create the pipeline.  \\n \\n \\n1. Select the GitHub  option from the Select a source  section::  \", \"\\n \\n \\n1. Authorization is required before Azure DevOps can access your GitHub repository. Enter  \\nGit\", \"Hub connection  in the Connection name  textbox. For example:  \\n \\n34 CHAPTER 3 | Continuous integrat\", \"ion and deployment with Azure DevOps  \\n  \\n \\n1. If two -factor authentication is enabled on your GitH\", \"ub account, a personal access token is \\nrequired. In that case, click the Authorize with a GitHub pe\", \"rsonal access token  link. See the \\nofficial GitHub personal access token creation instructions  for\", \" help. Only the repo scope of \\npermissions is needed. Otherwise, click the Authorize using OAuth  bu\", \"tton.  \\n2. When prompted, sign in to your GitHub account. Then select Authorize to grant access to \\n\", \"your Azure DevOps organization. If successful, a new service endpoint is created.  \\n3. Click the ell\", \"ipsis button next to the Repository  button. Select the /simple -feed-reader  \\nrepository from the l\", \"ist. Click the Select  button.  \\n4. Select the default branch ( main ) from the Default branch for m\", \"anual and scheduled builds  \\ndrop -down. Click the Continue  button. The template selection page app\", \"ears.  \\nCreate the build definition  \\n1. From the template selection page, enter ASP.NET Core  in th\", \"e search box:  \\n \\nThe template search results appear. Hover over the ASP.NET Core  template, and cli\", \"ck \\nthe Apply button. \\n1. The Tasks  tab of the build definition appears. Select the self -hosted Ag\", \"ent pool  if you have \\ncreated that in the earlier step.  \\n \\n35 CHAPTER 3 | Continuous integration a\", \"nd deployment with Azure DevOps  \\n  \\n \\n> [!NOTE]  \\n> If you are using MS -hosted agent then select t\", \"he *Hosted > Azure Pipelines* from \\ndrop down.  \\n1. Click the Triggers  tab. \\n2. Check the Enable co\", \"ntinuous integration  box. Under the Branch filters  section, confirm \\nthat the Type  drop -down is \", \"set to Include . Set the Branch specification  drop -down to main . \\n \\nThese settings cause a build \", \"to trigger when any change is pushed to the default \\nbranch (*main*) of the GitHub repository. Conti\", \"nuous integration is tested in the \\n[Commit changes to GitHub and automatically deploy to Azure](#co\", \"mmit -changes-to-\\ngithub-and-automatical) section.  \\n1. Click the Save & queue  button, and select t\", \"he Save  option:  \\n \\n36 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n  \\n \\n1\", \". The following modal dialog appears:  \\n \\nUse the default folder of * \\\\\\\\*, and click the **Save** bu\", \"tton.  \\nCreate the release pipeline  \\n1. Click the Releases  tab of your team project. Click the New\", \" pipeline  button.  \\n \\n \\n37 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n T\", \"he template selection pane appears.  \\n1. From the template selection page, enter App Service Deploym\", \"ent  in the search box:  \\n \\n \\n1. The template search results appear. Hover over the Azure App Servic\", \"e Deployment with \\nSlot template, and click the Apply  button. The Pipeline  tab of the release pipe\", \"line appears.  \\n \\n1. Click the Add button in the Artifacts  box. The Add artifact  panel appears:  \\n\", \" \\n \\n38 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n 1. Select the Build  t\", \"ile from the Source type  section. This type allows for the linking of the \\nrelease pipeline to the \", \"build definition.  \\n2. Select MyFirstProject  from the Project  drop -down.  \\n3. Select the build de\", \"finition name, MyFirstProject -ASP.NET Core -CI, from the Source (Build \\ndefinition)  drop -down.  \\n\", \"4. Select Latest  from the Default version  drop -down. This option builds the artifacts produced \\nb\", \"y the latest run of the build definition.  \\n5. Replace the text in the Source alias  textbox with Dr\", \"op . \\n6. Click the Add button. The Artifacts  section updates to display the changes.  \\n7. Click the\", \" lightning bolt icon to enable continuous deployments:  \\n \\nWith this option enabled, a deployment oc\", \"curs each time a new build is available.  \\n1. A Continuous deployment trigger  panel appears to the \", \"right. Click the toggle button to \\nenable the feature. It isn\\u2019t necessary to enable the Pull request\", \" trigger . \\n2. Click the Add drop -down in the Build branch filters  section. Choose the Build Defin\", \"ition\\u2019s \\ndefault branch  option. This filter causes the release to trigger only for a build from the\", \" \\nGitHub repository\\u2019s default branch ( main ). \\n3. Click the Save  button. Click the OK button in th\", \"e resulting Save  modal dialog.  \\n4. Click the Stage 1  box. An Stage  panel appears to the right. C\", \"hange the Stage 1  text in the \\nStage name  textbox to Production . \\n \\n39 CHAPTER 3 | Continuous int\", \"egration and deployment with Azure DevOps  \\n  \\n1. Click the 1 phase, 2 tasks  link in the Production\", \"  box: \\n \\n \\nThe **Tasks** tab of the environment appears.  \\n1. Click the Deploy Azure App Service to\", \" Slot  task. Its settings appear in a panel to the right.  \\n2. Select the Azure subscription associa\", \"ted with the App Service from the Azure subscription  \\ndrop -down. Once selected, click the Authoriz\", \"e  button.  \\n3. Select Web App  from the App type  drop -down.  \\n4. Select mywebapp/  from the App s\", \"ervice name  drop -down.  \\n5. Select AzureTutorial  from the Resource group  drop -down.  \\n6. Select\", \" staging  from the Slot drop -down.  \\n7. Select Run on agent * under Tasks . On the right pane, you\\u2019\", \"ll see Agent Job . \\n8. Select the self -hosted Agent pool  if you have created that in the earlier s\", \"tep.  \\n \\n \\n40 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n > [!NOTE]  \\n> I\", \"f you are using MS -hosted agent then select the *Hosted > Azure Pipelines* from \\ndrop down.  \\n1. Cl\", \"ick the Save  button.  \\n2. Hover over the default release pipeline name. Click the pencil icon to ed\", \"it it. Use \\nMyFirstProject -ASP.NET Core -CD as the name.  \\n \\n1. Click the Save  button.  \\nCommit ch\", \"anges to GitHub and automatically deploy to Azure  \\n1. Open SimpleFeedReader.sln  in Visual Studio. \", \" \\n2. In Solution Explorer, open Pages.cshtml . Change <h2>Simple Feed Reader - V3</h2> to \\n<h2>Simpl\", \"e Feed Reader - V4</h2>.  \\n3. Press Ctrl+Shift+B to build the app.  \\n4. Commit the file to the GitHu\", \"b repository. Use either the Changes  page in Visual Studio\\u2019s \\nTeam Explorer  tab, or execute the fo\", \"llowing using the local machine\\u2019s command shell:  \\n  :::{custom -style=CodeBox} console  git commit \", \"-a -m \\\"upgraded to V4\\\" :::  \\n5. Push the change in the default branch ( main ) to the origin  remote\", \" of your GitHub repository. \\nIn the following command, replace the placeholder {BRANCH} with the def\", \"ault branch (use \\nmain):  \\n  :::{custom -style=CodeBox} console  git push origin {BRANCH} :::  \\n  Th\", \"e commit appears in the GitHub repository\\u2019s default branch ( main ). You\\u2019ll be able to see the \\ncomm\", \"it history in https://github.com/<GitHub_username>/simple -feed-\\nreader/commits/main.  \\n  The build \", \"is triggered, since continuous integration is enabled in the build definition\\u2019s \\nTriggers  tab: \\n   \", \"\\n \\n41 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n 1. Navigate to the Pipe\", \"lines . You\\u2019ll see the CI pipeline details and monitor each steps if you drill \\ndown Jobs  details. \", \" \\n \\n1. Similarly, go to the Releases  tab to see the details of CD pipeline. You can always drill do\", \"wn \\nfurther to see more details of each step.  \\n \\n1. Once the build succeeds, a deployment to Azure \", \"occurs. Navigate to the app in the browser. \\nNotice that the \\u201cV4\\u201d text appears in the heading:  \\n \\nE\", \"xamine the Azure Pipelines pipeline  \\nBuild definition  \\nA build definition was created with the nam\", \"e MyFirstProject -ASP.NET Core -CI. Upon completion, the \\nbuild produces a .zip file including the a\", \"ssets to be published. The release pipeline deploys those \\nassets to Azure.  \\nThe build definition\\u2019s\", \" Tasks  tab lists the individual steps being used. There are five build tasks.  \\n \\n42 CHAPTER 3 | Co\", \"ntinuous integration and deployment with Azure DevOps  \\n  \\n1. Restore  \\u2014 Executes the dotnet restore\", \" command to restore the app\\u2019s NuGet packages. The \\ndefault package feed used is nuget.org.  \\n2. Buil\", \"d  \\u2014 Executes the dotnet build --configuration release command to compile the app\\u2019s \\ncode. This --co\", \"nfiguration option is used to produce an optimized version of the code, which \\nis suitable for deplo\", \"yment to a production environment. Modify the BuildConfiguration  \\nvariable on the build definition\\u2019\", \"s Variables  tab if, for example, a debug configuration is \\nneeded.  \\n3. Test \\u2014 Executes the dotnet \", \"test --configuration release --logger trx --results -directory \\n<local_path_on_build_agent> command \", \"to run the app\\u2019s unit tests. Unit tests are executed \\nwithin any C# project matching the ** /Tests/ \", \".csproj  glob pattern. Test results are saved in a .trx \\nfile at the location specified by the --res\", \"ults -directory option. If any tests fail, the build fails \\nand isn\\u2019t deployed.  \\n \\n43 CHAPTER 3 | C\", \"ontinuous integration and deployment with Azure DevOps  \\n   [!NOTE] To verify the unit tests work, m\", \"odify SimpleFeedReader.Tests.cs  to purposefully break \\none of the tests. For example, change Assert\", \".True(result.Count > 0); to \\nAssert.False(result.Count > 0); in the Returns_News_Stories_Given_Valid\", \"_Uri method. Commit \\nand push the change to GitHub. The build is triggered and fails. The b uild pip\", \"eline status \\nchanges to failed . Revert the change, commit, and push again. The build succeeds.  \\n4\", \". Publish  \\u2014 Executes the dotnet publish --configuration release --output \\n<local_path_on_build_agen\", \"t> command to produce a .zip file with the artifacts to be \\ndeployed. The --output option specifies \", \"the publish location of the .zip file. That location is \\nspecified by passing a predefined variable \", \" named $(build.artifactstagingdirectory). That \\nvariable expands to a local path, such as *c:_work \\\\\", \"1, on the build agent.  \\n5. Publish Artifact  \\u2014 Publishes the .zip file produced by the Publish  tas\", \"k. The task accepts the \\n.zip file location as a parameter, which is the predefined variable \\n$(buil\", \"d.artifactstagingdirectory). The .zip file is published as a folder named drop. \\nClick the build def\", \"inition\\u2019s Summary  link to view a history of builds with the definition:  \\n \\nOn the resulting page, \", \"click the individual build for more details.  \\n \\nA summary of this specific build is displayed. Clic\", \"k the published  link, and notice the drop folder \\nproduced by the build is listed:  \\n \\n44 CHAPTER 3\", \" | Continuous integration and deployment with Azure DevOps  \\n  \\n \\nUse the ellipsis and click on Down\", \"loads artifacts  links to inspect the published artifacts.  \\nRelease pipeline  \\nA release pipeline w\", \"as created with the name MyFirstProject -ASP.NET Core -CD: \\n \\nThe two major components of the releas\", \"e pipeline are the Artifacts  and the Stages . Clicking the box \\nin the Artifacts  section reveals t\", \"he following panel:  \\n \\n45 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n  \\n\", \"The Source (Build definition)  value represents the build definition to which this release pipeline \", \"is \\nlinked. The .zip file produced by a successful run of the build definition is provided to the Pr\", \"oduction  \\nenvironment for deployment to Azure. Click the 1 phase, 2 tasks  link in the Production  \", \"environment \\nbox to view the release pipeline tasks:  \\n \\nThe release pipeline consists of two tasks:\", \" Deploy Azure App Service to Slot  and Manage Azure App \\nService - Slot Swap . Clicking the first ta\", \"sk reveals the following task configuration:  \\n \\n46 CHAPTER 3 | Continuous integration and deploymen\", \"t with Azure DevOps  \\n  \\nThe Azure subscription, service type, web app name, resource group, and dep\", \"loyment slot are defined \\nin the deployment task. The Package or folder  textbox holds the .zip file\", \" path to be extracted and \\ndeployed to the staging  slot of the mywebapp<unique_number>  web app.  \\n\", \"Clicking the slot swap task reveals the following task configuration:  \\n \\n47 CHAPTER 3 | Continuous \", \"integration and deployment with Azure DevOps  \\n  \\nThe subscription, resource group, service type, we\", \"b app name, and deployment slot details are \\nprovided. The Swap with Production  check box is checke\", \"d. Consequently, the bits deployed to the \\nstaging  slot are swapped into the production environment\", \".  \\nAdditional reading  \\n\\u2022 Create your first pipeline with Azure Pipelines  \\n\\u2022 Build and .NET Core p\", \"roject  \\n\\u2022 Deploy a web app with Azure Pipelines  \\n \\n48 CHAPTER 3 | Continuous integration and deplo\", \"yment with Azure DevOps  \\n Continuous integration and deployment with \\nGitHub Actions  \\nGitHub has l\", \"ong been the home for millions of open -source developers around the globe. Most \\ndevelopers associa\", \"te source control with GitHub. However, GitHub is an evolving platform that can be \\nused for more th\", \"an just synchronizing Git repositories.  \\nGitHub Actions  \\nGitHub Actions is a workflow engine that \", \"can automate workflows for nearly all events that occur on \\nGitHub. Actions is a great solution for \", \"Continuous Integration/Continuous Deployment (CI/CD) \\npipelines.  \\nIn this section of articles, you\\u2019\", \"ll learn how to create an Actions workflow. The workflow will build, test, \\nand deploy a .NET web ap\", \"p to Azure Web Apps.  \\nNote  \\nBefore you begin, complete the Publish the app\\u2019s code to GitHub  and D\", \"isconnect local Git \\ndeployment  sections of the Continuous integration and deployment with Azure De\", \"vOps  section to \\npublish your code to GitHub. Then proceed to the Build  article.  \\nIn the Build  a\", \"rticle, you\\u2019ll create the initial workflow to build and test the .NET app. You\\u2019ll:  \\n[!div class=\\u201cch\", \"ecklist\\u201d]  \\n\\u2022 Learn the basic structure of a GitHub Action workflow YAML file.  \\n\\u2022 Use a template to\", \" create a basic build workflow that builds a .NET app and executes unit tests.  \\n\\u2022 Publish the compi\", \"led app so that it\\u2019s ready for deployment.  \\nIn the Deploy  article, you\\u2019ll:  \\n[!div class=\\u201cchecklis\", \"t\\u201d]  \\n\\u2022 Learn about environments in GitHub Actions.  \\n\\u2022 Create two environments and specify environm\", \"ent protection rules.  \\n\\u2022 Create environment secrets for managing environment -specific configuratio\", \"n.  \\n\\u2022 Extend the workflow YAML file to add deployment steps.  \\n\\u2022 Add a manual dispatch trigger.  \\nS\", \"ecure code with CodeQL  \\nIn addition to building and deploying code, GitHub Advanced Security  offer\", \"s tools for \\u201cshifting left\\u201d \\nwith security. That is, integrating security early on in the software d\", \"elivery lifecycle. CodeQL  is a code \\nscanning language that runs queries to find potential vulnerab\", \"ilities or quality issues in your code. \\nCodeQL is run using an Actions workflow.  \\nIn the CodeQL  a\", \"rticle, you\\u2019ll:   \\n49 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n [!div c\", \"lass=\\u201cchecklist\\u201d]  \\n\\u2022 Create a Code Scanning Action.  \\n\\u2022 Edit the workflow file to include custom sc\", \"an settings.  \\n\\u2022 See scanning results.  \\nCompare and contrast GitHub Actions and Azure Pipelines  \\nG\", \"itHub Actions and Azure Pipelines have a common lineage and are similar in many respects. \\nHowever, \", \"you should understand the differences before selecting a platform for building, testing, and \\ndeploy\", \"ing apps. In the Comparison  article, you\\u2019ll deep dive into these platforms and compare and \\ncontras\", \"t them. You\\u2019ll also learn how to select the correct platform for your CI/CD needs.  \\nContinuous inte\", \"gration and deployment with \\nGitHub Actions  \\nGitHub has long been the home for millions of open -so\", \"urce developers around the globe. Most \\ndevelopers associate source control with GitHub. However, Gi\", \"tHub is an evolving platform that can be \\nused for more than just synchronizing Git repositories.  \\n\", \"GitHub Actions  \\nGitHub Actions is a workflow engine that can automate workflows for nearly all even\", \"ts that occur on \\nGitHub. Actions is a great solution for Continuous Integration/Continuous Deployme\", \"nt (CI/CD) \\npipelines.  \\nIn this section of articles, you\\u2019ll learn how to create an Actions workflow\", \". The workflow will build, test, \\nand deploy a .NET web app to Azure Web Apps.  \\nNote  \\nBefore you b\", \"egin, complete the Publish the app\\u2019s code to GitHub  and Disconnect local Git \\ndeployment  sections \", \"of the Continuous integration and deployment with Azure DevOps  section to \\npublish your code to Git\", \"Hub. Then proceed to the Build  article.  \\nIn the Build  article, you\\u2019ll create the initial workflow\", \" to build and test the .NET app. You\\u2019ll:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 Learn the basic structure of\", \" a GitHub Action workflow YAML file.  \\n\\u2022 Use a template to create a basic build workflow that builds\", \" a .NET app and executes unit tests.  \\n\\u2022 Publish the compiled app so that it\\u2019s ready for deployment.\", \"  \\nIn the Deploy  article, you\\u2019ll:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 Learn about environments in GitHub\", \" Actions.   \\n50 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n \\u2022 Create two \", \"environments and specify environment protection rules.  \\n\\u2022 Create environment secrets for managing e\", \"nvironment -specific configuration.  \\n\\u2022 Extend the workflow YAML file to add deployment steps.  \\n\\u2022 A\", \"dd a manual dispatch trigger.  \\nSecure code with CodeQL  \\nIn addition to building and deploying code\", \", GitHub Advanced Security  offers tools for \\u201cshifting left\\u201d \\nwith security. That is, integrating se\", \"curity early on in the software delivery lifecycle. CodeQL  is a code \\nscanning language that runs q\", \"ueries to find potential vulnerabilities or quality issues in your code. \\nCodeQL is run using an Act\", \"ions workflow.  \\nIn the CodeQL  article, you\\u2019ll:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 Create a Code Scanni\", \"ng Action.  \\n\\u2022 Edit the workflow file to include custom scan settings.  \\n\\u2022 See scanning results.  \\nC\", \"ompare and contrast GitHub Actions and Azure Pipelines  \\nGitHub Actions and Azure Pipelines have a c\", \"ommon lineage and are similar in many respects. \\nHowever, you should understand the differences befo\", \"re selecting a platform for building, testing, and \\ndeploying apps. In the Comparison  article, you\\u2019\", \"ll deep dive into these platforms and compare and \\ncontrast them. You\\u2019ll also learn how to select th\", \"e correct platform for your CI/CD needs.  \\nCompare and contrast GitHub Actions and Azure \\nPipelines \", \" \\nGitHub Actions  and Azure Pipelines  have a common history. In fact, the Actions agent is a fork o\", \"f the \\nPipelines agent. There are many similarities between GitHub Actions and Azure Pipelines and i\", \"t\\u2019s \\nworth comparing and contrasting them.  \\nPipelines as code  \\nBefore you compare GitHub Actions a\", \"nd Azure Pipelines, you should consider the benefits of pipelines \\nas code . Pipelines as code:  \\n[!\", \"div class=\\u201cchecklist\\u201d]  \\n\\u2022 Benefit from standard source control practices (such as code reviews via \", \"pull request and \\nversioning).  \\n\\u2022 Can be audited for changes just like any other files in the repos\", \"itory.  \\n\\u2022 Don\\u2019t require accessing a separate system or UI to edit.  \\n\\u2022 Can fully codify the build, \", \"test, and deploy process for code.   \\n51 CHAPTER 3 | Continuous integration and deployment with Azur\", \"e DevOps  \\n \\u2022 Can usually be templatized to empower teams to create standard processes across multip\", \"le \\nrepositories.  \\nNote  \\nThe term \\u201cpipelines\\u201d can also be referred to by several different interch\", \"angeable words: pipeline , \\nworkflow , and build  are common terms. In this article, references to A\", \"zure Pipelines  are referring to \\nYAML Pipelines , and not the older UI -based Classic Pipelines . \\n\", \"Agents and runners  \\nBefore you examine pipelines themselves, you should consider how these pipeline\", \"s execute . Both \\nGitHub Actions and Azure Pipelines are really orchestration engines . When a pipel\", \"ine is triggered, the \\nsystem finds an \\u201cagent\\u201d and tells the agent to execute the jobs defined in th\", \"e pipeline file.  \\nAzure Pipelines run on agents . The agent is written in .NET, so it will run wher\", \"ever .NET can run: \\nWindows, macOS, and Linux. Agents can even run in containers. Agents are registe\", \"red to a pool in \\nAzure Pipelines or to a repository or organization in GitHub. Agents can be hosted\", \"  or private . \\nGitHub Workflows execute on runners . The runner code is essentially a fork of the A\", \"zure Pipelines \\ncode, so it\\u2019s very similar. It\\u2019s also cross -platform and you can also use hosted  o\", \"r self-hosted  runners.  \\nHosted agents and runners  \\nHosted agents (Azure Pipelines) and hosted run\", \"ners (GitHub) are agents that are spun up and \\nmanaged by Azure DevOps or GitHub respectively. You d\", \"on\\u2019t need to maintain any build \\ninfrastructure. When a pipeline triggers that targets a hosted agen\", \"t, an instan ce of the specified agent \\nimage is created. The job is run by the agent on the instanc\", \"e, and once the job completes, the \\ninstance is destroyed. The same applies for hosted runners runni\", \"ng GitHub workflows.  \\nNote  \\nThe list of software installed on Azure Pipelines images is listed in \", \"this repository . You can select the \\nplatform folder and examine the README.md  files. You can find\", \" information on GitHub hosted \\nrunners . \\nPrivate agents and self -hosted runners  \\nThere are times \", \"when you can\\u2019t use hosted images. For example, when you:  \\n\\u2022 Require SDKs or other software that isn\", \"\\u2019t installed on the images.  \\n\\u2022 Need to access resources that aren\\u2019t public (such as an internal Son\", \"arQube server or an \\ninternal Artifactory instance).  \\n\\u2022 Need to deploy to private networks.  \\n\\u2022 Nee\", \"d to install licenses for third -party software required for building your code.  \\n\\u2022 Need more stora\", \"ge or memory than is provided to the hosted agent images.  \\n\\u2022 Need more time than the maximum build \", \"time limit for hosted agents.   \\n52 CHAPTER 3 | Continuous integration and deployment with Azure Dev\", \"Ops  \\n Important  \\nIt\\u2019s possible to install tools and SDKs when running pipelines on hosted agents. \", \"If the install steps \\ndon\\u2019t take long, this is viable. However, if the tools/software take a long ti\", \"me to install, then you may \\nbe better off with a private agent or self -hosted runner, since the in\", \"stall steps will need to execut e for \\nevery run of the workflow.  \\nAzure DevOps agents  \\nEvery Azur\", \"e DevOps account has a hosted pool with a single agent that can run one job at a time. \\nAlso include\", \"d is a set number of free build minutes. You may purchase additional \\u201chosted pipelines\\u201d in \\nAzure De\", \"vOps. When you purchase an additional hosted pip eline, you\\u2019re really removing the build \\nminutes li\", \"mit and adding concurrency . One pipeline can run one job at a time. Two pipelines can run \\ntwo jobs\", \" simultaneously, and so on.  \\nComparison of agents  \\nFeature  GitHub  Azure Pipelines  Links  \\nHoste\", \"d agents for \\npublic \\nrepos/projects  Free Up to 10 free Microsoft -hosted parallel jobs \\nthat can r\", \"un for up to 360 minutes (6 hours) \\neach time with no overall time limit per \\nmonth. You aren\\u2019t give\", \"n this free grant by \\ndefault, you have to submit a request  Azure \\nPipelines  \\nGitHub  \\nHosted agen\", \"ts for \\nprivate \\nrepos/projects  2,000 minutes \\nfree per month, \\n3,000 minutes \\nfor Pro and \\nTeam li\", \"censes, \\n50,000 minutes \\nfor Enterprise \\nlicense. \\nAdditional \\nminutes may be \\npurchased.  One free \", \"parallel job that can run for up to \\n60 minutes each time, until you\\u2019ve used \\n1,800 minutes (30 hour\", \"s) per month. You \\ncan pay for additional capacity per parallel \\njob. Paid parallel jobs remove the \", \"monthly \\ntime limit and allow you to run each job fo r \\nup to 360 minutes (6 hours).   \\nCross -platf\", \"orm  Yes Yes  \\nScale set agents  No Yes Azure virtual \\nmachine \\nscale set \\nagents  \\nComparison of Gi\", \"tHub Actions and Azure Pipelines  \\nAzure Pipelines (YAML pipelines) provide a mature set of features\", \". Some of the features include:  \\n\\u2022 Approvals  \\n\\u2022 Artifact storage   \\n53 CHAPTER 3 | Continuous inte\", \"gration and deployment with Azure DevOps  \\n \\u2022 Deployment jobs  \\n\\u2022 Environments  \\n\\u2022 Gates  \\n\\u2022 Stages \", \" \\n\\u2022 Templates  \\n\\u2022 Triggers  \\n\\u2022 Variable groups  \\nFor a full list of Azure Pipelines features, refer \", \"to the Feature availability  table.  \\nGitHub Actions are evolving rapidly and provide features such \", \"as triggers for almost all GitHub events, \\nartifact storage, environments and environment rules, sta\", \"rter templates, and matrices. Read more \\nabout the entire feature set refer GitHub Actions . \\nFeatur\", \"e comparison  \\nThe following table is current as of January 2023 and is not an exhaustive list of fe\", \"atures.  \\nFeature  Description  GitHub Actions  Azure Pipelines  \\nApprovals  Define approval \\ncondit\", \"ions before \\nmoving further in the \\npipeline  Yes Yes \\nArtifacts  Upload, store, and \\ndownload artif\", \"acts \\nfrom jobs  Yes Yes \\nCaching  Cache folders or files \\nfor subsequent runs  Yes Yes \\nConditions \", \" Specify conditions \\nfor steps or jobs  Yes Yes \\nContainer \\nJobs Run jobs inside a \\ncontainer  Yes Y\", \"es \\nDemands  Specify demands \\nthat must be met to \\nmatch jobs to agents  Yes Yes \\nDependenci\\nes Spec\", \"ify \\ndependencies \\nbetween jobs or \\nstages  Yes Yes \\nDeployment \\nGroups  A logical set of target \\nma\", \"chines for \\ndeployments  No Yes \\nDeployment \\nJobs Job that targets a \\ndeployment group  No Yes  \\n54 \", \"CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n Feature  Description  GitHub \", \"Actions  Azure Pipelines  \\nEnvironment\\ns A collection of \\nresources to target \\nor a logical \\nenviron\", \"ment  Yes Yes \\nGates/Check\\ns Automatic collection \\nand evaluation of \\nsignals to control \\ncontinuati\", \"on  Yes Yes \\nJobs Sequence of steps \\nthat are executed on \\nan agent  Yes Yes \\nService \\nContainers  M\", \"anage the lifecycle \\nof a containerized \\nservice instance \\navailable during a \\njob Yes Yes \\nService \", \"\\nConnections  Abstract credentials \\nto external systems  No Yes \\nPasswordles\\ns \\nconnections \\nto clou\", \"d \\nproviders  Provide technologies \\nand support use \\ncases that reduce \\nand potentially \\neliminate t\", \"he use of \\npasswords  Yes No \\nStages  Group jobs in a \\npipeline  No Yes \\nTemplates  Define reusable,\", \" \\nparameterized \\nbuilding blocks for \\nsteps, jobs, or \\nvariables  Yes Yes \\nStarter \\nTemplates  Defin\", \"es a starter \\nworkflow based on \\nthe type of code \\ndetected in a \\nrepository  Yes No \\nTriggers  Set \", \"of events that \\ncause the pipeline to \\ntrigger  Yes Yes  \\n55 CHAPTER 3 | Continuous integration and \", \"deployment with Azure DevOps  \\n Feature  Description  GitHub Actions  Azure Pipelines  \\nVariables  V\", \"ariables that can be \\npassed in, statically \\nor dynamically \\ndefined  Yes Yes \\nVariable \\nGroups  Sto\", \"re values for use \\nacross multiple \\npipelines  No Yes \\nImportant  \\nGitHub Actions is rapidly evolvin\", \"g. Be sure to check documentation carefully before deciding which \\nplatform is right for you.  \\nBuil\", \"d a .NET web app using GitHub Actions  \\nGitHub Actions  allow you to automate workflows in response \", \"to events that are triggered in GitHub. A \\ncommon workflow is Continuous Integration (CI), but Actio\", \"ns can automate other processes. For \\nexample, sending welcome emails when people join a repository.\", \"  \\nTo explore moving code to the cloud, you\\u2019ll build a GitHub Actions workflow file. The workflow fi\", \"le will \\nbe used for the Simple Feed Reader app you\\u2019ve already deployed to Azure App Service.  \\nIn t\", \"his article, you will: > [!div class=\\u201cchecklist\\u201d] > > * Learn the basic structure of a GitHub Action\", \" \\nworkflow YAML file. > * Use a template to create a basic build workflow that builds the .NET app a\", \"nd \\nexecutes unit tests. > * Publish the compiled app so that it\\u2019s ready for deployment.  \\nWorkflow \", \"structure  \\nWorkflows are defined in YAML files, and contain several common nodes:  \\n\\u2022 a name  \\n\\u2022 a \", \"trigger, defined by an on section  \\n\\u2022 one or more job sections composed of one or more steps  \\n\\u2022 opt\", \"ional attributes such as environment variables  \\nJobs are run on runners . You can use hosted runner\", \"s , which are spun up by GitHub during the \\nworkflow and then thrown away. Hosted runners are great \", \"because you don\\u2019t have to maintain your \\nown build infrastructure. For workflows that require a spec\", \"ific build environment, or for running \\nworkflows on a privat e network, you can also use private  r\", \"unners. To create a private runner, install the \\nrunner on any machine that supports .NET.  \\nEach jo\", \"b will specify what runner GitHub should use to execute the steps. You can also specify \\ndependencie\", \"s between jobs using the needs attribute. Deployment jobs can also specify an \\nenvironment to target\", \".   \\n56 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n The steps node can be\", \" as easy as inline commands, or they can be actions. Most CI workflows will \\nhave a combination of r\", \"un steps (for executing scripts) and actions. Individual actions are pulled into \\nthe workflow by re\", \"ferencing the GitHub Action repository (and optionally a tag or commit hash for \\nspecific versions) \", \"and specifying any parameters using the with keyword.  \\nTip \\nFor more information, see GitHub Action\", \"s YAML syntax . \\nFrom a workflow file, you\\u2019re able to run any of the available .NET CLI commands . F\", \"or example, if you\\u2019re \\nrequired to build, test, and deploy an ASP.NET Core Blazor WebAssembly app wi\", \"th Ahead -of-Time \\n(AoT) compilation, you\\u2019d use the following commands:  \\n\\u2022 dotnet workload install \", \" \\n\\u2022 dotnet restore  \\n\\u2022 dotnet build  \\n\\u2022 dotnet test  \\n\\u2022 dotnet publish  \\nThe .NET SDK is a workflow \", \"necessity  \\nAll .NET workflows require the .NET SDK, and this can be set up by the actions/setup -do\", \"tnet  GitHub \\nAction . This action sets up a .NET CLI  environment for use in actions. Some GitHub h\", \"osted runners  \\nhave the .NET SDK preinstalled, but that\\u2019s subject to change. As a best practice, us\", \"e the actions/setup -\\ndotnet action to ensure the proper version is available.  \\nCreate a basic buil\", \"d workflow  \\nA primary principle of effective DevOps is to \\u201cbuild once, and deploy many times\\u201d. You\\u2019\", \"ll start by \\ncreating a workflow to build a basic .NET app. In the next step, you\\u2019ll publish the out\", \"put to prepare for \\ndeployment.  \\n1. Navigate to your GitHub repository and select the Actions  tab.\", \" \\n2. GitHub detects that there\\u2019s .NET code in the repository and suggests a .NET workflow \\ntemplate.\", \" Select Set up this workflow  to create a new YAML workflow file:  \\n \\n**Figure 1**: Creating a new w\", \"orkflow.  \\n \\n57 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n 1. Commit the\", \" file onto the main branch. Since you\\u2019ve defined a trigger condition for commits to \\nmain , this com\", \"mit should trigger the workflow to run.  \\n \\n**Figure 2**: Commit the YAML file.  \\n1. Select the Acti\", \"ons  tab again. You should see a running workflow. Once the workflow has \\ncompleted, you should see \", \"a successful run.  \\n \\n**Figure 3**: Successful build view.  \\n1. Opening the logs, you can see that t\", \"he .NET build succeeded and the tests ran and passed.  \\n \\n**Figure 4**: Checking the logs.  \\n \\n58 CH\", \"APTER 3 | Continuous integration and deployment with Azure DevOps  \\n Note  \\nIf any of the tests fail\", \", the workflow will fail.  \\nDissect the workflow file  \\nLet\\u2019s examine the workflow YAML file you hav\", \"e so far:  \\nname: .NET \\n \\non: \\n  push: \\n    branches : [ main ] \\n  pull_request : \\n    branches : [ \", \"main ] \\n \\njobs: \\n  build: \\n \\n    runs-on: ubuntu-latest \\n \\n    steps: \\n    - uses: actions/checkout@\", \"v3  \\n    - name: Setup .NET  \\n      uses: actions/setup -dotnet@v3  \\n      with: \\n        dotnet-ver\", \"sion: 6.0.x \\n    - name: Restore dependencies  \\n      run: dotnet restore  \\n    - name: Build \\n     \", \" run: dotnet build --no-restore \\n    - name: Test \\n      run: dotnet test --no-build --verbosity nor\", \"mal  \\nNotice the following things:  \\n1. There\\u2019s a name that names the workflow.  \\n2. The on object s\", \"pecifies when this workflow should run. This workflow has two events that \\ntrigger it: push to main \", \"and pull_request to main. Each time someone commits to main or \\ncreates a pull request (PR) to main,\", \" this workflow will execute.  \\n3. There\\u2019s a single job called build. This build should run on a host\", \"ed agent. ubuntu_latest \\nspecifies the most recent Ubuntu hosted agent.  \\n4. There are five steps:  \", \"\\n1. actions/checkout@v3 is an action that checks out the code in the repository onto the \\nrunner.  \\n\", \"2. actions/setup -dotnet@v3 is an action that sets up the .NET CLI. This step also \\nspecifies a name\", \" attribute for the logs and the dotnet -version parameter within the \\nwith object.  \\n3. Three run st\", \"eps that execute dotnet restore, dotnet build, and dotnet test. name \\nattributes are also specified \", \"for these run steps to make the logs look pretty.   \\n59 CHAPTER 3 | Continuous integration and deplo\", \"yment with Azure DevOps  \\n Publish the output  \\nNow that you\\u2019ve successfully built and tested the co\", \"de, add steps that publish the output so you can \\ndeploy the web app.  \\n1. Navigate to the .github/w\", \"orkflows/dotnet.yml  file and select the pencil icon to edit  \\n \\n**Figure 5**: Edit the YAML file.  \", \"\\n1. Add the following Publish step below the Test step. The step runs the dotnet publish \\ncommand to\", \" publish the web app:  \\n  :::{custom -style=CodeBox} ```yml  \\n\\u2013 name: Test run: dotnet test \\u2013no-buil\", \"d \\u2013verbosity normal # < \\u2013 this is the current \\nbottom line  \\n\\u2013 name: Publish run: dotnet publish Sim\", \"pleFeedReader/SimpleFeedReader.csproj -c \\nRelease -o website ``` :::  \\n2. This publishes the web app\", \" to a folder on the hosted agent. Now you\\u2019ll want to upload  the \\nsite as a build artifact that can \", \"be deployed to Azure. To complete this activity, you\\u2019ll use an \\nexisting action.  \\n3. On the list of\", \" actions in the Actions Helper  pane on the right, search for artifact. Select on \\nthe Upload a Buil\", \"d Artifact (By actions) action.  \\n    \\n**Figure 6**: Accessing the snippet helper.  \\n \\n60 CHAPTER 3 \", \"| Continuous integration and deployment with Azure DevOps  \\n 1. Edit the version to v2.2.2 to displa\", \"y a sample snippet. Select the clipboard icon to copy the \\nsnippet and paste it into the workflow be\", \"low the publish step.  \\n \\n**Figure 7**: Copying a snippet.  \\n1. Edit the YAML for this step to look \", \"as follows:  \\n  :::{custom -style=CodeBox} ```yml  \\n\\u2013 name: Upload a Build Artifact uses: actions/up\", \"load -artifact@v3 with: name: website \\npath: SimpleFeedReader/website/** if -no-files-found: error `\", \"`` :::  \\n2. Commit the file.  \\n3. Once the workflow completes, you\\u2019ll see the artifact from the Home\", \"  tab: \\n \\n**Figure 8**: Viewing artifacts in the summary page.  \\n \\n61 CHAPTER 3 | Continuous integra\", \"tion and deployment with Azure DevOps  \\n Final workflow file  \\nThe final workflow file should look s\", \"omething like this:  \\nname: .NET \\n \\non: \\n  push: \\n    branches : [ main ] \\n  pull_request : \\n    bra\", \"nches : [ main ] \\n \\njobs: \\n  build: \\n \\n    runs-on: ubuntu-latest \\n \\n    steps: \\n    - uses: actions\", \"/checkout@v3  \\n    - name: Setup .NET  \\n      uses: actions/setup -dotnet@v3  \\n      with: \\n        \", \"dotnet-version: 6.0.x \\n    - name: Restore dependencies  \\n      run: dotnet restore  \\n    - name: Bu\", \"ild \\n      run: dotnet build --no-restore \\n    - name: Test \\n      run: dotnet test --no-build --ver\", \"bosity normal  \\n    - name: Publish \\n      run: dotnet publish SimpleFeedReader/SimpleFeedReader.csp\", \"roj -c Release -o website  \\n    - name: Upload a Build Artifact  \\n      uses: actions/upload -artifa\", \"ct@v3  \\n      with: \\n        name: website \\n        path: SimpleFeedReader/website/**  \\n        if-n\", \"o-files-found: error \\nDeploy a .NET web app using GitHub Actions  \\nWarning  \\nPlease complete the Bui\", \"ld  tutorial before starting this lab.  \\nIn this article, you\\u2019ll: > [!div class=\\u201cchecklist\\u201d] > > * L\", \"earn about Environments in GitHub Actions. > * \\nCreate two environments and specify environment prot\", \"ection rules. > * Create environment secrets \\nfor managing environment -specific configuration. > * \", \"Extend the workflow YAML file to add \\ndeployment steps. > * Add a manual dispatch trigger.  \\nEnviron\", \"ments  \\nNow that you\\u2019ve published an artifact that\\u2019s potentially deployable , you\\u2019ll add deployment \", \" jobs to the \\nworkflow. There\\u2019s nothing special about a deployment job, other than the fact that it \", \"references an  \\n62 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n environmen\", \"t . Environments are logical  constructs that allow you to specify environment protection \\nrules, su\", \"ch as approvals, on any group of resources that you\\u2019re targeting.  \\nIn this walkthrough, you\\u2019ll be d\", \"eploying to two environments: PRE -PROD and PROD. In a typical \\ndevelopment lifecycle, you\\u2019ll want t\", \"o deploy the latest code to a soft environment (typically DEV) that \\nis expected to be a bit unstabl\", \"e. You\\u2019ll use PRE -PROD as this soft environment. The \\u201chigher\\u201d \\nenvironments (like UAT and PROD) are\", \" harder  environments that are expected to be more stable. To \\nenforce this, you can build protectio\", \"n rules into higher environments. You\\u2019ll configure an approval \\nprotection rule on the P ROD environ\", \"ment: whenever a deployment job targets an environment with \\nan approval rule, it will pause until a\", \"pproval is granted before executing.  \\nGitHub environments are logical . They represent the physical\", \" (or virtual) resources that you\\u2019re \\ndeploying to. In this case, the PRE -PROD is just a deployment \", \"slot on the Azure Web App. PROD is the \\nproduction slot. The PRE -PROD deployment job will deploy th\", \"e published .NET app to the sta ging \\nslot. The PROD deployment job will swap the slots.  \\nOnce you \", \"have these steps in place, you\\u2019ll update the workflow to handle environment -specific \\nconfiguration\", \" using environment secrets.  \\nNote  \\nFor more information, see GitHub Actions - Environments . \\nAzur\", \"e authentication  \\nTo perform actions such as deploying code to an Azure resource, you need the corr\", \"ect permissions. \\nFor deployment to Azure Web Apps, you can use a publishing profile. If you want to\", \" deploy to a \\nstaging slot, then you\\u2019ll need the publishing profile for the s lot too. Instead, you \", \"can use a service \\nprincipal (SPN) and assign permission to this service principal. You can then aut\", \"henticate using \\ncredentials for the SPN before using any commands that the SPN has permissions to p\", \"erform.  \\nOnce you have an SPN, you\\u2019ll create a repository secret  to securely store the credentials\", \". You can then \\nrefer to the secret whenever you need to authenticate. The secret is encrypted and o\", \"nce it has been \\nsaved, can never be viewed or edited (only deleted or re -created).  \\nCreate an SPN\", \"  \\n1. In your terminal or Cloud Shell, run the following command to create a service principal with \", \"\\ncontributor permissions to the web app you created earlier:  \\n  :::{custom -style=CodeBox} azurecli\", \"  az ad sp create -for-rbac --name \\\"{sp -name}\\\" --sdk-auth --\\nrole contributor \\\\  --scopes /subscrip\", \"tions/{subscription -id}/resourceGroups/{resource -\\ngroup}/providers/Microsoft.Web/sites/{webappname\", \"} :::  \\n2. The command should output JSON that has credentials embedded:  \\n  :::{custom -style=CodeB\", \"ox} json  {    \\\"clientId\\\": \\\"<GUID>\\\",    \\\"clientSecret\\\": \\\"<GUID>\\\",    \\n\\\"subscriptionId\\\": \\\"<GUID>\\\",   \", \" \\\"tenantId\\\": \\\"<GUID>\\\",    ...  } :::   \\n63 CHAPTER 3 | Continuous integration and deployment with Az\", \"ure DevOps  \\n 3. Make sure to record the clientId, clientSecret, subscription, and tenantId. You can\", \" also leave \\nthe terminal open for copy/paste later.  \\nCreate a repository secret  \\n1. Now you\\u2019re go\", \"ing to create an encrypted secret to store the credentials. You\\u2019ll create this \\nsecret at the reposi\", \"tory level.  \\n2. Navigate to GitHub and select your repository Settings  tab. Then select Secrets . \", \"Select New \\nrepository secret : \\n   \\n**Figure 1**: Create a secret.  \\n1. Copy and paste the JSON fro\", \"m the az ad sp create -for-rbac command into the body of the \\nsecret. You can create this JSON by ha\", \"nd too if you have the relevant fields for your SPN. The \\nsecret should be named AZURE_CREDENTIALS. \", \"Select Add secret  to save the new secret:  \\n   \\n**Figure 2**: Add Azure credentials.  \\n1. You\\u2019ll co\", \"nsume this secret in a workflow in later steps. To access it, use the variable notation \\n${{}}. In t\", \"his case, ${{ AZURE_CREDENTIAL }} will be populated with the JSON you saved.  \\nAdd environments  \\nEn\", \"vironments  are used as a logical boundary . You can add approvals to environments to ensure \\nqualit\", \"y. You can also track deployments to environments and specify environment -specific values \\n(secrets\", \") for configuration.  \\n \\n64 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n F\", \"or this example, you\\u2019re going to split the actual Azure environment into two logical  environments \\n\", \"called PRE -PROD and PROD. When you deploy the web app, you\\u2019ll deploy to the staging slot of the \\nAz\", \"ure web app, represented by the PRE -PROD environment. When you\\u2019re ready to deploy to PROD, \\nyou\\u2019ll \", \"just perform a slot swap.  \\nIn this case, the only difference between the environments is the slot t\", \"hat you\\u2019re deploying to. In real \\nlife, there would typically be different web apps (and separate we\", \"b app plans), separate resource \\ngroups, and even separate subscriptions. Typically, t here\\u2019s an SPN\", \" per environment. You may want to \\noverride the AZURE_CREDENTIAL value that you saved as a repositor\", \"y secret by creating it as an \\nenvironment secret . \\nNote  \\nPrecedence works from Environment to rep\", \"ository. If a targeted environment has a secret called \\nMY_SECRET, then that value is used. If not, \", \"the repository value of MY_SECRET (if any) is used.  \\n1. Select Settings  and then Environments  in \", \"your repository. Select New Environment : \\n     \\n**Figure 3**: Create an environment.  \\n1. Enter PRE\", \" -PROD and select Configure environment : \\n \\n**Figure 4**: Name the environment.  \\n \\n65 CHAPTER 3 | \", \"Continuous integration and deployment with Azure DevOps  \\n 1. Since deploying to a staging slot does\", \"n\\u2019t affect the web app, you can safely deploy to the slot \\nwithout requiring an approval first. A re\", \"viewer could be added if desired. For this example, \\nleave the Environment protection rules empty.  \", \"\\n  [!NOTE] If you target an environment in a workflow and it does not exist, an \\u201cempty\\u201d \\nenvironment\", \" is created automatically. The environment would look exactly the same as the \\nPRE-PROD environment \", \"- it would exist, but would not have any protection rules ena bled.  \\n2. Select Environments  again \", \"and again select New Environment . Now enter PROD as the \\nname and select Configure environment . \\n3\", \". Check the Required reviewers  rule and add yourself as a reviewer. Don\\u2019t forget to select \\nSave pr\", \"otection rules : \\n   \\n**Figure 5**: Add protection rules.  \\nDeploy to staging  \\nYou can now add addi\", \"tional jobs to the workflow to deploy to the environments! You\\u2019ll start by \\nadding a deployment to t\", \"he PRE -PROD environment, which in this case is the web app staging slot.  \\n1. Navigate to the .gith\", \"ub/workflows/dotnet.yml  file and select the pencil icon to edit the file.  \\n2. You\\u2019re going to use \", \"the web app name a few times in this workflow, and will need the name \\nof the resource group too. Yo\", \"u\\u2019ll define the app and resource group names as variables. With \\nthe variables, you can maintain the\", \" values in one place in the workflow f ile. \\n3. Add this snippet below the on block and above the jo\", \"bs block:  \\n  :::{custom -style=CodeBox} ```yml env: app -name: \\u201c\\u201d rg -name: \\u201c\\u201d  \\n  jobs: # < \\u2013 this\", \" is the existing jobs line ``` :::  \\n  [!WARNING] You\\u2019ll need to replace <name of your web app> with\", \" the actual name of your \\nweb app, and <name of your resource group> with the actual name of your re\", \"source group.  \\n4. Add a new job below the build job as follows:  \\n \\n66 CHAPTER 3 | Continuous integ\", \"ration and deployment with Azure DevOps  \\n   :::{custom -style=CodeBox} ```yml if -no-files-found: e\", \"rror # < \\u2013 last line of build job: insert \\nbelow this line  \\n  deploy_staging: needs: build runs -on\", \": ubuntu -latest  \\n environment:  \\n   name: PRE -PROD \\n   url: ${{ steps.deploywebapp.outputs.webapp\", \" -url }} \\n \\n steps: \\n - name: Download a Build Artifact  \\n   uses: actions/download -artifact@v3  \\n \", \"  with: \\n     name: website  \\n     path: website  \\n \\n - name: Login via Azure CLI  \\n   uses: azure/l\", \"ogin@v1  \\n   with: \\n     creds: ${{ secrets.AZURE_CREDENTIALS }}  \\n \\n - name: Deploy web app  \\n   id\", \": deploywebapp  \\n   uses: azure/webapps -deploy@v2  \\n   with: \\n     app-name: ${{ env.app -name }} \\n\", \"     slot-name: staging  \\n     package: website  \\n \\n - name: az cli logout  \\n   run: az logout  \\n  `\", \"`` ::: \\nThe preceding workflow defines several steps:  \\n1. You\\u2019re creating a new job called deploy_s\", \"taging.  \\n2. You specify a dependency using needs. This job needs the build job to complete \\nsuccess\", \"fully before it starts.  \\n3. This job also runs on the latest Ubuntu hosted agent, as specified with\", \" the runs -on \\nattribute.  \\n4. You specify that this job is targeting the PRE -PROD environment usin\", \"g the \\nenvironment object. You also specify the url property. This URL will be displayed in \\nthe wor\", \"kflow diagram, giving users an easy way to navigate to the environment. The \\nvalue of this property \", \"is set as the output of the step with id deploywebapp, which is \\ndefined below.  \\n5. You\\u2019re executin\", \"g a download -artifact step to download the artifact (compiled web \\napp) from the build job.  \\n6. Yo\", \"u then login to Azure using the AZURE_CREDENTIALS secret you saved earlier. \\nNote the ${{ }} notatio\", \"n for dereferencing variables.  \\n7. You then perform a webapp -deploy, specifying the app -name, slo\", \"t -name, and path to \\nthe downloaded artifact (package). This action also defines an output paramete\", \"r that \\nyou use to set the url of the environment above.   \\n67 CHAPTER 3 | Continuous integration an\", \"d deployment with Azure DevOps  \\n 8. Finally, you execute a logout to log out of the Azure context. \", \" \\n5. Commit the file.  \\n6. When the run completes, you should see two successful jobs. The URL for t\", \"he PRE -PROD \\nstage has been set and selecting it will navigate you to your web app staging slot:  \\n\", \"     \\n**Figure 6**: Deployment to PRE -PROD is successful.  \\n1. Notice how the staging slot\\u2019s direct\", \" URL contains -staging:  \\n   \\n**Figure 7**: The staging slot running.  \\n1. You can also now see depl\", \"oyments. Navigate to https://{your repository url}/deployments to \\nview your deployments:  \\n \\n68 CHA\", \"PTER 3 | Continuous integration and deployment with Azure DevOps  \\n    \\n**Figure 8**: View deploymen\", \"ts.  \\nDeploy to production  \\nNow that you\\u2019ve deployed successfully to PRE -PROD, you\\u2019ll want to depl\", \"oy to PROD. Deployment to \\nPROD will be slightly different since you don\\u2019t need to copy the website \", \"again - you just need to swap \\nthe staging slot with the production slot. You\\u2019ll do this  using an A\", \"zure CLI (az) command.  \\n1. Navigate to the .github/workflows/dotnet.yml  file and select the pencil\", \" icon to edit the file.  \\n2. Add a new job below the deploy_staging job as follows:  \\n  :::{custom -\", \"style=CodeBox} ```yml run: az logout # < \\u2013 last line of previous job: insert below this \\nline \\n  dep\", \"loy_prod: needs: deploy_staging runs -on: ubuntu -latest  \\n environment:  \\n   name: PROD  \\n   url: $\", \"{{ steps.slot_swap.outputs.url }}  \\n \\n steps: \\n - name: Login via Azure CLI  \\n   uses: azure/login@v\", \"1  \\n   with: \\n     creds: ${{ secrets.AZURE_CREDENTIALS }}  \\n \\n - name: Swap staging slot into produ\", \"ction  \\n   id: slot_swap  \\n   run: | \\n     az webapp deployment slot swap -g ${{ env.rg -name }} -n \", \"${{ env.app -name }} -s staging  \\n     url=$(az webapp show -g ${{ env.rg -name }} -n ${{ env.app -n\", \"ame }} --query \\n\\\"defaultHostName\\\" -o tsv) \\n     echo \\\"::set -output name=url::http://$url\\\"  \\n \\n - na\", \"me: az cli logout  \\n   run: az logout  \\n``` ::: \\n  The deployment to the PROD environment workflow s\", \"pecifies several steps:  \\n1. Once again, you specify a new job deploy_prod that needs deploy_staging\", \" to \\ncomplete before starting.  \\n2. You\\u2019re targeting the PROD environment this time. Also, the url v\", \"alue is different from \\nbefore.  \\n \\n69 CHAPTER 3 | Continuous integration and deployment with Azure \", \"DevOps  \\n 3. For the steps, you don\\u2019t need to download the artifact since you\\u2019re just going to \\nperf\", \"orm a slot swap. You start by executing a login to the Azure context.  \\n4. The Swap staging slot int\", \"o production step is a multi -line run command (note the use \\nof the pipe symbol |). You also specif\", \"y an id for this step so that you can refer to it \\n(you refer to it in the url property of the envir\", \"onment). The first line executes t he slot \\nswap using the variables you defined above in the workfl\", \"ow. The second line uses an \\naz webapp show command to extract the URL of the target web app. This f\", \"inal line \\nuses ::set -output in an echo to create an output variable for this task, setting th e va\", \"lue \\nto the web app URL.  \\n  [!NOTE] The URL must  start with http:// or https:// or it won\\u2019t render\", \".  \\n3. Commit the file.  \\n4. Let the workflow run for a couple minutes until it has deployed to PRE \", \"-PROD. At this point, \\nthe workflow will pause and wait for the required approval since you\\u2019re targe\", \"ting the PROD \\nenvironment, which requires an approval as defined earlier:  \\n   \\n**Figure 9**: Waiti\", \"ng for an approval.  \\n1. Select Review deployments , select the PROD  checkbox, optionally add a com\", \"ment, and then \\nselect Approve and deploy  to start the PROD job.  \\n \\n**Figure 10**: Approve the PRO\", \"D deployment.  \\n1. The deployment should only take a few seconds. Once it has completed, the URL for\", \" the \\nPROD environment will update.  \\n \\n70 CHAPTER 3 | Continuous integration and deployment with Az\", \"ure DevOps  \\n    \\n**Figure 11**: PROD deployment completed.  \\n1. Selecting the PROD URL will navigat\", \"e you to the PROD site.  \\n   \\n**Figure 12**: The PROD site.  \\nAdd a manual queue option  \\nYou now ha\", \"ve an end -to-end build and deploy workflow, including approvals. One more change you \\ncan make is t\", \"o add a manual trigger to the workflow so that the workflow can be triggered from \\nwithin the Action\", \"s  tab of the repository.  \\n1. Navigate to the .github/workflows/dotnet.yml  file and select the pen\", \"cil icon to edit the file.  \\n2. Add a new trigger between on and push on lines 3 and 4:  \\n  :::{cust\", \"om -style=CodeBox} yml  on:    workflow_dispatch:   # < -- this is the new line    push: :::  \\n3. Th\", \"e workflow_dispatch trigger displays a Run workflow button in the Actions  tab of the \\nrepository \\u2014b\", \"ut only if the trigger is defined in the default branch . However, once this trigger is \\ndefined in \", \"the workflow, you can select the branch for the run.  \\n4. Commit the file.  \\n \\n71 CHAPTER 3 | Contin\", \"uous integration and deployment with Azure DevOps  \\n 5. To see the Run workflow  button, select the \", \"Actions  tab. Select the .NET workflow in the list \\nof workflows. At the top of the list of runs, yo\", \"u\\u2019ll see the Run workflow  button. If you select \\nit, you can choose the branch to run the workflow \", \"against and queue it:  \\n   \\n**Figure 13**: Manual dispatch.  \\nHandle environment configuration  \\nYou\", \"r workflow is deploying the same binary to each environment. This concept is important to ensure \\nth\", \"at the binaries you test in one environment are the same that you deploy to the next. However, \\nenvi\", \"ronments typically have different settings like databas e connection strings. You want to ensure \\nth\", \"at the DEV app is using DEV settings and the PROD app is using PROD settings.  \\nFor this simple app,\", \" there\\u2019s no database connection string. However, there\\u2019s an example configuration \\nsetting that you \", \"can modify for each environment. If you open the simple -feed-\\nreader/SimpleFeedReader/appsettings.j\", \"son  file, you\\u2019ll see that the configuration includes a setting for \\nthe Header text on the Index pa\", \"ge:  \\n  \\\"UI\\\": { \\n    \\\"Index\\\": { \\n      \\\"Header\\\" : \\\"Simple News Reader\\\"  \\n    } \\n  }, \\nTo show how en\", \"vironment configuration can be handled, you\\u2019re going to add a secret to each \\nenvironment and then s\", \"ubstitute that value into the settings as you deploy.  \\nAdd environment secrets  \\n1. On your reposit\", \"ory, select Settings  > Environments  > PRE-PROD . \\n2. Select Add secret  and add a secret called in\", \"dex_header with the value PRE PROD News \\nReader. Select Add secret . \\n \\n72 CHAPTER 3 | Continuous in\", \"tegration and deployment with Azure DevOps  \\n    \\n**Figure 14**: Add an environment secret.  \\n1. Rep\", \"eat these steps to add a secret called index_header with the value PROD News Reader for \\nthe PROD en\", \"vironment.  \\n2. If you select Settings  > Secrets  in the repository, you\\u2019ll see the changes. They s\", \"hould look \\nsomething like this:  \\n   \\n**Figure 15**: View secrets.  \\nUpdate the workflow to handle \", \"configuration  \\n1. Navigate to the .github/workflows/dotnet.yml  file and select the pencil icon to \", \"edit the file.  \\n2. Add the following step before the az cli logout step in the deploy_staging job: \", \" \\n  :::{custom -style=CodeBox} ```yml - name: Update config uses: Azure/appservice -settings@v1 \\nwit\", \"h: app -name: ${{ env.app -name }}  slot -name: staging  app -settings -json: |  [  {  \\\"name\\\": \\n\\\"UI:\", \"Index:Header\\\",  \\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\u201c,\\u201dslotSetting\\u201d:  true } ]  \\n   - name: az cli \", \"logout   # < -- this exists already  \\n  ``` ::: \\n \\n73 CHAPTER 3 | Continuous integration and deploym\", \"ent with Azure DevOps  \\n 3. Add almost the same code to the deploy_prod job above its az cli logout \", \"step. The only \\ndifference is that you don\\u2019t specify a slot -name, since you\\u2019re targeting the produc\", \"tion slot:  \\n  :::{custom -style=CodeBox} ```yml - name: Update config uses: Azure/appservice -setti\", \"ngs@v1 \\nwith: app -name: ${{ env.app -name }}  app -settings -json: |  [  {  \\\"name\\\": \\\"UI:Index:Heade\", \"r\\\",  \\n\\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\u201c,\\u201dslotSetting\\u201d: true } ]  \\n   - name: az cli logout # < \", \"-- this exists already  \\n  ``` ::: \\n4. Commit the file.  \\n5. Let the workflow run and approve the de\", \"ployment to PROD once the approval is reached.  \\n6. You should see the following headers on the inde\", \"x page for both sites:  \\n  \\n \\n**Figure 16**: Settings changed in the environments.  \\nFinal workflow \", \"file  \\nThe final workflow file should look like this:  \\nname: .NET \\n \\non: \\n  workflow_dispatch : \\n  \", \"  inputs: \\n      reason: \\n        description : 'The reason for running the workflow'  \\n        requ\", \"ired : true \\n        default: 'Manual build from GitHub UI'  \\n  push: \\n    branches : [ main ] \\n  pu\", \"ll_request : \\n    branches : [ main ] \\n \\nenv: \\n  app-name: \\\"cd-simplefeedreader\\\"  \\n  rg-name: \\\"cd-do\", \"tnetactions\\\"  \\n \\njobs: \\n  build: \\n \\n \\n74 CHAPTER 3 | Continuous integration and deployment with Azur\", \"e DevOps  \\n     runs-on: ubuntu-latest \\n \\n    steps: \\n    - uses: actions/checkout@v3  \\n    - name: \", \"'Print manual run reason'  \\n      if: ${{ github.event_name == 'workflow_dispatch' }}  \\n      run: |\", \" \\n        echo 'Reason: ${{ github.event.inputs.reason }}'  \\n    - name: Setup .NET  \\n      uses: ac\", \"tions/setup -dotnet@v3  \\n      with: \\n        dotnet-version: 6.0.x \\n    - name: Restore dependencie\", \"s  \\n      run: dotnet restore  \\n    - name: Build \\n      run: dotnet build --no-restore \\n    - name:\", \" Test \\n      run: dotnet test --no-build --verbosity normal  \\n    - name: Publish \\n      run: dotnet\", \" publish SimpleFeedReader/SimpleFeedReader.csproj -c Release -o website  \\n    - name: Upload a Build\", \" Artifact  \\n      uses: actions/upload -artifact@v3  \\n      with: \\n        name: website \\n        pa\", \"th: SimpleFeedReader/website/**  \\n        if-no-files-found: error \\n   \\n  deploy_staging : \\n    need\", \"s: build \\n    runs-on: ubuntu-latest \\n \\n    environment : \\n      name: STAGING \\n      url: ${{ steps\", \".deploywebapp.outputs.webapp -url }} \\n \\n    steps: \\n    - name: Download a Build Artifact  \\n      us\", \"es: actions/download -artifact@v3  \\n      with: \\n        name: website \\n        path: website \\n \\n   \", \" - name: Login via Azure CLI  \\n      uses: azure/login@v1  \\n      with: \\n        creds: ${{ secrets.\", \"AZURE_CREDENTIALS }}  \\n \\n    - name: Deploy web app  \\n      id: deploywebapp  \\n      uses: azure/web\", \"apps -deploy@v2  \\n      with: \\n        app-name: ${{ env.app -name }} \\n        slot-name: staging \\n \", \"       package: website \\n \\n    - name: Update config  \\n      uses: Azure/appservice -settings@v1  \\n \", \"     with: \\n       app-name: ${{ env.app -name }} \\n       slot-name: staging \\n       app-settings -j\", \"son: |  \\n75 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n          [ \\n     \", \"        { \\n                 \\\"name\\\": \\\"UI:Index:Header\\\",  \\n                 \\\"value\\\": \\\"${{ secrets.INDE\", \"X_HEADER }}\\\",  \\n                 \\\"slotSetting\\\": true  \\n             } \\n         ] \\n \\n    - name: az \", \"cli logout  \\n      run: az logout  \\n \\n  deploy_prod : \\n    needs: deploy_staging  \\n    runs-on: ubun\", \"tu-latest \\n \\n    environment : \\n      name: PROD \\n      url: ${{ steps.slot_swap.outputs.url }}  \\n \\n\", \"    steps: \\n    - name: Login via Azure CLI  \\n      uses: azure/login@v1  \\n      with: \\n        cred\", \"s: ${{ secrets.AZURE_CREDENTIALS }}  \\n \\n    - name: Swap staging slot into production  \\n      id: sl\", \"ot_swap  \\n      run: | \\n        az webapp deployment slot swap -g ${{ env.rg -name }} -n ${{ env.app\", \" -name }} -s \\nstaging \\n        url=$(az webapp show -g ${{ env.rg -name }} -n ${{ env.app -name }} -\", \"-query \\n\\\"defaultHostName\\\" -o tsv) \\n        echo \\\"::set -output name=url::http://$url\\\"  \\n \\n    - name\", \": Update config  \\n      uses: Azure/appservice -settings@v1  \\n      with: \\n       app-name: ${{ env.\", \"app -name }} \\n       app-settings -json: | \\n         [ \\n             { \\n                 \\\"name\\\": \\\"UI\", \":Index:Header\\\",  \\n                 \\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\\",  \\n                 \\\"slotS\", \"etting\\\": true  \\n             } \\n         ] \\n \\n    - name: az cli logout  \\n      run: az logout  \\nSec\", \"ure .NET Code with CodeQL and GitHub Actions  \\nCodeQL  is a static code analysis engine that can aut\", \"omate security and quality checks. With CodeQL, \\nyou can perform variant analysis , which uses known\", \" vulnerabilities as seeds to find similar issues. \\nCodeQL is part of GitHub Advanced Security  that \", \"includes:  \\n[!div class=\\u201cchecklist\\u201d]   \\n76 CHAPTER 3 | Continuous integration and deployment with Az\", \"ure DevOps  \\n \\u2022 Code scanning \\u2014find potential security vulnerabilities in your code.  \\n\\u2022 Secret scan\", \"ning \\u2014detect secrets and tokens that are committed.  \\n\\u2022 Dependency scanning \\u2014detect vulnerabilities \", \"in packages that you consume.  \\nCodeQL supports some of the most popular programming languages and c\", \"ompilers : \\n\\u2022 C/C++  \\n\\u2022 Java \\n\\u2022 C# \\n\\u2022 Python  \\n\\u2022 Go \\n\\u2022 JavaScript  \\n\\u2022 TypeScript  \\nCodeQL is a power\", \"ful language and security professionals can create custom queries using CodeQL. \\nHowever, teams can \", \"benefit immensely from the large open -source collection of queries that the \\nsecurity community has\", \" created without having to write any custo m CodeQL.  \\nIn this article, you\\u2019ll set up a GitHub workf\", \"low that will scan code in your repository using CodeQL. \\nYou will:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 C\", \"reate a code scanning action.  \\n\\u2022 Edit the workflow file to include custom scan settings.  \\n\\u2022 See sc\", \"anning results.  \\nNote  \\nTo see security alerts for your repository, you must be a repository owner.\", \"  \\nCreate the code scanning workflow  \\nYou can use a starter workflow for code scanning by navigatin\", \"g to the Security  tab of your repository.  \\n1. Navigate to your GitHub repository and select the Se\", \"curity  > Code Scanning Alerts . The top \\nrecommended workflow should be CodeQL Analysis. Select Set\", \" up this workflow . \\n   \\n**Figure 1:** Create a new code scanning workflow.  \\n \\n77 CHAPTER 3 | Conti\", \"nuous integration and deployment with Azure DevOps  \\n 1. A new workflow file is created in your .git\", \"hub/workflows  folder.  \\n2. Select Start Commit  on the upper right to save the default workflow. Yo\", \"u can commit to the \\nmain branch.  \\n   \\n**Figure 2:** Commit the file.  \\n1. Select the Actions  tab.\", \" In the left -hand tree, you\\u2019ll see a CodeQL  node. Select this node to \\nfilter for CodeQL workflow \", \"runs.  \\n   \\n**Figure 3:** View the CodeQL workflow runs.  \\nTake a look at the workflow file while it\", \" runs. If you remove the comments from the file, you\\u2019ll see the \\nfollowing YAML:  \\nname: \\\"CodeQL\\\"  \\n\", \" \\non: \\n  push: \\n    branches : [ main ] \\n  pull_request : \\n    branches : [ main ] \\n  schedule : \\n  \", \"  - cron: '40 14 * * 6'  \\n \\njobs: \\n  analyze: \\n    name: Analyze \\n    runs-on: ubuntu-latest \\n \\n    \", \"strategy : \\n      fail-fast: false \\n \\n78 CHAPTER 3 | Continuous integration and deployment with Azur\", \"e DevOps  \\n       matrix: \\n        language : [ 'csharp'  ] \\n \\n    steps: \\n    - name: Checkout repo\", \"sitory  \\n      uses: actions/checkout@v3  \\n \\n    - name: Initialize CodeQL  \\n      uses: github/code\", \"ql -action/init@v1  \\n      with: \\n        languages : ${{ matrix.language }}  \\n \\n    - name: Autobui\", \"ld  \\n      uses: github/codeql -action/autobuild@v1  \\n \\n    - name: Perform CodeQL Analysis  \\n      \", \"uses: github/codeql -action/analyze@v1  \\nNotice the following things:  \\n1. The workflow name is Code\", \"QL.  \\n2. This workflow triggers on push and pull_request events to the main branch. There\\u2019s also a \\n\", \"cron trigger. The cron trigger lets you define a schedule for triggering this workflow and is \\nrando\", \"mly generated for you. In this case, this workflow will run at 14:4 0 UTC every Saturday.  \\n  [!TIP]\", \" If you edit the workflow file and hover over the cron expression, a tooltip will show you \\nthe Engl\", \"ish text for the cron expression.  \\n3. There\\u2019s a single job called analyze that runs on the ubuntu -\", \"latest hosted agent.  \\n4. This workflow defines a strategy with a matrix on the array of language. I\", \"n this case, there\\u2019s \\nonly csharp. If the repository contained other languages, you could add them t\", \"o this array. \\nThis causes the job to \\u201cfan out\\u201d and create an instance per value of the matrix.  \\n5.\", \" There are four steps, starting with checkout.  \\n6. The second step initializes the CodeQL scanner f\", \"or the language this job is going to scan. \\nCodeQL intercepts calls to the compiler to build a datab\", \"ase of the code while the code is \\nbeing built.  \\n7. The Autobuild step will attempt to automaticall\", \"y build the source code using common \\nconventions. If this step fails, you can replace it with your \", \"own custom build steps.  \\n8. After building, the CodeQL analysis is performed, where suites of queri\", \"es are run against the \\ncode database.  \\n9. The run should complete successfully. However, there app\", \"ear to be no issues.   \\n79 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \\n   \", \" \\n**Figure 4:** No results to the initial scan.  \\nCustomize CodeQL settings  \\nThe CodeQL scan isn\\u2019t \", \"reporting any security issues. That\\u2019s expected with this basic sample. CodeQL \\ncan also scan for qua\", \"lity  issues. The current workflow is using the default security -extended suite. You \\ncan add quali\", \"ty scanning in by adding a configuration file to customize the scanning suites. In this \\nstep, you\\u2019l\", \"l configure CodeQL to use the security -and-quality suites.  \\n[!INFORMATION] For other CodeQL config\", \"uration options, see Configuring CodeQL code scanning in \\nyour CI system . \\n1. Navigate to the .gith\", \"ub  folder in the Code  tab and select Add File : \\n   \\n**Figure 5:** Create a new file.  \\n1. Enter c\", \"odeql/codeql -config.yml  as the name. This creates the file in a folder. Paste in the \\nfollowing co\", \"de:  \\n  :::{custom -style=CodeBox} ```yml name: \\u201cSecurity and Quality\\u201d  \\n  queries:  \\n\\u2013 uses: securi\", \"ty -and-quality ``` :::  \\n \\n80 CHAPTER 3 | Continuous integration and deployment with Azure DevOps  \", \"\\n    \\n**Figure 6:** Create the CodeQL configuration file.  \\n1. Select Commit to main  at bottom of t\", \"he editor to commit the file.  \\n2. Edit the CodeQL workflow to use the new configuration file. Navig\", \"ate to \\n.github/workflows/codeql -analysis.yml  and select the pencil icon. Add a new property to th\", \"e \\nwith section as shown below:  \\n:::{custom -style=CodeBox} yml   - name: Initialize CodeQL     use\", \"s: github/codeql -action/init@v1     \\nwith:       languages: ${{ matrix.language }}       config -fi\", \"le: ./.github/codeql/codeql -config.yml  # < -- \\nadd this line :::  \\n1. Select Start Commit  and com\", \"mit to the main branch.  \\nReview the security alerts  \\nImportant  \\nYou must be a repository owner to\", \" view security alerts.  \\nThis sample repository is small. As such, it doesn\\u2019t contain any major secu\", \"rity or quality issues. \\nHowever, \\u201creal world\\u201d repositories will likely have some issues.  \\nWhen the\", \" last CodeQL workflow run completes, you should see two issues in the Security  tab: \\n \\n81 CHAPTER 3\", \" | Continuous integration and deployment with Azure DevOps  \\n  \\nFigure 7:  View security alerts.  \\n1\", \". Select the first alert to open it.  \\n2. In this case, the alert is for a generated file that isn\\u2019t\", \" committed to the repository. For that \\nreason, the preview is unavailable.  \\n3. Notice the tags tha\", \"t are applied. These tags can be used for filtering issues.  \\n4. Select Show more  under the rule in\", \"formation to show help and recommendations.  \\n   \\n**Figure 8:** Open an alert.  \\n1. Selecting Dismis\", \"s  will open options for dismissing this issue:  \\n \\n82 CHAPTER 3 | Continuous integration and deploy\", \"ment with Azure DevOps  \\n    \\n**Figure 9:** Dismiss an alert.  \\n \\n83 CHAPTER 4 | Monitor and debug  \", \"\\n CHAPTER  4 \\nMonitor and debug  \\nHaving deployed the app and built a DevOps pipeline, it\\u2019s importan\", \"t to understand how to monitor \\nand troubleshoot the app.  \\nIn this section, you\\u2019ll complete the fol\", \"lowing tasks:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 Find basic monitoring and troubleshooting data in the A\", \"zure portal  \\n\\u2022 Learn how Azure Monitor provides a deeper look at metrics across all Azure services \", \" \\n\\u2022 Connect the web app with Application Insights for app profiling  \\n\\u2022 Turn on logging and learn wh\", \"ere to download logs  \\n\\u2022 Stream logs in real time  \\n\\u2022 Learn where to set up alerts  \\n\\u2022 Learn about r\", \"emote debugging Azure App Service web apps.  \\nBasic monitoring and troubleshooting  \\nApp Service web\", \" apps are easily monitored in real time. The Azure portal renders metrics in easy -to-\\nunderstand ch\", \"arts and graphs.  \\n1. Open the Azure portal , and then navigate to the mywebapp<unique_number>  App \", \"Service.  \\n2. The Overview  tab displays useful \\u201cat -a-glance\\u201d information, including graphs display\", \"ing \\nrecent metrics.  \\n         \\n \\n84 CHAPTER 4 | Monitor and debug  \\n * **Http 5xx**: Count of serv\", \"er -side errors, usually exceptions in ASP.NET Core code.  \\n* **Data In**: Data ingress coming into \", \"your web app.  \\n* **Data Out**: Data egress from your web app to clients.  \\n* **Requests**: Count of\", \" HTTP requests.  \\n* **Average Respon se Time**: Average time for the web app to respond to HTTP requ\", \"ests.  \\n \\nSeveral self -service tools for troubleshooting and optimization are also found on this \\np\", \"age. \\n  \\n \\n* **Diagnose and solve problems** is a self -service troubleshooter.  \\n* **Application In\", \"sights** is for profiling performance and app behavior, and is \\ndiscussed later in this section.  \\n*\", \" **App Service Advisor** makes recommendations to tune your app experienc e. \\nAdvanced monitoring  \\n\", \"Azure Monitor  is the centralized service for monitoring all metrics and setting alerts across Azure\", \" \\nservices. Within Azure Monitor, administrators can granularly track performance and identify trend\", \"s. \\nEach Azure service offers its own set of metrics  to Azure Monitor.  \\nProfile with Application I\", \"nsights  \\nApplication Insights  is an Azure service for analyzing the performance and stability of w\", \"eb apps and \\nhow users use them. The data from Application Insights is broader and deeper than that \", \"of Azure \\nMonitor. The data can provide developers and administrators with key informatio n for impr\", \"oving \\napps. Application Insights can be added to an Azure App Service resource without code changes\", \".  \\n1. Open the Azure portal , and then navigate to the mywebapp<unique_number>  App Service.  \\n2. F\", \"rom the Overview  tab, click the Application Insights  tile. \\n \\n85 CHAPTER 4 | Monitor and debug  \\n \", \" \\n \\n1. Select the Create new resource  radio button. Use the default resource name, and select the \\n\", \"location for the Application Insights resource. The location doesn\\u2019t need to match that of your \\nweb\", \" app.  \\n       \\n1. For Runtime/Framework , select ASP.NET Core . Accept the default settings.  \\n2. S\", \"elect OK. If prompted to confirm, select Continue . \\n3. After the resource has been created, click t\", \"he name of Application Insights resource to \\nnavigate directly to the Application Insights page.  \\n \", \"\\nAs the app is used, data accumulates. Select Refresh  to reload the blade with new data.  \\n \\n86 CHA\", \"PTER 4 | Monitor and debug  \\n  \\nApplication Insights provides useful server -side information with n\", \"o additional configuration. To get \\nthe most value from Application Insights, instrument your app wi\", \"th the Application Insights SDK . \\nWhen properly configured, the service provides end -to-end monito\", \"ring across the web server and \\n \\n87 CHAPTER 4 | Monitor and debug  \\n browser, including client -sid\", \"e performance. For more information, see the Application Insights \\ndocumentation . \\nLogging  \\nWeb se\", \"rver and app logs are disabled by default in Azure App Service. Enable the logs with the \\nfollowing \", \"steps:  \\n1. Open the Azure portal , and navigate to the mywebapp<unique_number>  App Service.  \\n2. I\", \"n the menu to the left, scroll down to the Monitoring  section. Select Diagnostics logs . \\n        \\n\", \"1. Turn on Application Logging (Filesystem) . If prompted, click the box to install the \\nextensions \", \"to enable app logging in the web app.  \\n2. Set Web server logging  to File System . \\n3. Enter the Re\", \"tention Period  in days. For example, 30.  \\n4. Click Save . \\nASP.NET Core and web server (App Servic\", \"e) logs are generated for the web app. They can be \\ndownloaded using the FTP/FTPS information displa\", \"yed. The password is the same as the deployment \\ncredentials created earlier in this guide. The logs\", \" can be streamed directly to your local machine with \\nPowerShell or Azure CLI . Logs can also be vie\", \"wed in Application Insights . \\nLog streaming  \\nApp and web server logs can be streamed in real time \", \"through the portal.  \\n1. Open the Azure portal , and navigate to the mywebapp<unique_number>  App Se\", \"rvice.  \\n2. In the menu to the left, scroll down to the Monitoring  section and select Log stream . \", \"\\n \\n88 CHAPTER 4 | Monitor and debug  \\n      \\nLogs can also be streamed via Azure CLI or Azure PowerS\", \"hell , including through the Cloud Shell.  \\nAlerts  \\nAzure Monitor also provides real time alerts  b\", \"ased on metrics, administrative events, and other \\ncriteria.  \\nNote  \\nCurrently alerting on web app \", \"metrics is only available in the Alerts (classic) service.  \\nThe Alerts (classic) service  can be fo\", \"und in Azure Monitor or under the Monitoring  section of the App \\nService settings.  \\n \\nLive debuggi\", \"ng  \\nAzure App Service can be debugged remotely with Visual Studio  when logs don\\u2019t provide enough \\n\", \"information. However, remote debugging requires the app to be compiled with debug symbols. \\nDebuggin\", \"g shouldn\\u2019t be done in production, except as a last resort.  \\n \\n89 CHAPTER 4 | Monitor and debug  \\n \", \"Conclusion  \\nIn this section, you completed the following tasks:  \\n[!div class=\\u201cchecklist\\u201d]  \\n\\u2022 Find\", \" basic monitoring and troubleshooting data in the Azure portal  \\n\\u2022 Learn how Azure Monitor provides \", \"a deeper look at metrics across all Azure services  \\n\\u2022 Connect the web app with Application Insights\", \" for app profiling  \\n\\u2022 Turn on logging and learn where to download logs  \\n\\u2022 Stream logs in real time\", \"  \\n\\u2022 Learn where to set up alerts  \\n\\u2022 Learn about remote debugging Azure App Service web apps.  \\nAdd\", \"itional reading  \\n\\u2022 Troubleshooting ASP.NET Core on Azure App Service and IIS  \\n\\u2022 Common errors refe\", \"rence for Azure App Service and IIS with ASP.NET Core  \\n\\u2022 Monitor Azure web app performance with App\", \"lication Insights  \\n\\u2022 Enable diagnostics logging for web apps in Azure App Service  \\n\\u2022 Troubleshoot \", \"a web app in Azure App Service using Visual Studio  \\n\\u2022 Create classic metric alerts in Azure Monitor\", \" for Azure services - Azure portal   \\n90 CHAPTER 5 | Next steps  \\n CHAPTER  5 \\nNext steps  \\nIn this \", \"guide, you created a DevOps pipeline for an ASP.NET Core sample app. Congratulations! We \\nhope you e\", \"njoyed learning to publish ASP.NET Core web apps to Azure App Service and automate the \\ncontinuous i\", \"ntegration of changes.  \\nBeyond web hosting and DevOps, Azure has a wide array of Platform -as-a-Ser\", \"vice (PaaS) services \\nuseful to ASP.NET Core developers. This section gives a brief overview of some\", \" of the most commonly \\nused services.  \\nStorage and databases  \\nRedis Cache  is high -throughput, lo\", \"w -latency data caching available as a service. It can be used for \\ncaching page output, reducing da\", \"tabase requests, and providing ASP.NET Core session state across \\nmultiple instances of an app.  \\nAz\", \"ure Storage  is Azure\\u2019s massively scalable cloud storage. Developers can take advantage of Queue \\nSt\", \"orage  for reliable message queuing, and Table Storage  is a NoSQL key -value store designed for \\nra\", \"pid development using massive, semi -structured data sets.  \\nAzure SQL Database  provides familiar r\", \"elational database functionality as a service using the Microsoft \\nSQL Server Engine.  \\nCosmos DB  g\", \"lobally distributed, multi -model NoSQL database service. Multiple APIs are available, \\nincluding SQ\", \"L API (formerly called DocumentDB), Cassandra, and MongoDB.  \\nIdentity  \\nAzure Active Directory  and\", \" Azure Active Directory B2C  are both identity services. Azure Active \\nDirectory is designed for ent\", \"erprise scenarios and enables Azure AD B2B (business -to-business) \\ncollaboration, while Azure Activ\", \"e Directory B2C is intended business -to-customer scenarios, including \\nsocial network si gn-in. \\nMo\", \"bile  \\nNotification Hubs  is a multi -platform, scalable push -notification engine to quickly send m\", \"illions of \\nmessages to apps running on various types of devices.   \\n91 CHAPTER 5 | Next steps  \\n We\", \"b infrastructure  \\nAzure Container Service  manages your hosted Kubernetes environment, making it qu\", \"ick and easy to \\ndeploy and manage containerized apps without container orchestration expertise.  \\nA\", \"zure Search  is used to create an enterprise search solution over private, heterogenous content.  \\nS\", \"ervice Fabric  is a distributed systems platform that makes it easy to package, deploy, and manage \\n\", \"scalable and reliable microservices and containers.  \"]"