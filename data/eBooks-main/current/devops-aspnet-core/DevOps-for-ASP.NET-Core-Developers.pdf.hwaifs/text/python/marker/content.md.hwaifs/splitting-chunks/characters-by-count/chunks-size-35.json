"[\"![](_page_0_Picture_0.jpeg)\\n\\n# DevOps for ASP.NET Core Developers\\n\\n![](_page_0_Picture_2.jpeg)\\n\\nCam \", \"Soper Scott Addie Colin Dembovsky\\n\\n![](_page_1_Picture_0.jpeg)\\n\\n#### **EDITION v1.1.0**\\n\\nRefer [chan\", \"gelog](https://aka.ms/devops-ebook-changelog) for the book updates and community contributions.\\n\\nThi\", \"s guide is available as a [downloadable PDF e-book.](https://aka.ms/devopsbook)\\n\\nPUBLISHED BY\\n\\nMicro\", \"soft Developer Division, .NET, and Visual Studio product teams\\n\\nA division of Microsoft Corporation\\n\", \"\\nOne Microsoft Way\\n\\nRedmond, Washington 98052-6399\\n\\nCopyright \\u00a9 2022 by Microsoft Corporation\\n\\nAll r\", \"ights reserved. No part of the contents of this book may be reproduced or transmitted in any form or\", \" by any means without the written permission of the publisher.\\n\\nThis book is provided \\\"as-is\\\" and ex\", \"presses the author's views and opinions. The views, opinions, and information expressed in this book\", \", including URL and other Internet website references, may change without notice.\\n\\nSome examples dep\", \"icted herein are provided for illustration only and are fictitious. No real association or connectio\", \"n is intended or should be inferred.\\n\\nMicrosoft and the trademarks listed at [https://www.microsoft.\", \"com](https://www.microsoft.com/) on the \\\"Trademarks\\\" webpage are trademarks of the Microsoft group o\", \"f companies.\\n\\nMac and macOS are trademarks of Apple Inc.\\n\\nThe Docker whale logo is a registered trad\", \"emark of Docker, Inc. Used by permission.\\n\\nAll other marks and logos are property of their respectiv\", \"e owners.\\n\\n# Credits\\n\\nAuthors:\\n\\n[Cam Soper](https://twitter.com/camsoper)\\n\\n[Scott Addie](https://twi\", \"tter.com/scottaddie)\\n\\n[Colin Dembovsky](https://twitter.com/colindembovsky)\\n\\n# Welcome\\n\\nWelcome to t\", \"he Azure Development Lifecycle guide for .NET! This guide introduces the basic concepts of building \", \"a development lifecycle around Azure using .NET tools and processes. After finishing this guide, you\", \"'ll reap the benefits of a mature DevOps toolchain.\\n\\n# Who this guide is for\\n\\n![](_page_2_Picture_0.\", \"jpeg)\\n\\nYou should be an experienced ASP.NET Core developer (200-300 level). You don't need to know a\", \"nything about Azure, as we'll cover that in this introduction. This guide may also be useful for Dev\", \"Ops engineers who are more focused on operations than development.\\n\\nThis guide targets Windows devel\", \"opers. However, Linux and macOS are fully supported by .NET Core. To adapt this guide for Linux/macO\", \"S, watch for callouts for Linux/macOS differences.\\n\\n# What this guide doesn't cover\\n\\nThis guide is f\", \"ocused on an end-to-end continuous deployment experience for .NET developers. It's not an exhaustive\", \" guide to all things Azure, and it doesn't focus extensively on .NET APIs for Azure services. The em\", \"phasis is all around continuous integration, deployment, monitoring, and debugging. Near the end of \", \"the guide, recommendations for next steps are offered. Included in the suggestions are Azure platfor\", \"m services that are useful to ASP.NET Core developers.\\n\\n# What's in this guide\\n\\n#### **[Tools and do\", \"wnloads](xref:azure/devops/tools-and-downloads)**\\n\\nLearn where to acquire the tools used in this gui\", \"de.\\n\\n#### **[Deploy to App Service](xref:azure/devops/deploy-to-app-service)**\\n\\nLearn the various me\", \"thods for deploying an ASP.NET Core app to Azure App Service.\\n\\n#### **[Continuous integration and de\", \"ployment with Azure DevOps](xref:azure/devops/cicd)**\\n\\nBuild an end-to-end continuous integration an\", \"d deployment solution for your ASP.NET Core app with GitHub, Azure DevOps Services, and Azure.\\n\\n####\", \" **[Continuous integration and deployment with GitHub Actions](xref:azure/devops/github-actions)**\\n\\n\", \"Build an end-to-end continuous integration and deployment solution for your ASP.NET Core app with Gi\", \"tHub, GitHub Actions, and Azure, including code scanning for security and quality using CodeQL.\\n\\n###\", \"# **[Monitor and debug](xref:azure/devops/monitor)**\\n\\nUse Azure's tools to monitor, troubleshoot, an\", \"d tune your application.\\n\\n#### **[Next steps](xref:azure/devops/next-steps)**\\n\\nOther learning paths \", \"for the ASP.NET Core developer learning Azure.\\n\\n# Additional introductory reading\\n\\nIf this is your f\", \"irst exposure to cloud computing, these articles explain the basics.\\n\\n- [What is Cloud Computing?](h\", \"ttps://azure.microsoft.com/overview/what-is-cloud-computing/)\\n- [Examples of Cloud Computing](https:\", \"//azure.microsoft.com/overview/examples-of-cloud-computing/)\\n\\n![](_page_3_Picture_0.jpeg)\\n\\n- [What i\", \"s IaaS?](https://azure.microsoft.com/overview/what-is-iaas/)\\n- [What is PaaS?](https://azure.microso\", \"ft.com/overview/what-is-paas/)\\n\\n# Contents\\n\\n| Tools and downloads                                   \", \"     | 1  |\\n|------------------------------------------------------------|----|\\n| Prerequisites     \", \"                                         | 1  |\\n| Recommended tools (Windows only)                  \", \"         | 1  |\\n| Deploy an app to App Service                               | 3  |\\n| Download and t\", \"est the app                                  | 3  |\\n| Create the Azure App Service Web App          \", \"             | 5  |\\n| Deployment with Visual Studio                              | 6  |\\n| Deployment\", \" slots                                           | 8  |\\n| Summary                                   \", \"                 | 10 |\\n| Additional reading                                         | 10 |\\n| Contin\", \"uous integration and deployment with Azure DevOps    | 11 |\\n| Publish the app's code to GitHub      \", \"                     | 12 |\\n| Disconnect local Git deployment                            | 12 |\\n| Cr\", \"eate an Azure DevOps organization                        | 13 |\\n| Create a team project in Azure Dev\", \"Ops organization         | 13 |\\n| Configure a self-hosted agent if necessary                 | 13 |\\n\", \"| Configure the Azure Pipelines pipeline                     | 14 |\\n| Grant Azure DevOps access to t\", \"he GitHub repository         | 14 |\\n| Create the build definition                                | 1\", \"6 |\\n| Create the release pipeline                                | 18 |\\n| Commit changes to GitHub a\", \"nd automatically deploy to Azure | 22 |\\n| Examine the Azure Pipelines pipeline                      \", \" | 23 |\\n| Build definition                                           | 23 |\\n| Release pipeline      \", \"                                     | 26 |\\n| Additional reading                                    \", \"     | 29 |\\n| Continuous integration and deployment with Azure DevOps    | 30 |\\n| Publish the app's \", \"code to GitHub                           | 30 |\\n| Disconnect local Git deployment                   \", \"         | 31 |\\n\\n| Create an Azure DevOps organization                        | 31 |\\n|--------------\", \"----------------------------------------------|----|\\n| Create a team project in Azure DevOps organiz\", \"ation         | 32 |\\n| Configure a self-hosted agent if necessary                 | 32 |\\n| Configure\", \" the Azure Pipelines pipeline                     | 32 |\\n| Commit changes to GitHub and automaticall\", \"y deploy to Azure | 40 |\\n| Examine the Azure Pipelines pipeline                       | 41 |\\n| Addit\", \"ional reading                                         | 47 |\\n| Continuous integration and deployment\", \" with GitHub Actions  | 48 |\\n| GitHub Actions                                             | 48 |\\n| S\", \"ecure code with CodeQL                                    | 48 |\\n| Compare and contrast GitHub Actio\", \"ns and Azure Pipelines    | 49 |\\n| Continuous integration and deployment with GitHub Actions  | 49 |\", \"\\n| GitHub Actions                                             | 49 |\\n| Secure code with CodeQL      \", \"                              | 50 |\\n| Compare and contrast GitHub Actions and Azure Pipelines    | \", \"50 |\\n| Compare and contrast GitHub Actions and Azure Pipelines    | 50 |\\n| Pipelines as code        \", \"                                  | 50 |\\n| Agents and runners                                       \", \"  | 51 |\\n| Comparison of GitHub Actions and Azure Pipelines           | 52 |\\n| Build a .NET web app \", \"using GitHub Actions                  | 55 |\\n| Workflow structure                                   \", \"      | 55 |\\n| Create a basic build workflow                              | 56 |\\n| Dissect the workf\", \"low file                                  | 58 |\\n| Publish the output                               \", \"          | 59 |\\n| Deploy a .NET web app using GitHub Actions                 | 61 |\\n| Environments \", \"                                              | 61 |\\n| Azure authentication                         \", \"              | 62 |\\n| Add environments                                           | 63 |\\n| Deploy to\", \" staging                                          | 65 |\\n| Deploy to production                     \", \"                  | 68 |\\n| Add a manual queue option                                  | 70 |\\n| Handl\", \"e environment configuration                           |    |\\n\\n| Final workflow file                 \", \"            | 73 |\\n|-------------------------------------------------|----|\\n| Secure .NET Code with \", \"CodeQL and GitHub Actions | 75 |\\n| Create the code scanning workflow               | 76 |\\n| Customiz\", \"e CodeQL settings                       | 79 |\\n| Review the security alerts                      | 8\", \"0 |\\n| Monitor and debug                               | 83 |\\n| Basic monitoring and troubleshooting \", \"           | 83 |\\n| Advanced monitoring                             | 84 |\\n| Profile with Applicatio\", \"n Insights               | 84 |\\n| Logging                                         | 87 |\\n| Log strea\", \"ming                                   | 87 |\\n| Alerts                                          | 88\", \" |\\n| Live debugging                                  | 88 |\\n| Conclusion                            \", \"          | 89 |\\n| Additional reading                              | 89 |\\n| Next steps              \", \"                        | 90 |\\n| Storage and databases                           | 90 |\\n| Identity  \", \"                                      | 90 |\\n| Mobile                                          | 90 \", \"|\\n| Web infrastructure                              | 91 |\\n\\n**CHAPTER** 1\\n\\n# <span id=\\\"page-7-0\\\"></s\", \"pan>Tools and downloads\\n\\nAzure has several interfaces for provisioning and managing resources, such \", \"as the [Azure portal,](https://portal.azure.com/) [Azure](https://docs.microsoft.com/cli/azure/)  [C\", \"LI,](https://docs.microsoft.com/cli/azure/) [Azure PowerShell,](https://docs.microsoft.com/powershel\", \"l/azure/overview) [Azure Cloud Shell,](https://shell.azure.com/bash) and Visual Studio. This guide t\", \"akes a minimalist approach and uses the Azure Cloud Shell whenever possible to reduce the steps requ\", \"ired. However, the Azure portal must be used for some portions.\\n\\n# <span id=\\\"page-7-1\\\"></span>Prereq\", \"uisites\\n\\nThe following subscriptions are required:\\n\\n- Azure If you don't have an account, [get a fre\", \"e trial.](https://azure.microsoft.com/free/dotnet/)\\n- Azure DevOps Services your Azure DevOps subscr\", \"iption and organization is created in Chapter 4.\\n- GitHub If you don't have an account, [sign up for\", \" free.](https://github.com/join)\\n\\nThe following tools are required:\\n\\n- [Git](https://git-scm.com/dow\", \"nloads) A fundamental understanding of Git is recommended for this guide. Review the [Git](https://g\", \"it-scm.com/doc)  [documentation,](https://git-scm.com/doc) specifically [git remote](https://git-scm\", \".com/docs/git-remote) and [git push.](https://git-scm.com/docs/git-push)\\n- [.NET Core SDK](https://d\", \"otnet.microsoft.com/download/) Version 2.1.300 or later is required to build and run the sample app.\", \" If Visual Studio is installed with the **.NET Core cross-platform development** workload, the .NET \", \"Core SDK is already installed.\\n\\nVerify your .NET Core SDK installation. Open a command shell, and ru\", \"n the following command:\\n\\n:::{custom-style=CodeBox} dotnetcli dotnet --version :::\\n\\n# <span id=\\\"page\", \"-7-2\\\"></span>Recommended tools (Windows only)\\n\\n\\u2022 [Visual Studio](https://visualstudio.microsoft.com/\", \")'s robust Azure tools provide a GUI for most of the functionality described in this guide. Any edit\", \"ion of Visual Studio will work, including the free Visual Studio Community Edition. The tutorials ar\", \"e written to demonstrate development, deployment, and DevOps both with and without Visual Studio.\\n\\nC\", \"onfirm that Visual Studio has the following [workloads](https://docs.microsoft.com/visualstudio/inst\", \"all/modify-visual-studio) installed:\\n\\n- ASP.NET and web development\\n- Azure development\\n\\n\\u2013 .NET Core\", \" cross-platform development\\n\\n# <span id=\\\"page-9-0\\\"></span>Deploy an app to App Service\\n\\n[Azure App S\", \"ervice](https://docs.microsoft.com/azure/app-service/) is Azure's web hosting platform. Deploying a \", \"web app to Azure App Service can be done manually or by an automated process. This section of the gu\", \"ide discusses deployment methods that can be triggered manually or by script using the command line,\", \" or triggered manually using Visual Studio.\\n\\nIn this section, you'll accomplish the following tasks:\", \"\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Download and build the sample app.\\n- Create an Azure App Service Web A\", \"pp using the Azure Cloud Shell.\\n- Deploy the sample app to Azure using Git.\\n- Deploy a change to the\", \" app using Visual Studio.\\n- Add a staging slot to the web app.\\n- Deploy an update to the staging slo\", \"t.\\n- <span id=\\\"page-9-1\\\"></span>\\u2022 Swap the staging and production slots.\\n\\n# Download and test the ap\", \"p\\n\\nThe app used in this guide is a pre-built ASP.NET Core app, [Simple Feed Reader](https://github.c\", \"om/dotnet-architecture/simple-feed-reader/). It's an ASP.NET Core Razor Pages app that uses the Micr\", \"osoft.SyndicationFeed.ReaderWriter API to retrieve an RSS/Atom feed and display the news items in a \", \"list.\\n\\nFeel free to review the code, but it's important to understand that there's nothing special a\", \"bout this app. It's just a simple ASP.NET Core app for illustrative purposes.\\n\\nFrom a command shell,\", \" download the code, build the project, and run it as follows.\\n\\n#### **Note**\\n\\nLinux and macOS users \", \"should make appropriate changes for paths, for example, using forward slash (/) rather than back sla\", \"sh (\\\\).\\\\*\\n\\n1. Clone the code to a folder on your local machine.\\n\\n:::{custom-style=CodeBox} console g\", \"it clone https://github.com/dotnet-architecture/simplefeed-reader/ :::\\n\\n2. Change your working folde\", \"r to the *simple-feed-reader* folder that was created.\\n\\n:::{custom-style=CodeBox} console cd .\\\\simpl\", \"e-feed-reader\\\\SimpleFeedReader :::\\n\\n3. Restore the packages, and build the solution.\\n\\n:::{custom-sty\", \"le=CodeBox} dotnetcli dotnet build :::\\n\\n4. Run the app.\\n\\n:::{custom-style=CodeBox} dotnetcli dotnet \", \"run :::\\n\\n5. Open a browser and navigate to http://localhost:5000. The app allows you to type or past\", \"e a syndication feed URL and view a list of news items.\\n\\n![](_page_10_Picture_9.jpeg)\\n\\n6. Once you'r\", \"e satisfied the app is working correctly, shut it down by pressing Ctrl+C in the command shell.\\n\\n# <\", \"span id=\\\"page-11-0\\\"></span>Create the Azure App Service Web App\\n\\nTo deploy the app, you'll need to c\", \"reate an App Service [Web App.](https://docs.microsoft.com/azure/app-service/app-service-web-overvie\", \"w) After creation of the Web App, you'll deploy to it from your local machine using Git.\\n\\n- 1. Sign \", \"in to the [Azure Cloud Shell.](https://shell.azure.com/bash) Note: When you sign in for the first ti\", \"me, Cloud Shell prompts to create a storage account for configuration files. Accept the defaults or \", \"provide a unique name.\\n- 2. Use the Cloud Shell for the following steps.\\n  - a. Declare a variable t\", \"o store your web app's name. The name must be unique to be used in the default URL. Using the \\\\$RAND\", \"OM Bash function to construct the name guarantees uniqueness and results in the format webappname999\", \"99.\\n  - :::{custom-style=CodeBox} console webappname=mywebapp\\\\$RANDOM :::\\n    - b. Create a resource\", \" group. Resource groups provide a means to aggregate Azure resources to be managed as a group.\\n  - :\", \"::{custom-style=CodeBox} azurecli az group create --location centralus --name AzureTutorial :::\\n\\nThe\", \" az command invokes the [Azure CLI.](https://docs.microsoft.com/cli/azure/) The CLI can be run local\", \"ly, but using it in the Cloud Shell saves time and configuration.\\n\\nc. Create an App Service plan in \", \"the S1 tier. An App Service plan is a grouping of web apps that share the same pricing tier. The S1 \", \"tier isn't free, but it's required for the staging slots feature.\\n\\n:::{custom-style=CodeBox} azurecl\", \"i az appservice plan create --name \\\\$webappname - resource-group AzureTutorial --sku S1 :::\\n\\n- d. Cr\", \"eate the web app resource using the App Service plan in the same resource group.\\n- :::{custom-style=\", \"CodeBox} azurecli az webapp create --name \\\\$webappname --resourcegroup AzureTutorial --plan \\\\$webapp\", \"name :::\\n  - e. Set the deployment branch to main in the appsettings configuration.\\n- :::{custom-sty\", \"le=CodeBox} azurecli az webapp config appsettings set --name \\\\$webappname -resource-group AzureTutor\", \"ial --settings DEPLOYMENT\\\\_BRANCH=main :::\\n  - f. Set the deployment credentials. These deployment c\", \"redentials apply to all the web apps in your subscription. Don't use special characters in the user \", \"name.\\n- :::{custom-style=CodeBox} azurecli az webapp deployment user set --user-name REPLACE\\\\_WITH\\\\_\", \"USER\\\\_NAME --password REPLACE\\\\_WITH\\\\_PASSWORD :::\\n\\ng. Configure the web app to accept deployments fr\", \"om local Git and display the *Git deployment URL*. **Note this URL for reference later**.\\n\\n:::{custo\", \"m-style=CodeBox} azurecli echo Git deployment URL: \\\\$(az webapp deployment source config-local-git -\", \"-name \\\\$webappname --resource-group AzureTutorial --query url - output tsv) :::\\n\\nh. Display the *web\", \" app URL*. Browse to this URL to see the blank web app. **Note this URL for reference later**.\\n\\n:::{\", \"custom-style=CodeBox} console echo Web app URL: http://\\\\$webappname.azurewebsites.net :::\\n\\n- 3. Usin\", \"g a command shell on your local machine, navigate to the web app's project folder (for example, \\\\*.-\", \"feed-reader). Execute the following commands to set up Git to push to the deployment URL:\\n  - a. Add\", \" the remote URL to the local repository.\\n\\n:::{custom-style=CodeBox} console git remote add azure-pro\", \"d GIT\\\\_DEPLOYMENT\\\\_URL :::\\n\\nb. Push the local default branch (*main*) to the *azure-prod* remote's d\", \"eployment branch (*main*).\\n\\n:::{custom-style=CodeBox} console git push azure-prod main :::\\n\\nYou'll b\", \"e prompted for the deployment credentials you created earlier. Observe the output in the command she\", \"ll. Azure builds the ASP.NET Core app remotely.\\n\\n4. In a browser, navigate to the *Web app URL* and \", \"note the app has been built and deployed. Additional changes can be committed to the local Git repos\", \"itory with git commit. These changes are pushed to Azure with the preceding git push command.\\n\\n# <sp\", \"an id=\\\"page-12-0\\\"></span>Deployment with Visual Studio\\n\\n#### **Note**\\n\\nThis section applies to Windo\", \"ws only. Linux and macOS users should make the change described in step 2 below. Save the file, and \", \"commit the change to the local repository with git commit. Finally, push the change with git push, a\", \"s in the first section.\\\\*\\n\\nThe app has already been deployed from the command shell. Let's use Visua\", \"l Studio's integrated tools to deploy an update to the app. Behind the scenes, Visual Studio accompl\", \"ishes the same thing as the command line tooling, but within Visual Studio's familiar UI.\\n\\n- 1. Open\", \" *SimpleFeedReader.sln* in Visual Studio.\\n- 2. In Solution Explorer, open *Pages.cshtml*. Change <h2\", \">Simple Feed Reader</h2> to <h2>Simple Feed Reader - V2</h2>.\\n- 3. Press Ctrl+Shift+B to build the a\", \"pp.\\n- 4. In Solution Explorer, right-click on the project and click **Publish**.\\n\\n![](_page_13_Pictu\", \"re_0.jpeg)\\n\\n- 5. Visual Studio can create a new App Service resource, but this update will be publis\", \"hed over the existing deployment. In the **Pick a publish target** dialog, select **App Service** fr\", \"om the list on the left, and then select **Select Existing**. Click **Publish**.\\n- 6. In the **App S\", \"ervice** dialog, confirm that the Microsoft or Organizational account used to create your Azure subs\", \"cription is displayed in the upper right. If it's not, click the drop-down and add it.\\n- 7. Confirm \", \"that the correct Azure **Subscription** is selected. For **View**, select **Resource Group**. Expand\", \" the **AzureTutorial** resource group and then select the existing web app. Click **OK**.\\n\\n![](_page\", \"_13_Picture_4.jpeg)\\n\\nVisual Studio builds and deploys the app to Azure. Browse to the web app URL. V\", \"alidate that the <h2> element modification is live.\\n\\n![](_page_14_Picture_0.jpeg)\\n\\n# <span id=\\\"page-\", \"14-0\\\"></span>Deployment slots\\n\\nDeployment slots support the staging of changes without impacting the\", \" app running in production. Once the staged version of the app is validated by a quality assurance t\", \"eam, the production and staging slots can be swapped. The app in staging is promoted to production i\", \"n this manner. The following steps create a staging slot, deploy some changes to it, and swap the st\", \"aging slot with production after verification.\\n\\n- 1. Sign in to the [Azure Cloud Shell,](https://she\", \"ll.azure.com/bash) if not already signed in.\\n- 2. Create the staging slot.\\n  - a. Create a deploymen\", \"t slot with the name *staging*.\\n  - :::{custom-style=CodeBox} azurecli az webapp deployment slot cre\", \"ate --name \\\\$webappname --resource-group AzureTutorial --slot staging :::\\n    - b. Set the deploymen\", \"t branch to main in the appsettings configuration.\\n  - :::{custom-style=CodeBox} azurecli az webapp \", \"config appsettings set --name \\\\$webappname -resource-group AzureTutorial --slot staging --settings D\", \"EPLOYMENT\\\\_BRANCH=main :::\\n    - c. Configure the staging slot to use deployment from local Git and \", \"get the **staging** deployment URL. **Note this URL for reference later**.\\n  - :::{custom-style=Code\", \"Box} azurecli echo Git deployment URL for staging: \\\\$(az webapp deployment source config-local-git -\", \"-name \\\\$webappname --resource-group AzureTutorial - slot staging --query url --output tsv) :::\\n    -\", \" d. Display the staging slot's URL. Browse to the URL to see the empty staging slot. **Note this URL\", \" for reference later**.\\n\\n- :::{custom-style=CodeBox} console echo Staging web app URL: http://\\\\$weba\", \"ppnamestaging.azurewebsites.net :::\\n- 3. In a text editor or Visual Studio, modify *Pages/Index.csht\", \"ml* again so that the <h2> element reads <h2>Simple Feed Reader - V3</h2> and save the file.\\n- 4. Co\", \"mmit the file to the local Git repository, using either the **Changes** page in Visual Studio's *Tea\", \"m Explorer* tab, or by entering the following using the local machine's command shell:\\n  - :::{custo\", \"m-style=CodeBox} console git commit -a -m \\\"upgraded to V3\\\" :::\\n- 5. Using the local machine's comman\", \"d shell, add the staging deployment URL as a Git remote and push the committed changes:\\n  - a. Add t\", \"he remote URL for staging to the local Git repository.\\n  - :::{custom-style=CodeBox} console git rem\", \"ote add azure-staging <Git\\\\_staging\\\\_deployment\\\\_URL> :::\\n    - b. Push the local default branch (*m\", \"ain*) to the *azure-staging* remote's deployment branch (*main*).\\n  - :::{custom-style=CodeBox} cons\", \"ole git push azure-staging main :::\\n  - Wait while Azure builds and deploys the app.\\n- 6. To verify \", \"that V3 has been deployed to the staging slot, open two browser windows. In one window, navigate to \", \"the original web app URL. In the other window, navigate to the staging web app URL. The production U\", \"RL serves V2 of the app. The staging URL serves V3 of the app.\\n\\n![](_page_15_Picture_11.jpeg)\\n\\n7. In\", \" the Cloud Shell, swap the verified/warmed-up staging slot into production.\\n\\n:::{custom-style=CodeBo\", \"x} azurecli az webapp deployment slot swap --name \\\\$webappname - -resource-group AzureTutorial --slo\", \"t staging :::\\n\\n8. Verify that the swap occurred by refreshing the two browser windows.\\n\\n![](_page_16\", \"_Picture_2.jpeg)\\n\\n# <span id=\\\"page-16-0\\\"></span>Summary\\n\\nIn this section, the following tasks were c\", \"ompleted:\\n\\n- Downloaded and built the sample app.\\n- Created an Azure App Service Web App using the A\", \"zure Cloud Shell.\\n- Deployed the sample app to Azure using Git.\\n- Deployed a change to the app using\", \" Visual Studio.\\n- Added a staging slot to the web app.\\n- Deployed an update to the staging slot.\\n- S\", \"wapped the staging and production slots.\\n\\nIn the next section, you'll learn how to build a DevOps pi\", \"peline with Azure Pipelines.\\n\\n# <span id=\\\"page-16-1\\\"></span>Additional reading\\n\\n- [Web Apps overview\", \"](https://docs.microsoft.com/azure/app-service/app-service-web-overview)\\n- [Build a .NET Core and SQ\", \"L Database web app in Azure App Service](https://docs.microsoft.com/azure/app-service/tutorial-dotne\", \"tcore-sqldb-app)\\n- [Configure deployment credentials for Azure App Service](https://docs.microsoft.c\", \"om/azure/app-service/app-service-deployment-credentials)\\n- [Set up staging environments in Azure App\", \" Service](https://docs.microsoft.com/azure/app-service/web-sites-staged-publishing)\\n\\n# <span id=\\\"pag\", \"e-17-0\\\"></span>Continuous integration and deployment with Azure DevOps\\n\\n#### **Note**\\n\\nThis section \", \"details continuous integration and deployment with Azure DevOps. You can achieve that with GitHub Ac\", \"tions as well. GitHub Actions is a workflow engine built into GitHub that can also be used for conti\", \"nuous integration and deployment. To follow the guide for building and deploying to Azure using GitH\", \"ub, complete the **Publish the app's code to GitHub** and **Disconnect local Git deployment** sectio\", \"ns below and then proceed to the GitHub Actions section.\\n\\nIn the previous chapter, you created a loc\", \"al Git repository for the Simple Feed Reader app. In this chapter, you'll publish that code to a Git\", \"Hub repository and construct an Azure DevOps Services pipeline using Azure Pipelines. The pipeline e\", \"nables continuous builds and deployments of the app. Any commit to the GitHub repository triggers a \", \"build and a deployment to the Azure Web App's staging slot.\\n\\nIn this section, you'll complete the fo\", \"llowing tasks:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Publish the app's code to GitHub\\n- Disconnect local Git \", \"deployment\\n- Create an Azure DevOps organization\\n- Create a team project in Azure DevOps organizatio\", \"n\\n- Configure a self-hosted agent if necessary\\n- Create a build definition\\n- Create a release pipeli\", \"ne\\n- Commit changes to GitHub and automatically deploy to Azure\\n- Examine the Azure Pipelines pipeli\", \"ne\\n\\n# <span id=\\\"page-18-0\\\"></span>Publish the app's code to GitHub\\n\\n- 1. Open a browser window, and \", \"navigate to https://github.com.\\n- 2. Click the **+** drop-down in the header, and select **New repos\", \"itory**:\\n\\n![](_page_18_Picture_3.jpeg)\\n\\n- 1. Select your account in the **Owner** drop-down, and ent\", \"er *simple-feed-reader* in the **Repository name** textbox.\\n- 2. Click the **Create repository** but\", \"ton.\\n- 3. Open your local machine's command shell. Navigate to the directory in which the *simple-fe\", \"edreader* Git repository is stored.\\n- 4. Rename the existing *origin* remote to *upstream*. Execute \", \"the following command:\\n  - :::{custom-style=CodeBox} console git remote rename origin upstream :::\\n-\", \" 5. Add a new *origin* remote pointing to your copy of the repository on GitHub. Execute the followi\", \"ng command:\\n  - :::{custom-style=CodeBox} console git remote add origin https://github.com/<GitHub\\\\_\", \"username>/simple-feed-reader/ :::\\n- 6. Publish your local Git repository to the newly created GitHub\", \" repository. Execute the following command:\\n  - :::{custom-style=CodeBox} console git push -u origin\", \" main :::\\n- 7. Open a browser window, and navigate to https://github.com/<GitHub\\\\_username>/simplefe\", \"ed-reader/. Validate that your code appears in the GitHub repository.\\n\\n# <span id=\\\"page-18-1\\\"></span\", \">Disconnect local Git deployment\\n\\nRemove the local Git deployment with the following steps. Azure Pi\", \"pelines (an Azure DevOps service) both replaces and augments that functionality.\\n\\n1. Open the [Azure\", \" portal,](https://portal.azure.com/) and navigate to the *staging (mywebapp<unique\\\\_number>/staging)\", \"* Web App. The Web App can be quickly located by entering *staging* in the portal's search box: Clic\", \"k **Deployment Center**. A new panel appears. Click **Disconnect** to remove the local Git source co\", \"ntrol configuration that was added in the previous chapter. Confirm the removal operation by clickin\", \"g the **Yes** button.\\n\\n- 1. Navigate to the *mywebapp* App Service. As a reminder, the portal's sear\", \"ch box can be used to quickly locate the App Service.\\n- 2. Click **Deployment Center**. A new panel \", \"appears. Click **Disconnect** to remove the local Git source control configuration that was added in\", \" the previous chapter. Confirm the removal operation by clicking the **Yes** button.\\n\\n# <span id=\\\"pa\", \"ge-19-0\\\"></span>Create an Azure DevOps organization\\n\\n- 1. Open a browser, and navigate to the [Azure\", \" DevOps organization creation page.](https://go.microsoft.com/fwlink/?LinkId=307137)\\n- 2. Select **N\", \"ew organization**\\n- 3. Confirm the information, and then select **Continue**.\\n- <span id=\\\"page-19-1\\\"\", \"></span>4. Sign in to your organization at any time, https://dev.azure.com/{yourorganization}\\n\\n# Cre\", \"ate a team project in Azure DevOps organization\\n\\n- 1. Choose the organization, and then select **New\", \" project**.\\n- 2. Enter the project name as *MyFirstProject* and select the **Visibility** as *Privat\", \"e*\\n- 3. Select **Create project**.\\n\\nFor more information, see [Create a project](https://docs.micros\", \"oft.com/azure/devops/organizations/projects/create-project?view=azure-devops&tabs=preview-page&prese\", \"rve-view=true#create-a-project)\\n\\n# <span id=\\\"page-19-2\\\"></span>Configure a self-hosted agent if nece\", \"ssary\\n\\nTo build your code or deploy your software using Azure Pipelines, you need at least one agent\", \". In Azure Pipelines, you can run parallel jobs on either **Microsoft-hosted** or **self-hosted** ag\", \"ent. But with the recent change in Azure Pipelines free grant of parallel jobs is temporarily disabl\", \"e for the public projects.For more details, refer [Configure and pay for parallel jobs.](https://doc\", \"s.microsoft.com/azure/devops/pipelines/licensing/concurrent-jobs?view=azure-devops&tabs=ms-hosted&pr\", \"eserve-view=true)\\n\\nGo to **Organization Settings** and then **Pipelines** > **Parallel jobs**. If yo\", \"u see value **0** under **Microsofthosted** that means you need a **Self-hosted** agent to run your \", \"pipeline.\\n\\n![](_page_20_Figure_0.jpeg)\\n\\nYou can create that by following details mentioned in [Self-\", \"hosted agents.](https://docs.microsoft.com/azure/devops/pipelines/agents/agents?view=azure-devops&ta\", \"bs=browser&preserve-view=true#install) After successful configuration, you'll be able to see availab\", \"le agent under **Organization Settings** > **Agent pools** > **{youragentname}**\\n\\n![](_page_20_Pictu\", \"re_2.jpeg)\\n\\n# <span id=\\\"page-20-0\\\"></span>Configure the Azure Pipelines pipeline\\n\\nThere are three di\", \"stinct steps to complete. Completing the steps in the following three sections results in an operati\", \"onal DevOps pipeline.\\n\\n#### <span id=\\\"page-20-1\\\"></span>**Grant Azure DevOps access to the GitHub re\", \"pository**\\n\\n1. In your project, navigate to the **Pipelines** page. Then choose the action to create\", \" a new pipeline:\\n\\n![](_page_20_Picture_7.jpeg)\\n\\n1. Use Use the classic editor to create the pipeline\", \".\\n\\n![](_page_21_Figure_1.jpeg)\\n\\n1. Select the **GitHub** option from the **Select a source** section\", \"::\\n\\n![](_page_21_Figure_3.jpeg)\\n\\n1. Authorization is required before Azure DevOps can access your Gi\", \"tHub repository. Enter *GitHub connection* in the **Connection name** textbox. For example:\\n\\n![](_pa\", \"ge_21_Picture_5.jpeg)\\n\\n1. If two-factor authentication is enabled on your GitHub account, a personal\", \" access token is required. In that case, click the **Authorize with a GitHub personal access token**\", \" link. See the [official GitHub personal access token creation instructions](https://help.github.com\", \"/articles/creating-a-personal-access-token-for-the-command-line/) for help. Only the *repo* scope of\", \" permissions is needed. Otherwise, click the **Authorize using OAuth** button.\\n\\n- 2. When prompted, \", \"sign in to your GitHub account. Then select Authorize to grant access to your Azure DevOps organizat\", \"ion. If successful, a new service endpoint is created.\\n- 3. Click the ellipsis button next to the **\", \"Repository** button. Select the */simple-feed-reader* repository from the list. Click the **Select**\", \" button.\\n- 4. Select the default branch (*main*) from the **Default branch for manual and scheduled \", \"builds** drop-down. Click the **Continue** button. The template selection page appears.\\n\\n#### <span \", \"id=\\\"page-22-0\\\"></span>**Create the build definition**\\n\\n1. From the template selection page, enter *A\", \"SP.NET Core* in the search box:\\n\\n![](_page_22_Figure_5.jpeg)\\n\\n- 1. The template search results appea\", \"r. Hover over the **ASP.NET Core** template, and click the **Apply** button.\\n- 2. The **Tasks** tab \", \"of the build definition appears. Select the self-hosted **Agent pool** if you have created that in t\", \"he earlier step.\\n\\n![](_page_22_Figure_8.jpeg)\\n\\n- > [!NOTE]\\n- > If you are using MS-hosted agent then\", \" select the \\\\*Hosted > Azure Pipelines\\\\* from drop down.\\n\\n- 1. Click the **Triggers** tab.\\n- 2. Chec\", \"k the **Enable continuous integration** box. Under the **Branch filters** section, confirm that the \", \"**Type** drop-down is set to *Include*. Set the **Branch specification** drop-down to *main*.\\n\\n![](_\", \"page_23_Picture_2.jpeg)\\n\\nThese settings cause a build to trigger when any change is pushed to the de\", \"fault branch (\\\\*main\\\\*) of the GitHub repository. Continuous integration is tested in the [Commit ch\", \"anges to GitHub and automatically deploy to Azure](#commit-changes-togithub-and-automatical) section\", \".\\n\\n1. Click the **Save & queue** button, and select the **Save** option:\\n\\n![](_page_23_Picture_5.jpe\", \"g)\\n\\n1. The following modal dialog appears:\\n\\n![](_page_23_Picture_7.jpeg)\\n\\nUse the default folder of \", \"\\\\*\\\\\\\\\\\\*, and click the \\\\*\\\\*Save\\\\*\\\\* button.\\n\\n#### <span id=\\\"page-24-0\\\"></span>**Create the release pi\", \"peline**\\n\\n1. Click the **Releases** tab of your team project. Click the **New pipeline** button.\\n\\n![\", \"](_page_24_Picture_2.jpeg)\\n\\nThe template selection pane appears.\\n\\n1. From the template selection pag\", \"e, enter *App Service Deployment* in the search box:\\n\\n![](_page_24_Figure_5.jpeg)\\n\\n1. The template s\", \"earch results appear. Hover over the **Azure App Service Deployment with Slot** template, and click \", \"the **Apply** button. The **Pipeline** tab of the release pipeline appears.\\n\\n![](_page_25_Figure_0.j\", \"peg)\\n\\n1. Click the **Add** button in the **Artifacts** box. The **Add artifact** panel appears:\\n\\n![]\", \"(_page_25_Figure_2.jpeg)\\n\\n- 1. Select the **Build** tile from the **Source type** section. This type\", \" allows for the linking of the release pipeline to the build definition.\\n- 2. Select *MyFirstProject\", \"* from the **Project** drop-down.\\n- 3. Select the build definition name, *MyFirstProject-ASP.NET Cor\", \"e-CI*, from the **Source (Build definition)** drop-down.\\n- 4. Select *Latest* from the **Default ver\", \"sion** drop-down. This option builds the artifacts produced by the latest run of the build definitio\", \"n.\\n\\n- 5. Replace the text in the **Source alias** textbox with *Drop*.\\n- 6. Click the **Add** button\", \". The **Artifacts** section updates to display the changes.\\n- 7. Click the lightning bolt icon to en\", \"able continuous deployments:\\n\\n![](_page_26_Picture_3.jpeg)\\n\\nWith this option enabled, a deployment o\", \"ccurs each time a new build is available.\\n\\n- 1. A **Continuous deployment trigger** panel appears to\", \" the right. Click the toggle button to enable the feature. It isn't necessary to enable the **Pull r\", \"equest trigger**.\\n- 2. Click the **Add** drop-down in the **Build branch filters** section. Choose t\", \"he **Build Definition's default branch** option. This filter causes the release to trigger only for \", \"a build from the GitHub repository's default branch (*main*).\\n- 3. Click the **Save** button. Click \", \"the **OK** button in the resulting **Save** modal dialog.\\n- 4. Click the **Stage 1** box. An **Stage\", \"** panel appears to the right. Change the *Stage 1* text in the **Stage name** textbox to *Productio\", \"n*.\\n\\n![](_page_26_Figure_9.jpeg)\\n\\n1. Click the **1 phase, 2 tasks** link in the **Production** box:\\n\", \"\\n![](_page_27_Picture_0.jpeg)\\n\\nThe \\\\*\\\\*Tasks\\\\*\\\\* tab of the environment appears.\\n\\n- 1. Click the **D\", \"eploy Azure App Service to Slot** task. Its settings appear in a panel to the right.\\n- 2. Select the\", \" Azure subscription associated with the App Service from the **Azure subscription** drop-down. Once \", \"selected, click the **Authorize** button.\\n- 3. Select *Web App* from the **App type** drop-down.\\n- 4\", \". Select *mywebapp/* from the **App service name** drop-down.\\n- 5. Select *AzureTutorial* from the *\", \"*Resource group** drop-down.\\n- 6. Select *staging* from the **Slot** drop-down.\\n- 7. Select **Run on\", \" agent**\\\\* under **Tasks**. On the right pane, you'll see **Agent Job**.\\n- 8. Select the self-hosted\", \" **Agent pool** if you have created that in the earlier step.\\n\\n![](_page_27_Figure_10.jpeg)\\n\\n- > [!N\", \"OTE]\\n- > If you are using MS-hosted agent then select the \\\\*Hosted > Azure Pipelines\\\\* from drop dow\", \"n.\\n  - 1. Click the **Save** button.\\n  - 2. Hover over the default release pipeline name. Click the \", \"pencil icon to edit it. Use *MyFirstProject-ASP.NET Core-CD* as the name.\\n\\n![](_page_28_Figure_0.jpe\", \"g)\\n\\n1. Click the **Save** button.\\n\\n# <span id=\\\"page-28-0\\\"></span>Commit changes to GitHub and automa\", \"tically deploy to Azure\\n\\n- 1. Open *SimpleFeedReader.sln* in Visual Studio.\\n- 2. In Solution Explore\", \"r, open *Pages.cshtml*. Change <h2>Simple Feed Reader V3</h2> to <h2>Simple Feed Reader - V4</h2>.\\n-\", \" 3. Press Ctrl+Shift+B to build the app.\\n- 4. Commit the file to the GitHub repository. Use either t\", \"he **Changes** page in Visual Studio's *Team Explorer* tab, or execute the following using the local\", \" machine's command shell:\\n  - :::{custom-style=CodeBox} console git commit -a -m \\\"upgraded to V4\\\" ::\", \":\\n- 5. Push the change in the default branch (*main*) to the *origin* remote of your GitHub reposito\", \"ry. In the following command, replace the placeholder {BRANCH} with the default branch (use main):\\n \", \" - :::{custom-style=CodeBox} console git push origin {BRANCH} :::\\n\\nThe commit appears in the GitHub \", \"repository's default branch (*main*). You'll be able to see the commit history in https://github.com\", \"/<GitHub\\\\_username>/simple-feedreader/commits/main.\\n\\nThe build is triggered, since continuous integr\", \"ation is enabled in the build definition's **Triggers** tab:\\n\\n![](_page_28_Figure_12.jpeg)\\n\\n1. Navig\", \"ate to the **Pipelines**. You'll see the CI pipeline details and monitor each steps if you drill dow\", \"n **Jobs** details.\\n\\n![](_page_29_Figure_1.jpeg)\\n\\n1. Similarly, go to the **Releases** tab to see th\", \"e details of CD pipeline. You can always drill down further to see more details of each step.\\n\\n![](_\", \"page_29_Figure_3.jpeg)\\n\\n1. Once the build succeeds, a deployment to Azure occurs. Navigate to the ap\", \"p in the browser. Notice that the \\\"V4\\\" text appears in the heading:\\n\\n![](_page_29_Picture_5.jpeg)\\n\\n#\", \" <span id=\\\"page-29-0\\\"></span>Examine the Azure Pipelines pipeline\\n\\n#### <span id=\\\"page-29-1\\\"></span>\", \"**Build definition**\\n\\nA build definition was created with the name *MyFirstProject-ASP.NET Core-CI*.\", \" Upon completion, the build produces a *.zip* file including the assets to be published. The release\", \" pipeline deploys those assets to Azure.\\n\\nThe build definition's **Tasks** tab lists the individual \", \"steps being used. There are five build tasks.\\n\\n![](_page_30_Figure_1.jpeg)\\n\\n- 1. **Restore** Execute\", \"s the dotnet restore command to restore the app's NuGet packages. The default package feed used is n\", \"uget.org.\\n- 2. **Build** Executes the dotnet build --configuration release command to compile the ap\", \"p's code. This --configuration option is used to produce an optimized version of the code, which is \", \"suitable for deployment to a production environment. Modify the *BuildConfiguration* variable on the\", \" build definition's **Variables** tab if, for example, a debug configuration is needed.\\n- 3. **Test*\", \"* Executes the dotnet test --configuration release --logger trx --results-directory <local\\\\_path\\\\_on\", \"\\\\_build\\\\_agent> command to run the app's unit tests. Unit tests are executed within any C# project m\", \"atching the \\\\*\\\\**/*Tests/*.csproj* glob pattern. Test results are saved in a *.trx* file at the loca\", \"tion specified by the --results-directory option. If any tests fail, the build fails and isn't deplo\", \"yed.\\n\\n[!NOTE] To verify the unit tests work, modify *SimpleFeedReader.Tests.cs* to purposefully brea\", \"k one of the tests. For example, change Assert.True(result.Count > 0); to Assert.False(result.Count \", \"> 0); in the Returns\\\\_News\\\\_Stories\\\\_Given\\\\_Valid\\\\_Uri method. Commit and push the change to GitHub.\", \" The build is triggered and fails. The build pipeline status changes to **failed**. Revert the chang\", \"e, commit, and push again. The build succeeds.\\n\\n- 4. **Publish** Executes the dotnet publish --confi\", \"guration release --output <local\\\\_path\\\\_on\\\\_build\\\\_agent> command to produce a *.zip* file with the \", \"artifacts to be deployed. The --output option specifies the publish location of the *.zip* file. Tha\", \"t location is specified by passing a [predefined variable](https://docs.microsoft.com/azure/devops/p\", \"ipelines/build/variables) named \\\\$(build.artifactstagingdirectory). That variable expands to a local\", \" path, such as \\\\*c:\\\\_work\\\\1, on the build agent.\\n- 5. **Publish Artifact** Publishes the *.zip* file\", \" produced by the **Publish** task. The task accepts the *.zip* file location as a parameter, which i\", \"s the predefined variable \\\\$(build.artifactstagingdirectory). The *.zip* file is published as a fold\", \"er named *drop*.\\n\\nClick the build definition's **Summary** link to view a history of builds with the\", \" definition:\\n\\n![](_page_31_Figure_4.jpeg)\\n\\nOn the resulting page, click the individual build for mor\", \"e details.\\n\\n![](_page_31_Picture_6.jpeg)\\n\\nA summary of this specific build is displayed. Click the *\", \"*published** link, and notice the *drop* folder produced by the build is listed:\\n\\n![](_page_32_Figur\", \"e_0.jpeg)\\n\\nUse the ellipsis and click on **Downloads artifacts** links to inspect the published arti\", \"facts.\\n\\n#### <span id=\\\"page-32-0\\\"></span>**Release pipeline**\\n\\nA release pipeline was created with t\", \"he name *MyFirstProject-ASP.NET Core-CD*:\\n\\n![](_page_32_Figure_4.jpeg)\\n\\nThe two major components of \", \"the release pipeline are the **Artifacts** and the **Stages**. Clicking the box in the **Artifacts**\", \" section reveals the following panel:\\n\\n![](_page_33_Figure_0.jpeg)\\n\\nThe **Source (Build definition)*\", \"* value represents the build definition to which this release pipeline is linked. The *.zip* file pr\", \"oduced by a successful run of the build definition is provided to the *Production* environment for d\", \"eployment to Azure. Click the *1 phase, 2 tasks* link in the *Production* environment box to view th\", \"e release pipeline tasks:\\n\\n![](_page_33_Figure_2.jpeg)\\n\\nThe release pipeline consists of two tasks: \", \"*Deploy Azure App Service to Slot* and *Manage Azure App Service - Slot Swap*. Clicking the first ta\", \"sk reveals the following task configuration:\\n\\n![](_page_34_Figure_0.jpeg)\\n\\nThe Azure subscription, s\", \"ervice type, web app name, resource group, and deployment slot are defined in the deployment task. T\", \"he **Package or folder** textbox holds the *.zip* file path to be extracted and deployed to the *sta\", \"ging* slot of the *mywebapp<unique\\\\_number>* web app.\\n\\nClicking the slot swap task reveals the follo\", \"wing task configuration:\\n\\n![](_page_35_Figure_0.jpeg)\\n\\nThe subscription, resource group, service typ\", \"e, web app name, and deployment slot details are provided. The **Swap with Production** check box is\", \" checked. Consequently, the bits deployed to the *staging* slot are swapped into the production envi\", \"ronment.\\n\\n# <span id=\\\"page-35-0\\\"></span>Additional reading\\n\\n- [Create your first pipeline with Azure\", \" Pipelines](https://docs.microsoft.com/azure/devops/pipelines/create-first-pipeline)\\n- [Build and .N\", \"ET Core project](https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core)\\n- [Deploy \", \"a web app with Azure Pipelines](https://docs.microsoft.com/azure/devops/pipelines/targets/webapp)\\n\\n#\", \" <span id=\\\"page-36-0\\\"></span>Continuous integration and deployment with Azure DevOps\\n\\n#### **Note**\\n\", \"\\nThis section details continuous integration and deployment with Azure DevOps. You can achieve that \", \"with GitHub Actions as well. GitHub Actions is a workflow engine built into GitHub that can also be \", \"used for continuous integration and deployment. To follow the guide for building and deploying to Az\", \"ure using GitHub, complete the **Publish the app's code to GitHub** and **Disconnect local Git deplo\", \"yment** sections below and then proceed to the GitHub Actions section.\\n\\nIn the previous chapter, you\", \" created a local Git repository for the Simple Feed Reader app. In this chapter, you'll publish that\", \" code to a GitHub repository and construct an Azure DevOps Services pipeline using Azure Pipelines. \", \"The pipeline enables continuous builds and deployments of the app. Any commit to the GitHub reposito\", \"ry triggers a build and a deployment to the Azure Web App's staging slot.\\n\\nIn this section, you'll c\", \"omplete the following tasks:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Publish the app's code to GitHub\\n- Disconn\", \"ect local Git deployment\\n- Create an Azure DevOps organization\\n- Create a team project in Azure DevO\", \"ps organization\\n- Configure a self-hosted agent if necessary\\n- Create a build definition\\n- Create a \", \"release pipeline\\n- Commit changes to GitHub and automatically deploy to Azure\\n- Examine the Azure Pi\", \"pelines pipeline\\n\\n#### <span id=\\\"page-36-1\\\"></span>**Publish the app's code to GitHub**\\n\\n- 1. Open a\", \" browser window, and navigate to https://github.com.\\n- 2. Click the **+** drop-down in the header, a\", \"nd select **New repository**:\\n\\n![](_page_36_Picture_18.jpeg)\\n\\n- 1. Select your account in the **Owne\", \"r** drop-down, and enter *simple-feed-reader* in the **Repository name** textbox.\\n- 2. Click the **C\", \"reate repository** button.\\n- 3. Open your local machine's command shell. Navigate to the directory i\", \"n which the *simple-feedreader* Git repository is stored.\\n- 4. Rename the existing *origin* remote t\", \"o *upstream*. Execute the following command:\\n  - :::{custom-style=CodeBox} console git remote rename\", \" origin upstream :::\\n- 5. Add a new *origin* remote pointing to your copy of the repository on GitHu\", \"b. Execute the following command:\\n  - :::{custom-style=CodeBox} console git remote add origin https:\", \"//github.com/<GitHub\\\\_username>/simple-feed-reader/ :::\\n- 6. Publish your local Git repository to th\", \"e newly created GitHub repository. Execute the following command:\\n  - :::{custom-style=CodeBox} cons\", \"ole git push -u origin main :::\\n- 7. Open a browser window, and navigate to https://github.com/<GitH\", \"ub\\\\_username>/simplefeed-reader/. Validate that your code appears in the GitHub repository.\\n\\n#### <s\", \"pan id=\\\"page-37-0\\\"></span>**Disconnect local Git deployment**\\n\\nRemove the local Git deployment with \", \"the following steps. Azure Pipelines (an Azure DevOps service) both replaces and augments that funct\", \"ionality.\\n\\n1. Open the [Azure portal,](https://portal.azure.com/) and navigate to the *staging (mywe\", \"bapp<unique\\\\_number>/staging)* Web App. The Web App can be quickly located by entering *staging* in \", \"the portal's search box:\\n\\n![](_page_37_Picture_13.jpeg)\\n\\n- 1. Click **Deployment Center**. A new pan\", \"el appears. Click **Disconnect** to remove the local Git source control configuration that was added\", \" in the previous chapter. Confirm the removal operation by clicking the **Yes** button.\\n- 2. Navigat\", \"e to the *mywebapp* App Service. As a reminder, the portal's search box can be used to quickly locat\", \"e the App Service.\\n- 3. Click **Deployment Center**. A new panel appears. Click **Disconnect** to re\", \"move the local Git source control configuration that was added in the previous chapter. Confirm the \", \"removal operation by clicking the **Yes** button.\\n\\n#### <span id=\\\"page-37-1\\\"></span>**Create an Azur\", \"e DevOps organization**\\n\\n- 1. Open a browser, and navigate to the [Azure DevOps organization creatio\", \"n page.](https://go.microsoft.com/fwlink/?LinkId=307137)\\n- 2. Select **New organization**\\n- 3. Confi\", \"rm the information, and then select **Continue**.\\n\\n4. Sign in to your organization at any time, http\", \"s://dev.azure.com/{yourorganization}\\n\\n#### <span id=\\\"page-38-0\\\"></span>**Create a team project in Az\", \"ure DevOps organization**\\n\\n- 1. Choose the organization, and then select **New project**.\\n- 2. Enter\", \" the project name as *MyFirstProject* and select the **Visibility** as *Private*\\n- 3. Select **Creat\", \"e project**.\\n\\nFor more information, see [Create a project](https://docs.microsoft.com/azure/devops/o\", \"rganizations/projects/create-project?view=azure-devops&tabs=preview-page&preserve-view=true#create-a\", \"-project)\\n\\n#### <span id=\\\"page-38-1\\\"></span>**Configure a self-hosted agent if necessary**\\n\\nTo build\", \" your code or deploy your software using Azure Pipelines, you need at least one agent. In Azure Pipe\", \"lines, you can run parallel jobs on either **Microsoft-hosted** or **self-hosted** agent. But with t\", \"he recent change in Azure Pipelines free grant of parallel jobs is temporarily disable for the publi\", \"c projects.For more details, refer [Configure and pay for parallel jobs.](https://docs.microsoft.com\", \"/azure/devops/pipelines/licensing/concurrent-jobs?view=azure-devops&tabs=ms-hosted&preserve-view=tru\", \"e)\\n\\nGo to **Organization Settings** and then **Pipelines** > **Parallel jobs**. If you see value **0\", \"** under **Microsofthosted** that means you need a **Self-hosted** agent to run your pipeline.\\n\\n![](\", \"_page_38_Picture_9.jpeg)\\n\\nYou can create that by following details mentioned in [Self-hosted agents.\", \"](https://docs.microsoft.com/azure/devops/pipelines/agents/agents?view=azure-devops&tabs=browser&pre\", \"serve-view=true#install) After successful configuration, you'll be able to see available agent under\", \" **Organization Settings** > **Agent pools** > **{youragentname}**\\n\\n![](_page_38_Picture_11.jpeg)\\n\\n#\", \"### <span id=\\\"page-38-2\\\"></span>**Configure the Azure Pipelines pipeline**\\n\\nThere are three distinct\", \" steps to complete. Completing the steps in the following three sections results in an operational D\", \"evOps pipeline.\\n\\n#### **Grant Azure DevOps access to the GitHub repository**\\n\\n1. In your project, na\", \"vigate to the **Pipelines** page. Then choose the action to create a new pipeline:\\n\\n![](_page_39_Pic\", \"ture_2.jpeg)\\n\\n![](_page_39_Picture_5.jpeg)\\n\\n1. Use Use the classic editor to create the pipeline.\\n\\n!\", \"[](_page_39_Picture_7.jpeg)\\n\\n1. Select the **GitHub** option from the **Select a source** section::\\n\", \"\\n![](_page_39_Figure_9.jpeg)\\n\\n1. Authorization is required before Azure DevOps can access your GitHu\", \"b repository. Enter *GitHub connection* in the **Connection name** textbox. For example:\\n\\n![](_page_\", \"40_Figure_0.jpeg)\\n\\n- 1. If two-factor authentication is enabled on your GitHub account, a personal a\", \"ccess token is required. In that case, click the **Authorize with a GitHub personal access token** l\", \"ink. See the [official GitHub personal access token creation instructions](https://help.github.com/a\", \"rticles/creating-a-personal-access-token-for-the-command-line/) for help. Only the *repo* scope of p\", \"ermissions is needed. Otherwise, click the **Authorize using OAuth** button.\\n- 2. When prompted, sig\", \"n in to your GitHub account. Then select Authorize to grant access to your Azure DevOps organization\", \". If successful, a new service endpoint is created.\\n- 3. Click the ellipsis button next to the **Rep\", \"ository** button. Select the */simple-feed-reader* repository from the list. Click the **Select** bu\", \"tton.\\n- 4. Select the default branch (*main*) from the **Default branch for manual and scheduled bui\", \"lds** drop-down. Click the **Continue** button. The template selection page appears.\\n\\n#### **Create \", \"the build definition**\\n\\n1. From the template selection page, enter *ASP.NET Core* in the search box:\", \"\\n\\n![](_page_40_Figure_7.jpeg)\\n\\nThe template search results appear. Hover over the **ASP.NET Core** t\", \"emplate, and click the **Apply** button.\\n\\n1. The **Tasks** tab of the build definition appears. Sele\", \"ct the self-hosted **Agent pool** if you have created that in the earlier step.\\n\\n![](_page_41_Pictur\", \"e_0.jpeg)\\n\\n#### > [!NOTE]\\n\\n- > If you are using MS-hosted agent then select the \\\\*Hosted > Azure Pip\", \"elines\\\\* from drop down.\\n  - 1. Click the **Triggers** tab.\\n  - 2. Check the **Enable continuous int\", \"egration** box. Under the **Branch filters** section, confirm that the **Type** drop-down is set to \", \"*Include*. Set the **Branch specification** drop-down to *main*.\\n\\n![](_page_41_Picture_5.jpeg)\\n\\nThes\", \"e settings cause a build to trigger when any change is pushed to the default branch (\\\\*main\\\\*) of th\", \"e GitHub repository. Continuous integration is tested in the [Commit changes to GitHub and automatic\", \"ally deploy to Azure](#commit-changes-togithub-and-automatical) section.\\n\\n1. Click the **Save & queu\", \"e** button, and select the **Save** option:\\n\\n![](_page_42_Picture_0.jpeg)\\n\\n1. The following modal di\", \"alog appears:\\n\\n![](_page_42_Picture_2.jpeg)\\n\\nUse the default folder of \\\\*\\\\\\\\\\\\*, and click the \\\\*\\\\*Sav\", \"e\\\\*\\\\* button.\\n\\n#### **Create the release pipeline**\\n\\n1. Click the **Releases** tab of your team proj\", \"ect. Click the **New pipeline** button.\\n\\n![](_page_42_Picture_6.jpeg)\\n\\nThe template selection pane a\", \"ppears.\\n\\n1. From the template selection page, enter *App Service Deployment* in the search box:\\n\\n![]\", \"(_page_43_Figure_2.jpeg)\\n\\n1. The template search results appear. Hover over the **Azure App Service \", \"Deployment with Slot** template, and click the **Apply** button. The **Pipeline** tab of the release\", \" pipeline appears.\\n\\n![](_page_43_Figure_4.jpeg)\\n\\n1. Click the **Add** button in the **Artifacts** bo\", \"x. The **Add artifact** panel appears:\\n\\n![](_page_43_Picture_6.jpeg)\\n\\n- 1. Select the **Build** tile\", \" from the **Source type** section. This type allows for the linking of the release pipeline to the b\", \"uild definition.\\n- 2. Select *MyFirstProject* from the **Project** drop-down.\\n- 3. Select the build \", \"definition name, *MyFirstProject-ASP.NET Core-CI*, from the **Source (Build definition)** drop-down.\", \"\\n- 4. Select *Latest* from the **Default version** drop-down. This option builds the artifacts produ\", \"ced by the latest run of the build definition.\\n- 5. Replace the text in the **Source alias** textbox\", \" with *Drop*.\\n- 6. Click the **Add** button. The **Artifacts** section updates to display the change\", \"s.\\n- 7. Click the lightning bolt icon to enable continuous deployments:\\n\\n![](_page_44_Picture_7.jpeg\", \")\\n\\nWith this option enabled, a deployment occurs each time a new build is available.\\n\\n- 1. A **Conti\", \"nuous deployment trigger** panel appears to the right. Click the toggle button to enable the feature\", \". It isn't necessary to enable the **Pull request trigger**.\\n- 2. Click the **Add** drop-down in the\", \" **Build branch filters** section. Choose the **Build Definition's default branch** option. This fil\", \"ter causes the release to trigger only for a build from the GitHub repository's default branch (*mai\", \"n*).\\n- 3. Click the **Save** button. Click the **OK** button in the resulting **Save** modal dialog.\", \"\\n- 4. Click the **Stage 1** box. An **Stage** panel appears to the right. Change the *Stage 1* text \", \"in the **Stage name** textbox to *Production*.\\n\\n![](_page_45_Figure_0.jpeg)\\n\\n1. Click the **1 phase,\", \" 2 tasks** link in the **Production** box:\\n\\n![](_page_45_Picture_2.jpeg)\\n\\nThe \\\\*\\\\*Tasks\\\\*\\\\* tab of t\", \"he environment appears.\\n\\n- 1. Click the **Deploy Azure App Service to Slot** task. Its settings appe\", \"ar in a panel to the right.\\n- 2. Select the Azure subscription associated with the App Service from \", \"the **Azure subscription** drop-down. Once selected, click the **Authorize** button.\\n- 3. Select *We\", \"b App* from the **App type** drop-down.\\n- 4. Select *mywebapp/* from the **App service name** drop-d\", \"own.\\n- 5. Select *AzureTutorial* from the **Resource group** drop-down.\\n- 6. Select *staging* from t\", \"he **Slot** drop-down.\\n- 7. Select **Run on agent**\\\\* under **Tasks**. On the right pane, you'll see\", \" **Agent Job**.\\n- 8. Select the self-hosted **Agent pool** if you have created that in the earlier s\", \"tep.\\n\\n![](_page_45_Picture_12.jpeg)\\n\\n- > [!NOTE]\\n- > If you are using MS-hosted agent then select th\", \"e \\\\*Hosted > Azure Pipelines\\\\* from drop down.\\n  - 1. Click the **Save** button.\\n  - 2. Hover over t\", \"he default release pipeline name. Click the pencil icon to edit it. Use *MyFirstProject-ASP.NET Core\", \"-CD* as the name.\\n\\n![](_page_46_Picture_4.jpeg)\\n\\n1. Click the **Save** button.\\n\\n#### <span id=\\\"page-\", \"46-0\\\"></span>**Commit changes to GitHub and automatically deploy to Azure**\\n\\n- 1. Open *SimpleFeedRe\", \"ader.sln* in Visual Studio.\\n- 2. In Solution Explorer, open *Pages.cshtml*. Change <h2>Simple Feed R\", \"eader V3</h2> to <h2>Simple Feed Reader - V4</h2>.\\n- 3. Press Ctrl+Shift+B to build the app.\\n- 4. Co\", \"mmit the file to the GitHub repository. Use either the **Changes** page in Visual Studio's *Team Exp\", \"lorer* tab, or execute the following using the local machine's command shell:\\n  - :::{custom-style=C\", \"odeBox} console git commit -a -m \\\"upgraded to V4\\\" :::\\n- 5. Push the change in the default branch (*m\", \"ain*) to the *origin* remote of your GitHub repository. In the following command, replace the placeh\", \"older {BRANCH} with the default branch (use main):\\n  - :::{custom-style=CodeBox} console git push or\", \"igin {BRANCH} :::\\n\\nThe commit appears in the GitHub repository's default branch (*main*). You'll be \", \"able to see the commit history in https://github.com/<GitHub\\\\_username>/simple-feedreader/commits/ma\", \"in.\\n\\nThe build is triggered, since continuous integration is enabled in the build definition's **Tri\", \"ggers** tab:\\n\\n![](_page_46_Figure_16.jpeg)\\n\\n1. Navigate to the **Pipelines**. You'll see the CI pipe\", \"line details and monitor each steps if you drill down **Jobs** details.\\n\\n![](_page_47_Figure_1.jpeg)\", \"\\n\\n1. Similarly, go to the **Releases** tab to see the details of CD pipeline. You can always drill d\", \"own further to see more details of each step.\\n\\n![](_page_47_Figure_3.jpeg)\\n\\n1. Once the build succee\", \"ds, a deployment to Azure occurs. Navigate to the app in the browser. Notice that the \\\"V4\\\" text appe\", \"ars in the heading:\\n\\n![](_page_47_Picture_5.jpeg)\\n\\n#### <span id=\\\"page-47-0\\\"></span>**Examine the Az\", \"ure Pipelines pipeline**\\n\\n#### **Build definition**\\n\\nA build definition was created with the name *M\", \"yFirstProject-ASP.NET Core-CI*. Upon completion, the build produces a *.zip* file including the asse\", \"ts to be published. The release pipeline deploys those assets to Azure.\\n\\nThe build definition's **Ta\", \"sks** tab lists the individual steps being used. There are five build tasks.\\n\\n![](_page_48_Figure_1.\", \"jpeg)\\n\\n- 1. **Restore** Executes the dotnet restore command to restore the app's NuGet packages. The\", \" default package feed used is nuget.org.\\n- 2. **Build** Executes the dotnet build --configuration re\", \"lease command to compile the app's code. This --configuration option is used to produce an optimized\", \" version of the code, which is suitable for deployment to a production environment. Modify the *Buil\", \"dConfiguration* variable on the build definition's **Variables** tab if, for example, a debug config\", \"uration is needed.\\n- 3. **Test** Executes the dotnet test --configuration release --logger trx --res\", \"ults-directory <local\\\\_path\\\\_on\\\\_build\\\\_agent> command to run the app's unit tests. Unit tests are e\", \"xecuted within any C# project matching the \\\\*\\\\**/*Tests/*.csproj* glob pattern. Test results are sav\", \"ed in a *.trx* file at the location specified by the --results-directory option. If any tests fail, \", \"the build fails and isn't deployed.\\n\\n[!NOTE] To verify the unit tests work, modify *SimpleFeedReader\", \".Tests.cs* to purposefully break one of the tests. For example, change Assert.True(result.Count > 0)\", \"; to Assert.False(result.Count > 0); in the Returns\\\\_News\\\\_Stories\\\\_Given\\\\_Valid\\\\_Uri method. Commit\", \" and push the change to GitHub. The build is triggered and fails. The build pipeline status changes \", \"to **failed**. Revert the change, commit, and push again. The build succeeds.\\n\\n- 4. **Publish** Exec\", \"utes the dotnet publish --configuration release --output <local\\\\_path\\\\_on\\\\_build\\\\_agent> command to \", \"produce a *.zip* file with the artifacts to be deployed. The --output option specifies the publish l\", \"ocation of the *.zip* file. That location is specified by passing a [predefined variable](https://do\", \"cs.microsoft.com/azure/devops/pipelines/build/variables) named \\\\$(build.artifactstagingdirectory). T\", \"hat variable expands to a local path, such as \\\\*c:\\\\_work\\\\1, on the build agent.\\n- 5. **Publish Artif\", \"act** Publishes the *.zip* file produced by the **Publish** task. The task accepts the *.zip* file l\", \"ocation as a parameter, which is the predefined variable \\\\$(build.artifactstagingdirectory). The *.z\", \"ip* file is published as a folder named *drop*.\\n\\nClick the build definition's **Summary** link to vi\", \"ew a history of builds with the definition:\\n\\n![](_page_49_Figure_4.jpeg)\\n\\nOn the resulting page, cli\", \"ck the individual build for more details.\\n\\n![](_page_49_Picture_6.jpeg)\\n\\nA summary of this specific \", \"build is displayed. Click the **published** link, and notice the *drop* folder produced by the build\", \" is listed:\\n\\n![](_page_50_Figure_0.jpeg)\\n\\nUse the ellipsis and click on **Downloads artifacts** link\", \"s to inspect the published artifacts.\\n\\n#### **Release pipeline**\\n\\nA release pipeline was created wit\", \"h the name *MyFirstProject-ASP.NET Core-CD*:\\n\\n![](_page_50_Figure_4.jpeg)\\n\\nThe two major components \", \"of the release pipeline are the **Artifacts** and the **Stages**. Clicking the box in the **Artifact\", \"s** section reveals the following panel:\\n\\n![](_page_51_Figure_0.jpeg)\\n\\nThe **Source (Build definitio\", \"n)** value represents the build definition to which this release pipeline is linked. The *.zip* file\", \" produced by a successful run of the build definition is provided to the *Production* environment fo\", \"r deployment to Azure. Click the *1 phase, 2 tasks* link in the *Production* environment box to view\", \" the release pipeline tasks:\\n\\n![](_page_51_Figure_2.jpeg)\\n\\nThe release pipeline consists of two task\", \"s: *Deploy Azure App Service to Slot* and *Manage Azure App Service - Slot Swap*. Clicking the first\", \" task reveals the following task configuration:\\n\\n![](_page_52_Figure_0.jpeg)\\n\\nThe Azure subscription\", \", service type, web app name, resource group, and deployment slot are defined in the deployment task\", \". The **Package or folder** textbox holds the *.zip* file path to be extracted and deployed to the *\", \"staging* slot of the *mywebapp<unique\\\\_number>* web app.\\n\\nClicking the slot swap task reveals the fo\", \"llowing task configuration:\\n\\n![](_page_53_Figure_0.jpeg)\\n\\nThe subscription, resource group, service \", \"type, web app name, and deployment slot details are provided. The **Swap with Production** check box\", \" is checked. Consequently, the bits deployed to the *staging* slot are swapped into the production e\", \"nvironment.\\n\\n#### <span id=\\\"page-53-0\\\"></span>**Additional reading**\\n\\n- [Create your first pipeline \", \"with Azure Pipelines](https://docs.microsoft.com/azure/devops/pipelines/create-first-pipeline)\\n- [Bu\", \"ild and .NET Core project](https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core)\\n\", \"- [Deploy a web app with Azure Pipelines](https://docs.microsoft.com/azure/devops/pipelines/targets/\", \"webapp)\\n\\n# <span id=\\\"page-54-0\\\"></span>Continuous integration and deployment with GitHub Actions\\n\\nGi\", \"tHub has long been the home for millions of open-source developers around the globe. Most developers\", \" associate source control with GitHub. However, GitHub is an evolving platform that can be used for \", \"more than just synchronizing Git repositories.\\n\\n#### <span id=\\\"page-54-1\\\"></span>**GitHub Actions**\\n\", \"\\nGitHub Actions is a workflow engine that can automate workflows for nearly all events that occur on\", \" GitHub. Actions is a great solution for Continuous Integration/Continuous Deployment (CI/CD) pipeli\", \"nes.\\n\\nIn this section of articles, you'll learn how to create an Actions workflow. The workflow will\", \" build, test, and deploy a .NET web app to Azure Web Apps.\\n\\n#### **Note**\\n\\nBefore you begin, complet\", \"e the **Publish the app's code to GitHub** and **Disconnect local Git deployment** sections of the C\", \"ontinuous integration and deployment with Azure DevOps section to publish your code to GitHub. Then \", \"proceed to the Build article.\\n\\nIn the Build article, you'll create the initial workflow to build and\", \" test the .NET app. You'll:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Learn the basic structure of a GitHub Actio\", \"n workflow YAML file.\\n- Use a template to create a basic build workflow that builds a .NET app and e\", \"xecutes unit tests.\\n- Publish the compiled app so that it's ready for deployment.\\n\\nIn the Deploy art\", \"icle, you'll:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Learn about environments in GitHub Actions.\\n- Create two \", \"environments and specify environment protection rules.\\n- Create environment secrets for managing env\", \"ironment-specific configuration.\\n- Extend the workflow YAML file to add deployment steps.\\n- Add a ma\", \"nual dispatch trigger.\\n\\n#### <span id=\\\"page-54-2\\\"></span>**Secure code with CodeQL**\\n\\nIn addition to\", \" building and deploying code, [GitHub Advanced Security](https://docs.github.com/github/getting-star\", \"ted-with-github/about-github-advanced-security) offers tools for \\\"shifting left\\\" with security. That\", \" is, integrating security early on in the software delivery lifecycle. [CodeQL](https://codeql.githu\", \"b.com/docs/codeql-overview/about-codeql/) is a code scanning language that runs queries to find pote\", \"ntial vulnerabilities or quality issues in your code. CodeQL is run using an Actions workflow.\\n\\nIn t\", \"he CodeQL article, you'll:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Create a Code Scanning Action.\\n- Edit the wo\", \"rkflow file to include custom scan settings.\\n- See scanning results.\\n\\n#### <span id=\\\"page-55-0\\\"></sp\", \"an>**Compare and contrast GitHub Actions and Azure Pipelines**\\n\\nGitHub Actions and Azure Pipelines h\", \"ave a common lineage and are similar in many respects. However, you should understand the difference\", \"s before selecting a platform for building, testing, and deploying apps. In the Comparison article, \", \"you'll deep dive into these platforms and compare and contrast them. You'll also learn how to select\", \" the correct platform for your CI/CD needs.\\n\\n# <span id=\\\"page-55-1\\\"></span>Continuous integration an\", \"d deployment with GitHub Actions\\n\\nGitHub has long been the home for millions of open-source develope\", \"rs around the globe. Most developers associate source control with GitHub. However, GitHub is an evo\", \"lving platform that can be used for more than just synchronizing Git repositories.\\n\\n#### <span id=\\\"p\", \"age-55-2\\\"></span>**GitHub Actions**\\n\\nGitHub Actions is a workflow engine that can automate workflows\", \" for nearly all events that occur on GitHub. Actions is a great solution for Continuous Integration/\", \"Continuous Deployment (CI/CD) pipelines.\\n\\nIn this section of articles, you'll learn how to create an\", \" Actions workflow. The workflow will build, test, and deploy a .NET web app to Azure Web Apps.\\n\\n####\", \" **Note**\\n\\nBefore you begin, complete the **Publish the app's code to GitHub** and **Disconnect loca\", \"l Git deployment** sections of the Continuous integration and deployment with Azure DevOps section t\", \"o publish your code to GitHub. Then proceed to the Build article.\\n\\nIn the Build article, you'll crea\", \"te the initial workflow to build and test the .NET app. You'll:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Learn t\", \"he basic structure of a GitHub Action workflow YAML file.\\n- Use a template to create a basic build w\", \"orkflow that builds a .NET app and executes unit tests.\\n- Publish the compiled app so that it's read\", \"y for deployment.\\n\\nIn the Deploy article, you'll:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n\\u2022 Learn about environme\", \"nts in GitHub Actions.\\n\\n- Create two environments and specify environment protection rules.\\n- Create\", \" environment secrets for managing environment-specific configuration.\\n- Extend the workflow YAML fil\", \"e to add deployment steps.\\n- Add a manual dispatch trigger.\\n\\n#### <span id=\\\"page-56-0\\\"></span>**Secu\", \"re code with CodeQL**\\n\\nIn addition to building and deploying code, [GitHub Advanced Security](https:\", \"//docs.github.com/github/getting-started-with-github/about-github-advanced-security) offers tools fo\", \"r \\\"shifting left\\\" with security. That is, integrating security early on in the software delivery lif\", \"ecycle. [CodeQL](https://codeql.github.com/docs/codeql-overview/about-codeql/) is a code scanning la\", \"nguage that runs queries to find potential vulnerabilities or quality issues in your code. CodeQL is\", \" run using an Actions workflow.\\n\\nIn the CodeQL article, you'll:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Create \", \"a Code Scanning Action.\\n- Edit the workflow file to include custom scan settings.\\n- See scanning res\", \"ults.\\n\\n#### <span id=\\\"page-56-1\\\"></span>**Compare and contrast GitHub Actions and Azure Pipelines**\\n\", \"\\nGitHub Actions and Azure Pipelines have a common lineage and are similar in many respects. However,\", \" you should understand the differences before selecting a platform for building, testing, and deploy\", \"ing apps. In the Comparison article, you'll deep dive into these platforms and compare and contrast \", \"them. You'll also learn how to select the correct platform for your CI/CD needs.\\n\\n# <span id=\\\"page-5\", \"6-2\\\"></span>Compare and contrast GitHub Actions and Azure Pipelines\\n\\n[GitHub Actions](https://docs.g\", \"ithub.com/actions) and [Azure Pipelines](https://docs.microsoft.com/azure/devops/pipelines/get-start\", \"ed/what-is-azure-pipelines) have a common history. In fact, the Actions agent is a fork of the Pipel\", \"ines agent. There are many similarities between GitHub Actions and Azure Pipelines and it's worth co\", \"mparing and contrasting them.\\n\\n#### <span id=\\\"page-56-3\\\"></span>**Pipelines as code**\\n\\nBefore you co\", \"mpare GitHub Actions and Azure Pipelines, you should consider the benefits of *pipelines as code*. P\", \"ipelines as code:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Benefit from standard source control practices (such \", \"as code reviews via pull request and versioning).\\n- Can be audited for changes just like any other f\", \"iles in the repository.\\n- Don't require accessing a separate system or UI to edit.\\n- Can fully codif\", \"y the build, test, and deploy process for code.\\n\\n\\u2022 Can usually be templatized to empower teams to cr\", \"eate standard processes across multiple repositories.\\n\\n#### **Note**\\n\\nThe term \\\"pipelines\\\" can also \", \"be referred to by several different interchangeable words: *pipeline*, *workflow*, and *build* are c\", \"ommon terms. In this article, references to *Azure Pipelines* are referring to [YAML Pipelines,](htt\", \"ps://docs.microsoft.com/azure/devops/pipelines/get-started/pipelines-get-started?view=azure-devops&p\", \"reserve-view=true#define-pipelines-using-yaml-syntax) and not the older UI-based [Classic Pipelines.\", \"](https://docs.microsoft.com/azure/devops/pipelines/get-started/pipelines-get-started?view=azure-dev\", \"ops&preserve-view=true#define-pipelines-using-the-classic-interface)\\n\\n#### <span id=\\\"page-57-0\\\"></sp\", \"an>**Agents and runners**\\n\\nBefore you examine pipelines themselves, you should consider how these pi\", \"pelines *execute*. Both GitHub Actions and Azure Pipelines are really *orchestration engines*. When \", \"a pipeline is triggered, the system finds an \\\"agent\\\" and tells the agent to execute the jobs defined\", \" in the pipeline file.\\n\\nAzure Pipelines run on *agents*. The agent is written in .NET, so it will ru\", \"n wherever .NET can run: Windows, macOS, and Linux. Agents can even run in containers. Agents are re\", \"gistered to a [pool](https://docs.microsoft.com/azure/devops/pipelines/agents/pools-queues) in Azure\", \" Pipelines or to a repository or organization in GitHub. Agents can be *hosted* or *private*.\\n\\nGitHu\", \"b Workflows execute on *runners*. The runner code is essentially a fork of the Azure Pipelines code,\", \" so it's very similar. It's also cross-platform and you can also use *hosted* or *self-hosted* runne\", \"rs.\\n\\n#### **Hosted agents and runners**\\n\\nHosted agents (Azure Pipelines) and hosted runners (GitHub)\", \" are agents that are spun up and managed by Azure DevOps or GitHub respectively. You don't need to m\", \"aintain any build infrastructure. When a pipeline triggers that targets a hosted agent, an instance \", \"of the specified agent image is created. The job is run by the agent on the instance, and once the j\", \"ob completes, the instance is destroyed. The same applies for hosted runners running GitHub workflow\", \"s.\\n\\n#### **Note**\\n\\nThe list of software installed on Azure Pipelines images is listed in [this repos\", \"itory.](https://github.com/actions/virtual-environments/tree/main/images) You can select the platfor\", \"m folder and examine the *README.md* files. You can find information on [GitHub hosted](https://docs\", \".github.com/actions/reference/specifications-for-github-hosted-runners)  [runners.](https://docs.git\", \"hub.com/actions/reference/specifications-for-github-hosted-runners)\\n\\n#### **Private agents and self-\", \"hosted runners**\\n\\nThere are times when you can't use hosted images. For example, when you:\\n\\n- Requir\", \"e SDKs or other software that isn't installed on the images.\\n- Need to access resources that aren't \", \"public (such as an internal SonarQube server or an internal Artifactory instance).\\n- Need to deploy \", \"to private networks.\\n- Need to install licenses for third-party software required for building your \", \"code.\\n- Need more storage or memory than is provided to the hosted agent images.\\n- Need more time th\", \"an the maximum build time limit for hosted agents.\\n\\n#### **Important**\\n\\nIt's possible to install too\", \"ls and SDKs when running pipelines on hosted agents. If the install steps don't take long, this is v\", \"iable. However, if the tools/software take a long time to install, then you may be better off with a\", \" private agent or self-hosted runner, since the install steps will need to execute for every run of \", \"the workflow.\\n\\n#### **Azure DevOps agents**\\n\\nEvery Azure DevOps account has a hosted pool with a sin\", \"gle agent that can run one job at a time. Also included is a set number of free build minutes. You m\", \"ay purchase additional \\\"hosted pipelines\\\" in Azure DevOps. When you purchase an additional hosted pi\", \"peline, you're really removing the build minutes limit and adding *concurrency*. One pipeline can ru\", \"n one job at a time. Two pipelines can run two jobs simultaneously, and so on.\\n\\n#### **Comparison of\", \" agents**\\n\\n| Feature                                        | GitHub                                \", \"                                                                                                    \", \"                                       | Azure Pipelines                                            \", \"                                                                                                    \", \"                                                                                                    \", \"                                              | Links                                           |\\n|-\", \"-----------------------------------------------|----------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"--------------------------|-------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"---------------------------------|-------------------------------------------------|\\n| Hosted agents\", \" for<br>public<br>repos/projects  | Free                                                            \", \"                                                                                                    \", \"             | Up to 10 free Microsoft-hosted parallel jobs<br>that can run for up to 360 minutes (6\", \" hours)<br>each time with no overall time limit per<br>month. You aren't given this free grant by<br\", \">default, you have to submit a request                                                              \", \"                    | Azure<br>Pipelines<br>GitHub                    |\\n| Hosted agents for<br>priva\", \"te<br>repos/projects | 2,000 minutes<br>free per month,<br>3,000 minutes<br>for Pro and<br>Team lice\", \"nses,<br>50,000 minutes<br>for Enterprise<br>license.<br>Additional<br>minutes may be<br>purchased. \", \"| One free parallel job that can run for up to<br>60 minutes each time, until you've used<br>1,800 m\", \"inutes (30 hours) per month. You<br>can pay for additional capacity per parallel<br>job. Paid parall\", \"el jobs remove the monthly<br>time limit and allow you to run each job for<br>up to 360 minutes (6 h\", \"ours). |                                                 |\\n| Cross-platform                         \", \"        | Yes                                                                                       \", \"                                                                                       | Yes        \", \"                                                                                                    \", \"                                                                                                    \", \"                                                                                              |     \", \"                                            |\\n| Scale set agents                               | No \", \"                                                                                                    \", \"                                                                          | Yes                     \", \"                                                                                                    \", \"                                                                                                    \", \"                                                                                 | Azure virtual<br>\", \"machine<br>scale set<br>agents |\\n\\n#### <span id=\\\"page-58-0\\\"></span>**Comparison of GitHub Actions an\", \"d Azure Pipelines**\\n\\nAzure Pipelines (YAML pipelines) provide a mature set of features. Some of the \", \"features include:\\n\\n- Approvals\\n- Artifact storage\\n\\n- Deployment jobs\\n- Environments\\n- Gates\\n- Stages\", \"\\n- Templates\\n- Triggers\\n- Variable groups\\n\\nFor a full list of Azure Pipelines features, refer to the\", \" [Feature availability](https://docs.microsoft.com/azure/devops/pipelines/get-started/pipelines-get-\", \"started?view=azure-devops&preserve-view=true#feature-availability) table.\\n\\nGitHub Actions are evolvi\", \"ng rapidly and provide features such as triggers for almost all GitHub events, artifact storage, env\", \"ironments and environment rules, starter templates, and matrices. Read more about the entire feature\", \" set refer [GitHub Actions.](https://docs.github.com/actions)\\n\\n#### **Feature comparison**\\n\\nThe foll\", \"owing table is current as of January 2023 and is not an exhaustive list of features.\\n\\n| Feature     \", \"         | Description                                                               | GitHub Action\", \"s | Azure Pipelines |\\n|----------------------|------------------------------------------------------\", \"---------------------|----------------|-----------------|\\n| Approvals            | Define approval<b\", \"r>conditions before<br>moving further in the<br>pipeline | Yes            | Yes             |\\n| Arti\", \"facts            | Upload, store, and<br>download artifacts<br>from jobs                     | Yes  \", \"          | Yes             |\\n| Caching              | Cache folders or files<br>for subsequent runs\", \"                             | Yes            | Yes             |\\n| Conditions           | Specify c\", \"onditions<br>for steps or jobs                                   | Yes            | Yes             \", \"|\\n| Container<br>Jobs    | Run jobs inside a<br>container                                           \", \" | Yes            | Yes             |\\n| Demands              | Specify demands<br>that must be met t\", \"o<br>match jobs to agents            | Yes            | Yes             |\\n| Dependenci<br>es     | S\", \"pecify<br>dependencies<br>between jobs or<br>stages                      | Yes            | Yes     \", \"        |\\n| Deployment<br>Groups | A logical set of target<br>machines for<br>deployments           \", \"         | No             | Yes             |\\n| Deployment<br>Jobs   | Job that targets a<br>deploym\", \"ent group                                    | No             | Yes             |\\n\\n| Feature        \", \"                                          | Description                                             \", \"                                                             | GitHub Actions | Azure Pipelines |\\n|-\", \"---------------------------------------------------------|------------------------------------------\", \"----------------------------------------------------------------------------|----------------|------\", \"-----------|\\n| Environment<br>s                                         | A collection of<br>resourc\", \"es to target<br>or a logical<br>environment                                                | Yes    \", \"        | Yes             |\\n| Gates/Check<br>s                                         | Automatic c\", \"ollection<br>and evaluation of<br>signals to control<br>continuation                                \", \"      | Yes            | Yes             |\\n| Jobs                                                   \", \"  | Sequence of steps<br>that are executed on<br>an agent                                           \", \"                     | Yes            | Yes             |\\n| Service<br>Containers                   \", \"                 | Manage the lifecycle<br>of a containerized<br>service instance<br>available durin\", \"g a<br>job                          | Yes            | Yes             |\\n| Service<br>Connections   \", \"                                | Abstract credentials<br>to external systems                       \", \"                                                   | No             | Yes             |\\n| Passwordle\", \"s<br>s<br>connections<br>to cloud<br>providers | Provide technologies<br>and support use<br>cases th\", \"at reduce<br>and potentially<br>eliminate the use of<br>passwords | Yes            | No             \", \" |\\n| Stages                                                   | Group jobs in a<br>pipeline         \", \"                                                                                 | No             | \", \"Yes             |\\n| Templates                                                | Define reusable,<br>p\", \"arameterized<br>building blocks for<br>steps, jobs, or<br>variables                             | Ye\", \"s            | Yes             |\\n| Starter<br>Templates                                     | Define\", \"s a starter<br>workflow based on<br>the type of code<br>detected in a<br>repository                 \", \"           | Yes            | No              |\\n| Triggers                                          \", \"       | Set of events that<br>cause the pipeline to<br>trigger                                     \", \"                          | Yes            | Yes             |\\n\\n| Feature            | Description  \", \"                                                               | GitHub Actions | Azure Pipelines |\\n\", \"|--------------------|-----------------------------------------------------------------------------|\", \"----------------|-----------------|\\n| Variables          | Variables that can be<br>passed in, stati\", \"cally<br>or dynamically<br>defined | Yes            | Yes             |\\n| Variable<br>Groups | Store\", \" values for use<br>across multiple<br>pipelines                        | No             | Yes       \", \"      |\\n\\n#### **Important**\\n\\nGitHub Actions is rapidly evolving. Be sure to check documentation care\", \"fully before deciding which platform is right for you.\\n\\n# <span id=\\\"page-61-0\\\"></span>Build a .NET w\", \"eb app using GitHub Actions\\n\\n[GitHub Actions](https://github.com/features/actions) allow you to auto\", \"mate workflows in response to events that are triggered in GitHub. A common workflow is Continuous I\", \"ntegration (CI), but Actions can automate other processes. For example, sending welcome emails when \", \"people join a repository.\\n\\nTo explore moving code to the cloud, you'll build a GitHub Actions workfl\", \"ow file. The workflow file will be used for the Simple Feed Reader app you've already deployed to Az\", \"ure App Service.\\n\\nIn this article, you will: > [!div class=\\\"checklist\\\"] > > \\\\* Learn the basic struc\", \"ture of a GitHub Action workflow YAML file. > \\\\* Use a template to create a basic build workflow tha\", \"t builds the .NET app and executes unit tests. > \\\\* Publish the compiled app so that it's ready for \", \"deployment.\\n\\n#### <span id=\\\"page-61-1\\\"></span>**Workflow structure**\\n\\nWorkflows are defined in YAML \", \"files, and contain several common nodes:\\n\\n- a name\\n- a trigger, defined by an on section\\n- one or mo\", \"re job sections composed of one or more steps\\n- optional attributes such as environment variables\\n\\nJ\", \"obs are run on *runners*. You can use *hosted runners*, which are spun up by GitHub during the workf\", \"low and then thrown away. Hosted runners are great because you don't have to maintain your own build\", \" infrastructure. For workflows that require a specific build environment, or for running workflows o\", \"n a private network, you can also use *private* runners. To create a private runner, install the run\", \"ner on any machine that supports .NET.\\n\\nEach job will specify what runner GitHub should use to execu\", \"te the steps. You can also specify dependencies between jobs using the needs attribute. Deployment j\", \"obs can also specify an environment to target.\\n\\nThe steps node can be as easy as inline commands, or\", \" they can be actions. Most CI workflows will have a combination of run steps (for executing scripts)\", \" and actions. Individual actions are pulled into the workflow by referencing the GitHub Action repos\", \"itory (and optionally a tag or commit hash for specific versions) and specifying any parameters usin\", \"g the with keyword.\\n\\n#### **Tip**\\n\\nFor more information, see [GitHub Actions YAML syntax.](https://d\", \"ocs.github.com/actions/reference/workflow-syntax-for-github-actions)\\n\\nFrom a workflow file, you're a\", \"ble to run any of the available [.NET CLI commands](https://docs.microsoft.com/en-us/dotnet/core/too\", \"ls/). For example, if you're required to build, test, and deploy an ASP.NET Core Blazor WebAssembly \", \"app with Ahead-of-Time (AoT) compilation, you'd use the following commands:\\n\\n- [dotnet workload inst\", \"all](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-workload-install)\\n- [dotnet restore](\", \"https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-restore)\\n- [dotnet build](https://docs.mic\", \"rosoft.com/en-us/dotnet/core/tools/dotnet-build)\\n- [dotnet test](https://docs.microsoft.com/en-us/do\", \"tnet/core/tools/dotnet-test)\\n- [dotnet publish](https://docs.microsoft.com/en-us/dotnet/core/tools/d\", \"otnet-publish)\\n\\n#### **The .NET SDK is a workflow necessity**\\n\\nAll .NET workflows require the .NET S\", \"DK, and this can be set up by the [actions/setup-dotnet](https://github.com/actions/setup-dotnet) Gi\", \"tHub [Action.](https://github.com/actions/setup-dotnet) This action sets up a [.NET CLI](https://doc\", \"s.microsoft.com/en-us/dotnet/core/tools/) environment for use in actions. Some [GitHub hosted runner\", \"s](https://docs.github.com/actions/using-github-hosted-runners/about-github-hosted-runners#supported\", \"-software) have the .NET SDK preinstalled, but that's subject to change. As a best practice, use the\", \" actions/setupdotnet action to ensure the proper version is available.\\n\\n#### <span id=\\\"page-62-0\\\"></\", \"span>**Create a basic build workflow**\\n\\nA primary principle of effective DevOps is to \\\"build once, a\", \"nd deploy many times\\\". You'll start by creating a workflow to build a basic .NET app. In the next st\", \"ep, you'll publish the output to prepare for deployment.\\n\\n- 1. Navigate to your GitHub repository an\", \"d select the **Actions** tab.\\n- 2. GitHub detects that there's .NET code in the repository and sugge\", \"sts a .NET workflow template. Select **Set up this workflow** to create a new YAML workflow file:\\n\\n!\", \"[](_page_62_Picture_15.jpeg)\\n\\n\\\\*\\\\*Figure 1\\\\*\\\\*: Creating a new workflow.\\n\\n1. Commit the file onto th\", \"e main branch. Since you've defined a trigger condition for *commits to main*, this commit should tr\", \"igger the workflow to run.\\n\\n![](_page_63_Picture_1.jpeg)\\n\\n\\\\*\\\\*Figure 2\\\\*\\\\*: Commit the YAML file.\\n\\n1\", \". Select the **Actions** tab again. You should see a running workflow. Once the workflow has complet\", \"ed, you should see a successful run.\\n\\n![](_page_63_Picture_4.jpeg)\\n\\n\\\\*\\\\*Figure 3\\\\*\\\\*: Successful bui\", \"ld view.\\n\\n1. Opening the logs, you can see that the .NET build succeeded and the tests ran and passe\", \"d.\\n\\n![](_page_63_Picture_7.jpeg)\\n\\n\\\\*\\\\*Figure 4\\\\*\\\\*: Checking the logs.\\n\\n#### **Note**\\n\\nIf any of the\", \" tests fail, the workflow will fail.\\n\\n#### <span id=\\\"page-64-0\\\"></span>**Dissect the workflow file**\", \"\\n\\nLet's examine the workflow YAML file you have so far:\\n\\n```\\nname: .NET\\non:\\n push:\\n branches: [ main\", \" ]\\n pull_request:\\n branches: [ main ]\\njobs:\\n build:\\n runs-on: ubuntu-latest\\n steps:\\n - uses: actions\", \"/checkout@v3\\n - name: Setup .NET\\n uses: actions/setup-dotnet@v3\\n with:\\n dotnet-version: 6.0.x\\n - nam\", \"e: Restore dependencies\\n run: dotnet restore\\n - name: Build\\n run: dotnet build --no-restore\\n - name:\", \" Test\\n run: dotnet test --no-build --verbosity normal\\n```\\n\\n#### Notice the following things:\\n\\n- 1. T\", \"here's a name that names the workflow.\\n- 2. The on object specifies when this workflow should run. T\", \"his workflow has two events that trigger it: push to main and pull\\\\_request to main. Each time someo\", \"ne commits to main or creates a pull request (PR) to main, this workflow will execute.\\n- 3. There's \", \"a single job called build. This build should run on a hosted agent. ubuntu\\\\_latest specifies the mos\", \"t recent Ubuntu hosted agent.\\n- 4. There are five steps:\\n  - 1. actions/checkout@v3 is an action tha\", \"t checks out the code in the repository onto the runner.\\n  - 2. actions/setup-dotnet@v3 is an action\", \" that sets up the .NET CLI. This step also specifies a name attribute for the logs and the dotnet-ve\", \"rsion parameter within the with object.\\n  - 3. Three run steps that execute dotnet restore, dotnet b\", \"uild, and dotnet test. name attributes are also specified for these run steps to make the logs look \", \"pretty.\\n\\n#### <span id=\\\"page-65-0\\\"></span>**Publish the output**\\n\\nNow that you've successfully built\", \" and tested the code, add steps that publish the output so you can deploy the web app.\\n\\n1. Navigate \", \"to the *.github/workflows/dotnet.yml* file and select the pencil icon to edit\\n\\n![](_page_65_Picture_\", \"3.jpeg)\\n\\n\\\\*\\\\*Figure 5\\\\*\\\\*: Edit the YAML file.\\n\\n1. Add the following Publish step below the Test ste\", \"p. The step runs the dotnet publish command to publish the web app:\\n\\n:::{custom-style=CodeBox} ```ym\", \"l\\n\\n- name: Test run: dotnet test \\u2013no-build \\u2013verbosity normal # <\\u2013 this is the current bottom line\\n- \", \"name: Publish run: dotnet publish SimpleFeedReader/SimpleFeedReader.csproj -c Release -o website ```\", \" :::\\n- 2. This publishes the web app to a folder on the hosted agent. Now you'll want to *upload* th\", \"e site as a build artifact that can be deployed to Azure. To complete this activity, you'll use an e\", \"xisting action.\\n- 3. On the list of actions in the **Actions Helper** pane on the right, search for \", \"artifact. Select on the Upload a Build Artifact (By actions) action.\\n\\n![](_page_65_Figure_11.jpeg)\\n\\n\", \"\\\\*\\\\*Figure 6\\\\*\\\\*: Accessing the snippet helper.\\n\\n1. Edit the version to v2.2.2 to display a sample s\", \"nippet. Select the clipboard icon to copy the snippet and paste it into the workflow below the publi\", \"sh step.\\n\\n![](_page_66_Picture_1.jpeg)\\n\\n\\\\*\\\\*Figure 7\\\\*\\\\*: Copying a snippet.\\n\\n1. Edit the YAML for t\", \"his step to look as follows:\\n\\n```\\n:::{custom-style=CodeBox} ```yml\\n```\\n\\n- name: Upload a Build Artif\", \"act uses: actions/upload-artifact@v3 with: name: website path: SimpleFeedReader/website/\\\\*\\\\* if-no-f\", \"iles-found: error ``` :::\\n- 2. Commit the file.\\n- 3. Once the workflow completes, you'll see the art\", \"ifact from the **Home** tab:\\n\\n![](_page_66_Picture_8.jpeg)\\n\\n\\\\*\\\\*Figure 8\\\\*\\\\*: Viewing artifacts in t\", \"he summary page.\\n\\n#### **Final workflow file**\\n\\nThe final workflow file should look something like t\", \"his:\\n\\n```\\nname: .NET\\non:\\n push:\\n branches: [ main ]\\n pull_request:\\n branches: [ main ]\\njobs:\\n build:\", \"\\n runs-on: ubuntu-latest\\n steps:\\n - uses: actions/checkout@v3\\n - name: Setup .NET\\n uses: actions/set\", \"up-dotnet@v3\\n with:\\n dotnet-version: 6.0.x\\n - name: Restore dependencies\\n run: dotnet restore\\n - nam\", \"e: Build\\n run: dotnet build --no-restore\\n - name: Test\\n run: dotnet test --no-build --verbosity norm\", \"al\\n - name: Publish\\n run: dotnet publish SimpleFeedReader/SimpleFeedReader.csproj -c Release -o webs\", \"ite\\n - name: Upload a Build Artifact\\n uses: actions/upload-artifact@v3\\n with:\\n name: website\\n path: \", \"SimpleFeedReader/website/**\\n if-no-files-found: error\\n```\\n\\n# <span id=\\\"page-67-0\\\"></span>Deploy a .N\", \"ET web app using GitHub Actions\\n\\n#### **Warning**\\n\\nPlease complete the Build tutorial before startin\", \"g this lab.\\n\\nIn this article, you'll: > [!div class=\\\"checklist\\\"] > > \\\\* Learn about Environments in \", \"GitHub Actions. > \\\\* Create two environments and specify environment protection rules. > \\\\* Create e\", \"nvironment secrets for managing environment-specific configuration. > \\\\* Extend the workflow YAML fi\", \"le to add deployment steps. > \\\\* Add a manual dispatch trigger.\\n\\n#### <span id=\\\"page-67-1\\\"></span>**\", \"Environments**\\n\\nNow that you've published an artifact that's *potentially deployable*, you'll add *d\", \"eployment* jobs to the workflow. There's nothing special about a deployment job, other than the fact\", \" that it references an\\n\\n*environment*. Environments are *logical* constructs that allow you to speci\", \"fy environment protection rules, such as approvals, on any group of resources that you're targeting.\", \"\\n\\nIn this walkthrough, you'll be deploying to two environments: PRE-PROD and PROD. In a typical deve\", \"lopment lifecycle, you'll want to deploy the latest code to a *soft* environment (typically DEV) tha\", \"t is expected to be a bit unstable. You'll use PRE-PROD as this *soft* environment. The \\\"higher\\\" env\", \"ironments (like UAT and PROD) are *harder* environments that are expected to be more stable. To enfo\", \"rce this, you can build protection rules into higher environments. You'll configure an approval prot\", \"ection rule on the PROD environment: whenever a deployment job targets an environment with an approv\", \"al rule, it will pause until approval is granted before executing.\\n\\nGitHub environments are *logical\", \"*. They represent the physical (or virtual) resources that you're deploying to. In this case, the PR\", \"E-PROD is just a deployment slot on the Azure Web App. PROD is the production slot. The PRE-PROD dep\", \"loyment job will deploy the published .NET app to the staging slot. The PROD deployment job will swa\", \"p the slots.\\n\\nOnce you have these steps in place, you'll update the workflow to handle environment-s\", \"pecific configuration using environment secrets.\\n\\n#### **Note**\\n\\nFor more information, see [GitHub A\", \"ctions -](https://docs.github.com/actions/reference/environments) Environments.\\n\\n#### <span id=\\\"page\", \"-68-0\\\"></span>**Azure authentication**\\n\\nTo perform actions such as deploying code to an Azure resour\", \"ce, you need the correct permissions. For deployment to Azure Web Apps, you can use a publishing pro\", \"file. If you want to deploy to a staging slot, then you'll need the publishing profile for the slot \", \"too. Instead, you can use a service principal (SPN) and assign permission to this service principal.\", \" You can then authenticate using credentials for the SPN before using any commands that the SPN has \", \"permissions to perform.\\n\\nOnce you have an SPN, you'll create a [repository secret](https://docs.gith\", \"ub.com/actions/reference/encrypted-secrets) to securely store the credentials. You can then refer to\", \" the secret whenever you need to authenticate. The secret is encrypted and once it has been saved, c\", \"an never be viewed or edited (only deleted or re-created).\\n\\n#### **Create an SPN**\\n\\n- 1. In your ter\", \"minal or Cloud Shell, run the following command to create a service principal with contributor permi\", \"ssions to the web app you created earlier:\\n  - :::{custom-style=CodeBox} azurecli az ad sp create-fo\", \"r-rbac --name \\\"{sp-name}\\\" --sdk-auth role contributor \\\\ --scopes /subscriptions/{subscription-id}/re\", \"sourceGroups/{resourcegroup}/providers/Microsoft.Web/sites/{webappname} :::\\n- 2. The command should \", \"output JSON that has credentials embedded:\\n\\n```\\n:::{custom-style=CodeBox} json { \\\"clientId\\\": \\\"<GUID>\", \"\\\", \\\"clientSecret\\\": \\\"<GUID>\\\", \\n\\\"subscriptionId\\\": \\\"<GUID>\\\", \\\"tenantId\\\": \\\"<GUID>\\\", ... } :::\\n```\\n\\n3. Ma\", \"ke sure to record the clientId, clientSecret, subscription, and tenantId. You can also leave the ter\", \"minal open for copy/paste later.\\n\\n#### **Create a repository secret**\\n\\n- 1. Now you're going to crea\", \"te an encrypted secret to store the credentials. You'll create this secret at the repository level.\\n\", \"- 2. Navigate to GitHub and select your repository **Settings** tab. Then select **Secrets**. Select\", \" **New repository secret**:\\n\\n![](_page_69_Picture_4.jpeg)\\n\\n\\\\*\\\\*Figure 1\\\\*\\\\*: Create a secret.\\n\\n1. Co\", \"py and paste the JSON from the az ad sp create-for-rbac command into the body of the secret. You can\", \" create this JSON by hand too if you have the relevant fields for your SPN. The secret should be nam\", \"ed AZURE\\\\_CREDENTIALS. Select **Add secret** to save the new secret:\\n\\n![](_page_69_Picture_7.jpeg)\\n\\n\", \"\\\\*\\\\*Figure 2\\\\*\\\\*: Add Azure credentials.\\n\\n1. You'll consume this secret in a workflow in later steps\", \". To access it, use the variable notation \\\\${{}}. In this case, \\\\${{ AZURE\\\\_CREDENTIAL }} will be po\", \"pulated with the JSON you saved.\\n\\n#### <span id=\\\"page-69-0\\\"></span>**Add environments**\\n\\n[Environmen\", \"ts](https://docs.github.com/actions/reference/environments) are used as a *logical boundary*. You ca\", \"n add approvals to environments to ensure quality. You can also track deployments to environments an\", \"d specify environment-specific values (secrets) for configuration.\\n\\nFor this example, you're going t\", \"o split the actual Azure environment into two *logical* environments called PRE-PROD and PROD. When \", \"you deploy the web app, you'll deploy to the staging slot of the Azure web app, represented by the P\", \"RE-PROD environment. When you're ready to deploy to PROD, you'll just perform a slot swap.\\n\\nIn this \", \"case, the only difference between the environments is the slot that you're deploying to. In real lif\", \"e, there would typically be different web apps (and separate web app plans), separate resource group\", \"s, and even separate subscriptions. Typically, there's an SPN per environment. You may want to overr\", \"ide the AZURE\\\\_CREDENTIAL value that you saved as a repository secret by creating it as an *environm\", \"ent secret*.\\n\\n#### **Note**\\n\\nPrecedence works from Environment to repository. If a targeted environm\", \"ent has a secret called MY\\\\_SECRET, then that value is used. If not, the repository value of MY\\\\_SEC\", \"RET (if any) is used.\\n\\n1. Select **Settings** and then **Environments** in your repository. Select *\", \"*New Environment**:\\n\\n![](_page_70_Picture_5.jpeg)\\n\\n\\\\*\\\\*Figure 3\\\\*\\\\*: Create an environment.\\n\\n1. Ente\", \"r PRE-PROD and select **Configure environment**:\\n\\n![](_page_70_Picture_8.jpeg)\\n\\n\\\\*\\\\*Figure 4\\\\*\\\\*: Na\", \"me the environment.\\n\\n- 1. Since deploying to a staging slot doesn't affect the web app, you can safe\", \"ly deploy to the slot without requiring an approval first. A reviewer could be added if desired. For\", \" this example, leave the Environment protection rules empty.\\n  - [!NOTE] If you target an environmen\", \"t in a workflow and it does not exist, an \\\"empty\\\" environment is created automatically. The environm\", \"ent would look exactly the same as the PRE-PROD environment - it would exist, but would not have any\", \" protection rules enabled.\\n- 2. Select **Environments** again and again select **New Environment**. \", \"Now enter PROD as the name and select **Configure environment**.\\n- 3. Check the **Required reviewers\", \"** rule and add yourself as a reviewer. Don't forget to select **Save protection rules**:\\n\\n![](_page\", \"_71_Picture_4.jpeg)\\n\\n\\\\*\\\\*Figure 5\\\\*\\\\*: Add protection rules.\\n\\n#### <span id=\\\"page-71-0\\\"></span>**Dep\", \"loy to staging**\\n\\nYou can now add additional jobs to the workflow to deploy to the environments! You\", \"'ll start by adding a deployment to the PRE-PROD environment, which in this case is the web app stag\", \"ing slot.\\n\\n- 1. Navigate to the *.github/workflows/dotnet.yml* file and select the pencil icon to ed\", \"it the file.\\n- 2. You're going to use the web app name a few times in this workflow, and will need t\", \"he name of the resource group too. You'll define the app and resource group names as variables. With\", \" the variables, you can maintain the values in one place in the workflow file.\\n- 3. Add this snippet\", \" below the on block and above the jobs block:\\n\\n```\\n:::{custom-style=CodeBox} ```yml env: app-name: \\\"\", \"\\\" rg-name: \\\"\\\"\\njobs: # <\\u2013 this is the existing jobs line ``` :::\\n```\\n\\n[!WARNING] You'll need to repla\", \"ce <name of your web app> with the actual name of your web app, and <name of your resource group> wi\", \"th the actual name of your resource group.\\n\\n4. Add a new job below the build job as follows:\\n\\n:::{cu\", \"stom-style=CodeBox} ```yml if-no-files-found: error # <\\u2013 last line of build job: insert below this l\", \"ine\\n\\ndeploy\\\\_staging: needs: build runs-on: ubuntu-latest\\n\\n```\\nenvironment:\\n name: PRE-PROD\\n url: ${\", \"{ steps.deploywebapp.outputs.webapp-url }}\\nsteps:\\n- name: Download a Build Artifact\\n uses: actions/d\", \"ownload-artifact@v3\\n with:\\n name: website\\n path: website\\n- name: Login via Azure CLI\\n uses: azure/lo\", \"gin@v1\\n with:\\n creds: ${{ secrets.AZURE_CREDENTIALS }}\\n- name: Deploy web app\\n id: deploywebapp\\n use\", \"s: azure/webapps-deploy@v2\\n with:\\n app-name: ${{ env.app-name }}\\n slot-name: staging\\n package: websi\", \"te\\n- name: az cli logout\\n run: az logout\\n```\\n\\n``` :::\\n\\nThe preceding workflow defines several steps:\", \"\\n\\n- 1. You're creating a new job called deploy\\\\_staging.\\n- 2. You specify a dependency using needs. \", \"This job needs the build job to complete successfully before it starts.\\n- 3. This job also runs on t\", \"he latest Ubuntu hosted agent, as specified with the runs-on attribute.\\n- 4. You specify that this j\", \"ob is targeting the PRE-PROD environment using the environment object. You also specify the url prop\", \"erty. This URL will be displayed in the workflow diagram, giving users an easy way to navigate to th\", \"e environment. The value of this property is set as the output of the step with id deploywebapp, whi\", \"ch is defined below.\\n- 5. You're executing a download-artifact step to download the artifact (compil\", \"ed web app) from the build job.\\n- 6. You then login to Azure using the AZURE\\\\_CREDENTIALS secret you\", \" saved earlier. Note the \\\\${{ }} notation for dereferencing variables.\\n- 7. You then perform a webap\", \"p-deploy, specifying the app-name, slot-name, and path to the downloaded artifact (package). This ac\", \"tion also defines an output parameter that you use to set the url of the environment above.\\n\\n- 8. Fi\", \"nally, you execute a logout to log out of the Azure context.\\n- 5. Commit the file.\\n- 6. When the run\", \" completes, you should see two successful jobs. The URL for the PRE-PROD stage has been set and sele\", \"cting it will navigate you to your web app staging slot:\\n\\n![](_page_73_Picture_3.jpeg)\\n\\n\\\\*\\\\*Figure 6\", \"\\\\*\\\\*: Deployment to PRE-PROD is successful.\\n\\n1. Notice how the staging slot's direct URL contains -s\", \"taging:\\n\\n![](_page_73_Picture_6.jpeg)\\n\\n\\\\*\\\\*Figure 7\\\\*\\\\*: The staging slot running.\\n\\n1. You can also \", \"now see deployments. Navigate to https://{your repository url}/deployments to view your deployments:\", \"\\n\\n![](_page_74_Picture_0.jpeg)\\n\\n\\\\*\\\\*Figure 8\\\\*\\\\*: View deployments.\\n\\n#### <span id=\\\"page-74-0\\\"></spa\", \"n>**Deploy to production**\\n\\nNow that you've deployed successfully to PRE-PROD, you'll want to deploy\", \" to PROD. Deployment to PROD will be slightly different since you don't need to copy the website aga\", \"in - you just need to swap the staging slot with the production slot. You'll do this using an Azure \", \"CLI (az) command.\\n\\n- 1. Navigate to the *.github/workflows/dotnet.yml* file and select the pencil ic\", \"on to edit the file.\\n- 2. Add a new job below the deploy\\\\_staging job as follows:\\n\\n:::{custom-style=\", \"CodeBox} ```yml run: az logout # <\\u2013 last line of previous job: insert below this line\\n\\ndeploy\\\\_prod:\", \" needs: deploy\\\\_staging runs-on: ubuntu-latest\\n\\n```\\nenvironment:\\n name: PROD\\n url: ${{ steps.slot_sw\", \"ap.outputs.url }}\\nsteps:\\n- name: Login via Azure CLI\\n uses: azure/login@v1\\n with:\\n creds: ${{ secret\", \"s.AZURE_CREDENTIALS }}\\n- name: Swap staging slot into production\\n id: slot_swap\\n run: |\\n az webapp d\", \"eployment slot swap -g ${{ env.rg-name }} -n ${{ env.app-name }} -s staging\\n url=$(az webapp show -g\", \" ${{ env.rg-name }} -n ${{ env.app-name }} --query \\n\\\"defaultHostName\\\" -o tsv)\\n echo \\\"::set-output na\", \"me=url::http://$url\\\"\\n- name: az cli logout\\n run: az logout\\n``` :::\\n```\\n\\nThe deployment to the PROD e\", \"nvironment workflow specifies several steps:\\n\\n- 1. Once again, you specify a new job deploy\\\\_prod th\", \"at needs deploy\\\\_staging to complete before starting.\\n- 2. You're targeting the PROD environment thi\", \"s time. Also, the url value is different from before.\\n\\n- 3. For the steps, you don't need to downloa\", \"d the artifact since you're just going to perform a slot swap. You start by executing a login to the\", \" Azure context.\\n- 4. The Swap staging slot into production step is a multi-line run command (note th\", \"e use of the pipe symbol |). You also specify an id for this step so that you can refer to it (you r\", \"efer to it in the url property of the environment). The first line executes the slot swap using the \", \"variables you defined above in the workflow. The second line uses an az webapp show command to extra\", \"ct the URL of the target web app. This final line uses ::set-output in an echo to create an output v\", \"ariable for this task, setting the value to the web app URL.\\n\\n[!NOTE] The URL *must* start with http\", \":// or https:// or it won't render.\\n\\n- 3. Commit the file.\\n- 4. Let the workflow run for a couple mi\", \"nutes until it has deployed to PRE-PROD. At this point, the workflow will pause and wait for the req\", \"uired approval since you're targeting the PROD environment, which requires an approval as defined ea\", \"rlier:\\n\\n![](_page_75_Picture_5.jpeg)\\n\\n\\\\*\\\\*Figure 9\\\\*\\\\*: Waiting for an approval.\\n\\n1. Select **Review\", \" deployments**, select the **PROD** checkbox, optionally add a comment, and then select **Approve an\", \"d deploy** to start the PROD job.\\n\\n![](_page_75_Picture_8.jpeg)\\n\\n\\\\*\\\\*Figure 10\\\\*\\\\*: Approve the PROD\", \" deployment.\\n\\n1. The deployment should only take a few seconds. Once it has completed, the URL for t\", \"he PROD environment will update.\\n\\n![](_page_76_Figure_0.jpeg)\\n\\n\\\\*\\\\*Figure 11\\\\*\\\\*: PROD deployment co\", \"mpleted.\\n\\n1. Selecting the PROD URL will navigate you to the PROD site.\\n\\n![](_page_76_Picture_3.jpeg\", \")\\n\\n\\\\*\\\\*Figure 12\\\\*\\\\*: The PROD site.\\n\\n#### <span id=\\\"page-76-0\\\"></span>**Add a manual queue option**\", \"\\n\\nYou now have an end-to-end build and deploy workflow, including approvals. One more change you can\", \" make is to add a manual trigger to the workflow so that the workflow can be triggered from within t\", \"he **Actions** tab of the repository.\\n\\n- 1. Navigate to the *.github/workflows/dotnet.yml* file and \", \"select the pencil icon to edit the file.\\n- 2. Add a new trigger between on and push on lines 3 and 4\", \":\\n  - :::{custom-style=CodeBox} yml on: workflow\\\\_dispatch: # <-- this is the new line push: :::\\n- 3\", \". The workflow\\\\_dispatch trigger displays a Run workflow button in the **Actions** tab of the reposi\", \"tory\\u2014*but only if the trigger is defined in the default branch*. However, once this trigger is defin\", \"ed in the workflow, you can select the branch for the run.\\n- 4. Commit the file.\\n\\n5. To see the **Ru\", \"n workflow** button, select the **Actions** tab. Select the .NET workflow in the list of workflows. \", \"At the top of the list of runs, you'll see the **Run workflow** button. If you select it, you can ch\", \"oose the branch to run the workflow against and queue it:\\n\\n![](_page_77_Picture_1.jpeg)\\n\\n\\\\*\\\\*Figure \", \"13\\\\*\\\\*: Manual dispatch.\\n\\n#### <span id=\\\"page-77-0\\\"></span>**Handle environment configuration**\\n\\nYou\", \"r workflow is deploying the same binary to each environment. This concept is important to ensure tha\", \"t the binaries you test in one environment are the same that you deploy to the next. However, enviro\", \"nments typically have different settings like database connection strings. You want to ensure that t\", \"he DEV app is using DEV settings and the PROD app is using PROD settings.\\n\\nFor this simple app, ther\", \"e's no database connection string. However, there's an example configuration setting that you can mo\", \"dify for each environment. If you open the *simple-feedreader/SimpleFeedReader/appsettings.json* fil\", \"e, you'll see that the configuration includes a setting for the Header text on the Index page:\\n\\n```\\n\", \" \\\"UI\\\": {\\n \\\"Index\\\": {\\n \\\"Header\\\": \\\"Simple News Reader\\\"\\n }\\n },\\n```\\n\\nTo show how environment configurati\", \"on can be handled, you're going to add a secret to each environment and then substitute that value i\", \"nto the settings as you deploy.\\n\\n#### **Add environment secrets**\\n\\n- 1. On your repository, select *\", \"*Settings** > **Environments** > **PRE-PROD**.\\n- 2. Select **Add secret** and add a secret called in\", \"dex\\\\_header with the value PRE PROD News Reader. Select **Add secret**.\\n\\n![](_page_78_Picture_0.jpeg\", \")\\n\\n\\\\*\\\\*Figure 14\\\\*\\\\*: Add an environment secret.\\n\\n- 1. Repeat these steps to add a secret called ind\", \"ex\\\\_header with the value PROD News Reader for the PROD environment.\\n- 2. If you select **Settings**\", \" > **Secrets** in the repository, you'll see the changes. They should look something like this:\\n\\n![]\", \"(_page_78_Picture_4.jpeg)\\n\\n\\\\*\\\\*Figure 15\\\\*\\\\*: View secrets.\\n\\n#### **Update the workflow to handle co\", \"nfiguration**\\n\\n- 1. Navigate to the *.github/workflows/dotnet.yml* file and select the pencil icon t\", \"o edit the file.\\n- 2. Add the following step before the az cli logout step in the deploy\\\\_staging jo\", \"b:\\n\\n```\\n:::{custom-style=CodeBox} ```yml - name: Update config uses: Azure/appservice-settings@v1 \\nw\", \"ith: app-name: ${{ env.app-name }} slot-name: staging app-settings-json: | [ { \\\"name\\\": \\n\\\"UI:Index:He\", \"ader\\\", \\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\\",\\\"slotSetting\\\": true } ]\\n - name: az cli logout # <-- t\", \"his exists already\\n```\\n\\n``` :::\\n\\n3. Add almost the same code to the deploy\\\\_prod job above its az cl\", \"i logout step. The only difference is that you don't specify a slot-name, since you're targeting the\", \" production slot:\\n\\n```\\n:::{custom-style=CodeBox} ```yml - name: Update config uses: Azure/appservice\", \"-settings@v1 \\nwith: app-name: ${{ env.app-name }} app-settings-json: | [ { \\\"name\\\": \\\"UI:Index:Header\\\"\", \", \\n\\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\\",\\\"slotSetting\\\": true } ]\\n - name: az cli logout # <-- this \", \"exists already\\n```\\n\\n``` :::\\n\\n4. Commit the file.\\n\\n- 5. Let the workflow run and approve the deployme\", \"nt to PROD once the approval is reached.\\n- 6. You should see the following headers on the index page\", \" for both sites:\\n\\n![](_page_79_Picture_5.jpeg)\\n\\n\\\\*\\\\*Figure 16\\\\*\\\\*: Settings changed in the environme\", \"nts.\\n\\n#### <span id=\\\"page-79-0\\\"></span>**Final workflow file**\\n\\nThe final workflow file should look \", \"like this:\\n\\n```\\nname: .NET\\non:\\n workflow_dispatch:\\n inputs:\\n reason:\\n description: 'The reason for r\", \"unning the workflow'\\n required: true\\n default: 'Manual build from GitHub UI'\\n push:\\n branches: [ mai\", \"n ]\\n pull_request:\\n branches: [ main ]\\nenv:\\n app-name: \\\"cd-simplefeedreader\\\"\\n rg-name: \\\"cd-dotnetact\", \"ions\\\"\\njobs:\\n build:\\n```\\n\\n```\\n runs-on: ubuntu-latest\\n steps:\\n - uses: actions/checkout@v3\\n - name: '\", \"Print manual run reason'\\n if: ${{ github.event_name == 'workflow_dispatch' }}\\n run: |\\n echo 'Reason:\", \" ${{ github.event.inputs.reason }}'\\n - name: Setup .NET\\n uses: actions/setup-dotnet@v3\\n with:\\n dotne\", \"t-version: 6.0.x\\n - name: Restore dependencies\\n run: dotnet restore\\n - name: Build\\n run: dotnet buil\", \"d --no-restore\\n - name: Test\\n run: dotnet test --no-build --verbosity normal\\n - name: Publish\\n run: \", \"dotnet publish SimpleFeedReader/SimpleFeedReader.csproj -c Release -o website\\n - name: Upload a Buil\", \"d Artifact\\n uses: actions/upload-artifact@v3\\n with:\\n name: website\\n path: SimpleFeedReader/website/*\", \"*\\n if-no-files-found: error\\n deploy_staging:\\n needs: build\\n runs-on: ubuntu-latest\\n environment:\\n na\", \"me: STAGING\\n url: ${{ steps.deploywebapp.outputs.webapp-url }}\\n steps:\\n - name: Download a Build Art\", \"ifact\\n uses: actions/download-artifact@v3\\n with:\\n name: website\\n path: website\\n - name: Login via Az\", \"ure CLI\\n uses: azure/login@v1\\n with:\\n creds: ${{ secrets.AZURE_CREDENTIALS }}\\n - name: Deploy web ap\", \"p\\n id: deploywebapp\\n uses: azure/webapps-deploy@v2\\n with:\\n app-name: ${{ env.app-name }}\\n slot-name:\", \" staging\\n package: website\\n - name: Update config\\n uses: Azure/appservice-settings@v1\\n with:\\n app-na\", \"me: ${{ env.app-name }}\\n slot-name: staging\\n app-settings-json: |\\n```\\n\\n```\\n [\\n {\\n \\\"name\\\": \\\"UI:Index:\", \"Header\\\",\\n \\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\\",\\n \\\"slotSetting\\\": true\\n }\\n ]\\n - name: az cli logout\\n\", \" run: az logout\\n deploy_prod:\\n needs: deploy_staging\\n runs-on: ubuntu-latest\\n environment:\\n name: PR\", \"OD\\n url: ${{ steps.slot_swap.outputs.url }}\\n steps:\\n - name: Login via Azure CLI\\n uses: azure/login@\", \"v1\\n with:\\n creds: ${{ secrets.AZURE_CREDENTIALS }}\\n - name: Swap staging slot into production\\n id: s\", \"lot_swap\\n run: |\\n az webapp deployment slot swap -g ${{ env.rg-name }} -n ${{ env.app-name }} -s \\nst\", \"aging\\n url=$(az webapp show -g ${{ env.rg-name }} -n ${{ env.app-name }} --query \\n\\\"defaultHostName\\\" \", \"-o tsv)\\n echo \\\"::set-output name=url::http://$url\\\"\\n - name: Update config\\n uses: Azure/appservice-se\", \"ttings@v1\\n with:\\n app-name: ${{ env.app-name }}\\n app-settings-json: |\\n [\\n {\\n \\\"name\\\": \\\"UI:Index:Heade\", \"r\\\",\\n \\\"value\\\": \\\"${{ secrets.INDEX_HEADER }}\\\",\\n \\\"slotSetting\\\": true\\n }\\n ]\\n - name: az cli logout\\n run:\", \" az logout\\n```\\n\\n# <span id=\\\"page-81-0\\\"></span>Secure .NET Code with CodeQL and GitHub Actions\\n\\n[Code\", \"QL](https://codeql.github.com/docs/codeql-overview/about-codeql/) is a static code analysis engine t\", \"hat can automate security and quality checks. With CodeQL, you can perform *variant analysis*, which\", \" uses known vulnerabilities as seeds to find similar issues. CodeQL is part of [GitHub Advanced Secu\", \"rity](https://docs.github.com/github/getting-started-with-github/about-github-advanced-security) tha\", \"t includes:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Code scanning\\u2014find potential security vulnerabilities in yo\", \"ur code.\\n- Secret scanning\\u2014detect secrets and tokens that are committed.\\n- Dependency scanning\\u2014detec\", \"t vulnerabilities in packages that you consume.\\n\\nCodeQL [supports some of the most popular programmi\", \"ng languages and compilers:](https://codeql.github.com/docs/codeql-overview/supported-languages-and-\", \"frameworks/)\\n\\n- C/C++\\n- Java\\n- C#\\n- Python\\n- Go\\n- JavaScript\\n- TypeScript\\n\\nCodeQL is a powerful lang\", \"uage and security professionals can create custom queries using CodeQL. However, teams can benefit i\", \"mmensely from the large open-source collection of queries that the security community has created wi\", \"thout having to write any custom CodeQL.\\n\\nIn this article, you'll set up a GitHub workflow that will\", \" scan code in your repository using CodeQL. You will:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Create a code sca\", \"nning action.\\n- Edit the workflow file to include custom scan settings.\\n- See scanning results.\\n\\n###\", \"# **Note**\\n\\nTo see security alerts for your repository, you must be a repository owner.\\n\\n#### <span \", \"id=\\\"page-82-0\\\"></span>**Create the code scanning workflow**\\n\\nYou can use a starter workflow for code\", \" scanning by navigating to the **Security** tab of your repository.\\n\\n1. Navigate to your GitHub repo\", \"sitory and select the **Security** > **Code Scanning Alerts**. The top recommended workflow should b\", \"e CodeQL Analysis. Select **Set up this workflow**.\\n\\n![](_page_82_Picture_22.jpeg)\\n\\n\\\\*\\\\*Figure 1:\\\\*\\\\\", \"* Create a new code scanning workflow.\\n\\n- 1. A new workflow file is created in your *.github/workflo\", \"ws* folder.\\n- 2. Select **Start Commit** on the upper right to save the default workflow. You can co\", \"mmit to the main branch.\\n\\n![](_page_83_Picture_2.jpeg)\\n\\n\\\\*\\\\*Figure 2:\\\\*\\\\* Commit the file.\\n\\n1. Selec\", \"t the **Actions** tab. In the left-hand tree, you'll see a **CodeQL** node. Select this node to filt\", \"er for CodeQL workflow runs.\\n\\n![](_page_83_Picture_5.jpeg)\\n\\n\\\\*\\\\*Figure 3:\\\\*\\\\* View the CodeQL workfl\", \"ow runs.\\n\\nTake a look at the workflow file while it runs. If you remove the comments from the file, \", \"you'll see the following YAML:\\n\\n```\\nname: \\\"CodeQL\\\"\\non:\\n push:\\n branches: [ main ]\\n pull_request:\\n br\", \"anches: [ main ]\\n schedule:\\n - cron: '40 14 * * 6'\\njobs:\\n analyze:\\n name: Analyze\\n runs-on: ubuntu-l\", \"atest\\n strategy:\\n fail-fast: false\\n```\\n\\n```\\n matrix:\\n language: [ 'csharp' ]\\n steps:\\n - name: Checko\", \"ut repository\\n uses: actions/checkout@v3\\n - name: Initialize CodeQL\\n uses: github/codeql-action/init\", \"@v1\\n with:\\n languages: ${{ matrix.language }}\\n - name: Autobuild\\n uses: github/codeql-action/autobui\", \"ld@v1\\n - name: Perform CodeQL Analysis\\n uses: github/codeql-action/analyze@v1\\n```\\n\\n#### Notice the f\", \"ollowing things:\\n\\n- 1. The workflow name is CodeQL.\\n- 2. This workflow triggers on push and pull\\\\_re\", \"quest events to the main branch. There's also a cron trigger. The cron trigger lets you define a sch\", \"edule for triggering this workflow and is randomly generated for you. In this case, this workflow wi\", \"ll run at 14:40 UTC every Saturday.\\n  - [!TIP] If you edit the workflow file and hover over the cron\", \" expression, a tooltip will show you the English text for the cron expression.\\n- 3. There's a single\", \" job called analyze that runs on the ubuntu-latest hosted agent.\\n- 4. This workflow defines a strate\", \"gy with a matrix on the array of language. In this case, there's only csharp. If the repository cont\", \"ained other languages, you could add them to this array. This causes the job to \\\"fan out\\\" and create\", \" an instance per value of the matrix.\\n- 5. There are four steps, starting with checkout.\\n- 6. The se\", \"cond step initializes the CodeQL scanner for the language this job is going to scan. CodeQL intercep\", \"ts calls to the compiler to build a database of the code while the code is being built.\\n- 7. The Aut\", \"obuild step will attempt to automatically build the source code using common conventions. If this st\", \"ep fails, you can replace it with your own custom build steps.\\n- 8. After building, the CodeQL analy\", \"sis is performed, where suites of queries are run against the code database.\\n- 9. The run should com\", \"plete successfully. However, there appear to be no issues.\\n\\n![](_page_85_Figure_0.jpeg)\\n\\n\\\\*\\\\*Figure \", \"4:\\\\*\\\\* No results to the initial scan.\\n\\n#### <span id=\\\"page-85-0\\\"></span>**Customize CodeQL settings\", \"**\\n\\nThe CodeQL scan isn't reporting any security issues. That's expected with this basic sample. Cod\", \"eQL can also scan for *quality* issues. The current workflow is using the default security-extended \", \"suite. You can add quality scanning in by adding a configuration file to customize the scanning suit\", \"es. In this step, you'll configure CodeQL to use the security-and-quality suites.\\n\\n[!INFORMATION] Fo\", \"r other CodeQL configuration options, see [Configuring CodeQL code scanning in](https://docs.github.\", \"com/code-security/code-scanning/using-codeql-code-scanning-with-your-existing-ci-system/configuring-\", \"codeql-cli-in-your-ci-system)  [your CI system.](https://docs.github.com/code-security/code-scanning\", \"/using-codeql-code-scanning-with-your-existing-ci-system/configuring-codeql-cli-in-your-ci-system)\\n\\n\", \"1. Navigate to the *.github* folder in the **Code** tab and select **Add File**:\\n\\n![](_page_85_Pictu\", \"re_6.jpeg)\\n\\n\\\\*\\\\*Figure 5:\\\\*\\\\* Create a new file.\\n\\n1. Enter *codeql/codeql-config.yml* as the name. T\", \"his creates the file in a folder. Paste in the following code:\\n\\n```\\n:::{custom-style=CodeBox} ```yml\", \" name: \\\"Security and Quality\\\"\\nqueries:\\n```\\n\\n\\u2013 uses: security-and-quality ``` :::\\n\\n![](_page_86_Figur\", \"e_0.jpeg)\\n\\n\\\\*\\\\*Figure 6:\\\\*\\\\* Create the CodeQL configuration file.\\n\\n- 1. Select **Commit to main** a\", \"t bottom of the editor to commit the file.\\n- 2. Edit the CodeQL workflow to use the new configuratio\", \"n file. Navigate to *.github/workflows/codeql-analysis.yml* and select the pencil icon. Add a new pr\", \"operty to the with section as shown below:\\n\\n:::{custom-style=CodeBox} yml - name: Initialize CodeQL \", \"uses: github/codeql-action/init@v1 with: languages: \\\\${{ matrix.language }} config-file: ./.github/c\", \"odeql/codeql-config.yml # <- add this line :::\\n\\n1. Select **Start Commit** and commit to the main br\", \"anch.\\n\\n#### <span id=\\\"page-86-0\\\"></span>**Review the security alerts**\\n\\n#### **Important**\\n\\nYou must\", \" be a repository owner to view security alerts.\\n\\nThis sample repository is small. As such, it doesn'\", \"t contain any major security or quality issues. However, \\\"real world\\\" repositories will likely have \", \"some issues.\\n\\nWhen the last CodeQL workflow run completes, you should see two issues in the **Securi\", \"ty** tab:\\n\\n![](_page_87_Figure_0.jpeg)\\n\\n*Figure 7: View security alerts.*\\n\\n- 1. Select the first ale\", \"rt to open it.\\n- 2. In this case, the alert is for a generated file that isn't committed to the repo\", \"sitory. For that reason, the preview is unavailable.\\n- 3. Notice the tags that are applied. These ta\", \"gs can be used for filtering issues.\\n- 4. Select **Show more** under the rule information to show he\", \"lp and recommendations.\\n\\n![](_page_87_Figure_6.jpeg)\\n\\n\\\\*\\\\*Figure 8:\\\\*\\\\* Open an alert.\\n\\n1. Selecting\", \" **Dismiss** will open options for dismissing this issue:\\n\\n![](_page_88_Figure_0.jpeg)\\n\\n\\\\*\\\\*Figure 9\", \":\\\\*\\\\* Dismiss an alert.\\n\\n# <span id=\\\"page-89-0\\\"></span>Monitor and debug\\n\\nHaving deployed the app an\", \"d built a DevOps pipeline, it's important to understand how to monitor and troubleshoot the app.\\n\\nIn\", \" this section, you'll complete the following tasks:\\n\\n[!div class=\\\"checklist\\\"]\\n\\n- Find basic monitori\", \"ng and troubleshooting data in the Azure portal\\n- Learn how Azure Monitor provides a deeper look at \", \"metrics across all Azure services\\n- Connect the web app with Application Insights for app profiling\\n\", \"- Turn on logging and learn where to download logs\\n- Stream logs in real time\\n- Learn where to set u\", \"p alerts\\n- <span id=\\\"page-89-1\\\"></span>\\u2022 Learn about remote debugging Azure App Service web apps.\\n\\n#\", \" Basic monitoring and troubleshooting\\n\\nApp Service web apps are easily monitored in real time. The A\", \"zure portal renders metrics in easy-tounderstand charts and graphs.\\n\\n- 1. Open the [Azure portal,](h\", \"ttps://portal.azure.com/) and then navigate to the *mywebapp<unique\\\\_number>* App Service.\\n- 2. The \", \"**Overview** tab displays useful \\\"at-a-glance\\\" information, including graphs displaying recent metri\", \"cs.\\n\\n![](_page_89_Figure_16.jpeg)\\n\\n- \\\\* \\\\*\\\\*Http 5xx\\\\*\\\\*: Count of server-side errors, usually excep\", \"tions in ASP.NET Core code.\\n- \\\\* \\\\*\\\\*Data In\\\\*\\\\*: Data ingress coming into your web app.\\n- \\\\* \\\\*\\\\*Da\", \"ta Out\\\\*\\\\*: Data egress from your web app to clients.\\n- \\\\* \\\\*\\\\*Requests\\\\*\\\\*: Count of HTTP requests.\", \"\\n- \\\\* \\\\*\\\\*Average Response Time\\\\*\\\\*: Average time for the web app to respond to HTTP requests.\\n\\nSeve\", \"ral self-service tools for troubleshooting and optimization are also found on this page.\\n\\n![](_page_\", \"90_Figure_6.jpeg)\\n\\n- \\\\* \\\\*\\\\*Diagnose and solve problems\\\\*\\\\* is a self-service troubleshooter.\\n- \\\\* \\\\\", \"*\\\\*Application Insights\\\\*\\\\* is for profiling performance and app behavior, and is discussed later in\", \" this section.\\n- \\\\* \\\\*\\\\*App Service Advisor\\\\*\\\\* makes recommendations to tune your app experience.\\n\\n\", \"# <span id=\\\"page-90-0\\\"></span>Advanced monitoring\\n\\n[Azure Monitor](https://docs.microsoft.com/azure/\", \"monitoring-and-diagnostics/) is the centralized service for monitoring all metrics and setting alert\", \"s across Azure services. Within Azure Monitor, administrators can granularly track performance and i\", \"dentify trends. Each Azure service offers its own [set of metrics](https://docs.microsoft.com/azure/\", \"monitoring-and-diagnostics/monitoring-supported-metrics#microsoftwebsites-excluding-functions) to Az\", \"ure Monitor.\\n\\n# <span id=\\\"page-90-1\\\"></span>Profile with Application Insights\\n\\n[Application Insights\", \"](https://docs.microsoft.com/azure/application-insights/app-insights-overview) is an Azure service f\", \"or analyzing the performance and stability of web apps and how users use them. The data from Applica\", \"tion Insights is broader and deeper than that of Azure Monitor. The data can provide developers and \", \"administrators with key information for improving apps. Application Insights can be added to an Azur\", \"e App Service resource without code changes.\\n\\n- 1. Open the [Azure portal,](https://portal.azure.com\", \"/) and then navigate to the *mywebapp<unique\\\\_number>* App Service.\\n- 2. From the **Overview** tab, \", \"click the **Application Insights** tile.\\n\\n![](_page_91_Figure_0.jpeg)\\n\\n1. Select the **Create new re\", \"source** radio button. Use the default resource name, and select the location for the Application In\", \"sights resource. The location doesn't need to match that of your web app.\\n\\n![](_page_91_Figure_2.jpe\", \"g)\\n\\n- 1. For **Runtime/Framework**, select **ASP.NET Core**. Accept the default settings.\\n- 2. Selec\", \"t **OK**. If prompted to confirm, select **Continue**.\\n- 3. After the resource has been created, cli\", \"ck the name of Application Insights resource to navigate directly to the Application Insights page.\\n\", \"\\n![](_page_91_Figure_6.jpeg)\\n\\nAs the app is used, data accumulates. Select **Refresh** to reload the\", \" blade with new data.\\n\\n![](_page_92_Figure_0.jpeg)\\n\\nApplication Insights provides useful server-side\", \" information with no additional configuration. To get the most value from Application Insights, [ins\", \"trument your app with the Application Insights SDK.](https://docs.microsoft.com/azure/application-in\", \"sights/app-insights-asp-net-core) When properly configured, the service provides end-to-end monitori\", \"ng across the web server and\\n\\nbrowser, including client-side performance. For more information, see \", \"the [Application Insights](https://docs.microsoft.com/azure/application-insights/app-insights-overvi\", \"ew)  [documentation.](https://docs.microsoft.com/azure/application-insights/app-insights-overview)\\n\\n\", \"# <span id=\\\"page-93-0\\\"></span>Logging\\n\\nWeb server and app logs are disabled by default in Azure App \", \"Service. Enable the logs with the following steps:\\n\\n- 1. Open the [Azure portal,](https://portal.azu\", \"re.com/) and navigate to the *mywebapp<unique\\\\_number>* App Service.\\n- 2. In the menu to the left, s\", \"croll down to the **Monitoring** section. Select **Diagnostics logs**.\\n\\n![](_page_93_Picture_5.jpeg)\", \"\\n\\n- 1. Turn on **Application Logging (Filesystem)**. If prompted, click the box to install the exten\", \"sions to enable app logging in the web app.\\n- 2. Set **Web server logging** to **File System**.\\n- 3.\", \" Enter the **Retention Period** in days. For example, 30.\\n- 4. Click **Save**.\\n\\nASP.NET Core and web\", \" server (App Service) logs are generated for the web app. They can be downloaded using the FTP/FTPS \", \"information displayed. The password is the same as the deployment credentials created earlier in thi\", \"s guide. The logs can be [streamed directly to your local machine with](https://docs.microsoft.com/a\", \"zure/app-service/web-sites-enable-diagnostic-log#download)  [PowerShell or Azure CLI.](https://docs.\", \"microsoft.com/azure/app-service/web-sites-enable-diagnostic-log#download) Logs can also be [viewed i\", \"n Application Insights.](https://docs.microsoft.com/azure/app-service/web-sites-enable-diagnostic-lo\", \"g#how-to-view-logs-in-application-insights)\\n\\n# <span id=\\\"page-93-1\\\"></span>Log streaming\\n\\nApp and we\", \"b server logs can be streamed in real time through the portal.\\n\\n- 1. Open the [Azure portal,](https:\", \"//portal.azure.com/) and navigate to the *mywebapp<unique\\\\_number>* App Service.\\n- 2. In the menu to\", \" the left, scroll down to the **Monitoring** section and select **Log stream**.\\n\\n![](_page_94_Pictur\", \"e_0.jpeg)\\n\\nLogs can also be [streamed via Azure CLI or Azure PowerShell,](https://docs.microsoft.com\", \"/azure/app-service/web-sites-enable-diagnostic-log#streamlogs) including through the Cloud Shell.\\n\\n#\", \" <span id=\\\"page-94-0\\\"></span>Alerts\\n\\nAzure Monitor also provides [real time alerts](https://docs.mic\", \"rosoft.com/azure/monitoring-and-diagnostics/insights-alerts-portal) based on metrics, administrative\", \" events, and other criteria.\\n\\n#### **Note**\\n\\nCurrently alerting on web app metrics is only available\", \" in the Alerts (classic) service.\\n\\nThe [Alerts \\\\(classic\\\\) service](https://docs.microsoft.com/azure\", \"/monitoring-and-diagnostics/monitor-quick-resource-metric-alert-portal) can be found in Azure Monito\", \"r or under the **Monitoring** section of the App Service settings.\\n\\n![](_page_94_Picture_7.jpeg)\\n\\n# \", \"<span id=\\\"page-94-1\\\"></span>Live debugging\\n\\nAzure App Service can be [debugged remotely with Visual \", \"Studio](https://docs.microsoft.com/azure/app-service/web-sites-dotnet-troubleshoot-visual-studio#rem\", \"otedebug) when logs don't provide enough information. However, remote debugging requires the app to \", \"be compiled with debug symbols. Debugging shouldn't be done in production, except as a last resort.\\n\", \"\\n# <span id=\\\"page-95-0\\\"></span>Conclusion\\n\\nIn this section, you completed the following tasks:\\n\\n[!di\", \"v class=\\\"checklist\\\"]\\n\\n- Find basic monitoring and troubleshooting data in the Azure portal\\n- Learn h\", \"ow Azure Monitor provides a deeper look at metrics across all Azure services\\n- Connect the web app w\", \"ith Application Insights for app profiling\\n- Turn on logging and learn where to download logs\\n- Stre\", \"am logs in real time\\n- Learn where to set up alerts\\n- <span id=\\\"page-95-1\\\"></span>\\u2022 Learn about remo\", \"te debugging Azure App Service web apps.\\n\\n# Additional reading\\n\\n- [Troubleshooting ASP.NET Core on A\", \"zure App Service and IIS](https://docs.microsoft.com/aspnet/core/test/troubleshoot-azure-iis)\\n- [Com\", \"mon errors reference for Azure App Service and IIS with ASP.NET Core](https://docs.microsoft.com/asp\", \"net/core/host-and-deploy/azure-iis-errors-reference)\\n- [Monitor Azure web app performance with Appli\", \"cation Insights](https://docs.microsoft.com/azure/application-insights/app-insights-azure-web-apps)\\n\", \"- [Enable diagnostics logging for web apps in Azure App Service](https://docs.microsoft.com/azure/ap\", \"p-service/web-sites-enable-diagnostic-log)\\n- [Troubleshoot a web app in Azure App Service using Visu\", \"al Studio](https://docs.microsoft.com/azure/app-service/web-sites-dotnet-troubleshoot-visual-studio)\", \"\\n- [Create classic metric alerts in Azure Monitor for Azure services -](https://docs.microsoft.com/a\", \"zure/monitoring-and-diagnostics/insights-alerts-portal) Azure portal\\n\\n# <span id=\\\"page-96-0\\\"></span>\", \"Next steps\\n\\nIn this guide, you created a DevOps pipeline for an ASP.NET Core sample app. Congratulat\", \"ions! We hope you enjoyed learning to publish ASP.NET Core web apps to Azure App Service and automat\", \"e the continuous integration of changes.\\n\\nBeyond web hosting and DevOps, Azure has a wide array of P\", \"latform-as-a-Service (PaaS) services useful to ASP.NET Core developers. This section gives a brief o\", \"verview of some of the most commonly used services.\\n\\n# <span id=\\\"page-96-1\\\"></span>Storage and datab\", \"ases\\n\\n[Redis Cache](https://docs.microsoft.com/azure/redis-cache/) is high-throughput, low-latency d\", \"ata caching available as a service. It can be used for caching page output, reducing database reques\", \"ts, and providing ASP.NET Core session state across multiple instances of an app.\\n\\n[Azure Storage](h\", \"ttps://docs.microsoft.com/azure/storage/) is Azure's massively scalable cloud storage. Developers ca\", \"n take advantage of [Queue](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduct\", \"ion)  [Storage](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) for rel\", \"iable message queuing, and [Table Storage](https://docs.microsoft.com/azure/storage/tables/table-sto\", \"rage-overview) is a NoSQL key-value store designed for rapid development using massive, semi-structu\", \"red data sets.\\n\\n[Azure SQL Database](https://docs.microsoft.com/azure/sql-database/) provides famili\", \"ar relational database functionality as a service using the Microsoft SQL Server Engine.\\n\\n[Cosmos DB\", \"](https://docs.microsoft.com/azure/cosmos-db/) globally distributed, multi-model NoSQL database serv\", \"ice. Multiple APIs are available, including SQL API (formerly called DocumentDB), Cassandra, and Mon\", \"goDB.\\n\\n# <span id=\\\"page-96-2\\\"></span>Identity\\n\\n[Azure Active Directory](https://docs.microsoft.com/a\", \"zure/active-directory/) and [Azure Active Directory B2C](https://docs.microsoft.com/azure/active-dir\", \"ectory-b2c/) are both identity services. Azure Active Directory is designed for enterprise scenarios\", \" and enables Azure AD B2B (business-to-business) collaboration, while Azure Active Directory B2C is \", \"intended business-to-customer scenarios, including social network sign-in.\\n\\n# <span id=\\\"page-96-3\\\"><\", \"/span>Mobile\\n\\n[Notification Hubs](https://docs.microsoft.com/azure/notification-hubs/) is a multi-pl\", \"atform, scalable push-notification engine to quickly send millions of messages to apps running on va\", \"rious types of devices.\\n\\n# <span id=\\\"page-97-0\\\"></span>Web infrastructure\\n\\n[Azure Container Service]\", \"(https://docs.microsoft.com/azure/aks/) manages your hosted Kubernetes environment, making it quick \", \"and easy to deploy and manage containerized apps without container orchestration expertise.\\n\\n[Azure \", \"Search](https://docs.microsoft.com/azure/search/) is used to create an enterprise search solution ov\", \"er private, heterogenous content.\\n\\n[Service Fabric](https://docs.microsoft.com/azure/service-fabric/\", \") is a distributed systems platform that makes it easy to package, deploy, and manage scalable and r\", \"eliable microservices and containers.\"]"