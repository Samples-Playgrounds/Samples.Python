"[\"EDITION v4.0 - Updated to Azure Functions v4\\n\\nDOWNLOAD available at: https://aka.ms/serverlessbookpd\", \"f\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Visual Studio product teams\\n\\nA division of \", \"Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington 98052-6399\\n\\nCopyright \\u00a9 2018-2023 by M\", \"icrosoft Corporation\\n\\nAll rights reserved. No part of the contents of this book may be reproduced or\", \" transmitted in any form or by any means without the written permission of the publisher.\\n\\nThis book\", \" is provided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions and informat\", \"ion expressed in this book, including URL and other Internet website references, may change without \", \"notice.\\n\\nSome examples depicted herein are provided for illustration only and are fictitious. No rea\", \"l association or connection is intended or should be inferred.\\n\\nMicrosoft and the trademarks listed \", \"at https://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are trademarks of the Microsoft group of co\", \"mpanies.\\n\\nMac and macOS are trademarks of Apple Inc.\\n\\nAll other marks and logos are property of thei\", \"r respective owners.\\n\\nAuthor:\\n\\nJeremy Likness, Senior .NET Data Program Manager, Microsoft Corp.\\n\\nCo\", \"ntributor:\\n\\nCecil Phillip, Senior Cloud Advocate, Microsoft Corp.\\n\\nEditors:\\n\\nBill Wagner, Senior Con\", \"tent Developer, Microsoft Corp.\\n\\nMaira Wenzel, Senior Content Developer, Microsoft Corp.\\n\\nParticipan\", \"ts and reviewers:\\n\\nSteve Smith, Architect/Trainer, NimblePros.\\n\\nIntroduction\\n\\nServerless is the evol\", \"ution of cloud platforms in the direction of pure cloud native code. Serverless brings developers cl\", \"oser to business logic while insulating them from infrastructure concerns. It\\u2019s a pattern that doesn\", \"\\u2019t imply \\u201cno server\\u201d but rather, \\u201cless server.\\u201d Serverless code is event-driven. Code\\n\\nmay be trigge\", \"red by anything from a traditional HTTP web request to a timer or the result of uploading a file. Th\", \"e infrastructure behind serverless allows for instant scale to meet elastic demands and offers micro\", \"-billing to truly \\u201cpay for what you use.\\u201d Serverless requires a new way of thinking and approach to \", \"building applications and isn\\u2019t the right solution for every problem. As a developer, you must decid\", \"e:\\n\\nWhat are the pros and cons of serverless?\\n\\nWhy should you consider serverless for your own appli\", \"cations?\\n\\n\\n\\nHow can you build, test, deploy, and maintain your serverless code?\\n\\nWhere does it make \", \"sense to migrate code to serverless in existing applications, and what is the\\n\\nbest way to accomplis\", \"h this transformation?\\n\\nAbout this guide\\n\\nThis guide focuses on cloud native development of applicat\", \"ions that use serverless. The book highlights the benefits and exposes the potential drawbacks of de\", \"veloping serverless apps and provides a survey of serverless architectures. Many examples of how ser\", \"verless can be used are illustrated along with various serverless design patterns.\\n\\nThis guide expla\", \"ins the components of the Azure serverless platform and focuses specifically on implementation of se\", \"rverless using Azure Functions. You\\u2019ll learn about triggers and bindings as well as how to implement\", \" serverless apps that rely on state using durable functions. Finally, business examples and case stu\", \"dies will help provide context and a frame of reference to determine whether serverless is the right\", \" approach for your projects.\\n\\nEvolution of cloud platforms\\n\\nServerless is the culmination of several\", \" iterations of cloud platforms. The evolution began with physical metal in the data center and progr\", \"essed through Infrastructure as a Service (IaaS) and Platform as a Service (PaaS).\\n\\nBefore the cloud\", \", a discernible boundary existed between development and operations. Deploying an application meant \", \"answering myriad questions like:\\n\\nWhat hardware should be installed?\\n\\n\\n\\nHow is physical access to th\", \"e machine secured?\\n\\n\\n\\nDoes the data center require an Uninterruptible Power Supply (UPS)?\\n\\nWhere are\", \" storage backups sent?\\n\\n\\n\\nShould there be redundant power?\\n\\nThe list goes on and the overhead was en\", \"ormous. In many situations, IT departments were forced to deal with incredible waste. The waste was \", \"due to over-allocation of servers as backup machines for disaster recovery and standby servers to en\", \"able scale-out. Fortunately, the introduction of virtualization technology (like Hyper-V) with Virtu\", \"al Machines (VMs) gave rise to Infrastructure as a Service (IaaS). Virtualized infrastructure allowe\", \"d operations to set up a standard set of servers as the backbone, leading to a flexible environment \", \"capable of provisioning unique servers \\u201con demand.\\u201d More important, virtualization set the stage for\", \" using the cloud to provide virtual machines \\u201cas a service.\\u201d Companies could easily get out of the b\", \"usiness of worrying about redundant power or physical machines. Instead, they focused on the virtual\", \" environment.\\n\\nIaaS still requires heavy overhead because operations is still responsible for variou\", \"s tasks. These tasks include:\\n\\n\\n\\nPatching and backing up servers.\\n\\n\\n\\nInstalling packages.\\n\\n\\n\\nKeeping\", \" the operating system up-to-date.\\n\\nMonitoring the application.\\n\\nThe next evolution reduced the overh\", \"ead by providing Platform as a Service (PaaS). With PaaS, the cloud provider handles operating syste\", \"ms, security patches, and even the required packages to support a specific platform. Instead of buil\", \"ding a VM then configuring .NET and standing up Internet Information Services (IIS) servers, develop\", \"ers simply choose a \\u201cplatform target\\u201d such as \\u201cweb application\\u201d or \\u201cAPI endpoint\\u201d and deploy code di\", \"rectly. The infrastructure questions are reduced to:\\n\\nWhat size services are needed?\\n\\n\\n\\nHow do the s\", \"ervices scale out (add more servers or nodes)?\\n\\n\\n\\nHow do the services scale up (increase the capacit\", \"y of hosting servers or nodes)?\\n\\nServerless further abstracts servers by focusing on event-driven co\", \"de. Instead of a platform, developers can focus on a microservice that does one thing. The two key q\", \"uestions for building the serverless code are:\\n\\nWhat triggers the code?\\n\\nWhat does the code do?\\n\\nWit\", \"h serverless, infrastructure is abstracted. In some cases, the developer no longer worries about the\", \" host at all. Whether or not an instance of IIS, Kestrel, Apache, or some other web server is runnin\", \"g to manage web requests, the developer focuses on an HTTP trigger. The trigger provides the standar\", \"d, cross-platform payload for the request. The payload not only simplifies the development process, \", \"but facilitates testing and in some cases, makes the code easily portable across platforms.\\n\\nAnother\", \" feature of serverless is micro-billing. It\\u2019s common for web applications to host Web API endpoints.\", \" In traditional bare metal, IaaS and even PaaS implementations, the resources to host the APIs are p\", \"aid for continuously. That means you pay to host the endpoints even when they aren\\u2019t being accessed.\", \" Often you\\u2019ll find one API is called more than others, so the entire system is scaled\\n\\nbased on supp\", \"orting the popular endpoints. Serverless enables you to scale each endpoint independently and pay fo\", \"r usage, so no costs are incurred when the APIs aren\\u2019t being called. Migration may in many circumsta\", \"nces dramatically reduce the ongoing cost to support the endpoints.\\n\\nWhat this guide doesn\\u2019t cover\\n\\n\", \"This guide specifically emphasizes architecture approaches and design patterns and isn\\u2019t a deep dive\", \" into the implementation details of Azure Functions, Logic Apps, or other serverless platforms. This\", \" guide doesn\\u2019t cover, for example, advanced workflows with Logic Apps or features of Azure Functions\", \" such as configuring Cross-Origin Resource Sharing (CORS), applying custom domains, or uploading SSL\", \" certificates. These details are available through the online Azure Functions documentation.\\n\\nAdditi\", \"onal resources\\n\\n\\n\\nAzure Architecture center\\n\\n\\n\\nBest practices for cloud applications\\n\\nWho should use\", \" the guide\\n\\nThis guide was written for developers and solution architects who want to build enterpri\", \"se applications with .NET that may use serverless components either on premises or in the cloud. It\\u2019\", \"s useful to developers, architects, and technical decision makers interested in:\\n\\n\\n\\nUnderstanding th\", \"e pros and cons of serverless development\\n\\n\\n\\nLearning how to approach serverless architecture\\n\\n\\n\\nExa\", \"mple implementations of serverless apps\\n\\nHow to use the guide\\n\\nThe first part of this guide examines\", \" why serverless is a viable option by comparing several different architecture approaches. It examin\", \"es both the technology and development lifecycle, because all aspects of software development are im\", \"pacted by architecture decisions. The guide then examines use cases and design patterns and includes\", \" reference implementations using Azure Functions. Each section contains additional resources to lear\", \"n more about a particular area. The guide concludes with resources for walkthroughs and hands-on exp\", \"loration of serverless implementation.\\n\\nSend your feedback\\n\\nThe guide and related samples are consta\", \"ntly evolving, so your feedback is welcomed! If you have comments about how this guide can be improv\", \"ed, use the feedback section at the bottom of any page built on GitHub issues.\\n\\nContents\\n\\nArchitectu\", \"re approaches ......................................................................................\", \"................................................. 1\\n\\nArchitecture patterns .........................\", \"....................................................................................................\", \"................................. 1\\n\\nMonoliths .....................................................\", \"....................................................................................................\", \"........................... 1\\n\\nN-Layer applications ................................................\", \"....................................................................................................\", \"........... 2\\n\\nMicroservices .......................................................................\", \"....................................................................................................\", \".. 3\\n\\nArchitecture deployment approaches ...........................................................\", \".................................................................. 4\\n\\nN-Tier applications ..........\", \"....................................................................................................\", \"............................................... 5\\n\\nOn-premises and Infrastructure as a Service (IaaS\", \") ............................................................................................... 6\\n\", \"\\nPlatform as a Service (PaaS) ......................................................................\", \"...................................................................... 7\\n\\nSoftware as a Service (Saa\", \"S) .................................................................................................\", \".......................................... 7\\n\\nContainers and Functions as a Service (FaaS) .........\", \"................................................................................................. 8\\n\", \"\\nServerless ........................................................................................\", \"........................................................................................ 9\\n\\nSummary \", \"....................................................................................................\", \".......................................................................... 10\\n\\nRecommended resources\", \" ...................................................................................................\", \".......................................... 11\\n\\nServerless architecture .............................\", \"....................................................................................................\", \"........ 12\\n\\nFull serverless back end ..............................................................\", \"........................................................................................ 13\\n\\nMonolit\", \"hs and \\u201cstarving the beast\\u201d ........................................................................\", \"....................................................... 13\\n\\nWeb apps ...............................\", \"....................................................................................................\", \".............................................. 14\\n\\nMobile back ends ................................\", \"....................................................................................................\", \".............................. 14\\n\\nInternet of Things (IoT) ........................................\", \"....................................................................................................\", \"........... 15\\n\\nServerless architecture considerations .............................................\", \"............................................................................ 16\\n\\nManaging state ....\", \"....................................................................................................\", \"......................................................... 16\\n\\nLong-running processes ...............\", \"....................................................................................................\", \"............................. 16\\n\\nStartup time .....................................................\", \"....................................................................................................\", \"............... 17\\n\\nDatabase updates and migrations ................................................\", \"............................................................................ 17\\n\\nScaling ...........\", \"....................................................................................................\", \"................................................................... 17\\n\\nMonitoring, tracing, and log\", \"ging................................................................................................\", \"............................... 18\\n\\nInter-service dependencies .....................................\", \"....................................................................................................\", \". 18\\n\\ni\\n\\nContents\\n\\nManaging failure and providing resiliency .......................................\", \"..................................................................... 18\\n\\nVersioning and green/blue \", \"deployments ........................................................................................\", \"....................... 19\\n\\nServerless design examples .............................................\", \"................................................................................................. 19\", \"\\n\\nScheduling .......................................................................................\", \"................................................................................... 19\\n\\nCommand and \", \"Query Responsibility Segregation (CQRS) ............................................................\", \".................. 19\\n\\nEvent-based processing ......................................................\", \".......................................................................................... 20\\n\\nFile \", \"triggers and transformations........................................................................\", \"....................................................... 20\\n\\nAsynchronous background processing and m\", \"essaging ................................................................................... 21\\n\\nWeb\", \" apps and APIs .....................................................................................\", \".................................................................... 21\\n\\nData pipeline .............\", \"....................................................................................................\", \"..................................................... 22\\n\\nStream processing ........................\", \"....................................................................................................\", \"............................... 22\\n\\nAPI gateway ....................................................\", \"....................................................................................................\", \"................ 23\\n\\nRecommended resources .........................................................\", \".................................................................................... 23\\n\\nAzure serve\", \"rless platform .....................................................................................\", \".............................................. 24\\n\\nAzure Functions .................................\", \"....................................................................................................\", \"................................ 24\\n\\nProgramming language support ..................................\", \"............................................................................................. 25\\n\\nAp\", \"p service plans ....................................................................................\", \"......................................................................... 25\\n\\nCreate your first func\", \"tion ...............................................................................................\", \"............................................... 25\\n\\nUnderstand triggers and bindings ...............\", \"....................................................................................................\", \"......... 26\\n\\nTelemetry with Application Insights ..................................................\", \"............................................................................ 27\\n\\nAzure Logic Apps ..\", \"....................................................................................................\", \"............................................................ 29\\n\\nEvent Grid ........................\", \"....................................................................................................\", \"..................................................... 31\\n\\nScenarios.................................\", \"....................................................................................................\", \"......................................... 32\\n\\nEvent Grid vs. other Azure messaging services ........\", \"............................................................................................ 33\\n\\nPer\", \"formance targets....................................................................................\", \".................................................................... 34\\n\\nEvent Grid schema .........\", \"....................................................................................................\", \".............................................. 34\\n\\nAzure resources .................................\", \"....................................................................................................\", \"........................... 35\\n\\nConclusion .........................................................\", \"....................................................................................................\", \"............. 36\\n\\nRecommended resources ............................................................\", \"................................................................................. 36\\n\\nDurable Azure \", \"Functions ..........................................................................................\", \".......................................... 37\\n\\nTriggering a stateful workflow ......................\", \"....................................................................................................\", \"............... 37\\n\\nWorking with the Orchestration client ..........................................\", \".......................................................................... 37\\n\\nii\\n\\nContents\\n\\nThe orc\", \"hestrator function .................................................................................\", \"............................................................ 38\\n\\nThe activity functions ............\", \"....................................................................................................\", \"...................................... 39\\n\\nRecommended resources ...................................\", \"....................................................................................................\", \"........... 39\\n\\nOrchestration patterns .............................................................\", \"........................................................................................... 39\\n\\nFunc\", \"tion chaining ......................................................................................\", \"....................................................................... 40\\n\\nAsynchronous HTTP APIs .\", \"....................................................................................................\", \"......................................... 40\\n\\nMonitoring ...........................................\", \"....................................................................................................\", \"........................... 41\\n\\nRecommended resources ..............................................\", \"............................................................................................... 42\\n\\n\", \"Serverless business scenarios and use cases ........................................................\", \"...................................... 43\\n\\nBig data processing .....................................\", \"....................................................................................................\", \"..................... 43\\n\\nCreate serverless applications: hands-on lab .............................\", \"............................................................................... 43\\n\\nCustomer reviews\", \"....................................................................................................\", \".............................................................. 43\\n\\nFile processing and validation ..\", \"....................................................................................................\", \"................................... 44\\n\\nGame data visualization ....................................\", \"....................................................................................................\", \"............. 44\\n\\nGraphQL ..........................................................................\", \"....................................................................................................\", \"..... 44\\n\\nInternet of Things (IoT) reliable edge relay .............................................\", \"................................................................... 44\\n\\nMicroservices reference arch\", \"itecture ...........................................................................................\", \"................................. 44\\n\\nServerless for mobile ........................................\", \"....................................................................................................\", \"............... 45\\n\\nServerless messaging ...........................................................\", \"............................................................................................... 45\\n\\n\", \"Recommended resources ..............................................................................\", \".................................................................... 45\\n\\nConclusion ................\", \"....................................................................................................\", \"............................................ 46\\n\\niii\\n\\nContents\\n\\nCHAPTER 1 CHAPTER 1\\n\\nArchitecture ap\", \"proaches\\n\\nUnderstanding existing approaches to architecting enterprise apps helps clarify the role p\", \"layed by serverless. There are many approaches and patterns that evolved over decades of software de\", \"velopment, and all have their own pros and cons. In many cases, the ultimate solution may not involv\", \"e deciding on a single approach but may integrate several approaches. Migration scenarios often invo\", \"lve shifting from one architecture approach to another through a hybrid approach.\\n\\nThis chapter prov\", \"ides an overview of both logical and physical architecture patterns for enterprise applications.\\n\\nAr\", \"chitecture patterns\\n\\nModern business applications follow a variety of architecture patterns. This se\", \"ction represents a survey of common patterns. The patterns listed here aren\\u2019t necessarily all best p\", \"ractices, but illustrate different approaches.\\n\\nFor more information, see Azure application architec\", \"ture guide.\\n\\nMonoliths\\n\\nMany business applications follow a monolith pattern. Legacy applications ar\", \"e often implemented as monoliths. In the monolith pattern, all application concerns are contained in\", \" a single deployment. Everything from user interface to database calls is included in the same codeb\", \"ase.\\n\\n1\\n\\nCHAPTER 1 | Architecture approaches\\n\\nThere are several advantages to the monolith approach.\", \" It\\u2019s often easy to pull down a single code base and start working. Ramp up time may be less, and cr\", \"eating test environments is as simple as providing a new copy. The monolith may be designed to inclu\", \"de multiple components and applications.\\n\\nUnfortunately, the monolith pattern tends to break down at\", \" scale. Major disadvantages of the monolith approach include:\\n\\n\\n\\nDifficult to work in parallel in th\", \"e same code base.\\n\\n\\n\\nAny change, no matter how trivial, requires deploying a new version of the enti\", \"re application.\\n\\n\\n\\nRefactoring potentially impacts the entire application.\\n\\n\\n\\nOften the only solutio\", \"n to scale is to create multiple, resource-intensive copies of the monolith.\\n\\n\\n\\nAs systems expand or\", \" other systems are acquired, integration can be difficult.\\n\\n\\n\\nIt may be difficult to test due to the\", \" need to configure the entire monolith.\\n\\n\\n\\nCode reuse is challenging and often other apps end up hav\", \"ing their own copies of code.\\n\\nMany businesses look to the cloud as an opportunity to migrate monoli\", \"th applications and at the same time refactor them to more usable patterns. It\\u2019s common to break out\", \" the individual applications and components to allow them to be maintained, deployed, and scaled sep\", \"arately.\\n\\nN-Layer applications\\n\\nN-layer application partition application logic into specific layers\", \". The most common layers include:\\n\\n\\n\\nUser interface\\n\\n\\n\\nBusiness logic\\n\\n\\n\\nData access\\n\\n2\\n\\nCHAPTER 1 |\", \" Architecture approaches\\n\\nOther layers may include middleware, batch processing, and API. It\\u2019s impor\", \"tant to note the layers are logical. Although they\\u2019re developed in isolation, they may all be deploy\", \"ed to the same target platform.\\n\\nThere are several advantages to the N-Layer approach, including:\\n\\n\\n\", \"\\nRefactoring is isolated to a layer.\\n\\n\\n\\nTeams can independently build, test, deploy, and maintain se\", \"parate layers.\\n\\n\\n\\nLayers can be swapped out, for example the data layer may access multiple database\", \"s without requiring changes to the UI layer.\\n\\nServerless may be used to implement one or more layers\", \".\\n\\nMicroservices\\n\\nMicroservices architectures contain common characteristics that include:\\n\\n\\n\\nApplic\", \"ations are composed of several small services.\\n\\n\\n\\nEach service runs in its own process.\\n\\n\\n\\nServices \", \"are aligned around business domains.\\n\\n\\n\\nServices communicate over lightweight APIs, typically using \", \"HTTP as the transport.\\n\\n\\n\\nServices can be deployed and upgraded independently.\\n\\n\\n\\nServices aren\\u2019t de\", \"pendent on a single data store.\\n\\n\\n\\nThe system is designed with failure in mind, and the app may stil\", \"l run even when certain services fail.\\n\\nMicroservices don\\u2019t have to be mutually exclusive to other a\", \"rchitecture approaches. For example, an N-Tier architecture may use microservices for the middle tie\", \"r. It\\u2019s also possible to implement\\n\\n3\\n\\nCHAPTER 1 | Architecture approaches\\n\\nmicroservices in a varie\", \"ty of ways, from virtual directories on IIS hosts to containers. The characteristics of microservice\", \"s make them especially ideal for serverless implementations.\\n\\nThe pros of microservices architecture\", \"s include:\\n\\n\\n\\nRefactoring is often isolated to a single service.\\n\\n\\n\\nServices can be upgraded indepen\", \"dently of each other.\\n\\n\\n\\nResiliency and elasticity can be tuned to the demands of individual service\", \"s.\\n\\n\\n\\nDevelopment can happen in parallel across disparate teams and platforms.\\n\\n\\n\\nIt\\u2019s easier to wri\", \"te comprehensive tests for isolated services.\\n\\nMicroservices come with their own challenges, includi\", \"ng:\\n\\n\\n\\nDetermining what services are available and how to call them.\\n\\nManaging the lifecycle of serv\", \"ices.\\n\\n\\n\\nUnderstanding how services fit together in the overall application.\\n\\n\\n\\nFull system testing \", \"of calls made across disparate services.\\n\\nUltimately there are solutions to address all of these cha\", \"llenges, including tapping into the benefits of serverless that are discussed later.\\n\\nArchitecture d\", \"eployment approaches\\n\\nRegardless of the architecture approach used to design a business application,\", \" the implementation, or deployment of those applications may vary. Businesses host applications on e\", \"verything from physical hardware to serverless functions.\\n\\n4\\n\\nCHAPTER 1 | Architecture approaches\\n\\nN\", \"-Tier applications\\n\\nThe N-Tier architecture pattern is a mature architecture and simply refers to ap\", \"plications that separate various logical layers into separate physical tiers. N-Tier architecture is\", \" a physical implementation of N-Layer architecture. The most common implementation of this architect\", \"ure includes:\\n\\n\\n\\nA presentation tier, for example a web app.\\n\\n\\n\\nAn API or data access tier, such as \", \"a REST API.\\n\\n\\n\\nA data tier, such as a SQL database.\\n\\nN-tier solutions have the following characteris\", \"tics:\\n\\n\\n\\nProjects are typically aligned with tiers.\\n\\n\\n\\nTesting may be approached differently by tier\", \".\\n\\n\\n\\nTiers provide layers of abstraction, for example the presentation tier is typically ignorant of\", \" the implementation details of the data tier.\\n\\n\\n\\nTypically, layers only interact with adjacent layer\", \"s.\\n\\n\\n\\nReleases are often managed at the project, and therefore tier, level. A simple API change may \", \"require a new release of an entire middle tier.\\n\\nThis approach provides several benefits, including:\", \"\\n\\n\\n\\nIsolation of the database (often the front end doesn\\u2019t have direct access to the database back e\", \"nd).\\n\\n\\n\\nReuse of the API (for example, mobile, desktop, and web app clients can all reuse the same A\", \"PIs).\\n\\n5\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\n\\nAbility to scale out tiers independent of each othe\", \"r.\\n\\n\\n\\nRefactoring isolation: one tier may be refactored without impacting other tiers.\\n\\nOn-premises \", \"and Infrastructure as a Service (IaaS)\\n\\nThe traditional approach to hosting applications requires bu\", \"ying hardware and managing all of the software installations, including the operating system. Origin\", \"ally this involved expensive data centers and physical hardware. The challenges that come with opera\", \"ting physical hardware are many, including:\\n\\n\\n\\nThe need to buy excess for \\u201cjust in case\\u201d or peak dem\", \"and scenarios.\\n\\n\\n\\nSecuring physical access to the hardware.\\n\\n\\n\\nResponsibility for hardware failure (\", \"such as disk failure).\\n\\n\\n\\nCooling.\\n\\n\\n\\nConfiguring routers and load balancers.\\n\\n\\n\\nPower redundancy.\\n\\n\", \"\\n\\nSecuring software access.\\n\\nVirtualization of hardware, via \\u201cvirtual machines\\u201d enables Infrastructu\", \"re as a Service (IaaS). Host machines are effectively partitioned to provide resources to instances \", \"with allocations for their own memory, CPU, and storage. The team provisions the necessary VMs and c\", \"onfigures the associated networks and access to storage.\\n\\nFor more information, see virtual machine \", \"N-tier reference architecture.\\n\\nAlthough virtualization and Infrastructure as a Service (IaaS) addre\", \"ss many concerns, it still leaves much responsibility in the hands of the infrastructure team. The t\", \"eam maintains operating system versions, applies security patches, and installs third-party dependen\", \"cies on the target machines. Apps often behave differently on production machines compared to the te\", \"st environment. Issues arise due to different dependency versions and/or OS SKU levels. Although man\", \"y organizations deploy N-Tier applications to these targets, many companies benefit from deploying t\", \"o a more cloud native model\\n\\n6\\n\\nCHAPTER 1 | Architecture approaches\\n\\nsuch as Platform as a Service. \", \"Architectures with microservices are more challenging because of the requirements to scale out for e\", \"lasticity and resiliency.\\n\\nFor more information, see virtual machines.\\n\\nPlatform as a Service (PaaS)\", \"\\n\\nPlatform as a Service (PaaS) offers configured solutions that developers can plug into directly. P\", \"aaS is another term for managed hosting. It eliminates the need to manage the base operating system,\", \" security patches and in many cases any third-party dependencies. Examples of platforms include web \", \"applications, databases, and mobile back ends.\\n\\nPaaS addresses the challenges common to IaaS. PaaS a\", \"llows the developer to focus on the code or database schema rather than how it gets deployed. Benefi\", \"ts of PaaS include:\\n\\n\\n\\nPay for use models that eliminate the overhead of investing in idle machines.\", \"\\n\\n\\n\\nDirect deployment and improved DevOps, continuous integration (CI), and continuous delivery (CD)\", \" pipelines.\\n\\n\\n\\nAutomatic upgrades, updates, and security patches.\\n\\n\\n\\nPush-button scale out and scale\", \" up (elastic scale).\\n\\nThe main disadvantage of PaaS traditionally has been vendor lock-in. For examp\", \"le, some PaaS providers only support ASP.NET, Node.js, or other specific languages and platforms. Pr\", \"oducts like Azure App Service have evolved to address multiple platforms and support a variety of la\", \"nguages and frameworks for hosting web apps.\\n\\nSoftware as a Service (SaaS)\\n\\nSoftware as a Service or\", \" SaaS is centrally hosted and available without local installation or provisioning. SaaS often is ho\", \"sted on top of PaaS as a platform for deploying software. SaaS provides services to run and connect \", \"with existing software. SaaS is often industry and vertical specific. SaaS is often licensed and typ\", \"ically provides a client/server model. Most modern SaaS offerings use web-\\n\\n7\\n\\nCHAPTER 1 | Architect\", \"ure approaches\\n\\nbased apps for the client. Companies typically consider SaaS as a business solution \", \"to license offerings. It isn\\u2019t often implemented as architecture consideration for scalability and m\", \"aintainability of an application. Indeed, most SaaS solutions are built on IaaS, PaaS, and/or server\", \"less back ends.\\n\\nLearn more about SaaS through a sample application.\\n\\nContainers and Functions as a \", \"Service (FaaS)\\n\\nContainers are an interesting solution that enables PaaS-like benefits without the I\", \"aaS overhead. A container is essentially a runtime that contains the bare essentials needed to run a\", \" unique application. The kernel or core part of the host operating system and services such as stora\", \"ge are shared across a host. The shared kernel enables containers to be lightweight (some are mere m\", \"egabytes in size, compared to the gigabyte size of typical virtual machines). With hosts already run\", \"ning, containers can be started quickly, facilitating high availability. The ability to spin up cont\", \"ainers quickly also provides extra layers of resiliency. Docker is one of the more popular implement\", \"ations of containers.\\n\\nBenefits of containers include:\\n\\n\\n\\nLightweight and portable\\n\\n\\n\\nSelf-contained\", \" so no need to install dependencies\\n\\n\\n\\nProvide a consistent environment regardless of the host (runs\", \" exactly same on a laptop as on a cloud server)\\n\\n\\n\\nCan be provisioned quickly for scale-out\\n\\n\\n\\nCan b\", \"e restarted quickly to recover from failure\\n\\nA container runs on a container host (that in turn may \", \"run on a bare metal machine or a virtual machine). Multiple containers or instances of the same cont\", \"ainers may run on a single host. For true failover and resiliency, containers must be scaled across \", \"hosts.\\n\\nFor more information about Docker containers, see What is Docker.\\n\\nManaging containers acros\", \"s hosts typically requires an orchestration tool such as Kubernetes. Configuring and managing orches\", \"tration solutions may add additional overhead and complexity to projects. Fortunately, many cloud pr\", \"oviders provide orchestration services through PaaS solutions to simplify the management of containe\", \"rs.\\n\\nThe following image illustrates an example Kubernetes installation. Nodes in the installation a\", \"ddress scale out and failover. They run Docker container instances that are managed by the primary s\", \"erver. The kubelet is the client that relays commands from Kubernetes to Docker.\\n\\n8\\n\\nCHAPTER 1 | Arc\", \"hitecture approaches\\n\\nFor more information about orchestration, see Kubernetes on Azure.\\n\\nFunctions \", \"as a Service (FaaS) is a specialized container service that is similar to serverless. A specific imp\", \"lementation of FaaS, called OpenFaaS, sits on top of containers to provide serverless capabilities. \", \"OpenFaaS provides templates that package all of the container dependencies necessary to run a piece \", \"of code. Using templates simplifies the process of deploying code as a functional unit. OpenFaaS tar\", \"gets architectures that already include containers and orchestrators because it can use the existing\", \" infrastructure. Although it provides serverless functionality, it specifically requires you to use \", \"Docker and an orchestrator.\\n\\nServerless\\n\\nA serverless architecture provides a clear separation betwe\", \"en the code and its hosting environment. You implement code in a function that is invoked by a trigg\", \"er. After that function exits, all its needed resources may be freed. The trigger might be manual, a\", \" timed process, an HTTP request, or a file upload. The result of the trigger is the execution of cod\", \"e. Although serverless platforms vary, most provide access to pre-defined APIs and bindings to strea\", \"mline tasks such as writing to a database or queueing results.\\n\\nServerless is an architecture that r\", \"elies heavily on abstracting away the host environment to focus on code. It can be thought of as les\", \"s server.\\n\\nContainer solutions provide developers existing build scripts to publish code to serverle\", \"ss-ready images. Other implementations use existing PaaS solutions to provide a scalable architectur\", \"e.\\n\\nThe abstraction means the DevOps team doesn\\u2019t have to provision or manage servers, nor specific \", \"containers. The serverless platform hosts code, either as script or packaged executables built with \", \"a related SDK, and allocates the necessary resources for the code to scale.\\n\\nThe following diagram i\", \"llustrates four serverless components. An HTTP request causes the Checkout API code to run. The Chec\", \"kout API inserts code into a database, and the insert triggers several other functions to run to per\", \"form tasks like computing tasks and fulfilling the order.\\n\\n9\\n\\nCHAPTER 1 | Architecture approaches\\n\\nT\", \"he advantages of serverless include:\\n\\n\\n\\nHigh density. Many instances of the same serverless code can\", \" run on the same host compared to containers or virtual machines. The instances scale across multipl\", \"e hosts addressing scale out and resiliency.\\n\\nMicro-billing. Most serverless providers bill based on\", \" serverless executions, enabling massive\\n\\ncost savings in certain scenarios.\\n\\n\\n\\nInstant scale. Serve\", \"rless can scale to match workloads automatically and quickly.\\n\\n\\n\\nFaster time to market. Developers f\", \"ocus on code and deploy directly to the serverless platform. Components can be released independentl\", \"y of each other.\\n\\nServerless is most often discussed in the context of compute, but can also apply t\", \"o data. For example, Azure SQL and Cosmos DB both provide cloud databases that don\\u2019t require you to \", \"configure host machines or clusters. This book focuses on serverless compute.\\n\\nSummary\\n\\nThere\\u2019s a br\", \"oad spectrum of available choices for architecture, including a hybrid approach. Serverless simplifi\", \"es the approach, management, and cost of application features at the expense of control and portabil\", \"ity. However, many serverless platforms do expose configuration to help fine-tune the solution. Good\", \" programming practices can also lead to more portable code and less serverless platform lock-in. The\", \" following table illustrates the architecture approaches side by side. Choose serverless based on yo\", \"ur scale needs, whether or not you want to manage the runtime, and how well you can break your workl\", \"oads into small components. You\\u2019ll learn about potential challenges with serverless and other decisi\", \"on points in the next chapter.\\n\\nIaaS\\n\\nPaaS\\n\\nContainer\\n\\nServerless\\n\\nScale\\n\\nVM\\n\\nInstance\\n\\nApp\\n\\nFunctio\", \"n\\n\\nAbstracts\\n\\nHardware\\n\\nPlatform\\n\\nOS Host\\n\\nRuntime\\n\\nUnit\\n\\nVM\\n\\nProject\\n\\nImage\\n\\nCode\\n\\n10\\n\\nCHAPTER 1 | \", \"Architecture approaches\\n\\nIaaS\\n\\nPaaS\\n\\nContainer\\n\\nServerless\\n\\nLifetime\\n\\nMonths\\n\\nDays to Months Minutes\", \" to Days\\n\\nMilliseconds to Minutes\\n\\nResponsibility Applications,\\n\\ndependencies, runtime, and operatin\", \"g system\\n\\nApplications and dependencies\\n\\nApplications, dependencies, and runtime\\n\\nFunction\\n\\n\\n\\nScale \", \"refers to the unit that is used to scale the application\\n\\n\\n\\nAbstracts refers to the layer that is ab\", \"stracted by the implementation\\n\\n\\n\\nUnit refers to the scope of what is deployed\\n\\n\\n\\nLifetime refers to\", \" the typical runtime of a specific instance\\n\\n\\n\\nResponsibility refers to the overhead to build, deplo\", \"y, and maintain the application\\n\\nThe next chapter will focus on serverless architecture, use cases, \", \"and design patterns.\\n\\nRecommended resources\\n\\n\\n\\nAzure application architecture guide\\n\\n\\n\\nAzure Cosmos \", \"DB\\n\\n\\n\\nAzure SQL\\n\\n\\n\\nN-Tier architecture pattern\\n\\n\\n\\nKubernetes on Azure\\n\\nMicroservices\\n\\n\\n\\nVirtual mach\", \"ine N-tier reference architecture\\n\\n\\n\\nVirtual machines\\n\\nWhat is Docker?\\n\\nWingtip Tickets SaaS applica\", \"tion\\n\\n11\\n\\nCHAPTER 1 | Architecture approaches\\n\\nCHAPTER 2 CHAPTER 2\\n\\nServerless architecture\\n\\nThere a\", \"re many approaches to using serverless architectures. This chapter explores examples of common archi\", \"tectures that integrate serverless. It also covers concerns that may pose additional challenges or r\", \"equire extra consideration when implementing serverless. Finally, several design examples are provid\", \"ed that illustrate various serverless use cases.\\n\\nServerless hosts often use an existing container-b\", \"ased or PaaS layer to manage the serverless instances. For example, Azure Functions is based on Azur\", \"e App Service. The App Service is used to scale out instances and manage the runtime that executes A\", \"zure Functions code. For Windows-based functions, the host runs as PaaS and scales out the .NET runt\", \"ime. For Linux-based functions, the host leverages containers.\\n\\nThe WebJobs Core provides an executi\", \"on context for the function. The Language Runtime runs scripts, executes libraries and hosts the fra\", \"mework for the target language. For example, Node.js is used to run JavaScript functions and the .NE\", \"T Framework is used to run C# functions. You\\u2019ll learn more about language and platform options later\", \" in this chapter.\\n\\nSome projects may benefit from taking an \\u201call-in\\u201d approach to serverless. Applica\", \"tions that rely heavily on microservices may implement all microservices using serverless technology\", \". The majority of apps are hybrid, following an N-tier design and using serverless for the component\", \"s that make sense\\n\\n12\\n\\nCHAPTER 2 | Serverless architecture\\n\\nbecause the components are modular and i\", \"ndependently scalable. To help make sense of these scenarios, this section walks through some common\", \" architecture examples that use serverless.\\n\\nFull serverless back end\\n\\nThe full serverless back end \", \"is ideal for several types of scenarios, especially when building new or \\u201cgreen field\\u201d applications.\", \" An application with a large surface area of APIs may benefit from implementing each API as a server\", \"less function. Apps that are based on microservices architecture are another example that could be i\", \"mplemented as a full serverless back end. The microservices communicate over various protocols with \", \"each other. Specific scenarios include:\\n\\n\\n\\nAPI-based SaaS products (example: financial payments proc\", \"essor).\\n\\nMessage-driven applications (example: device monitoring solution).\\n\\n\\n\\nApps focused on integ\", \"ration between services (example: airline booking application).\\n\\n\\n\\nProcesses that run periodically (\", \"example: timer-based database clean-up).\\n\\n\\n\\nApps focused on data transformation (example: import tri\", \"ggered by file upload).\\n\\n\\n\\nExtract Transform and Load (ETL) processes.\\n\\nThere are other, more specif\", \"ic use cases that are covered later in this document.\\n\\nMonoliths and \\u201cstarving the beast\\u201d\\n\\nA common \", \"challenge is migrating an existing monolithic application to the cloud. The least risky approach is \", \"to \\u201clift and shift\\u201d entirely onto virtual machines. Many shops prefer to use the migration as an opp\", \"ortunity to modernize their code base. A practical approach to migration is called \\u201cstarving the bea\", \"st.\\u201d In this scenario, the monolith is migrated \\u201cas is\\u201d to start with. Then, selected services are m\", \"odernized. In some cases, the signature of the service is identical to the original: it simply is ho\", \"sted as a function. Clients are updated to use the new service rather than the monolith endpoint. In\", \" the interim, steps such as database replication enable microservices to host their own storage even\", \" when transactions are still handled by the monolith. Eventually, all clients are migrated onto the \", \"new services. The monolith is \\u201cstarved\\u201d (its services no longer called) until all functionality has \", \"been replaced. The combination of serverless and proxies can facilitate much of this migration.\\n\\n13\\n\", \"\\nCHAPTER 2 | Serverless architecture\\n\\nTo learn more about this approach, watch the video: Bring your\", \" app to the cloud with serverless Azure Functions.\\n\\nWeb apps\\n\\nWeb apps are great candidates for serv\", \"erless applications. There are two common approaches to web apps today: server-driven, and client-dr\", \"iven (such as Single Page Application or SPA). Server-driven web apps typically use a middleware lay\", \"er to issue API calls to render the web UI. SPA applications make REST API calls directly from the b\", \"rowser. In both scenarios, serverless can accommodate the middleware or REST API request by providin\", \"g the necessary business logic. A common architecture is to stand up a lightweight static web server\", \". The Single Page Application (SPA) serves HTML, CSS, JavaScript, and other browser assets. The web \", \"app then connects to a microservices back end.\\n\\nMobile back ends\\n\\nThe event-driven paradigm of serve\", \"rless apps makes them ideal as mobile back ends. The mobile device triggers the events and the serve\", \"rless code executes to satisfy requests. Taking advantage of a serverless model enables developers t\", \"o enhance business logic without having to deploy a full application update. The serverless approach\", \" also enables teams to share endpoints and work in parallel.\\n\\nMobile developers can build business l\", \"ogic without becoming experts on the server side. Traditionally, mobile apps connected to on-premise\", \"s services. Building the service layer required understanding the server platform and programming pa\", \"radigm. Developers worked with operations to provision servers\\n\\n14\\n\\nCHAPTER 2 | Serverless architect\", \"ure\\n\\nand configure them appropriately. Sometimes days or even weeks were spent on building a deploym\", \"ent pipeline. All of these challenges are addressed by serverless.\\n\\nServerless abstracts the server-\", \"side dependencies and enables the developer to focus on business logic. For example, a mobile develo\", \"per who builds apps using a JavaScript framework can build serverless functions with JavaScript as w\", \"ell. The serverless host manages the operating system, a Node.js instance to host the code, package \", \"dependencies, and more. The developer is provided a simple set of inputs and a standard template for\", \" outputs. They then can focus on building and testing the business logic. They\\u2019re therefore able to \", \"use existing skills to build the back-end logic for the mobile app without having to learn new platf\", \"orms or become a \\u201cserver-side developer.\\u201d\\n\\nMost cloud providers offer mobile-based serverless produc\", \"ts that simplify the entire mobile development lifecycle. The products may automate the provisioning\", \" of databases to persist data, handle DevOps concerns, provide cloud-based builds and testing framew\", \"orks and the ability to script business processes using the developer\\u2019s preferred language. Followin\", \"g a mobile-centric serverless approach can streamline the process. Serverless removes the tremendous\", \" overhead of provisioning, configuring, and maintaining servers for the mobile back end.\\n\\nInternet o\", \"f Things (IoT)\\n\\nIoT refers to physical objects that are networked together. They\\u2019re sometimes referr\", \"ed to as \\u201cconnected devices\\u201d or \\u201csmart devices.\\u201d Everything from cars and vending machines may be co\", \"nnected and send information ranging from inventory to sensor data such as temperature and humidity.\", \" In the enterprise, IoT provides business process improvements through monitoring and automation. Io\", \"T data may be used to regulate the climate in a large warehouse or track inventory through the suppl\", \"y chain. IoT can sense chemical spills and call the fire department when smoke is detected.\\n\\nThe she\", \"er volume of devices and information often dictates an event-driven architecture to route and proces\", \"s messages. Serverless is an ideal solution for several reasons:\\n\\n\\n\\nEnables scale as the volume of d\", \"evices and data increases.\\n\\n\\n\\nAccommodates adding new endpoints to support new devices and sensors.\\n\", \"\\n\\n\\nFacilitates independent versioning so developers can update the business logic for a specific dev\", \"ice without having to deploy the entire system.\\n\\n\\n\\nResiliency and less downtime.\\n\\n15\\n\\nCHAPTER 2 | Se\", \"rverless architecture\\n\\nThe pervasiveness of IoT has resulted in several serverless products that foc\", \"us specifically on IoT concerns, such as Azure IoT Hub. Serverless automates tasks such as device re\", \"gistration, policy enforcement, tracking, and even deployment of code to devices at the edge. The ed\", \"ge refers to devices like sensors and actuators that are connected to, but not an active part of, th\", \"e Internet.\\n\\nServerless architecture considerations\\n\\nAdopting a serverless architecture does come wi\", \"th certain challenges. This section explores some of the more common considerations to be aware of. \", \"All of these challenges have solutions. As with all architecture choices, the decision to go serverl\", \"ess should be made only after carefully considering the pros and cons. Depending on the needs of you\", \"r application, you may decide a serverless implementation isn\\u2019t the right solution for certain compo\", \"nents.\\n\\nManaging state\\n\\nServerless functions, as with microservices in general, are stateless by def\", \"ault. Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency wit\", \"hout a central point of failure. In some circumstances, business processes require state. If your pr\", \"ocess requires state, you have two options. You can adopt a model other than serverless, or interact\", \" with a separate service that provides state. Adding state can complicate the solution and make it h\", \"arder to scale, and potentially create a single point of failure. Carefully consider whether your fu\", \"nction absolutely requires state. If the answer is \\u201cyes,\\u201d determine whether it still makes sense to \", \"implement it with serverless.\\n\\nThere are several solutions to adopt state without compromising the b\", \"enefits of serverless. Some of the more popular solutions include:\\n\\n\\n\\nUse a temporary data store or \", \"distributed cache, like Redis\\n\\n\\n\\nStore state in a database, like SQL or CosmosDB\\n\\n\\n\\nHandle state thr\", \"ough a workflow engine like durable functions\\n\\nThe bottom line is that you should be aware of the ne\", \"ed for any state management within processes you\\u2019re considering to implement with serverless.\\n\\nLong-\", \"running processes\\n\\nMany benefits of serverless rely on the processes being ephemeral. Short run time\", \"s make it easier for the serverless provider to free up resources as functions end and share functio\", \"ns across hosts. Most cloud providers limit the total time your function can run to around 10 minute\", \"s. If your process may take longer, you might consider an alternative implementation.\\n\\nThere are a f\", \"ew exceptions and solutions. One solution may be to break your process into smaller components that \", \"individually take less time to run. If your process runs long because of dependencies, you can also \", \"consider an asynchronous workflow using a solution like durable functions. Durable functions pause a\", \"nd maintain the state of your process while it\\u2019s waiting on an external process to finish. Asynchron\", \"ous handling reduces the time the actual process runs.\\n\\n16\\n\\nCHAPTER 2 | Serverless architecture\\n\\nSta\", \"rtup time\\n\\nOne potential concern with serverless implementations is startup time. To conserve resour\", \"ces, many serverless providers create infrastructure \\u201con demand.\\u201d When a serverless function is trig\", \"gered after a period of time, the resources to host the function may need to be created or restarted\", \". In some situations, cold starts may result in delays of several seconds. Startup time varies acros\", \"s providers and service levels. There are a few approaches to address startup time if it\\u2019s important\", \" to minimize for the success of the app.\\n\\n\\n\\nSome providers allow users to pay for service levels tha\", \"t guarantee infrastructure is \\u201calways on\\u201d.\\n\\n\\n\\nImplement a keep-alive mechanism (ping the endpoint to\", \" keep it \\u201cawake\\u201d).\\n\\n\\n\\nUse orchestration like Kubernetes with a containerized function approach (the \", \"host is already running so spinning up new instances is extremely fast).\\n\\nDatabase updates and migra\", \"tions\\n\\nAn advantage of serverless code is that you can release new functions without having to redep\", \"loy the entire application. This advantage can become a disadvantage when there\\u2019s a relational datab\", \"ase involved. Changes to database schemas are difficult to synchronize with serverless updates. Addi\", \"tional challenges are posed when things go wrong and the changes must be rolled back. Data integrity\", \" is one reason that a best practice for microservices and serverless functions is that they own thei\", \"r own data. It is possible to deploy changes as a single unit of compute and data. The reality is th\", \"at many legacy systems feature a large back-end database that must be reconciled with the serverless\", \" architecture.\\n\\nA popular approach to solve schema versioning is to never modify existing properties\", \" and columns, but instead add new information. For example, consider a change to move from a Boolean\", \" \\u201ccompleted\\u201d flag for a todo list to a \\u201ccompleted date.\\u201d Instead of removing the old field, the data\", \"base change will:\\n\\n1.\\n\\nAdd a new \\u201ccompleted date\\u201d field.\\n\\n2.\\n\\nTransform the \\u201ccompleted\\u201d Boolean fiel\", \"d to a computed function that evaluates whether the completed date is after the current date.\\n\\n3.\\n\\nA\", \"dd a trigger to set the completed date to the current date when the completed Boolean is set to true\", \".\\n\\nThe sequence of changes ensures that legacy code continues to run \\u201cas is\\u201d while newer serverless \", \"functions can take advantage of the new field.\\n\\nFor more information about data in serverless archit\", \"ectures, see Challenges and solutions for distributed data management.\\n\\nScaling\\n\\nIt\\u2019s a common misco\", \"nception that serverless means \\u201cno server.\\u201d It\\u2019s in fact \\u201cless server.\\u201d The fact there is a backing \", \"infrastructure is important to understand when it comes to scaling. Most serverless platforms provid\", \"e a set of controls to handle how the infrastructure should scale when event density increases. You \", \"can choose from a variety of options, but your strategy may vary depending on the\\n\\n17\\n\\nCHAPTER 2 | S\", \"erverless architecture\\n\\nfunction. Furthermore, functions are typically run under a related host, so \", \"that functions on the same host have the same scale options. Therefore it is necessary to organize a\", \"nd strategize which functions are hosted together based on scale requirements.\\n\\nRules often specify \", \"how to scale-up (increase the host resources) and scale-out (increase the number of host instances) \", \"based on varying parameters. Triggers for scales may include schedule, request rates, CPU utilizatio\", \"n, and memory usage. Higher performance often comes at a greater cost. The less expensive, consumpti\", \"on-based approaches may not scale as quickly when the request rate suddenly increases. There is a tr\", \"ade-off between paying up front \\u201cinsurance cost\\u201d versus paying strictly \\u201cas you go\\u201d and risking slow\", \"er responses due to sudden increases in demand.\\n\\nMonitoring, tracing, and logging\\n\\nAn often overlook\", \"ed aspect of DevOps is monitoring applications once deployed. It\\u2019s important to have a strategy for \", \"monitoring serverless functions. The biggest challenge is often correlation, or recognizing when a u\", \"ser calls multiple functions as part of the same interaction. Most serverless platforms allow consol\", \"e logging that can be imported into third-party tools. There are also options to automate collection\", \" of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed \", \"insights. Azure provides the advanced Application Insights platform for monitoring and analytics.\\n\\nI\", \"nter-service dependencies\\n\\nA serverless architecture may include functions that rely on other functi\", \"ons. In fact, it isn\\u2019t uncommon in a serverless architecture to have multiple services call each oth\", \"er as part of an interaction or distributed transaction. To avoid strong coupling, it\\u2019s recommended \", \"that services don\\u2019t reference each other directly. When the endpoint for a service needs to change, \", \"direct references could result in major refactoring. A suggested solution is to provide a service di\", \"scovery mechanism, such as a registry, that provides the appropriate end point for a request type. A\", \"nother solution is to leverage messaging services like queues or topics for communication between se\", \"rvices.\\n\\nManaging failure and providing resiliency\\n\\nIt\\u2019s also important to consider the circuit-brea\", \"ker pattern: If, for some reason, a service continues to fail, it isn\\u2019t advisable to call that servi\", \"ce repeatedly. Instead, an alternative service is called or a message returned until the health of t\", \"he dependent service is re-established. The serverless architecture needs to take into account the s\", \"trategy for resolving and managing inter-service dependencies.\\n\\nTo continue the circuit-breaker patt\", \"ern, services need to be fault tolerant and resilient. Fault tolerance refers to the ability of your\", \" application to continue running even after unexpected exceptions or invalid states are encountered.\", \" Fault tolerance is typically a function of the code itself and how it\\u2019s written to handle exception\", \"s. Resiliency refers to how capable the app is at recovering from failures. Resiliency is often mana\", \"ged by the serverless platform. The platform should be able to spin up a new serverless function ins\", \"tance when the existing one fails. The platform should also be intelligent enough to stop spinning u\", \"p new instances when every new instance fails.\\n\\n18\\n\\nCHAPTER 2 | Serverless architecture\\n\\nFor more in\", \"formation, see Implementing the Circuit Breaker pattern.\\n\\nVersioning and green/blue deployments\\n\\nA m\", \"ajor benefit of serverless is the ability to upgrade a specific function without having to redeploy \", \"the entire application. For upgrades to be successful, functions must be versioned so that services \", \"calling them are routed to the correct version of code. A strategy for deploying new versions is als\", \"o important. A common approach is to use \\u201cgreen/blue deployments.\\u201d The green deployment is the curre\", \"nt function. A new \\u201cblue\\u201d version is deployed to production and tested. When testing passes, the gre\", \"en and blue versions are swapped so the new version comes live. If any issues are encountered, they \", \"can be swapped back. Supporting versioning and green/blue deployments requires a combination of auth\", \"oring the functions to accommodate version changes and working with the serverless platform to handl\", \"e deployments.\\n\\nServerless design examples\\n\\nThere are many design patterns that exist for serverless\", \". This section captures some common scenarios that use serverless. What all of the examples have in \", \"common is the fundamental combination of an event trigger and business logic.\\n\\nScheduling\\n\\nSchedulin\", \"g tasks is a common function. The following diagram shows a legacy database that doesn\\u2019t have approp\", \"riate integrity checks. The database must be scrubbed periodically. The serverless function finds in\", \"valid data and cleans it. The trigger is a timer that runs the code on a schedule.\\n\\nCommand and Quer\", \"y Responsibility Segregation (CQRS)\\n\\nCommand and Query Responsibility Segregation (CQRS) is a patter\", \"n that provides different interfaces for reading (or querying) data and operations that modify data.\", \" It addresses several common problems. In traditional Create Read Update Delete (CRUD) based systems\", \", conflicts can arise from high volume of both reads and writes to the same data store. Locking may \", \"frequently occur and dramatically slow down reads. Often, data is presented as a composite of severa\", \"l domain objects and read operations must combine data from different entities.\\n\\nUsing CQRS, a read \", \"might involve a special \\u201cflattened\\u201d entity that models data the way it\\u2019s consumed. The read is handl\", \"ed differently than how it\\u2019s stored. For example, although the database may store a contact as a hea\", \"der record with a child address record, the read could involve an entity with both\\n\\n19\\n\\nCHAPTER 2 | \", \"Serverless architecture\\n\\nheader and address properties. There are myriad approaches to creating the \", \"read model. It might be materialized from views. Update operations could be encapsulated as isolated\", \" events that then trigger updates to two different models. Separate models exist for reading and wri\", \"ting.\\n\\nServerless can accommodate the CQRS pattern by providing the segregated endpoints. One server\", \"less function accommodates queries or reads, and a different serverless function or set of functions\", \" handles update operations. A serverless function may also be responsible for keeping the read model\", \" up-to-date, and can be triggered by the database\\u2019s change feed. Front-end development is simplified\", \" to connecting to the necessary endpoints. Processing of events is handled on the back end. This mod\", \"el also scales well for large projects because different teams may work on different operations.\\n\\nEv\", \"ent-based processing\\n\\nIn message-based systems, events are often collected in queues or publisher/su\", \"bscriber topics to be acted upon. These events can trigger serverless functions to execute a piece o\", \"f business logic. An example of event-based processing is event-sourced systems. An \\u201cevent\\u201d is raise\", \"d to mark a task as complete. A serverless function triggered by the event updates the appropriate d\", \"atabase document. A second serverless function may use the event to update the read model for the sy\", \"stem. Azure Event Grid provides a way to integrate events with functions as subscribers.\\n\\nEvents are\", \" informational messages. For more information, see Event Sourcing pattern.\\n\\nFile triggers and transf\", \"ormations\\n\\nExtract, Transform, and Load (ETL) is a common business function. Serverless is a great s\", \"olution for ETL because it allows code to be triggered as part of a pipeline. Individual code compon\", \"ents can address various aspects. One serverless function may download the file, another applies the\", \" transformation, and another loads the data. The code can be tested and deployed independently, maki\", \"ng it easier to maintain and scale where needed.\\n\\n20\\n\\nCHAPTER 2 | Serverless architecture\\n\\nIn the di\", \"agram, \\u201ccool storage\\u201d provides data that is parsed in Azure Stream Analytics. Any issues encountered\", \" in the data stream trigger an Azure Function to address the anomaly.\\n\\nAsynchronous background proce\", \"ssing and messaging\\n\\nAsynchronous messaging and background processing allow applications to kick off\", \" processes without having to wait. An example of asynchronous processing is an OCR app. An image is \", \"submitted and queued for processing. Scanning the image to extract text may take time, and once it\\u2019s\", \" finished a notification is sent. Serverless can handle both the invocation and the result in this s\", \"cenario.\\n\\nWeb apps and APIs\\n\\nA popular scenario for serverless is N-tier applications, most commonly\", \" ones where the UI layer is a web app. The popularity of Single Page Applications (SPA) has surged r\", \"ecently. SPA apps render a single page, then rely on API calls and the returned data to dynamically \", \"render new UI without reloading a full page. Client-side rendering provides a much faster, more resp\", \"onsive application to the end user.\\n\\nServerless endpoints triggered by HTTP calls can be used to han\", \"dle the API requests. For example, an ad services company may call a serverless function with user p\", \"rofile information to request custom advertising. The serverless function returns the custom ad and \", \"the web page renders it.\\n\\n21\\n\\nCHAPTER 2 | Serverless architecture\\n\\nData pipeline\\n\\nServerless functio\", \"ns can be used to facilitate a data pipeline. In this example, a file triggers a function to transla\", \"te data in a CSV file to data rows in a table. The organized table allows a Power BI dashboard to pr\", \"esent analytics to the end user.\\n\\nStream processing\\n\\nDevices and sensors often generate streams of d\", \"ata that must be processed in real time. There are a number of technologies that can capture message\", \"s and streams from Event Hubs and IoT Hub to Service Bus. Regardless of transport, serverless is an \", \"ideal mechanism for processing the messages and streams of data as they come in. Serverless can scal\", \"e quickly to meet the demand of large volumes of data. The serverless code can apply business logic \", \"to parse the data and output in a structured format for action and analytics.\\n\\n22\\n\\nCHAPTER 2 | Serve\", \"rless architecture\\n\\nAPI gateway\\n\\nAn API gateway provides a single point of entry for clients and the\", \"n intelligently routes requests to back-end services. It\\u2019s useful to manage large sets of services. \", \"It can also handle versioning and simplify development by easily connecting clients to disparate env\", \"ironments. Serverless can handle back-end scaling of individual microservices while presenting a sin\", \"gle front end via an API gateway.\\n\\nRecommended resources\\n\\n\\n\\nAzure Event Grid\\n\\n\\n\\nAzure IoT Hub\\n\\n\\n\\nCha\", \"llenges and solutions for distributed data management\\n\\n\\n\\nDesigning microservices: identifying micros\", \"ervice boundaries\\n\\n\\n\\nEvent Hubs\\n\\n\\n\\nEvent Sourcing pattern\\n\\n\\n\\nImplementing the Circuit Breaker patter\", \"n\\n\\n\\n\\nIoT Hub\\n\\n\\n\\nService Bus\\n\\nWorking with the change feed support in Azure Cosmos DB\\n\\n23\\n\\nCHAPTER 2 \", \"| Serverless architecture\\n\\nCHAPTER 3 CHAPTER 3\\n\\nAzure serverless platform\\n\\nThe Azure serverless plat\", \"form includes Azure Functions, Logic Apps, and Event Grid. These services work together and connect \", \"with myriad other resources. The serverless platform works with everything from databases and storag\", \"e to analytics and machine learning/artificial intelligence.\\n\\nYou can also use Application Insights,\", \" a serverless platform for capturing diagnostic traces and telemetry. Application Insights are avail\", \"able to applications of all types (desktop, mobile, or web) as well as serverless implementations. T\", \"he platform is visualized in the following diagram:\\n\\nThis chapter breaks down the fundamentals of ea\", \"ch component.\\n\\nAzure Functions\\n\\nAzure Functions provide a serverless compute experience. A function \", \"is invoked by a trigger (such as access to an HTTP endpoint or a timer) and executes a block of code\", \" or business logic. Functions also support specialized bindings that connect to resources like stora\", \"ge and queues.\\n\\n24\\n\\nCHAPTER 3 | Azure serverless platform\\n\\nThe current runtime version 4.0 supports \", \"cross-platform .NET 7.0 applications. Additional languages besides C# such as JavaScript, F#, and Ja\", \"va are supported. Functions created in the portal provide a rich scripting syntax. Functions created\", \" as standalone projects can be deployed with full platform support and capabilities.\\n\\nFor more infor\", \"mation, see Azure Functions documentation.\\n\\nProgramming language support\\n\\nThe following languages ar\", \"e all supported in general availability (GA).\\n\\nLanguage\\n\\nSupported runtimes for 4.x\\n\\nC#\\n\\n.NET 6.0, 7\", \".0, .NET Framework 4.8\\n\\nJavaScript Node 14, 16, 18\\n\\nF#\\n\\n.NET 6.0, 7.0\\n\\nJava\\n\\nJava 8, 11, 17\\n\\nPython\\n\", \"\\nPython 3.7, 3.8, 3.9, 3.10\\n\\nTypeScript Node 14, 16, 18 (via JavaScript)\\n\\nPowerShell PowerShell Core\", \" 7.2\\n\\nFor more information on other runtime versions, see Supported languages.\\n\\nApp service plans\\n\\nF\", \"unctions are backed by an app service plan. The plan defines the resources used by the functions app\", \". You can assign plans to a region, determine the size and number of virtual machines that will be u\", \"sed, and pick a pricing tier. For a true serverless approach, function apps may use the consumption \", \"plan. The consumption plan will scale the back end automatically based on load.\\n\\nAnother hosting opt\", \"ion for function apps is the Premium plan. This plan provides an \\u201calways on\\u201d instance to avoid cold \", \"start, supports advanced features like VNet connectivity, and runs on premium hardware.\\n\\nFor more in\", \"formation, see App service plans.\\n\\nCreate your first function\\n\\nThere are three common ways you can c\", \"reate function apps.\\n\\n\\n\\nScript functions in the portal.\\n\\n\\n\\nCreate the necessary resources using the \", \"Azure CLI.\\n\\n\\n\\nBuild functions locally using your favorite IDE and publish them to Azure.\\n\\n25\\n\\nCHAPTE\", \"R 3 | Azure serverless platform\\n\\nFor more information on creating a scripted function in the portal,\", \" see Create your first function in the Azure portal.\\n\\nTo build from the Azure CLI, see Create your f\", \"irst function using the Azure CLI.\\n\\nTo create a function from Visual Studio, see Create your first f\", \"unction using Visual Studio.\\n\\nUnderstand triggers and bindings\\n\\nFunctions are invoked by a trigger a\", \"nd can have exactly one. In addition to invoking the function, certain triggers also serve as bindin\", \"gs. You may also define multiple bindings in addition to the trigger. Bindings provide a declarative\", \" way to connect data to your code. They can be passed in (input) or receive data (output). Triggers \", \"and bindings make functions easy to work with. Bindings remove the overhead of manually creating dat\", \"abase or file system connections. All of the information needed for the bindings is contained in a s\", \"pecial functions.json file for scripts or declared with attributes in code.\\n\\nSome common triggers in\", \"clude:\\n\\n\\n\\nBlob Storage: invoke your function when a file or folder is uploaded or changed in storage\", \".\\n\\n\\n\\nHTTP: invoke your function like a REST API.\\n\\n\\n\\nQueue: invoke your function when items exist in \", \"a queue.\\n\\n\\n\\nTimer: invoke your function on a regular cadence.\\n\\nExamples of bindings include:\\n\\n\\n\\nCosm\", \"osDB: easily connect to the database to load or save files.\\n\\n\\n\\nTable Storage: work with key/value st\", \"orage from your function app.\\n\\n\\n\\nQueue Storage: easily retrieve items from a queue, or place new ite\", \"ms on the queue.\\n\\nThe following example functions.json file defines a trigger and a binding:\\n\\n{ \\\"bin\", \"dings\\\": [ { \\\"name\\\": \\\"myBlob\\\", \\\"type\\\": \\\"blobTrigger\\\", \\\"direction\\\": \\\"in\\\", \\\"path\\\": \\\"images/{name}\\\", \\\"co\", \"nnection\\\": \\\"AzureWebJobsStorage\\\" }, { \\\"name\\\": \\\"$return\\\", \\\"type\\\": \\\"queue\\\", \\\"direction\\\": \\\"out\\\", \\\"queue\", \"Name\\\": \\\"images\\\", \\\"connection\\\": \\\"AzureWebJobsStorage\\\" } ], \\\"disabled\\\": false }\\n\\nIn this example, the \", \"function is triggered by a change to blob storage in the images container. The information for the f\", \"ile is passed in, so the trigger also acts as a binding. Another binding exists to put information o\", \"nto a queue named images.\\n\\n26\\n\\nCHAPTER 3 | Azure serverless platform\\n\\nHere is the C# script for the \", \"function:\\n\\npublic static string Run(Stream myBlob, string name, TraceWriter log) { log.Info($\\\"C# Blo\", \"b trigger function Processed blob\\\\n Name:{name} \\\\n Size: {myBlob.Length} Bytes\\\"); return name; }\\n\\nTh\", \"e example is a simple function that takes the name of the file that was modified or uploaded to blob\", \" storage, and places it on a queue for later processing.\\n\\nFor a full list of triggers and bindings, \", \"see Azure Functions triggers and bindings concepts.\\n\\nTelemetry with Application Insights\\n\\nApplicatio\", \"n Insights is a serverless diagnostics platform that enables developers to detect, triage, and diagn\", \"ose issues in web apps, mobile apps, desktop apps, and microservices. You can turn on Application In\", \"sights for function apps simply by flipping a switch in the portal. Application Insights provides al\", \"l of these capabilities without you having to configure a server or set up your own database. All of\", \" Application Insights\\u2019 capabilities are provided as a service that automatically integrates with you\", \"r apps.\\n\\nAdding Application Insights to existing apps is as easy as adding an instrumentation key to\", \" your application\\u2019s settings. With Application Insights you can:\\n\\n\\n\\nCreate custom charts and alerts \", \"based on metrics such as number of function invocations, the time it takes to run a function, and ex\", \"ceptions\\n\\n\\n\\nAnalyze failures and server exceptions\\n\\n\\n\\nDrill into performance by operation and measur\", \"e the time it takes to call third-party dependencies\\n\\nMonitor CPU usage, memory, and rates across al\", \"l servers that host your function apps\\n\\n\\n\\nView a live stream of metrics including request count and \", \"latency for your function apps\\n\\n\\n\\nUse Analytics to search, query, and create custom charts over your\", \" function data\\n\\n27\\n\\nCHAPTER 3 | Azure serverless platform\\n\\nIn addition to built-in telemetry, it\\u2019s a\", \"lso possible to generate custom telemetry. The following code snippet creates a custom telemetry cli\", \"ent using the instrumentation key set for the function app:\\n\\npublic static TelemetryClient telemetry\", \" = new TelemetryClient() { InstrumentationKey = Environment.GetEnvironmentVariable(\\\"APPINSIGHTS_INST\", \"RUMENTATIONKEY\\\") };\\n\\nThe following code measures how long it takes to insert a new row into an Azure\", \" Table Storage instance:\\n\\nvar startTime = DateTime.UtcNow; var timer = System.Diagnostics.Stopwatch.\", \"StartNew(); await tableClient.AddEntityAsync(entry); telemetry.TrackDependency(\\\"AzureTableStorageIns\", \"ert\\\", \\\"Insert\\\", startTime, timer.Elapsed, true);\\n\\nThe resulting performance graph is shown:\\n\\n28\\n\\nCHA\", \"PTER 3 | Azure serverless platform\\n\\nThe custom telemetry reveals the average time to insert a new ro\", \"w is 32.6 milliseconds.\\n\\nApplication Insights provides a powerful, convenient way to log detailed te\", \"lemetry about your serverless applications. You have full control over the level of tracing and logg\", \"ing that is provided. You can track custom statistics such as events, dependencies, and page view. F\", \"inally, the powerful analytics enable you to write queries that ask important questions and generate\", \" charts and advanced insights.\\n\\nFor more information, see Monitor Azure Functions.\\n\\nAzure Logic Apps\", \"\\n\\nAzure Logic Apps provides a serverless engine to build automated workflows to integrate apps and d\", \"ata between cloud services and on-premises systems. You build workflows using a visual designer. You\", \" can trigger workflows based on events or timers and leverage connectors to integration applications\", \" and facilitate business-to-business (B2B) communication. Logic Apps integrates seamlessly with Azur\", \"e Functions.\\n\\nLogic Apps can do more than just connect your cloud services (like functions) with clo\", \"ud resources (like queues and databases). You can also orchestrate on-premises workflows with the on\", \"-premises gateway. For example, you can use the Logic App to trigger an on-premises SQL stored proce\", \"dure in response to a cloud-based event or conditional logic in your workflow. Learn more about Conn\", \"ecting to on-premises data sources with Azure On-premises Data Gateway.\\n\\n29\\n\\nCHAPTER 3 | Azure serve\", \"rless platform\\n\\nLike Azure Functions, you kick off Logic App workflows with a trigger. There are man\", \"y triggers for you to choose from. The following capture shows just a few of the more popular ones o\", \"ut of hundreds that are available.\\n\\nOnce the app is triggered, you can use the visual designer to bu\", \"ild out steps, loops, conditions, and actions. Any data ingested in a previous step is available for\", \" you to use in subsequent steps. The following workflow loads URLs from a CosmosDB database. It find\", \"s the ones with a host of t.co then searches for them on Twitter. If it finds corresponding tweets, \", \"it updates the documents with the related tweets by calling a function.\\n\\n30\\n\\nCHAPTER 3 | Azure serve\", \"rless platform\\n\\nThe Logic Apps dashboard shows the history of running your workflows and whether eac\", \"h run completed successfully or not. You can navigate into any given run and inspect the data used b\", \"y each step for troubleshooting. Logic Apps also provides existing templates you can edit and are we\", \"ll suited for complex enterprise workflows.\\n\\nTo learn more, see Azure Logic Apps.\\n\\nEvent Grid\\n\\nAzure\", \" Event Grid provides serverless infrastructure for event-based applications. You can publish to Even\", \"t Grid from any source and consume messages from any platform. Event Grid also has built-in support \", \"for events from Azure resources to streamline integration with your applications. For example, you c\", \"an subscribe to blob storage events to notify your app when a file is uploaded. Your application can\", \" then publish a custom event grid message that is consumed by other cloud or on-premises application\", \"s. Event Grid was built to reliably handle massive scale. You get the benefits of publishing and sub\", \"scribing to messages without the overhead of setting up the necessary infrastructure.\\n\\n31\\n\\nCHAPTER 3\", \" | Azure serverless platform\\n\\nThe major features of event grid include:\\n\\n\\n\\nFully managed event routi\", \"ng.\\n\\n\\n\\nNear real-time event delivery at scale.\\n\\n\\n\\nBroad coverage both inside and outside of Azure.\\n\\n\", \"Scenarios\\n\\nEvent Grid addresses several different scenarios. This section covers three of the most c\", \"ommon ones.\\n\\nOps automation\\n\\nEvent Grid can help speed automation and simplify policy enforcement by\", \" notifying Azure Automation when infrastructure is provisioned.\\n\\n32\\n\\nCHAPTER 3 | Azure serverless pl\", \"atform\\n\\nApplication integration\\n\\nYou can use Event Grid to connect your app to other services. Using\", \" standard HTTP protocols, even legacy apps can be easily modified to publish Event Grid messages. We\", \"b hooks are available for other services and platforms to consume Event Grid messages.\\n\\nServerless a\", \"pps\\n\\nEvent Grid can trigger Azure Functions, Logic Apps, or your own custom code. A major benefit of\", \" using Event Grid is that it uses a push mechanism to send messages when events occur. The push arch\", \"itecture consumes fewer resources and scales better than polling mechanisms. Polling must check for \", \"updates on a regular interval.\\n\\nEvent Grid vs. other Azure messaging services\\n\\nAzure provides severa\", \"l messaging services, including Event Hubs and Service Bus. Each is designed to address a specific s\", \"et of use cases. The following diagram provides a high-level overview of the differences between the\", \" services.\\n\\n33\\n\\nCHAPTER 3 | Azure serverless platform\\n\\nFor a more in-depth comparison, see Compare m\", \"essaging services.\\n\\nPerformance targets\\n\\nUsing Event Grid you can take advantage of the following pe\", \"rformance guarantees:\\n\\n\\n\\nSubsecond end-to-end latency in the 99th percentile.\\n\\n\\n\\n99.99% availability\", \".\\n\\n\\n\\n10 million events per second per region.\\n\\n\\n\\n100 million subscriptions per region.\\n\\n\\n\\n50-ms publ\", \"isher latency.\\n\\n\\n\\n24-hour retry with exponential back-off for guaranteed delivery in the 1-day windo\", \"w.\\n\\n\\n\\nTransparent regional failover.\\n\\nEvent Grid schema\\n\\nEvent Grid uses a standard schema to wrap c\", \"ustom events. The schema is like an envelope that wraps your custom data element. Here is an example\", \" Event Grid message:\\n\\n[{ \\\"id\\\": \\\"03e24f21-a955-43cc-8921-1f61a6081ce0\\\", \\\"eventType\\\": \\\"myCustomEvent\\\",\", \" \\\"subject\\\": \\\"foo/bar/12\\\", \\\"eventTime\\\": \\\"2018-09-22T10:36:01+00:00\\\", \\\"data\\\": { \\\"favoriteColor\\\": \\\"blue\", \"\\\", \\\"favoriteAnimal\\\": \\\"panther\\\", \\\"favoritePlanet\\\": \\\"Jupiter\\\" }, \\\"dataVersion\\\": \\\"1.0\\\" }]\\n\\nEverything a\", \"bout the message is standard except the data property. You can inspect the message and use the event\", \"Type and dataVersion to de-serialize the custom portion of the payload.\\n\\n34\\n\\nCHAPTER 3 | Azure serve\", \"rless platform\\n\\nAzure resources\\n\\nA major benefit of using Event Grid is the automatic messages produ\", \"ced by Azure. In Azure, resources automatically publish to a topic that allows you to subscribe for \", \"various events. The following table lists the resource types, message types, and events that are ava\", \"ilable automatically.\\n\\nAzure resource\\n\\nEvent type\\n\\nDescription\\n\\nAzure subscription\\n\\nMicrosoft.Resour\", \"ces.ResourceWriteSuccess\\n\\nRaised when a resource create or update operation succeeds.\\n\\nMicrosoft.Res\", \"ources.ResourceWriteFailure\\n\\nRaised when a resource create or update operation fails.\\n\\nMicrosoft.Res\", \"ources.ResourceWriteCancel\\n\\nRaised when a resource create or update operation is canceled.\\n\\nMicrosof\", \"t.Resources.ResourceDeleteSuccess Raised when a resource delete\\n\\noperation succeeds.\\n\\nMicrosoft.Reso\", \"urces.ResourceDeleteFailure\\n\\nRaised when a resource delete operation fails.\\n\\nMicrosoft.Resources.Res\", \"ourceDeleteCancel\\n\\nRaised when a resource delete operation is canceled. This event happens when a te\", \"mplate deployment is canceled.\\n\\nBlob storage Microsoft.Storage.BlobCreated\\n\\nRaised when a blob is cr\", \"eated.\\n\\nMicrosoft.Storage.BlobDeleted\\n\\nRaised when a blob is deleted.\\n\\nEvent hubs\\n\\nMicrosoft.EventHu\", \"b.CaptureFileCreated\\n\\nRaised when a capture file is created.\\n\\nIoT Hub\\n\\nMicrosoft.Devices.DeviceCreat\", \"ed\\n\\nPublished when a device is registered to an IoT hub.\\n\\nMicrosoft.Devices.DeviceDeleted\\n\\nPublished\", \" when a device is deleted from an IoT hub.\\n\\nResource groups\\n\\nMicrosoft.Resources.ResourceWriteSucces\", \"s\\n\\nRaised when a resource create or update operation succeeds.\\n\\nMicrosoft.Resources.ResourceWriteFai\", \"lure\\n\\nRaised when a resource create or update operation fails.\\n\\nMicrosoft.Resources.ResourceWriteCan\", \"cel\\n\\nRaised when a resource create or update operation is canceled.\\n\\nMicrosoft.Resources.ResourceDel\", \"eteSuccess Raised when a resource delete\\n\\noperation succeeds.\\n\\nMicrosoft.Resources.ResourceDeleteFai\", \"lure\\n\\nRaised when a resource delete operation fails.\\n\\n35\\n\\nCHAPTER 3 | Azure serverless platform\\n\\nAzu\", \"re resource\\n\\nEvent type\\n\\nDescription\\n\\nMicrosoft.Resources.ResourceDeleteCancel\\n\\nRaised when a resour\", \"ce delete operation is canceled. This event happens when a template deployment is canceled.\\n\\nFor mor\", \"e information, see Azure Event Grid event schema.\\n\\nYou can access Event Grid from any type of applic\", \"ation, even one that runs on-premises.\\n\\nConclusion\\n\\nIn this chapter you learned about the Azure serv\", \"erless platform that is composed of Azure Functions, Logic Apps, and Event Grid. You can use these r\", \"esources to build an entirely serverless app architecture, or create a hybrid solution that interact\", \"s with other cloud resources and on-premises servers. Combined with a serverless data platform such \", \"as Azure SQL or CosmosDB, you can build fully managed cloud native applications.\\n\\nRecommended resour\", \"ces\\n\\n\\n\\nApp service plans\\n\\n\\n\\nApplication Insights\\n\\n\\n\\nApplication Insights Analytics\\n\\n\\n\\nAzure: Bring y\", \"our app to the cloud with serverless Azure Functions\\n\\n\\n\\nAzure Event Grid\\n\\n\\n\\nAzure Event Grid event s\", \"chema\\n\\n\\n\\nAzure Event Hubs\\n\\n\\n\\nAzure Functions documentation\\n\\n\\n\\nAzure Functions triggers and bindings \", \"concepts\\n\\n\\n\\nAzure Logic Apps\\n\\n\\n\\nAzure Service Bus\\n\\n\\n\\nAzure Table Storage\\n\\n\\n\\nConnecting to on-premise\", \"s data sources with Azure On-premises Data Gateway\\n\\n\\n\\nCreate your first function in the Azure portal\", \"\\n\\n\\n\\nCreate your first function using the Azure CLI\\n\\n\\n\\nCreate your first function using Visual Studio\", \"\\n\\n\\n\\nFunctions supported languages\\n\\nMonitor Azure Functions\\n\\n36\\n\\nCHAPTER 3 | Azure serverless platfor\", \"m\\n\\nCHAPTER 4 CHAPTER 4\\n\\nDurable Azure Functions\\n\\nWhen creating serverless applications with Azure Fu\", \"nctions, your operations will typically be designed to run in a stateless manner. The reason for thi\", \"s design choice is because as the platform scales, it becomes difficult to know what servers the cod\", \"e is running on. It also becomes difficult to know how many instances are active at any given point.\", \" However, there are classes of applications that require the current state of a process to be known.\", \" Consider the process of submitting an order to an online store. The checkout operation might be a w\", \"orkflow that is composed of multiple operations that need to know the state of the process. Such inf\", \"ormation may include the product inventory, if the customer has any credits on their account, and al\", \"so the results of processing the credit card. These operations could easily be their own internal wo\", \"rkflows or even services from third-party systems.\\n\\nVarious patterns exist today that assist with th\", \"e coordination of application state between internal and external systems. It\\u2019s common to come acros\", \"s solutions that rely on centralized queuing systems, distributed key-value stores, or shared databa\", \"ses to manage that state. However, these are all additional resources that now need to be provisione\", \"d and managed. In a serverless environment, your code could become cumbersome trying to coordinate w\", \"ith these resources manually. Azure Functions offers an alternative for creating stateful functions \", \"called Durable Functions.\\n\\nDurable Functions is an extension to the Azure Functions runtime that ena\", \"bles the definition of stateful workflows in code. By breaking down workflows into activities, the D\", \"urable Functions extension can manage state, create progress checkpoints, and handle the distributio\", \"n of function calls across servers. In the background, it makes use of an Azure Storage account to p\", \"ersist execution history, schedule activity functions and retrieve responses. Your serverless code s\", \"hould never interact with persisted information in that storage account, and is typically not someth\", \"ing with which developers need to interact.\\n\\nTriggering a stateful workflow\\n\\nStateful workflows in D\", \"urable Functions can be broken down into two intrinsic components; orchestration and activity trigge\", \"rs. Triggers and bindings are core components used by Azure Functions to enable your serverless func\", \"tions to be notified when to start, receive input, and return results.\\n\\nWorking with the Orchestrati\", \"on client\\n\\nOrchestrations are unique when compared to other styles of triggered operations in Azure \", \"Functions. Durable Functions enables the execution of functions that may take hours or even days to \", \"complete. That type of behavior comes with the need to able to check the status of a running orchest\", \"ration, preemptively terminate, or send notifications of external events.\\n\\n37\\n\\nCHAPTER 4 | Durable A\", \"zure Functions\\n\\nFor such cases, the Durable Functions extension provides the DurableOrchestrationCli\", \"ent class that allows you to interact with orchestrated functions. You get access to the orchestrati\", \"on client by using the OrchestrationClientAttribute binding. Generally, you would include this attri\", \"bute with another trigger type, such as an HttpTrigger or ServiceBusTrigger. Once the source functio\", \"n has been triggered, the orchestration client can be used to start an orchestrator function.\\n\\n[Func\", \"tionName(\\\"KickOff\\\")] public static async Task<HttpResponseMessage> Run( [HttpTrigger(AuthorizationLe\", \"vel.Function, \\\"POST\\\")]HttpRequestMessage req, [OrchestrationClient ] DurableOrchestrationClient<orch\", \"estrationClient>) { OrderRequestData data = await req.Content.ReadAsAsync<OrderRequestData>();\\n\\nstri\", \"ng instanceId = await orchestrationClient.StartNewAsync(\\\"PlaceOrder\\\", data);\\n\\nreturn orchestrationCl\", \"ient.CreateCheckStatusResponse(req, instanceId); }\\n\\nThe orchestrator function\\n\\nAnnotating a function\", \" with the OrchestrationTriggerAttribute in Azure Functions marks that function as an orchestrator fu\", \"nction. It\\u2019s responsible for managing the various activities that make up your stateful workflow.\\n\\nO\", \"rchestrator functions are unable to make use of bindings other than the OrchestrationTriggerAttribut\", \"e. This attribute can only be used with a parameter type of DurableOrchestrationContext. No other in\", \"puts can be used since deserialization of inputs in the function signature isn\\u2019t supported. To get i\", \"nputs provided by the orchestration client, the GetInput<T> method must be used.\\n\\nAlso, the return t\", \"ypes of orchestration functions must be either void, Task, or a JSON serializable value.\\n\\nError hand\", \"ling code has been left out for brevity\\n\\n[FunctionName(\\\"PlaceOrder\\\")] public static async Task<strin\", \"g> PlaceOrder([OrchestrationTrigger] DurableOrchestrationContext context) { OrderRequestData orderDa\", \"ta = context.GetInput<OrderRequestData>();\\n\\nawait context.CallActivityAsync<bool>(\\\"CheckAndReserveIn\", \"ventory\\\", orderData); await context.CallActivityAsync<string>(\\\"ProcessPayment\\\", orderData);\\n\\nstring \", \"trackingNumber = await context.CallActivityAsync<string>(\\\"ScheduleShipping\\\", orderData); await conte\", \"xt.CallActivityAsync<string>(\\\"EmailCustomer\\\", trackingNumber);\\n\\nreturn trackingNumber; }\\n\\nMultiple i\", \"nstances of an orchestration can be started and running at the same time. Calling the StartNewAsync \", \"method on the DurableOrchestrationClient launches a new instance of the orchestration. The method re\", \"turns a Task<string> that completes when the orchestration has started.\\n\\n38\\n\\nCHAPTER 4 | Durable Azu\", \"re Functions\\n\\nAn exception of type TimeoutException gets thrown if the orchestration hasn\\u2019t started \", \"within 30 seconds.\\n\\nThe completed Task<string> from StartNewAsync should contain the unique ID of th\", \"e orchestration instance. This instance ID can be used to invoke operations on that specific orchest\", \"ration. The orchestration can be queried for the status or sent event notifications.\\n\\nThe activity f\", \"unctions\\n\\nActivity functions are the discrete operations that get composed together within an orches\", \"tration function to create the workflow. Here is where most of actual work would take place. They re\", \"present the business logic, long running processes, and the puzzle pieces to a larger solution.\\n\\nThe\", \" ActivityTriggerAttribute is used to annotate a function parameter of type DurableActivityContext. U\", \"sing the annotation informs the runtime that the function is intended to be used as an activity func\", \"tion. Input values to activity functions are retrieved using the GetInput<T> method of the DurableAc\", \"tivityContext parameter.\\n\\nSimilar to orchestration functions, the return types of activity functions\", \" must be either void, Task, or a JSON serializable value.\\n\\nAny unhandled exceptions that get thrown \", \"within activity functions will get sent up to the calling orchestrator function and presented as a T\", \"askFailedException. At this point, the error can be caught and logged in the orchestrator, and the a\", \"ctivity can be retried.\\n\\n[FunctionName(\\\"CheckAndReserveInventory\\\")] public static bool CheckAndReser\", \"veInventory([ActivityTrigger] DurableActivityContext context) { OrderRequestData orderData = context\", \".GetInput<OrderRequestData>();\\n\\n// Connect to inventory system and try to reserve items return true;\", \" }\\n\\nRecommended resources\\n\\n\\n\\nDurable Functions\\n\\n\\n\\nBindings for Durable Functions\\n\\nManage instances i\", \"n Durable Functions\\n\\nOrchestration patterns\\n\\nDurable Functions makes it easier to create stateful wo\", \"rkflows that are composed of discrete, long running activities in a serverless environment. Since Du\", \"rable Functions can track the progress of your workflows and periodically checkpoints the execution \", \"history, it lends itself to implementing some interesting patterns.\\n\\n39\\n\\nCHAPTER 4 | Durable Azure F\", \"unctions\\n\\nFunction chaining\\n\\nIn a typical sequential process, activities need to execute one after t\", \"he other in a particular order. Optionally, the upcoming activity may require some output from the p\", \"revious function. This dependency on the ordering of activities creates a function chain of executio\", \"n.\\n\\nThe benefit of using Durable Functions to implement this workflow pattern comes from its ability\", \" to do checkpointing. If the server crashes, the network times out or some other issue occurs, Durab\", \"le functions can resume from the last known state and continue running your workflow even if it\\u2019s on\", \" another server.\\n\\n[FunctionName(\\\"PlaceOrder\\\")] public static async Task<string> PlaceOrder([Orchestr\", \"ationTrigger] DurableOrchestrationContext context) { OrderRequestData orderData = context.GetInput<O\", \"rderRequestData>();\\n\\nawait context.CallActivityAsync<bool>(\\\"CheckAndReserveInventory\\\", orderData); a\", \"wait context.CallActivityAsync<bool>(\\\"ProcessPayment\\\", orderData);\\n\\nstring trackingNumber = await co\", \"ntext.CallActivityAsync<string>(\\\"ScheduleShipping\\\", orderData); await context.CallActivityAsync<stri\", \"ng>(\\\"EmailCustomer\\\", trackingNumber);\\n\\nreturn trackingNumber; }\\n\\nIn the preceding code sample, the C\", \"allActivityAsync function is responsible for running a given activity on a virtual machine in the da\", \"ta center. When the await returns and the underlying Task completes, the execution will be recorded \", \"to the history table. The code in the orchestrator function can make use of any of the familiar cons\", \"tructs of the Task Parallel Library and the async/await keywords.\\n\\nThe following code is a simplifie\", \"d example of what the ProcessPayment method may look like:\\n\\n[FunctionName(\\\"ProcessPayment\\\")] public \", \"static bool ProcessPayment([ActivityTrigger] DurableActivityContext context) { OrderRequestData orde\", \"rData = context.GetInput<OrderRequestData>();\\n\\nApplyCoupons(orderData); if(IssuePaymentRequest(order\", \"Data)) { return true; }\\n\\nreturn false; }\\n\\nAsynchronous HTTP APIs\\n\\nIn some cases, workflows may conta\", \"in activities that take a relatively long period of time to complete. Imagine a process that kicks o\", \"ff the backup of media files into blob storage. Depending on the size and quantity of the media file\", \"s, this backup process may take hours to complete.\\n\\n40\\n\\nCHAPTER 4 | Durable Azure Functions\\n\\nIn this\", \" scenario, the DurableOrchestrationClient\\u2019s ability to check the status of a running workflow become\", \"s useful. When using an HttpTrigger to start a workflow, the CreateCheckStatusResponse method can be\", \" used to return an instance of HttpResponseMessage. This response provides the client with a URI in \", \"the payload that can be used to check the status of the running process.\\n\\n[FunctionName(\\\"OrderWorkfl\", \"ow\\\")] public static async Task<HttpResponseMessage> Run( [HttpTrigger(AuthorizationLevel.Function, \\\"\", \"POST\\\")]HttpRequestMessage req, [OrchestrationClient ] DurableOrchestrationClient orchestrationClient\", \") { OrderRequestData data = await req.Content.ReadAsAsync<OrderRequestData>();\\n\\nstring instanceId = \", \"await orchestrationClient.StartNewAsync(\\\"PlaceOrder\\\", data);\\n\\nreturn orchestrationClient.CreateCheck\", \"StatusResponse(req, instanceId); }\\n\\nThe sample result below shows the structure of the response payl\", \"oad.\\n\\n{ \\\"id\\\": \\\"instanceId\\\", \\\"statusQueryGetUri\\\": \\\"http://host/statusUri\\\", \\\"sendEventPostUri\\\": \\\"http:\", \"//host/eventUri\\\", \\\"terminatePostUri\\\": \\\"http://host/terminateUri\\\" }\\n\\nUsing your preferred HTTP client\", \", GET requests can be made to the URI in statusQueryGetUri to inspect the status of the running work\", \"flow. The returned status response should resemble the following code.\\n\\n{ \\\"runtimeStatus\\\": \\\"Running\\\"\", \", \\\"input\\\": { \\\"$type\\\": \\\"DurableFunctionsDemos.OrderRequestData, DurableFunctionsDemos\\\" }, \\\"output\\\": n\", \"ull, \\\"createdTime\\\": \\\"2018-01-01T00:22:05Z\\\", \\\"lastUpdatedTime\\\": \\\"2018-01-01T00:22:09Z\\\" }\\n\\nAs the proc\", \"ess continues, the status response will change to either Failed or Completed. On successful completi\", \"on, the output property in the payload will contain any returned data.\\n\\nMonitoring\\n\\nFor simple recur\", \"ring tasks, Azure Functions provides the TimerTrigger that can be scheduled based on a CRON expressi\", \"on. The timer works well for simple, short-lived tasks, but there might be scenarios where more flex\", \"ible scheduling is needed. This scenario is when the monitoring pattern and Durable Functions can he\", \"lp.\\n\\nDurable Functions allows for flexible scheduling intervals, lifetime management, and the creati\", \"on of multiple monitor processes from a single orchestration function. One use case for this functio\", \"nality might be to create watchers for stock price changes that complete once a certain threshold is\", \" met.\\n\\n41\\n\\nCHAPTER 4 | Durable Azure Functions\\n\\n[FunctionName(\\\"CheckStockPrice\\\")] public static asyn\", \"c Task CheckStockPrice([OrchestrationTrigger] DurableOrchestrationContext context) { StockWatcherInf\", \"o stockInfo = context.GetInput<StockWatcherInfo>(); const int checkIntervalSeconds = 120; StockPrice\", \" initialStockPrice = null;\\n\\nDateTime fireAt; DateTime exitTime = context.CurrentUtcDateTime.Add(stoc\", \"kInfo.TimeLimit);\\n\\nwhile (context.CurrentUtcDateTime < exitTime) { StockPrice currentStockPrice = aw\", \"ait context.CallActivityAsync<StockPrice>(\\\"GetStockPrice\\\", stockInfo);\\n\\nif (initialStockPrice == nul\", \"l) { initialStockPrice = currentStockPrice; fireAt = context.CurrentUtcDateTime.AddSeconds(checkInte\", \"rvalSeconds); await context.CreateTimer(fireAt, CancellationToken.None); continue; }\\n\\ndecimal percen\", \"tageChange = (initialStockPrice.Price - currentStockPrice.Price) / ((initialStockPrice.Price + curre\", \"ntStockPrice.Price) / 2);\\n\\nif (Math.Abs(percentageChange) >= stockInfo.PercentageChange) { // Change\", \" threshold detected await context.CallActivityAsync(\\\"NotifyStockPercentageChange\\\", currentStockPrice\", \"); break; }\\n\\n// Sleep til next polling interval fireAt = context.CurrentUtcDateTime.AddSeconds(check\", \"IntervalSeconds); await context.CreateTimer(fireAt, CancellationToken.None); } }\\n\\nDurableOrchestrati\", \"onContext\\u2019s CreateTimer method sets up the schedule for the next invocation of the loop to check for\", \" stock price changes. DurableOrchestrationContext also has a CurrentUtcDateTime property to get the \", \"current DateTime value in UTC. It\\u2019s better to use this property instead of DateTime.UtcNow because i\", \"t\\u2019s easily mocked for testing.\\n\\nRecommended resources\\n\\n\\n\\nAzure Durable Functions\\n\\n\\n\\nUnit Testing in \", \".NET Core and .NET Standard\\n\\n42\\n\\nCHAPTER 4 | Durable Azure Functions\\n\\nCHAPTER 5 CHAPTER 5\\n\\nServerles\", \"s business scenarios and use cases\\n\\nThere are many use cases and scenarios for serverless applicatio\", \"ns. This chapter includes samples that illustrate the different scenarios. The scenarios include lin\", \"ks to related documentation and public source code repositories. The samples in this chapter enable \", \"you to get started on your own building and implementing serverless solutions.\\n\\nBig data processing\\n\", \"\\nThis example uses serverless to do a map/reduce operation on a big data set. It determines the aver\", \"age speed of New York Yellow taxi trips per day in 2017.\\n\\nBig Data Processing: Serverless MapReduce \", \"on Azure\\n\\nCreate serverless applications: hands-on lab\\n\\nLearn how to use functions to execute server\", \"-side logic and build serverless architectures.\\n\\n\\n\\nChoosing the best Azure service for your business\", \"\\n\\n\\n\\nCreating Azure Functions\\n\\n\\n\\nUsing triggers\\n\\n\\n\\nChaining functions\\n\\n\\n\\nLong-running workflows\\n\\nMoni\", \"toring\\n\\n\\n\\nDevelopment, testing, and deployment\\n\\nCreate serverless applications\\n\\nCustomer reviews\\n\\nTh\", \"is sample showcases the new Azure Functions tooling for C# Class Libraries in Visual Studio. Create \", \"a website where customers submit product reviews that are stored in Azure storage blobs and\\n\\n43\\n\\nCHA\", \"PTER 5 | Serverless business scenarios and use cases\\n\\nCosmosDB. Add an Azure Function to perform aut\", \"omated moderation of the customer reviews using Azure Cognitive Services. Use an Azure storage queue\", \" to decouple the website from the function.\\n\\nCustomer Reviews App with Cognitive Services\\n\\nFile proc\", \"essing and validation\\n\\nThis example parses a set of CSV files from hypothetical customers. It ensure\", \"s that all files required for a customer \\u201cbatch\\u201d are ready, then validates the structure of each fil\", \"e. Different solutions are presented using Azure Functions, Logic Apps, and Durable Functions.\\n\\nFile\", \" processing and validation using Azure Functions, Logic Apps, and Durable Functions\\n\\nGame data visua\", \"lization\\n\\nAn example of how a developer could implement an in-editor data visualization solution for\", \" their game. In fact, an Unreal Engine 4 Plugin and Unity Plugin were developed using this sample as\", \" its backend. The service component is game engine agnostic.\\n\\nIn-editor game telemetry visualization\", \"\\n\\nGraphQL\\n\\nCreate a serverless function that exposes a GraphQL API.\\n\\nServerless functions for GraphQ\", \"L\\n\\nInternet of Things (IoT) reliable edge relay\\n\\nThis sample implements a new communication protocol\", \" to enable reliable upstream communication from IoT devices. It automates data gap detection and bac\", \"kfill.\\n\\nIoT Reliable Edge Relay\\n\\nMicroservices reference architecture\\n\\nA reference architecture that\", \" walks you through the decision-making process involved in designing, developing, and delivering the\", \" Rideshare by Relecloud application (a fictitious company). It includes hands-on instructions for co\", \"nfiguring and deploying all of the architecture\\u2019s components.\\n\\n44\\n\\nCHAPTER 5 | Serverless business s\", \"cenarios and use cases\\n\\nServerless Microservices reference architecture\\n\\nServerless for mobile\\n\\nAzur\", \"e Functions are easy to implement and maintain, and accessible through HTTP. They are a great way to\", \" implement an API for a mobile application. Microsoft offers great cross-platform tools for iOS, And\", \"roid, and Windows with Xamarin. As such, Xamarin and Azure Functions are working great together. Thi\", \"s article shows how to implement an Azure Function in the Azure portal or in Visual Studio at first,\", \" and build a cross-platform client with Xamarin.Forms running on Android, iOS, and Windows.\\n\\nImpleme\", \"nting a simple Azure Function with a Xamarin.Forms client\\n\\nServerless messaging\\n\\nThis sample shows h\", \"ow to utilize Durable Functions\\u2019 fan-out pattern to load an arbitrary number of messages across any \", \"number of sessions/partitions. It targets Service Bus, Event Hubs, or Storage Queues. The sample als\", \"o adds the ability to consume those messages with another Azure Function and load the resulting timi\", \"ng data in to another Event Hub. The data is then ingested into analytics services like Azure Data E\", \"xplorer.\\n\\nProduce and Consume messages through Service Bus, Event Hubs, and Storage Queues with Azur\", \"e Functions\\n\\nRecommended resources\\n\\n\\n\\nBig Data Processing: Serverless MapReduce on Azure\\n\\n\\n\\nCreate s\", \"erverless applications\\n\\n\\n\\nCustomer Reviews App with Cognitive Services\\n\\n\\n\\nFile processing and valida\", \"tion using Azure Functions, Logic Apps, and Durable Functions\\n\\n\\n\\nImplementing a simple Azure Functio\", \"n with a Xamarin.Forms client\\n\\n\\n\\nIn-editor game telemetry visualization\\n\\n\\n\\nIoT Reliable Edge Relay\\n\\n\", \"\\n\\nProduce and Consume messages through Service Bus, Event Hubs, and Storage Queues with Azure Functi\", \"ons\\n\\n\\n\\nServerless functions for GraphQL\\n\\n\\n\\nServerless Microservices reference architecture\\n\\n45\\n\\nCHAP\", \"TER 5 | Serverless business scenarios and use cases\\n\\nCHAPTER 6 CHAPTER 6\\n\\nConclusion\\n\\nThe following \", \"key takeaways are the most important conclusions from this guide.\\n\\nBenefits of using serverless. Ser\", \"verless solutions provide the important benefit of cost savings because serverless is implemented in\", \" a pay-per-use model. Serverless makes it possible to independently scale, test, and deploy individu\", \"al components of your application. Serverless is uniquely suited to implement microservices architec\", \"tures and integrates fully into a DevOps pipeline.\\n\\nCode as a unit of deployment. Serverless abstrac\", \"ts the hardware, OS, and runtime away from the application. Serverless enables focusing on business \", \"logic in code as the unit of deployment.\\n\\nTriggers and bindings. Serverless eases integration with s\", \"torage, APIs, and other cloud resources. Azure Functions provides triggers to execute code and bindi\", \"ngs to interact with resources.\\n\\nMicroservices. The microservices architecture is becoming the prefe\", \"rred approach for distributed and large or complex mission-critical applications that are based on m\", \"ultiple independent subsystems in the form of autonomous services. In a microservice-based architect\", \"ure, the application is built as a collection of services that can be developed, tested, versioned, \", \"deployed, and scaled independently. Serverless is an architecture well-suited for building these ser\", \"vices.\\n\\nServerless platforms. Serverless isn\\u2019t just about the code. Platforms that support serverles\", \"s architectures include serverless workflows and orchestration, serverless messaging and event servi\", \"ces, and serverless databases.\\n\\nServerless challenges. Serverless introduces challenges related to d\", \"istributed application development, such as fragmented and independent data models, resiliency, vers\", \"ioning, and service discovery. Serverless may not be ideally suited to long running processes or com\", \"ponents that benefit from tighter coupling.\\n\\nServerless as a tool, not the toolbox. Serverless is no\", \"t the exclusive solution to application architecture. It is a tool that can be leveraged as part of \", \"a hybrid application that may contain traditional tiers, monolith back ends, and containers. Serverl\", \"ess can be used to enhance existing solutions and is not an all-or-nothing approach to application d\", \"evelopment.\\n\\n46\\n\\nCHAPTER 6 | Conclusion\"]"