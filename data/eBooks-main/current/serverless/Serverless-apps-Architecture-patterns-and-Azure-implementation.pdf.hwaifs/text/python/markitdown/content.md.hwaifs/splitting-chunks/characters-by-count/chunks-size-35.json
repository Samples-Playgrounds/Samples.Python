"[\"\\n\\n\\fEDITION v4.0 - Updated to Azure Functions v4\\n\\nDOWNLOAD available at: https://aka.ms/serverlessboo\", \"kpdf\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Visual Studio product teams\\n\\nA division \", \"of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington 98052-6399\\n\\nCopyright \\u00a9 2018-2023 b\", \"y Microsoft Corporation\\n\\nAll rights reserved. No part of the contents of this book may be reproduced\", \" or transmitted in any\\nform or by any means without the written permission of the publisher.\\n\\nThis b\", \"ook is provided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions and\\ninfor\", \"mation expressed in this book, including URL and other Internet website references, may change\\nwitho\", \"ut notice.\\n\\nSome examples depicted herein are provided for illustration only and are fictitious. No \", \"real association\\nor connection is intended or should be inferred.\\n\\nMicrosoft and the trademarks list\", \"ed at https://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are\\ntrademarks of the Microsoft group of\", \" companies.\\n\\nMac and macOS are trademarks of Apple Inc.\\n\\nAll other marks and logos are property of t\", \"heir respective owners.\\n\\nAuthor:\\n\\nJeremy Likness, Senior .NET Data Program Manager, Microsoft Corp.\\n\", \"\\nContributor:\\n\\nCecil Phillip, Senior Cloud Advocate, Microsoft Corp.\\n\\nEditors:\\n\\nBill Wagner, Senior \", \"Content Developer, Microsoft Corp.\\n\\nMaira Wenzel, Senior Content Developer, Microsoft Corp.\\n\\nPartici\", \"pants and reviewers:\\n\\nSteve Smith, Architect/Trainer, NimblePros.\\n\\nIntroduction\\n\\nServerless is the e\", \"volution of cloud platforms in the direction of pure cloud native code. Serverless\\nbrings developers\", \" closer to business logic while insulating them from infrastructure concerns. It\\u2019s a\\npattern that do\", \"esn\\u2019t imply \\u201cno server\\u201d but rather, \\u201cless server.\\u201d Serverless code is event-driven. Code\\n\\n\\fmay be tr\", \"iggered by anything from a traditional HTTP web request to a timer or the result of\\nuploading a file\", \". The infrastructure behind serverless allows for instant scale to meet elastic demands\\nand offers m\", \"icro-billing to truly \\u201cpay for what you use.\\u201d Serverless requires a new way of thinking and\\napproach\", \" to building applications and isn\\u2019t the right solution for every problem. As a developer, you\\nmust d\", \"ecide:\\n\\n\\u2022  What are the pros and cons of serverless?\\n\\n\\u2022  Why should you consider serverless for your\", \" own applications?\\n\\n\\u2022\\n\\nHow can you build, test, deploy, and maintain your serverless code?\\n\\n\\u2022  Where\", \" does it make sense to migrate code to serverless in existing applications, and what is the\\n\\nbest wa\", \"y to accomplish this transformation?\\n\\nAbout this guide\\n\\nThis guide focuses on cloud native developme\", \"nt of applications that use serverless. The book\\nhighlights the benefits and exposes the potential d\", \"rawbacks of developing serverless apps and\\nprovides a survey of serverless architectures. Many examp\", \"les of how serverless can be used are\\nillustrated along with various serverless design patterns.\\n\\nTh\", \"is guide explains the components of the Azure serverless platform and focuses specifically on\\nimplem\", \"entation of serverless using Azure Functions. You\\u2019ll learn about triggers and bindings as well as\\nho\", \"w to implement serverless apps that rely on state using durable functions. Finally, business\\nexample\", \"s and case studies will help provide context and a frame of reference to determine whether\\nserverles\", \"s is the right approach for your projects.\\n\\nEvolution of cloud platforms\\n\\nServerless is the culminat\", \"ion of several iterations of cloud platforms. The evolution began with\\nphysical metal in the data ce\", \"nter and progressed through Infrastructure as a Service (IaaS) and\\nPlatform as a Service (PaaS).\\n\\nBe\", \"fore the cloud, a discernible boundary existed between development and operations. Deploying an\\nappl\", \"ication meant answering myriad questions like:\\n\\n\\u2022  What hardware should be installed?\\n\\n\\u2022\\n\\nHow is phy\", \"sical access to the machine secured?\\n\\n\\f\\u2022\\n\\nDoes the data center require an Uninterruptible Power Supp\", \"ly (UPS)?\\n\\n\\u2022  Where are storage backups sent?\\n\\n\\u2022\\n\\nShould there be redundant power?\\n\\nThe list goes on\", \" and the overhead was enormous. In many situations, IT departments were forced to\\ndeal with incredib\", \"le waste. The waste was due to over-allocation of servers as backup machines for\\ndisaster recovery a\", \"nd standby servers to enable scale-out. Fortunately, the introduction of\\nvirtualization technology (\", \"like Hyper-V) with Virtual Machines (VMs) gave rise to Infrastructure as a\\nService (IaaS). Virtualiz\", \"ed infrastructure allowed operations to set up a standard set of servers as the\\nbackbone, leading to\", \" a flexible environment capable of provisioning unique servers \\u201con demand.\\u201d\\nMore important, virtuali\", \"zation set the stage for using the cloud to provide virtual machines \\u201cas a\\nservice.\\u201d Companies could\", \" easily get out of the business of worrying about redundant power or\\nphysical machines. Instead, the\", \"y focused on the virtual environment.\\n\\nIaaS still requires heavy overhead because operations is stil\", \"l responsible for various tasks. These tasks\\ninclude:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nPatching and backing up servers.\\n\\nIn\", \"stalling packages.\\n\\nKeeping the operating system up-to-date.\\n\\n\\u2022  Monitoring the application.\\n\\nThe ne\", \"xt evolution reduced the overhead by providing Platform as a Service (PaaS). With PaaS, the\\ncloud pr\", \"ovider handles operating systems, security patches, and even the required packages to\\nsupport a spec\", \"ific platform. Instead of building a VM then configuring .NET and standing up Internet\\nInformation S\", \"ervices (IIS) servers, developers simply choose a \\u201cplatform target\\u201d such as \\u201cweb\\napplication\\u201d or \\u201cAP\", \"I endpoint\\u201d and deploy code directly. The infrastructure questions are reduced to:\\n\\n\\u2022  What size ser\", \"vices are needed?\\n\\n\\u2022\\n\\n\\u2022\\n\\nHow do the services scale out (add more servers or nodes)?\\n\\nHow do the serv\", \"ices scale up (increase the capacity of hosting servers or nodes)?\\n\\nServerless further abstracts ser\", \"vers by focusing on event-driven code. Instead of a platform,\\ndevelopers can focus on a microservice\", \" that does one thing. The two key questions for building the\\nserverless code are:\\n\\n\\u2022  What triggers \", \"the code?\\n\\n\\u2022  What does the code do?\\n\\nWith serverless, infrastructure is abstracted. In some cases, \", \"the developer no longer worries about the\\nhost at all. Whether or not an instance of IIS, Kestrel, A\", \"pache, or some other web server is running to\\nmanage web requests, the developer focuses on an HTTP \", \"trigger. The trigger provides the standard,\\ncross-platform payload for the request. The payload not \", \"only simplifies the development process, but\\nfacilitates testing and in some cases, makes the code e\", \"asily portable across platforms.\\n\\nAnother feature of serverless is micro-billing. It\\u2019s common for we\", \"b applications to host Web API\\nendpoints. In traditional bare metal, IaaS and even PaaS implementati\", \"ons, the resources to host the\\nAPIs are paid for continuously. That means you pay to host the endpoi\", \"nts even when they aren\\u2019t\\nbeing accessed. Often you\\u2019ll find one API is called more than others, so t\", \"he entire system is scaled\\n\\n\\fbased on supporting the popular endpoints. Serverless enables you to sc\", \"ale each endpoint\\nindependently and pay for usage, so no costs are incurred when the APIs aren\\u2019t bei\", \"ng called.\\nMigration may in many circumstances dramatically reduce the ongoing cost to support the e\", \"ndpoints.\\n\\nWhat this guide doesn\\u2019t cover\\n\\nThis guide specifically emphasizes architecture approaches\", \" and design patterns and isn\\u2019t a deep dive\\ninto the implementation details of Azure Functions, Logic\", \" Apps, or other serverless platforms. This\\nguide doesn\\u2019t cover, for example, advanced workflows with\", \" Logic Apps or features of Azure Functions\\nsuch as configuring Cross-Origin Resource Sharing (CORS),\", \" applying custom domains, or uploading\\nSSL certificates. These details are available through the onl\", \"ine Azure Functions documentation.\\n\\nAdditional resources\\n\\n\\u2022\\n\\n\\u2022\\n\\nAzure Architecture center\\n\\nBest prac\", \"tices for cloud applications\\n\\nWho should use the guide\\n\\nThis guide was written for developers and so\", \"lution architects who want to build enterprise\\napplications with .NET that may use serverless compon\", \"ents either on premises or in the cloud. It\\u2019s\\nuseful to developers, architects, and technical decisi\", \"on makers interested in:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nUnderstanding the pros and cons of serverless development\\n\\nLearni\", \"ng how to approach serverless architecture\\n\\nExample implementations of serverless apps\\n\\nHow to use t\", \"he guide\\n\\nThe first part of this guide examines why serverless is a viable option by comparing sever\", \"al different\\narchitecture approaches. It examines both the technology and development lifecycle, bec\", \"ause all\\naspects of software development are impacted by architecture decisions. The guide then exam\", \"ines\\nuse cases and design patterns and includes reference implementations using Azure Functions. Eac\", \"h\\nsection contains additional resources to learn more about a particular area. The guide concludes w\", \"ith\\nresources for walkthroughs and hands-on exploration of serverless implementation.\\n\\nSend your fee\", \"dback\\n\\nThe guide and related samples are constantly evolving, so your feedback is welcomed! If you h\", \"ave\\ncomments about how this guide can be improved, use the feedback section at the bottom of any\\npag\", \"e built on GitHub issues.\\n\\n\\fContents\\n\\nArchitecture approaches ......................................\", \"................................................................................................. 1\\n\", \"\\nArchitecture patterns .............................................................................\", \"................................................................................. 1\\n\\nMonoliths .....\", \"....................................................................................................\", \"........................................................................... 1\\n\\nN-Layer applications \", \"....................................................................................................\", \"........................................................... 2\\n\\nMicroservices .......................\", \"....................................................................................................\", \".................................................. 3\\n\\nArchitecture deployment approaches ...........\", \"....................................................................................................\", \".............. 4\\n\\nN-Tier applications ..............................................................\", \"............................................................................................... 5\\n\\nO\", \"n-premises and Infrastructure as a Service (IaaS) ..................................................\", \"............................................. 6\\n\\nPlatform as a Service (PaaS) ......................\", \"....................................................................................................\", \".................. 7\\n\\nSoftware as a Service (SaaS) .................................................\", \".......................................................................................... 7\\n\\nContai\", \"ners and Functions as a Service (FaaS) .............................................................\", \"............................................. 8\\n\\nServerless ........................................\", \"....................................................................................................\", \".................................... 9\\n\\nSummary ....................................................\", \"....................................................................................................\", \"...................... 10\\n\\nRecommended resources ...................................................\", \".......................................................................................... 11\\n\\nServe\", \"rless architecture .................................................................................\", \"........................................................ 12\\n\\nFull serverless back end ..............\", \"....................................................................................................\", \".................................... 13\\n\\nMonoliths and \\u201cstarving the beast\\u201d ........................\", \"....................................................................................................\", \"... 13\\n\\nWeb apps ...................................................................................\", \".............................................................................................. 14\\n\\nM\", \"obile back ends ....................................................................................\", \".............................................................................. 14\\n\\nInternet of Thing\", \"s (IoT) ............................................................................................\", \"........................................................... 15\\n\\nServerless architecture consideratio\", \"ns .................................................................................................\", \"........................ 16\\n\\nManaging state ........................................................\", \"....................................................................................................\", \"..... 16\\n\\nLong-running processes ...................................................................\", \"............................................................................. 16\\n\\nStartup time .....\", \"....................................................................................................\", \"............................................................... 17\\n\\nDatabase updates and migrations \", \"....................................................................................................\", \"........................ 17\\n\\nScaling ...............................................................\", \"....................................................................................................\", \"............... 17\\n\\nMonitoring, tracing, and logging................................................\", \"............................................................................... 18\\n\\nInter-service de\", \"pendencies .........................................................................................\", \"................................................. 18\\n\\ni\\n\\nContents\\n\\n\\fManaging failure and providing r\", \"esiliency ..........................................................................................\", \".................. 18\\n\\nVersioning and green/blue deployments .......................................\", \"........................................................................ 19\\n\\nServerless design examp\", \"les ................................................................................................\", \".............................................. 19\\n\\nScheduling ......................................\", \"....................................................................................................\", \"................................ 19\\n\\nCommand and Query Responsibility Segregation (CQRS) ...........\", \"................................................................... 19\\n\\nEvent-based processing .....\", \"....................................................................................................\", \"....................................... 20\\n\\nFile triggers and transformations.......................\", \"....................................................................................................\", \".... 20\\n\\nAsynchronous background processing and messaging ..........................................\", \"......................................... 21\\n\\nWeb apps and APIs ....................................\", \"....................................................................................................\", \"................. 21\\n\\nData pipeline ................................................................\", \"....................................................................................................\", \".. 22\\n\\nStream processing ...........................................................................\", \"................................................................................ 22\\n\\nAPI gateway ...\", \"....................................................................................................\", \"................................................................. 23\\n\\nRecommended resources ........\", \"....................................................................................................\", \"................................. 23\\n\\nAzure serverless platform ....................................\", \"............................................................................................... 24\\n\\n\", \"Azure Functions ....................................................................................\", \"................................................................................. 24\\n\\nProgramming la\", \"nguage support .....................................................................................\", \".......................................... 25\\n\\nApp service plans ...................................\", \"....................................................................................................\", \"...................... 25\\n\\nCreate your first function ..............................................\", \"................................................................................................ 25\\n\", \"\\nUnderstand triggers and bindings ..................................................................\", \".......................................................... 26\\n\\nTelemetry with Application Insights .\", \"....................................................................................................\", \"......................... 27\\n\\nAzure Logic Apps .....................................................\", \"....................................................................................................\", \"......... 29\\n\\nEvent Grid ...........................................................................\", \"....................................................................................................\", \".. 31\\n\\nScenarios....................................................................................\", \".......................................................................................... 32\\n\\nEvent\", \" Grid vs. other Azure messaging services ...........................................................\", \"......................................... 33\\n\\nPerformance targets...................................\", \"....................................................................................................\", \"................. 34\\n\\nEvent Grid schema ............................................................\", \"............................................................................................... 34\\n\\n\", \"Azure resources ....................................................................................\", \"............................................................................ 35\\n\\nConclusion ........\", \"....................................................................................................\", \".............................................................. 36\\n\\nRecommended resources ...........\", \"....................................................................................................\", \".............................. 36\\n\\nDurable Azure Functions .........................................\", \"........................................................................................... 37\\n\\nTrig\", \"gering a stateful workflow .........................................................................\", \"................................................................ 37\\n\\nWorking with the Orchestration \", \"client .............................................................................................\", \"....................... 37\\n\\nii\\n\\nContents\\n\\n\\fThe orchestrator function ...............................\", \"....................................................................................................\", \".......... 38\\n\\nThe activity functions ..............................................................\", \"........................................................................................ 39\\n\\nRecomme\", \"nded resources .....................................................................................\", \"............................................................. 39\\n\\nOrchestration patterns ...........\", \"....................................................................................................\", \"......................................... 39\\n\\nFunction chaining ....................................\", \"....................................................................................................\", \"..................... 40\\n\\nAsynchronous HTTP APIs ...................................................\", \"........................................................................................... 40\\n\\nMoni\", \"toring .............................................................................................\", \"............................................................................. 41\\n\\nRecommended resour\", \"ces ................................................................................................\", \"............................................. 42\\n\\nServerless business scenarios and use cases ......\", \"........................................................................................ 43\\n\\nBig dat\", \"a processing .......................................................................................\", \"....................................................................... 43\\n\\nCreate serverless applic\", \"ations: hands-on lab ...............................................................................\", \"............................. 43\\n\\nCustomer reviews..................................................\", \"....................................................................................................\", \"............ 43\\n\\nFile processing and validation ....................................................\", \"..................................................................................... 44\\n\\nGame data \", \"visualization ......................................................................................\", \"............................................................... 44\\n\\nGraphQL ........................\", \"....................................................................................................\", \"....................................................... 44\\n\\nInternet of Things (IoT) reliable edge r\", \"elay ...............................................................................................\", \"................. 44\\n\\nMicroservices reference architecture .........................................\", \"................................................................................... 44\\n\\nServerless f\", \"or mobile ..........................................................................................\", \"................................................................. 45\\n\\nServerless messaging .........\", \"....................................................................................................\", \"............................................. 45\\n\\nRecommended resources ............................\", \"....................................................................................................\", \".................. 45\\n\\nConclusion ..................................................................\", \".............................................................................................. 46\\n\\ni\", \"ii\\n\\nContents\\n\\n\\fCHAPTER  1\\nCHAPTER  1\\n\\nArchitecture approaches\\n\\nUnderstanding existing approaches to \", \"architecting enterprise apps helps clarify the role played by\\nserverless. There are many approaches \", \"and patterns that evolved over decades of software\\ndevelopment, and all have their own pros and cons\", \". In many cases, the ultimate solution may not\\ninvolve deciding on a single approach but may integra\", \"te several approaches. Migration scenarios\\noften involve shifting from one architecture approach to \", \"another through a hybrid approach.\\n\\nThis chapter provides an overview of both logical and physical a\", \"rchitecture patterns for enterprise\\napplications.\\n\\nArchitecture patterns\\n\\nModern business applicatio\", \"ns follow a variety of architecture patterns. This section represents a survey\\nof common patterns. T\", \"he patterns listed here aren\\u2019t necessarily all best practices, but illustrate\\ndifferent approaches.\\n\", \"\\nFor more information, see Azure application architecture guide.\\n\\nMonoliths\\n\\nMany business applicati\", \"ons follow a monolith pattern. Legacy applications are often implemented as\\nmonoliths. In the monoli\", \"th pattern, all application concerns are contained in a single deployment.\\nEverything from user inte\", \"rface to database calls is included in the same codebase.\\n\\n1\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\f\", \"There are several advantages to the monolith approach. It\\u2019s often easy to pull down a single code\\nba\", \"se and start working. Ramp up time may be less, and creating test environments is as simple as\\nprovi\", \"ding a new copy. The monolith may be designed to include multiple components and\\napplications.\\n\\nUnfo\", \"rtunately, the monolith pattern tends to break down at scale. Major disadvantages of the\\nmonolith ap\", \"proach include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nDifficult to work in parallel in the same code base.\\n\\nAny chan\", \"ge, no matter how trivial, requires deploying a new version of the entire application.\\n\\nRefactoring \", \"potentially impacts the entire application.\\n\\nOften the only solution to scale is to create multiple,\", \" resource-intensive copies of the monolith.\\n\\nAs systems expand or other systems are acquired, integr\", \"ation can be difficult.\\n\\nIt may be difficult to test due to the need to configure the entire monolit\", \"h.\\n\\nCode reuse is challenging and often other apps end up having their own copies of code.\\n\\nMany bus\", \"inesses look to the cloud as an opportunity to migrate monolith applications and at the\\nsame time re\", \"factor them to more usable patterns. It\\u2019s common to break out the individual\\napplications and compon\", \"ents to allow them to be maintained, deployed, and scaled separately.\\n\\nN-Layer applications\\n\\nN-layer\", \" application partition application logic into specific layers. The most common layers include:\\n\\nUser\", \" interface\\n\\nBusiness logic\\n\\nData access\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n2\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\fOther lay\", \"ers may include middleware, batch processing, and API. It\\u2019s important to note the layers are\\nlogical\", \". Although they\\u2019re developed in isolation, they may all be deployed to the same target platform.\\n\\nTh\", \"ere are several advantages to the N-Layer approach, including:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nRefactoring is isolated to \", \"a layer.\\n\\nTeams can independently build, test, deploy, and maintain separate layers.\\n\\nLayers can be \", \"swapped out, for example the data layer may access multiple databases without\\nrequiring changes to t\", \"he UI layer.\\n\\nServerless may be used to implement one or more layers.\\n\\nMicroservices\\n\\nMicroservices \", \"architectures contain common characteristics that include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nApplications are co\", \"mposed of several small services.\\n\\nEach service runs in its own process.\\n\\nServices are aligned aroun\", \"d business domains.\\n\\nServices communicate over lightweight APIs, typically using HTTP as the transpo\", \"rt.\\n\\nServices can be deployed and upgraded independently.\\n\\nServices aren\\u2019t dependent on a single dat\", \"a store.\\n\\nThe system is designed with failure in mind, and the app may still run even when certain s\", \"ervices\\nfail.\\n\\nMicroservices don\\u2019t have to be mutually exclusive to other architecture approaches. F\", \"or example, an\\nN-Tier architecture may use microservices for the middle tier. It\\u2019s also possible to \", \"implement\\n\\n3\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\fmicroservices in a variety of ways, from virtual\", \" directories on IIS hosts to containers. The characteristics\\nof microservices make them especially i\", \"deal for serverless implementations.\\n\\nThe pros of microservices architectures include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\", \"\\u2022\\n\\nRefactoring is often isolated to a single service.\\n\\nServices can be upgraded independently of eac\", \"h other.\\n\\nResiliency and elasticity can be tuned to the demands of individual services.\\n\\nDevelopment\", \" can happen in parallel across disparate teams and platforms.\\n\\nIt\\u2019s easier to write comprehensive te\", \"sts for isolated services.\\n\\nMicroservices come with their own challenges, including:\\n\\n\\u2022\\n\\nDetermining\", \" what services are available and how to call them.\\n\\n\\u2022  Managing the lifecycle of services.\\n\\n\\u2022\\n\\n\\u2022\\n\\nUn\", \"derstanding how services fit together in the overall application.\\n\\nFull system testing of calls made\", \" across disparate services.\\n\\nUltimately there are solutions to address all of these challenges, incl\", \"uding tapping into the benefits of\\nserverless that are discussed later.\\n\\nArchitecture deployment app\", \"roaches\\n\\nRegardless of the architecture approach used to design a business application, the implemen\", \"tation, or\\ndeployment of those applications may vary. Businesses host applications on everything fro\", \"m physical\\nhardware to serverless functions.\\n\\n4\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\fN-Tier applic\", \"ations\\n\\nThe N-Tier architecture pattern is a mature architecture and simply refers to applications t\", \"hat separate\\nvarious logical layers into separate physical tiers. N-Tier architecture is a physical \", \"implementation of\\nN-Layer architecture. The most common implementation of this architecture includes\", \":\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nA presentation tier, for example a web app.\\n\\nAn API or data access tier, such as a REST \", \"API.\\n\\nA data tier, such as a SQL database.\\n\\nN-tier solutions have the following characteristics:\\n\\n\\u2022\\n\", \"\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nProjects are typically aligned with tiers.\\n\\nTesting may be approached differently by ti\", \"er.\\n\\nTiers provide layers of abstraction, for example the presentation tier is typically ignorant of\", \" the\\nimplementation details of the data tier.\\n\\nTypically, layers only interact with adjacent layers.\", \"\\n\\nReleases are often managed at the project, and therefore tier, level. A simple API change may\\nrequ\", \"ire a new release of an entire middle tier.\\n\\nThis approach provides several benefits, including:\\n\\n\\u2022\\n\", \"\\n\\u2022\\n\\n5\\n\\nIsolation of the database (often the front end doesn\\u2019t have direct access to the database bac\", \"k\\nend).\\n\\nReuse of the API (for example, mobile, desktop, and web app clients can all reuse the same \", \"APIs).\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\f\\u2022\\n\\n\\u2022\\n\\nAbility to scale out tiers independent of each o\", \"ther.\\n\\nRefactoring isolation: one tier may be refactored without impacting other tiers.\\n\\nOn-premises\", \" and Infrastructure as a Service (IaaS)\\n\\nThe traditional approach to hosting applications requires b\", \"uying hardware and managing all of the\\nsoftware installations, including the operating system. Origi\", \"nally this involved expensive data centers\\nand physical hardware. The challenges that come with oper\", \"ating physical hardware are many,\\nincluding:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe need to buy excess for \\u201cjust \", \"in case\\u201d or peak demand scenarios.\\n\\nSecuring physical access to the hardware.\\n\\nResponsibility for ha\", \"rdware failure (such as disk failure).\\n\\nCooling.\\n\\nConfiguring routers and load balancers.\\n\\nPower red\", \"undancy.\\n\\nSecuring software access.\\n\\nVirtualization of hardware, via \\u201cvirtual machines\\u201d enables Infr\", \"astructure as a Service (IaaS). Host\\nmachines are effectively partitioned to provide resources to in\", \"stances with allocations for their own\\nmemory, CPU, and storage. The team provisions the necessary V\", \"Ms and configures the associated\\nnetworks and access to storage.\\n\\nFor more information, see virtual \", \"machine N-tier reference architecture.\\n\\nAlthough virtualization and Infrastructure as a Service (Iaa\", \"S) address many concerns, it still leaves\\nmuch responsibility in the hands of the infrastructure tea\", \"m. The team maintains operating system\\nversions, applies security patches, and installs third-party \", \"dependencies on the target machines. Apps\\noften behave differently on production machines compared t\", \"o the test environment. Issues arise due\\nto different dependency versions and/or OS SKU levels. Alth\", \"ough many organizations deploy N-Tier\\napplications to these targets, many companies benefit from dep\", \"loying to a more cloud native model\\n\\n6\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\fsuch as Platform as a \", \"Service. Architectures with microservices are more challenging because of the\\nrequirements to scale \", \"out for elasticity and resiliency.\\n\\nFor more information, see virtual machines.\\n\\nPlatform as a Servi\", \"ce (PaaS)\\n\\nPlatform as a Service (PaaS) offers configured solutions that developers can plug into di\", \"rectly. PaaS is\\nanother term for managed hosting. It eliminates the need to manage the base operatin\", \"g system,\\nsecurity patches and in many cases any third-party dependencies. Examples of platforms inc\", \"lude web\\napplications, databases, and mobile back ends.\\n\\nPaaS addresses the challenges common to Iaa\", \"S. PaaS allows the developer to focus on the code or\\ndatabase schema rather than how it gets deploye\", \"d. Benefits of PaaS include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nPay for use models that eliminate the overhead of investin\", \"g in idle machines.\\n\\nDirect deployment and improved DevOps, continuous integration (CI), and continu\", \"ous delivery\\n(CD) pipelines.\\n\\nAutomatic upgrades, updates, and security patches.\\n\\nPush-button scale \", \"out and scale up (elastic scale).\\n\\nThe main disadvantage of PaaS traditionally has been vendor lock-\", \"in. For example, some PaaS\\nproviders only support ASP.NET, Node.js, or other specific languages and \", \"platforms. Products like\\nAzure App Service have evolved to address multiple platforms and support a \", \"variety of languages and\\nframeworks for hosting web apps.\\n\\nSoftware as a Service (SaaS)\\n\\nSoftware as\", \" a Service or SaaS is centrally hosted and available without local installation or\\nprovisioning. Saa\", \"S often is hosted on top of PaaS as a platform for deploying software. SaaS provides\\nservices to run\", \" and connect with existing software. SaaS is often industry and vertical specific. SaaS is\\noften lic\", \"ensed and typically provides a client/server model. Most modern SaaS offerings use web-\\n\\n7\\n\\nCHAPTER \", \"1 | Architecture approaches\\n\\n\\fbased apps for the client. Companies typically consider SaaS as a busi\", \"ness solution to license\\nofferings. It isn\\u2019t often implemented as architecture consideration for sca\", \"lability and maintainability of\\nan application. Indeed, most SaaS solutions are built on IaaS, PaaS,\", \" and/or serverless back ends.\\n\\nLearn more about SaaS through a sample application.\\n\\nContainers and F\", \"unctions as a Service (FaaS)\\n\\nContainers are an interesting solution that enables PaaS-like benefits\", \" without the IaaS overhead. A\\ncontainer is essentially a runtime that contains the bare essentials n\", \"eeded to run a unique application.\\nThe kernel or core part of the host operating system and services\", \" such as storage are shared across a\\nhost. The shared kernel enables containers to be lightweight (s\", \"ome are mere megabytes in size,\\ncompared to the gigabyte size of typical virtual machines). With hos\", \"ts already running, containers can\\nbe started quickly, facilitating high availability. The ability t\", \"o spin up containers quickly also provides\\nextra layers of resiliency. Docker is one of the more pop\", \"ular implementations of containers.\\n\\nBenefits of containers include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nLightweight and\", \" portable\\n\\nSelf-contained so no need to install dependencies\\n\\nProvide a consistent environment regar\", \"dless of the host (runs exactly same on a laptop as on a\\ncloud server)\\n\\nCan be provisioned quickly f\", \"or scale-out\\n\\nCan be restarted quickly to recover from failure\\n\\nA container runs on a container host\", \" (that in turn may run on a bare metal machine or a virtual\\nmachine). Multiple containers or instanc\", \"es of the same containers may run on a single host. For true\\nfailover and resiliency, containers mus\", \"t be scaled across hosts.\\n\\nFor more information about Docker containers, see What is Docker.\\n\\nManagi\", \"ng containers across hosts typically requires an orchestration tool such as Kubernetes.\\nConfiguring \", \"and managing orchestration solutions may add additional overhead and complexity to\\nprojects. Fortuna\", \"tely, many cloud providers provide orchestration services through PaaS solutions to\\nsimplify the man\", \"agement of containers.\\n\\nThe following image illustrates an example Kubernetes installation. Nodes in\", \" the installation address\\nscale out and failover. They run Docker container instances that are manag\", \"ed by the primary server.\\nThe kubelet is the client that relays commands from Kubernetes to Docker.\\n\", \"\\n8\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\fFor more information about orchestration, see Kubernetes o\", \"n Azure.\\n\\nFunctions as a Service (FaaS) is a specialized container service that is similar to server\", \"less. A specific\\nimplementation of FaaS, called OpenFaaS, sits on top of containers to provide serve\", \"rless capabilities.\\nOpenFaaS provides templates that package all of the container dependencies neces\", \"sary to run a piece\\nof code. Using templates simplifies the process of deploying code as a functiona\", \"l unit. OpenFaaS\\ntargets architectures that already include containers and orchestrators because it \", \"can use the existing\\ninfrastructure. Although it provides serverless functionality, it specifically \", \"requires you to use Docker\\nand an orchestrator.\\n\\nServerless\\n\\nA serverless architecture provides a cl\", \"ear separation between the code and its hosting environment.\\nYou implement code in a function that i\", \"s invoked by a trigger. After that function exits, all its needed\\nresources may be freed. The trigge\", \"r might be manual, a timed process, an HTTP request, or a file\\nupload. The result of the trigger is \", \"the execution of code. Although serverless platforms vary, most\\nprovide access to pre-defined APIs a\", \"nd bindings to streamline tasks such as writing to a database or\\nqueueing results.\\n\\nServerless is an\", \" architecture that relies heavily on abstracting away the host environment to focus on\\ncode. It can \", \"be thought of as less server.\\n\\nContainer solutions provide developers existing build scripts to publ\", \"ish code to serverless-ready\\nimages. Other implementations use existing PaaS solutions to provide a \", \"scalable architecture.\\n\\nThe abstraction means the DevOps team doesn\\u2019t have to provision or manage se\", \"rvers, nor specific\\ncontainers. The serverless platform hosts code, either as script or packaged exe\", \"cutables built with a\\nrelated SDK, and allocates the necessary resources for the code to scale.\\n\\nThe\", \" following diagram illustrates four serverless components. An HTTP request causes the Checkout\\nAPI c\", \"ode to run. The Checkout API inserts code into a database, and the insert triggers several other\\nfun\", \"ctions to run to perform tasks like computing tasks and fulfilling the order.\\n\\n9\\n\\nCHAPTER 1 | Archit\", \"ecture approaches\\n\\n\\fThe advantages of serverless include:\\n\\n\\u2022\\n\\nHigh density. Many instances of the sa\", \"me serverless code can run on the same host compared\\nto containers or virtual machines. The instance\", \"s scale across multiple hosts addressing scale out\\nand resiliency.\\n\\n\\u2022  Micro-billing. Most serverles\", \"s providers bill based on serverless executions, enabling massive\\n\\ncost savings in certain scenarios\", \".\\n\\n\\u2022\\n\\n\\u2022\\n\\nInstant scale. Serverless can scale to match workloads automatically and quickly.\\n\\nFaster t\", \"ime to market. Developers focus on code and deploy directly to the serverless platform.\\nComponents c\", \"an be released independently of each other.\\n\\nServerless is most often discussed in the context of co\", \"mpute, but can also apply to data. For example,\\nAzure SQL and Cosmos DB both provide cloud databases\", \" that don\\u2019t require you to configure host\\nmachines or clusters. This book focuses on serverless comp\", \"ute.\\n\\nSummary\\n\\nThere\\u2019s a broad spectrum of available choices for architecture, including a hybrid ap\", \"proach. Serverless\\nsimplifies the approach, management, and cost of application features at the expe\", \"nse of control and\\nportability. However, many serverless platforms do expose configuration to help f\", \"ine-tune the\\nsolution. Good programming practices can also lead to more portable code and less serve\", \"rless\\nplatform lock-in. The following table illustrates the architecture approaches side by side. Ch\", \"oose\\nserverless based on your scale needs, whether or not you want to manage the runtime, and how we\", \"ll\\nyou can break your workloads into small components. You\\u2019ll learn about potential challenges with\\n\", \"serverless and other decision points in the next chapter.\\n\\nIaaS\\n\\nPaaS\\n\\nContainer\\n\\nServerless\\n\\nScale\\n\", \"\\nVM\\n\\nAbstracts\\n\\nHardware\\n\\nVM\\n\\nUnit\\n\\n10\\n\\nInstance\\n\\nPlatform\\n\\nProject\\n\\nApp\\n\\nOS Host\\n\\nImage\\n\\nFunction\\n\\n\", \"Runtime\\n\\nCode\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\fIaaS\\n\\nPaaS\\n\\nContainer\\n\\nServerless\\n\\nLifetime\\n\\nMo\", \"nths\\n\\nDays to Months  Minutes to Days\\n\\nResponsibility  Applications,\\n\\ndependencies, runtime,\\nand ope\", \"rating system\\n\\nApplications and\\ndependencies\\n\\nApplications,\\ndependencies, and\\nruntime\\n\\nMilliseconds\\n\", \"to Minutes\\n\\nFunction\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nScale refers to the unit that is used to scale the application\\n\", \"\\nAbstracts refers to the layer that is abstracted by the implementation\\n\\nUnit refers to the scope of\", \" what is deployed\\n\\nLifetime refers to the typical runtime of a specific instance\\n\\nResponsibility ref\", \"ers to the overhead to build, deploy, and maintain the application\\n\\nThe next chapter will focus on s\", \"erverless architecture, use cases, and design patterns.\\n\\nRecommended resources\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nAzure\", \" application architecture guide\\n\\nAzure Cosmos DB\\n\\nAzure SQL\\n\\nN-Tier architecture pattern\\n\\nKubernetes\", \" on Azure\\n\\n\\u2022  Microservices\\n\\n\\u2022\\n\\n\\u2022\\n\\nVirtual machine N-tier reference architecture\\n\\nVirtual machines\\n\\n\", \"\\u2022  What is Docker?\\n\\n\\u2022  Wingtip Tickets SaaS application\\n\\n11\\n\\nCHAPTER 1 | Architecture approaches\\n\\n\\fC\", \"HAPTER  2\\nCHAPTER  2\\n\\nServerless architecture\\n\\nThere are many approaches to using serverless archite\", \"ctures. This chapter explores examples of\\ncommon architectures that integrate serverless. It also co\", \"vers concerns that may pose additional\\nchallenges or require extra consideration when implementing s\", \"erverless. Finally, several design\\nexamples are provided that illustrate various serverless use case\", \"s.\\n\\nServerless hosts often use an existing container-based or PaaS layer to manage the serverless\\nin\", \"stances. For example, Azure Functions is based on Azure App Service. The App Service is used to\\nscal\", \"e out instances and manage the runtime that executes Azure Functions code. For Windows-based\\nfunctio\", \"ns, the host runs as PaaS and scales out the .NET runtime. For Linux-based functions, the host\\nlever\", \"ages containers.\\n\\nThe WebJobs Core provides an execution context for the function. The Language Runt\", \"ime runs scripts,\\nexecutes libraries and hosts the framework for the target language. For example, N\", \"ode.js is used to\\nrun JavaScript functions and the .NET Framework is used to run C# functions. You\\u2019l\", \"l learn more about\\nlanguage and platform options later in this chapter.\\n\\nSome projects may benefit f\", \"rom taking an \\u201call-in\\u201d approach to serverless. Applications that rely heavily\\non microservices may i\", \"mplement all microservices using serverless technology. The majority of apps\\nare hybrid, following a\", \"n N-tier design and using serverless for the components that make sense\\n\\n12\\n\\nCHAPTER 2 | Serverless \", \"architecture\\n\\n\\fbecause the components are modular and independently scalable. To help make sense of \", \"these\\nscenarios, this section walks through some common architecture examples that use serverless.\\n\\n\", \"Full serverless back end\\n\\nThe full serverless back end is ideal for several types of scenarios, espe\", \"cially when building new or\\n\\u201cgreen field\\u201d applications. An application with a large surface area of \", \"APIs may benefit from\\nimplementing each API as a serverless function. Apps that are based on microse\", \"rvices architecture are\\nanother example that could be implemented as a full serverless back end. The\", \" microservices\\ncommunicate over various protocols with each other. Specific scenarios include:\\n\\n\\u2022\\n\\nA\", \"PI-based SaaS products (example: financial payments processor).\\n\\n\\u2022  Message-driven applications (exa\", \"mple: device monitoring solution).\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nApps focused on integration between services (exampl\", \"e: airline booking application).\\n\\nProcesses that run periodically (example: timer-based database cle\", \"an-up).\\n\\nApps focused on data transformation (example: import triggered by file upload).\\n\\nExtract Tr\", \"ansform and Load (ETL) processes.\\n\\nThere are other, more specific use cases that are covered later i\", \"n this document.\\n\\nMonoliths and \\u201cstarving the beast\\u201d\\n\\nA common challenge is migrating an existing mo\", \"nolithic application to the cloud. The least risky\\napproach is to \\u201clift and shift\\u201d entirely onto vir\", \"tual machines. Many shops prefer to use the migration as\\nan opportunity to modernize their code base\", \". A practical approach to migration is called \\u201cstarving the\\nbeast.\\u201d In this scenario, the monolith i\", \"s migrated \\u201cas is\\u201d to start with. Then, selected services are\\nmodernized. In some cases, the signatu\", \"re of the service is identical to the original: it simply is hosted\\nas a function. Clients are updat\", \"ed to use the new service rather than the monolith endpoint. In the\\ninterim, steps such as database \", \"replication enable microservices to host their own storage even when\\ntransactions are still handled \", \"by the monolith. Eventually, all clients are migrated onto the new\\nservices. The monolith is \\u201cstarve\", \"d\\u201d (its services no longer called) until all functionality has been\\nreplaced. The combination of ser\", \"verless and proxies can facilitate much of this migration.\\n\\n13\\n\\nCHAPTER 2 | Serverless architecture\\n\", \"\\n\\fTo learn more about this approach, watch the video: Bring your app to the cloud with serverless Az\", \"ure\\nFunctions.\\n\\nWeb apps\\n\\nWeb apps are great candidates for serverless applications. There are two c\", \"ommon approaches to web\\napps today: server-driven, and client-driven (such as Single Page Applicatio\", \"n or SPA). Server-driven\\nweb apps typically use a middleware layer to issue API calls to render the \", \"web UI. SPA applications\\nmake REST API calls directly from the browser. In both scenarios, serverles\", \"s can accommodate the\\nmiddleware or REST API request by providing the necessary business logic. A co\", \"mmon architecture is\\nto stand up a lightweight static web server. The Single Page Application (SPA) \", \"serves HTML, CSS,\\nJavaScript, and other browser assets. The web app then connects to a microservices\", \" back end.\\n\\nMobile back ends\\n\\nThe event-driven paradigm of serverless apps makes them ideal as mobil\", \"e back ends. The mobile\\ndevice triggers the events and the serverless code executes to satisfy reque\", \"sts. Taking advantage of a\\nserverless model enables developers to enhance business logic without hav\", \"ing to deploy a full\\napplication update. The serverless approach also enables teams to share endpoin\", \"ts and work in\\nparallel.\\n\\nMobile developers can build business logic without becoming experts on the\", \" server side. Traditionally,\\nmobile apps connected to on-premises services. Building the service lay\", \"er required understanding the\\nserver platform and programming paradigm. Developers worked with opera\", \"tions to provision servers\\n\\n14\\n\\nCHAPTER 2 | Serverless architecture\\n\\n\\fand configure them appropriate\", \"ly. Sometimes days or even weeks were spent on building a\\ndeployment pipeline. All of these challeng\", \"es are addressed by serverless.\\n\\nServerless abstracts the server-side dependencies and enables the d\", \"eveloper to focus on business\\nlogic. For example, a mobile developer who builds apps using a JavaScr\", \"ipt framework can build\\nserverless functions with JavaScript as well. The serverless host manages th\", \"e operating system, a\\nNode.js instance to host the code, package dependencies, and more. The develop\", \"er is provided a\\nsimple set of inputs and a standard template for outputs. They then can focus on bu\", \"ilding and testing\\nthe business logic. They\\u2019re therefore able to use existing skills to build the ba\", \"ck-end logic for the\\nmobile app without having to learn new platforms or become a \\u201cserver-side devel\", \"oper.\\u201d\\n\\nMost cloud providers offer mobile-based serverless products that simplify the entire mobile\\n\", \"development lifecycle. The products may automate the provisioning of databases to persist data,\\nhand\", \"le DevOps concerns, provide cloud-based builds and testing frameworks and the ability to script\\nbusi\", \"ness processes using the developer\\u2019s preferred language. Following a mobile-centric serverless\\nappro\", \"ach can streamline the process. Serverless removes the tremendous overhead of provisioning,\\nconfigur\", \"ing, and maintaining servers for the mobile back end.\\n\\nInternet of Things (IoT)\\n\\nIoT refers to physi\", \"cal objects that are networked together. They\\u2019re sometimes referred to as\\n\\u201cconnected devices\\u201d or \\u201csm\", \"art devices.\\u201d Everything from cars and vending machines may be\\nconnected and send information rangin\", \"g from inventory to sensor data such as temperature and\\nhumidity. In the enterprise, IoT provides bu\", \"siness process improvements through monitoring and\\nautomation. IoT data may be used to regulate the \", \"climate in a large warehouse or track inventory\\nthrough the supply chain. IoT can sense chemical spi\", \"lls and call the fire department when smoke is\\ndetected.\\n\\nThe sheer volume of devices and informatio\", \"n often dictates an event-driven architecture to route and\\nprocess messages. Serverless is an ideal \", \"solution for several reasons:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n15\\n\\nEnables scale as the volume of devices and data incre\", \"ases.\\n\\nAccommodates adding new endpoints to support new devices and sensors.\\n\\nFacilitates independen\", \"t versioning so developers can update the business logic for a specific\\ndevice without having to dep\", \"loy the entire system.\\n\\nResiliency and less downtime.\\n\\nCHAPTER 2 | Serverless architecture\\n\\n\\fThe per\", \"vasiveness of IoT has resulted in several serverless products that focus specifically on IoT\\nconcern\", \"s, such as Azure IoT Hub. Serverless automates tasks such as device registration, policy\\nenforcement\", \", tracking, and even deployment of code to devices at the edge. The edge refers to\\ndevices like sens\", \"ors and actuators that are connected to, but not an active part of, the Internet.\\n\\nServerless archit\", \"ecture considerations\\n\\nAdopting a serverless architecture does come with certain challenges. This se\", \"ction explores some of\\nthe more common considerations to be aware of. All of these challenges have s\", \"olutions. As with all\\narchitecture choices, the decision to go serverless should be made only after \", \"carefully considering the\\npros and cons. Depending on the needs of your application, you may decide \", \"a serverless\\nimplementation isn\\u2019t the right solution for certain components.\\n\\nManaging state\\n\\nServer\", \"less functions, as with microservices in general, are stateless by default. Avoiding state enables\\ns\", \"erverless to be ephemeral, to scale out, and to provide resiliency without a central point of failur\", \"e. In\\nsome circumstances, business processes require state. If your process requires state, you have\", \" two\\noptions. You can adopt a model other than serverless, or interact with a separate service that \", \"provides\\nstate. Adding state can complicate the solution and make it harder to scale, and potentiall\", \"y create a\\nsingle point of failure. Carefully consider whether your function absolutely requires sta\", \"te. If the answer\\nis \\u201cyes,\\u201d determine whether it still makes sense to implement it with serverless.\\n\", \"\\nThere are several solutions to adopt state without compromising the benefits of serverless. Some of\", \"\\nthe more popular solutions include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nUse a temporary data store or distributed cache, like\", \" Redis\\n\\nStore state in a database, like SQL or CosmosDB\\n\\nHandle state through a workflow engine like\", \" durable functions\\n\\nThe bottom line is that you should be aware of the need for any state management\", \" within processes\\nyou\\u2019re considering to implement with serverless.\\n\\nLong-running processes\\n\\nMany ben\", \"efits of serverless rely on the processes being ephemeral. Short run times make it easier for\\nthe se\", \"rverless provider to free up resources as functions end and share functions across hosts. Most\\ncloud\", \" providers limit the total time your function can run to around 10 minutes. If your process may\\ntake\", \" longer, you might consider an alternative implementation.\\n\\nThere are a few exceptions and solutions\", \". One solution may be to break your process into smaller\\ncomponents that individually take less time\", \" to run. If your process runs long because of dependencies,\\nyou can also consider an asynchronous wo\", \"rkflow using a solution like durable functions. Durable\\nfunctions pause and maintain the state of yo\", \"ur process while it\\u2019s waiting on an external process to\\nfinish. Asynchronous handling reduces the ti\", \"me the actual process runs.\\n\\n16\\n\\nCHAPTER 2 | Serverless architecture\\n\\n\\fStartup time\\n\\nOne potential c\", \"oncern with serverless implementations is startup time. To conserve resources, many\\nserverless provi\", \"ders create infrastructure \\u201con demand.\\u201d When a serverless function is triggered after a\\nperiod of ti\", \"me, the resources to host the function may need to be created or restarted. In some\\nsituations, cold\", \" starts may result in delays of several seconds. Startup time varies across providers and\\nservice le\", \"vels. There are a few approaches to address startup time if it\\u2019s important to minimize for the\\nsucce\", \"ss of the app.\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nSome providers allow users to pay for service levels that guarantee infrast\", \"ructure is \\u201calways on\\u201d.\\n\\nImplement a keep-alive mechanism (ping the endpoint to keep it \\u201cawake\\u201d).\\n\\nU\", \"se orchestration like Kubernetes with a containerized function approach (the host is already\\nrunning\", \" so spinning up new instances is extremely fast).\\n\\nDatabase updates and migrations\\n\\nAn advantage of \", \"serverless code is that you can release new functions without having to redeploy the\\nentire applicat\", \"ion. This advantage can become a disadvantage when there\\u2019s a relational database\\ninvolved. Changes t\", \"o database schemas are difficult to synchronize with serverless updates. Additional\\nchallenges are p\", \"osed when things go wrong and the changes must be rolled back. Data integrity is\\none reason that a b\", \"est practice for microservices and serverless functions is that they own their own\\ndata. It is possi\", \"ble to deploy changes as a single unit of compute and data. The reality is that many\\nlegacy systems \", \"feature a large back-end database that must be reconciled with the serverless\\narchitecture.\\n\\nA popul\", \"ar approach to solve schema versioning is to never modify existing properties and columns,\\nbut inste\", \"ad add new information. For example, consider a change to move from a Boolean\\n\\u201ccompleted\\u201d flag for a\", \" todo list to a \\u201ccompleted date.\\u201d Instead of removing the old field, the database\\nchange will:\\n\\n1.\\n\\n\", \"2.\\n\\n3.\\n\\nAdd a new \\u201ccompleted date\\u201d field.\\n\\nTransform the \\u201ccompleted\\u201d Boolean field to a computed fun\", \"ction that evaluates whether the\\ncompleted date is after the current date.\\n\\nAdd a trigger to set the\", \" completed date to the current date when the completed Boolean is set\\nto true.\\n\\nThe sequence of chan\", \"ges ensures that legacy code continues to run \\u201cas is\\u201d while newer serverless\\nfunctions can take adva\", \"ntage of the new field.\\n\\nFor more information about data in serverless architectures, see Challenges\", \" and solutions for\\ndistributed data management.\\n\\nScaling\\n\\nIt\\u2019s a common misconception that serverles\", \"s means \\u201cno server.\\u201d It\\u2019s in fact \\u201cless server.\\u201d The fact there\\nis a backing infrastructure is impor\", \"tant to understand when it comes to scaling. Most serverless\\nplatforms provide a set of controls to \", \"handle how the infrastructure should scale when event density\\nincreases. You can choose from a varie\", \"ty of options, but your strategy may vary depending on the\\n\\n17\\n\\nCHAPTER 2 | Serverless architecture\\n\", \"\\n\\ffunction. Furthermore, functions are typically run under a related host, so that functions on the \", \"same\\nhost have the same scale options. Therefore it is necessary to organize and strategize which fu\", \"nctions\\nare hosted together based on scale requirements.\\n\\nRules often specify how to scale-up (incre\", \"ase the host resources) and scale-out (increase the number\\nof host instances) based on varying param\", \"eters. Triggers for scales may include schedule, request\\nrates, CPU utilization, and memory usage. H\", \"igher performance often comes at a greater cost. The less\\nexpensive, consumption-based approaches ma\", \"y not scale as quickly when the request rate suddenly\\nincreases. There is a trade-off between paying\", \" up front \\u201cinsurance cost\\u201d versus paying strictly \\u201cas you\\ngo\\u201d and risking slower responses due to su\", \"dden increases in demand.\\n\\nMonitoring, tracing, and logging\\n\\nAn often overlooked aspect of DevOps is\", \" monitoring applications once deployed. It\\u2019s important to\\nhave a strategy for monitoring serverless \", \"functions. The biggest challenge is often correlation, or\\nrecognizing when a user calls multiple fun\", \"ctions as part of the same interaction. Most serverless\\nplatforms allow console logging that can be \", \"imported into third-party tools. There are also options to\\nautomate collection of telemetry, generat\", \"e and track correlation IDs, and monitor specific actions to\\nprovide detailed insights. Azure provid\", \"es the advanced Application Insights platform for monitoring\\nand analytics.\\n\\nInter-service dependenc\", \"ies\\n\\nA serverless architecture may include functions that rely on other functions. In fact, it isn\\u2019t\", \" uncommon\\nin a serverless architecture to have multiple services call each other as part of an inter\", \"action or\\ndistributed transaction. To avoid strong coupling, it\\u2019s recommended that services don\\u2019t re\", \"ference each\\nother directly. When the endpoint for a service needs to change, direct references coul\", \"d result in\\nmajor refactoring. A suggested solution is to provide a service discovery mechanism, suc\", \"h as a\\nregistry, that provides the appropriate end point for a request type. Another solution is to \", \"leverage\\nmessaging services like queues or topics for communication between services.\\n\\nManaging fail\", \"ure and providing resiliency\\n\\nIt\\u2019s also important to consider the circuit-breaker pattern: If, for s\", \"ome reason, a service continues to\\nfail, it isn\\u2019t advisable to call that service repeatedly. Instead\", \", an alternative service is called or a\\nmessage returned until the health of the dependent service i\", \"s re-established. The serverless\\narchitecture needs to take into account the strategy for resolving \", \"and managing inter-service\\ndependencies.\\n\\nTo continue the circuit-breaker pattern, services need to \", \"be fault tolerant and resilient. Fault tolerance\\nrefers to the ability of your application to contin\", \"ue running even after unexpected exceptions or\\ninvalid states are encountered. Fault tolerance is ty\", \"pically a function of the code itself and how it\\u2019s\\nwritten to handle exceptions. Resiliency refers t\", \"o how capable the app is at recovering from failures.\\nResiliency is often managed by the serverless \", \"platform. The platform should be able to spin up a new\\nserverless function instance when the existin\", \"g one fails. The platform should also be intelligent\\nenough to stop spinning up new instances when e\", \"very new instance fails.\\n\\n18\\n\\nCHAPTER 2 | Serverless architecture\\n\\n\\fFor more information, see Implem\", \"enting the Circuit Breaker pattern.\\n\\nVersioning and green/blue deployments\\n\\nA major benefit of serve\", \"rless is the ability to upgrade a specific function without having to redeploy\\nthe entire applicatio\", \"n. For upgrades to be successful, functions must be versioned so that services\\ncalling them are rout\", \"ed to the correct version of code. A strategy for deploying new versions is also\\nimportant. A common\", \" approach is to use \\u201cgreen/blue deployments.\\u201d The green deployment is the\\ncurrent function. A new \\u201cb\", \"lue\\u201d version is deployed to production and tested. When testing passes, the\\ngreen and blue versions \", \"are swapped so the new version comes live. If any issues are encountered,\\nthey can be swapped back. \", \"Supporting versioning and green/blue deployments requires a\\ncombination of authoring the functions t\", \"o accommodate version changes and working with the\\nserverless platform to handle deployments.\\n\\nServe\", \"rless design examples\\n\\nThere are many design patterns that exist for serverless. This section captur\", \"es some common\\nscenarios that use serverless. What all of the examples have in common is the fundame\", \"ntal\\ncombination of an event trigger and business logic.\\n\\nScheduling\\n\\nScheduling tasks is a common f\", \"unction. The following diagram shows a legacy database that doesn\\u2019t\\nhave appropriate integrity check\", \"s. The database must be scrubbed periodically. The serverless\\nfunction finds invalid data and cleans\", \" it. The trigger is a timer that runs the code on a schedule.\\n\\nCommand and Query Responsibility Segr\", \"egation (CQRS)\\n\\nCommand and Query Responsibility Segregation (CQRS) is a pattern that provides diffe\", \"rent interfaces\\nfor reading (or querying) data and operations that modify data. It addresses several\", \" common\\nproblems. In traditional Create Read Update Delete (CRUD) based systems, conflicts can arise\", \" from\\nhigh volume of both reads and writes to the same data store. Locking may frequently occur and\\n\", \"dramatically slow down reads. Often, data is presented as a composite of several domain objects and\\n\", \"read operations must combine data from different entities.\\n\\nUsing CQRS, a read might involve a speci\", \"al \\u201cflattened\\u201d entity that models data the way it\\u2019s consumed.\\nThe read is handled differently than h\", \"ow it\\u2019s stored. For example, although the database may store a\\ncontact as a header record with a chi\", \"ld address record, the read could involve an entity with both\\n\\n19\\n\\nCHAPTER 2 | Serverless architectu\", \"re\\n\\n\\fheader and address properties. There are myriad approaches to creating the read model. It might\", \" be\\nmaterialized from views. Update operations could be encapsulated as isolated events that then tr\", \"igger\\nupdates to two different models. Separate models exist for reading and writing.\\n\\nServerless ca\", \"n accommodate the CQRS pattern by providing the segregated endpoints. One serverless\\nfunction accomm\", \"odates queries or reads, and a different serverless function or set of functions\\nhandles update oper\", \"ations. A serverless function may also be responsible for keeping the read model\\nup-to-date, and can\", \" be triggered by the database\\u2019s change feed. Front-end development is simplified\\nto connecting to th\", \"e necessary endpoints. Processing of events is handled on the back end. This\\nmodel also scales well \", \"for large projects because different teams may work on different operations.\\n\\nEvent-based processing\", \"\\n\\nIn message-based systems, events are often collected in queues or publisher/subscriber topics to b\", \"e\\nacted upon. These events can trigger serverless functions to execute a piece of business logic. An\", \"\\nexample of event-based processing is event-sourced systems. An \\u201cevent\\u201d is raised to mark a task as\\n\", \"complete. A serverless function triggered by the event updates the appropriate database document. A\\n\", \"second serverless function may use the event to update the read model for the system. Azure Event\\nGr\", \"id provides a way to integrate events with functions as subscribers.\\n\\nEvents are informational messa\", \"ges. For more information, see Event Sourcing pattern.\\n\\nFile triggers and transformations\\n\\nExtract, \", \"Transform, and Load (ETL) is a common business function. Serverless is a great solution for ETL\\nbeca\", \"use it allows code to be triggered as part of a pipeline. Individual code components can address\\nvar\", \"ious aspects. One serverless function may download the file, another applies the transformation,\\nand\", \" another loads the data. The code can be tested and deployed independently, making it easier to\\nmain\", \"tain and scale where needed.\\n\\n20\\n\\nCHAPTER 2 | Serverless architecture\\n\\n\\fIn the diagram, \\u201ccool storag\", \"e\\u201d provides data that is parsed in Azure Stream Analytics. Any issues\\nencountered in the data stream\", \" trigger an Azure Function to address the anomaly.\\n\\nAsynchronous background processing and messaging\", \"\\n\\nAsynchronous messaging and background processing allow applications to kick off processes without\\n\", \"having to wait. An example of asynchronous processing is an OCR app. An image is submitted and\\nqueue\", \"d for processing. Scanning the image to extract text may take time, and once it\\u2019s finished a\\nnotific\", \"ation is sent. Serverless can handle both the invocation and the result in this scenario.\\n\\nWeb apps \", \"and APIs\\n\\nA popular scenario for serverless is N-tier applications, most commonly ones where the UI \", \"layer is a\\nweb app. The popularity of Single Page Applications (SPA) has surged recently. SPA apps r\", \"ender a\\nsingle page, then rely on API calls and the returned data to dynamically render new UI witho\", \"ut\\nreloading a full page. Client-side rendering provides a much faster, more responsive application \", \"to the\\nend user.\\n\\nServerless endpoints triggered by HTTP calls can be used to handle the API request\", \"s. For example, an\\nad services company may call a serverless function with user profile information \", \"to request custom\\nadvertising. The serverless function returns the custom ad and the web page render\", \"s it.\\n\\n21\\n\\nCHAPTER 2 | Serverless architecture\\n\\n\\fData pipeline\\n\\nServerless functions can be used to \", \"facilitate a data pipeline. In this example, a file triggers a function\\nto translate data in a CSV f\", \"ile to data rows in a table. The organized table allows a Power BI dashboard\\nto present analytics to\", \" the end user.\\n\\nStream processing\\n\\nDevices and sensors often generate streams of data that must be p\", \"rocessed in real time. There are a\\nnumber of technologies that can capture messages and streams from\", \" Event Hubs and IoT Hub to\\nService Bus. Regardless of transport, serverless is an ideal mechanism fo\", \"r processing the messages\\nand streams of data as they come in. Serverless can scale quickly to meet \", \"the demand of large\\nvolumes of data. The serverless code can apply business logic to parse the data \", \"and output in a\\nstructured format for action and analytics.\\n\\n22\\n\\nCHAPTER 2 | Serverless architecture\", \"\\n\\n\\fAPI gateway\\n\\nAn API gateway provides a single point of entry for clients and then intelligently r\", \"outes requests to\\nback-end services. It\\u2019s useful to manage large sets of services. It can also handl\", \"e versioning and\\nsimplify development by easily connecting clients to disparate environments. Server\", \"less can handle\\nback-end scaling of individual microservices while presenting a single front end via\", \" an API gateway.\\n\\nRecommended resources\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nAzure Event Grid\\n\\nAzure IoT Hub\\n\", \"\\nChallenges and solutions for distributed data management\\n\\nDesigning microservices: identifying micr\", \"oservice boundaries\\n\\nEvent Hubs\\n\\nEvent Sourcing pattern\\n\\nImplementing the Circuit Breaker pattern\\n\\nI\", \"oT Hub\\n\\nService Bus\\n\\n\\u2022  Working with the change feed support in Azure Cosmos DB\\n\\n23\\n\\nCHAPTER 2 | Ser\", \"verless architecture\\n\\n\\fCHAPTER  3 CHAPTER  3\\n\\nAzure serverless platform\\n\\nThe Azure serverless platfo\", \"rm includes Azure Functions, Logic Apps, and Event Grid. These services\\nwork together and connect wi\", \"th myriad other resources. The serverless platform works with\\neverything from databases and storage \", \"to analytics and machine learning/artificial intelligence.\\n\\nYou can also use Application Insights, a\", \" serverless platform for capturing diagnostic traces and\\ntelemetry. Application Insights are availab\", \"le to applications of all types (desktop, mobile, or web) as\\nwell as serverless implementations. The\", \" platform is visualized in the following diagram:\\n\\nThis chapter breaks down the fundamentals of each\", \" component.\\n\\nAzure Functions\\n\\nAzure Functions provide a serverless compute experience. A function is\", \" invoked by a trigger (such as\\naccess to an HTTP endpoint or a timer) and executes a block of code o\", \"r business logic. Functions also\\nsupport specialized bindings that connect to resources like storage\", \" and queues.\\n\\n24\\n\\nCHAPTER 3 | Azure serverless platform\\n\\n\\fThe current runtime version 4.0 supports c\", \"ross-platform .NET 7.0 applications. Additional languages\\nbesides C# such as JavaScript, F#, and Jav\", \"a are supported. Functions created in the portal provide a\\nrich scripting syntax. Functions created \", \"as standalone projects can be deployed with full platform\\nsupport and capabilities.\\n\\nFor more inform\", \"ation, see Azure Functions documentation.\\n\\nProgramming language support\\n\\nThe following languages are\", \" all supported in general availability (GA).\\n\\nLanguage\\n\\nSupported runtimes for 4.x\\n\\nC#\\n\\n.NET 6.0, 7.\", \"0, .NET Framework 4.8\\n\\nJavaScript  Node 14, 16, 18\\n\\nF#\\n\\nJava\\n\\n.NET 6.0, 7.0\\n\\nJava 8, 11, 17\\n\\nPython\\n\", \"\\nPython 3.7, 3.8, 3.9, 3.10\\n\\nTypeScript  Node 14, 16, 18 (via JavaScript)\\n\\nPowerShell  PowerShell Co\", \"re 7.2\\n\\nFor more information on other runtime versions, see Supported languages.\\n\\nApp service plans\\n\", \"\\nFunctions are backed by an app service plan. The plan defines the resources used by the functions\\na\", \"pp. You can assign plans to a region, determine the size and number of virtual machines that will be\", \"\\nused, and pick a pricing tier. For a true serverless approach, function apps may use the consumptio\", \"n\\nplan. The consumption plan will scale the back end automatically based on load.\\n\\nAnother hosting o\", \"ption for function apps is the Premium plan. This plan provides an \\u201calways on\\u201d\\ninstance to avoid col\", \"d start, supports advanced features like VNet connectivity, and runs on premium\\nhardware.\\n\\nFor more \", \"information, see App service plans.\\n\\nCreate your first function\\n\\nThere are three common ways you can\", \" create function apps.\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n25\\n\\nScript functions in the portal.\\n\\nCreate the necessary resources\", \" using the Azure CLI.\\n\\nBuild functions locally using your favorite IDE and publish them to Azure.\\n\\nC\", \"HAPTER 3 | Azure serverless platform\\n\\n\\fFor more information on creating a scripted function in the p\", \"ortal, see Create your first function in the\\nAzure portal.\\n\\nTo build from the Azure CLI, see Create \", \"your first function using the Azure CLI.\\n\\nTo create a function from Visual Studio, see Create your f\", \"irst function using Visual Studio.\\n\\nUnderstand triggers and bindings\\n\\nFunctions are invoked by a tri\", \"gger and can have exactly one. In addition to invoking the function,\\ncertain triggers also serve as \", \"bindings. You may also define multiple bindings in addition to the\\ntrigger. Bindings provide a decla\", \"rative way to connect data to your code. They can be passed in (input)\\nor receive data (output). Tri\", \"ggers and bindings make functions easy to work with. Bindings remove the\\noverhead of manually creati\", \"ng database or file system connections. All of the information needed for\\nthe bindings is contained \", \"in a special functions.json file for scripts or declared with attributes in code.\\n\\nSome common trigg\", \"ers include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nBlob Storage: invoke your function when a file or folder is uploaded or ch\", \"anged in storage.\\n\\nHTTP: invoke your function like a REST API.\\n\\nQueue: invoke your function when ite\", \"ms exist in a queue.\\n\\nTimer: invoke your function on a regular cadence.\\n\\nExamples of bindings includ\", \"e:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nCosmosDB: easily connect to the database to load or save files.\\n\\nTable Storage: work wi\", \"th key/value storage from your function app.\\n\\nQueue Storage: easily retrieve items from a queue, or \", \"place new items on the queue.\\n\\nThe following example functions.json file defines a trigger and a bin\", \"ding:\\n\\n{\\n  \\\"bindings\\\": [\\n    {\\n      \\\"name\\\": \\\"myBlob\\\",\\n      \\\"type\\\": \\\"blobTrigger\\\",\\n      \\\"direction\", \"\\\": \\\"in\\\",\\n      \\\"path\\\": \\\"images/{name}\\\",\\n      \\\"connection\\\": \\\"AzureWebJobsStorage\\\"\\n    },\\n    {\\n     \", \" \\\"name\\\": \\\"$return\\\",\\n      \\\"type\\\": \\\"queue\\\",\\n      \\\"direction\\\": \\\"out\\\",\\n      \\\"queueName\\\": \\\"images\\\",\\n  \", \"    \\\"connection\\\": \\\"AzureWebJobsStorage\\\"\\n    }\\n  ],\\n  \\\"disabled\\\": false\\n}\\n\\nIn this example, the funct\", \"ion is triggered by a change to blob storage in the images container. The\\ninformation for the file i\", \"s passed in, so the trigger also acts as a binding. Another binding exists to put\\ninformation onto a\", \" queue named images.\\n\\n26\\n\\nCHAPTER 3 | Azure serverless platform\\n\\n\\fHere is the C# script for the func\", \"tion:\\n\\npublic static string Run(Stream myBlob, string name, TraceWriter log)\\n{\\n    log.Info($\\\"C# Blo\", \"b trigger function Processed blob\\\\n Name:{name} \\\\n Size:\\n{myBlob.Length} Bytes\\\");\\n    return name;\\n}\", \"\\n\\nThe example is a simple function that takes the name of the file that was modified or uploaded to\\n\", \"blob storage, and places it on a queue for later processing.\\n\\nFor a full list of triggers and bindin\", \"gs, see Azure Functions triggers and bindings concepts.\\n\\nTelemetry with Application Insights\\n\\nApplic\", \"ation Insights is a serverless diagnostics platform that enables developers to detect, triage, and\\nd\", \"iagnose issues in web apps, mobile apps, desktop apps, and microservices. You can turn on\\nApplicatio\", \"n Insights for function apps simply by flipping a switch in the portal. Application Insights\\nprovide\", \"s all of these capabilities without you having to configure a server or set up your own\\ndatabase. Al\", \"l of Application Insights\\u2019 capabilities are provided as a service that automatically\\nintegrates with\", \" your apps.\\n\\nAdding Application Insights to existing apps is as easy as adding an instrumentation ke\", \"y to your\\napplication\\u2019s settings. With Application Insights you can:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nCreate custom charts \", \"and alerts based on metrics such as number of function invocations, the\\ntime it takes to run a funct\", \"ion, and exceptions\\n\\nAnalyze failures and server exceptions\\n\\nDrill into performance by operation and\", \" measure the time it takes to call third-party\\ndependencies\\n\\n\\u2022  Monitor CPU usage, memory, and rates\", \" across all servers that host your function apps\\n\\n\\u2022\\n\\n\\u2022\\n\\n27\\n\\nView a live stream of metrics including \", \"request count and latency for your function apps\\n\\nUse Analytics to search, query, and create custom \", \"charts over your function data\\n\\nCHAPTER 3 | Azure serverless platform\\n\\n\\fIn addition to built-in tele\", \"metry, it\\u2019s also possible to generate custom telemetry. The following code\\nsnippet creates a custom \", \"telemetry client using the instrumentation key set for the function app:\\n\\npublic static TelemetryCli\", \"ent telemetry = new TelemetryClient()\\n{\\n    InstrumentationKey =\\nEnvironment.GetEnvironmentVariable(\", \"\\\"APPINSIGHTS_INSTRUMENTATIONKEY\\\")\\n};\\n\\nThe following code measures how long it takes to insert a new \", \"row into an Azure Table Storage\\ninstance:\\n\\nvar startTime = DateTime.UtcNow;\\nvar timer = System.Diagn\", \"ostics.Stopwatch.StartNew();\\nawait tableClient.AddEntityAsync(entry);\\ntelemetry.TrackDependency(\\\"Azu\", \"reTableStorageInsert\\\", \\\"Insert\\\", startTime, timer.Elapsed,\\ntrue);\\n\\nThe resulting performance graph i\", \"s shown:\\n\\n28\\n\\nCHAPTER 3 | Azure serverless platform\\n\\n\\fThe custom telemetry reveals the average time \", \"to insert a new row is 32.6 milliseconds.\\n\\nApplication Insights provides a powerful, convenient way \", \"to log detailed telemetry about your\\nserverless applications. You have full control over the level o\", \"f tracing and logging that is provided.\\nYou can track custom statistics such as events, dependencies\", \", and page view. Finally, the powerful\\nanalytics enable you to write queries that ask important ques\", \"tions and generate charts and advanced\\ninsights.\\n\\nFor more information, see Monitor Azure Functions.\", \"\\n\\nAzure Logic Apps\\n\\nAzure Logic Apps provides a serverless engine to build automated workflows to in\", \"tegrate apps and\\ndata between cloud services and on-premises systems. You build workflows using a vi\", \"sual designer.\\nYou can trigger workflows based on events or timers and leverage connectors to integr\", \"ation\\napplications and facilitate business-to-business (B2B) communication. Logic Apps integrates\\nse\", \"amlessly with Azure Functions.\\n\\nLogic Apps can do more than just connect your cloud services (like f\", \"unctions) with cloud resources\\n(like queues and databases). You can also orchestrate on-premises wor\", \"kflows with the on-premises\\ngateway. For example, you can use the Logic App to trigger an on-premise\", \"s SQL stored procedure in\\nresponse to a cloud-based event or conditional logic in your workflow. Lea\", \"rn more about Connecting\\nto on-premises data sources with Azure On-premises Data Gateway.\\n\\n29\\n\\nCHAPT\", \"ER 3 | Azure serverless platform\\n\\n\\fLike Azure Functions, you kick off Logic App workflows with a tri\", \"gger. There are many triggers for you\\nto choose from. The following capture shows just a few of the \", \"more popular ones out of hundreds\\nthat are available.\\n\\nOnce the app is triggered, you can use the vi\", \"sual designer to build out steps, loops, conditions, and\\nactions. Any data ingested in a previous st\", \"ep is available for you to use in subsequent steps. The\\nfollowing workflow loads URLs from a CosmosD\", \"B database. It finds the ones with a host of t.co then\\nsearches for them on Twitter. If it finds cor\", \"responding tweets, it updates the documents with the\\nrelated tweets by calling a function.\\n\\n30\\n\\nCHAP\", \"TER 3 | Azure serverless platform\\n\\n\\fThe Logic Apps dashboard shows the history of running your workf\", \"lows and whether each run\\ncompleted successfully or not. You can navigate into any given run and ins\", \"pect the data used by each\\nstep for troubleshooting. Logic Apps also provides existing templates you\", \" can edit and are well suited\\nfor complex enterprise workflows.\\n\\nTo learn more, see Azure Logic Apps\", \".\\n\\nEvent Grid\\n\\nAzure Event Grid provides serverless infrastructure for event-based applications. You\", \" can publish to\\nEvent Grid from any source and consume messages from any platform. Event Grid also h\", \"as built-in\\nsupport for events from Azure resources to streamline integration with your applications\", \". For example,\\nyou can subscribe to blob storage events to notify your app when a file is uploaded. \", \"Your application\\ncan then publish a custom event grid message that is consumed by other cloud or on-\", \"premises\\napplications. Event Grid was built to reliably handle massive scale. You get the benefits o\", \"f publishing\\nand subscribing to messages without the overhead of setting up the necessary infrastruc\", \"ture.\\n\\n31\\n\\nCHAPTER 3 | Azure serverless platform\\n\\n\\fThe major features of event grid include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\", \"\\u2022\\n\\nFully managed event routing.\\n\\nNear real-time event delivery at scale.\\n\\nBroad coverage both inside\", \" and outside of Azure.\\n\\nScenarios\\n\\nEvent Grid addresses several different scenarios. This section co\", \"vers three of the most common ones.\\n\\nOps automation\\n\\nEvent Grid can help speed automation and simpli\", \"fy policy enforcement by notifying Azure\\nAutomation when infrastructure is provisioned.\\n\\n32\\n\\nCHAPTER\", \" 3 | Azure serverless platform\\n\\n\\fApplication integration\\n\\nYou can use Event Grid to connect your app\", \" to other services. Using standard HTTP protocols, even\\nlegacy apps can be easily modified to publis\", \"h Event Grid messages. Web hooks are available for other\\nservices and platforms to consume Event Gri\", \"d messages.\\n\\nServerless apps\\n\\nEvent Grid can trigger Azure Functions, Logic Apps, or your own custom\", \" code. A major benefit of\\nusing Event Grid is that it uses a push mechanism to send messages when ev\", \"ents occur. The push\\narchitecture consumes fewer resources and scales better than polling mechanisms\", \". Polling must check\\nfor updates on a regular interval.\\n\\nEvent Grid vs. other Azure messaging servic\", \"es\\n\\nAzure provides several messaging services, including Event Hubs and Service Bus. Each is designe\", \"d to\\naddress a specific set of use cases. The following diagram provides a high-level overview of th\", \"e\\ndifferences between the services.\\n\\n33\\n\\nCHAPTER 3 | Azure serverless platform\\n\\n\\fFor a more in-depth\", \" comparison, see Compare messaging services.\\n\\nPerformance targets\\n\\nUsing Event Grid you can take adv\", \"antage of the following performance guarantees:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nSubsecond end-to-end latency i\", \"n the 99th percentile.\\n\\n99.99% availability.\\n\\n10 million events per second per region.\\n\\n100 million \", \"subscriptions per region.\\n\\n50-ms publisher latency.\\n\\n24-hour retry with exponential back-off for gua\", \"ranteed delivery in the 1-day window.\\n\\nTransparent regional failover.\\n\\nEvent Grid schema\\n\\nEvent Grid\", \" uses a standard schema to wrap custom events. The schema is like an envelope that wraps\\nyour custom\", \" data element. Here is an example Event Grid message:\\n\\n[{\\n    \\\"id\\\": \\\"03e24f21-a955-43cc-8921-1f61a60\", \"81ce0\\\",\\n    \\\"eventType\\\": \\\"myCustomEvent\\\",\\n    \\\"subject\\\": \\\"foo/bar/12\\\",\\n    \\\"eventTime\\\": \\\"2018-09-22T\", \"10:36:01+00:00\\\",\\n    \\\"data\\\": {\\n        \\\"favoriteColor\\\": \\\"blue\\\",\\n        \\\"favoriteAnimal\\\": \\\"panther\\\",\", \"\\n        \\\"favoritePlanet\\\": \\\"Jupiter\\\"\\n    },\\n    \\\"dataVersion\\\": \\\"1.0\\\"\\n}]\\n\\nEverything about the messag\", \"e is standard except the data property. You can inspect the message and\\nuse the eventType and dataVe\", \"rsion to de-serialize the custom portion of the payload.\\n\\n34\\n\\nCHAPTER 3 | Azure serverless platform\\n\", \"\\n\\fAzure resources\\n\\nA major benefit of using Event Grid is the automatic messages produced by Azure. \", \"In Azure, resources\\nautomatically publish to a topic that allows you to subscribe for various events\", \". The following table\\nlists the resource types, message types, and events that are available automat\", \"ically.\\n\\nAzure\\nresource\\n\\nAzure\\nsubscription\\n\\nEvent type\\n\\nDescription\\n\\nMicrosoft.Resources.ResourceWr\", \"iteSuccess\\n\\nMicrosoft.Resources.ResourceWriteFailure\\n\\nMicrosoft.Resources.ResourceWriteCancel\\n\\nRaise\", \"d when a resource create or\\nupdate operation succeeds.\\n\\nRaised when a resource create or\\nupdate oper\", \"ation fails.\\n\\nRaised when a resource create or\\nupdate operation is canceled.\\n\\nMicrosoft.Resources.Re\", \"sourceDeleteSuccess  Raised when a resource delete\\n\\nMicrosoft.Resources.ResourceDeleteFailure\\n\\nMicro\", \"soft.Resources.ResourceDeleteCancel\\n\\noperation succeeds.\\n\\nRaised when a resource delete\\noperation fa\", \"ils.\\n\\nRaised when a resource delete\\noperation is canceled. This event\\nhappens when a template deploy\", \"ment\\nis canceled.\\n\\nBlob storage  Microsoft.Storage.BlobCreated\\n\\nRaised when a blob is created.\\n\\nMicr\", \"osoft.Storage.BlobDeleted\\n\\nRaised when a blob is deleted.\\n\\nEvent hubs\\n\\nMicrosoft.EventHub.CaptureFil\", \"eCreated\\n\\nRaised when a capture file is created.\\n\\nIoT Hub\\n\\nMicrosoft.Devices.DeviceCreated\\n\\nMicrosof\", \"t.Devices.DeviceDeleted\\n\\nResource\\ngroups\\n\\nMicrosoft.Resources.ResourceWriteSuccess\\n\\nMicrosoft.Resour\", \"ces.ResourceWriteFailure\\n\\nMicrosoft.Resources.ResourceWriteCancel\\n\\nPublished when a device is regist\", \"ered\\nto an IoT hub.\\n\\nPublished when a device is deleted\\nfrom an IoT hub.\\n\\nRaised when a resource cre\", \"ate or\\nupdate operation succeeds.\\n\\nRaised when a resource create or\\nupdate operation fails.\\n\\nRaised \", \"when a resource create or\\nupdate operation is canceled.\\n\\nMicrosoft.Resources.ResourceDeleteSuccess  \", \"Raised when a resource delete\\n\\nMicrosoft.Resources.ResourceDeleteFailure\\n\\noperation succeeds.\\n\\nRaise\", \"d when a resource delete\\noperation fails.\\n\\n35\\n\\nCHAPTER 3 | Azure serverless platform\\n\\n\\fAzure\\nresourc\", \"e\\n\\nEvent type\\n\\nDescription\\n\\nMicrosoft.Resources.ResourceDeleteCancel\\n\\nRaised when a resource delete\\n\", \"operation is canceled. This event\\nhappens when a template deployment\\nis canceled.\\n\\nFor more informat\", \"ion, see Azure Event Grid event schema.\\n\\nYou can access Event Grid from any type of application, eve\", \"n one that runs on-premises.\\n\\nConclusion\\n\\nIn this chapter you learned about the Azure serverless pla\", \"tform that is composed of Azure Functions,\\nLogic Apps, and Event Grid. You can use these resources t\", \"o build an entirely serverless app\\narchitecture, or create a hybrid solution that interacts with oth\", \"er cloud resources and on-premises\\nservers. Combined with a serverless data platform such as Azure S\", \"QL or CosmosDB, you can build fully\\nmanaged cloud native applications.\\n\\nRecommended resources\\n\\n\\u2022\\n\\n\\u2022\\n\", \"\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nApp service plans\\n\\nApplication Insights\\n\\nApplication I\", \"nsights Analytics\\n\\nAzure: Bring your app to the cloud with serverless Azure Functions\\n\\nAzure Event G\", \"rid\\n\\nAzure Event Grid event schema\\n\\nAzure Event Hubs\\n\\nAzure Functions documentation\\n\\nAzure Functions\", \" triggers and bindings concepts\\n\\nAzure Logic Apps\\n\\nAzure Service Bus\\n\\nAzure Table Storage\\n\\nConnectin\", \"g to on-premises data sources with Azure On-premises Data Gateway\\n\\nCreate your first function in the\", \" Azure portal\\n\\nCreate your first function using the Azure CLI\\n\\nCreate your first function using Visu\", \"al Studio\\n\\nFunctions supported languages\\n\\n\\u2022  Monitor Azure Functions\\n\\n36\\n\\nCHAPTER 3 | Azure serverle\", \"ss platform\\n\\n\\fCHAPTER  4 CHAPTER  4\\n\\nDurable Azure Functions\\n\\nWhen creating serverless applications \", \"with Azure Functions, your operations will typically be designed\\nto run in a stateless manner. The r\", \"eason for this design choice is because as the platform scales, it\\nbecomes difficult to know what se\", \"rvers the code is running on. It also becomes difficult to know how\\nmany instances are active at any\", \" given point. However, there are classes of applications that require\\nthe current state of a process\", \" to be known. Consider the process of submitting an order to an online\\nstore. The checkout operation\", \" might be a workflow that is composed of multiple operations that need\\nto know the state of the proc\", \"ess. Such information may include the product inventory, if the customer\\nhas any credits on their ac\", \"count, and also the results of processing the credit card. These operations\\ncould easily be their ow\", \"n internal workflows or even services from third-party systems.\\n\\nVarious patterns exist today that a\", \"ssist with the coordination of application state between internal and\\nexternal systems. It\\u2019s common \", \"to come across solutions that rely on centralized queuing systems,\\ndistributed key-value stores, or \", \"shared databases to manage that state. However, these are all\\nadditional resources that now need to \", \"be provisioned and managed. In a serverless environment, your\\ncode could become cumbersome trying to\", \" coordinate with these resources manually. Azure Functions\\noffers an alternative for creating statef\", \"ul functions called Durable Functions.\\n\\nDurable Functions is an extension to the Azure Functions run\", \"time that enables the definition of\\nstateful workflows in code. By breaking down workflows into acti\", \"vities, the Durable Functions\\nextension can manage state, create progress checkpoints, and handle th\", \"e distribution of function calls\\nacross servers. In the background, it makes use of an Azure Storage\", \" account to persist execution\\nhistory, schedule activity functions and retrieve responses. Your serv\", \"erless code should never interact\\nwith persisted information in that storage account, and is typical\", \"ly not something with which\\ndevelopers need to interact.\\n\\nTriggering a stateful workflow\\n\\nStateful w\", \"orkflows in Durable Functions can be broken down into two intrinsic components;\\norchestration and ac\", \"tivity triggers. Triggers and bindings are core components used by Azure\\nFunctions to enable your se\", \"rverless functions to be notified when to start, receive input, and return\\nresults.\\n\\nWorking with th\", \"e Orchestration client\\n\\nOrchestrations are unique when compared to other styles of triggered operati\", \"ons in Azure Functions.\\nDurable Functions enables the execution of functions that may take hours or \", \"even days to complete.\\nThat type of behavior comes with the need to able to check the status of a ru\", \"nning orchestration,\\npreemptively terminate, or send notifications of external events.\\n\\n37\\n\\nCHAPTER \", \"4 | Durable Azure Functions\\n\\n\\fFor such cases, the Durable Functions extension provides the DurableOr\", \"chestrationClient class that\\nallows you to interact with orchestrated functions. You get access to t\", \"he orchestration client by using\\nthe OrchestrationClientAttribute binding. Generally, you would incl\", \"ude this attribute with another\\ntrigger type, such as an HttpTrigger or ServiceBusTrigger. Once the \", \"source function has been\\ntriggered, the orchestration client can be used to start an orchestrator fu\", \"nction.\\n\\n[FunctionName(\\\"KickOff\\\")]\\npublic static async Task<HttpResponseMessage> Run(\\n    [HttpTrigg\", \"er(AuthorizationLevel.Function, \\\"POST\\\")]HttpRequestMessage req,\\n    [OrchestrationClient ] DurableOr\", \"chestrationClient<orchestrationClient>)\\n{\\n    OrderRequestData data = await req.Content.ReadAsAsync<\", \"OrderRequestData>();\\n\\n    string instanceId = await orchestrationClient.StartNewAsync(\\\"PlaceOrder\\\", \", \"data);\\n\\n    return orchestrationClient.CreateCheckStatusResponse(req, instanceId);\\n}\\n\\nThe orchestrat\", \"or function\\n\\nAnnotating a function with the OrchestrationTriggerAttribute in Azure Functions marks t\", \"hat function\\nas an orchestrator function. It\\u2019s responsible for managing the various activities that \", \"make up your\\nstateful workflow.\\n\\nOrchestrator functions are unable to make use of bindings other tha\", \"n the\\nOrchestrationTriggerAttribute. This attribute can only be used with a parameter type of\\nDurabl\", \"eOrchestrationContext. No other inputs can be used since deserialization of inputs in the\\nfunction s\", \"ignature isn\\u2019t supported. To get inputs provided by the orchestration client, the\\nGetInput<T> method\", \" must be used.\\n\\nAlso, the return types of orchestration functions must be either void, Task, or a JS\", \"ON serializable\\nvalue.\\n\\nError handling code has been left out for brevity\\n\\n[FunctionName(\\\"PlaceOrder\", \"\\\")]\\npublic static async Task<string> PlaceOrder([OrchestrationTrigger]\\nDurableOrchestrationContext c\", \"ontext)\\n{\\n    OrderRequestData orderData = context.GetInput<OrderRequestData>();\\n\\n    await context.\", \"CallActivityAsync<bool>(\\\"CheckAndReserveInventory\\\", orderData);\\n    await context.CallActivityAsync<\", \"string>(\\\"ProcessPayment\\\", orderData);\\n\\n    string trackingNumber = await context.CallActivityAsync<s\", \"tring>(\\\"ScheduleShipping\\\",\\norderData);\\n    await context.CallActivityAsync<string>(\\\"EmailCustomer\\\", \", \"trackingNumber);\\n\\n    return trackingNumber;\\n}\\n\\nMultiple instances of an orchestration can be starte\", \"d and running at the same time. Calling the\\nStartNewAsync method on the DurableOrchestrationClient l\", \"aunches a new instance of the\\norchestration. The method returns a Task<string> that completes when t\", \"he orchestration has started.\\n\\n38\\n\\nCHAPTER 4 | Durable Azure Functions\\n\\n\\fAn exception of type Timeou\", \"tException gets thrown if the orchestration hasn\\u2019t started within 30\\nseconds.\\n\\nThe completed Task<st\", \"ring> from StartNewAsync should contain the unique ID of the orchestration\\ninstance. This instance I\", \"D can be used to invoke operations on that specific orchestration. The\\norchestration can be queried \", \"for the status or sent event notifications.\\n\\nThe activity functions\\n\\nActivity functions are the disc\", \"rete operations that get composed together within an orchestration\\nfunction to create the workflow. \", \"Here is where most of actual work would take place. They represent\\nthe business logic, long running \", \"processes, and the puzzle pieces to a larger solution.\\n\\nThe ActivityTriggerAttribute is used to anno\", \"tate a function parameter of type\\nDurableActivityContext. Using the annotation informs the runtime t\", \"hat the function is intended to\\nbe used as an activity function. Input values to activity functions \", \"are retrieved using the GetInput<T>\\nmethod of the DurableActivityContext parameter.\\n\\nSimilar to orch\", \"estration functions, the return types of activity functions must be either void, Task, or a\\nJSON ser\", \"ializable value.\\n\\nAny unhandled exceptions that get thrown within activity functions will get sent u\", \"p to the calling\\norchestrator function and presented as a TaskFailedException. At this point, the er\", \"ror can be caught\\nand logged in the orchestrator, and the activity can be retried.\\n\\n[FunctionName(\\\"C\", \"heckAndReserveInventory\\\")]\\npublic static bool CheckAndReserveInventory([ActivityTrigger] DurableActi\", \"vityContext\\ncontext)\\n{\\n    OrderRequestData orderData = context.GetInput<OrderRequestData>();\\n\\n    /\", \"/ Connect to inventory system and try to reserve items\\n    return true;\\n}\\n\\nRecommended resources\\n\\n\\u2022\\n\", \"\\n\\u2022\\n\\nDurable Functions\\n\\nBindings for Durable Functions\\n\\n\\u2022  Manage instances in Durable Functions\\n\\nOrc\", \"hestration patterns\\n\\nDurable Functions makes it easier to create stateful workflows that are compose\", \"d of discrete, long\\nrunning activities in a serverless environment. Since Durable Functions can trac\", \"k the progress of your\\nworkflows and periodically checkpoints the execution history, it lends itself\", \" to implementing some\\ninteresting patterns.\\n\\n39\\n\\nCHAPTER 4 | Durable Azure Functions\\n\\n\\fFunction chai\", \"ning\\n\\nIn a typical sequential process, activities need to execute one after the other in a particula\", \"r order.\\nOptionally, the upcoming activity may require some output from the previous function. This\\n\", \"dependency on the ordering of activities creates a function chain of execution.\\n\\nThe benefit of usin\", \"g Durable Functions to implement this workflow pattern comes from its ability to\\ndo checkpointing. I\", \"f the server crashes, the network times out or some other issue occurs, Durable\\nfunctions can resume\", \" from the last known state and continue running your workflow even if it\\u2019s on\\nanother server.\\n\\n[Func\", \"tionName(\\\"PlaceOrder\\\")]\\npublic static async Task<string> PlaceOrder([OrchestrationTrigger]\\nDurableOr\", \"chestrationContext context)\\n{\\n    OrderRequestData orderData = context.GetInput<OrderRequestData>();\", \"\\n\\n    await context.CallActivityAsync<bool>(\\\"CheckAndReserveInventory\\\", orderData);\\n    await contex\", \"t.CallActivityAsync<bool>(\\\"ProcessPayment\\\", orderData);\\n\\n    string trackingNumber = await context.C\", \"allActivityAsync<string>(\\\"ScheduleShipping\\\",\\norderData);\\n    await context.CallActivityAsync<string>\", \"(\\\"EmailCustomer\\\", trackingNumber);\\n\\n    return trackingNumber;\\n}\\n\\nIn the preceding code sample, the \", \"CallActivityAsync function is responsible for running a given\\nactivity on a virtual machine in the d\", \"ata center. When the await returns and the underlying Task\\ncompletes, the execution will be recorded\", \" to the history table. The code in the orchestrator function\\ncan make use of any of the familiar con\", \"structs of the Task Parallel Library and the async/await\\nkeywords.\\n\\nThe following code is a simplifi\", \"ed example of what the ProcessPayment method may look like:\\n\\n[FunctionName(\\\"ProcessPayment\\\")]\\npublic\", \" static bool ProcessPayment([ActivityTrigger] DurableActivityContext context)\\n{\\n    OrderRequestData\", \" orderData = context.GetInput<OrderRequestData>();\\n\\n    ApplyCoupons(orderData);\\n    if(IssuePayment\", \"Request(orderData)) {\\n        return true;\\n    }\\n\\n    return false;\\n}\\n\\nAsynchronous HTTP APIs\\n\\nIn so\", \"me cases, workflows may contain activities that take a relatively long period of time to complete.\\nI\", \"magine a process that kicks off the backup of media files into blob storage. Depending on the size\\na\", \"nd quantity of the media files, this backup process may take hours to complete.\\n\\n40\\n\\nCHAPTER 4 | Dur\", \"able Azure Functions\\n\\n\\fIn this scenario, the DurableOrchestrationClient\\u2019s ability to check the statu\", \"s of a running workflow\\nbecomes useful. When using an HttpTrigger to start a workflow, the CreateChe\", \"ckStatusResponse\\nmethod can be used to return an instance of HttpResponseMessage. This response prov\", \"ides the client\\nwith a URI in the payload that can be used to check the status of the running proces\", \"s.\\n\\n[FunctionName(\\\"OrderWorkflow\\\")]\\npublic static async Task<HttpResponseMessage> Run(\\n    [HttpTrig\", \"ger(AuthorizationLevel.Function, \\\"POST\\\")]HttpRequestMessage req,\\n    [OrchestrationClient ] DurableO\", \"rchestrationClient orchestrationClient)\\n{\\n    OrderRequestData data = await req.Content.ReadAsAsync<\", \"OrderRequestData>();\\n\\n    string instanceId = await orchestrationClient.StartNewAsync(\\\"PlaceOrder\\\", \", \"data);\\n\\n    return orchestrationClient.CreateCheckStatusResponse(req, instanceId);\\n}\\n\\nThe sample res\", \"ult below shows the structure of the response payload.\\n\\n{\\n    \\\"id\\\": \\\"instanceId\\\",\\n    \\\"statusQueryGe\", \"tUri\\\": \\\"http://host/statusUri\\\",\\n    \\\"sendEventPostUri\\\": \\\"http://host/eventUri\\\",\\n    \\\"terminatePostUr\", \"i\\\": \\\"http://host/terminateUri\\\"\\n}\\n\\nUsing your preferred HTTP client, GET requests can be made to the \", \"URI in statusQueryGetUri to\\ninspect the status of the running workflow. The returned status response\", \" should resemble the\\nfollowing code.\\n\\n{\\n    \\\"runtimeStatus\\\": \\\"Running\\\",\\n    \\\"input\\\": {\\n        \\\"$typ\", \"e\\\": \\\"DurableFunctionsDemos.OrderRequestData, DurableFunctionsDemos\\\"\\n    },\\n    \\\"output\\\": null,\\n    \\\"\", \"createdTime\\\": \\\"2018-01-01T00:22:05Z\\\",\\n    \\\"lastUpdatedTime\\\": \\\"2018-01-01T00:22:09Z\\\"\\n}\\n\\nAs the proces\", \"s continues, the status response will change to either Failed or Completed. On\\nsuccessful completion\", \", the output property in the payload will contain any returned data.\\n\\nMonitoring\\n\\nFor simple recurri\", \"ng tasks, Azure Functions provides the TimerTrigger that can be scheduled based\\non a CRON expression\", \". The timer works well for simple, short-lived tasks, but there might be scenarios\\nwhere more flexib\", \"le scheduling is needed. This scenario is when the monitoring pattern and Durable\\nFunctions can help\", \".\\n\\nDurable Functions allows for flexible scheduling intervals, lifetime management, and the creation\", \" of\\nmultiple monitor processes from a single orchestration function. One use case for this functiona\", \"lity\\nmight be to create watchers for stock price changes that complete once a certain threshold is m\", \"et.\\n\\n41\\n\\nCHAPTER 4 | Durable Azure Functions\\n\\n\\f[FunctionName(\\\"CheckStockPrice\\\")]\\npublic static async\", \" Task CheckStockPrice([OrchestrationTrigger] DurableOrchestrationContext\\ncontext)\\n{\\n    StockWatcher\", \"Info stockInfo = context.GetInput<StockWatcherInfo>();\\n    const int checkIntervalSeconds = 120;\\n   \", \" StockPrice initialStockPrice = null;\\n\\n    DateTime fireAt;\\n    DateTime exitTime = context.CurrentU\", \"tcDateTime.Add(stockInfo.TimeLimit);\\n\\n    while (context.CurrentUtcDateTime < exitTime)\\n    {\\n      \", \"  StockPrice currentStockPrice = await\\ncontext.CallActivityAsync<StockPrice>(\\\"GetStockPrice\\\", stockI\", \"nfo);\\n\\n        if (initialStockPrice == null)\\n        {\\n            initialStockPrice = currentStock\", \"Price;\\n            fireAt = context.CurrentUtcDateTime.AddSeconds(checkIntervalSeconds);\\n           \", \" await context.CreateTimer(fireAt, CancellationToken.None);\\n            continue;\\n        }\\n\\n       \", \" decimal percentageChange = (initialStockPrice.Price - currentStockPrice.Price) /\\n                  \", \"             ((initialStockPrice.Price + currentStockPrice.Price) / 2);\\n\\n        if (Math.Abs(percen\", \"tageChange) >= stockInfo.PercentageChange)\\n        {\\n            // Change threshold detected\\n      \", \"      await context.CallActivityAsync(\\\"NotifyStockPercentageChange\\\",\\ncurrentStockPrice);\\n           \", \" break;\\n        }\\n\\n        // Sleep til next polling interval\\n        fireAt = context.CurrentUtcDat\", \"eTime.AddSeconds(checkIntervalSeconds);\\n        await context.CreateTimer(fireAt, CancellationToken.\", \"None);\\n    }\\n}\\n\\nDurableOrchestrationContext\\u2019s CreateTimer method sets up the schedule for the next i\", \"nvocation\\nof the loop to check for stock price changes. DurableOrchestrationContext also has a\\nCurre\", \"ntUtcDateTime property to get the current DateTime value in UTC. It\\u2019s better to use this\\nproperty in\", \"stead of DateTime.UtcNow because it\\u2019s easily mocked for testing.\\n\\nRecommended resources\\n\\nAzure Durab\", \"le Functions\\n\\nUnit Testing in .NET Core and .NET Standard\\n\\n\\u2022\\n\\n\\u2022\\n\\n42\\n\\nCHAPTER 4 | Durable Azure Funct\", \"ions\\n\\n\\fCHAPTER  5 CHAPTER  5\\n\\nServerless business\\nscenarios and use cases\\n\\nThere are many use cases \", \"and scenarios for serverless applications. This chapter includes samples that\\nillustrate the differe\", \"nt scenarios. The scenarios include links to related documentation and public\\nsource code repositori\", \"es. The samples in this chapter enable you to get started on your own building\\nand implementing serv\", \"erless solutions.\\n\\nBig data processing\\n\\nThis example uses serverless to do a map/reduce operation on\", \" a big data set. It determines the\\naverage speed of New York Yellow taxi trips per day in 2017.\\n\\nBig\", \" Data Processing: Serverless MapReduce on Azure\\n\\nCreate serverless applications: hands-on lab\\n\\nLearn\", \" how to use functions to execute server-side logic and build serverless architectures.\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\", \"\\u2022\\n\\nChoosing the best Azure service for your business\\n\\nCreating Azure Functions\\n\\nUsing triggers\\n\\nChai\", \"ning functions\\n\\nLong-running workflows\\n\\n\\u2022  Monitoring\\n\\n\\u2022\\n\\nDevelopment, testing, and deployment\\n\\nCrea\", \"te serverless applications\\n\\nCustomer reviews\\n\\nThis sample showcases the new Azure Functions tooling \", \"for C# Class Libraries in Visual Studio. Create\\na website where customers submit product reviews tha\", \"t are stored in Azure storage blobs and\\n\\n43\\n\\nCHAPTER 5 | Serverless business scenarios and use cases\", \"\\n\\n\\fCosmosDB. Add an Azure Function to perform automated moderation of the customer reviews using\\nAzu\", \"re Cognitive Services. Use an Azure storage queue to decouple the website from the function.\\n\\nCustom\", \"er Reviews App with Cognitive Services\\n\\nFile processing and validation\\n\\nThis example parses a set of\", \" CSV files from hypothetical customers. It ensures that all files required for\\na customer \\u201cbatch\\u201d ar\", \"e ready, then validates the structure of each file. Different solutions are\\npresented using Azure Fu\", \"nctions, Logic Apps, and Durable Functions.\\n\\nFile processing and validation using Azure Functions, L\", \"ogic Apps, and Durable Functions\\n\\nGame data visualization\\n\\nAn example of how a developer could imple\", \"ment an in-editor data visualization solution for their\\ngame. In fact, an Unreal Engine 4 Plugin and\", \" Unity Plugin were developed using this sample as its\\nbackend. The service component is game engine \", \"agnostic.\\n\\nIn-editor game telemetry visualization\\n\\nGraphQL\\n\\nCreate a serverless function that expose\", \"s a GraphQL API.\\n\\nServerless functions for GraphQL\\n\\nInternet of Things (IoT) reliable edge relay\\n\\nTh\", \"is sample implements a new communication protocol to enable reliable upstream communication\\nfrom IoT\", \" devices. It automates data gap detection and backfill.\\n\\nIoT Reliable Edge Relay\\n\\nMicroservices refe\", \"rence architecture\\n\\nA reference architecture that walks you through the decision-making process invo\", \"lved in designing,\\ndeveloping, and delivering the Rideshare by Relecloud application (a fictitious c\", \"ompany). It includes\\nhands-on instructions for configuring and deploying all of the architecture\\u2019s c\", \"omponents.\\n\\n44\\n\\nCHAPTER 5 | Serverless business scenarios and use cases\\n\\n\\fServerless Microservices r\", \"eference architecture\\n\\nServerless for mobile\\n\\nAzure Functions are easy to implement and maintain, an\", \"d accessible through HTTP. They are a great\\nway to implement an API for a mobile application. Micros\", \"oft offers great cross-platform tools for iOS,\\nAndroid, and Windows with Xamarin. As such, Xamarin a\", \"nd Azure Functions are working great\\ntogether. This article shows how to implement an Azure Function\", \" in the Azure portal or in Visual\\nStudio at first, and build a cross-platform client with Xamarin.Fo\", \"rms running on Android, iOS, and\\nWindows.\\n\\nImplementing a simple Azure Function with a Xamarin.Forms\", \" client\\n\\nServerless messaging\\n\\nThis sample shows how to utilize Durable Functions\\u2019 fan-out pattern t\", \"o load an arbitrary number of\\nmessages across any number of sessions/partitions. It targets Service \", \"Bus, Event Hubs, or Storage\\nQueues. The sample also adds the ability to consume those messages with \", \"another Azure Function\\nand load the resulting timing data in to another Event Hub. The data is then \", \"ingested into analytics\\nservices like Azure Data Explorer.\\n\\nProduce and Consume messages through Ser\", \"vice Bus, Event Hubs, and Storage Queues with Azure\\nFunctions\\n\\nRecommended resources\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\", \"\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nBig Data Processing: Serverless MapReduce on Azure\\n\\nCreate serverless applications\\n\\n\", \"Customer Reviews App with Cognitive Services\\n\\nFile processing and validation using Azure Functions, \", \"Logic Apps, and Durable Functions\\n\\nImplementing a simple Azure Function with a Xamarin.Forms client\\n\", \"\\nIn-editor game telemetry visualization\\n\\nIoT Reliable Edge Relay\\n\\nProduce and Consume messages throu\", \"gh Service Bus, Event Hubs, and Storage Queues with\\nAzure Functions\\n\\nServerless functions for GraphQ\", \"L\\n\\nServerless Microservices reference architecture\\n\\n45\\n\\nCHAPTER 5 | Serverless business scenarios an\", \"d use cases\\n\\n\\fCHAPTER  6 CHAPTER  6\\n\\nConclusion\\n\\nThe following key takeaways are the most important \", \"conclusions from this guide.\\n\\nBenefits of using serverless. Serverless solutions provide the importa\", \"nt benefit of cost savings\\nbecause serverless is implemented in a pay-per-use model. Serverless make\", \"s it possible to\\nindependently scale, test, and deploy individual components of your application. Se\", \"rverless is uniquely\\nsuited to implement microservices architectures and integrates fully into a Dev\", \"Ops pipeline.\\n\\nCode as a unit of deployment. Serverless abstracts the hardware, OS, and runtime away\", \" from the\\napplication. Serverless enables focusing on business logic in code as the unit of deployme\", \"nt.\\n\\nTriggers and bindings. Serverless eases integration with storage, APIs, and other cloud resourc\", \"es.\\nAzure Functions provides triggers to execute code and bindings to interact with resources.\\n\\nMicr\", \"oservices. The microservices architecture is becoming the preferred approach for distributed and\\nlar\", \"ge or complex mission-critical applications that are based on multiple independent subsystems in\\nthe\", \" form of autonomous services. In a microservice-based architecture, the application is built as a\\nco\", \"llection of services that can be developed, tested, versioned, deployed, and scaled independently.\\nS\", \"erverless is an architecture well-suited for building these services.\\n\\nServerless platforms. Serverl\", \"ess isn\\u2019t just about the code. Platforms that support serverless\\narchitectures include serverless wo\", \"rkflows and orchestration, serverless messaging and event services,\\nand serverless databases.\\n\\nServe\", \"rless challenges. Serverless introduces challenges related to distributed application\\ndevelopment, s\", \"uch as fragmented and independent data models, resiliency, versioning, and service\\ndiscovery. Server\", \"less may not be ideally suited to long running processes or components that benefit\\nfrom tighter cou\", \"pling.\\n\\nServerless as a tool, not the toolbox. Serverless is not the exclusive solution to applicati\", \"on\\narchitecture. It is a tool that can be leveraged as part of a hybrid application that may contain\", \"\\ntraditional tiers, monolith back ends, and containers. Serverless can be used to enhance existing\\ns\", \"olutions and is not an all-or-nothing approach to application development.\\n\\n46\\n\\nCHAPTER 6 | Conclusi\", \"on\\n\\n\"]"