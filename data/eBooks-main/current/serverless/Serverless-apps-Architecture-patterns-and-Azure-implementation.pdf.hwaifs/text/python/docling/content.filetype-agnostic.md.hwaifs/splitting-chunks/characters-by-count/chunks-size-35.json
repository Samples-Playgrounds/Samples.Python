"[\"<!-- image -->\\n\\nServerless apps: Architecture, patterns, and Azure implementation\\n\\n<!-- image -->\\n\\nJ\", \"eremy Likness Cecil Phillip\\n\\nEDITION v4.0 -Updated to Azure Functions v4\\n\\nDOWNLOAD available at: htt\", \"ps://aka.ms/serverlessbookpdf\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Visual Studio p\", \"roduct teams\\n\\nA division of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington 98052-6399\", \"\\n\\nCopyright \\u00a9 2018-2023 by Microsoft Corporation\\n\\nAll rights reserved. No part of the contents of th\", \"is book may be reproduced or transmitted in any form or by any means without the written permission \", \"of the publisher.\\n\\nThis book is provided \\\"as-is\\\" and expresses the author's views and opinions. The \", \"views, opinions and information expressed in this book, including URL and other Internet website ref\", \"erences, may change without notice.\\n\\nSome examples depicted herein are provided for illustration onl\", \"y and are fictitious. No real association or connection is intended or should be inferred.\\n\\nMicrosof\", \"t and the trademarks listed at https://www.microsoft.com on the \\\"Trademarks\\\" webpage are trademarks \", \"of the Microsoft group of companies.\\n\\nMac and macOS are trademarks of Apple Inc.\\n\\nAll other marks an\", \"d logos are property of their respective owners.\\n\\nAuthor:\\n\\nJeremy Likness, Senior .NET Data Program \", \"Manager, Microsoft Corp.\\n\\nContributor:\\n\\nCecil Phillip, Senior Cloud Advocate, Microsoft Corp.\\n\\nEdito\", \"rs:\\n\\nBill Wagner, Senior Content Developer, Microsoft Corp.\\n\\nMaira Wenzel, Senior Content Developer,\", \" Microsoft Corp.\\n\\nParticipants and reviewers:\\n\\nSteve Smith, Architect/Trainer, NimblePros.\\n\\n## Intro\", \"duction\\n\\nServerless is the evolution of cloud platforms in the direction of pure cloud native code. \", \"Serverless brings developers closer to business logic while insulating them from infrastructure conc\", \"erns. It's a pattern that doesn't imply \\\"no server\\\" but rather, \\\"less server.\\\" Serverless code is ev\", \"ent-driven. Code\\n\\n<!-- image -->\\n\\nMicrosoft\\n\\n<!-- image -->\\n\\nmay be triggered by anything from a tra\", \"ditional HTTP web request to a timer or the result of uploading a file. The infrastructure behind se\", \"rverless allows for instant scale to meet elastic demands and offers micro -billing to truly \\\"pay fo\", \"r what you use.\\\" Serverless requires a new way of thinking and approach to building applications and\", \" isn't the right solution for every problem. As a developer, you must decide:\\n\\n- What are the pros a\", \"nd cons of serverless?\\n- Why should you consider serverless for your own applications?\\n- How can you\", \" build, test, deploy, and maintain your serverless code?\\n- Where does it make sense to migrate code \", \"to serverless in existing applications, and what is the best way to accomplish this transformation?\\n\", \"\\n## About this guide\\n\\nThis guide focuses on cloud native development of applications that use server\", \"less. The book highlights the benefits and exposes the potential drawbacks of developing serverless \", \"apps and provides a survey of serverless architectures. Many examples of how serverless can be used \", \"are illustrated along with various serverless design patterns.\\n\\nThis guide explains the components o\", \"f the Azure serverless platform and focuses specifically on implementation of serverless using Azure\", \" Functions. You'll learn about triggers and bindings as well as how to implement serverless apps tha\", \"t rely on state using durable functions. Finally, business examples and case studies will help provi\", \"de context and a frame of reference to determine whether serverless is the right approach for your p\", \"rojects.\\n\\n## Evolution of cloud platforms\\n\\nServerless is the culmination of several iterations of cl\", \"oud platforms. The evolution began with physical metal in the data center and progressed through Inf\", \"rastructure as a Service (IaaS) and Platform as a Service (PaaS).\\n\\n<!-- image -->\\n\\nBefore the cloud,\", \" a discernible boundary existed between development and operations. Deploying an application meant a\", \"nswering myriad questions like:\\n\\n- What hardware should be installed?\\n- How is physical access to th\", \"e machine secured?\\n- Does the data center require an Uninterruptible Power Supply (UPS)?\\n- Where are\", \" storage backups sent?\\n- Should there be redundant power?\\n\\nThe list goes on and the overhead was eno\", \"rmous. In many situations, IT departments were forced to deal with incredible waste. The waste was d\", \"ue to over -allocation of servers as backup machines for disaster recovery and standby servers to en\", \"able scale-out. Fortunately, the introduction of virtualization technology (like Hyper-V) with Virtu\", \"al Machines (VMs) gave rise to Infrastructure as a Service (IaaS). Virtualized infrastructure allowe\", \"d operations to set up a standard set of servers as the backbone, leading to a flexible environment \", \"capable of provisioning unique servers \\\"on demand.\\\" More important, virtualization set the stage for\", \" using the cloud to provide virtual machines \\\"as a service.\\\" Companies could easily get out of the b\", \"usiness of worrying about redundant power or physical machines. Instead, they focused on the virtual\", \" environment.\\n\\nIaaS still requires heavy overhead because operations is still responsible for variou\", \"s tasks. These tasks include:\\n\\n- Patching and backing up servers.\\n- Installing packages.\\n- Keeping t\", \"he operating system up-to-date.\\n- Monitoring the application.\\n\\nThe next evolution reduced the overhe\", \"ad by providing Platform as a Service (PaaS). With PaaS, the cloud provider handles operating system\", \"s, security patches, and even the required packages to support a specific platform. Instead of build\", \"ing a VM then configuring .NET and standing up Internet Information Services (IIS) servers, develope\", \"rs simply choose a \\\"platform target\\\" such as \\\"web application\\\" or \\\"API endpoint\\\" and deploy code dir\", \"ectly. The infrastructure questions are reduced to:\\n\\n- What size services are needed?\\n- How do the s\", \"ervices scale out (add more servers or nodes)?\\n- How do the services scale up (increase the capacity\", \" of hosting servers or nodes)?\\n\\nServerless further abstracts servers by focusing on event-driven cod\", \"e. Instead of a platform, developers can focus on a microservice that does one thing. The two key qu\", \"estions for building the serverless code are:\\n\\n- What triggers the code?\\n- What does the code do?\\n\\nW\", \"ith serverless, infrastructure is abstracted. In some cases, the developer no longer worries about t\", \"he host at all. Whether or not an instance of IIS, Kestrel, Apache, or some other web server is runn\", \"ing to manage web requests, the developer focuses on an HTTP trigger. The trigger provides the stand\", \"ard, cross-platform payload for the request. The payload not only simplifies the development process\", \", but facilitates testing and in some cases, makes the code easily portable across platforms.\\n\\nAnoth\", \"er feature of serverless is micro -billing. It's common for web applications to host Web API endpoin\", \"ts. In traditional bare metal, IaaS and even PaaS implementations, the resources to host the APIs ar\", \"e paid for continuously. That means you pay to host the endpoints even when they aren't being access\", \"ed. Often you'll find one API is called more than others, so the entire system is scaled\\n\\n<!-- image\", \" -->\\n\\n<!-- image -->\\n\\nbased on supporting the popular endpoints. Serverless enables you to scale eac\", \"h endpoint independently and pay for usage, so no costs are incurred when the APIs aren't being call\", \"ed. Migration may in many circumstances dramatically reduce the ongoing cost to support the endpoint\", \"s.\\n\\n## What this guide doesn\\u2019t cover\\n\\nThis guide specifically emphasizes architecture approaches and\", \" design patterns and isn't a deep dive into the implementation details of Azure Functions, Logic App\", \"s, or other serverless platforms. This guide doesn't cover, for example, advanced workflows with Log\", \"ic Apps or features of Azure Functions such as configuring Cross-Origin Resource Sharing (CORS), app\", \"lying custom domains, or uploading SSL certificates. These details are available through the online \", \"Azure Functions documentation .\\n\\n## Additional resources\\n\\n- Azure Architecture center\\n- Best practic\", \"es for cloud applications\\n\\n## Who should use the guide\\n\\nThis guide was written for developers and so\", \"lution architects who want to build enterprise applications with .NET that may use serverless compon\", \"ents either on premises or in the cloud. It's useful to developers, architects, and technical decisi\", \"on makers interested in:\\n\\n- Understanding the pros and cons of serverless development\\n- Learning how\", \" to approach serverless architecture\\n- Example implementations of serverless apps\\n\\n## How to use the\", \" guide\\n\\nThe first part of this guide examines why serverless is a viable option by comparing several\", \" different architecture approaches. It examines both the technology and development lifecycle, becau\", \"se all aspects of software development are impacted by architecture decisions. The guide then examin\", \"es use cases and design patterns and includes reference implementations using Azure Functions. Each \", \"section contains additional resources to learn more about a particular area. The guide concludes wit\", \"h resources for walkthroughs and hands-on exploration of serverless implementation.\\n\\n## Send your fe\", \"edback\\n\\nThe guide and related samples are constantly evolving, so your feedback is welcomed! If you \", \"have comments about how this guide can be improved, use the feedback section at the bottom of any pa\", \"ge built on GitHub issues .\\n\\n## Contents\\n\\n| Architecture approaches ................................\", \"................................ ................................................................   \", \"                              | .......  1                                                          \", \"                    |\\n|-----------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"----------|-----------------------------------------------------------------------------------------\", \"|\\n| Architecture patterns ................................ ................................ ........\", \"........................................................ ..............................   | 1       \", \"                                                                                |\\n| Monoliths  .....\", \"........................... ................................................................ .......\", \".........................................................             | .................... 1      \", \"                                                            |\\n| N - Layer applications .............\", \"................... ................................................................ ...............\", \"................. ............................... | 2                                               \", \"                                        |\\n| Microservices  ................................ ........\", \"........................................................                                            \", \"                              | ................................................................ ...\", \".......... 3        |\\n| Architecture deployment approaches  ................................ .......\", \"......................................................... .............................             \", \"          | 4                                                                                       \", \"|\\n| N - Tier applications  ................................ ................................ .......\", \"......................................................... .............................   | 5       \", \"                                                                                |\\n| On - premises an\", \"d Infrastructure as a Service (IaaS) ................................ ..............................\", \".. ...............................                                    | 6                           \", \"                                                            |\\n| Platform as a Service (PaaS) .......\", \"......................................................... ..........................................\", \"......................                            | ............ 7                                  \", \"                                        |\\n| Software as a Service (SaaS)  ..........................\", \"...................................... .............................................................\", \"...                           | ........... 7                                                       \", \"                    |\\n| Containers and Functions as a Service (FaaS) ...............................\", \". ................................................................                                  \", \"          | .......... 8                                                                            \", \"|\\n| Serverless ................................ ....................................................\", \"............                                                                              | ........\", \"........................................................ ................ 9     |\\n| Summary ........\", \"........................ ................................................................ ..........\", \"......................................................                | ..............  10          \", \"                                                            |\\n| Recommended resources  .............\", \"................................................... ................................................\", \"................                                  | .............  11                               \", \"                                        |\\n| Serverless architecture ................................\", \" ................................ ................................................................  \", \"                              | ......... 12                                                        \", \"                    |\\n| Full serverless back end ...................................................\", \"............. ................................................................                      \", \"          | ......................  13                                                              \", \"|\\n| Monoliths and \\u201cstarving the beast\\u201d .............................................................\", \"... ................................ ...............................                      | 13      \", \"                                                                                |\\n| Web apps  ......\", \".......................... ................................................................ ........\", \"........................................................              | .................  14       \", \"                                                            |\\n| Mobile back ends ...................\", \"............. ................................................................ .....................\", \"...........................................       | ..  14                                          \", \"                                        |\\n| Internet of Things (IoT) ...............................\", \"................................. ................................................................ .\", \"......................        | 15                                                                  \", \"                    |\\n| Serverless architecture considerations  ................................ ...\", \"............................................................. .........................             \", \"          | 16                                                                                      \", \"|\\n| Managing state  ................................ ...............................................\", \"................. ................................................................        | .  16   \", \"                                                                                |\\n| Long - running p\", \"rocesses ................................................................ ..........................\", \"...................................... ................               | 16                          \", \"                                                            |\\n| Startup time .......................\", \"......... ................................................................ .........................\", \".......................................           | ........  17                                    \", \"                                        |\\n| Database updates and migrations  .......................\", \"......................................... ................................ .........................\", \"...                           | 17                                                                  \", \"                    |\\n| Scaling  ................................ ..................................\", \"..............................                                                                      \", \"          | ................................................................ ..................  17 \", \"|\\n| Monitoring, tracing, and logging ...............................................................\", \". ................................                                                        | ........\", \".......................  18                                                     |\\n| Inter - service \", \"dependencies  ................................................................                      \", \"                                                                      | ............................\", \".................................... ..........  18         |\\n\\n| Managing failure and providing resi\", \"liency  ................................ ...........................................................\", \".....                                                    | ............  18         |\\n|-------------\", \"----------------------------------------------------------------------------------------------------\", \"--------------------------------------------------------------------------------|-------------------\", \"-------|\\n| Versioning and green/blue deployments ................................ ..................\", \".............................................. ...............                                      \", \"   | 19                       |\\n| Serverless design examples  ......................................\", \".......................... ................................................................ ........\", \"......                    | 19                       |\\n| Scheduling  ...............................\", \". ................................................................ .................................\", \"............................... ..........       | 19                       |\\n| Command and Query Re\", \"sponsibility Segregation (CQRS) ................................................................ ...\", \"...........                                                             | 19                       |\", \"\\n| Event - based processing  ................................................................ ......\", \".......................................................... ................                    | 20 \", \"                      |\\n| File triggers and transformations ........................................\", \"........................ ................................ ...............................           \", \"                  | 20                       |\\n| Asynchronous background processing and messaging ..\", \".............................................................. ...................                  \", \"                                         | 21                       |\\n| Web apps and APIs  .........\", \"....................... ................................ ...........................................\", \"..................... .........................                 | 21                       |\\n| Data \", \"pipeline ................................ ..........................................................\", \"...... ................................................................                | ......  22 \", \"              |\\n| Stream processing  ................................ ..............................\", \".. ................................................................ ...........................     \", \"          | 22                       |\\n| API gateway ................................ ..............\", \".................................................. .................................................\", \"...............                  | ........  23             |\\n| Recommended resources  .............\", \"................................................... ................................................\", \"................ .............                          | 23                       |\\n| Azure serverl\", \"ess platform ................................................................ ......................\", \"..........................................                                     | ... 24             \", \"      |\\n| Azure Functions  ................................ ........................................\", \"........................ ................................................................           \", \"  | .....  24                |\\n| Programming language support  .....................................\", \"........................... ................................ ...............................        \", \"                         | 25                       |\\n| App service plans  .........................\", \"....... ................................................................ ...........................\", \"..... .............................             | 25                       |\\n| Create your first fun\", \"ction  ................................................................ ............................\", \".................................... ..............                    | 25                       |\\n\", \"| Understand triggers and bindings  ................................................................\", \" ................................ ............................                                | 26  \", \"                     |\\n| Telemetry with Application Insights  ......................................\", \".......................... ................................ ..............................          \", \"                 | 27                       |\\n| Azure Logic Apps  ................................ .\", \"............................................................... ....................................\", \"............................            | ..  29                   |\\n| Event Grid ..................\", \".............. ................................................................ ....................\", \"............................................ ................. | 31                       |\\n| Scenar\", \"ios ................................ ...............................................................\", \". ................................................................ ..............     | 32          \", \"             |\\n| Event Grid vs. other Azure messaging services  ................................ ...\", \".............................................................                                       \", \"         | ....  33                 |\\n| Performance targets ................................ .......\", \"......................... ................................................................ .........\", \"...............                 | 34                       |\\n| Event Grid schema  ..................\", \".............. ................................ ....................................................\", \"............ ...........................               | 34                       |\\n| Azure resource\", \"s  ................................ ................................................................\", \" ................................ ................................            | 35                  \", \"     |\\n| Conclusion  ................................ ..............................................\", \".................. ................................................................                 \", \" | ..........  36           |\\n| Recommended resources  .............................................\", \"................... ................................................................ .............  \", \"                        | 36                       |\\n| Durable Azure Functions  ....................\", \"............................................ .......................................................\", \".........                                      | .... 37                  |\\n| Triggering a stateful \", \"workflow ................................................................ ..........................\", \"......................................                                | .........  37            |\\n|\", \" Working with the Orchestration client  ................................ ...........................\", \".....................................                                                        | .....\", \"...............  37 |\\n\\n| The orchestrator function  ................................................\", \"................ ................................................................ .............     \", \"                 | 38                                                                  |\\n|----------\", \"----------------------------------------------------------------------------------------------------\", \"-----------------------------------------------------------------------------------|----------------\", \"-----------------------------------------------------|\\n| The activity functions ....................\", \"............................................ .......................................................\", \"......... ......................                 | 39                                               \", \"                   |\\n| Recommended resources  ......................................................\", \".......... ................................................................ ..................      \", \"               | 39                                                                  |\\n| Orchestrati\", \"on patterns ................................ ................................ ......................\", \".......................................... ........................              | 39               \", \"                                                   |\\n| Function chaining ...........................\", \"..... ................................................................ .............................\", \"... .............................              | 40                                                 \", \"                 |\\n| Asynchronous HTTP APIs  .......................................................\", \"......... ................................................................ ..............           \", \"             | 40                                                                  |\\n| Monitoring ..\", \".............................. ................................................................ ....\", \"............................................................ ..........        | 41                 \", \"                                                 |\\n| Recommended resources  ........................\", \"........................................ ...........................................................\", \"..... .............                          | 42                                                   \", \"               |\\n| Serverless business scenarios and use cases  ................................ ...\", \"...........................................................                                         \", \"           | 43                                                                  |\\n| Big data proces\", \"sing ................................ ..............................................................\", \".. ................................ ..............................           | 43                   \", \"                                               |\\n| Create serverless applications: hands-on lab  ...\", \"............................. ................................................................      \", \"                                           | ............  43                                       \", \"             |\\n| Customer reviews ................................ .................................\", \"............................... ................................................................    \", \"         | ..  43                                                              |\\n| File processing a\", \"nd validation  ................................................................ ....................\", \"............................................                               | .........  44          \", \"                                             |\\n| Game data visualization  ..........................\", \"...................................... .............................................................\", \"... .....................                | 44                                                       \", \"           |\\n| GraphQL  ................................ ...........................................\", \"..................... ................................................................ .............\", \"...... | 44                                                                  |\\n| Internet of Things \", \"(IoT) reliable edge relay  ................................ ........................................\", \"........................ ................                                | 44                       \", \"                                           |\\n| Microservices reference architecture  ...............\", \"................................................. ................................ .................\", \"...........                            | 44                                                         \", \"         |\\n| Serverless for mobile ................................ ................................\", \" ................................................................ ...........................       \", \"     | 45                                                                  |\\n| Serverless messaging \", \" ................................ ................................ .................................\", \"............................... ..........................             | 45                         \", \"                                         |\\n| Recommended resources  ................................\", \"................................ ................................................................ ..\", \"................                     | 45                                                           \", \"       |\\n| Conclusion ................................ .............................................\", \"...................                                                                                 \", \"   | ................................................................ 46 |\\n\\n## Architecture approach\", \"es\\n\\nUnderstanding existing approaches to architecting enterprise apps helps clarify the role played \", \"by serverless. There are many approaches and patterns that evolved over decades of software developm\", \"ent, and all have their own pros and cons. In many cases, the ultimate solution may not involve deci\", \"ding on a single approach but may integrate several approaches. Migration scenarios often involve sh\", \"ifting from one architecture approach to another through a hybrid approach.\\n\\nThis chapter provides a\", \"n overview of both logical and physical architecture patterns for enterprise applications.\\n\\n## Archi\", \"tecture patterns\\n\\nModern business applications follow a variety of architecture patterns. This secti\", \"on represents a survey of common patterns. The patterns listed here aren't necessarily all best prac\", \"tices, but illustrate different approaches.\\n\\nFor more information, see Azure application architectur\", \"e guide .\\n\\n## Monoliths\\n\\nMany business applications follow a monolith pattern. Legacy applications a\", \"re often implemented as monoliths. In the monolith pattern, all application concerns are contained i\", \"n a single deployment. Everything from user interface to database calls is included in the same code\", \"base.\\n\\n<!-- image -->\\n\\nThere are several advantages to the monolith approach. It's often easy to pul\", \"l down a single code base and start working. Ramp up time may be less, and creating test environment\", \"s is as simple as providing a new copy. The monolith may be designed to include multiple components \", \"and applications.\\n\\nUnfortunately, the monolith pattern tends to break down at scale. Major disadvant\", \"ages of the monolith approach include:\\n\\n- Difficult to work in parallel in the same code base.\\n- Any\", \" change, no matter how trivial, requires deploying a new version of the entire application.\\n- Refact\", \"oring potentially impacts the entire application.\\n- Often the only solution to scale is to create mu\", \"ltiple, resource-intensive copies of the monolith.\\n- As systems expand or other systems are acquired\", \", integration can be difficult.\\n- It may be difficult to test due to the need to configure the entir\", \"e monolith.\\n- Code reuse is challenging and often other apps end up having their own copies of code.\", \"\\n\\nMany businesses look to the cloud as an opportunity to migrate monolith applications and at the sa\", \"me time refactor them to more usable patterns. It's common to break out the individual applications \", \"and components to allow them to be maintained, deployed, and scaled separately.\\n\\n## N -Layer applica\", \"tions\\n\\nN -layer application partition application logic into specific layers. The most common layers\", \" include:\\n\\n- User interface\\n- Business logic\\n- Data access\\n\\nUl Layer\\n\\n\\u2022 Web Pages\\n\\n\\u2022 Mobile App\\n\\nOth\", \"er layers may include middleware, batch processing, and API. It's important to note the layers are l\", \"ogical. Although they're developed in isolation, they may all be deployed to the same target platfor\", \"m.\\n\\n<!-- image -->\\n\\nThere are several advantages to the N-Layer approach, including:\\n\\n- Refactoring \", \"is isolated to a layer.\\n- Teams can independently build, test, deploy, and maintain separate layers.\", \"\\n- Layers can be swapped out, for example the data layer may access multiple databases without requi\", \"ring changes to the UI layer.\\n\\nServerless may be used to implement one or more layers.\\n\\n## Microserv\", \"ices\\n\\nMicroservices architectures contain common characteristics that include:\\n\\n- Applications are c\", \"omposed of several small services.\\n- Each service runs in its own process.\\n- Services are aligned ar\", \"ound business domains.\\n- Services communicate over lightweight APIs, typically using HTTP as the tra\", \"nsport.\\n- Services can be deployed and upgraded independently.\\n- Services aren't dependent on a sing\", \"le data store.\\n- The system is designed with failure in mind, and the app may still run even when ce\", \"rtain services fail.\\n\\nMicroservices don't have to be mutually exclusive to other architecture approa\", \"ches. For example, an N -Tier architecture may use microservices for the middle tier. It's also poss\", \"ible to implement\\n\\nBrowser\\n\\nService\\n\\n1\\n\\nmicroservices in a variety of ways, from virtual directories\", \" on IIS hosts to containers. The characteristics of microservices make them especially ideal for ser\", \"verless implementations.\\n\\n<!-- image -->\\n\\nThe pros of microservices architectures include:\\n\\n- Refact\", \"oring is often isolated to a single service.\\n- Services can be upgraded independently of each other.\", \"\\n- Resiliency and elasticity can be tuned to the demands of individual services.\\n- Development can h\", \"appen in parallel across disparate teams and platforms.\\n- It's easier to write comprehensive tests f\", \"or isolated services.\\n\\nMicroservices come with their own challenges, including:\\n\\n- Determining what \", \"services are available and how to call them.\\n- Managing the lifecycle of services.\\n- Understanding h\", \"ow services fit together in the overall application.\\n- Full system testing of calls made across disp\", \"arate services.\\n\\nUltimately there are solutions to address all of these challenges, including tappin\", \"g into the benefits of serverless that are discussed later.\\n\\n## Architecture deployment approaches\\n\\n\", \"Regardless of the architecture approach used to design a business application, the implementation, o\", \"r deployment of those applications may vary. Businesses host applications on everything from physica\", \"l hardware to serverless functions.\\n\\n## N -Tier applications\\n\\nThe N -Tier architecture pattern is a \", \"mature architecture and simply refers to applications that separate various logical layers into sepa\", \"rate physical tiers. N-Tier architecture is a physical implementation of N -Layer architecture. The \", \"most common implementation of this architecture includes:\\n\\n- A presentation tier, for example a web \", \"app.\\n- An API or data access tier, such as a REST API.\\n- A data tier, such as a SQL database.\\n\\nBrows\", \"er\\n\\nDatabase\\n\\n/ Backend\\n\\n<!-- image -->\\n\\n(Tier 2)\\n\\nN -tier solutions have the following characterist\", \"ics:\\n\\n- Projects are typically aligned with tiers.\\n- Testing may be approached differently by tier.\\n\", \"- Tiers provide layers of abstraction, for example the presentation tier is typically ignorant of th\", \"e implementation details of the data tier.\\n- Typically, layers only interact with adjacent layers.\\n-\", \" Releases are often managed at the project, and therefore tier, level. A simple API change may requi\", \"re a new release of an entire middle tier.\\n\\nThis approach provides several benefits, including:\\n\\n- I\", \"solation of the database (often the front end doesn't have direct access to the database back end).\\n\", \"- Reuse of the API (for example, mobile, desktop, and web app clients can all reuse the same APIs).\\n\", \"\\nBrowser\\n\\nWeb server\\n\\nAPI\\n\\nserver\\n\\n- Ability to scale out tiers independent of each other.\\n- Refacto\", \"ring isolation: one tier may be refactored without impacting other tiers.\\n\\nLoad\\n\\nLoad\\n\\nDatabase\\n\\n## \", \"On -premises and Infrastructure as a Service (IaaS)\\n\\nThe traditional approach to hosting application\", \"s requires buying hardware and managing all of the software installations, including the operating s\", \"ystem. Originally this involved expensive data centers and physical hardware. The challenges that co\", \"me with operating physical hardware are many, including:\\n\\n- The need to buy excess for \\\"just in case\", \"\\\" or peak demand scenarios.\\n- Securing physical access to the hardware.\\n- Responsibility for hardwar\", \"e failure (such as disk failure).\\n- Cooling.\\n- Configuring routers and load balancers.\\n- Power redun\", \"dancy.\\n- Securing software access.\\n\\n<!-- image -->\\n\\nVirtualization of hardware, via \\\"virtual machine\", \"s\\\" enables Infrastructure as a Service (IaaS). Host machines are effectively partitioned to provide \", \"resources to instances with allocations for their own memory, CPU, and storage. The team provisions \", \"the necessary VMs and configures the associated networks and access to storage.\\n\\nFor more informatio\", \"n, see virtual machine N -tier reference architecture .\\n\\nAlthough virtualization and Infrastructure \", \"as a Service (IaaS) address many concerns, it still leaves much responsibility in the hands of the i\", \"nfrastructure team. The team maintains operating system versions, applies security patches, and inst\", \"alls third-party dependencies on the target machines. Apps often behave differently on production ma\", \"chines compared to the test environment. Issues arise due to different dependency versions and/or OS\", \" SKU levels. Although many organizations deploy N-Tier applications to these targets, many companies\", \" benefit from deploying to a more cloud native model\\n\\nBrowser such as Platform as a Service. Archite\", \"ctures with microservices are more challenging because of the requirements to scale out for elastici\", \"ty and resiliency. Static Website REST API Database\\n\\nFor more information, see virtual machines .\\n\\n#\", \"# Platform as a Service (PaaS)\\n\\nPlatform as a Service (PaaS) offers configured solutions that develo\", \"pers can plug into directly. PaaS is another term for managed hosting. It eliminates the need to man\", \"age the base operating system, security patches and in many cases any third-party dependencies. Exam\", \"ples of platforms include web applications, databases, and mobile back ends.\\n\\nPaaS addresses the cha\", \"llenges common to IaaS. PaaS allows the developer to focus on the code or database schema rather tha\", \"n how it gets deployed. Benefits of PaaS include:\\n\\n- Pay for use models that eliminate the overhead \", \"of investing in idle machines.\\n- Direct deployment and improved DevOps, continuous integration (CI),\", \" and continuous delivery (CD) pipelines.\\n- Automatic upgrades, updates, and security patches.\\n- Push\", \" -button scale out and scale up (elastic scale).\\n\\nThe main disadvantage of PaaS traditionally has be\", \"en vendor lock-in. For example, some PaaS providers only support ASP.NET, Node.js, or other specific\", \" languages and platforms. Products like Azure App Service have evolved to address multiple platforms\", \" and support a variety of languages and frameworks for hosting web apps.\\n\\n<!-- image -->\\n\\n## Softwar\", \"e as a Service (SaaS)\\n\\nSoftware as a Service or SaaS is centrally hosted and available without local\", \" installation or provisioning. SaaS often is hosted on top of PaaS as a platform for deploying softw\", \"are. SaaS provides services to run and connect with existing software. SaaS is often industry and ve\", \"rtical specific. SaaS is often licensed and typically provides a client/server model. Most modern Sa\", \"aS offerings use web-\\n\\nbased apps for the client. Companies typically consider SaaS as a business so\", \"lution to license offerings. It isn't often implemented as architecture consideration for scalabilit\", \"y and maintainability of an application. Indeed, most SaaS solutions are built on IaaS, PaaS, and/or\", \" serverless back ends.\\n\\nLearn more about SaaS through a sample application .\\n\\n## Containers and Func\", \"tions as a Service (FaaS)\\n\\nContainers are an interesting solution that enables PaaS-like benefits wi\", \"thout the IaaS overhead. A container is essentially a runtime that contains the bare essentials need\", \"ed to run a unique application. The kernel or core part of the host operating system and services su\", \"ch as storage are shared across a host. The shared kernel enables containers to be lightweight (some\", \" are mere megabytes in size, compared to the gigabyte size of typical virtual machines). With hosts \", \"already running, containers can be started quickly, facilitating high availability. The ability to s\", \"pin up containers quickly also provides extra layers of resiliency. Docker is one of the more popula\", \"r implementations of containers.\\n\\n## Benefits of containers include:\\n\\n- Lightweight and portable\\n- S\", \"elf -contained so no need to install dependencies\\n- Provide a consistent environment regardless of t\", \"he host (runs exactly same on a laptop as on a cloud server)\\n- Can be provisioned quickly for scale-\", \"out\\n- Can be restarted quickly to recover from failure\\n\\nA container runs on a container host (that i\", \"n turn may run on a bare metal machine or a virtual machine). Multiple containers or instances of th\", \"e same containers may run on a single host. For true failover and resiliency, containers must be sca\", \"led across hosts.\\n\\nFor more information about Docker containers, see What is Docker .\\n\\nManaging cont\", \"ainers across hosts typically requires an orchestration tool such as Kubernetes. Configuring and man\", \"aging orchestration solutions may add additional overhead and complexity to projects. Fortunately, m\", \"any cloud providers provide orchestration services through PaaS solutions to simplify the management\", \" of containers.\\n\\nThe following image illustrates an example Kubernetes installation. Nodes in the in\", \"stallation address scale out and failover. They run Docker container instances that are managed by t\", \"he primary server. The kubelet is the client that relays commands from Kubernetes to Docker.\\n\\nKubele\", \"t\\n\\nKubernetes Master Server\\n\\nScheduler\\n\\nController\\n\\n<!-- image -->\\n\\nFor more information about orche\", \"stration, see Kubernetes on Azure .\\n\\nFunctions as a Service (FaaS) is a specialized container servic\", \"e that is similar to serverless. A specific implementation of FaaS, called OpenFaaS, sits on top of \", \"containers to provide serverless capabilities. OpenFaaS provides templates that package all of the c\", \"ontainer dependencies necessary to run a piece of code. Using templates simplifies the process of de\", \"ploying code as a functional unit. OpenFaaS targets architectures that already include containers an\", \"d orchestrators because it can use the existing infrastructure. Although it provides serverless func\", \"tionality, it specifically requires you to use Docker and an orchestrator.\\n\\n## Serverless\\n\\nA serverl\", \"ess architecture provides a clear separation between the code and its hosting environment. You imple\", \"ment code in a function that is invoked by a trigger. After that function exits, all its needed reso\", \"urces may be freed. The trigger might be manual, a timed process, an HTTP request, or a file upload.\", \" The result of the trigger is the execution of code. Although serverless platforms vary, most provid\", \"e access to pre-defined APIs and bindings to streamline tasks such as writing to a database or queue\", \"ing results.\\n\\nServerless is an architecture that relies heavily on abstracting away the host environ\", \"ment to focus on code. It can be thought of as less server .\\n\\nContainer solutions provide developers\", \" existing build scripts to publish code to serverless-ready images. Other implementations use existi\", \"ng PaaS solutions to provide a scalable architecture.\\n\\nThe abstraction means the DevOps team doesn't\", \" have to provision or manage servers, nor specific containers. The serverless platform hosts code, e\", \"ither as script or packaged executables built with a related SDK, and allocates the necessary resour\", \"ces for the code to scale.\\n\\nThe following diagram illustrates four serverless components. An HTTP re\", \"quest causes the Checkout API code to run. The Checkout API inserts code into a database, and the in\", \"sert triggers several other functions to run to perform tasks like computing tasks and fulfilling th\", \"e order.\\n\\nHTTP Trigger\\n\\n<!-- image -->\\n\\nThe advantages of serverless include:\\n\\n- High density. Many \", \"instances of the same serverless code can run on the same host compared to containers or virtual mac\", \"hines. The instances scale across multiple hosts addressing scale out and resiliency.\\n- Micro -billi\", \"ng. Most serverless providers bill based on serverless executions, enabling massive cost savings in \", \"certain scenarios.\\n- Instant scale. Serverless can scale to match workloads automatically and quickl\", \"y.\\n- Faster time to market. Developers focus on code and deploy directly to the serverless platform.\", \" Components can be released independently of each other.\\n\\nServerless is most often discussed in the \", \"context of compute, but can also apply to data. For example, Azure SQL and Cosmos DB both provide cl\", \"oud databases that don't require you to configure host machines or clusters. This book focuses on se\", \"rverless compute.\\n\\n## Summary\\n\\nThere's a broad spectrum of available choices for architecture, inclu\", \"ding a hybrid approach. Serverless simplifies the approach, management, and cost of application feat\", \"ures at the expense of control and portability. However, many serverless platforms do expose configu\", \"ration to help fine-tune the solution. Good programming practices can also lead to more portable cod\", \"e and less serverless platform lock-in. The following table illustrates the architecture approaches \", \"side by side. Choose serverless based on your scale needs, whether or not you want to manage the run\", \"time, and how well you can break your workloads into small components. You'll learn about potential \", \"challenges with serverless and other decision points in the next chapter.\\n\\n|           | IaaS     | \", \"PaaS     | Container   | Serverless   |\\n|-----------|----------|----------|-------------|-----------\", \"---|\\n| Scale     | VM       | Instance | App         | Function     |\\n| Abstracts | Hardware | Platf\", \"orm | OS Host     | Runtime      |\\n| Unit      | VM       | Project  | Image       | Code         |\\n\", \"\\n|                | IaaS                                                        | PaaS              \", \"             | Container                                 | Serverless               |\\n|-------------\", \"---|-------------------------------------------------------------|--------------------------------|-\", \"------------------------------------------|--------------------------|\\n| Lifetime       | Months    \", \"                                                  | Days to Months                 | Minutes to Days\", \"                           | Milliseconds  to Minutes |\\n| Responsibility | Applications,  dependenci\", \"es, runtime,  and operating system | Applications and  dependencies | Applications,  dependencies, a\", \"nd  runtime | Function                 |\\n\\n- Scale refers to the unit that is used to scale the appli\", \"cation\\n- Abstracts refers to the layer that is abstracted by the implementation\\n- Unit refers to the\", \" scope of what is deployed\\n- Lifetime refers to the typical runtime of a specific instance\\n- Respons\", \"ibility refers to the overhead to build, deploy, and maintain the application\\n\\nThe next chapter will\", \" focus on serverless architecture, use cases, and design patterns.\\n\\n## Recommended resources\\n\\n- Azur\", \"e application architecture guide\\n- Azure Cosmos DB\\n- Azure SQL\\n- N -Tier architecture pattern\\n- Kube\", \"rnetes on Azure\\n- Microservices\\n- Virtual machine N -tier reference architecture\\n- Virtual machines\\n\", \"- What is Docker?\\n- Wingtip Tickets SaaS application\\n\\nFunction Code\\n\\nFunction\\n\\nConfiguration\\n\\n## Ser\", \"verless architecture\\n\\nWebJobs Core\\n\\nThere are many approaches to using serverless architectures. Thi\", \"s chapter explores examples of common architectures that integrate serverless. It also covers concer\", \"ns that may pose additional challenges or require extra consideration when implementing serverless. \", \"Finally, several design examples are provided that illustrate various serverless use cases.\\n\\nServerl\", \"ess hosts often use an existing container-based or PaaS layer to manage the serverless instances. Fo\", \"r example, Azure Functions is based on Azure App Service. The App Service is used to scale out insta\", \"nces and manage the runtime that executes Azure Functions code. For Windows-based functions, the hos\", \"t runs as PaaS and scales out the .NET runtime. For Linux -based functions, the host leverages conta\", \"iners.\\n\\n<!-- image -->\\n\\nThe WebJobs Core provides an execution context for the function. The Languag\", \"e Runtime runs scripts, executes libraries and hosts the framework for the target language. For exam\", \"ple, Node.js is used to run JavaScript functions and the .NET Framework is used to run C# functions.\", \" You'll learn more about language and platform options later in this chapter.\\n\\nSome projects may ben\", \"efit from taking an \\\"all-in\\\" approach to serverless. Applications that rely heavily on microservices\", \" may implement all microservices using serverless technology. The majority of apps are hybrid, follo\", \"wing an N-tier design and using serverless for the components that make sense\\n\\nbecause the component\", \"s are modular and independently scalable. To help make sense of these scenarios, this section walks \", \"through some common architecture examples that use serverless.\\n\\n## Full serverless back end\\n\\nThe ful\", \"l serverless back end is ideal for several types of scenarios, especially when building new or \\\"gree\", \"n field\\\" applications. An application with a large surface area of APIs may benefit from implementin\", \"g each API as a serverless function. Apps that are based on microservices architecture are another e\", \"xample that could be implemented as a full serverless back end. The microservices communicate over v\", \"arious protocols with each other. Specific scenarios include:\\n\\n- API -based SaaS products (example: \", \"financial payments processor).\\n- Message -driven applications (example: device monitoring solution).\", \"\\n- Apps focused on integration between services (example: airline booking application).\\n- Processes \", \"that run periodically (example: timer-based database clean-up).\\n- Apps focused on data transformatio\", \"n (example: import triggered by file upload).\\n- Extract Transform and Load (ETL) processes.\\n\\nThere a\", \"re other, more specific use cases that are covered later in this document.\\n\\n## Monoliths and \\u201cstarvi\", \"ng the beast\\u201d\\n\\nA common challenge is migrating an existing monolithic application to the cloud. The \", \"least risky approach is to \\\"lift and shift\\\" entirely onto virtual machines. Many shops prefer to use\", \" the migration as an opportunity to modernize their code base. A practical approach to migration is \", \"called \\\"starving the beast.\\\" In this scenario, the monolith is migrated \\\"as is\\\" to start with. Then,\", \" selected services are modernized. In some cases, the signature of the service is identical to the o\", \"riginal: it simply is hosted as a function. Clients are updated to use the new service rather than t\", \"he monolith endpoint. In the interim, steps such as database replication enable microservices to hos\", \"t their own storage even when transactions are still handled by the monolith. Eventually, all client\", \"s are migrated onto the new services. The monolith is \\\"starved\\\" (its services no longer called) unti\", \"l all functionality has been replaced. The combination of serverless and proxies can facilitate much\", \" of this migration.\\n\\nBrowser\\n\\nFunction\\n\\n1\\n\\n<!-- image -->\\n\\nFunction\\n\\nTo learn more about this approa\", \"ch, watch the video: Bring your app to the cloud with serverless Azure Functions .\\n\\n## Web apps\\n\\nWeb\", \" apps are great candidates for serverless applications. There are two common approaches to web apps \", \"today: server-driven, and client-driven (such as Single Page Application or SPA). Server-driven web \", \"apps typically use a middleware layer to issue API calls to render the web UI. SPA applications make\", \" REST API calls directly from the browser. In both scenarios, serverless can accommodate the middlew\", \"are or REST API request by providing the necessary business logic. A common architecture is to stand\", \" up a lightweight static web server. The Single Page Application (SPA) serves HTML, CSS, JavaScript,\", \" and other browser assets. The web app then connects to a microservices back end.\\n\\n## Mobile back en\", \"ds\\n\\nThe event -driven paradigm of serverless apps makes them ideal as mobile back ends. The mobile d\", \"evice triggers the events and the serverless code executes to satisfy requests. Taking advantage of \", \"a serverless model enables developers to enhance business logic without having to deploy a full appl\", \"ication update. The serverless approach also enables teams to share endpoints and work in parallel.\\n\", \"\\nMobile developers can build business logic without becoming experts on the server side. Traditional\", \"ly, mobile apps connected to on-premises services. Building the service layer required understanding\", \" the server platform and programming paradigm. Developers worked with operations to provision server\", \"s\\n\\nPhoto taken and\\n\\nWebHook called and configure them appropriately. Sometimes days or even weeks we\", \"re spent on building a deployment pipeline. All of these challenges are addressed by serverless.\\n\\nSe\", \"rverless abstracts the server -side dependencies and enables the developer to focus on business logi\", \"c. For example, a mobile developer who builds apps using a JavaScript framework can build serverless\", \" functions with JavaScript as well. The serverless host manages the operating system, a Node.js inst\", \"ance to host the code, package dependencies, and more. The developer is provided a simple set of inp\", \"uts and a standard template for outputs. They then can focus on building and testing the business lo\", \"gic. They're therefore able to use existing skills to build the back-end logic for the mobile app wi\", \"thout having to learn new platforms or become a \\\"server-side developer.\\\"\\n\\n<!-- image -->\\n\\nMost cloud\", \" providers offer mobile-based serverless products that simplify the entire mobile development lifecy\", \"cle. The products may automate the provisioning of databases to persist data, handle DevOps concerns\", \", provide cloud-based builds and testing frameworks and the ability to script business processes usi\", \"ng the developer's preferred language. Following a mobile-centric serverless approach can streamline\", \" the process. Serverless removes the tremendous overhead of provisioning, configuring, and maintaini\", \"ng servers for the mobile back end.\\n\\n## Internet of Things (IoT)\\n\\nIoT refers to physical objects tha\", \"t are networked together. They're sometimes referred to as \\\"connected devices\\\" or \\\"smart devices.\\\" E\", \"verything from cars and vending machines may be connected and send information ranging from inventor\", \"y to sensor data such as temperature and humidity. In the enterprise, IoT provides business process \", \"improvements through monitoring and automation. IoT data may be used to regulate the climate in a la\", \"rge warehouse or track inventory through the supply chain. IoT can sense chemical spills and call th\", \"e fire department when smoke is detected.\\n\\nThe sheer volume of devices and information often dictate\", \"s an event -driven architecture to route and process messages. Serverless is an ideal solution for s\", \"everal reasons:\\n\\n- Enables scale as the volume of devices and data increases.\\n- Accommodates adding \", \"new endpoints to support new devices and sensors.\\n- Facilitates independent versioning so developers\", \" can update the business logic for a specific device without having to deploy the entire system.\\n- R\", \"esiliency and less downtime.\\n\\nThe pervasiveness of IoT has resulted in several serverless products t\", \"hat focus specifically on IoT concerns, such as Azure IoT Hub. Serverless automates tasks such as de\", \"vice registration, policy enforcement, tracking, and even deployment of code to devices at the edge.\", \" The edge refers to devices like sensors and actuators that are connected to, but not an active part\", \" of, the Internet.\\n\\n## Serverless architecture considerations\\n\\nAdopting a serverless architecture do\", \"es come with certain challenges. This section explores some of the more common considerations to be \", \"aware of. All of these challenges have solutions. As with all architecture choices, the decision to \", \"go serverless should be made only after carefully considering the pros and cons. Depending on the ne\", \"eds of your application, you may decide a serverless implementation isn't the right solution for cer\", \"tain components.\\n\\n## Managing state\\n\\nServerless functions, as with microservices in general, are sta\", \"teless by default. Avoiding state enables serverless to be ephemeral, to scale out, and to provide r\", \"esiliency without a central point of failure. In some circumstances, business processes require stat\", \"e. If your process requires state, you have two options. You can adopt a model other than serverless\", \", or interact with a separate service that provides state. Adding state can complicate the solution \", \"and make it harder to scale, and potentially create a single point of failure. Carefully consider wh\", \"ether your function absolutely requires state. If the answer is \\\"yes,\\\" determine whether it still ma\", \"kes sense to implement it with serverless.\\n\\nThere are several solutions to adopt state without compr\", \"omising the benefits of serverless. Some of the more popular solutions include:\\n\\n- Use a temporary d\", \"ata store or distributed cache, like Redis\\n- Store state in a database, like SQL or CosmosDB\\n- Handl\", \"e state through a workflow engine like durable functions\\n\\nThe bottom line is that you should be awar\", \"e of the need for any state management within processes you're considering to implement with serverl\", \"ess.\\n\\n## Long-running processes\\n\\nMany benefits of serverless rely on the processes being ephemeral. \", \"Short run times make it easier for the serverless provider to free up resources as functions end and\", \" share functions across hosts. Most cloud providers limit the total time your function can run to ar\", \"ound 10 minutes. If your process may take longer, you might consider an alternative implementation.\\n\", \"\\nThere are a few exceptions and solutions. One solution may be to break your process into smaller co\", \"mponents that individually take less time to run. If your process runs long because of dependencies,\", \" you can also consider an asynchronous workflow using a solution like durable functions. Durable fun\", \"ctions pause and maintain the state of your process while it's waiting on an external process to fin\", \"ish. Asynchronous handling reduces the time the actual process runs.\\n\\n## Startup time\\n\\nOne potential\", \" concern with serverless implementations is startup time. To conserve resources, many serverless pro\", \"viders create infrastructure \\\"on demand.\\\" When a serverless function is triggered after a period of \", \"time, the resources to host the function may need to be created or restarted. In some situations, co\", \"ld starts may result in delays of several seconds. Startup time varies across providers and service \", \"levels. There are a few approaches to address startup time if it's important to minimize for the suc\", \"cess of the app.\\n\\n- Some providers allow users to pay for service levels that guarantee infrastructu\", \"re is \\\"always on\\\".\\n- Implement a keep-alive mechanism (ping the endpoint to keep it \\\"awake\\\").\\n- Use \", \"orchestration like Kubernetes with a containerized function approach (the host is already running so\", \" spinning up new instances is extremely fast).\\n\\n## Database updates and migrations\\n\\nAn advantage of \", \"serverless code is that you can release new functions without having to redeploy the entire applicat\", \"ion. This advantage can become a disadvantage when there's a relational database involved. Changes t\", \"o database schemas are difficult to synchronize with serverless updates. Additional challenges are p\", \"osed when things go wrong and the changes must be rolled back. Data integrity is one reason that a b\", \"est practice for microservices and serverless functions is that they own their own data. It is possi\", \"ble to deploy changes as a single unit of compute and data. The reality is that many legacy systems \", \"feature a large back-end database that must be reconciled with the serverless architecture.\\n\\nA popul\", \"ar approach to solve schema versioning is to never modify existing properties and columns, but inste\", \"ad add new information. For example, consider a change to move from a Boolean \\\"completed\\\" flag for a\", \" todo list to a \\\"completed date.\\\" Instead of removing the old field, the database change will:\\n\\n1. A\", \"dd a new \\\"completed date\\\" field.\\n2. Transform the \\\"completed\\\" Boolean field to a computed function t\", \"hat evaluates whether the completed date is after the current date.\\n3. Add a trigger to set the comp\", \"leted date to the current date when the completed Boolean is set to true.\\n\\nThe sequence of changes e\", \"nsures that legacy code continues to run \\\"as is\\\" while newer serverless functions can take advantage\", \" of the new field.\\n\\nFor more information about data in serverless architectures, see Challenges and \", \"solutions for distributed data management .\\n\\n## Scaling\\n\\nIt's a common misconception that serverless\", \" means \\\"no server.\\\" It's in fact \\\"less server.\\\" The fact there is a backing infrastructure is import\", \"ant to understand when it comes to scaling. Most serverless platforms provide a set of controls to h\", \"andle how the infrastructure should scale when event density increases. You can choose from a variet\", \"y of options, but your strategy may vary depending on the\\n\\nfunction. Furthermore, functions are typi\", \"cally run under a related host, so that functions on the same host have the same scale options. Ther\", \"efore it is necessary to organize and strategize which functions are hosted together based on scale \", \"requirements.\\n\\nRules often specify how to scale-up (increase the host resources) and scale-out (incr\", \"ease the number of host instances) based on varying parameters. Triggers for scales may include sche\", \"dule, request rates, CPU utilization, and memory usage. Higher performance often comes at a greater \", \"cost. The less expensive, consumption-based approaches may not scale as quickly when the request rat\", \"e suddenly increases. There is a trade -off between paying up front \\\"insurance cost\\\" versus paying s\", \"trictly \\\"as you go\\\" and risking slower responses due to sudden increases in demand.\\n\\n## Monitoring, \", \"tracing, and logging\\n\\nAn often overlooked aspect of DevOps is monitoring applications once deployed.\", \" It's important to have a strategy for monitoring serverless functions. The biggest challenge is oft\", \"en correlation, or recognizing when a user calls multiple functions as part of the same interaction.\", \" Most serverless platforms allow console logging that can be imported into third-party tools. There \", \"are also options to automate collection of telemetry, generate and track correlation IDs, and monito\", \"r specific actions to provide detailed insights. Azure provides the advanced Application Insights pl\", \"atform for monitoring and analytics.\\n\\n## Inter -service dependencies\\n\\nA serverless architecture may \", \"include functions that rely on other functions. In fact, it isn't uncommon in a serverless architect\", \"ure to have multiple services call each other as part of an interaction or distributed transaction. \", \"To avoid strong coupling, it's recommended that services don't reference each other directly. When t\", \"he endpoint for a service needs to change, direct references could result in major refactoring. A su\", \"ggested solution is to provide a service discovery mechanism, such as a registry, that provides the \", \"appropriate end point for a request type. Another solution is to leverage messaging services like qu\", \"eues or topics for communication between services.\\n\\n## Managing failure and providing resiliency\\n\\nIt\", \"'s also important to consider the circuit-breaker pattern: If, for some reason, a service continues \", \"to fail, it isn't advisable to call that service repeatedly. Instead, an alternative service is call\", \"ed or a message returned until the health of the dependent service is re-established. The serverless\", \" architecture needs to take into account the strategy for resolving and managing inter-service depen\", \"dencies.\\n\\nTo continue the circuit -breaker pattern, services need to be fault tolerant and resilient\", \". Fault tolerance refers to the ability of your application to continue running even after unexpecte\", \"d exceptions or invalid states are encountered. Fault tolerance is typically a function of the code \", \"itself and how it's written to handle exceptions. Resiliency refers to how capable the app is at rec\", \"overing from failures. Resiliency is often managed by the serverless platform. The platform should b\", \"e able to spin up a new serverless function instance when the existing one fails. The platform shoul\", \"d also be intelligent enough to stop spinning up new instances when every new instance fails.\\n\\nEvery\", \" 15 minutes\\n\\nFor more information, see Implementing the Circuit Breaker pattern .\\n\\n## Versioning and\", \" green/blue deployments\\n\\nA major benefit of serverless is the ability to upgrade a specific function\", \" without having to redeploy the entire application. For upgrades to be successful, functions must be\", \" versioned so that services calling them are routed to the correct version of code. A strategy for d\", \"eploying new versions is also important. A common approach is to use \\\"green/blue deployments.\\\" The g\", \"reen deployment is the current function. A new \\\"blue\\\" version is deployed to production and tested. \", \"When testing passes, the green and blue versions are swapped so the new version comes live. If any i\", \"ssues are encountered, they can be swapped back. Supporting versioning and green/blue deployments re\", \"quires a combination of authoring the functions to accommodate version changes and working with the \", \"serverless platform to handle deployments.\\n\\n## Serverless design examples\\n\\nThere are many design pat\", \"terns that exist for serverless. This section captures some common scenarios that use serverless. Wh\", \"at all of the examples have in common is the fundamental combination of an event trigger and busines\", \"s logic.\\n\\n## Scheduling\\n\\nScheduling tasks is a common function. The following diagram shows a legacy\", \" database that doesn't have appropriate integrity checks. The database must be scrubbed periodically\", \". The serverless function finds invalid data and cleans it. The trigger is a timer that runs the cod\", \"e on a schedule.\\n\\n<!-- image -->\\n\\n## Command and Query Responsibility Segregation (CQRS)\\n\\nCommand an\", \"d Query Responsibility Segregation (CQRS) is a pattern that provides different interfaces for readin\", \"g (or querying) data and operations that modify data. It addresses several common problems. In tradi\", \"tional Create Read Update Delete (CRUD) based systems, conflicts can arise from high volume of both \", \"reads and writes to the same data store. Locking may frequently occur and dramatically slow down rea\", \"ds. Often, data is presented as a composite of several domain objects and read operations must combi\", \"ne data from different entities.\\n\\nUsing CQRS, a read might involve a special \\\"flattened\\\" entity that\", \" models data the way it's consumed. The read is handled differently than how it's stored. For exampl\", \"e, although the database may store a contact as a header record with a child address record, the rea\", \"d could involve an entity with both\\n\\nQuery\\n\\n&gt;\\n\\nheader and address properties. There are myriad ap\", \"proaches to creating the read model. It might be materialized from views. Update operations could be\", \" encapsulated as isolated events that then trigger updates to two different models. Separate models \", \"exist for reading and writing.\\n\\n<!-- image -->\\n\\nServerless can accommodate the CQRS pattern by provi\", \"ding the segregated endpoints. One serverless function accommodates queries or reads, and a differen\", \"t serverless function or set of functions handles update operations. A serverless function may also \", \"be responsible for keeping the read model up -to -date, and can be triggered by the database's chang\", \"e feed. Front-end development is simplified to connecting to the necessary endpoints. Processing of \", \"events is handled on the back end. This model also scales well for large projects because different \", \"teams may work on different operations.\\n\\n## Event -based processing\\n\\nIn message -based systems, even\", \"ts are often collected in queues or publisher/subscriber topics to be acted upon. These events can t\", \"rigger serverless functions to execute a piece of business logic. An example of event-based processi\", \"ng is event-sourced systems. An \\\"event\\\" is raised to mark a task as complete. A serverless function \", \"triggered by the event updates the appropriate database document. A second serverless function may u\", \"se the event to update the read model for the system. Azure Event Grid provides a way to integrate e\", \"vents with functions as subscribers.\\n\\nEvents are informational messages. For more information, see E\", \"vent Sourcing pattern .\\n\\n## File triggers and transformations\\n\\nExtract, Transform, and Load (ETL) is\", \" a common business function. Serverless is a great solution for ETL because it allows code to be tri\", \"ggered as part of a pipeline. Individual code components can address various aspects. One serverless\", \" function may download the file, another applies the transformation, and another loads the data. The\", \" code can be tested and deployed independently, making it easier to maintain and scale where needed.\", \"\\n\\nFlat Table Read\\n\\nFTP Download\\n\\nManager Function\\n\\nSingle Folder\\n\\nFTP\\n\\nAbnormal behavior\\n\\n<!-- image\", \" -->\\n\\nIn the diagram, \\\"cool storage\\\" provides data that is parsed in Azure Stream Analytics. Any iss\", \"ues encountered in the data stream trigger an Azure Function to address the anomaly.\\n\\n## Asynchronou\", \"s background processing and messaging\\n\\nAsynchronous messaging and background processing allow applic\", \"ations to kick off processes without having to wait. An example of asynchronous processing is an OCR\", \" app. An image is submitted and queued for processing. Scanning the image to extract text may take t\", \"ime, and once it's finished a notification is sent. Serverless can handle both the invocation and th\", \"e result in this scenario.\\n\\n## Web apps and APIs\\n\\nA popular scenario for serverless is N-tier applic\", \"ations, most commonly ones where the UI layer is a web app. The popularity of Single Page Applicatio\", \"ns (SPA) has surged recently. SPA apps render a single page, then rely on API calls and the returned\", \" data to dynamically render new UI without reloading a full page. Client-side rendering provides a m\", \"uch faster, more responsive application to the end user.\\n\\nServerless endpoints triggered by HTTP cal\", \"ls can be used to handle the API requests. For example, an ad services company may call a serverless\", \" function with user profile information to request custom advertising. The serverless function retur\", \"ns the custom ad and the web page renders it.\\n\\n10'\\n\\n01\\n\\nLoaded web page calls WebHook\\n\\nFile added to\", \"\\n\\nBlob Storage\\n\\n<!-- image -->\\n\\n## Data pipeline\\n\\nServerless functions can be used to facilitate a d\", \"ata pipeline. In this example, a file triggers a function to translate data in a CSV file to data ro\", \"ws in a table. The organized table allows a Power BI dashboard to present analytics to the end user.\", \"\\n\\n<!-- image -->\\n\\n## Stream processing\\n\\nDevices and sensors often generate streams of data that must\", \" be processed in real time. There are a number of technologies that can capture messages and streams\", \" from Event Hubs and IoT Hub to Service Bus. Regardless of transport, serverless is an ideal mechani\", \"sm for processing the messages and streams of data as they come in. Serverless can scale quickly to \", \"meet the demand of large volumes of data. The serverless code can apply business logic to parse the \", \"data and output in a structured format for action and analytics.\\n\\n1. ..\\n\\nMillions of devices feed in\", \"to Stream Analytics\\n\\nFunction app B\\n\\nSQL\\n\\n\\u2192 /products\\n\\n<!-- image -->\\n\\n## API gateway\\n\\n\\u2192 /orders\\n\\nFu\", \"nction2\\n\\nFunction3\\n\\nAn API gateway provides a single point of entry for clients and then intelligent\", \"ly routes requests to back -end services. It's useful to manage large sets of services. It can also \", \"handle versioning and simplify development by easily connecting clients to disparate environments. S\", \"erverless can handle back -end scaling of individual microservices while presenting a single front e\", \"nd via an API gateway.\\n\\n<!-- image -->\\n\\n## Recommended resources\\n\\n- Azure Event Grid\\n- Azure IoT Hub\", \"\\n- Challenges and solutions for distributed data management\\n- Designing microservices: identifying m\", \"icroservice boundaries\\n- Event Hubs\\n- Event Sourcing pattern\\n- Implementing the Circuit Breaker patt\", \"ern\\n- IoT Hub\\n- Service Bus\\n- Working with the change feed support in Azure Cosmos DB\\n\\nEvent Grid\\n\\n{\", \"02}\\n\\nPlatform\\n\\nLogic Apps\\n\\n&lt;5&gt;\\n\\nCHAPTER\\n\\nFunctions\\n\\n## Azure serverless platform\\n\\nDatabase\\n\\nTh\", \"e Azure serverless platform includes Azure Functions, Logic Apps, and Event Grid. These services wor\", \"k together and connect with myriad other resources. The serverless platform works with everything fr\", \"om databases and storage to analytics and machine learning/artificial intelligence.\\n\\nYou can also us\", \"e Application Insights, a serverless platform for capturing diagnostic traces and telemetry. Applica\", \"tion Insights are available to applications of all types (desktop, mobile, or web) as well as server\", \"less implementations. The platform is visualized in the following diagram:\\n\\n<!-- image -->\\n\\nThis cha\", \"pter breaks down the fundamentals of each component.\\n\\n## Azure Functions\\n\\nAzure Functions provide a \", \"serverless compute experience. A function is invoked by a trigger (such as access to an HTTP endpoin\", \"t or a timer) and executes a block of code or business logic. Functions also support specialized bin\", \"dings that connect to resources like storage and queues.\\n\\n3C\\n\\n<!-- image -->\\n\\nThe current runtime ve\", \"rsion 4.0 supports cross-platform .NET 7.0 applications. Additional languages besides C# such as Jav\", \"aScript, F#, and Java are supported. Functions created in the portal provide a rich scripting syntax\", \". Functions created as standalone projects can be deployed with full platform support and capabiliti\", \"es.\\n\\nFor more information, see Azure Functions documentation .\\n\\n## Programming language support\\n\\nThe\", \" following languages are all supported in general availability (GA).\\n\\n| Language   | Supported runti\", \"mes for 4.x        |\\n|------------|-----------------------------------|\\n| C#         | .NET 6.0, 7.0\", \", .NET Framework 4.8 |\\n| JavaScript | Node 14, 16, 18                   |\\n| F#         | .NET 6.0, 7\", \".0                     |\\n| Java       | Java 8, 11, 17                    |\\n| Python     | Python 3.\", \"7, 3.8, 3.9, 3.10        |\\n| TypeScript | Node 14, 16, 18 (via JavaScript)  |\\n| PowerShell | PowerSh\", \"ell Core 7.2               |\\n\\nFor more information on other runtime versions, see Supported language\", \"s .\\n\\n## App service plans\\n\\nFunctions are backed by an app service plan. The plan defines the resourc\", \"es used by the functions app. You can assign plans to a region, determine the size and number of vir\", \"tual machines that will be used, and pick a pricing tier. For a true serverless approach, function a\", \"pps may use the consumption plan. The consumption plan will scale the back end automatically based o\", \"n load.\\n\\nAnother hosting option for function apps is the Premium plan. This plan provides an \\\"always\", \" on\\\" instance to avoid cold start, supports advanced features like VNet connectivity, and runs on pr\", \"emium hardware.\\n\\nFor more information, see App service plans .\\n\\n## Create your first function\\n\\nThere\", \" are three common ways you can create function apps.\\n\\n- Script functions in the portal.\\n- Create the\", \" necessary resources using the Azure CLI.\\n- Build functions locally using your favorite IDE and publ\", \"ish them to Azure.\\n\\nFor more information on creating a scripted function in the portal, see Create y\", \"our first function in the Azure portal .\\n\\nTo build from the Azure CLI, see Create your first functio\", \"n using the Azure CLI .\\n\\nTo create a function from Visual Studio, see Create your first function usi\", \"ng Visual Studio .\\n\\n## Understand triggers and bindings\\n\\nFunctions are invoked by a trigger and can \", \"have exactly one. In addition to invoking the function, certain triggers also serve as bindings. You\", \" may also define multiple bindings in addition to the trigger. Bindings provide a declarative way to\", \" connect data to your code. They can be passed in (input) or receive data (output). Triggers and bin\", \"dings make functions easy to work with. Bindings remove the overhead of manually creating database o\", \"r file system connections. All of the information needed for the bindings is contained in a special \", \"functions.json file for scripts or declared with attributes in code.\\n\\nSome common triggers include:\\n\", \"\\n- Blob Storage: invoke your function when a file or folder is uploaded or changed in storage.\\n- HTT\", \"P: invoke your function like a REST API.\\n- Queue: invoke your function when items exist in a queue.\\n\", \"- Timer: invoke your function on a regular cadence.\\n\\nExamples of bindings include:\\n\\n- CosmosDB: easi\", \"ly connect to the database to load or save files.\\n- Table Storage: work with key/value storage from \", \"your function app.\\n- Queue Storage: easily retrieve items from a queue, or place new items on the qu\", \"eue.\\n\\nThe following example functions.json file defines a trigger and a binding:\\n\\n```\\n{ \\\"bindings\\\": \", \"[ { \\\"name\\\": \\\"myBlob\\\" , \\\"type\\\": \\\"blobTrigger\\\" , \\\"direction\\\": \\\"in\\\" , \\\"path\\\": \\\"images/{name}\\\" , \\\"connec\", \"tion\\\": \\\"AzureWebJobsStorage\\\" } , { \\\"name\\\": \\\"$return\\\" , \\\"type\\\": \\\"queue\\\" , \\\"direction\\\": \\\"out\\\" , \\\"queue\", \"Name\\\": \\\"images\\\" , \\\"connection\\\": \\\"AzureWebJobsStorage\\\" } ] , \\\"disabled\\\": false }\\n```\\n\\nIn this example\", \", the function is triggered by a change to blob storage in the images container. The information for\", \" the file is passed in, so the trigger also acts as a binding. Another binding exists to put informa\", \"tion onto a queue named images .\\n\\nHere is the C# script for the function:\\n\\n```\\npublic static string \", \"Run(Stream myBlob, string name, TraceWriter log) { log.Info($\\\"C# Blob trigger function Processed blo\", \"b\\\\n Name:{name} \\\\n Size: {myBlob.Length} Bytes\\\"); return name; }\\n```\\n\\nThe example is a simple functi\", \"on that takes the name of the file that was modified or uploaded to blob storage, and places it on a\", \" queue for later processing.\\n\\nFor a full list of triggers and bindings, see Azure Functions triggers\", \" and bindings concepts .\\n\\n## Telemetry with Application Insights\\n\\nApplication Insights is a serverle\", \"ss diagnostics platform that enables developers to detect, triage, and diagnose issues in web apps, \", \"mobile apps, desktop apps, and microservices. You can turn on Application Insights for function apps\", \" simply by flipping a switch in the portal. Application Insights provides all of these capabilities \", \"without you having to configure a server or set up your own database. All of Application Insights' c\", \"apabilities are provided as a service that automatically integrates with your apps.\\n\\n<!-- image -->\\n\", \"\\nAdding Application Insights to existing apps is as easy as adding an instrumentation key to your ap\", \"plication's settings. With Application Insights you can:\\n\\n- Create custom charts and alerts based on\", \" metrics such as number of function invocations, the time it takes to run a function, and exceptions\", \"\\n- Analyze failures and server exceptions\\n- Drill into performance by operation and measure the time\", \" it takes to call third-party dependencies\\n- Monitor CPU usage, memory, and rates across all servers\", \" that host your function apps\\n- View a live stream of metrics including request count and latency fo\", \"r your function apps\\n- Use Analytics to search, query, and create custom charts over your function d\", \"ata\\n\\n=\\n\\nfunctionapp0915 - Metrics Explorer\\n\\nApplication Insights\\n\\nO Search (Ctri+/)\\n\\n@ Overview\\n\\n\\u2022 A\", \"ctivity log iM Access control (IAM)\\n\\nTags\\n\\nINVESTIGATE\\n\\n\\u2022 Application map\\n\\n@ Smart Detection\\n\\n1- Liv\", \"e Metrics Stream i Metrics Explorer\\n\\nP Search\\n\\nAvailability\\n\\nFailures\\n\\nPerformance\\n\\nServers\\n\\nBrowser\", \"\\n\\nUSAGE (PREVIEW)\\n\\nUsers\\n\\n+ Add chart\\n\\n\\u2022 Time range\\n\\nY Filters\\n\\n\\u00a9 Refresh\\n\\nAlert rules\\n\\n* \\u00d7\\n\\n\\u2022\\u2022\\u2022 Mor\", \"e\\n\\n# *\\n\\n<!-- image -->\\n\\nIn addition to built -in telemetry, it's also possible to generate custom te\", \"lemetry. The following code snippet creates a custom telemetry client using the instrumentation key \", \"set for the function app:\\n\\n```\\npublic static TelemetryClient telemetry = new TelemetryClient() { Ins\", \"trumentationKey = Environment.GetEnvironmentVariable(\\\"APPINSIGHTS_INSTRUMENTATIONKEY\\\") };\\n```\\n\\nThe f\", \"ollowing code measures how long it takes to insert a new row into an Azure Table Storage instance:\\n\\n\", \"```\\nvar startTime = DateTime.UtcNow; var timer = System.Diagnostics . Stopwatch . StartNew(); await \", \"tableClient.AddEntityAsync(entry); telemetry.TrackDependency(\\\"AzureTableStorageInsert\\\" , \\\"Insert\\\", s\", \"tartTime, timer.Elapsed , true);\\n```\\n\\nThe resulting performance graph is shown:\\n\\nOperations\\n\\nDepende\", \"ncies\\n\\nDependency response time\\n\\n100 ms\\n\\n50 ms\\n\\n0.0ms\\n\\nDependency count\\n\\n12 PM\\n\\nSelect operation\\n\\nDE\", \"PENDENCY NAME\\n\\nOverall\\n\\nOther: AzureTableStoragelnsert\\n\\nOther: Azure TableStorage\\n\\nOther: Azure Tabl\", \"eStorageUpdate\\n\\nView in Analytics\\n\\nFeedback\\n\\nOther: Azure TableStorageinsert\\n\\nDistribution of durati\", \"ons: zoom into a range\\n\\n* Profiler\\n\\nScale\\n\\nHIII\\n\\n<!-- image -->\\n\\nThe custom telemetry reveals the av\", \"erage time to insert a new row is 32.6 milliseconds.\\n\\nApplication Insights provides a powerful, conv\", \"enient way to log detailed telemetry about your serverless applications. You have full control over \", \"the level of tracing and logging that is provided. You can track custom statistics such as events, d\", \"ependencies, and page view. Finally, the powerful analytics enable you to write queries that ask imp\", \"ortant questions and generate charts and advanced insights.\\n\\nFor more information, see Monitor Azure\", \" Functions .\\n\\n## Azure Logic Apps\\n\\nAzure Logic Apps provides a serverless engine to build automated \", \"workflows to integrate apps and data between cloud services and on -premises systems. You build work\", \"flows using a visual designer. You can trigger workflows based on events or timers and leverage conn\", \"ectors to integration applications and facilitate business-to-business (B2B) communication. Logic Ap\", \"ps integrates seamlessly with Azure Functions.\\n\\nLogic Apps can do more than just connect your cloud \", \"services (like functions) with cloud resources (like queues and databases). You can also orchestrate\", \" on-premises workflows with the on-premises gateway. For example, you can use the Logic App to trigg\", \"er an on-premises SQL stored procedure in response to a cloud-based event or conditional logic in yo\", \"ur workflow. Learn more about Connecting to on -premises data sources with Azure On-premises Data Ga\", \"teway .\\n\\n08:30\\n\\n03 PM\\n\\nAvg\\n\\n50\\u2122H\\n\\n95\\u2122H\\n\\n99\\u2122H\\n\\nRefresh\\n\\nStart with a common trigger\\n\\nPick from one of\", \" the most commonly used triggers, then orchestrate any number of actions using the rich collection o\", \"f connectors\\n\\nAzure Functions\\n\\nWhen a message is received in a Service\\n\\nBus queue\\n\\nService bus\\n\\nRecu\", \"rrence\\n\\n9S Cognitive services\\n\\n/ Machine learning\\n\\n5 &gt; SharePoint\\n\\n<!-- image -->\\n\\nLike Azure Fun\", \"ctions, you kick off Logic App workflows with a trigger. There are many triggers for you to choose f\", \"rom. The following capture shows just a few of the more popular ones out of hundreds that are availa\", \"ble.\\n\\n<!-- image -->\\n\\nOnce the app is triggered, you can use the visual designer to build out steps,\", \" loops, conditions, and actions. Any data ingested in a previous step is available for you to use in\", \" subsequent steps. The following workflow loads URLs from a CosmosDB database. It finds the ones wit\", \"h a host of t.co then searches for them on Twitter. If it finds corresponding tweets, it updates the\", \" documents with the related tweets by calling a function.\\n\\nWhen a HTTP\\n\\nrequest is received\\n\\nSQL\\n\\nWh\", \"en a new tweet is posted\\n\\nWhen a Event Grid event occurs\\n\\n\\u2022 Office 365\\n\\nIf true\\n\\nFor each\\n\\n\\\"Select a\", \"n output from previous steps\\n\\nScope\\n\\n{x}\\n\\n{x}\\n\\nRecurrence\\n\\nInitialize variable\\n\\nInitialize variable \", \"2\\n\\n<!-- image -->\\n\\nI Add anaction II Add a condition\\n\\nThe Logic Apps dashboard shows the history of \", \"running your workflows and whether each run completed successfully or not. You can navigate into any\", \" given run and inspect the data used by each step for troubleshooting. Logic Apps also provides exis\", \"ting templates you can edit and are well suited for complex enterprise workflows.\\n\\nTo learn more, se\", \"e Azure Logic Apps .\\n\\n## Event Grid\\n\\nAzure Event Grid provides serverless infrastructure for event-b\", \"ased applications. You can publish to Event Grid from any source and consume messages from any platf\", \"orm. Event Grid also has built-in support for events from Azure resources to streamline integration \", \"with your applications. For example, you can subscribe to blob storage events to notify your app whe\", \"n a file is uploaded. Your application can then publish a custom event grid message that is consumed\", \" by other cloud or on-premises applications. Event Grid was built to reliably handle massive scale. \", \"You get the benefits of publishing and subscribing to messages without the overhead of setting up th\", \"e necessary infrastructure.\\n\\nC: \\\\\\n\\n<!-- image -->\\n\\nThe major features of event grid include:\\n\\n- Full\", \"y managed event routing.\\n- Near real -time event delivery at scale.\\n- Broad coverage both inside and\", \" outside of Azure.\\n\\n## Scenarios\\n\\nEvent Grid addresses several different scenarios. This section cov\", \"ers three of the most common ones.\\n\\n## Ops automation\\n\\n<!-- image -->\\n\\nEvent Grid can help speed aut\", \"omation and simplify policy enforcement by notifying Azure Automation when infrastructure is provisi\", \"oned.\\n\\n## Application integration\\n\\n<!-- image -->\\n\\nYou can use Event Grid to connect your app to oth\", \"er services. Using standard HTTP protocols, even legacy apps can be easily modified to publish Event\", \" Grid messages. Web hooks are available for other services and platforms to consume Event Grid messa\", \"ges.\\n\\n## Serverless apps\\n\\n<!-- image -->\\n\\nEvent Grid can trigger Azure Functions, Logic Apps, or you\", \"r own custom code. A major benefit of using Event Grid is that it uses a push mechanism to send mess\", \"ages when events occur. The push architecture consumes fewer resources and scales better than pollin\", \"g mechanisms. Polling must check for updates on a regular interval.\\n\\n## Event Grid vs. other Azure m\", \"essaging services\\n\\nAzure provides several messaging services, including Event Hubs and Service Bus. \", \"Each is designed to address a specific set of use cases. The following diagram provides a high-level\", \" overview of the differences between the services.\\n\\nEvent Hubs\\n\\n\\u2022 \\\"Point in time\\\" data\\n\\n\\u2022 Fast pull\\n\", \"\\n\\u2022 Replay / strict ordering\\n\\n\\u2022 Big data streams\\n\\n<!-- image -->\\n\\nFor a more in -depth comparison, se\", \"e Compare messaging services .\\n\\n## Performance targets\\n\\nUsing Event Grid you can take advantage of t\", \"he following performance guarantees:\\n\\n- Subsecond end -to -end latency in the 99th percentile.\\n- 99.\", \"99% availability.\\n- 10 million events per second per region.\\n- 100 million subscriptions per region.\", \"\\n- 50 -ms publisher latency.\\n- 24 -hour retry with exponential back-off for guaranteed delivery in t\", \"he 1-day window.\\n- Transparent regional failover.\\n\\n## Event Grid schema\\n\\nEvent Grid uses a standard \", \"schema to wrap custom events. The schema is like an envelope that wraps your custom data element. He\", \"re is an example Event Grid message:\\n\\n```\\n[{ \\\"id\\\": \\\"03e24f21 -a955 -43cc -8921 -1f61a6081ce0\\\" , \\\"eve\", \"ntType\\\": \\\"myCustomEvent\\\" , \\\"subject\\\": \\\"foo/bar/12\\\" , \\\"eventTime\\\": \\\"2018 -09 -22T10:36:01+00:00\\\" , \\\"d\", \"ata\\\": { \\\"favoriteColor\\\": \\\"blue\\\" , \\\"favoriteAnimal\\\": \\\"panther\\\" , \\\"favoritePlanet\\\": \\\"Jupiter\\\" }, \\\"data\", \"Version\\\": \\\"1.0\\\" }]\\n```\\n\\nEverything about the message is standard except the data property. You can i\", \"nspect the message and use the eventType and dataVersion to de-serialize the custom portion of the p\", \"ayload.\\n\\n## Azure resources\\n\\nA major benefit of using Event Grid is the automatic messages produced \", \"by Azure. In Azure, resources automatically publish to a topic that allows you to subscribe for vari\", \"ous events. The following table lists the resource types, message types, and events that are availab\", \"le automatically.\\n\\n| Azure  resource     | Event type                                | Description  \", \"                                                                                                    \", \"  |\\n|---------------------|-------------------------------------------|-----------------------------\", \"---------------------------------------------------------------------------------------|\\n| Azure  su\", \"bscription | Microsoft.Resources.ResourceWriteSuccess  | Raised when a resource create or  update op\", \"eration succeeds.                                                       |\\n|                     | Mi\", \"crosoft.Resources.ResourceWriteFailure  | Raised when a resource create or  update operation fails. \", \"                                                         |\\n|                     | Microsoft.Resourc\", \"es.ResourceWriteCancel   | Raised when a resource create or  update operation is canceled.          \", \"                                          |\\n|                     | Microsoft.Resources.ResourceDele\", \"teSuccess | Raised when a resource delete  operation succeeds.                                      \", \"                           |\\n|                     | Microsoft.Resources.ResourceDeleteFailure | Rai\", \"sed when a resource delete  operation fails.                                                        \", \"            |\\n|                     | Microsoft.Resources.ResourceDeleteCancel  | Raised when a reso\", \"urce delete  operation is canceled. This event  happens when a template deployment  is canceled. |\\n|\", \" Blob storage        | Microsoft.Storage.BlobCreated             | Raised when a blob is created.   \", \"                                                                                  |\\n|               \", \"      | Microsoft.Storage.BlobDeleted             | Raised when a blob is deleted.                  \", \"                                                                   |\\n| Event hubs          | Microso\", \"ft.EventHub.CaptureFileCreated     | Raised when a capture file is created.                         \", \"                                                    |\\n| IoT Hub             | Microsoft.Devices.Devi\", \"ceCreated           | Published when a device is registered  to an IoT hub.                         \", \"                                     |\\n|                     | Microsoft.Devices.DeviceDeleted      \", \"     | Published when a device is deleted  from an IoT hub.                                         \", \"                      |\\n| Resource  groups    | Microsoft.Resources.ResourceWriteSuccess  | Raised w\", \"hen a resource create or  update operation succeeds.                                                \", \"       |\\n|                     | Microsoft.Resources.ResourceWriteFailure  | Raised when a resource \", \"create or  update operation fails.                                                          |\\n|     \", \"                | Microsoft.Resources.ResourceWriteCancel   | Raised when a resource create or  upda\", \"te operation is canceled.                                                    |\\n|                    \", \" | Microsoft.Resources.ResourceDeleteSuccess | Raised when a resource delete  operation succeeds.   \", \"                                                              |\\n|                     | Microsoft.Re\", \"sources.ResourceDeleteFailure | Raised when a resource delete  operation fails.                     \", \"                                               |\\n\\n| Azure  resource   | Event type                  \", \"             | Description                                                                          \", \"                              |\\n|-------------------|------------------------------------------|----\", \"----------------------------------------------------------------------------------------------------\", \"------------|\\n|                   | Microsoft.Resources.ResourceDeleteCancel | Raised when a resourc\", \"e delete  operation is canceled. This event  happens when a template deployment  is canceled. |\\n\\nFor\", \" more information, see Azure Event Grid event schema .\\n\\nYou can access Event Grid from any type of a\", \"pplication, even one that runs on-premises.\\n\\n## Conclusion\\n\\nIn this chapter you learned about the Az\", \"ure serverless platform that is composed of Azure Functions, Logic Apps, and Event Grid. You can use\", \" these resources to build an entirely serverless app architecture, or create a hybrid solution that \", \"interacts with other cloud resources and on-premises servers. Combined with a serverless data platfo\", \"rm such as Azure SQL or CosmosDB, you can build fully managed cloud native applications.\\n\\n## Recomme\", \"nded resources\\n\\n- App service plans\\n- Application Insights\\n- Application Insights Analytics\\n- Azure:\", \" Bring your app to the cloud with serverless Azure Functions\\n- Azure Event Grid\\n- Azure Event Grid e\", \"vent schema\\n- Azure Event Hubs\\n- Azure Functions documentation\\n- Azure Functions triggers and bindin\", \"gs concepts\\n- Azure Logic Apps\\n- Azure Service Bus\\n- Azure Table Storage\\n- Connecting to on-premises\", \" data sources with Azure On-premises Data Gateway\\n- Create your first function in the Azure portal\\n-\", \" Create your first function using the Azure CLI\\n- Create your first function using Visual Studio\\n- F\", \"unctions supported languages\\n- Monitor Azure Functions\\n\\nCHAPTER\\n\\n4C\\n\\n## Durable Azure Functions\\n\\nWhe\", \"n creating serverless applications with Azure Functions, your operations will typically be designed \", \"to run in a stateless manner. The reason for this design choice is because as the platform scales, i\", \"t becomes difficult to know what servers the code is running on. It also becomes difficult to know h\", \"ow many instances are active at any given point. However, there are classes of applications that req\", \"uire the current state of a process to be known. Consider the process of submitting an order to an o\", \"nline store. The checkout operation might be a workflow that is composed of multiple operations that\", \" need to know the state of the process. Such information may include the product inventory, if the c\", \"ustomer has any credits on their account, and also the results of processing the credit card. These \", \"operations could easily be their own internal workflows or even services from third-party systems.\\n\\n\", \"Various patterns exist today that assist with the coordination of application state between internal\", \" and external systems. It's common to come across solutions that rely on centralized queuing systems\", \", distributed key-value stores, or shared databases to manage that state. However, these are all add\", \"itional resources that now need to be provisioned and managed. In a serverless environment, your cod\", \"e could become cumbersome trying to coordinate with these resources manually. Azure Functions offers\", \" an alternative for creating stateful functions called Durable Functions.\\n\\nDurable Functions is an e\", \"xtension to the Azure Functions runtime that enables the definition of stateful workflows in code. B\", \"y breaking down workflows into activities, the Durable Functions extension can manage state, create \", \"progress checkpoints, and handle the distribution of function calls across servers. In the backgroun\", \"d, it makes use of an Azure Storage account to persist execution history, schedule activity function\", \"s and retrieve responses. Your serverless code should never interact with persisted information in t\", \"hat storage account, and is typically not something with which developers need to interact.\\n\\n## Trig\", \"gering a stateful workflow\\n\\nStateful workflows in Durable Functions can be broken down into two intr\", \"insic components; orchestration and activity triggers. Triggers and bindings are core components use\", \"d by Azure Functions to enable your serverless functions to be notified when to start, receive input\", \", and return results.\\n\\n## Working with the Orchestration client\\n\\nOrchestrations are unique when comp\", \"ared to other styles of triggered operations in Azure Functions. Durable Functions enables the execu\", \"tion of functions that may take hours or even days to complete. That type of behavior comes with the\", \" need to able to check the status of a running orchestration, preemptively terminate, or send notifi\", \"cations of external events.\\n\\nFor such cases, the Durable Functions extension provides the DurableOrc\", \"hestrationClient class that allows you to interact with orchestrated functions. You get access to th\", \"e orchestration client by using the OrchestrationClientAttribute binding. Generally, you would inclu\", \"de this attribute with another trigger type, such as an HttpTrigger or ServiceBusTrigger. Once the s\", \"ource function has been triggered, the orchestration client can be used to start an orchestrator fun\", \"ction.\\n\\n```\\n[FunctionName(\\\"KickOff\\\")] public static async Task<HttpResponseMessage> Run( [HttpTrigge\", \"r(AuthorizationLevel.Function , \\\"POST\\\")]HttpRequestMessage req, [OrchestrationClient ] DurableOrches\", \"trationClient<orchestrationClient>) { OrderRequestData data = await req.Content . ReadAsAsync<OrderR\", \"equestData>(); string instanceId = await orchestrationClient.StartNewAsync(\\\"PlaceOrder\\\", data); retu\", \"rn orchestrationClient.CreateCheckStatusResponse(req, instanceId); }\\n```\\n\\n## The orchestrator functi\", \"on\\n\\nAnnotating a function with the OrchestrationTriggerAttribute in Azure Functions marks that funct\", \"ion as an orchestrator function. It's responsible for managing the various activities that make up y\", \"our stateful workflow.\\n\\nOrchestrator functions are unable to make use of bindings other than the Orc\", \"hestrationTriggerAttribute. This attribute can only be used with a parameter type of DurableOrchestr\", \"ationContext. No other inputs can be used since deserialization of inputs in the function signature \", \"isn't supported. To get inputs provided by the orchestration client, the GetInput&lt;T&gt; method mu\", \"st be used.\\n\\nAlso, the return types of orchestration functions must be either void, Task, or a JSON \", \"serializable value.\\n\\nError handling code has been left out for brevity\\n\\n```\\n[FunctionName(\\\"PlaceOrde\", \"r\\\")] public static async Task<string> PlaceOrder([OrchestrationTrigger] DurableOrchestrationContext \", \"context) { OrderRequestData orderData = context.GetInput<OrderRequestData>(); await context.CallActi\", \"vityAsync<bool>(\\\"CheckAndReserveInventory\\\", orderData); await context.CallActivityAsync<string>(\\\"Pro\", \"cessPayment\\\", orderData); string trackingNumber = await context.CallActivityAsync<string>(\\\"ScheduleS\", \"hipping\\\" , orderData); await context.CallActivityAsync<string>(\\\"EmailCustomer\\\", trackingNumber); ret\", \"urn trackingNumber; }\\n```\\n\\nMultiple instances of an orchestration can be started and running at the \", \"same time. Calling the StartNewAsync method on the DurableOrchestrationClient launches a new instanc\", \"e of the orchestration. The method returns a Task&lt;string&gt; that completes when the orchestratio\", \"n has started.\\n\\nAn exception of type TimeoutException gets thrown if the orchestration hasn't starte\", \"d within 30 seconds.\\n\\nThe completed Task&lt;string&gt; from StartNewAsync should contain the unique \", \"ID of the orchestration instance. This instance ID can be used to invoke operations on that specific\", \" orchestration. The orchestration can be queried for the status or sent event notifications.\\n\\n## The\", \" activity functions\\n\\nActivity functions are the discrete operations that get composed together withi\", \"n an orchestration function to create the workflow. Here is where most of actual work would take pla\", \"ce. They represent the business logic, long running processes, and the puzzle pieces to a larger sol\", \"ution.\\n\\nThe ActivityTriggerAttribute is used to annotate a function parameter of type DurableActivit\", \"yContext. Using the annotation informs the runtime that the function is intended to be used as an ac\", \"tivity function. Input values to activity functions are retrieved using the GetInput&lt;T&gt; method\", \" of the DurableActivityContext parameter.\\n\\nSimilar to orchestration functions, the return types of a\", \"ctivity functions must be either void, Task, or a JSON serializable value.\\n\\nAny unhandled exceptions\", \" that get thrown within activity functions will get sent up to the calling orchestrator function and\", \" presented as a TaskFailedException. At this point, the error can be caught and logged in the orches\", \"trator, and the activity can be retried.\\n\\n```\\n[FunctionName(\\\"CheckAndReserveInventory\\\")] public stat\", \"ic bool CheckAndReserveInventory([ActivityTrigger] DurableActivityContext context) { OrderRequestDat\", \"a orderData = context.GetInput<OrderRequestData>(); // Connect to inventory system and try to reserv\", \"e items return true; }\\n```\\n\\n## Recommended resources\\n\\n- Durable Functions\\n- Bindings for Durable Fun\", \"ctions\\n- Manage instances in Durable Functions\\n\\n## Orchestration patterns\\n\\nDurable Functions makes i\", \"t easier to create stateful workflows that are composed of discrete, long running activities in a se\", \"rverless environment. Since Durable Functions can track the progress of your workflows and periodica\", \"lly checkpoints the execution history, it lends itself to implementing some interesting patterns.\\n\\n#\", \"# Function chaining\\n\\nIn a typical sequential process, activities need to execute one after the other\", \" in a particular order. Optionally, the upcoming activity may require some output from the previous \", \"function. This dependency on the ordering of activities creates a function chain of execution.\\n\\nThe \", \"benefit of using Durable Functions to implement this workflow pattern comes from its ability to do c\", \"heckpointing. If the server crashes, the network times out or some other issue occurs, Durable funct\", \"ions can resume from the last known state and continue running your workflow even if it's on another\", \" server.\\n\\n```\\n[FunctionName(\\\"PlaceOrder\\\")] public static async Task<string> PlaceOrder([Orchestratio\", \"nTrigger] DurableOrchestrationContext context) { OrderRequestData orderData = context.GetInput<Order\", \"RequestData>(); await context.CallActivityAsync<bool>(\\\"CheckAndReserveInventory\\\", orderData); await \", \"context.CallActivityAsync<bool>(\\\"ProcessPayment\\\", orderData); string trackingNumber = await context.\", \"CallActivityAsync<string>(\\\"ScheduleShipping\\\" , orderData); await context.CallActivityAsync<string>(\\\"\", \"EmailCustomer\\\", trackingNumber); return trackingNumber; }\\n```\\n\\nIn the preceding code sample, the Cal\", \"lActivityAsync function is responsible for running a given activity on a virtual machine in the data\", \" center. When the await returns and the underlying Task completes, the execution will be recorded to\", \" the history table. The code in the orchestrator function can make use of any of the familiar constr\", \"ucts of the Task Parallel Library and the async/await keywords.\\n\\nThe following code is a simplified \", \"example of what the ProcessPayment method may look like:\\n\\n```\\n[FunctionName(\\\"ProcessPayment\\\")] publi\", \"c static bool ProcessPayment([ActivityTrigger] DurableActivityContext context) { OrderRequestData or\", \"derData = context.GetInput<OrderRequestData>(); ApplyCoupons(orderData); if(IssuePaymentRequest(orde\", \"rData)) { return true; } return false; }\\n```\\n\\n## Asynchronous HTTP APIs\\n\\nIn some cases, workflows ma\", \"y contain activities that take a relatively long period of time to complete. Imagine a process that \", \"kicks off the backup of media files into blob storage. Depending on the size and quantity of the med\", \"ia files, this backup process may take hours to complete.\\n\\nIn this scenario, the DurableOrchestratio\", \"nClient's ability to check the status of a running workflow becomes useful. When using an HttpTrigge\", \"r to start a workflow, the CreateCheckStatusResponse method can be used to return an instance of Htt\", \"pResponseMessage. This response provides the client with a URI in the payload that can be used to ch\", \"eck the status of the running process.\\n\\n```\\n[FunctionName(\\\"OrderWorkflow\\\")] public static async Task\", \"<HttpResponseMessage> Run( [HttpTrigger(AuthorizationLevel.Function , \\\"POST\\\")]HttpRequestMessage req\", \", [OrchestrationClient ] DurableOrchestrationClient orchestrationClient) { OrderRequestData data = a\", \"wait req.Content . ReadAsAsync<OrderRequestData>(); string instanceId = await orchestrationClient.St\", \"artNewAsync(\\\"PlaceOrder\\\", data); return orchestrationClient.CreateCheckStatusResponse(req, instanceI\", \"d); }\\n```\\n\\nThe sample result below shows the structure of the response payload.\\n\\n```\\n{ \\\"id\\\": \\\"instan\", \"ceId\\\" , \\\"statusQueryGetUri\\\": \\\"http://host/statusUri\\\" , \\\"sendEventPostUri\\\": \\\"http://host/eventUri\\\" , \", \"\\\"terminatePostUri\\\": \\\"http://host/terminateUri\\\" }\\n```\\n\\nUsing your preferred HTTP client, GET requests\", \" can be made to the URI in statusQueryGetUri to inspect the status of the running workflow. The retu\", \"rned status response should resemble the following code.\\n\\n```\\n{ \\\"runtimeStatus\\\": \\\"Running\\\" , \\\"input\\\"\", \": { \\\"$type\\\": \\\"DurableFunctionsDemos.OrderRequestData, DurableFunctionsDemos\\\" }, \\\"output\\\": null , \\\"cr\", \"eatedTime\\\": \\\"2018 -01 -01T00:22:05Z\\\" , \\\"lastUpdatedTime\\\": \\\"2018-01-01T00:22:09Z\\\" }\\n```\\n\\nAs the proce\", \"ss continues, the status response will change to either Failed or Completed. On successful completio\", \"n, the output property in the payload will contain any returned data.\\n\\n## Monitoring\\n\\nFor simple rec\", \"urring tasks, Azure Functions provides the TimerTrigger that can be scheduled based on a CRON expres\", \"sion. The timer works well for simple, short-lived tasks, but there might be scenarios where more fl\", \"exible scheduling is needed. This scenario is when the monitoring pattern and Durable Functions can \", \"help.\\n\\nDurable Functions allows for flexible scheduling intervals, lifetime management, and the crea\", \"tion of multiple monitor processes from a single orchestration function. One use case for this funct\", \"ionality might be to create watchers for stock price changes that complete once a certain threshold \", \"is met.\\n\\n```\\n[FunctionName(\\\"CheckStockPrice\\\")] public static async Task CheckStockPrice([Orchestrati\", \"onTrigger] DurableOrchestrationContext context) { StockWatcherInfo stockInfo = context.GetInput<Stoc\", \"kWatcherInfo>(); const int checkIntervalSeconds = 120; StockPrice initialStockPrice = null; DateTime\", \" fireAt; DateTime exitTime = context.CurrentUtcDateTime . Add(stockInfo.TimeLimit); while (context.C\", \"urrentUtcDateTime < exitTime) { StockPrice currentStockPrice = await context.CallActivityAsync<Stock\", \"Price>(\\\"GetStockPrice\\\", stockInfo); if (initialStockPrice == null) { initialStockPrice = currentStoc\", \"kPrice; fireAt = context.CurrentUtcDateTime . AddSeconds(checkIntervalSeconds); await context.Create\", \"Timer(fireAt, CancellationToken.None); continue; } decimal percentageChange = (initialStockPrice.Pri\", \"ce -currentStockPrice.Price) / ((initialStockPrice.Price + currentStockPrice.Price) / 2); if (Math.A\", \"bs(percentageChange) >= stockInfo.PercentageChange) { // Change threshold detected await context.Cal\", \"lActivityAsync(\\\"NotifyStockPercentageChange\\\" , currentStockPrice); break; } // Sleep til next pollin\", \"g interval fireAt = context.CurrentUtcDateTime . AddSeconds(checkIntervalSeconds); await context.Cre\", \"ateTimer(fireAt, CancellationToken.None); } }\\n```\\n\\nDurableOrchestrationContext's CreateTimer method \", \"sets up the schedule for the next invocation of the loop to check for stock price changes. DurableOr\", \"chestrationContext also has a CurrentUtcDateTime property to get the current DateTime value in UTC. \", \"It's better to use this property instead of DateTime.UtcNow because it's easily mocked for testing.\\n\", \"\\n## Recommended resources\\n\\n- Azure Durable Functions\\n- Unit Testing in .NET Core and .NET Standard\\n\\n\", \"CHAPTER\\n\\n5C\\n\\n## Serverless business scenarios and use cases\\n\\nThere are many use cases and scenarios \", \"for serverless applications. This chapter includes samples that illustrate the different scenarios. \", \"The scenarios include links to related documentation and public source code repositories. The sample\", \"s in this chapter enable you to get started on your own building and implementing serverless solutio\", \"ns.\\n\\n## Big data processing\\n\\nThis example uses serverless to do a map/reduce operation on a big data\", \" set. It determines the average speed of New York Yellow taxi trips per day in 2017.\\n\\nBig Data Proce\", \"ssing: Serverless MapReduce on Azure\\n\\n## Create serverless applications: hands -on lab\\n\\nLearn how to\", \" use functions to execute server -side logic and build serverless architectures.\\n\\n- Choosing the bes\", \"t Azure service for your business\\n- Creating Azure Functions\\n- Using triggers\\n- Chaining functions\\n-\", \" Long -running workflows\\n- Monitoring\\n- Development, testing, and deployment\\n\\nCreate serverless appl\", \"ications\\n\\n## Customer reviews\\n\\nThis sample showcases the new Azure Functions tooling for C# Class Li\", \"braries in Visual Studio. Create a website where customers submit product reviews that are stored in\", \" Azure storage blobs and\\n\\nCosmosDB. Add an Azure Function to perform automated moderation of the cus\", \"tomer reviews using Azure Cognitive Services. Use an Azure storage queue to decouple the website fro\", \"m the function.\\n\\nCustomer Reviews App with Cognitive Services\\n\\n## File processing and validation\\n\\nTh\", \"is example parses a set of CSV files from hypothetical customers. It ensures that all files required\", \" for a customer \\\"batch\\\" are ready, then validates the structure of each file. Different solutions ar\", \"e presented using Azure Functions, Logic Apps, and Durable Functions.\\n\\nFile processing and validatio\", \"n using Azure Functions, Logic Apps, and Durable Functions\\n\\n## Game data visualization\\n\\nAn example o\", \"f how a developer could implement an in-editor data visualization solution for their game. In fact, \", \"an Unreal Engine 4 Plugin and Unity Plugin were developed using this sample as its backend. The serv\", \"ice component is game engine agnostic.\\n\\nIn -editor game telemetry visualization\\n\\n## GraphQL\\n\\nCreate \", \"a serverless function that exposes a GraphQL API.\\n\\nServerless functions for GraphQL\\n\\n## Internet of \", \"Things (IoT) reliable edge relay\\n\\nThis sample implements a new communication protocol to enable reli\", \"able upstream communication from IoT devices. It automates data gap detection and backfill.\\n\\nIoT Rel\", \"iable Edge Relay\\n\\n## Microservices reference architecture\\n\\nA reference architecture that walks you t\", \"hrough the decision-making process involved in designing, developing, and delivering the Rideshare b\", \"y Relecloud application (a fictitious company). It includes hands -on instructions for configuring a\", \"nd deploying all of the architecture's components.\\n\\n## Serverless for mobile\\n\\nAzure Functions are ea\", \"sy to implement and maintain, and accessible through HTTP. They are a great way to implement an API \", \"for a mobile application. Microsoft offers great cross-platform tools for iOS, Android, and Windows \", \"with Xamarin. As such, Xamarin and Azure Functions are working great together. This article shows ho\", \"w to implement an Azure Function in the Azure portal or in Visual Studio at first, and build a cross\", \" -platform client with Xamarin.Forms running on Android, iOS, and Windows.\\n\\nImplementing a simple Az\", \"ure Function with a Xamarin.Forms client\\n\\n## Serverless messaging\\n\\nThis sample shows how to utilize \", \"Durable Functions' fan-out pattern to load an arbitrary number of messages across any number of sess\", \"ions/partitions. It targets Service Bus, Event Hubs, or Storage Queues. The sample also adds the abi\", \"lity to consume those messages with another Azure Function and load the resulting timing data in to \", \"another Event Hub. The data is then ingested into analytics services like Azure Data Explorer.\\n\\nProd\", \"uce and Consume messages through Service Bus, Event Hubs, and Storage Queues with Azure Functions\\n\\n#\", \"# Recommended resources\\n\\n- Big Data Processing: Serverless MapReduce on Azure\\n- Create serverless ap\", \"plications\\n- Customer Reviews App with Cognitive Services\\n- File processing and validation using Azu\", \"re Functions, Logic Apps, and Durable Functions\\n- Implementing a simple Azure Function with a Xamari\", \"n.Forms client\\n- In -editor game telemetry visualization\\n- IoT Reliable Edge Relay\\n- Produce and Con\", \"sume messages through Service Bus, Event Hubs, and Storage Queues with Azure Functions\\n- Serverless \", \"functions for GraphQL\\n- Serverless Microservices reference architecture\\n\\n## Conclusion\\n\\nThe followin\", \"g key takeaways are the most important conclusions from this guide.\\n\\nBenefits of using serverless. S\", \"erverless solutions provide the important benefit of cost savings because serverless is implemented \", \"in a pay-per-use model. Serverless makes it possible to independently scale, test, and deploy indivi\", \"dual components of your application. Serverless is uniquely suited to implement microservices archit\", \"ectures and integrates fully into a DevOps pipeline.\\n\\nCode as a unit of deployment. Serverless abstr\", \"acts the hardware, OS, and runtime away from the application. Serverless enables focusing on busines\", \"s logic in code as the unit of deployment.\\n\\nTriggers and bindings. Serverless eases integration with\", \" storage, APIs, and other cloud resources. Azure Functions provides triggers to execute code and bin\", \"dings to interact with resources.\\n\\nMicroservices. The microservices architecture is becoming the pre\", \"ferred approach for distributed and large or complex mission-critical applications that are based on\", \" multiple independent subsystems in the form of autonomous services. In a microservice -based archit\", \"ecture, the application is built as a collection of services that can be developed, tested, versione\", \"d, deployed, and scaled independently. Serverless is an architecture well -suited for building these\", \" services.\\n\\nServerless platforms. Serverless isn't just about the code. Platforms that support serve\", \"rless architectures include serverless workflows and orchestration, serverless messaging and event s\", \"ervices, and serverless databases.\\n\\nServerless challenges. Serverless introduces challenges related \", \"to distributed application development, such as fragmented and independent data models, resiliency, \", \"versioning, and service discovery. Serverless may not be ideally suited to long running processes or\", \" components that benefit from tighter coupling.\\n\\nServerless as a tool, not the toolbox. Serverless i\", \"s not the exclusive solution to application architecture. It is a tool that can be leveraged as part\", \" of a hybrid application that may contain traditional tiers, monolith back ends, and containers. Ser\", \"verless can be used to enhance existing solutions and is not an all -or-nothing approach to applicat\", \"ion development.\\n\\nCHAPTER\\n\\n6C\"]"