<h1>Book title</h1>
<h3>Book subtitle Author Name</h3>
<p>PUBLISHED BY</p>
<p>DevDiv, .NET and Visual Studio produc teams<br />
A division of Microsoft Corporation<br />
One Microsoft Way<br />
Redmond, Washington 98052-6399</p>
<p>Copyright © 2017 by Microsoft Corporation</p>
<p>All rights reserved. No part of the contents of this book may be reproduced or transmitted in any<br />
form or by any means without the written permission of the publisher.</p>
<p>This book is provided “as-is” and expresses the author’s views and opinions. The views, opinions and<br />
information expressed in this book, including URL and other Internet website references, may change<br />
without notice.</p>
<p>Some examples depicted herein are provided for illustration only and are fictitious. No real association<br />
or connection is intended or should be inferred.</p>
<p>Microsoft and the trademarks listed at http://www.microsoft.com on the “Trademarks” webpage are<br />
trademarks of the Microsoft group of companies. All other marks are property of their respective<br />
owners.</p>
<p><strong>Author:</strong> David Britch<br />
<strong>Developer:</strong> Javier Suarez Ruiz (Plain Concepts)<br />
<strong>Participants and reviewers:</strong> Craig Dunn, Tom Opgenorth<br />
<strong>Editor:</strong> John Meade (Populus Group)</p>
<h1>Contents</h1>
<p><strong>Preface ........................................................................................................................... iv</strong></p>
<p><strong>Purpose .................................................................................................................................. iv</strong></p>
<p>What's left out of this guide's scope .............................................................................................. iv<br />
Who should use this guide ............................................................................................................. iv<br />
How to use this guide ...................................................................................................................... v</p>
<p><strong>Introduction .................................................................................................................... 1</strong></p>
<p><strong>Sample application ................................................................................................................... 2</strong></p>
<p>Sample application architecture...................................................................................................... 2<br />
Mobile app ....................................................................................................................................... 4<br />
<strong>eShopOnContainers.Core project</strong> ................................................................................................... 5<br />
<strong>Platform projects</strong> ............................................................................................................................ 6<br />
<strong>Summary ................................................................................................................................. 6</strong></p>
<p><strong>MVVM ............................................................................................................................. 7</strong></p>
<p><strong>The MVVM pattern .................................................................................................................. 7</strong></p>
<p>View ................................................................................................................................................. 8<br />
ViewModel ....................................................................................................................................... 8<br />
Model ............................................................................................................................................... 9<br />
<strong>Connecting view models to views ............................................................................................. 9</strong></p>
<p>Creating a view model declaratively .............................................................................................10<br />
Creating a view model programmatically .....................................................................................10<br />
Creating a view defined as a data template ..................................................................................11<br />
Automatically creating a view model with a view model locator .................................................11<br />
<strong>Updating views in response to changes in the underlying view model or model ....................... 12</strong><br />
<strong>UI interaction using commands and behaviors ........................................................................ 13</strong></p>
<p>Implementing commands ..............................................................................................................14<br />
Implementing behaviors ................................................................................................................15<br />
<strong>Summary ............................................................................................................................... 17</strong></p>
<p><strong>Dependency injection .................................................................................................... 18</strong></p>
<p><strong>Introduction to dependency injection ..................................................................................... 18</strong><br />
<strong>Registration ........................................................................................................................... 20</strong><br />
<strong>Resolution .............................................................................................................................. 22</strong><br />
<strong>Managing the lifetime of resolved objects ............................................................................... 22</strong><br />
<strong>Summary ............................................................................................................................... 23</strong></p>
<p>i</p>
<p><strong>Communicating between loosely coupled components .................................................. 24</strong></p>
<p><strong>Introduction to MessagingCenter ............................................................................................ 24</strong><br />
<strong>Defining a message................................................................................................................. 26</strong><br />
<strong>Publishing a message .............................................................................................................. 26</strong><br />
<strong>Subscribing to a message ........................................................................................................ 27</strong><br />
<strong>Unsubscribing from a message................................................................................................ 27</strong><br />
<strong>Summary ............................................................................................................................... 27</strong></p>
<p><strong>Navigation ..................................................................................................................... 28</strong></p>
<p><strong>Navigating between pages ...................................................................................................... 29</strong></p>
<p>Creating the NavigationService instance .......................................................................................29<br />
Handling navigation requests ........................................................................................................30<br />
Navigating when the app is launched ...........................................................................................32<br />
Passing parameters during navigation ..........................................................................................33<br />
Invoking navigation using behaviors .............................................................................................34<br />
Confirming or cancelling navigation ..............................................................................................34<br />
<strong>Summary ............................................................................................................................... 35</strong></p>
<p><strong>Validation ...................................................................................................................... 36</strong></p>
<p><strong>Specifying validation rules ...................................................................................................... 37</strong><br />
<strong>Adding validation rules to a property ...................................................................................... 38</strong><br />
<strong>Triggering validation ............................................................................................................... 39</strong></p>
<p>Triggering validation manually ......................................................................................................39<br />
Triggering validation when properties change..............................................................................40<br />
<strong>Displaying validation errors .................................................................................................... 40</strong></p>
<p>Highlighting a control that contains invalid data ..........................................................................41<br />
Displaying error messages .............................................................................................................44<br />
<strong>Summary ............................................................................................................................... 45</strong></p>
<p><strong>Configuration management ........................................................................................... 46</strong></p>
<p><strong>Creating a settings class .......................................................................................................... 46</strong><br />
<strong>Adding a setting ..................................................................................................................... 47</strong><br />
<strong>Data binding to user settings .................................................................................................. 48</strong><br />
<strong>Summary ............................................................................................................................... 50</strong></p>
<p><strong>Containerized microservices ........................................................................................... 51</strong></p>
<p><strong>Microservices ......................................................................................................................... 52</strong><br />
<strong>Containerization ..................................................................................................................... 53</strong><br />
<strong>Communication between client and microservices .................................................................. 55</strong><br />
<strong>Communication between microservices .................................................................................. 56</strong><br />
<strong>Summary ............................................................................................................................... 58</strong></p>
<p><strong>Authentication and authorization .................................................................................. 59</strong></p>
<p><strong>Authentication ....................................................................................................................... 59</strong></p>
<p>Issuing bearer tokens using IdentityServer 4 ................................................................................60<br />
Adding IdentityServer to a web application ..................................................................................60<br />
Configuring IdentityServer ............................................................................................................61</p>
<p>ii</p>
<p>Performing authentication ............................................................................................................64<br />
<strong>Authorization ......................................................................................................................... 69</strong></p>
<p>Configuring IdentityServer to perform authorization ...................................................................70<br />
Making access requests to APIs .....................................................................................................71<br />
<strong>Summary ............................................................................................................................... 71</strong></p>
<p><strong>Accessing remote data ................................................................................................... 73</strong></p>
<p><strong>Introduction to Representational State Transfer...................................................................... 73</strong><br />
<strong>Consuming RESTful APIs ......................................................................................................... 74</strong></p>
<p>Making web requests ....................................................................................................................74<br />
<strong>Caching data .......................................................................................................................... 81</strong></p>
<p>Managing data expiration .............................................................................................................82<br />
Caching images ..............................................................................................................................82<br />
<strong>Increasing resilience ............................................................................................................... 83</strong></p>
<p>Retry pattern .................................................................................................................................83<br />
Circuit breaker pattern ..................................................................................................................84<br />
<strong>Summary ............................................................................................................................... 85</strong></p>
<p><strong>Unit testing .................................................................................................................... 86</strong></p>
<p><strong>Dependency injection and unit testing .................................................................................... 86</strong><br />
<strong>Testing MVVM applications .................................................................................................... 87</strong></p>
<p>Testing asynchronous functionality...............................................................................................88<br />
Testing INotifyPropertyChanged implementations.......................................................................88<br />
Testing message-based communication .......................................................................................89<br />
Testing exception handling ............................................................................................................89<br />
Testing validation ..........................................................................................................................90<br />
<strong>Summary ............................................................................................................................... 91</strong></p>
<p>iii</p>
<h1>Preface</h1>
<h4>Purpose</h4>
<p>This eBook provides guidance on building cross-platform enterprise apps using Xamarin.Forms.<br />
Xamarin.Forms is a cross-platform UI toolkit that allows developers to easily create native user<br />
interface layouts that can be shared across platforms, including iOS, Android, and the Universal<br />
Windows Platform (UWP). It provides a comprehensive solution for Business to Employee (B2E),<br />
Business to Business (B2B), and Business to Consumer (B2C) apps, providing the ability to share code<br />
across all target platforms and helping to lower the total cost of ownership (TCO).</p>
<p>The guide provides architectural guidance for developing adaptable, maintainable, and testable<br />
Xamarin.Forms enterprise apps. Guidance is provided on how to implement MVVM, dependency<br />
injection, navigation, validation, and configuration management, while maintaining loose coupling. In<br />
addition, there's also guidance on performing authentication and authorization with IdentityServer,<br />
accessing data from containerized microservices, and unit testing.</p>
<p><a href="https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Mobile">The guide comes with source code for the eShopOnContainers mobile app, and source code for the</a><br />
<a href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers reference app. The eShopOnContainers mobile app is a cross-platform enterprise</a><br />
app developed using Xamarin.Forms, which connects to a series of containerized microservices known<br />
as the eShopOnContainers reference app. However, the eShopOnContainers mobile app can be<br />
configured to consume data from mock services for those who wish to avoid deploying the<br />
containerized microservices.</p>
<h5><strong>What's left out of this guide's scope</strong></h5>
<p>This guide is aimed at readers who are already familiar with Xamarin.Forms. For a detailed<br />
introduction to Xamarin.Forms, see the <a href="https://developer.xamarin.com/guides/xamarin-forms/">Xamarin.Forms documentation</a> on the Xamarin Developer<br />
<a href="https://aka.ms/xamebook">Center, and Creating Mobile Apps with Xamarin.Forms.</a></p>
<p><a href="https://aka.ms/microservicesebook">The guide is complementary to .NET Microservices: Architecture for Containerized .NET Applications,</a><br />
which focuses on developing and deploying containerized microservices. Other guides worth reading<br />
include <a href="http://aka.ms/WebAppEbook">Architecting and Developing Modern Web Applications with ASP.NET Core and Microsoft</a><br />
<a href="http://aka.ms/WebAppEbook">Azure,</a> <a href="http://aka.ms/dockerlifecycleebook">Containerized Docker Application Lifecycle with Microsoft Platform and Tools, and Microsoft</a><br />
<a href="http://aka.ms/MobAppDev/StndPDF">Platform and Tools for Mobile App Development.</a></p>
<h5><strong>Who should use this guide</strong></h5>
<p>The audience for this guide is mainly developers and architects who would like to learn how to<br />
architect and implement cross-platform enterprise apps using Xamarin.Forms.</p>
<p>iv Preface</p>
<p>A secondary audience is technical decision makers who would like to receive an architectural and<br />
technology overview before deciding on what approach to select for cross-platform enterprise app<br />
development using Xamarin.Forms.</p>
<h5><strong>How to use this guide</strong></h5>
<p>This guide focuses on building cross-platform enterprise apps using Xamarin.Forms. As such, it should<br />
be read in its entirety to provide a foundation of understanding such apps and their technical<br />
considerations. The guide, along with its sample app, can also serve as a starting point or reference for<br />
creating a new enterprise app. Use the associated sample app as a template for the new app, or to see<br />
how to organize an app's component parts. Then, refer back to this guide for architectural guidance.</p>
<p>Feel free to forward this guide to team members to help ensure a common understanding of crossplatform enterprise app development using Xamarin.Forms. Having everybody working from a<br />
common set of terminologies and underlying principles will help ensure a consistent application of<br />
architectural patterns and practices.</p>
<p>v Preface</p>
<h1>Introduction</h1>
<p>Regardless of platform, developers of enterprise apps face several challenges:</p>
<ul>
<li>
<p>App requirements that can change over time.</p>
</li>
<li>
<p>New business opportunities and challenges.</p>
</li>
<li>
<p>Ongoing feedback during development that can significantly affect the scope and<br />
requirements of the app.</p>
</li>
</ul>
<p>With these in mind, it's important to build apps that can be easily modified or extended over time.<br />
Designing for such adaptability can be difficult as it requires an architecture that allows individual<br />
parts of the app to be independently developed and tested in isolation without affecting the rest of<br />
the app.</p>
<p>Many enterprise apps are sufficiently complex to require more than one developer. It can be a<br />
significant challenge to decide how to design an app so that multiple developers can work effectively<br />
on different pieces of the app independently, while ensuring that the pieces come together seamlessly<br />
when integrated into the app.</p>
<p>The traditional approach to designing and building an app results in what is referred to as a<br />
<em>monolithic</em> app, where components are tightly coupled with no clear separation between them.<br />
Typically, this monolithic approach leads to apps that are difficult and inefficient to maintain, because<br />
it can be difficult to resolve bugs without breaking other components in the app, and it can be<br />
difficult to add new features or to replace existing features.</p>
<p>An effective remedy for these challenges is to partition an app into discrete, loosely coupled<br />
components that can be easily integrated together into an app. Such an approach offers several<br />
benefits:</p>
<ul>
<li>
<p>It allows individual functionality to be developed, tested, extended, and maintained by<br />
different individuals or teams.</p>
</li>
<li>
<p>It promotes reuse and a clean separation of concerns between the app's horizontal<br />
capabilities, such as authentication and data access, and the vertical capabilities, such as app<br />
specific business functionality. This allows the dependencies and interactions between app<br />
components to be more easily managed.</p>
</li>
<li>
<p>It helps maintain a separation of roles by allowing different individuals, or teams, to focus on<br />
a specific task or piece of functionality according to their expertise. In particular, it provides a<br />
cleaner separation between the user interface and the app's business logic.</p>
</li>
</ul>
<p>However, there are many issues that must be resolved when partitioning an app into discrete, loosely<br />
coupled components. These include:</p>
<ul>
<li>Deciding how to provide a clean separation of concerns between the user interface controls<br />
and their logic. One of the most important decisions when creating a Xamarin.Forms<br />
enterprise app is whether to place business logic in code-behind files, or whether to create a<br />
clean separation of concerns between the user interface controls and their logic, in order to</li>
</ul>
<p>1 CHAPTER 1 | Introduction</p>
<p>make the app more maintainable and testable. For more information, see Model-ViewViewModel.</p>
<ul>
<li>
<p>Determining whether to use a dependency injection container. Dependency injection<br />
containers reduce the dependency coupling between objects by providing a facility to<br />
construct instances of classes with their dependencies injected, and manage their lifetime<br />
based on the configuration of the container. For more information, see Dependency injection.</p>
</li>
<li>
<p>Choosing between platform provided eventing and loosely coupled message-based<br />
communication between components that are inconvenient to link by object and type<br />
references. For more information, see Introduction to Communicating between loosely<br />
coupled components.</p>
</li>
<li>
<p>Deciding how to navigate between pages, including how to invoke navigation, and where<br />
navigation logic should reside. For more information, see Navigation.</p>
</li>
<li>
<p>Determining how to validate user input for correctness. The decision must include how to<br />
validate user input, and how to notify the user about validation errors. For more information,<br />
see Validation.</p>
</li>
<li>
<p>Deciding how to perform authentication, and how to protect resources with authorization. For<br />
more information, see Authentication and authorization.</p>
</li>
<li>
<p>Determining how to access remote data from web services, including how to reliably retrieve<br />
data, and how to cache data. For more information, see Accessing remote data.</p>
</li>
<li>
<p>Deciding how to test the app. For more information, see Unit testing.</p>
</li>
</ul>
<p>This guide provides guidance on these issues, and focuses on the core patterns and architecture for<br />
building a cross-platform enterprise app using Xamarin.Forms. The guidance aims to help to produce<br />
adaptable, maintainable, and testable code, by addressing common Xamarin.Forms enterprise app<br />
development scenarios, and by separating the concerns of presentation, presentation logic, and<br />
entities through support for the Model-View-ViewModel (MVVM) pattern.</p>
<h4>Sample application</h4>
<p>This guide includes a sample application, eShopOnContainers, that's an online store that includes the<br />
following functionality:</p>
<ul>
<li>
<p>Authenticating and authorizing against a backend service.</p>
</li>
<li>
<p>Browsing a catalog of shirts, coffee mugs, and other marketing items.</p>
</li>
<li>
<p>Filtering the catalog.</p>
</li>
<li>
<p>Ordering items from the catalog.</p>
</li>
<li>
<p>Viewing the user's order history.</p>
</li>
<li>
<p>Configuration of settings.</p>
</li>
</ul>
<h5><strong>Sample application architecture</strong></h5>
<p>Figure 1-1 provides a high-level overview of the architecture of the sample application.</p>
<p>2 CHAPTER 1 | Introduction</p>
<p>The sample application ships with three client apps:</p>
<ul>
<li>
<p>An MVC application developed with ASP.NET Core.</p>
</li>
<li>
<p>A Single Page Application (SPA) developed with Angular 2 and Typescript. This approach for<br />
web applications avoids performing a round-trip to the server with each operation.</p>
</li>
<li>
<p>A mobile app developed with Xamarin.Forms, which supports iOS, Android, and the Universal<br />
Windows Platform (UWP).</p>
</li>
</ul>
<p><a href="http://aka.ms/WebAppEbook">For information about the web applications, see Architecting and Developing Modern Web</a><br />
<a href="http://aka.ms/WebAppEbook">Applications with ASP.NET Core and Microsoft Azure.</a></p>
<p>The sample application includes the following backend services:</p>
<ul>
<li>
<p>An identity microservice, which uses ASP.NET Core Identity and IdentityServer.</p>
</li>
<li>
<p>A catalog microservice, which is a data-driven create, read, update, delete (CRUD) service that<br />
consumes an SQL Server database using EntityFramework Core.</p>
</li>
<li>
<p>An ordering microservice, which is a domain-driven service that uses domain-driven design<br />
patterns.</p>
</li>
<li>
<p>A basket microservice, which is a data-driven CRUD service that uses Redis Cache.</p>
</li>
</ul>
<p>These backend services are implemented as microservices using ASP.NET Core MVC, and are<br />
deployed as unique containers within a single Docker host. Collectively, these backend services are<br />
referred to as the eShopOnContainers reference application. Client apps communicate with the<br />
backend services through a Representational State Transfer (REST) web interface. For more<br />
information about microservices and Docker, see Containerized microservices.</p>
<p><a href="https://aka.ms/microservicesebook">For information about the implementation of the backend services, see .NET Microservices:</a><br />
<a href="https://aka.ms/microservicesebook">Architecture for Containerized .NET Applications.</a></p>
<p>3 CHAPTER 1 | Introduction</p>
<h5><strong>Mobile app</strong></h5>
<p>This guide focuses on building cross-platform enterprise apps using Xamarin.Forms, and uses the<br />
eShopOnContainers mobile app as an example. Figure 1-2 shows the pages from the<br />
eShopOnContainers mobile app that provide the functionality outlined earlier.</p>
<p>The mobile app consumes the backend services provided by the eShopOnContainers reference<br />
application. However, it can be configured to consume data from mock services for those who wish to<br />
avoid deploying the backend services.</p>
<p>The eShopOnContainers mobile app exercises the following Xamarin.Forms functionality:</p>
<ul>
<li>
<p>XAML</p>
</li>
<li>
<p>Controls</p>
</li>
<li>
<p>Bindings</p>
</li>
<li>
<p>Converters</p>
</li>
<li>
<p>Styles</p>
</li>
</ul>
<p>4 CHAPTER 1 | Introduction</p>
<ul>
<li>
<p>Animations</p>
</li>
<li>
<p>Commands</p>
</li>
<li>
<p>Behaviors</p>
</li>
<li>
<p>Triggers</p>
</li>
<li>
<p>Effects</p>
</li>
<li>
<p>Custom Renderers</p>
</li>
<li>
<p>MessagingCenter</p>
</li>
<li>
<p>Custom Controls</p>
</li>
</ul>
<p>For more information about this functionality, see the <a href="https://developer.xamarin.com/guides/xamarin-forms/">Xamarin.Forms documentation</a> on the Xamarin<br />
<a href="https://aka.ms/xamebook">Developer Center, and Creating Mobile Apps with Xamarin.Forms.</a></p>
<p>In addition, unit tests are provided for some of the classes in the eShopOnContainers mobile app.</p>
<p><strong>Mobile app solution</strong></p>
<p>The eShopOnContainers mobile app solution organizes the source code and other resources into<br />
projects. All of the projects use folders to organize the source code and other resources into<br />
categories. The following table outlines the projects that make up the eShopOnContainers mobile<br />
app:</p>
<table>
<thead>
<tr>
<th>Project</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>eShopOnContainers.Core</td>
<td>This project is the portable class library (PCL) project<br>that contains the shared code and shared UI.</td>
</tr>
<tr>
<td>eShopOnContainers.Droid</td>
<td>This project holds Android specific code and is the<br>entry point for the Android app.</td>
</tr>
<tr>
<td>eShopOnContainers.iOS</td>
<td>This project holds iOS specific code and is the entry<br>point for the iOS app.</td>
</tr>
<tr>
<td>eShopOnContainers.UWP</td>
<td>This project holds Universal Windows Platform (UWP)<br>specific code and is the entry point for the Windows<br>app.</td>
</tr>
<tr>
<td>eShopOnContainers.TestRunner.Droid</td>
<td>This project is the Android test runner for the<br>eShopOnContainers.UnitTests project.</td>
</tr>
<tr>
<td>eShopOnContainers.TestRunner.iOS</td>
<td>This project is the iOS test runner for the<br>eShopOnContainers.UnitTests project.</td>
</tr>
<tr>
<td>eShopOnContainers.TestRunner.Windows</td>
<td>This project is the Universal Windows Platform test<br>runner for the eShopOnContainers.UnitTests project.</td>
</tr>
<tr>
<td>eShopOnContainers.UnitTests<br></td>
<td>This project contains unit tests for the<br>eShopOnContainers.Core project.</td>
</tr>
</tbody>
</table>
<p>The classes from the eShopOnContainers mobile app can be re-used in any Xamarin.Forms app with<br />
little or no modification.</p>
<h5><strong>eShopOnContainers.Core project</strong></h5>
<p>The eShopOnContainers.Core PCL project contains the following folders:</p>
<p>5 CHAPTER 1 | Introduction</p>
<table>
<thead>
<tr>
<th>Folder</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Animations</td>
<td>Contains classes that enable animations to be consumed in XAML.</td>
</tr>
<tr>
<td>Behaviors</td>
<td>Contains behaviors that are exposed to view classes.</td>
</tr>
<tr>
<td>Controls</td>
<td>Contains custom controls used by the app.</td>
</tr>
<tr>
<td>Converters</td>
<td>Contains value converters that apply custom logic to a binding.</td>
</tr>
<tr>
<td>Effects</td>
<td>Contains the<code>EntryLineColorEffect</code> class, which is used to change the border<br>color of specific<code>Entry</code> controls.</td>
</tr>
<tr>
<td>Exceptions</td>
<td>Contains the custom<code>ServiceAuthenticationException</code>.</td>
</tr>
<tr>
<td>Extensions</td>
<td>Contains extension methods for the<code>VisualElement</code> and<code>IEnumerable&lt;T&gt;</code> classes.</td>
</tr>
<tr>
<td>Helpers</td>
<td>Contains helper classes for the app.</td>
</tr>
<tr>
<td>Models</td>
<td>Contains the model classes for the app.</td>
</tr>
<tr>
<td>Properties</td>
<td>Contains<code>AssemblyInfo.cs</code>, a .NET assembly metadata file.</td>
</tr>
<tr>
<td>Services</td>
<td>Contains interfaces and classes that implement services that are provided to the<br>app.</td>
</tr>
<tr>
<td>Triggers</td>
<td>Contains the<code>BeginAnimation</code> trigger, which is used to invoke an animation in<br>XAML.</td>
</tr>
<tr>
<td>Validations</td>
<td>Contains classes involved in validating data input.</td>
</tr>
<tr>
<td>ViewModels</td>
<td>Contains the application logic that's exposed to pages.</td>
</tr>
<tr>
<td>Views<br></td>
<td>Contains the pages for the app.</td>
</tr>
</tbody>
</table>
<h5><strong>Platform projects</strong></h5>
<p>The platform projects contain effect implementations, custom renderer implementations, and other<br />
platform-specific resources.</p>
<h4>Summary</h4>
<p>Xamarin's cross-platform mobile app development tools and platforms provide a comprehensive<br />
solution for B2E, B2B, and B2C mobile client apps, providing the ability to share code across all target<br />
platforms (iOS, Android, and Windows) and helping to lower the total cost of ownership. Apps can<br />
share their user interface and app logic code, while retaining the native platform look and feel.</p>
<p>Developers of enterprise apps face several challenges that can alter the architecture of the app during<br />
development. Therefore, it's important to build an app so that it can be modified or extended over<br />
time. Designing for such adaptability can be difficult, but typically involves partitioning an app into<br />
discrete, loosely coupled components that can be easily integrated together into an app.</p>
<p>6 CHAPTER 1 | Introduction</p>
<h1>MVVM</h1>
<p>The Xamarin.Forms developer experience typically involves creating a user interface in XAML, and then<br />
adding code-behind that operates on the user interface. As apps are modified, and grow in size and<br />
scope, complex maintenance issues can arise. These issues include the tight coupling between the UI<br />
controls and the business logic, which increases the cost of making UI modifications, and the difficulty<br />
of unit testing such code.</p>
<p>The Model-View-ViewModel (MVVM) pattern helps to cleanly separate the business and presentation<br />
logic of an application from its user interface (UI). Maintaining a clean separation between application<br />
logic and the UI helps to address numerous development issues and can make an application easier<br />
to test, maintain, and evolve. It can also greatly improve code re-use opportunities and allows<br />
developers and UI designers to more easily collaborate when developing their respective parts of an<br />
app.</p>
<h4>The MVVM pattern</h4>
<p>There are three core components in the MVVM pattern: the model, the view, and the view model.<br />
Each serves a distinct purpose. Figure 2-1 shows the relationships between the three components.</p>
<p>In addition to understanding the responsibilities of each components, it's also important to<br />
understand how they interact with each other. At a high level, the view &quot;knows about&quot; the view model,<br />
and the view model &quot;knows about&quot; the model, but the model is unaware of the view model, and the<br />
view model is unaware of the view. Therefore, the view model isolates the view from the model, and<br />
allows the model to evolve independently of the view.</p>
<p>The benefits of using the MVVM pattern are as follows:</p>
<ul>
<li>If there's an existing model implementation that encapsulates existing business logic, it can<br />
be difficult or risky to change it. In this scenario, the view model acts as an adapter for the<br />
model classes and enables you to avoid making any major changes to the model code.</li>
</ul>
<p>7 CHAPTER 2 | MVVM</p>
<ul>
<li>
<p>Developers can create unit tests for the view model and the model, without using the view.<br />
The unit tests for the view model can exercise exactly the same functionality as used by the<br />
view.</p>
</li>
<li>
<p>The app UI can be redesigned without touching the code, provided that the view is<br />
implemented entirely in XAML. Therefore, a new version of the view should work with the<br />
existing view model.</p>
</li>
<li>
<p>Designers and developers can work independently and concurrently on their components<br />
during the development process. Designers can focus on the view, while developers can work<br />
on the view model and model components.</p>
</li>
</ul>
<p>The key to using MVVM effectively lies in understanding how to factor app code into the correct<br />
classes, and in understanding how the classes interact. The following sections discuss the<br />
responsibilities of each of the classes in the MVVM pattern.</p>
<h5><strong>View</strong></h5>
<p>The view is responsible for defining the structure, layout, and appearance of what the user sees on<br />
screen. Ideally, each view is defined in XAML, with a limited code-behind that does not contain<br />
business logic. However, in some cases, the code-behind might contain UI logic that implements<br />
visual behavior that is difficult to express in XAML, such as animations.</p>
<p>In a Xamarin.Forms application, a view is typically a <code>Page</code> -derived or <code>ContentView</code> -derived class.<br />
However, views can also be represented by a data template, which specifies the UI elements to be<br />
used to visually represent an object when it's displayed. A data template as a view does not have any<br />
code-behind, and is designed to bind to a specific view model type.</p>
<p>There are several options for executing code on the view model in response to interactions on the<br />
view, such as a button click or item selection. If a control supports commands, the control's <code>Command</code><br />
property can be data-bound to an <code>ICommand</code> property on the view model. When the control's<br />
command is invoked, the code in the view model will be executed. In addition to commands,<br />
behaviors can be attached to an object in the view and can listen for either a command to be invoked<br />
or event to be raised. In response, the behavior can then invoke an <code>ICommand</code> on the view model or a<br />
method on the view model.</p>
<h5><strong>ViewModel</strong></h5>
<p>The view model implements properties and commands to which the view can data bind to, and<br />
notifies the view of any state changes through change notification events. The properties and<br />
commands that the view model provides define the functionality to be offered by the UI, but the view<br />
determines how that functionality is to be displayed.</p>
<p>8 CHAPTER 2 | MVVM</p>
<p>The view model is also responsible for coordinating the view's interactions with any model classes that<br />
are required. There's typically a one-to-many relationship between the view model and the model<br />
classes. The view model might choose to expose model classes directly to the view so that controls in<br />
the view can data bind directly to them. In this case, the model classes will need to be designed to<br />
support data binding and change notification events.</p>
<p>Each view model provides data from a model in a form that the view can easily consume. To<br />
accomplish this, the view model sometimes performs data conversion. Placing this data conversion in<br />
the view model is a good idea because it provides properties that the view can bind to. For example,<br />
the view model might combine the values of two properties to make it easier for display by the view.</p>
<p>In order for the view model to participate in two-way data binding with the view, its properties must<br />
raise the <code>PropertyChanged</code> event. View models satisfy this requirement by implementing the<br />
<code>INotifyPropertyChanged</code> interface, and raising the <code>PropertyChanged</code> event when a property is<br />
changed.</p>
<p>For collections, the view-friendly <code>ObservableCollection&lt;T&gt;</code> is provided. This collection implements<br />
collection changed notification, relieving the developer from having to implement the<br />
<code>INotifyCollectionChanged</code> interface on collections.</p>
<h5><strong>Model</strong></h5>
<p>Model classes are non-visual classes that encapsulate the app's data. Therefore, the model can be<br />
thought of as representing the app's domain model, which usually includes a data model along with<br />
business and validation logic. Examples of model objects include data transfer objects (DTOs), Plain<br />
Old CLR Objects (POCOs), and generated entity and proxy objects.</p>
<p>Model classes are typically used in conjunction with services or repositories that encapsulate data<br />
access and caching.</p>
<h4>Connecting view models to views</h4>
<p>View models can be connected to views by using the data-binding capabilities of Xamarin.Forms.<br />
There are many approaches that can be used to construct views and view models and associate them<br />
at runtime. These approaches fall into two categories, known as view first composition, and view<br />
model first composition. Choosing between view first composition and view model first composition is<br />
an issue of preference and complexity. However, all approaches share the same aim, which is for the<br />
view to have a view model assigned to its <code>BindingContext</code> property.</p>
<p>With view first composition the app is conceptually composed of views that connect to the view<br />
models they depend on. The primary benefit of this approach is that it makes it easy to construct<br />
loosely coupled, unit testable apps because the view models have no dependence on the views<br />
themselves. It's also easy to understand the structure of the app by following its visual structure,<br />
rather than having to track code execution to understand how classes are created and associated. In<br />
addition, view first construction aligns with the Xamarin.Forms navigation system that's responsible<br />
for constructing pages when navigation occurs, which makes a view model first composition complex<br />
and misaligned with the platform.</p>
<p>9 CHAPTER 2 | MVVM</p>
<p>With view model first composition the app is conceptually composed of view models, with a service<br />
being responsible for locating the view for a view model. View model first composition feels more<br />
natural to some developers, since the view creation can be abstracted away, allowing them to focus<br />
on the logical non-UI structure of the app. In addition, it allows view models to be created by other<br />
view models. However, this approach is often complex and it can become difficult to understand how<br />
the various parts of the app are created and associated.</p>
<p>The following sections discuss the main approaches to connecting view models to views.</p>
<h5><strong>Creating a view model declaratively</strong></h5>
<p>The simplest approach is for the view to declaratively instantiate its corresponding view model in<br />
XAML. When the view is constructed, the corresponding view model object will also be constructed.<br />
This approach is demonstrated in the following code example:</p>
<p>When the <code>ContentPage</code> is created, an instance of the <code>LoginViewModel</code> is automatically constructed<br />
and set as the view's <code>BindingContext</code> .</p>
<p>This declarative construction and assignment of the view model by the view has the advantage that<br />
it's simple, but has the disadvantage that it requires a default (parameter-less) constructor in the view<br />
model.</p>
<h5><strong>Creating a view model programmatically</strong></h5>
<p>A view can have code in the code-behind file that results in the view model being assigned to its<br />
BindingContext property. This is often accomplished in the view's constructor, as shown in the<br />
following code example:</p>
<p>The programmatic construction and assignment of the view model within the view's code-behind has<br />
the advantage that it's simple. However, the main disadvantage of this approach is that the view<br />
needs to provide the view model with any required dependencies. Using a dependency injection<br />
container can help to maintain loose coupling between the view and view model. For more<br />
information, see Dependency injection.</p>
<p>10 CHAPTER 2 | MVVM</p>
<h5><strong>Creating a view defined as a data template</strong></h5>
<p>A view can be defined as a data template and associated with a view model type. Data templates can<br />
be defined as resources, or they can be defined inline within the control that will display the view<br />
model. The content of the control is the view model instance, and the data template is used to visually<br />
represent it. This technique is an example of a situation in which the view model is instantiated first,<br />
followed by the creation of the view.</p>
<h5><strong>Automatically creating a view model with a view model locator</strong></h5>
<p>A view model locator is a custom class that manages the instantiation of view models and their<br />
association to views. In the eShopOnContainers mobile app, the <code>ViewModelLocator</code> class has an<br />
attached property, <code>AutoWireViewModel</code>, that's used to associate view models with views. In the view's<br />
XAML, this attached property is set to <code>true</code> to indicate that the view model should be automatically<br />
connected to the view, as shown in the following code example:</p>
<pre><code> viewModelBase:ViewModelLocator.AutoWireViewModel=&quot;true&quot;

</code></pre>
<p>The <code>AutoWireViewModel</code> property is a bindable property that's initialized to <code>false</code>, and when its<br />
value changes the <code>OnAutoWireViewModelChanged</code> event handler is called. This method resolves the<br />
view model for the view. The following code example shows how this is achieved:</p>
<p>The <code>OnAutoWireViewModelChanged</code> method attempts to resolve the view model using a conventionbased approach. This convention assumes that:</p>
<ul>
<li>
<p>View models are in the same assembly as view types.</p>
</li>
<li>
<p>Views are in a .Views child namespace.</p>
</li>
<li>
<p>View models are in a .ViewModels child namespace.</p>
</li>
<li>
<p>View model names correspond with view names and end with &quot;ViewModel&quot;.</p>
</li>
</ul>
<p>11 CHAPTER 2 | MVVM</p>
<p>Finally, the <code>OnAutoWireViewModelChanged</code> method sets the <code>BindingContext</code> of the view type to the<br />
resolved view model type. For more information about resolving the view model type, see Resolution.</p>
<p>This approach has the advantage that an app has a single class that is responsible for the instantiation<br />
of view models and their connection to views.</p>
<h4>Updating views in response to changes in the underlying view model or model</h4>
<p>All view model and model classes that are accessible to a view should implement the<br />
<code>INotifyPropertyChanged</code> interface. Implementing this interface in a view model or model class<br />
allows the class to provide change notifications to any data-bound controls in the view when the<br />
underlying property value changes.</p>
<p>App's should be architected for the correct use of property change notification, by meeting the<br />
following requirements:</p>
<ul>
<li>
<p>Always raising a <code>PropertyChanged</code> event if a public property's value changes. Do not assume<br />
that raising the <code>PropertyChanged</code> event can be ignored because of knowledge of how XAML<br />
binding occurs.</p>
</li>
<li>
<p>Always raising a <code>PropertyChanged</code> event for any calculated properties whose values are used<br />
by other properties in the view model or model.</p>
</li>
<li>
<p>Always raising the <code>PropertyChanged</code> event at the end of the method that makes a property<br />
change, or when the object is known to be in a safe state. Raising the event interrupts the<br />
operation by invoking the event's handlers synchronously. If this happens in the middle of an<br />
operation, it might expose the object to callback functions when it is in an unsafe, partially<br />
updated state. In addition, it's possible for cascading changes to be triggered by<br />
<code>PropertyChanged</code> events. Cascading changes generally require updates to be complete<br />
before the cascading change is safe to execute.</p>
</li>
<li>
<p>Never raising a <code>PropertyChanged</code> event if the property does not change. This means that you<br />
must compare the old and new values before raising the <code>PropertyChanged</code> event.</p>
</li>
<li>
<p>Never raising the <code>PropertyChanged</code> event during a view model's constructor if you are<br />
initializing a property. Data-bound controls in the view will not have subscribed to receive<br />
change notifications at this point.</p>
</li>
<li>
<p>Never raising more than one <code>PropertyChanged</code> event with the same property name<br />
argument within a single synchronous invocation of a public method of a class. For example,<br />
given a <code>NumberOfItems</code> property whose backing store is the <code>_numberOfItems</code> field, if a<br />
method increments <code>_numberOfItems</code> fifty times during the execution of a loop, it should only<br />
raise property change notification on the <code>NumberOfItems</code> property once, after all the work is<br />
complete. For asynchronous methods, raise the <code>PropertyChanged</code> event for a given property<br />
name in each synchronous segment of an asynchronous continuation chain.</p>
</li>
</ul>
<p>The eShopOnContainers mobile app uses the <code>ExtendedBindableObject</code> class to provide change<br />
notifications, which is shown in the following code example:</p>
<p>12 CHAPTER 2 | MVVM</p>
<p>Xamarin.Form's <code>BindableObject</code> class implements the <code>INotifyPropertyChanged</code> interface, and<br />
provides an <code>OnPropertyChanged</code> method. The <code>ExtendedBindableObject</code> class provides the<br />
<code>RaisePropertyChanged</code> method to invoke property change notification, and in doing so uses the<br />
functionality provided by the <code>BindableObject</code> class.</p>
<p>Each view model class in the eShopOnContainers mobile app derives from the <code>ViewModelBase</code> class,<br />
which in turn derives from the <code>ExtendedBindableObject</code> class. Therefore, each view model class uses<br />
the <code>RaisePropertyChanged</code> method in the <code>ExtendedBindableObject</code> class to provide property<br />
change notification. The following code example shows how the eShopOnContainers mobile app<br />
invokes property change notification by using a lambda expression:</p>
<p>Note that using a lambda expression in this way involves a small performance cost because the<br />
lambda expression has to be evaluated for each call. Although the performance cost is small and<br />
would not normally impact an app, the costs can accrue when there are many change notifications.<br />
However, the benefit of this approach is that it provides compile-time type safety and refactoring<br />
support when renaming properties.</p>
<h4>UI interaction using commands and behaviors</h4>
<p>In mobile apps, actions are typically invoked in response to a user action, such as a button click, that<br />
can be implemented by creating an event handler in the code-behind file. However, in the MVVM<br />
pattern, the responsibility for implementing the action lies with the view model, and placing code in<br />
the code-behind should be avoided.</p>
<p>Commands provide a convenient way to represent actions that can be bound to controls in the UI.<br />
They encapsulate the code that implements the action, and help to keep it decoupled from its visual<br />
representation in the view. Xamarin.Forms includes controls that can be declaratively connected to a<br />
command, and these controls will invoke the command when the user interacts with the control.</p>
<p>13 CHAPTER 2 | MVVM</p>
<p>Behaviors also allow controls to be declaratively connected to a command. However, behaviors can be<br />
used to invoke an action that's associated with a range of events raised by a control. Therefore,<br />
behaviors address many of the same scenarios as command-enabled controls, while providing a<br />
greater degree of flexibility and control. In addition, behaviors can also be used to associate command<br />
objects or methods with controls that were not specifically designed to interact with commands.</p>
<h5><strong>Implementing commands</strong></h5>
<p>View models typically expose command properties, for binding from the view, that are object<br />
instances that implement the <code>ICommand</code> interface. A number of Xamarin.Forms controls provide a<br />
<code>Command</code> property, which can be data bound to an <code>ICommand</code> object provided by the view model. The<br />
<code>ICommand</code> interface defines an <code>Execute</code> method, which encapsulates the operation itself, a<br />
<code>CanExecute</code> method, which indicates whether the command can be invoked, and a<br />
<code>CanExecuteChanged</code> event that occurs when changes occur that affect whether the command should<br />
execute. The <code>Command</code> and <code>Command&lt;T&gt;</code> classes, provided by Xamarin.Forms, implement the <code>ICommand</code><br />
interface, where <code>T</code> is the type of the arguments to <code>Execute</code> and <code>CanExecute</code> .</p>
<p>Within a view model, there should be an object of type <code>Command</code> or <code>Command&lt;T&gt;</code> for each public<br />
property in the view model of type <code>ICommand</code> . The <code>Command</code> or <code>Command&lt;T&gt;</code> constructor requires an<br />
<code>Action</code> callback object that's called when the <code>ICommand.Execute</code> method is invoked. The<br />
<code>CanExecute</code> method is an optional constructor parameter, and is a <code>Func</code> that returns a <code>bool</code> .</p>
<p>The following code shows how a <code>Command</code> instance, which represents a register command, is<br />
constructed by specifying a delegate to the <code>Register</code> view model method:</p>
<pre><code> public ICommand RegisterCommand =&gt; new Command(Register);

</code></pre>
<p>The command is exposed to the view through a property that returns a reference to an <code>ICommand</code> .<br />
When the <code>Execute</code> method is called on the <code>Command</code> object, it simply forwards the call to the method<br />
in the view model via the delegate that was specified in the <code>Command</code> constructor.</p>
<p>An asynchronous method can be invoked by a command by using the <code>async</code> and <code>await</code> keywords<br />
when specifying the command's <code>Execute</code> delegate. This indicates that the callback is a <code>Task</code> and<br />
should be awaited. For example, the following code shows how a <code>Command</code> instance, which represents<br />
a sign-in command, is constructed by specifying a delegate to the <code>SignInAsync</code> view model method:</p>
<pre><code> public ICommand SignInCommand =&gt; new Command(async () =&gt; await SignInAsync());

</code></pre>
<p>Parameters can be passed to the <code>Execute</code> and <code>CanExecute</code> actions by using the <code>Command&lt;T&gt;</code> class to<br />
instantiate the command. For example, the following code shows how a <code>Command&lt;T&gt;</code> instance is used<br />
to indicate that the <code>NavigateAsync</code> method will require an argument of type <code>string</code> :</p>
<pre><code> public ICommand NavigateCommand =&gt; new Command&lt;string&gt;(NavigateAsync);

</code></pre>
<p>In both the <code>Command</code> and <code>Command&lt;T&gt;</code> classes, the delegate to the <code>CanExecute</code> method in each<br />
constructor is optional. If a delegate isn't specified, the <code>Command</code> will return <code>true</code> for <code>CanExecute</code> .<br />
However, the view model can indicate a change in the command's <code>CanExecute</code> status by calling the<br />
<code>ChangeCanExecute</code> method on the <code>Command</code> object. This causes the <code>CanExecuteChanged</code> event to be<br />
raised. Any controls in the UI that are bound to the command will then update their enabled status to<br />
reflect the availability of the data-bound command.</p>
<p>14 CHAPTER 2 | MVVM</p>
<p><strong>Invoking commands from a view</strong></p>
<p>The following code example shows how a <code>Grid</code> in the <code>LoginView</code> binds to the <code>RegisterCommand</code> in<br />
the <code>LoginViewModel</code> class by using a <code>TapGestureRecognizer</code> instance:</p>
<p>A command parameter can also be optionally defined using the <code>CommandParameter</code> property. The<br />
type of the expected argument is specified in the <code>Execute</code> and <code>CanExecute</code> target methods. The<br />
<code>TapGestureRecognizer</code> will automatically invoke the target command when the user interacts with<br />
the attached control. The command parameter, if provided, will be passed as the argument to the<br />
command's <code>Execute</code> delegate.</p>
<h5><strong>Implementing behaviors</strong></h5>
<p>Behaviors allow functionality to be added to UI controls without having to subclass them. Instead, the<br />
functionality is implemented in a behavior class and attached to the control as if it was part of the<br />
control itself. Behaviors enable you to implement code that you would normally have to write as<br />
code-behind, because it directly interacts with the API of the control, in such a way that it can be<br />
concisely attached to the control, and packaged for reuse across more than one view or app. In the<br />
context of MVVM, behaviors are a useful approach for connecting controls to commands.</p>
<p>A behavior that's attached to a control through attached properties is known as an <em>attached behavior</em> .<br />
The behavior can then use the exposed API of the element to which it is attached to add functionality<br />
to that control, or other controls, in the visual tree of the view. The eShopOnContainers mobile app<br />
contains the <code>LineColorBehavior</code> class, which is an attached behavior. For more information about<br />
this behavior, see Displaying validation errors.</p>
<p>A Xamarin.Forms behavior is a class that derives from the <code>Behavior</code> or <code>Behavior&lt;T&gt;</code> class, where <code>T</code> is<br />
the type of the control to which the behavior should apply. These classes provide <code>OnAttachedTo</code> and<br />
<code>OnDetachingFrom</code> methods, which should be overridden to provide logic that will be executed when<br />
the behavior is attached to and detached from controls.</p>
<p>In the eShopOnContainers mobile app, the <code>BindableBehavior&lt;T&gt;</code> class derives from the<br />
<code>Behavior&lt;T&gt;</code> class. The purpose of the <code>BindableBehavior&lt;T&gt;</code> class is to provide a base class for<br />
Xamarin.Forms behaviors that require the <code>BindingContext</code> of the behavior to be set to the attached<br />
control.</p>
<p>The <code>BindableBehavior&lt;T&gt;</code> class provides an overridable <code>OnAttachedTo</code> method that sets the<br />
<code>BindingContext</code> of the behavior, and an overridable <code>OnDetachingFrom</code> method that cleans up the<br />
<code>BindingContext</code> . In addition, the class stores a reference to the attached control in the<br />
<code>AssociatedObject</code> property.</p>
<p>The eShopOnContainers mobile app includes an <code>EventToCommandBehavior</code> class, which executes a<br />
command in response to an event occurring. This class derives from the <code>BindableBehavior&lt;View&gt;</code><br />
class so that the behavior can bind to and execute an <code>ICommand</code> specified by a <code>Command</code> property<br />
when the behavior is consumed. The following code example shows the <code>EventToCommandBehavior</code><br />
class:</p>
<p>15 CHAPTER 2 | MVVM</p>
<p>The <code>OnAttachedTo</code> and <code>OnDetachingFrom</code> methods are used to register and deregister an event<br />
handler for the event defined in the <code>EventName</code> property. Then, when the event fires, the <code>OnFired</code><br />
method is invoked, which executes the command.</p>
<p>The advantage of using the <code>EventToCommandBehavior</code> to execute a command when an event fires, is<br />
that commands can be associated with controls that weren't designed to interact with commands. In<br />
addition, this moves event-handling code to view models, where it can be unit tested.</p>
<p><strong>Invoking behaviors from a view</strong></p>
<p>The <code>EventToCommandBehavior</code> is particularly useful for attaching a command to a control that<br />
doesn't support commands. For example, the <code>ProfileView</code> uses the <code>EventToCommandBehavior</code> to<br />
execute the <code>OrderDetailCommand</code> when the <code>ItemTapped</code> event fires on the <code>ListView</code> that lists the<br />
user's orders, as shown in the following code:</p>
<p>16 CHAPTER 2 | MVVM</p>
<p>At runtime, the <code>EventToCommandBehavior</code> will respond to interaction with the <code>ListView</code> . When an<br />
item is selected in the <code>ListView</code>, the <code>ItemTapped</code> event will fire, which will execute the<br />
<code>OrderDetailCommand</code> in the <code>ProfileViewModel</code> . By default, the event arguments for the event are<br />
passed to the command. This data is converted as it's passed between source and target by the<br />
converter specified in the <code>EventArgsConverter</code> property, which returns the <code>Item</code> of the <code>ListView</code><br />
from the I <code>temTappedEventArgs</code> . Therefore, when the <code>OrderDetailCommand</code> is executed, the selected<br />
<code>Order</code> is passed as a parameter to the registered <code>Action</code> .</p>
<p><a href="https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/behaviors/">For more information about behaviors, see Behaviors on the Xamarin Developer Center.</a></p>
<h4>Summary</h4>
<p>The Model-View-ViewModel (MVVM) pattern helps to cleanly separate the business and presentation<br />
logic of an application from its user interface (UI). Maintaining a clean separation between application<br />
logic and the UI helps to address numerous development issues and can make an application easier<br />
to test, maintain, and evolve. It can also greatly improve code re-use opportunities and allows<br />
developers and UI designers to more easily collaborate when developing their respective parts of an<br />
app.</p>
<p>Using the MVVM pattern, the UI of the app and the underlying presentation and business logic is<br />
separated into three separate classes: the view, which encapsulates the UI and UI logic; the view<br />
model, which encapsulates presentation logic and state; and the model, which encapsulates the app's<br />
business logic and data.</p>
<p>17 CHAPTER 2 | MVVM</p>
<h1>Dependency injection</h1>
<p>Typically, a class constructor is invoked when instantiating an object, and any values that the object<br />
needs are passed as arguments to the constructor. This is an example of dependency injection, and<br />
specifically is known as <em>constructor injection</em> . The dependencies the object needs are injected into the<br />
constructor.</p>
<p>By specifying dependencies as interface types, dependency injection enables decoupling of the<br />
concrete types from the code that depends on these types. It generally uses a container that holds a<br />
list of registrations and mappings between interfaces and abstract types, and the concrete types that<br />
implement or extend these types.</p>
<p>There are also other types of dependency injection, such as <em>property setter injection</em>, and <em>method call</em><br />
<em>injection</em>, but they are less commonly seen. Therefore, this chapter will focus solely on performing<br />
constructor injection with a dependency injection container.</p>
<h4>Introduction to dependency injection</h4>
<p>Dependency injection is a specialized version of the Inversion of Control (IoC) pattern, where the<br />
concern being inverted is the process of obtaining the required dependency. With dependency<br />
injection, another class is responsible for injecting dependencies into an object at runtime. The<br />
following code example shows how the <code>ProfileViewModel</code> class is structured when using<br />
dependency injection:</p>
<p>The <code>ProfileViewModel</code> constructor receives an <code>IOrderService</code> instance as an argument, injected by<br />
another class. The only dependency in the <code>ProfileViewModel</code> class is on the interface type.<br />
Therefore, the <code>ProfileViewModel</code> class doesn't have any knowledge of the class that's responsible for<br />
instantiating the <code>IOrderService</code> object. The class that's responsible for instantiating the</p>
<p>18 CHAPTER 3 | Dependency injection</p>
<p><code>IOrderService</code> object, and inserting it into the <code>ProfileViewModel</code> class, is known as the <em>dependency</em><br />
<em>injection container</em> .</p>
<p>Dependency injection containers reduce the coupling between objects by providing a facility to<br />
instantiate class instances and manage their lifetime based on the configuration of the container.<br />
During the objects creation, the container injects any dependencies that the object requires into it. If<br />
those dependencies have not yet been created, the container creates and resolves their dependencies<br />
first.</p>
<p>There are several advantages to using a dependency injection container:</p>
<ul>
<li>
<p>A container removes the need for a class to locate its dependencies and manage their<br />
lifetimes.</p>
</li>
<li>
<p>A container allows mapping of implemented dependencies without affecting the class.</p>
</li>
<li>
<p>A container facilitates testability by allowing dependencies to be mocked.</p>
</li>
<li>
<p>A container increases maintainability by allowing new classes to be easily added to the app.</p>
</li>
</ul>
<p>In the context of a Xamarin.Forms app that uses MVVM, a dependency injection container will<br />
typically be used for registering and resolving view models, and for registering services and injecting<br />
them into view models.</p>
<p>There are many dependency injection containers available, with the eShopOnContainers mobile app<br />
using Autofac to manage the instantiation of view model and service classes in the app. Autofac<br />
facilitates building loosely coupled apps, and provides all of the features commonly found in<br />
dependency injection containers, including methods to register type mappings and object instances,<br />
resolve objects, manage object lifetimes, and inject dependent objects into constructors of objects<br />
that it resolves. For more information about Autofac, see <a href="http://autofac.readthedocs.io/en/latest/index.html">Autofac</a> on readthedocs.io.</p>
<p>In Autofac, the <code>IContainer</code> interface provides the dependency injection container. Figure 3-1 shows<br />
the dependencies when using this container, which instantiates an <code>IOrderService</code> object and injects<br />
it into the <code>ProfileViewModel</code> class.</p>
<p>19 CHAPTER 3 | Dependency injection</p>
<p>At runtime, the container must know which implementation of the <code>IOrderService</code> interface it should<br />
instantiate, before it can instantiate a <code>ProfileViewModel</code> object. This involves:</p>
<ul>
<li>
<p>The container deciding how to instantiate an object that implements the <code>IOrderService</code><br />
interface. This is known as <em>registration</em> .</p>
</li>
<li>
<p>The container instantiating the object that implements the <code>IOrderService</code> interface, and the<br />
<code>ProfileViewModel</code> object. This is known as <em>resolution</em> .</p>
</li>
</ul>
<p>Eventually, the app will finish using the <code>ProfileViewModel</code> object and it will become available for<br />
garbage collection. At this point, the garbage collector should dispose of the <code>IOrderService</code> instance<br />
if other classes do not share the same instance.</p>
<h4>Registration</h4>
<p>Before dependencies can be injected into an object, the types of the dependencies must first be<br />
registered with the container. Registering a type typically involves passing the container an interface<br />
and a concrete type that implements the interface.</p>
<p>There are two ways of registering types and objects in the container through code:</p>
<ul>
<li>
<p>Register a type or mapping with the container. When required, the container will build an<br />
instance of the specified type.</p>
</li>
<li>
<p>Register an existing object in the container as a singleton. When required, the container will<br />
return a reference to the existing object.</p>
</li>
</ul>
<p>The registration of types that require dependency injection should be performed in a single method in<br />
an app, and this method should be invoked early in the app's lifecycle to ensure that the app is aware<br />
of the dependencies between its classes. In the eShopOnContainers mobile app this is performed by<br />
the <code>ViewModelLocator</code> class, which builds the <code>IContainer</code> object and is the only class in the app that<br />
holds a reference to that object. The following code example shows how the eShopOnContainers<br />
mobile app declares the <code>IContainer</code> object in the <code>ViewModelLocator</code> class:</p>
<pre><code> private static IContainer _container;

</code></pre>
<p>Types and instances are registered in the <code>RegisterDependencies</code> method in the <code>ViewModelLocator</code><br />
class. This is achieved by first creating a <code>ContainerBuilder</code> instance, which is demonstrated in the<br />
following code example:</p>
<pre><code> var builder = new ContainerBuilder();

</code></pre>
<p>20 CHAPTER 3 | Dependency injection</p>
<p>Types and instances are then registered with the <code>ContainerBuilder</code> object, and the following code<br />
example demonstrates the most common form of type registration:</p>
<pre><code> builder.RegisterType&lt;RequestProvider&gt;().As&lt;IRequestProvider&gt;();

</code></pre>
<p>The <code>RegisterType</code> method shown here maps an interface type to a concrete type. It tells the<br />
container to instantiate a <code>RequestProvider</code> object when it instantiates an object that requires an<br />
injection of an <code>IRequestProvider</code> through a constructor.</p>
<p>Concrete types can also be registered directly without a mapping from an interface type, as shown in<br />
the following code example:</p>
<pre><code> builder.RegisterType&lt;ProfileViewModel&gt;();

</code></pre>
<p>When the <code>ProfileViewModel</code> type is resolved, the container will inject its required dependencies.</p>
<p>Autofac also allows instance registration, where the container is responsible for maintaining a<br />
reference to a singleton instance of a type. For example, the following code example shows how the<br />
eShopOnContainers mobile app registers the concrete type to use when a <code>ProfileViewModel</code><br />
instance requires an <code>IOrderService</code> instance:</p>
<pre><code> builder.RegisterType&lt;OrderService&gt;().As&lt;IOrderService&gt;().SingleInstance();

</code></pre>
<p>The <code>RegisterType</code> method shown here maps an interface type to a concrete type. The<br />
<code>SingleInstance</code> method configures the registration so that every dependent object receives the<br />
same shared instance. Therefore, only a single <code>OrderService</code> instance will exist in the container,<br />
which is shared by objects that require an injection of an <code>IOrderService</code> through a constructor.</p>
<p>Instance registration can also be performed with the <code>RegisterInstance</code> method, which is<br />
demonstrated in the following code example:</p>
<pre><code> builder.RegisterInstance(new OrderMockService()).As&lt;IOrderService&gt;();

</code></pre>
<p>The <code>RegisterInstance</code> method shown here creates a new <code>OrderMockService</code> instance and registers<br />
it with the container. Therefore, only a single <code>OrderMockService</code> instance exists in the container,<br />
which is shared by objects that require an injection of an <code>IOrderService</code> through a constructor.</p>
<p>Following type and instance registration, the <code>IContainer</code> object must be built, which is demonstrated<br />
in the following code example:</p>
<pre><code> _container = builder.Build();

</code></pre>
<p>Invoking the <code>Build</code> method on the <code>ContainerBuilder</code> instance builds a new dependency injection<br />
container that contains the registrations that have been made.</p>
<p>21 CHAPTER 3 | Dependency injection</p>
<h4>Resolution</h4>
<p>After a type is registered, it can be resolved or injected as a dependency. When a type is being<br />
resolved and the container needs to create a new instance, it injects any dependencies into the<br />
instance.</p>
<p>Generally, when a type is resolved, one of three things happens:</p>
<p><strong>1.</strong> If the type hasn't been registered, the container throws an exception.</p>
<p><strong>2.</strong> If the type has been registered as a singleton, the container returns the singleton instance. If</p>
<p>this is the first time the type is called for, the container creates it if required, and maintains a<br />
reference to it.</p>
<p><strong>3.</strong> If the type hasn't been registered as a singleton, the container returns a new instance, and</p>
<p>doesn't maintain a reference to it.</p>
<p>The following code example shows how the <code>RequestProvider</code> type that was previously registered<br />
with Autofac can be resolved:</p>
<pre><code> var requestProvider = _container.Resolve&lt;IRequestProvider&gt;();

</code></pre>
<p>In this example, Autofac is asked to resolve the concrete type for the <code>IRequestProvider</code> type, along<br />
with any dependencies. Typically, the <code>Resolve</code> method is called when an instance of a specific type is<br />
required. For information about controlling the lifetime of resolved objects, see Managing the lifetime<br />
of resolved objects.</p>
<p>The following code example shows how the eShopOnContainers mobile app instantiates view model<br />
types and their dependencies:</p>
<pre><code> var viewModel = _container.Resolve(viewModelType);

</code></pre>
<p>In this example, Autofac is asked to resolve the view model type for a requested view model, and the<br />
container will also resolve any dependencies. When resolving the <code>ProfileViewModel</code> type, the<br />
dependency to resolve is an <code>IOrderService</code> object. Therefore, Autofac first constructs an<br />
<code>OrderService</code> object and then passes it to the constructor of the <code>ProfileViewModel</code> class. For more<br />
information about how the eShopOnContainers mobile app constructs view models and associates<br />
them to views, see Automatically creating a view model with a view model locator.</p>
<h4>Managing the lifetime of resolved objects</h4>
<p>After registering a type, the default behavior for Autofac is to create a new instance of the registered<br />
type each time the type is resolved, or when the dependency mechanism injects instances into other<br />
classes. In this scenario, the container doesn't hold a reference to the resolved object. However, when<br />
registering an instance, the default behavior for Autofac is to manage the lifetime of the object as a<br />
singleton. Therefore, the instance remains in scope while the container is in scope, and is disposed<br />
when the container goes out of scope and is garbage collected, or when code explicitly disposes the<br />
container.</p>
<p>22 CHAPTER 3 | Dependency injection</p>
<p>An Autofac instance scope can be used to specify the singleton behavior for an object that Autofac<br />
creates from a registered type. Autofac instance scopes manage the object lifetimes instantiated by<br />
the container. The default instance scope for the <code>RegisterType</code> method is the<br />
<code>InstancePerDependency</code> scope. However, the <code>SingleInstance</code> scope can be used with the<br />
<code>RegisterType</code> method, so that the container creates or returns a singleton instance of a type when<br />
calling the <code>Resolve</code> method. The following code example shows how Autofac is instructed to create a<br />
singleton instance of the <code>NavigationService</code> class:</p>
<pre><code> builder.RegisterType&lt;NavigationService&gt;().As&lt;INavigationService&gt;().SingleInstance();

</code></pre>
<p>The first time that the <code>INavigationService</code> interface is resolved, the container creates a new<br />
<code>NavigationService</code> object and maintains a reference to it. On any subsequent resolutions of the<br />
<code>INavigationService</code> interface, the container returns a reference to the <code>NavigationService</code> object<br />
that was previously created.</p>
<p><a href="http://autofac.readthedocs.io/en/latest/lifetime/instance-scope.html">Autofac includes additional instance scopes. For more information, see Instance Scope</a> on<br />
readthedocs.io.</p>
<h4>Summary</h4>
<p>Dependency injection enables decoupling of concrete types from the code that depends on these<br />
types. It typically uses a container that holds a list of registrations and mappings between interfaces<br />
and abstract types, and the concrete types that implement or extend these types.</p>
<p>Autofac facilitates building loosely coupled apps, and provides all of the features commonly found in<br />
dependency injection containers, including methods to register type mappings and object instances,<br />
resolve objects, manage object lifetimes, and inject dependent objects into constructors of objects it<br />
resolves.</p>
<p>23 CHAPTER 3 | Dependency injection</p>
<h1>Communicating between loosely coupled components</h1>
<p>The publish-subscribe pattern is a messaging pattern in which publishers send messages without<br />
having knowledge of any receivers, known as subscribers. Similarly, subscribers listen for specific<br />
messages, without having knowledge of any publishers.</p>
<p>Events in .NET implement the publish-subscribe pattern, and are the most simple and straightforward<br />
approach for a communication layer between components if loose coupling is not required, such as a<br />
control and the page that contains it. However, the publisher and subscriber lifetimes are coupled by<br />
object references to each other, and the subscriber type must have a reference to the publisher type.<br />
This can create memory management issues, especially when there are short lived objects that<br />
subscribe to an event of a static or long-lived object. If the event handler isn't removed, the subscriber<br />
will be kept alive by the reference to it in the publisher, and this will prevent or delay the garbage<br />
collection of the subscriber.</p>
<h4>Introduction to MessagingCenter</h4>
<p>The Xamarin.Forms <code>MessagingCenter</code> class implements the publish-subscribe pattern, allowing<br />
message-based communication between components that are inconvenient to link by object and type<br />
references. This mechanism allows publishers and subscribers to communicate without having a<br />
reference to each other, helping to reduce dependencies between components, while also allowing<br />
components to be independently developed and tested.</p>
<p>The <code>MessagingCenter</code> class provides multicast publish-subscribe functionality. This means that there<br />
can be multiple publishers that publish a single message, and there can be multiple subscribers<br />
listening for the same message. Figure 4-1 illustrates this relationship:</p>
<p>24 CHAPTER 4 | Communicating between loosely coupled components</p>
<p>Publishers send messages using the <code>MessagingCenter.Send</code> method, while subscribers listen for<br />
messages using the <code>MessagingCenter.Subscribe</code> method. In addition, subscribers can also<br />
unsubscribe from message subscriptions, if required, with the <code>MessagingCenter.Unsubscribe</code><br />
method.</p>
<p>Internally, the <code>MessagingCenter</code> class uses weak references. This means that it will not keep objects<br />
alive, and will allow them to be garbage collected. Therefore, it should only be necessary to<br />
unsubscribe from a message when a class no longer wishes to receive the message.</p>
<p>The eShopOnContainers mobile app uses the <code>MessagingCenter</code> class to communicate between<br />
loosely coupled components. The app defines three messages:</p>
<ul>
<li>
<p>The <code>AddProduct</code> message is published by the <code>CatalogViewModel</code> class when an item is<br />
added to the shopping basket. In return, the <code>BasketViewModel</code> class subscribes to the<br />
message and increments the number of items in the shopping basket in response. In addition,<br />
the <code>BasketViewModel</code> class also unsubscribes from this message.</p>
</li>
<li>
<p>The <code>Filter</code> message is published by the <code>CatalogViewModel</code> class when the user applies a<br />
brand or type filter to the items displayed from the catalogue. In return, the <code>CatalogView</code><br />
class subscribes to the message and updates the UI so that only items that match the filter<br />
criteria are displayed.</p>
</li>
<li>
<p>The <code>ChangeTab</code> message is published by the <code>MainViewModel</code> class when the<br />
<code>CheckoutViewModel</code> navigates to the <code>MainViewModel</code> following the successful creation and<br />
submission of a new order. In return, the <code>MainView</code> class subscribes to the message and<br />
updates the UI so that the <strong>My profile</strong> tab is active, to show the user's orders.</p>
</li>
</ul>
<p>In the eShopOnContainers mobile app, <code>MessagingCenter</code> is used to update in the UI in response to<br />
an action occurring in another class. Therefore, messages are published on the UI thread, with<br />
subscribers receiving the message on the same thread.</p>
<p>25 CHAPTER 4 | Communicating between loosley coupled components</p>
<p>For more information about <code>MessagingCenter</code> <a href="https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/messaging-center/">, see MessagingCenter</a> on the Xamarin Developer<br />
Center.</p>
<h4>Defining a message</h4>
<p><code>MessagingCenter</code> messages are strings that are used to identify messages. The following code<br />
example shows the messages defined within the eShopOnContainers mobile app:</p>
<p>In this example, messages are defined using constants. The advantage of this approach is that it<br />
provides compile-time type safety and refactoring support.</p>
<h4>Publishing a message</h4>
<p>Publishers notify subscribers of a message with one of the <code>MessagingCenter.Send</code> overloads. The<br />
following code example demonstrates publishing the <code>AddProduct</code> message:</p>
<pre><code> MessagingCenter.Send(this, MessengerKeys.AddProduct, catalogItem);

</code></pre>
<p>In this example, the <code>Send</code> method specifies three arguments:</p>
<ul>
<li>
<p>The first argument specifies the sender class. The sender class must be specified by any<br />
subscribers who wish to receive the message.</p>
</li>
<li>
<p>The second argument specifies the message.</p>
</li>
<li>
<p>The third argument specifies the payload data to be sent to the subscriber. In this case the<br />
payload data is a <code>CatalogItem</code> instance.</p>
</li>
</ul>
<p>The <code>Send</code> method will publish the message, and its payload data, using a fire-and-forget approach.<br />
Therefore, the message is sent even if there are no subscribers registered to receive the message. In<br />
this situation, the sent message is ignored.</p>
<p>26 CHAPTER 4 | Communicating between loosley coupled components</p>
<h4>Subscribing to a message</h4>
<p>Subscribers can register to receive a message using one of the <code>MessagingCenter.Subscribe</code><br />
overloads. The following code example demonstrates how the eShopOnContainers mobile app<br />
subscribes to, and processes, the <code>AddProduct</code> message:</p>
<p>In this example, the <code>Subscribe</code> method subscribes to the <code>AddProduct</code> message, and executes a<br />
callback delegate in response to receiving the message. This callback delegate, specified as a lambda<br />
expression, executes code that updates the UI.</p>
<p>A subscriber might not need to handle every instance of a published message, and this can be<br />
controlled by the generic type arguments that are specified on the <code>Subscribe</code> method. In this<br />
example, the subscriber will only receive <code>AddProduct</code> messages that are sent from the<br />
<code>CatalogViewModel</code> class, whose payload data is a <code>CatalogItem</code> instance.</p>
<h4>Unsubscribing from a message</h4>
<p>Subscribers can unsubscribe from messages they no longer want to receive. This is achieved with one<br />
of the <code>MessagingCenter.Unsubscribe</code> overloads, as demonstrated in the following code example:</p>
<pre><code> MessagingCenter.Unsubscribe&lt;CatalogViewModel, CatalogItem&gt;(this, MessengerKeys.AddProduct);

</code></pre>
<p>In this example, the <code>Unsubscribe</code> method syntax reflects the type arguments specified when<br />
subscribing to receive the <code>AddProduct</code> message.</p>
<h4>Summary</h4>
<p>The Xamarin.Forms <code>MessagingCenter</code> class implements the publish-subscribe pattern, allowing<br />
message-based communication between components that are inconvenient to link by object and type<br />
references. This mechanism allows publishers and subscribers to communicate without having a<br />
reference to each other, helping to reduce dependencies between components, while also allowing<br />
components to be independently developed and tested.</p>
<p>27 CHAPTER 4 | Communicating between loosley coupled components</p>
<h1>Navigation</h1>
<p>Xamarin.Forms includes support for page navigation, which typically results from the user's interaction<br />
with the UI or from the app itself as a result of internal logic-driven state changes. However,<br />
navigation can be complex to implement in apps that use the Model-View-ViewModel (MVVM)<br />
pattern, as the following challenges must be met:</p>
<ul>
<li>
<p>How to identify the view to be navigated to, using an approach that does not introduce tight<br />
coupling and dependencies between views.</p>
</li>
<li>
<p>How to coordinate the process by which the view to be navigated to is instantiated and<br />
initialized. When using MVVM, the view and view model need to be instantiated and<br />
associated with each other via the view's binding context. When an app is using a<br />
dependency injection container, the instantiation of views and view models might require a<br />
specific construction mechanism.</p>
</li>
<li>
<p>Whether to perform view-first navigation, or view model-first navigation. With view-first<br />
navigation, the page to navigate to refers to the name of the view type. During navigation,<br />
the specified view is instantiated, along with its corresponding view model and other<br />
dependent services. An alternative approach is to use view model-first navigation, where the<br />
page to navigate to refers to the name of the view model type.</p>
</li>
<li>
<p>How to cleanly separate the navigational behavior of the app across the views and view<br />
models. The MVVM pattern provides a separation between the app's UI and its presentation<br />
and business logic. However, the navigation behavior of an app will often span the UI and<br />
presentations parts of the app. The user will often initiate navigation from a view, and the<br />
view will be replaced as a result of the navigation. However, navigation might often also need<br />
to be initiated or coordinated from within the view model.</p>
</li>
<li>
<p>How to pass parameters during navigation for initialization purposes. For example, if the user<br />
navigates to a view to update order details, the order data will have to be passed to the view<br />
so that it can display the correct data.</p>
</li>
<li>
<p>How to co-ordinate navigation, to ensure that certain business rules are obeyed. For example,<br />
users might be prompted before navigating away from a view so that they can correct any<br />
invalid data or be prompted to submit or discard any data changes that were made within the<br />
view.</p>
</li>
</ul>
<p>This chapter addresses these challenges by presenting a <code>NavigationService</code> class that's used to<br />
perform view model-first page navigation.</p>
<p>28 CHAPTER 5 | Navigation</p>
<h4>Navigating between pages</h4>
<p>Navigation logic can reside in a view's code-behind, or in a data bound view model. While placing<br />
navigation logic in a view might be the simplest approach, it is not easily testable through unit tests.<br />
Placing navigation logic in view model classes means that the logic can be exercised through unit<br />
tests. In addition, the view model can then implement logic to control navigation to ensure that<br />
certain business rules are enforced. For example, an app might not allow the user to navigate away<br />
from a page without first ensuring that the entered data is valid.</p>
<p>A <code>NavigationService</code> class is typically invoked from view models, in order to promote testability.<br />
However, navigating to views from view models would require the view models to reference views,<br />
and particularly views that the active view model isn't associated with, which is not recommended.<br />
Therefore, the <code>NavigationService</code> presented here specifies the view model type as the target to<br />
navigate to.</p>
<p>The eShopOnContainers mobile app uses the <code>NavigationService</code> class to provide view model-first<br />
navigation. This class implements the <code>INavigationService</code> interface, which is shown in the following<br />
code example:</p>
<p>This interface specifies that an implementing class must provide the following methods:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>InitializeAsync</code></td>
<td>Performs navigation to one of two pages when the app is<br>launched.</td>
</tr>
<tr>
<td><code>NavigateToAsync&lt;T&gt;</code></td>
<td>Performs hierarchical navigation to a specified page.</td>
</tr>
<tr>
<td><code>NavigateToAsync&lt;T&gt;(parameter)</code></td>
<td>Performs hierarchical navigation to a specified page, passing<br>a parameter.</td>
</tr>
<tr>
<td><code>RemoveLastFromBackStackAsync</code></td>
<td>Removes the previous page from the navigation stack.</td>
</tr>
<tr>
<td><code>RemoveBackStackAsync</code><br></td>
<td>Removes all the previous pages from the navigation stack.</td>
</tr>
</tbody>
</table>
<p>In addition, the <code>INavigationService</code> interface specifies that an implementing class must provide a<br />
<code>PreviousPageViewModel</code> property. This property returns the view model type associated with the<br />
previous page in the navigation stack.</p>
<h5><strong>Creating the NavigationService instance</strong></h5>
<p>The <code>NavigationService</code> class, which implements the <code>INavigationService</code> interface, is registered as<br />
a singleton with the Autofac dependency injection container, as demonstrated in the following code<br />
example:</p>
<p>29 CHAPTER 5 | Navigation</p>
<pre><code> builder.RegisterType&lt;NavigationService&gt;().As&lt;INavigationService&gt;().SingleInstance();

</code></pre>
<p>The <code>INavigationService</code> interface is resolved in the <code>ViewModelBase</code> class constructor, as<br />
demonstrated in the following code example:</p>
<pre><code> NavigationService = ViewModelLocator.Resolve&lt;INavigationService&gt;();

</code></pre>
<p>This returns a reference to the <code>NavigationService</code> object that's stored in the Autofac dependency<br />
injection container, which is created by the <code>InitNavigation</code> method in the <code>App</code> class. For more<br />
information, see Navigating when the app is launched.</p>
<p>The <code>ViewModelBase</code> class stores the <code>NavigationService</code> instance in a <code>NavigationService</code> property,<br />
of type <code>INavigationService</code> . Therefore, all view model classes, which derive from the<br />
<code>ViewModelBase</code> class, can use the <code>NavigationService</code> property to access the methods specified by<br />
the <code>INavigationService</code> interface. This avoids the overhead of injecting the <code>NavigationService</code><br />
object from the Autofac dependency injection container into each view model class.</p>
<h5><strong>Handling navigation requests</strong></h5>
<p>Xamarin.Forms provides the <code>NavigationPage</code> class, which implements a hierarchical navigation<br />
experience in which the user is able to navigate through pages, forwards and backwards, as desired.<br />
<a href="https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/navigation/hierarchical/">For more information about hierarchical navigation, see Hierarchical Navigation</a> on the Xamarin<br />
Developer Center.</p>
<p>Rather than use the <code>NavigationPage</code> class directly, the eShopOnContainers app wraps the<br />
<code>NavigationPage</code> class in the <code>CustomNavigationView</code> class, as shown in the following code example:</p>
<p>The purpose of this wrapping is for ease of styling the <code>NavigationPage</code> instance inside the XAML file<br />
for the class.</p>
<p>Navigation is performed inside view model classes by invoking one of the <code>NavigateToAsync</code><br />
methods, specifying the view model type for the page being navigated to, as demonstrated in the<br />
following code example:</p>
<pre><code> await NavigationService.NavigateToAsync&lt;MainViewModel&gt;();

</code></pre>
<p>The following code example shows the <code>NavigateToAsync</code> methods provided by the<br />
<code>NavigationService</code> class:</p>
<p>30 CHAPTER 5 | Navigation</p>
<p>Each method allows any view model class that derives from the <code>ViewModelBase</code> class to perform<br />
hierarchical navigation by invoking the <code>InternalNavigateToAsync</code> method. In addition, the second<br />
<code>NavigateToAsync</code> method enables navigation data to be specified as an argument that's passed to<br />
the view model being navigated to, where it's typically used to perform initialization. For more<br />
information, see Passing parameters during navigation.</p>
<p>The <code>InternalNavigateToAsync</code> method executes the navigation request, and is shown in the<br />
following code example:</p>
<p>31 CHAPTER 5 | Navigation</p>
<p>The <code>InternalNavigateToAsync</code> method performs navigation to a view model by first calling the<br />
<code>CreatePage</code> method. This method locates the view that corresponds to the specified view model type,<br />
and creates and returns an instance of this view type. Locating the view that corresponds to the view<br />
model type uses a convention-based approach, which assumes that:</p>
<ul>
<li>
<p>Views are in the same assembly as view model types.</p>
</li>
<li>
<p>Views are in a .Views child namespace.</p>
</li>
<li>
<p>View models are in a .ViewModels child namespace.</p>
</li>
<li>
<p>View names correspond to view model names, with &quot;Model&quot; removed.</p>
</li>
</ul>
<p>When a view is instantiated, it's associated with its corresponding view model. For more information<br />
about how this occurs, see Automatically creating a view model with a view model locator.</p>
<p>If the view being created is a <code>LoginView</code>, it's wrapped inside a new instance of the<br />
<code>CustomNavigationView</code> class and assigned to the <code>Application.Current.MainPage</code> property.<br />
Otherwise, the <code>CustomNavigationView</code> instance is retrieved, and provided that it isn't <code>null</code>, the<br />
<code>PushAsync</code> method is invoked to push the view being created onto the navigation stack. However, If<br />
the retrieved <code>CustomNavigationView</code> instance is <code>null</code>, the view being created is wrapped inside a<br />
new instance of the <code>CustomNavigationView</code> class and assigned to the<br />
<code>Application.Current.MainPage</code> property. This mechanism ensures that during navigation, pages<br />
are added correctly to the navigation stack both when it's empty, and when it contains data.</p>
<p>After the view is created and navigated to, the <code>InitializeAsync</code> method of the view's associated<br />
view model is executed. For more information, see Passing parameters during navigation.</p>
<h5><strong>Navigating when the app is launched</strong></h5>
<p>When the app is launched, the <code>InitNavigation</code> method in the <code>App</code> class is invoked. The following<br />
code example shows this method:</p>
<p>The method creates a new <code>NavigationService</code> object in the Autofac dependency injection container,<br />
and returns a reference to it, before invoking its <code>InitializeAsync</code> method.</p>
<p>32 CHAPTER 5 | Navigation</p>
<p>The following code example shows the <code>NavigationService</code> <code>InitializeAsync</code> method:</p>
<p>The <code>MainView</code> is navigated to if the app has a cached access token, which is used for authentication.<br />
Otherwise, the <code>LoginView</code> is navigated to.</p>
<p>For more information about the Autofac dependency injection container, see Introduction to<br />
dependency injection.</p>
<h5><strong>Passing parameters during navigation</strong></h5>
<p>One of the <code>NavigateToAsync</code> methods, specified by the <code>INavigationService</code> interface, enables<br />
navigation data to be specified as an argument that's passed to the view model being navigated to,<br />
where it's typically used to perform initialization.</p>
<p>For example, the <code>ProfileViewModel</code> class contains an <code>OrderDetailCommand</code> that's executed when<br />
the user selects an order on the <code>ProfileView</code> page. In turn, this executes the <code>OrderDetailAsync</code><br />
method, which is shown in the following code example:</p>
<p>This method invokes navigation to the <code>OrderDetailViewModel</code>, passing an <code>Order</code> instance that<br />
represents the order that the user selected on the <code>ProfileView</code> page. When the <code>NavigationService</code><br />
class creates the <code>OrderDetailView</code>, the <code>OrderDetailViewModel</code> class is instantiated and assigned to<br />
the view's <code>BindingContext</code> . After navigating to the <code>OrderDetailView</code>, the<br />
<code>InternalNavigateToAsync</code> method executes the <code>InitializeAsync</code> method of the view's associated<br />
view model.</p>
<p>The <code>InitializeAsync</code> method is defined in the <code>ViewModelBase</code> class as a method that can be<br />
overridden. This method specifies an <code>object</code> argument that represents the data to be passed to a<br />
view model during a navigation operation. Therefore, view model classes that want to receive data<br />
from a navigation operation provide their own implementation of the <code>InitializeAsync</code> method to<br />
perform the required initialization. The following code example shows the <code>InitializeAsync</code> method<br />
from the <code>OrderDetailViewModel</code> class:</p>
<p>33 CHAPTER 5 | Navigation</p>
<p>This method retrieves the <code>Order</code> instance that was passed into the view model during the navigation<br />
operation, and uses it to retrieve the full order details from the <code>OrderService</code> instance.</p>
<h5><strong>Invoking navigation using behaviors</strong></h5>
<p>Navigation is usually triggered from a view by a user interaction. For example, the <code>LoginView</code><br />
performs navigation following successful authentication. The following code example shows how the<br />
navigation is invoked by a behavior:</p>
<p>At runtime, the <code>EventToCommandBehavior</code> will respond to interaction with the <code>WebView</code> . When the<br />
<code>WebView</code> navigates to a web page, the <code>Navigating</code> event will fire, which will execute the<br />
<code>NavigateCommand</code> in the <code>LoginViewModel</code> . By default, the event arguments for the event are passed<br />
to the command. This data is converted as it's passed between source and target by the converter<br />
specified in the <code>EventArgsConverter</code> property, which returns the <code>Url</code> from the<br />
<code>WebNavigatingEventArgs</code> . Therefore, when the <code>NavigationCommand</code> is executed, the <code>Url</code> of the web<br />
page is passed as a parameter to the registered <code>Action</code> .</p>
<p>In turn, the <code>NavigationCommand</code> executes the <code>NavigateAsync</code> method, which is shown in the<br />
following code example:</p>
<p>This method invokes navigation to the <code>MainViewModel</code>, and following navigation, removes the<br />
<code>LoginView</code> page from the navigation stack.</p>
<h5><strong>Confirming or cancelling navigation</strong></h5>
<p>An app might need to interact with the user during a navigation operation, so that the user can<br />
confirm or cancel navigation. This might be necessary, for example, when the user attempts to<br />
navigate before having fully completed a data entry page. In this situation, an app should provide a<br />
notification that allows the user to navigate away from the page, or to cancel the navigation operation<br />
before it occurs. This can be achieved in a view model class by using the response from a notification<br />
to control whether or not navigation is invoked.</p>
<p>34 CHAPTER 5 | Navigation</p>
<h4>Summary</h4>
<p>Xamarin.Forms includes support for page navigation, which typically results from the user's interaction<br />
with the UI, or from the app itself, as a result of internal logic-driven state changes. However,<br />
navigation can be complex to implement in apps that use the MVVM pattern.</p>
<p>This chapter presented a <code>NavigationService</code> class, which is used to perform view model-first<br />
navigation from view models. Placing navigation logic in view model classes means that the logic can<br />
be exercised through automated tests. In addition, the view model can then implement logic to<br />
control navigation to ensure that certain business rules are enforced.</p>
<p>35 CHAPTER 5 | Navigation</p>
<h1>Validation</h1>
<p>Any app that accepts input from users should ensure that the input is valid. An app could, for<br />
example, check for input that contains only characters in a particular range, is of a certain length, or<br />
matches a particular format. Without validation, a user can supply data that causes the app to fail.<br />
Validation enforces business rules, and prevents an attacker from injecting malicious data.</p>
<p>In the context of the Model-ViewModel-Model (MVVM) pattern, a view model or model will often be<br />
required to perform data validation and signal any validation errors to the view so that the user can<br />
correct them. The eShopOnContainers mobile app performs synchronous client-side validation of view<br />
model properties and notifies the user of any validation errors by highlighting the control that<br />
contains the invalid data, and by displaying error messages that inform the user of why the data is<br />
invalid. Figure 6-1 shows the classes involved in performing validation in the eShopOnContainers<br />
mobile app.</p>
<p>View model properties that require validation are of type <code>ValidatableObject&lt;T&gt;</code>, and each<br />
<code>ValidatableObject&lt;T&gt;</code> instance has validation rules added to its <code>Validations</code> property. Validation<br />
is invoked from the view model by calling the <code>Validate</code> method of the <code>ValidatableObject&lt;T&gt;</code></p>
<p>36 CHAPTER 6 | Validation</p>
<p>instance, which retrieves the validation rules and executes them against the <code>ValidatableObject&lt;T&gt;</code><br />
<code>Value</code> property. Any validation errors are placed into the <code>Errors</code> property of the<br />
<code>ValidatableObject&lt;T&gt;</code> instance, and the <code>IsValid</code> property of the <code>ValidatableObject&lt;T&gt;</code> instance<br />
is updated to indicate whether validation succeeded or failed.</p>
<p>Property change notification is provided by the <code>ExtendedBindableObject</code> class, and so an <code>Entry</code><br />
control can bind to the <code>IsValid</code> property of <code>ValidatableObject&lt;T&gt;</code> instance in the view model class<br />
to be notified of whether or not the entered data is valid.</p>
<h4>Specifying validation rules</h4>
<p>Validation rules are specified by creating a class that derives from the <code>IValidationRule&lt;T&gt;</code> interface,<br />
which is shown in the following code example:</p>
<p>This interface specifies that a validation rule class must provide a <code>boolean Check</code> method that is used<br />
to perform the required validation, and a <code>ValidationMessage</code> property whose value is the validation<br />
error message that will be displayed if validation fails.</p>
<p>The following code example shows the <code>IsNotNullOrEmptyRule&lt;T&gt;</code> validation rule, which is used to<br />
perform validation of the username and password entered by the user on the <code>LoginView</code> when using<br />
mock services in the eShopOnContainers mobile app:</p>
<p>The <code>Check</code> method returns a <code>boolean</code> indicating whether the <code>value</code> argument is <code>null</code>, empty, or<br />
consists only of whitespace characters.</p>
<p>Although not used by the eShopOnContainers mobile app, the following code example shows a<br />
validation rule for validating email addresses:</p>
<p>37 CHAPTER 6 | Validation</p>
<p>The <code>Check</code> method returns a <code>boolean</code> indicating whether or not the <code>value</code> argument is a valid email<br />
address. This is achieved by searching the <code>value</code> argument for the first occurrence of the regular<br />
expression pattern specified in the <code>Regex</code> constructor. Whether the regular expression pattern has<br />
been found in the input string can be determined by checking the value of the <code>Match</code> object's<br />
<code>Success</code> property.</p>
<h4>Adding validation rules to a property</h4>
<p>In the eShopOnContainers mobile app, view model properties that require validation are declared to<br />
be of type <code>ValidatableObject&lt;T&gt;,</code> where <code>T</code> is the type of the data to be validated. The following<br />
code example shows an example of two such properties:</p>
<p>For validation to occur, validation rules must be added to the <code>Validations</code> collection of each<br />
<code>ValidatableObject&lt;T&gt;</code> instance, as demonstrated in the following code example:</p>
<p>38 CHAPTER 6 | Validation</p>
<p>This method adds the <code>IsNotNullOrEmptyRule&lt;T&gt;</code> validation rule to the <code>Validations</code> collection of<br />
each <code>ValidatableObject&lt;T&gt;</code> instance, specifying values for the validation rule's <code>ValidationMessage</code><br />
property, which specifies the validation error message that will be displayed if validation fails.</p>
<h4>Triggering validation</h4>
<p>The validation approach used in the eShopOnContainers mobile app can manually trigger validation<br />
of a property, and automatically trigger validation when a property changes.</p>
<h5><strong>Triggering validation manually</strong></h5>
<p>Validation can be triggered manually for a view model property. For example, this occurs in the<br />
eShopOnContainers mobile app when the user taps the <strong>Login</strong> button on the <code>LoginView</code>, when using<br />
mock services. The command delegate calls the <code>MockSignInAsync</code> method in the <code>LoginViewModel</code>,<br />
which invokes validation by executing the <code>Validate</code> method, which is shown in the following code<br />
example:</p>
<p>The <code>Validate</code> method performs validation of the username and password entered by the user on the<br />
<code>LoginView</code>, by invoking the <code>Validate</code> method on each <code>ValidatableObject&lt;T&gt;</code> instance. The<br />
following code example shows the <code>Validate</code> method from the <code>ValidatableObject&lt;T&gt;</code> class:</p>
<p>39 CHAPTER 6 | Validation</p>
<p>This method clears the <code>Errors</code> collection, and then retrieves any validation rules that were added to<br />
the object's <code>Validations</code> collection. The <code>Check</code> method for each retrieved validation rule is executed,<br />
and the <code>ValidationMessage</code> property value for any validation rule that fails to validate the data is<br />
added to the <code>Errors</code> collection of the <code>ValidatableObject&lt;T&gt;</code> instance. Finally, the <code>IsValid</code> property<br />
is set, and its value is returned to the calling method, indicating whether validation succeeded or<br />
failed.</p>
<h5><strong>Triggering validation when properties change</strong></h5>
<p>Validation is also automatically triggered whenever a bound property changes. For example, when a<br />
two-way binding in the <code>LoginView</code> sets the <code>UserName</code> or <code>Password</code> property, validation is triggered.<br />
The following code example demonstrates how this occurs:</p>
<p>The <code>Entry</code> control binds to the <code>UserName.Value</code> property of the <code>ValidatableObject&lt;T&gt;</code> instance,<br />
and the control's <code>Behaviors</code> collection has an <code>EventToCommandBehavior</code> instance added to it. This<br />
behavior executes the <code>ValidateUserNameCommand</code> in response to the <code>TextChanged</code> event firing on<br />
the <code>Entry,</code> which is raised when the text in the <code>Entry</code> changes. In turn, the<br />
<code>ValidateUserNameCommand</code> delegate executes the <code>ValidateUserName</code> method, which executes the<br />
<code>Validate</code> method on the <code>ValidatableObject&lt;T&gt;</code> instance. Therefore, every time the user enters a<br />
character in the <code>Entry</code> control for the username, validation of the entered data is performed.</p>
<p>For more information about behaviors, see Implementing behaviors.</p>
<h4>Displaying validation errors</h4>
<p>The eShopOnContainers mobile app notifies the user of any validation errors by highlighting the<br />
control that contains the invalid data with a red line, and by displaying an error message that informs<br />
the user why the data is invalid below the control containing the invalid data. When the invalid data is<br />
corrected, the line changes to black and the error message is removed. Figure 6-2 shows the<br />
<code>LoginView</code> in the eShopOnContainers mobile app when validation errors are present.</p>
<p>40 CHAPTER 6 | Validation</p>
<p><strong>Figure 6-2:</strong> Displaying validation errors during login</p>
<h5><strong>Highlighting a control that contains invalid data</strong></h5>
<p>The <code>LineColorBehavior</code> attached behavior is used to highlight <code>Entry</code> controls where validation<br />
errors have occurred. The following code example shows how the <code>LineColorBehavior</code> attached<br />
behavior is attached to an <code>Entry</code> control:</p>
<p>The <code>Entry</code> control consumes an explicit style, which is shown in the following code example:</p>
<p>This style sets the <code>ApplyLineColor</code> and <code>LineColor</code> attached properties of the <code>LineColorBehavior</code><br />
attached behavior on the <code>Entry</code> <a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/styles/">control. For more information about styles, see Styles</a> on the Xamarin<br />
Developer Center.</p>
<p>When the value of the <code>ApplyLineColor</code> attached property is set, or changes, the <code>LineColorBehavior</code><br />
attached behavior executes the <code>OnApplyLineColorChanged</code> method, which is shown in the following<br />
code example:</p>
<p>41 CHAPTER 6 | Validation</p>
<p>The parameters for this method provide the instance of the control that the behavior is attached to,<br />
and the old and new values of the <code>ApplyLineColor</code> attached property. The <code>EntryLineColorEffect</code><br />
class is added to the control's <code>Effects</code> collection if the <code>ApplyLineColor</code> attached property is <code>true</code>,<br />
otherwise it's removed from the control's <code>Effects</code> collection. For more information about behaviors,<br />
see Implementing behaviors.</p>
<p>The <code>EntryLineColorEffect</code> subclasses the <code>RoutingEffect</code> class, and is shown in the following code<br />
example:</p>
<p>The <code>RoutingEffect</code> class represents a platform-independent effect that wraps an inner effect that's<br />
platform-specific. This simplifies the effect removal process, since there is no compile-time access to<br />
the type information for a platform-specific effect. The <code>EntryLineColorEffect</code> calls the base class<br />
constructor, passing in a parameter consisting of a concatenation of the resolution group name, and<br />
the unique ID that's specified on each platform-specific effect class.</p>
<p>The following code example shows the eShopOnContainers.EntryLineColorEffect implementation for<br />
iOS:</p>
<p>42 CHAPTER 6 | Validation</p>
<p>43 CHAPTER 6 | Validation</p>
<p>The <code>OnAttached</code> method retrieves the native control for the Xamarin.Forms <code>Entry</code> control, and<br />
updates the line color by calling the <code>UpdateLineColor</code> method. The <code>OnElementPropertyChanged</code><br />
override responds to bindable property changes on the <code>Entry</code> control by updating the line color if the<br />
attached <code>LineColor</code> property changes, or the <code>Height</code> property of the <code>Entry</code> changes. For more<br />
<a href="https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/effects/">information about effects, see Effects</a> on the Xamarin Developer Center.</p>
<p>When valid data is entered in the <code>Entry</code> control, it will apply a black line to the bottom of the control,<br />
to indicate that there is no validation error. Figure 6-3 shows an example of this.</p>
<p><strong>Figure 6-3</strong> : Black line indicating no validation error</p>
<p>The <code>Entry</code> control also has a <code>DataTrigger</code> added to its <code>Triggers</code> collection. The following code<br />
example shows the <code>DataTrigger</code> :</p>
<p>This <code>DataTrigger</code> monitors the <code>UserName.IsValid</code> property, and if it's value becomes <code>false</code>, it<br />
executes the <code>Setter</code>, which changes the <code>LineColor</code> attached property of the <code>LineColorBehavior</code><br />
attached behavior to red. Figure 6-4 shows an example of this.</p>
<p><strong>Figure 6-4</strong> : Red line indicating validation error</p>
<p>The line in the <code>Entry</code> control will remain red while the entered data is invalid, otherwise it will change<br />
to black to indicate that the entered data is valid.</p>
<p><a href="https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/triggers/">For more information about Triggers, see Triggers on the Xamarin Developer Center.</a></p>
<h5><strong>Displaying error messages</strong></h5>
<p>The UI displays validation error messages in <code>Label</code> controls below each control whose data failed<br />
validation. The following code example shows the <code>Label</code> that displays a validation error message if<br />
the user has not entered a valid username:</p>
<p>44 CHAPTER 6 | Validation</p>
<p>Each <code>Label</code> binds to the Errors property of the view model object that's being validated. The <code>Errors</code><br />
property is provided by the <code>ValidatableObject&lt;T&gt;</code> class, and is of type <code>List&lt;string&gt;.</code> Because the<br />
<code>Errors</code> property can contain multiple validation errors, the <code>FirstValidationErrorConverter</code><br />
instance is used to retrieve the first error from the collection for display.</p>
<h4>Summary</h4>
<p>The eShopOnContainers mobile app performs synchronous client-side validation of view model<br />
properties and notifies the user of any validation errors by highlighting the control that contains the<br />
invalid data, and by displaying error messages that inform the user why the data is invalid.</p>
<p>View model properties that require validation are of type <code>ValidatableObject&lt;T&gt;</code>, and each<br />
<code>ValidatableObject&lt;T&gt;</code> instance has validation rules added to its <code>Validations</code> property. Validation<br />
is invoked from the view model by calling the <code>Validate</code> method of the <code>ValidatableObject&lt;T&gt;</code><br />
instance, which retrieves the validation rules and executes them against the <code>ValidatableObject&lt;T&gt;</code><br />
<code>Value</code> property. Any validation errors are placed into the <code>Errors</code> property of the<br />
<code>ValidatableObject&lt;T&gt;</code> instance, and the <code>IsValid</code> property of the <code>ValidatableObject&lt;T&gt;</code> instance<br />
is updated to indicate whether validation succeeded or failed.</p>
<p>45 CHAPTER 6 | Validation</p>
<h1>Configuration management</h1>
<p>Settings allow the separation of data that configures the behavior of an app from the code, allowing<br />
the behavior to be changed without rebuilding the app. There are two types of settings: app settings,<br />
and user settings.</p>
<p>App settings are data that an app creates and manages. It can include data such as fixed web service<br />
endpoints, API keys, and runtime state. App settings are tied to the existence of the app and are only<br />
meaningful to that app.</p>
<p>User settings are the customizable settings of an app that affect the behavior of the app and don't<br />
require frequent re-adjustment. For example, an app might let the user specify where to retrieve data<br />
from, and how to display it on the screen.</p>
<p>Xamarin.Forms includes a persistent dictionary that can be used to store settings data. This dictionary<br />
can be accessed using the <code>Application.Current.Properties</code> property, and any data that's placed<br />
into it is saved when the app goes into a sleep state, and is restored when the app resumes or starts<br />
up again. In addition, the <code>Application</code> class also has a <code>SavePropertiesAsync</code> method that allows an<br />
app to have its settings saved when required. For more information about this dictionary, see<br />
<a href="https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/application-class/#Properties_Dictionary">Properties Dictionary on the Xamarin Developer Center.</a></p>
<p>A downside to storing data using the Xamarin.Forms persistent dictionary is that it's not easily data<br />
bound to. Therefore, the eShopOnContainers mobile app uses the Xam.Plugins.Settings library,<br />
<a href="https://www.nuget.org/packages/Xam.Plugins.Settings/">available from NuGet. This library provides a consistent, type-safe, cross-platform approach for</a><br />
persisting and retrieving app and user settings, while using the native settings management provided<br />
by each platform. In addition, it's straightforward to use data binding to access settings data exposed<br />
by the library.</p>
<h4>Creating a settings class</h4>
<p>When using the Xam.Plugins.Settings library, a single <code>static</code> class should be created that will contain<br />
the app and user settings required by the app. The following code example shows the <code>Settings</code> class<br />
in the eShopOnContainers mobile app:</p>
<p>46 CHAPTER 7 | Configuration management</p>
<p>Settings can be read and written through the <code>ISettings</code> API, which is provided by the<br />
Xam.Plugins.Settings library. This library provides a singleton that can be used to access the API,<br />
<code>CrossSettings.Current</code>, and an app's settings class should expose this singleton via an <code>ISettings</code><br />
property.</p>
<h4>Adding a setting</h4>
<p>Each setting consists of a key, a default value, and a property. The following code example shows all<br />
three items for a user setting that represents the base URL for the online services that the<br />
eShopOnContainers mobile app connects to:</p>
<p>The key is always a <code>const string</code> that defines the key name, with the default value for the setting<br />
being a <code>static readonly</code> value of the required type. Providing a default value ensures that a valid<br />
value is available if an unset setting is retrieved.</p>
<p>The <code>UrlBase</code> <code>static</code> property uses two methods from the <code>ISettings</code> API to read or write the setting<br />
value. The <code>ISettings.GetValueOrDefault</code> method is used to retrieve a setting's value from<br />
platform-specific storage. If no value is defined for the setting, its default value is retrieved instead.<br />
Similarly, the <code>ISettings.AddOrUpdateValue</code> method is used to persist a setting's value to platformspecific storage.</p>
<p>47 CHAPTER 7 | Configuration management</p>
<p>Rather that define a default value inside the <code>Settings</code> class, the <code>UrlBaseDefault</code> string obtains its<br />
value from the <code>GlobalSetting</code> class. The following code example shows the <code>BaseEndpoint</code> property<br />
and <code>UpdateEndpoint</code> method in this class:</p>
<p>Each time the <code>BaseEndpoint</code> property is set, the <code>UpdateEndpoint</code> method is called. This method<br />
updates a series of properties, all of which are based on the <code>UrlBase</code> user setting that's provided by<br />
the <code>Settings</code> class that represent different endpoints that the eShopOnContainers mobile app<br />
connects to.</p>
<h4>Data binding to user settings</h4>
<p>In the eShopOnContainers mobile app, the <code>SettingsView</code> exposes two user settings. These settings<br />
allow configuration of whether the app should retrieve data from microservices that are deployed as<br />
Docker containers, or whether the app should retrieve data from mock services that don't require an<br />
internet connection. When choosing to retrieve data from containerized microservices, a base<br />
endpoint URL for the microservices must be specified. Figure 7-1 shows the <code>SettingsView</code> when the<br />
user has chosen to retrieve data from containerized microservices.</p>
<p>48 CHAPTER 7 | Configuration management</p>
<p><strong>Figure 7-1</strong> : User settings exposed by the eShopOnContainers mobile app</p>
<p>Data binding can be used to retrieve and set settings exposed by the <code>Settings</code> class. This is achieved<br />
by controls on the view binding to view model properties that in turn access properties in the<br />
<code>Settings</code> class, and raising a property changed notification if the settings value has changed. For<br />
information about how the eShopOnContainers mobile app constructs view models and associates<br />
them to views, see Automatically creating a view model with a view model locator.</p>
<p>The following code example shows the <code>Entry</code> control from the <code>SettingsView</code> that allows the user to<br />
enter a base endpoint URL for the containerized microservices:</p>
<pre><code> &lt;Entry Text=&quot;{Binding Endpoint, Mode=TwoWay}&quot; /&gt;

</code></pre>
<p>This <code>Entry</code> control binds to the <code>Endpoint</code> property of the <code>SettingsViewModel</code> class, using a two-way<br />
binding. The following code example shows the <code>Endpoint</code> property:</p>
<p>When the Endpoint property is set the <code>UpdateEndpoint</code> method is called, provided that the supplied<br />
value is valid, and property changed notification is raised. The following code example shows the<br />
<code>UpdateEndpoint</code> method:</p>
<p>49 CHAPTER 7 | Configuration management</p>
<p>This method updates the <code>UrlBase</code> property in the <code>Settings</code> class with the base endpoint URL value<br />
entered by the user, which causes it to be persisted to platform-specific storage.</p>
<p>When the <code>SettingsView</code> is navigated to, the <code>InitializeAsync</code> method in the <code>SettingsViewModel</code><br />
class is executed. The following code example shows this method:</p>
<p>The method sets the <code>Endpoint</code> property to the value of the <code>UrlBase</code> property in the <code>Settings</code> class.<br />
Accessing the <code>UrlBase</code> property causes the Xam.Plugins.Settings library to retrieve the settings value<br />
from platform-specific storage. For information about how the <code>InitializeAsync</code> method is invoked,<br />
see Passing parameters during navigation.</p>
<p>This mechanism ensures that whenever a user navigates to the <code>SettingsView</code>, user settings are<br />
retrieved from platform-specific storage and presented through data binding. Then, if the user<br />
changes the settings values, data binding ensures that they are immediately persisted back to<br />
platform-specific storage.</p>
<h4>Summary</h4>
<p>Settings allow the separation of data that configures the behavior of an app from the code, allowing<br />
the behavior to be changed without rebuilding the app. App settings are data that an app creates and<br />
manages, and user settings are the customizable settings of an app that affect the behavior of the app<br />
and don't require frequent re-adjustment.</p>
<p>The Xam.Plugins.Settings library provides a consistent, type-safe, cross-platform approach for<br />
persisting and retrieving app and user settings, and data binding can be used to access settings<br />
created with the library.</p>
<p>50 CHAPTER 7 | Configuration management</p>
<h1>Containerized microservices</h1>
<p>Developing client-server applications has resulted in a focus on building tiered applications that use<br />
specific technologies in each tier. Such applications are often referred to as <em>monolithic</em> applications,<br />
and are packaged onto hardware pre-scaled for peak loads. The main drawbacks of this development<br />
approach are the tight coupling between components within each tier, that individual components<br />
can't be easily scaled, and the cost of testing. A simple update can have unforeseen effects on the rest<br />
of the tier, and so a change to an application component requires its entire tier to be retested and<br />
redeployed.</p>
<p>Particularly concerning in the age of the cloud, is that individual components can't be easily scaled. A<br />
monolithic application contains domain-specific functionality, and is typically divided by functional<br />
layers such as front end, business logic, and data storage. A monolithic application is scaled by<br />
cloning the entire application onto multiple machines, as illustrated in Figure 8-1.</p>
<p><strong>Figure 8-1</strong> : Monolithic application scaling approach</p>
<p>51 CHAPTER 8 | Containerized microservices</p>
<h4>Microservices</h4>
<p>Microservices offer a different approach to application development and deployment, an approach<br />
that's suited to the agility, scale, and reliability requirements of modern cloud applications. A<br />
microservices application is decomposed into independent components that work together to deliver<br />
the application's overall functionality. The term microservice emphasizes that applications should be<br />
composed of services small enough to reflect independent concerns, so that each microservice<br />
implements a single function. In addition, each microservice has well-defined contracts so that other<br />
microservices can communicate and share data with it. Typical examples of microservices include<br />
shopping carts, inventory processing, purchase subsystems, and payment processing.</p>
<p>Microservices can scale-out independently, as compared to giant monolithic applications that scale<br />
together. This means that a specific functional area, that requires more processing power or network<br />
bandwidth to support demand, can be scaled rather than unnecessarily scaling-out other areas of the<br />
application. Figure 8-2 illustrates this approach, where microservices are deployed and scaled<br />
independently, creating instances of services across machines.</p>
<p><strong>Figure 8-2</strong> : Microservices application scaling approach</p>
<p>Microservice scale-out can be nearly instantaneous, allowing an application to adapt to changing<br />
loads. For example, a single microservice in the web-facing functionality of an application might be<br />
the only microservice in the application that needs to scale out to handle additional incoming traffic.</p>
<p>The classic model for application scalability is to have a load-balanced, stateless tier with a shared<br />
external datastore to store persistent data. Stateful microservices manage their own persistent data,<br />
usually storing it locally on the servers on which they are placed, to avoid the overhead of network<br />
access and complexity of cross-service operations. This enables the fastest possible processing of data<br />
and can eliminate the need for caching systems. In addition, scalable stateful microservices usually<br />
partition data among their instances, in order to manage data size and transfer throughput beyond<br />
which a single server can support.</p>
<p>Microservices also support independent updates. This loose coupling between microservices provides<br />
a rapid and reliable application evolution. Their independent, distributed nature supports rolling<br />
updates, where only a subset of instances of a single microservice will update at any given time.<br />
Therefore, if a problem is detected, a buggy update can be rolled back, before all instances update<br />
with the faulty code or configuration. Similarly, microservices typically use schema versioning, so that</p>
<p>52 CHAPTER 8 | Containerized microservices</p>
<p>clients see a consistent version when updates are being applied, regardless of which microservice<br />
instance is being communicated with.</p>
<p>Therefore, microservice applications have many benefits over monolithic applications:</p>
<ul>
<li>
<p>Each microservice is relatively small, easy to manage and evolve.</p>
</li>
<li>
<p>Each microservice can be developed and deployed independently of other services.</p>
</li>
<li>
<p>Each microservice can be scaled-out independently. For example, a catalog service or<br />
shopping basket service might need to be scaled-out more than an ordering service.<br />
Therefore, the resulting infrastructure will more efficiently consume resources when scaling<br />
out.</p>
</li>
<li>
<p>Each microservice isolates any issues. For example, if there is an issue in a service it only<br />
impacts that service. The other services can continue to handle requests.</p>
</li>
<li>
<p>Each microservice can use the latest technologies. Because microservices are autonomous and<br />
run side-by-side, the latest technologies and frameworks can be used, rather than being<br />
forced to use an older framework that might be used by a monolithic application.</p>
</li>
</ul>
<p>However, a microservice based solution also has potential drawbacks:</p>
<ul>
<li>
<p>Choosing how to partition an application into microservices can be challenging, as each<br />
microservice has to be completely autonomous, end-to-end, including responsibility for its<br />
data sources.</p>
</li>
<li>
<p>Developers must implement inter-service communication, which adds complexity and latency<br />
to the application.</p>
</li>
<li>
<p>Atomic transactions between multiple microservices usually aren't possible. Therefore,<br />
business requirements must embrace eventual consistency between microservices.</p>
</li>
<li>
<p>In production, there is an operational complexity in deploying and managing a system<br />
compromised of many independent services.</p>
</li>
<li>
<p>Direct client-to-microservice communication can make it difficult to refactor the contracts of<br />
microservices. For example, over time how the system is partitioned into services might need<br />
to change. A single service might split into two or more services, and two services might<br />
merge. When clients communicate directly with microservices, this refactoring work can break<br />
compatibility with client apps.</p>
</li>
</ul>
<h4>Containerization</h4>
<p>Containerization is an approach to software development in which an application and its versioned set<br />
of dependencies, plus its environment configuration abstracted as deployment manifest files, are<br />
packaged together as a container image, tested as a unit, and deployed to a host operating system.</p>
<p>A container is an isolated, resource controlled, and portable operating environment, where an<br />
application can run without touching the resources of other containers, or the host. Therefore, a<br />
container looks and acts like a newly installed physical computer or a virtual machine.</p>
<p>There are many similarities between containers and virtual machines, as illustrated in Figure 8-3.</p>
<p>53 CHAPTER 8 | Containerized microservices</p>
<p>A container runs an operating system, has a file system, and can be accessed over a network as if it<br />
were a physical or virtual machine. However, the technology and concepts used by containers are very<br />
different from virtual machines. Virtual machines include the applications, the required dependencies,<br />
and a full guest operating system. Containers include the application and its dependencies, but share<br />
the operating system with other containers, running as isolated processes on the host operating<br />
system (aside from Hyper-V containers which run inside of a special virtual machine per container).<br />
Therefore, containers share resources and typically require fewer resources than virtual machines.</p>
<p>The advantage of a container-oriented development and deployment approach is that it eliminates<br />
most of the issues that arise from inconsistent environment setups and the problems that come with<br />
them. In addition, containers permit fast application scale-up functionality by instancing new<br />
containers as required.</p>
<p>The key concepts when creating and working with containers are:</p>
<ul>
<li>
<p>Container Host: The physical or virtual machine configured to host containers. The container<br />
host will run one or more containers.</p>
</li>
<li>
<p>Container Image: An image consists of a union of layered filesystems stacked on top of each<br />
other, and is the basis of a container. An image does not have state and it never changes as<br />
it's deployed to different environments.</p>
</li>
<li>
<p>Container: A container is a runtime instance of an image.</p>
</li>
<li>
<p>Container OS Image: Containers are deployed from images. The container operating system<br />
image is the first layer in potentially many image layers that make up a container. A container<br />
operating system is immutable, and can't be modified.</p>
</li>
<li>
<p>Container Repository: Each time a container image is created, the image and its dependencies<br />
are stored in a local repository. These images can be reused many times on the container<br />
<a href="https://hub.docker.com/">host. The container images can also be stored in a public or private registry, such as Docker</a><br />
Hub, so that they can be used across different container hosts.</p>
</li>
</ul>
<p>54 CHAPTER 8 | Containerized microservices</p>
<p>Enterprises are increasingly adopting containers when implementing microservice based applications,<br />
and Docker has become the standard container implementation that has been adopted by most<br />
software platforms and cloud vendors.</p>
<p>The eShopOnContainers reference application uses Docker to host four containerized back-end<br />
microservices, as illustrated in Figure 8-4.</p>
<p>The architecture of the back-end services in the reference application is decomposed into multiple<br />
autonomous sub-systems in the form of collaborating microservices and containers. Each microservice<br />
provides a single area of functionality: an identity service, a catalog service, an ordering service, and a<br />
basket service.</p>
<p>Each microservice has its own database, allowing it to be fully decoupled from the other<br />
microservices. Where necessary, consistency between databases from different microservices is<br />
achieved using application-level events. For more information, see Communication between<br />
microservices.</p>
<p><a href="https://aka.ms/microservicesebook">For more information about the reference application, see .NET Microservices: Architecture for</a><br />
<a href="https://aka.ms/microservicesebook">Containerized .NET Applications.</a></p>
<h4>Communication between client and microservices</h4>
<p>The eShopOnContainers mobile app communicates with the containerized back-end microservices<br />
using <em>direct client-to-microservice</em> communication, which is shown in Figure 8-5.</p>
<p>55 CHAPTER 8 | Containerized microservices</p>
<p>With direct client-to-microservice communication, the mobile app makes requests to each<br />
microservice directly through its public endpoint, with a different TCP port per microservice. In<br />
production, the endpoint would typically map to the microservice's load balancer, which distributes<br />
requests across the available instances.</p>
<h4>Communication between microservices</h4>
<p>A microservices based application is a distributed system, potentially running on multiple machines.<br />
Each service instance is typically a process. Therefore, services must interact using an inter-process<br />
communication protocol, such as HTTP, TCP, Advanced Message Queuing Protocol (AMQP), or binary<br />
protocols, depending on the nature of each service.</p>
<p>The two common approaches for microservice-to-microservice communication are HTTP based REST<br />
communication when querying for data, and lightweight asynchronous messaging when<br />
communicating updates across multiple microservices.</p>
<p>Asynchronous messaging based event-driven communication is critical when propagating changes<br />
across multiple microservices. With this approach, a microservice publishes an event when something<br />
notable happens, for example, when it updates a business entity. Other microservices subscribe to<br />
these events. Then, when a microservice receives an event, it updates its own business entities, which<br />
might in turn lead to more events being published. This publish-subscribe functionality is usually<br />
achieved with an event bus.</p>
<p>An event bus allows publish-subscribe communication between microservices, without requiring the<br />
components to be explicitly aware of each other, as shown in Figure 8-6.</p>
<p>56 CHAPTER 8 | Containerized microservices</p>
<p>From an application perspective, the event bus is simply a publish-subscribe channel exposed via an<br />
interface. However, the way the event bus is implemented can vary. For example, an event bus<br />
implementation could use RabbitMQ, Azure Service Bus, or other service buses such as NServiceBus<br />
and MassTransit. Figure 8-7 shows how an event bus is used in the eShopOnContainers reference<br />
application.</p>
<p><strong>Figure 8-7:</strong> Asynchronous event-driven communication in the reference application</p>
<p>The eShopOnContainers event bus, implemented using RabbitMQ, provides one-to-many<br />
asynchronous publish-subscribe functionality. This means that after publishing an event, there can be<br />
multiple subscribers listening for the same event. Figure 8-9 illustrates this relationship.</p>
<p>57 CHAPTER 8 | Containerized microservices</p>
<p>This one-to-many communication approach uses events to implement business transactions that span<br />
multiple services, ensuring eventual consistency between the services. An eventual-consistent<br />
transaction consists of a series of distributed steps. Therefore, when the user-profile microservice<br />
receives the <code>UpdateUser</code> command, it updates the user's details in its database and publishes the<br />
<code>UserUpdated</code> event to the event bus. Both the basket microservice and the ordering microservice<br />
have subscribed to receive this event, and in response update their buyer information in their<br />
respective databases.</p>
<p><a href="https://aka.ms/microservicesebook">For information about the event bus implementation, see .NET Microservices: Architecture for</a><br />
<a href="https://aka.ms/microservicesebook">Containerized .NET Applications.</a></p>
<h4>Summary</h4>
<p>Microservices offer an approach to application development and deployment that's suited to the<br />
agility, scale, and reliability requirements of modern cloud applications. One of the main advantages<br />
of microservices is that they can be scaled-out independently, which means that a specific functional<br />
area can be scaled that requires more processing power or network bandwidth to support demand,<br />
without unnecessarily scaling areas of the application that are not experiencing increased demand.</p>
<p>A container is an isolated, resource controlled, and portable operating environment, where an<br />
application can run without touching the resources of other containers, or the host. Enterprises are<br />
increasingly adopting containers when implementing microservice based applications, and Docker has<br />
become the standard container implementation that has been adopted by most software platforms<br />
and cloud vendors.</p>
<p>58 CHAPTER 8 | Containerized microservices</p>
<h1>Authentication and authorization</h1>
<p>Authentication is the process of obtaining identification credentials such as name and password from<br />
a user, and validating those credentials against an authority. If the credentials are valid, the entity that<br />
submitted the credentials is considered an authenticated identity. Once an identity has been<br />
authenticated, an authorization process determines whether that identity has access to a given<br />
resource.</p>
<p>There are many approaches to integrating authentication and authorization into a Xamarin.Forms app<br />
that communicates with an ASP.NET MVC web application, including using ASP.NET Core Identity,<br />
external authentication providers such as Microsoft, Google, Facebook, or Twitter, and authentication<br />
middleware. The eShopOnContainers mobile app performs authentication and authorization with a<br />
containerized identity microservice that uses IdentityServer 4. The mobile app requests security tokens<br />
from IdentityServer, either for authenticating a user or for accessing a resource. For IdentityServer to<br />
issue tokens on behalf of a user, the user must sign-in to IdentityServer. However, IdentityServer<br />
doesn't provide a user interface or database for authentication. Therefore, in the eShopOnContainers<br />
reference application, ASP.NET Core Identity is used for this purpose.</p>
<h4>Authentication</h4>
<p>Authentication is required when an application needs to know the identity of the current user.<br />
ASP.NET Core's primary mechanism for identifying users is the ASP.NET Core Identity membership<br />
system, which stores user information in a data store configured by the developer. Typically, this data<br />
store will be an EntityFramework store, though custom stores or third party packages can be used to<br />
store identity information in Azure storage, DocumentDB, or other locations.</p>
<p>For authentication scenarios that make use of a local user data store, and that persist identity<br />
information between requests via cookies (as is typical in ASP.NET MVC web applications), ASP.NET<br />
Core Identity is a suitable solution. However, cookies are not always a natural means of persisting and<br />
transmitting data. For example, an ASP.NET Core web application that exposes RESTful endpoints that<br />
are accessed from a mobile app will typically need to use bearer token authentication, since cookies<br />
can't be used in this scenario. However, bearer tokens can easily be retrieved and included in the<br />
authorization header of web requests made from the mobile app.</p>
<p>59 CHAPTER 9 | Authentication and authorization</p>
<h5><strong>Issuing bearer tokens using IdentityServer 4</strong></h5>
<p><a href="https://github.com/IdentityServer/IdentityServer4">IdentityServer 4</a> is an open source OpenID Connect and OAuth 2.0 framework for ASP.NET Core,<br />
which can be used for many authentication and authorization scenarios including issuing security<br />
tokens for local ASP.NET Core Identity users.</p>
<p>In applications that use direct client-to-microservice communication, such as the eShopOnContainers<br />
reference application, a dedicated authentication microservice acting as a Security Token Service (STS)<br />
can be used to authenticate users, as shown in Figure 9-1. For more information about direct clientto-microservice communication, see Communication between client and microservices.</p>
<p>The eShopOnContainers mobile app communicates with the identity microservice, which uses<br />
IdentityServer 4 to perform authentication, and access control for APIs. Therefore, the mobile app<br />
requests tokens from IdentityServer, either for authenticating a user or for accessing a resource:</p>
<ul>
<li>
<p>Authenticating users with IdentityServer is achieved by the mobile app requesting an <em>identity</em><br />
token, which represents the outcome of an authentication process. At a bare minimum, it<br />
contains an identifier for the user, and information about how and when the user<br />
authenticated. It can also contain additional identity data.</p>
</li>
<li>
<p>Accessing a resource with IdentityServer is achieved by the mobile app requesting an <em>access</em><br />
token, which allows access to an API resource. Clients request access tokens and forward<br />
them to the API. Access tokens contain information about the client, and the user (if present).<br />
APIs then use that information to authorize access to their data.</p>
</li>
</ul>
<h5><strong>Adding IdentityServer to a web application</strong></h5>
<p>In order for an ASP.NET Core web application to use IdentityServer 4, it must be added to the web<br />
<a href="https://identityserver4.readthedocs.io/en/release/quickstarts/0_overview.html">application's Visual Studio solution. For more information, see Setup and Overview</a> in the<br />
IdentityServer documentation.</p>
<p>60 CHAPTER 9 | Authentication and authorization</p>
<p>Once IdentityServer is included in the web application's Visual Studio solution, it must be added to<br />
the web application's HTTP request processing pipeline, so that it can serve requests to OpenID<br />
Connect and OAuth 2.0 endpoints. This is achieved in the <code>Configure</code> method in the web application's<br />
<code>Startup</code> class, as demonstrated in the following code example:</p>
<p>Order matters in the web application's HTTP request processing pipeline. Therefore, IdentityServer<br />
must be added to the pipeline before the UI framework that implements the login screen.</p>
<h5><strong>Configuring IdentityServer</strong></h5>
<p>IdentityServer should be configured in the <code>ConfigureServices</code> method in the web application's<br />
<code>Startup</code> class by calling the <code>services.AddIdentityServer</code> method, as demonstrated in the<br />
following code example from the eShopOnContainers reference application:</p>
<p>After calling the <code>services.AddIdentityServer</code> method, additional fluent APIs are called to<br />
configure the following:</p>
<ul>
<li>
<p>Credentials used for signing.</p>
</li>
<li>
<p>API and identity resources that users might request access to.</p>
</li>
<li>
<p>Clients that will be connecting to request tokens.</p>
</li>
<li>
<p>ASP.NET Core Identity.</p>
</li>
</ul>
<p><a href="https://identityserver4.readthedocs.io/en/release/quickstarts/6_aspnet_identity.html">For information about configuring IdentityServer to use ASP.NET Core Identity, see Using ASP.NET</a><br />
<a href="https://identityserver4.readthedocs.io/en/release/quickstarts/6_aspnet_identity.html">Core Identity</a> in the IdentityServer documentation.</p>
<p>61 CHAPTER 9 | Authentication and authorization</p>
<p><strong>Configuring API resources</strong></p>
<p>When configuring API resources, the <code>AddInMemoryApiResources</code> method expects an<br />
<code>IEnumerable&lt;ApiResource&gt;</code> collection. The following code example shows the <code>GetApis</code> method that<br />
provides this collection in the eShopOnContainers reference application:</p>
<p>This method specifies that IdentityServer should protect the <code>orders</code> and <code>basket</code> APIs. Therefore,<br />
IdentityServer managed access tokens will be required when making calls to these APIs. For more<br />
information about the <code>ApiResource</code> <a href="https://identityserver4.readthedocs.io/en/release/reference/api_resource.html#refapiresource">type, see API Resource</a> in the IdentityServer 4 documentation.</p>
<p><strong>Configuring identity resources</strong></p>
<p>When configuring identity resources, the <code>AddInMemoryIdentityResources</code> method expects an<br />
<code>IEnumerable&lt;IdentityResource&gt;</code> collection. Identity resources are data such as user ID, name, or<br />
email address. Each identity resource has a unique name, and arbitrary claim types can be assigned to<br />
it, which will then be included in the identity token for the user. The following code example shows<br />
the <code>GetResources</code> method that provides this collection in the eShopOnContainers reference<br />
application:</p>
<p><a href="https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims">The OpenID Connect specification specifies some standard identity resources. The minimum</a><br />
requirement is that support is provided for emitting a unique ID for users. This is achieved by<br />
exposing the <code>IdentityResources.OpenId</code> identity resource.</p>
<p><a href="https://identityserver4.readthedocs.io/en/release/topics/resources.html#defining-custom-identity-resources">IdentityServer also supports defining custom identity resources. For more information, see Defining</a><br />
<a href="https://identityserver4.readthedocs.io/en/release/topics/resources.html#defining-custom-identity-resources">custom identity resources in the IdentityServer documentation. For more information about the</a><br />
<code>IdentityResource</code> type, see <a href="https://identityserver4.readthedocs.io/en/release/reference/identity_resource.html">Identity Resource</a> in the IdentityServer 4 documentation.</p>
<p><strong>Configuring clients</strong></p>
<p>Clients are applications that can request tokens from IdentityServer. Typically, the following settings<br />
must be defined for each client as a minimum:</p>
<ul>
<li>
<p>A unique client ID.</p>
</li>
<li>
<p>The allowed interactions with the token service (known as the grant type).</p>
</li>
<li>
<p>The location where identity and access tokens are sent to (known as a redirect URI).</p>
</li>
</ul>
<p>62 CHAPTER 9 | Authentication and authorization</p>
<ul>
<li>A list of resources that the client is allowed access to (known as scopes).</li>
</ul>
<p>When configuring clients, the <code>AddInMemoryClients</code> method expects an <code>IEnumerable&lt;Client&gt;</code><br />
collection. The following code example shows the configuration for the eShopOnContainers mobile<br />
app in the <code>GetClients</code> method that provides this collection in the eShopOnContainers reference<br />
application:</p>
<p>This configuration specifies data for the following properties:</p>
<ul>
<li>
<p><code>ClientId</code> : A unique ID for the client.</p>
</li>
<li>
<p><code>ClientName</code> : The client display name, which is used for logging and the consent screen.</p>
</li>
<li>
<p><code>AllowedGrantTypes</code> : Specifies how a client wants to interact with IdentityServer. For more<br />
information see Configuring the authentication flow.</p>
</li>
<li>
<p><code>ClientSecrets</code> : Specifies the client secret credentials that are used when requesting tokens<br />
from the token endpoint.</p>
</li>
<li>
<p><code>RedirectUris</code> : Specifies the allowed URIs to which to return tokens or authorization codes.</p>
</li>
<li>
<p><code>RequireConsent</code> : Specifies whether a consent screen is required.</p>
</li>
<li>
<p><code>RequirePkce</code> : Specifies whether clients using an authorization code must send a proof key.</p>
</li>
<li>
<p><code>PostLogoutRedirectUris</code> : Specifies the allowed URIs to redirect to after logout.</p>
</li>
</ul>
<p>63 CHAPTER 9 | Authentication and authorization</p>
<ul>
<li>
<p><code>AllowedCorsOrigins</code> : Specifies the origin of the client so that IdentityServer can allow crossorigin calls from the origin.</p>
</li>
<li>
<p><code>AllowedScopes</code> : Specifies the resources the client has access to. By default, a client has no<br />
access to any resources.</p>
</li>
<li>
<p><code>AllowOfflineAccess</code> : Specifies whether the client can request refresh tokens.</p>
</li>
</ul>
<p><strong>Configuring the authentication flow</strong></p>
<p>The authentication flow between a client and IdentityServer can be configured by specifying the grant<br />
types in the <code>Client.AllowedGrantTypes</code> property. The OpenID Connect and OAuth 2.0 specifications<br />
define a number of authentication flows, including:</p>
<ul>
<li>
<p>Implicit. This flow is optimized for browser-based applications and should be used either for<br />
user authentication-only, or authentication and access token requests. All tokens are<br />
transmitted via the browser, and therefore advanced features like refresh tokens are not<br />
permitted.</p>
</li>
<li>
<p>Authorization code. This flow provides the ability to retrieve tokens on a back channel, as<br />
opposed to the browser front channel, while also supporting client authentication.</p>
</li>
<li>
<p>Hybrid. This flow is a combination of the implicit and authorization code grant types. The<br />
identity token is transmitted via the browser channel and contains the signed protocol<br />
response along with other artifacts such as the authorization code. After successful validation<br />
of the response, the back channel should be used to retrieve the access and refresh token.</p>
</li>
</ul>
<p><a href="https://identityserver4.readthedocs.io/en/release/topics/grant_types.html">For more information about authentication flows, see Grant Types</a> in the IdentityServer 4<br />
documentation.</p>
<h5><strong>Performing authentication</strong></h5>
<p>For IdentityServer to issue tokens on behalf of a user, the user must sign-in to IdentityServer.<br />
However, IdentityServer doesn't provide a user interface or database for authentication. Therefore, in<br />
the eShopOnContainers reference application, ASP.NET Core Identity is used for this purpose.</p>
<p>The eShopOnContainers mobile app authenticates with IdentityServer with the hybrid authentication<br />
flow, which is illustrated in Figure 9-2.</p>
<p>64 CHAPTER 9 | Authentication and authorization</p>
<p>A sign-in request is made to <code>&lt;base endpoint&gt;:5105/connect/authorize</code> . Following successful<br />
authentication, IdentityServer returns an authentication response containing an authorization code<br />
and an identity token. The authorization code is then sent to <code>&lt;base</code><br />
<code>endpoint&gt;:5105/connect/token</code>, which responds with access, identity, and refresh tokens.</p>
<p>The eShopOnContainers mobile app signs-out of IdentityServer by sending a request to<br />
<code>http://&lt;base endpoint&gt;:5105/connect/endsession</code>, with additional parameters. After sign-out<br />
occurs, IdentityServer responds by sending a post logout redirect URI back to the mobile app. Figure<br />
9-3 illustrates this process.</p>
<p>In the eShopOnContainers mobile app, communication with IdentityServer is performed by the<br />
<code>IdentityService</code> class, which implements the <code>IIdentityService</code> interface. This interface specifies<br />
that the implementing class must provide <code>CreateAuthorizationRequest</code>, <code>CreateLogoutRequest</code>,<br />
and <code>GetTokenAsync</code> methods.</p>
<p><strong>Signing-in</strong></p>
<p>When the user taps the <strong>LOGIN</strong> button on the <code>LoginView</code>, the <code>SignInCommand</code> in the <code>LoginViewModel</code><br />
class is executed, which in turn executes the <code>SignInAsync</code> method. The following code example<br />
shows this method:</p>
<p>This method invokes the <code>CreateAuthorizationRequest</code> method in the <code>IdentityService</code> class,<br />
which is shown in the following code example:</p>
<p>65 CHAPTER 9 | Authentication and authorization</p>
<p><a href="https://identityserver4.readthedocs.io/en/release/endpoints/authorize.html">This method creates the URI for IdentityServer's authorization endpoint, with the required parameters.</a><br />
The authorization endpoint is at <code>/connect/authorize</code> on port 5105 of the base endpoint exposed as<br />
a user setting. For more information about user settings, see Configuration management.</p>
<p>The returned URI is stored in the <code>LoginUrl</code> property of the <code>LoginViewModel</code> class. When the <code>IsLogin</code><br />
property becomes <code>true</code>, the <code>WebView</code> in the <code>LoginView</code> becomes visible. The <code>WebView</code> data binds its<br />
<code>Source</code> property to the <code>LoginUrl</code> property of the <code>LoginViewModel</code> class, and so makes a sign-in<br />
request to IdentityServer when the <code>LoginUrl</code> property is set to IdentityServer's authorization<br />
endpoint. When IdentityServer receives this request and the user isn't authenticated, the <code>WebView</code> will<br />
be redirected to the configured login page, which is shown in Figure 9-4.</p>
<p><strong>Figure 9-4:</strong> Login page displayed by the WebView</p>
<p>Once login is completed, the <code>WebView</code> will be redirected to a return URI. This <code>WebView</code> navigation will<br />
cause the <code>NavigateAsync</code> method in the <code>LoginViewModel</code> class to be executed, which is shown in<br />
the following code example:</p>
<p>66 CHAPTER 9 | Authentication and authorization</p>
<p>This method parses the authentication response that's contained in the return URI, and provided that<br />
<a href="https://identityserver4.readthedocs.io/en/release/endpoints/token.html">a valid authorization code is present, it makes a request to IdentityServer's token endpoint, passing</a><br />
the authorization code, the PKCE secret verifier, and other required parameters. The token endpoint is<br />
at <code>/connect/token</code> on port 5105 of the base endpoint exposed as a user setting. For more<br />
information about user settings, see Configuration management.</p>
<p>If the token endpoint receives a valid authorization code and PKCE secret verifier, it responds with an<br />
access token, identity token, and refresh token. The access token (which allows access to API<br />
resources) and identity token are then stored as application settings, and page navigation is<br />
performed. Therefore, the overall effect in the eShopOnContainers mobile app is this: provided that<br />
users are able to successfully authenticate with IdentityServer, they are navigated to the <code>MainView</code><br />
page, which is a <code>TabbedPage</code> that displays the <code>CatalogView</code> as its selected tab.</p>
<p>For information about page navigation, see Navigation. For information about how <code>WebView</code><br />
navigation causes a view model method to be executed, see Invoking navigation using behaviors. For<br />
information about application settings, see Configuration management.</p>
<p><strong>Signing-out</strong></p>
<p>When the user taps the <strong>LOG OUT</strong> button in the <code>ProfileView</code>, the <code>LogoutCommand</code> in the<br />
<code>ProfileViewModel</code> class is executed, which in turn executes the <code>LogoutAsync</code> method. This method<br />
performs page navigation to the <code>LoginView</code> page, passing a <code>LogoutParameter</code> instance set to <code>true</code><br />
as a parameter. For more information about passing parameters during page navigation, see Passing<br />
parameters during navigation.</p>
<p>67 CHAPTER 9 | Authentication and authorization</p>
<p>When a view is created and navigated to, the <code>InitializeAsync</code> method of the view's associated<br />
view model is executed, which then executes the <code>Logout</code> method of the <code>LoginViewModel</code> class, which<br />
is shown in the following code example:</p>
<p>This method invokes the <code>CreateLogoutRequest</code> method in the <code>IdentityService</code> class, passing the<br />
identity token retrieved from application settings as a parameter. For more information about<br />
application settings, see Configuration management. The following code example shows the<br />
<code>CreateLogoutRequest</code> method:</p>
<p><a href="https://identityserver4.readthedocs.io/en/release/endpoints/endsession.html#refendsession">This method creates the URI to IdentityServer's end session endpoint, with the required parameters.</a><br />
The end session endpoint is at <code>/connect/endsession</code> on port 5105 of the base endpoint exposed as<br />
a user setting. For more information about user settings, see Configuration management.</p>
<p>The returned URI is stored in the <code>LoginUrl</code> property of the <code>LoginViewModel</code> class. While the <code>IsLogin</code><br />
property is <code>true</code>, the <code>WebView</code> in the <code>LoginView</code> is visible. The <code>WebView</code> data binds its <code>Source</code> property<br />
to the <code>LoginUrl</code> property of the <code>LoginViewModel</code> class, and so makes a sign-out request to<br />
IdentityServer when the <code>LoginUrl</code> property is set to IdentityServer's end session endpoint. When<br />
IdentityServer receives this request, provided that the user is signed-in, sign-out occurs.<br />
Authentication is tracked with a cookie managed by the cookie authentication middleware from<br />
ASP.NET Core. Therefore, signing out of IdentityServer removes the authentication cookie and sends a<br />
post logout redirect URI back to the client.</p>
<p>In the mobile app, the <code>WebView</code> will be redirected to the post logout redirect URI. This <code>WebView</code><br />
navigation will cause the <code>NavigateAsync</code> method in the <code>LoginViewModel</code> class to be executed, which<br />
is shown in the following code example:</p>
<p>68 CHAPTER 9 | Authentication and authorization</p>
<p>This method clears both the identity token and the access token from application settings, and sets<br />
the <code>IsLogin</code> property to <code>false</code>, which causes the <code>WebView</code> on the <code>LoginView</code> page to become<br />
invisible. Finally, the <code>LoginUrl</code> <a href="https://identityserver4.readthedocs.io/en/release/endpoints/authorize.html">property is set to the URI of IdentityServer's authorization endpoint,</a><br />
with the required parameters, in preparation for the next time the user initiates a sign-in.</p>
<p>For information about page navigation, see Navigation. For information about how <code>WebView</code><br />
navigation causes a view model method to be executed, see Invoking navigation using behaviors. For<br />
information about application settings, see Configuration management.</p>
<h4>Authorization</h4>
<p>After authentication, ASP.NET Core web APIs often need to authorize access, which allows a service to<br />
make APIs available to some authenticated users, but not to all.</p>
<p>Restricting access to an ASP.NET Core MVC route can be achieved by applying an <code>Authorize</code> attribute<br />
to a controller or action, which limits access to the controller or action to authenticated users, as<br />
shown in the following code example:</p>
<p>If an unauthorized user attempts to access a controller or action that's marked with the <code>Authorize</code><br />
attribute, the MVC framework returns a 401 (unauthorized) HTTP status code.</p>
<p>69 CHAPTER 9 | Authentication and authorization</p>
<p>IdentityServer can be integrated into the authorization workflow so that the access tokens it provides<br />
control authorization. This approach is shown in Figure 9-5.</p>
<p>The eShopOnContainers mobile app communicates with the identity microservice and requests an<br />
access token as part of the authentication process. The access token is then forwarded to the APIs<br />
exposed by the ordering and basket microservices as part of the access requests. Access tokens<br />
contain information about the client, and the user. APIs then use that information to authorize access<br />
to their data. For information about how to configure IdentityServer to protect APIs, see Configuring<br />
API resources.</p>
<h5><strong>Configuring IdentityServer to perform authorization</strong></h5>
<p>To perform authorization with IdentityServer, its authorization middleware must be added to the web<br />
application's HTTP request pipeline. The middleware is added in the <code>ConfigureAuth</code> method in the<br />
web application's <code>Startup</code> class, which is invoked from the <code>Configure</code> method, and is demonstrated<br />
in the following code example from the eShopOnContainers reference application:</p>
<p>This method ensures that the API can only be accessed with a valid access token. The middleware<br />
validates the incoming token to ensure that it's sent from a trusted issuer, and validates that the token<br />
is valid to be used with the API that receives it. Therefore, browsing to the ordering or basket<br />
controller will return a 401 (unauthorized) HTTP status code, indicating that an access token is<br />
required.</p>
<p>70 CHAPTER 9 | Authentication and authorization</p>
<h5><strong>Making access requests to APIs</strong></h5>
<p>When making requests to the ordering and basket microservices, the access token, obtained from<br />
IdentityServer during the authentication process, must be included in the request, as shown in the<br />
following code example:</p>
<p>The access token is stored as an application setting, and is retrieved from platform-specific storage<br />
and included in the call to the <code>GetOrderAsync</code> method in the <code>OrderService</code> class.</p>
<p>Similarly, the access token must be included when sending data to an IdentityServer protected API, as<br />
shown in the following code example:</p>
<p>The access token is retrieved from platform-specific storage and included in the call to the<br />
<code>UpdateBasketAsync</code> method in the <code>BasketService</code> class.</p>
<p>The <code>RequestProvider</code> class, in the eShopOnContainers mobile app, uses the <code>HttpClient</code> class to<br />
make requests to the RESTful APIs exposed by the eShopOnContainers reference application. When<br />
making requests to the ordering and basket APIs, which require authorization, a valid access token<br />
must be included with the request. This is achieved by adding the access token to the headers of the<br />
<code>HttpClient</code> instance, as demonstrated in the following code example:</p>
<pre><code> httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, token);

</code></pre>
<p>The <code>DefaultRequestHeaders</code> property of the <code>HttpClient</code> class exposes the headers that are sent<br />
with each request, and the access token is added to the <code>Authorization</code> header prefixed with the<br />
string <code>Bearer</code> . When the request is sent to a RESTful API, the value of the <code>Authorization</code> header is<br />
extracted and validated to ensure that it's sent from a trusted issuer, and used to determine whether<br />
the user has permission to invoke the API that receives it.</p>
<p>For more information about how the eShopOnContainers mobile app makes web requests, see<br />
Accessing remote data.</p>
<h4>Summary</h4>
<p>There are many approaches to integrating authentication and authorization into a Xamarin.Forms app<br />
that communicates with an ASP.NET MVC web application. The eShopOnContainers mobile app<br />
performs authentication and authorization with a containerized identity microservice that uses<br />
IdentityServer 4. IdentityServer is an open source OpenID Connect and OAuth 2.0 framework for<br />
ASP.NET Core that integrates with ASP.NET Core Identity to perform bearer token authentication.</p>
<p>71 CHAPTER 9 | Authentication and authorization</p>
<p>The mobile app requests security tokens from IdentityServer, either for authenticating a user or for<br />
accessing a resource. When accessing a resource, an access token must be included in the request to<br />
APIs that require authorization. IdentityServer's middleware validates incoming access tokens to<br />
ensure that they are sent from a trusted issuer, and that they are valid to be used with the API that<br />
receives them.</p>
<p>72 CHAPTER 9 | Authentication and authorization</p>
<h1>Accessing remote data</h1>
<p>Many modern web-based solutions make use of web services, hosted by web servers, to provide<br />
functionality for remote client applications. The operations that a web service exposes constitute a<br />
web API.</p>
<p>Client apps should be able to utilize the web API without knowing how the data or operations that the<br />
API exposes are implemented. This requires that the API abides by common standards that enable a<br />
client app and web service to agree on which data formats to use, and the structure of the data that is<br />
exchanged between client apps and the web service.</p>
<h4>Introduction to Representational State Transfer</h4>
<p>Representational State Transfer (REST) is an architectural style for building distributed systems based<br />
on hypermedia. A primary advantage of the REST model is that it's based on open standards and<br />
doesn't bind the implementation of the model or the client apps that access it to any specific<br />
implementation. Therefore, a REST web service could be implemented using Microsoft ASP.NET Core<br />
MVC, and client apps could be developing using any language and toolset that can generate HTTP<br />
requests and parse HTTP responses.</p>
<p>The REST model uses a navigational scheme to represent objects and services over a network, referred<br />
to as resources. Systems that implement REST typically use the HTTP protocol to transmit requests to<br />
access these resources. In such systems, a client app submits a request in the form of a URI that<br />
identifies a resource, and an HTTP method (such as GET, POST, PUT, or DELETE) that indicates the<br />
operation to be performed on that resource. The body of the HTTP request contains any data required<br />
to perform the operation.</p>
<p>The response from a REST request makes use of standard HTTP status codes. For example, a request<br />
that returns valid data should include the HTTP response code 200 (OK), while a request that fails to<br />
find or delete a specified resource should return a response that includes the HTTP status code 404<br />
(Not Found).</p>
<p>A RESTful web API exposes a set of connected resources, and provides the core operations that<br />
enable an app to manipulate those resources and easily navigate between them. For this reason, the<br />
URIs that constitute a typical RESTful web API are oriented towards the data that it exposes, and use<br />
the facilities provided by HTTP to operate on this data.</p>
<p>73 CHAPTER 10 | Accessing remote data</p>
<p>The data included by a client app in an HTTP request, and the corresponding response messages from<br />
the web server, could be presented in a variety of formats, known as media types. When a client app<br />
sends a request that returns data in the body of a message, it can specify the media types it can<br />
handle in the <code>Accept</code> header of the request. If the web server supports this media type, it can reply<br />
with a response that includes the <code>Content-Type</code> header that specifies the format of the data in the<br />
body of the message. It's then the responsibility of the client app to parse the response message and<br />
interpret the results in the message body appropriately.</p>
<p><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design">For more information about REST, see API design and</a> <a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-implementation">API implementation</a> on Microsoft Docs.</p>
<h4>Consuming RESTful APIs</h4>
<p>The eShopOnContainers mobile app uses the Model-View-ViewModel (MVVM) pattern, and the<br />
model elements of the pattern represent the domain entities used in the app. The controller and<br />
repository classes in the eShopOnContainers reference application accept and return many of these<br />
model objects. Therefore, they are used as data transfer objects (DTOs) that hold all the data that is<br />
passed between the mobile app and the containerized microservices. The main benefit of using DTOs<br />
to pass data to and receive data from a web service is that by transmitting more data in a single<br />
remote call, the app can reduce the number of remote calls that need to be made.</p>
<h5><strong>Making web requests</strong></h5>
<p>The eShopOnContainers mobile app uses the <code>HttpClient</code> class to make requests over HTTP, with<br />
JSON being used as the media type. This class provides functionality for asynchronously sending HTTP<br />
requests and receiving HTTP responses from a URI identified resource. The <code>HttpResponseMessage</code><br />
class represents an HTTP response message received from a REST API after an HTTP request has been<br />
made. It contains information about the response, including the status code, headers, and any body.<br />
The <code>HttpContent</code> class represents the HTTP body and content headers, such as <code>Content-Type</code> and<br />
<code>Content-Encoding</code> . The content can be read using any of the <code>ReadAs</code> methods, such as<br />
<code>ReadAsStringAsync</code> and <code>ReadAsByteArrayAsync</code>, depending on the format of the data.</p>
<p><strong>Making a GET request</strong></p>
<p>The <code>CatalogService</code> class is used to manage the data retrieval process from the catalog<br />
microservice. In the <code>RegisterDependencies</code> method in the <code>ViewModelLocator</code> class, the<br />
<code>CatalogService</code> class is registered as a type mapping against the <code>ICatalogService</code> type with the<br />
Autofac dependency injection container. Then, when an instance of the <code>CatalogViewModel</code> class is<br />
created, its constructor accepts an <code>ICatalogService</code> type, which Autofac resolves, returning an<br />
instance of the <code>CatalogService</code> class. For more information about dependency injection, see<br />
Introduction to dependency injection.</p>
<p>Figure 10-1 shows the interaction of classes that read catalog data from the catalog microservice for<br />
displaying by the <code>CatalogView</code> .</p>
<p>74 CHAPTER 10 | Accessing remote data</p>
<p>When the <code>CatalogView</code> is navigated to, the <code>OnInitialize</code> method in the <code>CatalogViewModel</code> class is<br />
called. This method retrieves catalog data from the catalog microservice, as demonstrated in the<br />
following code example:</p>
<p>This method calls the <code>GetCatalogAsync</code> method of the <code>CatalogService</code> instance that was injected<br />
into the <code>CatalogViewModel</code> by Autofac. The following code example shows the <code>GetCatalogAsync</code><br />
method:</p>
<p>75 CHAPTER 10 | Accessing remote data</p>
<p>This method builds the URI that identifies the resource the request will be sent to, and uses the<br />
<code>RequestProvider</code> class to invoke the GET HTTP method on the resource, before returning the results<br />
to the <code>CatalogViewModel</code> . The <code>RequestProvider</code> class contains functionality that submits a request<br />
in the form of a URI that identifies a resource, an HTTP method that indicates the operation to be<br />
performed on that resource, and a body that contains any data required to perform the operation. For<br />
information about how the <code>RequestProvider</code> class is injected into the <code>CatalogService</code> class, see<br />
Introduction to dependency injection.</p>
<p>The following code example shows the <code>GetAsync</code> method in the <code>RequestProvider</code> class:</p>
<p>This method calls the <code>CreateHttpClient</code> method, which returns an instance of the <code>HttpClient</code> class<br />
with the appropriate headers set. It then submits an asynchronous GET request to the resource<br />
identified by the URI, with the response being stored in the <code>HttpResponseMessage</code> instance. The<br />
<code>HandleResponse</code> method is then invoked, which throws an exception if the response doesn't include<br />
a success HTTP status code. Then the response is read as a string, converted from JSON to a<br />
<code>CatalogRoot</code> object, and returned to the <code>CatalogService</code> .</p>
<p>The <code>CreateHttpClient</code> method is shown in the following code example:</p>
<p>This method creates a new instance of the <code>HttpClient</code> class, and sets the <code>Accept</code> header of any<br />
requests made by the <code>HttpClient</code> instance to <code>application/json</code>, which indicates that it expects the<br />
content of any response to be formatted using JSON. Then, if an access token was passed as an<br />
argument to the <code>CreateHttpClient</code> method, it's added to the <code>Authorization</code> header of any<br />
requests made by the <code>HttpClient</code> instance, prefixed with the string <code>Bearer</code> . For more information<br />
about authorization, see Authorization.</p>
<p>76 CHAPTER 10 | Accessing remote data</p>
<p>When the <code>GetAsync</code> method in the <code>RequestProvider</code> class calls <code>HttpClient.GetAsync</code>, the <code>Items</code><br />
method in the <code>CatalogController</code> class in the <code>Catalog.API</code> project is invoked, which is shown in the<br />
following code example:</p>
<p>This method retrieves the catalog data from the SQL database using EntityFramework, and returns it<br />
as a response message that includes a success HTTP status code, and a collection of JSON formatted<br />
<code>CatalogItem</code> instances.</p>
<p><strong>Making a POST request</strong></p>
<p>The <code>BasketService</code> class is used to manage the data retrieval and update process with the basket<br />
microservice. In the <code>RegisterDependencies</code> method in the <code>ViewModelLocator</code> class, the<br />
<code>BasketService</code> class is registered as a type mapping against the <code>IBasketService</code> type with the<br />
Autofac dependency injection container. Then, when an instance of the <code>BasketViewModel</code> class is<br />
created, its constructor accepts an <code>IBasketService</code> type, which Autofac resolves, returning an<br />
instance of the <code>BasketService</code> class. For more information about dependency injection, see<br />
Introduction to dependency injection.</p>
<p>Figure 10-2 shows the interaction of classes that send the basket data displayed by the <code>BasketView</code>,<br />
to the basket microservice.</p>
<p>77 CHAPTER 10 | Accessing remote data</p>
<p>When an item is added to the shopping basket, the <code>ReCalculateTotalAsync</code> method in the<br />
<code>BasketViewModel</code> class is called. This method updates the total value of items in the basket, and<br />
sends the basket data to the basket microservice, as demonstrated in the following code example:</p>
<p>This method calls the <code>UpdateBasketAsync</code> method of the <code>BasketService</code> instance that was injected<br />
into the <code>BasketViewModel</code> by Autofac. The following method shows the <code>UpdateBasketAsync</code><br />
method:</p>
<p>78 CHAPTER 10 | Accessing remote data</p>
<p>This method builds the URI that identifies the resource the request will be sent to, and uses the<br />
<code>RequestProvider</code> class to invoke the POST HTTP method on the resource, before returning the<br />
results to the <code>BasketViewModel</code> . Note that an access token, obtained from IdentityServer during the<br />
authentication process, is required to authorize requests to the basket microservice. For more<br />
information about authorization, see Authorization.</p>
<p>The following code example shows one of the <code>PostAsync</code> methods in the <code>RequestProvider</code> class:</p>
<p>This method calls the <code>CreateHttpClient</code> method, which returns an instance of the <code>HttpClient</code> class<br />
with the appropriate headers set. It then submits an asynchronous POST request to the resource<br />
identified by the URI, with the serialized basket data being sent in JSON format, and the response<br />
being stored in the <code>HttpResponseMessage</code> instance. The <code>HandleResponse</code> method is then invoked,<br />
which throws an exception if the response doesn't include a success HTTP status code. Then, the<br />
response is read as a string, converted from JSON to a <code>CustomerBasket</code> object, and returned to the<br />
<code>BasketService</code> . For more information about the CreateHttpClient method, see Making a GET request.</p>
<p>When the <code>PostAsync</code> method in the <code>RequestProvider</code> class calls <code>HttpClient.PostAsync</code>, the <code>Post</code><br />
method in the <code>BasketController</code> class in the <code>Basket.API</code> project is invoked, which is shown in the<br />
following code example:</p>
<p>This method uses an instance of the <code>RedisBasketRepository</code> class to persist the basket data to the<br />
Redis cache, and returns it as a response message that includes a success HTTP status code, and a<br />
JSON formatted <code>CustomerBasket</code> instance.</p>
<p><strong>Making a DELETE request</strong></p>
<p>Figure 10-3 shows the interactions of classes that delete basket data from the basket microservice, for<br />
the <code>CheckoutView</code> .</p>
<p>79 CHAPTER 10 | Accessing remote data</p>
<p>When the checkout process is invoked, the <code>CheckoutAsync</code> method in the <code>CheckoutViewModel</code> class<br />
is called. This method creates a new order, before clearing the shopping basket, as demonstrated in<br />
the following code example:</p>
<p>This method calls the <code>ClearBasketAsync</code> method of the <code>BasketService</code> instance that was injected<br />
into the <code>CheckoutViewModel</code> by Autofac. The following method shows the <code>ClearBasketAsync</code><br />
method:</p>
<p>This method builds the URI that identifies the resource that the request will be sent to, and uses the<br />
<code>RequestProvider</code> class to invoke the DELETE HTTP method on the resource. Note that an access<br />
token, obtained from IdentityServer during the authentication process, is required to authorize<br />
requests to the basket microservice. For more information about authorization, see Authorization.</p>
<p>The following code example shows the <code>DeleteAsync</code> method in the <code>RequestProvider</code> class:</p>
<p>80 CHAPTER 10 | Accessing remote data</p>
<p>This method calls the <code>CreateHttpClient</code> method, which returns an instance of the <code>HttpClient</code> class<br />
with the appropriate headers set. It then submits an asynchronous DELETE request to the resource<br />
identified by the URI. For more information about the <code>CreateHttpClient</code> method, see Making a GET<br />
request.</p>
<p>When the <code>DeleteAsync</code> method in the <code>RequestProvider</code> class calls <code>HttpClient.DeleteAsync</code>, the<br />
<code>Delete</code> method in the <code>BasketController</code> class in the <code>Basket.API</code> project is invoked, which is shown<br />
in the following code example:</p>
<p>This method uses an instance of the <code>RedisBasketRepository</code> class to delete the basket data from<br />
the Redis cache.</p>
<h4>Caching data</h4>
<p>The performance of an app can be improved by caching frequently accessed data to fast storage<br />
that's located close to the app. If the fast storage is located closer to the app than the original source,<br />
then caching can significantly improve response times when retrieving data.</p>
<p>The most common form of caching is read-through caching, where an app retrieves data by<br />
referencing the cache. If the data isn't in the cache, it's retrieved from the data store and added to the<br />
cache. Apps can implement read-through caching with the cache-aside pattern. This pattern<br />
determines whether the item is currently in the cache. If the item isn't in the cache, it's read from the<br />
<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">data store and added to the cache. For more information, see the Cache-Aside</a> pattern on Microsoft<br />
Docs.</p>
<p>Distributed applications, such as the eShopOnContainers reference application, should provide either<br />
or both of the following caches:</p>
<ul>
<li>
<p>A shared cache, which can be accessed by multiple processes or machines.</p>
</li>
<li>
<p>A private cache, where data is held locally on the device running the app.</p>
</li>
</ul>
<p>The eShopOnContainers mobile app uses a private cache, where data is held locally on the device<br />
that's running an instance of the app. For information about the cache used by the<br />
eShopOnContainers reference application, see <a href="https://aka.ms/microservicesebook">.NET Microservices: Architecture for Containerized .NET</a><br />
<a href="https://aka.ms/microservicesebook">Applications.</a></p>
<p>81 CHAPTER 10 | Accessing remote data</p>
<h5><strong>Managing data expiration</strong></h5>
<p>It's impractical to expect that cached data will always be consistent with the original data. Data in the<br />
original data store might change after it's been cached, causing the cached data to become stale.<br />
Therefore, apps should implement a strategy that helps to ensure that the data in the cache is as upto-date as possible, but can also detect and handle situations that arise when the data in the cache<br />
has become stale. Most caching mechanisms enable the cache to be configured to expire data, and<br />
hence reduce the period for which data might be out of date.</p>
<p>When cached data expires, it should be removed from the cache, and the app must retrieve the data<br />
from the original data store and place it back into the cache.</p>
<p>It's also possible that a cache might fill up if data is allowed to remain for too long a period. Therefore,<br />
requests to add new items to the cache might be required to remove some items in a process known<br />
as <em>eviction</em> . Caching services typically evict data on a least-recently-used basis. However, there are<br />
other eviction policies, including most-recently-used, and first-in-first-out. For more information, see<br />
<a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/caching">Caching Guidance on Microsoft Docs.</a></p>
<h5><strong>Caching images</strong></h5>
<p>The eShopOnContainers mobile app consumes remote product images that benefit from being<br />
cached. These images are displayed by the <code>Image</code> control, and the <code>CachedImage</code> control provided by<br />
<a href="https://www.nuget.org/packages/Xamarin.FFImageLoading.Forms/">the FFImageLoading library.</a></p>
<p>The Xamarin.Forms <code>Image</code> control supports caching of downloaded images. Caching is enabled by<br />
default, and will store the image locally for 24 hours. In addition, the expiration time can be<br />
configured with the <code>CacheValidity</code> <a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/images/#Downloaded_Image_Caching">property. For more information, see Downloaded Image Caching</a><br />
on the Xamarin Developer Center.</p>
<p>FFImageLoading's <code>CachedImage</code> control is a replacement for the Xamarin.Forms <code>Image</code> control,<br />
providing additional properties that enable supplementary functionality. Amongst this functionality,<br />
the control provides configurable caching, while supporting error and loading image placeholders.<br />
The following code example shows how the eShopOnContainers mobile app uses the <code>CachedImage</code><br />
control in the <code>ProductTemplate</code>, which is the data template used by the <code>ListView</code> control in the<br />
<code>CatalogView</code> :</p>
<p>82 CHAPTER 10 | Accessing remote data</p>
<p>The <code>CachedImage</code> control sets the <code>LoadingPlaceholder</code> and <code>ErrorPlaceholder</code> properties to<br />
platform-specific images. The <code>LoadingPlaceholder</code> property specifies the image to be displayed<br />
while the image specified by the <code>Source</code> property is retrieved, and the <code>ErrorPlaceholder</code> property<br />
specifies the image to be displayed if an error occurs when attempting to retrieve the image specified<br />
by the <code>Source</code> property.</p>
<p>As the name implies, the <code>CachedImage</code> control caches remote images on the device for the time<br />
specified by the value of the <code>CacheDuration</code> property. When this property value isn't explicitly set, the<br />
default value of 30 days is applied.</p>
<h4>Increasing resilience</h4>
<p>All apps that communicate with remote services and resources must be sensitive to transient faults.<br />
Transient faults include the momentary loss of network connectivity to services, the temporary<br />
unavailability of a service, or timeouts that arise when a service is busy. These faults are often selfcorrecting, and if the action is repeated after a suitable delay it's likely to succeed.</p>
<p>Transient faults can have a huge impact on the perceived quality of an app, even if it has been<br />
thoroughly tested under all foreseeable circumstances. To ensure that an app that communicates with<br />
remote services operates reliably, it must be able to do all of the following:</p>
<ul>
<li>
<p>Detect faults when they occur, and determine if the faults are likely to be transient.</p>
</li>
<li>
<p>Retry the operation if it determines that the fault is likely to be transient and keep track of the<br />
number of times the operation was retried.</p>
</li>
<li>
<p>Use an appropriate retry strategy, which specifies the number of retries, the delay between<br />
each attempt, and the actions to take after a failed attempt.</p>
</li>
</ul>
<p>This transient fault handling can be achieved by wrapping all attempts to access a remote service in<br />
code that implements the retry pattern.</p>
<h5><strong>Retry pattern</strong></h5>
<p>If an app detects a failure when it tries to send a request to a remote service, it can handle the failure<br />
in any of the following ways:</p>
<ul>
<li>
<p>Retrying the operation. The app could retry the failing request immediately.</p>
</li>
<li>
<p>Retrying the operation after a delay. The app should wait for a suitable amount of time before<br />
retrying the request.</p>
</li>
<li>
<p>Cancelling the operation. The application should cancel the operation and report an<br />
exception.</p>
</li>
</ul>
<p>83 CHAPTER 10 | Accessing remote data</p>
<p>The retry strategy should be tuned to match the business requirements of the app. For example, it's<br />
important to optimize the retry count and retry interval to the operation being attempted. If the<br />
operation is part of a user interaction, the retry interval should be short and only a few retries<br />
attempted to avoid making users wait for a response. If the operation is part of a long running<br />
workflow, where cancelling or restarting the workflow is expensive or time-consuming, it's appropriate<br />
to wait longer between attempts and to retry more times.</p>
<p>If a request still fails after a number of retries, it's better for the app to prevent further requests going<br />
to the same resource and to report a failure. Then, after a set period, the app can make one or more<br />
requests to the resource to see if they're successful. For more information, see Circuit breaker pattern.</p>
<p>The eShopOnContainers mobile app does not currently implement the retry pattern when making<br />
RESTful web requests. However, the <code>CachedImage</code> control, provided by the <a href="https://www.nuget.org/packages/Xamarin.FFImageLoading.Forms/">FFImageLoading</a> library<br />
supports transient fault handling by retrying image loading. If image loading fails, further attempts<br />
will be made. The number of attempts is specified by the <code>RetryCount</code> property, and retries will occur<br />
after a delay specified by the <code>RetryDelay</code> property. If these property values aren't explicitly set, their<br />
default values are applied – 3 for the <code>RetryCount</code> property, and 250ms for the <code>RetryDelay</code> property.<br />
For more information about the <code>CachedImage</code> control, see Caching images.</p>
<p>The eShopOnContainers reference application does implement the retry pattern. For more<br />
information, including a discussion of how to combine the retry pattern with the <code>HttpClient</code> class,<br />
<a href="https://aka.ms/microservicesebook">see .NET Microservices: Architecture for Containerized .NET Applications.</a></p>
<p><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/retry">For more information about the retry pattern, see the Retry</a> pattern on Microsoft Docs.</p>
<h5><strong>Circuit breaker pattern</strong></h5>
<p>In some situations, faults can occur due to anticipated events that take longer to fix. These faults can<br />
range from a partial loss of connectivity to the complete failure of a service. In these situations, it's<br />
pointless for an app to retry an operation that's unlikely to succeed, and instead should accept that<br />
the operation has failed and handle this failure accordingly.</p>
<p>The circuit breaker pattern can prevent an app from repeatedly trying to execute an operation that's<br />
likely to fail, while also enabling the app to detect whether the fault has been resolved.</p>
<p>A circuit breaker acts as a proxy for operations that might fail. The proxy should monitor the number<br />
of recent failures that have occurred, and use this information to decide whether to allow the<br />
operation to proceed, or to return an exception immediately.</p>
<p>The eShopOnContainers mobile app does not currently implement the circuit breaker pattern.<br />
<a href="https://aka.ms/microservicesebook">However, the eShopOnContainers does. For more information, see .NET Microservices: Architecture</a><br />
<a href="https://aka.ms/microservicesebook">for Containerized .NET Applications.</a></p>
<p>84 CHAPTER 10 | Accessing remote data</p>
<p><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker">For more information about the circuit breaker pattern, see the Circuit Breaker pattern on Microsoft</a><br />
Docs.</p>
<h4>Summary</h4>
<p>Many modern web-based solutions make use of web services, hosted by web servers, to provide<br />
functionality for remote client applications. The operations that a web service exposes constitute a<br />
web API, and client apps should be able to utilize the web API without knowing how the data or<br />
operations that the API exposes are implemented.</p>
<p>The performance of an app can be improved by caching frequently accessed data to fast storage<br />
that's located close to the app. Apps can implement read-through caching with the cache-aside<br />
pattern. This pattern determines whether the item is currently in the cache. If the item isn't in the<br />
cache, it's read from the data store and added to the cache.</p>
<p>When communicating with web APIs, apps must be sensitive to transient faults. Transient faults<br />
include the momentary loss of network connectivity to services, the temporary unavailability of a<br />
service, or timeouts that arise when a service is busy. These faults are often self-correcting, and if the<br />
action is repeated after a suitable delay, then it's likely to succeed. Therefore, apps should wrap all<br />
attempts to access a web API in code that implements a transient fault handling mechanism.</p>
<p>85 CHAPTER 10 | Accessing remote data</p>
<h1>Unit testing</h1>
<p>Mobile apps have unique problems that desktop and web-based applications don't have to worry<br />
about. Mobile users will differ by the devices that they use, by network connectivity, by the availability<br />
of services, and a range of other factors. Therefore, mobile apps should be tested as they will be used<br />
in the real world in order to improve their quality, reliability, and performance. There are many types<br />
of testing that should be performed on an app, including unit testing, integration testing, and user<br />
interface testing, with unit testing being the most common form of testing.</p>
<p>A unit test takes a small unit of the app, typically a method, isolates it from the remainder of the code,<br />
and verifies that it behaves as expected. Its goal is to check that each unit of functionality performs as<br />
expected, so that errors don't propagate throughout the app. Detecting a bug where it occurs is more<br />
efficient that observing the effect of a bug indirectly at a secondary point of failure.</p>
<p>Unit testing has the greatest effect on code quality when it's an integral part of the software<br />
development workflow. As soon as a method has been written, unit tests should be written that verify<br />
the behavior of the method in response to standard, boundary, and incorrect cases of input data, and<br />
that check any explicit or implicit assumptions made by the code. Alternatively, with test driven<br />
development, unit tests are written before the code. In this scenario, unit tests act as both design<br />
documentation and functional specifications.</p>
<p>Unit tests typically use the arrange-act-assert pattern:</p>
<ul>
<li>
<p>The <em>arrange</em> section of the unit test method initializes objects and sets the value of the data<br />
that is passed to the method under test.</p>
</li>
<li>
<p>The <em>act</em> section invokes the method under test with the required arguments.</p>
</li>
<li>
<p>The <em>assert</em> section verifies that the action of the method under test behaves as expected.</p>
</li>
</ul>
<p>Following this pattern ensures that unit tests are readable and consistent.</p>
<h4>Dependency injection and unit testing</h4>
<p>One of the motivations for adopting a loosely-coupled architecture is that it facilitates unit testing.<br />
One of the types registered with Autofac is the <code>OrderService</code> class. The following code example<br />
shows an outline of this class:</p>
<p>86 CHAPTER 11 | Unit testing</p>
<p>The <code>OrderDetailViewModel</code> class has a dependency on the <code>IOrderService</code> type which the container<br />
resolves when it instantiates a <code>OrderDetailViewModel</code> object. However, rather than create an<br />
<code>OrderService</code> object to unit test the <code>OrderDetailViewModel</code> class, instead, replace the<br />
<code>OrderService</code> object with a mock for the purpose of the tests. Figure 10-1 illustrates this relationship.</p>
<p><strong>Figure 10-1:</strong> Classes that implement the IOrderService interface</p>
<p>This approach allows the <code>OrderService</code> object to be passed into the <code>OrderDetailViewModel</code> class at<br />
runtime, and in the interests of testability, it allows the <code>OrderMockService</code> class to be passed into the<br />
<code>OrderDetailViewModel</code> class at test time. The main advantage of this approach is that it enables unit<br />
tests to be executed without requiring unwieldy resources such as web services, or databases.</p>
<h4>Testing MVVM applications</h4>
<p>Testing models and view models from MVVM applications is identical to testing any other classes, and<br />
the same tools and techniques – such as unit testing and mocking, can be used. However, there are<br />
some patterns that are typical to model and view model classes, that can benefit from specific unit<br />
testing techniques.</p>
<p><a href="https://xunit.github.io/">The eShopOnContainers mobile app uses xUnit to perform unit testing, which supports two different</a><br />
types of unit tests:</p>
<ul>
<li>
<p>Facts are tests that are always true, which test invariant conditions.</p>
</li>
<li>
<p>Theories are tests that are only true for a particular set of data.</p>
</li>
</ul>
<p>87 CHAPTER 11 | Unit testing</p>
<p>The unit tests included with the eShopOnContainers mobile app are fact tests, and so each unit test<br />
method is decorated with the <code>[Fact]</code> attribute.</p>
<h5><strong>Testing asynchronous functionality</strong></h5>
<p>When implementing the MVVM pattern, view models usually invoke operations on services, often<br />
asynchronously. Tests for code that invokes these operations typically use mocks as replacements for<br />
the actual services. The following code example demonstrates testing asynchronous functionality by<br />
passing a mock service into a view model:</p>
<p>This unit test checks that the <code>Order</code> property of the <code>OrderDetailViewModel</code> instance will have a value<br />
after the <code>InitializeAsync</code> method has been invoked. The <code>InitializeAsync</code> method is invoked<br />
when the view model's corresponding view is navigated to. For more information about navigation,<br />
see Navigation.</p>
<p>When the <code>OrderDetailViewModel</code> instance is created, it expects an <code>OrderService</code> instance to be<br />
specified as an argument. However, the <code>OrderService</code> retrieves data from a web service. Therefore,<br />
an <code>OrderMockService</code> instance, which is a mock version of the <code>OrderService</code> class, is specified as the<br />
argument to the <code>OrderDetailViewModel</code> constructor. Then, when the view model's<br />
<code>InitializeAsync</code> method is invoked, which invokes <code>IOrderService</code> operations, mock data is<br />
retrieved rather than communicating with a web service.</p>
<h5><strong>Testing INotifyPropertyChanged implementations</strong></h5>
<p>Implementing the <code>INotifyPropertyChanged</code> interface allows views to react to changes that originate<br />
from view models and models. These changes are not limited to data shown in controls – they are<br />
also used to control the view, such as view model states that cause animations to be started or<br />
controls to be disabled.</p>
<p>Properties that can be updated directly by the unit test can be tested by attaching an event handler to<br />
the <code>PropertyChanged</code> event and checking whether the event is raised after setting a new value for the<br />
property. The following code example shows such a test:</p>
<p>88 CHAPTER 11 | Unit testing</p>
<p>This unit test invokes the <code>InitializeAsync</code> method of the <code>OrderViewModel</code> class, which causes its<br />
<code>Order</code> property to be updated. The unit test will pass, provided that the <code>PropertyChanged</code> event is<br />
raised for the <code>Order</code> property.</p>
<h5><strong>Testing message-based communication</strong></h5>
<p>View models that use the <code>MessagingCenter</code> class to communicate between loosely-coupled classes<br />
can be unit tested by subscribing to the message being sent by the code under test, as demonstrated<br />
in the following code example:</p>
<p>This unit test checks that the <code>CatalogViewModel</code> publishes the <code>AddProduct</code> message in response to<br />
its <code>AddCatalogItemCommand</code> being executed. Because the <code>MessagingCenter</code> class supports multicast<br />
message subscriptions, the unit test can subscribe to the <code>AddProduct</code> message and execute a callback<br />
delegate in response to receiving it. This callback delegate, specified as a lambda expression, sets a<br />
<code>boolean</code> field that's used by the <code>Assert</code> statement to verify the behavior of the test.</p>
<h5><strong>Testing exception handling</strong></h5>
<p>Unit tests can also be written that check that specific exceptions are thrown for invalid actions or<br />
inputs, as demonstrated in the following code example:</p>
<p>89 CHAPTER 11 | Unit testing</p>
<p>This unit test will throw an exception, because the <code>ListView</code> control does not have an event named<br />
<code>OnItemTapped</code> . The <code>Assert.Throws&lt;T&gt;</code> method is a generic method where <code>T</code> is the type of the<br />
expected exception. The argument passed to the <code>Assert.Throws&lt;T&gt;</code> method is a lambda expression<br />
that will throw the exception. Therefore, the unit test will pass provided that the lambda expression<br />
throws an <code>ArgumentException</code> .</p>
<h5><strong>Testing validation</strong></h5>
<p>There are two aspects to testing the validation implementation: testing that any validation rules are<br />
correctly implemented, and testing that the <code>ValidatableObject&lt;T&gt;</code> class performs as expected.</p>
<p>Validation logic is usually simple to test, because it is typically a self-contained process where the<br />
output depends on the input. There should be tests on the results of invoking the <code>Validate</code> method<br />
on each property that has at least one associated validation rule, as demonstrated in the following<br />
code example:</p>
<p>This unit test checks that validation succeeds when the two <code>ValidatableObject&lt;T&gt;</code> properties in the<br />
<code>MockViewModel</code> instance both have data.</p>
<p>As well as checking that validation succeeds, validation unit tests should also check the values of the<br />
<code>Value</code>, <code>IsValid</code>, and <code>Errors</code> property of each <code>ValidatableObject&lt;T&gt;</code> instance, to verify that the<br />
class performs as expected. The following code example demonstrates a unit test that does this:</p>
<p>90 CHAPTER 11 | Unit testing</p>
<p>This unit test checks that validation fails when the <code>Surname</code> property of the <code>MockViewModel</code> doesn't<br />
have any data, and the <code>Value</code>, <code>IsValid</code>, and Errors property of each <code>ValidatableObject&lt;T&gt;</code> instance<br />
are correctly set.</p>
<h4>Summary</h4>
<p>A unit test takes a small unit of the app, typically a method, isolates it from the remainder of the code,<br />
and verifies that it behaves as expected. Its goal is to check that each unit of functionality performs as<br />
expected, so that errors don't propagate throughout the app.</p>
<p>The behavior of an object under test can be isolated by replacing dependent objects with mock<br />
objects that simulate the behavior of the dependent objects. This enables unit tests to be executed<br />
without requiring unwieldy resources such as web services, or databases.</p>
<p>Testing models and view models from MVVM applications is identical to testing any other classes, and<br />
the same tools and techniques can be used.</p>
<p>91 CHAPTER 11 | Unit testing</p>
<p>92 CHAPTER 11 | Unit testing</p>
