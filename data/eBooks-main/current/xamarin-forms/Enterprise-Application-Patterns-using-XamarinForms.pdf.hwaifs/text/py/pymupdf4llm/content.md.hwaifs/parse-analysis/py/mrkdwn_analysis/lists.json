{'Unordered list': [[{'text': 'App requirements that can change over time.', 'task_item': False}, {'text': 'New business opportunities and challenges.', 'task_item': False}, {'text': 'Ongoing feedback during development that can significantly affect the scope and\nrequirements of the app.', 'task_item': False}, {'text': "With these in mind, it's important to build apps that can be easily modified or extended over time.\nDesigning for such adaptability can be difficult as it requires an architecture that allows individual\nparts of the app to be independently developed and tested in isolation without affecting the rest of\nthe app.", 'task_item': False}, {'text': 'Many enterprise apps are sufficiently complex to require more than one developer. It can be a\nsignificant challenge to decide how to design an app so that multiple developers can work effectively\non different pieces of the app independently, while ensuring that the pieces come together seamlessly\nwhen integrated into the app.', 'task_item': False}, {'text': 'The traditional approach to designing and building an app results in what is referred to as a\n_monolithic_ app, where components are tightly coupled with no clear separation between them.\nTypically, this monolithic approach leads to apps that are difficult and inefficient to maintain, because\nit can be difficult to resolve bugs without breaking other components in the app, and it can be\ndifficult to add new features or to replace existing features.', 'task_item': False}, {'text': 'An effective remedy for these challenges is to partition an app into discrete, loosely coupled\ncomponents that can be easily integrated together into an app. Such an approach offers several\nbenefits:', 'task_item': False}, {'text': 'It allows individual functionality to be developed, tested, extended, and maintained by\ndifferent individuals or teams.', 'task_item': False}, {'text': "It promotes reuse and a clean separation of concerns between the app's horizontal\ncapabilities, such as authentication and data access, and the vertical capabilities, such as app\nspecific business functionality. This allows the dependencies and interactions between app\ncomponents to be more easily managed.", 'task_item': False}, {'text': "It helps maintain a separation of roles by allowing different individuals, or teams, to focus on\na specific task or piece of functionality according to their expertise. In particular, it provides a\ncleaner separation between the user interface and the app's business logic.", 'task_item': False}, {'text': 'However, there are many issues that must be resolved when partitioning an app into discrete, loosely\ncoupled components. These include:', 'task_item': False}, {'text': 'Deciding how to provide a clean separation of concerns between the user interface controls\nand their logic. One of the most important decisions when creating a Xamarin.Forms\nenterprise app is whether to place business logic in code-behind files, or whether to create a\nclean separation of concerns between the user interface controls and their logic, in order to', 'task_item': False}, {'text': '1 CHAPTER 1 | Introduction', 'task_item': False}, {'text': 'make the app more maintainable and testable. For more information, see Model-ViewViewModel.', 'task_item': False}, {'text': 'Determining whether to use a dependency injection container. Dependency injection\ncontainers reduce the dependency coupling between objects by providing a facility to\nconstruct instances of classes with their dependencies injected, and manage their lifetime\nbased on the configuration of the container. For more information, see Dependency injection.', 'task_item': False}, {'text': 'Choosing between platform provided eventing and loosely coupled message-based\ncommunication between components that are inconvenient to link by object and type\nreferences. For more information, see Introduction to Communicating between loosely\ncoupled components.', 'task_item': False}, {'text': 'Deciding how to navigate between pages, including how to invoke navigation, and where\nnavigation logic should reside. For more information, see Navigation.', 'task_item': False}, {'text': 'Determining how to validate user input for correctness. The decision must include how to\nvalidate user input, and how to notify the user about validation errors. For more information,\nsee Validation.', 'task_item': False}, {'text': 'Deciding how to perform authentication, and how to protect resources with authorization. For\nmore information, see Authentication and authorization.', 'task_item': False}, {'text': 'Determining how to access remote data from web services, including how to reliably retrieve\ndata, and how to cache data. For more information, see Accessing remote data.', 'task_item': False}, {'text': 'Deciding how to test the app. For more information, see Unit testing.', 'task_item': False}, {'text': 'This guide provides guidance on these issues, and focuses on the core patterns and architecture for\nbuilding a cross-platform enterprise app using Xamarin.Forms. The guidance aims to help to produce\nadaptable, maintainable, and testable code, by addressing common Xamarin.Forms enterprise app\ndevelopment scenarios, and by separating the concerns of presentation, presentation logic, and\nentities through support for the Model-View-ViewModel (MVVM) pattern.', 'task_item': False}], [{'text': 'Authenticating and authorizing against a backend service.', 'task_item': False}, {'text': 'Browsing a catalog of shirts, coffee mugs, and other marketing items.', 'task_item': False}, {'text': 'Filtering the catalog.', 'task_item': False}, {'text': 'Ordering items from the catalog.', 'task_item': False}, {'text': "Viewing the user's order history.", 'task_item': False}, {'text': 'Configuration of settings.', 'task_item': False}], [{'text': 'An MVC application developed with ASP.NET Core.', 'task_item': False}, {'text': 'A Single Page Application (SPA) developed with Angular 2 and Typescript. This approach for\nweb applications avoids performing a round-trip to the server with each operation.', 'task_item': False}, {'text': 'A mobile app developed with Xamarin.Forms, which supports iOS, Android, and the Universal\nWindows Platform (UWP).', 'task_item': False}, {'text': '[For information about the web applications, see Architecting and Developing Modern Web](http://aka.ms/WebAppEbook)\n[Applications with ASP.NET Core and Microsoft Azure.](http://aka.ms/WebAppEbook)', 'task_item': False}, {'text': 'The sample application includes the following backend services:', 'task_item': False}, {'text': 'An identity microservice, which uses ASP.NET Core Identity and IdentityServer.', 'task_item': False}, {'text': 'A catalog microservice, which is a data-driven create, read, update, delete (CRUD) service that\nconsumes an SQL Server database using EntityFramework Core.', 'task_item': False}, {'text': 'An ordering microservice, which is a domain-driven service that uses domain-driven design\npatterns.', 'task_item': False}, {'text': 'A basket microservice, which is a data-driven CRUD service that uses Redis Cache.', 'task_item': False}, {'text': 'These backend services are implemented as microservices using ASP.NET Core MVC, and are\ndeployed as unique containers within a single Docker host. Collectively, these backend services are\nreferred to as the eShopOnContainers reference application. Client apps communicate with the\nbackend services through a Representational State Transfer (REST) web interface. For more\ninformation about microservices and Docker, see Containerized microservices.', 'task_item': False}, {'text': '[For information about the implementation of the backend services, see .NET Microservices:](https://aka.ms/microservicesebook)\n[Architecture for Containerized .NET Applications.](https://aka.ms/microservicesebook)', 'task_item': False}, {'text': '3 CHAPTER 1 | Introduction', 'task_item': False}], [{'text': 'XAML', 'task_item': False}, {'text': 'Controls', 'task_item': False}, {'text': 'Bindings', 'task_item': False}, {'text': 'Converters', 'task_item': False}, {'text': 'Styles', 'task_item': False}, {'text': '4 CHAPTER 1 | Introduction', 'task_item': False}, {'text': 'Animations', 'task_item': False}, {'text': 'Commands', 'task_item': False}, {'text': 'Behaviors', 'task_item': False}, {'text': 'Triggers', 'task_item': False}, {'text': 'Effects', 'task_item': False}, {'text': 'Custom Renderers', 'task_item': False}, {'text': 'MessagingCenter', 'task_item': False}, {'text': 'Custom Controls', 'task_item': False}, {'text': 'For more information about this functionality, see the [Xamarin.Forms documentation](https://developer.xamarin.com/guides/xamarin-forms/) on the Xamarin\n[Developer Center, and Creating Mobile Apps with Xamarin.Forms.](https://aka.ms/xamebook)', 'task_item': False}, {'text': 'In addition, unit tests are provided for some of the classes in the eShopOnContainers mobile app.', 'task_item': False}, {'text': '**Mobile app solution**', 'task_item': False}, {'text': 'The eShopOnContainers mobile app solution organizes the source code and other resources into\nprojects. All of the projects use folders to organize the source code and other resources into\ncategories. The following table outlines the projects that make up the eShopOnContainers mobile\napp:', 'task_item': False}, {'text': '|Project|Description|\n|---|---|\n|eShopOnContainers.Core|This project is the portable class library (PCL) project<br>that contains the shared code and shared UI.|\n|eShopOnContainers.Droid|This project holds Android specific code and is the<br>entry point for the Android app.|\n|eShopOnContainers.iOS|This project holds iOS specific code and is the entry<br>point for the iOS app.|\n|eShopOnContainers.UWP|This project holds Universal Windows Platform (UWP)<br>specific code and is the entry point for the Windows<br>app.|\n|eShopOnContainers.TestRunner.Droid|This project is the Android test runner for the<br>eShopOnContainers.UnitTests project.|\n|eShopOnContainers.TestRunner.iOS|This project is the iOS test runner for the<br>eShopOnContainers.UnitTests project.|\n|eShopOnContainers.TestRunner.Windows|This project is the Universal Windows Platform test<br>runner for the eShopOnContainers.UnitTests project.|\n|eShopOnContainers.UnitTests<br>|This project contains unit tests for the<br>eShopOnContainers.Core project.|', 'task_item': False}, {'text': 'The classes from the eShopOnContainers mobile app can be re-used in any Xamarin.Forms app with\nlittle or no modification.', 'task_item': False}], [{'text': "If there's an existing model implementation that encapsulates existing business logic, it can\nbe difficult or risky to change it. In this scenario, the view model acts as an adapter for the\nmodel classes and enables you to avoid making any major changes to the model code.", 'task_item': False}, {'text': '7 CHAPTER 2 | MVVM', 'task_item': False}, {'text': 'Developers can create unit tests for the view model and the model, without using the view.\nThe unit tests for the view model can exercise exactly the same functionality as used by the\nview.', 'task_item': False}, {'text': 'The app UI can be redesigned without touching the code, provided that the view is\nimplemented entirely in XAML. Therefore, a new version of the view should work with the\nexisting view model.', 'task_item': False}, {'text': 'Designers and developers can work independently and concurrently on their components\nduring the development process. Designers can focus on the view, while developers can work\non the view model and model components.', 'task_item': False}, {'text': 'The key to using MVVM effectively lies in understanding how to factor app code into the correct\nclasses, and in understanding how the classes interact. The following sections discuss the\nresponsibilities of each of the classes in the MVVM pattern.', 'task_item': False}], [{'text': 'View models are in the same assembly as view types.', 'task_item': False}, {'text': 'Views are in a .Views child namespace.', 'task_item': False}, {'text': 'View models are in a .ViewModels child namespace.', 'task_item': False}, {'text': 'View model names correspond with view names and end with "ViewModel".', 'task_item': False}, {'text': '11 CHAPTER 2 | MVVM', 'task_item': False}, {'text': 'Finally, the `OnAutoWireViewModelChanged` method sets the `BindingContext` of the view type to the\nresolved view model type. For more information about resolving the view model type, see Resolution.', 'task_item': False}, {'text': 'This approach has the advantage that an app has a single class that is responsible for the instantiation\nof view models and their connection to views.', 'task_item': False}], [{'text': "Always raising a `PropertyChanged` event if a public property's value changes. Do not assume\nthat raising the `PropertyChanged` event can be ignored because of knowledge of how XAML\nbinding occurs.", 'task_item': False}, {'text': 'Always raising a `PropertyChanged` event for any calculated properties whose values are used\nby other properties in the view model or model.', 'task_item': False}, {'text': "Always raising the `PropertyChanged` event at the end of the method that makes a property\nchange, or when the object is known to be in a safe state. Raising the event interrupts the\noperation by invoking the event's handlers synchronously. If this happens in the middle of an\noperation, it might expose the object to callback functions when it is in an unsafe, partially\nupdated state. In addition, it's possible for cascading changes to be triggered by\n`PropertyChanged` events. Cascading changes generally require updates to be complete\nbefore the cascading change is safe to execute.", 'task_item': False}, {'text': 'Never raising a `PropertyChanged` event if the property does not change. This means that you\nmust compare the old and new values before raising the `PropertyChanged` event.', 'task_item': False}, {'text': "Never raising the `PropertyChanged` event during a view model's constructor if you are\ninitializing a property. Data-bound controls in the view will not have subscribed to receive\nchange notifications at this point.", 'task_item': False}, {'text': 'Never raising more than one `PropertyChanged` event with the same property name\nargument within a single synchronous invocation of a public method of a class. For example,\ngiven a `NumberOfItems` property whose backing store is the `_numberOfItems` field, if a\nmethod increments `_numberOfItems` fifty times during the execution of a loop, it should only\nraise property change notification on the `NumberOfItems` property once, after all the work is\ncomplete. For asynchronous methods, raise the `PropertyChanged` event for a given property\nname in each synchronous segment of an asynchronous continuation chain.', 'task_item': False}, {'text': 'The eShopOnContainers mobile app uses the `ExtendedBindableObject` class to provide change\nnotifications, which is shown in the following code example:', 'task_item': False}, {'text': '12 CHAPTER 2 | MVVM', 'task_item': False}, {'text': "Xamarin.Form's `BindableObject` class implements the `INotifyPropertyChanged` interface, and\nprovides an `OnPropertyChanged` method. The `ExtendedBindableObject` class provides the\n`RaisePropertyChanged` method to invoke property change notification, and in doing so uses the\nfunctionality provided by the `BindableObject` class.", 'task_item': False}, {'text': 'Each view model class in the eShopOnContainers mobile app derives from the `ViewModelBase` class,\nwhich in turn derives from the `ExtendedBindableObject` class. Therefore, each view model class uses\nthe `RaisePropertyChanged` method in the `ExtendedBindableObject` class to provide property\nchange notification. The following code example shows how the eShopOnContainers mobile app\ninvokes property change notification by using a lambda expression:', 'task_item': False}, {'text': 'Note that using a lambda expression in this way involves a small performance cost because the\nlambda expression has to be evaluated for each call. Although the performance cost is small and\nwould not normally impact an app, the costs can accrue when there are many change notifications.\nHowever, the benefit of this approach is that it provides compile-time type safety and refactoring\nsupport when renaming properties.', 'task_item': False}], [{'text': 'A container removes the need for a class to locate its dependencies and manage their\nlifetimes.', 'task_item': False}, {'text': 'A container allows mapping of implemented dependencies without affecting the class.', 'task_item': False}, {'text': 'A container facilitates testability by allowing dependencies to be mocked.', 'task_item': False}, {'text': 'A container increases maintainability by allowing new classes to be easily added to the app.', 'task_item': False}, {'text': 'In the context of a Xamarin.Forms app that uses MVVM, a dependency injection container will\ntypically be used for registering and resolving view models, and for registering services and injecting\nthem into view models.', 'task_item': False}, {'text': 'There are many dependency injection containers available, with the eShopOnContainers mobile app\nusing Autofac to manage the instantiation of view model and service classes in the app. Autofac\nfacilitates building loosely coupled apps, and provides all of the features commonly found in\ndependency injection containers, including methods to register type mappings and object instances,\nresolve objects, manage object lifetimes, and inject dependent objects into constructors of objects\nthat it resolves. For more information about Autofac, see [Autofac](http://autofac.readthedocs.io/en/latest/index.html) on readthedocs.io.', 'task_item': False}, {'text': 'In Autofac, the `IContainer` interface provides the dependency injection container. Figure 3-1 shows\nthe dependencies when using this container, which instantiates an `IOrderService` object and injects\nit into the `ProfileViewModel` class.', 'task_item': False}, {'text': '19 CHAPTER 3 | Dependency injection', 'task_item': False}, {'text': 'At runtime, the container must know which implementation of the `IOrderService` interface it should\ninstantiate, before it can instantiate a `ProfileViewModel` object. This involves:', 'task_item': False}, {'text': 'The container deciding how to instantiate an object that implements the `IOrderService`\ninterface. This is known as _registration_ .', 'task_item': False}, {'text': 'The container instantiating the object that implements the `IOrderService` interface, and the\n`ProfileViewModel` object. This is known as _resolution_ .', 'task_item': False}, {'text': 'Eventually, the app will finish using the `ProfileViewModel` object and it will become available for\ngarbage collection. At this point, the garbage collector should dispose of the `IOrderService` instance\nif other classes do not share the same instance.', 'task_item': False}], [{'text': 'Register a type or mapping with the container. When required, the container will build an\ninstance of the specified type.', 'task_item': False}, {'text': 'Register an existing object in the container as a singleton. When required, the container will\nreturn a reference to the existing object.', 'task_item': False}, {'text': "The registration of types that require dependency injection should be performed in a single method in\nan app, and this method should be invoked early in the app's lifecycle to ensure that the app is aware\nof the dependencies between its classes. In the eShopOnContainers mobile app this is performed by\nthe `ViewModelLocator` class, which builds the `IContainer` object and is the only class in the app that\nholds a reference to that object. The following code example shows how the eShopOnContainers\nmobile app declares the `IContainer` object in the `ViewModelLocator` class:", 'task_item': False}], [{'text': 'The `AddProduct` message is published by the `CatalogViewModel` class when an item is\nadded to the shopping basket. In return, the `BasketViewModel` class subscribes to the\nmessage and increments the number of items in the shopping basket in response. In addition,\nthe `BasketViewModel` class also unsubscribes from this message.', 'task_item': False}, {'text': 'The `Filter` message is published by the `CatalogViewModel` class when the user applies a\nbrand or type filter to the items displayed from the catalogue. In return, the `CatalogView`\nclass subscribes to the message and updates the UI so that only items that match the filter\ncriteria are displayed.', 'task_item': False}, {'text': "The `ChangeTab` message is published by the `MainViewModel` class when the\n`CheckoutViewModel` navigates to the `MainViewModel` following the successful creation and\nsubmission of a new order. In return, the `MainView` class subscribes to the message and\nupdates the UI so that the **My profile** tab is active, to show the user's orders.", 'task_item': False}, {'text': 'In the eShopOnContainers mobile app, `MessagingCenter` is used to update in the UI in response to\nan action occurring in another class. Therefore, messages are published on the UI thread, with\nsubscribers receiving the message on the same thread.', 'task_item': False}, {'text': '25 CHAPTER 4 | Communicating between loosley coupled components', 'task_item': False}, {'text': 'For more information about `MessagingCenter` [, see MessagingCenter](https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/messaging-center/) on the Xamarin Developer\nCenter.', 'task_item': False}], [{'text': 'The first argument specifies the sender class. The sender class must be specified by any\nsubscribers who wish to receive the message.', 'task_item': False}, {'text': 'The second argument specifies the message.', 'task_item': False}, {'text': 'The third argument specifies the payload data to be sent to the subscriber. In this case the\npayload data is a `CatalogItem` instance.', 'task_item': False}, {'text': 'The `Send` method will publish the message, and its payload data, using a fire-and-forget approach.\nTherefore, the message is sent even if there are no subscribers registered to receive the message. In\nthis situation, the sent message is ignored.', 'task_item': False}, {'text': '26 CHAPTER 4 | Communicating between loosley coupled components', 'task_item': False}], [{'text': 'How to identify the view to be navigated to, using an approach that does not introduce tight\ncoupling and dependencies between views.', 'task_item': False}, {'text': "How to coordinate the process by which the view to be navigated to is instantiated and\ninitialized. When using MVVM, the view and view model need to be instantiated and\nassociated with each other via the view's binding context. When an app is using a\ndependency injection container, the instantiation of views and view models might require a\nspecific construction mechanism.", 'task_item': False}, {'text': 'Whether to perform view-first navigation, or view model-first navigation. With view-first\nnavigation, the page to navigate to refers to the name of the view type. During navigation,\nthe specified view is instantiated, along with its corresponding view model and other\ndependent services. An alternative approach is to use view model-first navigation, where the\npage to navigate to refers to the name of the view model type.', 'task_item': False}, {'text': "How to cleanly separate the navigational behavior of the app across the views and view\nmodels. The MVVM pattern provides a separation between the app's UI and its presentation\nand business logic. However, the navigation behavior of an app will often span the UI and\npresentations parts of the app. The user will often initiate navigation from a view, and the\nview will be replaced as a result of the navigation. However, navigation might often also need\nto be initiated or coordinated from within the view model.", 'task_item': False}, {'text': 'How to pass parameters during navigation for initialization purposes. For example, if the user\nnavigates to a view to update order details, the order data will have to be passed to the view\nso that it can display the correct data.', 'task_item': False}, {'text': 'How to co-ordinate navigation, to ensure that certain business rules are obeyed. For example,\nusers might be prompted before navigating away from a view so that they can correct any\ninvalid data or be prompted to submit or discard any data changes that were made within the\nview.', 'task_item': False}, {'text': "This chapter addresses these challenges by presenting a `NavigationService` class that's used to\nperform view model-first page navigation.", 'task_item': False}, {'text': '28 CHAPTER 5 | Navigation', 'task_item': False}], [{'text': 'Views are in the same assembly as view model types.', 'task_item': False}, {'text': 'Views are in a .Views child namespace.', 'task_item': False}, {'text': 'View models are in a .ViewModels child namespace.', 'task_item': False}, {'text': 'View names correspond to view model names, with "Model" removed.', 'task_item': False}, {'text': "When a view is instantiated, it's associated with its corresponding view model. For more information\nabout how this occurs, see Automatically creating a view model with a view model locator.", 'task_item': False}, {'text': "If the view being created is a `LoginView`, it's wrapped inside a new instance of the\n`CustomNavigationView` class and assigned to the `Application.Current.MainPage` property.\nOtherwise, the `CustomNavigationView` instance is retrieved, and provided that it isn't `null`, the\n`PushAsync` method is invoked to push the view being created onto the navigation stack. However, If\nthe retrieved `CustomNavigationView` instance is `null`, the view being created is wrapped inside a\nnew instance of the `CustomNavigationView` class and assigned to the\n`Application.Current.MainPage` property. This mechanism ensures that during navigation, pages\nare added correctly to the navigation stack both when it's empty, and when it contains data.", 'task_item': False}, {'text': "After the view is created and navigated to, the `InitializeAsync` method of the view's associated\nview model is executed. For more information, see Passing parameters during navigation.", 'task_item': False}], [{'text': 'Each microservice is relatively small, easy to manage and evolve.', 'task_item': False}, {'text': 'Each microservice can be developed and deployed independently of other services.', 'task_item': False}, {'text': 'Each microservice can be scaled-out independently. For example, a catalog service or\nshopping basket service might need to be scaled-out more than an ordering service.\nTherefore, the resulting infrastructure will more efficiently consume resources when scaling\nout.', 'task_item': False}, {'text': 'Each microservice isolates any issues. For example, if there is an issue in a service it only\nimpacts that service. The other services can continue to handle requests.', 'task_item': False}, {'text': 'Each microservice can use the latest technologies. Because microservices are autonomous and\nrun side-by-side, the latest technologies and frameworks can be used, rather than being\nforced to use an older framework that might be used by a monolithic application.', 'task_item': False}, {'text': 'However, a microservice based solution also has potential drawbacks:', 'task_item': False}, {'text': 'Choosing how to partition an application into microservices can be challenging, as each\nmicroservice has to be completely autonomous, end-to-end, including responsibility for its\ndata sources.', 'task_item': False}, {'text': 'Developers must implement inter-service communication, which adds complexity and latency\nto the application.', 'task_item': False}, {'text': "Atomic transactions between multiple microservices usually aren't possible. Therefore,\nbusiness requirements must embrace eventual consistency between microservices.", 'task_item': False}, {'text': 'In production, there is an operational complexity in deploying and managing a system\ncompromised of many independent services.', 'task_item': False}, {'text': 'Direct client-to-microservice communication can make it difficult to refactor the contracts of\nmicroservices. For example, over time how the system is partitioned into services might need\nto change. A single service might split into two or more services, and two services might\nmerge. When clients communicate directly with microservices, this refactoring work can break\ncompatibility with client apps.', 'task_item': False}], [{'text': 'Container Host: The physical or virtual machine configured to host containers. The container\nhost will run one or more containers.', 'task_item': False}, {'text': "Container Image: An image consists of a union of layered filesystems stacked on top of each\nother, and is the basis of a container. An image does not have state and it never changes as\nit's deployed to different environments.", 'task_item': False}, {'text': 'Container: A container is a runtime instance of an image.', 'task_item': False}, {'text': "Container OS Image: Containers are deployed from images. The container operating system\nimage is the first layer in potentially many image layers that make up a container. A container\noperating system is immutable, and can't be modified.", 'task_item': False}, {'text': 'Container Repository: Each time a container image is created, the image and its dependencies\nare stored in a local repository. These images can be reused many times on the container\n[host. The container images can also be stored in a public or private registry, such as Docker](https://hub.docker.com/)\nHub, so that they can be used across different container hosts.', 'task_item': False}, {'text': '54 CHAPTER 8 | Containerized microservices', 'task_item': False}, {'text': 'Enterprises are increasingly adopting containers when implementing microservice based applications,\nand Docker has become the standard container implementation that has been adopted by most\nsoftware platforms and cloud vendors.', 'task_item': False}, {'text': 'The eShopOnContainers reference application uses Docker to host four containerized back-end\nmicroservices, as illustrated in Figure 8-4.', 'task_item': False}, {'text': 'The architecture of the back-end services in the reference application is decomposed into multiple\nautonomous sub-systems in the form of collaborating microservices and containers. Each microservice\nprovides a single area of functionality: an identity service, a catalog service, an ordering service, and a\nbasket service.', 'task_item': False}, {'text': 'Each microservice has its own database, allowing it to be fully decoupled from the other\nmicroservices. Where necessary, consistency between databases from different microservices is\nachieved using application-level events. For more information, see Communication between\nmicroservices.', 'task_item': False}, {'text': '[For more information about the reference application, see .NET Microservices: Architecture for](https://aka.ms/microservicesebook)\n[Containerized .NET Applications.](https://aka.ms/microservicesebook)', 'task_item': False}], [{'text': 'Authenticating users with IdentityServer is achieved by the mobile app requesting an _identity_\ntoken, which represents the outcome of an authentication process. At a bare minimum, it\ncontains an identifier for the user, and information about how and when the user\nauthenticated. It can also contain additional identity data.', 'task_item': False}, {'text': 'Accessing a resource with IdentityServer is achieved by the mobile app requesting an _access_\ntoken, which allows access to an API resource. Clients request access tokens and forward\nthem to the API. Access tokens contain information about the client, and the user (if present).\nAPIs then use that information to authorize access to their data.', 'task_item': False}], [{'text': 'Credentials used for signing.', 'task_item': False}, {'text': 'API and identity resources that users might request access to.', 'task_item': False}, {'text': 'Clients that will be connecting to request tokens.', 'task_item': False}, {'text': 'ASP.NET Core Identity.', 'task_item': False}, {'text': '[For information about configuring IdentityServer to use ASP.NET Core Identity, see Using ASP.NET](https://identityserver4.readthedocs.io/en/release/quickstarts/6_aspnet_identity.html)\n[Core Identity](https://identityserver4.readthedocs.io/en/release/quickstarts/6_aspnet_identity.html) in the IdentityServer documentation.', 'task_item': False}, {'text': '61 CHAPTER 9 | Authentication and authorization', 'task_item': False}, {'text': '**Configuring API resources**', 'task_item': False}, {'text': 'When configuring API resources, the `AddInMemoryApiResources` method expects an\n`IEnumerable<ApiResource>` collection. The following code example shows the `GetApis` method that\nprovides this collection in the eShopOnContainers reference application:', 'task_item': False}, {'text': 'This method specifies that IdentityServer should protect the `orders` and `basket` APIs. Therefore,\nIdentityServer managed access tokens will be required when making calls to these APIs. For more\ninformation about the `ApiResource` [type, see API Resource](https://identityserver4.readthedocs.io/en/release/reference/api_resource.html#refapiresource) in the IdentityServer 4 documentation.', 'task_item': False}, {'text': '**Configuring identity resources**', 'task_item': False}, {'text': 'When configuring identity resources, the `AddInMemoryIdentityResources` method expects an\n`IEnumerable<IdentityResource>` collection. Identity resources are data such as user ID, name, or\nemail address. Each identity resource has a unique name, and arbitrary claim types can be assigned to\nit, which will then be included in the identity token for the user. The following code example shows\nthe `GetResources` method that provides this collection in the eShopOnContainers reference\napplication:', 'task_item': False}, {'text': '[The OpenID Connect specification specifies some standard identity resources. The minimum](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims)\nrequirement is that support is provided for emitting a unique ID for users. This is achieved by\nexposing the `IdentityResources.OpenId` identity resource.', 'task_item': False}, {'text': '[IdentityServer also supports defining custom identity resources. For more information, see Defining](https://identityserver4.readthedocs.io/en/release/topics/resources.html#defining-custom-identity-resources)\n[custom identity resources in the IdentityServer documentation. For more information about the](https://identityserver4.readthedocs.io/en/release/topics/resources.html#defining-custom-identity-resources)\n`IdentityResource` type, see [Identity Resource](https://identityserver4.readthedocs.io/en/release/reference/identity_resource.html) in the IdentityServer 4 documentation.', 'task_item': False}, {'text': '**Configuring clients**', 'task_item': False}, {'text': 'Clients are applications that can request tokens from IdentityServer. Typically, the following settings\nmust be defined for each client as a minimum:', 'task_item': False}, {'text': 'A unique client ID.', 'task_item': False}, {'text': 'The allowed interactions with the token service (known as the grant type).', 'task_item': False}, {'text': 'The location where identity and access tokens are sent to (known as a redirect URI).', 'task_item': False}, {'text': '62 CHAPTER 9 | Authentication and authorization', 'task_item': False}, {'text': 'A list of resources that the client is allowed access to (known as scopes).', 'task_item': False}, {'text': 'When configuring clients, the `AddInMemoryClients` method expects an `IEnumerable<Client>`\ncollection. The following code example shows the configuration for the eShopOnContainers mobile\napp in the `GetClients` method that provides this collection in the eShopOnContainers reference\napplication:', 'task_item': False}, {'text': 'This configuration specifies data for the following properties:', 'task_item': False}, {'text': '`ClientId` : A unique ID for the client.', 'task_item': False}, {'text': '`ClientName` : The client display name, which is used for logging and the consent screen.', 'task_item': False}, {'text': '`AllowedGrantTypes` : Specifies how a client wants to interact with IdentityServer. For more\ninformation see Configuring the authentication flow.', 'task_item': False}, {'text': '`ClientSecrets` : Specifies the client secret credentials that are used when requesting tokens\nfrom the token endpoint.', 'task_item': False}, {'text': '`RedirectUris` : Specifies the allowed URIs to which to return tokens or authorization codes.', 'task_item': False}, {'text': '`RequireConsent` : Specifies whether a consent screen is required.', 'task_item': False}, {'text': '`RequirePkce` : Specifies whether clients using an authorization code must send a proof key.', 'task_item': False}, {'text': '`PostLogoutRedirectUris` : Specifies the allowed URIs to redirect to after logout.', 'task_item': False}, {'text': '63 CHAPTER 9 | Authentication and authorization', 'task_item': False}, {'text': '`AllowedCorsOrigins` : Specifies the origin of the client so that IdentityServer can allow crossorigin calls from the origin.', 'task_item': False}, {'text': '`AllowedScopes` : Specifies the resources the client has access to. By default, a client has no\naccess to any resources.', 'task_item': False}, {'text': '`AllowOfflineAccess` : Specifies whether the client can request refresh tokens.', 'task_item': False}, {'text': '**Configuring the authentication flow**', 'task_item': False}, {'text': 'The authentication flow between a client and IdentityServer can be configured by specifying the grant\ntypes in the `Client.AllowedGrantTypes` property. The OpenID Connect and OAuth 2.0 specifications\ndefine a number of authentication flows, including:', 'task_item': False}, {'text': 'Implicit. This flow is optimized for browser-based applications and should be used either for\nuser authentication-only, or authentication and access token requests. All tokens are\ntransmitted via the browser, and therefore advanced features like refresh tokens are not\npermitted.', 'task_item': False}, {'text': 'Authorization code. This flow provides the ability to retrieve tokens on a back channel, as\nopposed to the browser front channel, while also supporting client authentication.', 'task_item': False}, {'text': 'Hybrid. This flow is a combination of the implicit and authorization code grant types. The\nidentity token is transmitted via the browser channel and contains the signed protocol\nresponse along with other artifacts such as the authorization code. After successful validation\nof the response, the back channel should be used to retrieve the access and refresh token.', 'task_item': False}, {'text': '[For more information about authentication flows, see Grant Types](https://identityserver4.readthedocs.io/en/release/topics/grant_types.html) in the IdentityServer 4\ndocumentation.', 'task_item': False}], [{'text': 'A shared cache, which can be accessed by multiple processes or machines.', 'task_item': False}, {'text': 'A private cache, where data is held locally on the device running the app.', 'task_item': False}, {'text': "The eShopOnContainers mobile app uses a private cache, where data is held locally on the device\nthat's running an instance of the app. For information about the cache used by the\neShopOnContainers reference application, see [.NET Microservices: Architecture for Containerized .NET](https://aka.ms/microservicesebook)\n[Applications.](https://aka.ms/microservicesebook)", 'task_item': False}, {'text': '81 CHAPTER 10 | Accessing remote data', 'task_item': False}], [{'text': 'Detect faults when they occur, and determine if the faults are likely to be transient.', 'task_item': False}, {'text': 'Retry the operation if it determines that the fault is likely to be transient and keep track of the\nnumber of times the operation was retried.', 'task_item': False}, {'text': 'Use an appropriate retry strategy, which specifies the number of retries, the delay between\neach attempt, and the actions to take after a failed attempt.', 'task_item': False}, {'text': 'This transient fault handling can be achieved by wrapping all attempts to access a remote service in\ncode that implements the retry pattern.', 'task_item': False}], [{'text': 'Retrying the operation. The app could retry the failing request immediately.', 'task_item': False}, {'text': 'Retrying the operation after a delay. The app should wait for a suitable amount of time before\nretrying the request.', 'task_item': False}, {'text': 'Cancelling the operation. The application should cancel the operation and report an\nexception.', 'task_item': False}, {'text': '83 CHAPTER 10 | Accessing remote data', 'task_item': False}, {'text': "The retry strategy should be tuned to match the business requirements of the app. For example, it's\nimportant to optimize the retry count and retry interval to the operation being attempted. If the\noperation is part of a user interaction, the retry interval should be short and only a few retries\nattempted to avoid making users wait for a response. If the operation is part of a long running\nworkflow, where cancelling or restarting the workflow is expensive or time-consuming, it's appropriate\nto wait longer between attempts and to retry more times.", 'task_item': False}, {'text': "If a request still fails after a number of retries, it's better for the app to prevent further requests going\nto the same resource and to report a failure. Then, after a set period, the app can make one or more\nrequests to the resource to see if they're successful. For more information, see Circuit breaker pattern.", 'task_item': False}, {'text': "The eShopOnContainers mobile app does not currently implement the retry pattern when making\nRESTful web requests. However, the `CachedImage` control, provided by the [FFImageLoading](https://www.nuget.org/packages/Xamarin.FFImageLoading.Forms/) library\nsupports transient fault handling by retrying image loading. If image loading fails, further attempts\nwill be made. The number of attempts is specified by the `RetryCount` property, and retries will occur\nafter a delay specified by the `RetryDelay` property. If these property values aren't explicitly set, their\ndefault values are applied â€“ 3 for the `RetryCount` property, and 250ms for the `RetryDelay` property.\nFor more information about the `CachedImage` control, see Caching images.", 'task_item': False}, {'text': 'The eShopOnContainers reference application does implement the retry pattern. For more\ninformation, including a discussion of how to combine the retry pattern with the `HttpClient` class,\n[see .NET Microservices: Architecture for Containerized .NET Applications.](https://aka.ms/microservicesebook)', 'task_item': False}, {'text': '[For more information about the retry pattern, see the Retry](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry) pattern on Microsoft Docs.', 'task_item': False}], [{'text': 'The _arrange_ section of the unit test method initializes objects and sets the value of the data\nthat is passed to the method under test.', 'task_item': False}, {'text': 'The _act_ section invokes the method under test with the required arguments.', 'task_item': False}, {'text': 'The _assert_ section verifies that the action of the method under test behaves as expected.', 'task_item': False}, {'text': 'Following this pattern ensures that unit tests are readable and consistent.', 'task_item': False}], [{'text': 'Facts are tests that are always true, which test invariant conditions.', 'task_item': False}, {'text': 'Theories are tests that are only true for a particular set of data.', 'task_item': False}, {'text': '87 CHAPTER 11 | Unit testing', 'task_item': False}, {'text': 'The unit tests included with the eShopOnContainers mobile app are fact tests, and so each unit test\nmethod is decorated with the `[Fact]` attribute.', 'task_item': False}]]}