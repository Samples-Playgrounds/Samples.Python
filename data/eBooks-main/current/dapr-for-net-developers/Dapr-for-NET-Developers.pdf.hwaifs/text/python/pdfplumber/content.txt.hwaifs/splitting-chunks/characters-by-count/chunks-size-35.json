"[\"EDITION v1.2\\nPUBLISHED BY\\nMicrosoft Developer Division, .NET, and Azure Incubations teams\\nA division\", \" of Microsoft Corporation\\nOne Microsoft Way\\nRedmond, Washington 98052-6399\\nCopyright \\u00a9 2023 by Micro\", \"soft Corporation\\nAll rights reserved. No part of the contents of this book may be reproduced or tran\", \"smitted in any\\nform or by any means without the written permission of the publisher.\\nThis book is pr\", \"ovided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions, and\\ninformation e\", \"xpressed in this book, including URL and other Internet website references, may change\\nwithout notic\", \"e.\\nSome examples depicted herein are provided for illustration only and are fictitious. No real asso\", \"ciation\\nor connection is intended or should be inferred.\\nMicrosoft and the trademarks listed at http\", \"s://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are\\ntrademarks of the Microsoft group of companies\", \".\\nMac and macOS are trademarks of Apple Inc.\\nThe Docker whale logo is a registered trademark of Dock\", \"er, Inc. Used by permission.\\nAll other marks and logos are property of their respective owners.\\nAuth\", \"ors:\\nRob Vettor, Principal Cloud Solution Architect - thinkingincloudnative.com, Microsoft\\nSander Mo\", \"lenkamp, Principal Cloud Architect/Microsoft MVP - sandermolenkamp.com, Info Support\\nEdwin van Wijk,\", \" Principal Solution Architect/Microsoft MVP - defaultconstructor.com, Info Support\\nParticipants and \", \"Reviewers:\\nMark Russinovich, Azure CTO and Technical Fellow, Azure Office of CTO, Microsoft\\nNish Ani\", \"l, Senior Program Manager, .NET team, Microsoft\\nMark Fussell, Principal Program Manager, Azure Incub\", \"ations, Microsoft\\nYaron Schneider, Principal Software Engineer, Azure Incubations, Microsoft\\nOri Zoh\", \"ar, Senior Program Manager, Azure Incubations, Microsoft\\nEditors:\\nDavid Pine, Senior Content Develop\", \"er, .NET team, Microsoft\\nMaira Wenzel, Senior Program Manager, .NET team, MicrosoftSteve \\u201cardalis\\u201d S\", \"mith, Senior Architect and Trainer, NimblePros\\nVersion\\nThis guide has been written to cover the Dapr\", \" 1.9 version. .NET samples are based on .NET 7.\\nWho should use this guide\\nThe audience for this guid\", \"e is mainly developers, development leads, and architects who are\\ninterested in learning how to buil\", \"d applications designed for the cloud.\\nA secondary audience is technical decision-makers who plan to\", \" choose whether to build their\\napplications using a cloud-native approach.\\nHow you can use this guid\", \"e\\nThis guide is available both in PDF form and online. Feel free to forward this document or links t\", \"o its\\nonline version to your team to help ensure common understanding of these topics. Most of these\", \"\\ntopics benefit from a consistent understanding of the underlying principles and patterns, as well a\", \"s\\nthe trade-offs involved in decisions related to these topics. Our goal with this document is to eq\", \"uip\\nteams and their leaders with the information they need to make well-informed decisions for their\", \"\\napplications\\u2019 architecture, development, and hosting.Contents\\nForeword - Dapr for .NET Developers .\", \".................................................................................. 1\\nThe world is di\", \"stributed ..........................................................................................\", \"................ 3\\nSummary .........................................................................\", \"....................................................................................................\", \"........ 7\\nDapr at 20,000 feet .....................................................................\", \"............................................ 8\\nDapr and the problem it solves ......................\", \"....................................................................................................\", \"................ 8\\nDapr architecture ...............................................................\", \"....................................................................................................\", \".. 9\\nBuilding blocks ...............................................................................\", \"...................................................................................... 9\\nComponents \", \"....................................................................................................\", \"................................................................... 11\\nSidecar architecture ........\", \"....................................................................................................\", \"............................................. 13\\nHosting environments ..............................\", \"....................................................................................................\", \".................. 14\\nDapr performance considerations ..............................................\", \"................................................................................... 15\\nDapr and serv\", \"ice meshes .........................................................................................\", \".......................................................... 16\\nSummary ..............................\", \"....................................................................................................\", \"................................................ 18\\nReferences .....................................\", \"....................................................................................................\", \".................................. 18\\nGet started with Dapr ........................................\", \"................................................................... 19\\nInstall Dapr into your local \", \"environment ........................................................................................\", \"............................. 19\\nBuild your first Dapr application .................................\", \"....................................................................................................\", \" 19\\nCreate the application .........................................................................\", \"........................................................................... 19\\nAdd Dapr State Manage\", \"ment ...............................................................................................\", \"...................................... 20\\nComponent configuration files ............................\", \"....................................................................................................\", \"....... 21\\nBuild a multi-container Dapr application ................................................\", \".................................................................... 23\\nCreate the application .....\", \"....................................................................................................\", \"........................................... 23\\nAdd Dapr service invocation .........................\", \"....................................................................................................\", \"........... 27\\nAdd container support ...............................................................\", \".................................................................................... 29\\nSummary ....\", \"....................................................................................................\", \".......................................................................... 35\\nReferences ...........\", \"....................................................................................................\", \"............................................................ 35\\nTraffic Control sample application .\", \"..................................................................................... 36\\nUsing Dapr \", \"building blocks.....................................................................................\", \".......................................................... 39\\ni ContentsHosting ....................\", \"....................................................................................................\", \".............................................................. 40\\nSelf-hosted mode .................\", \"....................................................................................................\", \"....................................... 40\\nKubernetes ..............................................\", \"....................................................................................................\", \"........................ 41\\nSummary ................................................................\", \"....................................................................................................\", \".............. 41\\nReferences .......................................................................\", \"....................................................................................................\", \" 41\\nThe Dapr state management building block .......................................................\", \"............... 42\\nWhat it solves ..................................................................\", \"....................................................................................................\", \"... 42\\nHow it works ................................................................................\", \"........................................................................................... 43\\nConsi\", \"stency .............................................................................................\", \"............................................................................ 43\\nConcurrency ........\", \"....................................................................................................\", \"........................................................... 45\\nTransactions ........................\", \"....................................................................................................\", \"........................................... 45\\nUse the Dapr .NET SDK ...............................\", \"....................................................................................................\", \".................... 46\\nASP.NET Core integration ...................................................\", \".......................................................................................... 47\\nState \", \"store components ...................................................................................\", \".................................................................. 47\\nConfiguration ................\", \"....................................................................................................\", \"................................................. 48\\nKey prefix strategies .........................\", \"....................................................................................................\", \"........................... 49\\nSample application: Dapr Traffic Control ............................\", \"........................................................................................ 50\\nSummary \", \"....................................................................................................\", \".............................................................................. 51\\nReferences .......\", \"....................................................................................................\", \"................................................................ 52\\nThe Dapr service invocation buil\", \"ding block ....................................................................... 53\\nWhat it solves\", \" ...................................................................................................\", \"...................................................................... 53\\nHow it works .............\", \"....................................................................................................\", \".......................................................... 53\\nUse the Dapr .NET SDK ................\", \"....................................................................................................\", \"................................... 55\\nInvoke HTTP services using HttpClient .......................\", \"............................................................................................. 55\\nInv\", \"oke HTTP services using DaprClient .................................................................\", \".................................................. 57\\nInvoke gRPC services using DaprClient ........\", \"....................................................................................................\", \"....... 58\\nName resolution components ..............................................................\", \"........................................................................... 58\\nConfiguration .......\", \"....................................................................................................\", \".......................................................... 58\\nSample application: Dapr Traffic Contr\", \"ol .................................................................................................\", \"................... 59\\nSummary .....................................................................\", \"....................................................................................................\", \"......... 60\\nReferences ............................................................................\", \"............................................................................................... 60\\ni\", \"i ContentsThe Dapr publish & subscribe building block ..............................................\", \"...................... 61\\nWhat it solves ...........................................................\", \"....................................................................................................\", \".......... 61\\nHow it works .........................................................................\", \".................................................................................................. 6\", \"2\\nCompeting consumers ..............................................................................\", \"..................................................................... 66\\nUse the Dapr .NET SDK .....\", \"....................................................................................................\", \".............................................. 66\\nPub/sub components ...............................\", \"....................................................................................................\", \"....................... 68\\nConfiguration ...........................................................\", \"....................................................................................................\", \"...... 68\\nSample application: Dapr Traffic Control .................................................\", \"................................................................... 69\\nSummary .....................\", \"....................................................................................................\", \"......................................................... 71\\nReferences ............................\", \"....................................................................................................\", \"........................................... 71\\nThe Dapr bindings building block ....................\", \"................................................................... 72\\nWhat it solves ..............\", \"....................................................................................................\", \"....................................................... 72\\nHow it works ............................\", \"....................................................................................................\", \"........................................... 73\\nInput bindings ......................................\", \"....................................................................................................\", \"......................... 73\\nOutput bindings .......................................................\", \"....................................................................................................\", \".... 74\\nUse the Dapr .NET SDK ......................................................................\", \"................................................................................. 76\\nBinding compone\", \"nts ................................................................................................\", \"........................................................... 76\\nCron binding ........................\", \"....................................................................................................\", \".......................................... 77\\nSample application: Dapr Traffic Control .............\", \"....................................................................................................\", \"... 78\\nMQTT input binding ..........................................................................\", \".............................................................................. 79\\nSMTP output bindin\", \"g ..................................................................................................\", \"................................................... 81\\nSummary .....................................\", \"....................................................................................................\", \"......................................... 83\\nReferences ............................................\", \"....................................................................................................\", \"........................... 83\\nThe Dapr actors building block ......................................\", \"...................................................... 84\\nWhat it solves ...........................\", \"....................................................................................................\", \".......................................... 84\\nHow it works .........................................\", \"....................................................................................................\", \".............................. 85\\nTurn-based access model ..........................................\", \"................................................................................................... \", \"88\\nTimers and reminders ............................................................................\", \"......................................................................... 89\\nState persistence .....\", \"....................................................................................................\", \"..................................................... 89\\nUse the Dapr .NET SDK .....................\", \"....................................................................................................\", \".............................. 90\\nCall actors from ASP.NET Core clients ............................\", \"......................................................................................... 93\\niii Con\", \"tentsCall non-.NET actors...........................................................................\", \"............................................................................. 94\\nTimers and reminder\", \"s ..................................................................................................\", \"................................................... 95\\nSample application: Dapr Traffic Control ....\", \"....................................................................................................\", \"............ 97\\nSummary ............................................................................\", \"....................................................................................................\", \".. 98\\nReferences ...................................................................................\", \"........................................................................................ 99\\nThe Dapr\", \" observability building block ......................................................................\", \"........ 100\\nWhat it solves ........................................................................\", \"............................................................................................... 101\\n\", \"How it works .......................................................................................\", \".................................................................................. 101\\nDistributed t\", \"racing .............................................................................................\", \"............................................................ 102\\nMetrics ...........................\", \"....................................................................................................\", \"................................................. 109\\nLogging ......................................\", \"....................................................................................................\", \".................................... 111\\nHealth status .............................................\", \"....................................................................................................\", \"................... 113\\nDapr dashboard .............................................................\", \"................................................................................................. 11\", \"4\\nUse the Dapr .NET SDK ............................................................................\", \"......................................................................... 115\\nSample application: Da\", \"pr Traffic Control .................................................................................\", \"................................. 115\\nSummary ......................................................\", \"....................................................................................................\", \"...................... 117\\nReferences ..............................................................\", \"....................................................................................................\", \"........... 118\\nThe Dapr secrets management building block .........................................\", \"....................... 119\\nWhat it solves .........................................................\", \"....................................................................................................\", \".......... 119\\nHow it works ........................................................................\", \"................................................................................................. 12\", \"0\\nUse the Dapr .NET SDK ............................................................................\", \"......................................................................... 121\\nSecret store component\", \"s ..................................................................................................\", \"............................................... 122\\nConfiguration ..................................\", \"....................................................................................................\", \"............................. 123\\nIndirectly consume Dapr secrets ..................................\", \"............................................................................................ 123\\nLoc\", \"al file ............................................................................................\", \"................................................................................. 124\\nKubernetes sec\", \"ret ................................................................................................\", \".......................................................... 126\\nAzure Key Vault .....................\", \"....................................................................................................\", \"...................................... 126\\nScope secrets ...........................................\", \"....................................................................................................\", \".................... 129\\nSample application: Dapr Traffic Control ..................................\", \"................................................................................ 129\\nSecrets .......\", \"....................................................................................................\", \"..................................................................... 131\\nSMTP server credentials ..\", \"....................................................................................................\", \"........................................ 132\\nRedis server credentials ..............................\", \"....................................................................................................\", \"............. 133\\niv ContentsFineCalculator component license key ..................................\", \"................................................................................ 134\\nSummary .......\", \"....................................................................................................\", \"..................................................................... 135\\nReferences ...............\", \"....................................................................................................\", \".......................................................... 135\\nDapr reference application ..........\", \"....................................................................................... 137\\neShopOnC\", \"ontainers ..........................................................................................\", \"................................................................. 137\\neShopOnDapr ..................\", \"....................................................................................................\", \"................................................. 138\\nApplication of Dapr building blocks...........\", \"....................................................................................................\", \"............. 139\\nState management .................................................................\", \"....................................................................................... 140\\nService \", \"invocation .........................................................................................\", \"................................................................. 142\\nPublish & subscribe ..........\", \"....................................................................................................\", \"......................................... 147\\nBindings .............................................\", \"....................................................................................................\", \"............................ 150\\nActors ............................................................\", \"....................................................................................................\", \".................. 152\\nObservability ...............................................................\", \"....................................................................................................\", \". 158\\nSecrets ......................................................................................\", \".......................................................................................... 159\\nBenef\", \"its of applying Dapr to eShop ......................................................................\", \"...................................................... 160\\nSummary .................................\", \"....................................................................................................\", \"........................................... 161\\nReferences .........................................\", \"....................................................................................................\", \"............................ 161\\nSummary and the road ahead ........................................\", \".................................................... 162\\nThe road ahead ............................\", \"....................................................................................................\", \".................................... 165\\nv Contents1\\nCHAPTER\\nForeword - Dapr for .NET\\nDevelopers\\nWit\", \"h the wave of cloud adoption underway, there is a major shift happening towards \\u201ccloud native\\u201d\\ndevel\", \"opment, often built with microservice-architectures. These microservices are both stateless and\\nstat\", \"eful, and run on the cloud and edge, embracing the diversity of languages and frameworks\\navailable t\", \"oday. This enterprise shift is driven by both the market forces of faster time to market, and\\nthe sc\", \"ale and efficiencies of building services for the cloud. Even before COVID-19, cloud adoption\\nwas ac\", \"celerating for enterprises, and developers were being asked to do even more to deliver on\\nbuilding t\", \"hese distributed system applications. That has only accelerated since COVID-19. Developers\\nin enterp\", \"rises seek to focus on business logic, while leaning on platforms to imbue their applications\\nwith s\", \"cale, resiliency, maintainability, elasticity, and the other attributes of cloud-native architecture\", \"s,\\nwhich is why there is also shift towards serverless platforms that hide the underlying infrastruc\", \"ture.\\nDevelopers should not be expected to become distributed systems experts. This is where Dapr st\", \"eps\\nin to help you, whether you are building on infrastructure such as Kubernetes, or on a serverles\", \"s\\nplatform.\\nDapr is designed as an enterprise, developer-focused, microservices programming model pl\", \"atform\\nwith the mantra \\u201cany language, any framework, run anywhere\\u201d. It makes building distributed\\nap\", \"plications easy and portable across any infrastructure, from public-cloud, through hierarchical edge\", \",\\nand even down to single node IoT devices. It emerged from both our experiences building services i\", \"n\\nAzure and time spent working with customers building applications on Azure Kubernetes Service and\\n\", \"Azure Service Fabric. Over and over, we saw common problems that they had to address. It became\\nclea\", \"r that there was a need to provide a \\u201clibrary\\u201d of common microservice best practices that\\ndevelopers\", \" could use, not only in new green field applications, but also to aid in the modernization of\\nexisti\", \"ng applications. In the containerized, distributed, and networked cloud native world, the sidecar\\nmo\", \"del has emerged as the preferred approach, in the same way DLLs are preferred in the client/server\\ng\", \"eneration. Using Dapr\\u2019s sidecar and APIs give you, as a developer, all the power of distributed\\nsyst\", \"ems functionality, with the ease of a single HTTP or gRPC local call.\\nTo address the wide range of s\", \"cenarios that developers face, Dapr provides features such as state\\nmanagement, service-to-service i\", \"nvocation, pub/sub, and integration to external systems with I/O\\nbindings, which are based on the tr\", \"iggers and bindings of Azure Functions. These in turn take\\nadvantage of Dapr\\u2019s component model, whic\", \"h allows you to \\u201cswap out\\u201d, say different underlying state\\nstores, without having to change any code\", \". This component model makes code more portable, more\\nflexible, and allows for experimentation of wh\", \"at best suits your needs. Developers don\\u2019t need to learn\\n1 CHAPTER 1 | Foreword - Dapr for .NET Deve\", \"lopersand incorporate service SDKs into their code, or worry about authentication, secret management\", \",\\nretries, or conditional code that targets specific deployment environments.\\nThis book shows how Da\", \"pr reduces your development time and overall code maintenance by\\nincrementally \\u201cDaperizing\\u201d the cano\", \"nical .NET reference application, eShop. For example, in the\\noriginal eShop implementation, signific\", \"ant amounts of code were written to abstract between Azure\\nService Bus and RabbitMQ for publishing e\", \"vents between services. All this code can be discarded and\\nsimply replaced with Dapr\\u2019s pub/sub API a\", \"nd component model, which had an even wider range of\\npub/sub brokers, rather than just two. Dapr\\u2019s a\", \"ctor model, when used in the reworked eShop\\napplication, shows the ease of building long running, st\", \"ateful, event driven, workflow applications with\\nall the difficulties of concurrency and multi-threa\", \"ding removed. By the end of this book, you will see\\nthe drastic simplification that Dapr brings to y\", \"our application development, and I firmly believe all\\ndevelopers embarking on a cloud native app bui\", \"lding journey should use Dapr.\\nWe publicly announced Dapr with the v0.1 release in Oct 2019 and now,\", \" a year and half later, I am\\nthrilled to say that Dapr is ready for production usage with the v1.0 r\", \"elease. Getting Dapr to v1.0 has\\ntruly been a community effort. It has been amazing to see the open-\", \"source community coalesce\\naround Dapr and grow since it was first announced \\u2013 from 114 contributors \", \"in October 2019 to over\\n700 in early 2021 - a six-fold increase in 16 months! Contributions to the p\", \"roject have gone to every\\nDapr repo and have ranged from opening issues, commenting on feature propo\", \"sals, providing\\nsamples, and, of course, contributing code. The parts of the project community membe\", \"rs have\\ncontributed to the most include the Dapr runtime, docs, CLI, SDKs, and the creation of a ric\", \"h\\necosystem of components. Maintaining this openness is critical to Dapr\\u2019s future.\\nDapr is just gett\", \"ing started, though, and you should expect to see more Dapr capabilities and more\\nsupport for Dapr i\", \"n Azure services. I hope that you will take advantage of Dapr to enable you to focus\\non your core bu\", \"siness logic and accelerate your microservices development. I am excited to have you\\njoin us in the \", \"Dapr community on this journey at https://github.com/dapr/ and on Discord\\nhttps://aka.ms/dapr-discor\", \"d.\\nModern distributed systems are complex. You start with small, loosely coupled, independently\\ndepl\", \"oyable services. These services cross process and server boundaries. They then consume different\\nkin\", \"ds of infrastructure backing services (databases, message brokers, key vaults). Finally, these\\ndispa\", \"rate pieces compose together to form an application.\\nMark Russinovich Azure CTO and Technical Fellow\", \" Microsoft\\n2 CHAPTER 1 | Foreword - Dapr for .NET Developers2\\nCHAPTER\\nThe world is distributed\\nJust \", \"ask any \\u2018cool kid\\u2019: Modern, distributed systems are in, and monolithic apps are out!\\nBut, it\\u2019s not j\", \"ust \\u201ccool kids.\\u201d Progressive IT Leaders, corporate architects, and astute developers are\\nechoing the\", \"se same thoughts as they explore and evaluate modern distributed applications. Many\\nhave bought in. \", \"They\\u2019re designing new and replatforming existing enterprise applications following\\nthe principles, p\", \"atterns, and practices of distributed microservice applications.\\nBut, this evolution raises many que\", \"stions\\u2026\\n\\u2022 What exactly is a distributed application?\\n\\u2022 Why are they gaining popularity?\\n\\u2022 What are t\", \"he costs?\\n\\u2022 And, importantly, what are the tradeoffs?\\nTo start, let\\u2019s rewind and look at the past 15\", \" years. During this period, we typically constructed\\napplications as a single, monolithic unit. Figu\", \"re 1-1 shows the architecture.\\nFigure 1-1. Monolithic architecture.\\nNote how the modules for Orderin\", \"g, Identity, and Marketing execute in a single-server process.\\nApplication data is stored in a share\", \"d database. Business functionality is exposed via HTML and\\nRESTful interfaces.\\nIn many ways, monolit\", \"hic apps are straightforward. They\\u2019re straightforward to:\\n\\u2022 Build\\n3 CHAPTER 2 | The world is distrib\", \"uted\\u2022 Test\\n\\u2022 Deploy\\n\\u2022 Troubleshoot\\n\\u2022 Scale vertically (scale up)\\nHowever, monolithic architectures c\", \"an present significant challenges.\\nOver time, you may reach a point where you begin to lose control\\u2026\", \"\\n\\u2022 The monolith has become so overwhelmingly complicated that no single person understands it.\\n\\u2022 You\", \" fear making changes as each brings unintended and costly side effects.\\n\\u2022 New features/fixes become \", \"time-consuming and expensive to implement.\\n\\u2022 Even the smallest change requires full deployment of th\", \"e entire application - expensive and\\nrisky.\\n\\u2022 One unstable component can crash the entire system.\\n\\u2022 \", \"Adding new technologies and frameworks aren\\u2019t an option.\\n\\u2022 Implementing agile delivery methodologies\", \" are difficult.\\n\\u2022 Architectural erosion sets in as the code base deteriorates with never-ending \\u201cspe\", \"cial cases.\\u201d\\n\\u2022 Eventually the consultants come in and tell you to rewrite it.\\nIT practitioners call \", \"this condition the Fear Cycle. If you\\u2019ve been in the technology business for any\\nlength of time, goo\", \"d chance you\\u2019ve experienced it. It\\u2019s stressful and exhausts your IT budget. Instead\\nof building new \", \"and innovative solutions, most of your budget is spent maintaining legacy apps.\\nInstead of fear, bus\", \"inesses require speed and agility. They seek an architectural style with which\\nthey can rapidly resp\", \"ond to market conditions. They need to instantaneously update and individually\\nscale small areas of \", \"a live application.\\nAn early attempt to gain speed and agility came in the form of Service Oriented \", \"Architecture, or SOA.\\nIn this model, service consumers and service providers collaborated via middle\", \"ware messaging\\ncomponents, often referred to as an Enterprise Service Bus, or ESB. Figure 1-2 shows \", \"the architecture.\\n4 CHAPTER 2 | The world is distributedFigure 1-2. SOA architecture.\\nWith SOA, cent\", \"ralized service providers registered with the ESB. Business logic would be built into the\\nESB to int\", \"egrate providers and consumers. Service consumers could then find and communicate with\\nthese provide\", \"rs using the ESB.\\nDespite the promises of SOA, implementing this approach often increased complexity\", \" and introduced\\nbottlenecks. Maintenance costs became high and ESB middleware expensive. Services te\", \"nded to be\\nlarge. They often shared dependencies and data storage. In the end, SOAs often resulted i\", \"n a\\n\\u2018distributed monolithic\\u2019 structure with centralized services that were resistant to change.\\nNowa\", \"days, many organizations have realized speed and agility by adopting a distributed microservice\\narch\", \"itectural approach to building systems. Figure 1-3 shows the same system built using distributed\\ntec\", \"hniques and practices.\\n5 CHAPTER 2 | The world is distributedFigure 1-3. Distributed architecture.\\nN\", \"ote how the same application is decomposed across a set of distributed services. Each is self-\\nconta\", \"ined and encapsulates its own code, data, and dependencies. Each is deployed in a software\\ncontainer\", \" and managed by a container orchestrator. Instead of a single database shared by multiple\\nservices, \", \"each service owns a private database. Other services can\\u2019t access this database directly and\\ncan onl\", \"y get to data that is exposed through the public API of the service that owns it. Note how\\nsome serv\", \"ices require a full relational database, but others, a NoSQL datastore. The basket service\\nstores it\", \"s state in a distributed key/value cache. Note how inbound traffic routes through an API\\nGateway ser\", \"vice. It\\u2019s responsible for directing calls to services and enforcing cross-cutting concerns.\\nMost im\", \"portantly, the application takes full advantage of the scalability, availability, and resiliency\\nfea\", \"tures found in modern cloud platforms.\\nBut, while distributed services can provide agility and speed\", \", they present a different set of challenges.\\nConsider the following\\u2026\\n\\u2022 How can distributed services\", \" discover each other and communicate synchronously?\\n6 CHAPTER 2 | The world is distributed\\u2022 How can \", \"they implement asynchronous messaging?\\n\\u2022 How can they maintain contextual information across a trans\", \"action?\\n\\u2022 How can they become resilient to failure?\\n\\u2022 How can they scale to meet fluctuating demand?\", \"\\n\\u2022 How are they monitored and observed?\\nFor each of these challenges, multiple products are often av\", \"ailable. But, shielding your application\\nfrom product differences and keeping code maintainable and \", \"portable become a challenge.\\nThis book introduces Dapr. Dapr is a distributed application runtime. I\", \"t directly addresses many of the\\nchallenges found that come along with distributed applications. Loo\", \"king ahead, Dapr has the\\npotential to have a profound impact on distributed application development.\", \"\\nSummary\\nIn this chapter, we discussed the adoption of distributed applications. We contrasted a mon\", \"olithic\\nsystem approach with that of distributed services. We pointed out many of the common challen\", \"ges\\nwhen considering a distributed approach.\\nNow, sit back, relax, and let us introduce you the new \", \"world of Dapr.\\n7 CHAPTER 2 | The world is distributed3\\nCHAPTER\\nDapr at 20,000 feet\\nIn chapter 1, we \", \"discussed the appeal of distributed microservice applications. But, we also pointed\\nout that they dr\", \"amatically increase architectural and operational complexity. With that in mind, the\\nquestion become\", \"s, how can you \\u201chave your cake\\u201d and \\u201ceat it too?\\u201d. That is, how can you take\\nadvantage of the agilit\", \"y of distributed architecture, and minimize its complexity?\\nDapr, or Distributed Application Runtime\", \", is a new way to build modern distributed applications.\\nWhat started as a prototype has evolved int\", \"o a highly successful open-source project. Its sponsor,\\nMicrosoft, has closely partnered with custom\", \"ers and the open-source community to design and build\\nDapr. The Dapr project brings together develop\", \"ers from all backgrounds to solve some of the\\ntoughest challenges of developing distributed applicat\", \"ions.\\nThis book looks at Dapr from the viewpoint of a .NET developer. In this chapter, you\\u2019ll build \", \"a\\nconceptual understanding of Dapr and how it works. Later on, we present practical, hands-on\\ninstru\", \"ction on how you can use Dapr in your applications.\\nImagine flying in a jet at 20,000 feet. You look\", \" out the window and see the landscape below from a\\nwide perspective. Let\\u2019s do the same for Dapr. Vis\", \"ualize yourself flying over Dapr at 20,000 feet. What\\nwould you see?\\nDapr and the problem it solves\\n\", \"Dapr addresses a large challenge inherent in modern distributed applications: Complexity.\\nThrough an\", \" architecture of pluggable components, Dapr greatly simplifies the plumbing behind\\ndistributed appli\", \"cations. It provides a dynamic glue that binds your application with infrastructure\\ncapabilities fro\", \"m the Dapr runtime.\\nConsider a requirement to make one of your services stateful? What would be your\", \" design. You could\\nwrite custom code that targets a state store such as Redis Cache. However, Dapr p\", \"rovides state\\nmanagement capabilities out-of-the-box. Your service invokes the Dapr state management\", \" building\\nblock that dynamically binds to a state store component via a Dapr component configuration\", \" yaml\\nfile. Dapr ships with several pre-built state store components, including Redis. With this mod\", \"el, your\\nservice delegates state management to the Dapr runtime. Your service has no SDK, library, o\", \"r direct\\nreference to the underlying component. You can even change state stores, say, from Redis to\", \" MySQL\\nor Cassandra, with no code changes.\\nFigure 2-1 shows Dapr from 20,000 feet.\\n8 CHAPTER 3 | Dap\", \"r at 20,000 feetFigure 2-1. Dapr at 20,000 feet.\\nIn the top row of the figure, note how Dapr provide\", \"s language-specific SDKs for popular development\\nplatforms. Dapr v1.0 includes support for Go, Node.\", \"js, Python, .NET, Java, and JavaScript. This book\\nfocuses on the Dapr .NET SDK, which also provides \", \"direct support for ASP.NET Core integration.\\nWhile language-specific SDKs enhance the developer expe\", \"rience, Dapr is platform agnostic. Under the\\nhood, Dapr\\u2019s programming model exposes capabilities thr\", \"ough standard HTTP/gRPC communication\\nprotocols. Any programming platform can call Dapr via its nati\", \"ve HTTP and gRPC APIs.\\nThe blue boxes across the center of the figure represent the Dapr building bl\", \"ocks. Each exposes a\\ndistributed application capability that your application can consume.\\nThe botto\", \"m row highlights the portability of Dapr and the diverse environments across which it can\\nrun.\\nDapr \", \"architecture\\nAt this point, the jet turns around and flies back over Dapr, descending in altitude, g\", \"iving you a closer\\nlook at how Dapr works.\\nBuilding blocks\\nFrom the new perspective, you see a more \", \"detailed view of the Dapr building blocks.\\nA building block encapsulates a distributed infrastructur\", \"e capability. You can access the functionality\\nthrough the HTTP or gRPC APIs. Figure 2-2 shows the a\", \"vailable blocks for Dapr v 1.0.\\n9 CHAPTER 3 | Dapr at 20,000 feetFigure 2-2. Dapr building blocks.\\nT\", \"he following table describes the infrastructure services provided by each block.\\nBuilding block Desc\", \"ription\\nState management Support contextual information for long running stateful services.\\nService \", \"invocation Invoke direct, secure service-to-service calls using platform agnostic protocols\\nand well\", \"-known endpoints.\\nPublish and Implement secure, scalable pub/sub messaging between services.\\nsubscri\", \"be\\n10 CHAPTER 3 | Dapr at 20,000 feetBuilding block Description\\nBindings Trigger code from events ra\", \"ised by external resources with bi-directional\\ncommunication.\\nObservability Monitor and measure mess\", \"age calls across networked services.\\nSecrets Securely access external secret stores.\\nActors Encapsul\", \"ate logic and data in reusable actor objects.\\nBuilding blocks abstract the implementation of distrib\", \"uted application capabilities from your services.\\nFigure 2-3 shows this interaction.\\nFigure 2-3. Dap\", \"r building block integration.\\nBuilding blocks invoke Dapr components that provide the concrete imple\", \"mentation for each resource.\\nThe code for your service is only aware of the building block. It takes\", \" no dependencies on external\\nSDKs or libraries - Dapr handles the plumbing for you. Each building bl\", \"ock is independent. You can\\nuse one, some, or all of them in your application. As a value-add, Dapr \", \"building blocks bake in\\nindustry best practices including comprehensive observability.\\nWe provide de\", \"tailed explanation and code samples for each Dapr building block in the upcoming\\nchapters. At this p\", \"oint, the jet descends even more. From the new perspective, you now have a closer\\nlook at the Dapr c\", \"omponents layer.\\nComponents\\nWhile building blocks expose an API to invoke distributed application ca\", \"pabilities, Dapr components\\nprovide the concrete implementation to make it happen.\\n11 CHAPTER 3 | Da\", \"pr at 20,000 feetConsider, the Dapr state store component. It provides a uniform way to manage state\", \" for CRUD\\noperations. Without any change to your service code, you could switch between any of the f\", \"ollowing\\nDapr state components:\\n\\u2022 AWS DynamoDB\\n\\u2022 Aerospike\\n\\u2022 Azure Blob Storage\\n\\u2022 Azure CosmosDB\\n\\u2022 A\", \"zure Table Storage\\n\\u2022 Cassandra\\n\\u2022 Cloud Firestore (Datastore mode)\\n\\u2022 CloudState\\n\\u2022 Couchbase\\n\\u2022 Etcd\\n\\u2022 \", \"HashiCorp Consul\\n\\u2022 Hazelcast\\n\\u2022 Memcached\\n\\u2022 MongoDB\\n\\u2022 PostgreSQL\\n\\u2022 Redis\\n\\u2022 RethinkDB\\n\\u2022 SQL Server\\n\\u2022 Z\", \"ookeeper\\nEach component provides the necessary implementation through a common state management\\ninte\", \"rface:\\ntype Store interface {\\nInit(metadata Metadata) error\\nDelete(req *DeleteRequest) error\\nBulkDel\", \"ete(req []DeleteRequest) error\\nGet(req *GetRequest) (*GetResponse, error)\\nSet(req *SetRequest) error\", \"\\nBulkSet(req []SetRequest) error\\n}\\nTip\\nThe Dapr runtime as well as all of the Dapr components have b\", \"een written in the Golang, or Go,\\nlanguage. Go is a popular language across the open source communit\", \"y and attests to cross-platform\\ncommitment of Dapr.\\nPerhaps you start with Azure Redis Cache as your\", \" state store. You specify it with the following\\nconfiguration:\\n12 CHAPTER 3 | Dapr at 20,000 feet:::\", \"{custom-style=CodeBox} yaml apiVersion: dapr.io/v1alpha1 kind: Component metadata: name:\\nstatestore \", \"namespace: default spec: type: state.redis version: v1 metadata: - name: redisHost\\nvalue: <HOST> - n\", \"ame: redisPassword value: <PASSWORD> - name: enableTLS value:\\n<bool> # Optional. Allowed: true, fals\", \"e. - name: failover value: <bool> # Optional. Allowed: true,\\nfalse. :::\\nIn the spec section, you con\", \"figure Dapr to use the Redis Cache for state management. The section\\nalso contains component-specifi\", \"c metadata. In this case, you can use it to configure additional Redis\\nsettings.\\nAt a later time, th\", \"e application is ready to go to production. For the production environment, you may\\nwant to change y\", \"our state management to Azure Table Storage. Azure Table Storage provides state\\nmanagement capabilit\", \"ies that are affordable and highly durable.\\nAt the time of this writing, the following component typ\", \"es are provided by Dapr:\\nComponent Description\\nService Used by the service invocation building block\", \" to integrate with the hosting\\ndiscovery environment to provide service-to-service discovery.\\nState \", \"Provides a uniform interface to interact with a wide variety of state store\\nimplementations.\\nPub/sub\", \" Provides a uniform interface to interact with a wide variety of message bus\\nimplementations.\\nBindin\", \"gs Provides a uniform interface to trigger application events from external systems and\\ninvoke exter\", \"nal systems with optional data payloads.\\nMiddleware Allows custom middleware to plug into the reques\", \"t processing pipeline and invoke\\nadditional actions on a request or response.\\nSecret stores Provides\", \" a uniform interface to interact with external secret stores, including cloud,\\nedge, commercial, ope\", \"n-source services.\\nAs the jet completes its fly over of Dapr, you look back once more and can see ho\", \"w it connects\\ntogether.\\nSidecar architecture\\nDapr exposes its building blocks and components through\", \" a sidecar architecture. A sidecar enables\\nDapr to run in a separate memory process or separate cont\", \"ainer alongside your service. Sidecars\\nprovide isolation and encapsulation as they aren\\u2019t part of th\", \"e service, but connected to it. This\\nseparation enables each to have its own runtime environment and\", \" be built upon different\\nprogramming platforms. Figure 2-4 shows a sidecar pattern.\\n13 CHAPTER 3 | D\", \"apr at 20,000 feetFigure 2-4. Sidecar architecture.\\nThis pattern is named Sidecar because it resembl\", \"es a sidecar attached to a motorcycle. In the previous\\nfigure, note how the Dapr sidecar is attached\", \" to your service to provide distributed application\\ncapabilities.\\nHosting environments\\nDapr has cros\", \"s-platform support and can run in many different environments. These environments\\ninclude Kubernetes\", \", a group of VMs, or edge environments such as Azure IoT Edge.\\nFor local development, the easiest wa\", \"y to get started is with self-hosted mode. In self-hosted mode,\\nthe microservices and Dapr sidecars \", \"run in separate local processes without a container orchestrator\\nsuch as Kubernetes. For more inform\", \"ation, see download and install the Dapr CLI.\\nFigure 2-5 shows an application and Dapr hosted in two\", \" separate memory processes communicating\\nvia HTTP or gRPC.\\n14 CHAPTER 3 | Dapr at 20,000 feetFigure \", \"2-5. Self-hosted Dapr sidecar.\\nBy default, Dapr installs Docker containers for Redis and Zipkin to p\", \"rovide default state management\\nand observability. If you don\\u2019t want to install Docker on your local\", \" machine, you can even run Dapr in\\nself-hosted mode without any Docker containers. However, you must\", \" install default components such\\nas Redis for state management and pub/sub manually.\\nDapr also runs \", \"in containerized environments, such as Kubernetes. Figure 2-6 shows Dapr running in a\\nseparate side-\", \"car container along with the application container in the same Kubernetes pod.\\nFigure 2-6. Kubernete\", \"s-hosted Dapr sidecar.\\nDapr performance considerations\\nAs you\\u2019ve seen, Dapr exposes a sidecar archit\", \"ecture to decouple your application from distributed\\napplication capabilities. Invoking a Dapr opera\", \"tion requires at least one out-of-process network call.\\nFigure 2-7 presents an example of a Dapr tra\", \"ffic pattern.\\n15 CHAPTER 3 | Dapr at 20,000 feetFigure 2-7. Dapr traffic patterns.\\nLooking at the pr\", \"evious figure, one might question the latency and overhead incurred for each call.\\nThe Dapr team has\", \" invested heavily in performance. A tremendous amount of engineering effort has\\ngone into making Dap\", \"r efficient. Calls between Dapr sidecars are always made with gRPC, which\\ndelivers high performance \", \"and small binary payloads. In most cases, the additional overhead should\\nbe sub-millisecond.\\nTo incr\", \"ease performance, developers can call the Dapr building blocks with gRPC.\\ngRPC is a modern, high-per\", \"formance framework that evolves the age-old remote procedure call (RPC)\\nprotocol. gRPC uses HTTP/2 f\", \"or its transport protocol, which provides significant performance\\nenhancements over HTTP RESTFul ser\", \"vice, including:\\n\\u2022 Multiplexing support for sending multiple parallel requests over the same connect\", \"ion - HTTP 1.1\\nlimits processing to one request/response message at a time.\\n\\u2022 Bidirectional full-dup\", \"lex communication for sending both client requests and server responses\\nsimultaneously.\\n\\u2022 Built-in s\", \"treaming enabling requests and responses to asynchronously stream large data sets.\\nTo learn more, ch\", \"eck out the gRPC overview from the Architecting Cloud-Native .NET Apps for Azure\\neBook.\\nDapr and ser\", \"vice meshes\\nService mesh is another rapidly evolving technology for distributed applications.\\nA serv\", \"ice mesh is a configurable infrastructure layer with built-in capabilities to handle service-to-\\nser\", \"vice communication, resiliency, load balancing, and telemetry capture. It moves the responsibility\\nf\", \"or these concerns out of the services and into the service mesh layer. Like Dapr, a service mesh als\", \"o\\nfollows a sidecar architecture.\\nFigure 2-8 shows an application that implements service mesh techn\", \"ology.\\n16 CHAPTER 3 | Dapr at 20,000 feetFigure 2-8. Service mesh with a side car.\\nThe previous figu\", \"re shows how messages are intercepted by a sidecar proxy that runs alongside each\\nservice. Each prox\", \"y can be configured with traffic rules specific to the service. It understands messages\\nand can rout\", \"e them across your services and the outside world.\\nSo the question becomes, \\u201cIs Dapr a service mesh?\", \"\\u201d.\\nWhile both use a sidecar architecture, each technology has a different purpose. Dapr provides\\ndis\", \"tributed application features. A service mesh provides a dedicated network infrastructure layer.\\nAs \", \"each works at a different level, both can work together in the same application. For example, a\\nserv\", \"ice mesh could provide networking communication between services. Dapr could provide\\napplication ser\", \"vices such as state management or actor services.\\nFigure 2-9 shows an application that implements bo\", \"th Dapr and service mesh technology.\\n17 CHAPTER 3 | Dapr at 20,000 feetFigure 2-9. Dapr and service \", \"mesh together.\\nThe Dapr online documentation cover Dapr and service mesh integration.\\nSummary\\nThis c\", \"hapter introduced you to Dapr, a Distributed Application Runtime.\\nDapr is an open-source project spo\", \"nsored by Microsoft with close collaboration from customers and\\nthe open-source community.\\nAt its co\", \"re, Dapr helps reduce the inherent complexity of distributed microservice applications. It\\u2019s\\nbuilt u\", \"pon a concept of building block APIs. Dapr building blocks expose common distributed\\napplication cap\", \"abilities, such as state management, service-to-service invocation, and pub/sub\\nmessaging. Dapr comp\", \"onents lie beneath the building blocks and provide the concrete\\nimplementation for each capability. \", \"Applications bind to various components through configuration\\nfiles.\\nIn the next chapters, we presen\", \"t practical, hands-on instruction on how to use Dapr in your\\napplications.\\nReferences\\n\\u2022 Dapr documen\", \"tation\\n\\u2022 Learning Dapr\\n\\u2022 .NET Microservices: Architecture for Containerized .NET applications\\n\\u2022 Arch\", \"itecting Cloud-Native .NET Apps for Azure\\n18 CHAPTER 3 | Dapr at 20,000 feet4\\nCHAPTER\\nGet started wi\", \"th Dapr\\nIn the first two chapters, you learned basic concepts about Dapr. It\\u2019s time to take it for a\", \" test drive. This\\nchapter will guide you through preparing your local development environment and bu\", \"ilding two Dapr\\n.NET applications.\\nInstall Dapr into your local environment\\nYou\\u2019ll start by installi\", \"ng Dapr on your development computer. Once complete, you can build and run\\nDapr applications in self\", \"-hosted mode.\\n1. Install the Dapr CLI. It enables you to launch, run, and manage Dapr instances. It \", \"also provides\\ndebugging support.\\n2. Install Docker Desktop. If you\\u2019re running on Windows, make sure \", \"that Docker Desktop for\\nWindows is configured to use Linux containers.\\n[!NOTE] By default, Dapr uses\", \" Docker containers to provide you the best out-of-the-box\\nexperience. To run Dapr outside of Docker,\", \" you can skip this step and execute a slim\\ninitialization. The examples in this chapter require you \", \"use Docker containers.\\n3. Initialize Dapr. This step sets up your development environment by install\", \"ing the latest Dapr\\nbinaries and container images.\\n4. Install the .NET 7 SDK.\\nNow that Dapr is insta\", \"lled, it\\u2019s time to build your first Dapr application!\\nBuild your first Dapr application\\nYou\\u2019ll start\", \" by building a simple .NET Console application that consumes the Dapr state management\\nbuilding bloc\", \"k.\\nCreate the application\\n1. Open up the command shell or terminal of your choice. You might conside\", \"r the terminal\\ncapabilities in Visual Studio Code. Navigate to the root folder in which you want to \", \"build your\\napplication. Once there, enter the following command to create a new .NET Console applica\", \"tion:\\ndotnet new console -o DaprCounter\\nThe command scaffolds a simple \\\"Hello World\\\" .NET applicatio\", \"n.\\n19 CHAPTER 4 | Get started with Dapr1. Then, navigate into the new directory created by the previ\", \"ous command:\\ncd DaprCounter\\n1. Run the newly created application using the dotnet run command. Doing\", \" so writes \\u201cHello\\nWorld!\\u201d to the console screen:\\ndotnet run\\nAdd Dapr State Management\\nNext, you\\u2019ll u\", \"se the Dapr state management building block to implement a stateful counter in the\\nprogram.\\nYou can \", \"invoke Dapr APIs across any development platform using Dapr\\u2019s native support for HTTP and\\ngRPC. Howe\", \"ver, .NET Developers will find the Dapr .NET SDK more natural and intuitive. It provides a\\nstrongly \", \"typed .NET client to call the Dapr APIs. The .NET SDK also tightly integrates with ASP.NET\\nCore.\\n1. \", \"From the terminal window, add the Dapr.Client NuGet package to your application:\\ndotnet add package \", \"Dapr.Client\\n1. Open the Program.cs file in your favorite editor and update its contents to the follo\", \"wing code:\\nusing Dapr.Client\\nconst string storeName = \\\"statestore\\\";\\nconst string key = \\\"counter\\\"\\nvar\", \" daprClient = new DaprClientBuilder().Build();\\nvar counter = await daprClient.GetStateAsync<int>(sto\", \"reName, key)\\nwhile (true)\\n{\\nConsole.WriteLine($\\\"Counter = {counter++}\\\")\\nawait daprClient.SaveStateAs\", \"ync(storeName, key, counter);\\nawait Task.Delay(1000);\\n}\\nThe updated code implements the following st\", \"eps:\\n- First a new [`DaprClient`]{custom-style=Code} instance is instantiated. This class\\nenables yo\", \"u to interact with the Dapr sidecar.\\n- From the state store, [`DaprClient.GetStateAsync`]{custom-sty\", \"le=Code} fetches the\\nvalue for the [`counter`]{custom-style=Code} key. If the key doesn't exist, the\", \"\\ndefault value for [`int`]{custom-style=Code} (which is [`0`]{custom-style=Code}) is\\nreturned.\\n- The\", \" code then iterates, writing the [`counter`]{custom-style=Code} value to the\\nconsole and saving an i\", \"ncremented value to the state store.\\n1. The Dapr CLI run command starts the application. It invokes \", \"the underlying Dapr runtime and\\nenables both the application and Dapr sidecar to run together. If yo\", \"u omit the app-id, Dapr will\\ngenerate a unique name for the application. The final segment of the co\", \"mmand, dotnet run,\\ninstructs the Dapr runtime to run the .NET application.\\n[!IMPORTANT] Care must be\", \" taken to always pass an explicit app-id parameter when consuming\\nthe state management building bloc\", \"k. The block uses the application id value as a prefix for its\\n20 CHAPTER 4 | Get started with Daprs\", \"tate key for each key/value pair. If the application id changes, you can no longer access the\\nprevio\", \"usly stored state.\\nNow run the application with the following command:\\ndapr run --app-id DaprCounter\", \" dotnet run\\nTry stopping and restarting the application. You'll see that the counter doesn't\\nreset. \", \"Instead it continues from the previously saved state. The Dapr building block\\nmakes the application \", \"stateful.\\nImportant\\nIt\\u2019s important to understand your sample application communicates with a pre-con\", \"figured state\\ncomponent, but has no direct dependency on it. Dapr abstracts away the dependency. As \", \"you\\u2019ll\\nshortly see, the underlying state store component can be changed with a simple configuration \", \"update.\\nYou might be wondering, where exactly is the state stored?\\nComponent configuration files\\nWhe\", \"n you first initialized Dapr for your local environment, it automatically provisioned a Redis\\ncontai\", \"ner. Dapr then configured the Redis container as the default state store component with a\\ncomponent \", \"configuration file, entitled statestore.yaml. Here\\u2019s a look at its contents:\\napiVersion: dapr.io/v1a\", \"lpha1\\nkind: Component\\nmetadata:\\nname: statestore\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- nam\", \"e: redisHost\\nvalue: localhost:6379\\n- name: redisPassword\\nvalue: \\\"\\\"\\n- name: actorStateStore\\nvalue: \\\"t\", \"rue\\\"\\nNote\\nDefault component configuration files are stored in the $HOME/.dapr/components folder on\\nL\", \"inux/macOS, and in the %USERPROFILE%\\\\.dapr\\\\components folder on Windows.\\nNote the format of the prev\", \"ious component configuration file:\\n\\u2022 Each component has a name. In the sample above, the component i\", \"s named statestore. We\\nused that name in our first code example to tell the Dapr sidecar which compo\", \"nent to use.\\n\\u2022 Each component configuration file has a spec section. It contains a type field that s\", \"pecifies the\\ncomponent type. The version field specifies the component version. The metadata field\\n2\", \"1 CHAPTER 4 | Get started with Daprcontains information that the component requires, such as connect\", \"ion details and other settings.\\nThe metadata values will vary for the different types of components.\", \"\\nA Dapr sidecar can consume any Dapr component configured in your application. But, what if you had\\n\", \"an architectural justification to limit the accessibility of a component? How could you restrict the\", \" Redis\\ncomponent to Dapr sidecars running only in a production environment?\\nTo do so, you could defi\", \"ne a namespace for the production environment. You might name it\\nproduction. In self-hosted mode, yo\", \"u specify the namespace of a Dapr sidecar by setting the\\nNAMESPACE environment variable. When config\", \"ured, the Dapr sidecar will only load the components\\nthat match the namespace. For Kubernetes deploy\", \"ments, the Kubernetes namespace determines the\\ncomponents that are loaded. The following sample show\", \"s the Redis component placed in a\\nproduction namespace. Note the namespace declaration in the metada\", \"ta element:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: statestore\\nnamespace: produ\", \"ction\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- name: redisHost\\nvalue: localhost:6379\\n- name: \", \"redisPassword\\nvalue: \\\"\\\"\\n- name: actorStateStore\\nvalue: \\\"true\\\"\\nImportant\\nA namespaced component is on\", \"ly accessible to applications running in the same namespace. If your\\nDapr application fails to load \", \"a component, make sure that the application namespace matches the\\ncomponent namespace. This can be e\", \"specially tricky in self-hosted mode where the application\\nnamespace is stored in a NAMESPACE enviro\", \"nment variable.\\nIf needed, you could further restrict a component to a particular application. Withi\", \"n the production\\nnamespace, you may want to limit access of the Redis cache to only the DaprCounter \", \"application. You\\ndo so by specifying scopes in the component configuration. The following example sh\", \"ows how to\\nrestrict access to the Redis statestore component to the application DaprCounter in the p\", \"roduction\\nnamespace:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: statestore\\nnamespa\", \"ce: production\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- name: redisHost\\n22 CHAPTER 4 | Get st\", \"arted with Daprvalue: localhost:6379\\n- name: redisPassword\\nvalue: \\\"\\\"\\n- name: actorStateStore\\nvalue: \", \"\\\"true\\\"\\nscopes:\\n- DaprCounter\\nBuild a multi-container Dapr application\\nIn the first example, you crea\", \"ted a simple .NET console application that ran side-by-side with a Dapr\\nsidecar. Modern distributed \", \"applications, however, often consist of many moving parts. They can\\nsimultaneously run independent m\", \"icroservices. These modern applications are typically containerized\\nand require container orchestrat\", \"ion tools such as Docker Compose or Kubernetes.\\nIn the next example, you\\u2019ll create a multi-container\", \" application. You\\u2019ll also use the Dapr service\\ninvocation building block to communicate between serv\", \"ices. The solution will consist of a web\\napplication that retrieves weather forecasts from a web API\", \". They will each run in a Docker container.\\nYou\\u2019ll use Docker Compose to run the container locally a\", \"nd enable debugging capabilities.\\nMake sure you\\u2019ve configured your local environment for Dapr and in\", \"stalled the .NET 7 Development\\nTools (instructions are available at the beginning of this chapter).\\n\", \"Additionally, you\\u2019ll need to complete this sample using Visual Studio 2022 with the ASP.NET and web\\n\", \"development workload installed.\\nCreate the application\\n1. In Visual Studio 2022, create an ASP.NET C\", \"ore Web App project:\\n23 CHAPTER 4 | Get started with Dapr1. Name your project MyFrontEnd and your so\", \"lution DaprMultiContainer:\\n24 CHAPTER 4 | Get started with Dapr1. In the final dialog, keep the defa\", \"ults. Don\\u2019t select Enable Docker Support. You\\u2019ll add Docker\\nsupport later.\\n25 CHAPTER 4 | Get starte\", \"d with Dapr1. For the backend, add an ASP.NET Core Web API project to the same solution:\\n26 CHAPTER \", \"4 | Get started with Dapr1. Name the project MyBackEnd:\\n1. By default, a Dapr sidecar relies on the \", \"network boundary to limit access to its public API. So,\\nclear the checkbox for Configure for HTTPS:\\n\", \"> [!IMPORTANT]\\n> If you leave the **Configure for HTTPS** checkbox checked, the generated ASP.NET\\nCo\", \"re API project includes middleware to redirect client requests to the HTTPS\\nendpoint. This breaks co\", \"mmunication between the Dapr sidecar and your application,\\nunless you explicitly configure the use o\", \"f HTTPS when running your Dapr application.\\nTo enable the Dapr sidecar to communicate over HTTPS, in\", \"clude the [`--app-\\nssl`]{custom-style=Code} flag in the Dapr command to start the application. Also\\n\", \"specify the HTTPS port using the [`--app-port`]{custom-style=Code} parameter. The\\nremainder of this \", \"walkthrough uses plain HTTP communication between the sidecar and\\nthe application, and requires you \", \"to clear the **Configure for HTTPS** checkbox.\\nAdd Dapr service invocation\\nNow, you\\u2019ll configure com\", \"munication between the services using Dapr service invocation building\\nblock. You\\u2019ll enable the web \", \"app to retrieve weather forecasts from the web API. The service\\ninvocation building block features m\", \"any benefits. It includes service discovery, automatic retries,\\nmessage encryption (using mTLS), and\", \" improved observability. You\\u2019ll use the Dapr .NET SDK to invoke\\nthe service invocation API on the Da\", \"pr sidecar.\\n27 CHAPTER 4 | Get started with Dapr1. In Visual Studio, open the Package Manager Consol\", \"e (Tools > NuGet Package Manager >\\nPackage Manager Console) and make sure that MyFrontEnd is the def\", \"ault project. From the\\nconsole, add the Dapr.AspNetCore NuGet package to the project:\\nInstall-Packag\", \"e Dapr.AspNetCore\\n1. In the MyFrontEnd project, open the Program.cs file and add a call to\\nbuilder.S\", \"ervices.AddDaprClient:\\nvar builder = WebApplication.CreateBuilder(args)\\n// Add services to the conta\", \"iner.\\nbuilder.Services.AddDaprClient();\\nbuilder.Services.AddRazorPages()\\n// ...\\nThe [`AddDaprClient`\", \"]{custom-style=Code} call registers the [`DaprClient`]{custom-\\nstyle=Code} class with the ASP.NET Co\", \"re dependency injection system. With the client\\nregistered, you can now inject an instance of [`Dapr\", \"Client`]{custom-style=Code} into\\nyour service code to communicate with the Dapr sidecar, building bl\", \"ocks, and\\ncomponents.\\n1. Add a new C# class file named WeatherForecast to the MyFrontEnd project:\\nna\", \"mespace MyFrontEnd\\npublic class WeatherForecast\\n{\\npublic DateTime Date { get; set;\\npublic int Temper\", \"atureC { get; set;\\npublic int TemperatureF { get; set;\\npublic string Summary { get; set; } = string.\", \"Empty;\\n}\\n1. Open the Index.cshtml.cs file in the Pages folder, and replace its contents with the fol\", \"lowing\\ncode:\\nusing Dapr.Client;\\nusing Microsoft.AspNetCore.Mvc.RazorPages\\nnamespace MyFrontEnd.Pages\", \"\\npublic class IndexModel : PageModel\\n{\\nprivate readonly DaprClient _daprClient\\npublic IndexModel(Dap\", \"rClient daprClient)\\n{\\n_daprClient = daprClient;\\npublic async Task OnGet()\\n{\\nvar forecasts = await _d\", \"aprClient.InvokeMethodAsync<IEnumerable<WeatherForecast>>(\\nHttpMethod.Get,\\n\\\"MyBackEnd\\\",\\n\\\"weatherfore\", \"cast\\\")\\nViewData[\\\"WeatherForecastData\\\"] = forecasts;\\n}\\n}\\nYou add Dapr capabilities into the web app b\", \"y injecting the [`DaprClient`]{custom-\\nstyle=Code} class into [`IndexModel`]{custom-style=Code} cons\", \"tructor. In the\\n[`OnGet`]{custom-style=Code} method, you call the backend API service with the Dapr\\n\", \"service invocation building block. The [`OnGet`]{custom-style=Code} method is invoked\\n28 CHAPTER 4 |\", \" Get started with Daprwhenever a user visits the home page. You use the\\n[`DaprClient.InvokeMethodAsy\", \"nc`]{custom-style=Code} method to invoke the\\n[`weatherforecast`]{custom-style=Code} method of the [`\", \"MyBackEnd`]{custom-style=Code}\\nservice. You'll configure the web API to use [`MyBackEnd`]{custom-sty\", \"le=Code} as its\\napplication ID later on when configuring it to run with Dapr. Finally, the service\\nr\", \"esponse is saved in view data.\\n1. Replace the contents of the Index.cshtml file in the Pages folder,\", \" with the following code. It\\ndisplays the weather forecasts stored in the view data to the user:\\n@pa\", \"ge\\n@model IndexModel\\n@{\\nViewData[\\\"Title\\\"] = \\\"Home page\\\";\\n<div class=\\\"text-center\\\">\\n<h1 class=\\\"displa\", \"y-4\\\">Welcome</h1>\\n<p>Learn about <a href=\\\"https://learn.microsoft.com/aspnet/core\\\">building Web apps\", \" with\\nASP.NECore</a>.</p>\\n@foreach (var forecast in\\n(IEnumerable<WeatherForecast>)ViewData[\\\"WeatherF\", \"orecastData\\\"]!)\\n{\\n<p>The forecast for @forecast.Date is @forecast.Summary!</p>\\n}\\n</div>\\nAdd containe\", \"r support\\nIn the final part of this example, you\\u2019ll add container support and run the solution using\", \" Docker\\nCompose.\\n1. Right-click the MyFrontEnd project, and choose Add > Container Orchestrator Supp\", \"ort\\u2026. The\\nAdd Container Orchestrator Support dialog appears:\\nChoose **Docker Compose**.\\n1. In the ne\", \"xt dialog, select Linux as the Target OS:\\n29 CHAPTER 4 | Get started with DaprVisual Studio creates \", \"a *docker-compose.yml*file and a *.dockerignore* file in the\\n**docker-compose** folder in the soluti\", \"on:\\n30 CHAPTER 4 | Get started with DaprThe *docker-compose.yml* file has the following content:\\nver\", \"sion: '3.4\\nservices:\\nmyfrontend:\\nimage: ${DOCKER_REGISTRY-}myfrontend\\nbuild:\\ncontext: .\\ndockerfile: \", \"MyFrontEnd/Dockerfile\\nThe *.dockerignore* file contains file types and extensions that you don't wan\", \"t Docker\\nto include in the container. These files are associated with the development\\nenvironment an\", \"d source control and not the app or service you're deploying.\\n31 CHAPTER 4 | Get started with DaprIn\", \" the root of the *MyFrontEnd* project directory, a new *Dockerfile* was created. A\\n*Dockerfile* is a\", \" sequence of commands that are used to build an image. For more\\ninformation, see [Dockerfile\\nreferen\", \"ce](https://docs.docker.com/engine/reference/builder).\\nThe *Dockerfile* contains the following comma\", \"nds:\\nFROM mcr.microsoft.com/dotnet/aspnet:7.0 AS base\\nWORKDIR /app\\nEXPOSE 80\\nEXPOSE 44\\nFROM mcr.micr\", \"osoft.com/dotnet/sdk:7.0 AS build\\nWORKDIR /src\\nCOPY [\\\"MyFrontEnd/MyFrontEnd.csproj\\\", \\\"MyFrontEnd/\\\"]\\n\", \"RUN dotnet restore \\\"MyFrontEnd/MyFrontEnd.csproj\\\"\\nCOPY . .\\nWORKDIR \\\"/src/MyFrontEnd\\\"\\nRUN dotnet buil\", \"d \\\"MyFrontEnd.csproj\\\" -c Release -o /app/buil\\nFROM build AS publish\\nRUN dotnet publish \\\"MyFrontEnd.c\", \"sproj\\\" -c Release -o /app/publis\\nFROM base AS final\\nWORKDIR /app\\nCOPY --from=publish /app/publish .\\n\", \"ENTRYPOINT [\\\"dotnet\\\", \\\"MyFrontEnd.dll\\\"]\\nThe preceding *Dockerfile* sequentially performs the followi\", \"ng steps when invoked:\\n1. Pulls the [`mcr.microsoft.com/dotnet/aspnet:7.0`]{custom-style=Code} image\", \" and\\nnames it [`base`]{custom-style=Code}.\\n2. Sets the working directory to */app*.\\n3. Exposes port \", \"[`80`]{custom-style=Code} and [`443`]{custom-style=Code}.\\n4. Pulls the [`mcr.microsoft.com/dotnet/sd\", \"k:7.0`]{custom-style=Code} image and names\\nit [`build`]{custom-style=Code}.\\n5. Sets the working dire\", \"ctory to */src*.\\n6. Copies the _MyFrontEnd/MyFrontEnd.csproj_ to a new directory named *MyFrontEnd/*\", \".\\n7. Calls [[`dotnet restore`]{custom-style=Code}](https://docs.microsoft.com/en-\\nus/dotnet/core/too\", \"ls/dotnet-restore) on the project.\\n8. Copies everything from the root directory into the image's roo\", \"t.\\n9. Sets the working directory to _/src/MyFrontEnd_.\\n10. Calls [[`dotnet build`]{custom-style=Code\", \"}](https://docs.microsoft.com/en-\\nus/dotnet/core/tools/dotnet-build) on the project.\\n- Targeting the\", \" **Release** configuration and outputs to */app/build*.\\n11. Initializes a new build stage from the e\", \"xisting [`build`]{custom-style=Code} base\\nimage and names it [`publish`]{custom-style=Code}.\\n12. Cal\", \"ls [`dotnet publish`]{custom-style=Code} on the project.\\n- Targeting the **Release** configuration a\", \"nd outputs to */app/publish*.\\n13. Initializes a new build stage from the existing [`publish`]{custom\", \"-style=Code}\\nbase image and names it [`final`]{custom-style=Code}.\\n14. Sets the working directory to\", \" */app*.\\n15. Copies the [`/app/publish`]{custom-style=Code} directory from the\\n[`publish`]{custom-st\", \"yle=Code} image into the root of the [`final`]{custom-style=Code}\\nimage.\\n16. Sets the entry point as\", \" the image to [`dotnet`]{custom-style=Code} and passes the\\n[`MyFrontEnd.dll`]{custom-style=Code} as \", \"an arg.\\n32 CHAPTER 4 | Get started with Dapr1. In the MyBackEnd web API project, right-click on the \", \"project node, and choose Add > Container\\nOrchestrator Support\\u2026. Choose Docker Compose, and then sele\", \"ct Linux again as the target\\nOS.\\nIn the root of the MyBackEnd project directory, a new Dockerfile wa\", \"s created. The Dockerfile\\ncontains the following commands:\\nFROM mcr.microsoft.com/dotnet/aspnet:7.0 \", \"AS base\\nWORKDIR /app\\nEXPOSE 8\\nFROM mcr.microsoft.com/dotnet/sdk:7.0 AS build\\nWORKDIR /src\\nCOPY [\\\"MyB\", \"ackEnd/MyBackEnd.csproj\\\", \\\"MyBackEnd/\\\"]\\nRUN dotnet restore \\\"MyBackEnd/MyBackEnd.csproj\\\"\\nCOPY . .\\nWOR\", \"KDIR \\\"/src/MyBackEnd\\\"\\nRUN dotnet build \\\"MyBackEnd.csproj\\\" -c Release -o /app/buil\\nFROM build AS publ\", \"ish\\nRUN dotnet publish \\\"MyBackEnd.csproj\\\" -c Release -o /app/publis\\nFROM base AS final\\nWORKDIR /app\\n\", \"COPY --from=publish /app/publish .\\nENTRYPOINT [\\\"dotnet\\\", \\\"MyBackEnd.dll\\\"]\\nOpen the *docker-compose.y\", \"ml* file again and examine its contents. Visual Studio has\\nupdated the **Docker Compose** file. Now \", \"both services are included:\\nversion: '3.4\\nservices:\\nmyfrontend:\\nimage: ${DOCKER_REGISTRY-}myfrontend\", \"\\nbuild:\\ncontext: .\\ndockerfile: MyFrontEnd/Dockerfil\\nmybackend:\\nimage: ${DOCKER_REGISTRY-}mybackend\\nb\", \"uild:\\ncontext: .\\ndockerfile: MyBackEnd/Dockerfile\\n1. To use Dapr building blocks from inside a conta\", \"inerized application, you\\u2019ll need to add the Dapr\\nsidecars containers to your Compose file. Carefull\", \"y update the content of the docker-\\ncompose.yml file to match the following example. Pay close atten\", \"tion to the formatting and\\nspacing and don\\u2019t use tabs.\\nversion: '3.4\\nservices:\\nmyfrontend:\\nimage: ${\", \"DOCKER_REGISTRY-}myfrontend\\nbuild:\\ncontext: .\\ndockerfile: MyFrontEnd/Dockerfile\\nports:\\n- \\\"51000:5000\", \"1\\nmyfrontend-dapr:\\nimage: \\\"daprio/daprd:latest\\\"\\ncommand: [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyFrontEnd\\\", \\\"-app\", \"-port\\\", \\\"80\\\" ]\\ndepends_on:\\n33 CHAPTER 4 | Get started with Dapr- myfrontend\\nnetwork_mode: \\\"service:m\", \"yfrontend\\nmybackend:\\nimage: ${DOCKER_REGISTRY-}mybackend\\nbuild:\\ncontext: .\\ndockerfile: MyBackEnd/Doc\", \"kerfile\\nports:\\n- \\\"52000:50001\\nmybackend-dapr:\\nimage: \\\"daprio/daprd:latest\\\"\\ncommand: [ \\\"./daprd\\\", \\\"-a\", \"pp-id\\\", \\\"MyBackEnd\\\", \\\"-app-port\\\", \\\"80\\\" ]\\ndepends_on:\\n- mybackend\\nnetwork_mode: \\\"service:mybackend\\\"\\nI\", \"n the updated file, we've added [`myfrontend-dapr`]{custom-style=Code} and\\n[`mybackend-dapr`]{custom\", \"-style=Code} sidecars for the [`myfrontend`]{custom-\\nstyle=Code} and [`mybackend`]{custom-style=Code\", \"} services respectively. In the updated\\nfile, pay close attention to the following changes:\\n- The si\", \"decars use the [`daprio/daprd:latest`]{custom-style=Code} container image. The\\nuse of the [`latest`]\", \"{custom-style=Code} tag isn't recommended for production\\nscenarios. For production, it's better to u\", \"se a specific version number.\\n- Each service defined in the Compose file has its own network namespa\", \"ce for network\\nisolation purposes. The sidecars use [`network_mode: \\\"service:...\\\"`]{custom-\\nstyle=Co\", \"de} to ensure they run in the same network namespace as the application. Doing\\nso allows the sidecar\", \" and the application to communicate using [`localhost`]{custom-\\nstyle=Code}.\\n- The ports on which th\", \"e Dapr sidecars are listening for gRPC communication (by\\ndefault 50001) must be exposed to allow the\", \" sidecars to communicate with each other.\\n1. Run the solution (F5 or Ctrl+F5) to verify that it work\", \"s as expected. If everything is configured\\ncorrectly, you should see the weather forecast data:\\n34 C\", \"HAPTER 4 | Get started with DaprRunning locally with Docker Compose and Visual Studio, you can set b\", \"reakpoints and\\ndebug into the application. For production scenarios, it's recommended to host your\\na\", \"pplication in Kubernetes. This book includes an accompanying reference application,\\n[eShopOnDapr](ht\", \"tps://github.com/dotnet-architecture/eShopOnDapr), that contains\\nscripts to deploy to Kubernetes.\\nTo\", \" learn more about the Dapr service invocation building block used in this\\nwalkthrough, refer to [cha\", \"pter 6](#the-dapr-service-invocation-building-blo).\\nSummary\\nIn this chapter, you had an opportunity \", \"to test drive Dapr. Using the Dapr .NET SDK, you saw how\\nDapr integrates with the .NET application p\", \"latform.\\nThe first example was a simple, stateful, .NET Console application that used the Dapr state\", \"\\nmanagement building block.\\nThe second example involved a multi-container application running in Doc\", \"ker. By using Visual Studio\\nwith Docker Compose, you experienced the familiar F5 debugging experienc\", \"e available across all .NET\\napps.\\nYou also got a closer look at Dapr component configuration files. \", \"They configure the actual\\ninfrastructure implementation used by the Dapr building blocks. You can us\", \"e namespaces and scopes\\nto restrict component access to particular environments and applications.\\nIn\", \" the upcoming chapters, you\\u2019ll dive deep into the building blocks offered by Dapr.\\nReferences\\n\\u2022 Dapr\", \" documentation - Getting started\\n\\u2022 eShopOnDapr\\n35 CHAPTER 4 | Get started with Dapr5\\nCHAPTER\\nTraffic\", \" Control sample\\napplication\\nIn the first chapters, you\\u2019ve learned about basic Dapr concepts. You saw\", \" how Dapr can help you and\\nyour team construct distributed applications while reducing architectural\", \" and operational complexity.\\nThis chapter introduces the sample application that you\\u2019ll use to explo\", \"re the Dapr building blocks. The\\napplication targets .NET 7 and uses the latest C# 11 language featu\", \"res.\\nNote\\nDownload the sample application code from the Dapr Traffic Control GitHub repo. This repos\", \"itory\\ncontains a detailed description on how you can run the sample application on your machine.\\nThe\", \" Traffic Control sample application simulates a highway traffic control system. Its purpose is to\\nde\", \"tect speeding vehicles and send the offending driver a fine notice. These systems actually exist in\\n\", \"real life and here\\u2019s how they work. A set of cameras (one above each lane) is placed at the beginnin\", \"g\\nand end of a highway stretch (say 10 kilometers) without on- or off-ramps. As a vehicle passes\\nund\", \"erneath a camera, it takes a photograph of the vehicle. Using Optical Character Recognition (OCR)\\nso\", \"ftware, it extracts the license number of the vehicle from the photo. Using the entry- and exit-\\ntim\", \"estamp of each vehicle, the system calculates the average speed of that vehicle. If the average\\nspee\", \"d is above the maximum speed limit for that highway stretch, the system retrieves the driver\\ninforma\", \"tion and automatically sends a fine notice.\\nAlthough the simulation is simple, responsibilities with\", \"in the system are separated into several\\nmicroservices. Figure 4.1 shows an overview of the services\", \" that are part of the application:\\n36 CHAPTER 5 | Traffic Control sample application37 CHAPTER 5 | T\", \"raffic Control sample applicationFigure 4-1. The services in the sample application.\\n\\u2022 The Camera Si\", \"mulation is a console application that simulates vehicles and sends messages to\\nthe TrafficControl s\", \"ervice. Every simulated car invokes both the entry and exit service endpoints.\\n\\u2022 The TrafficControl \", \"service is an ASP.NET Core Web API application that exposes the /entrycam\\nand /exitcam endpoints. In\", \"voking an endpoint simulates a car passing under one of the entry-\\nor exit-cameras respectively. The\", \" request message payload simply contains the license plate of\\nthe car (no actual OCR is implemented)\", \".\\n\\u2022 The FineCollection service is an ASP.NET Core Web API application that offers 1 endpoint:\\n/colle\", \"ctfine. Invoking this endpoint will send a fine notice to the driver of the speeding\\nvehicle. The pa\", \"yload of the request contains all the information about the speeding violation.\\n\\u2022 The VehicleRegistr\", \"ation service is an ASP.NET Core Web API application that offers 1 endpoint:\\n/vehicleinfo/{licensenu\", \"mber}. It\\u2019s used for obtaining vehicle- and owner-information for a\\nspeeding vehicle based on the li\", \"cense number sent in the URL (for example, /vehicleinfo/RV-\\n752-S).\\nThe sequence diagram in figure 4\", \".2 shows the simulation flow:\\nFigure 4-2. Sequence diagram of the simulation flow.\\nThe services comm\", \"unicate by directly invoking each other\\u2019s APIs. This design works fine, but it has\\nsome drawbacks.\\n3\", \"8 CHAPTER 5 | Traffic Control sample applicationThe biggest challenge is that the call-chain will br\", \"eak if one of the services is off-line. Decoupling\\nservices by replacing direct calls with asynchron\", \"ous messaging would solve this issue. Asynchronous\\nmessaging is typically implemented with a message\", \" broker like RabbitMQ or Azure Service Bus.\\nAnother drawback is that the vehicle state for every veh\", \"icle is stored in memory in the TrafficControl\\nservice. This state is lost when the service is resta\", \"rted after an update or a crash. To increase system\\ndurability, state should be stored outside the s\", \"ervice.\\nUsing Dapr building blocks\\nOne of the goals of Dapr is to provide cloud-native capabilities \", \"for microservices applications. The\\nTraffic Control application uses Dapr building blocks to increas\", \"e robustness and mitigate the design\\ndrawbacks described in the previous paragraph. Figure 4.shows a\", \" Dapr-enabled version of the traffic\\ncontrol application:\\nFigure 4-3. Traffic Control application wi\", \"th Dapr building blocks.\\n1. Service invocation The Dapr service invocation building block handles re\", \"quest/response\\ncommunication between the FineCollectionService and the VehicleRegistrationService. B\", \"ecause\\nthe call is a query to retrieve required data to complete the operation, a synchronous call i\", \"s\\nacceptable here. The service invocation building block provides service discovery. The\\nFineCollect\", \"ion service no longer has to know where the VehicleRegistration service lives. It also\\nimplements au\", \"tomatic retries if the VehicleRegistration service is off-line.\\n2. Publish & subscribe The publish a\", \"nd subscribe building block handles asynchronous messaging\\nfor sending speeding violations from the \", \"TrafficControl service to the FineCollectionService. This\\nimplementation decouples the TrafficContro\", \"l and FineCollection service. If the\\nFineCollectionService were to become temporarily unavailable, d\", \"ata would accumulate in the\\nqueue and resume processing at a later time. RabbitMQ is the current mes\", \"sage broker that\\ntransports messages from the producers to the consumers. As the Dapr pub/sub buildi\", \"ng block\\nabstracts the message broker, developers don\\u2019t need to learn the details of the RabbitMQ cl\", \"ient\\nlibrary. Switching to another message broker doesn\\u2019t require code changes, only configuration.\\n\", \"3. State management The TrafficControl service uses the state management building block to\\npersist v\", \"ehicle state outside of the service in a Redis cache. As with pub/sub, developers don\\u2019t\\nneed to lear\", \"n Redis specific APIs. Switching to another data store requires no code changes.\\n4. Output binding T\", \"he FineCollection service sends fines to the owners of speeding vehicles by\\nemail. The Dapr output b\", \"inding for SMTP abstracts the email transmission using the SMTP\\nprotocol.\\n5. Input binding The Camer\", \"aSimulation sends messages with simulated car info to the\\nTrafficControl service using the MQTT prot\", \"ocol. It uses a .NET MQTT library for sending\\nmessages to Mosquitto - a lightweight MQTT broker. The\", \" TrafficControl service uses the Dapr\\ninput binding for MQTT to subscribe to the MQTT broker and rec\", \"eive messages.\\n6. Secrets management The FineCollectionService needs credentials for connecting to t\", \"he smtp\\nserver and a license-key for a fine calculator component it uses internally. It uses the sec\", \"rets\\nmanagement building block to obtain the credentials and the license-key.\\n39 CHAPTER 5 | Traffic\", \" Control sample application7. Actors The TrafficControlService has an alternative implementation bas\", \"ed on Dapr actors. In this\\nimplementation, the TrafficControl service creates a new actor for every \", \"vehicle that is registered\\nby the entry camera. The license number of the vehicle forms the unique a\", \"ctor Id. The actor\\nencapsulates the vehicle state, which it persists in the Redis cache. When a vehi\", \"cle is registered\\nby the exit camera, it invokes the actor. The actor then calculate the average spe\", \"ed and possibly\\nissue a speeding violation.\\nFigure 4.4 shows a sequence diagram of the flow of the s\", \"imulation with all the Dapr building blocks in\\nplace:\\nFigure 4-4. Sequence diagram of simulation flo\", \"w with Dapr building blocks.\\nThe rest of this book features a chapter for each of the Dapr building \", \"blocks. Each chapter explains in\\ndetail how the building block works, its configuration, and how to \", \"use it. Each chapter explains how\\nthe Traffic Control sample application uses the building block.\\nHo\", \"sting\\nThe Traffic Control sample application can run in self-hosted mode or in Kubernetes.\\nSelf-host\", \"ed mode\\nThe sample repository contains PowerShell scripts to start the infrastructure services (Redi\", \"s,\\nRabbitMQ, and Mosquitto) as Docker containers on your machine. They\\u2019re located in the\\nsrc/Infrast\", \"ructure folder. For every application service in the solution, the repository contains a\\nseparate fo\", \"lder. Each of these folders contains a start-selfhosted.ps1 PowerShell script to start the\\nservice w\", \"ith Dapr.\\n40 CHAPTER 5 | Traffic Control sample applicationKubernetes\\nThe src/k8s folder in the samp\", \"le repository contains the Kubernetes manifest files to run the\\napplication (including the infrastru\", \"cture services) with Dapr in Kubernetes. This folder also contains a\\nstart.ps1 and stop.ps1 PowerShe\", \"ll script to start and stop the solution in Kubernetes. All services\\nwill run in the dapr-trafficcon\", \"trol namespace.\\nSummary\\nThe Traffic Control sample application is a microservices application that s\", \"imulates a highway speed\\ntrap.\\nThe application uses several Dapr building blocks to make it robust a\", \"nd cloud-native. The domain is\\nkept simple to keep the focus on Dapr.\\nThe application will be used i\", \"n the following chapters that focus on Dapr building block.\\nReferences\\n\\u2022 Dapr Traffic Control Sample\", \"\\n41 CHAPTER 5 | Traffic Control sample application6\\nCHAPTER\\nThe Dapr state\\nmanagement building\\nblock\", \"\\nDistributed applications are composed of independent services. While each service should be\\nstatele\", \"ss, some services must track state to complete business operations. Consider a shopping basket\\nservi\", \"ce for an e-Commerce site. If the service can\\u2019t track state, the customer could lose the shopping\\nba\", \"sket content by leaving the website, resulting in a lost sale and an unhappy customer experience.\\nFo\", \"r these scenarios, state needs to be persisted to a distributed state store. The Dapr state\\nmanageme\", \"nt building block simplifies state tracking and offers advanced features across various data\\nstores.\", \"\\nTo try out the state management building block, have a look at the counter application sample in\\nch\", \"apter 3.\\nWhat it solves\\nTracking state in a distributed application can be challenging. For example:\", \"\\n\\u2022 The application may require different types of data stores.\\n\\u2022 Different consistency levels may be\", \" required for accessing and updating data.\\n\\u2022 Multiple users may update data at the same time, requir\", \"ing conflict resolution.\\n\\u2022 Services must retry any short-lived transient errors that occur while int\", \"eracting with the data\\nstore.\\nThe Dapr state management building block addresses these challenges. I\", \"t streamlines tracking state\\nwithout dependencies or a learning curve on third-party storage SDKs.\\nI\", \"mportant\\nDapr state management offers a key/value API. The feature doesn\\u2019t support relational or gra\", \"ph data\\nstorage.\\n42 CHAPTER 6 | The Dapr state management building blockHow it works\\nThe application\", \" interacts with a Dapr sidecar to store and retrieve key/value data. Under the hood, the\\nsidecar API\", \" consumes a configurable state store component to persist data. Developers can choose\\nfrom a growing\", \" collection of supported state stores that include Azure Cosmos DB, SQL Server, and\\nCassandra.\\nThe A\", \"PI can be called with either HTTP or gRPC. Use the following URL to call the HTTP API:\\nhttp://localh\", \"ost:<dapr-port>/v1.0/state/<store-name>/\\n\\u2022 <dapr-port>: the HTTP port that Dapr listens on.\\n\\u2022 <store\", \"-name>: the name of the state store component to use.\\nFigure 5-1 shows how a Dapr-enabled shopping b\", \"asket service stores a key/value pair using the Dapr\\nstate store component named statestore.\\n:::imag\", \"e type=\\u201ccontent\\u201d source=\\u201c./media/state-management/state-management-flow.png\\u201d alt-\\ntext=\\u201cDiagram of s\", \"toring a key/value pair in a Dapr state store.\\u201d:::\\nFigure 5-1. Storing a key/value pair in a Dapr st\", \"ate store.\\nNote the steps in the previous figure:\\n1. The basket service calls the state management A\", \"PI on the Dapr sidecar. The body of the request\\nencloses a JSON array that can contain multiple key/\", \"value pairs.\\n2. The Dapr sidecar determines the state store based on the component configuration fil\", \"e. In this\\ncase, it\\u2019s a Redis cache state store.\\n3. The sidecar persists the data to the Redis cache\", \".\\nRetrieving the stored data is a similar API call. In the example below, a curl command retrieves t\", \"he\\ndata by calling the Dapr sidecar API:\\ncurl http://localhost:3500/v1.0/state/statestore/basket1\\nTh\", \"e command returns the stored state in the response body:\\n{\\n\\\"items\\\": [\\n{\\n\\\"itemId\\\": \\\"DaprHoodie\\\",\\n\\\"qua\", \"ntity\\\": 1\\n}\\n],\\n\\\"customerId\\\": 1\\n}\\nThe following sections explain how to use the more advanced feature\", \"s of the state management\\nbuilding block.\\nConsistency\\nThe CAP theorem is a set of principles that ap\", \"ply to distributed systems that store state. Figure 5-2\\nshows the three properties of the CAP theore\", \"m.\\n43 CHAPTER 6 | The Dapr state management building block:::image type=\\u201ccontent\\u201d source=\\u201c./media/st\", \"ate-management/cap-theorem.png\\u201d alt-text=\\u201cThe CAP\\ntheorem.\\u201d:::\\nFigure 5-2. The CAP theorem.\\nThe theo\", \"rem states that distributed data systems offer a trade-off between consistency, availability,\\nand pa\", \"rtition tolerance. And, that any datastore can only guarantee two of the three properties:\\n\\u2022 Consist\", \"ency (C). Every node in the cluster responds with the most recent data, even if the system\\nmust bloc\", \"k the request until all replicas update. If you query a \\u201cconsistent system\\u201d for an item\\nthat is curr\", \"ently updating, you won\\u2019t get a response until all replicas successfully update.\\nHowever, you\\u2019ll alw\", \"ays receive the most current data.\\n\\u2022 Availability (A). Every node returns an immediate response, eve\", \"n if that response isn\\u2019t the most\\nrecent data. If you query an \\u201cavailable system\\u201d for an item that i\", \"s updating, you\\u2019ll get the best\\npossible answer the service can provide at that moment.\\n\\u2022 Partition \", \"Tolerance (P). Guarantees the system continues to operate even if a replicated data\\nnode fails or lo\", \"ses connectivity with other replicated data nodes.\\nDistributed applications must handle the P proper\", \"ty. As services communicate among each other with\\nnetwork calls, network disruptions (P) will occur.\", \" With that in mind, distributed applications must\\neither be AP or CP.\\nAP applications choose availab\", \"ility over consistency. Dapr supports this choice with its eventual\\nconsistency strategy. Consider a\", \"n underlying data store, such as Azure CosmosDB, which stores\\nredundant data on multiple replicas. W\", \"ith eventual consistency, the state store writes the update to\\none replica and completes the write r\", \"equest with the client. After this time, the store will\\nasynchronously update its replicas. Read req\", \"uests can return data from any of the replicas, including\\nthose replicas that haven\\u2019t yet received t\", \"he latest update.\\nCP applications choose consistency over availability. Dapr supports this choice wi\", \"th its strong\\nconsistency strategy. In this scenario, the state store will synchronously update all \", \"(or, in some cases,\\na quorum of) required replicas before completing the write request. Read operati\", \"ons will return the\\nmost up-to-date data consistently across replicas.\\nThe consistency level for a s\", \"tate operation is specified by attaching a consistency hint to the operation.\\nThe following curl com\", \"mand writes a Hello=World key/value pair to a state store using a strong\\nconsistency hint:\\ncurl -X P\", \"OST http://localhost:3500/v1.0/state/<store-name> \\\\\\n-H \\\"Content-Type: application/json\\\" \\\\\\n-d '[\\n{\\n\\\"k\", \"ey\\\": \\\"Hello\\\",\\n\\\"value\\\": \\\"World\\\",\\n\\\"options\\\": {\\n\\\"consistency\\\": \\\"strong\\\"\\n}\\n}\\n]'\\n44 CHAPTER 6 | The Dapr \", \"state management building blockImportant\\nIt is up to the Dapr state store component to fulfill the c\", \"onsistency hint attached to the operation. Not\\nall data stores support both consistency levels. If n\", \"o consistency hint is set, the default behavior is\\neventual.\\nConcurrency\\nIn a multi-user application\", \", there\\u2019s a chance that multiple users will update the same data concurrently\\n(at the same time). Da\", \"pr supports optimistic concurrency control (OCC) to manage conflicts. OCC is\\nbased on an assumption \", \"that update conflicts are uncommon because users work on different parts of\\nthe data. It\\u2019s more effi\", \"cient to assume an update will succeed and retry if it doesn\\u2019t. The alternative,\\nimplementing pessim\", \"istic locking, can affect performance with long-running locking causing data\\ncontention.\\nDapr suppor\", \"ts optimistic concurrency control (OCC) using ETags. An ETag is a value associated with a\\nspecific v\", \"ersion of a stored key/value pair. Each time a key/value pair updates, the ETag value updates\\nas wel\", \"l. When a client retrieves a key/value pair, the response includes the current ETag value. When a\\ncl\", \"ient updates or deletes a key/value pair, it must send that ETag value back in the request body. If\\n\", \"another client has updated the data in the meantime, the ETags won\\u2019t match and the request will fail\", \".\\nAt this point, the client must retrieve the updated data, make the change again, and resubmit the\\n\", \"update. This strategy is called first-write-wins.\\nDapr also supports a last-write-wins strategy. Wit\", \"h this approach, the client doesn\\u2019t attach an ETag\\nto the write request. The state store component w\", \"ill always allow the update, even if the underlying\\nvalue has changed during the session. Last-write\", \"-wins is useful for high-throughput write scenarios\\nwith low data contention. As well, overwriting a\", \"n occasional user update can be tolerated.\\nTransactions\\nDapr can write multi-item changes to a data \", \"store as a single operation implemented as a transaction.\\nThis functionality is only available for d\", \"ata stores that support ACID transactions. At the time of this\\nwriting, these stores include Redis, \", \"MongoDB, PostgreSQL, SQL Server, and Azure CosmosDB.\\nIn the example below, a multi-item operation is\", \" sent to the state store in a single transaction. All\\noperations must succeed for the transaction to\", \" commit. If one or more of the operations fail, the\\nentire transaction rolls back.\\ncurl -X POST http\", \"://localhost:3500/v1.0/state/<store-name>/transaction \\\\\\n-H \\\"Content-Type: application/json\\\" \\\\\\n-d '{\\n\", \"\\\"operations\\\": [\\n{\\n\\\"operation\\\": \\\"upsert\\\",\\n\\\"request\\\": { \\\"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\"\\n}\\n},\\n{\\n\\\"opera\", \"tion\\\": \\\"delete\\\",\\n\\\"request\\\": { \\\"key\\\": \\\"Key2\\\" }\\n}\\n45 CHAPTER 6 | The Dapr state management building bl\", \"ock]\\n}'\\nFor data stores that don\\u2019t support transactions, multiple keys can still be sent as a single\", \" request. The\\nfollowing example shows a bulk write operation:\\ncurl -X POST http://localhost:3500/v1.\", \"0/state/<store-name> \\\\\\n-H \\\"Content-Type: application/json\\\" \\\\\\n-d '[\\n{ \\\"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\", \"\\\" },\\n{ \\\"key\\\": \\\"Key2\\\", \\\"value\\\": \\\"Value2\\\" }\\n]'\\nFor bulk operations, Dapr will submit each key/value pa\", \"ir update as a separate request to the data\\nstore.\\nUse the Dapr .NET SDK\\nThe Dapr .NET SDK provides \", \"language-specific support for the .NET platform. Developers can use the\\nDaprClient class introduced \", \"in chapter 3 to read and write data. The following example shows how to\\nuse the DaprClient.GetStateA\", \"sync<TValue> method to read data from a state store. The method\\nexpects the store name, statestore, \", \"and key, AMS, as parameters:\\nvar weatherForecast = await daprClient.GetStateAsync<WeatherForecast>(\\\"\", \"statestore\\\", \\\"AMS\\\");\\nIf the state store contains no data for key AMS, the result will be default(Wea\", \"therForecast).\\nTo write data to the data store, use the DaprClient.SaveStateAsync<TValue> method:\\nda\", \"prClient.SaveStateAsync(\\\"statestore\\\", \\\"AMS\\\", weatherForecast);\\nThe example uses the last-write-wins \", \"strategy as an ETag value isn\\u2019t passed to the state store\\ncomponent. To use optimistic concurrency c\", \"ontrol (OCC) with a first-write-wins strategy, first retrieve\\nthe current ETag using the DaprClient.\", \"GetStateAndETagAsync method. Then write the updated\\nvalue and pass along the retrieved ETag using th\", \"e DaprClient.TrySaveStateAsync method.\\nvar (weatherForecast, etag) = await\\ndaprClient.GetStateAndETa\", \"gAsync<WeatherForecast>(\\\"statestore\\\", city);\\n// ... make some changes to the retrieved weather forec\", \"ast\\nvar result = await daprClient.TrySaveStateAsync(\\\"statestore\\\", city, weatherForecast, etag);\\nThe \", \"DaprClient.TrySaveStateAsync method fails when the data (and associated ETag) has been\\nchanged in th\", \"e state store after the data was retrieved. The method returns a boolean value to\\nindicate whether t\", \"he call succeeded. A strategy to handle the failure is to simply reload the updated\\ndata from the st\", \"ate store, make the change again, and resubmit the update.\\nIf you always want a write to succeed reg\", \"ardless of other changes to the data, use the last-write-wins\\nstrategy.\\nThe SDK provides other metho\", \"ds to retrieve data in bulk, delete data, and execute transactions. For\\nmore information, see the Da\", \"pr .NET SDK repository.\\n46 CHAPTER 6 | The Dapr state management building blockASP.NET Core integrat\", \"ion\\nDapr also supports ASP.NET Core, a cross-platform framework for building modern cloud-based web\\n\", \"applications. The Dapr SDK integrates state management capabilities directly into the ASP.NET Core\\nm\", \"odel binding capabilities. Configuration is simple. In the Program.cs file, call the following exten\", \"sion\\nmethod on the WebApplication builder:\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder\", \".Services.AddControllers().AddDapr();\\nOnce configured, Dapr can inject a key/value pair directly int\", \"o a controller action using the ASP.NET\\nCore FromState attribute. Referencing the DaprClient object \", \"is no longer necessary. The next\\nexample shows a Web API that returns the weather forecast for a giv\", \"en city:\\n[HttpGet(\\\"{city}\\\")]\\npublic ActionResult<WeatherForecast> Get([FromState(\\\"statestore\\\", \\\"city\", \"\\\")]\\nStateEntry<WeatherForecast> forecast)\\n{\\nif (forecast.Value == null)\\n{\\nreturn NotFound();\\n}\\nretur\", \"n forecast.Value;\\n}\\nIn the example, the controller loads the weather forecast using the FromState at\", \"tribute. The first\\nattribute parameter is the state store, statestore. The second attribute paramete\", \"r, city, is the name\\nof the route template variable to get the state key. If you omit the second par\", \"ameter, the name of the\\nbound method parameter (forecast) is used to look up the route template vari\", \"able.\\nThe StateEntry class contains properties for all the information that is retrieved for a singl\", \"e key/value\\npair: StoreName, Key, Value, and ETag. The ETag is useful for implementing optimistic co\", \"ncurrency\\ncontrol (OCC) strategy. The class also provides methods to delete or update retrieved key/\", \"value data\\nwithout requiring a DaprClient instance. In the next example, the TrySaveAsync method is \", \"used to\\nupdate the retrieved weather forecast using OCC.\\n[HttpPut(\\\"{city}\\\")]\\npublic async Task Put(W\", \"eatherForecast updatedForecast, [FromState(\\\"statestore\\\", \\\"city\\\")]\\nStateEntry<WeatherForecast> curren\", \"tForecast)\\n{\\n// update cached current forecast with updated forecast passed into service endpoint\\ncu\", \"rrentForecast.Value = updatedForecast;\\n// update state store\\nvar success = await currentForecast.Try\", \"SaveAsync();\\n// ... check result\\n}\\nState store components\\nAt the time of this writing, Dapr provides\", \" support for the following transactional state stores:\\n47 CHAPTER 6 | The Dapr state management buil\", \"ding block\\u2022 Azure CosmosDB\\n\\u2022 Azure SQL Server\\n\\u2022 CockroachDB\\n\\u2022 In Memory\\n\\u2022 MongoDB\\n\\u2022 MySQL\\n\\u2022 Oracle D\", \"atabase\\n\\u2022 PostgreSQL\\n\\u2022 Redis\\n\\u2022 RethinkDB\\nDapr also includes support for state stores that support CR\", \"UD operations, but not transactional\\ncapabilities:\\n\\u2022 Aerospike\\n\\u2022 Apache Cassandra\\n\\u2022 AWS DynamoDB\\n\\u2022 A\", \"zure Blob Storage\\n\\u2022 Azure Table Storage\\n\\u2022 Couchbase\\n\\u2022 GCP Firestore\\n\\u2022 Hashicorp Consul\\n\\u2022 Hazelcast\\n\\u2022\", \" JetStream KV\\n\\u2022 Memcached\\n\\u2022 Oracle Object Storage\\n\\u2022 Zookeeper\\nConfiguration\\nWhen initialized for loc\", \"al, self-hosted development, Dapr registers Redis as the default state store.\\nHere\\u2019s an example of t\", \"he default state store configuration. Note the default name, statestore:\\napiVersion: dapr.io/v1alpha\", \"1\\nkind: Component\\nmetadata:\\nname: statestore\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- name: r\", \"edisHost\\nvalue: localhost:6379\\n- name: redisPassword\\nvalue: \\\"\\\"\\n- name: actorStateStore\\nvalue: \\\"true\\\"\", \"\\n48 CHAPTER 6 | The Dapr state management building block[!NOTE] Many state stores can be registered \", \"to a single application each with a different name.\\nThe Redis state store requires redisHost and red\", \"isPassword metadata to connect to the Redis\\ninstance. In the example above, the Redis password (whic\", \"h is an empty string by default) is stored as a\\nplain string. The best practice is to avoid clear-te\", \"xt strings and always use secret references. To learn\\nmore about secret management, see chapter 10.\\n\", \"The other metadata field, actorStateStore, indicates whether the state store can be consumed by\\nthe \", \"actors building block.\\nKey prefix strategies\\nState store components enable different strategies to s\", \"tore key/value pairs in the underlying store.\\nRecall the earlier example of a shopping basket servic\", \"e storing items a customer wishes to purchase:\\ncurl -X POST http://localhost:3500/v1.0/state/statest\", \"ore \\\\\\n-H \\\"Content-Type: application/json\\\" \\\\\\n-d '[{\\n\\\"key\\\": \\\"basket1\\\",\\n\\\"value\\\": {\\n\\\"customerId\\\": 1,\\n\\\"it\", \"ems\\\": [\\n{ \\\"itemId\\\": \\\"DaprHoodie\\\", \\\"quantity\\\": 1 }\\n]\\n}\\n}]'\\nUsing the Redis Console tool, look inside \", \"the Redis cache to see how the Redis state store component\\npersisted the data:\\n127.0.0.1:6379> KEYS \", \"*\\n1) \\\"basketservice||basket1\\\"\\n127.0.0.1:6379> HGETALL basketservice||basket1\\n1) \\\"data\\\"\\n2) \\\"{\\\\\\\"items\\\\\", \"\\\":[{\\\\\\\"itemId\\\\\\\":\\\\\\\"DaprHoodie\\\\\\\",\\\\\\\"quantity\\\\\\\":1}],\\\\\\\"customerId\\\\\\\":1}\\\"\\n3) \\\"version\\\"\\n4) \\\"1\\\"\\nThe output sho\", \"ws the full Redis key for the data as basketservice||basket1. By default, Dapr uses\\nthe application \", \"id of the Dapr instance (basketservice) as a prefix for the key. This naming\\nconvention enables mult\", \"iple Dapr instances to share the same data store without key name collisions.\\nFor the developer, it\\u2019\", \"s critical always to specify the same application id when running the\\napplication with Dapr. If omit\", \"ted, Dapr will generate a unique application ID. If the application id\\nchanges, the application can \", \"no longer access the state stored with the previous key prefix.\\nThat said, it\\u2019s possible to configur\", \"e a constant value for the key prefix in the keyPrefix metadata field\\nin the state store component f\", \"ile. Consider the following example:\\nspec:\\nmetadata:\\n- name: keyPrefix\\n- value: MyPrefix\\n49 CHAPTER \", \"6 | The Dapr state management building blockA constant key prefix enables the state store to be acce\", \"ssed across multiple Dapr applications. What\\u2019s\\nmore, setting the keyPrefix to none omits the prefix \", \"completely.\\nSample application: Dapr Traffic Control\\nIn the Dapr Traffic Control sample app, the Tra\", \"fficControl service uses the Dapr state management\\nbuilding block to persist the entry and exit time\", \"stamps of each passing vehicle. Figure 5-3 shows the\\nconceptual architecture of the Dapr Traffic Con\", \"trol sample application. The Dapr state management\\nbuilding block is used in flows marked with numbe\", \"r 3 in the diagram:\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/state-management/dapr-solution-state-man\", \"agement.png\\u201d\\nalt-text=\\u201cConceptual architecture of the Dapr Traffic Control sample application.\\u201d:::\\nF\", \"igure 5-3. Conceptual architecture of the Dapr Traffic Control sample application.\\nEntry and exit ev\", \"ent logic is handled by the TrafficController class, an ordinary ASP.NET Controller.\\nThe TrafficCont\", \"roller.VehicleEntry method accepts an incoming VehicleRegistered message\\nand saves the enclosed vehi\", \"cle state:\\n// store vehicle state\\nvar vehicleState = new VehicleState\\n{\\nLicenseNumber = msg.LicenseN\", \"umber,\\nEntryTimestamp = msg.Timestamp\\n};\\nawait _vehicleStateRepository.SaveVehicleStateAsync(vehicle\", \"State);\\nIn the preceding code snippet, the abstraction _vehicleStateRepository is responsible for sa\", \"ving\\nstate to the data store. Its concrete implementation, DaprVehicleStateRepository, is shown belo\", \"w:\\npublic class DaprVehicleStateRepository : IVehicleStateRepository\\n{\\nprivate const string DAPR_STO\", \"RE_NAME = \\\"statestore\\\";\\nprivate readonly DaprClient _daprClient;\\npublic DaprVehicleStateRepository(D\", \"aprClient daprClient)\\n{\\n_daprClient = daprClient;\\n}\\npublic async Task SaveVehicleStateAsync(VehicleS\", \"tate vehicleState)\\n{\\nawait _daprClient.SaveStateAsync<VehicleState>(\\nDAPR_STORE_NAME, vehicleState.L\", \"icenseNumber, vehicleState);\\n}\\npublic async Task<VehicleState> GetVehicleStateAsync(string licenseNu\", \"mber)\\n{\\nreturn await _daprClient.GetStateAsync<VehicleState>(\\nDAPR_STORE_NAME, licenseNumber);\\n}\\n}\\nA\", \"s the preceding code snippet shows, the implementation of the DaprVehicleStateRepository class\\nis pr\", \"etty straightforward. The SaveVehicleStateAsync method uses the injected DaprClient object\\n50 CHAPTE\", \"R 6 | The Dapr state management building blockto save the state to the configured Dapr state store. \", \"It uses the vehicle\\u2019s license number as the key.\\nThe application can retrieve the saved state by cal\", \"ling the GetVehicleStateAsync method.\\nThe TrafficControl service uses Redis as its underlying data s\", \"tore. Looking at the code, you\\u2019d never\\nknow it. A service consuming the Dapr state management buildi\", \"ng block doesn\\u2019t directly reference\\nany state components. Instead, a Dapr component configuration fi\", \"le specifies the store:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: statestore\\nname\", \"space: dapr-trafficcontrol\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- name: redisHost\\nvalue: lo\", \"calhost:6379\\n- name: redisPassword\\nsecretKeyRef:\\nname: state.redisPassword\\nkey: state.redisPassword\\n\", \"scopes:\\n- trafficcontrolservice\\nNote\\nThe component configuration file includes an element secretKeyR\", \"ef. The application uses it to\\nreference the Redis password value from the Dapr secrets building blo\", \"ck. See chapter 10 to learn\\nmore about managing secrets with Dapr.\\nThe type element in the configura\", \"tion, state.redis instructs the building block to manage state with\\nDapr Redis component.\\nThe scopes\", \" element in the configuration constrains application access to the state store component.\\nOnly the T\", \"rafficControl service can access the state store.\\nSummary\\nThe Dapr state management building block o\", \"ffers an API for storing key/value data across various\\ndata stores. The API provides support for:\\n\\u2022 \", \"Bulk operations\\n\\u2022 Strong and eventual consistency\\n\\u2022 Optimistic concurrency control\\n\\u2022 Multi-item tran\", \"sactions\\nThe .NET SDK provides language-specific support for .NET and ASP.NET Core. Model binding\\nin\", \"tegration simplifies accessing and updating state from ASP.NET Core controller action methods.\\nIn th\", \"e Dapr Traffic Control sample application, the benefits of using Dapr state management are clear:\\n51\", \" CHAPTER 6 | The Dapr state management building block1. It abstracts away the complexity of using th\", \"ird-party SDKs, such as StackExchange.Redis.\\n2. Replacing the underlying Redis cache with a differen\", \"t type of data store only requires changes to\\nthe component configuration file.\\nReferences\\n\\u2022 Dapr su\", \"pported state stores\\n52 CHAPTER 6 | The Dapr state management building block7\\nCHAPTER\\nThe Dapr servi\", \"ce\\ninvocation building block\\nAcross a distributed system, one service often needs to communicate wit\", \"h another to complete a\\nbusiness operation. The Dapr service invocation building block can help stre\", \"amline the\\ncommunication between services.\\nWhat it solves\\nMaking calls between services in a distrib\", \"uted application may appear easy, but there are many\\nchallenges involved. For example:\\n\\u2022 Where the o\", \"ther services are located.\\n\\u2022 How to call a service securely, given the service address.\\n\\u2022 How to han\", \"dle retries when short-lived transient errors occur.\\nLastly, as distributed applications compose man\", \"y different services, capturing insights across service\\ncall graphs are critical to diagnosing produ\", \"ction issues.\\nThe service invocation building block addresses these challenges by using a Dapr sidec\", \"ar as a reverse\\nproxy for your service.\\nHow it works\\nLet\\u2019s start with an example. Consider two servi\", \"ces, \\u201cService A\\u201d and \\u201cService B\\u201d. Service A needs to call\\nthe catalog/items API on Service B. While \", \"Service A could take a dependency on Service B and make\\na direct call to it, Service A instead invok\", \"es the service invocation API on the Dapr sidecar. Figure 6-1\\nshows the operation.\\n53 CHAPTER 7 | Th\", \"e Dapr service invocation building blockFigure 6-1. How Dapr service invocation works.\\nNote the step\", \"s from the previous figure:\\n1. Service A makes a call to the catalog/items endpoint in Service B by \", \"invoking the service\\ninvocation API on the Service A sidecar.\\n[!NOTE] The sidecar uses a pluggable n\", \"ame resolution component to resolve the address of\\nService B. In self-hosted mode, Dapr uses mDNS to\", \" find it. When running in Kubernetes mode,\\nthe Kubernetes DNS service determines the address.\\n2. The\", \" Service A sidecar forwards the request to the Service B sidecar.\\n3. The Service B sidecar makes the\", \" actual catalog/items request against the Service B API.\\n4. Service B executes the request and retur\", \"ns a response back to its sidecar.\\n5. The Service B sidecar forwards the response back to the Servic\", \"e A sidecar.\\n6. The Service A sidecar returns the response back to Service A.\\nBecause the calls flow\", \" through sidecars, Dapr can inject some useful cross-cutting behaviors:\\n\\u2022 Automatically retry calls \", \"upon failure.\\n\\u2022 Make calls between services secure with mutual (mTLS) authentication, including auto\", \"matic\\ncertificate rollover.\\n\\u2022 Control what operations clients can do using access control policies.\\n\", \"\\u2022 Capture traces and metrics for all calls between services to provide insights and diagnostics.\\n54 \", \"CHAPTER 7 | The Dapr service invocation building blockAny application can invoke a Dapr sidecar by u\", \"sing the native invoke API built into Dapr. The API can\\nbe called with either HTTP or gRPC. Use the \", \"following URL to call the HTTP API:\\nhttp://localhost:<dapr-port>/v1.0/invoke/<application-id>/method\", \"/<method-name>\\n\\u2022 <dapr-port> the HTTP port that Dapr is listening on.\\n\\u2022 <application-id> application\", \" ID of the service to call.\\n\\u2022 <method-name> name of the method to invoke on the remote service.\\nIn t\", \"he following example, a curl call is made to the catalog/items \\u2018GET\\u2019 endpoint of Service B:\\ncurl htt\", \"p://localhost:3500/v1.0/invoke/serviceb/method/catalog/items\\nNote\\nThe Dapr APIs enable any applicati\", \"on stack that supports HTTP or gRPC to use Dapr building blocks.\\nTherefore, the service invocation b\", \"uilding block can act as a bridge between protocols. Services can\\ncommunicate with each other using \", \"HTTP, gRPC or a combination of both.\\nIn the next section, you\\u2019ll learn how to use the .NET SDK to si\", \"mplify service invocation calls.\\nUse the Dapr .NET SDK\\nThe Dapr .NET SDK provides .NET developers wi\", \"th an intuitive and language-specific way to interact\\nwith Dapr. The SDK offers developers three way\", \"s of making remote service invocation calls:\\n1. Invoke HTTP services using HttpClient\\n2. Invoke HTTP\", \" services using DaprClient\\n3. Invoke gRPC services using DaprClient\\nInvoke HTTP services using HttpC\", \"lient\\nThe preferred way to call an HTTP endpoint is to use Dapr\\u2019s rich integration with HttpClient. \", \"The\\nfollowing example submits an order by calling the submit method of the orderservice application:\", \"\\nvar httpClient = DaprClient.CreateInvokeHttpClient();\\nawait httpClient.PostAsJsonAsync(\\\"http://orde\", \"rservice/submit\\\", order);\\nIn the example, DaprClient.CreateInvokeHttpClient returns an HttpClient in\", \"stance that is used to\\nperform Dapr service invocation. The returned HttpClient uses a special Dapr \", \"message handler that\\nrewrites URIs of outgoing requests. The host name is interpreted as the applica\", \"tion ID of the service to\\ncall. The rewritten request that\\u2019s actually being called is:\\nhttp://127.0.\", \"0.1:3500/v1/invoke/orderservice/method/submit\\nThis example uses the default value for the Dapr HTTP \", \"endpoint, which is http://127.0.0.1:<dapr-\\nhttp-port>/. The value of dapr-http-port is taken from th\", \"e DAPR_HTTP_PORT environment variable.\\nIf it\\u2019s not set, the default port number 3500 is used.\\n55 CHA\", \"PTER 7 | The Dapr service invocation building blockAlternatively, you can configure a custom endpoin\", \"t in the call to\\nDaprClient.CreateInvokeHttpClient:\\nvar httpClient = DaprClient.CreateInvokeHttpClie\", \"nt(daprEndpoint: \\\"localhost:4000\\\");\\nYou can also directly set the base address by specifying the app\", \"lication ID. Doing so enables relative\\nURIs when making a call:\\nvar httpClient = DaprClient.CreateIn\", \"vokeHttpClient(\\\"orderservice\\\");\\nawait httpClient.PostAsJsonAsync(\\\"/submit\\\");\\nThe HttpClient object i\", \"s intended to be long-lived. A single HttpClient instance can be reused for\\nthe lifetime of the appl\", \"ication. The next scenario demonstrates how an OrderServiceClient class\\nreuses a Dapr HttpClient ins\", \"tance:\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder.Services.AddSingleton<IOrderService\", \"Client, OrderServiceClient>(\\n_ => new OrderServiceClient(DaprClient.CreateInvokeHttpClient(\\\"orderser\", \"vice\\\")));\\nIn the snippet above, the OrderServiceClient is registered as a singleton with the ASP.NET\", \" Core\\ndependency injection system. An implementation factory creates a new HttpClient instance by\\nca\", \"lling DaprClient.CreateInvokeHttpClient. It then uses the newly created HttpClient to\\ninstantiate th\", \"e OrderServiceClient object. By registering the OrderServiceClient as a singleton, it\\nwill be reused\", \" for the lifetime of the application.\\nThe OrderServiceClient itself has no Dapr-specific code. Even \", \"though Dapr service invocation is\\nused under the hood, you can treat the Dapr HttpClient like any ot\", \"her HttpClient:\\npublic class OrderServiceClient : IOrderServiceClient\\n{\\nprivate readonly HttpClient \", \"_httpClient;\\npublic OrderServiceClient(HttpClient httpClient)\\n{\\n_httpClient = httpClient ?? throw ne\", \"w ArgumentNullException(nameof(httpClient));\\n}\\npublic async Task SubmitOrder(Order order)\\n{\\nvar resp\", \"onse = await _httpClient.PostAsJsonAsync(\\\"submit\\\", order);\\nresponse.EnsureSuccessStatusCode();\\n}\\n}\\nU\", \"sing the HttpClient class with Dapr service invocation has many benefits:\\n\\u2022 HttpClient is a well-kno\", \"wn class that many developers already use in their code. Using HttpClient\\nfor Dapr service invocatio\", \"n allows developers to reuse their existing skills.\\n\\u2022 HttpClient supports advanced scenarios, such a\", \"s custom headers, and full control over request\\nand response messages.\\n\\u2022 In .NET 5, HttpClient suppo\", \"rts automatic serialization and deserialization using System.Text.Json.\\n\\u2022 HttpClient integrates with\", \" many existing frameworks and libraries, such as Refit, RestSharp, and\\nPolly.\\n56 CHAPTER 7 | The Dap\", \"r service invocation building blockInvoke HTTP services using DaprClient\\nWhile HttpClient is the pre\", \"ferred way to invoke services using HTTP semantics, you can also use the\\nDaprClient.InvokeMethodAsyn\", \"c family of methods. The following example submits an order by\\ncalling the submit method of the orde\", \"rservice application:\\nvar daprClient = new DaprClientBuilder().Build();\\ntry\\n{\\nvar confirmation =\\nawa\", \"it daprClient.InvokeMethodAsync<Order, OrderConfirmation>(\\n\\\"orderservice\\\", \\\"submit\\\", order);\\n}\\ncatch\", \" (InvocationException ex)\\n{\\n// Handle error\\n}\\nThe third argument, an order object, is serialized int\", \"ernally (with System.Text.JsonSerializer) and\\nsent as the request payload. The .NET SDK takes care o\", \"f the call to the sidecar. It also deserializes the\\nresponse to an OrderConfirmation object. Because\", \" no HTTP method is specified, the request is\\nexecuted as an HTTP POST.\\nThe next example demonstrates\", \" how you can make an HTTP GET request by specifying the\\nHttpMethod:\\nvar catalogItems = await\\ndaprCli\", \"ent.InvokeMethodAsync<IEnumerable<CatalogItem>>(HttpMethod.Get, \\\"catalogservice\\\",\\n\\\"items\\\");\\nFor some\", \" scenarios, you may require more control over the request message. For example, when you\\nneed to spe\", \"cify request headers, or you want to use a custom serializer for the payload.\\nDaprClient.CreateInvok\", \"eMethodRequest creates an HttpRequestMessage. The following example\\ndemonstrates how to add an HTTP \", \"authorization header to a request message:\\nvar request = daprClient.CreateInvokeMethodRequest(\\\"order\", \"service\\\", \\\"submit\\\", order);\\nrequest.Headers.Authorization = new AuthenticationHeaderValue(\\\"bearer\\\", \", \"token);\\nThe HttpRequestMessage now has the following properties set:\\n\\u2022 Url = http://127.0.0.1:3500/v\", \"1.0/invoke/orderservice/method/submit\\n\\u2022 HttpMethod = POST\\n\\u2022 Content = JsonContent object containing \", \"the JSON-serialized order\\n\\u2022 Headers.Authorization = \\u201cbearer <token>\\u201d\\nOnce you\\u2019ve got the request set\", \" up the way you want, use DaprClient.InvokeMethodAsync to send it:\\nvar orderConfirmation = await dap\", \"rClient.InvokeMethodAsync<OrderConfirmation>(request);\\nDaprClient.InvokeMethodAsync deserializes the\", \" response to an OrderConfirmation object if the\\nrequest is successful. Alternatively, you can use Da\", \"prClient.InvokeMethodWithResponseAsync to get\\nfull access to the underlying HttpResponseMessage:\\n57 \", \"CHAPTER 7 | The Dapr service invocation building blockvar response = await daprClient.InvokeMethodWi\", \"thResponseAsync(request);\\nresponse.EnsureSuccessStatusCode();\\nvar orderConfirmation = response.Conte\", \"nt.ReadFromJsonAsync<OrderConfirmation>();\\nNote\\nFor service invocation calls using HTTP, it\\u2019s worth \", \"considering using the Dapr HttpClient integration\\npresented in the previous section. Using HttpClien\", \"t gives you additional benefits such as integration\\nwith existing frameworks and libraries.\\nInvoke g\", \"RPC services using DaprClient\\nDaprClient provides a family of InvokeMethodGrpcAsync methods for call\", \"ing gRPC endpoints. The\\nmain difference with the HTTP methods is the use of a Protobuf serializer in\", \"stead of JSON. The\\nfollowing example invokes the submitOrder method of the orderservice over gRPC.\\nv\", \"ar daprClient = new DaprClientBuilder().Build();\\ntry\\n{\\nvar confirmation = await daprClient.InvokeMet\", \"hodGrpcAsync<Order,\\nOrderConfirmation>(\\\"orderservice\\\", \\\"submitOrder\\\", order);\\n}\\ncatch (InvocationExc\", \"eption ex)\\n{\\n// Handle error\\n}\\nIn the example above, DaprClient serializes the given order object us\", \"ing Protobuf and uses the result\\nas the gRPC request body. Likewise, the response body is Protobuf d\", \"eserialized and returned to the\\ncaller. Protobuf typically provides better performance than the JSON\", \" payloads used in HTTP service\\ninvocation.\\nName resolution components\\nAt the time of writing, Dapr p\", \"rovides support for the following name resolution components:\\n\\u2022 mDNS (default when running self-host\", \"ed)\\n\\u2022 Kubernetes Name Resolution (default when running in Kubernetes)\\n\\u2022 HashiCorp Consul\\nConfigurati\", \"on\\nTo use a non-default name resolution component, add a nameResolution spec to the application\\u2019s\\nDa\", \"pr configuration file. Here\\u2019s an example of a Dapr configuration file that enables HashiCorp Consul\\n\", \"name resolution:\\napiVersion: dapr.io/v1alpha1\\nkind: Configuration\\nmetadata:\\n58 CHAPTER 7 | The Dapr \", \"service invocation building blockname: dapr-config\\nspec:\\nnameResolution:\\ncomponent: \\\"consul\\\"\\nconfigu\", \"ration:\\nselfRegister: true\\nSample application: Dapr Traffic Control\\nIn Dapr Traffic Control sample a\", \"pp, the FineCollection service uses the Dapr service invocation\\nbuilding block to retrieve vehicle a\", \"nd owner information from the VehicleRegistration service. Figure\\n6-2 shows the conceptual architect\", \"ure of the Dapr Traffic Control sample application. The Dapr service\\ninvocation building block is us\", \"ed in flows marked with number 1 in the diagram:\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/service-inv\", \"ocation/dapr-solution-service-invocation.png\\u201d\\nalt-text=\\u201cConceptual architecture of the Dapr Traffic \", \"Control sample application.\\u201d:::\\nFigure 6-2. Conceptual architecture of the Dapr Traffic Control samp\", \"le application.\\nInformation is retrieved by the ASP.NET CollectionController class in the FineCollec\", \"tion service.\\nThe CollectFine method expects an incoming SpeedingViolation parameter. It invokes a D\", \"apr\\nservice invocation building block to call to the VehicleRegistration service. The code snippet i\", \"s\\npresented below.\\n:::{custom-style=CodeBox} ```csharp [Topic(\\u201cpubsub\\u201d, \\u201cspeedingviolations\\u201d)] [Rout\", \"e(\\u201ccollectfine\\u201d)]\\n[HttpPost] public async Task CollectFine(SpeedingViolation speedingViolation, [Fro\", \"mServices]\\nDaprClient daprClient) { // \\u2026\\n// get owner info (Dapr service invocation)\\nvar vehicleInfo\", \" =\\n_vehicleRegistrationService.GetVehicleInfo(speedingViolation.VehicleId).Result;\\n// ...\\n} ``` :::\\n\", \"The code uses a proxy of type VehicleRegistrationService to call the VehicleRegistration service.\\nAS\", \"P.NET Core injects an instance of the service proxy using constructor injection:\\n:::{custom-style=Co\", \"deBox} csharp public CollectionController( ILogger<CollectionController>\\nlogger, IFineCalculator fin\", \"eCalculator, VehicleRegistrationService vehicleRegistrationService,\\nDaprClient daprClient) { // ... \", \"} :::\\nThe VehicleRegistrationService class contains a single method: GetVehicleInfo. It uses the\\nASP\", \".NET Core HttpClient to call the VehicleRegistration service:\\n:::{custom-style=CodeBox} ```csharp pu\", \"blic class VehicleRegistrationService { private HttpClient\\n_httpClient; public VehicleRegistrationSe\", \"rvice(HttpClient httpClient) { _httpClient = httpClient; }\\npublic async Task<VehicleInfo> GetVehicle\", \"Info(string licenseNumber)\\n{\\nreturn await _httpClient.GetFromJsonAsync<VehicleInfo>(\\n59 CHAPTER 7 | \", \"The Dapr service invocation building block$\\\"vehicleinfo/{licenseNumber}\\\");\\n}\\n} ``` :::\\nThe code does\", \"n\\u2019t depend on any Dapr classes directly. It instead leverages the Dapr ASP.NET Core\\nintegration as d\", \"escribed in the Invoke HTTP services using HttpClient section of this module. The\\nfollowing code in \", \"the ConfigureService method of the Startup class registers the\\nVehicleRegistrationService proxy:\\nvar\", \" builder = WebApplication.CreateBuilder(args);\\nbuilder.Services.AddSingleton<VehicleRegistrationServ\", \"ice>(_ =>\\nnew VehicleRegistrationService(DaprClient.CreateInvokeHttpClient(\\n\\\"vehicleregistrationserv\", \"ice\\\", $\\\"http://localhost:{daprHttpPort}\\\"\\n)));\\nThe DaprClient.CreateInvokeHttpClient creates an HttpC\", \"lient instance that calls the\\nVehicleRegistration service using the service invocation building bloc\", \"k under the covers. It expects\\nboth the Dapr app-id of the target service and the URL of its Dapr si\", \"decar. At start time, the\\ndaprHttpPort argument contains the port number used for HTTP communication\", \" with the Dapr\\nsidecar.\\nUsing Dapr service invocation in the Traffic Control sample application prov\", \"ides several benefits:\\n1. Decouples the location of the target service.\\n2. Adds resiliency with auto\", \"matic retry features.\\n3. Ability to reuse an existing HttpClient based proxy (offered by the ASP.NET\", \" Core integration).\\nSummary\\nIn this chapter, you learned about the service invocation building block\", \". You saw how to invoke\\nremote methods both by making direct HTTP calls to the Dapr sidecar, and by \", \"using the Dapr .NET\\nSDK.\\nThe Dapr .NET SDK provides multiple ways to invoke remote methods. HttpClie\", \"nt support is great for\\ndevelopers wanting to reuse existing skills and is compatible with many exis\", \"ting frameworks and\\nlibraries. DaprClient offers support for directly using the Dapr service invocat\", \"ion API using either HTTP\\nor gRPC semantics.\\nReferences\\n\\u2022 Dapr service invocation building block\\n\\u2022 M\", \"onitoring distributed cloud-native applications\\n60 CHAPTER 7 | The Dapr service invocation building \", \"block8\\nCHAPTER\\nThe Dapr publish &\\nsubscribe building block\\nThe Publish-Subscribe pattern (often refe\", \"rred to as \\u201cpub/sub\\u201d) is a well-known and widely used\\nmessaging pattern. Architects commonly embrace\", \" it in distributed applications. However, the\\nplumbing to implement it can be complex. There are oft\", \"en subtle feature differences across different\\nmessaging products. Dapr offers a building block that\", \" significantly simplifies implementing pub/sub\\nfunctionality.\\nWhat it solves\\nThe primary advantage o\", \"f the Publish-Subscribe pattern is loose coupling, sometimes referred to as\\ntemporal decoupling. The\", \" pattern decouples services that send messages (the publishers) from\\nservices that consume messages \", \"(the subscribers). Both publishers and subscribers are unaware of\\neach other - both are dependent on\", \" a centralized message broker that distributes the messages.\\nFigure 7-1 shows the high-level archite\", \"cture of the pub/sub pattern.\\nFigure 7-1. The pub/sub pattern.\\nFrom the previous figure, note the st\", \"eps of the pattern:\\n1. Publishers send messages to the message broker.\\n2. Subscribers bind to a subs\", \"cription on the message broker.\\n61 CHAPTER 8 | The Dapr publish & subscribe building block3. The mes\", \"sage broker forwards a copy of the message to interested subscriptions.\\n4. Subscribers consume messa\", \"ges from their subscriptions.\\nMost message brokers encapsulate a queueing mechanism that can persist\", \" messages once received.\\nWith it, the message broker guarantees durability by storing the message. S\", \"ubscribers don\\u2019t need to\\nbe immediately available or even online when a publisher sends a message. O\", \"nce available, the\\nsubscriber receives and processes the message. Dapr guarantees At-Least-Once sema\", \"ntics for\\nmessage delivery. Once a message is published, it will be delivered at least once to any i\", \"nterested\\nsubscriber.\\nTip\\nIf your service can only process a message once, you\\u2019ll need to provide an\", \" idempotency check to\\nensure that the same message is not processed multiple times. While such logic\", \" can be coded, some\\nmessage brokers, such as Azure Service Bus, provide built-in duplicate detection\", \" messaging\\ncapabilities.\\nThere are several message broker products available - both commercially and\", \" open-source. Each has\\nadvantages and drawbacks. Your job is to match your system requirements to th\", \"e appropriate broker.\\nOnce selected, it\\u2019s a best practice to decouple your application from message \", \"broker plumbing. You\\nachieve this functionality by wrapping the broker inside an abstraction. The ab\", \"straction encapsulates\\nthe message plumbing and exposes generic pub/sub operations to your code. You\", \"r code\\ncommunicates with the abstraction, not the actual message broker. While a wise decision, you\\u2019\", \"ll have\\nto write and maintain the abstraction and its underlying implementation. This approach requi\", \"res\\ncustom code that can be complex, repetitive, and error-prone.\\nThe Dapr publish & subscribe build\", \"ing block provides the messaging abstraction and implementation\\nout-of-the-box. The custom code you \", \"would have had to write is prebuilt and encapsulated inside the\\nDapr building block. You bind to it \", \"and consume it. Instead of writing messaging plumbing code, you\\nand your team focus on creating busi\", \"ness functionality that adds value to your customers.\\nHow it works\\nThe Dapr publish & subscribe buil\", \"ding block provides a platform-agnostic API framework to send and\\nreceive messages. Your services pu\", \"blish messages to a named topic. Your services subscribe to a topic\\nto consume messages.\\nThe service\", \" calls the pub/sub API on the Dapr sidecar. The sidecar then makes calls into a pre-defined\\nDapr pub\", \"/sub component that encapsulates a specific message broker product. Figure 7-2 shows the\\nDapr pub/su\", \"b messaging stack.\\n62 CHAPTER 8 | The Dapr publish & subscribe building blockFigure 7-2. The Dapr pu\", \"b/sub stack.\\nThe Dapr publish & subscribe building block can be invoked in many ways.\\nAt the lowest \", \"level, any programming platform can invoke the building block over HTTP or gRPC\\nusing the Dapr nativ\", \"e API. To publish a message, you make the following API call:\\nhttp://localhost:<dapr-port>/v1.0/publ\", \"ish/<pub-sub-name>/<topic>\\nThere are several Dapr specific URL segments in the above call:\\n\\u2022 <dapr-p\", \"ort> provides the port number upon which the Dapr sidecar is listening.\\n\\u2022 <pub-sub-name> provides th\", \"e name of the selected Dapr pub/sub component.\\n\\u2022 <topic> provides the name of the topic to which the\", \" message is published.\\nUsing the curl command-line tool to publish a message, you can try it out:\\ncu\", \"rl -X POST http://localhost:3500/v1.0/publish/pubsub/newOrder \\\\\\n-H \\\"Content-Type: application/json\\\" \", \"\\\\\\n-d '{ \\\"orderId\\\": \\\"1234\\\", \\\"productId\\\": \\\"5678\\\", \\\"amount\\\": 2 }'\\nYou receive messages by subscribing t\", \"o a topic. At startup, the Dapr runtime will call the application\\non a well-known endpoint to identi\", \"fy and create the required subscriptions:\\nhttp://localhost:<appPort>/dapr/subscribe\\n63 CHAPTER 8 | T\", \"he Dapr publish & subscribe building block\\u2022 <appPort> informs the Dapr sidecar of the port upon whic\", \"h the application is listening.\\nYou can implement this endpoint yourself. But Dapr provides more int\", \"uitive ways of implementing it.\\nWe\\u2019ll address this functionality later in this chapter.\\nThe response\", \" from the call contains a list of topics to which the applications will subscribe. Each\\nincludes an \", \"endpoint to call when the topic receives a message. Here\\u2019s an example of a response:\\n[\\n{\\n\\\"pubsubname\", \"\\\": \\\"pubsub\\\",\\n\\\"topic\\\": \\\"newOrder\\\",\\n\\\"route\\\": \\\"/orders\\\"\\n},\\n{\\n\\\"pubsubname\\\": \\\"pubsub\\\",\\n\\\"topic\\\": \\\"newProdu\", \"ct\\\",\\n\\\"route\\\": \\\"/productCatalog/products\\\"\\n}\\n]\\nIn the JSON response, you can see the application wants\", \" to subscribe to topics newOrder and\\nnewProduct. It registers the endpoints /orders and /productCata\", \"log/products for each,\\nrespectively. For both subscriptions, the application is binding to the Dapr \", \"component named pubsub.\\nFigure 7-3 presents the flow of the example.\\n64 CHAPTER 8 | The Dapr publish\", \" & subscribe building blockFigure 7-3. Pub/sub flow with Dapr.\\nFrom the previous figure, note the fl\", \"ow:\\n1. The Dapr sidecar for Service B calls the /dapr/subscribe endpoint from Service B (the\\nconsume\", \"r). The service responds with the subscriptions it wants to create.\\n2. The Dapr sidecar for Service \", \"B creates the requested subscriptions on the message broker.\\n3. Service A publishes a message at the\", \" /v1.0/publish/<pub-sub-name>/<topic> endpoint on\\nthe Dapr Service A sidecar.\\n4. The Service A sidec\", \"ar publishes the message to the message broker.\\n5. The message broker sends a copy of the message to\", \" the Service B sidecar.\\n6. The Service B sidecar calls the endpoint corresponding to the subscriptio\", \"n (in this case /orders)\\non Service B. The service responds with an HTTP status-code 200 OK so the s\", \"idecar will consider\\nthe message as being handled successfully.\\nIn the example, the message is handl\", \"ed successfully. But if something goes wrong while Service B is\\nhandling the request, it can use the\", \" response to specify what needs to happen with the message.\\nWhen it returns an HTTP status-code 404,\", \" an error is logged and the message is dropped. With any\\nother status-code than 200 or 404, a warnin\", \"g is logged and the message is retried. Alternatively,\\n65 CHAPTER 8 | The Dapr publish & subscribe b\", \"uilding blockService B can explicitly specify what needs to happen with the message by including a J\", \"SON payload\\nin the body of the response:\\n{\\n\\\"status\\\": \\\"<status>\\\"\\n}\\nThe following table shows the avai\", \"lable status values:\\nStatus Action\\nSUCCESS The message is considered as processed successfully and d\", \"ropped.\\nRETRY The message is retried.\\nDROP A warning is logged and the message is dropped.\\nAny other\", \" status The message is retried.\\nCompeting consumers\\nWhen scaling out an application that subscribes \", \"to a topic, you have to deal with competing\\nconsumers. Only one application instance should handle a\", \" message sent to the topic. Luckily, Dapr\\nhandles that problem. When multiple instances of a service\", \" with the same application-id subscribe to\\na topic, Dapr delivers each message to only one of them.\\n\", \"Use the Dapr .NET SDK\\nFor .NET Developers, the Dapr .NET SDK provides a more productive way of worki\", \"ng with Dapr. The\\nSDK exposes a DaprClient class through which you can directly invoke Dapr function\", \"ality. It\\u2019s intuitive\\nand easy to use.\\nTo publish a message, the DaprClient exposes a PublishEventAs\", \"ync method.\\nvar data = new OrderData\\n{\\norderId = \\\"123456\\\",\\nproductId = \\\"67890\\\",\\namount = 2\\n};\\nvar da\", \"prClient = new DaprClientBuilder().Build();\\nawait daprClient.PublishEventAsync<OrderData>(\\\"pubsub\\\", \", \"\\\"newOrder\\\", data);\\n\\u2022 The first argument pubsub is the name of the Dapr component that provides the m\", \"essage broker\\nimplementation. We\\u2019ll address components later in this chapter.\\n\\u2022 The second argument \", \"neworder provides the name of the topic to send the message to.\\n\\u2022 The third argument is the payload \", \"of the message.\\n\\u2022 You can specify the .NET type of the message using the generic type parameter of t\", \"he method.\\n66 CHAPTER 8 | The Dapr publish & subscribe building blockTo receive messages, you bind a\", \"n endpoint to a subscription for a registered topic. The AspNetCore\\nlibrary for Dapr makes this triv\", \"ial. Assume, for example, that you have an existing ASP.NET WebAPI\\naction method entitled CreateOrde\", \"r:\\n[HttpPost(\\\"/orders\\\")]\\npublic async Task<ActionResult> CreateOrder(Order order)\\nImportant\\nYou must\", \" add a reference to the Dapr.AspNetCore NuGet package in your project to consume the\\nDapr ASP.NET Co\", \"re integration.\\nTo bind this action method to a topic, you decorate it with the Topic attribute:\\n[To\", \"pic(\\\"pubsub\\\", \\\"newOrder\\\")]\\n[HttpPost(\\\"/orders\\\")]\\npublic async Task<ActionResult> CreateOrder(Order o\", \"rder)\\nYou specify two key elements with this attribute:\\n\\u2022 The Dapr pub/sub component to target (in t\", \"his case pubsub).\\n\\u2022 The topic to subscribe to (in this case newOrder).\\nDapr then invokes that action\", \" method as it receives messages for that topic.\\nYou\\u2019ll also need to enable ASP.NET Core to use Dapr.\", \" The Dapr .NET SDK provides several extension\\nmethods that can be used to do this.\\nIn the Program.cs\", \" file, you must call the following extension method on the WebApplication builder\\nto register Dapr:\\n\", \"var builder = WebApplication.CreateBuilder(args);\\nbuilder.Services.AddControllers().AddDapr();\\nAppen\", \"ding the AddDapr extension method to the AddControllers extension method registers the\\nnecessary ser\", \"vices to integrate Dapr into the MVC pipeline. It also registers a DaprClient instance\\ninto the depe\", \"ndency injection container, which then can be injected anywhere into your service.\\nAfter the WebAppl\", \"ication has been created, you must add the following middleware components to\\nenable Dapr:\\nvar build\", \"er = WebApplication.CreateBuilder(args);\\nvar app = builder.Build();\\napp.UseCloudEvents();\\napp.MapCon\", \"trollers();\\napp.MapSubscribeHandler();\\nThe call to UseCloudEvents adds CloudEvents middleware into t\", \"o the ASP.NET Core middleware\\npipeline. This middleware will unwrap requests that use the CloudEvent\", \"s structured format, so the\\nreceiving method can read the event payload directly.\\n67 CHAPTER 8 | The\", \" Dapr publish & subscribe building blockNote\\nCloudEvents is a standardized messaging format, providi\", \"ng a common way to describe event\\ninformation across platforms. Dapr embraces CloudEvents. For more \", \"information about CloudEvents,\\nsee the cloudevents specification.\\nThe call to MapSubscribeHandler in\", \" the endpoint routing configuration will add a Dapr subscribe\\nendpoint to the application. This endp\", \"oint will respond to requests on /dapr/subscribe. When this\\nendpoint is called, it will automaticall\", \"y find all WebAPI action methods decorated with the Topic\\nattribute and instruct Dapr to create subs\", \"criptions for them.\\nPub/sub components\\nDapr pub/sub components handle the actual transport of the me\", \"ssages. Several are available. Each\\nencapsulates a specific message broker product to implement the \", \"pub/sub functionality. At the time\\nof writing, the following pub/sub components were available:\\n\\u2022 Ap\", \"ache Kafka\\n\\u2022 AWS SNS/SQS\\n\\u2022 Azure Event Hubs\\n\\u2022 Azure Service Bus\\n\\u2022 GCP Pub/Sub\\n\\u2022 Hazelcast\\n\\u2022 In Memor\", \"y\\n\\u2022 JetStream\\n\\u2022 MQTT\\n\\u2022 NATS Streaming\\n\\u2022 Pulsar\\n\\u2022 RabbitMQ\\n\\u2022 Redis Streams\\nNote\\nThe Azure cloud stack\", \" has both messaging functionality (Azure Service Bus) and event streaming\\n(Azure Event Hub) availabi\", \"lity.\\nThese components are created by the community in a component-contrib repository on GitHub.\\nYou\", \"\\u2019re encouraged to write your own Dapr component for a message broker that isn\\u2019t yet supported.\\nConfi\", \"guration\\nUsing a Dapr configuration file, you can specify the pub/sub component(s) to use. This conf\", \"iguration\\ncontains several fields. The name field specifies the pub/sub component that you want to u\", \"se. When\\nsending or receiving a message, you need to specify this name (as you saw earlier in the\\nPu\", \"blishEventAsync method signature).\\n68 CHAPTER 8 | The Dapr publish & subscribe building blockBelow y\", \"ou see an example of a Dapr configuration file for configuring a RabbitMQ message broker\\ncomponent:\\n\", \"apiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: pubsub-rq\\nspec:\\ntype: pubsub.rabbitmq\\nv\", \"ersion: v1\\nmetadata:\\n- name: host\\nvalue: \\\"amqp://localhost:5672\\\"\\n- name: durable\\nvalue: true\\nIn this\", \" example, you can see that you can specify any message broker-specific configuration in the\\nmetadata\", \" block. In this case, RabbitMQ is configured to create durable queues. But the RabbitMQ\\ncomponent ha\", \"s more configuration options. Each of the components\\u2019 configuration will have its own\\nset of possibl\", \"e fields. You can read which fields are available in the documentation of each pub/sub\\ncomponent.\\nNe\", \"xt to the programmatic way of subscribing to a topic from code, Dapr pub/sub also provides a\\ndeclara\", \"tive way of subscribing to a topic. This approach removes the Dapr dependency from the\\napplication c\", \"ode. Therefore, it also enables an existing application to subscribe to topics without any\\nchanges t\", \"o the code. The following example shows a Dapr configuration file for configuring a\\nsubscription:\\nap\", \"iVersion: dapr.io/v1alpha1\\nkind: Subscription\\nmetadata:\\nname: newOrder-subscription\\nspec:\\npubsubname\", \": pubsub\\ntopic: newOrder\\nroute: /orders\\nscopes:\\n- ServiceB\\n- ServiceC\\nYou have to specify several el\", \"ements with every subscription:\\n\\u2022 The name of the Dapr pub/sub component you want to use (in this ca\", \"se pubsub).\\n\\u2022 The name of the topic to subscribe to (in this case newOrder).\\n\\u2022 The API operation tha\", \"t needs to be called for this topic (in this case /orders).\\n\\u2022 The scope can specify which services c\", \"an publish and subscribe to a topic.\\nSample application: Dapr Traffic Control\\nIn Dapr Traffic Contro\", \"l sample app, the TrafficControl service uses the Dapr pub/sub building block to\\nsend speeding viola\", \"tions to the FineCollection service. Figure 7-4 shows the conceptual architecture\\n69 CHAPTER 8 | The\", \" Dapr publish & subscribe building blockof the Dapr Traffic Control sample application. The Dapr pub\", \"/sub building block is used in flows\\nmarked with number 2 in the diagram:\\n:::image type=\\u201ccontent\\u201d so\", \"urce=\\u201c./media/publish-subscribe/dapr-solution-pub-sub.png\\u201d alt-\\ntext=\\u201cConceptual architecture of the\", \" Dapr Traffic Control sample application.\\u201d:::\\nFigure 7-4. Conceptual architecture of the Dapr Traffi\", \"c Control sample application.\\nSpeeding violations are handled by the CollectionController, an ordina\", \"ry ASP.NET Core Controller.\\nThe CollectionController.CollectFine method subscribes to and handles Sp\", \"eedingViolation\\nevent messages:\\n[Topic(\\\"pubsub\\\", \\\"speedingviolations\\\")]\\n[Route(\\\"collectfine\\\")]\\n[Http\", \"Post]\\npublic async Task<ActionResult> CollectFine(\\nSpeedingViolation speedingViolation, [FromService\", \"s] DaprClient daprClient)\\n{\\n// ...\\n}\\nThe method is decorated with the Dapr Topic attribute. It speci\", \"fies that the pub/sub component\\nnamed pubsub should be used to subscribe to messages sent to the spe\", \"edingviolations topic.\\nThe TrafficControl service sends speeding violations. Near the end of the Veh\", \"icleExit method in the\\nTrafficController class, the DaprClient object is used to publish SpeedingVio\", \"lation messages\\nusing the pub/sub building block:\\n/// ...\\nvar speedingViolation = new SpeedingViolat\", \"ion\\n{\\nVehicleId = msg.LicenseNumber,\\nRoadId = _roadId,\\nViolationInKmh = violation,\\nTimestamp = msg.T\", \"imestamp\\n};\\n// publish speedingviolation (Dapr publish / subscribe)\\nawait daprClient.PublishEventAsy\", \"nc(\\\"pubsub\\\", \\\"speedingviolations\\\", speedingViolation);\\n/// ...\\nNote how the DaprClient object reduce\", \"s the call to a single line of code, again, binding to the\\nspeedingviolations topic and the Dapr pub\", \"sub component.\\nWhile the Traffic Control app uses RabbitMQ as the message broker, it never directly \", \"references\\nRabbitMQ. Instead, the accompanying Dapr component configuration file named pubsub.yaml i\", \"n the\\n/dapr/components folder specifies the message broker:\\napiVersion: dapr.io/v1alpha1\\nkind: Compo\", \"nent\\nmetadata:\\nname: pubsub\\nnamespace: dapr-trafficcontrol\\nspec:\\ntype: pubsub.rabbitmq\\n70 CHAPTER 8 \", \"| The Dapr publish & subscribe building blockversion: v1\\nmetadata:\\n- name: host\\nvalue: \\\"amqp://local\", \"host:5672\\\"\\n- name: durable\\nvalue: \\\"false\\\"\\n- name: deletedWhenUnused\\nvalue: \\\"false\\\"\\n- name: autoAck\\nv\", \"alue: \\\"false\\\"\\n- name: reconnectWait\\nvalue: \\\"0\\\"\\n- name: concurrency\\nvalue: parallel\\nscopes:\\n- traffic\", \"controlservice\\n- finecollectionservice\\nThe type element in the configuration, pubsub.rabbitmq instru\", \"cts the building block to use the Dapr\\nRabbitMQ component.\\nThe scopes element in the configuration c\", \"onstrains application access to the RabbitMQ component.\\nOnly the TrafficControl and FineCollection s\", \"ervices can consume it.\\nUsing Dapr pub/sub in the Traffic Control sample application offers the foll\", \"owing benefits:\\n1. No infrastructural abstraction of a message broker to maintain.\\n2. Services are t\", \"emporally decoupled, which increases robustness.\\n3. Publisher and subscribers are unaware of each ot\", \"her. This means that additional services could\\nbe introduced that will react to speeding violations \", \"in the future, without the need to change the\\nTrafficControl service.\\nSummary\\nThe pub/sub pattern he\", \"lps you decouple services in a distributed application. The Dapr publish &\\nsubscribe building block \", \"simplifies implementing this behavior in your application.\\nThrough Dapr pub/sub, you can publish mes\", \"sages to a specific topic. As well, the building block will\\nquery your service to determine which to\", \"pic(s) to subscribe to.\\nYou can use Dapr pub/sub natively over HTTP or by using one of the language-\", \"specific SDKs, such as\\nthe .NET SDK for Dapr. The .NET SDK tightly integrates with the ASP.NET core \", \"platform.\\nWith Dapr, you can plug a supported message broker product into your application. You can \", \"then\\nswap message brokers without requiring code changes to your application.\\nReferences\\n\\u2022 Dapr supp\", \"orted pub/sub brokers\\n71 CHAPTER 8 | The Dapr publish & subscribe building block9\\nCHAPTER\\nThe Dapr b\", \"indings\\nbuilding block\\nCloud-based serverless offerings, such as Azure Functions and AWS Lambda, hav\", \"e gained wide\\nadoption across the distributed architecture space. Among many benefits, they enable a\", \" microservice\\nto handle events from or invoke events in an external system - abstracting away the un\", \"derlying\\ncomplexity and plumbing concerns. External resources are many: They include datastores, mes\", \"sage\\nsystems, and web resources, across different platforms and vendors. The Dapr bindings building \", \"block\\nbrings these same resource binding capabilities to the doorstep of your Dapr applications.\\nWha\", \"t it solves\\nDapr resource bindings enable your services to integrate business operations across exte\", \"rnal\\nresources outside of the immediate application. An event from an external system could trigger \", \"an\\noperation in your service passing in contextual information. Your service could then expand the\\no\", \"peration by triggering an event in another external system, passing in contextual payload\\ninformatio\", \"n. Your service communicates without coupling or awareness of the external resource. The\\nplumbing is\", \" encapsulated inside pre-defined Dapr components. The Dapr component to use can be\\neasily swapped at\", \" run time without code changes.\\nConsider, for example, a Twitter account that triggers an event when\", \"ever a user tweets a keyword.\\nYour service exposes an event handler that receives and processes the \", \"tweet. Once complete, your\\nservice triggers an event that invokes an external Twilio service. Twilio\", \" sends an SMS message that\\nincludes the tweet. Figure 8-1 show the conceptual architecture of this o\", \"peration:\\nFigure 8-1. Conceptual architecture of a Dapr resource binding.\\nAt first glance, resource \", \"binding behavior may appear similar to the Publish/Subscribe pattern\\ndescribed earlier in this book.\", \" While they share similarities, there are differences. Publish/subscribe\\n72 CHAPTER 9 | The Dapr bin\", \"dings building blockfocuses on asynchronous communication between Dapr services. Resource binding ha\", \"s a much wider\\nscope. It focuses on system interoperability across software platforms. Exchanging in\", \"formation\\nbetween disparate applications, datastores, and services outside your microservice applica\", \"tion.\\nHow it works\\nDapr resource binding starts with a component configuration file. This YAML file \", \"describes the type of\\nresource to which you\\u2019ll bind along with its configuration settings. Once conf\", \"igured, your service can\\nreceive events from the resource or trigger events on it.\\nNote\\nBinding conf\", \"igurations are presented in detail later in the Components section.\\nInput bindings\\nInput bindings tr\", \"igger your code with incoming events from external resources. To receive events and\\ndata, you regist\", \"er a public endpoint from your service that becomes the event handler. Figure 8-2\\nshows the flow:\\nFi\", \"gure 8-2. Dapr input binding flow.\\nFigure 8.2 describes the steps for receiving events from an exter\", \"nal Twitter account:\\n73 CHAPTER 9 | The Dapr bindings building block1. The Dapr sidecar reads the bi\", \"nding configuration file and subscribes to the event specified for\\nthe external resource. In the exa\", \"mple, the event source is a Twitter account.\\n2. When a matching Tweet is published on Twitter, the b\", \"inding component running in the Dapr\\nsidecar picks it up and triggers an event.\\n3. The Dapr sidecar \", \"invokes the endpoint (that is, event handler) configured for the binding. In the\\nexample, the servic\", \"e listens for an HTTP POST on the /tweet endpoint on port 6000. Because it\\u2019s\\nan HTTP POST operation,\", \" the JSON payload for the event is passed in the request body.\\n4. After handling the event, the serv\", \"ice returns an HTTP status code 200 OK.\\nThe following ASP.NET Core controller provides an example of\", \" handling an event triggered by the\\nTwitter binding:\\n[ApiController]\\npublic class SomeController : C\", \"ontrollerBase\\n{\\npublic class TwitterTweet\\n{\\n[JsonPropertyName(\\\"id_str\\\")]\\npublic string ID {get; set;\", \" }\\n[JsonPropertyName(\\\"text\\\")]\\npublic string Text {get; set; }\\n}\\n[HttpPost(\\\"/tweet\\\")]\\npublic ActionRe\", \"sult Post(TwitterTweet tweet)\\n{\\n// Handle tweet\\nConsole.WriteLine(\\\"Tweet received: {0}: {1}\\\", tweet.\", \"ID, tweet.Text);\\n// ...\\n// Acknowledge message\\nreturn Ok();\\n}\\n}\\nIf the operation should error, you w\", \"ould return the appropriate 400 or 500 level HTTP status code. For\\nbindings that feature at-least-on\", \"ce delivery guarantees, the Dapr sidecar will retry the trigger. Check\\nout Dapr documentation for re\", \"source bindings to see whether they offer at-least-once or exactly-once\\ndelivery guarantees.\\nOutput \", \"bindings\\nDapr also includes output binding capabilities. They enable your service to trigger an even\", \"t that\\ninvokes an external resource. Again, you start by configuring a binding configuration YAML fi\", \"le that\\ndescribes the output binding. Once in place, you trigger an event that invokes the bindings \", \"API on the\\nDapr sidecar of your application. Figure 8-3 shows the flow of an output binding:\\n74 CHAP\", \"TER 9 | The Dapr bindings building blockFigure 8-3. Dapr output binding flow.\\n1. The Dapr sidecar re\", \"ads the binding configuration file with the information on how to connect to\\nthe external resource. \", \"In the example, the external resource is a Twilio SMS account.\\n2. Your application invokes the /v1.0\", \"/bindings/sms endpoint on the Dapr sidecar. In this case, it\\nuses an HTTP POST to invoke the API. It\", \"\\u2019s also possible to use gRPC.\\n3. The binding component running in the Dapr sidecar calls the externa\", \"l messaging system to send\\nthe message. The message will contain the payload passed in the POST requ\", \"est.\\nAs an example, you can invoke an output binding by invoking the Dapr API using curl:\\ncurl -X PO\", \"ST http://localhost:3500/v1.0/bindings/sms \\\\\\n-H \\\"Content-Type: application/json\\\" \\\\\\n-d '{\\n\\\"data\\\": \\\"We\", \"lcome to this awesome service\\\",\\n\\\"metadata\\\": {\\n\\\"toNumber\\\": \\\"555-3277\\\"\\n},\\n\\\"operation\\\": \\\"create\\\"\\n}'\\nNot\", \"e that the HTTP port is the same as used by the Dapr sidecar (in this case, the default Dapr HTTP\\npo\", \"rt 3500).\\nThe structure of the payload (that is, message sent) will vary per binding. In the example\", \" above, the\\npayload contains a data element with a message. Bindings to other types of external reso\", \"urces can be\\ndifferent, especially for the metadata that is sent. Each payload must also contain an \", \"operation field,\\n75 CHAPTER 9 | The Dapr bindings building blockthat defines the operation the bindi\", \"ng will execute. The above example specifies a create operation\\nthat creates the SMS message. Common\", \" operations include:\\n\\u2022 create\\n\\u2022 get\\n\\u2022 delete\\n\\u2022 list\\nIt\\u2019s up to the author of the binding which opera\", \"tions the binding supports. The documentation for\\neach binding describes the available operations an\", \"d how to invoke them.\\nUse the Dapr .NET SDK\\nThe Dapr .NET SDK provides language-specific support for\", \" .NET developers. In the following example,\\nthe call to the HttpClient.PostAsync() is replaced with \", \"the DaprClient.InvokeBindingAsync()\\nmethod. This specialized method simplifies invoking a configured\", \" output binding:\\nprivate async Task SendSMSAsync([FromServices] DaprClient daprClient)\\n{\\nvar message\", \" = \\\"Welcome to this awesome service\\\";\\nvar metadata = new Dictionary<string, string>\\n{\\n{ \\\"toNumber\\\", \", \"\\\"555-3277\\\" }\\n};\\nawait daprClient.InvokeBindingAsync(\\\"sms\\\", \\\"create\\\", message, metadata);\\n}\\nThe metho\", \"d expects the metadata and message values.\\nWhen used to invoke a binding, the DaprClient uses gRPC t\", \"o call the Dapr API on the Dapr sidecar.\\nBinding components\\nUnder the hood, resource bindings are im\", \"plemented with Dapr binding components. They\\u2019re\\ncontributed by the community and written in Go. If y\", \"ou need to integrate with an external resource\\nfor which no Dapr binding exists yet, you can create \", \"it yourself. Check out the Dapr components-\\ncontrib repo to see how you can contribute a binding.\\nNo\", \"te\\nDapr and all of its components are written in the Golang (Go) language. Go is considered a modern\", \",\\ncloud-native programming platform.\\nYou configure bindings using a YAML configuration file. Here\\u2019s \", \"an example configuration for the\\nTwitter binding:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetad\", \"ata:\\nname: twitter-mention\\n76 CHAPTER 9 | The Dapr bindings building blocknamespace: default\\nspec:\\nt\", \"ype: bindings.twitter\\nversion: v1\\nmetadata:\\n- name: consumerKey\\nvalue: \\\"****\\\" # twitter api consumer\", \" key, required\\n- name: consumerSecret\\nvalue: \\\"****\\\" # twitter api consumer secret, required\\n- name: \", \"accessToken\\nvalue: \\\"****\\\" # twitter api access token, required\\n- name: accessSecret\\nvalue: \\\"****\\\" # \", \"twitter api access secret, required\\n- name: query\\nvalue: \\\"dapr\\\" # your search query, required\\nEach b\", \"inding configuration contains a general metadata element with a name and namespace field.\\nDapr will \", \"determine the endpoint to invoke your service based upon the configured name field. In the\\nabove exa\", \"mple, Dapr will invoke the method annotated with /twitter-mention in your service when\\nan event occu\", \"rs.\\nIn the spec element, you specify the type of the binding along with binding specific metadata. T\", \"he\\nexample specifies credentials for accessing a Twitter account using its API. The metadata can dif\", \"fer\\nbetween input and output bindings. For example, to use Twitter as an input binding, you need to\\n\", \"specify the text to search for in tweets using the query field. Every time a matching tweet is sent,\", \" the\\nDapr sidecar will invoke the /twitter-mention endpoint on the service. It will also deliver the\", \"\\ncontents of the tweet.\\nA binding can be configured for input, output, or both. Interestingly, the b\", \"inding doesn\\u2019t explicitly\\nspecify input or output configuration. Instead, the direction is inferred \", \"by the usage of the binding\\nalong with configuration values.\\nThe Dapr documentation for resource bin\", \"dings provides a complete list of the available bindings and\\ntheir specific configuration settings.\\n\", \"Cron binding\\nPay close attention to Dapr\\u2019s Cron binding. It doesn\\u2019t subscribe to events from an exte\", \"rnal system.\\nInstead, this binding uses a configurable interval schedule to trigger your application\", \". The binding\\nprovides a simple way to implement a background worker to wake up and do some work at \", \"a regular\\ninterval, without the need to implement an endless loop with a configurable delay. Here\\u2019s \", \"an example\\nof a Cron binding configuration:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nn\", \"ame: checkOrderBacklog\\nnamespace: default\\nspec:\\ntype: bindings.cron\\nversion: v1\\nmetadata:\\n- name: sc\", \"hedule\\nvalue: \\\"@every 30m\\\"\\n77 CHAPTER 9 | The Dapr bindings building blockIn this example, Dapr trig\", \"gers a service by invoking the /checkOrderBacklog endpoint every 30\\nminutes. There are several patte\", \"rns available for specifying the schedule value. For more information,\\nsee the Cron binding document\", \"ation.\\nSample application: Dapr Traffic Control\\nIn the Dapr Traffic Control sample application, the \", \"TrafficControl service uses the MQTT input binding\\nto retrieve messages from the CameraSimulation. F\", \"igure 8-4 shows the conceptual architecture of the\\nDapr Traffic Control sample application. The Dapr\", \" input binding is used in flows marked with number\\n5 in the diagram:\\nFigure 8-4. Conceptual architec\", \"ture of the Dapr Traffic Control sample application.\\n78 CHAPTER 9 | The Dapr bindings building block\", \"MQTT input binding\\nMQTT is a lightweight pub/sub messaging protocol, often used in IoT scenarios. Pr\", \"oducers sent MQTT\\nmessages to a topic; subscribers then retrieve messages from the topic. There are \", \"several MQTT\\nmessage broker products available. The Traffic Control sample application uses Eclipse \", \"Mosquitto.\\nThe CameraSimulation doesn\\u2019t depend on any Dapr building blocks. It uses the System.Net.M\", \"qtt\\nlibrary to send MQTT messages:\\n// ...\\n// simulate entry\\nDateTime entryTimestamp = DateTime.Now;\\n\", \"var vehicleRegistered = new VehicleRegistered\\n{\\nLane = _camNumber,\\nLicenseNumber = GenerateRandomLic\", \"enseNumber(),\\nTimestamp = entryTimestamp\\n};\\n_trafficControlService.SendVehicleEntry(vehicleRegistere\", \"d);\\n// ...\\nThe code uses a proxy of type ITrafficControlService to call the TrafficControl service. \", \".NET injects\\nan implementation of the ITrafficControlService interface using constructor injection:\\n\", \":::{custom-style=CodeBox} csharp public CameraSimulation(int camNumber, ITrafficControlService\\ntraff\", \"icControlService) { _camNumber = camNumber; _trafficControlService = trafficControlService;\\n} :::\\nTh\", \"e MqttTrafficControlService class implements the ITrafficControlService interface. It\\nexposes two me\", \"thods: SendVehicleEntryAsync and SendVehicleExitAsync. They both use the\\nMQTT client to send message\", \"s to the trafficcontrol/entrycam and trafficcontrol/exitcam\\ntopics respectively:\\npublic async Task S\", \"endVehicleEntryAsync(VehicleRegistered vehicleRegistered)\\n{\\nvar eventJson = JsonSerializer.Serialize\", \"(vehicleRegistered);\\nvar message = new MqttApplicationMessage(\\\"trafficcontrol/entrycam\\\",\\nEncoding.UT\", \"F8.GetBytes(eventJson));\\nawait _client.PublishAsync(message, MqttQualityOfService.AtMostOnce);\\n}\\npub\", \"lic async Task SendVehicleExitAsync(VehicleRegistered vehicleRegistered)\\n{\\nvar eventJson = JsonSeria\", \"lizer.Serialize(vehicleRegistered);\\nvar message = new MqttApplicationMessage(\\\"trafficcontrol/exitcam\", \"\\\",\\nEncoding.UTF8.GetBytes(eventJson));\\nawait _client.PublishAsync(message, MqttQualityOfService.AtMo\", \"stOnce);\\n}\\nThe constructor sets up the MQTT client to send messages to the MQTT broker (Mosquitto) r\", \"unning\\non port 1883.\\nOn the other end, the TrafficControl service uses the MQTT input binding to rec\", \"eive\\nVehicleRegistered messages sent by the CameraSimulation. For each subscribed topic, there\\u2019s a\\n7\", \"9 CHAPTER 9 | The Dapr bindings building blockseparate component configuration file in the /dapr/com\", \"ponents folder. The first one is\\nentrycam.yaml:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadat\", \"a:\\nname: entrycam\\nnamespace: dapr-trafficcontrol\\nspec:\\ntype: bindings.mqtt\\nversion: v1\\nmetadata:\\n- n\", \"ame: url\\nvalue: mqtt://localhost:1883\\n- name: topic\\nvalue: trafficcontrol/entrycam\\nscopes:\\n- traffic\", \"controlservice\\nThe configuration specifies the binding type: bindings.mqtt. It also specifies that t\", \"he broker runs on\\nlocalhost:1883, the standard port that Mosquitto uses. It also exposes the topic,\\n\", \"trafficcontrol/entrycam. Using scopes, the config file specifies that only the service with app-id\\nt\", \"rafficcontrolservice will have access to the binding.\\nWhen the TrafficControl service starts, the Da\", \"pr sidecar automatically subscribes to the\\ntrafficcontrol/entrycam MQTT topic specified in the compo\", \"nent configuration. When messages\\narrive on the topic, the Dapr sidecar invokes an HTTP endpoint on \", \"your service. The sidecar\\ndetermines the URL of the HTTP endpoint to call by looking at the metadata\", \".name field in the binding\\nconfiguration. In the example above, the endpoint URL is /entrycam. Withi\", \"n the TrafficControl service,\\nno code needs to be added to support the endpoint:\\n[HttpPost(\\\"entrycam\", \"\\\")]\\npublic async Task<ActionResult> VehicleEntry(VehicleRegistered msg)\\n{\\n// ...\\n}\\nThe exitcam.yaml \", \"component configuration file configures everything for the exitcam endpoint:\\napiVersion: dapr.io/v1a\", \"lpha1\\nkind: Component\\nmetadata:\\nname: exitcam\\nnamespace: dapr-trafficcontrol\\nspec:\\ntype: bindings.mq\", \"tt\\nversion: v1\\nmetadata:\\n- name: url\\nvalue: mqtt://localhost:1883\\n- name: topic\\nvalue: trafficcontro\", \"l/exitcam\\nscopes:\\n- trafficcontrolservice\\n80 CHAPTER 9 | The Dapr bindings building blockSMTP output\", \" binding\\nThe FineCollection service uses the Dapr SMTP output binding to send emails. Figure 8-5 sho\", \"ws the\\nconceptual architecture of the Dapr Traffic Control sample application. The Dapr input bindin\", \"g is used\\nin flows marked with number 4 in the diagram:\\nFigure 8-5. Conceptual architecture of the D\", \"apr Traffic Control sample application.\\nThe CollectFine method on the CollectionController in the Fi\", \"neCollection service contains code that\\nuses the Dapr client to invoke the output binding:\\n// ...\\n//\", \" send fine by email (Dapr output binding)\\nvar body = EmailUtils.CreateEmailBody(speedingViolation, v\", \"ehicleInfo, fineString);\\nvar metadata = new Dictionary<string, string>\\n{\\n[\\\"emailFrom\\\"] = \\\"noreply@cf\", \"ca.gov\\\",\\n[\\\"emailTo\\\"] = vehicleInfo.OwnerEmail,\\n81 CHAPTER 9 | The Dapr bindings building block[\\\"subj\", \"ect\\\"] = $\\\"Speeding violation on the {speedingViolation.RoadId}\\\"\\n};\\nawait daprClient.InvokeBindingAsy\", \"nc(\\\"sendmail\\\", \\\"create\\\", body, metadata);\\n// ...\\nThe code uses a simple utility class to create an H\", \"TML email body containing the necessary\\ninformation. It also creates a dictionary with metadata spec\", \"ific to the SMTP binding. This binding\\ncomponent interprets the metadata when invoked.\\nThe following\", \" arguments are required to invoke the binding:\\n\\u2022 The name of the binding component. In this case sen\", \"dmail.\\n\\u2022 The operation the binding needs to perform. In this case create.\\n\\u2022 The body of the message \", \"to send. In this case, the HTML email body.\\n\\u2022 The metadata for sending the email.\\nThe Dapr output bi\", \"nding named sendmail is configured in the email.yaml component configuration\\nfile in the /dapr/compo\", \"nents folder:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: sendmail\\nnamespace: dapr-\", \"trafficcontrol\\nspec:\\ntype: bindings.smtp\\nversion: v1\\nmetadata:\\n- name: host\\nvalue: localhost\\n- name:\", \" port\\nvalue: 4025\\n- name: user\\nsecretKeyRef:\\nname: smtp.user\\nkey: smtp.user\\n- name: password\\nsecretK\", \"eyRef:\\nname: smtp.password\\nkey: smtp.password\\n- name: skipTLSVerify\\nvalue: true\\nauth:\\nsecretStore: t\", \"rafficcontrol-secrets\\nscopes:\\n- finecollectionservice\\nThe configuration specifies the binding type: \", \"bindings.smtp.\\nThe metadata section contains the information for connecting to the SMTP server. See \", \"the binding\\u2019s\\ndocumentation for specific metadata required for this binding. The username and passwo\", \"rd to\\nconnect to the SMTP server are retrieved from a secrets store. See the Secrets management buil\", \"ding\\nblock chapter for more information on how this works.\\nThe scopes element specifies that only th\", \"e service with app-id finecollectonservice can access this\\nbinding.\\n82 CHAPTER 9 | The Dapr bindings\", \" building blockThe Traffic Control sample application uses MailDev. MailDev is a development SMTP se\", \"rver that\\ndoesn\\u2019t actually send out emails (by default). Instead, it collects emails and presents th\", \"em in an inbox\\nweb application. MailDev is extremely useful for dev/test and demo scenarios.\\nUsing D\", \"apr bindings in the Traffic Control sample application provides the following benefits:\\n1. Using MQT\", \"T messaging and SMTP without the need to learn this protocol or a specific MQTT\\nAPI.\\n2. Using SMTP t\", \"o send an email without the need to learn this protocol or a specific SMTP API.\\nSummary\\nDapr resourc\", \"e bindings enable you to integrate with different external resources and systems without\\ntaking depe\", \"ndencies on their libraries or SDKs. These external systems don\\u2019t necessarily have to be\\nmessaging s\", \"ystems like a service bus or message broker. Bindings also exist for datastores and web\\nresources li\", \"ke Twitter or SendGrid.\\nInput bindings (or triggers) react to events occurring in an external system\", \". They invoke the public\\nHTTP endpoints pre-configured in your application. Dapr uses the name of th\", \"e binding in the\\nconfiguration to determine the endpoint to call in your application.\\nOutput binding\", \"s will send messages to an external system. You trigger an output binding by doing an\\nHTTP POST on t\", \"he /v1.0/bindings/<binding-name> endpoint on the Dapr sidecar. You can also use\\ngRPC to invoke the b\", \"inding. The .NET SDK offers a InvokeBindingAsync method to invoke Dapr\\nbindings using gRPC.\\nYou impl\", \"ement a binding with a Dapr component. These components are contributed by the\\ncommunity. Each bindi\", \"ng component\\u2019s configuration has metadata that is specific for the external\\nsystem it abstracts. Als\", \"o, the commands it supports and the structure of the payload will differ per\\nbinding component.\\nRefe\", \"rences\\n\\u2022 Dapr documentation for resource bindings\\n\\u2022 Mosquitto MQTT broker\\n\\u2022 MailDev development SMTP\", \" server\\n83 CHAPTER 9 | The Dapr bindings building block10\\nCHAPTER\\nThe Dapr actors building\\nblock\\nThe\", \" actor model originated in 1973. It was proposed by Carl Hewitt as a conceptual model of\\nconcurrent \", \"computation, a form of computing in which several computations are executed at the\\nsame time. Highly\", \" parallel computers weren\\u2019t yet available at that time, but the more recent\\nadvancements of multi-co\", \"re CPUs and distributed systems have made the actor model popular.\\nIn the actor model, the actor is \", \"an independent unit of compute and state. Actors are completely\\nisolated from each other and they wi\", \"ll never share memory. Actors communicate with each other\\nusing messages. When an actor receives a m\", \"essage, it can change its internal state, and send\\nmessages to other (possibly new) actors.\\nThe reas\", \"on why the actor model makes writing concurrent systems easier is that it provides a turn-\\nbased (or\", \" single-threaded) access model. Multiple actors can run at the same time, but each actor will\\nproces\", \"s received messages one at a time. This means that you can be sure that at most one thread is\\nactive\", \" inside an actor at any time. That makes writing correct concurrent and parallel systems much\\neasier\", \".\\nWhat it solves\\nActor model implementations are usually tied to a specific language or platform. Wi\", \"th the Dapr actors\\nbuilding block however, you can leverage the actor model from any language or pla\", \"tform.\\nDapr\\u2019s implementation is based on the virtual actor pattern introduced by Project \\u201cOrleans\\u201d. \", \"With the\\nvirtual actor pattern, you don\\u2019t need to explicitly create actors. Actors are activated imp\", \"licitly and\\nplaced on a node in the cluster the first time a message is sent to the actor. When not \", \"executing\\noperations, actors are silently unloaded from memory. If a node fails, Dapr automatically \", \"moves\\nactivated actors to healthy nodes. Besides sending messages between actors, the Dapr actor mod\", \"el\\nalso support scheduling future work using timers and reminders.\\nWhile the actor model can provide\", \" great benefits, it\\u2019s important to carefully consider the actor design.\\nFor example, having many cli\", \"ents call the same actor will result in poor performance because the actor\\noperations execute serial\", \"ly. Here are some criteria to check if a scenario is a good fit for Dapr actors:\\n\\u2022 Your problem spac\", \"e involves concurrency. Without actors, you\\u2019d have to introduce explicit\\nlocking mechanisms in your \", \"code.\\n84 CHAPTER 10 | The Dapr actors building block\\u2022 Your problem space can be partitioned into sma\", \"ll, independent, and isolated units of state and\\nlogic.\\n\\u2022 You don\\u2019t need low-latency reads of the ac\", \"tor state. Low-latency reads cannot be guaranteed\\nbecause actor operations execute serially.\\n\\u2022 You d\", \"on\\u2019t need to query state across a set of actors. Querying across actors is inefficient because\\neach \", \"actor\\u2019s state needs to be read individually and can introduce unpredictable latencies.\\nOne design pa\", \"ttern that fits these criteria quite well is the orchestration-based saga or process\\nmanager design \", \"pattern. A saga manages a sequence of steps that must be taken to reach some\\noutcome. The saga (or p\", \"rocess manager) maintains the current state of the sequence and triggers the\\nnext step. If a step fa\", \"ils, the saga can execute compensating actions. Actors make it easy to deal with\\nconcurrency in the \", \"saga and to keep track of the current state. The eShopOnDapr reference\\napplication uses the saga pat\", \"tern and Dapr actors to implement the Ordering process.\\nHow it works\\nThe Dapr sidecar provides the H\", \"TTP/gRPC API to invoke actors. This is the base URL of the HTTP API:\\nhttp://localhost:<daprPort>/v1.\", \"0/actors/<actorType>/<actorId>/\\n\\u2022 <daprPort>: the HTTP port that Dapr listens on.\\n\\u2022 <actorType>: the\", \" actor type.\\n\\u2022 <actorId>: the ID of the specific actor to call.\\nThe sidecar manages how, when and wh\", \"ere each actor runs, and also routes messages between\\nactors. When an actor hasn\\u2019t been used for a p\", \"eriod of time, the runtime deactivates the actor and\\nremoves it from memory. Any state managed by th\", \"e actor is persisted and will be available when the\\nactor re-activates. Dapr uses an idle timer to d\", \"etermine when an actor can be deactivated. When an\\noperation is called on the actor (either by a met\", \"hod call or a reminder firing), the idle timer is reset\\nand the actor instance will remain activated\", \".\\nThe sidecar API is only one part of the equation. The service itself also needs to implement an AP\", \"I\\nspecification, because the actual code that you write for the actor will run inside the service it\", \"self.\\nFigure 11-1 shows the various API calls between the service and its sidecar:\\n85 CHAPTER 10 | T\", \"he Dapr actors building blockFigure 11-1. API calls between actor service and Dapr sidecar.\\nTo provi\", \"de scalability and reliability, actors are partitioned across all the instances of the actor service\", \".\\nThe Dapr placement service is responsible for keeping track of the partitioning information. When \", \"a\\nnew instance of an actor service is started, the sidecar registers the supported actor types with \", \"the\\nplacement service. The placement service calculates the updated partitioning information for the\", \"\\ngiven actor type and broadcasts it to all instances. Figure 11-2 shows what happens when a service \", \"is\\nscaled out to a second replica:\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/actors/placement.png\\u201d alt\", \"-text=\\u201cDiagram of the actor\\nplacement service.\\u201d:::\\nFigure 11-2. Actor placement service.\\n1. On start\", \"up, the sidecar makes a call to the actor service to get the registered actor types as well\\nas actor\", \" configuration settings.\\n2. The sidecar sends the list of registered actor types to the placement se\", \"rvice.\\n3. The placement service broadcasts the updated partitioning information to all actor service\", \"\\ninstances. Each instance will keep a cached copy of the partitioning information and use it to\\ninvo\", \"ke actors.\\nImportant\\nBecause actors are randomly distributed across service instances, it should be \", \"expected that an actor\\noperation always requires a call to a different node in the network.\\n86 CHAPT\", \"ER 10 | The Dapr actors building blockThe next figure shows an ordering service instance running in \", \"Pod 1 call the ship method of an\\nOrderActor instance with ID 3. Because the actor with ID 3 is place\", \"d in a different instance, this results\\nin a call to a different node in the cluster:\\nFigure 11-3. C\", \"alling an actor method.\\n1. The service calls the actor API on the sidecar. The JSON payload in the r\", \"equest body contains the\\ndata to send to the actor.\\n2. The sidecar uses the locally cached partition\", \"ing information from the placement service to\\ndetermine which actor service instance (partition) is \", \"responsible for hosting the actor with ID 3.\\nIn this example, it\\u2019s the service instance in pod 2. Th\", \"e call is forwarded to the appropriate\\nsidecar.\\n3. The sidecar instance in pod 2 calls the service i\", \"nstance to invoke the actor. The service instance\\nactivates the actor (if it hasn\\u2019t already) and exe\", \"cutes the actor method.\\n87 CHAPTER 10 | The Dapr actors building blockTurn-based access model\\nThe tu\", \"rn-based access model ensures that at any time there\\u2019s at most one thread active inside an\\nactor ins\", \"tance. To understand why this is useful, consider the following example of a method that\\nincrements \", \"a counter value:\\npublic int Increment()\\n{\\nvar currentValue = GetValue();\\nvar newValue = currentValue\", \" + 1;\\nSaveValue(newValue);\\nreturn newValue;\\n}\\nLet\\u2019s assume that the current value returned by the Ge\", \"tValue method is 1. When two threads call the\\nIncrement method at the same time, there\\u2019s a risk of b\", \"oth of them calling the GetValue method\\nbefore one of them calls SaveValue. This results in both thr\", \"eads starting with the same initial value (1).\\nThe threads then increment the value to 2 and return \", \"it to the caller. The resulting value after the two\\ncalls is now 2 instead of 3 which it should be. \", \"This is a simple example to illustrate the kind of issues\\nthat can slip into your code when working \", \"with multiple threads, and is easy to solve. In real world\\napplications however, concurrent and para\", \"llel scenarios can become very complex.\\nIn traditional programming models, you can solve this proble\", \"m by introducing locking mechanisms.\\nFor example:\\npublic int Increment()\\n{\\nint newValue;\\nlock (_lock\", \"Object)\\n{\\nvar currentValue = GetValue();\\nnewValue = currentValue + 1;\\nSaveValue(newValue);\\n}\\nreturn \", \"newValue;\\n}\\nUnfortunately, using explicit locking mechanisms is error-prone. They can easily lead to\", \" deadlocks and\\ncan have serious impact on performance.\\nThanks to the turn-based access model, you do\", \"n\\u2019t need to worry about multiple threads with actors,\\nmaking it much easier to write concurrent syst\", \"ems. The following actor example closely mirrors the\\ncode from the previous sample, but doesn\\u2019t requ\", \"ire any locking mechanisms to be correct:\\npublic async Task<int> IncrementAsync()\\n{\\nvar counterValue\", \" = await StateManager.TryGetStateAsync<int>(\\\"counter\\\");\\nvar currentValue = counterValue.HasValue ? c\", \"ounterValue.Value : 0;\\nvar newValue = currentValue + 1;\\n88 CHAPTER 10 | The Dapr actors building blo\", \"ckawait StateManager.SetStateAsync(\\\"counter\\\", newValue);\\nreturn newValue;\\n}\\nTimers and reminders\\nAct\", \"ors can use timers and reminders to schedule calls to themselves. Both concepts support the\\nconfigur\", \"ation of a due time. The difference lies in the lifetime of the callback registrations:\\n\\u2022 Timers wil\", \"l only stay active as long as the actor is activated. Timers will not reset the idle-timer,\\nso they \", \"cannot keep an actor active on their own.\\n\\u2022 Reminders outlive actor activations. If an actor is deac\", \"tivated, a reminder will re-activate the\\nactor. Reminders will reset the idle-timer.\\nTimers are regi\", \"stered by making a call to the actor API. In the following example, a timer is registered\\nwith a due\", \" time of 0 and a period of 10 seconds.\\ncurl -X POST http://localhost:3500/v1.0/actors/<actorType>/<a\", \"ctorId>/timers/<name> \\\\\\n-H \\\"Content-Type: application/json\\\" \\\\\\n-d '{\\n\\\"dueTime\\\": \\\"0h0m0s0ms\\\",\\n\\\"period\\\"\", \": \\\"0h0m10s0ms\\\"\\n}'\\nBecause the due time is 0, the timer will fire immediately. After a timer callback\", \" has finished, the timer\\nwill wait 10 seconds before firing again.\\nReminders are registered in a sim\", \"ilar way. The following example shows a reminder registration with a\\ndue time of 5 minutes, and an e\", \"mpty period:\\ncurl -X POST http://localhost:3500/v1.0/actors/<actorType>/<actorId>/reminders/<name> \\\\\", \"\\n-H \\\"Content-Type: application/json\\\" \\\\\\n-d '{\\n\\\"dueTime\\\": \\\"0h5m0s0ms\\\",\\n\\\"period\\\": \\\"\\\"\\n}'\\nThis reminder w\", \"ill fire in 5 minutes. Because the given period is empty, this will be a one-time\\nreminder.\\nNote\\nTim\", \"ers and reminders both respect the turn-based access model. When a timer or reminder fires, the\\ncall\", \"back will not be executed until any other method invocation or timer/reminder callback has\\nfinished.\", \"\\nState persistence\\nActor state is persisted using the Dapr state management building block. Because \", \"actors can execute\\nmultiple state operations in a single turn, the state store component must suppor\", \"t multi-item\\ntransactions. At the time of writing, the following state stores support multi-item tra\", \"nsactions:\\n89 CHAPTER 10 | The Dapr actors building block\\u2022 Azure Cosmos DB\\n\\u2022 MongoDB\\n\\u2022 MySQL\\n\\u2022 Postg\", \"reSQL\\n\\u2022 Redis\\n\\u2022 RethinkDB\\n\\u2022 SQL Server\\nTo configure a state store component for use with actors, you\", \" need to append the following metadata\\nto the state store configuration:\\n- name: actorStateStore\\nval\", \"ue: \\\"true\\\"\\nHere\\u2019s a complete example for a Redis state store:\\napiVersion: dapr.io/v1alpha1\\nkind: Com\", \"ponent\\nmetadata:\\nname: statestore\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- name: redisHost\\nva\", \"lue: localhost:6379\\n- name: redisPassword\\nvalue: \\\"\\\"\\n- name: actorStateStore\\nvalue: \\\"true\\\"\\nUse the Da\", \"pr .NET SDK\\nYou can create an actor model implementation using only HTTP/gRPC calls. However, it\\u2019s m\", \"uch more\\nconvenient to use the language specific Dapr SDKs. At the time of writing, the .NET, Java a\", \"nd Python\\nSDKs all provide extensive support for working with actors.\\nTo get started with the .NET D\", \"apr actors SDK, you add a package reference to Dapr.Actors to your\\nservice project. The first step o\", \"f creating an actual actor is to define an interface that derives from\\nIActor. Clients use the inter\", \"face to invoke operations on the actor. Here\\u2019s a simple example of an\\nactor interface for keeping sc\", \"ores:\\npublic interface IScoreActor : IActor\\n{\\nTask<int> IncrementScoreAsync();\\nTask<int> GetScoreAsy\", \"nc();\\n}\\n90 CHAPTER 10 | The Dapr actors building blockImportant\\nThe return type of an actor method m\", \"ust be Task or Task<T>. Also, actor methods can have at most\\none argument. Both the return type and \", \"the arguments must be System.Text.Json serializable.\\nNext, implement the actor by deriving a ScoreAc\", \"tor class from Actor. The ScoreActor class must also\\nimplement the IScoreActor interface:\\npublic cla\", \"ss ScoreActor : Actor, IScoreActor\\n{\\npublic ScoreActor(ActorHost host) : base(host)\\n{\\n}\\n// TODO Impl\", \"ement interface methods.\\n}\\nThe constructor in the snippet above takes a host argument of type ActorH\", \"ost. The ActorHost class\\nrepresents the host for an actor type within the actor runtime. You need to\", \" pass this argument to the\\nconstructor of the Actor base class. Actors also support dependency injec\", \"tion. Any additional\\narguments that you add to the actor constructor are resolved using the .NET dep\", \"endency injection\\ncontainer.\\nLet\\u2019s now implement the IncrementScoreAsync method of the interface:\\npu\", \"blic Task<int> IncrementScoreAsync()\\n{\\nreturn StateManager.AddOrUpdateStateAsync(\\n\\\"score\\\",\\n1,\\n(key, \", \"currentScore) => currentScore + 1\\n);\\n}\\nIn the snippet above, a single call to StateManager.AddOrUpda\", \"teStateAsync provides the full\\nimplementation for the IncrementScoreAsync method. The AddOrUpdateSta\", \"teAsync method takes\\nthree arguments:\\n1. The key of the state to update.\\n2. The value to write if no\", \" score is stored in the state store yet.\\n3. A Func to call if there already is a score stored in the\", \" state store. It takes the state key and\\ncurrent score, and returns the updated score to write back \", \"to the state store.\\nThe GetScoreAsync implementation reads the current score from the state store an\", \"d returns it to the\\nclient:\\npublic async Task<int> GetScoreAsync()\\n{\\nvar scoreValue = await StateMan\", \"ager.TryGetStateAsync<int>(\\\"score\\\");\\nif (scoreValue.HasValue)\\n{\\nreturn scoreValue.Value;\\n}\\n91 CHAPTE\", \"R 10 | The Dapr actors building blockreturn 0;\\n}\\nTo host actors in an ASP.NET Core service, you must\", \" add a reference to the Dapr.Actors.AspNetCore\\npackage and make some changes in the Program file. In\", \" the following example, the call to\\nMapActorsHandlers registers Dapr Actor endpoints in ASP.NET Core\", \" routing:\\nvar builder = WebApplication.CreateBuilder(args);\\nvar app = builder.Build();\\n// Actors bui\", \"lding block does not support HTTPS redirection.\\n//app.UseHttpsRedirection();\\napp.MapControllers();\\n/\", \"/ Add actor endpoints.\\napp.MapActorsHandlers();\\nThe actors endpoints are necessary because the Dapr \", \"sidecar calls the application to host and interact\\nwith actor instances.\\nImportant\\nMake sure your Pr\", \"ogram (or Startup) class does not contain an app.UseHttpsRedirection call to\\nredirect clients to the\", \" HTTPS endpoint. This will not work with actors. By design, a Dapr sidecar sends\\nrequests over unenc\", \"rypted HTTP by default. The HTTPS middleware will block these requests when\\nenabled.\\nThe Program fil\", \"e is also the place to register the specific actor types. The following example registers\\nthe ScoreA\", \"ctor using the AddActors extension method:\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder\", \".Services.AddActors(options =>\\n{\\noptions.Actors.RegisterActor<ScoreActor>();\\n});\\nAt this point, the \", \"ASP.NET Core service is ready to host the ScoreActor and accept incoming requests.\\nClient applicatio\", \"ns use actor proxies to invoke operations on actors. The following example shows\\nhow a console clien\", \"t application invokes the IncrementScoreAsync operation on a ScoreActor\\ninstance:\\nvar actorId = new \", \"ActorId(\\\"scoreActor1\\\");\\nvar proxy = ActorProxy.Create<IScoreActor>(actorId, \\\"ScoreActor\\\");\\nvar score\", \" = await proxy.IncrementScoreAsync();\\nConsole.WriteLine($\\\"Current score: {score}\\\");\\nThe above exampl\", \"e uses the Dapr.Actors package to call the actor service. To invoke an operation on\\nan actor, you ne\", \"ed to be able to address it. You\\u2019ll need two parts for this:\\n1. The actor type uniquely identifies t\", \"he actor implementation across the whole application. By\\ndefault, the actor type is the name of the \", \"implementation class (without namespace). You can\\ncustomize the actor type by adding an ActorAttribu\", \"te to the implementation class and setting\\nits TypeName property.\\n92 CHAPTER 10 | The Dapr actors bu\", \"ilding block2. The ActorId uniquely identifies an instance of an actor type. You can also use this c\", \"lass to\\ngenerate a random actor id by calling ActorId.CreateRandom.\\nThe example uses ActorProxy.Crea\", \"te to create a proxy instance for the ScoreActor. The Create\\nmethod takes two arguments: the ActorId\", \" identifying the specific actor and the actor type. It also has\\na generic type parameter to specify \", \"the actor interface that the actor type implements. As both the\\nserver and client applications need \", \"to use the actor interfaces, they\\u2019re typically stored in a separate\\nshared project.\\nThe final step i\", \"n the example calls the IncrementScoreAsync method on the actor and outputs the\\nresult. Remember tha\", \"t the Dapr placement service distributes the actor instances across the Dapr\\nsidecars. Therefore, ex\", \"pect an actor call to be a network call to another node.\\nCall actors from ASP.NET Core clients\\nThe c\", \"onsole client example in the previous section uses the static ActorProxy.Create method directly\\nto g\", \"et an actor proxy instance. If the client application is an ASP.NET Core application, you should use\", \"\\nthe IActorProxyFactory interface to create actor proxies. The main benefit is that it allows you to\", \"\\nmanage configuration in one place. The AddActors extension method on IServiceCollection takes\\na del\", \"egate that allows you to specify actor runtime options, such as the HTTP endpoint of the Dapr\\nsideca\", \"r. The following example specifies custom JsonSerializerOptions to use for actor state\\npersistence a\", \"nd message deserialization:\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder.Services.AddAc\", \"tors(options =>\\n{\\nvar jsonSerializerOptions = new JsonSerializerOptions()\\n{\\nPropertyNamingPolicy = J\", \"sonNamingPolicy.CamelCase,\\nPropertyNameCaseInsensitive = true\\n};\\noptions.JsonSerializerOptions = jso\", \"nSerializerOptions;\\noptions.Actors.RegisterActor<ScoreActor>();\\n});\\nThe call to AddActors registers \", \"the IActorProxyFactory for .NET dependency injection. This allows\\nASP.NET Core to inject an IActorPr\", \"oxyFactory instance into your controller classes. The following\\nexample calls an actor method from a\", \"n ASP.NET Core controller class:\\n[ApiController]\\n[Route(\\\"[controller]\\\")]\\npublic class ScoreControlle\", \"r : ControllerBase\\n{\\nprivate readonly IActorProxyFactory _actorProxyFactory;\\npublic ScoreController(\", \"IActorProxyFactory actorProxyFactory)\\n{\\n_actorProxyFactory = actorProxyFactory;\\n}\\n[HttpPut(\\\"{scoreId\", \"}\\\")]\\npublic Task<int> IncrementAsync(string scoreId)\\n{\\n93 CHAPTER 10 | The Dapr actors building bloc\", \"kvar scoreActor = _actorProxyFactory.CreateActorProxy<IScoreActor>(\\nnew ActorId(scoreId),\\n\\\"ScoreActo\", \"r\\\");\\nreturn scoreActor.IncrementScoreAsync();\\n}\\n}\\nActors can also call other actors directly. The Ac\", \"tor base class exposes an IActorProxyFactory class\\nthrough the ProxyFactory property. To create an a\", \"ctor proxy from within an actor, use the\\nProxyFactory property of the Actor base class. The followin\", \"g example shows an OrderActor that\\ninvokes operations on two other actors:\\npublic class OrderActor :\", \" Actor, IOrderActor\\n{\\npublic OrderActor(ActorHost host) : base(host)\\n{\\n}\\npublic async Task ProcessOr\", \"derAsync(Order order)\\n{\\nvar stockActor = ProxyFactory.CreateActorProxy<IStockActor>(\\nnew ActorId(ord\", \"er.OrderNumber),\\n\\\"StockActor\\\");\\nawait stockActor.ReserveStockAsync(order.OrderLines);\\nvar paymentAct\", \"or = ProxyFactory.CreateActorProxy<IPaymentActor>(\\nnew ActorId(order.OrderNumber),\\n\\\"PaymentActor\\\");\\n\", \"await paymentActor.ProcessPaymentAsync(order.PaymentDetails);\\n}\\n}\\nNote\\nBy default, Dapr actors aren\\u2019\", \"t reentrant. This means that a Dapr actor cannot be called more than once\\nin the same chain. For exa\", \"mple, the call chain Actor A -> Actor B -> Actor A is not allowed. At the\\ntime of writing, there\\u2019s a\", \" preview feature available to support reentrancy. However, there is no SDK\\nsupport yet. For more det\", \"ails, see the official documentation.\\nCall non-.NET actors\\nSo far, the examples used strongly-typed \", \"actor proxies based on .NET interfaces to illustrate actor\\ninvocations. This works great when both t\", \"he actor host and client are .NET applications. However, if\\nthe actor host is not a .NET application\", \", you don\\u2019t have an actor interface to create a strongly-typed\\nproxy. In these cases, you can use a \", \"weakly-typed proxy.\\nYou create weakly-typed proxies in a similar way to strongly-typed proxies. Inst\", \"ead of relying on a\\n.NET interface, you need to pass in the actor method name as a string.\\n[HttpPut(\", \"\\\"{scoreId}\\\")]\\npublic Task<int> IncrementAsync(string scoreId)\\n94 CHAPTER 10 | The Dapr actors buildi\", \"ng block{\\nvar scoreActor = _actorProxyFactory.CreateActorProxy(\\nnew ActorId(scoreId),\\n\\\"ScoreActor\\\");\", \"\\nreturn scoreActor(\\\"IncrementScoreAsync\\\");\\n}\\nTimers and reminders\\nUse the RegisterTimerAsync method \", \"of the Actor base class to schedule actor timers. In the\\nfollowing example, a TimerActor exposes a S\", \"tartTimerAsync method. Clients can call the method to\\nstart a timer that repeatedly writes a given t\", \"ext to the log output.\\npublic class TimerActor : Actor, ITimerActor\\n{\\npublic TimerActor(ActorHost ho\", \"st) : base(host)\\n{\\n}\\npublic Task StartTimerAsync(string name, string text)\\n{\\nreturn RegisterTimerAsy\", \"nc(\\nname,\\nnameof(TimerCallback),\\nEncoding.UTF8.GetBytes(text),\\nTimeSpan.Zero,\\nTimeSpan.FromSeconds(3\", \"));\\n}\\npublic Task TimerCallbackAsync(byte[] state)\\n{\\nvar text = Encoding.UTF8.GetString(state);\\nLogg\", \"er.LogInformation($\\\"Timer fired: {text}\\\");\\nreturn Task.CompletedTask;\\n}\\n}\\nThe StartTimerAsync method\", \" calls RegisterTimerAsync to schedule the timer. RegisterTimerAsync\\ntakes five arguments:\\n1. The nam\", \"e of the timer.\\n2. The name of the method to call when the timer fires.\\n3. The state to pass to the \", \"callback method.\\n4. The amount of time to wait before the callback method is first invoked.\\n5. The t\", \"ime interval between callback method invocations. You can specify\\nTimeSpan.FromMilliseconds(-1) to d\", \"isable periodic signaling.\\nThe TimerCallbackAsync method receives the user state in binary form. In \", \"the example, the callback\\ndecodes the state back to a string before writing it to the log.\\nTimers ca\", \"n be stopped by calling UnregisterTimerAsync:\\n95 CHAPTER 10 | The Dapr actors building blockpublic c\", \"lass TimerActor : Actor, ITimerActor\\n{\\n// ...\\npublic Task StopTimerAsync(string name)\\n{\\nreturn Unreg\", \"isterTimerAsync(name);\\n}\\n}\\nRemember that timers do not reset the actor idle timer. When no other cal\", \"ls are made on the actor, it\\nmay be deactivated and the timer will be stopped automatically. To sche\", \"dule work that does reset the\\nidle timer, use reminders which we\\u2019ll look at next.\\nTo use reminders i\", \"n an actor, your actor class must implement the IRemindable interface:\\npublic interface IRemindable\\n\", \"{\\nTask ReceiveReminderAsync(\\nstring reminderName, byte[] state,\\nTimeSpan dueTime, TimeSpan period);\\n\", \"}\\nThe ReceiveReminderAsync method is called when a reminder is fired. It takes 4 arguments:\\n1. The n\", \"ame of the reminder.\\n2. The user state provided during registration.\\n3. The invocation due time prov\", \"ided during registration.\\n4. The invocation period provided during registration.\\nTo register a remin\", \"der, use the RegisterReminderAsync method of the actor base class. The following\\nexample sets a remi\", \"nder to fire a single time with a due time of three minutes.\\npublic class ReminderActor : Actor, IRe\", \"minderActor, IRemindable\\n{\\npublic ReminderActor(ActorHost host) : base(host)\\n{\\n}\\npublic Task SetRemi\", \"nderAsync(string text)\\n{\\nreturn RegisterReminderAsync(\\n\\\"DoNotForget\\\",\\nEncoding.UTF8.GetBytes(text),\\n\", \"TimeSpan.FromSeconds(3),\\nTimeSpan.FromMilliseconds(-1));\\n}\\npublic Task ReceiveReminderAsync(\\nstring \", \"reminderName, byte[] state,\\nTimeSpan dueTime, TimeSpan period)\\n{\\nif (reminderName == \\\"DoNotForget\\\")\\n\", \"{\\nvar text = Encoding.UTF8.GetString(state);\\nLogger.LogInformation($\\\"Don't forget: {text}\\\");\\n96 CHAP\", \"TER 10 | The Dapr actors building block}\\nreturn Task.CompletedTask;\\n}\\n}\\nThe RegisterReminderAsync me\", \"thod is similar to RegisterTimerAsync but you don\\u2019t have to specify\\na callback method explicitly. As\", \" the above example shows, you implement\\nIRemindable.ReceiveReminderAsync to handle fired reminders.\\n\", \"Reminders both reset the idle timer and are persistent. Even if your actor is deactivated, it will b\", \"e\\nreactivated at the moment a reminder fires. To stop a reminder from firing, call\\nUnregisterReminde\", \"rAsync.\\nSample application: Dapr Traffic Control\\nThe default version of Dapr Traffic Control does no\", \"t use the actor model. However, it does contain an\\nalternative actor-based implementation of the Tra\", \"fficControl service that you can enable. To make use\\nof actors in the TrafficControl service, open u\", \"p the\\nsrc/TrafficControlService/Controllers/TrafficController.cs file and uncomment the\\nUSE_ACTORMOD\", \"EL statement at the top of the file:\\n#define USE_ACTORMODEL\\nWhen the actor model is enabled, the app\", \"lication uses actors to represent vehicles. The operations\\nthat can be invoked on the vehicle actors\", \" are defined in an IVehicleActor interface:\\npublic interface IVehicleActor : IActor\\n{\\nTask RegisterE\", \"ntryAsync(VehicleRegistered msg);\\nTask RegisterExitAsync(VehicleRegistered msg);\\n}\\nThe (simulated) e\", \"ntry cameras call the RegisterEntryAsync method when a new vehicle is first\\ndetected in the lane. Th\", \"e only responsibility of this method is storing the entry timestamp in the actor\\nstate:\\nvar vehicleS\", \"tate = new VehicleState\\n{\\nLicenseNumber = msg.LicenseNumber,\\nEntryTimestamp = msg.Timestamp\\n};\\nawait\", \" StateManager.SetStateAsync(\\\"VehicleState\\\", vehicleState);\\nWhen the vehicle reaches the end of the s\", \"peed camera zone, the exit camera calls the\\nRegisterExitAsync method. The RegisterExitAsync method f\", \"irst gets the current states and\\nupdates it to include the exit timestamp:\\nvar vehicleState = await \", \"StateManager.GetStateAsync<VehicleState>(\\\"VehicleState\\\");\\nvehicleState.ExitTimestamp = msg.Timestamp\", \";\\n97 CHAPTER 10 | The Dapr actors building blockNote\\nThe code above currently assumes that a Vehicle\", \"State instance has already been saved by the\\nRegisterEntryAsync method. The code could be improved b\", \"y first checking to make sure the state\\nexists. Thanks to the turn-based access model, no explicit l\", \"ocks are required in the code.\\nAfter the state is updated, the RegisterExitAsync method checks if th\", \"e vehicle was driving too fast. If\\nit was, the actor publishes a message to the collectfine pub/sub \", \"topic:\\nint violation = _speedingViolationCalculator.DetermineSpeedingViolationInKmh(\\nvehicleState.En\", \"tryTimestamp, vehicleState.ExitTimestamp);\\nif (violation > 0)\\n{\\nvar speedingViolation = new Speeding\", \"Violation\\n{\\nVehicleId = msg.LicenseNumber,\\nRoadId = _roadId,\\nViolationInKmh = violation,\\nTimestamp =\", \" msg.Timestamp\\n};\\nawait _daprClient.PublishEventAsync(\\\"pubsub\\\", \\\"collectfine\\\", speedingViolation);\\n}\", \"\\nThe code above uses two external dependencies. The _speedingViolationCalculator encapsulates\\nthe bu\", \"siness logic for determining whether or not a vehicle has driven too fast. The _daprClient\\nallows th\", \"e actor to publish messages using the Dapr pub/sub building block.\\nBoth dependencies are registered \", \"in the Program.cs class and injected into the actor using constructor\\ndependency injection:\\nprivate \", \"readonly DaprClient _daprClient;\\nprivate readonly ISpeedingViolationCalculator _speedingViolationCal\", \"culator;\\nprivate readonly string _roadId;\\npublic VehicleActor(\\nActorHost host, DaprClient daprClient\", \",\\nISpeedingViolationCalculator speedingViolationCalculator)\\n: base(host)\\n{\\n_daprClient = daprClient;\", \"\\n_speedingViolationCalculator = speedingViolationCalculator;\\n_roadId = _speedingViolationCalculator.\", \"GetRoadId();\\n}\\nThe actor based implementation no longer uses the Dapr state management building bloc\", \"k directly.\\nInstead, the state is automatically persisted after each operation is executed.\\nSummary\\n\", \"The Dapr actors building block makes it easier to write correct concurrent systems. Actors are small\", \"\\nunits of state and logic. They use a turn-based access model which saves you from having to use\\nloc\", \"king mechanisms to write thread-safe code. Actors are created implicitly and are silently unloaded\\n9\", \"8 CHAPTER 10 | The Dapr actors building blockfrom memory when no operations are performed. Any state\", \" stored in the actor is automatically\\npersisted and loaded when the actor is reactivated. Actor mode\", \"l implementations are typically created\\nfor a specific language or platform. With the Dapr actors bu\", \"ilding block however, you can leverage the\\nactor model from any language or platform.\\nActors support\", \" timers and reminders to schedule future work. Timers do not reset the idle timer and\\nwill allow the\", \" actor to be deactivated when no other operations are performed. Reminders do reset\\nthe idle timer a\", \"nd are also persisted automatically. Both timers and reminders respect the turn-based\\naccess model, \", \"making sure that no other operations can execute while the timer/reminder events are\\nhandled.\\nActor \", \"state is persisted using the Dapr state management building block. Any state store that\\nsupports mul\", \"ti-item transactions can be used to store actor state.\\nReferences\\n\\u2022 Dapr supported state stores\\n99 C\", \"HAPTER 10 | The Dapr actors building block11\\nCHAPTER\\nThe Dapr observability\\nbuilding block\\nModern di\", \"stributed systems are complex. You start with small, loosely coupled, independently\\ndeployable servi\", \"ces. These services cross process and server boundaries. They then consume different\\nkinds of infras\", \"tructure backing services (databases, message brokers, key vaults). Finally, these\\ndisparate pieces \", \"compose together to form an application.\\nWith so many separate, moving parts, how do you make sense \", \"of what is going on? Unfortunately,\\nlegacy monitoring approaches from the past aren\\u2019t enough. Instea\", \"d, the system must be observable\\nfrom end-to-end. Modern observability practices provide visibility \", \"and insight into the health of the\\napplication at all times. They enable you to infer the internal s\", \"tate by observing the output. Not only is\\nobservability mandatory for monitoring and troubleshooting\", \" distributed applications, it needs to be\\nimplemented at the start.\\nThe system information used to g\", \"ain observability is referred to as telemetry. It can be divided into\\nfour broad categories:\\n1. Dist\", \"ributed tracing provides insights into the traffic between services involved in distributed\\nbusiness\", \" transactions.\\n2. Metrics provides insights into the performance of a service and its resource consu\", \"mption.\\n3. Logging provides insights into how code is executing and if errors have occurred.\\n4. Heal\", \"th endpoints provide insight into the availability of a service.\\nThe depth of telemetry is determine\", \"d by the observability features of an application platform.\\nConsider the Azure cloud. It provides a \", \"rich telemetry experience that includes all of the telemetry\\ncategories. With little configuration, \", \"Azure IaaS and PaaS services will propagate and publish\\ntelemetry to the Azure Monitor and Azure App\", \"lication Insights services. Application Insights presents\\nsystem logging, tracing, and problem areas\", \" with highly visual dashboards. It can even render a\\ndiagram showing the dependencies between servic\", \"es based on their communication.\\nHowever, what if an application can\\u2019t use Azure PaaS and IaaS resou\", \"rces? Is it still possible to take\\nadvantage of the rich telemetry experience of Application Insight\", \"s? The answer is yes. A non-Azure\\napplication can import libraries, add configuration, and instrumen\", \"t code to emit telemetry to Azure\\nApplication Insights. However, this approach tightly couples the a\", \"pplication to Application Insights.\\nMoving the app to a different monitoring platform could involve \", \"expensive refactoring. Wouldn\\u2019t it be\\ngreat to avoid tight coupling and consume observability outsid\", \"e of the code?\\nWith Dapr, you can. Let\\u2019s look at how Dapr can add observability to our distributed a\", \"pplications.\\n100 CHAPTER 11 | The Dapr observability building blockWhat it solves\\nThe Dapr observabi\", \"lity building block decouples observability from the application. It automatically\\ncaptures traffic \", \"generated by Dapr sidecars and Dapr system services that make up the Dapr control\\nplane. The block c\", \"orrelates traffic from a single operation that spans multiple services. It also exposes\\nperformance \", \"metrics, resource utilization, and the health of the system. Telemetry is published in\\nopen-standard\", \" formats enabling information to be fed into your monitoring back end of choice.\\nThere, the informat\", \"ion can be visualized, queried, and analyzed.\\nAs Dapr abstracts away the plumbing, the application i\", \"s unaware of how observability is implemented.\\nThere\\u2019s no need to reference libraries or implement c\", \"ustom instrumentation code. Dapr allows the\\ndeveloper to focus on building business logic instead of\", \" observability plumbing. Observability is\\nconfigured at the Dapr system level and is consistent acro\", \"ss services, even when created by different\\nteams, and built with different technology stacks.\\nHow i\", \"t works\\nDapr\\u2019s sidecar architecture enables built-in observability features. As services communicate\", \", Dapr\\nsidecars intercept the traffic and extract tracing, metrics, and logging information. Telemet\", \"ry is\\npublished in an open standards format. By default, Dapr supports OpenTelemetry and Zipkin.\\nDap\", \"r provides collectors that can publish telemetry to different back-end monitoring tools. These\\ntools\", \" present Dapr telemetry for analysis and querying. Figure 10-1 shows the Dapr observability\\narchitec\", \"ture:\\nFigure 10-1. Dapr observability architecture.\\n1. Service A calls an operation on Service B. Th\", \"e call is routed from a Dapr sidecar for Service A to a\\nsidecar for Service B.\\n2. When Service B com\", \"pletes the operation, a response is sent back to Service A through the Dapr\\nsidecars. They gather an\", \"d publish all available telemetry for every request and response.\\n3. The configured collector ingest\", \"s the telemetry and sends it to the monitoring back end.\\n101 CHAPTER 11 | The Dapr observability bui\", \"lding blockAs a developer, keep in mind that adding observability is different from configuring othe\", \"r Dapr\\nbuilding blocks, like pub/sub or state management. Instead of referencing a building block, y\", \"ou add a\\ncollector and a monitoring back end. Figure 10-1 shows it\\u2019s possible to configure multiple \", \"collectors\\nthat integrate with different monitoring back ends.\\nAt the beginning of this chapter, fou\", \"r categories of telemetry were identified. The following sections\\nwill provide detail for each categ\", \"ory. They\\u2019ll include instruction on how to configure collectors that\\nintegrate with popular monitori\", \"ng back ends.\\nDistributed tracing\\nDistributed tracing provides insight into traffic that flows acros\", \"s services in a distributed application.\\nThe logs of exchanged request and response messages are a s\", \"ource of invaluable information for\\ntroubleshooting issues. The hard part is correlating messages th\", \"at belong to the same business\\ntransaction.\\nDapr uses the W3C Trace Context to correlate related mes\", \"sages. It injects the same context\\ninformation into requests and responses that form a unique operat\", \"ion. Figure 10-2 shows how\\ncorrelation works:\\nNote\\nThe trace context is often referred to as a corre\", \"lation token in microservice terminology.\\nFigure 10-2. W3C Trace Context example.\\n1. Service A invok\", \"es an operation on Service B. As Service A starts the call, Dapr creates a unique\\ntrace context and \", \"injects it into the request.\\n2. Service B receives the request and invokes an operation on Service C\", \". Dapr detects that the\\nincoming request contains a trace context and propagates it by injecting it \", \"into the outgoing\\nrequest to Service C.\\n3. Service C receives the request and handles it. Dapr detec\", \"ts that the incoming request contains a\\ntrace context and propagates it by injecting it into the out\", \"going response back to Service B.\\n4. Service B receives the response and handles it. It then creates\", \" a new response and propagates\\nthe trace context by injecting it into the outgoing response back to \", \"Service A.\\nA set of requests and responses that belong together is called a trace. Figure 10-3 shows\", \" a trace:\\n102 CHAPTER 11 | The Dapr observability building blockFigure 10-3. Traces and spans.\\nIn th\", \"e figure, note how the trace represents a unique application transaction that takes place across\\nman\", \"y services. A trace is a collection of spans. Each span represents a single operation or unit of wor\", \"k\\ndone within the trace. Spans are the requests and responses that are sent between services that\\nim\", \"plement the unique transaction.\\nThe next sections discuss how to inspect tracing telemetry by publis\", \"hing it to a monitoring back end.\\nUse a Zipkin monitoring back end\\nZipkin is an open-source distribu\", \"ted tracing system. It can ingest and visualize telemetry data. Dapr\\noffers default support for Zipk\", \"in. The following example demonstrates how to configure Zipkin to\\nvisualize Dapr telemetry.\\nEnable a\", \"nd configure tracing\\nTo start, tracing must be enabled for the Dapr runtime using a Dapr configurati\", \"on file. Here\\u2019s an\\nexample of a configuration file named dapr-config.yaml that enables tracing:\\napiV\", \"ersion: dapr.io/v1alpha1\\nkind: Configuration\\nmetadata:\\nname: dapr-config\\nnamespace: default\\nspec:\\ntr\", \"acing:\\nsamplingRate: \\\"1\\\"\\nzipkin:\\nendpointAddress: \\\"http://zipkin.default.svc.cluster.local:9411/api/\", \"v2/spans\\\"\\nThe samplingRate attribute specifies the interval used for publishing traces. The value mu\", \"st be\\nbetween 0 (tracing disabled) and 1 (every trace is published). With a value of 0.5, for exampl\", \"e, every\\nother trace is published, significantly reducing published traffic. The endpointAddress poi\", \"nts to an\\nendpoint on a Zipkin server running in a Kubernetes cluster. The default port for Zipkin i\", \"s 9411. The\\nconfiguration must be applied to the Kubernetes cluster using the Kubernetes CLI:\\nkubect\", \"l apply -f dapr-config.yaml\\n103 CHAPTER 11 | The Dapr observability building blockInstall the Zipkin\", \" server\\nWhen installing Dapr in self-hosted mode, a Zipkin server is automatically installed and tra\", \"cing is\\nenabled in the default configuration file located in $HOME/.dapr/config.yaml or\\n%USERPROFILE\", \"%\\\\.dapr\\\\config.yaml on Windows.\\nWhen installing Dapr on a Kubernetes cluster, Zipkin must be deploye\", \"d manually. Use the following\\nKubernetes manifest file entitled zipkin.yaml to deploy a standard Zip\", \"kin server to a Kubernetes\\ncluster:\\nkind: Deployment\\napiVersion: apps/v1\\nmetadata:\\nname: zipkin\\nname\", \"space: dapr-trafficcontrol\\nlabels:\\nservice: zipkin\\nspec:\\nreplicas: 1\\nselector:\\nmatchLabels:\\nservice:\", \" zipkin\\ntemplate:\\nmetadata:\\nlabels:\\nservice: zipkin\\nspec:\\ncontainers:\\n- name: zipkin\\nimage: openzipk\", \"in/zipkin-slim\\nimagePullPolicy: IfNotPresent\\nports:\\n- name: http\\ncontainerPort: 9411\\nprotocol: TCP\\n-\", \"--\\nkind: Service\\napiVersion: v1\\nmetadata:\\nname: zipkin\\nnamespace: dapr-trafficcontrol\\nlabels:\\nservic\", \"e: zipkin\\nspec:\\ntype: NodePort\\nports:\\n- port: 9411\\ntargetPort: 9411\\nnodePort: 32411\\nprotocol: TCP\\nna\", \"me: zipkin\\nselector:\\nservice: zipkin\\nThe deployment uses the standard openzipkin/zipkin-slim contain\", \"er image. The Zipkin service\\nexposes the Zipkin web front end, which you can use to view the telemet\", \"ry on port 32411. Use the\\n104 CHAPTER 11 | The Dapr observability building blockKubernetes CLI to ap\", \"ply the Zipkin manifest file to the Kubernetes cluster and deploy the Zipkin\\nserver:\\nkubectl apply -\", \"f zipkin.yaml\\nConfigure the services to use the tracing configuration\\nNow everything is set up corre\", \"ctly to start publishing telemetry. Every Dapr sidecar that is deployed as\\npart of the application m\", \"ust be instructed to emit telemetry when started. To do that, add a\\ndapr.io/config annotation that r\", \"eferences the dapr-config configuration to the deployment of\\neach service. Here\\u2019s an example of the \", \"Traffic Control FineCollection service\\u2019s manifest file containing\\nthe annotation:\\napiVersion: apps/v\", \"1\\nkind: Deployment\\nmetadata:\\nname: finecollectionservice\\nnamespace: dapr-trafficcontrol\\nlabels:\\napp:\", \" finecollectionservice\\nspec:\\nreplicas: 1\\nselector:\\nmatchLabels:\\napp: finecollectionservice\\ntemplate:\", \"\\nmetadata:\\nlabels:\\napp: finecollectionservice\\nannotations:\\ndapr.io/enabled: \\\"true\\\"\\ndapr.io/app-id: \\\"\", \"finecollectionservice\\\"\\ndapr.io/app-port: \\\"6001\\\"\\ndapr.io/config: \\\"dapr-config\\\"\\nspec:\\ncontainers:\\n- na\", \"me: finecollectionservice\\nimage: dapr-trafficcontrol/finecollectionservice:1.0\\nports:\\n- containerPor\", \"t: 6001\\nInspect the telemetry in Zipkin\\nOnce the application is started, the Dapr sidecars will emit\", \" telemetry to the Zipkin server. To inspect\\nthis telemetry, point a web-browser to http://localhost:\", \"32411. You\\u2019ll see the Zipkin web front end:\\n105 CHAPTER 11 | The Dapr observability building blockFi\", \"gure 10-4. Zipkin front end.\\nOn the Find a trace tab, you can query traces. Pressing the RUN QUERY b\", \"utton without specifying any\\nrestrictions will show all the ingested traces:\\nFigure 10-5. Zipkin tra\", \"ces overview.\\nClicking the SHOW button next to a specific trace, will show the details of that trace\", \":\\n106 CHAPTER 11 | The Dapr observability building blockFigure 10-6. Zipkin trace details.\\nEach item\", \" on the details page, is a span that represents a request that is part of the selected trace.\\nInspec\", \"t the dependencies between services\\nBecause Dapr sidecars handle traffic between services, Zipkin ca\", \"n use the trace information to\\ndetermine the dependencies between the services. To see it in action,\", \" go to the Dependencies tab on\\nthe Zipkin web page and select the button with the magnifying glass. \", \"Zipkin will show an overview of\\nthe services and their dependencies:\\n107 CHAPTER 11 | The Dapr obser\", \"vability building blockFigure 10-7. Zipkin dependencies.\\nThe animated dots on the lines between the \", \"services represent requests and move from source to\\ndestination. Red dots indicate a failed request.\", \"\\nUse a Jaeger or New Relic monitoring back end\\nBeyond Zipkin, other monitoring back-end software can\", \" also ingest telemetry with the Zipkin format.\\nJaeger is an open source tracing system created by Ub\", \"er Technologies. It\\u2019s used to trace transactions\\nbetween distributed services and troubleshoot compl\", \"ex microservices environments. New Relic is a\\nfull-stack observability platform. It links relevant d\", \"ata from a distributed application to provide a\\ncomplete picture of your system. To try them out, sp\", \"ecify an endpointAddress pointing to either a\\nJaeger or New Relic server in the Dapr configuration f\", \"ile. Here\\u2019s an example of a configuration file that\\nconfigures Dapr to send telemetry to a Jaeger se\", \"rver. The URL for Jaeger is identical to the URL for the\\nZipkin. The only difference is the number o\", \"f the port on which the server runs:\\n:::{custom-style=CodeBox} yaml apiVersion: dapr.io/v1alpha1 kin\", \"d: Configuration metadata: name:\\ndapr-config namespace: default spec: tracing: samplingRate: \\\"1\\\" zip\", \"kin:\\nendpointAddress: \\\"http://localhost:9415/api/v2/spans\\\" :::\\nTo try out New Relic, specify the end\", \"point of the New Relic API. Here\\u2019s an example of a configuration\\nfile for New Relic:\\n:::{custom-styl\", \"e=CodeBox} yaml apiVersion: dapr.io/v1alpha1 kind: Configuration metadata: name:\\ndapr-config namespa\", \"ce: default spec: tracing: samplingRate: \\\"1\\\" zipkin:\\nendpointAddress: \\\"https://trace-api.newrelic.co\", \"m/trace/v1?Api-Key=<NR-API-KEY>&Data-\\nFormat=zipkin&Data-Format-Version=2\\\" :::\\n108 CHAPTER 11 | The \", \"Dapr observability building blockCheck out the Jaeger and New Relic websites for more information on\", \" how to use them.\\nMetrics\\nMetrics provide insight into performance and resource consumption. Under t\", \"he hood, Dapr emits a\\nwide collection of system and runtime metrics. Dapr uses Prometheus as a metri\", \"c standard. Dapr\\nsidecars and system services, expose a metrics endpoint on port 9090. A Prometheus \", \"scraper calls this\\nendpoint at a predefined interval to collect metrics. The scraper sends metric va\", \"lues to a monitoring\\nback end. Figure 10-8 shows the scraping process:\\nFigure 10-8. Scraping Prometh\", \"eus metrics.\\nEach sidecar and system service exposes a metric endpoint that listens on port 9090. Th\", \"e Prometheus\\nMetrics Scrapper captures metrics from each endpoint and published the information to t\", \"he\\nmonitoring back end.\\nService discovery\\nYou might wonder how the metrics scraper knows where to co\", \"llect metrics. Prometheus can integrate\\nwith discovery mechanisms built into target deployment envir\", \"onments. For example, when running in\\nKubernetes, Prometheus can integrate with the Kubernetes API t\", \"o find all available Kubernetes\\nresources running in the environment.\\nMetrics list\\nDapr generates a \", \"large set of metrics for Dapr system services and its runtime. Some examples\\ninclude:\\n109 CHAPTER 11\", \" | The Dapr observability building blockMetric Source Description\\ndapr_operator_service_created_tota\", \"l System The total number of Dapr services created\\nby the Dapr Operator service.\\ndapr_injector_sidec\", \"ar_injection/requests_total System The total number of sidecar injection\\nrequests received by the Da\", \"pr Sidecar-\\nInjector service.\\ndapr_placement_runtimes_total System The total number of hosts reporte\", \"d to the\\nDapr Placement service.\\ndapr_sentry_cert_sign_request_received_total System The number of c\", \"ertificate signing requests\\n(CRSs) received by the Dapr Sentry service.\\ndapr_runtime_component_loade\", \"d Runtime The number of successfully loaded Dapr\\ncomponents.\\ndapr_grpc_io_server_completed_rpcs Runt\", \"ime Count of gRPC calls by method and status.\\ndapr_http_server_request_count Runtime Number of HTTP \", \"requests started in an\\nHTTP server.\\ndapr_http/client/sent_bytes Runtime Total bytes sent in request \", \"body (not\\nincluding headers) by an HTTP client.\\nFor more information on available metrics, see the D\", \"apr metrics documentation.\\nConfigure Dapr metrics\\nAt run time, you can disable the metrics collectio\", \"n endpoint by including the --enable-\\nmetrics=false argument in the Dapr command. Or, you can also c\", \"hange the default port for the\\nendpoint with the --metrics-port 9090 argument.\\nYou can also use a Da\", \"pr configuration file to statically enable or disable runtime metrics collection:\\napiVersion: dapr.i\", \"o/v1alpha1\\nkind: Configuration\\nmetadata:\\nname: dapr-config\\nnamespace: dapr-trafficcontrol\\nspec:\\ntrac\", \"ing:\\nsamplingRate: \\\"1\\\"\\nmetric:\\nenabled: false\\nVisualize Dapr metrics\\nWith the Prometheus scraper col\", \"lecting and publishing metrics into the monitoring back end, how do\\nyou make sense of the raw data? \", \"A popular visualization tool for analyzing metrics is Grafana. With\\nGrafana, you can create dashboar\", \"ds from the available metrics. Here\\u2019s an example of a dashboard\\ndisplaying Dapr system services metr\", \"ics:\\n110 CHAPTER 11 | The Dapr observability building blockFigure 10-9. Grafana dashboard.\\nThe Dapr \", \"documentation includes a tutorial for installing Prometheus and Grafana.\\nLogging\\nLogging provides in\", \"sight into what is happening with a service at run time. When running an\\napplication, Dapr automatic\", \"ally emits log entries from Dapr sidecars and Dapr system services.\\nHowever, logging entries instrum\", \"ented in your application code aren\\u2019t automatically included. To\\nemit logging from application code,\", \" you can import a specific SDK like OpenTelemetry SDK for .NET.\\nLogging application code is covered \", \"later in this chapter in the section Using the Dapr .NET SDK.\\nLog entry structure\\nDapr emits structu\", \"red logging. Each log entry has the following format:\\nField Description Example\\ntime ISO8601 formatt\", \"ed timestamp 2021-01-10T14:19:31.000Z\\nlevel Level of the entry (debug, info, warn, or error) info\\nty\", \"pe Log Type log\\nmsg Log Message metrics server started on :62408/\\nscope Logging Scope dapr.runtime\\ni\", \"nstance Hostname where Dapr runs TSTSRV01\\n111 CHAPTER 11 | The Dapr observability building blockFiel\", \"d Description Example\\napp_id Dapr App ID finecollectionservice\\nver Dapr Runtime Version 1.0\\nWhen sea\", \"rching through logging entries in a troubleshooting scenario, the time and level fields are\\nespecial\", \"ly helpful. The time field orders log entries so that you can pinpoint specific time periods.\\nWhen t\", \"roubleshooting, log entries at the debug level provide more information on the behavior of the\\ncode.\", \"\\nPlain text versus JSON format\\nBy default, Dapr emits structured logging in plain-text format. Every\", \" log entry is formatted as a string\\ncontaining key/value pairs. Here\\u2019s an example of logging in plai\", \"n text:\\n== DAPR == time=\\\"2021-01-12T16:11:39.4669323+01:00\\\" level=info msg=\\\"starting Dapr Runtime -\\n\", \"- version 1.0 -- commit 196483d\\\" app_id=finecollectionservice instance=TSTSRV03\\nscope=dapr.runtime t\", \"ype=log ver=1.0\\n== DAPR == time=\\\"2021-01-12T16:11:39.467933+01:00\\\" level=info msg=\\\"log level set to:\", \" info\\\"\\napp_id=finecollectionservice instance=TSTSRV03 scope=dapr.runtime type=log ver=1.0\\n== DAPR ==\", \" time=\\\"2021-01-12T16:11:39.467933+01:00\\\" level=info msg=\\\"metrics server started\\non :62408/\\\" app_id=f\", \"inecollectionservice instance=TSTSRV03 scope=dapr.metrics type=log\\nver=1.0\\nWhile simple, this format\", \" is difficult to parse. If viewing log entries with a monitoring tool, you\\u2019ll want\\nto enable JSON fo\", \"rmatted logging. With JSON entries, a monitoring tool can index and query\\nindividual fields. Here\\u2019s \", \"the same log entries in JSON format:\\n{\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"le\", \"vel\\\": \\\"info\\\", \\\"msg\\\":\\n\\\"starting Dapr Runtime -- version 1.0 -- commit 196483d\\\", \\\"scope\\\": \\\"dapr.runtim\", \"e\\\", \\\"time\\\":\\n\\\"2021-01-12T16:11:39.4669323+01:00\\\", \\\"type\\\": \\\"log\\\", \\\"ver\\\": \\\"1.0\\\"}\\n{\\\"app_id\\\": \\\"finecollec\", \"tionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \\\"log\\nlevel set to: info\\\", \\\"scope\\\": \\\"da\", \"pr.runtime\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"2021-01-\\n12T16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"}\\n{\\\"app_id\\\": \\\"f\", \"inecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\":\\n\\\"metrics server started on :6\", \"2408/\\\", \\\"scope\\\": \\\"dapr.metrics\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"2021-\\n01-12T16:11:39.467933+01:00\\\", \\\"ver\\\": \", \"\\\"1.0\\\"}\\nTo enable JSON formatting, you need to configure each Dapr sidecar. In self-hosted mode, you \", \"can\\nspecify the flag --log-as-json on the command line:\\ndapr run --app-id finecollectionservice --lo\", \"g-level info --log-as-json dotnet run\\nIn Kubernetes, you can add a dapr.io/log-as-json annotation to\", \" each deployment for the\\napplication:\\nannotations:\\ndapr.io/enabled: \\\"true\\\"\\ndapr.io/app-id: \\\"finecoll\", \"ectionservice\\\"\\ndapr.io/app-port: \\\"80\\\"\\ndapr.io/config: \\\"dapr-config\\\"\\ndapr.io/log-as-json: \\\"true\\\"\\nWhen\", \" you install Dapr in a Kubernetes cluster using Helm, you can enable JSON formatted logging for\\nall \", \"the Dapr system services:\\n112 CHAPTER 11 | The Dapr observability building blockhelm repo add dapr h\", \"ttps://dapr.github.io/helm-charts/\\nhelm repo update\\nkubectl create namespace dapr-system\\nhelm instal\", \"l dapr dapr/dapr --namespace dapr-system --set global.logAsJson=true\\nCollect logs\\nThe logs emitted b\", \"y Dapr can be fed into a monitoring back end for analysis. A log collector is a\\ncomponent that colle\", \"cts logs from a system and sends them to a monitoring back end. A popular log\\ncollector is Fluentd. \", \"Check out the How-To: Set up Fluentd, Elastic search and Kibana in Kubernetes in\\nthe Dapr documentat\", \"ion. This article contains instructions for setting up Fluentd as log collector and\\nthe ELK Stack (E\", \"lastic Search and Kibana) as a monitoring back end.\\nHealth status\\nThe health status of a service pro\", \"vides insight into its availability. Each Dapr sidecar exposes a health\\nAPI that can be used by the \", \"hosting environment to determine the health of the sidecar. The API has\\none operation:\\nGET http://lo\", \"calhost:3500/v1.0/healthz\\nThe operation returns two HTTP status codes:\\n\\u2022 204: When the sidecar is he\", \"althy\\n\\u2022 500: when the sidecar isn\\u2019t healthy\\nWhen running in self-hosted mode, the health API isn\\u2019t a\", \"utomatically invoked. You can invoke the API\\nthough from application code or a health monitoring too\", \"l.\\nWhen running in Kubernetes, the Dapr sidecar-injector automatically configures Kubernetes to use \", \"the\\nhealth API for executing liveness probes and readiness probes.\\nKubernetes uses liveness probes t\", \"o determine whether a container is up and running. If a liveness\\nprobe returns a failure code, Kuber\", \"netes will assume the container is dead and automatically restart it.\\nThis feature increases the ove\", \"rall availability of your application.\\nKubernetes uses readiness probes to determine whether a conta\", \"iner is ready to start accepting traffic.\\nA pod is considered ready when all of its containers are r\", \"eady. Readiness determines whether a\\nKubernetes service can direct traffic to a pod in a load-balanc\", \"ing scenario. Pods that aren\\u2019t ready are\\nautomatically removed from the load-balancer.\\nLiveness and \", \"readiness probes have several configurable parameters. Both are configured in the\\ncontainer spec sec\", \"tion of a pod\\u2019s manifest file. By default, Dapr uses the following configuration for\\neach sidecar co\", \"ntainer:\\nlivenessProbe:\\nhttpGet:\\npath: v1.0/healthz\\nport: 3500\\ninitialDelaySeconds: 5\\nperiodSeconds:\", \" 10\\ntimeoutSeconds : 5\\nfailureThreshold : 3\\n113 CHAPTER 11 | The Dapr observability building blockre\", \"adinessProbe:\\nhttpGet:\\npath: v1.0/healthz\\nport: 3500\\ninitialDelaySeconds: 5\\nperiodSeconds: 10\\ntimeou\", \"tSeconds : 5\\nfailureThreshold: 3\\nThe following parameters are available for the probes:\\n\\u2022 The path s\", \"pecifies the Dapr health API endpoint.\\n\\u2022 The port specifies the Dapr health API port.\\n\\u2022 The initialD\", \"elaySecondsspecifies the number of seconds Kubernetes will wait before it starts\\nprobing a container\", \" for the first time.\\n\\u2022 The periodSeconds specifies the number of seconds Kubernetes will wait betwee\", \"n each probe.\\n\\u2022 The timeoutSeconds specifies the number of seconds Kubernetes will wait on a respons\", \"e from\\nthe API before timing out. A timeout is interpreted as a failure.\\n\\u2022 The failureThresholdspeci\", \"fies the number of failed status code Kubernetes will accept before\\nconsidering the container not al\", \"ive or not ready.\\nDapr dashboard\\nDapr offers a dashboard that presents status information on Dapr ap\", \"plications, components, and\\nconfigurations. Use the Dapr CLI to start the dashboard as a web-applica\", \"tion on the local machine on\\nport 8080:\\ndapr dashboard\\nFor Dapr application running in Kubernetes, u\", \"se the following command:\\ndapr dashboard -k\\nThe dashboard opens with an overview of all services in \", \"your application that have a Dapr sidecar. The\\nfollowing screenshot shows the Dapr dashboard for the\", \" Traffic Control sample application running in\\nKubernetes:\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/o\", \"bservability/dapr-dashboard-overview.png\\u201d alt-text=\\u201cDapr\\ndashboard overview\\u201d:::\\nFigure 10-10. Dapr d\", \"ashboard overview.\\nThe Dapr dashboard is invaluable when troubleshooting a Dapr application. It prov\", \"ides information\\nabout Dapr sidecars and system services. You can drill down into the configuration \", \"of each service,\\nincluding the logging entries.\\nThe dashboard also shows the configured components (\", \"and their configuration) for an application:\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/observability/d\", \"apr-dashboard-components.png\\u201d alt-\\ntext=\\u201cDapr dashboard components\\u201d:::\\nFigure 10-11. Dapr dashboard \", \"components.\\n114 CHAPTER 11 | The Dapr observability building blockThere\\u2019s a large amount of informat\", \"ion available through the dashboard. You can discover it by\\nrunning a Dapr application and browsing \", \"the dashboard.\\nCheck out the Dapr dashboard CLI command reference in the Dapr docs for more informat\", \"ion on the\\nDapr dashboard commands.\\nUse the Dapr .NET SDK\\nThe Dapr .NET SDK doesn\\u2019t contain any spec\", \"ific observability features. All observability features are\\noffered at the Dapr level.\\nIf you want t\", \"o emit telemetry from your .NET application code, you should consider the\\nOpenTelemetry SDK for .NET\", \". The Open Telemetry project is cross-platform, open source, and vendor\\nagnostic. It provides an end\", \"-to-end implementation to generate, emit, collect, process, and export\\ntelemetry data. There\\u2019s a sin\", \"gle instrumentation library per language that supports automatic and\\nmanual instrumentation. Telemet\", \"ry is published using the Open Telemetry standard. The project has\\nbroad industry support and adopti\", \"on from cloud providers, vendors, and end users.\\nSample application: Dapr Traffic Control\\nBecause th\", \"e Traffic Control sample application runs with Dapr, all the telemetry described in this\\nchapter is \", \"available. If you run the application and open the Zipkin web front end, you\\u2019ll see end-to-\\nend trac\", \"ing. Figure 10-12 shows an example:\\nFigure 10-12. Zipkin end-to-end tracing example.\\nThis trace show\", \"s the communication that occurs when a speeding violation has been detected:\\n115 CHAPTER 11 | The Da\", \"pr observability building block1. An exiting vehicle triggers the MQTT input binding that sends a me\", \"ssage containing the vehicle\\nlicense number, lane, and timestamp.\\n2. The MQTT input binding invokes \", \"the TrafficControl service with the message.\\n3. The TrafficControl service retrieves the state for t\", \"he vehicle, appends the entry, and saves the\\nupdated vehicle state back to the state store.\\n4. The T\", \"rafficControl service publishes the speeding violation using pub/sub to the\\nspeedingviolations topic\", \".\\n5. The FineCollection service receives the speeding violation using a pub/sub subscription on the\\n\", \"speedingviolations topic.\\n6. The FineCollection service invokes the vehicleinfo endpoint of the Vehi\", \"cleRegistration service\\nusing service invocation.\\n7. The FineCollection service invokes an output bi\", \"nding for sending the email.\\nClick any trace line (span) to see more details. If you click on the la\", \"st line, you\\u2019ll see the sendmail\\nbinding component invoked to send the driver a violation notice.\\n11\", \"6 CHAPTER 11 | The Dapr observability building blockFigure 10-13. Output binding trace details.\\nSumm\", \"ary\\nDetailed observability is critical to running a distributed system in production.\\nDapr provides \", \"different types of telemetry, including distributed tracing, logging, metrics, and health\\nstatus.\\nDa\", \"pr only produces telemetry for the Dapr system services and sidecars. Telemetry from your\\napplicatio\", \"n code isn\\u2019t automatically included. You can however use a specific SDK like the\\nOpenTelemetry SDK f\", \"or .NET to emit telemetry from your application code.\\n117 CHAPTER 11 | The Dapr observability buildi\", \"ng blockDapr telemetry is produced in an open-standards based format so that it can be ingested by a\", \" large\\nset of available monitoring tools. Examples include Zipkin, Azure Application Insights, the E\", \"LK Stack,\\nNew Relic, and Grafana. See Monitor your application with Dapr in the Dapr documentation f\", \"or\\ntutorials on how to monitor your Dapr applications with specific monitoring back ends.\\nYou\\u2019ll nee\", \"d a telemetry scraper that ingests telemetry and publishes it to the monitoring back end.\\nDapr can b\", \"e configured to emit structured logging. Structured logging is favored as it can be indexed\\nby back-\", \"end monitoring tools. Indexed logging enables users to execute rich queries when searching\\nthrough t\", \"he logging.\\nDapr offers a dashboard that presents information about the Dapr services and configurat\", \"ion.\\nReferences\\n\\u2022 Azure Application Insights\\n\\u2022 Open Telemetry\\n\\u2022 Zipkin\\n\\u2022 W3C Trace Context\\n\\u2022 Jaeger\\n\", \"\\u2022 New Relic\\n\\u2022 Prometheus\\n\\u2022 Grafana\\n\\u2022 Open Telemetry SDK for .NET\\n\\u2022 Fluentd\\n\\u2022 ELK stack\\n\\u2022 Seq\\n\\u2022 Seril\", \"og\\n118 CHAPTER 11 | The Dapr observability building block12\\nCHAPTER\\nThe Dapr secrets\\nmanagement buil\", \"ding\\nblock\\nEnterprise applications require secrets. Common examples include:\\n\\u2022 A database connection\", \" string that contains a username and password.\\n\\u2022 An API key for calling an external web API.\\n\\u2022 A cli\", \"ent certificate for authenticating to an external system.\\nSecrets must be carefully managed so that \", \"they\\u2019re never disclosed outside of the application.\\nNot long ago, it was popular to store applicatio\", \"n secrets in a configuration file inside the application\\ncodebase. .NET developers will fondly recal\", \"l the web.config file. While simple to implement, integrating\\nsecrets to along with code was far fro\", \"m secure. A common misstep was to include the file when\\npushing to a public GIT repository, exposing\", \" the secrets to the world.\\nA widely accepted methodology for constructing modern distributed applica\", \"tions is The Twelve-\\nFactor App. It describes a set of principles and best practices. Its third fact\", \"or prescribes that\\nconfiguration and secrets be externalized outside of the code base.\\nTo address th\", \"is concern, the .NET platform includes a Secret Manager feature that stores sensitive\\ndata in a phys\", \"ical folder outside of the project tree. While secrets are outside of source control, this\\nfeature d\", \"oesn\\u2019t encrypt data. It\\u2019s designed for development purposes only.\\nA more modern and secure practice \", \"is to isolate secrets in a secrets management tool like Hashicorp\\nVault or Azure Key Vault. These to\", \"ols enable you to store secrets externally, vary credentials across\\nenvironments, and reference them\", \" from application code. However, each tool has its complexities and\\nlearning curve.\\nDapr offers a bu\", \"ilding block that simplifies managing secrets.\\nWhat it solves\\nThe Dapr secrets management building b\", \"lock abstracts away the complexity of working with secrets\\nand secret management tools.\\n119 CHAPTER \", \"12 | The Dapr secrets management building block\\u2022 It hides the underlying plumbing through a unified \", \"interface.\\n\\u2022 It supports various pluggable secret store components, which can vary between developme\", \"nt\\nand production.\\n\\u2022 Applications don\\u2019t require direct dependencies on secret store libraries.\\n\\u2022 Dev\", \"elopers don\\u2019t require detailed knowledge of each secret store.\\nDapr handles all of the above concern\", \"s.\\nAccess to the secrets is secured through authentication and authorization. Only an application wi\", \"th\\nsufficient rights can access secrets. Applications running in Kubernetes can also use its built-i\", \"n secrets\\nmanagement mechanism.\\nHow it works\\nApplications use the secrets management building block \", \"in two ways:\\n\\u2022 Retrieve a secret directly from the building block.\\n\\u2022 Reference a secret indirectly f\", \"rom a Dapr component configuration.\\nRetrieving secrets directly is covered first. Referencing a secr\", \"et from a Dapr component configuration\\nfile is addressed in a later section.\\nThe application interac\", \"ts with a Dapr sidecar when using the secrets management building block. The\\nsidecar exposes the sec\", \"rets API. The API can be called with either HTTP or gRPC. Use the following\\nURL to call the HTTP API\", \":\\nhttp://localhost:<dapr-port>/v1.0/secrets/<store-name>/<name>?<metadata>\\nThe URL contains the foll\", \"owing segments:\\n\\u2022 <dapr-port> specifies the port number upon which the Dapr sidecar is listening.\\n\\u2022 \", \"<store-name> specifies the name of the Dapr secret store.\\n\\u2022 <name> specifies the name of the secret \", \"to retrieve.\\n\\u2022 <metadata> provides additional information for the secret. This segment is optional a\", \"nd\\nmetadata properties differ per secret store. For more information on metadata properties, see\\nthe\", \" [secrets API reference]INTERNAL-LINK:(Secrets API reference | Dapr Docs).\\n[!NOTE] The above URL rep\", \"resents the native Dapr API call available to any development platform that\\nsupports HTTP or gRPC. P\", \"opular platforms like .NET, Java, and Go have their own custom APIs.\\nThe JSON response contains the \", \"key and value of the secret.\\nFigure 11-1 shows how Dapr handles a request for the secrets API:\\n120 C\", \"HAPTER 12 | The Dapr secrets management building blockFigure 11-1. Retrieving a secret with the Dapr\", \" secrets API.\\n1. The service calls the Dapr secrets API, along with the name of the secret store, an\", \"d secret to\\nretrieve.\\n2. The Dapr sidecar retrieves the specified secret from the secret store.\\n3. T\", \"he Dapr sidecar returns the secret information back to the service.\\nSome secret stores support stori\", \"ng multiple key/value pairs in a single secret. For those scenarios, the\\nresponse would contain mult\", \"iple key/value pairs in a single JSON response as in the following\\nexample:\\nGET http://localhost:350\", \"0/v1.0/secrets/secret-store/interestRates?metadata.version_id=3\\n{\\n\\\"tier1-percentage\\\": \\\"2.5\\\",\\n\\\"tier2-\", \"percentage\\\": \\\"3.8\\\",\\n\\\"tier3-percentage\\\": \\\"5.1\\\"\\n}\\nThe Dapr secrets API also offers an operation to ret\", \"rieve all the secrets the application has access to:\\nhttp://localhost:<dapr-port>/v1.0/secrets/<stor\", \"e-name>/bulk\\nUse the Dapr .NET SDK\\nFor .NET developers, the Dapr .NET SDK streamlines Dapr secret ma\", \"nagement. Consider the\\nDaprClient.GetSecretAsync method. It enables you to retrieve a secret directl\", \"y from any Dapr secret\\nstore with minimal effort. Here\\u2019s an example of fetching a connection string \", \"secret for a SQL Server\\ndatabase:\\n121 CHAPTER 12 | The Dapr secrets management building blockvar met\", \"adata = new Dictionary<string, string> { [\\\"version_id\\\"] = \\\"3\\\" };\\nDictionary<string, string> secrets \", \"= await daprClient.GetSecretAsync(\\\"secret-store\\\",\\n\\\"eshopsecrets\\\", metadata);\\nstring connectionString\", \" = secrets[\\\"customerdb\\\"];\\nArguments for the GetSecretAsync method include:\\n\\u2022 The name of the Dapr se\", \"cret store component (\\u2018secret-store\\u2019)\\n\\u2022 The secret to retrieve (\\u2018eshopsecrets\\u2019)\\n\\u2022 Optional metadata \", \"key/value pairs (\\u2018version_id=3\\u2019)\\nThe method responds with a dictionary object as a secret can contai\", \"n multiple key/value pairs. In the\\nexample above, the secret named customerdb is referenced from the\", \" collection to return a connection\\nstring.\\nThe Dapr .NET SDK also features a .NET configuration prov\", \"ider. It loads specified secrets into the\\nunderlying .NET configuration API. The running application\", \" can then reference secrets from the\\nIConfiguration dictionary that is registered in ASP.NET Core de\", \"pendency injection.\\nThe secrets configuration provider is available from the Dapr.Extensions.Configu\", \"ration NuGet\\npackage. The provider can be registered in the Program.cs of an ASP.NET Web API applica\", \"tion:\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder.WebHost.ConfigureAppConfiguration(co\", \"nfig =>\\n{\\nvar daprClient = new DaprClientBuilder().Build();\\nvar secretDescriptors = new List<DaprSec\", \"retDescriptor>\\n{\\nnew DaprSecretDescriptor(\\\"eshopsecrets\\\")\\n};\\nconfig.AddDaprSecretStore(\\\"secret-store\", \"\\\", secretDescriptors, daprClient);\\n});\\nThe above example loads the eshopsecrets secrets collection i\", \"nto the .NET configuration system at\\nstartup. Registering the provider requires an instance of DaprC\", \"lient to invoke the secrets API on the\\nDapr sidecar. The other arguments include the name of the sec\", \"ret store and a DaprSecretDescriptor\\nobject with the name of the secret.\\nOnce loaded, you can retrie\", \"ve secrets directly from application code:\\npublic void GetCustomer(IConfiguration config)\\n{\\nvar conn\", \"ectionString = config[\\\"eshopsecrets\\\"][\\\"customerdb\\\"];\\n}\\nSecret store components\\nThe secrets managemen\", \"t building block supports several secret store components. At the time of\\nwriting, the following sec\", \"ret stores are available:\\n\\u2022 AlibabaCloud OOS Parameter Store\\n\\u2022 AWS Secrets Manager\\n\\u2022 AWS SSM Paramet\", \"er Store\\n122 CHAPTER 12 | The Dapr secrets management building block\\u2022 Azure Key Vault\\n\\u2022 GCP Secret M\", \"anager\\n\\u2022 HashiCorp Vault\\n\\u2022 Kubernetes secrets\\n\\u2022 Local environment variables\\n\\u2022 Local file\\nImportant\\nT\", \"he local environment variables and file components are designed for development workloads only.\\nThe \", \"following sections show how to configure a secret store.\\nConfiguration\\nYou configure a secret store \", \"using a Dapr component configuration file. The typical structure of the\\nfile is shown below:\\napiVers\", \"ion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: [component name]\\nnamespace: [namespace]\\nspec:\\n\", \"type: secretstores.[secret store type]\\nversion: [secret store version]\\nmetadata:\\n- name: [property n\", \"ame]\\nvalue: [property value]\\nAll Dapr component configuration files require a name along with an opt\", \"ional namespace value.\\nAdditionally, the type field in the spec section specifies the type of secret\", \" store component. The\\nproperties in the metadata section differ per secret store.\\nIndirectly consume\", \" Dapr secrets\\nAs mentioned earlier in this chapter, applications can also consume secrets by referen\", \"cing them in\\ncomponent configuration files. Consider a state management component that uses Redis ca\", \"che for\\nstoring state:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: eshop-basket-sta\", \"testore\\nnamespace: eshop\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- name: redisHost\\nvalue: loca\", \"lhost:6379\\n- name: redisPassword\\nvalue: e$h0p0nD@pr\\n123 CHAPTER 12 | The Dapr secrets management bui\", \"lding blockThe above configuration file contains a clear-text password for connecting to the Redis s\", \"erver.\\nHardcoded passwords are always a bad idea. Pushing this configuration file to a public reposi\", \"tory\\nwould expose the password. Storing the password in a secret store would dramatically improve th\", \"is\\nscenario.\\nThe following examples demonstrate this using several different secret stores.\\nLocal fi\", \"le\\nThe local file component is designed for development scenarios. It stores secrets on the local\\nfi\", \"lesystem inside a JSON file. Here\\u2019s an example named eshop-secrets.json. It contains a single\\nsecret\", \" - a password for Redis:\\n{\\n\\\"eShopRedisPassword\\\": \\\"e$h0p0nD@pr\\\"\\n}\\nYou place this file in a components\", \" folder that you specify when running the Dapr application.\\nThe following secret store configuration\", \" file consumes the JSON file as a secret store. It\\u2019s also placed\\nin the components folder:\\napiVersio\", \"n: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: eshop-local-secret-store\\nnamespace: eshop\\nspec:\\n\", \"type: secretstores.local.file\\nversion: v1\\nmetadata:\\n- name: secretsFile\\nvalue: ./components/eshop-se\", \"crets.json\\n- name: nestedSeparator\\nvalue: \\\":\\\"\\nThe component type is secretstore.local.file. The secr\", \"etsFile metadata element specifies the\\npath to the secrets file.\\nImportant\\nThe path to a secrets fil\", \"e can be a absolute or relative path. The relative path is based on the folder in\\nwhich the applicat\", \"ion starts. In the example, the components folder is a sub-folder of the directory that\\ncontains the\", \" .NET application.\\nFrom the application folder, start the Dapr application specifying the components\", \" path as a command-\\nline argument:\\ndapr run --app-id basket-api --components-path ./components dotne\", \"t run\\n124 CHAPTER 12 | The Dapr secrets management building blockNote\\nThis above example applies to \", \"running Dapr in self-hosted mode. For Kubernetes hosting, consider\\nusing volume mounts.\\nThe nestedSe\", \"parator in a Dapr configuration file specifies a character to flatten a JSON hierarchy.\\nConsider the\", \" following snippet:\\n{\\n\\\"redisPassword\\\": \\\"some password\\\",\\n\\\"connectionStrings\\\": {\\n\\\"customerdb\\\": \\\"some c\", \"onnection string\\\",\\n\\\"productdb\\\": \\\"some connection string\\\"\\n}\\n}\\nUsing a colon as a separator, you can r\", \"etrieve the customerdb connection-string using the key\\nconnectionStrings:customerdb.\\nNote\\nThe colon \", \": is the default separator value.\\nIn the next example, a state management configuration file referen\", \"ces the local secret store\\ncomponent to obtain the password for connecting to the Redis server:\\napiV\", \"ersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: eshop-basket-statestore\\nnamespace: eshop\\nsp\", \"ec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- name: redisHost\\nvalue: localhost:6379\\n- name: redisPas\", \"sword\\nsecretKeyRef:\\nname: eShopRedisPassword\\nkey: eShopRedisPassword\\nauth:\\nsecretStore: eshop-local-\", \"secret-store\\nThe secretKeyRef element references the secret containing the password. It replaces the\", \" earlier clear-\\ntext value. The secret name and the key name, eShopRedisPassword, reference the secr\", \"et. The name\\nof the secret management component eshop-local-secret-store is found in the auth metada\", \"ta\\nelement.\\nYou might wonder why eShopRedisPassword is identical for both the name and key in the se\", \"cret\\nreference. In the local file secret store, secrets aren\\u2019t identified with a separate name. The \", \"scenario will\\nbe different in the next example using Kubernetes secrets.\\n125 CHAPTER 12 | The Dapr s\", \"ecrets management building blockKubernetes secret\\nThis second example focuses on a Dapr application \", \"running in Kubernetes. It uses the standard secrets\\nmechanism that Kubernetes offers. Use the Kubern\", \"etes CLI (kubectl) to create a secret named eshop-\\nredis-secret that contains the password:\\nkubectl \", \"create secret generic eshopsecrets --from-literal=redisPassword=e$h0p0nD@pr -n\\neshop\\nOnce created, y\", \"ou can reference the secret in the component configuration file for state management:\\napiVersion: da\", \"pr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: eshop-basket-statestore\\nnamespace: eshop\\nspec:\\ntype: \", \"state.redis\\nversion: v1\\nmetadata:\\n- name: redisHost\\nvalue: redis:6379\\n- name: redisPassword\\nsecretKe\", \"yRef:\\nname: eshopsecrets\\nkey: redisPassword\\nauth:\\nsecretStore: kubernetes\\nThe secretKeyRef element s\", \"pecifies the name of the Kubernetes secret and the secret\\u2019s key,\\neshopsecrets, and redisPassword res\", \"pectively. The auth metadata section instructs Dapr to use the\\nKubernetes secrets management compone\", \"nt.\\nNote\\nAuth is the default value when using Kubernetes secrets and can be omitted.\\nIn a production\", \" setting, secrets are typically created as part of an automated CI/CD pipeline. Doing so\\nensures onl\", \"y people with sufficient permissions can access and change the secrets. Developers create\\nconfigurat\", \"ion files without knowing the actual value of the secrets.\\nAzure Key Vault\\nThe next example is geare\", \"d toward a real-world production scenario. It uses Azure Key Vault as the\\nsecret store. Azure Key Va\", \"ult is a managed Azure service that enables secrets to be stored securely in\\nthe cloud.\\nFor this exa\", \"mple to work, the following prerequisites must be satisfied:\\n\\u2022 You\\u2019ve secured administrative access \", \"to an Azure subscription.\\n\\u2022 You\\u2019ve provisioned an Azure Key Vault named eshopkv that holds a secret \", \"named\\nredisPassword that contains the password for connecting to the Redis server.\\n\\u2022 You\\u2019ve created \", \"service principal in Azure Active Directory.\\n126 CHAPTER 12 | The Dapr secrets management building b\", \"lock\\u2022 You\\u2019ve installed an X509 certificate for this service principal (containing both the public an\", \"d\\nprivate key) on the local filesystem.\\nNote\\nA service principal is an identity that can be used by \", \"an application to authenticate an Azure service.\\nThe service principal uses a X509 certificate. The \", \"application uses this certificate as a credential to\\nauthenticate itself.\\nThe Dapr Azure Key Vault s\", \"ecret store documentation provides step-by-step instructions to create\\nand configure a Key Vault env\", \"ironment.\\nUse Key Vault when running in self-hosted mode\\nUsing Azure Key Vault in Dapr self-hosted m\", \"ode requires the following component configuration file:\\napiVersion: dapr.io/v1alpha1\\nkind: Componen\", \"t\\nmetadata:\\nname: eshop-azurekv-secret-store\\nnamespace: eshop\\nspec:\\ntype: secretstores.azure.keyvaul\", \"t\\nversion: v1\\nmetadata:\\n- name: vaultName\\nvalue: eshopkv\\n- name: spnTenantId\\nvalue: \\\"619926af-a7c3-4\", \"e95-93ed-4ecc4e3e652b\\\"\\n- name: spnClientId\\nvalue: \\\"6cf48032-6c38-43be-9d6f-2a43ce736b09\\\"\\n- name: spn\", \"CertificateFile\\nvalue : \\\"azurekv-spn-cert.pfx\\\"\\nThe secret store type is secretstores.azure.keyvault.\", \" The metadata element provides access to the\\nKey Vault with the following properties:\\n\\u2022 The vaultNam\", \"e contains the name of the Azure Key Vault.\\n\\u2022 The spnTenantId contains the tenant ID of the service \", \"principal used to authenticate against the\\nKey Vault.\\n\\u2022 The spnClientId contains the app ID of the s\", \"ervice principal used to authenticate against the\\nKey Vault.\\n\\u2022 The spnCertificateFile contains the p\", \"ath to the certificate file for the service principal to\\nauthenticate against the Key Vault.\\nTip\\nYou\", \" can copy the service principal information from the Azure portal or Azure CLI .\\nNow the application\", \" can retrieve the Redis password from the Azure Key Vault.\\n127 CHAPTER 12 | The Dapr secrets managem\", \"ent building blockUse Key Vault when running on Kubernetes\\nConsuming Azure Key Vault with Dapr and K\", \"ubernetes also requires a service principal to authenticate\\nagainst the Azure Key Vault.\\nFirst, crea\", \"te a Kubernetes secret that contains a certificate file using the kubectl CLI tool:\\nkubectl create s\", \"ecret generic [k8s_spn_secret_name] --from-\\nfile=[pfx_certificate_file_local_path] -n eshop\\nThe comm\", \"and requires two command-line arguments:\\n\\u2022 [k8s_spn_secret_name] is the secret name in Kubernetes se\", \"cret store.\\n\\u2022 [pfx_certificate_file_local_path] is the path of X509 certificate file.\\nOnce created, \", \"you can reference the Kubernetes secret in the secret store component configuration\\nfile:\\napiVersion\", \": dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: eshop-azurekv-secret-store\\nnamespace: eshop\\nspec:\", \"\\ntype: secretstores.azure.keyvault\\nversion: v1\\nmetadata:\\n- name: vaultName\\nvalue: [your_keyvault_nam\", \"e]\\n- name: spnTenantId\\nvalue: \\\"619926af-a7c3-4e95-93ed-4ecc4e3e652b\\\"\\n- name: spnClientId\\nvalue: \\\"6cf\", \"48032-6c38-43be-9d6f-2a43ce736b09\\\"\\n- name: spnCertificate\\nsecretKeyRef:\\nname: [k8s_spn_secret_name]\\n\", \"key: [pfx_certificate_file_local_name]\\nauth:\\nsecretStore: kubernetes\\nAt this point, an application r\", \"unning in Kubernetes can retrieve the Redis password from the Azure\\nKey Vault.\\nImportant\\nIt\\u2019s critic\", \"al to keep the X509 certificate file for the service principal in a safe place. It\\u2019s best to place i\", \"t in\\na well-known folder outside the source-code repository. The configuration file can then referen\", \"ce the\\ncertificate file from this well-known folder. On a local development machine, you\\u2019re responsi\", \"ble for\\ncopying the certificate to the folder. For automated deployments, the pipeline will copy the\", \" certificate\\nto the machine where the application is deployed. It\\u2019s a best practice to use a differe\", \"nt service\\nprincipal per environment. Doing so prevents the service principal from a DEVELOPMENT env\", \"ironment\\nto access secrets in a PRODUCTION environment.\\n128 CHAPTER 12 | The Dapr secrets management\", \" building blockWhen running in Azure Kubernetes Service (AKS), it\\u2019s preferable to use an Azure Manag\", \"ed Identity for\\nauthenticating against Azure Key Vault. Managed identities are outside of the scope \", \"of this book, but\\nexplained in the Azure Key Vault with managed identities documentation.\\nScope secr\", \"ets\\nSecret scopes allow you to control which secrets your application can access. You configure scop\", \"es in\\na Dapr sidecar configuration file. The Dapr configuration documentation provides instructions \", \"for\\nscoping secrets.\\nHere\\u2019s an example of a Dapr sidecar configuration file that contains secret sco\", \"pes:\\napiVersion: dapr.io/v1alpha1\\nkind: Configuration\\nmetadata:\\nname: dapr-config\\nnamespace: eshop\\ns\", \"pec:\\ntracing:\\nsamplingRate: \\\"1\\\"\\nsecrets:\\nscopes:\\n- storeName: eshop-azurekv-secret-store\\ndefaultAcce\", \"ss: allow\\ndeniedSecrets: [\\\"redisPassword\\\", \\\"apiKey\\\"]\\nYou specify scopes per secret store. In the abo\", \"ve example, the secret store is named eshop-azurekv-\\nsecret-store. You configure access to secrets u\", \"sing the following properties:\\nProperty Value Description\\ndefaultAccess allow or Allows or denies ac\", \"cess to all secrets in the specified secret store.\\ndeny This property is optional with a default val\", \"ue of allow.\\nallowedSecrets List of Secrets specified in the array will be accessible. This property\", \" is\\nsecret keys optional.\\ndeniedSecrets List of Secrets specified in the array will NOT be accessibl\", \"e. This property is\\nsecret keys optional.\\nThe allowedSecrets and deniedSecrets properties take prece\", \"dence over the defaultAccess\\nproperty. Imagine specifying defaultAccess: allowed and an allowedSecre\", \"ts list. In this case, only\\nthe secrets in the allowedSecrets list would be accessible by the applic\", \"ation.\\nSample application: Dapr Traffic Control\\nIn Dapr Traffic Control sample app, the secrets mana\", \"gement building block is used in several places.\\nSecrets are retrieved from code and referenced by D\", \"apr component configuration files. Figure 10-2\\nshows the conceptual architecture of the Dapr Traffic\", \" Control sample application. The Dapr secrets\\nmanagement building block is used in flows marked with\", \" number 6 in the diagram:\\n129 CHAPTER 12 | The Dapr secrets management building blockFigure 10-2. Co\", \"nceptual architecture of the Dapr Traffic Control sample application.\\nThe FineCollection service use\", \"s an SMTP output binding for sending emails (see the Bindings chapter).\\nThe email component file con\", \"sumes the secrets management building block to retrieve credentials to\\nconnect to the SMTP server. T\", \"o calculate the fine for a speeding violation, the service uses a fictitious\\nFineCalculator componen\", \"t that requires a license key. It retrieves this license key from the secrets\\nmanagement building bl\", \"ock.\\nThe TrafficControl service stores vehicle information in a Redis state store (see the State man\", \"agement\\nchapter). It uses the secrets management building block for retrieving credentials to connec\", \"t to the\\nRedis server.\\nBecause the Traffic Control sample application can run in self-hosted mode or\", \" in Kubernetes, there are\\ntwo ways for specifying secrets:\\n\\u2022 A local JSON file\\n\\u2022 A Kubernetes secret\", \"\\n130 CHAPTER 12 | The Dapr secrets management building blockSecrets\\nExamine the secrets-file.yaml co\", \"mponent configuration file in the dapr/components folder:\\napiVersion: dapr.io/v1alpha1\\nkind: Compone\", \"nt\\nmetadata:\\nname: trafficcontrol-secrets\\nnamespace: dapr-trafficcontrol\\nspec:\\ntype: secretstores.lo\", \"cal.file\\nversion: v1\\nmetadata:\\n- name: secretsFile\\nvalue: ../dapr/components/secrets.json\\n- name: ne\", \"stedSeparator\\nvalue: \\\".\\\"\\nscopes:\\n- trafficcontrolservice\\n- finecollectionservice\\nThe file describes \", \"a secrets management component entitled trafficcontrol-secrets. The type\\nelement is set to local.fil\", \"e and the secretsFile to ../dapr/components/secrets.json. For self-\\nhosted mode, use a Local file co\", \"mponent. The path must be relatively specified from the folder from\\nwhich the service starts. The se\", \"crets file contains a JSON representation of the secrets:\\n{\\n\\\"state\\\":{\\n\\\"redisPassword\\\": \\\"\\\"\\n},\\n\\\"smtp\\\":\", \"{\\n\\\"user\\\": \\\"_username\\\",\\n\\\"password\\\": \\\"_password\\\"\\n},\\n\\\"finecalculator\\\":{\\n\\\"licensekey\\\": \\\"HX783-K2L7V-CRJ4\", \"A-5PN1G\\\"\\n}\\n}\\nIn the sample application the Redis server is used without a password. To connect to th\", \"e SMTP server,\\nthe credentials are _username and _password. The license key for the FineCalculator l\", \"icense key is a\\nrandomly generated string.\\nWhile secrets are stored at nested levels, the secrets ma\", \"nagement building block flattens this\\nhierarchy when the file is read. It uses a period as a level s\", \"eparator (as specified in the\\nnestedSeparator field in the component configuration file). This const\", \"ruct enables you to reference\\nsecrets with a flattened name, for example: smtp.user.\\nWhen running in\", \" Kubernetes, the secrets are specified using the built-in Kubernetes secrets store.\\nExamine the foll\", \"owing secrets.yaml Kubernetes manifest file in the k8s folder:\\napiVersion: v1\\nkind: Secret\\nmetadata:\", \"\\nname: trafficcontrol-secrets\\nnamespace: dapr-trafficcontrol\\n131 CHAPTER 12 | The Dapr secrets manag\", \"ement building blocktype: Opaque\\ndata:\\nsmtp.user: X3VzZXJuYW1l\\nsmtp.password: X3Bhc3N3b3Jk\\nfinecalcu\", \"lator.licensekey: SFg3ODMtSzJMN1YtQ1JKNEEtNVBOMUc=\\nThe component is also named trafficcontrol-secret\", \"s. Secrets are stored as Base64 encoded\\nstrings.\\nImportant\\nBase64 representations encode, but do not\", \" encrypt data. Base64 isn\\u2019t secure for production scenarios.\\nThe following paragraphs describe how s\", \"ecrets are used in the Traffic Control sample application.\\nSMTP server credentials\\nExamine the email\", \".yaml component configuration file located in the dapr/components folder:\\napiVersion: dapr.io/v1alph\", \"a1\\nkind: Component\\nmetadata:\\nname: sendmail\\nnamespace: dapr-trafficcontrol\\nspec:\\ntype: bindings.smtp\", \"\\nversion: v1\\nmetadata:\\n- name: host\\nvalue: localhost\\n- name: port\\nvalue: 4025\\n- name: user\\nsecretKey\", \"Ref:\\nname: smtp.user\\nkey: smtp.user\\n- name: password\\nsecretKeyRef:\\nname: smtp.password\\nkey: smtp.pas\", \"sword\\n- name: skipTLSVerify\\nvalue: true\\nauth:\\nsecretStore: trafficcontrol-secrets\\nscopes:\\n- finecoll\", \"ectionservice\\nThe auth section references the secrets management component named trafficcontrol-secr\", \"ets.\\nThe user and password entries in the binding metadata reference the secrets: smtp.user and\\nsmtp\", \".password respectively.\\nWhen running in Kubernetes, the built-in Kubernetes secrets store is used. T\", \"he email.yaml manifest\\nfile found in the k8s folder references the Kubernetes secret for retrieving \", \"the credentials for\\nconnecting to the smtp server:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\n132 \", \"CHAPTER 12 | The Dapr secrets management building blockmetadata:\\nname: sendmail\\nnamespace: dapr-traf\", \"ficcontrol\\nspec:\\ntype: bindings.smtp\\nversion: v1\\nmetadata:\\n- name: host\\nvalue: mailserver\\n- name: po\", \"rt\\nvalue: 25\\n- name: user\\nsecretKeyRef:\\nname: trafficcontrol-secrets\\nkey: smtp.user\\n- name: password\", \"\\nsecretKeyRef:\\nname: trafficcontrol-secrets\\nkey: smtp.password\\n- name: skipTLSVerify\\nvalue: true\\nsco\", \"pes:\\n- finecollectionservice\\nUnlike the local secrets store, the Kubernetes store doesn\\u2019t explicitly\", \" specify a secrets management\\ncomponent to use with the auth section. Instead, the default is the bu\", \"ilt-in Kubernetes secrets store.\\nRedis server credentials\\nNext, examine the statestore.yaml componen\", \"t configuration file in the dapr/components folder:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmet\", \"adata:\\nname: statestore\\nnamespace: dapr-trafficcontrol\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\", \"\\n- name: redisHost\\nvalue: localhost:6379\\n- name: redisPassword\\nsecretKeyRef:\\nname: state.redisPasswo\", \"rd\\nkey: state.redisPassword\\n- name: actorStateStore\\nvalue: \\\"true\\\"\\nauth:\\nsecretStore: trafficcontrol-\", \"secrets\\nscopes:\\n- trafficcontrolservice\\nOnce again, the auth section references the secrets manageme\", \"nt component named\\ntrafficcontrol-secrets. The redisPassword entries in the binding metadata referen\", \"ce the secret\\nstate.redisPassword.\\n133 CHAPTER 12 | The Dapr secrets management building blockFineCa\", \"lculator component license key\\nThe FineCollection service uses a component that calculates the fine \", \"based on the information of a\\nspeeding violation. This component is implemented as a domain service \", \"and is abstracted by the\\nIFineCalculator interface:\\npublic interface IFineCalculator\\n{\\npublic int Ca\", \"lculateFine(string licenseKey, int violationInKmh);\\n}\\nThe CalculateFine method expects a string cont\", \"aining a licenseKey as its first argument. This key\\nunlocks the third-party component used by the im\", \"plementation. To keep the example simple, the\\nimplementation hard-codes a series of if statements. Y\", \"ou can find the implementation in the\\nHardCodedFineCalculator class in the DomainsServices folder:\\np\", \"ublic class HardCodedFineCalculator : IFineCalculator\\n{\\npublic int CalculateFine(string licenseKey, \", \"int violationInKmh)\\n{\\nif (licenseKey != \\\"HX783-K2L7V-CRJ4A-5PN1G\\\")\\n{\\nthrow new InvalidOperationExcep\", \"tion(\\\"Invalid license-key specified.\\\");\\n}\\nint fine = 9; // default administration fee\\nif (violationI\", \"nKmh < 5 )\\n{\\nfine += 18;\\n}\\nelse if (violationInKmh >= 5 && violationInKmh < 10 )\\n{\\nfine += 31;\\n}\\n// \", \"...\\nelse if (violationInKmh == 35)\\n{\\nfine += 372;\\n}\\nelse\\n{\\n// violation above 35 KMh will be determi\", \"ned by the prosecutor\\nreturn 0;\\n}\\nreturn fine;\\n}\\n}\\nThe implementation simulates a check on the licen\", \"seKey that is passed in. The\\nCollectionController of the FineCollection service must pass in the cor\", \"rect license key argument\\nwhen calling the CalculateFine method. It retrieves the license key from t\", \"he Dapr secrets\\nmanagement building block that is exposed by the Dapr client in the Dapr SDK for .NE\", \"T. If you\\nexamine the constructor of the CollectionController, you can see the call:\\n134 CHAPTER 12 \", \"| The Dapr secrets management building block// set finecalculator component license-key\\nif (_fineCal\", \"culatorLicenseKey == null)\\n{\\nbool runningInK8s =\\nConvert.ToBoolean(Environment.GetEnvironmentVariabl\", \"e(\\\"DOTNET_RUNNING_IN_CONTAINER\\\") ??\\n\\\"false\\\");\\nvar metadata = new Dictionary<string, string> { { \\\"nam\", \"espace\\\", \\\"dapr-trafficcontrol\\\" }\\n};\\nif (runningInK8s)\\n{\\nvar k8sSecrets = daprClient.GetSecretAsync(\\n\", \"\\\"kubernetes\\\", \\\"trafficcontrol-secrets\\\", metadata).Result;\\n_fineCalculatorLicenseKey = k8sSecrets[\\\"fi\", \"necalculator.licensekey\\\"];\\n}\\nelse\\n{\\nvar secrets = daprClient.GetSecretAsync(\\n\\\"trafficcontrol-secrets\", \"\\\", \\\"finecalculator.licensekey\\\", metadata).Result;\\n_fineCalculatorLicenseKey = secrets[\\\"finecalculato\", \"r.licensekey\\\"];\\n}\\n}\\nThe code determines whether the service is running in Kubernetes or self-hosted \", \"mode. This check is\\nnecessary because a different secrets management component must be used for each\", \" situation. The\\nfirst argument of the GetSecretAsync method is the name of the Dapr component. The s\", \"econd\\nargument is the name of the secret. The metadata passed in as the third argument specifies the\", \"\\nnamespace that contains the secret. The value of the finecalculator.licensekey secret is stored in\\n\", \"a private field for later use.\\nUsing Dapr secrets management offers several benefits:\\n1. No sensitiv\", \"e information is stored in code or application configuration files.\\n2. No need to learn any new API \", \"for interacting with a secrets store.\\nSummary\\nThe Dapr secrets management building block provides ca\", \"pabilities for storing and retrieving sensitive\\nconfiguration settings like passwords and connection\", \"-strings. It keeps secrets private and prevents\\nthem from being accidentally disclosed.\\nThe building\", \" block supports several different secret stores and hides their complexity with the Dapr\\nsecrets API\", \".\\nThe Dapr .NET SDK provides a DaprClient object to retrieve secrets. It also includes a .NET\\nconfig\", \"uration provider that adds secrets to the .NET configuration system. Once loaded, you can\\nconsume th\", \"ese secrets in your .NET code.\\nYou can use secret scopes to control access to specific secrets.\\nRefe\", \"rences\\n\\u2022 Beyond the Twelve-Factor Application\\n135 CHAPTER 12 | The Dapr secrets management building \", \"block\\u2022 Dapr supported secret stores\\n136 CHAPTER 12 | The Dapr secrets management building block13\\nCH\", \"APTER\\nDapr reference application\\nOver the course of this book, you\\u2019ve learned about the foundational\", \" benefits of Dapr. You saw how\\nDapr can help you and your team construct distributed applications wh\", \"ile reducing architectural and\\noperational complexity. Along the way, you\\u2019ve had the opportunity to \", \"build some small Dapr apps.\\nNow, it\\u2019s time to explore how a more complex application can benefit fro\", \"m Dapr.\\nBut, first a little history.\\neShopOnContainers\\nSeveral years ago, Microsoft, in partnership \", \"with leading community experts, released a popular\\nguidance book, entitled .NET Microservices for Co\", \"ntainerized .NET Applications. Figure 12-1 shows the\\nbook:\\nFigure 12-1. .NET Microservices: Architec\", \"ture for Containerized .NET Applications.\\nThe book dove deep into the principles, patterns, and best\", \" practices for building distributed\\napplications. It included a full-featured microservice reference\", \" application that showcased the\\narchitectural concepts. Entitled, eShopOnContainers, the application\", \" hosts an e-Commerce storefront\\nthat sells various items, including clothing and coffee mugs. Built \", \"in .NET, the application is cross-\\nplatform and can run in either Linux or Windows containers. Figur\", \"e 12-2 shows the original eShop\\narchitecture.\\n137 CHAPTER 13 | Dapr reference applicationFigure 12-2\", \". Original ShopOnContainers reference application.\\nAs you can see, eShopOnContainers includes many m\", \"oving parts:\\n1. Three different frontend clients.\\n2. An application gateway to abstract backend serv\", \"ices from the frontend.\\n3. Several backend core microservices.\\n4. An event bus component that enable\", \"s asynchronous pub/sub messaging.\\nThe eShopOnContainers reference application has been widely accept\", \"ed across the .NET community\\nand used to model many large commercial microservice applications.\\neSho\", \"pOnDapr\\nAn updated version of eShop accompanies this book. It\\u2019s called eShopOnDapr. The update evolv\", \"es\\nthe earlier eShopOnContainers application by integrating Dapr building blocks. Figure 12-3 shows \", \"the\\nnew solution architecture:\\n[eShopOnDapr reference application architecture](#g\\ufffd\\ufffd\\ufffdr&\\ufffd<\\ufffd\\ufffdp\\ufffd\\ufffdr\\ufffdm\\u0433z\\ufffd\", \"!c(*\\ufffd-\\n\\u03ce\\ufffd9\\ufffd\\ufffd\\ufffd\\ufffd>4)\\nFigure 12-3. eShopOnDapr reference application architecture.\\nWhile eShopOnDapr foc\", \"uses on Dapr, the architecture has also been streamlined and simplified.\\n1. A Single Page Applicatio\", \"n running on Blazor WebAssembly sends user requests to an API\\ngateway.\\n2. The API gateway abstracts \", \"the backend core microservices from the frontend client. It\\u2019s\\nimplemented using Envoy, a high perfor\", \"mant, open-source service proxy. Envoy routes incoming\\n138 CHAPTER 13 | Dapr reference applicationre\", \"quests to backend microservices. Most requests are simple CRUD operations (for example, get\\nthe list\", \" of brands from the catalog) and handled by a direct call to a backend microservice.\\n3. Other reques\", \"ts are more logically complex and require multiple microservice calls to work\\ntogether. For these ca\", \"ses, eShopOnDapr implements an aggregator microservice that\\norchestrates a workflow across those mic\", \"roservices needed to complete the operation.\\n4. The core backend microservices implement the require\", \"d functionality for an e-Commerce store.\\nEach is self-contained and independent of the others. Follo\", \"wing widely accepted domain\\ndecomposition patterns, each microservice isolates a specific business c\", \"apability:\\n\\u2013 The basket service manages the customer\\u2019s shopping basket experience.\\n\\u2013 The catalog ser\", \"vice manages product items available for sale.\\n\\u2013 The identity service manages authentication and ide\", \"ntity.\\n\\u2013 The ordering service handles all aspects of placing and managing orders.\\n\\u2013 The payment serv\", \"ice transacts the customer\\u2019s payment.\\n5. Adhering to best practices, each microservice maintains its\", \" own persistent storage. The\\napplication doesn\\u2019t share a single datastore.\\n6. Finally, the event bus\", \" wraps the Dapr publish/subscribe components. It enables asynchronous\\npublish/subscribe messaging ac\", \"ross microservices. Developers can plug in any Dapr-supported\\nmessage broker component.\\nApplication \", \"of Dapr building blocks\\nIn eShopOnDapr, Dapr building blocks replace a large amount of complex, erro\", \"r-prone plumbing\\ncode.\\nFigure 12-4 shows the Dapr integration in the application.\\nFigure 12-4. Dapr \", \"integration in eShopOnDapr.\\n139 CHAPTER 13 | Dapr reference applicationThe above figure shows the Da\", \"pr building blocks (represented as green numbered boxes) that each\\neShopOnDapr service consumes.\\n1. \", \"The API gateway and web shopping aggregator services use the service invocation building\\nblock to in\", \"voke methods on the backend services.\\n2. The backend services communicate asynchronously using the p\", \"ublish & subscribe building\\nblock.\\n3. The basket service uses the state management building block to\", \" store the state of the\\ncustomer\\u2019s shopping basket.\\n4. The original eShopOnContainers demonstrates D\", \"DD concepts and patterns in the ordering\\nservice. eShopOnDapr uses the actor building block as an al\", \"ternative implementation. The turn-\\nbased access model of actors makes it easy to implement a statef\", \"ul ordering process with\\nsupport for cancellation.\\n5. The ordering service sends order confirmation \", \"e-mails using the bindings building block.\\n6. Secret management is done by the secrets building bloc\", \"k.\\nThe following sections provide more detail on how the Dapr building blocks are applied in\\neShopOn\", \"Dapr.\\nState management\\nIn eShopOnDapr, the Basket service uses the state management building block t\", \"o persist the contents\\nof the customer\\u2019s shopping basket. The original eShopOnContainers architectur\", \"e used an\\nIBasketRepository interface to read and write data for the basket service. The\\nRedisBasket\", \"Repository class provided the implementation using Redis as the underlying data store.\\nTo compare an\", \"d contrast, the original eShopOnContainers implementation is presented below:\\npublic class RedisBask\", \"etRepository : IBasketRepository\\n{\\nprivate readonly ConnectionMultiplexer _redis;\\nprivate readonly I\", \"Database _database;\\npublic RedisBasketRepository(ConnectionMultiplexer redis)\\n{\\n_redis = redis;\\n_dat\", \"abase = redis.GetDatabase();\\n}\\npublic async Task<CustomerBasket> GetBasketAsync(string customerId)\\n{\", \"\\nvar data = await _database.StringGetAsync(customerId);\\nif (data.IsNullOrEmpty)\\n{\\nreturn null;\\n}\\nret\", \"urn JsonConvert.DeserializeObject<CustomerBasket>(data);\\n}\\n// ...\\n}\\n140 CHAPTER 13 | Dapr reference \", \"applicationThis code uses the third party StackExchange.Redis NuGet package. The following steps are\", \" required\\nto load the shopping basket for a given customer:\\n1. Inject a Redis ConnectionMultiplexer \", \"into the constructor. The ConnectionMultiplexer is\\nregistered with the dependency injection framewor\", \"k in the Program.cs file:\\nservices.AddSingleton<ConnectionMultiplexer>(sp =>\\n{\\nvar settings = spGetR\", \"equiredService<IOptions<BasketSettings>>().Value;\\nvar configuration = ConfigurationOptions.Parse(set\", \"tingsConnectionString, true);\\nconfiguration.ResolveDns = true;\\nreturn ConnectionMultiplexer.Connect(\", \"configuration);\\n});\\n1. Use the ConnectionMultiplexer to create an IDatabase instance in each consumi\", \"ng class.\\n2. Use the IDatabase instance to execute a Redis StringGet call using the given customerId\", \" as the\\nkey.\\n3. Check if data is loaded from Redis; if not, return null.\\n4. Deserialize the data fro\", \"m Redis to a CustomerBasket object and return the result.\\nIn the updated eShopOnDapr reference appli\", \"cation, a new DaprBasketRepository class replaces the\\nRedisBasketRepository class:\\npublic class Dapr\", \"BasketRepository : IBasketRepository\\n{\\nprivate const string StoreName = \\\"eshop-statestore\\\";\\nprivate \", \"readonly DaprClient _daprClient;\\npublic DaprBasketRepository(DaprClient daprClient)\\n{\\n_daprClient = \", \"daprClient;\\n}\\npublic Task<CustomerBasket> GetBasketAsync(string customerId) =>\\n_daprClient.GetStateA\", \"sync<CustomerBasket>(StoreName, customerId);\\n// ...\\n}\\nThe updated code uses the Dapr .NET SDK to rea\", \"d and write data using the state management\\nbuilding block. The new steps to load the basket for a c\", \"ustomer are dramatically simplified:\\n1. Inject a DaprClient into the constructor. The DaprClient is \", \"registered with the dependency\\ninjection framework in the Program.cs`_ file.\\n2. Use the DaprClient.G\", \"etStateAsync method to load the customer\\u2019s shopping basket items from\\nthe configured state store and\", \" return the result.\\nThe updated implementation still uses Redis as the underlying data store. But, n\", \"ote how Dapr\\nabstracts the StackExchange.Redis references and complexity from the application. The a\", \"pplication\\nno longer requires a direct dependency on Redis. A Dapr configuration file is all that\\u2019s \", \"needed:\\n141 CHAPTER 13 | Dapr reference applicationapiVersion: dapr.io/v1alpha1\\nkind: Component\\nmeta\", \"data:\\nname: eshop-statestore\\nnamespace: eshop\\nspec:\\ntype: state.redis\\nversion: v1\\nmetadata:\\n- name: \", \"redisHost\\nvalue: redis:6379\\n- name: redisPassword\\nsecretKeyRef:\\nname: redisPassword\\nauth:\\nsecretStor\", \"e: eshop-secretstore\\nThe Dapr implementation also simplifies changing the underlying data store. Swi\", \"tching to Azure Table\\nStorage, for example, requires only changing the contents of the configuration\", \" file. No code changes\\nare necessary.\\nService invocation\\nThe original eShopOnContainers used a mix o\", \"f HTTP/REST and gRPC services. The use of gRPC was\\nlimited to communication between an aggregator se\", \"rvice and core backend services. Figure 12-5\\nshows the original architecture:\\nFigure 12-5. gRPC and \", \"HTTP/REST calls in eShopOnContainers.\\nNote the steps from the previous figure:\\n1. The frontend calls\", \" the API gateway using HTTP/REST.\\n142 CHAPTER 13 | Dapr reference application2. The API gateway forw\", \"ards simple CRUD (Create, Read, Update, Delete) requests directly to a core\\nbackend service using HT\", \"TP/REST.\\n3. The API gateway forwards complex requests that involve coordinated backend service calls\", \" to\\nthe web shopping aggregator service.\\n4. The aggregator service uses gRPC to call core backend se\", \"rvices.\\nIn the updated eShopOnDapr implementation, Dapr sidecars are added to the services and API\\ng\", \"ateway. Figure 12-6 show the updated architecture:\\nFigure 12-6. Updated eShop architecture using Dap\", \"r.\\nNote the updated steps from the previous figure:\\n1. The frontend still uses HTTP/REST to call the\", \" API gateway.\\n2. The API gateway forwards HTTP requests to its Dapr sidecar.\\n3. The API gateway side\", \"car sends the request to the sidecar of the aggregator or backend service.\\n4. The aggregator service\", \" uses the Dapr .NET SDK to call backend services through their sidecar\\narchitecture.\\nDapr implements\", \" calls between sidecars with gRPC. So even if you\\u2019re invoking a remote service with\\nHTTP/REST semant\", \"ics, a part of the transport is implemented using gRPC.\\nThe eShopOnDapr reference application benefi\", \"ts from the Dapr service invocation building block. The\\nbenefits also include service discovery, aut\", \"omatic mTLS, and built-in observability.\\nForward HTTP requests using Envoy and Dapr\\nBoth the origina\", \"l and updated eShop application leverage the Envoy proxy as an API gateway. Envoy\\nis an open-source \", \"proxy and communication bus that is popular across modern distributed\\napplications. Originating from\", \" Lyft, Envoy is owned and maintained by the Cloud-Native Computing\\nFoundation.\\n143 CHAPTER 13 | Dapr\", \" reference applicationIn the original eShopOnContainers implementation, the Envoy API gateway forwar\", \"ded incoming HTTP\\nrequests directly to aggregator or backend services. In the new eShopOnDapr, the E\", \"nvoy proxy\\nforwards the request to a Dapr sidecar.\\nEnvoy is configured using a YAML definition file \", \"to control the proxy\\u2019s behavior. To enable Envoy to\\nforward HTTP requests to a Dapr sidecar containe\", \"r, a dapr cluster is added to the configuration. The\\ncluster configuration contains a host that poin\", \"ts to the HTTP port on which the Dapr sidecar is\\nlistening:\\nclusters:\\n- name: dapr\\nconnect_timeout: \", \"0.25s\\ntype: strict_dns\\nhosts:\\n- socket_address:\\naddress: 127.0.0.1\\nport_value: 3500\\nThe Envoy route \", \"configuration is updated to rewrite incoming requests as calls to the Dapr sidecar\\n(pay close attent\", \"ion to the prefix_rewrite key/value pair):\\n- name: \\\"c-short\\\"\\nmatch:\\nprefix: \\\"/c/\\\"\\nroute:\\nauto_host_r\", \"ewrite: true\\nprefix_rewrite: \\\"/v1.0/invoke/catalog-api/method/\\\"\\ncluster: dapr\\nConsider a scenario wh\", \"ere the frontend client wants to retrieve a list of catalog items. The Catalog API\\nprovides an endpo\", \"int for getting the catalog items:\\n[Route(\\\"api/v1/[controller]\\\")]\\n[ApiController]\\npublic class Catal\", \"ogController : ControllerBase\\n{\\n[HttpGet(\\\"items/by_page\\\")]\\n[ProducesResponseType(typeof(PaginatedIte\", \"msViewModel), (int)HttpStatusCode.OK)]\\npublic async Task<PaginatedItemsViewModel> ItemsAsync(\\n[FromQ\", \"uery] int typeId = -1,\\n[FromQuery] int brandId = -1,\\n[FromQuery] int pageSize = 10,\\n[FromQuery] int \", \"pageIndex = 0)\\n{\\n// ...\\n}\\nFirst, the frontend makes a direct HTTP call to the Envoy API gateway.\\nGET\", \" http://<api-gateway>/c/api/v1/catalog/items\\nThe Envoy proxy matches the route, rewrites the HTTP re\", \"quest, and forwards it to the invoke API of its\\nDapr sidecar:\\nGET http://127.0.0.1:3500/v1.0/invoke/\", \"catalog-api/method/api/v1/catalog/items\\n144 CHAPTER 13 | Dapr reference applicationThe sidecar handl\", \"es service discovery and routes the request to the Catalog API sidecar. Finally, the\\nsidecar calls t\", \"he Catalog API to execute the request, fetch catalog items, and return a response:\\nGET http://localh\", \"ost/api/v1/catalog/items\\nMake aggregated service calls using the .NET SDK\\nMost calls from the eShop \", \"frontend are simple CRUD calls. The API gateway forwards them to a single\\nservice for processing. So\", \"me scenarios, however, require multiple backend services to work together\\nto complete a request. For\", \" the more complex calls, the web shopping aggregator service mediates the\\ncross service workflow. Fi\", \"gure 12-7 show the processing sequence of adding an item to your\\nshopping basket:\\nFigure 12-7. Backe\", \"nd call requiring multiple services.\\nThe aggregator service first retrieves catalog items from the C\", \"atalog API. It then validates item\\navailability and pricing. Finally, the aggregator service updates\", \" the shopping basket by calling the\\nBasket API.\\nThe aggregator service contains a BasketController t\", \"hat provides an endpoint for updating the\\nshopping basket:\\n[Route(\\\"api/v1/[controller]\\\")]\\n[Authorize\", \"]\\n[ApiController]\\npublic class BasketController : ControllerBase\\n{\\nprivate readonly ICatalogService \", \"_catalog;\\nprivate readonly IBasketService _basket;\\n[HttpPost]\\n[HttpPut]\\n[ProducesResponseType((int)H\", \"ttpStatusCode.BadRequest)]\\n[ProducesResponseType(typeof(BasketData), (int)HttpStatusCode.OK)]\\npublic\", \" async Task<ActionResult<BasketData>> UpdateAllBasketAsync(\\n[FromBody] UpdateBasketRequest data,\\n[Fr\", \"omHeader] string authorization)\\n{\\nBasketData basket;\\n145 CHAPTER 13 | Dapr reference applicationif (\", \"data.Items is null || !data.Items.Any())\\n{\\nbasket = new();\\n}\\nelse\\n{\\n// Get the item details from the\", \" catalog API.\\nvar catalogItems = await _catalog.GetCatalogItemsAsync(\\ndata.Items.Select(x => x.Produ\", \"ctId));\\nif (catalogItems == null)\\n{\\nreturn BadRequest(\\n\\\"Catalog items were not available for the spe\", \"cified items in the\\nbasket.\\\");\\n}\\n// Check item availability and prices; store results in basket obje\", \"ct.\\nbasket = CreateValidatedBasket(data.Items, catalogItems);\\n}\\n// Save the updated shopping basket.\", \"\\nawait _basket.UpdateAsync(basket, authorization.Substring(\\\"Bearer \\\".Length));\\nreturn basket;\\n}\\n// .\", \"..\\n}\\nThe UpdateAllBasketAsync method gets the Authorization header of the incoming request using a\\nF\", \"romHeader attribute. The Authorization header contains the access token that is needed to call\\nprote\", \"cted backend services.\\nAfter receiving a request to update the basket, the aggregator service calls \", \"the Catalog API to get the\\nitem details. The Basket controller uses an injected ICatalogService obje\", \"ct to make that call and\\ncommunicate with the Catalog API. The original implementation of the interf\", \"ace used gRPC to make\\nthe call. The updated implementation uses Dapr service invocation with HttpCli\", \"ent support:\\npublic class CatalogService : ICatalogService\\n{\\nprivate readonly HttpClient _httpClient\", \";\\npublic CatalogService(HttpClient httpClient)\\n{\\n_httpClient = httpClient;\\n}\\npublic Task<IEnumerable\", \"<CatalogItem>> GetCatalogItemsAsync(IEnumerable<int> ids)\\n{\\nvar requestUri = $\\\"api/v1/catalog/items/\", \"by_ids?ids={string.Join(\\\",\\\", ids)}\\\";\\nreturn _httpClient.GetFromJsonAsync<IEnumerable<CatalogItem>>(r\", \"equestUri);\\n}\\n// ...\\n}\\n146 CHAPTER 13 | Dapr reference applicationNotice how no Dapr-specific code i\", \"s required to make the service invocation call. All communication is\\ndone using the standard HttpCli\", \"ent object.\\nThe Dapr HttpClient is configured for the CatalogService class on program startup:\\nbuild\", \"er.Services.AddSingleton<ICatalogService, CatalogService>(\\n_ => new CatalogService(DaprClient.Create\", \"InvokeHttpClient(\\\"catalog-api\\\")));\\nThe other call made by the aggregator service is to the Basket AP\", \"I. It only allows authorized requests.\\nThe access token is passed along in an Authorization request \", \"header to ensure the call succeeds:\\npublic class BasketService : IBasketService\\n{\\npublic Task Update\", \"Async(BasketData currentBasket, string accessToken)\\n{\\nvar request = new HttpRequestMessage(HttpMetho\", \"d.Post, \\\"api/v1/basket\\\")\\n{\\nContent = JsonContent.Create(currentBasket)\\n};\\nrequest.Headers.Authorizat\", \"ion = new AuthenticationHeaderValue(\\\"Bearer\\\",\\naccessToken);\\nvar response = await _httpClient.SendAsy\", \"nc(request);\\nresponse.EnsureSuccessStatusCode();\\n}\\n// ...\\n}\\nIn this example too, only standard HttpC\", \"lient functionality is used to call the service. This allows\\ndevelopers who are already familiar wit\", \"h HttpClient to reuse their existing skills. It even enables\\nexisting HttpClient code to use Dapr se\", \"rvice invocation without making any changes.\\nPublish & subscribe\\nBoth eShopOnContainers and eShopOnD\", \"apr use the pub/sub pattern for communicating integration\\nevents across microservices. Integration e\", \"vents include:\\n\\u2022 When a user checks-out a shopping basket.\\n\\u2022 When a payment for an order has succeed\", \"ed.\\n\\u2022 When the grace-period of a purchase has expired.\\nNote\\nThink of an Integration Event as an even\", \"t that takes place across multiple services.\\nEventing in eShopOnContainers is based on the following\", \" IEventBus interface:\\npublic interface IEventBus\\n{\\nvoid Publish(IntegrationEvent integrationEvent);\\n\", \"void Subscribe<T, THandler>()\\nwhere TEvent : IntegrationEvent\\nwhere THandler : IIntegrationEventHand\", \"ler<T>;\\n}\\n147 CHAPTER 13 | Dapr reference applicationConcrete implementations of this interface for \", \"both RabbitMQ and Azure Service Bus are found in\\neShopOnContainers. Each implementation included a l\", \"arge amount of custom plumbing code that\\nwas complex to understand and difficult to maintain.\\nThe ne\", \"wer eShopOnDapr significantly simplifies pub/sub behavior by using Dapr. To start, the\\nIEventBus int\", \"erface was reduced to a single method:\\npublic interface IEventBus\\n{\\nTask PublishAsync(IntegrationEve\", \"nt integrationEvent);\\n}\\nPublish events\\nIn eShopOnDapr, a single DaprEventBus implementation can supp\", \"ort any Dapr-supported message\\nbroker. The following code block shows the simplified Publish method.\", \" Note how the PublishAsync\\nmethod uses the Dapr client to publish an event:\\npublic class DaprEventBu\", \"s : IEventBus\\n{\\nprivate const string DAPR_PUBSUB_NAME = \\\"pubsub\\\";\\nprivate readonly DaprClient _dapr;\", \"\\nprivate readonly ILogger _logger;\\npublic DaprEventBus(DaprClient dapr, ILogger<DaprEventBus> logger\", \")\\n{\\n_dapr = dapr;\\n_logger = logger;\\n}\\npublic async Task PublishAsync(IntegrationEvent integrationEve\", \"nt)\\n{\\nvar topicName = integrationEvent.GetType().Name;\\n_logger.LogInformation(\\n\\\"Publishing event {@E\", \"vent} to {PubsubName}.{TopicName}\\\",\\nintegrationEvent,\\nDAPR_PUBSUB_NAME,\\ntopicName);\\n// We need to ma\", \"ke sure that we pass the concrete type to PublishEventAsync,\\n// which can be accomplished by casting\", \" the event to dynamic. This ensures\\n// that all event fields are properly serialized.\\nawait _dapr.Pu\", \"blishEventAsync(DAPR_PUBSUB_NAME, topicName,\\n(object)integrationEvent);\\n}\\n}\\nAs you can see in the co\", \"de snippet, the topic name is derived from event type\\u2019s name. Because all\\neShop services use the IEv\", \"entBus abstraction, retrofitting Dapr required absolutely no change to the\\nmainline application code\", \".\\n148 CHAPTER 13 | Dapr reference applicationImportant\\nThe Dapr SDK uses System.Text.Json to seriali\", \"ze/deserialize messages. However, System.Text.Json\\ndoesn\\u2019t serialize properties of derived classes b\", \"y default. In the eShop code, an event is sometimes\\nexplicitly declared as an IntegrationEvent, the \", \"base class for integration events. This construct allows\\nthe concrete event type to be determined dy\", \"namically at run time based on business logic. As a result,\\nthe event is serialized using the type i\", \"nformation of the base class and not the derived class. To force\\nSystem.Text.Json to serialize the p\", \"roperties of both the base and derived class, the code uses\\nobject as the generic type parameter. Fo\", \"r more information, see the .NET documentation.\\nWith Dapr, pub/sub infrastructure code is dramatical\", \"ly simplified. The application doesn\\u2019t need to\\ndistinguish between message brokers. Dapr provides th\", \"is abstraction for you. If needed, you can easily\\nswap out message brokers or configure multiple mes\", \"sage broker components with no code changes.\\nSubscribe to events\\nThe earlier eShopOnContainers app c\", \"ontains SubscriptionManagers to handle the subscription\\nimplementation for each message broker. Each\", \" manager contains complex message broker-specific\\ncode for handling subscription events. To receive \", \"events, each service has to explicitly register a\\nhandler for each event-type.\\neShopOnDapr streamlin\", \"es the plumbing for event subscriptions by using Dapr ASP.NET Core\\nintegration. Each event is handle\", \"d by an action method in a controller. A Topic attribute decorates the\\naction method with the name o\", \"f the corresponding topic. Here\\u2019s a code snippet taken from the\\nPaymentService:\\n[Route(\\\"api/v1/[cont\", \"roller]\\\")]\\n[ApiController]\\npublic class IntegrationEventController : ControllerBase\\n{\\nprivate const \", \"string DAPR_PUBSUB_NAME = \\\"pubsub\\\";\\n[HttpPost(\\\"OrderStatusChangedToValidated\\\")]\\n[Topic(DAPR_PUBSUB_N\", \"AME, nameof(OrderStatusChangedToValidatedIntegrationEvent))]\\npublic Task HandleAsync(\\nOrderStatusCha\", \"ngedToValidatedIntegrationEvent integrationEvent,\\n[FromServices] OrderStatusChangedToValidatedIntegr\", \"ationEventHandler handler) =>\\nhandler.Handle(integrationEvent);\\n}\\nIn the Topic attribute, the name o\", \"f the .NET type of the event is used as the topic name. For handling\\nthe event, an event handler tha\", \"t already existed in the earlier eShopOnContainers code base is\\nresolved using dependency injection \", \"and invoked. In the previous example, messages received from\\nthe OrderStatusChangedToValidatedIntegr\", \"ationEvent topic invoke the existing\\nOrderStatusChangedToValidatedIntegrationEventHandler event hand\", \"ler. Because Dapr\\nimplements the underlying plumbing for subscriptions and message brokers, a large \", \"amount of\\noriginal code became obsolete and was removed from the code-base. Much of this code was co\", \"mplex\\nto understand and challenging to maintain.\\n149 CHAPTER 13 | Dapr reference applicationUse pub/\", \"sub components\\nWithin the eShopOnDapr repository, a deployment folder contains files for deploying t\", \"he application\\nusing different deployment modes: Docker Compose and Kubernetes. A dapr folder exists\", \" within each\\nof these folders that holds a components folder. This folder holds a file eshop-pubsub.\", \"yaml. It\\nspecifies the Dapr pub/sub component that the application will use for pub/sub behavior. As\", \" you saw\\nin the earlier code snippets, the name of the pub/sub component used is pubsub. Here\\u2019s the \", \"content\\nof the eshop-pubsub.yaml file in the deployment/compose/dapr/components folder:\\napiVersion: \", \"dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: pubsub\\nnamespace: eshop\\nspec:\\ntype: pubsub.rabbitmq\", \"\\nversion: v1\\nmetadata:\\n- name: host\\nvalue: \\\"amqp://rabbitmq:5672\\\"\\nThe configuration specifies Rabbit\", \"MQ as the underlying infrastructure. To change message brokers,\\nyou need only to configure a differe\", \"nt message broker, such as NATS or Azure Service Bus and update\\nthe yaml file. With Dapr, there are \", \"no changes to your mainline service code when switching message\\nbrokers.\\nYou can also easily use mul\", \"tiple message brokers in a single application. Many times a system will\\nhandle workloads with differ\", \"ent characteristics. One event may occur 10 times a day, but another\\nevent occurs 5,000 times per se\", \"cond. You may benefit by partitioning messaging traffic to different\\nmessage brokers. With Dapr, you\", \" can add multiple pub/sub component configurations, each with a\\ndifferent name.\\nBindings\\neShopOnDapr\", \" uses the bindings building block for sending e-mails. When a user places an order, the\\napplication \", \"sends an order confirmation e-mail using the SMTP output binding. You can find this\\nbinding in the e\", \"shop-email.yaml file in the components folder:\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata\", \":\\nname: sendmail\\nnamespace: eshop\\nspec:\\ntype: bindings.smtp\\nversion: v1\\nmetadata:\\n- name: host\\nvalue\", \": maildev\\n- name: port\\nvalue: 25\\n- name: user\\nsecretKeyRef:\\nname: Smtp.User\\n150 CHAPTER 13 | Dapr re\", \"ference applicationkey: Smtp.User\\n- name: password\\nsecretKeyRef:\\nname: Smtp.Password\\nkey: Smtp.Passw\", \"ord\\n- name: skipTLSVerify\\nvalue: true\\nauth:\\nsecretStore: eshop-secretstore\\nscopes:\\n- ordering-api\\nDa\", \"pr gets the username and password for connecting to the SMTP server from a secret reference. This\\nap\", \"proach keeps secrets outside of the configuration file. To learn more about Dapr secrets, read the\\ns\", \"ecrets building block chapter.\\nThe binding configuration specifies a binding component that can be i\", \"nvoked using the /sendmail\\nendpoint on the Dapr sidecar. Here\\u2019s a code snippet in which an email is \", \"sent whenever an order is\\nstarted:\\npublic Task Handle(OrderStartedDomainEvent notification, Cancella\", \"tionToken\\ncancellationToken)\\n{\\nvar message = CreateEmailBody(notification);\\nvar metadata = new Dicti\", \"onary<string, string>\\n{\\n[\\\"emailFrom\\\"] = \\\"eShopOn@dapr.io\\\",\\n[\\\"emailTo\\\" = notification.UserName,\\n[\\\"sub\", \"ject\\\"] = $\\\"Your eShopOnDapr order #{notification.Order.Id}\\\"\\n};\\nreturn _daprClient.InvokeBindingAsync\", \"(\\\"sendmail\\\", \\\"create\\\", message, metadata,\\ncancellationToken);\\n}\\npublic Task SendOrderConfirmationAsy\", \"nc(Order order)\\n{\\nvar message = CreateEmailBody(order);\\nreturn _daprClient.InvokeBindingAsync(\\n\\\"send\", \"mail\\\",\\n\\\"create\\\",\\nCreateEmailBody(order),\\nnew Dictionary<string, string>\\n{\\n[\\\"emailFrom\\\"] = \\\"eshoponda\", \"pr@example.com\\\",\\n[\\\"emailTo\\\"] = order.BuyerEmail,\\n[\\\"subject\\\"] = $\\\"Your eShopOnDapr Order #{order.Orde\", \"rNumber}\\\"\\n});\\n}\\nAs you can see in this example, message contains the message body. The CreateEmailBo\", \"dy method\\nsimply formats a string with the body text. The name of the binding to invoke is sendmail \", \"and the\\noperation is create. The metadata specifies the email sender, recipient, and subject for the\", \" email\\nmessage. If these values are static, they can also be included in the metadata fields in the\\n\", \"configuration file.\\n151 CHAPTER 13 | Dapr reference applicationActors\\nIn the original eShopOnContain\", \"ers solution, the Ordering service provides a great example of how to\\nuse DDD design patterns in a .\", \"NET microservice. As the updated eShopOnDapr focuses on Dapr, the\\nOrdering service now uses the acto\", \"rs building block to implement its business logic.\\nThe ordering process consists of the following st\", \"eps:\\n1. The customer submits the order. There\\u2019s a grace period before any further processing occurs.\", \"\\nDuring the grace period, the customer can cancel the order.\\n2. The system checks that there\\u2019s avail\", \"able stock.\\n3. The system processes the payment.\\n4. The system ships the order.\\nThe process is imple\", \"mented using a single OrderingProcessActor actor type. Here\\u2019s the interface for\\nthe actor:\\npublic in\", \"terface IOrderingProcessActor : IActor\\n{\\nTask SubmitAsync(\\nstring userId, string userName, string st\", \"reet, string city,\\nstring zipCode, string state, string country, CustomerBasket basket);\\nTask Notify\", \"StockConfirmedAsync();\\nTask NotifyStockRejectedAsync(List<int> rejectedProductIds);\\nTask NotifyPayme\", \"ntSucceededAsync();\\nTask NotifyPaymentFailedAsync();\\nTask<bool> CancelAsync();\\nTask<bool> ShipAsync(\", \");\\nTask<Order> GetOrderDetailsAsync();\\n}\\nThe process is started when a customer checks out some prod\", \"ucts. Upon checkout, the Basket service\\npublishes a UserCheckoutAcceptedIntegrationEvent message usi\", \"ng the Dapr pub/sub building\\nblock. The Ordering service handles the message in the OrderingProcessE\", \"ventController class and\\ncalls the SubmitAsync method of the actor:\\n[HttpPost(\\\"UserCheckoutAccepted\\\"\", \")]\\n[Topic(DaprPubSubName, \\\"UserCheckoutAcceptedIntegrationEvent\\\")]\\npublic async Task HandleAsync(Use\", \"rCheckoutAcceptedIntegrationEvent integrationEvent)\\n{\\nif (integrationEvent.RequestId != Guid.Empty)\\n\", \"{\\nvar actorId = new ActorId(integrationEvent.RequestId.ToString());\\nvar orderingProcess = _actorProx\", \"yFactory.CreateActorProxy<IOrderingProcessActor>(\\nactorId,\\nnameof(OrderingProcessActor));\\nawait orde\", \"ringProcess.SubmitAsync(integrationEvent.UserId,\\nintegrationEvent.UserName,\\n152 CHAPTER 13 | Dapr re\", \"ference applicationintegrationEvent.Street, integrationEvent.City, integrationEvent.ZipCode,\\nintegra\", \"tionEvent.State, integrationEvent.Country, integrationEvent.Basket);\\n}\\nelse\\n{\\n_logger.LogWarning(\\n\\\"I\", \"nvalid IntegrationEvent - RequestId is missing - {@IntegrationEvent}\\\",\\nintegrationEvent);\\n}\\n}\\nIn the\", \" example above, the Ordering service first uses the original request ID from the\\nUserCheckoutAccepte\", \"dIntegrationEvent message as the actor ID. The handler uses the ActorId to\\ncreate an actor proxy and\", \" invokes the SubmitAsync method. The following snippet shows the\\nimplementation of the SubmitAsync m\", \"ethod:\\npublic async Task SubmitAsync(\\nstring buyerId,\\nstring buyerEmail,\\nstring street,\\nstring city,\", \"\\nstring state,\\nstring country,\\nCustomerBasket basket)\\n{\\nvar orderState = new OrderState\\n{\\nOrderDate \", \"= DateTime.UtcNow,\\nOrderStatus = OrderStatus.Submitted,\\nDescription = \\\"Submitted\\\",\\nAddress = new Ord\", \"erAddressState\\n{\\nStreet = street,\\nCity = city,\\nState = state,\\nCountry = country\\n},\\nBuyerId = buyerId\", \",\\nBuyerEmail = buyerEmail,\\nOrderItems = basket.Items\\n.Select(item => new OrderItemState\\n{\\nProductId \", \"= item.ProductId,\\nProductName = item.ProductName,\\nUnitPrice = item.UnitPrice,\\nUnits = item.Quantity,\", \"\\nPictureFileName = item.PictureFileName\\n})\\n.ToList()\\n};\\nawait StateManager.SetStateAsync(OrderDetail\", \"sStateName, orderState);\\nawait StateManager.SetStateAsync(OrderStatusStateName, OrderStatus.Submitte\", \"d);\\nawait RegisterReminderAsync(\\nGracePeriodElapsedReminder,\\nnull,\\nTimeSpan.FromSeconds(_settings.Va\", \"lue.GracePeriodTime),\\nTimeSpan.FromMilliseconds(-1));\\n153 CHAPTER 13 | Dapr reference applicationawa\", \"it _eventBus.PublishAsync(new OrderStatusChangedToSubmittedIntegrationEvent(\\nOrderId,\\nOrderStatus.Su\", \"bmitted.Name,\\nbuyerId,\\nbuyerEmail));\\n}\\nThere\\u2019s a lot going on in the Submit method:\\n1. The method ta\", \"kes the given arguments to create an OrderState object and saves it in the actor\\nstate.\\n2. The metho\", \"d saves the current status of the process (OrderStatus.Submitted) in the actor state.\\n3. The method \", \"registers a reminder to signal the end of the grace period. Order processing is\\ndelayed until the en\", \"d of the grace period to deal with customers changing their mind.\\n4. Lastly, the method publishes an\", \" OrderStatusChangedToSubmittedIntegrationEvent to notify\\nother services of the status change.\\nWhen t\", \"he reminder for the grace period ending fires, the actor runtime calls the\\nReceiveReminderAsync meth\", \"od:\\npublic Task ReceiveReminderAsync(\\nstring reminderName, byte[] state, TimeSpan dueTime, TimeSpan \", \"period)\\n{\\nreturn reminderName switch\\n{\\nGracePeriodElapsedReminder => OnGracePeriodElapsedAsync(),\\nSt\", \"ockConfirmedReminder => OnStockConfirmedSimulatedWorkDoneAsync(),\\nStockRejectedReminder => OnStockRe\", \"jectedSimulatedWorkDoneAsync(\\nJsonConvert.DeserializeObject<List<int>>(Encoding.UTF8.GetString(state\", \"))),\\nPaymentSucceededReminder => OnPaymentSucceededSimulatedWorkDoneAsync(),\\nPaymentFailedReminder =\", \"> OnPaymentFailedSimulatedWorkDoneAsync(),\\n_ => Task.CompletedTask\\n};\\n}\\nAs shown in the snippet abov\", \"e, the ReceiveReminderAsync method handles not just the grace period\\nreminder. The actor also uses r\", \"eminders to simulate background work and introduce some delays in\\nthe ordering process. This makes t\", \"he process easier to follow in the eShopOnDapr UI where\\nnotifications are shown for each status upda\", \"te. The ReceiveReminderAsync method uses the\\nreminder name to determine which method handles the rem\", \"inder. The grace period reminder is\\nhandled by the OnGracePeriodElapsedAsync method:\\npublic async Ta\", \"sk OnGracePeriodElapsedAsync()\\n{\\nvar statusChanged = await TryUpdateOrderStatusAsync(\\nOrderStatus.Su\", \"bmitted, OrderStatus.AwaitingStockValidation);\\nif (statusChanged)\\n{\\nvar order = await StateManager.G\", \"etStateAsync<Order>(OrderDetailsStateName);\\nawait _eventBus.PublishAsync(new\\nOrderStatusChangedToAwa\", \"itingStockValidationIntegrationEvent(\\nOrderId,\\nOrderStatus.AwaitingStockValidation.Name,\\n\\\"Grace peri\", \"od elapsed; waiting for stock validation.\\\",\\n154 CHAPTER 13 | Dapr reference applicationorder.UserNam\", \"e,\\norder.OrderItems\\n.Select(orderItem => new OrderStockItem(orderItem.ProductId,\\norderItem.Units))))\", \";\\n}\\n}\\nThe OnGracePeriodElapsedAsync method first tries to update the order status to the new\\nAwaitin\", \"gStockValidation status. If that succeeds, it retrieves the order details from state and\\npublishes a\", \"n OrderStatusChangedToAwaitingStockValidationIntegrationEvent to inform other\\nservice of the status \", \"change. For example, the Category service subscribes to this event to check the\\navailable stock.\\nLet\", \"\\u2019s look at the TryUpdateOrderStatusAsync method to see under which circumstances it may fail to\\nupda\", \"te the order status:\\nprivate async Task<bool> TryUpdateOrderStatusAsync(OrderStatus expectedOrderSta\", \"tus,\\nOrderStatus newOrderStatus)\\n{\\nvar orderStatus = await\\nStateManager.TryGetStateAsync<OrderStatus\", \">(OrderStatusStateName);\\nif (!orderStatus.HasValue)\\n{\\n_logger.LogWarning(\\n\\\"Order with Id: {OrderId} \", \"cannot be updated because it doesn't exist\\\",\\nOrderId);\\nreturn false;\\n}\\nif (orderStatus.Value.Id != e\", \"xpectedOrderStatus.Id)\\n{\\n_logger.LogWarning(\\n\\\"Order with Id: {OrderId} is in status {Status} instead\", \" of expected status\\n{ExpectedStatus}\\\",\\nOrderId, orderStatus.Value.Name, expectedOrderStatus.Name);\\nr\", \"eturn false;\\n}\\nawait StateManager.SetStateAsync(OrderStatusStateName, newOrderStatus);\\nreturn true;\\n\", \"}\\nFirst, the TryUpdateOrderStatusAsync method checks whether there even is a current order status. I\", \"f\\nthere isn\\u2019t, the order doesn\\u2019t exist. This is a fail-safe that should not happen with normal appli\", \"cation\\nusage. Then, the method checks whether the current order status is the status that we expecte\", \"d.\\nRemember that the ordering process is driven by events using the Dapr pub/sub building block. Eve\", \"nt\\ndelivery uses at-least-once semantics, so a single message could be received multiple times. The \", \"order\\nstatus check ensures that even when the same message is received multiple times, it is only pr\", \"ocessed\\nonce.\\nThe other steps in the ordering process are all implemented in a very similar way to t\", \"he grace period\\nstep. In the next sections, we\\u2019ll look at some other aspects of the ordering process\", \", namely\\ncancellation and viewing order details.\\n155 CHAPTER 13 | Dapr reference applicationOrder ca\", \"ncellation\\nCustomers are allowed to cancel any order that has not been paid or shipped yet. The\\nOrde\", \"rsController class handles incoming order cancellations. It invokes the CancelAsync method on\\nthe Or\", \"deringProcessActor instance for the given order.\\npublic async Task<bool> CancelAsync()\\n{\\nvar orderSt\", \"atus = await\\nStateManager.TryGetStateAsync<OrderStatus>(OrderStatusStateName);\\nif (!orderStatus.HasV\", \"alue)\\n{\\n_logger.LogWarning(\\n\\\"Order with Id: {OrderId} cannot be cancelled because it doesn't exist\\\",\", \"\\nOrderId);\\nreturn false;\\n}\\nif (orderStatus.Value.Id == OrderStatus.Paid.Id || orderStatus.Value.Id =\", \"=\\nOrderStatus.Shipped.Id)\\n{\\n_logger.LogWarning(\\n\\\"Order with Id: {OrderId} cannot be cancelled becaus\", \"e it's in status {Status}\\\",\\nOrderId, orderStatus.Value.Name);\\nreturn false;\\n}\\nawait StateManager.Set\", \"StateAsync(OrderStatusStateName, OrderStatus.Cancelled);\\nvar order = await StateManager.GetStateAsyn\", \"c<Order>(OrderDetailsStateName);\\nawait _eventBus.PublishAsync(new OrderStatusChangedToCancelledInteg\", \"rationEvent(\\nOrderId,\\nOrderStatus.Cancelled.Name,\\n$\\\"The order was cancelled by buyer.\\\",\\norder.UserNa\", \"me));\\nreturn true;\\n}\\nThe CancelAsync method consists of the following steps:\\n1. First, the method en\", \"sures that the order exists by retrieving the current order status.\\n2. If the order exists, the meth\", \"od checks whether it\\u2019s eligible for cancellation. Any order not in the\\nPaid or Shipped state can be \", \"cancelled.\\n3. If the order can be cancelled, the order status is changed to Cancelled.\\n4. Lastly, th\", \"e order details are retrieved from state and used to publish an\\nOrderStatusChangedToCancelledIntegra\", \"tionEvent to inform the other services.\\nThe CancelAsync method is a great example of the usefulness \", \"of the turn-based access model of\\nactors. Nowhere in the method do we need to worry about multiple t\", \"hreads running at the same time.\\nTherefore, the method does not require any explicit locking mechani\", \"sms to be correct.\\n156 CHAPTER 13 | Dapr reference applicationOrder details\\nCustomers can check the \", \"status and details of their order in the eShopOnDapr UI. They can also view\\na complete history of pa\", \"st orders. Directly querying actor instances for this information is a bad idea\\nbecause of two reaso\", \"ns:\\n1. Low-latency reads cannot be guaranteed because actor operations execute serially.\\n2. Querying\", \" across actors is inefficient because each actor\\u2019s state needs to be read individually and\\ncan intro\", \"duce more unpredictable latencies.\\nTo fix this issue, eShopOnDapr uses a separate read model for any\", \" queries on order data. The read\\nmodel is stored in a separate SQL database. An ASP.NET Core control\", \"ler class named\\nUpdateOrderStatusEventController subscribes to the order status events and builds up\", \" the view\\nmodel. The same UpdateOrderStatusEventController class also sends push notifications to th\", \"e UI\\nto inform the customer of order status updates.\\nThe following snippet shows the code for handli\", \"ng the\\nOrderStatusChangedToSubmittedIntegrationEvent message:\\n[HttpPost(\\\"OrderStatusChangedToSubmitt\", \"ed\\\")]\\n[Topic(DaprPubSubName, nameof(OrderStatusChangedToSubmittedIntegrationEvent))]\\npublic async Ta\", \"sk HandleAsync(\\nOrderStatusChangedToSubmittedIntegrationEvent integrationEvent,\\n[FromServices] IOpti\", \"ons<OrderingSettings> settings,\\n[FromServices] IEmailService emailService)\\n{\\n// Gets the order detai\", \"ls from Actor state.\\nvar actorId = new ActorId(integrationEvent.OrderId.ToString());\\nvar orderingPro\", \"cess = _actorProxyFactory.CreateActorProxy<IOrderingProcessActor>(\\nactorId,\\nnameof(OrderingProcessAc\", \"tor));\\n//\\nvar actorOrder = await orderingProcess.GetOrderDetailsAsync();\\nvar readModelOrder = new Or\", \"der(integrationEvent.OrderId, actorOrder);\\n// Add the order to the read model so it can be queried f\", \"rom the API.\\n// It may already exist if this event has been handled before (at-least-once\\nsemantics)\", \".\\nreadModelOrder = await _orderRepository.AddOrGetOrderAsync(readModelOrder);\\n// Send a SignalR noti\", \"fication to the client.\\nawait SendNotificationAsync(readModelOrder.OrderNumber, integrationEvent.Ord\", \"erStatus,\\nintegrationEvent.BuyerId);\\n// Send a confirmation e-mail if enabled.\\nif (settings.Value.Se\", \"ndConfirmationEmail)\\n{\\nawait emailService.SendOrderConfirmationAsync(readModelOrder);\\n}\\n}\\nThe handle\", \"r contains the code for all the actions that must occur after an order is submitted\\nsuccessfully. Be\", \"cause the events originate from the OrderingProcessActor, we can be sure that any\\nvalidations perfor\", \"med by the actor have succeeded.\\nThe handler performs the following steps:\\n157 CHAPTER 13 | Dapr ref\", \"erence application1. First, the method creates an actor proxy and uses it to retrieve the order deta\", \"ils from the actor\\ninstance.\\n2. The method maps the order details to the read model and stores it in\", \" the database. Due to the\\nat-least-once semantics of the Dapr pub/sub building block, the order may \", \"already exist in the\\ndatabase. In that case, it will not be overwritten.\\n3. The method publishes a p\", \"ush notification for the status update using SignalR.\\n4. Lastly, if enabled, the method sends a conf\", \"irmation e-mail to the customer.\\nSubsequent order status updates are all handled equally to each oth\", \"er. The following snippet shows\\nwhat happens when the order status is updated to AwaitingStockValida\", \"tion:\\n[HttpPost(\\\"OrderStatusChangedToAwaitingStockValidation\\\")]\\n[Topic(DaprPubSubName,\\nnameof(OrderS\", \"tatusChangedToAwaitingStockValidationIntegrationEvent))]\\npublic Task HandleAsync(\\nOrderStatusChanged\", \"ToAwaitingStockValidationIntegrationEvent integrationEvent)\\n{\\n// Save the updated status in the read\", \" model and notify the client via SignalR.\\nreturn UpdateReadModelAndSendNotificationAsync(integration\", \"Event.OrderId,\\nintegrationEvent.OrderStatus, integrationEvent.Description,\\nintegrationEvent.BuyerId)\", \";\\n}\\nprivate async Task UpdateReadModelAndSendNotificationAsync(\\nGuid orderId, string orderStatus, st\", \"ring description, string buyerId)\\n{\\nvar order = await _orderRepository.GetOrderByIdAsync(orderId);\\ni\", \"f (order is not null)\\n{\\norder.OrderStatus = orderStatus;\\norder.Description = description;\\nawait _ord\", \"erRepository.UpdateOrderAsync(order);\\nawait SendNotificationAsync(order.OrderNumber, orderStatus, bu\", \"yerId);\\n}\\n}\\nIn the snippet, the handler calls the UpdateReadModelAndSendNotificationAsync helper met\", \"hod to\\nhandle the status update:\\n1. The helper method first loads the current order from the databas\", \"e.\\n2. If that succeeds, it updates the OrderStatus and Description fields and saves the updated\\nmode\", \"l back to the database.\\n3. Lastly, it sends a push notification to notify the client UI.\\nObservabili\", \"ty\\neShopOnDapr uses Zipkin to visualize distributed traces collected by Dapr. Seq aggregates the\\neSh\", \"opOnDapr application logs. The various services emit structured logging using the SeriLog logging\\nli\", \"brary. Serilog publishes log events to a construct called a sink. A sink is simply a target platform\", \" to\\nwhich Serilog writes its logging events. Many Serilog sinks are available, including one for Seq\", \". Seq is\\nthe Serilog sink used in eShopOnDapr.\\n158 CHAPTER 13 | Dapr reference applicationeShopOnDap\", \"r also includes a custom health dashboard that gives insight into the health of the eShop\\nservices. \", \"This dashboard uses the built-in health checks mechanism of ASP.NET Core. The dashboard\\nnot only pro\", \"vides the health status of the services, but also the health of the dependencies of the\\nservices, in\", \"cluding the Dapr sidecars.\\nSecrets\\nThe eShopOnDapr reference application uses the secrets building b\", \"lock for various secrets:\\n\\u2022 The password for connecting to the Redis cache.\\n\\u2022 The username and passw\", \"ord for the SMTP server.\\n\\u2022 The connection strings for the SQL databases.\\nWhen running the applicatio\", \"n using Docker Compose, the local file secret store is used. The\\ncomponent configuration file eshop-\", \"secretstore.yaml is found in the dapr/components folder of\\nthe eShopOnDapr repository:\\napiVersion: d\", \"apr.io/v1alpha1\\nkind: Component\\nmetadata:\\nname: eshop-secretstore\\nnamespace: eshop\\nspec:\\ntype: secre\", \"tstores.local.file\\nversion: v1\\nmetadata:\\n- name: secretsFile\\nvalue: ./components/eshop-secretstore.j\", \"son\\n- name: nestedSeparator\\nvalue: \\\".\\\"\\nThe configuration file references the local store file eshop-\", \"secretstore.json located in the same\\nfolder:\\n{\\n\\\"ConnectionStrings\\\": {\\n\\\"CatalogDB\\\": \\\"**********\\\",\\n\\\"Id\", \"entityDB\\\": \\\"**********\\\",\\n\\\"OrderingDB\\\": \\\"**********\\\"\\n},\\n\\\"Smtp\\\": {\\n\\\"User\\\": \\\"**********\\\",\\n\\\"Password\\\": \\\"\", \"**********\\\"\\n},\\n\\\"State\\\": {\\n\\\"RedisPassword\\\": \\\"**********\\\"\\n}\\n}\\nThe components folder is specified in th\", \"e command-line and mounted as a local folder inside the Dapr\\nsidecar container. Here\\u2019s a snippet fro\", \"m the docker-compose.override.yml file in the repository root\\nthat specifies the volume mount:\\ncatal\", \"og-api-dapr:\\ncommand: [\\\"./daprd\\\",\\n159 CHAPTER 13 | Dapr reference application\\\"-app-id\\\", \\\"catalog-api\", \"\\\",\\n\\\"-app-port\\\", \\\"80\\\",\\n\\\"-components-path\\\", \\\"/components\\\",\\n\\\"-config\\\", \\\"/configuration/eshop-config.yam\", \"l\\\"\\n]\\nvolumes:\\n- \\\"./dapr/components/:/components\\\"\\n- \\\"./dapr/configuration/:/configuration\\\"\\nThe /compo\", \"nents volume mount and --components-path command-line argument are passed into\\nthe daprd startup com\", \"mand.\\nOnce configured, other component configuration files can also reference the secrets. Here\\u2019s an\", \"\\nexample of the state store component configuration consuming secrets:\\napiVersion: dapr.io/v1alpha1\\n\", \"kind: Component\\nmetadata:\\nname: eshop-statestore\\nnamespace: eshop\\nspec:\\ntype: state.redis\\nversion: v\", \"1\\nmetadata:\\n- name: redisHost\\nvalue: redis:6379\\n- name: redisPassword\\nsecretKeyRef:\\nname: State.Redi\", \"sPassword\\nkey: State.RedisPassword\\n- name: actorStateStore\\nvalue: \\\"true\\\"\\nauth:\\nsecretStore: eshop-se\", \"cretstore\\nscopes:\\n- basket-api\\n- ordering-api\\nBenefits of applying Dapr to eShop\\nIn general, the use\", \" of Dapr building blocks adds observability and flexibility to the application:\\n1. Observability: By\", \" using the Dapr building blocks, you gain rich distributed tracing for calls\\nbetween services and to\", \" Dapr components without having to write any code. In\\neShopOnContainers, a large amount of custom lo\", \"gging is used to provide insight.\\n2. Flexibility: You can now swap out infrastructure simply by chan\", \"ging a component configuration\\nfile. No code changes are necessary.\\nHere are some more examples of b\", \"enefits offered by specific building blocks:\\n\\u2022 Service Invocation\\n\\u2013 With Dapr\\u2019s support for mTLS, se\", \"rvices now communicate through encrypted channels.\\n\\u2013 When transient errors occur, service calls are \", \"automatically retried.\\n160 CHAPTER 13 | Dapr reference application\\u2013 Automatic service discovery redu\", \"ces the amount of configuration needed for services to\\nfind each other.\\n\\u2022 Publish/Subscribe\\n\\u2013 eShopO\", \"nContainers included a large amount of custom code to support both Azure\\nService Bus and RabbitMQ. D\", \"evelopers used Azure Service Bus for production and\\nRabbitMQ for local development and testing. An I\", \"EventBus abstraction layer was\\ncreated to enable swapping between these message brokers. This layer \", \"consisted of\\napproximately 700 lines of error-prone code. The updated implementation with Dapr\\nrequi\", \"res only 35 lines of code. That\\u2019s 5% of the original lines of code! More importantly,\\nthe implementa\", \"tion is straightforward and easy to understand.\\n\\u2013 eShopOnDapr uses Dapr\\u2019s rich ASP.NET Core integrat\", \"ion to use pub/sub. You add Topic\\nattributes to ASP.NET Core controller methods to subscribe to mess\", \"ages. Therefore,\\nthere\\u2019s no need to write a separate message handler loop for each message broker.\\n\\u2013\", \" Messages routed to the service as HTTP calls enable the use of ASP.NET Core\\nmiddleware to add funct\", \"ionality, without introducing new concepts or SDKs to learn.\\n\\u2022 Bindings\\n\\u2013 The eShopOnContainers solu\", \"tion contained a to-do item for e-mailing an order\\nconfirmation to the customer. With Dapr, implemen\", \"ting email notification was as easy as\\nconfiguring a resource binding.\\n\\u2022 Actors\\n\\u2013 The actors buildin\", \"g block makes it easy to create long running, stateful workflows.\\nThanks to the turn-based access mo\", \"del, there\\u2019s no need for explicit locking mechanisms.\\n\\u2013 The complexity of the grace period implement\", \"ation is greatly reduced by using actor\\nreminders instead of polling on the database.\\nSummary\\nIn thi\", \"s chapter, you\\u2019re introduced to the eShopOnDapr reference application. It\\u2019s an evolution of the\\nwide\", \"ly popular eShopOnContainers microservice reference application. eShopOnDapr replaces a large\\namount\", \" of custom functionality with Dapr building blocks and components, dramatically simplifying\\nthe comp\", \"lexities required to build a microservices application.\\nReferences\\n\\u2022 eShopOnDapr\\n\\u2022 eShopOnContainers\", \"\\n\\u2022 .NET Microservices for Containerized .NET Applications\\n\\u2022 Architecting Cloud-Native .NET Apps for \", \"Azure\\n161 CHAPTER 13 | Dapr reference application14\\nCHAPTER\\nSummary and the road\\nahead\\nWe\\u2019re at the \", \"end of our Dapr flight. The jet plane flying at 20,000 feet from chapter 2 is on final\\napproach and \", \"about to land.\\nAs the plane taxis to the gate, let\\u2019s take a minute to review some important conclusi\", \"ons from this\\nguide:\\n\\u2022 Dapr - Dapr is a Distributed Application Runtime that streamlines how you bui\", \"ld distributed\\napplications. It exposes an architecture of building blocks and pluggable components.\", \" Dapr\\nprovides a dynamic glue that binds your application with infrastructure capabilities that exis\", \"t in\\nthe Dapr runtime. Instead of building infrastructure plumbing, you and your team focus on\\ndeliv\", \"ering business features to customers.\\n\\u2022 Open source and cross-platform - The native Dapr API can be \", \"consumed by any platform that\\nsupports HTTP or gRPC. Dapr also provides language-specific SDKs for p\", \"opular development\\nplatforms. Dapr v1.0 supports Go, Python, .NET, Java, PHP, and JavaScript.\\n\\u2022 Buil\", \"ding blocks - Dapr building blocks encapsulate distributed application functionality. At the\\ntime of\", \" this writing, Dapr supports the seven building blocks shown in figure 13-1.\\n162 CHAPTER 14 | Summar\", \"y and the road aheadFigure 13-1. Dapr building blocks.\\n\\u2022 Components - Dapr components provide the co\", \"ncrete implementation for each Dapr building\\nblock capability. They expose a common interface that e\", \"nables developers to swap out\\ncomponent implementations without changing application code. Figure 13\", \"-2 shows the\\nrelationship among components, building blocks, and your service.\\n163 CHAPTER 14 | Summ\", \"ary and the road aheadFigure 13-2. Dapr building block integration.\\n\\u2022 Sidecars - Dapr runs alongside\", \" your application in a sidecar architecture, either as a separate\\nprocess of a container. Your appli\", \"cation communicates with the Dapr APIs over HTTP and gRPC.\\nSidecars provide isolation and encapsulat\", \"ion as they aren\\u2019t part of the service, but connected to\\nit. Figure 13-3 shows a sidecar architectur\", \"e.\\nFigure 13-3. Sidecar architecture.\\n164 CHAPTER 14 | Summary and the road ahead\\u2022 Hosting environme\", \"nts Dapr has cross-platform support and can run in multiple environments.\\nAt the time of this writin\", \"g, the environments include a local self-hosted mode and Kubernetes.\\n\\u2022 eShopOnDapr - This book inclu\", \"des an accompanying reference application entitled\\neShopOnDapr. Using a popular e-commerce applicati\", \"on domain, the reference application\\ndemonstrates the usage of each building block. It\\u2019s an evolutio\", \"n of the widely popular\\neShopOnContainers, released several years ago.\\nThe road ahead\\nLooking forwar\", \"d, Dapr has the potential to have a profound impact on distributed application\\ndevelopment. What can\", \" you expect from the Dapr team and its open-source contributors?\\nAt the time of writing, the list of\", \" proposed enhancements for Dapr include:\\n\\u2022 Feature enhancements to existing building blocks:\\n\\u2013 Query\", \" capabilities in state management enabling you to retrieve multiple values.\\n\\u2013 Topic filtering in pub\", \"/sub enabling you to filter topics based on their content.\\n\\u2013 An application tracing API in observabi\", \"lity that provides tracing in the application\\ndirectly without having to bind to specific libraries.\", \"\\n\\u2013 Binding and pub/sub support for actors providing event driven capabilities to the actor\\nprogrammi\", \"ng model. Bound components will trigger events and messages invoke\\nmethods in the actor.\\n\\u2022 New build\", \"ing blocks:\\n\\u2013 Configuration API building block for reading and writing configuration data. The block\", \"\\nwill bind to providers that include Azure Configuration Manager or GCP Configuration\\nManagement.\\n\\u2013 \", \"Http scale-to-zero autoscale.\\n\\u2013 Leader election building block to provide singleton instances and lo\", \"cking semantic\\ncapabilities.\\n\\u2013 Transparent proxying building block for service invocation, enabling \", \"you to route\\nmessages based on URLs or DNS addresses at the network level.\\n\\u2013 Resiliency building blo\", \"ck (circuit breakers, bulkheads & timeouts).\\n\\u2022 Integration with frameworks and cloud native technolo\", \"gies. Some examples include:\\n\\u2013 Django\\n\\u2013 Nodejs\\n\\u2013 Express\\n\\u2013 Kyma\\n\\u2013 Midway\\n\\u2022 New language SDKs:\\n\\u2013 Java\", \"Script\\n\\u2013 RUST\\n\\u2013 C++\\n165 CHAPTER 14 | Summary and the road ahead\\u2022 New hosting platforms:\\n\\u2013 VMs\\n\\u2013 Azur\", \"e IoT Edge\\n\\u2013 Azure Stack Edge\\n\\u2013 Azure Service Fabric\\n\\u2022 Developer and operator productivity tooling:\\n\", \"\\u2013 VS Code extension.\\n\\u2013 Remote Dev Containers for local debugging a DevOps pipeline development.\\n\\u2013 Da\", \"pr operational dashboard enhancements that will provide deeper visibility into the\\noperational conce\", \"rns of managing Dapr applications.\\nDapr version 1.0 provides developers with a compelling toolbox fo\", \"r building distributed applications.\\nAs the proposed enhancement list shows, Dapr is under active de\", \"velopment with many new\\ncapabilities to come. Stay tuned to the Dapr site and Dapr announcement blog\", \" for future updates.\\n166 CHAPTER 14 | Summary and the road ahead\"]"