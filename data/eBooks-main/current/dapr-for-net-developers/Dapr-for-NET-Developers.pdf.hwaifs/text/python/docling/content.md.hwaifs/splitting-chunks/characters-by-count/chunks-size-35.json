"[\"## Dapr for .NET Developers\\n\\nForeword by Mark Russinovich, Microsoft Azure CTO and Technical Fellow\\n\", \"\\n<!-- image -->\\n\\nRobert Vettor Sander Molenkamp Edwin van Wijk\\n\\n<!-- image -->\\n\\n## EDITION v1.2\\n\\nPUB\", \"LISHED BY Microsoft Developer Division, .NET, and Azure Incubations teams A division of Microsoft Co\", \"rporation One Microsoft Way Redmond, Washington 98052-6399 Copyright \\u00a9 2023 by Microsoft Corporation\", \" All rights reserved. No part of the contents of this book may be reproduced or transmitted in any f\", \"orm or by any means without the written permission of the publisher. This book is provided 'as -is' \", \"and expresses the author's views and opinions. The views, opinions, and information expressed in thi\", \"s book, including URL and other Internet website references, may change without notice. Some example\", \"s depicted herein are provided for illustration only and are fictitious. No real association or conn\", \"ection is intended or should be inferred. Microsoft and the trademarks listed at https://www.microso\", \"ft.com on the 'Trademarks' webpage are trademarks of the Microsoft group of companies. Mac and macOS\", \" are trademarks of Apple Inc. The Docker whale logo is a registered trademark of Docker, Inc. Used b\", \"y permission. All other marks and logos are property of their respective owners. Authors: Rob Vettor\", \" , Principal Cloud Solution Architect - thinkingincloudnative.com, Microsoft Sander Molenkamp , Prin\", \"cipal Cloud Architect/Microsoft MVP - sandermolenkamp.com, Info Support Edwin van Wijk , Principal S\", \"olution Architect/Microsoft MVP - defaultconstructor.com, Info Support Participants and Reviewers: M\", \"ark Russinovich , Azure CTO and Technical Fellow, Azure Office of CTO, Microsoft Nish Anil , Senior \", \"Program Manager, .NET team, Microsoft Mark Fussell , Principal Program Manager, Azure Incubations, M\", \"icrosoft Yaron Schneider , Principal Software Engineer, Azure Incubations, Microsoft Ori Zohar , Sen\", \"ior Program Manager, Azure Incubations, Microsoft Editors: David Pine , Senior Content Developer, .N\", \"ET team, Microsoft\\n\\nMaira Wenzel , Senior Program Manager, .NET team, Microsoft\\n\\nSteve 'ardalis' Smi\", \"th , Senior Architect and Trainer, NimblePros\\n\\n## Version\\n\\nThis guide has been written to cover the \", \"Dapr 1.9 version. .NET samples are based on .NET 7 .\\n\\n## Who should use this guide\\n\\nThe audience for\", \" this guide is mainly developers, development leads, and architects who are interested in learning h\", \"ow to build applications designed for the cloud.\\n\\nA secondary audience is technical decision-makers \", \"who plan to choose whether to build their applications using a cloud-native approach.\\n\\n## How you ca\", \"n use this guide\\n\\nThis guide is available both in PDF form and online. Feel free to forward this doc\", \"ument or links to its online version to your team to help ensure common understanding of these topic\", \"s. Most of these topics benefit from a consistent understanding of the underlying principles and pat\", \"terns, as well as the trade-offs involved in decisions related to these topics. Our goal with this d\", \"ocument is to equip teams and their leaders with the information they need to make well-informed dec\", \"isions for their applications' architecture, development, and hosting.\\n\\n## Contents\\n\\n| Foreword - Da\", \"pr for .NET Developers..............................................................................\", \"..... 1                                                                      |\\n|--------------------\", \"----------------------------------------------------------------------------------------------------\", \"-----------------------------------------------------------------------|\\n| The world is distributed.\", \"....................................................................................................\", \"..... 3                                                          |\\n| Summary........................\", \"....................................................................................................\", \".........................................................7 |\\n| Dapr at 20,000 feet .................\", \"................................................................................................ 8  \", \"                                                     |\\n| Dapr and the problem it solves.............\", \"....................................................................................................\", \".........................8                     |\\n| Dapr architecture ...............................\", \"....................................................................................................\", \"..................................9      |\\n| Building blocks........................................\", \"....................................................................................................\", \".........................9         |\\n| Components...................................................\", \"....................................................................................................\", \"................11           |\\n| Sidecar architecture...............................................\", \"....................................................................................................\", \"......13               |\\n| Hosting environments.....................................................\", \"...............................................................................................14   \", \"                 |\\n| Dapr performance considerations ...............................................\", \".................................................................................. 15               \", \"           |\\n| Dapr and service meshes..............................................................\", \"..................................................................................... 16            \", \"     |\\n| Summary....................................................................................\", \".............................................................................................. 18  |\", \"\\n| References.......................................................................................\", \"....................................................................................18       |\\n| Get\", \" started with Dapr .................................................................................\", \".......................... 19                                                          |\\n| Install D\", \"apr into your local environment.....................................................................\", \"................................................ 19                              |\\n| Build your firs\", \"t Dapr application..................................................................................\", \"................................................... 19                     |\\n| Create the applicatio\", \"n...................................................................................................\", \".................................................19                  |\\n| Component configuration fil\", \"es .................................................................................................\", \"...................................... 21                      |\\n| Build a multi-container Dapr appl\", \"ication.............................................................................................\", \"....................... 23                               |\\n| Create the application.................\", \"....................................................................................................\", \"...............................23                  |\\n| Add Dapr service invocation..................\", \"....................................................................................................\", \"..................27                         |\\n| container                                          \", \"                                                                                                    \", \"                                       |\\n| Add support..............................................\", \"....................................................................................................\", \".29                              |\\n| Summary........................................................\", \"....................................................................................................\", \"...................... 35  |\\n| References...........................................................\", \"....................................................................................................\", \"............35       |\\n| Traffic Control sample application.........................................\", \"............................................. 36                                                    \", \"               |\\n| Using Dapr building blocks.......................................................\", \"........................................................................................ 39         \", \"         |\\n\\n| Hosting...............................................................................\", \"....................................................................................................\", \"...   | 40   |\\n|------------------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"---------|------|\\n| Self-hosted mode ...............................................................\", \".............................................................................................40     \", \"            |      |\\n| Kubernetes...................................................................\", \"....................................................................................................\", \"...41          |      |\\n| Summary...................................................................\", \"....................................................................................................\", \"...........       | 41   |\\n| References.............................................................\", \"....................................................................................................\", \"..........41         |      |\\n| The Dapr state management building block............................\", \"..........................................                                                          \", \"                        | 42   |\\n| What it solves...................................................\", \"....................................................................................................\", \"..................         | 42   |\\n| How it works..................................................\", \"....................................................................................................\", \".....................         | 43   |\\n| Consistency................................................\", \"....................................................................................................\", \".....................43          |      |\\n| Concurrency ............................................\", \"....................................................................................................\", \".......................45           |      |\\n| Transactions ........................................\", \"....................................................................................................\", \"...........................45          |      |\\n| Use the Dapr .NET SDK.............................\", \"....................................................................................................\", \"......................                    | 46   |\\n| ASP.NET Core integration.......................\", \"....................................................................................................\", \"..................47                         |      |\\n| State store components......................\", \"....................................................................................................\", \"...........................                     | 47   |\\n| Configuration............................\", \"....................................................................................................\", \".....................................48            |      |\\n| Key prefix strategies.................\", \"....................................................................................................\", \"...................................49                 |      |\\n| Sample application: Dapr Traffic Co\", \"ntrol ..............................................................................................\", \"......................                                   | 50   |\\n| Summary.........................\", \"....................................................................................................\", \".....................................................       | 51   |\\n| References...................\", \"....................................................................................................\", \"....................................................52         |      |\\n| The Dapr service invocatio\", \"n building block.......................................................................             \", \"                                                                  | 53   |\\n| What it solves.........\", \"....................................................................................................\", \"............................................................         | 53   |\\n| How it works........\", \"....................................................................................................\", \"...............................................................         | 53   |\\n| Use the Dapr .NET\", \" SDK................................................................................................\", \".......................................................                    | 55   |\\n| Invoke HTTP se\", \"rvices using HttpClient.............................................................................\", \".......................................55                                     |      |\\n| Invoke HTTP\", \" services using DaprClient..........................................................................\", \".........................................57                                      |      |\\n| Invoke g\", \"RPC services using DaprClient.......................................................................\", \"............................................58                                      |      |\\n| Name \", \"resolution components...............................................................................\", \"..........................................................                             | 58   |\\n| Co\", \"nfiguration.........................................................................................\", \"............................................................................58            |      |\\n|\", \" Sample application: Dapr Traffic Control ..........................................................\", \"..........................................................                                   | 59   \", \"|\\n| Summary.........................................................................................\", \".........................................................................................       | 60\", \"   |\\n| References...................................................................................\", \"........................................................................................60         |\", \"      |\\n\\n| The Dapr publish &subscribe building block...............................................\", \".....................                                                                            | 6\", \"1   |\\n|---------------------------------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------|-----\", \"-|\\n| What it solves.................................................................................\", \"........................................................................................   | 61   |\\n\", \"| How it works......................................................................................\", \".....................................................................................   | 62   |\\n| C\", \"ompeting consumers..................................................................................\", \".................................................................66                  |      |\\n| Use \", \"the Dapr .NET SDK...................................................................................\", \"....................................................................              | 66   |\\n| Pub/sub\", \" components.........................................................................................\", \".................................................................              | 68   |\\n| Configurat\", \"ion.................................................................................................\", \"....................................................................68      |      |\\n| Sample applic\", \"ation: Dapr Traffic Control ........................................................................\", \"............................................                             | 69   |\\n| Summary.........\", \"....................................................................................................\", \"..................................................................... | 71   |\\n| References.........\", \"....................................................................................................\", \"..............................................................71   |      |\\n| The Dapr bindings buil\", \"ding block.......................................................................................   \", \"                                                                | 72   |\\n| What it solves...........\", \"....................................................................................................\", \"..........................................................   | 72   |\\n| How it works................\", \"....................................................................................................\", \".......................................................   | 73   |\\n| Input bindings ................\", \"....................................................................................................\", \"...............................................73      |      |\\n| Output bindings ..................\", \"....................................................................................................\", \".........................................74         |      |\\n| Use the Dapr .NET SDK................\", \"....................................................................................................\", \"...................................              | 76   |\\n| Binding components .....................\", \"....................................................................................................\", \"..................................            | 76   |\\n| Cron binding ..............................\", \"....................................................................................................\", \"....................................77     |      |\\n| Sample application: Dapr Traffic Control .....\", \"....................................................................................................\", \"...........                             | 78   |\\n| MQTT input binding...............................\", \"....................................................................................................\", \".....................79              |      |\\n| SMTP output binding ................................\", \"....................................................................................................\", \".................81               |      |\\n| Summary................................................\", \"....................................................................................................\", \".............................. | 83   |\\n| References................................................\", \"....................................................................................................\", \".......................83   |      |\\n| The Dapr actors building block...............................\", \".............................................................                                       \", \"                         | 84   |\\n| What it solves..................................................\", \"....................................................................................................\", \"...................   | 84   |\\n| How it works.......................................................\", \"....................................................................................................\", \"................   | 85   |\\n| Turn-based access model...............................................\", \"..............................................................................................88    \", \"                |      |\\n| Timers and reminders.....................................................\", \"................................................................................................89  \", \"             |      |\\n| State persistence ..........................................................\", \"....................................................................................................\", \"89        |      |\\n| Use the Dapr .NET SDK..........................................................\", \".............................................................................................       \", \"       | 90   |\\n| Call actors from ASP.NET Core clients ............................................\", \".........................................................................93                         \", \"    |      |\\n\\n| Call non-.NET                                                                       \", \"                                                                                                    \", \"    | actors........................................................................................\", \"................................................................94   |\\n|----------------------------\", \"----------------------------------------------------------------------------------------------------\", \"-------------------------------------------------------------|--------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"--------------------------|\\n| Timers and reminders..................................................\", \"...................................................................................................9\", \"5                 |                                                                                 \", \"                                                                                   |\\n| Sample applic\", \"ation: Dapr Traffic Control ........................................................................\", \"............................................                               | 97                     \", \"                                                                                                    \", \"                                        |\\n| Summary.................................................\", \"....................................................................................................\", \".............................   | 98                                                                \", \"                                                                                                 |\\n|\", \" References.........................................................................................\", \"..................................................................................99     |          \", \"                                                                                                    \", \"                                                      |\\n| The Dapr observability building block.....\", \".........................................................................100                        \", \"                                              |                                                     \", \"                                                                                                    \", \"           |\\n| What it solves.......................................................................\", \"................................................................................................101 \", \"   |                                                                                                \", \"                                                                    |\\n| How it works................\", \"....................................................................................................\", \".....................................................101    |                                       \", \"                                                                                                    \", \"                         |\\n| Distributed tracing....................................................\", \"....................................................................................................\", \".102             |                                                                                  \", \"                                                                                  |\\n| Metrics.......\", \"....................................................................................................\", \".....................................................................109  |                         \", \"                                                                                                    \", \"                                       |\\n| Logging..................................................\", \"....................................................................................................\", \"........................111    |                                                                    \", \"                                                                                                |\\n| \", \"Health status ......................................................................................\", \"..............................................................................113       |           \", \"                                                                                                    \", \"                                                     |\\n| Dapr dashboard.............................\", \"....................................................................................................\", \".............................114             |                                                      \", \"                                                                                                    \", \"          |\\n| Use the Dapr .NET SDK.................................................................\", \"....................................................................................115             \", \"  |                                                                                                 \", \"                                                                   |\\n| Sample application: Dapr Traf\", \"fic Control ........................................................................................\", \"..........................115                              |                                        \", \"                                                                                                    \", \"                        |\\n| Summary.................................................................\", \"....................................................................................................\", \"...........117  |                                                                                   \", \"                                                                                 |\\n| References ....\", \"....................................................................................................\", \".....................................................................118 |                          \", \"                                                                                                    \", \"                                      |\\n| The Dapr secrets management building block ...............\", \".................................................119                                                \", \"                              |                                                                     \", \"                                                                                               |\\n| W\", \"hat it solves.......................................................................................\", \"................................................................................119    |            \", \"                                                                                                    \", \"                                                    |\\n| How it works................................\", \"....................................................................................................\", \".....................................120    |                                                       \", \"                                                                                                    \", \"         |\\n| Use the Dapr .NET SDK..................................................................\", \"...................................................................................121              \", \" |                                                                                                  \", \"                                                                  |\\n| Secret store components.......\", \"....................................................................................................\", \"......................................122                 |                                         \", \"                                                                                                    \", \"                       |\\n| Configuration............................................................\", \"....................................................................................................\", \"...123         |                                                                                    \", \"                                                                                |\\n| Indirectly consu\", \"me Dapr secrets.....................................................................................\", \".........................................123                            |                           \", \"                                                                                                    \", \"                                     |\\n| Local file ................................................\", \"....................................................................................................\", \".........................124 |                                                                      \", \"                                                                                              |\\n| Ku\", \"bernetes secret ....................................................................................\", \"......................................................................126             |             \", \"                                                                                                    \", \"                                                   |\\n| Azure Key Vault..............................\", \"....................................................................................................\", \".............................126           |                                                        \", \"                                                                                                    \", \"        |\\n| Scope secrets...........................................................................\", \"........................................................................................129         \", \"|                                                                                                   \", \"                                                                 |\\n| Sample application: Dapr Traffi\", \"c Control ..........................................................................................\", \"........................129                              |                                          \", \"                                                                                                    \", \"                      |\\n| Secrets ..................................................................\", \"....................................................................................................\", \"..........131 |                                                                                     \", \"                                                                               |\\n| SMTP server crede\", \"ntials .............................................................................................\", \".................................................132                   |                            \", \"                                                                                                    \", \"                                    |\\n| Redis server credentials....................................\", \"....................................................................................................\", \".......133                  |                                                                       \", \"                                                                                             |\\n\\n| Fi\", \"neCalculator component license key..................................................................\", \"................................................134                                   |\\n|-----------\", \"----------------------------------------------------------------------------------------------------\", \"------------------------------------------------------------------------------|\\n| Summary...........\", \"....................................................................................................\", \".................................................................135  |\\n| References ...............\", \"....................................................................................................\", \"..........................................................135 |\\n| Dapr reference application........\", \".........................................................................................137        \", \"                                                      |\\n| eShopOnContainers.........................\", \"....................................................................................................\", \"..............................137             |\\n| eShopOnDapr.......................................\", \"....................................................................................................\", \"............................138       |\\n| Application of Dapr building blocks.......................\", \"....................................................................................................\", \".139                          |\\n| State management..................................................\", \"....................................................................................................\", \"..140                 |\\n| Service invocation........................................................\", \"..................................................................................................14\", \"2             |\\n| Publish & subscribe...............................................................\", \"........................................................................................147         \", \"      |\\n| Bindings .................................................................................\", \"............................................................................................150   |\\n\", \"| Actors............................................................................................\", \"......................................................................................152 |\\n| Observ\", \"ability ............................................................................................\", \"........................................................................158       |\\n| Secrets ......\", \"....................................................................................................\", \"......................................................................159 |\\n| Benefits of applying D\", \"apr to eShop........................................................................................\", \"....................................160                           |\\n| Summary.......................\", \"....................................................................................................\", \".....................................................161  |\\n| References............................\", \"....................................................................................................\", \".........................................161      |\\n| Summary and the road ahead....................\", \"........................................................................162                         \", \"                                          |\\n| The road ahead........................................\", \"....................................................................................................\", \"........................165       |\\n\\n## Foreword - Dapr for .NET Developers\\n\\nWith the wave of cloud \", \"adoption underway, there is a major shift happening towards 'cloud native' development, often built \", \"with microservice-architectures. These microservices are both stateless and stateful, and run on the\", \" cloud and edge, embracing the diversity of languages and frameworks available today. This enterpris\", \"e shift is driven by both the market forces of faster time to market, and the scale and efficiencies\", \" of building services for the cloud. Even before COVID-19, cloud adoption was accelerating for enter\", \"prises, and developers were being asked to do even more to deliver on building these distributed sys\", \"tem applications. That has only accelerated since COVID-19. Developers in enterprises seek to focus \", \"on business logic, while leaning on platforms to imbue their applications with scale, resiliency, ma\", \"intainability, elasticity, and the other attributes of cloud-native architectures, which is why ther\", \"e is also shift towards serverless platforms that hide the underlying infrastructure. Developers sho\", \"uld not be expected to become distributed systems experts. This is where Dapr steps in to help you, \", \"whether you are building on infrastructure such as Kubernetes, or on a serverless platform.\\n\\nDapr is\", \" designed as an enterprise, developer-focused, microservices programming model platform wi th the ma\", \"ntra 'any language, any framework, run anywhere'. It makes building distributed applications easy an\", \"d portable across any infrastructure, from public-cloud, through hierarchical edge, and even down to\", \" single node IoT devices. It emerged from both our experiences building services in Azure and time s\", \"pent working with customers building applications on Azure Kubernetes Service and Azure Service Fabr\", \"ic. Over and over, we saw common problems that they had to address. It became clear that there was a\", \" ne ed to provide a 'library' of common microservice best practices that developers could use, not o\", \"nly in new green field applications, but also to aid in the modernization of existing applications. \", \"In the containerized, distributed, and networked cloud native world, the sidecar model has emerged a\", \"s the preferred approach, in the same way DLLs are preferred in the client/server generation. Using \", \"Dapr's sidecar and APIs give you, as a developer, all the power of distributed systems functionality\", \", with the ease of a single HTTP or gRPC local call.\\n\\nTo address the wide range of scenarios that de\", \"velopers face, Dapr provides features such as state management, service-to-service invocation, pub/s\", \"ub, and integration to external systems with I/O bindings, which are based on the triggers and bindi\", \"ngs of Azure Functions. These in turn take advantage of Dapr's component model, which allows you to \", \"'swap out', say different underlying state stores, without having to change any code. This component\", \" model makes code more portable, more flexible, and allows for experimentation of what best suits yo\", \"ur needs. Developers don't need to learn\\n\\nand incorporate service SDKs into their code, or worry abo\", \"ut authentication, secret management, retries, or conditional code that targets specific deployment \", \"environments.\\n\\nThis book shows how Dapr reduces your development time and overall code maintenance b\", \"y incrementally 'Daperizing' the canonical .NET reference application, eShop. For example, in the or\", \"iginal eShop implementation, significant amounts of code were written to abstract between Azure Serv\", \"ice Bus and RabbitMQ for publishing events between services. All this code can be discarded and simp\", \"ly replaced with Dapr's pub/sub API and component model, which had an even wider range of pub/s ub b\", \"rokers, rather than just two. Dapr's actor model, when used in the reworked eShop application, shows\", \" the ease of building long running, stateful, event driven, workflow applications with all the diffi\", \"culties of concurrency and multi-threading removed. By the end of this book, you will see the drasti\", \"c simplification that Dapr brings to your application development, and I firmly believe all develope\", \"rs embarking on a cloud native app building journey should use Dapr.\\n\\nWe publicly announced Dapr wit\", \"h the v0.1 release in Oct 2019 and now, a year and half later, I am thrilled to say that Dapr is rea\", \"dy for production usage with the v1.0 release. Getting Dapr to v1.0 has truly been a community effor\", \"t. It has been amazing to see the open-source community coalesce around Dapr and grow since it was f\", \"irst announced -from 114 contributors in October 2019 to over 700 in early 2021 - a six-fold increas\", \"e in 16 months! Contributions to the project have gone to every Dapr repo and have ranged from openi\", \"ng issues, commenting on feature proposals, providing samples, and, of course, contributing code. Th\", \"e parts of the project community members have contributed to the most include the Dapr runtime, docs\", \", CLI, SDKs, and the creation of a rich ecosystem of components. Maintaining this openness is critic\", \"al to Dapr's future.\\n\\nDapr is just getting started, though, and you should expect to see more Dapr c\", \"apabilities and more support for Dapr in Azure services. I hope that you will take advantage of Dapr\", \" to enable you to focus on your core business logic and accelerate your microservices development. I\", \" am excited to have you join us in the Dapr community on this journey at https://github.com/dapr/ an\", \"d on Discord https://aka.ms/dapr-discord.\\n\\nModern distributed systems are complex. You start with sm\", \"all, loosely coupled, independently deployable services. These services cross process and server bou\", \"ndaries. They then consume different kinds of infrastructure backing services (databases, message br\", \"okers, key vaults). Finally, these disparate pieces compose together to form an application.\\n\\nMark R\", \"ussinovich Azure CTO and Technical Fellow Microsoft\\n\\nClient app\\n\\nMobile app valzzzaral\\n\\nWeb app\\n\\nAPI\", \"\\n\\nServer app\\n\\nModules\\n\\nIdentity\\n\\nCatalog\\n\\n## The world is distributed\\n\\ndatabase\\n\\nMarketing\\n\\nLocation\", \"\\n\\nJust ask any 'cool kid': Modern, distributed systems are in, and monolithic apps are out!\\n\\nBut, it\", \"'s not just 'cool kids.' Progressive IT Leaders, corporate architects, and astute developers are ech\", \"oing these same thoughts as they explore and evaluate modern distributed applications. Many have bou\", \"ght in. They're designing new and replatforming existing enterprise applications following the princ\", \"iples, patterns, and practices of distributed microservice applications.\\n\\nBut, this evolution raises\", \" m any questions\\u2026\\n\\n- What exactly is a distributed application?\\n- Why are they gaining popularity?\\n-\", \" What are the costs?\\n- And, importantly, what are the tradeoffs?\\n\\nTo start, let's rewind and look at\", \" the past 15 years. During this period, we typically constructed applications as a single, monolithi\", \"c unit. Figure 1-1 shows the architecture.\\n\\nFigure 1-1. Monolithic architecture.\\n\\n<!-- image -->\\n\\nNo\", \"te how the modules for Ordering, Identity, and Marketing execute in a single-server process. Applica\", \"tion data is stored in a shared database. Business functionality is exposed via HTML and RESTful int\", \"erfaces.\\n\\nIn many ways, monolithic apps are straightforward . They're straightforward to:\\n\\n- Build\\n\\n\", \"Infrastructure\\n\\n- Test\\n- Deploy\\n- Troubleshoot\\n- Scale vertically (scale up)\\n\\nHowever, monolithic ar\", \"chitectures can present significant challenges.\\n\\nOver time, you may reach a point where you begin to\", \" lose control\\u2026\\n\\n- The monolith has become so overwhelmingly complicated that no single person unders\", \"tands it.\\n- You fear making changes as each brings unintended and costly side effects.\\n- New feature\", \"s/fixes become time-consuming and expensive to implement.\\n- Even the smallest change requires full d\", \"eployment of the entire application - expensive and risky.\\n- One unstable component can crash the en\", \"tire system.\\n- Adding new technologies and frameworks aren't an option.\\n- Implementing agile deliver\", \"y methodologies are difficult.\\n- Architectural erosion sets in as the code base deteriorates with ne\", \"verending 'special cases.'\\n- Eventually the consultants come in and tell you to rewrite it.\\n\\nIT prac\", \"titioners call this condition the Fear Cycle . If you've been in the technology business for any len\", \"gth of time, good chance you've experienced it. It's stressful and exhausts your IT budget. Instead \", \"of building new and innovative solutions, most of your budget is spent maintaining legacy apps.\\n\\nIns\", \"tead of fear, businesses require speed and agility . They seek an architectural style with which the\", \"y can rapidly respond to market conditions. They need to instantaneously update and individually sca\", \"le small areas of a live application.\\n\\nAn early attempt to gain speed and agility came in the form o\", \"f Service Oriented Architecture, or SOA . In this model, service consumers and service providers col\", \"laborated via middleware messaging components, often referred to as an Enterprise Service Bus, or ES\", \"B . Figure 1-2 shows the architecture.\\n\\nprovider\\n\\nConsumers\\n\\nFigure 1-2. SOA architecture.\\n\\n<!-- ima\", \"ge -->\\n\\nWith SOA, centralized service providers registered with the ESB. Business logic would be bui\", \"lt into the ESB to integrate providers and consumers. Service consumers could then find and communic\", \"ate with these providers using the ESB.\\n\\nDespite the promises of SOA, implementing this approach oft\", \"en increased complexity and introduced bottlenecks. Maintenance costs became high and ESB middleware\", \" expensive. Services tended to be large. They often shared dependencies and data storage. In the end\", \", SOAs often resulted in a 'distributed monolithic' structure with centralized services that were re\", \"sistant to change.\\n\\nNowadays, many organizations have realized speed and agility by adopting a distr\", \"ibuted microservice architectural approach to building systems. Figure 1-3 shows the same system bui\", \"lt using distributed techniques and practices.\\n\\nOrdering microservice\\n\\nAPI\\n\\nConsumers\\n\\nFigure 1-3. D\", \"istributed architecture.\\n\\n<!-- image -->\\n\\nNote how the same application is decomposed across a set o\", \"f distributed services. Each is selfcontained and encapsulates its own code, data, and dependencies.\", \" Each is deployed in a software container and managed by a container orchestrator. Instead of a sing\", \"le database shared by multiple services, each service own s a private database. Other services can't\", \" access this database directly and can only get to data that is exposed through the public API of th\", \"e service that owns it. Note how some services require a full relational database, but others, a NoS\", \"QL datastore. The basket service stores its state in a distributed key/value cache. Note how inbound\", \" traffic routes through an API Gateway service. It's responsible for directing calls to services and\", \" enforcing cross -cutting concerns. Most importantly, the application takes full advantage of the sc\", \"alability, availability, and resiliency features found in modern cloud platforms.\\n\\nBut, while distri\", \"buted services can provide agility and speed, they present a different set of challenges. Consider t\", \"he following\\u2026\\n\\n- How can distributed services discover each other and communicate synchronously?\\n\\n- \", \"How can they implement asynchronous messaging?\\n- How can they maintain contextual information across\", \" a transaction?\\n- How can they become resilient to failure?\\n- How can they scale to meet fluctuating\", \" demand?\\n- How are they monitored and observed?\\n\\nFor each of these challenges, multiple products are\", \" often available. But, shielding your application from product differences and keeping code maintain\", \"able and portable become a challenge.\\n\\nThis book introduces Dapr. Dapr is a distributed application \", \"runtime. It directly addresses many of the challenges found that come along with distributed applica\", \"tions. Looking ahead, Dapr has the potential to have a profound impact on distributed application de\", \"velopment.\\n\\n## Summary\\n\\nIn this chapter, we discussed the adoption of distributed applications. We c\", \"ontrasted a monolithic system approach with that of distributed services. We pointed out many of the\", \" common challenges when considering a distributed approach.\\n\\nNow, sit back, relax, and let us introd\", \"uce you the new world of Dapr.\\n\\n## Dapr at 20,000 feet\\n\\nIn chapter 1, we discussed the appeal of dis\", \"tributed microservice applications. But, we also pointed out that they dramatically increase archite\", \"ctural and operational complexity. With that in mind, the question becomes, how can you 'have your c\", \"ake' and 'eat it too?'. That is, how can you take advantage of the agility of distributed architectu\", \"re, and minimize its complexity?\\n\\nDapr, or Distributed Application Runtime , is a new way to build m\", \"odern distributed applications.\\n\\nWhat started as a prototype has evolved into a highly successful op\", \"en-source project. Its sponsor, Microsoft, has closely partnered with customers and the open-source \", \"community to design and build Dapr. The Dapr project brings together developers from all backgrounds\", \" to solve some of the toughest challenges of developing distributed applications.\\n\\nThis book looks a\", \"t Dapr from the viewpoint of a .NET developer. In this chapter, you'll build a conceptual understand\", \"ing of Dapr and how it works. Later on, we present practical, hands-on instruction on how you can us\", \"e Dapr in your applications.\\n\\nImagine flying in a jet at 20,000 feet. You look out the window and se\", \"e the landscape below from a wide perspective. Let's do the same for Dapr. Visualize yourself flying\", \" over Dapr at 20,000 feet. W hat would you see?\\n\\n## Dapr and the problem it solves\\n\\nDapr addresses a\", \" large challenge inherent in modern distributed applications: Complexity .\\n\\nThrough an architecture \", \"of pluggable components, Dapr greatly simplifies the plumbing behind distributed applications. It pr\", \"ovides a dynamic glue that binds your application with infrastructure capabilities from the Dapr run\", \"time.\\n\\nConsider a requirement to make one of your services stateful? What would be your design. You \", \"could write custom code that targets a state store such as Redis Cache. However, Dapr provides state\", \" management capabilities out-of-the-box. Your service invokes the Dapr state management building blo\", \"ck that dynamically binds to a state store component via a Dapr component configuration yaml file. D\", \"apr ships with several pre-built state store components, including Redis. With this model, your serv\", \"ice delegates state management to the Dapr runtime. Your service has no SDK, library, or direct refe\", \"rence to the underlying component. You can even change state stores, say, from Redis to MySQL or Cas\", \"sandra, with no code changes.\\n\\nFigure 2-1 shows Dapr from 20,000 feet.\\n\\ndapr\\n\\nAny code or framework.\", \"..\\n\\n=GO\\n\\nApplication code\\n\\nMicroservices written in nodeo\\n\\npython\\n\\n.NET\\n\\n\\u2192 lava\\n\\nFigure 2-1. Dapr at\", \" 20,000 feet.\\n\\n<!-- image -->\\n\\nIn the top row of the figure, note how Dapr provides language-specifi\", \"c SDKs for popular development platforms. Dapr v1.0 includes support for Go, Node.js, Python, .NET, \", \"Java, and JavaScript. This book focuses on the Dapr .NET SDK, which also provides direct support for\", \" ASP.NET Core integration.\\n\\nWhile language-specific SDKs enhance the developer experience, Dapr is p\", \"latform agnostic. Under the hood, Dapr's programming model exposes capabilities through standard HTT\", \"P/gRPC communication protocols. Any programming platform can call Dapr via its native HTTP and gRPC \", \"APIs.\\n\\nThe blue boxes across the center of the figure represent the Dapr building blocks. Each expos\", \"es a distributed application capability that your application can consume.\\n\\nThe bottom row highlight\", \"s the portability of Dapr and the diverse environments across which it can run.\\n\\n## Dapr architectur\", \"e\\n\\nAt this point, the jet turns around and flies back over Dapr, descending in altitude, giving you \", \"a closer look at how Dapr works.\\n\\n## Building blocks\\n\\nFrom the new perspective, you see a more detai\", \"led view of the Dapr building blocks .\\n\\nA building block encapsulates a distributed infrastructure c\", \"apability. You can access the functionality through the HTTP or gRPC APIs. Figure 2-2 shows the avai\", \"lable blocks for Dapr v 1.0.\\n\\nState management\\n\\nPublish &amp;\\n\\nsubscribe\\n\\nBindings\\n\\nExtensibility\\n\\nF\", \"igure 2-2. Dapr building blocks.\\n\\n<!-- image -->\\n\\nThe following table describes the infrastructure s\", \"ervices provided by each block.\\n\\n| Building block        | Description                              \", \"                                                                  |\\n|-----------------------|-------\", \"----------------------------------------------------------------------------------------------------\", \"-|\\n| State management      | Support contextual information for long running stateful services.     \", \"                                    |\\n| Service invocation    | Invoke direct, secure service-to-ser\", \"vice calls using platform agnostic protocols and well-known endpoints. |\\n| Publish and subscribe | I\", \"mplement secure, scalable pub/sub messaging between services.                                       \", \"      |\\n\\nService invocation\\n\\nDapr API\\n\\nHTTP /\\n\\ngRPC\\n\\nYour service\\n\\n| Building block   | Description \", \"                                                                             |\\n|------------------|-\", \"-----------------------------------------------------------------------------------------|\\n| Binding\", \"s         | Trigger code from events raised by external resources with bi-directional communication.\", \" |\\n| Observability    | Monitor and measure message calls across networked services.                \", \"             |\\n| Secrets          | Securely access external secret stores.                         \", \"                         |\\n| Actors           | Encapsulate logic and data in reusable actor objects\", \".                                    |\\n\\nBuilding blocks abstract the implementation of distributed a\", \"pplication capabilities from your services. Figure 2-3 shows this interaction.\\n\\nFigure 2-3. Dapr bui\", \"lding block integration.\\n\\n<!-- image -->\\n\\nBuilding blocks invoke Dapr components that provide the co\", \"ncrete implementation for each resource. The code for your service is only aware of the building blo\", \"ck. It takes no dependencies on external SDKs or libraries - Dapr handles the plumbing for you. Each\", \" building block is independent. You can use one, some, or all of them in your application. As a valu\", \"e-add, Dapr building blocks bake in industry best practices including comprehensive observability.\\n\\n\", \"We provide detailed explanation and code samples for each Dapr building block in the upcoming chapte\", \"rs. At this point, the jet descends even more. From the new perspective, you now have a closer look \", \"at the Dapr components layer.\\n\\n## Components\\n\\nWhile building blocks expose an API to invoke distribu\", \"ted application capabilities, Dapr components provide the concrete implementation to make it happen.\", \"\\n\\nConsider, the Dapr state store component. It provides a uniform way to manage state for CRUD opera\", \"tions. Without any change to your service code, you could switch between any of the following Dapr s\", \"tate components:\\n\\n- AWS DynamoDB\\n- Aerospike\\n- Azure Blob Storage\\n- Azure CosmosDB\\n- Azure Table Sto\", \"rage\\n- Cassandra\\n- Cloud Firestore (Datastore mode)\\n- CloudState\\n- Couchbase\\n- Etcd\\n- HashiCorp Cons\", \"ul\\n- Hazelcast\\n- Memcached\\n- MongoDB\\n- PostgreSQL\\n- Redis\\n- RethinkDB\\n- SQL Server\\n- Zookeeper\\n\\nEach\", \" component provides the necessary implementation through a common state management interface:\\n\\n```\\nt\", \"ype Store interface { Init(metadata Metadata) error Delete(req *DeleteRequest) error BulkDelete(req \", \"[]DeleteRequest) error Get(req *GetRequest) (*GetResponse, error) Set(req *SetRequest) error BulkSet\", \"(req []SetRequest) error }\\n```\\n\\n<!-- image -->\\n\\nPerhaps you start with Azure Redis Cache as your sta\", \"te store. You specify it with the following configuration:\\n\\n:::{custom-style=CodeBox} yaml  apiVersi\", \"on: dapr.io/v1alpha1  kind: Component  metadata:    name: statestore    namespace: default  spec:   \", \" type: state.redis    version: v1    metadata:    - name: redisHost value: &lt;HOST&gt;    - name: r\", \"edisPassword      value: &lt;PASSWORD&gt;    - name: enableTLS      value: &lt;bool&gt; # Optional. \", \"Allowed: true, false.    - name: failover      value: &lt;bool&gt; # Optional. Allowed: true, false.\", \" :::\\n\\nIn the spec section, you configure Dapr to use the Redis Cache for state management. The secti\", \"on also contains component-specific metadata. In this case, you can use it to configure additional R\", \"edis settings.\\n\\nAt a later time, the application is ready to go to production. For the production en\", \"vironment, you may want to change your state management to Azure Table Storage. Azure Table Storage \", \"provides state management capabilities that are affordable and highly durable.\\n\\nAt the time of this \", \"writing, the following component types are provided by Dapr:\\n\\n| Component         | Description     \", \"                                                                                                    \", \"                      |\\n|-------------------|-------------------------------------------------------\", \"------------------------------------------------------------------------------------|\\n| Service disc\", \"overy | Used by the service invocation building block to integrate with the hosting environment to p\", \"rovide service-to-service discovery.          |\\n| State             | Provides a uniform interface t\", \"o interact with a wide variety of state store implementations.                                      \", \"        |\\n| Pub/sub           | Provides a uniform interface to interact with a wide variety of mess\", \"age bus implementations.                                              |\\n| Bindings          | Provid\", \"es a uniform interface to trigger application events from external systems and invoke external syste\", \"ms with optional data payloads. |\\n| Middleware        | Allows custom middleware to plug into the re\", \"quest processing pipeline and invoke additional actions on a request or response.             |\\n| Se\", \"cret stores     | Provides a uniform interface to interact with external secret stores, including cl\", \"oud, edge, commercial, open-source services.            |\\n\\nAs the jet completes its fly over of Dapr\", \", you look back once more and can see how it connects together.\\n\\n## Sidecar architecture\\n\\nDapr expos\", \"es its building blocks and components through a sidecar architecture. A sidecar enables Dapr to run \", \"in a separate memory process or separate container alongside your service. Sidecars provide isolatio\", \"n and encapsulation as they aren't part of the service, but connected to it. This separation enables\", \" each to have its own runtime environment and be built upon different programming platforms. Figure \", \"2-4 shows a sidecar pattern.\\n\\nSidecar\\n\\nDapr API\\n\\ndapr\\n\\nComponent\\n\\n(Redis Cache)\\n\\nFigure 2-4. Sidecar\", \" architecture.\\n\\n<!-- image -->\\n\\nThis pattern is named Sidecar because it resembles a sidecar attache\", \"d to a motorcycle. In the previous figure, note how the Dapr sidecar is attached to your service to \", \"provide distributed application capabilities.\\n\\n## Hosting environments\\n\\nDapr has cross-platform supp\", \"ort and can run in many different environments. These environments include Kubernetes, a group of VM\", \"s, or edge environments such as Azure IoT Edge.\\n\\nFor local development, the easiest way to get start\", \"ed is with self-hosted mode. In self-hosted mode, the microservices and Dapr sidecars run in separat\", \"e local processes without a container orchestrator such as Kubernetes. For more information, see dow\", \"nload and install the Dapr CLI.\\n\\nFigure 2-5 shows an application and Dapr hosted in two separate mem\", \"ory processes communicating via HTTP or gRPC.\\n\\nHTTP /\\n\\nPrimary service\\n\\nYour\\n\\nPod\\n\\nContainer\\n\\nApplic\", \"ation\\n\\nCode\\n\\nApplication\\n\\nService\\n\\nInvocation\\n\\nPub/Sub\\n\\nState\\n\\nManagement\\n\\nSecrets\\n\\n@ Container\\n\\nFig\", \"ure 2-5. Self-hosted Dapr sidecar.\\n\\n<!-- image -->\\n\\nBy default, Dapr installs Docker containers for \", \"Redis and Zipkin to provide default state management and observability. If you don't want to install\", \" Docker on your local machine, you can even run Dapr in self-hosted mode without any Docker containe\", \"rs. However, you must install default components such as Redis for state management and pub/sub manu\", \"ally.\\n\\nDapr also runs in containerized environments, such as Kubernetes. Figure 2-6 shows Dapr runni\", \"ng in a separate side-car container along with the application container in the same Kubernetes pod.\", \"\\n\\nFigure 2-6. Kubernetes-hosted Dapr sidecar.\\n\\n<!-- image -->\\n\\n## Dapr performance considerations\\n\\nA\", \"s you've seen, Dapr exposes a sidecar architecture to decouple your application from distributed app\", \"lication capabilities. Invoking a Dapr operation requires at least one out-of-process network call. \", \"Figure 2-7 presents an example of a Dapr traffic pattern.\\n\\ndapr\\n\\nApp\\n\\n\\\"frontend\\\"\\n\\nApp\\n\\n\\\"backend\\\"\\n\\nda\", \"pr\\n\\nSidecar\\n\\nFigure 2-7. Dapr traffic patterns.\\n\\n<!-- image -->\\n\\nLooking at the previous figure, one\", \" might question the latency and overhead incurred for each call.\\n\\nThe Dapr team has invested heavily\", \" in performance. A tremendous amount of engineering effort has gone into making Dapr efficient. Call\", \"s between Dapr sidecars are always made with gRPC, which delivers high performance and small binary \", \"payloads. In most cases, the additional overhead should be sub-millisecond.\\n\\nTo increase performance\", \", developers can call the Dapr building blocks with gRPC.\\n\\ngRPC is a modern, high-performance framew\", \"ork that evolves the age-old remote procedure call (RPC) protocol. gRPC uses HTTP/2 for its transpor\", \"t protocol, which provides significant performance enhancements over HTTP RESTFul service, including\", \":\\n\\n- Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1\", \" limits processing to one request/response message at a time.\\n- Bidirectional full-duplex communicat\", \"ion for sending both client requests and server responses simultaneously.\\n- Built-in streaming enabl\", \"ing requests and responses to asynchronously stream large data sets.\\n\\nTo learn more, check out the g\", \"RPC overview from the Architecting Cloud-Native .NET Apps for Azure eBook.\\n\\n## Dapr and service mesh\", \"es\\n\\nService mesh is another rapidly evolving technology for distributed applications.\\n\\nA service mes\", \"h is a configurable infrastructure layer with built-in capabilities to handle service-toservice comm\", \"unication, resiliency, load balancing, and telemetry capture. It moves the responsibility for these \", \"concerns out of the services and into the service mesh layer. Like Dapr, a service mesh also follows\", \" a sidecar architecture.\\n\\nFigure 2-8 shows an application that implements service mesh technology.\\n\\n\", \"microservice\\n\\nSidecar\\n\\nSidecar microservice\\n\\nFigure 2-8. Service mesh with a side car.\\n\\n<!-- image -\", \"->\\n\\nThe previous figure shows how messages are intercepted by a sidecar proxy that runs alongside ea\", \"ch service. Each proxy can be configured with traffic rules specific to the service. It understands \", \"messages and can route them across your services and the outside world.\\n\\nSo the question becomes, 'I\", \"s Dapr a service mesh?'.\\n\\nWhile both use a sidecar architecture, each technology has a different pur\", \"pose. Dapr provides distributed application features. A service mesh provides a dedicated network in\", \"frastructure layer.\\n\\nAs each works at a different level, both can work together in the same applicat\", \"ion. For example, a service mesh could provide networking communication between services. Dapr could\", \" provide application services such as state management or actor services.\\n\\nFigure 2-9 shows an appli\", \"cation that implements both Dapr and service mesh technology.\\n\\nmicroservice microservice\\n\\nlinkerd\\n\\nS\", \"ervice A\\n\\nService mesh\\n\\nService B\\n\\nFigure 2-9. Dapr and service mesh together.\\n\\n<!-- image -->\\n\\nThe \", \"Dapr online documentation cover Dapr and service mesh integration.\\n\\n## Summary\\n\\nThis chapter introdu\", \"ced you to Dapr, a Distributed Application Runtime.\\n\\nDapr is an open-source project sponsored by Mic\", \"rosoft with close collaboration from customers and the open-source community.\\n\\nAt its core, Dapr hel\", \"ps reduce the inherent complexity of distributed microservice applications. It's built upon a concep\", \"t of building block APIs. Dapr building blocks expose common distributed application capabilities, s\", \"uch as state management, service-to-service invocation, and pub/sub messaging. Dapr components lie b\", \"eneath the building blocks and provide the concrete implementation for each capability. Applications\", \" bind to various components through configuration files.\\n\\nIn the next chapters, we present practical\", \", hands-on instruction on how to use Dapr in your applications.\\n\\n## References\\n\\n- Dapr documentation\", \"\\n- Learning Dapr\\n- .NET Microservices: Architecture for Containerized .NET applications\\n- Architecti\", \"ng Cloud-Native .NET Apps for Azure\\n\\n## Get started with Dapr\\n\\nIn the first two chapters, you learne\", \"d basic concepts about Dapr. It's time to take it for a test drive . This chapter will guide you thr\", \"ough preparing your local development environment and building two Dapr .NET applications.\\n\\n## Insta\", \"ll Dapr into your local environment\\n\\nYou'll start by installing Dapr on your development computer. O\", \"nce complete, you can build and run Dapr applications in self-hosted mode.\\n\\n1. Install the Dapr CLI.\", \" It enables you to launch, run, and manage Dapr instances. It also provides debugging support.\\n2. In\", \"stall Docker Desktop . If you're running on Windows, mak e sure that Docker Desktop for Windows is c\", \"onfigured to use Linux containers. [!NOTE] By default, Dapr uses Docker containers to provide you th\", \"e best out-of-the-box\\n3. experience. To run Dapr outside of Docker, you can skip this step and execu\", \"te a slim initialization. The examples in this chapter require you use Docker containers.\\n3. Initial\", \"ize Dapr. This step sets up your development environment by installing the latest Dapr binaries and \", \"container images.\\n4. Install the .NET 7 SDK.\\n\\nNow that Dapr is installed, it's time to build your fi\", \"rst Dapr application!\\n\\n## Build your first Dapr application\\n\\nYou'll start by building a simple .NET \", \"Console application that consumes the Dapr state management building block.\\n\\n## Create the applicati\", \"on\\n\\n1. Open up the command shell or terminal of your choice. You might consider the terminal capabil\", \"ities in Visual Studio Code. Navigate to the root folder in which you want to build your application\", \". Once there, enter the following command to create a new .NET Console application:\\n\\ndotnet new cons\", \"ole -o DaprCounter\\n\\nThe command scaffolds a simple \\\"Hello World\\\" .NET application.\\n\\n1. Then, navigat\", \"e into the new directory created by the previous command:\\n\\n## cd DaprCounter\\n\\n1. Run the newly creat\", \"ed application using the dotnet run command. Doing so writes 'Hello World!' to the console screen:\\n\\n\", \"```\\ndotnet run\\n```\\n\\n## Add Dapr State Management\\n\\nNext, you'll use the Dapr state management buildin\", \"g block to implement a stateful counter in the program.\\n\\nYou can invoke Dapr APIs across any develop\", \"ment platform using Dapr's native support for HTTP and gRPC. However, .NET Developers will find the \", \"Dapr .NET SDK more natural and intuitive. It provides a strongly typed .NET client to call the Dapr \", \"APIs. The .NET SDK also tightly integrates with ASP.NET Core.\\n\\n1. From the terminal window, add the \", \"Dapr.Client NuGet package to your application:\\n1. Open the Program.cs file in your favorite editor a\", \"nd update its contents to the following code:\\n\\n```\\ndotnet add package Dapr.Client\\n```\\n\\n```\\nusing Dap\", \"r.Client const string storeName = \\\"statestore\\\"; const string key = \\\"counter\\\" var daprClient = new Da\", \"prClientBuilder().Build(); var counter = await daprClient.GetStateAsync<int>(storeName, key) while (\", \" true ) { Console.WriteLine($\\\"Counter = {counter++}\\\") await daprClient.SaveStateAsync(storeName, key\", \", counter); await Task.Delay(1000); }\\n```\\n\\nThe updated code implements the following steps:\\n\\n- First\", \" a new [`DaprClient`]{custom-style=Code} instance is instantiated. This class enables you to interac\", \"t with the Dapr sidecar.\\n- From the state store, [`DaprClient.GetStateAsync`]{custom-style=Code} fet\", \"ches the value for the [`counter`]{custom-style=Code} key. If the key doesn't exist, the default val\", \"ue for [`int`]{custom-style=Code} (which is [`0`]{custom-style=Code}) is returned.\\n- The code then i\", \"terates, writing the [`counter`]{custom-style=Code} value to the console and saving an incremented v\", \"alue to the state store.\\n1. The Dapr CLI run command starts the application. It invokes the underlyi\", \"ng Dapr runtime and enables both the application and Dapr sidecar to run together. If you omit the a\", \"pp-id , Dapr will generate a unique name for the application. The final segment of the command, dotn\", \"et run , instructs the Dapr runtime to run the .NET application.\\n\\n[!IMPORTANT] Care must be taken to\", \" always pass an explicit app-id parameter when consuming the state management building block. The bl\", \"ock uses the application id value as a prefix for its\\n\\nstate key for each key/value pair. If the app\", \"lication id changes, you can no longer access the previously stored state.\\n\\nNow run the application \", \"with the following command:\\n\\n```\\ndapr run --app-id DaprCounter dotnet run\\n```\\n\\nTry stopping and rest\", \"arting the application. You'll see that the counter doesn't reset. Instead it continues from the pre\", \"viously saved state. The Dapr building block makes the application stateful.\\n\\n<!-- image -->\\n\\nYou mi\", \"ght be wondering, where exactly is the state stored?\\n\\n## Component configuration files\\n\\nWhen you fir\", \"st initialized Dapr for your local environment, it automatically provisioned a Redis container. Dapr\", \" then configured the Redis container as the default state store component with a component configura\", \"tion file, entitled statestore.yaml . Here's a look at its contents:\\n\\n```\\napiVersion: dapr.io/v1alph\", \"a1 kind: Component metadata: name: statestore spec: type: state.redis version: v1 metadata: -name: r\", \"edisHost value: localhost:6379 -name: redisPassword value: \\\"\\\" -name: actorStateStore value: \\\"true\\\"\\n`\", \"``\\n\\n<!-- image -->\\n\\nNote the format of the previous component configuration file:\\n\\n- Each component \", \"has a name. In the sample above, the component is named statestore . We used that name in our first \", \"code example to tell the Dapr sidecar which component to use.\\n- Each component configuration file ha\", \"s a spec section. It contains a type field that specifies the component type. The version field spec\", \"ifies the component version. The metadata field\\n\\ncontains information that the component requires, s\", \"uch as connection details and other settings. The metadata values will vary for the different types \", \"of components.\\n\\nA Dapr sidecar can consume any Dapr component configured in your application. But, w\", \"hat if you had an architectural justification to limit the accessibility of a component? How could y\", \"ou restrict the Redis component to Dapr sidecars running only in a production environment?\\n\\nTo do so\", \", you could define a namespace for the production environment. You might name it production . In sel\", \"f-hosted mode, you specify the namespace of a Dapr sidecar by setting the NAMESPACE environment vari\", \"able. When configured, the Dapr sidecar will only load the components that match the namespace. For \", \"Kubernetes deployments, the Kubernetes namespace determines the components that are loaded. The foll\", \"owing sample shows the Redis component placed in a production namespace. Note the namespace declarat\", \"ion in the metadata element:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: state\", \"store namespace: production spec: type: state.redis version: v1 metadata: -name: redisHost value: lo\", \"calhost:6379 -name: redisPassword value: \\\"\\\" -name: actorStateStore value: \\\"true\\\"\\n```\\n\\n## Important\\n\\n\", \"A namespaced component is only accessible to applications running in the same namespace. If your Dap\", \"r application fails to load a component, make sure that the application namespace matches the compon\", \"ent namespace. This can be especially tricky in self-hosted mode where the application namespace is \", \"stored in a NAMESPACE environment variable.\\n\\nIf needed, you could further restrict a component to a \", \"particular application. Within the production namespace, you may want to limit access of the Redis c\", \"ache to only the DaprCounter application. You do so by specifying scopes in the component configurat\", \"ion. The following example shows how to restrict access to the Redis statestore component to the app\", \"lication DaprCounter in the production namespace:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component \", \"metadata: name: statestore namespace: production spec: type: state.redis version: v1 metadata: -name\", \": redisHost\\n```\\n\\n| - value:   | value: localhost:6379 name: redisPassword \\\"\\\"   |\\n|------------|-----\", \"-------------------------------------------|\\n\\n## Build a multi-container Dapr application\\n\\nIn the fi\", \"rst example, you created a simple .NET console application that ran side-by-side with a Dapr sidecar\", \". Modern distributed applications, however, often consist of many moving parts. They can simultaneou\", \"sly run independent microservices. These modern applications are typically containerized and require\", \" container orchestration tools such as Docker Compose or Kubernetes.\\n\\nIn the next example, you'll cr\", \"eate a multi -container application. You'll also use the Dapr service invocation building block to c\", \"ommunicate between services. The solution will consist of a web application that retrieves weather f\", \"orecasts from a web API. They will each run in a Docker container. You'll use Docker Compose to run \", \"the container locally and enable debugging capabilities .\\n\\nMake sure you've configured your local en\", \"vironment for Dapr and installed the .NET 7 Development Tools (instructions are available at the beg\", \"inning of this chapter).\\n\\nAdditionally, you'll need to complete this sample using Visual Studio 2022\", \" with the ASP.NET and web development workload installed.\\n\\n## Create the application\\n\\n1. In Visual S\", \"tudio 2022, create an ASP.NET Core Web App project:\\n\\nCreate a new project\\n\\nRecent project templates\\n\", \"\\nA list of your recently accessed templates will be displayed here.\\n\\nSearch for templates (Alt+S)\\n\\nA\", \"ll languages\\n\\nAll platforms\\n\\nAll project types\\n\\n-\\n\\n<!-- image -->\\n\\n1. Name your project MyFrontEnd a\", \"nd your solution DaprMultiContainer :\\n\\nP\\n\\nX\\n\\nConfigure your new project\\n\\nASP.NET Core Web App c*\\n\\nPr\", \"oject name\\n\\nMyFrontEnd\\n\\nLocation\\n\\nC:\\\\ Git\\\\\\n\\nSolution\\n\\nCreate new solution\\n\\nSolution name i\\n\\nDaprMult\", \"iContainer\\n\\nPlace solution and project in the same directory\\n\\nLinux macos\\n\\nWindows\\n\\nCloud\\n\\nService\\n\\n\", \"Web\\n\\n<!-- image -->\\n\\n1. In the final dialog, keep the defaults. Don't select Enable Docker Support .\", \" You'll add Docker support later.\\n\\nAdditional information\\n\\nASP.NET Core Web App c*\\n\\nFramework f\\n\\n.NE\", \"T 6.0 (Long-term support)\\n\\nAuthentication type O\\n\\nNone\\n\\n\\u2022 Configure for HTTPS O\\n\\nL Enable Docker \\u00ae\\n\\n\", \"Docker OS O\\n\\nLinux\\n\\nLinux macOS\\n\\nWindows\\n\\nCloud\\n\\nService\\n\\nWeb\\n\\n<!-- image -->\\n\\n1. For the backend, a\", \"dd an ASP.NET Core Web API project to the same solution:\\n\\n-\\n\\nAdd a new project\\n\\nRecent project templ\", \"ates a ASP.NET Core Web App\\n\\nSearch for templates (Alt+S)\\n\\nAll languages\\n\\nAll platforms\\n\\n-\\n\\nAll proj\", \"ect types\\n\\n-\\n\\n<!-- image -->\\n\\n1. Name the project MyBackEnd :\\n1. By default, a Dapr sidecar relies o\", \"n the network boundary to limit access to its public API. So, clear the checkbox for Configure for H\", \"TTPS :\\n\\n&gt; [!IMPORTANT] &gt; If you leave the **Configure for HTTPS** checkbox checked, the genera\", \"ted ASP.NET Core API project includes middleware to redirect client requests to the HTTPS endpoint. \", \"This breaks communication between the Dapr sidecar and your application, unless you explicitly confi\", \"gure the use of HTTPS when running your Dapr application. To enable the Dapr sidecar to communicate \", \"over HTTPS, include the [`--appssl`]{custom-style=Code} flag in the Dapr command to start the applic\", \"ation. Also specify the HTTPS port using the [`--app-port`]{custom-style=Code} parameter. The remain\", \"der of this walkthrough uses plain HTTP communication between the sidecar and the application, and r\", \"equires you to clear the **Configure for HTTPS** checkbox.\\n\\n## Add Dapr service invocation\\n\\nNow, you\", \"'ll configure communication between the services using Dapr service invocation building block . You'\", \"ll enable the web app to retrieve weather forecasts from the web API. The service invocation buildin\", \"g block features many benefits. It includes service discovery, automatic retries, message encryption\", \" (using mTLS), and improved observability. You'll use the Dapr .NET SDK to invoke the service invoca\", \"tion API on the Dapr sidecar.\\n\\n1. In Visual Studio, open the Package Manager Console ( Tools &gt; Nu\", \"Get Package Manager &gt; Package Manager Console ) and make sure that MyFrontEnd is the default proj\", \"ect. From the console, add the Dapr.AspNetCore NuGet package to the project:\\n1. In the MyFrontEnd pr\", \"oject, open the Program.cs file and add a call to builder.Services.AddDaprClient :\\n\\n```\\nInstall-Pack\", \"age Dapr.AspNetCore\\n```\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args) // Add services to the\", \" container. builder.Services.AddDaprClient(); builder.Services.AddRazorPages() // ...\\n```\\n\\nThe [`Add\", \"DaprClient`]{custom-style=Code} call registers the [`DaprClient`]{customstyle=Code} class with the A\", \"SP.NET Core dependency injection system. With the client registered, you can now inject an instance \", \"of [`DaprClient`]{custom-style=Code} into your service code to communicate with the Dapr sidecar, bu\", \"ilding blocks, and components.\\n\\n1. Add a new C# class file named WeatherForecast to the MyFrontEnd p\", \"roject:\\n1. Open the Index.cshtml.cs file in the Pages folder, and replace its contents with the foll\", \"owing code:\\n\\n```\\nnamespace MyFrontEnd public class WeatherForecast { public DateTime Date { get ; se\", \"t ; public int TemperatureC { get ; set ; public int TemperatureF { get ; set ; public string Summar\", \"y { get ; set ; } = string.Empty; }\\n```\\n\\n```\\nusing Dapr.Client; using Microsoft.AspNetCore.Mvc.Razor\", \"Pages namespace MyFrontEnd.Pages public class IndexModel : PageModel { private readonly DaprClient _\", \"daprClient public IndexModel(DaprClient daprClient) { _daprClient = daprClient; public async Task On\", \"Get() { var forecasts = await _daprClient.InvokeMethodAsync<IEnumerable<WeatherForecast>>( HttpMetho\", \"d.Get, \\\"MyBackEnd\\\", \\\"weatherforecast\\\") ViewData[\\\"WeatherForecastData\\\"] = forecasts; } }\\n```\\n\\nYou add\", \" Dapr capabilities into the web app by injecting the [`DaprClient`]{customstyle=Code} class into [`I\", \"ndexModel`]{custom-style=Code} constructor. In the [`OnGet`]{custom-style=Code} method, you call the\", \" backend API service with the Dapr service invocation building block. The [`OnGet`]{custom-style=Cod\", \"e} method is invoked\\n\\nAdd Container Orchestrator Support\\n\\nContainer orchestrator:\\n\\nDocker Compose\\n\\n`\", \"``\\nwhenever a user visits the home page. You use the [`DaprClient.InvokeMethodAsync`]{custom-style=C\", \"ode} method to invoke the [`weatherforecast`]{custom-style=Code} method of the [`MyBackEnd`]{custom-\", \"style=Code} service. You'll configure the web API to use [`MyBackEnd`]{custom-style=Code} as its app\", \"lication ID later on when configuring it to run with Dapr. Finally, the service response is saved in\", \" view data.\\n```\\n\\n1. Replace the contents of the Index.cshtml file in the Pages folder, with the foll\", \"owing code. It displays the weather forecasts stored in the view data to the user:\\n\\n```\\n@page @model\", \" IndexModel @{ ViewData[\\\"Title\\\"] = \\\"Home page\\\"; <div class=\\\"text-center\\\"> <h1 class=\\\"display-4\\\">Welc\", \"ome</h1> <p>Learn about <a href=\\\"https://learn.microsoft.com/aspnet/core\\\">building Web apps with ASP\", \".NECore</a>.</p> @foreach (var forecast in (IEnumerable<WeatherForecast>)ViewData[\\\"WeatherForecastDa\", \"ta\\\"]!) { <p>The forecast for @forecast.Date is @forecast.Summary!</p> } </div>\\n```\\n\\n## Add container\", \" support\\n\\nIn the final part of this example, you'll add container support and run the solution using\", \" Docker Compose.\\n\\n1. Right-click the MyFrontEnd project, and choose Add &gt; Container Orchestrator \", \"Support\\u2026 . The Add Container Orchestrator Support dialog appears:\\n\\n<!-- image -->\\n\\nChoose **Docker C\", \"ompose**.\\n\\n1. In the next dialog, select Linux as the Target OS:\\n\\nDocker Support Options\\n\\nTarget OS:\", \"\\n\\nLinux\\n\\nWindows\\n\\n<!-- image -->\\n\\nVisual Studio creates a *docker-compose.yml*file and a *.dockerign\", \"ore* file in the **docker-compose** folder in the solution:\\n\\nSolution Explorer\\n\\nSearch Solution Expl\", \"orer (Ctrl+;)\\n\\nFa Solution 'DaprMultiContainer' (B of 3 projects)\\n\\nYML\\n\\ne] MyBackEnd\\n\\nC# Program.cs\\n\", \"\\nMyFrontEnd\\n\\n\\u2022 wwwroot\\n\\n\\u2022 Pages\\n\\n\\u2022 Dockerfile\\n\\nC# Program.cs\\n\\n\\u2022 C# WeatherForecast.cs\\n\\n* 4 x\\n\\n<!-- i\", \"mage -->\\n\\nThe *docker-compose.yml* file has the following content:\\n\\n```\\nversion: '3.4 services: myfr\", \"ontend: image: ${DOCKER_REGISTRY-}myfrontend build: context: . dockerfile: MyFrontEnd/Dockerfile\\n```\", \"\\n\\nThe *.dockerignore* file contains file types and extensions that you don't want Docker to include \", \"in the container. These files are associated with the development environment and source control and\", \" not the app or service you're deploying.\\n\\nD\\n\\nD\\n\\n```\\nIn the root of the *MyFrontEnd* project directo\", \"ry, a new *Dockerfile* was created. A *Dockerfile* is a sequence of commands that are used to build \", \"an image. For more information, see [Dockerfile reference](https://docs.docker.com/engine/reference/\", \"builder).\\n```\\n\\nThe *Dockerfile* contains the following commands:\\n\\n```\\nFROM mcr.microsoft.com/dotnet/\", \"aspnet:7.0 AS base WORKDIR /app EXPOSE 80 EXPOSE 44 FROM mcr.microsoft.com/dotnet/sdk:7.0 AS build W\", \"ORKDIR /src COPY [\\\"MyFrontEnd/MyFrontEnd.csproj\\\", \\\"MyFrontEnd/\\\"] RUN dotnet restore \\\"MyFrontEnd/MyFr\", \"ontEnd.csproj\\\" COPY . . WORKDIR \\\"/src/MyFrontEnd\\\" RUN dotnet build \\\"MyFrontEnd.csproj\\\" -c Release -o\", \" /app/buil FROM build AS publish RUN dotnet publish \\\"MyFrontEnd.csproj\\\" -c Release -o /app/publis FR\", \"OM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\\\"dotnet\\\", \\\"MyFrontEnd.d\", \"ll\\\"]\\n```\\n\\nThe preceding *Dockerfile* sequentially performs the following steps when invoked:\\n\\n```\\n1.\", \" Pulls the [`mcr.microsoft.com/dotnet/aspnet:7.0`]{custom-style=Code} image and names it [`base`]{cu\", \"stom-style=Code}. 2. Sets the working directory to */app*. 3. Exposes port [`80`]{custom-style=Code}\", \" and [`443`]{custom-style=Code}. 4. Pulls the [`mcr.microsoft.com/dotnet/sdk:7.0`]{custom-style=Code\", \"} image and names it [`build`]{custom-style=Code}. 5. Sets the working directory to */src*. 6. Copie\", \"s the _MyFrontEnd/MyFrontEnd.csproj_ to a new directory named *MyFrontEnd/*. 7. Calls [[`dotnet rest\", \"ore`]{custom-style=Code}](https://docs.microsoft.com/enus/dotnet/core/tools/dotnet-restore) on the p\", \"roject. 8. Copies everything from the root directory into the image's root. 9. Sets the working dire\", \"ctory to _/src/MyFrontEnd_. 10. Calls [[`dotnet build`]{custom-style=Code}](https://docs.microsoft.c\", \"om/enus/dotnet/core/tools/dotnet-build) on the project. - Targeting the **Release** configuration an\", \"d outputs to */app/build*. 11. Initializes a new build stage from the existing [`build`]{custom-styl\", \"e=Code} base image and names it [`publish`]{custom-style=Code}. 12. Calls [`dotnet publish`]{custom-\", \"style=Code} on the project. - Targeting the **Release** configuration and outputs to */app/publish*.\", \" 13. Initializes a new build stage from the existing [`publish`]{custom-style=Code} base image and n\", \"ames it [`final`]{custom-style=Code}. 14. Sets the working directory to */app*. 15. Copies the [`/ap\", \"p/publish`]{custom-style=Code} directory from the [`publish`]{custom-style=Code} image into the root\", \" of the [`final`]{custom-style=Code} image. 16. Sets the entry point as the image to [`dotnet`]{cust\", \"om-style=Code} and passes the [`MyFrontEnd.dll`]{custom-style=Code} as an arg.\\n```\\n\\n1. In the MyBack\", \"End web API project, right-click on the project node, and choose Add &gt; Container Orchestrator Sup\", \"port\\u2026 . Choose Docker Compose , and then select Linux again as the target OS.\\n\\nIn the root of the My\", \"BackEnd project directory, a new Dockerfile was created. The Dockerfile contains the following comma\", \"nds:\\n\\n```\\nFROM mcr.microsoft.com/dotnet/aspnet:7.0 AS base WORKDIR /app EXPOSE 8 FROM mcr.microsoft.\", \"com/dotnet/sdk:7.0 AS build WORKDIR /src COPY [\\\"MyBackEnd/MyBackEnd.csproj\\\", \\\"MyBackEnd/\\\"] RUN dotne\", \"t restore \\\"MyBackEnd/MyBackEnd.csproj\\\" COPY . . WORKDIR \\\"/src/MyBackEnd\\\" RUN dotnet build \\\"MyBackEnd\", \".csproj\\\" -c Release -o /app/buil FROM build AS publish RUN dotnet publish \\\"MyBackEnd.csproj\\\" -c Rele\", \"ase -o /app/publis FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\\\"d\", \"otnet\\\", \\\"MyBackEnd.dll\\\"]\\n```\\n\\nOpen the *docker-compose.yml* file again and examine its contents. Vis\", \"ual Studio has updated the **Docker Compose** file. Now both services are included:\\n\\n```\\nversion: '3\", \".4 services: myfrontend: image: ${DOCKER_REGISTRY-}myfrontend build: context: . dockerfile: MyFrontE\", \"nd/Dockerfil mybackend: image: ${DOCKER_REGISTRY-}mybackend build: context: . dockerfile: MyBackEnd/\", \"Dockerfile\\n```\\n\\n1. To use Dapr building blocks from inside a containerized application, you'll need \", \"to add the Dapr sidecars containers to your Compose file. Carefully update the content of the docker\", \"compose.yml file to match the following example. Pay close attention to the formatting and spacing a\", \"nd don't use tabs.\\n\\n```\\nversion: '3.4 services: myfrontend: image: ${DOCKER_REGISTRY-}myfrontend bui\", \"ld: context: . dockerfile: MyFrontEnd/Dockerfile ports: - \\\"51000:50001 myfrontend-dapr: image: \\\"dapr\", \"io/daprd:latest\\\" command: [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyFrontEnd\\\", \\\"-app-port\\\", \\\"80\\\" ] depends_on:\\n```\\n\", \"\\n```\\n- myfrontend network_mode: \\\"service:myfrontend mybackend: image: ${DOCKER_REGISTRY-}mybackend b\", \"uild: context: . dockerfile: MyBackEnd/Dockerfile ports: - \\\"52000:50001 mybackend-dapr: image: \\\"dapr\", \"io/daprd:latest\\\" command: [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyBackEnd\\\", \\\"-app-port\\\", \\\"80\\\" ] depends_on: - myb\", \"ackend network_mode: \\\"service:mybackend\\\"\\n```\\n\\nIn the updated file, we've added [`myfrontend-dapr`]{c\", \"ustom-style=Code} and [`mybackend-dapr`]{custom-style=Code} sidecars for the [`myfrontend`]{customst\", \"yle=Code} and [`mybackend`]{custom-style=Code} services respectively. In the updated file, pay close\", \" attention to the following changes:\\n\\n- The sidecars use the [`daprio/daprd:latest`]{custom-style=Co\", \"de} container image. The use of the [`latest`]{custom-style=Code} tag isn't recommended for producti\", \"on scenarios. For production, it's better to use a specific version number.\\n- Each service defined i\", \"n the Compose file has its own network namespace for network isolation purposes. The sidecars use [`\", \"network\\\\_mode: \\\"service:...\\\"`]{customstyle=Code} to ensure they run in the same network namespace as\", \" the application. Doing so allows the sidecar and the application to communicate using [`localhost`]\", \"{customstyle=Code}.\\n- The ports on which the Dapr sidecars are listening for gRPC communication (by \", \"default 50001) must be exposed to allow the sidecars to communicate with each other.\\n1. Run the solu\", \"tion (F5 or Ctrl+F5) to verify that it works as expected. If everything is configured correctly, you\", \" should see the weather forecast data:\\n\\nlE Home page - MyFrontEnd\\n\\n+\\n\\n&lt; &gt; C a localhost:59782\\n\", \"\\nMyFrontEnd Home Privacy\\n\\n\\u00a9 2021 - MyFrontEnd - Privacy\\n\\n<!-- image -->\\n\\nRunning locally with Docker\", \" Compose and Visual Studio, you can set breakpoints and debug into the application. For production s\", \"cenarios, it's recommended to host your application in Kubernetes. This book includes an accompanyin\", \"g reference application, [eShopOnDapr](https://github.com/dotnet-architecture/eShopOnDapr), that con\", \"tains scripts to deploy to Kubernetes.\\n\\nTo learn more about the Dapr service invocation building blo\", \"ck used in this walkthrough, refer to [chapter 6](#the-dapr-service-invocation-building-blo).\\n\\n## Su\", \"mmary\\n\\nIn this chapter, you had an opportunity to test drive Dapr. Using the Dapr .NET SDK, you saw \", \"how Dapr integrates with the .NET application platform.\\n\\nThe first example was a simple, stateful, .\", \"NET Console application that used the Dapr state management building block.\\n\\nThe second example invo\", \"lved a multi-container application running in Docker. By using Visual Studio with Docker Compose, yo\", \"u experienced the familiar F5 debugging experience available across all .NET apps.\\n\\nYou also got a c\", \"loser look at Dapr component configuration files. They configure the actual infrastructure implement\", \"ation used by the Dapr building blocks. You can use namespaces and scopes to restrict component acce\", \"ss to particular environments and applications.\\n\\nIn the upcoming chapters, you'll dive deep into the\", \" building blocks offered by Dapr.\\n\\n## References\\n\\n- Dapr documentation - Getting started\\n- eShopOnDa\", \"pr\\n\\n## Traffic Control sample application\\n\\nIn the first chapters, you've learned about basic Dapr co\", \"ncepts. You saw how Dapr can help you and your team construct distributed applications while reducin\", \"g architectural and operational complexity. This chapter introdu ces the sample application that you\", \"'ll use to explore the Dapr building blocks. The application targets .NET 7 and uses the latest C# 1\", \"1 language features.\\n\\n## Note\\n\\nDownload the sample application code from the Dapr Traffic Control Gi\", \"tHub repo. This repository contains a detailed description on how you can run the sample application\", \" on your machine.\\n\\nThe Traffic Control sample application simulates a highway traffic control system\", \". Its purpose is to detect speeding vehicles and send the offending driver a fine notice. These syst\", \"ems actually exist in real life and here's how they work. A set of cameras (one above each lane) is \", \"placed at the beginning and end of a highway stretch (say 10 kilometers) without on- or off-ramps. A\", \"s a vehicle passes underneath a camera, it takes a photograph of the vehicle. Using Optical Characte\", \"r Recognition (OCR) software, it extracts the license number of the vehicle from the photo. Using th\", \"e entry- and exittimestamp of each vehicle, the system calculates the average speed of that vehicle.\", \" If the average speed is above the maximum speed limit for that highway stretch, the system retrieve\", \"s the driver information and automatically sends a fine notice.\\n\\nAlthough the simulation is simple, \", \"responsibilities within the system are separated into several microservices. Figure 4.1 shows an ove\", \"rview of the services that are part of the application:\\n\\nCamera\\n\\nSimulation\\n\\nService\\n\\n/entrycam\\n\\n/co\", \"llectfine\\n\\n/vehicleinfo\\n\\n<!-- image -->\\n\\nInterval\\n\\nCamera\\n\\nSimulation\\n\\nPOST /entrycam\\n\\nFigure 4-1. T\", \"he services in the sample application.\\n\\nStore\\n\\n- The Camera Simulation is a console application that\", \" simulates vehicles and sends messages to the TrafficControl service. Every simulated car invokes bo\", \"th the entry and exit service endpoints.\\n- The TrafficControl service is an ASP.NET Core Web API app\", \"lication that exposes the /entrycam and /exitcam endpoints. Invoking an endpoint simulates a car pas\", \"sing under one of the entryor exit-cameras respectively. The request message payload simply contains\", \" the license plate of the car (no actual OCR is implemented).\\n- The FineCollection service is an ASP\", \".NET Core Web API application that offers 1 endpoint: /collectfine . Invoking this endpoint will sen\", \"d a fine notice to the driver of the speeding vehicle. The payload of the request contains all the i\", \"nformation about the speeding violation.\\n\\nFine\\n\\n- The VehicleRegistration service is an ASP.NET Core\", \" Web API application that offers 1 endpoint: /vehicleinfo/{licensenumber} . It's used for obtaining \", \"vehicle - and owner-information for a speeding vehicle based on the license number sent in the URL (\", \"for example, /vehicleinfo/RV752-S ). Send email\\n\\nThe sequence diagram in figure 4.2 shows the simula\", \"tion flow:\\n\\nFigure 4-2. Sequence diagram of the simulation flow.\\n\\n<!-- image -->\\n\\nThe services commu\", \"nicate by directly i nvoking each other's APIs. This design works fine, but it has some drawbacks.\\n\\n\", \"Random\\n\\nTraffic Control\\n\\nService\\n\\nFine Collection\\n\\nService\\n\\nVehicle Registration\\n\\nService\\n\\nThe bigge\", \"st challenge is that the call-chain will break if one of the services is off-line. Decoupling servic\", \"es by replacing direct calls with asynchronous messaging would solve this issue. Asynchronous messag\", \"ing is typically implemented with a message broker like RabbitMQ or Azure Service Bus.\\n\\nAnother draw\", \"back is that the vehicle state for every vehicle is stored in memory in the TrafficControl service. \", \"This state is lost when the service is restarted after an update or a crash. To increase system dura\", \"bility, state should be stored outside the service.\\n\\n## Using Dapr building blocks\\n\\nOne of the goals\", \" of Dapr is to provide cloud-native capabilities for microservices applications. The Traffic Control\", \" application uses Dapr building blocks to increase robustness and mitigate the design drawbacks desc\", \"ribed in the previous paragraph. Figure 4.shows a Dapr-enabled version of the traffic control applic\", \"ation:\\n\\nFigure 4-3. Traffic Control application with Dapr building blocks.\\n\\n1. Service invocation Th\", \"e Dapr service invocation building block handles request/response communication between the FineColl\", \"ectionService and the VehicleRegistrationService. Because the call is a query to retrieve required d\", \"ata to complete the operation, a synchronous call is acceptable here. The service invocation buildin\", \"g block provides service discovery. The FineCollection service no longer has to know where the Vehic\", \"leRegistration service lives. It also implements automatic retries if the VehicleRegistration servic\", \"e is off-line.\\n2. Publish &amp; subscribe The publish and subscribe building block handles asynchron\", \"ous messaging for sending speeding violations from the TrafficControl service to the FineCollectionS\", \"ervice. This implementation decouples the TrafficControl and FineCollection service. If the FineColl\", \"ectionService were to become temporarily unavailable, data would accumulate in the queue and resume \", \"processing at a later time. RabbitMQ is the current message broker that transports messages from the\", \" producers to the consumers. As the Dapr pub/sub building block abstracts the message broker, develo\", \"pers don't need to learn the details of the RabbitMQ client library. Switching to another message br\", \"oker doesn't r equire code changes, only configuration.\\n3. State management The TrafficControl servi\", \"ce uses the state management building block to persist vehicle state outside of the service in a Red\", \"is cache. As with pub/sub, developers don't need to learn Redis specific APIs. Switching to another \", \"data store requires no code changes.\\n4. Output binding The FineCollection service sends fines to the\", \" owners of speeding vehicles by email. The Dapr output binding for SMTP abstracts the email transmis\", \"sion using the SMTP protocol.\\n5. Input binding The CameraSimulation sends messages with simulated ca\", \"r info to the TrafficControl service using the MQTT protocol. It uses a .NET MQTT library for sendin\", \"g messages to Mosquitto - a lightweight MQTT broker. The TrafficControl service uses the Dapr input \", \"binding for MQTT to subscribe to the MQTT broker and receive messages.\\n6. Secrets management The Fin\", \"eCollectionService needs credentials for connecting to the smtp server and a license-key for a fine \", \"calculator component it uses internally. It uses the secrets management building block to obtain the\", \" credentials and the license-key.\\n\\ncamera\\n\\nSimulation\\n\\nMosquitto\\n\\nVehicleRegistered\\n\\nRandom\\n\\nInterva\", \"l\\n\\nVehicleRegistered\\n\\n+\\n\\ndapr\\n\\nSidecar\\n\\nVehicleRegistered\\n\\nPOST /entrycam\\n\\nStore vehicle state\\n\\nStor\", \"e vehicle state\\n\\n7. Actors The TrafficControlService has an alternative implementation based on Dapr\", \" actors. In this implementation, the TrafficControl service creates a new actor for every vehicle th\", \"at is registered by the entry camera. The license number of the vehicle forms the unique actor Id. T\", \"he actor encapsulates the vehicle state, which it persists in the Redis cache. When a vehicle is reg\", \"istered by the exit camera, it invokes the actor. The actor then calculate the average speed and pos\", \"sibly issue a speeding violation.\\n\\nSpeeding Violation\\n\\nFigure 4.4 shows a sequence diagram of the fl\", \"ow of the simulation with all the Dapr building blocks in place: Calculate Fine invoke vehilcleinto/\", \"KL-714-V\\n\\ninvoke vehicleinfo/KL-714-V\\n\\nFigure 4-4. Sequence diagram of simulation flow with Dapr bui\", \"lding blocks.\\n\\n<!-- image -->\\n\\nThe rest of this book features a chapter for each of the Dapr buildin\", \"g blocks. Each chapter explains in detail how the building block works, its configuration, and how t\", \"o use it. Each chapter explains how the Traffic Control sample application uses the building block.\\n\", \"\\n## Hosting\\n\\nThe Traffic Control sample application can run in self-hosted mode or in Kubernetes.\\n\\n#\", \"# Self-hosted mode\\n\\nThe sample repository contains PowerShell scripts to start the infrastructure se\", \"rvices (Redis, RabbitMQ, and Mosquitto) as Docker containers on your machine. They're located in the\", \" src/Infrastructure folder. For every application service in the solution, the repository contains a\", \" separate folder. Each of these folders contains a start-selfhosted.ps1 PowerShell script to start t\", \"he service with Dapr.\\n\\nTraffic\\n\\nControl\\n\\nService\\n\\nRedis\\n\\nRabbitMQ\\n\\ndapi\\n\\nSidecar\\n\\nFine\\n\\nCollection\\n\\n\", \"Service dap\\n\\nSidecar\\n\\nVehicle\\n\\nRegistration\\n\\nService\\n\\nMailDev\\n\\n## Kubernetes\\n\\nThe src/k8s folder in \", \"the sample repository contains the Kubernetes manifest files to run the application (including the i\", \"nfrastructure services) with Dapr in Kubernetes. This folder also contains a start.ps1 and stop.ps1 \", \"PowerShell script to start and stop the solution in Kubernetes. All services will run in the dapr-tr\", \"afficcontrol namespace.\\n\\n## Summary\\n\\nThe Traffic Control sample application is a microservices appli\", \"cation that simulates a highway speed trap.\\n\\nThe application uses several Dapr building blocks to ma\", \"ke it robust and cloud-native. The domain is kept simple to keep the focus on Dapr.\\n\\nThe application\", \" will be used in the following chapters that focus on Dapr building block.\\n\\n## References\\n\\n- Dapr Tr\", \"affic Control Sample\\n\\n<!-- image -->\\n\\n## The Dapr state management building block\\n\\nDistributed appli\", \"cations are composed of independent services. While each service should be stateless, some services \", \"must track state to complete business operations. Consider a shopping basket service for an eCommerc\", \"e site. If the service can't track state, the customer could lose the shopping basket content by lea\", \"ving the website, resulting in a lost sale and an unhappy customer experience. For these scenarios, \", \"state needs to be persisted to a distributed state store. The Dapr state management building block s\", \"implifies state tracking and offers advanced features across various data stores.\\n\\nTo try out the st\", \"ate management building block, have a look at the counter application sample in chapter 3.\\n\\n## What \", \"it solves\\n\\nTracking state in a distributed application can be challenging. For example:\\n\\n- The appli\", \"cation may require different types of data stores.\\n- Different consistency levels may be required fo\", \"r accessing and updating data.\\n- Multiple users may update data at the same time, requiring conflict\", \" resolution.\\n- Services must retry any short-lived transient errors that occur while interacting wit\", \"h the data store.\\n\\nThe Dapr state management building block addresses these challenges. It streamlin\", \"es tracking state without dependencies or a learning curve on third-party storage SDKs.\\n\\n## Importan\", \"t\\n\\nDapr state management offers a key/value API. The feature doesn't support relational or graph dat\", \"a storage.\\n\\n## How it works\\n\\nThe application interacts with a Dapr sidecar to store and retrieve key\", \"/value data. Under the hood, the sidecar API consumes a configurable state store component to persis\", \"t data. Developers can choose from a growing collection of supported state stores that include Azure\", \" Cosmos DB, SQL Server, and Cassandra.\\n\\nThe API can be called with either HTTP or gRPC. Use the foll\", \"owing URL to call the HTTP API:\\n\\n```\\nhttp://localhost:<dapr-port>/v1.0/state/<store-name>/\\n```\\n\\n- &l\", \"t;dapr-port&gt; : the HTTP port that Dapr listens on.\\n- &lt;store-name&gt; : the name of the state s\", \"tore component to use.\\n\\nFigure 5-1 shows how a Dapr-enabled shopping basket service stores a key/val\", \"ue pair using the Dapr state store component named statestore .\\n\\n:::image type='content' source='./m\", \"edia/state -management/state-managementflow.png' alt -text='Diagram of storing a key/value pair in a\", \" Dapr state store.':::\\n\\nFigure 5-1. Storing a key/value pair in a Dapr state store.\\n\\nNote the steps \", \"in the previous figure:\\n\\n1. The basket service calls the state management API on the Dapr sidecar. T\", \"he body of the request encloses a JSON array that can contain multiple key/value pairs.\\n2. The Dapr \", \"sidecar determines the state store based on the component configuration file. In this case, it's a R\", \"edis cache state store.\\n3. The sidecar persists the data to the Redis cache.\\n\\nRetrieving the stored \", \"data is a similar API call. In the example below, a curl command retrieves the data by calling the D\", \"apr sidecar API:\\n\\n```\\ncurl http://localhost:3500/v1.0/state/statestore/basket1\\n```\\n\\nThe command retu\", \"rns the stored state in the response body:\\n\\n```\\n{ \\\"items\\\": [ { \\\"itemId\\\": \\\"DaprHoodie\\\", \\\"quantity\\\": 1\", \" } ], \\\"customerId\\\": 1 }\\n```\\n\\nThe following sections explain how to use the more advanced features of\", \" the state management building block.\\n\\n## Consistency\\n\\nThe CAP theorem is a set of principles that a\", \"pply to distributed systems that store state. Figure 5-2 shows the three properties of the CAP theor\", \"em.\\n\\n:::image type='content' source='./media/state -management/captheorem.png' alt -text='The CAP th\", \"eorem.':::\\n\\nFigure 5-2. The CAP theorem.\\n\\nThe theorem states that distributed data systems offer a t\", \"rade-off between consistency, availability, and partition tolerance. And, that any datastore can onl\", \"y guarantee two of the three properties :\\n\\n- Consistency ( C ). Every node in the cluster responds w\", \"ith the most recent data, even if the system must block the request until all replicas update. If yo\", \"u query a 'consistent system' for an item that is currently updating, you won't get a response until\", \" all replicas successfully update. However, you'll always receive the most current data.\\n- Availabil\", \"ity ( A ). Every node returns an immediate response, even if that response isn't the most recent dat\", \"a. If you query an 'available system' for an item that is updating, you'l l get the best possible an\", \"swer the service can provide at that moment.\\n- Partition Tolerance ( P ). Guarantees the system cont\", \"inues to operate even if a replicated data node fails or loses connectivity with other replicated da\", \"ta nodes.\\n\\nDistributed applications must handle the P property. As services communicate among each o\", \"ther with network calls, network disruptions ( P ) will occur. With that in mind, distributed applic\", \"ations must either be AP or CP .\\n\\nAP applications choose availability over consistency. Dapr support\", \"s this choice with its eventual consistency strategy. Consider an underlying data store, such as Azu\", \"re CosmosDB, which stores redundant data on multiple replicas. With eventual consistency, the state \", \"store writes the update to one replica and completes the write request with the client. After this t\", \"ime, the store will asynchronously update its replicas. Read requests can return data from any of th\", \"e replicas, including those replicas that haven' t yet received the latest update.\\n\\nCP applications \", \"choose consistency over availability. Dapr supports this choice with its strong consistency strategy\", \". In this scenario, the state store will synchronously update all (or, in some cases, a quorum of) r\", \"equired replicas before completing the write request. Read operations will return the most up-to-dat\", \"e data consistently across replicas.\\n\\nThe consistency level for a state operation is specified by at\", \"taching a consistency hint to the operation. The following curl command writes a Hello=World key/val\", \"ue pair to a state store using a strong consistency hint:\\n\\n```\\ncurl -X POST http://localhost:3500/v1\", \".0/state/<store-name> \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '[ { \\\"key\\\": \\\"Hello\\\", \\\"value\\\": \\\"Worl\", \"d\\\", \\\"options\\\": { \\\"consistency\\\": \\\"strong\\\" } } ]'\\n```\\n\\n## Important\\n\\nIt is up to the Dapr state store \", \"component to fulfill the consistency hint attached to the operation. Not all data stores support bot\", \"h consistency levels. If no consistency hint is set, the default behavior is eventual .\\n\\n## Concurre\", \"ncy\\n\\nIn a multiuser application, there's a chance that multiple users will update the same data conc\", \"urrently (at the same time). Dapr supports optimistic concurrency control (OCC) to manage conflicts.\", \" OCC is based on an assumption that update conflicts are uncommon because users work on different pa\", \"rts of the data. It's more efficient to assume an update will succeed and retry if it doesn't. The a\", \"lternative, implementing pessimistic locking, can affect performance with long-running locking causi\", \"ng data contention.\\n\\nDapr supports optimistic concurrency control (OCC) using ETags. An ETag is a va\", \"lue associated with a specific version of a stored key/value pair. Each time a key/value pair update\", \"s, the ETag value updates as well. When a client retrieves a key/value pair, the response includes t\", \"he current ETag value. When a client updates or deletes a key/value pair, it must send that ETag val\", \"ue back in the request body. If another client has updated the data in the meantime, the ETags won't\", \" match and the request will fail. At this point, the client must retrieve the updated data, make the\", \" change again, and resubmit the update. This strategy is called first-write-wins .\\n\\nDapr also suppor\", \"ts a last-write-wins strategy. With this approach, the client doesn't attach an ETag to the write re\", \"quest. The state store component will always allow the update, even if the underlying value has chan\", \"ged during the session. Last-write-wins is useful for high-throughput write scenarios with low data \", \"contention. As well, overwriting an occasional user update can be tolerated.\\n\\n## Transactions\\n\\nDapr \", \"can write multi-item changes to a data store as a single operation implemented as a transaction. Thi\", \"s functionality is only available for data stores that support ACID transactions. At the time of thi\", \"s writing, these stores include Redis, MongoDB, PostgreSQL, SQL Server, and Azure CosmosDB.\\n\\nIn the \", \"example below, a multi-item operation is sent to the state store in a single transaction. All operat\", \"ions must succeed for the transaction to commit. If one or more of the operations fail, the entire t\", \"ransaction rolls back.\\n\\n```\\ncurl -X POST http://localhost:3500/v1.0/state/<store-name>/transaction \\\\\", \" -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"operations\\\": [ { \\\"operation\\\": \\\"upsert\\\", \\\"request\\\": { \\\"\", \"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\" } }, { \\\"operation\\\": \\\"delete\\\", \\\"request\\\": { \\\"key\\\": \\\"Key2\\\" } }\\n```\\n\\n``\", \"`\\n] }'\\n```\\n\\nFor data stores that don't support transactions, multiple keys can still be sent as a si\", \"ngle request. The following example shows a bulk write operation:\\n\\n```\\ncurl -X POST http://localhost\", \":3500/v1.0/state/<store-name> \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '[ { \\\"key\\\": \\\"Key1\\\", \\\"value\\\"\", \": \\\"Value1\\\" }, { \\\"key\\\": \\\"Key2\\\", \\\"value\\\": \\\"Value2\\\" } ]'\\n```\\n\\nFor bulk operations, Dapr will submit eac\", \"h key/value pair update as a separate request to the data store.\\n\\n## Use the Dapr .NET SDK\\n\\nThe Dapr\", \" .NET SDK provides language-specific support for the .NET platform. Developers can use the DaprClien\", \"t class introduced in chapter 3 to read and write data. The following example shows how to use the D\", \"aprClient.GetStateAsync&lt;TValue&gt; method to read data from a state store. The method expects the\", \" store name, statestore , and key, AMS , as parameters:\\n\\n```\\nvar weatherForecast = await daprClient.\", \"GetStateAsync<WeatherForecast>(\\\"statestore\\\", \\\"AMS\\\");\\n```\\n\\nIf the state store contains no data for ke\", \"y AMS , the result will be default(WeatherForecast) .\\n\\nTo write data to the data store, use the Dapr\", \"Client.SaveStateAsync&lt;TValue&gt; method:\\n\\n```\\ndaprClient.SaveStateAsync(\\\"statestore\\\", \\\"AMS\\\", weat\", \"herForecast);\\n```\\n\\nThe example uses the last-write-wins strategy as an ETag value isn't p assed to t\", \"he state store component. To use optimistic concurrency control (OCC) with a first-write-wins strate\", \"gy, first retrieve the current ETag using the DaprClient.GetStateAndETagAsync method. Then write the\", \" updated value and pass along the retrieved ETag using the DaprClient.TrySaveStateAsync method.\\n\\n```\", \"\\nvar (weatherForecast, etag) = await daprClient.GetStateAndETagAsync<WeatherForecast>(\\\"statestore\\\", \", \"city); // ... make some changes to the retrieved weather forecast var result = await daprClient.TryS\", \"aveStateAsync(\\\"statestore\\\", city, weatherForecast, etag);\\n```\\n\\nThe DaprClient.TrySaveStateAsync meth\", \"od fails when the data (and associated ETag) has been changed in the state store after the data was \", \"retrieved. The method returns a boolean value to indicate whether the call succeeded. A strategy to \", \"handle the failure is to simply reload the updated data from the state store, make the change again,\", \" and resubmit the update.\\n\\nIf you always want a write to succeed regardless of other changes to the \", \"data, use the last-write-wins strategy.\\n\\nThe SDK provides other methods to retrieve data in bulk, de\", \"lete data, and execute transactions. For more information, see the Dapr .NET SDK repository.\\n\\n## ASP\", \".NET Core integration\\n\\nDapr also supports ASP.NET Core, a cross-platform framework for building mode\", \"rn cloud-based web applications. The Dapr SDK integrates state management capabilities directly into\", \" the ASP.NET Core model binding capabilities. Configuration is simple. In the Program.cs file, call \", \"the following extension method on the WebApplication builder:\\n\\n```\\nvar builder = WebApplication.Crea\", \"teBuilder(args); builder.Services.AddControllers().AddDapr();\\n```\\n\\nOnce configured, Dapr can inject \", \"a key/value pair directly into a controller action using the ASP.NET Core FromState attribute. Refer\", \"encing the DaprClient object is no longer necessary. The next example shows a Web API that returns t\", \"he weather forecast for a given city:\\n\\n```\\n[HttpGet(\\\"{city}\\\")] public ActionResult<WeatherForecast> \", \"Get([FromState(\\\"statestore\\\", \\\"city\\\")] StateEntry<WeatherForecast> forecast) { if (forecast.Value == \", \"null ) { return NotFound(); } return forecast.Value; }\\n```\\n\\nIn the example, the controller loads the\", \" weather forecast using the FromState attribute. The first attribute parameter is the state store, s\", \"tatestore . The second attribute parameter, city , is the name of the route template variable to get\", \" the state key. If you omit the second parameter, the name of the bound method parameter ( forecast \", \") is used to look up the route template variable.\\n\\nThe StateEntry class contains properties for all \", \"the information that is retrieved for a single key/value pair: StoreName , Key , Value , and ETag . \", \"The ETag is useful for implementing optimistic concurrency control (OCC) strategy. The class also pr\", \"ovides methods to delete or update retrieved key/value data without requiring a DaprClient instance.\", \" In the next example, the TrySaveAsync method is used to update the retrieved weather forecast using\", \" OCC.\\n\\n```\\n[HttpPut(\\\"{city}\\\")] public async Task Put(WeatherForecast updatedForecast, [FromState(\\\"st\", \"atestore\\\", \\\"city\\\")] StateEntry<WeatherForecast> currentForecast) { // update cached current forecast\", \" with updated forecast passed into service endpoint currentForecast.Value = updatedForecast; // upda\", \"te state store var success = await currentForecast.TrySaveAsync(); // ... check result }\\n```\\n\\n## Sta\", \"te store components\\n\\nAt the time of this writing, Dapr provides support for the following transactio\", \"nal state stores:\\n\\n- Azure CosmosDB\\n- Azure SQL Server\\n- CockroachDB\\n- In Memory\\n- MongoDB\\n- MySQL\\n-\", \" Oracle Database\\n- PostgreSQL\\n- Redis\\n- RethinkDB\\n\\nDapr also includes support for state stores that \", \"support CRUD operations, but not transactional capabilities:\\n\\n- Aerospike\\n- Apache Cassandra\\n- AWS D\", \"ynamoDB\\n- Azure Blob Storage\\n- Azure Table Storage\\n- Couchbase\\n- GCP Firestore\\n- Hashicorp Consul\\n- \", \"Hazelcast\\n- JetStream KV\\n- Memcached\\n- Oracle Object Storage\\n- Zookeeper\\n\\n## Configuration\\n\\nWhen ini\", \"tialized for local, self-hosted development, Dapr registers Redis as the default state store. Here's\", \" an example of the default state store configuration. Note the default name, statestore :\\n\\n```\\napiVe\", \"rsion: dapr.io/v1alpha1 kind: Component metadata: name: statestore spec: type: state.redis version: \", \"v1 metadata: -name: redisHost value: localhost:6379 -name: redisPassword value: \\\"\\\" -name: actorState\", \"Store value: \\\"true\\\"\\n```\\n\\n[!NOTE] Many state stores can be registered to a single application each wi\", \"th a different name.\\n\\nThe Redis state store requires redisHost and redisPassword metadata to connect\", \" to the Redis instance. In the example above, the Redis password (which is an empty string by defaul\", \"t) is stored as a plain string. The best practice is to avoid clear-text strings and always use secr\", \"et references. To learn more about secret management, see chapter 10.\\n\\nThe other metadata field, act\", \"orStateStore , indicates whether the state store can be consumed by the actors building block.\\n\\n## K\", \"ey prefix strategies\\n\\nState store components enable different strategies to store key/value pairs in\", \" the underlying store. Recall the earlier example of a shopping basket service storing items a custo\", \"mer wishes to purchase:\\n\\n```\\ncurl -X POST http://localhost:3500/v1.0/state/statestore \\\\ -H \\\"Content-\", \"Type: application/json\\\" \\\\ -d '[{ \\\"key\\\": \\\"basket1\\\", \\\"value\\\": { \\\"customerId\\\": 1, \\\"items\\\": [ { \\\"itemId\\\"\", \": \\\"DaprHoodie\\\", \\\"quantity\\\": 1 } ] } }]'\\n```\\n\\nUsing the Redis Console tool, look inside the Redis cac\", \"he to see how the Redis state store component persisted the data:\\n\\n```\\n127.0.0.1:6379> KEYS * 1) \\\"ba\", \"sketservice||basket1\\\" 127.0.0.1:6379> HGETALL basketservice||basket1 1) \\\"data\\\" 2) \\\"{\\\\\\\"items\\\\\\\":[{\\\\\\\"it\", \"emId\\\\\\\":\\\\\\\"DaprHoodie\\\\\\\",\\\\\\\"quantity\\\\\\\":1}],\\\\\\\"customerId\\\\\\\":1}\\\" 3) \\\"version\\\" 4) \\\"1\\\"\\n```\\n\\nThe output shows \", \"the full Redis key for the data as basketservice||basket1 . By default, Dapr uses the application id\", \" of the Dapr instance ( basketservice ) as a prefix for the key. This naming convention enables mult\", \"iple Dapr instances to share the same data store without key name collisions. For the developer, it'\", \"s critical always to specify the same application id when running the application with Dapr. If omit\", \"ted, Dapr will generate a unique application ID. If the application id changes, the application can \", \"no longer access the state stored with the previous key prefix.\\n\\nThat said, it's possible to configu\", \"re a constant value for the key prefix in the keyPrefix metadata field in the state store component \", \"file. Consider the following example:\\n\\n```\\nspec: metadata: -name: keyPrefix -value: MyPrefix\\n```\\n\\nA \", \"constant key prefix enables the state store to be accessed across multiple Dapr applications. What's\", \" more, setting the keyPrefix to none omits the prefix completely.\\n\\n## Sample application: Dapr Traff\", \"ic Control\\n\\nIn the Dapr Traffic Control sample app, the TrafficControl service uses the Dapr state m\", \"anagement building block to persist the entry and exit timestamps of each passing vehicle. Figure 5-\", \"3 shows the conceptual architecture of the Dapr Traffic Control sample application. The Dapr state m\", \"anagement building block is used in flows marked with number 3 in the diagram:\\n\\n:::image type='conte\", \"nt' source='./media/state -management/dapr-solution-statemanagement.png' alttext='Conceptual archite\", \"cture of the Dapr Traffic Control sample application.':::\\n\\nFigure 5-3. Conceptual architecture of th\", \"e Dapr Traffic Control sample application.\\n\\nEntry and exit event logic is handled by the TrafficCont\", \"roller class, an ordinary ASP.NET Controller. The TrafficController.VehicleEntry method accepts an i\", \"ncoming VehicleRegistered message and saves the enclosed vehicle state:\\n\\n```\\n// store vehicle state \", \"var vehicleState = new VehicleState { LicenseNumber = msg.LicenseNumber, EntryTimestamp = msg.Timest\", \"amp }; await _vehicleStateRepository.SaveVehicleStateAsync(vehicleState);\\n```\\n\\nIn the preceding code\", \" snippet, the abstraction \\\\_vehicleStateRepository is responsible for saving state to the data store\", \". Its concrete implementation, DaprVehicleStateRepository , is shown below:\\n\\n```\\npublic class DaprVe\", \"hicleStateRepository : IVehicleStateRepository { private const string DAPR_STORE_NAME = \\\"statestore\\\"\", \"; private readonly DaprClient _daprClient; public DaprVehicleStateRepository(DaprClient daprClient) \", \"{ _daprClient = daprClient; } public async Task SaveVehicleStateAsync(VehicleState vehicleState) { a\", \"wait _daprClient.SaveStateAsync<VehicleState>( DAPR_STORE_NAME, vehicleState.LicenseNumber, vehicleS\", \"tate); } public async Task<VehicleState> GetVehicleStateAsync(string licenseNumber) { return await _\", \"daprClient.GetStateAsync<VehicleState>( DAPR_STORE_NAME, licenseNumber); } }\\n```\\n\\nAs the preceding c\", \"ode snippet shows, the implementation of the DaprVehicleStateRepository class is pretty straightforw\", \"ard. The SaveVehicleStateAsync method uses the injected DaprClient object\\n\\nto save the state to the \", \"configured Dapr state store. It uses the vehicle's license number as the key. The application can re\", \"trieve the saved state by calling the GetVehicleStateAsync method.\\n\\nThe TrafficControl service uses \", \"Redis as its underlying data store. Looking at the code, you'd never know it. A service consuming th\", \"e Dapr state management building block doesn't directly reference any state components. Instead, a D\", \"apr component configuration file specifies the store:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Compon\", \"ent metadata: name: statestore namespace: dapr-trafficcontrol spec: type: state.redis version: v1 me\", \"tadata: -name: redisHost value: localhost:6379 -name: redisPassword secretKeyRef: name: state.redisP\", \"assword key: state.redisPassword scopes: -trafficcontrolservice\\n```\\n\\n## Note\\n\\nThe component configur\", \"ation file includes an element secretKeyRef . The application uses it to reference the Redis passwor\", \"d value from the Dapr secrets building block. See chapter 10 to learn more about managing secrets wi\", \"th Dapr.\\n\\nThe type element in the configuration, state.redis instructs the building block to manage \", \"state with Dapr Redis component.\\n\\nThe scopes element in the configuration constrains application acc\", \"ess to the state store component. Only the TrafficControl service can access the state store.\\n\\n## Su\", \"mmary\\n\\nThe Dapr state management building block offers an API for storing key/value data across vari\", \"ous data stores. The API provides support for:\\n\\n- Bulk operations\\n- Strong and eventual consistency\\n\", \"- Optimistic concurrency control\\n- Multi-item transactions\\n\\nThe .NET SDK provides language-specific \", \"support for .NET and ASP.NET Core. Model binding integration simplifies accessing and updating state\", \" from ASP.NET Core controller action methods.\\n\\nIn the Dapr Traffic Control sample application, the b\", \"enefits of using Dapr state management are clear:\\n\\n1. It abstracts away the complexity of using thir\", \"d-party SDKs, such as StackExchange.Redis .\\n2. Replacing the underlying Redis cache with a different\", \" type of data store only requires changes to the component configuration file.\\n\\n## References\\n\\n- Dap\", \"r supported state stores\\n\\n## The Dapr service invocation building block\\n\\nAcross a distributed system\", \", one service often needs to communicate with another to complete a business operation. The Dapr ser\", \"vice invocation building block can help streamline the communication between services.\\n\\n## What it s\", \"olves\\n\\nMaking calls between services in a distributed application may appear easy, but there are man\", \"y challenges involved. For example:\\n\\n- Where the other services are located.\\n- How to call a service\", \" securely, given the service address.\\n- How to handle retries when short-lived transient errors occu\", \"r.\\n\\nLastly, as distributed applications compose many different services, capturing insights across s\", \"ervice call graphs are critical to diagnosing production issues.\\n\\nThe service invocation building bl\", \"ock addresses these challenges by using a Dapr sidecar as a reverse proxy for your service.\\n\\n## How \", \"it works\\n\\nLet's start with an example. Consider two services, 'Service A' and 'Service B'. Service A\", \" needs to call the catalog/items API on Service B. While Service A could take a dependency on Servic\", \"e B and make a direct call to it, Service A instead invokes the service invocation API on the Dapr s\", \"idecar. Figure 6-1 shows the operation.\\n\\nGET http://localhost:3500/v1.0/invoke/serviceb/method/catal\", \"og/items\\n\\nService A\\n\\nService B\\n\\nFigure 6-1. How Dapr service invocation works.\\n\\n<!-- image -->\\n\\nNote\", \" the steps from the previous figure:\\n\\n1. Service A makes a call to the catalog/items endpoint in Ser\", \"vice B by invoking the service invocation API on the Service A sidecar.\\n\\n[!NOTE] The sidecar uses a \", \"pluggable name resolution component to resolve the address of Service B. In self-hosted mode, Dapr u\", \"ses mDNS to find it. When running in Kubernetes mode, the Kubernetes DNS service determines the addr\", \"ess.\\n\\n2. The Service A sidecar forwards the request to the Service B sidecar.\\n3. The Service B sidec\", \"ar makes the actual catalog/items request against the Service B API.\\n4. Service B executes the reque\", \"st and returns a response back to its sidecar.\\n5. The Service B sidecar forwards the response back t\", \"o the Service A sidecar.\\n6. The Service A sidecar returns the response back to Service A.\\n\\nBecause t\", \"he calls flow through sidecars, Dapr can inject some useful cross-cutting behaviors:\\n\\n- Automaticall\", \"y retry calls upon failure.\\n- Make calls between services secure with mutual (mTLS) authentication, \", \"including automatic certificate rollover.\\n- Control what operations clients can do using access cont\", \"rol policies.\\n- Capture traces and metrics for all calls between services to provide insights and di\", \"agnostics.\\n\\nAny application can invoke a Dapr sidecar by using the native invoke API built into Dapr\", \". The API can be called with either HTTP or gRPC. Use the following URL to call the HTTP API:\\n\\nhttp:\", \"//localhost:&lt;dapr-port&gt;/v1.0/invoke/&lt;application-id&gt;/method/&lt;method-name&gt;\\n\\n- &lt;d\", \"apr-port&gt; the HTTP port that Dapr is listening on.\\n- &lt;application-id&gt; application ID of the\", \" service to call.\\n- &lt;method-name&gt; name of the method to invoke on the remote service.\\n\\nIn the \", \"following example, a curl call is made to the catalog/items 'GET' endpoint of Service B :\\n\\ncurl http\", \"://localhost:3500/v1.0/invoke/serviceb/method/catalog/items\\n\\n## Note\\n\\nThe Dapr APIs enable any appli\", \"cation stack that supports HTTP or gRPC to use Dapr building blocks. Therefore, the service invocati\", \"on building block can act as a bridge between protocols. Services can communicate with each other us\", \"ing HTTP, gRPC or a combination of both.\\n\\nIn the next section, you'll learn how to use the .NET SDK \", \"to simplify service invocation calls.\\n\\n## Use the Dapr .NET SDK\\n\\nThe Dapr .NET SDK provides .NET dev\", \"elopers with an intuitive and language-specific way to interact with Dapr. The SDK offers developers\", \" three ways of making remote service invocation calls:\\n\\n1. Invoke HTTP services using HttpClient\\n2. \", \"Invoke HTTP services using DaprClient\\n3. Invoke gRPC services using DaprClient\\n\\n## Invoke HTTP servi\", \"ces using HttpClient\\n\\nThe preferred way to call an HTTP endpoint is to use Dapr's rich integration w\", \"ith HttpClient . The following example submits an order by calling the submit method of the orderser\", \"vice application:\\n\\n```\\nvar httpClient = DaprClient.CreateInvokeHttpClient();\\n```\\n\\nawait httpClient.P\", \"ostAsJsonAsync(\\\"http://orderservice/submit\\\", order);\\n\\nIn the example, DaprClient.CreateInvokeHttpCli\", \"ent returns an HttpClient instance that is used to perform Dapr service invocation. The returned Htt\", \"pClient uses a special Dapr message handler that rewrites URIs of outgoing requests. The host name i\", \"s interpreted as the application ID of the service to call. The rewritten request that's actually be\", \"ing called is:\\n\\n```\\nhttp://127.0.0.1:3500/v1/invoke/orderservice/method/submit\\n```\\n\\nThis example use\", \"s the default value for the Dapr HTTP endpoint, which is http://127.0.0.1:&lt;daprhttp-port&gt;/ . T\", \"he value of dapr-http-port is taken from the DAPR\\\\_HTTP\\\\_PORT environment variable. If it's not set,\", \" the default port number 3500 is used.\\n\\nAlternatively, you can configure a custom endpoint in the ca\", \"ll to DaprClient.CreateInvokeHttpClient :\\n\\n```\\nvar httpClient = DaprClient.CreateInvokeHttpClient(da\", \"prEndpoint: \\\"localhost:4000\\\");\\n```\\n\\nYou can also directly set the base address by specifying the app\", \"lication ID. Doing so enables relative URIs when making a call:\\n\\n```\\nvar httpClient = DaprClient.Cre\", \"ateInvokeHttpClient(\\\"orderservice\\\"); await httpClient.PostAsJsonAsync(\\\"/submit\\\");\\n```\\n\\nThe HttpClien\", \"t object is intended to be long-lived. A single HttpClient instance can be reused for the lifetime o\", \"f the application. The next scenario demonstrates how an OrderServiceClient class reuses a Dapr Http\", \"Client instance:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddSingleto\", \"n<IOrderServiceClient, OrderServiceClient>( _ => new OrderServiceClient(DaprClient.CreateInvokeHttpC\", \"lient(\\\"orderservice\\\")));\\n```\\n\\nIn the snippet above, the OrderServiceClient is registered as a single\", \"ton with the ASP.NET Core dependency injection system. An implementation factory creates a new HttpC\", \"lient instance by calling DaprClient.CreateInvokeHttpClient . It then uses the newly created HttpCli\", \"ent to instantiate the OrderServiceClient object. By registering the OrderServiceClient as a singlet\", \"on, it will be reused for the lifetime of the application.\\n\\nThe OrderServiceClient itself has no Dap\", \"r-specific code. Even though Dapr service invocation is used under the hood, you can treat the Dapr \", \"HttpClient like any other HttpClient:\\n\\n```\\npublic class OrderServiceClient : IOrderServiceClient { p\", \"rivate readonly HttpClient _httpClient; public OrderServiceClient(HttpClient httpClient) { _httpClie\", \"nt = httpClient ?? throw new ArgumentNullException(nameof(httpClient)); } public async Task SubmitOr\", \"der(Order order) { var response = await _httpClient.PostAsJsonAsync(\\\"submit\\\", order); response.Ensur\", \"eSuccessStatusCode(); } }\\n```\\n\\nUsing the HttpClient class with Dapr service invocation has many bene\", \"fits:\\n\\n- HttpClient is a well-known class that many developers already use in their code. Using Http\", \"Client for Dapr service invocation allows developers to reuse their existing skills.\\n- HttpClient su\", \"pports advanced scenarios, such as custom headers, and full control over request and response messag\", \"es.\\n- In .NET 5, HttpClient supports automatic serialization and deserialization using System.Text.J\", \"son.\\n- HttpClient integrates with many existing frameworks and libraries, such as Refit, RestSharp, \", \"and Polly.\\n\\n## Invoke HTTP services using DaprClient\\n\\nWhile HttpClient is the preferred way to invok\", \"e services using HTTP semantics, you can also use the DaprClient.InvokeMethodAsync family of methods\", \". The following example submits an order by calling the submit method of the orderservice applicatio\", \"n:\\n\\n```\\nvar daprClient = new DaprClientBuilder().Build(); try { var confirmation = await daprClient.\", \"InvokeMethodAsync<Order, OrderConfirmation>( \\\"orderservice\\\", \\\"submit\\\", order); } catch (InvocationEx\", \"ception ex) { // Handle error }\\n```\\n\\nThe third argument, an order object, is serialized internally (\", \"with System.Text.JsonSerializer ) and sent as the request payload. The .NET SDK takes care of the ca\", \"ll to the sidecar. It also deserializes the response to an OrderConfirmation object. Because no HTTP\", \" method is specified, the request is executed as an HTTP POST.\\n\\nThe next example demonstrates how yo\", \"u can make an HTTP GET request by specifying the HttpMethod :\\n\\n```\\nvar catalogItems = await daprClie\", \"nt.InvokeMethodAsync<IEnumerable<CatalogItem>>(HttpMethod.Get, \\\"catalogservice\\\", \\\"items\\\");\\n```\\n\\nFor \", \"some scenarios, you may require more control over the request message. For example, when you need to\", \" specify request headers, or you want to use a custom serializer for the payload. DaprClient.CreateI\", \"nvokeMethodRequest creates an HttpRequestMessage . The following example demonstrates how to add an \", \"HTTP authorization header to a request message:\\n\\n```\\nvar request = daprClient.CreateInvokeMethodRequ\", \"est(\\\"orderservice\\\", \\\"submit\\\", order); request.Headers.Authorization = new AuthenticationHeaderValue(\", \"\\\"bearer\\\", token);\\n```\\n\\nThe HttpRequestMessage now has the following properties set:\\n\\n- Url = http://\", \"127.0.0.1:3500/v1.0/invoke/orderservice/method/submit\\n- HttpMethod = POST\\n- Content = JsonContent ob\", \"ject containing the JSON-serialized order\\n- Headers.Authorization = 'bearer &lt;token&gt;'\\n\\nOnce you\", \"'ve got the request set up the way you want, use DaprClient.InvokeMethodAsync to send it:\\n\\n```\\nvar o\", \"rderConfirmation = await daprClient.InvokeMethodAsync<OrderConfirmation>(request);\\n```\\n\\nDaprClient.I\", \"nvokeMethodAsync deserializes the response to an OrderConfirmation object if the request is successf\", \"ul. Alternatively, you can use DaprClient.InvokeMethodWithResponseAsync to get full access to the un\", \"derlying HttpResponseMessage :\\n\\n```\\nvar response = await daprClient.InvokeMethodWithResponseAsync(re\", \"quest); response.EnsureSuccessStatusCode(); var orderConfirmation = response.Content.ReadFromJsonAsy\", \"nc<OrderConfirmation>();\\n```\\n\\n## Note\\n\\nFor service invocation calls using HTTP, it's worth consideri\", \"ng using the Dapr HttpClient integration presented in the previous section. Using HttpClient gives y\", \"ou additional benefits such as integration with existing frameworks and libraries.\\n\\n## Invoke gRPC s\", \"ervices using DaprClient\\n\\nDaprClient provides a family of InvokeMethodGrpcAsync methods for calling \", \"gRPC endpoints. The main difference with the HTTP methods is the use of a Protobuf serializer instea\", \"d of JSON. The following example invokes the submitOrder method of the orderservice over gRPC.\\n\\n```\\n\", \"var daprClient = new DaprClientBuilder().Build(); try { var confirmation = await daprClient.InvokeMe\", \"thodGrpcAsync<Order, OrderConfirmation>(\\\"orderservice\\\", \\\"submitOrder\\\", order); } catch (InvocationEx\", \"ception ex) { // Handle error }\\n```\\n\\nIn the example above, DaprClient serializes the given order obj\", \"ect using Protobuf and uses the result as the gRPC request body. Likewise, the response body is Prot\", \"obuf deserialized and returned to the caller. Protobuf typically provides better performance than th\", \"e JSON payloads used in HTTP service invocation.\\n\\n## Name resolution components\\n\\nAt the time of writ\", \"ing, Dapr provides support for the following name resolution components:\\n\\n- mDNS (default when runni\", \"ng self-hosted)\\n- Kubernetes Name Resolution (default when running in Kubernetes)\\n- HashiCorp Consul\", \"\\n\\n## Configuration\\n\\nTo use a non-default name resolution component, add a nameResolution spec to the\", \" application's Dapr configuration file. Here's an example of a Dapr configuration file that enable s\", \" HashiCorp Consul name resolution:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Configuration metadata:\\n`\", \"``\\n\\n```\\nname: dapr-config spec: nameResolution: configuration:\\n```\\n\\n```\\ncomponent: \\\"consul\\\" selfRegi\", \"ster: true\\n```\\n\\n## Sample application: Dapr Traffic Control\\n\\nIn Dapr Traffic Control sample app, the\", \" FineCollection service uses the Dapr service invocation building block to retrieve vehicle and owne\", \"r information from the VehicleRegistration service. Figure 6-2 shows the conceptual architecture of \", \"the Dapr Traffic Control sample application. The Dapr service invocation building block is used in f\", \"lows marked with number 1 in the diagram:\\n\\n```\\n:::image type='content' source='./media/service -invo\", \"cation/dapr-solution-serviceinvocation.png' alttext='Conceptual architecture of the Dapr Traffic Con\", \"trol sample application.'::: Figure 6-2. Conceptual architecture of the Dapr Traffic Control sample \", \"application. Information is retrieved by the ASP.NET CollectionController class in the FineCollectio\", \"n service. The CollectFine method expects an incoming SpeedingViolation parameter. It invokes a Dapr\", \" service invocation building block to call to the VehicleRegistration service. The code snippet is p\", \"resented below. :::{customstyle=CodeBox} ```csharp [Topic('pubsub', 'speedingviolations')] [Route('c\", \"ollectfine')] [HttpPost] public async Task CollectFine(SpeedingViolation speedingViolation, [FromSer\", \"vices] DaprClient daprClient) { // \\u2026 // get owner info (Dapr service invocation) var vehicleInfo = _\", \"vehicleRegistrationService.GetVehicleInfo(speedingViolation.VehicleId).Result; // ... } ``` ::: The \", \"code uses a proxy of type VehicleRegistrationService to call the VehicleRegistration service. ASP.NE\", \"T Core injects an instance of the service proxy using constructor injection: :::{custom-style=CodeBo\", \"x} csharp  public CollectionController(      ILogger<CollectionController> logger,      IFineCalcula\", \"tor fineCalculator,      VehicleRegistrationService vehicleRegistrationService, DaprClient daprClien\", \"t)  {      // ...  } ::: The VehicleRegistrationService class contains a single method: GetVehicleIn\", \"fo . It uses the ASP.NET Core HttpClient to call the VehicleRegistration service: _httpClient; publi\", \"c VehicleRegistrationService(HttpClient httpClient) { _httpClient = httpClient; }\\n```\\n\\n```\\n:::{custo\", \"m-style=CodeBox} ```csharp public class VehicleRegistrationService { private HttpClient public async\", \" Task<VehicleInfo> GetVehicleInfo(string licenseNumber) {\\n```\\n\\n```\\nreturn await _httpClient.GetFromJ\", \"sonAsync<VehicleInfo>(\\n```\\n\\n```\\n$\\\"vehicleinfo/{licenseNumber}\\\"); } } ``` :::\\n```\\n\\nThe code doesn't d\", \"epend on any Dapr classes directly. It instead leverages the Dapr ASP.NET Core integration as descri\", \"bed in the Invoke HTTP services using HttpClient section of this module. The following code in the C\", \"onfigureService method of the Startup class registers the VehicleRegistrationService proxy:\\n\\n```\\nvar\", \" builder = WebApplication.CreateBuilder(args); builder.Services.AddSingleton<VehicleRegistrationServ\", \"ice>(_ => new VehicleRegistrationService(DaprClient.CreateInvokeHttpClient( \\\"vehicleregistrationserv\", \"ice\\\", $\\\"http://localhost:{daprHttpPort}\\\" )));\\n```\\n\\nThe DaprClient.CreateInvokeHttpClient creates an \", \"HttpClient instance that calls the VehicleRegistration service using the service invocation building\", \" block under the covers. It expects both the Dapr app-id of the target service and the URL of its Da\", \"pr sidecar. At start time, the daprHttpPort argument contains the port number used for HTTP communic\", \"ation with the Dapr sidecar.\\n\\nUsing Dapr service invocation in the Traffic Control sample applicatio\", \"n provides several benefits:\\n\\n1. Decouples the location of the target service.\\n2. Adds resiliency wi\", \"th automatic retry features.\\n3. Ability to reuse an existing HttpClient based proxy (offered by the \", \"ASP.NET Core integration).\\n\\n## Summary\\n\\nIn this chapter, you learned about the service invocation bu\", \"ilding block. You saw how to invoke remote methods both by making direct HTTP calls to the Dapr side\", \"car, and by using the Dapr .NET SDK.\\n\\nThe Dapr .NET SDK provides multiple ways to invoke remote meth\", \"ods. HttpClient support is great for developers wanting to reuse existing skills and is compatible w\", \"ith many existing frameworks and libraries. DaprClient offers support for directly using the Dapr se\", \"rvice invocation API using either HTTP or gRPC semantics.\\n\\n## References\\n\\n- Dapr service invocation \", \"building block\\n- Monitoring distributed cloud-native applications\\n\\nPublisher\\n\\nMessage broker\\n\\n## The\", \" Dapr publish &amp; subscribe building block\\n\\nThe Publish-Subscribe pattern (often referred to as 'p\", \"ub/sub') is a well -known and widely used messaging pattern. Architects commonly embrace it in distr\", \"ibuted applications. However, the plumbing to implement it can be complex. There are often subtle fe\", \"ature differences across different messaging products. Dapr offers a building block that significant\", \"ly simplifies implementing pub/sub functionality.\\n\\n## What it solves\\n\\nThe primary advantage of the P\", \"ublish-Subscribe pattern is loose coupling , sometimes referred to as temporal decoupling. The patte\", \"rn decouples services that send messages (the publishers ) from services that consume messages (the \", \"subscribers ). Both publishers and subscribers are unaware of each other - both are dependent on a c\", \"entralized message broker that distributes the messages.\\n\\nFigure 7-1 shows the high-level architectu\", \"re of the pub/sub pattern.\\n\\nFigure 7-1. The pub/sub pattern.\\n\\n<!-- image -->\\n\\nFrom the previous figu\", \"re, note the steps of the pattern:\\n\\n1. Publishers send messages to the message broker.\\n2. Subscriber\", \"s bind to a subscription on the message broker.\\n\\n3. The message broker forwards a copy of the messag\", \"e to interested subscriptions.\\n4. Subscribers consume messages from their subscriptions.\\n\\nMost messa\", \"ge brokers encapsulate a queueing mechanism that can persist messages once received. With it, the me\", \"ssage broker guarantees durability by storing the message. Subscribers don't need to be immediately \", \"available or even online when a publisher sends a message. Once available, the subscriber receives a\", \"nd processes the message. Dapr guarantees At-Least-Once semantics for message delivery. Once a messa\", \"ge is published, it will be delivered at least once to any interested subscriber.\\n\\n## Tip\\n\\nIf your s\", \"ervice can only process a message once, you'll need to provide an idempotency check to ensure that t\", \"he same message is not processed multiple times. While such logic can be coded, some message brokers\", \", such as Azure Service Bus, provide built-in duplicate detection messaging capabilities.\\n\\nThere are\", \" several message broker products available - both commercially and open-source. Each has advantages \", \"and drawbacks. Your job is to match your system requirements to the appropriate broker. Once selecte\", \"d, it's a best practice to decouple your application from message broker plumbing. You achieve this \", \"functionality by wrapping the broker inside an abstraction . The abstraction encapsulates the messag\", \"e plumbing and exposes generic pub/sub operations to your code. Your code communicates with the abst\", \"raction, not the actual message broker. While a wise decision, you'll have to write and maintain the\", \" abstraction and its underlying implementation. This approach requires custom code that can be compl\", \"ex, repetitive, and error-prone.\\n\\nThe Dapr publish &amp; subscribe building block provides the messa\", \"ging abstraction and implementation out-of-the-box. The custom code you would have had to write is p\", \"rebuilt and encapsulated inside the Dapr building block. You bind to it and consume it. Instead of w\", \"riting messaging plumbing code, you and your team focus on creating business functionality that adds\", \" value to your customers.\\n\\n## How it works\\n\\nThe Dapr publish &amp; subscribe building block provides\", \" a platform-agnostic API framework to send and receive messages. Your services publish messages to a\", \" named topic. Your services subscribe to a topic to consume messages.\\n\\nThe service calls the pub/sub\", \" API on the Dapr sidecar. The sidecar then makes calls into a pre-defined Dapr pub/sub component tha\", \"t encapsulates a specific message broker product. Figure 7-2 shows the Dapr pub/sub messaging stack.\", \"\\n\\nRabbitMQ\\n\\ncomponent\\n\\nFigure 7-2. The Dapr pub/sub stack.\\n\\n<!-- image -->\\n\\nThe Dapr publish &amp; s\", \"ubscribe building block can be invoked in many ways.\\n\\nAt the lowest level, any programming platform \", \"can invoke the building block over HTTP or gRPC using the Dapr native API . To publish a message, yo\", \"u make the following API call:\\n\\n```\\nhttp://localhost:<dapr-port>/v1.0/publish/<pub-sub-name>/<topic>\", \"\\n```\\n\\nThere are several Dapr specific URL segments in the above call:\\n\\n- &lt;dapr-port&gt; provides \", \"the port number upon which the Dapr sidecar is listening.\\n- &lt;pub-sub-name&gt; provides the name o\", \"f the selected Dapr pub/sub component.\\n- &lt;topic&gt; provides the name of the topic to which the m\", \"essage is published.\\n\\nUsing the curl command-line tool to publish a message, you can try it out:\\n\\n``\", \"`\\ncurl -X POST http://localhost:3500/v1.0/publish/pubsub/newOrder \\\\ -H \\\"Content-Type: application/js\", \"on\\\" \\\\ -d '{ \\\"orderId\\\": \\\"1234\\\", \\\"productId\\\": \\\"5678\\\", \\\"amount\\\": 2 }'\\n```\\n\\nYou receive messages by subs\", \"cribing to a topic. At startup, the Dapr runtime will call the application on a well-known endpoint \", \"to identify and create the required subscriptions:\\n\\nhttp://localhost:&lt;appPort&gt;/dapr/subscribe\\n\", \"\\n- &lt;appPort&gt; informs the Dapr sidecar of the port upon which the application is listening.\\n\\nYo\", \"u can implement this endpoint yourself. But Dapr provides more intuitive ways of implementing it. We\", \"'ll address this functionality later in this chapter.\\n\\nThe response from the call contains a list of\", \" topics to which the applications will subscribe. Each includes an endpoint to call when the topic r\", \"eceives a message. Here's an example of a response:\\n\\n```\\n[ { \\\"pubsubname\\\": \\\"pubsub\\\", \\\"topic\\\": \\\"newOr\", \"der\\\", \\\"route\\\": \\\"/orders\\\" }, { \\\"pubsubname\\\": \\\"pubsub\\\", \\\"topic\\\": \\\"newProduct\\\", \\\"route\\\": \\\"/productCatal\", \"og/products\\\" } ]\\n```\\n\\nIn the JSON response, you can see the application wants to subscribe to topics\", \" newOrder and newProduct . It registers the endpoints /orders and /productCatalog/products for each,\", \" respectively. For both subscriptions, the application is binding to the Dapr component named pubsub\", \" .\\n\\nFigure 7-3 presents the flow of the example.\\n\\nPOST http://localhost:3500/v1.0/publish/pubsub/new\", \"Order\\n\\nService A\\n\\nService B\\n\\nFigure 7-3. Pub/sub flow with Dapr.\\n\\n<!-- image -->\\n\\n## From the previo\", \"us figure, note the flow:\\n\\n1. The Dapr sidecar for Service B calls the /dapr/subscribe endpoint from\", \" Service B (the consumer). The service responds with the subscriptions it wants to create.\\n2. The Da\", \"pr sidecar for Service B creates the requested subscriptions on the message broker.\\n3. Service A pub\", \"lishes a message at the /v1.0/publish/&lt;pub-sub-name&gt;/&lt;topic&gt; endpoint on the Dapr Servic\", \"e A sidecar.\\n4. The Service A sidecar publishes the message to the message broker.\\n5. The message br\", \"oker sends a copy of the message to the Service B sidecar.\\n6. The Service B sidecar calls the endpoi\", \"nt corresponding to the subscription (in this case /orders ) on Service B. The service responds with\", \" an HTTP status-code 200 OK so the sidecar will consider the message as being handled successfully.\\n\", \"\\nIn the example, the message is handled successfully. But if something goes wrong while Service B is\", \" handling the request, it can use the response to specify what needs to happen with the message. Whe\", \"n it returns an HTTP status-code 404 , an error is logged and the message is dropped. With any other\", \" status-code than 200 or 404 , a warning is logged and the message is retried. Alternatively,\\n\\nServi\", \"ce B can explicitly specify what needs to happen with the message by including a JSON payload in the\", \" body of the response:\\n\\n```\\n{ \\\"status\\\": \\\"<status>\\\" }\\n```\\n\\nThe following table shows the available st\", \"atus values:\\n\\n| Status           | Action                                                           \", \"|\\n|------------------|------------------------------------------------------------------|\\n| SUCCESS \", \"         | The message is considered as processed successfully and dropped. |\\n| RETRY            | T\", \"he message is retried.                                          |\\n| DROP             | A warning is \", \"logged and the message is dropped.                  |\\n| Any other status | The message is retried.  \", \"                                        |\\n\\n## Competing consumers\\n\\nWhen scaling out an application t\", \"hat subscribes to a topic, you have to deal with competing consumers. Only one application instance \", \"should handle a message sent to the topic. Luckily, Dapr handles that problem. When multiple instanc\", \"es of a service with the same application-id subscribe to a topic, Dapr delivers each message to onl\", \"y one of them.\\n\\n## Use the Dapr .NET SDK\\n\\nFor .NET Developers, the Dapr .NET SDK provides a more pro\", \"ductive way of working with Dapr. The SDK exposes a DaprClient class through which you can directly \", \"invoke Dapr functionality. It's intuitive and easy to use.\\n\\nTo publish a message, the DaprClient exp\", \"oses a PublishEventAsync method.\\n\\n```\\nvar data = new OrderData { orderId = \\\"123456\\\", productId = \\\"67\", \"890\\\", amount = 2 }; var daprClient = new DaprClientBuilder().Build(); await daprClient.PublishEventA\", \"sync<OrderData>(\\\"pubsub\\\", \\\"newOrder\\\", data);\\n```\\n\\n- The first argument pubsub is the name of the Dap\", \"r component that provides the message broker implementation. We'll address components later in this \", \"chapter.\\n- The second argument neworder provides the name of the topic to send the message to.\\n- The\", \" third argument is the payload of the message.\\n- You can specify the .NET type of the message using \", \"the generic type parameter of the method.\\n\\nTo receive messages, you bind an endpoint to a subscripti\", \"on for a registered topic. The AspNetCore library for Dapr makes this trivial. Assume, for example, \", \"that you have an existing ASP.NET WebAPI action method entitled CreateOrder :\\n\\n```\\n[HttpPost(\\\"/order\", \"s\\\")]\\n```\\n\\n```\\npublic async Task<ActionResult> CreateOrder(Order order)\\n```\\n\\n```\\nImportant You must a\", \"dd a reference to the Dapr.AspNetCore NuGet package in your project to consume the\\n```\\n\\nDapr ASP.NET\", \" Core integration.\\n\\nTo bind this action method to a topic, you decorate it with the Topic attribute:\", \"\\n\\n```\\n[Topic(\\\"pubsub\\\", \\\"newOrder\\\")] [HttpPost(\\\"/orders\\\")] public async Task<ActionResult> CreateOrde\", \"r(Order order)\\n```\\n\\nYou specify two key elements with this attribute:\\n\\n- The Dapr pub/sub component \", \"to target (in this case pubsub ).\\n- The topic to subscribe to (in this case newOrder ).\\n\\nDapr then i\", \"nvokes that action method as it receives messages for that topic.\\n\\nYou'll also need to enable ASP.NE\", \"T Core to use Dapr. The Dapr .NET SDK provides several extension methods that can be used to do this\", \".\\n\\nIn the Program.cs file, you must call the following extension method on the WebApplication builde\", \"r to register Dapr:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddContr\", \"ollers().AddDapr();\\n```\\n\\nAppending the AddDapr extension method to the AddControllers extension meth\", \"od registers the necessary services to integrate Dapr into the MVC pipeline. It also registers a Dap\", \"rClient instance into the dependency injection container, which then can be injected anywhere into y\", \"our service.\\n\\nAfter the WebApplication has been created, you must add the following middleware compo\", \"nents to enable Dapr:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); var app = builder.Build\", \"(); app.UseCloudEvents(); app.MapControllers(); app.MapSubscribeHandler();\\n```\\n\\nThe call to UseCloud\", \"Events adds CloudEvents middleware into to the ASP.NET Core middleware pipeline. This middleware wil\", \"l unwrap requests that use the CloudEvents structured format, so the receiving method can read the e\", \"vent payload directly.\\n\\n## Note\\n\\nCloudEvents is a standardized messaging format, providing a common \", \"way to describe event information across platforms. Dapr embraces CloudEvents. For more information \", \"about CloudEvents, see the cloudevents specification.\\n\\nThe call to MapSubscribeHandler in the endpoi\", \"nt routing configuration will add a Dapr subscribe endpoint to the application. This endpoint will r\", \"espond to requests on /dapr/subscribe . When this endpoint is called, it will automatically find all\", \" WebAPI action methods decorated with the Topic attribute and instruct Dapr to create subscriptions \", \"for them.\\n\\n## Pub/sub components\\n\\nDapr pub/sub components handle the actual transport of the message\", \"s. Several are available. Each encapsulates a specific message broker product to implement the pub/s\", \"ub functionality. At the time of writing, the following pub/sub components were available:\\n\\n- Apache\", \" Kafka\\n- AWS SNS/SQS\\n- Azure Event Hubs\\n- Azure Service Bus\\n- GCP Pub/Sub\\n- Hazelcast\\n- In Memory\\n- \", \"JetStream\\n- MQTT\\n- NATS Streaming\\n- Pulsar\\n- RabbitMQ\\n- Redis Streams\\n\\n## Note\\n\\nThe Azure cloud stac\", \"k has both messaging functionality (Azure Service Bus) and event streaming (Azure Event Hub) availab\", \"ility.\\n\\nThese components are created by the community in a component-contrib repository on GitHub. Y\", \"ou're encouraged to write your own Dapr component for a message broker that isn't yet supported.\\n\\n##\", \" Configuration\\n\\nUsing a Dapr configuration file, you can specify the pub/sub component(s) to use. Th\", \"is configuration contains several fields. The name field specifies the pub/sub component that you wa\", \"nt to use. When sending or receiving a message, you need to specify this name (as you saw earlier in\", \" the PublishEventAsync method signature).\\n\\nBelow you see an example of a Dapr configuration file for\", \" configuring a RabbitMQ message broker component:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component \", \"metadata: name: pubsub-rq spec: type: pubsub.rabbitmq version: v1 metadata: -name: host value: \\\"amqp\", \"://localhost:5672\\\" -name: durable value: true\\n```\\n\\nIn this example, you can see that you can specify\", \" any message broker-specific configuration in the metadata block. In this case, RabbitMQ is configur\", \"ed to create durable queues. But the RabbitMQ component has more configuration options. Each of the \", \"components' configuration will have its own set of possible fields. You can read which fields are av\", \"ailable in the documentation of each pub/sub component.\\n\\nNext to the programmatic way of subscribing\", \" to a topic from code, Dapr pub/sub also provides a declarative way of subscribing to a topic. This \", \"approach removes the Dapr dependency from the application code. Therefore, it also enables an existi\", \"ng application to subscribe to topics without any changes to the code. The following example shows a\", \" Dapr configuration file for configuring a subscription:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Sub\", \"scription metadata: name: newOrder-subscription spec: pubsubname: pubsub topic: newOrder route: /ord\", \"ers scopes: -ServiceB -ServiceC\\n```\\n\\nYou have to specify several elements with every subscription:\\n\\n\", \"- The name of the Dapr pub/sub component you want to use (in this case pubsub ).\\n- The name of the t\", \"opic to subscribe to (in this case newOrder ).\\n- The API operation that needs to be called for this \", \"topic (in this case /orders ).\\n- The scope can specify which services can publish and subscribe to a\", \" topic.\\n\\n## Sample application: Dapr Traffic Control\\n\\nIn Dapr Traffic Control sample app, the Traffi\", \"cControl service uses the Dapr pub/sub building block to send speeding violations to the FineCollect\", \"ion service. Figure 7-4 shows the conceptual architecture\\n\\nof the Dapr Traffic Control sample applic\", \"ation. The Dapr pub/sub building block is used in flows marked with number 2 in the diagram:\\n\\n:::ima\", \"ge type='content' source='./media/publish -subscribe/dapr-solution-pubsub.png' alt -text='Conceptual\", \" architecture of the Dapr Traffic Control sample application.':::\\n\\nFigure 7-4. Conceptual architectu\", \"re of the Dapr Traffic Control sample application.\\n\\nSpeeding violations are handled by the Collectio\", \"nController , an ordinary ASP.NET Core Controller. The CollectionController.CollectFine method subsc\", \"ribes to and handles SpeedingViolation event messages:\\n\\n```\\n[Topic(\\\"pubsub\\\", \\\"speedingviolations\\\")] \", \"[Route(\\\"collectfine\\\")] [HttpPost] public async Task<ActionResult> CollectFine( SpeedingViolation spe\", \"edingViolation, [FromServices] DaprClient daprClient) { // ... }\\n```\\n\\nThe method is decorated with t\", \"he Dapr Topic attribute. It specifies that the pub/sub component named pubsub should be used to subs\", \"cribe to messages sent to the speedingviolations topic.\\n\\nThe TrafficControl service sends speeding v\", \"iolations. Near the end of the VehicleExit method in the TrafficController class, the DaprClient obj\", \"ect is used to publish SpeedingViolation messages using the pub/sub building block:\\n\\n```\\n/// ... var\", \" speedingViolation = new SpeedingViolation { VehicleId = msg.LicenseNumber, RoadId = _roadId, Violat\", \"ionInKmh = violation, Timestamp = msg.Timestamp }; // publish speedingviolation (Dapr publish / subs\", \"cribe) await daprClient.PublishEventAsync(\\\"pubsub\\\", \\\"speedingviolations\\\", speedingViolation); /// ..\", \".\\n```\\n\\nNote how the DaprClient object reduces the call to a single line of code, again, binding to t\", \"he speedingviolations topic and the Dapr pubsub component.\\n\\nWhile the Traffic Control app uses Rabbi\", \"tMQ as the message broker, it never directly references RabbitMQ. Instead, the accompanying Dapr com\", \"ponent configuration file named pubsub.yaml in the /dapr/components folder specifies the message bro\", \"ker:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: pubsub namespace: dapr-traffi\", \"ccontrol spec: type: pubsub.rabbitmq\\n```\\n\\n```\\nversion: v1 metadata: -name: host value: \\\"amqp://local\", \"host:5672\\\" -name: durable value: \\\"false\\\" -name: deletedWhenUnused value: \\\"false\\\" -name: autoAck valu\", \"e: \\\"false\\\" -name: reconnectWait value: \\\"0\\\" -name: concurrency value: parallel scopes: -trafficcontro\", \"lservice -finecollectionservice\\n```\\n\\nThe type element in the configuration, pubsub.rabbitmq instruct\", \"s the building block to use the Dapr RabbitMQ component.\\n\\nThe scopes element in the configuration co\", \"nstrains application access to the RabbitMQ component. Only the TrafficControl and FineCollection se\", \"rvices can consume it.\\n\\nUsing Dapr pub/sub in the Traffic Control sample application offers the foll\", \"owing benefits:\\n\\n1. No infrastructural abstraction of a message broker to maintain.\\n2. Services are \", \"temporally decoupled, which increases robustness.\\n3. Publisher and subscribers are unaware of each o\", \"ther. This means that additional services could be introduced that will react to speeding violations\", \" in the future, without the need to change the TrafficControl service.\\n\\n## Summary\\n\\nThe pub/sub patt\", \"ern helps you decouple services in a distributed application. The Dapr publish &amp; subscribe build\", \"ing block simplifies implementing this behavior in your application.\\n\\nThrough Dapr pub/sub, you can \", \"publish messages to a specific topic . As well, the building block will query your service to determ\", \"ine which topic(s) to subscribe to.\\n\\nYou can use Dapr pub/sub natively over HTTP or by using one of \", \"the language-specific SDKs, such as the .NET SDK for Dapr. The .NET SDK tightly integrates with the \", \"ASP.NET core platform.\\n\\nWith Dapr, you can plug a supported message broker product into your applica\", \"tion. You can then swap message brokers without requiring code changes to your application.\\n\\n## Refe\", \"rences\\n\\n- Dapr supported pub/sub brokers\\n\\nExternal\\n\\nResource\\n\\nTwitter\\n\\n\\u2192\\n\\nDapr dapr\\n\\nSidecar\\n\\nYour s\", \"ervice\\n\\nExternal\\n\\nResource\\n\\n\\u2192\\n\\nTwilio SMS\\n\\n## The Dapr bindings building block\\n\\nCloud-based serverle\", \"ss offerings, such as Azure Functions and AWS Lambda, have gained wide adoption across the distribut\", \"ed architecture space. Among many benefits, they enable a microservice to handle events from or invo\", \"ke events in an external system - abstracting away the underlying complexity and plumbing concerns. \", \"External resources are many: They include datastores, message systems, and web resources, across dif\", \"ferent platforms and vendors. The Dapr bindings building block brings these same resource binding ca\", \"pabilities to the doorstep of your Dapr applications.\\n\\n## What it solves\\n\\nDapr resource bindings ena\", \"ble your services to integrate business operations across external resources outside of the immediat\", \"e application. An event from an external system could trigger an operation in your service passing i\", \"n contextual information. Your service could then expand the operation by triggering an event in ano\", \"ther external system, passing in contextual payload information. Your service communicates without c\", \"oupling or awareness of the external resource. The plumbing is encapsulated inside pre-defined Dapr \", \"components. The Dapr component to use can be easily swapped at run time without code changes.\\n\\nConsi\", \"der, for example, a Twitter account that triggers an event whenever a user tweets a keyword. Your se\", \"rvice exposes an event handler that receives and processes the tweet. Once complete, your service tr\", \"iggers an event that invokes an external Twilio service. Twilio sends an SMS message that includes t\", \"he tweet. Figure 8-1 show the conceptual architecture of this operation:\\n\\nFigure 8-1. Conceptual arc\", \"hitecture of a Dapr resource binding.\\n\\n<!-- image -->\\n\\nAt first glance, resource binding behavior ma\", \"y appear similar to the Publish/Subscribe pattern described earlier in this book. While they share s\", \"imilarities, there are differences. Publish/subscribe\\n\\n\\u2192\\n\\nDapr dapr\\n\\nSidecar\\n\\n<!-- image -->\\n\\n## How\", \" it works\\n\\nPOST http://localhost:6000/tweet focuses on asynchronous communication between Dapr servi\", \"ces. Resource binding has a much wider scope. It focuses on system interoperability across software \", \"platforms. Exchanging information between disparate applications, datastores, and services outside y\", \"our microservice application.\\n\\nYour service\\n\\nDapr resource binding starts with a component configura\", \"tion file. This YAML file describes the type of resource to which you'll bind along with its configu\", \"ration settings. Once configured, your service can receive events from the resource or trigger event\", \"s on it.\\n\\n<!-- image -->\\n\\n| Note                                                                    \", \"        |\\n|---------------------------------------------------------------------------------|\\n| Bind\", \"ing configurations are presented in detail later in the Components section. |\\n\\n## Input bindings\\n\\nBi\", \"nding configuration\\n\\nInput bindings trigger your code with incoming events from external resources. \", \"To receive events and data, you register a public endpoint from your service that becomes the event \", \"handler . Figure 8-2 shows the flow:\\n\\nFigure 8-2. Dapr input binding flow.\\n\\n<!-- image -->\\n\\nFigure 8\", \".2 describes the steps for receiving events from an external Twitter account:\\n\\ncomponent\\n\\n1. The Dap\", \"r sidecar reads the binding configuration file and subscribes to the event specified for the externa\", \"l resource. In the example, the event source is a Twitter account.\\n2. When a matching Tweet is publi\", \"shed on Twitter, the binding component running in the Dapr sidecar picks it up and triggers an event\", \".\\n3. The Dapr sidecar invokes the endpoint (that is, event handler) configured for the binding. In t\", \"he example, the service listens for an HTTP POST on the /tweet endpoint on port 6000. Because i t's \", \"an HTTP POST operation, the JSON payload for the event is passed in the request body.\\n4. After handl\", \"ing the event, the service returns an HTTP status code 200 OK .\\n\\nThe following ASP.NET Core controll\", \"er provides an example of handling an event triggered by the Twitter binding:\\n\\n```\\n[ApiController] p\", \"ublic class SomeController : ControllerBase { public class TwitterTweet { [JsonPropertyName(\\\"id_str\\\"\", \")] public string ID { get ; set ; } [JsonPropertyName(\\\"text\\\")] public string Text { get ; set ; } } \", \"[HttpPost(\\\"/tweet\\\")] public ActionResult Post(TwitterTweet tweet) { // Handle tweet Console.WriteLin\", \"e(\\\"Tweet received: {0}: {1}\\\", tweet.ID, tweet.Text); // ... // Acknowledge message return Ok(); } }\\n\", \"```\\n\\nIf the operation should error, you would return the appropriate 400 or 500 level HTTP status co\", \"de. For bindings that feature at-least-once delivery guarantees, the Dapr sidecar will retry the tri\", \"gger. Check out Dapr documentation for resource bindings to see whether they offer at-least-once or \", \"exactly-once delivery guarantees.\\n\\n## Output bindings\\n\\nDapr also includes output binding capabilitie\", \"s. They enable your service to trigger an event that invokes an external resource. Again, you start \", \"by configuring a binding configuration YAML file that describes the output binding. Once in place, y\", \"ou trigger an event that invokes the bindings API on the Dapr sidecar of your application. Figure 8-\", \"3 shows the flow of an output binding:\\n\\nPOST http://localhost:3500/v1.0/bindings/sms\\n\\n7=\\u2022\\n\\n=\\n\\n=\\n\\n<!-\", \"- image -->\\n\\nYour service\\n\\nBinding configuration\\n\\nFigure 8-3. Dapr output binding flow.\\n\\n1. The Dapr\", \" sidecar reads the binding configuration file with the information on how to connect to the external\", \" resource. In the example, the external resource is a Twilio SMS account.\\n2. Your application invoke\", \"s the /v1.0/bindings/sms endpoint on the Dapr sidecar. In this case, it uses an HTTP POST to invoke \", \"the API. It's also possible to use gRPC.\\n3. The binding component running in the Dapr sidecar calls \", \"the external messaging system to send the message. The message will contain the payload passed in th\", \"e POST request.\\n\\nAs an example, you can invoke an output binding by invoking the Dapr API using curl\", \":\\n\\n```\\ncurl -X POST http://localhost:3500/v1.0/bindings/sms \\\\ -H \\\"Content-Type: application/json\\\" \\\\ \", \"-d '{ \\\"data\\\": \\\"Welcome to this awesome service\\\", \\\"metadata\\\": { \\\"toNumber\\\": \\\"555-3277\\\" }, \\\"operation\\\"\", \": \\\"create\\\" }'\\n```\\n\\nNote that the HTTP port is the same as used by the Dapr sidecar (in this case, th\", \"e default Dapr HTTP port 3500 ).\\n\\nThe structure of the payload (that is, message sent) will vary per\", \" binding. In the example above, the payload contains a data element with a message. Bindings to othe\", \"r types of external resources can be different, especially for the metadata that is sent. Each paylo\", \"ad must also contain an operation field,\\n\\nDapr\\n\\nExternal\\n\\nthat defines the operation the binding wil\", \"l execute. The above example specifies a create operation that creates the SMS message. Common opera\", \"tions include:\\n\\n- create\\n- get\\n- delete\\n- list\\n\\nIt's up to the author of the binding which operation\", \"s the binding supports. The documentation for each binding describes the available operations and ho\", \"w to invoke them.\\n\\n## Use the Dapr .NET SDK\\n\\nThe Dapr .NET SDK provides language-specific support fo\", \"r .NET developers. In the following example, the call to the HttpClient.PostAsync() is replaced with\", \" the DaprClient.InvokeBindingAsync() method. This specialized method simplifies invoking a configure\", \"d output binding:\\n\\n```\\nprivate async Task SendSMSAsync([FromServices] DaprClient daprClient) { var m\", \"essage = \\\"Welcome to this awesome service\\\"; var metadata = new Dictionary<string, string> { { \\\"toNum\", \"ber\\\", \\\"555-3277\\\" } }; await daprClient.InvokeBindingAsync(\\\"sms\\\", \\\"create\\\", message, metadata); }\\n```\", \"\\n\\nThe method expects the metadata and message values.\\n\\nWhen used to invoke a binding, the DaprClient\", \" uses gRPC to call the Dapr API on the Dapr sidecar.\\n\\n## Binding components\\n\\nUnder the hood, resourc\", \"e bindings are implemented with Dapr binding components. They're contributed by the community and wr\", \"itten in Go. If you need to integrate with an external resource for which no Dapr binding exists yet\", \", you can create it yourself. Check out the Dapr componentscontrib repo to see how you can contribut\", \"e a binding.\\n\\n## Note\\n\\nDapr and all of its components are written in the Golang (Go) language. Go is\", \" considered a modern, cloud-native programming platform.\\n\\nYou configure bindings using a YAML config\", \"uration file. Here's an example configuration for the Twitter binding:\\n\\n```\\napiVersion: dapr.io/v1al\", \"pha1 kind: Component metadata: name: twitter-mention\\n```\\n\\n```\\nnamespace: default spec: type: binding\", \"s.twitter version: v1 metadata: -name: consumerKey value: \\\"****\\\" # twitter api consumer key, require\", \"d -name: consumerSecret value: \\\"****\\\" # twitter api consumer secret, required -name: accessToken val\", \"ue: \\\"****\\\" # twitter api access token, required -name: accessSecret value: \\\"****\\\" # twitter api acce\", \"ss secret, required -name: query value: \\\"dapr\\\" # your search query, required\\n```\\n\\nEach binding confi\", \"guration contains a general metadata element with a name and namespace field. Dapr will determine th\", \"e endpoint to invoke your service based upon the configured name field. In the above example, Dapr w\", \"ill invoke the method annotated with /twitter-mention in your service when an event occurs.\\n\\nIn the \", \"spec element, you specify the type of the binding along with binding specific metadata . The example\", \" specifies credentials for accessing a Twitter account using its API. The metadata can differ betwee\", \"n input and output bindings. For example, to use Twitter as an input binding, you need to specify th\", \"e text to search for in tweets using the query field. Every time a matching tweet is sent, the Dapr \", \"sidecar will invoke the /twitter-mention endpoint on the service. It will also deliver the contents \", \"of the tweet.\\n\\nA binding can be configured for input, output, or both. Interestingly, the binding do\", \"esn't explicitly specify input or output configuration. Instead, the direction is inferred by the us\", \"age of the binding along with configuration values.\\n\\nThe Dapr documentation for resource bindings pr\", \"ovides a complete list of the available bindings and their specific configuration settings.\\n\\n## Cron\", \" binding\\n\\nPay close attention to Dapr's Cron binding. It doesn't subscribe to events from an externa\", \"l system. Instead, this binding uses a configurable interval schedule to trigger your application. T\", \"he binding provides a simple way to implement a background worker to wake up and do some work at a r\", \"egular interval, without the need to implement an endless loop with a configurable delay. Here's an \", \"example of a Cron binding configuration:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata:\", \" name: checkOrderBacklog namespace: default spec: type: bindings.cron version: v1 metadata: -name: s\", \"chedule value: \\\"@every 30m\\\"\\n```\\n\\nTrafficControl\\n\\nCamera\\n\\nIn this example, Dapr triggers a service by\", \" invoking the /checkOrderBacklog endpoint every 30 minutes. There are several patterns available for\", \" specifying the schedule value. For more information, see the Cron binding documentation.\\n\\n2\\n\\n## Sam\", \"ple application: Dapr Traffic Control\\n\\nIn the Dapr Traffic Control sample application, the TrafficCo\", \"ntrol service uses the MQTT input binding to retrieve messages from the CameraSimulation. Figure 8-4\", \" shows the conceptual architecture of the Dapr Traffic Control sample application. The Dapr input bi\", \"nding is used in flows marked with number 5 in the diagram:\\n\\nSendFine\\n\\n<!-- image -->\\n\\nFineCollectio\", \"n\\n\\nService\\n\\nVehicleRegistration\\n\\nService\\n\\nService invocation\\n\\n2\\n\\nPublish / subscribe\\n\\nFigure 8-4. Co\", \"nceptual architecture of the Dapr Traffic Control sample application.\\n\\n12 - 3\\n\\nEntryCam\\n\\n## MQTT inp\", \"ut binding\\n\\nMQTT is a lightweight pub/sub messaging protocol, often used in IoT scenarios. Producers\", \" sent MQTT messages to a topic; subscribers then retrieve messages from the topic. There are several\", \" MQTT message broker products available. The Traffic Control sample application uses Eclipse Mosquit\", \"to.\\n\\nThe CameraSimulation doesn't depend on any Dapr building blocks. It uses the System.Net.Mqtt li\", \"brary to send MQTT messages:\\n\\n```\\n// ... // simulate entry DateTime entryTimestamp = DateTime.Now; v\", \"ar vehicleRegistered = new VehicleRegistered { Lane = _camNumber, LicenseNumber = GenerateRandomLice\", \"nseNumber(), Timestamp = entryTimestamp }; _trafficControlService.SendVehicleEntry(vehicleRegistered\", \"); // ...\\n```\\n\\nThe code uses a proxy of type ITrafficControlService to call the TrafficControl servi\", \"ce. .NET injects an implementation of the ITrafficControlService interface using constructor injecti\", \"on:\\n\\n:::{custom-style=CodeBox} csharp public CameraSimulation(int camNumber, ITrafficControlService \", \"trafficControlService) {     \\\\_camNumber = camNumber;     \\\\_trafficControlService = trafficControlSe\", \"rvice; } :::\\n\\nThe MqttTrafficControlService class implements the ITrafficControlService interface. I\", \"t exposes two methods: SendVehicleEntryAsync and SendVehicleExitAsync . They both use the MQTT clien\", \"t to send messages to the trafficcontrol/entrycam and trafficcontrol/exitcam topics respectively:\\n\\n`\", \"``\\npublic async Task SendVehicleEntryAsync(VehicleRegistered vehicleRegistered) { var eventJson = Js\", \"onSerializer.Serialize(vehicleRegistered); var message = new MqttApplicationMessage(\\\"trafficcontrol/\", \"entrycam\\\", Encoding.UTF8.GetBytes(eventJson)); await _client.PublishAsync(message, MqttQualityOfServ\", \"ice.AtMostOnce); } public async Task SendVehicleExitAsync(VehicleRegistered vehicleRegistered) { var\", \" eventJson = JsonSerializer.Serialize(vehicleRegistered); var message = new MqttApplicationMessage(\\\"\", \"trafficcontrol/exitcam\\\", Encoding.UTF8.GetBytes(eventJson)); await _client.PublishAsync(message, Mqt\", \"tQualityOfService.AtMostOnce); }\\n```\\n\\nThe constructor sets up the MQTT client to send messages to th\", \"e MQTT broker (Mosquitto) running on port 1883.\\n\\nOn the other end, the TrafficControl service uses t\", \"he MQTT input binding to receive VehicleRegistered messages sent by the CameraSimulation. For each s\", \"ubscribed topic, there's a\\n\\nseparate component configuration file in the /dapr/components folder. Th\", \"e first one is entrycam.yaml :\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: ent\", \"rycam namespace: dapr-trafficcontrol spec: type: bindings.mqtt version: v1 metadata: -name: url valu\", \"e: mqtt://localhost:1883 -name: topic value: trafficcontrol/entrycam scopes: -trafficcontrolservice\\n\", \"```\\n\\nThe configuration specifies the binding type: bindings.mqtt . It also specifies that the broker\", \" runs on localhost:1883 , the standard port that Mosquitto uses. It also exposes the topic , traffic\", \"control/entrycam . Using scopes , the config file specifies that only the service with app-id traffi\", \"ccontrolservice will have access to the binding.\\n\\nWhen the TrafficControl service starts, the Dapr s\", \"idecar automatically subscribes to the trafficcontrol/entrycam MQTT topic specified in the component\", \" configuration. When messages arrive on the topic, the Dapr sidecar invokes an HTTP endpoint on your\", \" service. The sidecar determines the URL of the HTTP endpoint to call by looking at the metadata.nam\", \"e field in the binding configuration. In the example above, the endpoint URL is /entrycam . Within t\", \"he TrafficControl service, no code needs to be added to support the endpoint:\\n\\n```\\n[HttpPost(\\\"entryc\", \"am\\\")] public async Task<ActionResult> VehicleEntry(VehicleRegistered msg) { // ... }\\n```\\n\\nThe exitca\", \"m.yaml component configuration file configures everything for the exitcam endpoint:\\n\\n```\\napiVersion:\", \" dapr.io/v1alpha1 kind: Component metadata: name: exitcam namespace: dapr-trafficcontrol spec: type:\", \" bindings.mqtt version: v1 metadata: -name: url value: mqtt://localhost:1883 -name: topic value: tra\", \"fficcontrol/exitcam scopes: -trafficcontrolservice\\n```\\n\\nTrafficControl\\n\\n5\\n\\ndapr\\n\\n## SMTP output bind\", \"ing\\n\\nmosquitto\\n\\nThe FineCollection service uses the Dapr SMTP output binding to send emails. Figure \", \"8-5 shows the conceptual architecture of the Dapr Traffic Control sample application. The Dapr input\", \" binding is used in flows marked with number 4 in the diagram:\\n\\nRedis\\n\\n<!-- image -->\\n\\nFineCollectio\", \"n\\n\\nService\\n\\nVehicleRegistration\\n\\nService\\n\\n2\\n\\nFigure 8-5. Conceptual architecture of the Dapr Traffic\", \" Control sample application.\\n\\nThe CollectFine method on the CollectionController in the FineCollecti\", \"on service contains code that uses the Dapr client to invoke the output binding:\\n\\n```\\n// ... // send\", \" fine by email (Dapr output binding) var body = EmailUtils.CreateEmailBody(speedingViolation, vehicl\", \"eInfo, fineString); var metadata = new Dictionary<string, string> { [\\\"emailFrom\\\"] = \\\"noreply@cfca.go\", \"v\\\", [\\\"emailTo\\\"] = vehicleInfo.OwnerEmail,\\n```\\n\\n12 - 3\\n\\nEntryCam\\n\\n5\\n\\nCamera\\n\\nSimulation\\n\\n```\\n[\\\"subjec\", \"t\\\"] = $\\\"Speeding violation on the {speedingViolation.RoadId}\\\" }; await daprClient.InvokeBindingAsync\", \"(\\\"sendmail\\\", \\\"create\\\", body, metadata); // ...\\n```\\n\\nThe code uses a simple utility class to create a\", \"n HTML email body containing the necessary information. It also creates a dictionary with metadata s\", \"pecific to the SMTP binding. This binding component interprets the metadata when invoked.\\n\\nThe follo\", \"wing arguments are required to invoke the binding:\\n\\n- The name of the binding component. In this cas\", \"e sendmail .\\n- The operation the binding needs to perform. In this case create .\\n- The body of the m\", \"essage to send. In this case, the HTML email body.\\n- The metadata for sending the email.\\n\\nThe Dapr o\", \"utput binding named sendmail is configured in the email.yaml component configuration file in the /da\", \"pr/components folder:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: sendmail nam\", \"espace: dapr-trafficcontrol spec: type: bindings.smtp version: v1 metadata: -name: host value: local\", \"host -name: port value: 4025 -name: user secretKeyRef: name: smtp.user key: smtp.user -name: passwor\", \"d secretKeyRef: name: smtp.password key: smtp.password -name: skipTLSVerify value: true auth: secret\", \"Store: trafficcontrol-secrets scopes: -finecollectionservice\\n```\\n\\nThe configuration specifies the bi\", \"nding type: bindings.smtp .\\n\\nThe metadata section contains the information for connecting to the SMT\", \"P server. See the binding's documentation for specific metadata required for this binding. The usern\", \"ame and password to connect to the SMTP server are retrieved from a secrets store. See the Secrets m\", \"anagement building block chapter for more information on how this works.\\n\\nThe scopes element specifi\", \"es that only the service with app-id finecollectonservice can access this binding.\\n\\nThe Traffic Cont\", \"rol sample application uses MailDev. MailDev is a development SMTP server that doesn't actually send\", \" out emails (by default). Instead, it collects emails and presents them in an in box web application\", \". MailDev is extremely useful for dev/test and demo scenarios.\\n\\nUsing Dapr bindings in the Traffic C\", \"ontrol sample application provides the following benefits:\\n\\n1. Using MQTT messaging and SMTP without\", \" the need to learn this protocol or a specific MQTT API.\\n2. Using SMTP to send an email without the \", \"need to learn this protocol or a specific SMTP API.\\n\\n## Summary\\n\\nDapr resource bindings enable you t\", \"o integrate with different external resources and systems without taking dependencies on their libra\", \"ries o r SDKs. These external systems don't necessarily have to be messaging systems like a service \", \"bus or message broker. Bindings also exist for datastores and web resources like Twitter or SendGrid\", \".\\n\\nInput bindings (or triggers) react to events occurring in an external system. They invoke the pub\", \"lic HTTP endpoints pre-configured in your application. Dapr uses the name of the binding in the conf\", \"iguration to determine the endpoint to call in your application.\\n\\nOutput bindings will send messages\", \" to an external system. You trigger an output binding by doing an HTTP POST on the /v1.0/bindings/&l\", \"t;binding-name&gt; endpoint on the Dapr sidecar. You can also use gRPC to invoke the binding. The .N\", \"ET SDK offers a InvokeBindingAsync method to invoke Dapr bindings using gRPC.\\n\\nYou implement a bindi\", \"ng with a Dapr component. These components are contributed by the community. Each binding component'\", \"s configuration has metadata that is specific for the external system it abstracts. Also, the comman\", \"ds it supports and the structure of the payload will differ per binding component.\\n\\n## References\\n\\n-\", \" Dapr documentation for resource bindings\\n- Mosquitto MQTT broker\\n- MailDev development SMTP server\\n\", \"\\n## The Dapr actors building block\\n\\nThe actor model originated in 1973. It was proposed by Carl Hewi\", \"tt as a conceptual model of concurrent computation, a form of computing in which several computation\", \"s are executed at the same time. Highly parallel computers weren't yet available at that tim e, but \", \"the more recent advancements of multi-core CPUs and distributed systems have made the actor model po\", \"pular.\\n\\nIn the actor model, the actor is an independent unit of compute and state. Actors are comple\", \"tely isolated from each other and they will never share memory. Actors communicate with each other u\", \"sing messages. When an actor receives a message, it can change its internal state, and send messages\", \" to other (possibly new) actors.\\n\\nThe reason why the actor model makes writing concurrent systems ea\", \"sier is that it provides a turnbased (or single-threaded) access model. Multiple actors can run at t\", \"he same time, but each actor will process received messages one at a time. This means that you can b\", \"e sure that at most one thread is active inside an actor at any time. That makes writing correct con\", \"current and parallel systems much easier.\\n\\n## What it solves\\n\\nActor model implementations are usuall\", \"y tied to a specific language or platform. With the Dapr actors building block however, you can leve\", \"rage the actor model from any language or platform.\\n\\nDapr's implementation is based on the virtual a\", \"ctor pattern introduced by Project 'Orleans' . With the virtual actor pattern, you don't need to exp\", \"licitly create actors. Actors are activated implicitly and placed on a node in the cluster the first\", \" time a message is sent to the actor. When not executing operations, actors are silently unloaded fr\", \"om memory. If a node fails, Dapr automatically moves activated actors to healthy nodes. Besides send\", \"ing messages between actors, the Dapr actor model also support scheduling future work using timers a\", \"nd reminders.\\n\\nWhile th e actor model can provide great benefits, it's important to carefully consid\", \"er the actor design. For example, having many clients call the same actor will result in poor perfor\", \"mance because the actor operations execute serially. Here are some criteria to check if a scenario i\", \"s a good fit for Dapr actors:\\n\\n- Your problem space involves concurrency. Without actors, you'd have\", \" to introduce explicit locking mechanisms in your code.\\n\\n- Your problem space can be partitioned int\", \"o small, independent, and isolated units of state and logic.\\n- You don't need low -latency reads of \", \"the actor state. Low-latency reads cannot be guaranteed because actor operations execute serially.\\n-\", \" You don't need to query state across a set of actors. Querying across actors is inefficient because\", \" each actor's state needs to be read individually and can introduce unpredictable latencies.\\n\\nOne de\", \"sign pattern that fits these criteria quite well is the orchestration-based saga or process manager \", \"design pattern. A saga manages a sequence of steps that must be taken to reach some outcome. The sag\", \"a (or process manager) maintains the current state of the sequence and triggers the next step. If a \", \"step fails, the saga can execute compensating actions. Actors make it easy to deal with concurrency \", \"in the saga and to keep track of the current state. The eShopOnDapr reference application uses the s\", \"aga pattern and Dapr actors to implement the Ordering process.\\n\\n## How it works\\n\\nThe Dapr sidecar pr\", \"ovides the HTTP/gRPC API to invoke actors. This is the base URL of the HTTP API:\\n\\nhttp://localhost:&\", \"lt;daprPort&gt;/v1.0/actors/&lt;actorType&gt;/&lt;actorId&gt;/\\n\\n- &lt;daprPort&gt; : the HTTP port t\", \"hat Dapr listens on.\\n- &lt;actorType&gt; : the actor type.\\n- &lt;actorId&gt; : the ID of the specifi\", \"c actor to call.\\n\\nThe sidecar manages how, when and where each actor runs, and also routes messages \", \"between act ors. When an actor hasn't been used for a period of time, the runtime deactivates the ac\", \"tor and removes it from memory. Any state managed by the actor is persisted and will be available wh\", \"en the actor re-activates. Dapr uses an idle timer to determine when an actor can be deactivated. Wh\", \"en an operation is called on the actor (either by a method call or a reminder firing), the idle time\", \"r is reset and the actor instance will remain activated.\\n\\nThe sidecar API is only one part of the eq\", \"uation. The service itself also needs to implement an API specification, because the actual code tha\", \"t you write for the actor will run inside the service itself. Figure 11-1 shows the various API call\", \"s between the service and its sidecar:\\n\\nService\\n\\nInvoke actor method\\n\\nGet/persist actor state\\n\\nCreat\", \"e/Get/Delete reminder -\\n\\n\\u2192\\n\\nFigure 11-1. API calls between actor service and Dapr sidecar.\\n\\n<!-- ima\", \"ge -->\\n\\nTo provide scalability and reliability, actors are partitioned across all the instances of t\", \"he actor service. The Dapr placement service is responsible for keeping track of the partitioning in\", \"formation. When a new instance of an actor service is started, the sidecar registers the supported a\", \"ctor types with the placement service. The placement service calculates the updated partitioning inf\", \"ormation for the given actor type and broadcasts it to all instances. Figure 11-2 shows what happens\", \" when a service is scaled out to a second replica:\\n\\n:::image type='content' source='./media/actors/p\", \"lacement.png' alt -text='Diagram of the actor placement service.':::\\n\\nFigure 11-2. Actor placement s\", \"ervice.\\n\\n1. On startup, the sidecar makes a call to the actor service to get the registered actor ty\", \"pes as well as actor configuration settings.\\n2. The sidecar sends the list of registered actor types\", \" to the placement service.\\n3. The placement service broadcasts the updated partitioning information \", \"to all actor service instances. Each instance will keep a cached copy of the partitioning informatio\", \"n and use it to invoke actors.\\n\\n## Important\\n\\nBecause actors are randomly distributed across service\", \" instances, it should be expected that an actor operation always requires a call to a different node\", \" in the network.\\n\\nPOST http://localhost:3500/1.0/actors/OrderActor/3/method/ship\\n\\nThe next figure sh\", \"ows an ordering service instance running in Pod 1 call the ship method of an OrderActor instance wit\", \"h ID 3 . Because the actor with ID 3 is placed in a different instance, this results in a call to a \", \"different node in the cluster:\\n\\nOrdering\\n\\nService\\n\\nOrdering\\n\\nService\\n\\nFigure 11-3. Calling an actor \", \"method.\\n\\n<!-- image -->\\n\\n1. The service calls the actor API on the sidecar. The JSON payload in the \", \"request body contains the data to send to the actor.\\n2. The sidecar uses the locally cached partitio\", \"ning information from the placement service to determine which actor service instance (partition) is\", \" responsible for hosting the actor with ID 3 . In this example, it's the service instance in pod 2. \", \"The call is forwarded to the appropriate sidecar.\\n3. The sidecar instance in pod 2 calls the service\", \" instance to invoke the actor. The service instance activates the actor (if it hasn't already) and e\", \"xecutes the actor method.\\n\\nActor\\n\\nActor dapr Sidecar\\n\\n## Turn-based access model\\n\\nThe turnbased acce\", \"ss model ensures that at any time there's at most one thread active inside an actor instance. To und\", \"erstand why this is useful, consider the following example of a method that increments a counter val\", \"ue:\\n\\n```\\npublic int Increment() { var currentValue = GetValue(); var newValue = currentValue + 1; Sa\", \"veValue(newValue); return newValue; }\\n```\\n\\nLet's assume that th e current value returned by the GetV\", \"alue method is 1 . When two threads call the Increment method at the same time, there's a risk of bo\", \"th of them calling the GetValue method before one of them calls SaveValue . This results in both thr\", \"eads starting with the same initial value ( 1 ). The threads then increment the value to 2 and retur\", \"n it to the caller. The resulting value after the two calls is now 2 instead of 3 which it should be\", \". This is a simple example to illustrate the kind of issues that can slip into your code when workin\", \"g with multiple threads, and is easy to solve. In real world applications however, concurrent and pa\", \"rallel scenarios can become very complex.\\n\\nIn traditional programming models, you can solve this pro\", \"blem by introducing locking mechanisms. For example:\\n\\n```\\npublic int Increment() { int newValue; loc\", \"k (_lockObject) { var currentValue = GetValue(); newValue = currentValue + 1; SaveValue(newValue); }\", \" return newValue; }\\n```\\n\\nUnfortunately, using explicit locking mechanisms is error-prone. They can e\", \"asily lead to deadlocks and can have serious impact on performance.\\n\\nThanks to the turnbased access \", \"model, you don't need to worry about multiple threads with actors, making it much easier to write co\", \"ncurrent systems. The following actor example closely mirrors the code from the previous sample, but\", \" doesn't require any locking mechanisms to be correct:\\n\\n```\\npublic async Task<int> IncrementAsync() \", \"{ var counterValue = await StateManager.TryGetStateAsync<int>(\\\"counter\\\"); var currentValue = counter\", \"Value.HasValue ? counterValue.Value : 0; var newValue = currentValue + 1;\\n```\\n\\n```\\nawait StateManage\", \"r.SetStateAsync(\\\"counter\\\", newValue); return newValue; }\\n```\\n\\n## Timers and reminders\\n\\nActors can us\", \"e timers and reminders to schedule calls to themselves. Both concepts support the configuration of a\", \" due time. The difference lies in the lifetime of the callback registrations:\\n\\n- Timers will only st\", \"ay active as long as the actor is activated. Timers will not reset the idle-timer, so they cannot ke\", \"ep an actor active on their own.\\n- Reminders outlive actor activations. If an actor is deactivated, \", \"a reminder will re-activate the actor. Reminders will reset the idle-timer.\\n\\nTimers are registered b\", \"y making a call to the actor API. In the following example, a timer is registered with a due time of\", \" 0 and a period of 10 seconds.\\n\\n```\\ncurl -X POST http://localhost:3500/v1.0/actors/<actorType>/<acto\", \"rId>/timers/<name> \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"dueTime\\\": \\\"0h0m0s0ms\\\", \\\"period\\\": \\\"\", \"0h0m10s0ms\\\" }'\\n```\\n\\nBecause the due time is 0, the timer will fire immediately. After a timer callba\", \"ck has finished, the timer will wait 10 seconds before firing again.\\n\\nReminders are registered in a \", \"similar way. The following example shows a reminder registration with a due time of 5 minutes, and a\", \"n empty period:\\n\\n```\\ncurl -X POST http://localhost:3500/v1.0/actors/<actorType>/<actorId>/reminders/\", \"<name> \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"dueTime\\\": \\\"0h5m0s0ms\\\", \\\"period\\\": \\\"\\\" }'\\n```\\n\\nTh\", \"is reminder will fire in 5 minutes. Because the given period is empty, this will be a one-time remin\", \"der.\\n\\n## Note\\n\\nTimers and reminders both respect the turn-based access model. When a timer or remind\", \"er fires, the callback will not be executed until any other method invocation or timer/reminder call\", \"back has finished.\\n\\n## State persistence\\n\\nActor state is persisted using the Dapr state management b\", \"uilding block. Because actors can execute multiple state operations in a single turn, the state stor\", \"e component must support multi-item transactions. At the time of writing, the following state stores\", \" support multi-item transactions:\\n\\n- Azure Cosmos DB\\n- MongoDB\\n- MySQL\\n- PostgreSQL\\n- Redis\\n- Rethin\", \"kDB\\n- SQL Server\\n\\nTo configure a state store component for use with actors, you need to append the f\", \"ollowing metadata to the state store configuration:\\n\\n```\\n-name: actorStateStore value: \\\"true\\\"\\n```\\n\\nH\", \"ere's a complete example for a Redis state store:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component \", \"metadata: name: statestore spec: type: state.redis version: v1 metadata: -name: redisHost value: loc\", \"alhost:6379 -name: redisPassword value: \\\"\\\" -name: actorStateStore value: \\\"true\\\"\\n```\\n\\n## Use the Dapr\", \" .NET SDK\\n\\nYou can create an actor model implementation using only HTTP/gRPC calls. However, it's mu\", \"ch more convenient to use the language specific Dapr SDKs. At the time of writing, the .NET, Java an\", \"d Python SDKs all provide extensive support for working with actors.\\n\\nTo get started with the .NET D\", \"apr actors SDK, you add a package reference to Dapr.Actors to your service project. The first step o\", \"f creating an actual actor is to define an interface that derives from IActor . Clients use the inte\", \"rface to invoke operations on the actor. Here's a simple example o f an actor interface for keeping \", \"scores:\\n\\n```\\npublic interface IScoreActor : IActor { Task<int> IncrementScoreAsync(); Task<int> GetS\", \"coreAsync(); }\\n```\\n\\n## Important\\n\\nThe return type of an actor method must be Task or Task&lt;T&gt; .\", \" Also, actor methods can have at most one argument. Both the return type and the arguments must be S\", \"ystem.Text.Json serializable.\\n\\nNext, implement the actor by deriving a ScoreActor class from Actor .\", \" The ScoreActor class must also implement the IScoreActor interface:\\n\\n```\\npublic class ScoreActor : \", \"Actor, IScoreActor { public ScoreActor(ActorHost host) : base (host) { } // TODO Implement interface\", \" methods. }\\n```\\n\\nThe constructor in the snippet above takes a host argument of type ActorHost . The \", \"ActorHost class represents the host for an actor type within the actor runtime. You need to pass thi\", \"s argument to the constructor of the Actor base class. Actors also support dependency injection. Any\", \" additional arguments that you add to the actor constructor are resolved using the .NET dependency i\", \"njection container.\\n\\nLet's now implement the IncrementScoreAsync method of the interface:\\n\\n```\\npubli\", \"c Task<int> IncrementScoreAsync() { return StateManager.AddOrUpdateStateAsync( \\\"score\\\", 1, (key, cur\", \"rentScore) => currentScore + 1 ); }\\n```\\n\\nIn the snippet above, a single call to StateManager.AddOrUp\", \"dateStateAsync provides the full implementation for the IncrementScoreAsync method. The AddOrUpdateS\", \"tateAsync method takes three arguments:\\n\\n1. The key of the state to update.\\n2. The value to write if\", \" no score is stored in the state store yet.\\n3. A Func to call if there already is a score stored in \", \"the state store. It takes the state key and current score, and returns the updated score to write ba\", \"ck to the state store.\\n\\nThe GetScoreAsync implementation reads the current score from the state stor\", \"e and returns it to the client:\\n\\n```\\npublic async Task<int> GetScoreAsync() { var scoreValue = await\", \" StateManager.TryGetStateAsync<int>(\\\"score\\\"); if (scoreValue.HasValue) { return scoreValue.Value; }\\n\", \"```\\n\\n```\\nreturn 0; }\\n```\\n\\nTo host actors in an ASP.NET Core service, you must add a reference to the\", \" Dapr.Actors.AspNetCore package and make some changes in the Program file. In the following example,\", \" the call to MapActorsHandlers registers Dapr Actor endpoints in ASP.NET Core routing:\\n\\n```\\nvar buil\", \"der = WebApplication.CreateBuilder(args); var app = builder.Build(); // Actors building block does n\", \"ot support HTTPS redirection. //app.UseHttpsRedirection(); app.MapControllers(); // Add actor endpoi\", \"nts. app.MapActorsHandlers();\\n```\\n\\nThe actors endpoints are necessary because the Dapr sidecar calls\", \" the application to host and interact with actor instances.\\n\\n## Important\\n\\nMake sure your Program (o\", \"r Startup ) class does not contain an app.UseHttpsRedirection call to redirect clients to the HTTPS \", \"endpoint. This will not work with actors. By design, a Dapr sidecar sends requests over unencrypted \", \"HTTP by default. The HTTPS middleware will block these requests when enabled.\\n\\nThe Program file is a\", \"lso the place to register the specific actor types. The following example registers the ScoreActor u\", \"sing the AddActors extension method:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); builder.\", \"Services.AddActors(options => { options.Actors.RegisterActor<ScoreActor>(); });\\n```\\n\\nAt this point, \", \"the ASP.NET Core service is ready to host the ScoreActor and accept incoming requests. Client applic\", \"ations use actor proxies to invoke operations on actors. The following example shows how a console c\", \"lient application invokes the IncrementScoreAsync operation on a ScoreActor instance:\\n\\n```\\nvar actor\", \"Id = new ActorId(\\\"scoreActor1\\\"); var proxy = ActorProxy.Create<IScoreActor>(actorId, \\\"ScoreActor\\\"); \", \"var score = await proxy.IncrementScoreAsync(); Console.WriteLine($\\\"Current score: {score}\\\");\\n```\\n\\nTh\", \"e above example uses the Dapr.Actors package to call the actor service. To invoke an operation on an\", \" actor, you need to be able to address it. You'll need two parts for this:\\n\\n1. The actor type unique\", \"ly identifies the actor implementation across the whole application. By default, the actor type is t\", \"he name of the implementation class (without namespace). You can customize the actor type by adding \", \"an ActorAttribute to the implementation class and setting its TypeName property.\\n\\n2. The ActorId uni\", \"quely identifies an instance of an actor type. You can also use this class to generate a random acto\", \"r id by calling ActorId.CreateRandom .\\n\\nThe example uses ActorProxy.Create to create a proxy instanc\", \"e for the ScoreActor . The Create method takes two arguments: the ActorId identifying the specific a\", \"ctor and the actor type. It also has a generic type parameter to specify the actor interface that th\", \"e actor type implements. As both the server and client applications need to use the actor interfaces\", \", they're typically stored in a separate shared project.\\n\\nThe final step in the example calls the In\", \"crementScoreAsync method on the actor and outputs the result. Remember that the Dapr placement servi\", \"ce distributes the actor instances across the Dapr sidecars. Therefore, expect an actor call to be a\", \" network call to another node.\\n\\n## Call actors from ASP.NET Core clients\\n\\nThe console client example\", \" in the previous section uses the static ActorProxy.Create method directly to get an actor proxy ins\", \"tance. If the client application is an ASP.NET Core application, you should use the IActorProxyFacto\", \"ry interface to create actor proxies. The main benefit is that it allows you to manage configuration\", \" in one place. The AddActors extension method on IServiceCollection takes a delegate that allows you\", \" to specify actor runtime options, such as the HTTP endpoint of the Dapr sidecar. The following exam\", \"ple specifies custom JsonSerializerOptions to use for actor state persistence and message deserializ\", \"ation:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddActors(options => \", \"{ var jsonSerializerOptions = new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.\", \"CamelCase, PropertyNameCaseInsensitive = true }; options.JsonSerializerOptions = jsonSerializerOptio\", \"ns; options.Actors.RegisterActor<ScoreActor>(); });\\n```\\n\\nThe call to AddActors registers the IActorP\", \"roxyFactory for .NET dependency injection. This allows ASP.NET Core to inject an IActorProxyFactory \", \"instance into your controller classes. The following example calls an actor method from an ASP.NET C\", \"ore controller class:\\n\\n```\\n[ApiController] [Route(\\\"[controller]\\\")] public class ScoreController : Co\", \"ntrollerBase { private readonly IActorProxyFactory _actorProxyFactory; public ScoreController(IActor\", \"ProxyFactory actorProxyFactory) { _actorProxyFactory = actorProxyFactory; } [HttpPut(\\\"{scoreId}\\\")] p\", \"ublic Task<int> IncrementAsync(string scoreId) {\\n```\\n\\n```\\nvar scoreActor = _actorProxyFactory.Create\", \"ActorProxy<IScoreActor>( new ActorId(scoreId), \\\"ScoreActor\\\"); return scoreActor.IncrementScoreAsync(\", \"); } }\\n```\\n\\nActors can also call other actors directly. The Actor base class exposes an IActorProxyF\", \"actory class through the ProxyFactory property. To create an actor proxy from within an actor, use t\", \"he ProxyFactory property of the Actor base class. The following example shows an OrderActor that inv\", \"okes operations on two other actors:\\n\\n```\\npublic class OrderActor : Actor, IOrderActor { public Orde\", \"rActor(ActorHost host) : base (host) { } public async Task ProcessOrderAsync(Order order) { var stoc\", \"kActor = ProxyFactory.CreateActorProxy<IStockActor>( new ActorId(order.OrderNumber), \\\"StockActor\\\"); \", \"await stockActor.ReserveStockAsync(order.OrderLines); var paymentActor = ProxyFactory.CreateActorPro\", \"xy<IPaymentActor>( new ActorId(order.OrderNumber), \\\"PaymentActor\\\"); await paymentActor.ProcessPaymen\", \"tAsync(order.PaymentDetails); } }\\n```\\n\\n## Note\\n\\nBy default, Dapr actors aren't reentrant. This means\", \" that a Dapr actor cannot be called more than once in the same chain. For example, the call chain Ac\", \"tor A -&gt; Actor B -&gt; Actor A is not allowed. At the time of writing, there's a preview feature \", \"available to support reentrancy. However, there is no SDK support yet. For more details, see the off\", \"icial documentation.\\n\\n## Call non-.NET actors\\n\\nSo far, the examples used strongly-typed actor proxie\", \"s based on .NET interfaces to illustrate actor invocations. This works great when both the actor hos\", \"t and client are .NET applications. However, if the actor host is not a .NET application, you don't \", \"have an actor interface to create a strongly -typed proxy. In these cases, you can use a weakly-type\", \"d proxy.\\n\\nYou create weakly-typed proxies in a similar way to strongly-typed proxies. Instead of rel\", \"ying on a .NET interface, you need to pass in the actor method name as a string.\\n\\n```\\n[HttpPut(\\\"{sco\", \"reId}\\\")]\\n```\\n\\n```\\npublic Task<int> IncrementAsync(string scoreId)\\n```\\n\\n```\\n{ var scoreActor = _actor\", \"ProxyFactory.CreateActorProxy( new ActorId(scoreId), \\\"ScoreActor\\\"); return scoreActor(\\\"IncrementScor\", \"eAsync\\\"); }\\n```\\n\\n## Timers and reminders\\n\\nUse the RegisterTimerAsync method of the Actor base class \", \"to schedule actor timers. In the following example, a TimerActor exposes a StartTimerAsync method. C\", \"lients can call the method to start a timer that repeatedly writes a given text to the log output.\\n\\n\", \"```\\npublic class TimerActor : Actor, ITimerActor { public TimerActor(ActorHost host) : base (host) {\", \" } public Task StartTimerAsync(string name, string text) { return RegisterTimerAsync( name, nameof(T\", \"imerCallback), Encoding.UTF8.GetBytes(text), TimeSpan.Zero, TimeSpan.FromSeconds(3)); } public Task \", \"TimerCallbackAsync(byte[] state) { var text = Encoding.UTF8.GetString(state); Logger.LogInformation(\", \"$\\\"Timer fired: {text}\\\"); return Task.CompletedTask; } }\\n```\\n\\nThe StartTimerAsync method calls Regist\", \"erTimerAsync to schedule the timer. RegisterTimerAsync takes five arguments:\\n\\n1. The name of the tim\", \"er.\\n2. The name of the method to call when the timer fires.\\n3. The state to pass to the callback met\", \"hod.\\n4. The amount of time to wait before the callback method is first invoked.\\n5. The time interval\", \" between callback method invocations. You can specify TimeSpan.FromMilliseconds(-1) to disable perio\", \"dic signaling.\\n\\nThe TimerCallbackAsync method receives the user state in binary form. In the example\", \", the callback decodes the state back to a string before writing it to the log.\\n\\nTimers can be stopp\", \"ed by calling UnregisterTimerAsync :\\n\\n```\\npublic class TimerActor : Actor, ITimerActor { // ... publ\", \"ic Task StopTimerAsync(string name) { return UnregisterTimerAsync(name); } }\\n```\\n\\nRemember that time\", \"rs do not reset the actor idle timer. When no other calls are made on the actor, it may be deactivat\", \"ed and the timer will be stopped automatically. To schedule work that does reset the idle timer, use\", \" reminders which we'll look at next.\\n\\nTo use reminders in an actor, your actor class must implement \", \"the IRemindable interface:\\n\\n```\\npublic interface IRemindable { Task ReceiveReminderAsync( string rem\", \"inderName, byte[] state, TimeSpan dueTime, TimeSpan period); }\\n```\\n\\nThe ReceiveReminderAsync method \", \"is called when a reminder is fired. It takes 4 arguments:\\n\\n1. The name of the reminder.\\n2. The user \", \"state provided during registration.\\n3. The invocation due time provided during registration.\\n4. The \", \"invocation period provided during registration.\\n\\nTo register a reminder, use the RegisterReminderAsy\", \"nc method of the actor base class. The following example sets a reminder to fire a single time with \", \"a due time of three minutes.\\n\\n```\\npublic class ReminderActor : Actor, IReminderActor, IRemindable { \", \"public ReminderActor(ActorHost host) : base (host) { } public Task SetReminderAsync(string text) { r\", \"eturn RegisterReminderAsync( \\\"DoNotForget\\\", Encoding.UTF8.GetBytes(text), TimeSpan.FromSeconds(3), T\", \"imeSpan.FromMilliseconds(-1)); } public Task ReceiveReminderAsync( string reminderName, byte[] state\", \", TimeSpan dueTime, TimeSpan period) { if (reminderName == \\\"DoNotForget\\\") { var text = Encoding.UTF8\", \".GetString(state); Logger.LogInformation($\\\"Don't forget: {text}\\\");\\n```\\n\\n```\\n} return Task.CompletedT\", \"ask; } }\\n```\\n\\nThe RegisterReminderAsync method is similar to RegisterTimerAsync but you don't have t\", \"o specify a callback method explicitly. As the above example shows, you implement IRemindable.Receiv\", \"eReminderAsync to handle fired reminders.\\n\\nReminders both reset the idle timer and are persistent. E\", \"ven if your actor is deactivated, it will be reactivated at the moment a reminder fires. To stop a r\", \"eminder from firing, call UnregisterReminderAsync .\\n\\n## Sample application: Dapr Traffic Control\\n\\nTh\", \"e default version of Dapr Traffic Control does not use the actor model. However, it does contain an \", \"alternative actor-based implementation of the TrafficControl service that you can enable. To make us\", \"e of actors in the TrafficControl service, open up the src/TrafficControlService/Controllers/Traffic\", \"Controller.cs file and uncomment the USE\\\\_ACTORMODEL statement at the top of the file:\\n\\n```\\n#define \", \"USE_ACTORMODEL\\n```\\n\\nWhen the actor model is enabled, the application uses actors to represent vehicl\", \"es. The operations that can be invoked on the vehicle actors are defined in an IVehicleActor interfa\", \"ce:\\n\\n```\\npublic interface IVehicleActor : IActor { Task RegisterEntryAsync(VehicleRegistered msg); T\", \"ask RegisterExitAsync(VehicleRegistered msg); }\\n```\\n\\nThe (simulated) entry cameras call the Register\", \"EntryAsync method when a new vehicle is first detected in the lane. The only responsibility of this \", \"method is storing the entry timestamp in the actor state:\\n\\n```\\nvar vehicleState = new VehicleState {\", \" LicenseNumber = msg.LicenseNumber, EntryTimestamp = msg.Timestamp }; await StateManager.SetStateAsy\", \"nc(\\\"VehicleState\\\", vehicleState);\\n```\\n\\nWhen the vehicle reaches the end of the speed camera zone, th\", \"e exit camera calls the RegisterExitAsync method. The RegisterExitAsync method first gets the curren\", \"t states and updates it to include the exit timestamp:\\n\\n```\\nvar vehicleState = await StateManager.Ge\", \"tStateAsync<VehicleState>(\\\"VehicleState\\\"); vehicleState.ExitTimestamp = msg.Timestamp;\\n```\\n\\n## Note\\n\", \"\\nThe code above currently assumes that a VehicleState instance has already been saved by the Registe\", \"rEntryAsync method. The code could be improved by first checking to make sure the state exists. Than\", \"ks to the turn-based access model, no explicit locks are required in the code.\\n\\nAfter the state is u\", \"pdated, the RegisterExitAsync method checks if the vehicle was driving too fast. If it was, the acto\", \"r publishes a message to the collectfine pub/sub topic:\\n\\n```\\nint violation = _speedingViolationCalcu\", \"lator.DetermineSpeedingViolationInKmh( vehicleState.EntryTimestamp, vehicleState.ExitTimestamp); if \", \"(violation > 0) { var speedingViolation = new SpeedingViolation { VehicleId = msg.LicenseNumber, Roa\", \"dId = _roadId, ViolationInKmh = violation, Timestamp = msg.Timestamp }; await _daprClient.PublishEve\", \"ntAsync(\\\"pubsub\\\", \\\"collectfine\\\", speedingViolation); }\\n```\\n\\nThe code above uses two external depende\", \"ncies. The \\\\_speedingViolationCalculator encapsulates the business logic for determining whether or \", \"not a vehicle has driven too fast. The \\\\_daprClient allows the actor to publish messages using the D\", \"apr pub/sub building block.\\n\\nBoth dependencies are registered in the Program.cs class and injected i\", \"nto the actor using constructor dependency injection:\\n\\n```\\nprivate readonly DaprClient _daprClient; \", \"private readonly ISpeedingViolationCalculator _speedingViolationCalculator; private readonly string \", \"_roadId; public VehicleActor( ActorHost host, DaprClient daprClient, ISpeedingViolationCalculator sp\", \"eedingViolationCalculator) : base (host) { _daprClient = daprClient; _speedingViolationCalculator = \", \"speedingViolationCalculator; _roadId = _speedingViolationCalculator.GetRoadId(); }\\n```\\n\\nThe actor ba\", \"sed implementation no longer uses the Dapr state management building block directly. Instead, the st\", \"ate is automatically persisted after each operation is executed.\\n\\n## Summary\\n\\nThe Dapr actors buildi\", \"ng block makes it easier to write correct concurrent systems. Actors are small units of state and lo\", \"gic. They use a turn-based access model which saves you from having to use locking mechanisms to wri\", \"te thread-safe code. Actors are created implicitly and are silently unloaded\\n\\nfrom memory when no op\", \"erations are performed. Any state stored in the actor is automatically persisted and loaded when the\", \" actor is reactivated. Actor model implementations are typically created for a specific language or \", \"platform. With the Dapr actors building block however, you can leverage the actor model from any lan\", \"guage or platform.\\n\\nActors support timers and reminders to schedule future work. Timers do not reset\", \" the idle timer and will allow the actor to be deactivated when no other operations are performed. R\", \"eminders do reset the idle timer and are also persisted automatically. Both timers and reminders res\", \"pect the turn-based access model, making sure that no other operations can execute while the timer/r\", \"eminder events are handled.\\n\\nActor state is persisted using the Dapr state management building block\", \". Any state store that supports multi-item transactions can be used to store actor state.\\n\\n## Refere\", \"nces\\n\\n- Dapr supported state stores\\n\\n## The Dapr observability building block\\n\\nModern distributed sy\", \"stems are complex. You start with small, loosely coupled, independently deployable services. These s\", \"ervices cross process and server boundaries. They then consume different kinds of infrastructure bac\", \"king services (databases, message brokers, key vaults). Finally, these disparate pieces compose toge\", \"ther to form an application.\\n\\nWith so many separate, moving parts, how do you make sense of what is \", \"going on? Unfortunately, legacy monitoring approaches from the past aren't enough. Instead, the syst\", \"em must be observable from end-to-end. Modern observability practices provide visibility and insight\", \" into the health of the application at all times. They enable you to infer the internal state by obs\", \"erving the output. Not only is observability mandatory for monitoring and troubleshooting distribute\", \"d applications, it needs to be implemented at the start.\\n\\nThe system information used to gain observ\", \"ability is referred to as telemetry . It can be divided into four broad categories:\\n\\n1. Distributed \", \"tracing provides insights into the traffic between services involved in distributed business transac\", \"tions.\\n2. Metrics provides insights into the performance of a service and its resource consumption.\\n\", \"3. Logging provides insights into how code is executing and if errors have occurred.\\n4. Health endpo\", \"ints provide insight into the availability of a service.\\n\\nThe depth of telemetry is determined by th\", \"e observability features of an application platform. Consider the Azure cloud. It provides a rich te\", \"lemetry experience that includes all of the telemetry categories. With little configuration, Azure I\", \"aaS and PaaS services will propagate and publish telemetry to the Azure Monitor and Azure Applicatio\", \"n Insights services. Application Insights presents system logging, tracing, and problem areas with h\", \"ighly visual dashboards. It can even render a diagram showing the dependencies between services base\", \"d on their communication.\\n\\nHowever, what if an application can't use Azure PaaS and IaaS resources? \", \"Is it still possible to take advantage of the rich telemetry experience of Application Insights? The\", \" answer is yes. A non-Azure application can import libraries, add configuration, and instrument code\", \" to emit telemetry to Azure Application Insights. However, this approach tightly couples the applica\", \"tion to Application Insights. Moving the app to a different monitoring platform could involve expens\", \"ive refactoring. Wouldn't it be great to avoid tight coupling and consume observability outside of t\", \"he code?\\n\\nWith Dapr, you can. Let's look at how Dapr can add observability to our distr ibuted appli\", \"cations.\\n\\nService A\\n\\n1\\n\\nService A\\n\\nsidecar dapr\\n\\n## What it solves\\n\\n0\\n\\n2\\n\\nCollector\\n\\nThe Dapr observ\", \"ability building block decouples observability from the application. It automatically captures traff\", \"ic generated by Dapr sidecars and Dapr system services that make up the Dapr control plane. The bloc\", \"k correlates traffic from a single operation that spans multiple services. It also exposes performan\", \"ce metrics, resource utilization, and the health of the system. Telemetry is published in open-stand\", \"ard formats enabling information to be fed into your monitoring back end of choice. There, the infor\", \"mation can be visualized, queried, and analyzed.\\n\\nAs Dapr abstracts away the plumbing, the applicati\", \"on is unaware of how observability is implemented. There's no need to reference libraries or impleme\", \"nt custom instrume ntation code. Dapr allows the developer to focus on building business logic inste\", \"ad of observability plumbing. Observability is configured at the Dapr system level and is consistent\", \" across services, even when created by different teams, and built with different technology stacks.\\n\", \"\\n## How it works\\n\\nDapr's sidecar architecture enables built-in observability features. As services c\", \"ommunicate, Dapr sidecars intercept the traffic and extract tracing, metrics, and logging informatio\", \"n. Telemetry is published in an open standards format. By default, Dapr supports OpenTelemetry and Z\", \"ipkin.\\n\\nDapr provides collectors that can publish telemetry to different back-end monitoring tools. \", \"These tools present Dapr telemetry for analysis and querying. Figure 10-1 shows the Dapr observabili\", \"ty architecture:\\n\\nFigure 10-1. Dapr observability architecture.\\n\\n<!-- image -->\\n\\n1. Service A calls \", \"an operation on Service B. The call is routed from a Dapr sidecar for Service A to a sidecar for Ser\", \"vice B.\\n2. When Service B completes the operation, a response is sent back to Service A through the \", \"Dapr sidecars. They gather and publish all available telemetry for every request and response.\\n3. Th\", \"e configured collector ingests the telemetry and sends it to the monitoring back end.\\n\\nService B\\n\\nsi\", \"decar dapr\\n\\n-2\\n\\nService B\\n\\nService A\\n\\ndapr\\n\\nService C\\n\\nA\\n\\nAs a developer, keep in mind that adding o\", \"bservability is different from configuring other Dapr building blocks, like pub/sub or state managem\", \"ent. Instead of referencing a building block, you add a collector and a monitoring back end. Figure \", \"101 shows it's possible to configure multiple collectors that integrate with different monitoring ba\", \"ck ends.\\n\\nService A\\n\\nService C\\n\\nAt the beginning of this chapter, four categories of telemetry were \", \"identified. The following sections will provide detail for each category. They'll include instructio\", \"n on how to configure collectors that integrate with popular monitoring back ends.\\n\\n## Distributed t\", \"racing\\n\\nDistributed tracing provides insight into traffic that flows across services in a distribute\", \"d application. The logs of exchanged request and response messages are a source of invaluable inform\", \"ation for troubleshooting issues. The hard part is correlating messages that belong to the same busi\", \"ness transaction.\\n\\nDapr uses the W3C Trace Context to correlate related messages. It injects the sam\", \"e context information into requests and responses that form a unique operation. Figure 10-2 shows ho\", \"w correlation works:\\n\\n<!-- image -->\\n\\n## Note\\n\\nThe trace context is often referred to as a correlati\", \"on token in microservice terminology.\\n\\nFigure 10-2. W3C Trace Context example.\\n\\n1. Service A invokes\", \" an operation on Service B. As Service A starts the call, Dapr creates a unique trace context and in\", \"jects it into the request.\\n2. Service B receives the request and invokes an operation on Service C. \", \"Dapr detects that the incoming request contains a trace context and propagates it by injecting it in\", \"to the outgoing request to Service C.\\n3. Service C receives the request and handles it. Dapr detects\", \" that the incoming request contains a trace context and propagates it by injecting it into the outgo\", \"ing response back to Service B.\\n4. Service B receives the response and handles it. It then creates a\", \" new response and propagates the trace context by injecting it into the outgoing response back to Se\", \"rvice A.\\n\\nA set of requests and responses that belong together is called a trace . Figure 10-3 shows\", \" a trace:\\n\\nService B\\n\\nSpan\\n\\nTrace\\n\\nA =\\u2192 B\\n\\nFigure 10-3. Traces and spans.\\n\\n<!-- image -->\\n\\nIn the fi\", \"gure, note how the trace represents a unique application transaction that takes place across many se\", \"rvices. A trace is a collection of spans . Each span represents a single operation or unit of work d\", \"one within the trace. Spans are the requests and responses that are sent between services that imple\", \"ment the unique transaction.\\n\\nThe next sections discuss how to inspect tracing telemetry by publishi\", \"ng it to a monitoring back end.\\n\\n## Use a Zipkin monitoring back end\\n\\nZipkin is an open-source distr\", \"ibuted tracing system. It can ingest and visualize telemetry data. Dapr offers default support for Z\", \"ipkin. The following example demonstrates how to configure Zipkin to visualize Dapr telemetry.\\n\\n## E\", \"nable and configure tracing\\n\\nTo start , tracing must be enabled for the Dapr runtime using a Dapr co\", \"nfiguration file. Here's an example of a configuration file named dapr-config.yaml that enables trac\", \"ing:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Configuration metadata: name: dapr-config namespace: de\", \"fault spec: tracing: samplingRate: \\\"1\\\" zipkin: endpointAddress: \\\"http://zipkin.default.svc.cluster.l\", \"ocal:9411/api/v2/spans\\\"\\n```\\n\\nThe samplingRate attribute specifies the interval used for publishing t\", \"races. The value must be between 0 (tracing disabled) and 1 (every trace is published). With a value\", \" of 0.5 , for example, every other trace is published, significantly reducing published traffic. The\", \" endpointAddress points to an endpoint on a Zipkin server running in a Kubernetes cluster. The defau\", \"lt port for Zipkin is 9411 . The configuration must be applied to the Kubernetes cluster using the K\", \"ubernetes CLI:\\n\\n```\\nkubectl apply -f dapr-config.yaml\\n```\\n\\n## Install the Zipkin server\\n\\nWhen instal\", \"ling Dapr in self-hosted mode, a Zipkin server is automatically installed and tracing is enabled in \", \"the default configuration file located in $HOME/.dapr/config.yaml or %USERPROFILE%\\\\.dapr\\\\config.yaml\", \" on Windows.\\n\\nWhen installing Dapr on a Kubernetes cluster, Zipkin must be deployed manually. Use th\", \"e following Kubernetes manifest file entitled zipkin.yaml to deploy a standard Zipkin server to a Ku\", \"bernetes cluster:\\n\\n```\\nkind: Deployment apiVersion: apps/v1 metadata: name: zipkin namespace: dapr-t\", \"rafficcontrol labels: service: zipkin spec: replicas: 1 selector: matchLabels: service: zipkin templ\", \"ate: metadata: labels: service: zipkin spec: containers: -name: zipkin image: openzipkin/zipkin-slim\", \" imagePullPolicy: IfNotPresent ports: -name: http containerPort: 9411 protocol: TCP ---kind: Service\", \" apiVersion: v1 metadata: name: zipkin namespace: dapr-trafficcontrol labels: service: zipkin spec: \", \"type: NodePort ports: -port: 9411 targetPort: 9411 nodePort: 32411 protocol: TCP name: zipkin select\", \"or: service: zipkin\\n```\\n\\nThe deployment uses the standard openzipkin/zipkin-slim container image. Th\", \"e Zipkin service exposes the Zipkin web front end, which you can use to view the telemetry on port 3\", \"2411 . Use the\\n\\nKubernetes CLI to apply the Zipkin manifest file to the Kubernetes cluster and deplo\", \"y the Zipkin server:\\n\\nkubectl apply -f zipkin.yaml\\n\\n## Configure the services to use the tracing con\", \"figuration\\n\\nNow everything is set up correctly to start publishing telemetry. Every Dapr sidecar tha\", \"t is deployed as part of the application must be instructed to emit telemetry when started. To do th\", \"at, add a dapr.io/config annotation that references the dapr-config configuration to the deployment \", \"of each service. Here's an example of the Traffic Control FineCollection service's manifest file con\", \"taining the annotation:\\n\\n```\\napiVersion: apps/v1 kind: Deployment metadata: name: finecollectionserv\", \"ice namespace: dapr-trafficcontrol labels: app: finecollectionservice spec: replicas: 1 selector: ma\", \"tchLabels: app: finecollectionservice template: metadata: labels: app: finecollectionservice annotat\", \"ions: dapr.io/enabled: \\\"true\\\" dapr.io/app-id: \\\"finecollectionservice\\\" dapr.io/app-port: \\\"6001\\\" dapr.\", \"io/config: \\\"dapr-config\\\" spec: containers: -name: finecollectionservice image: dapr-trafficcontrol/f\", \"inecollectionservice:1.0 ports: -containerPort: 6001\\n```\\n\\n## Inspect the telemetry in Zipkin\\n\\nOnce t\", \"he application is started, the Dapr sidecars will emit telemetry to the Zipkin server. To inspect th\", \"is telemetry, point a web-browser to http://localhost:32411 . You'll see the Zipkin web front end:\\n\\n\", \"Zipkin\\n\\nZipkin\\n\\n+\\n\\n+\\n\\n10 Results\\n\\nRoot trafficcontrolservice: bindings/exitcam\\n\\ntrafficcontrolservic\", \"e: bindings/exitcam trafficcontrolservice: bindings/exitcam\\n\\ntrafficcontrolservice: bindings/exitcam\", \" trafficcontrolservice: bindings/entrycam\\n\\ntrafficcontrolservice: bindings/exitcam trafficcontrolser\", \"vice: bindings/entrycam\\n\\nSearch by trace ID\\n\\nSearch by trace ID\\n\\nRUN GUERY\\n\\n*-\\n\\nS RUN QUERY\\n\\nService\", \" filters\\n\\nFigure 10-4. Zipkin front end.\\n\\n<!-- image -->\\n\\nOn the Find a trace tab, you can query tra\", \"ces. Pressing the RUN QUERY button without specifying any restrictions will show all the ingested tr\", \"aces :\\n\\nFigure 10-5. Zipkin traces overview.\\n\\n<!-- image -->\\n\\nClicking the SHOW button next to a spe\", \"cific trace, will show the details of that trace:\\n\\nQ Find a trace\\n\\nT\\u00b0 Dependencies\\n\\nQ Find a trace D\", \"ependencies\\n\\nXA ENGLISH Y\\n\\n*A ENGLISH V\\n\\nEXPAND ALL\\n\\nCOLLAPSE ALL\\n\\n\\u2022 Zipkin\\n\\nQ Find a trace\\n\\n\\\" Depen\", \"dencies\\n\\nTRAFFICCONTROLSERVICE: bindings/entrycam\\n\\nDuration: 5.666ms Services: 1 Depth: 2 Total Span\", \"s: 2 Trace ID: 572745da4058a2f8406446420c402657\\n\\n^ v\\n\\n\\u2022 TRAFFICCONTROLSERVICE\\n\\nTRAFFICCONTROLSERVICE\", \"\\n\\n\\u00ab\\n\\nFigure 10-6. Zipkin trace details.\\n\\n<!-- image -->\\n\\nEach item on the details page, is a span th\", \"at represents a request that is part of the selected trace.\\n\\n## Inspect the dependencies between ser\", \"vices\\n\\nBecause Dapr sidecars handle traffic between services, Zipkin can use the trace information t\", \"o determine the dependencies between the services. To see it in action, go to the Dependencies tab o\", \"n the Zipkin web page and select the button with the magnifying glass. Zipkin will show an overview \", \"of the services and their dependencies:\\n\\nJA ENGLISH Y\\n\\nSearch by trace ID\\n\\n* DOWNLOAD JSON\\n\\nZipkin\\n\\n\", \"Select...\\n\\nQ Find a trace\\n\\n*\\u00b0 Dependencies\\n\\nStart Time\\n\\n05/09/2021 09:58:51\\n\\nTA ENGLISH V\\n\\nEnd Time\\n\", \"\\n05/10/2021 09:58:51\\n\\nQ\\n\\nFigure 10-7. Zipkin dependencies.\\n\\n<!-- image -->\\n\\nThe animated dots on the\", \" lines between the services represent requests and move from source to destination. Red dots indicat\", \"e a failed request.\\n\\n## Use a Jaeger or New Relic monitoring back end\\n\\nBeyond Zipkin, other monitori\", \"ng back-end software can also ingest telemetry with the Zipkin format. Jaeger is an open source trac\", \"ing system created by Uber Technologies. It's used to trace transactions between distributed service\", \"s and troubleshoot complex microservices environments. New Relic is a full-stack observability platf\", \"orm. It links relevant data from a distributed application to provide a complete picture of your sys\", \"tem. To try them out, specify an endpointAddress pointing to either a Jaeger or New Relic server in \", \"the Dapr configuration file. Here's an example of a configuration file that configures Dapr to send \", \"telemetry to a Jaeger server. The URL for Jaeger is identical to the URL for the Zipkin. The only di\", \"fference is the number of the port on which the server runs:\\n\\n:::{custom-style=CodeBox} yaml  apiVer\", \"sion: dapr.io/v1alpha1  kind: Configuration  metadata:    name: dapr-config    namespace: default  s\", \"pec:    tracing:      samplingRate: \\\"1\\\"      zipkin: endpointAddress: \\\"http://localhost:9415/api/v2/\", \"spans\\\" :::\\n\\nTo try out New Relic, specify the endpoint of the New Relic API. Here's an example of a \", \"configuration file for New Relic:\\n\\n:::{custom-style=CodeBox} yaml apiVersion: dapr.io/v1alpha1  kind\", \": Configuration  metadata:    name: dapr-config    namespace: default  spec:    tracing:      sampli\", \"ngRate: \\\"1\\\"      zipkin: endpointAddress: \\\"https://trace-api.newrelic.com/trace/v1?Api-Key=&lt;NR-AP\", \"I-KEY&gt;&amp;DataFormat=zipkin&amp;Data-Format-Version=2\\\" :::\\n\\nSearch by trace ID\\n\\ndapr dapr\\n\\ndapr \", \"dapr\\n\\nSidecar dapr\\n\\nSidecar\\n\\nCheck out the Jaeger and New Relic websites for more information on how\", \" to use them.\\n\\n## Metrics\\n\\nMetrics provide insight into performance and resource consumption. Under \", \"the hood, Dapr emits a wide collection of system and runtime metrics. Dapr uses Prometheus as a metr\", \"ic standard. Dapr sidecars and system services, expose a metrics endpoint on port 9090 . A Prometheu\", \"s scraper calls this endpoint at a predefined interval to collect metrics. The scraper sends metric \", \"values to a monitoring back end. Figure 10-8 shows the scraping process: backend\\n\\nPlacement service\\n\", \"\\nSentry service\\n\\n-04\\n\\nmetrics scraper\\n\\nFigure 10-8. Scraping Prometheus metrics.\\n\\n<!-- image -->\\n\\nEa\", \"ch sidecar and system service exposes a metric endpoint that listens on port 9090. The Prometheus Me\", \"trics Scrapper captures metrics from each endpoint and published the information to the monitoring b\", \"ack end.\\n\\n## Service discovery\\n\\nYou might wonder how the metrics scraper knows where to collect metr\", \"ics. Prometheus can integrate with discovery mechanisms built into target deployment environments. F\", \"or example, when running in Kubernetes, Prometheus can integrate with the Kubernetes API to find all\", \" available Kubernetes resources running in the environment.\\n\\n## Metrics list\\n\\nDapr generates a large\", \" set of metrics for Dapr system services and its runtime. Some examples include:\\n\\nService A\\n\\nService\", \" B\\n\\n| Metric                                         | Source   | Description                       \", \"                                                             |\\n|------------------------------------\", \"------------|----------|----------------------------------------------------------------------------\", \"--------------------|\\n| dapr_operator_service_created_total            | System   | The total number\", \" of Dapr services created by the Dapr Operator service.                        |\\n| dapr_injector_sid\", \"ecar_injection/requests_total | System   | The total number of sidecar injection requests received b\", \"y the Dapr Sidecar- Injector service. |\\n| dapr_placement_runtimes_total                  | System   \", \"| The total number of hosts reported to the Dapr Placement service.                              |\\n|\", \" dapr_sentry_cert_sign_request_received_total   | System   | The number of certificate signing reque\", \"sts (CRSs) received by the Dapr Sentry service.         |\\n| dapr_runtime_component_loaded           \", \"       | Runtime  | The number of successfully loaded Dapr components.                              \", \"               |\\n| dapr_grpc_io_server_completed_rpcs             | Runtime  | Count of gRPC calls b\", \"y method and status.                                                      |\\n| dapr_http_server_reque\", \"st_count                 | Runtime  | Number of HTTP requests started in an HTTP server.            \", \"                                 |\\n| dapr_http/client/sent_bytes                    | Runtime  | Tot\", \"al bytes sent in request body (not including headers) by an HTTP client.                    |\\n\\nFor m\", \"ore information on available metrics, see the Dapr metrics documentation.\\n\\n## Configure Dapr metrics\", \"\\n\\nAt run time, you can disable the metrics collection endpoint by including the --enablemetrics=fals\", \"e argument in the Dapr command. Or, you can also change the default port for the endpoint with the -\", \"-metrics-port 9090 argument.\\n\\nYou can also use a Dapr configuration file to statically enable or dis\", \"able runtime metrics collection:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Configuration metadata: nam\", \"e: dapr-config namespace: dapr-trafficcontrol spec: tracing: samplingRate: \\\"1\\\" metric: enabled: fals\", \"e\\n```\\n\\n## Visualize Dapr metrics\\n\\nWith the Prometheus scraper collecting and publishing metrics into\", \" the monitoring back end, how do you make sense of the raw data? A popular visualization tool for an\", \"alyzing metrics is Grafana. With Grafana, you can create dashboards from the available metrics. Here\", \"'s an example of a dashboard displaying Dapr system services metrics:\\n\\nQ\\n\\n+\\n\\n88\\n\\n88 Dapr System Serv\", \"ices Dashboard * &lt;\\n\\nv Health &amp; Resource\\n\\nUptime dapr-operator\\n\\ndapr-placement-server dapr-sen\", \"try\\n\\ndapr-sidecar-injector v Sidecar Injector\\n\\n5.0\\n\\n4.5\\n\\n4.0\\n\\n3.5\\n\\n3.0\\n\\n20:18:30\\n\\n20:19:00\\n\\n- sideca\", \"rs requests\\n\\n~ CA Sentry\\n\\nRoot/Issuer cert expirynute\\n\\n52.1 week left\\n\\n6.0 min\\n\\n6.0 min\\n\\n8 ms\\n\\n6 ms\\n\", \"\\n15.0 MB\\n\\n12.5 MB\\n\\n10.0 MB\\n\\n100\\n\\n75\\n\\nFigure 10-9. Grafana dashboard.\\n\\n<!-- image -->\\n\\nThe Dapr docum\", \"entation includes a tutorial for installing Prometheus and Grafana.\\n\\n## Logging\\n\\nLogging provides in\", \"sight into what is happening with a service at run time. When running an application, Dapr automatic\", \"ally emits log entries from Dapr sidecars and Dapr system services. However, logging entries instrum\", \"ented in your application code aren't automatically included. To emit logging from application code,\", \" you can import a specific SDK like OpenTelemetry SDK for .NET. Logging application code is covered \", \"later in this chapter in the section Using the Dapr .NET SDK .\\n\\n## Log entry structure\\n\\nDapr emits s\", \"tructured logging. Each log entry has the following format:\\n\\n| Field    | Description               \", \"                            | Example                           |\\n|----------|----------------------\", \"---------------------------------|-----------------------------------|\\n| time     | ISO8601 formatte\", \"d timestamp                           | 2021-01-10T14:19:31.000Z          |\\n| level    | Level of th\", \"e entry ( debug , info , warn , or error ) | info                              |\\n| type     | Log Ty\", \"pe                                              | log                               |\\n| msg      | L\", \"og Message                                           | metrics server started on :62408/ |\\n| scope  \", \"  | Logging Scope                                         | dapr.runtime                      |\\n| in\", \"stance | Hostname where Dapr runs                              | TSTSRV01                          |\", \"\\n\\nTotal CPU usage (kernel and user)\\n\\nHeap Memory usage in bytes\\n\\n1h 4\\n\\n\\u2022 Last 5 minutes\\n\\nNumber of G\", \"O routines\\n\\n5s v\\n\\n| Field   | Description          | Example               |\\n|---------|------------\", \"----------|-----------------------|\\n| app_id  | Dapr App ID          | finecollectionservice |\\n| ver\", \"     | Dapr Runtime Version | 1.0                   |\\n\\nWhen searching through logging entries in a t\", \"roubleshooting scenario, the time and level fields are especially helpful. The time field orders log\", \" entries so that you can pinpoint specific time periods. When troubleshooting, log entries at the de\", \"bug level provide more information on the behavior of the code.\\n\\n## Plain text versus JSON format\\n\\nB\", \"y default, Dapr emits structured logging in plain-text format. Every log entry is formatted as a str\", \"ing containing key/value pairs. Here's an example of logging in plain te xt:\\n\\n```\\n== DAPR == time=\\\"2\", \"021-01-12T16:11:39.4669323+01:00\\\" level=info msg=\\\"starting Dapr Runtime - version 1.0 -- commit 1964\", \"83d\\\" app_id=finecollectionservice instance=TSTSRV03 scope=dapr.runtime type=log ver=1.0 == DAPR == t\", \"ime=\\\"2021-01-12T16:11:39.467933+01:00\\\" level=info msg=\\\"log level set to: info\\\" app_id=finecollection\", \"service instance=TSTSRV03 scope=dapr.runtime type=log ver=1.0 == DAPR == time=\\\"2021-01-12T16:11:39.4\", \"67933+01:00\\\" level=info msg=\\\"metrics server started on :62408/\\\" app_id=finecollectionservice instanc\", \"e=TSTSRV03 scope=dapr.metrics type=log ver=1.0\\n```\\n\\nWhile simple, this format is difficult to parse.\", \" If viewing log entries with a monitoring tool, you'll want to enable JSON formatted logging. With J\", \"SON entries, a monitoring tool can index and query individual fields. Here's the same log entries in\", \" JSON format:\\n\\n```\\n{\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\", \"\\\": \\\"starting Dapr Runtime -- version 1.0 -- commit 196483d\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"time\\\": \\\"2021-\", \"01-12T16:11:39.4669323+01:00\\\", \\\"type\\\": \\\"log\\\", \\\"ver\\\": \\\"1.0\\\"} {\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"ins\", \"tance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \\\"log level set to: info\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"type\", \"\\\": \\\"log\\\", \\\"time\\\": \\\"2021-0112T16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"} {\\\"app_id\\\": \\\"finecollectionservice\", \"\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \\\"metrics server started on :62408/\\\", \\\"scope\\\": \\\"da\", \"pr.metrics\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"202101-12T16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"}\\n```\\n\\nTo enable \", \"JSON formatting, you need to configure each Dapr sidecar. In self-hosted mode, you can specify the f\", \"lag --log-as-json on the command line:\\n\\n```\\ndapr run --app-id finecollectionservice --log-level info\", \" --log-as-json dotnet run\\n```\\n\\nIn Kubernetes, you can add a dapr.io/log-as-json annotation to each d\", \"eployment for the application:\\n\\n```\\nannotations: dapr.io/enabled: \\\"true\\\" dapr.io/app-id: \\\"finecollec\", \"tionservice\\\" dapr.io/app-port: \\\"80\\\" dapr.io/config: \\\"dapr-config\\\" dapr.io/log-as-json: \\\"true\\\"\\n```\\n\\nW\", \"hen you install Dapr in a Kubernetes cluster using Helm, you can enable JSON formatted logging for a\", \"ll the Dapr system services:\\n\\n```\\nhelm repo add dapr https://dapr.github.io/helm-charts/ helm repo u\", \"pdate kubectl create namespace dapr-system helm install dapr dapr/dapr --namespace dapr-system --set\", \" global.logAsJson=true\\n```\\n\\n## Collect logs\\n\\nThe logs emitted by Dapr can be fed into a monitoring b\", \"ack end for analysis. A log collector is a component that collects logs from a system and sends them\", \" to a monitoring back end. A popular log collector is Fluentd. Check out the How-To: Set up Fluentd,\", \" Elastic search and Kibana in Kubernetes in the Dapr documentation. This article contains instructio\", \"ns for setting up Fluentd as log collector and the ELK Stack (Elastic Search and Kibana) as a monito\", \"ring back end.\\n\\n## Health status\\n\\nThe health status of a service provides insight into its availabil\", \"ity. Each Dapr sidecar exposes a health API that can be used by the hosting environment to determine\", \" the health of the sidecar. The API has one operation:\\n\\n```\\nGET http://localhost:3500/v1.0/healthz\\n`\", \"``\\n\\nThe operation returns two HTTP status codes:\\n\\n- 204: When the sidecar is healthy\\n- 500: when the\", \" sidecar isn't healthy\\n\\nWhen running in selfhosted mode, the health API isn't automatically invoked.\", \" You can invoke the API though from application code or a health monitoring tool.\\n\\nWhen running in K\", \"ubernetes, the Dapr sidecar-injector automatically configures Kubernetes to use the health API for e\", \"xecuting liveness probes and readiness probes .\\n\\nKubernetes uses liveness probes to determine whethe\", \"r a container is up and running. If a liveness probe returns a failure code, Kubernetes will assume \", \"the container is dead and automatically restart it. This feature increases the overall availability \", \"of your application.\\n\\nKubernetes uses readiness probes to determine whether a container is ready to \", \"start accepting traffic. A pod is considered ready when all of its containers are ready. Readiness d\", \"etermines whether a Kubernetes service can direct traffic to a pod in a loadbalancing scenario. Pods\", \" that aren't ready are automatically removed from the load-balancer.\\n\\nLiveness and readiness probes \", \"have several configurable parameters. Both are configured in the container spec section of a pod's m\", \"anifest file. By default, Dapr uses the following configuration for each sidecar container:\\n\\n```\\nliv\", \"enessProbe: httpGet: path: v1.0/healthz port: 3500 initialDelaySeconds: 5 periodSeconds: 10 timeoutS\", \"econds : 5 failureThreshold : 3\\n```\\n\\n```\\nreadinessProbe: httpGet: path: v1.0/healthz port: 3500 init\", \"ialDelaySeconds: 5 periodSeconds: 10 timeoutSeconds : 5 failureThreshold: 3\\n```\\n\\nThe following param\", \"eters are available for the probes:\\n\\n- The path specifies the Dapr health API endpoint.\\n- The port s\", \"pecifies the Dapr health API port.\\n- The initialDelaySeconds specifies the number of seconds Kuberne\", \"tes will wait before it starts probing a container for the first time.\\n- The periodSeconds specifies\", \" the number of seconds Kubernetes will wait between each probe.\\n- The timeoutSeconds specifies the n\", \"umber of seconds Kubernetes will wait on a response from the API before timing out. A timeout is int\", \"erpreted as a failure.\\n- The failureThreshold specifies the number of failed status code Kubernetes \", \"will accept before considering the container not alive or not ready.\\n\\n## Dapr dashboard\\n\\nDapr offers\", \" a dashboard that presents status information on Dapr applications, components, and configurations. \", \"Use the Dapr CLI to start the dashboard as a web-application on the local machine on port 8080:\\n\\n```\", \"\\ndapr dashboard\\n```\\n\\nFor Dapr application running in Kubernetes, use the following command:\\n\\n```\\ndap\", \"r dashboard -k\\n```\\n\\nThe dashboard opens with an overview of all services in your application that ha\", \"ve a Dapr sidecar. The following screenshot shows the Dapr dashboard for the Traffic Control sample \", \"application running in Kubernetes:\\n\\n:::i mage type='content' source='./media/observability/dapr -das\", \"hboardoverview.png' alt -text='Dapr dashboard overview':::\\n\\nFigure 10-10. Dapr dashboard overview.\\n\\n\", \"The Dapr dashboard is invaluable when troubleshooting a Dapr application. It provides information ab\", \"out Dapr sidecars and system services. You can drill down into the configuration of each service, in\", \"cluding the logging entries.\\n\\nThe dashboard also shows the configured components (and their configur\", \"ation) for an application:\\n\\n:::image type='content' source='./media/observability/dapr -dashboardcom\", \"ponents.png' alt -text='Dapr dashboard components':::\\n\\nFigure 10-11. Dapr dashboard components.\\n\\n\\u2022 Z\", \"ipkin\\n\\nQ, Find a trace\\n\\n*' Dependencies\\n\\nTRAFFICCONTROLSERVICE: bindings/exitcam\\n\\nDuration: 1.785s S\", \"ervices: 3 Depth: 3 Total Spans: 8 Trace ID: b05e9fbd829ac2cd425295dc4c2fdf6a\\n\\nJA ENGLISH v\\n\\nSearch \", \"by trace ID\\n\\n* DOWNLOAD JSON\\n\\n\\u00ab\\n\\nThere's a large amount of information available through the dashboa\", \"rd. You can discover it by running a Dapr application and browsing the dashboard.\\n\\nCheck out the Dap\", \"r dashboard CLI command reference in the Dapr docs for more information on the Dapr dashboard comman\", \"ds.\\n\\nVEHICLEREGISTRATIONSERVICE\\n\\nFINECOLLECTIONSERVICE\\n\\ncalllocal/vehicleregistrationservice/vehicle\", \"info/pl-454-f [101.711ms)\\n\\n/dapr.proto.runtime.v1.dapr/invokebinding [1.677s]\\n\\n## Use the Dapr .NET \", \"SDK\\n\\nThe Dapr .NET SDK doesn't contain any specific observability features. All observability featur\", \"es are offered at the Dapr level.\\n\\nIf you want to emit telemetry from your .NET application code, yo\", \"u should consider the OpenTelemetry SDK for .NET. The Open Telemetry project is cross-platform, open\", \" source, and vendor agnostic. It provides an end-to-end implementation to generate, emit, collect, p\", \"rocess, and export telemetry data. There's a single instrumentation library per language that suppor\", \"ts automatic and manual instrumentation. Telemetry is published using the Open Telemetry standard. T\", \"he project has broad industry support and adoption from cloud providers, vendors, and end users.\\n\\n##\", \" Sample application: Dapr Traffic Control\\n\\nBecause the Traffic Control sample application runs with \", \"Dapr, all the telemetry described in this chapter is available. If you run the application and open \", \"the Zipkin web fro nt end, you'll see end -toend tracing. Figure 10-12 shows an example:\\n\\nFigure 10-\", \"12. Zipkin end-to-end tracing example.\\n\\n<!-- image -->\\n\\nThis trace shows the communication that occu\", \"rs when a speeding violation has been detected:\\n\\n1. An exiting vehicle triggers the MQTT input bindi\", \"ng that sends a message containing the vehicle license number, lane, and timestamp.\\n2. The MQTT inpu\", \"t binding invokes the TrafficControl service with the message.\\n3. The TrafficControl service retriev\", \"es the state for the vehicle, appends the entry, and saves the updated vehicle state back to the sta\", \"te store.\\n4. The TrafficControl service publishes the speeding violation using pub/sub to the speedi\", \"ngviolations topic.\\n5. The FineCollection service receives the speeding violation using a pub/sub su\", \"bscription on the speedingviolations topic.\\n6. The FineCollection service invokes the vehicleinfo en\", \"dpoint of the VehicleRegistration service using service invocation.\\n7. The FineCollection service in\", \"vokes an output binding for sending the email.\\n\\nClick any trace line (span) to see more details. If \", \"you click on the last line, you'll see the sendmail binding component invoked to send the driver a v\", \"iolation notice.\\n\\nFINECOLLECTIONSERVICE\\n\\n/dapr.proto.runtime.v1.dapr/invokebinding\\n\\nSpan ID: 496eb00\", \"91499dd88 Parent ID:e3785a963afOec45\\n\\nAnnotations\\n\\nTags dapr.api\\n\\n/dapr.proto.runtime.v1.Dapr/Invoke\", \"Binding dapr.protocol\\n\\ngrpc db.connection\\\\_string|\\n\\nbindings doctane\\n\\nsendmail db.statement\\n\\n/dapr.p\", \"roto.runtime.v1.Dapr/InvokeBinding db.system\\n\\nbindings\\n\\n\\u0433pc.service\\n\\nDapr\\n\\nFigure 10-13. Output bind\", \"ing trace details.\\n\\n<!-- image -->\\n\\n## Summary\\n\\nDetailed observability is critical to running a dist\", \"ributed system in production.\\n\\nDapr provides different types of telemetry, including distributed tra\", \"cing, logging, metrics, and health status.\\n\\nDapr only produces telemetry for the Dapr system service\", \"s and sidecars. Telemetry from your application code isn't automatically included. You can however u\", \"se a specific SDK like the OpenTelemetry SDK for .NET to emit telemetry from your application code.\\n\", \"\\nDapr telemetry is produced in an open-standards based format so that it can be ingested by a large \", \"set of available monitoring tools. Examples include Zipkin, Azure Application Insights, the ELK Stac\", \"k, New Relic, and Grafana. See Monitor your application with Dapr in the Dapr documentation for tuto\", \"rials on how to monitor your Dapr applications with specific monitoring back ends.\\n\\nYou'll need a te\", \"lemetry scraper that ingests telemetry and publishe s it to the monitoring back end.\\n\\nDapr can be co\", \"nfigured to emit structured logging. Structured logging is favored as it can be indexed by back-end \", \"monitoring tools. Indexed logging enables users to execute rich queries when searching through the l\", \"ogging.\\n\\nDapr offers a dashboard that presents information about the Dapr services and configuration\", \".\\n\\n## References\\n\\n- Azure Application Insights\\n- Open Telemetry\\n- Zipkin\\n- W3C Trace Context\\n- Jaege\", \"r\\n- New Relic\\n- Prometheus\\n- Grafana\\n- Open Telemetry SDK for .NET\\n- Fluentd\\n- ELK stack\\n- Seq\\n- Ser\", \"ilog\\n\\n## The Dapr secrets management building block\\n\\nEnterprise applications require secrets. Common\", \" examples include:\\n\\n- A database connection string that contains a username and password.\\n- An API k\", \"ey for calling an external web API.\\n- A client certificate for authenticating to an external system.\", \"\\n\\nSecrets must be carefully managed so that they're never disclosed outside of the application.\\n\\nNot\", \" long ago, it was popular to store application secrets in a configuration file inside the applicatio\", \"n codebase. .NET developers will fondly recall the web.config file. While simple to implement, integ\", \"rating secrets to along with code was far from secure. A common misstep was to include the file when\", \" pushing to a public GIT repository, exposing the secrets to the world.\\n\\nA widely accepted methodolo\", \"gy for constructing modern distributed applications is The TwelveFactor App. It describes a set of p\", \"rinciples and best practices. Its third factor prescribes that configuration and secrets be external\", \"ized outside of the code base.\\n\\nTo address this concern, the .NET platform includes a Secret Manager\", \" feature that stores sensitive data in a physical folder outside of the project tree. While secrets \", \"are outside of source control, this feature doesn't encrypt data. It's designed for development purp\", \"oses only.\\n\\nA more modern and secure practice is to isolate secrets in a secrets management tool lik\", \"e Hashicorp Vault or Azure Key Vault . These tools enable you to store secrets externally, vary cred\", \"entials across environments, and reference them from application code. However, each tool has its co\", \"mplexities and learning curve.\\n\\nDapr offers a building block that simplifies managing secrets.\\n\\n## W\", \"hat it solves\\n\\nThe Dapr secrets management building block abstracts away the complexity of working w\", \"ith secrets and secret management tools.\\n\\n- It hides the underlying plumbing through a unified inter\", \"face.\\n- It supports various pluggable secret store components, which can vary between development an\", \"d production.\\n- Applications don't require direct dependencies on secret store libraries.\\n- Develope\", \"rs don't require detailed knowledge of each secret store.\\n\\nDapr handles all of the above concerns.\\n\\n\", \"Access to the secrets is secured through authentication and authorization. Only an application with \", \"sufficient rights can access secrets. Applications running in Kubernetes can also use its built-in s\", \"ecrets management mechanism.\\n\\n## How it works\\n\\nApplications use the secrets management building bloc\", \"k in two ways:\\n\\n- Retrieve a secret directly from the building block.\\n- Reference a secret indirectl\", \"y from a Dapr component configuration.\\n\\nRetrieving secrets directly is covered first. Referencing a \", \"secret from a Dapr component configuration file is addressed in a later section.\\n\\nThe application in\", \"teracts with a Dapr sidecar when using the secrets management building block. The sidecar exposes th\", \"e secrets API. The API can be called with either HTTP or gRPC. Use the following URL to call the HTT\", \"P API:\\n\\nhttp://localhost:&lt;dapr-port&gt;/v1.0/secrets/&lt;store-name&gt;/&lt;name&gt;?&lt;metadata\", \"&gt;\\n\\nThe URL contains the following segments:\\n\\n- &lt;dapr-port&gt; specifies the port number upon w\", \"hich the Dapr sidecar is listening.\\n- &lt;store-name&gt; specifies the name of the Dapr secret store\", \".\\n- &lt;name&gt; specifies the name of the secret to retrieve.\\n- &lt;metadata&gt; provides additiona\", \"l information for the secret. This segment is optional and metadata properties differ per secret sto\", \"re. For more information on metadata properties, see the [secrets API reference] INTERNAL-LINK:(Secr\", \"ets API reference | Dapr Docs ).\\n\\n[!NOTE] The above URL represents the native Dapr API call availabl\", \"e to any development platform that supports HTTP or gRPC. Popular platforms like .NET, Java, and Go \", \"have their own custom APIs.\\n\\nThe JSON response contains the key and value of the secret.\\n\\nFigure 11-\", \"1 shows how Dapr handles a request for the secrets API:\\n\\n{\\n\\n}\\n\\nGET http://localhost:3500/v1.0/secret\", \"s/secrets-store/redis-password\\n\\nService A\\n\\nFigure 11-1. Retrieving a secret with the Dapr secrets AP\", \"I.\\n\\n<!-- image -->\\n\\n1. The service calls the Dapr secrets API, along with the name of the secret sto\", \"re, and secret to retrieve.\\n2. The Dapr sidecar retrieves the specified secret from the secret store\", \".\\n3. The Dapr sidecar returns the secret information back to the service.\\n\\nSome secret stores suppor\", \"t storing multiple key/value pairs in a single secret. For those scenarios, the response would conta\", \"in multiple key/value pairs in a single JSON response as in the following example:\\n\\nGET http://local\", \"host:3500/v1.0/secrets/secret-store/interestRates?metadata.version\\\\_id=3\\n\\n```\\n{ \\\"tier1-percentage\\\": \", \"\\\"2.5\\\", \\\"tier2-percentage\\\": \\\"3.8\\\", \\\"tier3-percentage\\\": \\\"5.1\\\" }\\n```\\n\\nThe Dapr secrets API also offers \", \"an operation to retrieve all the secrets the application has access to:\\n\\n```\\nhttp://localhost:<dapr-\", \"port>/v1.0/secrets/<store-name>/bulk\\n```\\n\\n## Use the Dapr .NET SDK\\n\\nFor .NET developers, the Dapr .N\", \"ET SDK streamlines Dapr secret management. Consider the DaprClient.GetSecretAsync method. It enables\", \" you to retrieve a secret directly from any Dapr secret store with minimal effort. Here's an example\", \" of fetching a connection string secret for a SQL Server database:\\n\\n```\\nvar metadata = new Dictionar\", \"y<string, string> { [\\\"version_id\\\"] = \\\"3\\\" }; Dictionary<string, string> secrets = await daprClient.Ge\", \"tSecretAsync(\\\"secret-store\\\", \\\"eshopsecrets\\\", metadata); string connectionString = secrets[\\\"customerd\", \"b\\\"];\\n```\\n\\nArguments for the GetSecretAsync method include:\\n\\n- The name of the Dapr secret store comp\", \"onent ('secret -store')\\n- The secret to retrieve ('eshopsecrets')\\n- Optional metadata key/value pair\", \"s ('version\\\\_id=3')\\n\\nThe method responds with a dictionary object as a secret can contain multiple k\", \"ey/value pairs. In the example above, the secret named customerdb is referenced from the collection \", \"to return a connection string.\\n\\nThe Dapr .NET SDK also features a .NET configuration provider. It lo\", \"ads specified secrets into the underlying .NET configuration API. The running application can then r\", \"eference secrets from the IConfiguration dictionary that is registered in ASP.NET Core dependency in\", \"jection.\\n\\nThe secrets configuration provider is available from the Dapr.Extensions.Configuration NuG\", \"et package. The provider can be registered in the Program.cs of an ASP.NET Web API application:\\n\\n```\", \"\\nvar builder = WebApplication.CreateBuilder(args); builder.WebHost.ConfigureAppConfiguration(config \", \"=> { var daprClient = new DaprClientBuilder().Build(); var secretDescriptors = new List<DaprSecretDe\", \"scriptor> { new DaprSecretDescriptor(\\\"eshopsecrets\\\") }; config.AddDaprSecretStore(\\\"secret-store\\\", se\", \"cretDescriptors, daprClient); });\\n```\\n\\nThe above example loads the eshopsecrets secrets collection i\", \"nto the .NET configuration system at startup. Registering the provider requires an instance of DaprC\", \"lient to invoke the secrets API on the Dapr sidecar. The other arguments include the name of the sec\", \"ret store and a DaprSecretDescriptor object with the name of the secret.\\n\\nOnce loaded, you can retri\", \"eve secrets directly from application code:\\n\\n```\\npublic void GetCustomer(IConfiguration config) { va\", \"r connectionString = config[\\\"eshopsecrets\\\"][\\\"customerdb\\\"]; }\\n```\\n\\n## Secret store components\\n\\nThe se\", \"crets management building block supports several secret store components. At the time of writing, th\", \"e following secret stores are available:\\n\\n- AlibabaCloud OOS Parameter Store\\n- AWS Secrets Manager\\n-\", \" AWS SSM Parameter Store\\n\\n- Azure Key Vault\\n- GCP Secret Manager\\n- HashiCorp Vault\\n- Kubernetes secr\", \"ets\\n- Local environment variables\\n- Local file\\n\\n## Important\\n\\nThe local environment variables and fi\", \"le components are designed for development workloads only.\\n\\nThe following sections show how to confi\", \"gure a secret store.\\n\\n## Configuration\\n\\nYou configure a secret store using a Dapr component configur\", \"ation file. The typical structure of the file is shown below:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind\", \": Component metadata: name: [ component name ] namespace: [ namespace ] spec: type: secretstores.[se\", \"cret store type] version: [ secret store version ] metadata: -name: [ property name ] value: [ prope\", \"rty value ]\\n```\\n\\nAll Dapr component configuration files require a name along with an optional namesp\", \"ace value. Additionally, the type field in the spec section specifies the type of secret store compo\", \"nent. The properties in the metadata section differ per secret store.\\n\\n## Indirectly consume Dapr se\", \"crets\\n\\nAs mentioned earlier in this chapter, applications can also consume secrets by referencing th\", \"em in component configuration files. Consider a state management component that uses Redis cache for\", \" storing state:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: eshop-basket-state\", \"store namespace: eshop spec: type: state.redis version: v1 metadata: -name: redisHost value: localho\", \"st:6379 -name: redisPassword value: e$h0p0nD@pr\\n```\\n\\nThe above configuration file contains a clear-t\", \"ext password for connecting to the Redis server. Hardcoded passwords are always a bad idea. Pushing \", \"this configuration file to a public repository would expose the password. Storing the password in a \", \"secret store would dramatically improve this scenario.\\n\\nThe following examples demonstrate this usin\", \"g several different secret stores.\\n\\n## Local file\\n\\nThe local file component is designed for developm\", \"ent scenarios. It stores secrets on the local filesystem inside a JSON file. Here's an example named\", \" eshop-secrets.json . It contains a single secret - a password for Redis:\\n\\n```\\n{ \\\"eShopRedisPassword\", \"\\\": \\\"e$h0p0nD@pr\\\" }\\n```\\n\\nYou place this file in a components folder that you specify when running the\", \" Dapr application.\\n\\nThe following secret store configuration file consumes the JSON file as a secret\", \" store. It's also placed in the components folder:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component\", \" metadata: name: eshop-local-secret-store namespace: eshop spec: type: secretstores.local.file versi\", \"on: v1 metadata: -name: secretsFile value: ./components/eshop-secrets.json -name: nestedSeparator va\", \"lue: \\\":\\\"\\n```\\n\\nThe component type is secretstore.local.file . The secretsFile metadata element specif\", \"ies the path to the secrets file.\\n\\n## Important\\n\\nThe path to a secrets file can be a absolute or rel\", \"ative path. The relative path is based on the folder in which the application starts. In the example\", \", the components folder is a sub-folder of the directory that contains the .NET application.\\n\\nFrom t\", \"he application folder, start the Dapr application specifying the components path as a commandline ar\", \"gument:\\n\\n```\\ndapr run --app-id basket-api --components-path ./components dotnet run\\n```\\n\\n## Note\\n\\nTh\", \"is above example applies to running Dapr in self-hosted mode. For Kubernetes hosting, consider using\", \" volume mounts.\\n\\nThe nestedSeparator in a Dapr configuration file specifies a character to flatten a\", \" JSON hierarchy. Consider the following snippet:\\n\\n```\\n{ \\\"redisPassword\\\": \\\"some password\\\", \\\"connectio\", \"nStrings\\\": { \\\"customerdb\\\": \\\"some connection string\\\", \\\"productdb\\\": \\\"some connection string\\\" } }\\n```\\n\\n\", \"Using a colon as a separator, you can retrieve the customerdb connection-string using the key connec\", \"tionStrings:customerdb .\\n\\nNote The colon : is the default separator value.\\n\\nIn the next example, a s\", \"tate management configuration file references the local secret store component to obtain the passwor\", \"d for connecting to the Redis server:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: na\", \"me: eshop-basket-statestore namespace: eshop spec: type: state.redis version: v1 metadata: -name: re\", \"disHost value: localhost:6379 -name: redisPassword secretKeyRef: name: eShopRedisPassword key: eShop\", \"RedisPassword auth: secretStore: eshop-local-secret-store\\n```\\n\\nThe secretKeyRef element references t\", \"he secret containing the password. It replaces the earlier cleartext value. The secret name and the \", \"key name, eShopRedisPassword , reference the secret. The name of the secret management component esh\", \"op-local-secret-store is found in the auth metadata element.\\n\\nYou might wonder why eShopRedisPasswor\", \"d is identical for both the name and key in the secret reference. In the local file secret store, se\", \"crets aren't identified with a separate name. The scenario will be different in the next example usi\", \"ng Kubernetes secrets.\\n\\n## Kubernetes secret\\n\\nThis second example focuses on a Dapr application runn\", \"ing in Kubernetes. It uses the standard secrets mechanism that Kubernetes offers. Use the Kubernetes\", \" CLI ( kubectl ) to create a secret named eshopredis-secret that contains the password:\\n\\nkubectl cre\", \"ate secret generic eshopsecrets --from-literal=redisPassword=e$h0p0nD@pr -n eshop\\n\\nOnce created, you\", \" can reference the secret in the component configuration file for state management:\\n\\n```\\napiVersion:\", \" dapr.io/v1alpha1 kind: Component metadata: name: eshop-basket-statestore namespace: eshop spec: typ\", \"e: state.redis version: v1 metadata: -name: redisHost value: redis:6379 -name: redisPassword secretK\", \"eyRef: name: eshopsecrets key: redisPassword auth: secretStore: kubernetes\\n```\\n\\nThe secretKeyRef ele\", \"ment specifies the name of the Kubernetes secret and the secret's key, eshopsecrets , and redisPassw\", \"ord respectively. The auth metadata section instructs Dapr to use the Kubernetes secrets management \", \"component.\\n\\n## Note\\n\\nAuth is the default value when using Kubernetes secrets and can be omitted.\\n\\nIn\", \" a production setting, secrets are typically created as part of an automated CI/CD pipeline. Doing s\", \"o ensures only people with sufficient permissions can access and change the secrets. Developers crea\", \"te configuration files without knowing the actual value of the secrets.\\n\\n## Azure Key Vault\\n\\nThe nex\", \"t example is geared toward a real-world production scenario. It uses Azure Key Vault as the secret s\", \"tore. Azure Key Vault is a managed Azure service that enables secrets to be stored securely in the c\", \"loud.\\n\\nFor this example to work, the following prerequisites must be satisfied:\\n\\n- You've secured ad\", \"ministrative access to an Azure subscription.\\n- You've provisioned an Azure Key Vault named eshopkv \", \"that holds a secret named redisPassword that contains the password for connecting to the Redis serve\", \"r.\\n- You've created service principal in Azure Active Directory.\\n\\n- You've installed an X509 certifi\", \"cate for this service principal ( containing both the public and private key) on the local filesyste\", \"m.\\n\\n## Note\\n\\nA service principal is an identity that can be used by an application to authenticate a\", \"n Azure service. The service principal uses a X509 certificate. The application uses this certificat\", \"e as a credential to authenticate itself.\\n\\nThe Dapr Azure Key Vault secret store documentation provi\", \"des step-by-step instructions to create and configure a Key Vault environment.\\n\\n## Use Key Vault whe\", \"n running in self-hosted mode\\n\\nUsing Azure Key Vault in Dapr self-hosted mode requires the following\", \" component configuration file:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: esh\", \"op-azurekv-secret-store namespace: eshop spec: type: secretstores.azure.keyvault version: v1 metadat\", \"a: -name: vaultName value: eshopkv -name: spnTenantId value: \\\"619926af-a7c3-4e95-93ed-4ecc4e3e652b\\\" \", \"-name: spnClientId value: \\\"6cf48032-6c38-43be-9d6f-2a43ce736b09\\\" -name: spnCertificateFile value : \\\"\", \"azurekv-spn-cert.pfx\\\"\\n```\\n\\nThe secret store type is secretstores.azure.keyvault . The metadata eleme\", \"nt provides access to the Key Vault with the following properties:\\n\\n- The vaultName contains the nam\", \"e of the Azure Key Vault.\\n- The spnTenantId contains the tenant ID of the service principal used to \", \"authenticate against the Key Vault.\\n- The spnClientId contains the app ID of the service principal u\", \"sed to authenticate against the Key Vault.\\n- The spnCertificateFile contains the path to the certifi\", \"cate file for the service principal to authenticate against the Key Vault.\\n\\n## Tip\\n\\nYou can copy the\", \" service principal information from the Azure portal or Azure CLI .\\n\\nNow the application can retriev\", \"e the Redis password from the Azure Key Vault.\\n\\n## Use Key Vault when running on Kubernetes\\n\\nConsumi\", \"ng Azure Key Vault with Dapr and Kubernetes also requires a service principal to authenticate agains\", \"t the Azure Key Vault.\\n\\nFirst, create a Kubernetes secret that contains a certificate file using the\", \" kubectl CLI tool:\\n\\n```\\nkubectl create secret generic [k8s_spn_secret_name] --fromfile=[pfx_certific\", \"ate_file_local_path] -n eshop\\n```\\n\\nThe command requires two command-line arguments:\\n\\n- [k8s\\\\_spn\\\\_se\", \"cret\\\\_name] is the secret name in Kubernetes secret store.\\n- [pfx\\\\_certificate\\\\_file\\\\_local\\\\_path] i\", \"s the path of X509 certificate file.\\n\\nOnce created, you can reference the Kubernetes secret in the s\", \"ecret store component configuration file:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata\", \": name: eshop-azurekv-secret-store namespace: eshop spec: type: secretstores.azure.keyvault version:\", \" v1 metadata: -name: vaultName value: [ your_keyvault_name ] -name: spnTenantId value: \\\"619926af-a7c\", \"3-4e95-93ed-4ecc4e3e652b\\\" -name: spnClientId value: \\\"6cf48032-6c38-43be-9d6f-2a43ce736b09\\\" -name: sp\", \"nCertificate secretKeyRef: name: [ k8s_spn_secret_name ] key: [ pfx_certificate_file_local_name ] au\", \"th: secretStore: kubernetes\\n```\\n\\nAt this point, an application running in Kubernetes can retrieve th\", \"e Redis password from the Azure Key Vault.\\n\\n## Important\\n\\nIt's critical to keep the X509 certificate\", \" file for the service principal in a safe place. It's best to place it in a well-known folder outsid\", \"e the source-code repository. The configuration file can then reference the certificate file from th\", \"is well-known folder. On a local development machine, you're responsible for copying the certificate\", \" to the folder. For automated deployments, the pipeline will copy the certificate to the machine whe\", \"re the application is deployed. It's a best practice to use a differen t service principal per envir\", \"onment. Doing so prevents the service principal from a DEVELOPMENT environment to access secrets in \", \"a PRODUCTION environment.\\n\\nWhen running in Azure Kubernetes Service (AKS), it's preferable to use an\", \" Azure Managed Identity for authenticating against Azure Key Vault. Managed identities are outside o\", \"f the scope of this book, but explained in the Azure Key Vault with managed identities documentation\", \".\\n\\n## Scope secrets\\n\\nSecret scopes allow you to control which secrets your application can access. Y\", \"ou configure scopes in a Dapr sidecar configuration file. The Dapr configuration documentation provi\", \"des instructions for scoping secrets.\\n\\nHere's an example of a Dapr sidecar configuration file that c\", \"ontains secret scopes:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Configuration metadata: name: dapr-co\", \"nfig namespace: eshop spec: tracing: samplingRate: \\\"1\\\" secrets: scopes: -storeName: eshop-azurekv-se\", \"cret-store defaultAccess: allow deniedSecrets: [ \\\"redisPassword\\\" , \\\"apiKey\\\" ]\\n```\\n\\nYou specify scope\", \"s per secret store. In the above example, the secret store is named eshop-azurekvsecret-store . You \", \"configure access to secrets using the following properties:\\n\\n| Property       | Value               \", \"| Description                                                                                       \", \"                              |\\n|----------------|---------------------|----------------------------\", \"----------------------------------------------------------------------------------------------------\", \"-|\\n| defaultAccess  | allow or deny       | Allows or denies access to all secrets in the specified \", \"secret store. This property is optional with a default value of allow . |\\n| allowedSecrets | List of\", \" secret keys | Secrets specified in the array will be accessible. This property is optional.        \", \"                                           |\\n| deniedSecrets  | List of secret keys | Secrets specif\", \"ied in the array will NOT be accessible. This property is optional.                                 \", \"              |\\n\\nThe allowedSecrets and deniedSecrets properties take precedence over the defaultAcc\", \"ess property. Imagine specifying defaultAccess: allowed and an allowedSecrets list. In this case, on\", \"ly the secrets in the allowedSecrets list would be accessible by the application.\\n\\n## Sample applica\", \"tion: Dapr Traffic Control\\n\\nIn Dapr Traffic Control sample app, the secrets management building bloc\", \"k is used in several places. Secrets are retrieved from code and referenced by Dapr component config\", \"uration files. Figure 10-2 shows the conceptual architecture of the Dapr Traffic Control sample appl\", \"ication. The Dapr secrets management building block is used in flows marked with number 6 in the dia\", \"gram:\\n\\nTrafficControl\\n\\nService\\n\\nFineCollection\\n\\nService\\n\\nVehicleRegistration\\n\\nService\\n\\n2\\n\\ndapr\\n\\nSide\", \"car\\n\\n5\\n\\nCamera\\n\\nSimulation\\n\\nFigure 10-2. Conceptual architecture of the Dapr Traffic Control sample \", \"application.\\n\\n<!-- image -->\\n\\nThe FineCollection service uses an SMTP output binding for sending ema\", \"ils (see the Bindings chapter). The email component file consumes the secrets management building bl\", \"ock to retrieve credentials to connect to the SMTP server. To calculate the fine for a speeding viol\", \"ation, the service uses a fictitious FineCalculator component that requires a license key. It retrie\", \"ves this license key from the secrets management building block.\\n\\nThe TrafficControl service stores \", \"vehicle information in a Redis state store (see the State management chapter). It uses the secrets m\", \"anagement building block for retrieving credentials to connect to the Redis server.\\n\\nBecause the Tra\", \"ffic Control sample application can run in self-hosted mode or in Kubernetes, there are two ways for\", \" specifying secrets:\\n\\n- A local JSON file\\n- A Kubernetes secret\\n\\n2 - 3 -\\n\\nEntryCam\\n\\n5\\n\\n5\\n\\n## Secrets\", \"\\n\\nExamine the secrets-file.yaml component configuration file in the dapr/components folder:\\n\\n```\\napi\", \"Version: dapr.io/v1alpha1 kind: Component metadata: name: trafficcontrol-secrets namespace: dapr-tra\", \"fficcontrol spec: type: secretstores.local.file version: v1 metadata: -name: secretsFile value: ../d\", \"apr/components/secrets.json -name: nestedSeparator value: \\\".\\\" scopes: -trafficcontrolservice -fineco\", \"llectionservice\\n```\\n\\nThe file describes a secrets management component entitled trafficcontrol-secre\", \"ts . The type element is set to local.file and the secretsFile to ../dapr/components/secrets.json . \", \"For selfhosted mode, use a Local file component. The path must be relatively specified from the fold\", \"er from which the service starts. The secrets file contains a JSON representation of the secrets:\\n\\n`\", \"``\\n{ \\\"state\\\":{ \\\"redisPassword\\\": \\\"\\\" }, \\\"smtp\\\":{ \\\"user\\\": \\\"_username\\\", \\\"password\\\": \\\"_password\\\" }, \\\"fine\", \"calculator\\\":{ \\\"licensekey\\\": \\\"HX783-K2L7V-CRJ4A-5PN1G\\\" } }\\n```\\n\\nIn the sample application the Redis s\", \"erver is used without a password. To connect to the SMTP server, the credentials are \\\\_username and \", \"\\\\_password . The license key for the FineCalculator license key is a randomly generated string.\\n\\nWhi\", \"le secrets are stored at nested levels, the secrets management building block flattens this hierarch\", \"y when the file is read. It uses a period as a level separator (as specified in the nestedSeparator \", \"field in the component configuration file). This construct enables you to reference secrets with a f\", \"lattened name, for example: smtp.user .\\n\\nWhen running in Kubernetes, the secrets are specified using\", \" the built-in Kubernetes secrets store. Examine the following secrets.yaml Kubernetes manifest file \", \"in the k8s folder:\\n\\n```\\napiVersion: v1 kind: Secret metadata: name: trafficcontrol-secrets namespace\", \": dapr-trafficcontrol\\n```\\n\\n```\\ntype: Opaque data: smtp.user: X3VzZXJuYW1l smtp.password: X3Bhc3N3b3J\", \"k finecalculator.licensekey: SFg3ODMtSzJMN1YtQ1JKNEEtNVBOMUc=\\n```\\n\\nThe component is also named traff\", \"iccontrol-secrets . Secrets are stored as Base64 encoded strings.\\n\\n## Important\\n\\nBase64 representati\", \"ons encode , but do not encrypt data. Base64 isn't secure for production scenarios.\\n\\nThe following p\", \"aragraphs describe how secrets are used in the Traffic Control sample application.\\n\\n## SMTP server c\", \"redentials\\n\\nExamine the email.yaml component configuration file located in the dapr/components folde\", \"r:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: sendmail namespace: dapr-traffi\", \"ccontrol spec: type: bindings.smtp version: v1 metadata: -name: host value: localhost -name: port va\", \"lue: 4025 -name: user secretKeyRef: name: smtp.user key: smtp.user -name: password secretKeyRef: nam\", \"e: smtp.password key: smtp.password -name: skipTLSVerify value: true auth: secretStore: trafficcontr\", \"ol-secrets scopes: -finecollectionservice\\n```\\n\\nThe auth section references the secrets management co\", \"mponent named trafficcontrol-secrets . The user and password entries in the binding metadata referen\", \"ce the secrets: smtp.user and smtp.password respectively.\\n\\nWhen running in Kubernetes, the built-in \", \"Kubernetes secrets store is used. The email.yaml manifest file found in the k8s folder references th\", \"e Kubernetes secret for retrieving the credentials for connecting to the smtp server:\\n\\n```\\napiVersio\", \"n: dapr.io/v1alpha1 kind: Component\\n```\\n\\n```\\nmetadata: name: sendmail namespace: dapr-trafficcontrol\", \" spec: type: bindings.smtp version: v1 metadata: -name: host value: mailserver -name: port value: 25\", \" -name: user secretKeyRef: name: trafficcontrol-secrets key: smtp.user -name: password secretKeyRef:\", \" name: trafficcontrol-secrets key: smtp.password -name: skipTLSVerify value: true scopes: -finecolle\", \"ctionservice\\n```\\n\\nUnlike the local secrets store, the Kubernetes store doesn't explicitly specify a \", \"secrets management component to use with the auth section. Instead, the default is the built-in Kube\", \"rnetes secrets store.\\n\\n## Redis server credentials\\n\\nNext, examine the statestore.yaml component conf\", \"iguration file in the dapr/components folder:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component meta\", \"data: name: statestore namespace: dapr-trafficcontrol spec: type: state.redis version: v1 metadata: \", \"-name: redisHost value: localhost:6379 -name: redisPassword secretKeyRef: name: state.redisPassword \", \"key: state.redisPassword -name: actorStateStore value: \\\"true\\\" auth: secretStore: trafficcontrol-secr\", \"ets scopes: -trafficcontrolservice\\n```\\n\\nOnce again, the auth section references the secrets manageme\", \"nt component named trafficcontrol-secrets . The redisPassword entries in the binding metadata refere\", \"nce the secret state.redisPassword .\\n\\n## FineCalculator component license key\\n\\nThe FineCollection se\", \"rvice uses a component that calculates the fine based on the information of a speeding violation. Th\", \"is component is implemented as a domain service and is abstracted by the IFineCalculator interface:\\n\", \"\\n```\\npublic interface IFineCalculator { public int CalculateFine(string licenseKey, int violationInK\", \"mh); }\\n```\\n\\nThe CalculateFine method expects a string containing a licenseKey as its first argument.\", \" This key unlocks the third-party component used by the implementation. To keep the example simple, \", \"the implementation hard-codes a series of if statements. You can find the implementation in the Hard\", \"CodedFineCalculator class in the DomainsServices folder:\\n\\n```\\npublic class HardCodedFineCalculator :\", \" IFineCalculator { public int CalculateFine(string licenseKey, int violationInKmh) { if (licenseKey \", \"!= \\\"HX783-K2L7V-CRJ4A-5PN1G\\\") { throw new InvalidOperationException(\\\"Invalid license-key specified.\\\"\", \"); } int fine = 9; // default administration fee if (violationInKmh < 5 ) { fine += 18; } else if (v\", \"iolationInKmh >= 5 && violationInKmh < 10 ) { fine += 31; } // ... else if (violationInKmh == 35) { \", \"fine += 372; } else { // violation above 35 KMh will be determined by the prosecutor return 0; } ret\", \"urn fine; } }\\n```\\n\\nThe implementation simulates a check on the licenseKey that is passed in. The Col\", \"lectionController of the FineCollection service must pass in the correct license key argument when c\", \"alling the CalculateFine method. It retrieves the license key from the Dapr secrets management build\", \"ing block that is exposed by the Dapr client in the Dapr SDK for .NET. If you examine the constructo\", \"r of the CollectionController , you can see the call:\\n\\n```\\n// set finecalculator component license-k\", \"ey if (_fineCalculatorLicenseKey == null ) { bool runningInK8s = Convert.ToBoolean(Environment.GetEn\", \"vironmentVariable(\\\"DOTNET_RUNNING_IN_CONTAINER\\\") ?? \\\"false\\\"); var metadata = new Dictionary<string, \", \"string> { { \\\"namespace\\\", \\\"dapr-trafficcontrol\\\" } }; if (runningInK8s) { var k8sSecrets = daprClient.\", \"GetSecretAsync( \\\"kubernetes\\\", \\\"trafficcontrol-secrets\\\", metadata).Result; _fineCalculatorLicenseKey \", \"= k8sSecrets[\\\"finecalculator.licensekey\\\"]; } else { var secrets = daprClient.GetSecretAsync( \\\"traffi\", \"ccontrol-secrets\\\", \\\"finecalculator.licensekey\\\", metadata).Result; _fineCalculatorLicenseKey = secret\", \"s[\\\"finecalculator.licensekey\\\"]; } }\\n```\\n\\nThe code determines whether the service is running in Kuber\", \"netes or self-hosted mode. This check is necessary because a different secrets management component \", \"must be used for each situation. The first argument of the GetSecretAsync method is the name of the \", \"Dapr component. The second argument is the name of the secret. The metadata passed in as the third a\", \"rgument specifies the namespace that contains the secret. The value of the finecalculator.licensekey\", \" secret is stored in a private field for later use.\\n\\nUsing Dapr secrets management offers several be\", \"nefits:\\n\\n1. No sensitive information is stored in code or application configuration files.\\n2. No nee\", \"d to learn any new API for interacting with a secrets store.\\n\\n## Summary\\n\\nThe Dapr secrets managemen\", \"t building block provides capabilities for storing and retrieving sensitive configuration settings l\", \"ike passwords and connection-strings. It keeps secrets private and prevents them from being accident\", \"ally disclosed.\\n\\nThe building block supports several different secret stores and hides their complex\", \"ity with the Dapr secrets API.\\n\\nThe Dapr .NET SDK provides a DaprClient object to retrieve secrets. \", \"It also includes a .NET configuration provider that adds secrets to the .NET configuration system. O\", \"nce loaded, you can consume these secrets in your .NET code.\\n\\nYou can use secret scopes to control a\", \"ccess to specific secrets.\\n\\n## References\\n\\n- Beyond the Twelve-Factor Application\\n\\n- Dapr supported \", \"secret stores\\n\\nMicrosoft\\n\\n.NET Microservices:\\n\\nArchitecture for\\n\\nContainerized NET\\n\\nApplications\\n\\n##\", \" Dapr reference application\\n\\nOver the co urse of this book, you've learned about the foundational be\", \"nefits of Dapr. You saw how Dapr can help you and your team construct distributed applications while\", \" reducing architectural and operational complexity. Along the way, you've had the opportunity to bui\", \"ld some small Dapr apps. Now, it's time to explore how a more complex application can benefit from D\", \"apr.\\n\\nBut, first a little history.\\n\\n## eShopOnContainers\\n\\nSeveral years ago, Microsoft, in partnersh\", \"ip with leading community experts, released a popular guidance book, entitled .NET Microservices for\", \" Containerized .NET Applications. Figure 12-1 shows the book:\\n\\nFigure 12-1. .NET Microservices: Arch\", \"itecture for Containerized .NET Applications.\\n\\n<!-- image -->\\n\\nThe book dove deep into the principle\", \"s, patterns, and best practices for building distributed applications. It included a full-featured m\", \"icroservice reference application that showcased the architectural concepts. Entitled, eShopOnContai\", \"ners, the application hosts an e-Commerce storefront that sells various items, including clothing an\", \"d coffee mugs. Built in .NET, the application is crossplatform and can run in either Linux or Window\", \"s containers. Figure 12-2 shows the original eShop architecture.\\n\\nClient apps eShop mobile app\\n\\nXama\", \"rin.Forms\\n\\nC#\\n\\nxPlat. OS:\\n\\niOS\\n\\nAndroid\\n\\nWindows eShop traditional Web app\\n\\nK\\n\\neShop SPA Web app\\n\\nTy\", \"peScript/Angular 2\\n\\nFigure 12-2. Original ShopOnContainers reference application.\\n\\n<!-- image -->\\n\\nA\", \"s you can see, eShopOnContainers includes many moving parts:\\n\\n1. Three different frontend clients.\\n2\", \". An application gateway to abstract backend services from the frontend.\\n3. Several backend core mic\", \"roservices.\\n4. An event bus component that enables asynchronous pub/sub messaging.\\n\\nThe eShopOnConta\", \"iners reference application has been widely accepted across the .NET community and used to model man\", \"y large commercial microservice applications.\\n\\n## eShopOnDapr\\n\\nAn updated version of eShop accompani\", \"es this book. It's called eShopOnDapr. The update evolves the earlier eShopOnContainers application \", \"by integrating Dapr building blocks. Figure 12-3 shows the new solution architecture:\\n\\n[eShopOnDapr \", \"reference application architecture](#g \\ufffd\\ufffd\\ufffd r&amp; \\ufffd &lt; \\ufffd\\ufffd p \\ufffd\\ufffd r \\ufffdm\\u0433z\\ufffd !c(* \\ufffd -\\u03ce\\ufffd 9 \\ufffd\\ufffd\\ufffd\\ufffd &gt;4)\\n\\nF\", \"igure 12-3. eShopOnDapr reference application architecture.\\n\\nWhile eShopOnDapr focuses on Dapr, the \", \"architecture has also been streamlined and simplified.\\n\\n1. A Single Page Application running on Blaz\", \"or WebAssembly sends user requests to an API gateway.\\n2. The API gateway abstracts the backend core \", \"microservices from the frontend client. It's implemented using Envoy, a high performant, open-source\", \" service proxy. Envoy routes incoming\\n\\neShopOnContainers reference application\\n\\n(Development environ\", \"ment architecture)\\n\\n-\\n\\n\\u2022 Docker Host\\n\\nIdentity microservice (STS+users)\\n\\nSQL Server database\\n\\nAPI Ga\", \"teways/BFF Catalog microservice SQL Server\\n\\nBlazor\\n\\nFrontend\\n\\nActors\\n\\nSecrets\\n\\n5\\n\\ndapr\\n\\n3\\n\\nBasket\\n\\n4\", \"\\n\\n3\\n\\n4\\n\\nrequests to backend microservices. Most requests are simple CRUD operations (for example, ge\", \"t the list of brands from the catalog) and handled by a direct call to a backend microservice.\\n\\n(Env\", \"oy)\\n\\n5\\n\\naggregator\\n\\n5\\n\\n3. Other requests are more logically complex and require multiple microservic\", \"e calls to work together. For these cases, eShopOnDapr implements an aggregator microservice that or\", \"chestrates a workflow across those microservices needed to complete the operation.\\n\\n3\\n\\n4. The core b\", \"ackend microservices implement the required functionality for an e-Commerce store. Each is self-cont\", \"ained and independent of the others. Following widely accepted domain decomposition patterns, each m\", \"icroservice isolates a specific business capability : 5\\n2. -The basket service manages the customer'\", \"s shopping basket experience.\\n3. -The catalog service manages product items available for sale.\\n4. -\", \"The identity service manages authentication and identity.\\n5. -The ordering service handles all aspec\", \"ts of placing and managing orders.\\n6. -The payment service transacts the customer's payment.\\n5. Adhe\", \"ring to best practices, each microservice maintains its own persistent storage. The application does\", \"n't share a single datastore.\\n6. Finally, the event bus wraps the Dapr publish/subscribe components.\", \" It enables asynchronous publish/subscribe messaging across microservices. Developers can plug in an\", \"y Dapr-supported message broker component.\\n\\n## Application of Dapr building blocks\\n\\nIn eShopOnDapr, \", \"Dapr building blocks replace a large amount of complex, error-prone plumbing code.\\n\\nFigure 12-4 show\", \"s the Dapr integration in the application.\\n\\nFigure 12-4. Dapr integration in eShopOnDapr.\\n\\n<!-- imag\", \"e -->\\n\\nThe above figure shows the Dapr building blocks (represented as green numbered boxes) that ea\", \"ch eShopOnDapr service consumes.\\n\\n1. The API gateway and web shopping aggregator services use the se\", \"rvice invocation building block to invoke methods on the backend services.\\n2. The backend services c\", \"ommunicate asynchronously using the publish &amp; subscribe building block.\\n3. The basket service us\", \"es the state management building block to store the state of the customer's shopping basket.\\n4. The \", \"original eShopOnContainers demonstrates DDD concepts and patterns in the ordering service. eShopOnDa\", \"pr uses the actor building block as an alternative implementation. The turnbased access model of act\", \"ors makes it easy to implement a stateful ordering process with support for cancellation.\\n5. The ord\", \"ering service sends order confirmation e-mails using the bindings building block.\\n6. Secret manageme\", \"nt is done by the secrets building block.\\n\\nThe following sections provide more detail on how the Dap\", \"r building blocks are applied in eShopOnDapr.\\n\\n## State management\\n\\nIn eShopOnDapr, the Basket servi\", \"ce uses the state management building block to persist the contents of the customer's shopping baske\", \"t. The original eShopOnCont ainers architecture used an IBasketRepository interface to read and writ\", \"e data for the basket service. The RedisBasketRepository class provided the implementation using Red\", \"is as the underlying data store. To compare and contrast, the original eShopOnContainers implementat\", \"ion is presented below:\\n\\n```\\npublic class RedisBasketRepository : IBasketRepository { private readon\", \"ly ConnectionMultiplexer _redis; private readonly IDatabase _database; public RedisBasketRepository(\", \"ConnectionMultiplexer redis) { _redis = redis; _database = redis.GetDatabase(); } public async Task<\", \"CustomerBasket> GetBasketAsync(string customerId) { var data = await _database.StringGetAsync(custom\", \"erId); if (data.IsNullOrEmpty) { return null ; } return JsonConvert.DeserializeObject<CustomerBasket\", \">(data); } // ... }\\n```\\n\\nThis code uses the third party StackExchange.Redis NuGet package. The follo\", \"wing steps are required to load the shopping basket for a given customer:\\n\\n1. Inject a Redis Connect\", \"ionMultiplexer into the constructor. The ConnectionMultiplexer is registered with the dependency inj\", \"ection framework in the Program.cs file:\\n1. Use the ConnectionMultiplexer to create an IDatabase ins\", \"tance in each consuming class.\\n2. Use the IDatabase instance to execute a Redis StringGet call using\", \" the given customerId as the key.\\n3. Check if data is loaded from Redis; if not, return null .\\n4. De\", \"serialize the data from Redis to a CustomerBasket object and return the result.\\n\\n```\\nservices.AddSin\", \"gleton<ConnectionMultiplexer>(sp => { var settings = spGetRequiredService<IOptions<BasketSettings>>(\", \").Value; var configuration = ConfigurationOptions.Parse(settingsConnectionString, true ); configurat\", \"ion.ResolveDns = true ; return ConnectionMultiplexer.Connect(configuration); });\\n```\\n\\nIn the updated\", \" eShopOnDapr reference application, a new DaprBasketRepository class replaces the RedisBasketReposit\", \"ory class:\\n\\n```\\npublic class DaprBasketRepository : IBasketRepository { private const string StoreNa\", \"me = \\\"eshop-statestore\\\"; private readonly DaprClient _daprClient; public DaprBasketRepository(DaprCl\", \"ient daprClient) { _daprClient = daprClient; } public Task<CustomerBasket> GetBasketAsync(string cus\", \"tomerId) => _daprClient.GetStateAsync<CustomerBasket>(StoreName, customerId); // ... }\\n```\\n\\nThe upda\", \"ted code uses the Dapr .NET SDK to read and write data using the state management building block. Th\", \"e new steps to load the basket for a customer are dramatically simplified:\\n\\n1. Inject a DaprClient i\", \"nto the constructor. The DaprClient is registered with the dependency injection framework in the Pro\", \"gram.cs `\\\\_ file.\\n2. Use the DaprClient.GetStateAsync method to load the customer's shopping basket \", \"items from the configured state store and return the result.\\n\\nThe updated implementation still uses \", \"Redis as the underlying data store. But, note how Dapr abstracts the StackExchange.Redis references \", \"and complexity from the application. The application no longer requires a direct dependency on Redis\", \". A Dapr configuration file is all that's needed:\\n\\nhttp\\n\\n<!-- image -->\\n\\nBasket\\n\\nThe Dapr implementa\", \"tion also simplifies changing the underlying data store. Switching to Azure Table Storage, for examp\", \"le, requires only changing the contents of the configuration file. No code changes are necessary.\\n\\n#\", \"# Service invocation\\n\\nThe original eShopOnContainers used a mix of HTTP/REST and gRPC services. The \", \"use of gRPC was limited to communication between an aggregator service and core backend services. Fi\", \"gure 12-5 shows the original architecture:\\n\\nFigure 12-5. gRPC and HTTP/REST calls in eShopOnContaine\", \"rs.\\n\\n<!-- image -->\\n\\nNote the steps from the previous figure:\\n\\n1. The frontend calls the API gateway\", \" using HTTP/REST.\\n\\nAPI Gateway\\n\\n(Envoy)\\n\\nhttp\\n\\nFrontend grpo\\n\\ndapr\\n\\nSidecar\\n\\n2. The API gateway forw\", \"ards simple CRUD (Create, Read, Update, Delete) requests directly to a core backend service using HT\", \"TP/REST. Sidecar Sidecar catalog\\n3. The API gateway forwards complex requests that involve coordinat\", \"ed backend service calls to the web shopping aggregator service. Sidecar - http \\u2192\\n4. The aggregator \", \"service uses gRPC to call core backend services.\\n\\nIn the updated eShopOnDapr implementation, Dapr si\", \"decars are added to the services and API gateway. Figure 12-6 show the updated architecture:\\n\\nFigure\", \" 12-6. Updated eShop architecture using Dapr.\\n\\n<!-- image -->\\n\\nNote the updated steps from the previ\", \"ous figure:\\n\\n1. The frontend still uses HTTP/REST to call the API gateway.\\n2. The API gateway forwar\", \"ds HTTP requests to its Dapr sidecar.\\n3. The API gateway sidecar sends the request to the sidecar of\", \" the aggregator or backend service.\\n4. The aggregator service uses the Dapr .NET SDK to call backend\", \" services through their sidecar architecture.\\n\\nDapr implements calls between sidecars with gRPC. So \", \"even if you're invoking a remote service with HTTP/REST semantics, a part of the transport is implem\", \"ented using gRPC.\\n\\nThe eShopOnDapr reference application benefits from the Dapr service invocation b\", \"uilding block. The benefits also include service discovery, automatic mTLS, and built-in observabili\", \"ty.\\n\\n## Forward HTTP requests using Envoy and Dapr\\n\\nBoth the original and updated eShop application \", \"leverage the Envoy proxy as an API gateway. Envoy is an open-source proxy and communication bus that\", \" is popular across modern distributed applications. Originating from Lyft, Envoy is owned and mainta\", \"ined by the Cloud-Native Computing Foundation.\\n\\nhttp\\u2192\\n\\nBasket\\n\\nIn the original eShopOnContainers imp\", \"lementation, the Envoy API gateway forwarded incoming HTTP requests directly to aggregator or backen\", \"d services. In the new eShopOnDapr, the Envoy proxy forwards the request to a Dapr sidecar.\\n\\nEnvoy i\", \"s configured using a YAML definition file to control the proxy's behavior. To enable Envoy to forwar\", \"d HTTP requests to a Dapr sidecar container, a dapr cluster is added to the configuration. The clust\", \"er configuration contains a host that points to the HTTP port on which the Dapr sidecar is listening\", \":\\n\\n```\\nclusters: -name: dapr connect_timeout: 0.25s type: strict_dns hosts: -socket_address: address\", \": 127.0.0.1 port_value: 3500\\n```\\n\\nThe Envoy route configuration is updated to rewrite incoming reque\", \"sts as calls to the Dapr sidecar (pay close attention to the prefix\\\\_rewrite key/value pair):\\n\\n```\\n-\", \"name: \\\"c-short\\\" match: prefix: \\\"/c/\\\" route: auto_host_rewrite: true prefix_rewrite: \\\"/v1.0/invoke/ca\", \"talog-api/method/\\\" cluster: dapr\\n```\\n\\nConsider a scenario where the frontend client wants to retriev\", \"e a list of catalog items. The Catalog API provides an endpoint for getting the catalog items:\\n\\n```\\n\", \"[Route(\\\"api/v1/[controller]\\\")] [ApiController] public class CatalogController : ControllerBase { [Ht\", \"tpGet(\\\"items/by_page\\\")] [ProducesResponseType( typeof (PaginatedItemsViewModel), (int)HttpStatusCode\", \".OK)] public async Task<PaginatedItemsViewModel> ItemsAsync( [FromQuery] int typeId = -1, [FromQuery\", \"] int brandId = -1, [FromQuery] int pageSize = 10, [FromQuery] int pageIndex = 0) { // ... }\\n```\\n\\nFi\", \"rst, the frontend makes a direct HTTP call to the Envoy API gateway.\\n\\n```\\nGET http://<api-gateway>/c\", \"/api/v1/catalog/items\\n```\\n\\nThe Envoy proxy matches the route, rewrites the HTTP request, and forward\", \"s it to the invoke API of its Dapr sidecar:\\n\\n```\\nGET http://127.0.0.1:3500/v1.0/invoke/catalog-api/m\", \"ethod/api/v1/catalog/items\\n```\\n\\nFrontend update basket\\n\\nAPI gateway\\n\\nWeb shopping update basket\\n\\nThe\", \" sidecar handles service discovery and routes the request to the Catalog API sidecar. Finally, the s\", \"idecar calls the Catalog API to execute the request, fetch catalog items, and return a response:\\n\\nGE\", \"T http://localhost/api/v1/catalog/items save basket\\n\\n## Make aggregated service calls using the .NET\", \" SDK\\n\\nMost calls from the eShop frontend are simple CRUD calls. The API gateway forwards them to a s\", \"ingle service for processing. Some scenarios, however, require multiple backend services to work tog\", \"ether to complete a request. For the more complex calls, the web shopping aggregator service mediate\", \"s the cross service workflow. Figure 12-7 show the processing sequence of adding an item to your sho\", \"pping basket:\\n\\nFigure 12-7. Backend call requiring multiple services.\\n\\n<!-- image -->\\n\\nThe aggregato\", \"r service first retrieves catalog items from the Catalog API. It then validates item availability an\", \"d pricing. Finally, the aggregator service updates the shopping basket by calling the Basket API.\\n\\nT\", \"he aggregator service contains a BasketController that provides an endpoint for updating the shoppin\", \"g basket:\\n\\n```\\n[Route(\\\"api/v1/[controller]\\\")] [Authorize] [ApiController] public class BasketControl\", \"ler : ControllerBase { private readonly ICatalogService _catalog; private readonly IBasketService _b\", \"asket; [HttpPost] [HttpPut] [ProducesResponseType((int)HttpStatusCode.BadRequest)] [ProducesResponse\", \"Type( typeof (BasketData), (int)HttpStatusCode.OK)] public async Task<ActionResult<BasketData>> Upda\", \"teAllBasketAsync( [FromBody] UpdateBasketRequest data, [FromHeader] string authorization) { BasketDa\", \"ta basket;\\n```\\n\\naggregator\\n\\nCatalog API\\n\\nBasket API\\n\\n```\\nif (data.Items is null || !data.Items.Any()\", \") { basket = new (); } else { // Get the item details from the catalog API. var catalogItems = await\", \" _catalog.GetCatalogItemsAsync( data.Items.Select(x => x.ProductId)); if (catalogItems == null ) { r\", \"eturn BadRequest( \\\"Catalog items were not available for the specified items in the basket.\\\"); } // C\", \"heck item availability and prices; store results in basket object. basket = CreateValidatedBasket(da\", \"ta.Items, catalogItems); } // Save the updated shopping basket. await _basket.UpdateAsync(basket, au\", \"thorization.Substring(\\\"Bearer \\\".Length)); return basket; } // ... }\\n```\\n\\nThe UpdateAllBasketAsync me\", \"thod gets the Authorization header of the incoming request using a FromHeader attribute. The Authori\", \"zation header contains the access token that is needed to call protected backend services.\\n\\nAfter re\", \"ceiving a request to update the basket, the aggregator service calls the Catalog API to get the item\", \" details. The Basket controller uses an injected ICatalogService object to make that call and commun\", \"icate with the Catalog API. The original implementation of the interface used gRPC to make the call.\", \" The updated implementation uses Dapr service invocation with HttpClient support:\\n\\n```\\npublic class \", \"CatalogService : ICatalogService { private readonly HttpClient _httpClient; public CatalogService(Ht\", \"tpClient httpClient) { _httpClient = httpClient; } public Task<IEnumerable<CatalogItem>> GetCatalogI\", \"temsAsync(IEnumerable<int> ids) { var requestUri = $\\\"api/v1/catalog/items/by_ids?ids={string.Join(\\\",\", \"\\\", ids)}\\\"; return _httpClient.GetFromJsonAsync<IEnumerable<CatalogItem>>(requestUri); } // ... }\\n```\", \"\\n\\nNotice how no Dapr-specific code is required to make the service invocation call. All communicatio\", \"n is done using the standard HttpClient object.\\n\\nThe Dapr HttpClient is configured for the CatalogSe\", \"rvice class on program startup:\\n\\n```\\nbuilder.Services.AddSingleton<ICatalogService, CatalogService>(\", \" _ => new CatalogService(DaprClient.CreateInvokeHttpClient(\\\"catalog-api\\\")));\\n```\\n\\nThe other call mad\", \"e by the aggregator service is to the Basket API. It only allows authorized requests. The access tok\", \"en is passed along in an Authorization request header to ensure the call succeeds:\\n\\n```\\npublic class\", \" BasketService : IBasketService { public Task UpdateAsync(BasketData currentBasket, string accessTok\", \"en) { var request = new HttpRequestMessage(HttpMethod.Post, \\\"api/v1/basket\\\") { Content = JsonContent\", \".Create(currentBasket) }; request.Headers.Authorization = new AuthenticationHeaderValue(\\\"Bearer\\\", ac\", \"cessToken); var response = await _httpClient.SendAsync(request); response.EnsureSuccessStatusCode();\", \" } // ... }\\n```\\n\\nIn this example too, only standard HttpClient functionality is used to call the ser\", \"vice. This allows developers who are already familiar with HttpClient to reuse their existing skills\", \". It even enables existing HttpClient code to use Dapr service invocation without making any changes\", \".\\n\\n## Publish &amp; subscribe\\n\\nBoth eShopOnContainers and eShopOnDapr use the pub/sub pattern for co\", \"mmunicating integration events across microservices. Integration events include:\\n\\n- When a user chec\", \"ks-out a shopping basket.\\n- When a payment for an order has succeeded.\\n- When the grace-period of a \", \"purchase has expired.\\n\\nNote Think of an Integration Event as an event that takes place across multip\", \"le services.\\n\\nEventing in eShopOnContainers is based on the following IEventBus interface:\\n\\n```\\npubl\", \"ic interface IEventBus { void Publish(IntegrationEvent integrationEvent); void Subscribe<T, THandler\", \">() where TEvent : IntegrationEvent where THandler : IIntegrationEventHandler<T>; }\\n```\\n\\nConcrete im\", \"plementations of this interface for both RabbitMQ and Azure Service Bus are found in eShopOnContaine\", \"rs. Each implementation included a large amount of custom plumbing code that was complex to understa\", \"nd and difficult to maintain.\\n\\nThe newer eShopOnDapr significantly simplifies pub/sub behavior by us\", \"ing Dapr. To start, the IEventBus interface was reduced to a single method:\\n\\n```\\npublic interface IE\", \"ventBus { Task PublishAsync(IntegrationEvent integrationEvent); }\\n```\\n\\n## Publish events\\n\\nIn eShopOn\", \"Dapr, a single DaprEventBus implementation can support any Dapr-supported message broker. The follow\", \"ing code block shows the simplified Publish method. Note how the PublishAsync method uses the Dapr c\", \"lient to publish an event:\\n\\n```\\npublic class DaprEventBus : IEventBus { private const string DAPR_PU\", \"BSUB_NAME = \\\"pubsub\\\"; private readonly DaprClient _dapr; private readonly ILogger _logger; public Da\", \"prEventBus(DaprClient dapr, ILogger<DaprEventBus> logger) { _dapr = dapr; _logger = logger; } public\", \" async Task PublishAsync(IntegrationEvent integrationEvent) { var topicName = integrationEvent.GetTy\", \"pe().Name; _logger.LogInformation( \\\"Publishing event {@Event} to {PubsubName}.{TopicName}\\\", integrat\", \"ionEvent, DAPR_PUBSUB_NAME, topicName); // We need to make sure that we pass the concrete type to Pu\", \"blishEventAsync, // which can be accomplished by casting the event to dynamic. This ensures // that \", \"all event fields are properly serialized. await _dapr.PublishEventAsync(DAPR_PUBSUB_NAME, topicName,\", \" (object)integrationEvent); } }\\n```\\n\\nAs you can see in the code snippet, the topic name is derived f\", \"rom event type's name. Because all eShop services use the IEventBus abstraction, retrofitting Dapr r\", \"equired absolutely no change to the mainline application code.\\n\\n## Important\\n\\nThe Dapr SDK uses Syst\", \"em.Text.Json to serialize/deserialize messages. However, System.Text.Json doesn't serialize properti\", \"es of derived classes by default. In the eShop code, an event is sometimes explicitly declared as an\", \" IntegrationEvent , the base class for integration events. This construct allows the concrete event \", \"type to be determined dynamically at run time based on business logic. As a result, the event is ser\", \"ialized using the type information of the base class and not the derived class. To force System.Text\", \".Json to serialize the properties of both the base and derived class, the code uses object as the ge\", \"neric type parameter. For more information, see the .NET documentation.\\n\\nWith Dapr, pub/sub infrastr\", \"ucture code is dramatically simplified . The application doesn't need to distinguish between message\", \" brokers. Dapr provides this abstraction for you. If needed, you can easily swap out message brokers\", \" or configure multiple message broker components with no code changes.\\n\\n## Subscribe to events\\n\\nThe \", \"earlier eShopOnContainers app contains SubscriptionManagers to handle the subscription implementatio\", \"n for each message broker. Each manager contains complex message broker-specific code for handling s\", \"ubscription events. To receive events, each service has to explicitly register a handler for each ev\", \"ent-type.\\n\\neShopOnDapr streamlines the plumbing for event subscriptions by using Dapr ASP.NET Core i\", \"ntegration. Each event is handled by an action method in a controller. A Topic attribute decorates t\", \"he action method with the name of the corresponding topic. Here's a code snippet taken from the Paym\", \"entService :\\n\\n```\\n[Route(\\\"api/v1/[controller]\\\")] [ApiController] public class IntegrationEventContro\", \"ller : ControllerBase { private const string DAPR_PUBSUB_NAME = \\\"pubsub\\\"; [HttpPost(\\\"OrderStatusChan\", \"gedToValidated\\\")] [Topic(DAPR_PUBSUB_NAME, nameof(OrderStatusChangedToValidatedIntegrationEvent))] p\", \"ublic Task HandleAsync( OrderStatusChangedToValidatedIntegrationEvent integrationEvent, [FromService\", \"s] OrderStatusChangedToValidatedIntegrationEventHandler handler) => handler.Handle(integrationEvent)\", \"; }\\n```\\n\\nIn the Topic attribute, the name of the .NET type of the event is used as the topic name. F\", \"or handling the event, an event handler that already existed in the earlier eShopOnContainers code b\", \"ase is resolved using dependency injection and invoked. In the previous example, messages received f\", \"rom the OrderStatusChangedToValidatedIntegrationEvent topic invoke the existing OrderStatusChangedTo\", \"ValidatedIntegrationEventHandler event handler. Because Dapr implements the underlying plumbing for \", \"subscriptions and message brokers, a large amount of original code became obsolete and was removed f\", \"rom the code-base. Much of this code was complex to understand and challenging to maintain.\\n\\n## Use \", \"pub/sub components\\n\\nWithin the eShopOnDapr repository, a deployment folder contains files for deploy\", \"ing the application using different deployment modes: Docker Compose and Kubernetes . A dapr folder \", \"exists within each of these folders that holds a components folder. This folder holds a file eshop-p\", \"ubsub.yaml . It specifies the Dapr pub/sub component that the application will use for pub/sub behav\", \"ior. As you saw in the earlier code snippets, the name of the pub/sub component used is pubsub . Her\", \"e's the content of the eshop-pubsub.yaml file in the deployment/compose/dapr/components folder:\\n\\n```\", \"\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: pubsub namespace: eshop spec: type: pu\", \"bsub.rabbitmq version: v1 metadata: -name: host value: \\\"amqp://rabbitmq:5672\\\"\\n```\\n\\nThe configuration\", \" specifies RabbitMQ as the underlying infrastructure. To change message brokers, you need only to co\", \"nfigure a different message broker, such as NATS or Azure Service Bus and update the yaml file. With\", \" Dapr, there are no changes to your mainline service code when switching message brokers.\\n\\nYou can a\", \"lso easily use multiple message brokers in a single application. Many times a system will handle wor\", \"kloads with different characteristics. One event may occur 10 times a day, but another event occurs \", \"5,000 times per second. You may benefit by partitioning messaging traffic to different message broke\", \"rs. With Dapr, you can add multiple pub/sub component configurations, each with a different name.\\n\\n#\", \"# Bindings\\n\\neShopOnDapr uses the bindings building block for sending e-mails. When a user places an \", \"order, the application sends an order confirmation e-mail using the SMTP output binding. You can fin\", \"d this binding in the eshop-email.yaml file in the components folder:\\n\\n```\\napiVersion: dapr.io/v1alp\", \"ha1 kind: Component metadata: name: sendmail namespace: eshop spec: type: bindings.smtp version: v1 \", \"metadata: -name: host value: maildev -name: port value: 25 -name: user secretKeyRef: name: Smtp.User\", \"\\n```\\n\\n```\\nkey: Smtp.User -name: password secretKeyRef: name: Smtp.Password key: Smtp.Password -name:\", \" skipTLSVerify value: true auth: secretStore: eshop-secretstore scopes: -ordering-api\\n```\\n\\nDapr gets\", \" the username and password for connecting to the SMTP server from a secret reference. This approach \", \"keeps secrets outside of the configuration file. To learn more about Dapr secrets, read the secrets \", \"building block chapter.\\n\\nThe binding configuration specifies a binding component that can be invoked\", \" using the /sendmail endpoint on the Dapr sidecar. Here's a code snippet in which an email is sent w\", \"henever an order is started:\\n\\n```\\npublic Task Handle(OrderStartedDomainEvent notification, Cancellat\", \"ionToken cancellationToken) { var message = CreateEmailBody(notification); var metadata = new Dictio\", \"nary<string, string> { [\\\"emailFrom\\\"] = \\\"eShopOn@dapr.io\\\", [\\\"emailTo\\\" = notification.UserName, [\\\"subj\", \"ect\\\"] = $\\\"Your eShopOnDapr order #{notification.Order.Id}\\\" }; return _daprClient.InvokeBindingAsync(\", \"\\\"sendmail\\\", \\\"create\\\", message, metadata, cancellationToken); } public Task SendOrderConfirmationAsyn\", \"c(Order order) { var message = CreateEmailBody(order); return _daprClient.InvokeBindingAsync( \\\"sendm\", \"ail\\\", \\\"create\\\", CreateEmailBody(order), new Dictionary<string, string> { [\\\"emailFrom\\\"] = \\\"eshopondap\", \"r@example.com\\\", [\\\"emailTo\\\"] = order.BuyerEmail, [\\\"subject\\\"] = $\\\"Your eShopOnDapr Order #{order.Order\", \"Number}\\\" }); }\\n```\\n\\nAs you can see in this example, message contains the message body. The CreateEma\", \"ilBody method simply formats a string with the body text. The name of the binding to invoke is sendm\", \"ail and the operation is create . The metadata specifies the email sender, recipient, and subject fo\", \"r the email message. If these values are static, they can also be included in the metadata fields in\", \" the configuration file.\\n\\n## Actors\\n\\nIn the original eShopOnContainers solution, the Ordering servic\", \"e provides a great example of how to use DDD design patterns in a .NET microservice. As the updated \", \"eShopOnDapr focuses on Dapr, the Ordering service now uses the actors building block to implement it\", \"s business logic.\\n\\nThe ordering process consists of the following steps:\\n\\n1. The customer submits th\", \"e order. There's a grace period before any further processing occurs. During the grace period, the c\", \"ustomer can cancel the order.\\n2. The system checks that there's available stock.\\n3. The system proce\", \"sses the payment.\\n4. The system ships the order.\\n\\nThe process is implemented using a single Ordering\", \"ProcessActor actor type. Here's the interface for the actor:\\n\\n```\\npublic interface IOrderingProcessA\", \"ctor : IActor { Task SubmitAsync( string userId, string userName, string street, string city, string\", \" zipCode, string state, string country, CustomerBasket basket); Task NotifyStockConfirmedAsync(); Ta\", \"sk NotifyStockRejectedAsync(List<int> rejectedProductIds); Task NotifyPaymentSucceededAsync(); Task \", \"NotifyPaymentFailedAsync(); Task<bool> CancelAsync(); Task<bool> ShipAsync(); Task<Order> GetOrderDe\", \"tailsAsync(); }\\n```\\n\\nThe process is started when a customer checks out some products. Upon checkout,\", \" the Basket service publishes a UserCheckoutAcceptedIntegrationEvent message using the Dapr pub/sub \", \"building block. The Ordering service handles the message in the OrderingProcessEventController class\", \" and calls the SubmitAsync method of the actor:\\n\\n```\\n[HttpPost(\\\"UserCheckoutAccepted\\\")] [Topic(DaprP\", \"ubSubName, \\\"UserCheckoutAcceptedIntegrationEvent\\\")] public async Task HandleAsync(UserCheckoutAccept\", \"edIntegrationEvent integrationEvent) { if (integrationEvent.RequestId != Guid.Empty) { var actorId =\", \" new ActorId(integrationEvent.RequestId.ToString()); var orderingProcess = _actorProxyFactory.Create\", \"ActorProxy<IOrderingProcessActor>( actorId, nameof(OrderingProcessActor)); await orderingProcess.Sub\", \"mitAsync(integrationEvent.UserId, integrationEvent.UserName,\\n```\\n\\n```\\nintegrationEvent.Street, integ\", \"rationEvent.City, integrationEvent.ZipCode, integrationEvent.State, integrationEvent.Country, integr\", \"ationEvent.Basket); } else { _logger.LogWarning( \\\"Invalid IntegrationEvent - RequestId is missing - \", \"{@IntegrationEvent}\\\", integrationEvent); } }\\n```\\n\\nIn the example above, the Ordering service first u\", \"ses the original request ID from the UserCheckoutAcceptedIntegrationEvent message as the actor ID. T\", \"he handler uses the ActorId to create an actor proxy and invokes the SubmitAsync method. The followi\", \"ng snippet shows the implementation of the SubmitAsync method:\\n\\n```\\npublic async Task SubmitAsync( s\", \"tring buyerId, string buyerEmail, string street, string city, string state, string country, Customer\", \"Basket basket) { var orderState = new OrderState { OrderDate = DateTime.UtcNow, OrderStatus = OrderS\", \"tatus.Submitted, Description = \\\"Submitted\\\", Address = new OrderAddressState { Street = street, City \", \"= city, State = state, Country = country }, BuyerId = buyerId, BuyerEmail = buyerEmail, OrderItems =\", \" basket.Items .Select(item => new OrderItemState { ProductId = item.ProductId, ProductName = item.Pr\", \"oductName, UnitPrice = item.UnitPrice, Units = item.Quantity, PictureFileName = item.PictureFileName\", \" }) .ToList() }; await StateManager.SetStateAsync(OrderDetailsStateName, orderState); await StateMan\", \"ager.SetStateAsync(OrderStatusStateName, OrderStatus.Submitted); await RegisterReminderAsync( GraceP\", \"eriodElapsedReminder, null , TimeSpan.FromSeconds(_settings.Value.GracePeriodTime), TimeSpan.FromMil\", \"liseconds(-1));\\n```\\n\\n```\\nawait _eventBus.PublishAsync( new OrderStatusChangedToSubmittedIntegrationE\", \"vent( OrderId, OrderStatus.Submitted.Name, buyerId, buyerEmail)); }\\n```\\n\\nThere's a lot going on in t\", \"he Submit method:\\n\\n1. The method takes the given arguments to create an OrderState object and saves \", \"it in the actor state.\\n2. The method saves the current status of the process ( OrderStatus.Submitted\", \" ) in the actor state.\\n3. The method registers a reminder to signal the end of the grace period. Ord\", \"er processing is delayed until the end of the grace period to deal with customers changing their min\", \"d.\\n4. Lastly, the method publishes an OrderStatusChangedToSubmittedIntegrationEvent to notify other \", \"services of the status change.\\n\\nWhen the reminder for the grace period ending fires, the actor runti\", \"me calls the ReceiveReminderAsync method:\\n\\n```\\npublic Task ReceiveReminderAsync( string reminderName\", \", byte[] state, TimeSpan dueTime, TimeSpan period) { return reminderName switch { GracePeriodElapsed\", \"Reminder => OnGracePeriodElapsedAsync(), StockConfirmedReminder => OnStockConfirmedSimulatedWorkDone\", \"Async(), StockRejectedReminder => OnStockRejectedSimulatedWorkDoneAsync( JsonConvert.DeserializeObje\", \"ct<List<int>>(Encoding.UTF8.GetString(state))), PaymentSucceededReminder => OnPaymentSucceededSimula\", \"tedWorkDoneAsync(), PaymentFailedReminder => OnPaymentFailedSimulatedWorkDoneAsync(), _ => Task.Comp\", \"letedTask }; }\\n```\\n\\nAs shown in the snippet above, the ReceiveReminderAsync method handles not just \", \"the grace period reminder. The actor also uses reminders to simulate background work and introduce s\", \"ome delays in the ordering process. This makes the process easier to follow in the eShopOnDapr UI wh\", \"ere notifications are shown for each status update. The ReceiveReminderAsync method uses the reminde\", \"r name to determine which method handles the reminder. The grace period reminder is handled by the O\", \"nGracePeriodElapsedAsync method:\\n\\n```\\npublic async Task OnGracePeriodElapsedAsync() { var statusChan\", \"ged = await TryUpdateOrderStatusAsync( OrderStatus.Submitted, OrderStatus.AwaitingStockValidation); \", \"if (statusChanged) { var order = await StateManager.GetStateAsync<Order>(OrderDetailsStateName); awa\", \"it _eventBus.PublishAsync( new OrderStatusChangedToAwaitingStockValidationIntegrationEvent( OrderId,\", \" OrderStatus.AwaitingStockValidation.Name, \\\"Grace period elapsed; waiting for stock validation.\\\",\\n``\", \"`\\n\\n```\\norder.UserName, order.OrderItems .Select(orderItem => new OrderStockItem(orderItem.ProductId,\", \" orderItem.Units)))); } }\\n```\\n\\nThe OnGracePeriodElapsedAsync method first tries to update the order \", \"status to the new AwaitingStockValidation status. If that succeeds, it retrieves the order details f\", \"rom state and publishes an OrderStatusChangedToAwaitingStockValidationIntegrationEvent to inform oth\", \"er service of the status change. For example, the Category service subscribes to this event to check\", \" the available stock.\\n\\nLet's look at the TryUpdateOrderStatusAsync method to see under which circums\", \"tances it may fail to update the order status:\\n\\n```\\nprivate async Task<bool> TryUpdateOrderStatusAsy\", \"nc(OrderStatus expectedOrderStatus, OrderStatus newOrderStatus) { var orderStatus = await StateManag\", \"er.TryGetStateAsync<OrderStatus>(OrderStatusStateName); if (!orderStatus.HasValue) { _logger.LogWarn\", \"ing( \\\"Order with Id: {OrderId} cannot be updated because it doesn't exist\\\", OrderId); return false ;\", \" } if (orderStatus.Value.Id != expectedOrderStatus.Id) { _logger.LogWarning( \\\"Order with Id: {OrderI\", \"d} is in status {Status} instead of expected status {ExpectedStatus}\\\", OrderId, orderStatus.Value.Na\", \"me, expectedOrderStatus.Name); return false ; } await StateManager.SetStateAsync(OrderStatusStateNam\", \"e, newOrderStatus); return true ; }\\n```\\n\\nFirst, the TryUpdateOrderStatusAsync method checks whether \", \"there even is a current order status. If there isn't, the order doesn't exist. This is a fail -safe \", \"that should not happen with normal application usage. Then, the method checks whether the current or\", \"der status is the status that we expected. Remember that the ordering process is driven by events us\", \"ing the Dapr pub/sub building block. Event delivery uses at-least-once semantics, so a single messag\", \"e could be received multiple times. The order status check ensures that even when the same message i\", \"s received multiple times, it is only processed once.\\n\\nThe other steps in the ordering process are a\", \"ll implemented in a very similar way to the grace period step. In the next sections, we'll look at s\", \"ome other aspects of the ordering process, namely cancellation and viewing order details.\\n\\n## Order \", \"cancellation\\n\\nCustomers are allowed to cancel any order that has not been paid or shipped yet. The O\", \"rdersController class handles incoming order cancellations. It invokes the CancelAsync method on the\", \" OrderingProcessActor instance for the given order.\\n\\n```\\npublic async Task<bool> CancelAsync() { var\", \" orderStatus = await StateManager.TryGetStateAsync<OrderStatus>(OrderStatusStateName); if (!orderSta\", \"tus.HasValue) { _logger.LogWarning( \\\"Order with Id: {OrderId} cannot be cancelled because it doesn't\", \" exist\\\", OrderId); return false ; } if (orderStatus.Value.Id == OrderStatus.Paid.Id || orderStatus.V\", \"alue.Id == OrderStatus.Shipped.Id) { _logger.LogWarning( \\\"Order with Id: {OrderId} cannot be cancell\", \"ed because it's in status {Status}\\\", OrderId, orderStatus.Value.Name); return false ; } await StateM\", \"anager.SetStateAsync(OrderStatusStateName, OrderStatus.Cancelled); var order = await StateManager.Ge\", \"tStateAsync<Order>(OrderDetailsStateName); await _eventBus.PublishAsync( new OrderStatusChangedToCan\", \"celledIntegrationEvent( OrderId, OrderStatus.Cancelled.Name, $\\\"The order was cancelled by buyer.\\\", o\", \"rder.UserName)); return true ; }\\n```\\n\\nThe CancelAsync method consists of the following steps:\\n\\n1. Fi\", \"rst, the method ensures that the order exists by retrieving the current order status.\\n2. If the orde\", \"r exists, the method checks wheth er it's eligible for cancellation. Any order not in the Paid or Sh\", \"ipped state can be cancelled.\\n3. If the order can be cancelled, the order status is changed to Cance\", \"lled .\\n4. Lastly, the order details are retrieved from state and used to publish an OrderStatusChang\", \"edToCancelledIntegrationEvent to inform the other services.\\n\\nThe CancelAsync method is a great examp\", \"le of the usefulness of the turn-based access model of actors. Nowhere in the method do we need to w\", \"orry about multiple threads running at the same time. Therefore, the method does not require any exp\", \"licit locking mechanisms to be correct.\\n\\n## Order details\\n\\nCustomers can check the status and detail\", \"s of their order in the eShopOnDapr UI. They can also view a complete history of past orders. Direct\", \"ly querying actor instances for this information is a bad idea because of two reasons:\\n\\n1. Low-laten\", \"cy reads cannot be guaranteed because actor operations execute serially.\\n2. Querying across actors i\", \"s inefficient because each actor's state needs to be read individually and can introduce more unpred\", \"ictable latencies.\\n\\nTo fix this issue, eShopOnDapr uses a separate read model for any queries on ord\", \"er data. The read model is stored in a separate SQL database. An ASP.NET Core controller class named\", \" UpdateOrderStatusEventController subscribes to the order status events and builds up the view model\", \". The same UpdateOrderStatusEventController class also sends push notifications to the UI to inform \", \"the customer of order status updates.\\n\\nThe following snippet shows the code for handling the OrderSt\", \"atusChangedToSubmittedIntegrationEvent message:\\n\\n```\\n[HttpPost(\\\"OrderStatusChangedToSubmitted\\\")] [To\", \"pic(DaprPubSubName, nameof(OrderStatusChangedToSubmittedIntegrationEvent))] public async Task Handle\", \"Async( OrderStatusChangedToSubmittedIntegrationEvent integrationEvent, [FromServices] IOptions<Order\", \"ingSettings> settings, [FromServices] IEmailService emailService) { // Gets the order details from A\", \"ctor state. var actorId = new ActorId(integrationEvent.OrderId.ToString()); var orderingProcess = _a\", \"ctorProxyFactory.CreateActorProxy<IOrderingProcessActor>( actorId, nameof(OrderingProcessActor)); //\", \" var actorOrder = await orderingProcess.GetOrderDetailsAsync(); var readModelOrder = new Order(integ\", \"rationEvent.OrderId, actorOrder); // Add the order to the read model so it can be queried from the A\", \"PI. // It may already exist if this event has been handled before (at-least-once semantics). readMod\", \"elOrder = await _orderRepository.AddOrGetOrderAsync(readModelOrder); // Send a SignalR notification \", \"to the client. await SendNotificationAsync(readModelOrder.OrderNumber, integrationEvent.OrderStatus,\", \" integrationEvent.BuyerId); // Send a confirmation e-mail if enabled. if (settings.Value.SendConfirm\", \"ationEmail) { await emailService.SendOrderConfirmationAsync(readModelOrder); } }\\n```\\n\\nThe handler co\", \"ntains the code for all the actions that must occur after an order is submitted successfully. Becaus\", \"e the events originate from the OrderingProcessActor , we can be sure that any validations performed\", \" by the actor have succeeded.\\n\\nThe handler performs the following steps:\\n\\n1. First, the method creat\", \"es an actor proxy and uses it to retrieve the order details from the actor instance.\\n2. The method m\", \"aps the order details to the read model and stores it in the database. Due to the at-least-once sema\", \"ntics of the Dapr pub/sub building block, the order may already exist in the database. In that case,\", \" it will not be overwritten.\\n3. The method publishes a push notification for the status update using\", \" SignalR.\\n4. Lastly, if enabled, the method sends a confirmation e-mail to the customer.\\n\\nSubsequent\", \" order status updates are all handled equally to each other. The following snippet shows what happen\", \"s when the order status is updated to AwaitingStockValidation :\\n\\n```\\n[HttpPost(\\\"OrderStatusChangedTo\", \"AwaitingStockValidation\\\")] [Topic(DaprPubSubName, nameof(OrderStatusChangedToAwaitingStockValidation\", \"IntegrationEvent))] public Task HandleAsync( OrderStatusChangedToAwaitingStockValidationIntegrationE\", \"vent integrationEvent) { // Save the updated status in the read model and notify the client via Sign\", \"alR. return UpdateReadModelAndSendNotificationAsync(integrationEvent.OrderId, integrationEvent.Order\", \"Status, integrationEvent.Description, integrationEvent.BuyerId); } private async Task UpdateReadMode\", \"lAndSendNotificationAsync( Guid orderId, string orderStatus, string description, string buyerId) { v\", \"ar order = await _orderRepository.GetOrderByIdAsync(orderId); if (order is not null ) { order.OrderS\", \"tatus = orderStatus; order.Description = description; await _orderRepository.UpdateOrderAsync(order)\", \"; await SendNotificationAsync(order.OrderNumber, orderStatus, buyerId); } }\\n```\\n\\nIn the snippet, the\", \" handler calls the UpdateReadModelAndSendNotificationAsync helper method to handle the status update\", \":\\n\\n1. The helper method first loads the current order from the database.\\n2. If that succeeds, it upd\", \"ates the OrderStatus and Description fields and saves the updated model back to the database.\\n3. Las\", \"tly, it sends a push notification to notify the client UI.\\n\\n## Observability\\n\\neShopOnDapr uses Zipki\", \"n to visualize distributed traces collected by Dapr. Seq aggregates the eShopOnDapr application logs\", \". The various services emit structured logging using the SeriLog logging library. Serilog publishes \", \"log events to a construct called a sink . A sink is simply a target platform to which Serilog writes\", \" its logging events. Many Serilog sinks are available, including one for Seq. Seq is the Serilog sin\", \"k used in eShopOnDapr.\\n\\neShopOnDapr also includes a custom health dashboard that gives insight into \", \"the health of the eShop services. This dashboard uses the built-in health checks mechanism of ASP.NE\", \"T Core. The dashboard not only provides the health status of the services, but also the health of th\", \"e dependencies of the services, including the Dapr sidecars.\\n\\n## Secrets\\n\\nThe eShopOnDapr reference \", \"application uses the secrets building block for various secrets:\\n\\n- The password for connecting to t\", \"he Redis cache.\\n- The username and password for the SMTP server.\\n- The connection strings for the SQ\", \"L databases.\\n\\nWhen running the application using Docker Compose, the local file secret store is used\", \". The component configuration file eshop-secretstore.yaml is found in the dapr/components folder of \", \"the eShopOnDapr repository:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: eshop-\", \"secretstore namespace: eshop spec: type: secretstores.local.file version: v1 metadata: -name: secret\", \"sFile value: ./components/eshop-secretstore.json -name: nestedSeparator value: \\\".\\\"\\n```\\n\\nThe configur\", \"ation file references the local store file eshop-secretstore.json located in the same folder:\\n\\n```\\n{\", \" \\\"ConnectionStrings\\\": { \\\"CatalogDB\\\": \\\"**********\\\", \\\"IdentityDB\\\": \\\"**********\\\", \\\"OrderingDB\\\": \\\"******\", \"****\\\" }, \\\"Smtp\\\": { \\\"User\\\": \\\"**********\\\", \\\"Password\\\": \\\"**********\\\" }, \\\"State\\\": { \\\"RedisPassword\\\": \\\"**\", \"********\\\" } }\\n```\\n\\nThe components folder is specified in the command-line and mounted as a local fol\", \"der inside the Dapr sidecar container. Here's a snippet from the docker-compose.override.yml file in\", \" the repository root that specifies the volume mount:\\n\\n```\\ncatalog-api-dapr: command: [ \\\"./daprd\\\" ,\\n\", \"```\\n\\n```\\n\\\"-app-id\\\" , \\\"catalog-api\\\" , \\\"-app-port\\\" , \\\"80\\\" , \\\"-components-path\\\" , \\\"/components\\\" , \\\"-con\", \"fig\\\" , \\\"/configuration/eshop-config.yaml\\\" ] volumes: -\\\"./dapr/components/:/components\\\" -\\\"./dapr/conf\", \"iguration/:/configuration\\\"\\n```\\n\\nThe /components volume mount and --components-path command-line argu\", \"ment are passed into the daprd startup command.\\n\\nOnce configured, other component configuration file\", \"s can also reference the secrets. Here's an example of the state store component configuration consu\", \"ming secrets:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: eshop-statestore nam\", \"espace: eshop spec: type: state.redis version: v1 metadata: -name: redisHost value: redis:6379 -name\", \": redisPassword secretKeyRef: name: State.RedisPassword key: State.RedisPassword -name: actorStateSt\", \"ore value: \\\"true\\\" auth: secretStore: eshop-secretstore scopes: -basket-api -ordering-api\\n```\\n\\n## Ben\", \"efits of applying Dapr to eShop\\n\\nIn general, the use of Dapr building blocks adds observability and \", \"flexibility to the application:\\n\\n1. Observability: By using the Dapr building blocks, you gain rich \", \"distributed tracing for calls between services and to Dapr components without having to write any co\", \"de. In eShopOnContainers, a large amount of custom logging is used to provide insight.\\n2. Flexibilit\", \"y: You can now swap out infrastructure simply by changing a component configuration file. No code ch\", \"anges are necessary.\\n\\nHere are some more examples of benefits offered by specific building blocks:\\n\\n\", \"## \\u00b7 Service Invocation\\n\\n- -With Dapr's support for mTLS, services now communicate through encrypted\", \" channels.\\n- -When transient errors occur, service calls are automatically retried.\\n\\n- -Automatic se\", \"rvice discovery reduces the amount of configuration needed for services to find each other.\\n- Publis\", \"h/Subscribe\\n- -eShopOnContainers included a large amount of custom code to support both Azure Servic\", \"e Bus and RabbitMQ. Developers used Azure Service Bus for production and RabbitMQ for local developm\", \"ent and testing. An IEventBus abstraction layer was created to enable swapping between these message\", \" brokers. This layer consisted of approximately 700 lines of error-prone code . The updated implemen\", \"tation with Dapr requires only 35 lines of code . That's 5% of the original lines of code! More impo\", \"rtantly, the implementation is straightforward and easy to understand.\\n- -eShopOnDapr uses Dapr's ri\", \"ch ASP.NET Core integration to use pub/sub. You add Topic attributes to ASP.NET Core controller meth\", \"ods to subscribe to messages. Therefore, there's no need to wr ite a separate message handler loop f\", \"or each message broker.\\n- -Messages routed to the service as HTTP calls enable the use of ASP.NET Co\", \"re middleware to add functionality, without introducing new concepts or SDKs to learn.\\n- Bindings\\n- \", \"-The eShopOnContainers solution contained a to-do item for e-mailing an order confirmation to the cu\", \"stomer. With Dapr, implementing email notification was as easy as configuring a resource binding.\\n- \", \"Actors\\n- -The actors building block makes it easy to create long running, stateful workflows. Thanks\", \" to the turnbased access model, there's no need for explicit locking mechanisms.\\n- -The complexity o\", \"f the grace period implementation is greatly reduced by using actor reminders instead of polling on \", \"the database.\\n\\n## Summary\\n\\nIn this chapter, you're introduced to the eShopOnDapr reference applicati\", \"on. It's an evolution of the widely popular eShopOnContainers microservice reference application. eS\", \"hopOnDapr replaces a large amount of custom functionality with Dapr building blocks and components, \", \"dramatically simplifying the complexities required to build a microservices application.\\n\\n## Referen\", \"ces\\n\\n- eShopOnDapr\\n- eShopOnContainers\\n- .NET Microservices for Containerized .NET Applications\\n- Ar\", \"chitecting Cloud-Native .NET Apps for Azure\\n\\n<!-- image -->\\n\\n## Summary and the road ahead\\n\\nWe're at\", \" the end of our Dapr flight. The jet plane flying at 20,000 feet from chapter 2 is on final approach\", \" and about to land.\\n\\nAs the plane taxis to the gate, let's take a minute to review some important co\", \"nclusions from this guide:\\n\\n- Dapr - Dapr is a Distributed Application Runtime that streamlines how \", \"you build distributed applications. It exposes an architecture of building blocks and pluggable comp\", \"onents. Dapr provides a dynamic glue that binds your application with infrastructure capabilities th\", \"at exist in the Dapr runtime. Instead of building infrastructure plumbing, you and your team focus o\", \"n delivering business features to customers.\\n- Open source and cross-platform - The native Dapr API \", \"can be consumed by any platform that supports HTTP or gRPC. Dapr also provides language-specific SDK\", \"s for popular development platforms. Dapr v1.0 supports Go, Python, .NET, Java, PHP, and JavaScript.\", \"\\n- Building blocks - Dapr building blocks encapsulate distributed application functionality. At the \", \"time of this writing, Dapr supports the seven building blocks shown in figure 13-1.\\n\\nState managemen\", \"t\\n\\nPublish &amp;\\n\\nsubscribe\\n\\nBindings\\n\\nExtensibility\\n\\nFigure 13-1. Dapr building blocks.\\n\\n<!-- image\", \" -->\\n\\n- Components - Dapr components provide the concrete implementation for each Dapr building bloc\", \"k capability. They expose a common interface that enables developers to swap out component implement\", \"ations without changing application code. Figure 13-2 shows the relationship among components, build\", \"ing blocks, and your service.\\n\\nService invocation\\n\\nDapr API\\n\\nSidecar\\n\\nDapr API\\n\\ndapr dapr\\n\\nComponent\", \"\\n\\n(Redis Cache)\\n\\nComponent\\n\\n(Redis Cache)\\n\\nHTTP /\\n\\ngRPC\\n\\nYour\\n\\nPrimary service service\\n\\nFigure 13-2.\", \" Dapr building block integration.\\n\\n<!-- image -->\\n\\n- Sidecars - Dapr runs alongside your application\", \" in a sidecar architecture, either as a separate process of a container. Your application communicat\", \"es with the Dapr APIs over HTTP and gRPC. Sidecars provide isolation and encapsulation as they aren'\", \"t part of the service, but connected to it. Figure 13-3 shows a sidecar architecture.\\n\\nFigure 13-3. \", \"Sidecar architecture.\\n\\n<!-- image -->\\n\\n- Hosting environments Dapr has cross-platform support and ca\", \"n run in multiple environments. At the time of this writing, the environments include a local self-h\", \"osted mode and Kubernetes.\\n- eShopOnDapr - This book includes an accompanying reference application \", \"entitled eShopOnDapr. Using a popular e-commerce application domain, the reference application demon\", \"strates the usage of each build ing block. It's an evolution of the widely popular eShopOnContainers\", \", released several years ago.\\n\\n## The road ahead\\n\\nLooking forward, Dapr has the potential to have a \", \"profound impact on distributed application development. What can you expect from the Dapr team and i\", \"ts open-source contributors?\\n\\nAt the time of writing, the list of proposed enhancements for Dapr inc\", \"lude:\\n\\n- Feature enhancements to existing building blocks:\\n- -Query capabilities in state management\", \" enabling you to retrieve multiple values.\\n- -Topic filtering in pub/sub enabling you to filter topi\", \"cs based on their content.\\n- -An application tracing API in observability that provides tracing in t\", \"he application directly without having to bind to specific libraries.\\n- -Binding and pub/sub support\", \" for actors providing event driven capabilities to the actor programming model. Bound components wil\", \"l trigger events and messages invoke methods in the actor.\\n- New building blocks:\\n- -Configuration A\", \"PI building block for reading and writing configuration data. The block will bind to providers that \", \"include Azure Configuration Manager or GCP Configuration Management.\\n- -Http scale-to-zero autoscale\", \".\\n- -Leader election building block to provide singleton instances and locking semantic capabilities\", \".\\n- -Transparent proxying building block for service invocation, enabling you to route messages base\", \"d on URLs or DNS addresses at the network level.\\n- -Resiliency building block (circuit breakers, bul\", \"kheads &amp; timeouts).\\n- Integration with frameworks and cloud native technologies. Some examples i\", \"nclude:\\n- -Django\\n- -Nodejs\\n- -Express\\n- -Kyma\\n- -Midway\\n- New language SDKs:\\n- -JavaScript\\n- -RUST\\n\", \"- -C++\\n\\n- New hosting platforms:\\n- -VMs\\n- -Azure IoT Edge\\n- -Azure Stack Edge\\n- -Azure Service Fabri\", \"c\\n- Developer and operator productivity tooling:\\n- -VS Code extension.\\n- -Remote Dev Containers for \", \"local debugging a DevOps pipeline development.\\n- -Dapr operational dashboard enhancements that will \", \"provide deeper visibility into the operational concerns of managing Dapr applications.\\n\\nDapr version\", \" 1.0 provides developers with a compelling toolbox for building distributed applications. As the pro\", \"posed enhancement list shows, Dapr is under active development with many new capabilities to come. S\", \"tay tuned to the Dapr site and Dapr announcement blog for future updates.\"]"