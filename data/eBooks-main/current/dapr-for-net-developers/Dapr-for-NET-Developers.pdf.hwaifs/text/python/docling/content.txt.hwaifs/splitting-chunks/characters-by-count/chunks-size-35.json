"[\"## Dapr for .NET Developers\\n\\nForeword by Mark Russinovich, Microsoft Azure CTO and Technical Fellow\\n\", \"\\nRobert Vettor Sander Molenkamp Edwin van Wijk\\n\\n## EDITION v1.2\\n\\nPUBLISHED BY Microsoft Developer Di\", \"vision, .NET, and Azure Incubations teams A division of Microsoft Corporation One Microsoft Way Redm\", \"ond, Washington 98052-6399 Copyright \\u00a9 2023 by Microsoft Corporation All rights reserved. No part of\", \" the contents of this book may be reproduced or transmitted in any form or by any means without the \", \"written permission of the publisher. This book is provided 'as -is' and expresses the author's views\", \" and opinions. The views, opinions, and information expressed in this book, including URL and other \", \"Internet website references, may change without notice. Some examples depicted herein are provided f\", \"or illustration only and are fictitious. No real association or connection is intended or should be \", \"inferred. Microsoft and the trademarks listed at https://www.microsoft.com on the 'Trademarks' webpa\", \"ge are trademarks of the Microsoft group of companies. Mac and macOS are trademarks of Apple Inc. Th\", \"e Docker whale logo is a registered trademark of Docker, Inc. Used by permission. All other marks an\", \"d logos are property of their respective owners. Authors: Rob Vettor , Principal Cloud Solution Arch\", \"itect - thinkingincloudnative.com, Microsoft Sander Molenkamp , Principal Cloud Architect/Microsoft \", \"MVP - sandermolenkamp.com, Info Support Edwin van Wijk , Principal Solution Architect/Microsoft MVP \", \"- defaultconstructor.com, Info Support Participants and Reviewers: Mark Russinovich , Azure CTO and \", \"Technical Fellow, Azure Office of CTO, Microsoft Nish Anil , Senior Program Manager, .NET team, Micr\", \"osoft Mark Fussell , Principal Program Manager, Azure Incubations, Microsoft Yaron Schneider , Princ\", \"ipal Software Engineer, Azure Incubations, Microsoft Ori Zohar , Senior Program Manager, Azure Incub\", \"ations, Microsoft Editors: David Pine , Senior Content Developer, .NET team, Microsoft\\n\\nMaira Wenzel\", \" , Senior Program Manager, .NET team, Microsoft\\n\\nSteve 'ardalis' Smith , Senior Architect and Traine\", \"r, NimblePros\\n\\n## Version\\n\\nThis guide has been written to cover the Dapr 1.9 version. .NET samples a\", \"re based on .NET 7 .\\n\\n## Who should use this guide\\n\\nThe audience for this guide is mainly developers\", \", development leads, and architects who are interested in learning how to build applications designe\", \"d for the cloud.\\n\\nA secondary audience is technical decision-makers who plan to choose whether to bu\", \"ild their applications using a cloud-native approach.\\n\\n## How you can use this guide\\n\\nThis guide is \", \"available both in PDF form and online. Feel free to forward this document or links to its online ver\", \"sion to your team to help ensure common understanding of these topics. Most of these topics benefit \", \"from a consistent understanding of the underlying principles and patterns, as well as the trade-offs\", \" involved in decisions related to these topics. Our goal with this document is to equip teams and th\", \"eir leaders with the information they need to make well-informed decisions for their applications' a\", \"rchitecture, development, and hosting.\\n\\n## Contents\\n\\n| Foreword - Dapr for .NET Developers..........\", \"......................................................................... 1                         \", \"                                             |\\n|----------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"---------------------------------------|\\n| The world is distributed.................................\", \"......................................................................... 3                         \", \"                                 |\\n| Summary........................................................\", \"....................................................................................................\", \".........................7 |\\n| Dapr at 20,000 feet .................................................\", \"................................................................ 8                                  \", \"                     |\\n| Dapr and the problem it solves.............................................\", \".............................................................................................8      \", \"               |\\n| Dapr architecture ...............................................................\", \"....................................................................................................\", \"..9      |\\n| Building blocks........................................................................\", \".............................................................................................9      \", \"   |\\n| Components...................................................................................\", \"....................................................................................11           |\\n|\", \" Sidecar architecture...............................................................................\", \"..........................................................................13               |\\n| Hosti\", \"ng environments.....................................................................................\", \"...............................................................14                    |\\n| Dapr perfor\", \"mance considerations ...............................................................................\", \".................................................. 15                          |\\n| Dapr and service \", \"meshes..............................................................................................\", \"..................................................... 16                 |\\n| Summary................\", \"....................................................................................................\", \".............................................................. 18  |\\n| References...................\", \"....................................................................................................\", \"....................................................18       |\\n| Get started with Dapr .............\", \".............................................................................................. 19   \", \"                                                       |\\n| Install Dapr into your local environment.\", \"....................................................................................................\", \"................ 19                              |\\n| Build your first Dapr application..............\", \"....................................................................................................\", \"................... 19                     |\\n| Create the application...............................\", \"....................................................................................................\", \".................19                  |\\n| Component configuration files .............................\", \"....................................................................................................\", \"...... 21                      |\\n| Build a multi-container Dapr application.........................\", \"........................................................................................... 23      \", \"                         |\\n| Create the application.................................................\", \"...................................................................................................2\", \"3                  |\\n| Add Dapr service invocation..................................................\", \"......................................................................................27            \", \"             |\\n| container                                                                          \", \"                                                                                                    \", \"       |\\n| Add support..............................................................................\", \".....................................................................29                             \", \" |\\n| Summary........................................................................................\", \".......................................................................................... 35  |\\n| R\", \"eferences...........................................................................................\", \"................................................................................35       |\\n| Traffic\", \" Control sample application.........................................................................\", \"............. 36                                                                   |\\n| Using Dapr bu\", \"ilding blocks.......................................................................................\", \"........................................................ 39                  |\\n\\n| Hosting...........\", \"....................................................................................................\", \".......................................................................   | 40   |\\n|----------------\", \"----------------------------------------------------------------------------------------------------\", \"-----------------------------------------------------------------------------|------|\\n| Self-hosted \", \"mode ...............................................................................................\", \".............................................................40                 |      |\\n| Kubernete\", \"s...................................................................................................\", \".......................................................................41          |      |\\n| Summar\", \"y...................................................................................................\", \"...............................................................................       | 41   |\\n| Ref\", \"erences.............................................................................................\", \"..............................................................................41         |      |\\n| \", \"The Dapr state management building block............................................................\", \"..........                                                                                  | 42   |\", \"\\n| What it solves...................................................................................\", \"......................................................................................         | 42 \", \"  |\\n| How it works..................................................................................\", \".........................................................................................         | \", \"43   |\\n| Consistency................................................................................\", \".........................................................................................43         \", \" |      |\\n| Concurrency ............................................................................\", \"...........................................................................................45       \", \"    |      |\\n| Transactions ........................................................................\", \"...............................................................................................45   \", \"       |      |\\n| Use the Dapr .NET SDK.............................................................\", \"..........................................................................................          \", \"          | 46   |\\n| ASP.NET Core integration.......................................................\", \"......................................................................................47            \", \"             |      |\\n| State store components......................................................\", \"...............................................................................................     \", \"                | 47   |\\n| Configuration............................................................\", \"....................................................................................................\", \".....48            |      |\\n| Key prefix strategies.................................................\", \"....................................................................................................\", \"...49                 |      |\\n| Sample application: Dapr Traffic Control ..........................\", \"..........................................................................................          \", \"                         | 50   |\\n| Summary.........................................................\", \"....................................................................................................\", \".....................       | 51   |\\n| References...................................................\", \"....................................................................................................\", \"....................52         |      |\\n| The Dapr service invocation building block................\", \".......................................................                                             \", \"                                  | 53   |\\n| What it solves.........................................\", \"....................................................................................................\", \"............................         | 53   |\\n| How it works........................................\", \"....................................................................................................\", \"...............................         | 53   |\\n| Use the Dapr .NET SDK............................\", \"....................................................................................................\", \".......................                    | 55   |\\n| Invoke HTTP services using HttpClient.........\", \"....................................................................................................\", \".......55                                     |      |\\n| Invoke HTTP services using DaprClient......\", \"....................................................................................................\", \".........57                                      |      |\\n| Invoke gRPC services using DaprClient...\", \"....................................................................................................\", \"............58                                      |      |\\n| Name resolution components...........\", \"....................................................................................................\", \"..........................                             | 58   |\\n| Configuration.....................\", \"....................................................................................................\", \"............................................58            |      |\\n| Sample application: Dapr Traffi\", \"c Control ..........................................................................................\", \"..........................                                   | 59   |\\n| Summary.....................\", \"....................................................................................................\", \".........................................................       | 60   |\\n| References...............\", \"....................................................................................................\", \"........................................................60         |      |\\n\\n| The Dapr publish &sub\", \"scribe building block....................................................................           \", \"                                                                 | 61   |\\n|-------------------------\", \"----------------------------------------------------------------------------------------------------\", \"--------------------------------------------------------------|------|\\n| What it solves.............\", \"....................................................................................................\", \"........................................................   | 61   |\\n| How it works..................\", \"....................................................................................................\", \".....................................................   | 62   |\\n| Competing consumers..............\", \"....................................................................................................\", \".................................66                  |      |\\n| Use the Dapr .NET SDK...............\", \"....................................................................................................\", \"....................................              | 66   |\\n| Pub/sub components.....................\", \"....................................................................................................\", \".................................              | 68   |\\n| Configuration.............................\", \"....................................................................................................\", \"....................................68      |      |\\n| Sample application: Dapr Traffic Control ....\", \"....................................................................................................\", \"............                             | 69   |\\n| Summary.........................................\", \"....................................................................................................\", \"..................................... | 71   |\\n| References.........................................\", \"....................................................................................................\", \"..............................71   |      |\\n| The Dapr bindings building block......................\", \".................................................................                                   \", \"                                | 72   |\\n| What it solves...........................................\", \"....................................................................................................\", \"..........................   | 72   |\\n| How it works................................................\", \"....................................................................................................\", \".......................   | 73   |\\n| Input bindings ................................................\", \"....................................................................................................\", \"...............73      |      |\\n| Output bindings ..................................................\", \"....................................................................................................\", \".........74         |      |\\n| Use the Dapr .NET SDK................................................\", \"....................................................................................................\", \"...              | 76   |\\n| Binding components .....................................................\", \"....................................................................................................\", \"..            | 76   |\\n| Cron binding ..............................................................\", \"....................................................................................................\", \"....77     |      |\\n| Sample application: Dapr Traffic Control .....................................\", \"...............................................................................                     \", \"        | 78   |\\n| MQTT input binding...............................................................\", \".........................................................................................79         \", \"     |      |\\n| SMTP output binding ................................................................\", \".....................................................................................81             \", \"  |      |\\n| Summary................................................................................\", \".................................................................................................. |\", \" 83   |\\n| References................................................................................\", \"...........................................................................................83   |   \", \"   |\\n| The Dapr actors building block...............................................................\", \".............................                                                                | 84   \", \"|\\n| What it solves..................................................................................\", \".......................................................................................   | 84   |\\n|\", \" How it works.......................................................................................\", \"....................................................................................   | 85   |\\n| Tu\", \"rn-based access model...............................................................................\", \"..............................................................88                    |      |\\n| Timer\", \"s and reminders.....................................................................................\", \"................................................................89               |      |\\n| State pe\", \"rsistence ..........................................................................................\", \"....................................................................89        |      |\\n| Use the Dap\", \"r .NET SDK..........................................................................................\", \".............................................................              | 90   |\\n| Call actors fr\", \"om ASP.NET Core clients ............................................................................\", \".........................................93                             |      |\\n\\n| Call non-.NET   \", \"                                                                                                    \", \"                                                                        | actors....................\", \"....................................................................................................\", \"................................94   |\\n|------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"-----------------------------|----------------------------------------------------------------------\", \"----------------------------------------------------------------------------------------------|\\n| Ti\", \"mers and reminders..................................................................................\", \"...................................................................95                 |             \", \"                                                                                                    \", \"                                                   |\\n| Sample application: Dapr Traffic Control ....\", \"....................................................................................................\", \"............                               | 97                                                     \", \"                                                                                                    \", \"        |\\n| Summary.................................................................................\", \".................................................................................................   \", \"| 98                                                                                                \", \"                                                                 |\\n| References.....................\", \"....................................................................................................\", \"..................................................99     |                                          \", \"                                                                                                    \", \"                      |\\n| The Dapr observability building block.....................................\", \".........................................100                                                        \", \"              |                                                                                     \", \"                                                                               |\\n| What it solves...\", \"....................................................................................................\", \"................................................................101    |                            \", \"                                                                                                    \", \"                                    |\\n| How it works................................................\", \"....................................................................................................\", \".....................101    |                                                                       \", \"                                                                                             |\\n| Dis\", \"tributed tracing....................................................................................\", \".....................................................................102             |              \", \"                                                                                                    \", \"                                                  |\\n| Metrics.......................................\", \"....................................................................................................\", \".....................................109  |                                                         \", \"                                                                                                    \", \"       |\\n| Logging..................................................................................\", \"............................................................................................111    |\", \"                                                                                                    \", \"                                                                |\\n| Health status ..................\", \"....................................................................................................\", \"..............................................113       |                                           \", \"                                                                                                    \", \"                     |\\n| Dapr dashboard.............................................................\", \".................................................................................................114\", \"             |                                                                                      \", \"                                                                              |\\n| Use the Dapr .NET \", \"SDK.................................................................................................\", \"....................................................115               |                             \", \"                                                                                                    \", \"                                   |\\n| Sample application: Dapr Traffic Control ....................\", \"..............................................................................................115   \", \"                           |                                                                        \", \"                                                                                            |\\n| Summ\", \"ary.................................................................................................\", \"...............................................................................117  |               \", \"                                                                                                    \", \"                                                 |\\n| References ....................................\", \"....................................................................................................\", \".....................................118 |                                                          \", \"                                                                                                    \", \"      |\\n| The Dapr secrets management building block ...............................................\", \".................119                                                                              | \", \"                                                                                                    \", \"                                                               |\\n| What it solves...................\", \"....................................................................................................\", \"................................................119    |                                            \", \"                                                                                                    \", \"                    |\\n| How it works................................................................\", \"....................................................................................................\", \".....120    |                                                                                       \", \"                                                                             |\\n| Use the Dapr .NET S\", \"DK..................................................................................................\", \"...................................................121               |                              \", \"                                                                                                    \", \"                                  |\\n| Secret store components.......................................\", \"....................................................................................................\", \"......122                 |                                                                         \", \"                                                                                           |\\n| Confi\", \"guration............................................................................................\", \".......................................................................123         |                \", \"                                                                                                    \", \"                                                |\\n| Indirectly consume Dapr secrets.................\", \"....................................................................................................\", \".........123                            |                                                           \", \"                                                                                                    \", \"     |\\n| Local file ................................................................................\", \".............................................................................................124 |  \", \"                                                                                                    \", \"                                                              |\\n| Kubernetes secret ................\", \"....................................................................................................\", \"......................................126             |                                             \", \"                                                                                                    \", \"                   |\\n| Azure Key Vault..............................................................\", \".................................................................................................126\", \"           |                                                                                        \", \"                                                                            |\\n| Scope secrets.......\", \"....................................................................................................\", \"........................................................129         |                               \", \"                                                                                                    \", \"                                 |\\n| Sample application: Dapr Traffic Control ......................\", \"............................................................................................129     \", \"                         |                                                                          \", \"                                                                                          |\\n| Secret\", \"s ..................................................................................................\", \"..............................................................................131 |                 \", \"                                                                                                    \", \"                                               |\\n| SMTP server credentials .........................\", \"....................................................................................................\", \".................132                   |                                                            \", \"                                                                                                    \", \"    |\\n| Redis server credentials....................................................................\", \"...........................................................................133                  |   \", \"                                                                                                    \", \"                                                             |\\n\\n| FineCalculator component license k\", \"ey..................................................................................................\", \"................134                                   |\\n|-------------------------------------------\", \"----------------------------------------------------------------------------------------------------\", \"----------------------------------------------|\\n| Summary...........................................\", \"....................................................................................................\", \".................................135  |\\n| References ...............................................\", \"....................................................................................................\", \"..........................135 |\\n| Dapr reference application........................................\", \".........................................................137                                        \", \"                      |\\n| eShopOnContainers.........................................................\", \"..................................................................................................13\", \"7             |\\n| eShopOnDapr.......................................................................\", \"................................................................................................138 \", \"      |\\n| Application of Dapr building blocks.......................................................\", \".....................................................................139                          |\\n\", \"| State management..................................................................................\", \"......................................................................140                 |\\n| Servic\", \"e invocation........................................................................................\", \"..................................................................142             |\\n| Publish & subs\", \"cribe...............................................................................................\", \"........................................................147               |\\n| Bindings .............\", \"....................................................................................................\", \"............................................................150   |\\n| Actors........................\", \"....................................................................................................\", \"......................................................152 |\\n| Observability ........................\", \"....................................................................................................\", \"........................................158       |\\n| Secrets ......................................\", \"....................................................................................................\", \"......................................159 |\\n| Benefits of applying Dapr to eShop....................\", \"....................................................................................................\", \"....160                           |\\n| Summary.......................................................\", \"....................................................................................................\", \".....................161  |\\n| References............................................................\", \"....................................................................................................\", \".........161      |\\n| Summary and the road ahead....................................................\", \"........................................162                                                         \", \"          |\\n| The road ahead........................................................................\", \"............................................................................................165     \", \"  |\\n\\n## Foreword - Dapr for .NET Developers\\n\\nWith the wave of cloud adoption underway, there is a ma\", \"jor shift happening towards 'cloud native' development, often built with microservice-architectures.\", \" These microservices are both stateless and stateful, and run on the cloud and edge, embracing the d\", \"iversity of languages and frameworks available today. This enterprise shift is driven by both the ma\", \"rket forces of faster time to market, and the scale and efficiencies of building services for the cl\", \"oud. Even before COVID-19, cloud adoption was accelerating for enterprises, and developers were bein\", \"g asked to do even more to deliver on building these distributed system applications. That has only \", \"accelerated since COVID-19. Developers in enterprises seek to focus on business logic, while leaning\", \" on platforms to imbue their applications with scale, resiliency, maintainability, elasticity, and t\", \"he other attributes of cloud-native architectures, which is why there is also shift towards serverle\", \"ss platforms that hide the underlying infrastructure. Developers should not be expected to become di\", \"stributed systems experts. This is where Dapr steps in to help you, whether you are building on infr\", \"astructure such as Kubernetes, or on a serverless platform.\\n\\nDapr is designed as an enterprise, deve\", \"loper-focused, microservices programming model platform wi th the mantra 'any language, any framewor\", \"k, run anywhere'. It makes building distributed applications easy and portable across any infrastruc\", \"ture, from public-cloud, through hierarchical edge, and even down to single node IoT devices. It eme\", \"rged from both our experiences building services in Azure and time spent working with customers buil\", \"ding applications on Azure Kubernetes Service and Azure Service Fabric. Over and over, we saw common\", \" problems that they had to address. It became clear that there was a ne ed to provide a 'library' of\", \" common microservice best practices that developers could use, not only in new green field applicati\", \"ons, but also to aid in the modernization of existing applications. In the containerized, distribute\", \"d, and networked cloud native world, the sidecar model has emerged as the preferred approach, in the\", \" same way DLLs are preferred in the client/server generation. Using Dapr's sidecar and APIs give you\", \", as a developer, all the power of distributed systems functionality, with the ease of a single HTTP\", \" or gRPC local call.\\n\\nTo address the wide range of scenarios that developers face, Dapr provides fea\", \"tures such as state management, service-to-service invocation, pub/sub, and integration to external \", \"systems with I/O bindings, which are based on the triggers and bindings of Azure Functions. These in\", \" turn take advantage of Dapr's component model, which allows you to 'swap out', say different underl\", \"ying state stores, without having to change any code. This component model makes code more portable,\", \" more flexible, and allows for experimentation of what best suits your needs. Developers don't need \", \"to learn\\n\\nand incorporate service SDKs into their code, or worry about authentication, secret manage\", \"ment, retries, or conditional code that targets specific deployment environments.\\n\\nThis book shows h\", \"ow Dapr reduces your development time and overall code maintenance by incrementally 'Daperizing' the\", \" canonical .NET reference application, eShop. For example, in the original eShop implementation, sig\", \"nificant amounts of code were written to abstract between Azure Service Bus and RabbitMQ for publish\", \"ing events between services. All this code can be discarded and simply replaced with Dapr's pub/sub \", \"API and component model, which had an even wider range of pub/s ub brokers, rather than just two. Da\", \"pr's actor model, when used in the reworked eShop application, shows the ease of building long runni\", \"ng, stateful, event driven, workflow applications with all the difficulties of concurrency and multi\", \"-threading removed. By the end of this book, you will see the drastic simplification that Dapr bring\", \"s to your application development, and I firmly believe all developers embarking on a cloud native a\", \"pp building journey should use Dapr.\\n\\nWe publicly announced Dapr with the v0.1 release in Oct 2019 a\", \"nd now, a year and half later, I am thrilled to say that Dapr is ready for production usage with the\", \" v1.0 release. Getting Dapr to v1.0 has truly been a community effort. It has been amazing to see th\", \"e open-source community coalesce around Dapr and grow since it was first announced -from 114 contrib\", \"utors in October 2019 to over 700 in early 2021 - a six-fold increase in 16 months! Contributions to\", \" the project have gone to every Dapr repo and have ranged from opening issues, commenting on feature\", \" proposals, providing samples, and, of course, contributing code. The parts of the project community\", \" members have contributed to the most include the Dapr runtime, docs, CLI, SDKs, and the creation of\", \" a rich ecosystem of components. Maintaining this openness is critical to Dapr's future.\\n\\nDapr is ju\", \"st getting started, though, and you should expect to see more Dapr capabilities and more support for\", \" Dapr in Azure services. I hope that you will take advantage of Dapr to enable you to focus on your \", \"core business logic and accelerate your microservices development. I am excited to have you join us \", \"in the Dapr community on this journey at https://github.com/dapr/ and on Discord https://aka.ms/dapr\", \"-discord.\\n\\nModern distributed systems are complex. You start with small, loosely coupled, independen\", \"tly deployable services. These services cross process and server boundaries. They then consume diffe\", \"rent kinds of infrastructure backing services (databases, message brokers, key vaults). Finally, the\", \"se disparate pieces compose together to form an application.\\n\\nMark Russinovich Azure CTO and Technic\", \"al Fellow Microsoft\\n\\nClient app\\n\\nMobile app valzzzaral\\n\\nWeb app\\n\\nAPI\\n\\nServer app\\n\\nModules\\n\\nIdentity\\n\", \"\\nCatalog\\n\\n## The world is distributed\\n\\ndatabase\\n\\nMarketing\\n\\nLocation\\n\\nJust ask any 'cool kid': Moder\", \"n, distributed systems are in, and monolithic apps are out!\\n\\nBut, it's not just 'cool kids.' Progres\", \"sive IT Leaders, corporate architects, and astute developers are echoing these same thoughts as they\", \" explore and evaluate modern distributed applications. Many have bought in. They're designing new an\", \"d replatforming existing enterprise applications following the principles, patterns, and practices o\", \"f distributed microservice applications.\\n\\nBut, this evolution raises m any questions\\u2026\\n\\n- What exactl\", \"y is a distributed application?\\n- Why are they gaining popularity?\\n- What are the costs?\\n- And, impo\", \"rtantly, what are the tradeoffs?\\n\\nTo start, let's rewind and look at the past 15 years. During this \", \"period, we typically constructed applications as a single, monolithic unit. Figure 1-1 shows the arc\", \"hitecture.\\n\\nFigure 1-1. Monolithic architecture.\\n\\nNote how the modules for Ordering, Identity, and M\", \"arketing execute in a single-server process. Application data is stored in a shared database. Busine\", \"ss functionality is exposed via HTML and RESTful interfaces.\\n\\nIn many ways, monolithic apps are stra\", \"ightforward . They're straightforward to:\\n\\n- Build\\n\\nInfrastructure\\n\\n- Test\\n- Deploy\\n- Troubleshoot\\n-\", \" Scale vertically (scale up)\\n\\nHowever, monolithic architectures can present significant challenges.\\n\", \"\\nOver time, you may reach a point where you begin to lose control\\u2026\\n\\n- The monolith has become so ove\", \"rwhelmingly complicated that no single person understands it.\\n- You fear making changes as each brin\", \"gs unintended and costly side effects.\\n- New features/fixes become time-consuming and expensive to i\", \"mplement.\\n- Even the smallest change requires full deployment of the entire application - expensive \", \"and risky.\\n- One unstable component can crash the entire system.\\n- Adding new technologies and frame\", \"works aren't an option.\\n- Implementing agile delivery methodologies are difficult.\\n- Architectural e\", \"rosion sets in as the code base deteriorates with neverending 'special cases.'\\n- Eventually the cons\", \"ultants come in and tell you to rewrite it.\\n\\nIT practitioners call this condition the Fear Cycle . I\", \"f you've been in the technology business for any length of time, good chance you've experienced it. \", \"It's stressful and exhausts your IT budget. Instead of building new and innovative solutions, most o\", \"f your budget is spent maintaining legacy apps.\\n\\nInstead of fear, businesses require speed and agili\", \"ty . They seek an architectural style with which they can rapidly respond to market conditions. They\", \" need to instantaneously update and individually scale small areas of a live application.\\n\\nAn early \", \"attempt to gain speed and agility came in the form of Service Oriented Architecture, or SOA . In thi\", \"s model, service consumers and service providers collaborated via middleware messaging components, o\", \"ften referred to as an Enterprise Service Bus, or ESB . Figure 1-2 shows the architecture.\\n\\nprovider\", \"\\n\\nConsumers\\n\\nFigure 1-2. SOA architecture.\\n\\nWith SOA, centralized service providers registered with \", \"the ESB. Business logic would be built into the ESB to integrate providers and consumers. Service co\", \"nsumers could then find and communicate with these providers using the ESB.\\n\\nDespite the promises of\", \" SOA, implementing this approach often increased complexity and introduced bottlenecks. Maintenance \", \"costs became high and ESB middleware expensive. Services tended to be large. They often shared depen\", \"dencies and data storage. In the end, SOAs often resulted in a 'distributed monolithic' structure wi\", \"th centralized services that were resistant to change.\\n\\nNowadays, many organizations have realized s\", \"peed and agility by adopting a distributed microservice architectural approach to building systems. \", \"Figure 1-3 shows the same system built using distributed techniques and practices.\\n\\nOrdering microse\", \"rvice\\n\\nAPI\\n\\nConsumers\\n\\nFigure 1-3. Distributed architecture.\\n\\nNote how the same application is decom\", \"posed across a set of distributed services. Each is selfcontained and encapsulates its own code, dat\", \"a, and dependencies. Each is deployed in a software container and managed by a container orchestrato\", \"r. Instead of a single database shared by multiple services, each service own s a private database. \", \"Other services can't access this database directly and can only get to data that is exposed through \", \"the public API of the service that owns it. Note how some services require a full relational databas\", \"e, but others, a NoSQL datastore. The basket service stores its state in a distributed key/value cac\", \"he. Note how inbound traffic routes through an API Gateway service. It's responsible for directing c\", \"alls to services and enforcing cross -cutting concerns. Most importantly, the application takes full\", \" advantage of the scalability, availability, and resiliency features found in modern cloud platforms\", \".\\n\\nBut, while distributed services can provide agility and speed, they present a different set of ch\", \"allenges. Consider the following\\u2026\\n\\n- How can distributed services discover each other and communicat\", \"e synchronously?\\n\\n- How can they implement asynchronous messaging?\\n- How can they maintain contextua\", \"l information across a transaction?\\n- How can they become resilient to failure?\\n- How can they scale\", \" to meet fluctuating demand?\\n- How are they monitored and observed?\\n\\nFor each of these challenges, m\", \"ultiple products are often available. But, shielding your application from product differences and k\", \"eeping code maintainable and portable become a challenge.\\n\\nThis book introduces Dapr. Dapr is a dist\", \"ributed application runtime. It directly addresses many of the challenges found that come along with\", \" distributed applications. Looking ahead, Dapr has the potential to have a profound impact on distri\", \"buted application development.\\n\\n## Summary\\n\\nIn this chapter, we discussed the adoption of distribute\", \"d applications. We contrasted a monolithic system approach with that of distributed services. We poi\", \"nted out many of the common challenges when considering a distributed approach.\\n\\nNow, sit back, rela\", \"x, and let us introduce you the new world of Dapr.\\n\\n## Dapr at 20,000 feet\\n\\nIn chapter 1, we discuss\", \"ed the appeal of distributed microservice applications. But, we also pointed out that they dramatica\", \"lly increase architectural and operational complexity. With that in mind, the question becomes, how \", \"can you 'have your cake' and 'eat it too?'. That is, how can you take advantage of the agility of di\", \"stributed architecture, and minimize its complexity?\\n\\nDapr, or Distributed Application Runtime , is \", \"a new way to build modern distributed applications.\\n\\nWhat started as a prototype has evolved into a \", \"highly successful open-source project. Its sponsor, Microsoft, has closely partnered with customers \", \"and the open-source community to design and build Dapr. The Dapr project brings together developers \", \"from all backgrounds to solve some of the toughest challenges of developing distributed applications\", \".\\n\\nThis book looks at Dapr from the viewpoint of a .NET developer. In this chapter, you'll build a c\", \"onceptual understanding of Dapr and how it works. Later on, we present practical, hands-on instructi\", \"on on how you can use Dapr in your applications.\\n\\nImagine flying in a jet at 20,000 feet. You look o\", \"ut the window and see the landscape below from a wide perspective. Let's do the same for Dapr. Visua\", \"lize yourself flying over Dapr at 20,000 feet. W hat would you see?\\n\\n## Dapr and the problem it solv\", \"es\\n\\nDapr addresses a large challenge inherent in modern distributed applications: Complexity .\\n\\nThro\", \"ugh an architecture of pluggable components, Dapr greatly simplifies the plumbing behind distributed\", \" applications. It provides a dynamic glue that binds your application with infrastructure capabiliti\", \"es from the Dapr runtime.\\n\\nConsider a requirement to make one of your services stateful? What would \", \"be your design. You could write custom code that targets a state store such as Redis Cache. However,\", \" Dapr provides state management capabilities out-of-the-box. Your service invokes the Dapr state man\", \"agement building block that dynamically binds to a state store component via a Dapr component config\", \"uration yaml file. Dapr ships with several pre-built state store components, including Redis. With t\", \"his model, your service delegates state management to the Dapr runtime. Your service has no SDK, lib\", \"rary, or direct reference to the underlying component. You can even change state stores, say, from R\", \"edis to MySQL or Cassandra, with no code changes.\\n\\nFigure 2-1 shows Dapr from 20,000 feet.\\n\\ndapr\\n\\nAn\", \"y code or framework...\\n\\n=GO\\n\\nApplication code\\n\\nMicroservices written in nodeo\\n\\npython\\n\\n.NET\\n\\n\\u2192 lava\\n\", \"\\nFigure 2-1. Dapr at 20,000 feet.\\n\\nIn the top row of the figure, note how Dapr provides language-spe\", \"cific SDKs for popular development platforms. Dapr v1.0 includes support for Go, Node.js, Python, .N\", \"ET, Java, and JavaScript. This book focuses on the Dapr .NET SDK, which also provides direct support\", \" for ASP.NET Core integration.\\n\\nWhile language-specific SDKs enhance the developer experience, Dapr \", \"is platform agnostic. Under the hood, Dapr's programming model exposes capabilities through standard\", \" HTTP/gRPC communication protocols. Any programming platform can call Dapr via its native HTTP and g\", \"RPC APIs.\\n\\nThe blue boxes across the center of the figure represent the Dapr building blocks. Each e\", \"xposes a distributed application capability that your application can consume.\\n\\nThe bottom row highl\", \"ights the portability of Dapr and the diverse environments across which it can run.\\n\\n## Dapr archite\", \"cture\\n\\nAt this point, the jet turns around and flies back over Dapr, descending in altitude, giving \", \"you a closer look at how Dapr works.\\n\\n## Building blocks\\n\\nFrom the new perspective, you see a more d\", \"etailed view of the Dapr building blocks .\\n\\nA building block encapsulates a distributed infrastructu\", \"re capability. You can access the functionality through the HTTP or gRPC APIs. Figure 2-2 shows the \", \"available blocks for Dapr v 1.0.\\n\\nState management\\n\\nPublish &amp;\\n\\nsubscribe\\n\\nBindings\\n\\nExtensibilit\", \"y\\n\\nFigure 2-2. Dapr building blocks.\\n\\nThe following table describes the infrastructure services prov\", \"ided by each block.\\n\\n| Building block        | Description                                          \", \"                                                      |\\n|-----------------------|-------------------\", \"-----------------------------------------------------------------------------------------|\\n| State m\", \"anagement      | Support contextual information for long running stateful services.                 \", \"                        |\\n| Service invocation    | Invoke direct, secure service-to-service calls u\", \"sing platform agnostic protocols and well-known endpoints. |\\n| Publish and subscribe | Implement sec\", \"ure, scalable pub/sub messaging between services.                                             |\\n\\nSer\", \"vice invocation\\n\\nDapr API\\n\\nHTTP /\\n\\ngRPC\\n\\nYour service\\n\\n| Building block   | Description             \", \"                                                                 |\\n|------------------|-------------\", \"-----------------------------------------------------------------------------|\\n| Bindings         | \", \"Trigger code from events raised by external resources with bi-directional communication. |\\n| Observa\", \"bility    | Monitor and measure message calls across networked services.                            \", \" |\\n| Secrets          | Securely access external secret stores.                                     \", \"             |\\n| Actors           | Encapsulate logic and data in reusable actor objects.           \", \"                         |\\n\\nBuilding blocks abstract the implementation of distributed application c\", \"apabilities from your services. Figure 2-3 shows this interaction.\\n\\nFigure 2-3. Dapr building block \", \"integration.\\n\\nBuilding blocks invoke Dapr components that provide the concrete implementation for ea\", \"ch resource. The code for your service is only aware of the building block. It takes no dependencies\", \" on external SDKs or libraries - Dapr handles the plumbing for you. Each building block is independe\", \"nt. You can use one, some, or all of them in your application. As a value-add, Dapr building blocks \", \"bake in industry best practices including comprehensive observability.\\n\\nWe provide detailed explanat\", \"ion and code samples for each Dapr building block in the upcoming chapters. At this point, the jet d\", \"escends even more. From the new perspective, you now have a closer look at the Dapr components layer\", \".\\n\\n## Components\\n\\nWhile building blocks expose an API to invoke distributed application capabilities\", \", Dapr components provide the concrete implementation to make it happen.\\n\\nConsider, the Dapr state s\", \"tore component. It provides a uniform way to manage state for CRUD operations. Without any change to\", \" your service code, you could switch between any of the following Dapr state components:\\n\\n- AWS Dyna\", \"moDB\\n- Aerospike\\n- Azure Blob Storage\\n- Azure CosmosDB\\n- Azure Table Storage\\n- Cassandra\\n- Cloud Fir\", \"estore (Datastore mode)\\n- CloudState\\n- Couchbase\\n- Etcd\\n- HashiCorp Consul\\n- Hazelcast\\n- Memcached\\n-\", \" MongoDB\\n- PostgreSQL\\n- Redis\\n- RethinkDB\\n- SQL Server\\n- Zookeeper\\n\\nEach component provides the nece\", \"ssary implementation through a common state management interface:\\n\\n```\\ntype Store interface { Init(m\", \"etadata Metadata) error Delete(req *DeleteRequest) error BulkDelete(req []DeleteRequest) error Get(r\", \"eq *GetRequest) (*GetResponse, error) Set(req *SetRequest) error BulkSet(req []SetRequest) error }\\n`\", \"``\\n\\nPerhaps you start with Azure Redis Cache as your state store. You specify it with the following \", \"configuration:\\n\\n:::{custom-style=CodeBox} yaml  apiVersion: dapr.io/v1alpha1  kind: Component  metad\", \"ata:    name: statestore    namespace: default  spec:    type: state.redis    version: v1    metadat\", \"a:    - name: redisHost value: &lt;HOST&gt;    - name: redisPassword      value: &lt;PASSWORD&gt;   \", \" - name: enableTLS      value: &lt;bool&gt; # Optional. Allowed: true, false.    - name: failover   \", \"   value: &lt;bool&gt; # Optional. Allowed: true, false. :::\\n\\nIn the spec section, you configure Dap\", \"r to use the Redis Cache for state management. The section also contains component-specific metadata\", \". In this case, you can use it to configure additional Redis settings.\\n\\nAt a later time, the applica\", \"tion is ready to go to production. For the production environment, you may want to change your state\", \" management to Azure Table Storage. Azure Table Storage provides state management capabilities that \", \"are affordable and highly durable.\\n\\nAt the time of this writing, the following component types are p\", \"rovided by Dapr:\\n\\n| Component         | Description                                                 \", \"                                                                              |\\n|-------------------\", \"|---------------------------------------------------------------------------------------------------\", \"----------------------------------------|\\n| Service discovery | Used by the service invocation build\", \"ing block to integrate with the hosting environment to provide service-to-service discovery.        \", \"  |\\n| State             | Provides a uniform interface to interact with a wide variety of state stor\", \"e implementations.                                              |\\n| Pub/sub           | Provides a u\", \"niform interface to interact with a wide variety of message bus implementations.                    \", \"                          |\\n| Bindings          | Provides a uniform interface to trigger applicatio\", \"n events from external systems and invoke external systems with optional data payloads. |\\n| Middlewa\", \"re        | Allows custom middleware to plug into the request processing pipeline and invoke additio\", \"nal actions on a request or response.             |\\n| Secret stores     | Provides a uniform interfa\", \"ce to interact with external secret stores, including cloud, edge, commercial, open-source services.\", \"            |\\n\\nAs the jet completes its fly over of Dapr, you look back once more and can see how it\", \" connects together.\\n\\n## Sidecar architecture\\n\\nDapr exposes its building blocks and components throug\", \"h a sidecar architecture. A sidecar enables Dapr to run in a separate memory process or separate con\", \"tainer alongside your service. Sidecars provide isolation and encapsulation as they aren't part of t\", \"he service, but connected to it. This separation enables each to have its own runtime environment an\", \"d be built upon different programming platforms. Figure 2-4 shows a sidecar pattern.\\n\\nSidecar\\n\\nDapr \", \"API\\n\\ndapr\\n\\nComponent\\n\\n(Redis Cache)\\n\\nFigure 2-4. Sidecar architecture.\\n\\nThis pattern is named Sideca\", \"r because it resembles a sidecar attached to a motorcycle. In the previous figure, note how the Dapr\", \" sidecar is attached to your service to provide distributed application capabilities.\\n\\n## Hosting en\", \"vironments\\n\\nDapr has cross-platform support and can run in many different environments. These enviro\", \"nments include Kubernetes, a group of VMs, or edge environments such as Azure IoT Edge.\\n\\nFor local d\", \"evelopment, the easiest way to get started is with self-hosted mode. In self-hosted mode, the micros\", \"ervices and Dapr sidecars run in separate local processes without a container orchestrator such as K\", \"ubernetes. For more information, see download and install the Dapr CLI.\\n\\nFigure 2-5 shows an applica\", \"tion and Dapr hosted in two separate memory processes communicating via HTTP or gRPC.\\n\\nHTTP /\\n\\nPrima\", \"ry service\\n\\nYour\\n\\nPod\\n\\nContainer\\n\\nApplication\\n\\nCode\\n\\nApplication\\n\\nService\\n\\nInvocation\\n\\nPub/Sub\\n\\nStat\", \"e\\n\\nManagement\\n\\nSecrets\\n\\n@ Container\\n\\nFigure 2-5. Self-hosted Dapr sidecar.\\n\\nBy default, Dapr install\", \"s Docker containers for Redis and Zipkin to provide default state management and observability. If y\", \"ou don't want to install Docker on your local machine, you can even run Dapr in self-hosted mode wit\", \"hout any Docker containers. However, you must install default components such as Redis for state man\", \"agement and pub/sub manually.\\n\\nDapr also runs in containerized environments, such as Kubernetes. Fig\", \"ure 2-6 shows Dapr running in a separate side-car container along with the application container in \", \"the same Kubernetes pod.\\n\\nFigure 2-6. Kubernetes-hosted Dapr sidecar.\\n\\n## Dapr performance considera\", \"tions\\n\\nAs you've seen, Dapr exposes a sidecar architecture to decouple your application from distrib\", \"uted application capabilities. Invoking a Dapr operation requires at least one out-of-process networ\", \"k call. Figure 2-7 presents an example of a Dapr traffic pattern.\\n\\ndapr\\n\\nApp\\n\\n\\\"frontend\\\"\\n\\nApp\\n\\n\\\"back\", \"end\\\"\\n\\ndapr\\n\\nSidecar\\n\\nFigure 2-7. Dapr traffic patterns.\\n\\nLooking at the previous figure, one might q\", \"uestion the latency and overhead incurred for each call.\\n\\nThe Dapr team has invested heavily in perf\", \"ormance. A tremendous amount of engineering effort has gone into making Dapr efficient. Calls betwee\", \"n Dapr sidecars are always made with gRPC, which delivers high performance and small binary payloads\", \". In most cases, the additional overhead should be sub-millisecond.\\n\\nTo increase performance, develo\", \"pers can call the Dapr building blocks with gRPC.\\n\\ngRPC is a modern, high-performance framework that\", \" evolves the age-old remote procedure call (RPC) protocol. gRPC uses HTTP/2 for its transport protoc\", \"ol, which provides significant performance enhancements over HTTP RESTFul service, including:\\n\\n- Mul\", \"tiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits \", \"processing to one request/response message at a time.\\n- Bidirectional full-duplex communication for \", \"sending both client requests and server responses simultaneously.\\n- Built-in streaming enabling requ\", \"ests and responses to asynchronously stream large data sets.\\n\\nTo learn more, check out the gRPC over\", \"view from the Architecting Cloud-Native .NET Apps for Azure eBook.\\n\\n## Dapr and service meshes\\n\\nServ\", \"ice mesh is another rapidly evolving technology for distributed applications.\\n\\nA service mesh is a c\", \"onfigurable infrastructure layer with built-in capabilities to handle service-toservice communicatio\", \"n, resiliency, load balancing, and telemetry capture. It moves the responsibility for these concerns\", \" out of the services and into the service mesh layer. Like Dapr, a service mesh also follows a sidec\", \"ar architecture.\\n\\nFigure 2-8 shows an application that implements service mesh technology.\\n\\nmicroser\", \"vice\\n\\nSidecar\\n\\nSidecar microservice\\n\\nFigure 2-8. Service mesh with a side car.\\n\\nThe previous figure \", \"shows how messages are intercepted by a sidecar proxy that runs alongside each service. Each proxy c\", \"an be configured with traffic rules specific to the service. It understands messages and can route t\", \"hem across your services and the outside world.\\n\\nSo the question becomes, 'Is Dapr a service mesh?'.\", \"\\n\\nWhile both use a sidecar architecture, each technology has a different purpose. Dapr provides dist\", \"ributed application features. A service mesh provides a dedicated network infrastructure layer.\\n\\nAs \", \"each works at a different level, both can work together in the same application. For example, a serv\", \"ice mesh could provide networking communication between services. Dapr could provide application ser\", \"vices such as state management or actor services.\\n\\nFigure 2-9 shows an application that implements b\", \"oth Dapr and service mesh technology.\\n\\nmicroservice microservice\\n\\nlinkerd\\n\\nService A\\n\\nService mesh\\n\\n\", \"Service B\\n\\nFigure 2-9. Dapr and service mesh together.\\n\\nThe Dapr online documentation cover Dapr and\", \" service mesh integration.\\n\\n## Summary\\n\\nThis chapter introduced you to Dapr, a Distributed Applicati\", \"on Runtime.\\n\\nDapr is an open-source project sponsored by Microsoft with close collaboration from cus\", \"tomers and the open-source community.\\n\\nAt its core, Dapr helps reduce the inherent complexity of dis\", \"tributed microservice applications. It's built upon a concept of building block APIs. Dapr building \", \"blocks expose common distributed application capabilities, such as state management, service-to-serv\", \"ice invocation, and pub/sub messaging. Dapr components lie beneath the building blocks and provide t\", \"he concrete implementation for each capability. Applications bind to various components through conf\", \"iguration files.\\n\\nIn the next chapters, we present practical, hands-on instruction on how to use Dap\", \"r in your applications.\\n\\n## References\\n\\n- Dapr documentation\\n- Learning Dapr\\n- .NET Microservices: A\", \"rchitecture for Containerized .NET applications\\n- Architecting Cloud-Native .NET Apps for Azure\\n\\n## \", \"Get started with Dapr\\n\\nIn the first two chapters, you learned basic concepts about Dapr. It's time t\", \"o take it for a test drive . This chapter will guide you through preparing your local development en\", \"vironment and building two Dapr .NET applications.\\n\\n## Install Dapr into your local environment\\n\\nYou\", \"'ll start by installing Dapr on your development computer. Once complete, you can build and run Dapr\", \" applications in self-hosted mode.\\n\\n1. Install the Dapr CLI. It enables you to launch, run, and mana\", \"ge Dapr instances. It also provides debugging support.\\n2. Install Docker Desktop . If you're running\", \" on Windows, mak e sure that Docker Desktop for Windows is configured to use Linux containers. [!NOT\", \"E] By default, Dapr uses Docker containers to provide you the best out-of-the-box\\n3. experience. To \", \"run Dapr outside of Docker, you can skip this step and execute a slim initialization. The examples i\", \"n this chapter require you use Docker containers.\\n3. Initialize Dapr. This step sets up your develop\", \"ment environment by installing the latest Dapr binaries and container images.\\n4. Install the .NET 7 \", \"SDK.\\n\\nNow that Dapr is installed, it's time to build your first Dapr application!\\n\\n## Build your fir\", \"st Dapr application\\n\\nYou'll start by building a simple .NET Console application that consumes the Da\", \"pr state management building block.\\n\\n## Create the application\\n\\n1. Open up the command shell or term\", \"inal of your choice. You might consider the terminal capabilities in Visual Studio Code. Navigate to\", \" the root folder in which you want to build your application. Once there, enter the following comman\", \"d to create a new .NET Console application:\\n\\ndotnet new console -o DaprCounter\\n\\nThe command scaffold\", \"s a simple \\\"Hello World\\\" .NET application.\\n\\n1. Then, navigate into the new directory created by the \", \"previous command:\\n\\n## cd DaprCounter\\n\\n1. Run the newly created application using the dotnet run comm\", \"and. Doing so writes 'Hello World!' to the console screen:\\n\\n```\\ndotnet run\\n```\\n\\n## Add Dapr State Ma\", \"nagement\\n\\nNext, you'll use the Dapr state management building block to implement a stateful counter \", \"in the program.\\n\\nYou can invoke Dapr APIs across any development platform using Dapr's native suppor\", \"t for HTTP and gRPC. However, .NET Developers will find the Dapr .NET SDK more natural and intuitive\", \". It provides a strongly typed .NET client to call the Dapr APIs. The .NET SDK also tightly integrat\", \"es with ASP.NET Core.\\n\\n1. From the terminal window, add the Dapr.Client NuGet package to your applic\", \"ation:\\n1. Open the Program.cs file in your favorite editor and update its contents to the following \", \"code:\\n\\n```\\ndotnet add package Dapr.Client\\n```\\n\\n```\\nusing Dapr.Client const string storeName = \\\"state\", \"store\\\"; const string key = \\\"counter\\\" var daprClient = new DaprClientBuilder().Build(); var counter =\", \" await daprClient.GetStateAsync<int>(storeName, key) while ( true ) { Console.WriteLine($\\\"Counter = \", \"{counter++}\\\") await daprClient.SaveStateAsync(storeName, key, counter); await Task.Delay(1000); }\\n``\", \"`\\n\\nThe updated code implements the following steps:\\n\\n- First a new [`DaprClient`]{custom-style=Code}\", \" instance is instantiated. This class enables you to interact with the Dapr sidecar.\\n- From the stat\", \"e store, [`DaprClient.GetStateAsync`]{custom-style=Code} fetches the value for the [`counter`]{custo\", \"m-style=Code} key. If the key doesn't exist, the default value for [`int`]{custom-style=Code} (which\", \" is [`0`]{custom-style=Code}) is returned.\\n- The code then iterates, writing the [`counter`]{custom-\", \"style=Code} value to the console and saving an incremented value to the state store.\\n1. The Dapr CLI\", \" run command starts the application. It invokes the underlying Dapr runtime and enables both the app\", \"lication and Dapr sidecar to run together. If you omit the app-id , Dapr will generate a unique name\", \" for the application. The final segment of the command, dotnet run , instructs the Dapr runtime to r\", \"un the .NET application.\\n\\n[!IMPORTANT] Care must be taken to always pass an explicit app-id paramete\", \"r when consuming the state management building block. The block uses the application id value as a p\", \"refix for its\\n\\nstate key for each key/value pair. If the application id changes, you can no longer a\", \"ccess the previously stored state.\\n\\nNow run the application with the following command:\\n\\n```\\ndapr ru\", \"n --app-id DaprCounter dotnet run\\n```\\n\\nTry stopping and restarting the application. You'll see that \", \"the counter doesn't reset. Instead it continues from the previously saved state. The Dapr building b\", \"lock makes the application stateful.\\n\\nYou might be wondering, where exactly is the state stored?\\n\\n##\", \" Component configuration files\\n\\nWhen you first initialized Dapr for your local environment, it autom\", \"atically provisioned a Redis container. Dapr then configured the Redis container as the default stat\", \"e store component with a component configuration file, entitled statestore.yaml . Here's a look at i\", \"ts contents:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore spec: type\", \": state.redis version: v1 metadata: -name: redisHost value: localhost:6379 -name: redisPassword valu\", \"e: \\\"\\\" -name: actorStateStore value: \\\"true\\\"\\n```\\n\\nNote the format of the previous component configurat\", \"ion file:\\n\\n- Each component has a name. In the sample above, the component is named statestore . We \", \"used that name in our first code example to tell the Dapr sidecar which component to use.\\n- Each com\", \"ponent configuration file has a spec section. It contains a type field that specifies the component \", \"type. The version field specifies the component version. The metadata field\\n\\ncontains information th\", \"at the component requires, such as connection details and other settings. The metadata values will v\", \"ary for the different types of components.\\n\\nA Dapr sidecar can consume any Dapr component configured\", \" in your application. But, what if you had an architectural justification to limit the accessibility\", \" of a component? How could you restrict the Redis component to Dapr sidecars running only in a produ\", \"ction environment?\\n\\nTo do so, you could define a namespace for the production environment. You might\", \" name it production . In self-hosted mode, you specify the namespace of a Dapr sidecar by setting th\", \"e NAMESPACE environment variable. When configured, the Dapr sidecar will only load the components th\", \"at match the namespace. For Kubernetes deployments, the Kubernetes namespace determines the componen\", \"ts that are loaded. The following sample shows the Redis component placed in a production namespace.\", \" Note the namespace declaration in the metadata element:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Com\", \"ponent metadata: name: statestore namespace: production spec: type: state.redis version: v1 metadata\", \": -name: redisHost value: localhost:6379 -name: redisPassword value: \\\"\\\" -name: actorStateStore value\", \": \\\"true\\\"\\n```\\n\\n## Important\\n\\nA namespaced component is only accessible to applications running in the\", \" same namespace. If your Dapr application fails to load a component, make sure that the application \", \"namespace matches the component namespace. This can be especially tricky in self-hosted mode where t\", \"he application namespace is stored in a NAMESPACE environment variable.\\n\\nIf needed, you could furthe\", \"r restrict a component to a particular application. Within the production namespace, you may want to\", \" limit access of the Redis cache to only the DaprCounter application. You do so by specifying scopes\", \" in the component configuration. The following example shows how to restrict access to the Redis sta\", \"testore component to the application DaprCounter in the production namespace:\\n\\n```\\napiVersion: dapr.\", \"io/v1alpha1 kind: Component metadata: name: statestore namespace: production spec: type: state.redis\", \" version: v1 metadata: -name: redisHost\\n```\\n\\n| - value:   | value: localhost:6379 name: redisPasswor\", \"d \\\"\\\"   |\\n|------------|------------------------------------------------|\\n\\n## Build a multi-container\", \" Dapr application\\n\\nIn the first example, you created a simple .NET console application that ran side\", \"-by-side with a Dapr sidecar. Modern distributed applications, however, often consist of many moving\", \" parts. They can simultaneously run independent microservices. These modern applications are typical\", \"ly containerized and require container orchestration tools such as Docker Compose or Kubernetes.\\n\\nIn\", \" the next example, you'll create a multi -container application. You'll also use the Dapr service in\", \"vocation building block to communicate between services. The solution will consist of a web applicat\", \"ion that retrieves weather forecasts from a web API. They will each run in a Docker container. You'l\", \"l use Docker Compose to run the container locally and enable debugging capabilities .\\n\\nMake sure you\", \"'ve configured your local environment for Dapr and installed the .NET 7 Development Tools (instructi\", \"ons are available at the beginning of this chapter).\\n\\nAdditionally, you'll need to complete this sam\", \"ple using Visual Studio 2022 with the ASP.NET and web development workload installed.\\n\\n## Create the\", \" application\\n\\n1. In Visual Studio 2022, create an ASP.NET Core Web App project:\\n\\nCreate a new projec\", \"t\\n\\nRecent project templates\\n\\nA list of your recently accessed templates will be displayed here.\\n\\nSea\", \"rch for templates (Alt+S)\\n\\nAll languages\\n\\nAll platforms\\n\\nAll project types\\n\\n-\\n\\n1. Name your project \", \"MyFrontEnd and your solution DaprMultiContainer :\\n\\nP\\n\\nX\\n\\nConfigure your new project\\n\\nASP.NET Core We\", \"b App c*\\n\\nProject name\\n\\nMyFrontEnd\\n\\nLocation\\n\\nC:\\\\ Git\\\\\\n\\nSolution\\n\\nCreate new solution\\n\\nSolution name\", \" i\\n\\nDaprMultiContainer\\n\\nPlace solution and project in the same directory\\n\\nLinux macos\\n\\nWindows\\n\\nClou\", \"d\\n\\nService\\n\\nWeb\\n\\n1. In the final dialog, keep the defaults. Don't select Enable Docker Support . You\", \"'ll add Docker support later.\\n\\nAdditional information\\n\\nASP.NET Core Web App c*\\n\\nFramework f\\n\\n.NET 6.\", \"0 (Long-term support)\\n\\nAuthentication type O\\n\\nNone\\n\\n\\u2022 Configure for HTTPS O\\n\\nL Enable Docker \\u00ae\\n\\nDock\", \"er OS O\\n\\nLinux\\n\\nLinux macOS\\n\\nWindows\\n\\nCloud\\n\\nService\\n\\nWeb\\n\\n1. For the backend, add an ASP.NET Core W\", \"eb API project to the same solution:\\n\\n-\\n\\nAdd a new project\\n\\nRecent project templates a ASP.NET Core \", \"Web App\\n\\nSearch for templates (Alt+S)\\n\\nAll languages\\n\\nAll platforms\\n\\n-\\n\\nAll project types\\n\\n-\\n\\n1. Nam\", \"e the project MyBackEnd :\\n1. By default, a Dapr sidecar relies on the network boundary to limit acce\", \"ss to its public API. So, clear the checkbox for Configure for HTTPS :\\n\\n&gt; [!IMPORTANT] &gt; If yo\", \"u leave the **Configure for HTTPS** checkbox checked, the generated ASP.NET Core API project include\", \"s middleware to redirect client requests to the HTTPS endpoint. This breaks communication between th\", \"e Dapr sidecar and your application, unless you explicitly configure the use of HTTPS when running y\", \"our Dapr application. To enable the Dapr sidecar to communicate over HTTPS, include the [`--appssl`]\", \"{custom-style=Code} flag in the Dapr command to start the application. Also specify the HTTPS port u\", \"sing the [`--app-port`]{custom-style=Code} parameter. The remainder of this walkthrough uses plain H\", \"TTP communication between the sidecar and the application, and requires you to clear the **Configure\", \" for HTTPS** checkbox.\\n\\n## Add Dapr service invocation\\n\\nNow, you'll configure communication between \", \"the services using Dapr service invocation building block . You'll enable the web app to retrieve we\", \"ather forecasts from the web API. The service invocation building block features many benefits. It i\", \"ncludes service discovery, automatic retries, message encryption (using mTLS), and improved observab\", \"ility. You'll use the Dapr .NET SDK to invoke the service invocation API on the Dapr sidecar.\\n\\n1. In\", \" Visual Studio, open the Package Manager Console ( Tools &gt; NuGet Package Manager &gt; Package Man\", \"ager Console ) and make sure that MyFrontEnd is the default project. From the console, add the Dapr.\", \"AspNetCore NuGet package to the project:\\n1. In the MyFrontEnd project, open the Program.cs file and \", \"add a call to builder.Services.AddDaprClient :\\n\\n```\\nInstall-Package Dapr.AspNetCore\\n```\\n\\n```\\nvar bui\", \"lder = WebApplication.CreateBuilder(args) // Add services to the container. builder.Services.AddDapr\", \"Client(); builder.Services.AddRazorPages() // ...\\n```\\n\\nThe [`AddDaprClient`]{custom-style=Code} call\", \" registers the [`DaprClient`]{customstyle=Code} class with the ASP.NET Core dependency injection sys\", \"tem. With the client registered, you can now inject an instance of [`DaprClient`]{custom-style=Code}\", \" into your service code to communicate with the Dapr sidecar, building blocks, and components.\\n\\n1. A\", \"dd a new C# class file named WeatherForecast to the MyFrontEnd project:\\n1. Open the Index.cshtml.cs \", \"file in the Pages folder, and replace its contents with the following code:\\n\\n```\\nnamespace MyFrontEn\", \"d public class WeatherForecast { public DateTime Date { get ; set ; public int TemperatureC { get ; \", \"set ; public int TemperatureF { get ; set ; public string Summary { get ; set ; } = string.Empty; }\\n\", \"```\\n\\n```\\nusing Dapr.Client; using Microsoft.AspNetCore.Mvc.RazorPages namespace MyFrontEnd.Pages pub\", \"lic class IndexModel : PageModel { private readonly DaprClient _daprClient public IndexModel(DaprCli\", \"ent daprClient) { _daprClient = daprClient; public async Task OnGet() { var forecasts = await _daprC\", \"lient.InvokeMethodAsync<IEnumerable<WeatherForecast>>( HttpMethod.Get, \\\"MyBackEnd\\\", \\\"weatherforecast\", \"\\\") ViewData[\\\"WeatherForecastData\\\"] = forecasts; } }\\n```\\n\\nYou add Dapr capabilities into the web app \", \"by injecting the [`DaprClient`]{customstyle=Code} class into [`IndexModel`]{custom-style=Code} const\", \"ructor. In the [`OnGet`]{custom-style=Code} method, you call the backend API service with the Dapr s\", \"ervice invocation building block. The [`OnGet`]{custom-style=Code} method is invoked\\n\\nAdd Container \", \"Orchestrator Support\\n\\nContainer orchestrator:\\n\\nDocker Compose\\n\\n```\\nwhenever a user visits the home p\", \"age. You use the [`DaprClient.InvokeMethodAsync`]{custom-style=Code} method to invoke the [`weatherf\", \"orecast`]{custom-style=Code} method of the [`MyBackEnd`]{custom-style=Code} service. You'll configur\", \"e the web API to use [`MyBackEnd`]{custom-style=Code} as its application ID later on when configurin\", \"g it to run with Dapr. Finally, the service response is saved in view data.\\n```\\n\\n1. Replace the cont\", \"ents of the Index.cshtml file in the Pages folder, with the following code. It displays the weather \", \"forecasts stored in the view data to the user:\\n\\n```\\n@page @model IndexModel @{ ViewData[\\\"Title\\\"] = \\\"\", \"Home page\\\"; <div class=\\\"text-center\\\"> <h1 class=\\\"display-4\\\">Welcome</h1> <p>Learn about <a href=\\\"htt\", \"ps://learn.microsoft.com/aspnet/core\\\">building Web apps with ASP.NECore</a>.</p> @foreach (var forec\", \"ast in (IEnumerable<WeatherForecast>)ViewData[\\\"WeatherForecastData\\\"]!) { <p>The forecast for @foreca\", \"st.Date is @forecast.Summary!</p> } </div>\\n```\\n\\n## Add container support\\n\\nIn the final part of this \", \"example, you'll add container support and run the solution using Docker Compose.\\n\\n1. Right-click the\", \" MyFrontEnd project, and choose Add &gt; Container Orchestrator Support\\u2026 . The Add Container Orchest\", \"rator Support dialog appears:\\n\\nChoose **Docker Compose**.\\n\\n1. In the next dialog, select Linux as th\", \"e Target OS:\\n\\nDocker Support Options\\n\\nTarget OS:\\n\\nLinux\\n\\nWindows\\n\\nVisual Studio creates a *docker-co\", \"mpose.yml*file and a *.dockerignore* file in the **docker-compose** folder in the solution:\\n\\nSolutio\", \"n Explorer\\n\\nSearch Solution Explorer (Ctrl+;)\\n\\nFa Solution 'DaprMultiContainer' (B of 3 projects)\\n\\nY\", \"ML\\n\\ne] MyBackEnd\\n\\nC# Program.cs\\n\\nMyFrontEnd\\n\\n\\u2022 wwwroot\\n\\n\\u2022 Pages\\n\\n\\u2022 Dockerfile\\n\\nC# Program.cs\\n\\n\\u2022 C# W\", \"eatherForecast.cs\\n\\n* 4 x\\n\\nThe *docker-compose.yml* file has the following content:\\n\\n```\\nversion: '3.\", \"4 services: myfrontend: image: ${DOCKER_REGISTRY-}myfrontend build: context: . dockerfile: MyFrontEn\", \"d/Dockerfile\\n```\\n\\nThe *.dockerignore* file contains file types and extensions that you don't want Do\", \"cker to include in the container. These files are associated with the development environment and so\", \"urce control and not the app or service you're deploying.\\n\\nD\\n\\nD\\n\\n```\\nIn the root of the *MyFrontEnd*\", \" project directory, a new *Dockerfile* was created. A *Dockerfile* is a sequence of commands that ar\", \"e used to build an image. For more information, see [Dockerfile reference](https://docs.docker.com/e\", \"ngine/reference/builder).\\n```\\n\\nThe *Dockerfile* contains the following commands:\\n\\n```\\nFROM mcr.micro\", \"soft.com/dotnet/aspnet:7.0 AS base WORKDIR /app EXPOSE 80 EXPOSE 44 FROM mcr.microsoft.com/dotnet/sd\", \"k:7.0 AS build WORKDIR /src COPY [\\\"MyFrontEnd/MyFrontEnd.csproj\\\", \\\"MyFrontEnd/\\\"] RUN dotnet restore \", \"\\\"MyFrontEnd/MyFrontEnd.csproj\\\" COPY . . WORKDIR \\\"/src/MyFrontEnd\\\" RUN dotnet build \\\"MyFrontEnd.cspro\", \"j\\\" -c Release -o /app/buil FROM build AS publish RUN dotnet publish \\\"MyFrontEnd.csproj\\\" -c Release -\", \"o /app/publis FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\\\"dotnet\", \"\\\", \\\"MyFrontEnd.dll\\\"]\\n```\\n\\nThe preceding *Dockerfile* sequentially performs the following steps when \", \"invoked:\\n\\n```\\n1. Pulls the [`mcr.microsoft.com/dotnet/aspnet:7.0`]{custom-style=Code} image and name\", \"s it [`base`]{custom-style=Code}. 2. Sets the working directory to */app*. 3. Exposes port [`80`]{cu\", \"stom-style=Code} and [`443`]{custom-style=Code}. 4. Pulls the [`mcr.microsoft.com/dotnet/sdk:7.0`]{c\", \"ustom-style=Code} image and names it [`build`]{custom-style=Code}. 5. Sets the working directory to \", \"*/src*. 6. Copies the _MyFrontEnd/MyFrontEnd.csproj_ to a new directory named *MyFrontEnd/*. 7. Call\", \"s [[`dotnet restore`]{custom-style=Code}](https://docs.microsoft.com/enus/dotnet/core/tools/dotnet-r\", \"estore) on the project. 8. Copies everything from the root directory into the image's root. 9. Sets \", \"the working directory to _/src/MyFrontEnd_. 10. Calls [[`dotnet build`]{custom-style=Code}](https://\", \"docs.microsoft.com/enus/dotnet/core/tools/dotnet-build) on the project. - Targeting the **Release** \", \"configuration and outputs to */app/build*. 11. Initializes a new build stage from the existing [`bui\", \"ld`]{custom-style=Code} base image and names it [`publish`]{custom-style=Code}. 12. Calls [`dotnet p\", \"ublish`]{custom-style=Code} on the project. - Targeting the **Release** configuration and outputs to\", \" */app/publish*. 13. Initializes a new build stage from the existing [`publish`]{custom-style=Code} \", \"base image and names it [`final`]{custom-style=Code}. 14. Sets the working directory to */app*. 15. \", \"Copies the [`/app/publish`]{custom-style=Code} directory from the [`publish`]{custom-style=Code} ima\", \"ge into the root of the [`final`]{custom-style=Code} image. 16. Sets the entry point as the image to\", \" [`dotnet`]{custom-style=Code} and passes the [`MyFrontEnd.dll`]{custom-style=Code} as an arg.\\n```\\n\\n\", \"1. In the MyBackEnd web API project, right-click on the project node, and choose Add &gt; Container \", \"Orchestrator Support\\u2026 . Choose Docker Compose , and then select Linux again as the target OS.\\n\\nIn th\", \"e root of the MyBackEnd project directory, a new Dockerfile was created. The Dockerfile contains the\", \" following commands:\\n\\n```\\nFROM mcr.microsoft.com/dotnet/aspnet:7.0 AS base WORKDIR /app EXPOSE 8 FRO\", \"M mcr.microsoft.com/dotnet/sdk:7.0 AS build WORKDIR /src COPY [\\\"MyBackEnd/MyBackEnd.csproj\\\", \\\"MyBack\", \"End/\\\"] RUN dotnet restore \\\"MyBackEnd/MyBackEnd.csproj\\\" COPY . . WORKDIR \\\"/src/MyBackEnd\\\" RUN dotnet \", \"build \\\"MyBackEnd.csproj\\\" -c Release -o /app/buil FROM build AS publish RUN dotnet publish \\\"MyBackEnd\", \".csproj\\\" -c Release -o /app/publis FROM base AS final WORKDIR /app COPY --from=publish /app/publish \", \". ENTRYPOINT [\\\"dotnet\\\", \\\"MyBackEnd.dll\\\"]\\n```\\n\\nOpen the *docker-compose.yml* file again and examine i\", \"ts contents. Visual Studio has updated the **Docker Compose** file. Now both services are included:\\n\", \"\\n```\\nversion: '3.4 services: myfrontend: image: ${DOCKER_REGISTRY-}myfrontend build: context: . dock\", \"erfile: MyFrontEnd/Dockerfil mybackend: image: ${DOCKER_REGISTRY-}mybackend build: context: . docker\", \"file: MyBackEnd/Dockerfile\\n```\\n\\n1. To use Dapr building blocks from inside a containerized applicati\", \"on, you'll need to add the Dapr sidecars containers to your Compose file. Carefully update the conte\", \"nt of the dockercompose.yml file to match the following example. Pay close attention to the formatti\", \"ng and spacing and don't use tabs.\\n\\n```\\nversion: '3.4 services: myfrontend: image: ${DOCKER_REGISTRY\", \"-}myfrontend build: context: . dockerfile: MyFrontEnd/Dockerfile ports: - \\\"51000:50001 myfrontend-da\", \"pr: image: \\\"daprio/daprd:latest\\\" command: [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyFrontEnd\\\", \\\"-app-port\\\", \\\"80\\\" ] \", \"depends_on:\\n```\\n\\n```\\n- myfrontend network_mode: \\\"service:myfrontend mybackend: image: ${DOCKER_REGIS\", \"TRY-}mybackend build: context: . dockerfile: MyBackEnd/Dockerfile ports: - \\\"52000:50001 mybackend-da\", \"pr: image: \\\"daprio/daprd:latest\\\" command: [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyBackEnd\\\", \\\"-app-port\\\", \\\"80\\\" ] d\", \"epends_on: - mybackend network_mode: \\\"service:mybackend\\\"\\n```\\n\\nIn the updated file, we've added [`myf\", \"rontend-dapr`]{custom-style=Code} and [`mybackend-dapr`]{custom-style=Code} sidecars for the [`myfro\", \"ntend`]{customstyle=Code} and [`mybackend`]{custom-style=Code} services respectively. In the updated\", \" file, pay close attention to the following changes:\\n\\n- The sidecars use the [`daprio/daprd:latest`]\", \"{custom-style=Code} container image. The use of the [`latest`]{custom-style=Code} tag isn't recommen\", \"ded for production scenarios. For production, it's better to use a specific version number.\\n- Each s\", \"ervice defined in the Compose file has its own network namespace for network isolation purposes. The\", \" sidecars use [`network_mode: \\\"service:...\\\"`]{customstyle=Code} to ensure they run in the same netwo\", \"rk namespace as the application. Doing so allows the sidecar and the application to communicate usin\", \"g [`localhost`]{customstyle=Code}.\\n- The ports on which the Dapr sidecars are listening for gRPC com\", \"munication (by default 50001) must be exposed to allow the sidecars to communicate with each other.\\n\", \"1. Run the solution (F5 or Ctrl+F5) to verify that it works as expected. If everything is configured\", \" correctly, you should see the weather forecast data:\\n\\nlE Home page - MyFrontEnd\\n\\n+\\n\\n&lt; &gt; C a l\", \"ocalhost:59782\\n\\nMyFrontEnd Home Privacy\\n\\n\\u00a9 2021 - MyFrontEnd - Privacy\\n\\nRunning locally with Docker \", \"Compose and Visual Studio, you can set breakpoints and debug into the application. For production sc\", \"enarios, it's recommended to host your application in Kubernetes. This book includes an accompanying\", \" reference application, [eShopOnDapr](https://github.com/dotnet-architecture/eShopOnDapr), that cont\", \"ains scripts to deploy to Kubernetes.\\n\\nTo learn more about the Dapr service invocation building bloc\", \"k used in this walkthrough, refer to [chapter 6](#the-dapr-service-invocation-building-blo).\\n\\n## Sum\", \"mary\\n\\nIn this chapter, you had an opportunity to test drive Dapr. Using the Dapr .NET SDK, you saw h\", \"ow Dapr integrates with the .NET application platform.\\n\\nThe first example was a simple, stateful, .N\", \"ET Console application that used the Dapr state management building block.\\n\\nThe second example invol\", \"ved a multi-container application running in Docker. By using Visual Studio with Docker Compose, you\", \" experienced the familiar F5 debugging experience available across all .NET apps.\\n\\nYou also got a cl\", \"oser look at Dapr component configuration files. They configure the actual infrastructure implementa\", \"tion used by the Dapr building blocks. You can use namespaces and scopes to restrict component acces\", \"s to particular environments and applications.\\n\\nIn the upcoming chapters, you'll dive deep into the \", \"building blocks offered by Dapr.\\n\\n## References\\n\\n- Dapr documentation - Getting started\\n- eShopOnDap\", \"r\\n\\n## Traffic Control sample application\\n\\nIn the first chapters, you've learned about basic Dapr con\", \"cepts. You saw how Dapr can help you and your team construct distributed applications while reducing\", \" architectural and operational complexity. This chapter introdu ces the sample application that you'\", \"ll use to explore the Dapr building blocks. The application targets .NET 7 and uses the latest C# 11\", \" language features.\\n\\n## Note\\n\\nDownload the sample application code from the Dapr Traffic Control Git\", \"Hub repo. This repository contains a detailed description on how you can run the sample application \", \"on your machine.\\n\\nThe Traffic Control sample application simulates a highway traffic control system.\", \" Its purpose is to detect speeding vehicles and send the offending driver a fine notice. These syste\", \"ms actually exist in real life and here's how they work. A set of cameras (one above each lane) is p\", \"laced at the beginning and end of a highway stretch (say 10 kilometers) without on- or off-ramps. As\", \" a vehicle passes underneath a camera, it takes a photograph of the vehicle. Using Optical Character\", \" Recognition (OCR) software, it extracts the license number of the vehicle from the photo. Using the\", \" entry- and exittimestamp of each vehicle, the system calculates the average speed of that vehicle. \", \"If the average speed is above the maximum speed limit for that highway stretch, the system retrieves\", \" the driver information and automatically sends a fine notice.\\n\\nAlthough the simulation is simple, r\", \"esponsibilities within the system are separated into several microservices. Figure 4.1 shows an over\", \"view of the services that are part of the application:\\n\\nCamera\\n\\nSimulation\\n\\nService\\n\\n/entrycam\\n\\n/col\", \"lectfine\\n\\n/vehicleinfo\\n\\nInterval\\n\\nCamera\\n\\nSimulation\\n\\nPOST /entrycam\\n\\nFigure 4-1. The services in th\", \"e sample application.\\n\\nStore\\n\\n- The Camera Simulation is a console application that simulates vehicl\", \"es and sends messages to the TrafficControl service. Every simulated car invokes both the entry and \", \"exit service endpoints.\\n- The TrafficControl service is an ASP.NET Core Web API application that exp\", \"oses the /entrycam and /exitcam endpoints. Invoking an endpoint simulates a car passing under one of\", \" the entryor exit-cameras respectively. The request message payload simply contains the license plat\", \"e of the car (no actual OCR is implemented).\\n- The FineCollection service is an ASP.NET Core Web API\", \" application that offers 1 endpoint: /collectfine . Invoking this endpoint will send a fine notice t\", \"o the driver of the speeding vehicle. The payload of the request contains all the information about \", \"the speeding violation.\\n\\nFine\\n\\n- The VehicleRegistration service is an ASP.NET Core Web API applicat\", \"ion that offers 1 endpoint: /vehicleinfo/{licensenumber} . It's used for obtaining vehicle - and own\", \"er-information for a speeding vehicle based on the license number sent in the URL (for example, /veh\", \"icleinfo/RV752-S ). Send email\\n\\nThe sequence diagram in figure 4.2 shows the simulation flow:\\n\\nFigur\", \"e 4-2. Sequence diagram of the simulation flow.\\n\\nThe services communicate by directly i nvoking each\", \" other's APIs. This design works fine, but it has some drawbacks.\\n\\nRandom\\n\\nTraffic Control\\n\\nService\\n\", \"\\nFine Collection\\n\\nService\\n\\nVehicle Registration\\n\\nService\\n\\nThe biggest challenge is that the call-cha\", \"in will break if one of the services is off-line. Decoupling services by replacing direct calls with\", \" asynchronous messaging would solve this issue. Asynchronous messaging is typically implemented with\", \" a message broker like RabbitMQ or Azure Service Bus.\\n\\nAnother drawback is that the vehicle state fo\", \"r every vehicle is stored in memory in the TrafficControl service. This state is lost when the servi\", \"ce is restarted after an update or a crash. To increase system durability, state should be stored ou\", \"tside the service.\\n\\n## Using Dapr building blocks\\n\\nOne of the goals of Dapr is to provide cloud-nati\", \"ve capabilities for microservices applications. The Traffic Control application uses Dapr building b\", \"locks to increase robustness and mitigate the design drawbacks described in the previous paragraph. \", \"Figure 4.shows a Dapr-enabled version of the traffic control application:\\n\\nFigure 4-3. Traffic Contr\", \"ol application with Dapr building blocks.\\n\\n1. Service invocation The Dapr service invocation buildin\", \"g block handles request/response communication between the FineCollectionService and the VehicleRegi\", \"strationService. Because the call is a query to retrieve required data to complete the operation, a \", \"synchronous call is acceptable here. The service invocation building block provides service discover\", \"y. The FineCollection service no longer has to know where the VehicleRegistration service lives. It \", \"also implements automatic retries if the VehicleRegistration service is off-line.\\n2. Publish &amp; s\", \"ubscribe The publish and subscribe building block handles asynchronous messaging for sending speedin\", \"g violations from the TrafficControl service to the FineCollectionService. This implementation decou\", \"ples the TrafficControl and FineCollection service. If the FineCollectionService were to become temp\", \"orarily unavailable, data would accumulate in the queue and resume processing at a later time. Rabbi\", \"tMQ is the current message broker that transports messages from the producers to the consumers. As t\", \"he Dapr pub/sub building block abstracts the message broker, developers don't need to learn the deta\", \"ils of the RabbitMQ client library. Switching to another message broker doesn't r equire code change\", \"s, only configuration.\\n3. State management The TrafficControl service uses the state management buil\", \"ding block to persist vehicle state outside of the service in a Redis cache. As with pub/sub, develo\", \"pers don't need to learn Redis specific APIs. Switching to another data store requires no code chang\", \"es.\\n4. Output binding The FineCollection service sends fines to the owners of speeding vehicles by e\", \"mail. The Dapr output binding for SMTP abstracts the email transmission using the SMTP protocol.\\n5. \", \"Input binding The CameraSimulation sends messages with simulated car info to the TrafficControl serv\", \"ice using the MQTT protocol. It uses a .NET MQTT library for sending messages to Mosquitto - a light\", \"weight MQTT broker. The TrafficControl service uses the Dapr input binding for MQTT to subscribe to \", \"the MQTT broker and receive messages.\\n6. Secrets management The FineCollectionService needs credenti\", \"als for connecting to the smtp server and a license-key for a fine calculator component it uses inte\", \"rnally. It uses the secrets management building block to obtain the credentials and the license-key.\", \"\\n\\ncamera\\n\\nSimulation\\n\\nMosquitto\\n\\nVehicleRegistered\\n\\nRandom\\n\\nInterval\\n\\nVehicleRegistered\\n\\n+\\n\\ndapr\\n\\nSi\", \"decar\\n\\nVehicleRegistered\\n\\nPOST /entrycam\\n\\nStore vehicle state\\n\\nStore vehicle state\\n\\n7. Actors The Tr\", \"afficControlService has an alternative implementation based on Dapr actors. In this implementation, \", \"the TrafficControl service creates a new actor for every vehicle that is registered by the entry cam\", \"era. The license number of the vehicle forms the unique actor Id. The actor encapsulates the vehicle\", \" state, which it persists in the Redis cache. When a vehicle is registered by the exit camera, it in\", \"vokes the actor. The actor then calculate the average speed and possibly issue a speeding violation.\", \"\\n\\nSpeeding Violation\\n\\nFigure 4.4 shows a sequence diagram of the flow of the simulation with all the\", \" Dapr building blocks in place: Calculate Fine invoke vehilcleinto/KL-714-V\\n\\ninvoke vehicleinfo/KL-7\", \"14-V\\n\\nFigure 4-4. Sequence diagram of simulation flow with Dapr building blocks.\\n\\nThe rest of this b\", \"ook features a chapter for each of the Dapr building blocks. Each chapter explains in detail how the\", \" building block works, its configuration, and how to use it. Each chapter explains how the Traffic C\", \"ontrol sample application uses the building block.\\n\\n## Hosting\\n\\nThe Traffic Control sample applicati\", \"on can run in self-hosted mode or in Kubernetes.\\n\\n## Self-hosted mode\\n\\nThe sample repository contain\", \"s PowerShell scripts to start the infrastructure services (Redis, RabbitMQ, and Mosquitto) as Docker\", \" containers on your machine. They're located in the src/Infrastructure folder. For every application\", \" service in the solution, the repository contains a separate folder. Each of these folders contains \", \"a start-selfhosted.ps1 PowerShell script to start the service with Dapr.\\n\\nTraffic\\n\\nControl\\n\\nService\\n\", \"\\nRedis\\n\\nRabbitMQ\\n\\ndapi\\n\\nSidecar\\n\\nFine\\n\\nCollection\\n\\nService dap\\n\\nSidecar\\n\\nVehicle\\n\\nRegistration\\n\\nServ\", \"ice\\n\\nMailDev\\n\\n## Kubernetes\\n\\nThe src/k8s folder in the sample repository contains the Kubernetes man\", \"ifest files to run the application (including the infrastructure services) with Dapr in Kubernetes. \", \"This folder also contains a start.ps1 and stop.ps1 PowerShell script to start and stop the solution \", \"in Kubernetes. All services will run in the dapr-trafficcontrol namespace.\\n\\n## Summary\\n\\nThe Traffic \", \"Control sample application is a microservices application that simulates a highway speed trap.\\n\\nThe \", \"application uses several Dapr building blocks to make it robust and cloud-native. The domain is kept\", \" simple to keep the focus on Dapr.\\n\\nThe application will be used in the following chapters that focu\", \"s on Dapr building block.\\n\\n## References\\n\\n- Dapr Traffic Control Sample\\n\\n## The Dapr state managemen\", \"t building block\\n\\nDistributed applications are composed of independent services. While each service \", \"should be stateless, some services must track state to complete business operations. Consider a shop\", \"ping basket service for an eCommerce site. If the service can't track state, the customer could lose\", \" the shopping basket content by leaving the website, resulting in a lost sale and an unhappy custome\", \"r experience. For these scenarios, state needs to be persisted to a distributed state store. The Dap\", \"r state management building block simplifies state tracking and offers advanced features across vari\", \"ous data stores.\\n\\nTo try out the state management building block, have a look at the counter applica\", \"tion sample in chapter 3.\\n\\n## What it solves\\n\\nTracking state in a distributed application can be cha\", \"llenging. For example:\\n\\n- The application may require different types of data stores.\\n- Different co\", \"nsistency levels may be required for accessing and updating data.\\n- Multiple users may update data a\", \"t the same time, requiring conflict resolution.\\n- Services must retry any short-lived transient erro\", \"rs that occur while interacting with the data store.\\n\\nThe Dapr state management building block addre\", \"sses these challenges. It streamlines tracking state without dependencies or a learning curve on thi\", \"rd-party storage SDKs.\\n\\n## Important\\n\\nDapr state management offers a key/value API. The feature does\", \"n't support relational or graph data storage.\\n\\n## How it works\\n\\nThe application interacts with a Dap\", \"r sidecar to store and retrieve key/value data. Under the hood, the sidecar API consumes a configura\", \"ble state store component to persist data. Developers can choose from a growing collection of suppor\", \"ted state stores that include Azure Cosmos DB, SQL Server, and Cassandra.\\n\\nThe API can be called wit\", \"h either HTTP or gRPC. Use the following URL to call the HTTP API:\\n\\n```\\nhttp://localhost:<dapr-port>\", \"/v1.0/state/<store-name>/\\n```\\n\\n- &lt;dapr-port&gt; : the HTTP port that Dapr listens on.\\n- &lt;store\", \"-name&gt; : the name of the state store component to use.\\n\\nFigure 5-1 shows how a Dapr-enabled shopp\", \"ing basket service stores a key/value pair using the Dapr state store component named statestore .\\n\\n\", \":::image type='content' source='./media/state -management/state-managementflow.png' alt -text='Diagr\", \"am of storing a key/value pair in a Dapr state store.':::\\n\\nFigure 5-1. Storing a key/value pair in a\", \" Dapr state store.\\n\\nNote the steps in the previous figure:\\n\\n1. The basket service calls the state ma\", \"nagement API on the Dapr sidecar. The body of the request encloses a JSON array that can contain mul\", \"tiple key/value pairs.\\n2. The Dapr sidecar determines the state store based on the component configu\", \"ration file. In this case, it's a Redis cache state store.\\n3. The sidecar persists the data to the R\", \"edis cache.\\n\\nRetrieving the stored data is a similar API call. In the example below, a curl command \", \"retrieves the data by calling the Dapr sidecar API:\\n\\n```\\ncurl http://localhost:3500/v1.0/state/state\", \"store/basket1\\n```\\n\\nThe command returns the stored state in the response body:\\n\\n```\\n{ \\\"items\\\": [ { \\\"i\", \"temId\\\": \\\"DaprHoodie\\\", \\\"quantity\\\": 1 } ], \\\"customerId\\\": 1 }\\n```\\n\\nThe following sections explain how t\", \"o use the more advanced features of the state management building block.\\n\\n## Consistency\\n\\nThe CAP th\", \"eorem is a set of principles that apply to distributed systems that store state. Figure 5-2 shows th\", \"e three properties of the CAP theorem.\\n\\n:::image type='content' source='./media/state -management/ca\", \"ptheorem.png' alt -text='The CAP theorem.':::\\n\\nFigure 5-2. The CAP theorem.\\n\\nThe theorem states that\", \" distributed data systems offer a trade-off between consistency, availability, and partition toleran\", \"ce. And, that any datastore can only guarantee two of the three properties :\\n\\n- Consistency ( C ). E\", \"very node in the cluster responds with the most recent data, even if the system must block the reque\", \"st until all replicas update. If you query a 'consistent system' for an item that is currently updat\", \"ing, you won't get a response until all replicas successfully update. However, you'll always receive\", \" the most current data.\\n- Availability ( A ). Every node returns an immediate response, even if that\", \" response isn't the most recent data. If you query an 'available system' for an item that is updatin\", \"g, you'l l get the best possible answer the service can provide at that moment.\\n- Partition Toleranc\", \"e ( P ). Guarantees the system continues to operate even if a replicated data node fails or loses co\", \"nnectivity with other replicated data nodes.\\n\\nDistributed applications must handle the P property. A\", \"s services communicate among each other with network calls, network disruptions ( P ) will occur. Wi\", \"th that in mind, distributed applications must either be AP or CP .\\n\\nAP applications choose availabi\", \"lity over consistency. Dapr supports this choice with its eventual consistency strategy. Consider an\", \" underlying data store, such as Azure CosmosDB, which stores redundant data on multiple replicas. Wi\", \"th eventual consistency, the state store writes the update to one replica and completes the write re\", \"quest with the client. After this time, the store will asynchronously update its replicas. Read requ\", \"ests can return data from any of the replicas, including those replicas that haven' t yet received t\", \"he latest update.\\n\\nCP applications choose consistency over availability. Dapr supports this choice w\", \"ith its strong consistency strategy. In this scenario, the state store will synchronously update all\", \" (or, in some cases, a quorum of) required replicas before completing the write request. Read operat\", \"ions will return the most up-to-date data consistently across replicas.\\n\\nThe consistency level for a\", \" state operation is specified by attaching a consistency hint to the operation. The following curl c\", \"ommand writes a Hello=World key/value pair to a state store using a strong consistency hint:\\n\\n```\\ncu\", \"rl -X POST http://localhost:3500/v1.0/state/<store-name> \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d \", \"'[ { \\\"key\\\": \\\"Hello\\\", \\\"value\\\": \\\"World\\\", \\\"options\\\": { \\\"consistency\\\": \\\"strong\\\" } } ]'\\n```\\n\\n## Important\", \"\\n\\nIt is up to the Dapr state store component to fulfill the consistency hint attached to the operati\", \"on. Not all data stores support both consistency levels. If no consistency hint is set, the default \", \"behavior is eventual .\\n\\n## Concurrency\\n\\nIn a multiuser application, there's a chance that multiple u\", \"sers will update the same data concurrently (at the same time). Dapr supports optimistic concurrency\", \" control (OCC) to manage conflicts. OCC is based on an assumption that update conflicts are uncommon\", \" because users work on different parts of the data. It's more efficient to assume an update will suc\", \"ceed and retry if it doesn't. The alternative, implementing pessimistic locking, can affect performa\", \"nce with long-running locking causing data contention.\\n\\nDapr supports optimistic concurrency control\", \" (OCC) using ETags. An ETag is a value associated with a specific version of a stored key/value pair\", \". Each time a key/value pair updates, the ETag value updates as well. When a client retrieves a key/\", \"value pair, the response includes the current ETag value. When a client updates or deletes a key/val\", \"ue pair, it must send that ETag value back in the request body. If another client has updated the da\", \"ta in the meantime, the ETags won't match and the request will fail. At this point, the client must \", \"retrieve the updated data, make the change again, and resubmit the update. This strategy is called f\", \"irst-write-wins .\\n\\nDapr also supports a last-write-wins strategy. With this approach, the client doe\", \"sn't attach an ETag to the write request. The state store component will always allow the update, ev\", \"en if the underlying value has changed during the session. Last-write-wins is useful for high-throug\", \"hput write scenarios with low data contention. As well, overwriting an occasional user update can be\", \" tolerated.\\n\\n## Transactions\\n\\nDapr can write multi-item changes to a data store as a single operatio\", \"n implemented as a transaction. This functionality is only available for data stores that support AC\", \"ID transactions. At the time of this writing, these stores include Redis, MongoDB, PostgreSQL, SQL S\", \"erver, and Azure CosmosDB.\\n\\nIn the example below, a multi-item operation is sent to the state store \", \"in a single transaction. All operations must succeed for the transaction to commit. If one or more o\", \"f the operations fail, the entire transaction rolls back.\\n\\n```\\ncurl -X POST http://localhost:3500/v1\", \".0/state/<store-name>/transaction \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"operations\\\": [ { \\\"o\", \"peration\\\": \\\"upsert\\\", \\\"request\\\": { \\\"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\" } }, { \\\"operation\\\": \\\"delete\\\", \\\"re\", \"quest\\\": { \\\"key\\\": \\\"Key2\\\" } }\\n```\\n\\n```\\n] }'\\n```\\n\\nFor data stores that don't support transactions, mult\", \"iple keys can still be sent as a single request. The following example shows a bulk write operation:\", \"\\n\\n```\\ncurl -X POST http://localhost:3500/v1.0/state/<store-name> \\\\ -H \\\"Content-Type: application/jso\", \"n\\\" \\\\ -d '[ { \\\"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\" }, { \\\"key\\\": \\\"Key2\\\", \\\"value\\\": \\\"Value2\\\" } ]'\\n```\\n\\nFor bu\", \"lk operations, Dapr will submit each key/value pair update as a separate request to the data store.\\n\", \"\\n## Use the Dapr .NET SDK\\n\\nThe Dapr .NET SDK provides language-specific support for the .NET platfor\", \"m. Developers can use the DaprClient class introduced in chapter 3 to read and write data. The follo\", \"wing example shows how to use the DaprClient.GetStateAsync&lt;TValue&gt; method to read data from a \", \"state store. The method expects the store name, statestore , and key, AMS , as parameters:\\n\\n```\\nvar \", \"weatherForecast = await daprClient.GetStateAsync<WeatherForecast>(\\\"statestore\\\", \\\"AMS\\\");\\n```\\n\\nIf the \", \"state store contains no data for key AMS , the result will be default(WeatherForecast) .\\n\\nTo write d\", \"ata to the data store, use the DaprClient.SaveStateAsync&lt;TValue&gt; method:\\n\\n```\\ndaprClient.SaveS\", \"tateAsync(\\\"statestore\\\", \\\"AMS\\\", weatherForecast);\\n```\\n\\nThe example uses the last-write-wins strategy \", \"as an ETag value isn't p assed to the state store component. To use optimistic concurrency control (\", \"OCC) with a first-write-wins strategy, first retrieve the current ETag using the DaprClient.GetState\", \"AndETagAsync method. Then write the updated value and pass along the retrieved ETag using the DaprCl\", \"ient.TrySaveStateAsync method.\\n\\n```\\nvar (weatherForecast, etag) = await daprClient.GetStateAndETagAs\", \"ync<WeatherForecast>(\\\"statestore\\\", city); // ... make some changes to the retrieved weather forecast\", \" var result = await daprClient.TrySaveStateAsync(\\\"statestore\\\", city, weatherForecast, etag);\\n```\\n\\nTh\", \"e DaprClient.TrySaveStateAsync method fails when the data (and associated ETag) has been changed in \", \"the state store after the data was retrieved. The method returns a boolean value to indicate whether\", \" the call succeeded. A strategy to handle the failure is to simply reload the updated data from the \", \"state store, make the change again, and resubmit the update.\\n\\nIf you always want a write to succeed \", \"regardless of other changes to the data, use the last-write-wins strategy.\\n\\nThe SDK provides other m\", \"ethods to retrieve data in bulk, delete data, and execute transactions. For more information, see th\", \"e Dapr .NET SDK repository.\\n\\n## ASP.NET Core integration\\n\\nDapr also supports ASP.NET Core, a cross-p\", \"latform framework for building modern cloud-based web applications. The Dapr SDK integrates state ma\", \"nagement capabilities directly into the ASP.NET Core model binding capabilities. Configuration is si\", \"mple. In the Program.cs file, call the following extension method on the WebApplication builder:\\n\\n``\", \"`\\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers().AddDapr();\\n```\", \"\\n\\nOnce configured, Dapr can inject a key/value pair directly into a controller action using the ASP.\", \"NET Core FromState attribute. Referencing the DaprClient object is no longer necessary. The next exa\", \"mple shows a Web API that returns the weather forecast for a given city:\\n\\n```\\n[HttpGet(\\\"{city}\\\")] pu\", \"blic ActionResult<WeatherForecast> Get([FromState(\\\"statestore\\\", \\\"city\\\")] StateEntry<WeatherForecast>\", \" forecast) { if (forecast.Value == null ) { return NotFound(); } return forecast.Value; }\\n```\\n\\nIn th\", \"e example, the controller loads the weather forecast using the FromState attribute. The first attrib\", \"ute parameter is the state store, statestore . The second attribute parameter, city , is the name of\", \" the route template variable to get the state key. If you omit the second parameter, the name of the\", \" bound method parameter ( forecast ) is used to look up the route template variable.\\n\\nThe StateEntry\", \" class contains properties for all the information that is retrieved for a single key/value pair: St\", \"oreName , Key , Value , and ETag . The ETag is useful for implementing optimistic concurrency contro\", \"l (OCC) strategy. The class also provides methods to delete or update retrieved key/value data witho\", \"ut requiring a DaprClient instance. In the next example, the TrySaveAsync method is used to update t\", \"he retrieved weather forecast using OCC.\\n\\n```\\n[HttpPut(\\\"{city}\\\")] public async Task Put(WeatherForec\", \"ast updatedForecast, [FromState(\\\"statestore\\\", \\\"city\\\")] StateEntry<WeatherForecast> currentForecast) \", \"{ // update cached current forecast with updated forecast passed into service endpoint currentForeca\", \"st.Value = updatedForecast; // update state store var success = await currentForecast.TrySaveAsync()\", \"; // ... check result }\\n```\\n\\n## State store components\\n\\nAt the time of this writing, Dapr provides s\", \"upport for the following transactional state stores:\\n\\n- Azure CosmosDB\\n- Azure SQL Server\\n- Cockroac\", \"hDB\\n- In Memory\\n- MongoDB\\n- MySQL\\n- Oracle Database\\n- PostgreSQL\\n- Redis\\n- RethinkDB\\n\\nDapr also incl\", \"udes support for state stores that support CRUD operations, but not transactional capabilities:\\n\\n- A\", \"erospike\\n- Apache Cassandra\\n- AWS DynamoDB\\n- Azure Blob Storage\\n- Azure Table Storage\\n- Couchbase\\n- \", \"GCP Firestore\\n- Hashicorp Consul\\n- Hazelcast\\n- JetStream KV\\n- Memcached\\n- Oracle Object Storage\\n- Zo\", \"okeeper\\n\\n## Configuration\\n\\nWhen initialized for local, self-hosted development, Dapr registers Redis\", \" as the default state store. Here's an example of the default state store configuration. Note the de\", \"fault name, statestore :\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestor\", \"e spec: type: state.redis version: v1 metadata: -name: redisHost value: localhost:6379 -name: redisP\", \"assword value: \\\"\\\" -name: actorStateStore value: \\\"true\\\"\\n```\\n\\n[!NOTE] Many state stores can be registe\", \"red to a single application each with a different name.\\n\\nThe Redis state store requires redisHost an\", \"d redisPassword metadata to connect to the Redis instance. In the example above, the Redis password \", \"(which is an empty string by default) is stored as a plain string. The best practice is to avoid cle\", \"ar-text strings and always use secret references. To learn more about secret management, see chapter\", \" 10.\\n\\nThe other metadata field, actorStateStore , indicates whether the state store can be consumed \", \"by the actors building block.\\n\\n## Key prefix strategies\\n\\nState store components enable different str\", \"ategies to store key/value pairs in the underlying store. Recall the earlier example of a shopping b\", \"asket service storing items a customer wishes to purchase:\\n\\n```\\ncurl -X POST http://localhost:3500/v\", \"1.0/state/statestore \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '[{ \\\"key\\\": \\\"basket1\\\", \\\"value\\\": { \\\"cu\", \"stomerId\\\": 1, \\\"items\\\": [ { \\\"itemId\\\": \\\"DaprHoodie\\\", \\\"quantity\\\": 1 } ] } }]'\\n```\\n\\nUsing the Redis Cons\", \"ole tool, look inside the Redis cache to see how the Redis state store component persisted the data:\", \"\\n\\n```\\n127.0.0.1:6379> KEYS * 1) \\\"basketservice||basket1\\\" 127.0.0.1:6379> HGETALL basketservice||bask\", \"et1 1) \\\"data\\\" 2) \\\"{\\\\\\\"items\\\\\\\":[{\\\\\\\"itemId\\\\\\\":\\\\\\\"DaprHoodie\\\\\\\",\\\\\\\"quantity\\\\\\\":1}],\\\\\\\"customerId\\\\\\\":1}\\\" 3) \\\"ver\", \"sion\\\" 4) \\\"1\\\"\\n```\\n\\nThe output shows the full Redis key for the data as basketservice||basket1 . By de\", \"fault, Dapr uses the application id of the Dapr instance ( basketservice ) as a prefix for the key. \", \"This naming convention enables multiple Dapr instances to share the same data store without key name\", \" collisions. For the developer, it's critical always to specify the same application id when running\", \" the application with Dapr. If omitted, Dapr will generate a unique application ID. If the applicati\", \"on id changes, the application can no longer access the state stored with the previous key prefix.\\n\\n\", \"That said, it's possible to configure a constant value for the key prefix in the keyPrefix metadata \", \"field in the state store component file. Consider the following example:\\n\\n```\\nspec: metadata: -name:\", \" keyPrefix -value: MyPrefix\\n```\\n\\nA constant key prefix enables the state store to be accessed across\", \" multiple Dapr applications. What's more, setting the keyPrefix to none omits the prefix completely.\", \"\\n\\n## Sample application: Dapr Traffic Control\\n\\nIn the Dapr Traffic Control sample app, the TrafficCo\", \"ntrol service uses the Dapr state management building block to persist the entry and exit timestamps\", \" of each passing vehicle. Figure 5-3 shows the conceptual architecture of the Dapr Traffic Control s\", \"ample application. The Dapr state management building block is used in flows marked with number 3 in\", \" the diagram:\\n\\n:::image type='content' source='./media/state -management/dapr-solution-statemanageme\", \"nt.png' alttext='Conceptual architecture of the Dapr Traffic Control sample application.':::\\n\\nFigure\", \" 5-3. Conceptual architecture of the Dapr Traffic Control sample application.\\n\\nEntry and exit event \", \"logic is handled by the TrafficController class, an ordinary ASP.NET Controller. The TrafficControll\", \"er.VehicleEntry method accepts an incoming VehicleRegistered message and saves the enclosed vehicle \", \"state:\\n\\n```\\n// store vehicle state var vehicleState = new VehicleState { LicenseNumber = msg.License\", \"Number, EntryTimestamp = msg.Timestamp }; await _vehicleStateRepository.SaveVehicleStateAsync(vehicl\", \"eState);\\n```\\n\\nIn the preceding code snippet, the abstraction _vehicleStateRepository is responsible \", \"for saving state to the data store. Its concrete implementation, DaprVehicleStateRepository , is sho\", \"wn below:\\n\\n```\\npublic class DaprVehicleStateRepository : IVehicleStateRepository { private const str\", \"ing DAPR_STORE_NAME = \\\"statestore\\\"; private readonly DaprClient _daprClient; public DaprVehicleState\", \"Repository(DaprClient daprClient) { _daprClient = daprClient; } public async Task SaveVehicleStateAs\", \"ync(VehicleState vehicleState) { await _daprClient.SaveStateAsync<VehicleState>( DAPR_STORE_NAME, ve\", \"hicleState.LicenseNumber, vehicleState); } public async Task<VehicleState> GetVehicleStateAsync(stri\", \"ng licenseNumber) { return await _daprClient.GetStateAsync<VehicleState>( DAPR_STORE_NAME, licenseNu\", \"mber); } }\\n```\\n\\nAs the preceding code snippet shows, the implementation of the DaprVehicleStateRepos\", \"itory class is pretty straightforward. The SaveVehicleStateAsync method uses the injected DaprClient\", \" object\\n\\nto save the state to the configured Dapr state store. It uses the vehicle's license number \", \"as the key. The application can retrieve the saved state by calling the GetVehicleStateAsync method.\", \"\\n\\nThe TrafficControl service uses Redis as its underlying data store. Looking at the code, you'd nev\", \"er know it. A service consuming the Dapr state management building block doesn't directly reference \", \"any state components. Instead, a Dapr component configuration file specifies the store:\\n\\n```\\napiVers\", \"ion: dapr.io/v1alpha1 kind: Component metadata: name: statestore namespace: dapr-trafficcontrol spec\", \": type: state.redis version: v1 metadata: -name: redisHost value: localhost:6379 -name: redisPasswor\", \"d secretKeyRef: name: state.redisPassword key: state.redisPassword scopes: -trafficcontrolservice\\n``\", \"`\\n\\n## Note\\n\\nThe component configuration file includes an element secretKeyRef . The application uses\", \" it to reference the Redis password value from the Dapr secrets building block. See chapter 10 to le\", \"arn more about managing secrets with Dapr.\\n\\nThe type element in the configuration, state.redis instr\", \"ucts the building block to manage state with Dapr Redis component.\\n\\nThe scopes element in the config\", \"uration constrains application access to the state store component. Only the TrafficControl service \", \"can access the state store.\\n\\n## Summary\\n\\nThe Dapr state management building block offers an API for \", \"storing key/value data across various data stores. The API provides support for:\\n\\n- Bulk operations\\n\", \"- Strong and eventual consistency\\n- Optimistic concurrency control\\n- Multi-item transactions\\n\\nThe .N\", \"ET SDK provides language-specific support for .NET and ASP.NET Core. Model binding integration simpl\", \"ifies accessing and updating state from ASP.NET Core controller action methods.\\n\\nIn the Dapr Traffic\", \" Control sample application, the benefits of using Dapr state management are clear:\\n\\n1. It abstracts\", \" away the complexity of using third-party SDKs, such as StackExchange.Redis .\\n2. Replacing the under\", \"lying Redis cache with a different type of data store only requires changes to the component configu\", \"ration file.\\n\\n## References\\n\\n- Dapr supported state stores\\n\\n## The Dapr service invocation building \", \"block\\n\\nAcross a distributed system, one service often needs to communicate with another to complete \", \"a business operation. The Dapr service invocation building block can help streamline the communicati\", \"on between services.\\n\\n## What it solves\\n\\nMaking calls between services in a distributed application \", \"may appear easy, but there are many challenges involved. For example:\\n\\n- Where the other services ar\", \"e located.\\n- How to call a service securely, given the service address.\\n- How to handle retries when\", \" short-lived transient errors occur.\\n\\nLastly, as distributed applications compose many different ser\", \"vices, capturing insights across service call graphs are critical to diagnosing production issues.\\n\\n\", \"The service invocation building block addresses these challenges by using a Dapr sidecar as a revers\", \"e proxy for your service.\\n\\n## How it works\\n\\nLet's start with an example. Consider two services, 'Ser\", \"vice A' and 'Service B'. Service A needs to call the catalog/items API on Service B. While Service A\", \" could take a dependency on Service B and make a direct call to it, Service A instead invokes the se\", \"rvice invocation API on the Dapr sidecar. Figure 6-1 shows the operation.\\n\\nGET http://localhost:3500\", \"/v1.0/invoke/serviceb/method/catalog/items\\n\\nService A\\n\\nService B\\n\\nFigure 6-1. How Dapr service invoc\", \"ation works.\\n\\nNote the steps from the previous figure:\\n\\n1. Service A makes a call to the catalog/ite\", \"ms endpoint in Service B by invoking the service invocation API on the Service A sidecar.\\n\\n[!NOTE] T\", \"he sidecar uses a pluggable name resolution component to resolve the address of Service B. In self-h\", \"osted mode, Dapr uses mDNS to find it. When running in Kubernetes mode, the Kubernetes DNS service d\", \"etermines the address.\\n\\n2. The Service A sidecar forwards the request to the Service B sidecar.\\n3. T\", \"he Service B sidecar makes the actual catalog/items request against the Service B API.\\n4. Service B \", \"executes the request and returns a response back to its sidecar.\\n5. The Service B sidecar forwards t\", \"he response back to the Service A sidecar.\\n6. The Service A sidecar returns the response back to Ser\", \"vice A.\\n\\nBecause the calls flow through sidecars, Dapr can inject some useful cross-cutting behavior\", \"s:\\n\\n- Automatically retry calls upon failure.\\n- Make calls between services secure with mutual (mTLS\", \") authentication, including automatic certificate rollover.\\n- Control what operations clients can do\", \" using access control policies.\\n- Capture traces and metrics for all calls between services to provi\", \"de insights and diagnostics.\\n\\nAny application can invoke a Dapr sidecar by using the native invoke A\", \"PI built into Dapr. The API can be called with either HTTP or gRPC. Use the following URL to call th\", \"e HTTP API:\\n\\nhttp://localhost:&lt;dapr-port&gt;/v1.0/invoke/&lt;application-id&gt;/method/&lt;method\", \"-name&gt;\\n\\n- &lt;dapr-port&gt; the HTTP port that Dapr is listening on.\\n- &lt;application-id&gt; app\", \"lication ID of the service to call.\\n- &lt;method-name&gt; name of the method to invoke on the remote\", \" service.\\n\\nIn the following example, a curl call is made to the catalog/items 'GET' endpoint of Serv\", \"ice B :\\n\\ncurl http://localhost:3500/v1.0/invoke/serviceb/method/catalog/items\\n\\n## Note\\n\\nThe Dapr API\", \"s enable any application stack that supports HTTP or gRPC to use Dapr building blocks. Therefore, th\", \"e service invocation building block can act as a bridge between protocols. Services can communicate \", \"with each other using HTTP, gRPC or a combination of both.\\n\\nIn the next section, you'll learn how to\", \" use the .NET SDK to simplify service invocation calls.\\n\\n## Use the Dapr .NET SDK\\n\\nThe Dapr .NET SDK\", \" provides .NET developers with an intuitive and language-specific way to interact with Dapr. The SDK\", \" offers developers three ways of making remote service invocation calls:\\n\\n1. Invoke HTTP services us\", \"ing HttpClient\\n2. Invoke HTTP services using DaprClient\\n3. Invoke gRPC services using DaprClient\\n\\n##\", \" Invoke HTTP services using HttpClient\\n\\nThe preferred way to call an HTTP endpoint is to use Dapr's \", \"rich integration with HttpClient . The following example submits an order by calling the submit meth\", \"od of the orderservice application:\\n\\n```\\nvar httpClient = DaprClient.CreateInvokeHttpClient();\\n```\\n\\n\", \"await httpClient.PostAsJsonAsync(\\\"http://orderservice/submit\\\", order);\\n\\nIn the example, DaprClient.C\", \"reateInvokeHttpClient returns an HttpClient instance that is used to perform Dapr service invocation\", \". The returned HttpClient uses a special Dapr message handler that rewrites URIs of outgoing request\", \"s. The host name is interpreted as the application ID of the service to call. The rewritten request \", \"that's actually being called is:\\n\\n```\\nhttp://127.0.0.1:3500/v1/invoke/orderservice/method/submit\\n```\", \"\\n\\nThis example uses the default value for the Dapr HTTP endpoint, which is http://127.0.0.1:&lt;dapr\", \"http-port&gt;/ . The value of dapr-http-port is taken from the DAPR_HTTP_PORT environment variable. \", \"If it's not set, the default port number 3500 is used.\\n\\nAlternatively, you can configure a custom en\", \"dpoint in the call to DaprClient.CreateInvokeHttpClient :\\n\\n```\\nvar httpClient = DaprClient.CreateInv\", \"okeHttpClient(daprEndpoint: \\\"localhost:4000\\\");\\n```\\n\\nYou can also directly set the base address by sp\", \"ecifying the application ID. Doing so enables relative URIs when making a call:\\n\\n```\\nvar httpClient \", \"= DaprClient.CreateInvokeHttpClient(\\\"orderservice\\\"); await httpClient.PostAsJsonAsync(\\\"/submit\\\");\\n``\", \"`\\n\\nThe HttpClient object is intended to be long-lived. A single HttpClient instance can be reused fo\", \"r the lifetime of the application. The next scenario demonstrates how an OrderServiceClient class re\", \"uses a Dapr HttpClient instance:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); builder.Serv\", \"ices.AddSingleton<IOrderServiceClient, OrderServiceClient>( _ => new OrderServiceClient(DaprClient.C\", \"reateInvokeHttpClient(\\\"orderservice\\\")));\\n```\\n\\nIn the snippet above, the OrderServiceClient is regist\", \"ered as a singleton with the ASP.NET Core dependency injection system. An implementation factory cre\", \"ates a new HttpClient instance by calling DaprClient.CreateInvokeHttpClient . It then uses the newly\", \" created HttpClient to instantiate the OrderServiceClient object. By registering the OrderServiceCli\", \"ent as a singleton, it will be reused for the lifetime of the application.\\n\\nThe OrderServiceClient i\", \"tself has no Dapr-specific code. Even though Dapr service invocation is used under the hood, you can\", \" treat the Dapr HttpClient like any other HttpClient:\\n\\n```\\npublic class OrderServiceClient : IOrderS\", \"erviceClient { private readonly HttpClient _httpClient; public OrderServiceClient(HttpClient httpCli\", \"ent) { _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient)); } public asy\", \"nc Task SubmitOrder(Order order) { var response = await _httpClient.PostAsJsonAsync(\\\"submit\\\", order)\", \"; response.EnsureSuccessStatusCode(); } }\\n```\\n\\nUsing the HttpClient class with Dapr service invocati\", \"on has many benefits:\\n\\n- HttpClient is a well-known class that many developers already use in their \", \"code. Using HttpClient for Dapr service invocation allows developers to reuse their existing skills.\", \"\\n- HttpClient supports advanced scenarios, such as custom headers, and full control over request and\", \" response messages.\\n- In .NET 5, HttpClient supports automatic serialization and deserialization usi\", \"ng System.Text.Json.\\n- HttpClient integrates with many existing frameworks and libraries, such as Re\", \"fit, RestSharp, and Polly.\\n\\n## Invoke HTTP services using DaprClient\\n\\nWhile HttpClient is the prefer\", \"red way to invoke services using HTTP semantics, you can also use the DaprClient.InvokeMethodAsync f\", \"amily of methods. The following example submits an order by calling the submit method of the orderse\", \"rvice application:\\n\\n```\\nvar daprClient = new DaprClientBuilder().Build(); try { var confirmation = a\", \"wait daprClient.InvokeMethodAsync<Order, OrderConfirmation>( \\\"orderservice\\\", \\\"submit\\\", order); } cat\", \"ch (InvocationException ex) { // Handle error }\\n```\\n\\nThe third argument, an order object, is seriali\", \"zed internally (with System.Text.JsonSerializer ) and sent as the request payload. The .NET SDK take\", \"s care of the call to the sidecar. It also deserializes the response to an OrderConfirmation object.\", \" Because no HTTP method is specified, the request is executed as an HTTP POST.\\n\\nThe next example dem\", \"onstrates how you can make an HTTP GET request by specifying the HttpMethod :\\n\\n```\\nvar catalogItems \", \"= await daprClient.InvokeMethodAsync<IEnumerable<CatalogItem>>(HttpMethod.Get, \\\"catalogservice\\\", \\\"it\", \"ems\\\");\\n```\\n\\nFor some scenarios, you may require more control over the request message. For example, \", \"when you need to specify request headers, or you want to use a custom serializer for the payload. Da\", \"prClient.CreateInvokeMethodRequest creates an HttpRequestMessage . The following example demonstrate\", \"s how to add an HTTP authorization header to a request message:\\n\\n```\\nvar request = daprClient.Create\", \"InvokeMethodRequest(\\\"orderservice\\\", \\\"submit\\\", order); request.Headers.Authorization = new Authentica\", \"tionHeaderValue(\\\"bearer\\\", token);\\n```\\n\\nThe HttpRequestMessage now has the following properties set:\\n\", \"\\n- Url = http://127.0.0.1:3500/v1.0/invoke/orderservice/method/submit\\n- HttpMethod = POST\\n- Content \", \"= JsonContent object containing the JSON-serialized order\\n- Headers.Authorization = 'bearer &lt;toke\", \"n&gt;'\\n\\nOnce you've got the request set up the way you want, use DaprClient.InvokeMethodAsync to sen\", \"d it:\\n\\n```\\nvar orderConfirmation = await daprClient.InvokeMethodAsync<OrderConfirmation>(request);\\n`\", \"``\\n\\nDaprClient.InvokeMethodAsync deserializes the response to an OrderConfirmation object if the req\", \"uest is successful. Alternatively, you can use DaprClient.InvokeMethodWithResponseAsync to get full \", \"access to the underlying HttpResponseMessage :\\n\\n```\\nvar response = await daprClient.InvokeMethodWith\", \"ResponseAsync(request); response.EnsureSuccessStatusCode(); var orderConfirmation = response.Content\", \".ReadFromJsonAsync<OrderConfirmation>();\\n```\\n\\n## Note\\n\\nFor service invocation calls using HTTP, it's\", \" worth considering using the Dapr HttpClient integration presented in the previous section. Using Ht\", \"tpClient gives you additional benefits such as integration with existing frameworks and libraries.\\n\\n\", \"## Invoke gRPC services using DaprClient\\n\\nDaprClient provides a family of InvokeMethodGrpcAsync meth\", \"ods for calling gRPC endpoints. The main difference with the HTTP methods is the use of a Protobuf s\", \"erializer instead of JSON. The following example invokes the submitOrder method of the orderservice \", \"over gRPC.\\n\\n```\\nvar daprClient = new DaprClientBuilder().Build(); try { var confirmation = await dap\", \"rClient.InvokeMethodGrpcAsync<Order, OrderConfirmation>(\\\"orderservice\\\", \\\"submitOrder\\\", order); } cat\", \"ch (InvocationException ex) { // Handle error }\\n```\\n\\nIn the example above, DaprClient serializes the\", \" given order object using Protobuf and uses the result as the gRPC request body. Likewise, the respo\", \"nse body is Protobuf deserialized and returned to the caller. Protobuf typically provides better per\", \"formance than the JSON payloads used in HTTP service invocation.\\n\\n## Name resolution components\\n\\nAt \", \"the time of writing, Dapr provides support for the following name resolution components:\\n\\n- mDNS (de\", \"fault when running self-hosted)\\n- Kubernetes Name Resolution (default when running in Kubernetes)\\n- \", \"HashiCorp Consul\\n\\n## Configuration\\n\\nTo use a non-default name resolution component, add a nameResolu\", \"tion spec to the application's Dapr configuration file. Here's an example of a Dapr configuration fi\", \"le that enable s HashiCorp Consul name resolution:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Configura\", \"tion metadata:\\n```\\n\\n```\\nname: dapr-config spec: nameResolution: configuration:\\n```\\n\\n```\\ncomponent: \\\"\", \"consul\\\" selfRegister: true\\n```\\n\\n## Sample application: Dapr Traffic Control\\n\\nIn Dapr Traffic Control\", \" sample app, the FineCollection service uses the Dapr service invocation building block to retrieve \", \"vehicle and owner information from the VehicleRegistration service. Figure 6-2 shows the conceptual \", \"architecture of the Dapr Traffic Control sample application. The Dapr service invocation building bl\", \"ock is used in flows marked with number 1 in the diagram:\\n\\n```\\n:::image type='content' source='./med\", \"ia/service -invocation/dapr-solution-serviceinvocation.png' alttext='Conceptual architecture of the \", \"Dapr Traffic Control sample application.'::: Figure 6-2. Conceptual architecture of the Dapr Traffic\", \" Control sample application. Information is retrieved by the ASP.NET CollectionController class in t\", \"he FineCollection service. The CollectFine method expects an incoming SpeedingViolation parameter. I\", \"t invokes a Dapr service invocation building block to call to the VehicleRegistration service. The c\", \"ode snippet is presented below. :::{customstyle=CodeBox} ```csharp [Topic('pubsub', 'speedingviolati\", \"ons')] [Route('collectfine')] [HttpPost] public async Task CollectFine(SpeedingViolation speedingVio\", \"lation, [FromServices] DaprClient daprClient) { // \\u2026 // get owner info (Dapr service invocation) var\", \" vehicleInfo = _vehicleRegistrationService.GetVehicleInfo(speedingViolation.VehicleId).Result; // ..\", \". } ``` ::: The code uses a proxy of type VehicleRegistrationService to call the VehicleRegistration\", \" service. ASP.NET Core injects an instance of the service proxy using constructor injection: :::{cus\", \"tom-style=CodeBox} csharp  public CollectionController(      ILogger<CollectionController> logger,  \", \"    IFineCalculator fineCalculator,      VehicleRegistrationService vehicleRegistrationService, Dapr\", \"Client daprClient)  {      // ...  } ::: The VehicleRegistrationService class contains a single meth\", \"od: GetVehicleInfo . It uses the ASP.NET Core HttpClient to call the VehicleRegistration service: _h\", \"ttpClient; public VehicleRegistrationService(HttpClient httpClient) { _httpClient = httpClient; }\\n``\", \"`\\n\\n```\\n:::{custom-style=CodeBox} ```csharp public class VehicleRegistrationService { private HttpCli\", \"ent public async Task<VehicleInfo> GetVehicleInfo(string licenseNumber) {\\n```\\n\\n```\\nreturn await _htt\", \"pClient.GetFromJsonAsync<VehicleInfo>(\\n```\\n\\n```\\n$\\\"vehicleinfo/{licenseNumber}\\\"); } } ``` :::\\n```\\n\\nTh\", \"e code doesn't depend on any Dapr classes directly. It instead leverages the Dapr ASP.NET Core integ\", \"ration as described in the Invoke HTTP services using HttpClient section of this module. The followi\", \"ng code in the ConfigureService method of the Startup class registers the VehicleRegistrationService\", \" proxy:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddSingleton<Vehicle\", \"RegistrationService>(_ => new VehicleRegistrationService(DaprClient.CreateInvokeHttpClient( \\\"vehicle\", \"registrationservice\\\", $\\\"http://localhost:{daprHttpPort}\\\" )));\\n```\\n\\nThe DaprClient.CreateInvokeHttpCl\", \"ient creates an HttpClient instance that calls the VehicleRegistration service using the service inv\", \"ocation building block under the covers. It expects both the Dapr app-id of the target service and t\", \"he URL of its Dapr sidecar. At start time, the daprHttpPort argument contains the port number used f\", \"or HTTP communication with the Dapr sidecar.\\n\\nUsing Dapr service invocation in the Traffic Control s\", \"ample application provides several benefits:\\n\\n1. Decouples the location of the target service.\\n2. Ad\", \"ds resiliency with automatic retry features.\\n3. Ability to reuse an existing HttpClient based proxy \", \"(offered by the ASP.NET Core integration).\\n\\n## Summary\\n\\nIn this chapter, you learned about the servi\", \"ce invocation building block. You saw how to invoke remote methods both by making direct HTTP calls \", \"to the Dapr sidecar, and by using the Dapr .NET SDK.\\n\\nThe Dapr .NET SDK provides multiple ways to in\", \"voke remote methods. HttpClient support is great for developers wanting to reuse existing skills and\", \" is compatible with many existing frameworks and libraries. DaprClient offers support for directly u\", \"sing the Dapr service invocation API using either HTTP or gRPC semantics.\\n\\n## References\\n\\n- Dapr ser\", \"vice invocation building block\\n- Monitoring distributed cloud-native applications\\n\\nPublisher\\n\\nMessag\", \"e broker\\n\\n## The Dapr publish &amp; subscribe building block\\n\\nThe Publish-Subscribe pattern (often r\", \"eferred to as 'pub/sub') is a well -known and widely used messaging pattern. Architects commonly emb\", \"race it in distributed applications. However, the plumbing to implement it can be complex. There are\", \" often subtle feature differences across different messaging products. Dapr offers a building block \", \"that significantly simplifies implementing pub/sub functionality.\\n\\n## What it solves\\n\\nThe primary ad\", \"vantage of the Publish-Subscribe pattern is loose coupling , sometimes referred to as temporal decou\", \"pling. The pattern decouples services that send messages (the publishers ) from services that consum\", \"e messages (the subscribers ). Both publishers and subscribers are unaware of each other - both are \", \"dependent on a centralized message broker that distributes the messages.\\n\\nFigure 7-1 shows the high-\", \"level architecture of the pub/sub pattern.\\n\\nFigure 7-1. The pub/sub pattern.\\n\\nFrom the previous figu\", \"re, note the steps of the pattern:\\n\\n1. Publishers send messages to the message broker.\\n2. Subscriber\", \"s bind to a subscription on the message broker.\\n\\n3. The message broker forwards a copy of the messag\", \"e to interested subscriptions.\\n4. Subscribers consume messages from their subscriptions.\\n\\nMost messa\", \"ge brokers encapsulate a queueing mechanism that can persist messages once received. With it, the me\", \"ssage broker guarantees durability by storing the message. Subscribers don't need to be immediately \", \"available or even online when a publisher sends a message. Once available, the subscriber receives a\", \"nd processes the message. Dapr guarantees At-Least-Once semantics for message delivery. Once a messa\", \"ge is published, it will be delivered at least once to any interested subscriber.\\n\\n## Tip\\n\\nIf your s\", \"ervice can only process a message once, you'll need to provide an idempotency check to ensure that t\", \"he same message is not processed multiple times. While such logic can be coded, some message brokers\", \", such as Azure Service Bus, provide built-in duplicate detection messaging capabilities.\\n\\nThere are\", \" several message broker products available - both commercially and open-source. Each has advantages \", \"and drawbacks. Your job is to match your system requirements to the appropriate broker. Once selecte\", \"d, it's a best practice to decouple your application from message broker plumbing. You achieve this \", \"functionality by wrapping the broker inside an abstraction . The abstraction encapsulates the messag\", \"e plumbing and exposes generic pub/sub operations to your code. Your code communicates with the abst\", \"raction, not the actual message broker. While a wise decision, you'll have to write and maintain the\", \" abstraction and its underlying implementation. This approach requires custom code that can be compl\", \"ex, repetitive, and error-prone.\\n\\nThe Dapr publish &amp; subscribe building block provides the messa\", \"ging abstraction and implementation out-of-the-box. The custom code you would have had to write is p\", \"rebuilt and encapsulated inside the Dapr building block. You bind to it and consume it. Instead of w\", \"riting messaging plumbing code, you and your team focus on creating business functionality that adds\", \" value to your customers.\\n\\n## How it works\\n\\nThe Dapr publish &amp; subscribe building block provides\", \" a platform-agnostic API framework to send and receive messages. Your services publish messages to a\", \" named topic. Your services subscribe to a topic to consume messages.\\n\\nThe service calls the pub/sub\", \" API on the Dapr sidecar. The sidecar then makes calls into a pre-defined Dapr pub/sub component tha\", \"t encapsulates a specific message broker product. Figure 7-2 shows the Dapr pub/sub messaging stack.\", \"\\n\\nRabbitMQ\\n\\ncomponent\\n\\nFigure 7-2. The Dapr pub/sub stack.\\n\\nThe Dapr publish &amp; subscribe buildin\", \"g block can be invoked in many ways.\\n\\nAt the lowest level, any programming platform can invoke the b\", \"uilding block over HTTP or gRPC using the Dapr native API . To publish a message, you make the follo\", \"wing API call:\\n\\n```\\nhttp://localhost:<dapr-port>/v1.0/publish/<pub-sub-name>/<topic>\\n```\\n\\nThere are \", \"several Dapr specific URL segments in the above call:\\n\\n- &lt;dapr-port&gt; provides the port number \", \"upon which the Dapr sidecar is listening.\\n- &lt;pub-sub-name&gt; provides the name of the selected D\", \"apr pub/sub component.\\n- &lt;topic&gt; provides the name of the topic to which the message is publis\", \"hed.\\n\\nUsing the curl command-line tool to publish a message, you can try it out:\\n\\n```\\ncurl -X POST h\", \"ttp://localhost:3500/v1.0/publish/pubsub/newOrder \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"ord\", \"erId\\\": \\\"1234\\\", \\\"productId\\\": \\\"5678\\\", \\\"amount\\\": 2 }'\\n```\\n\\nYou receive messages by subscribing to a top\", \"ic. At startup, the Dapr runtime will call the application on a well-known endpoint to identify and \", \"create the required subscriptions:\\n\\nhttp://localhost:&lt;appPort&gt;/dapr/subscribe\\n\\n- &lt;appPort&g\", \"t; informs the Dapr sidecar of the port upon which the application is listening.\\n\\nYou can implement \", \"this endpoint yourself. But Dapr provides more intuitive ways of implementing it. We'll address this\", \" functionality later in this chapter.\\n\\nThe response from the call contains a list of topics to which\", \" the applications will subscribe. Each includes an endpoint to call when the topic receives a messag\", \"e. Here's an example of a response:\\n\\n```\\n[ { \\\"pubsubname\\\": \\\"pubsub\\\", \\\"topic\\\": \\\"newOrder\\\", \\\"route\\\": \\\"\", \"/orders\\\" }, { \\\"pubsubname\\\": \\\"pubsub\\\", \\\"topic\\\": \\\"newProduct\\\", \\\"route\\\": \\\"/productCatalog/products\\\" } ]\", \"\\n```\\n\\nIn the JSON response, you can see the application wants to subscribe to topics newOrder and ne\", \"wProduct . It registers the endpoints /orders and /productCatalog/products for each, respectively. F\", \"or both subscriptions, the application is binding to the Dapr component named pubsub .\\n\\nFigure 7-3 p\", \"resents the flow of the example.\\n\\nPOST http://localhost:3500/v1.0/publish/pubsub/newOrder\\n\\nService A\", \"\\n\\nService B\\n\\nFigure 7-3. Pub/sub flow with Dapr.\\n\\n## From the previous figure, note the flow:\\n\\n1. Th\", \"e Dapr sidecar for Service B calls the /dapr/subscribe endpoint from Service B (the consumer). The s\", \"ervice responds with the subscriptions it wants to create.\\n2. The Dapr sidecar for Service B creates\", \" the requested subscriptions on the message broker.\\n3. Service A publishes a message at the /v1.0/pu\", \"blish/&lt;pub-sub-name&gt;/&lt;topic&gt; endpoint on the Dapr Service A sidecar.\\n4. The Service A si\", \"decar publishes the message to the message broker.\\n5. The message broker sends a copy of the message\", \" to the Service B sidecar.\\n6. The Service B sidecar calls the endpoint corresponding to the subscrip\", \"tion (in this case /orders ) on Service B. The service responds with an HTTP status-code 200 OK so t\", \"he sidecar will consider the message as being handled successfully.\\n\\nIn the example, the message is \", \"handled successfully. But if something goes wrong while Service B is handling the request, it can us\", \"e the response to specify what needs to happen with the message. When it returns an HTTP status-code\", \" 404 , an error is logged and the message is dropped. With any other status-code than 200 or 404 , a\", \" warning is logged and the message is retried. Alternatively,\\n\\nService B can explicitly specify what\", \" needs to happen with the message by including a JSON payload in the body of the response:\\n\\n```\\n{ \\\"s\", \"tatus\\\": \\\"<status>\\\" }\\n```\\n\\nThe following table shows the available status values:\\n\\n| Status          \", \" | Action                                                           |\\n|------------------|----------\", \"--------------------------------------------------------|\\n| SUCCESS          | The message is consid\", \"ered as processed successfully and dropped. |\\n| RETRY            | The message is retried.          \", \"                                |\\n| DROP             | A warning is logged and the message is droppe\", \"d.                  |\\n| Any other status | The message is retried.                                  \", \"        |\\n\\n## Competing consumers\\n\\nWhen scaling out an application that subscribes to a topic, you h\", \"ave to deal with competing consumers. Only one application instance should handle a message sent to \", \"the topic. Luckily, Dapr handles that problem. When multiple instances of a service with the same ap\", \"plication-id subscribe to a topic, Dapr delivers each message to only one of them.\\n\\n## Use the Dapr \", \".NET SDK\\n\\nFor .NET Developers, the Dapr .NET SDK provides a more productive way of working with Dapr\", \". The SDK exposes a DaprClient class through which you can directly invoke Dapr functionality. It's \", \"intuitive and easy to use.\\n\\nTo publish a message, the DaprClient exposes a PublishEventAsync method.\", \"\\n\\n```\\nvar data = new OrderData { orderId = \\\"123456\\\", productId = \\\"67890\\\", amount = 2 }; var daprClie\", \"nt = new DaprClientBuilder().Build(); await daprClient.PublishEventAsync<OrderData>(\\\"pubsub\\\", \\\"newOr\", \"der\\\", data);\\n```\\n\\n- The first argument pubsub is the name of the Dapr component that provides the me\", \"ssage broker implementation. We'll address components later in this chapter.\\n- The second argument n\", \"eworder provides the name of the topic to send the message to.\\n- The third argument is the payload o\", \"f the message.\\n- You can specify the .NET type of the message using the generic type parameter of th\", \"e method.\\n\\nTo receive messages, you bind an endpoint to a subscription for a registered topic. The A\", \"spNetCore library for Dapr makes this trivial. Assume, for example, that you have an existing ASP.NE\", \"T WebAPI action method entitled CreateOrder :\\n\\n```\\n[HttpPost(\\\"/orders\\\")]\\n```\\n\\n```\\npublic async Task<\", \"ActionResult> CreateOrder(Order order)\\n```\\n\\n```\\nImportant You must add a reference to the Dapr.AspNe\", \"tCore NuGet package in your project to consume the\\n```\\n\\nDapr ASP.NET Core integration.\\n\\nTo bind this\", \" action method to a topic, you decorate it with the Topic attribute:\\n\\n```\\n[Topic(\\\"pubsub\\\", \\\"newOrder\", \"\\\")] [HttpPost(\\\"/orders\\\")] public async Task<ActionResult> CreateOrder(Order order)\\n```\\n\\nYou specify \", \"two key elements with this attribute:\\n\\n- The Dapr pub/sub component to target (in this case pubsub )\", \".\\n- The topic to subscribe to (in this case newOrder ).\\n\\nDapr then invokes that action method as it \", \"receives messages for that topic.\\n\\nYou'll also need to enable ASP.NET Core to use Dapr. The Dapr .NE\", \"T SDK provides several extension methods that can be used to do this.\\n\\nIn the Program.cs file, you m\", \"ust call the following extension method on the WebApplication builder to register Dapr:\\n\\n```\\nvar bui\", \"lder = WebApplication.CreateBuilder(args); builder.Services.AddControllers().AddDapr();\\n```\\n\\nAppendi\", \"ng the AddDapr extension method to the AddControllers extension method registers the necessary servi\", \"ces to integrate Dapr into the MVC pipeline. It also registers a DaprClient instance into the depend\", \"ency injection container, which then can be injected anywhere into your service.\\n\\nAfter the WebAppli\", \"cation has been created, you must add the following middleware components to enable Dapr:\\n\\n```\\nvar b\", \"uilder = WebApplication.CreateBuilder(args); var app = builder.Build(); app.UseCloudEvents(); app.Ma\", \"pControllers(); app.MapSubscribeHandler();\\n```\\n\\nThe call to UseCloudEvents adds CloudEvents middlewa\", \"re into to the ASP.NET Core middleware pipeline. This middleware will unwrap requests that use the C\", \"loudEvents structured format, so the receiving method can read the event payload directly.\\n\\n## Note\\n\", \"\\nCloudEvents is a standardized messaging format, providing a common way to describe event informatio\", \"n across platforms. Dapr embraces CloudEvents. For more information about CloudEvents, see the cloud\", \"events specification.\\n\\nThe call to MapSubscribeHandler in the endpoint routing configuration will ad\", \"d a Dapr subscribe endpoint to the application. This endpoint will respond to requests on /dapr/subs\", \"cribe . When this endpoint is called, it will automatically find all WebAPI action methods decorated\", \" with the Topic attribute and instruct Dapr to create subscriptions for them.\\n\\n## Pub/sub components\", \"\\n\\nDapr pub/sub components handle the actual transport of the messages. Several are available. Each e\", \"ncapsulates a specific message broker product to implement the pub/sub functionality. At the time of\", \" writing, the following pub/sub components were available:\\n\\n- Apache Kafka\\n- AWS SNS/SQS\\n- Azure Eve\", \"nt Hubs\\n- Azure Service Bus\\n- GCP Pub/Sub\\n- Hazelcast\\n- In Memory\\n- JetStream\\n- MQTT\\n- NATS Streamin\", \"g\\n- Pulsar\\n- RabbitMQ\\n- Redis Streams\\n\\n## Note\\n\\nThe Azure cloud stack has both messaging functionali\", \"ty (Azure Service Bus) and event streaming (Azure Event Hub) availability.\\n\\nThese components are cre\", \"ated by the community in a component-contrib repository on GitHub. You're encouraged to write your o\", \"wn Dapr component for a message broker that isn't yet supported.\\n\\n## Configuration\\n\\nUsing a Dapr con\", \"figuration file, you can specify the pub/sub component(s) to use. This configuration contains severa\", \"l fields. The name field specifies the pub/sub component that you want to use. When sending or recei\", \"ving a message, you need to specify this name (as you saw earlier in the PublishEventAsync method si\", \"gnature).\\n\\nBelow you see an example of a Dapr configuration file for configuring a RabbitMQ message \", \"broker component:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: pubsub-rq spec: \", \"type: pubsub.rabbitmq version: v1 metadata: -name: host value: \\\"amqp://localhost:5672\\\" -name: durabl\", \"e value: true\\n```\\n\\nIn this example, you can see that you can specify any message broker-specific con\", \"figuration in the metadata block. In this case, RabbitMQ is configured to create durable queues. But\", \" the RabbitMQ component has more configuration options. Each of the components' configuration will h\", \"ave its own set of possible fields. You can read which fields are available in the documentation of \", \"each pub/sub component.\\n\\nNext to the programmatic way of subscribing to a topic from code, Dapr pub/\", \"sub also provides a declarative way of subscribing to a topic. This approach removes the Dapr depend\", \"ency from the application code. Therefore, it also enables an existing application to subscribe to t\", \"opics without any changes to the code. The following example shows a Dapr configuration file for con\", \"figuring a subscription:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Subscription metadata: name: newOrd\", \"er-subscription spec: pubsubname: pubsub topic: newOrder route: /orders scopes: -ServiceB -ServiceC\\n\", \"```\\n\\nYou have to specify several elements with every subscription:\\n\\n- The name of the Dapr pub/sub c\", \"omponent you want to use (in this case pubsub ).\\n- The name of the topic to subscribe to (in this ca\", \"se newOrder ).\\n- The API operation that needs to be called for this topic (in this case /orders ).\\n-\", \" The scope can specify which services can publish and subscribe to a topic.\\n\\n## Sample application: \", \"Dapr Traffic Control\\n\\nIn Dapr Traffic Control sample app, the TrafficControl service uses the Dapr p\", \"ub/sub building block to send speeding violations to the FineCollection service. Figure 7-4 shows th\", \"e conceptual architecture\\n\\nof the Dapr Traffic Control sample application. The Dapr pub/sub building\", \" block is used in flows marked with number 2 in the diagram:\\n\\n:::image type='content' source='./medi\", \"a/publish -subscribe/dapr-solution-pubsub.png' alt -text='Conceptual architecture of the Dapr Traffi\", \"c Control sample application.':::\\n\\nFigure 7-4. Conceptual architecture of the Dapr Traffic Control s\", \"ample application.\\n\\nSpeeding violations are handled by the CollectionController , an ordinary ASP.NE\", \"T Core Controller. The CollectionController.CollectFine method subscribes to and handles SpeedingVio\", \"lation event messages:\\n\\n```\\n[Topic(\\\"pubsub\\\", \\\"speedingviolations\\\")] [Route(\\\"collectfine\\\")] [HttpPost\", \"] public async Task<ActionResult> CollectFine( SpeedingViolation speedingViolation, [FromServices] D\", \"aprClient daprClient) { // ... }\\n```\\n\\nThe method is decorated with the Dapr Topic attribute. It spec\", \"ifies that the pub/sub component named pubsub should be used to subscribe to messages sent to the sp\", \"eedingviolations topic.\\n\\nThe TrafficControl service sends speeding violations. Near the end of the V\", \"ehicleExit method in the TrafficController class, the DaprClient object is used to publish SpeedingV\", \"iolation messages using the pub/sub building block:\\n\\n```\\n/// ... var speedingViolation = new Speedin\", \"gViolation { VehicleId = msg.LicenseNumber, RoadId = _roadId, ViolationInKmh = violation, Timestamp \", \"= msg.Timestamp }; // publish speedingviolation (Dapr publish / subscribe) await daprClient.PublishE\", \"ventAsync(\\\"pubsub\\\", \\\"speedingviolations\\\", speedingViolation); /// ...\\n```\\n\\nNote how the DaprClient o\", \"bject reduces the call to a single line of code, again, binding to the speedingviolations topic and \", \"the Dapr pubsub component.\\n\\nWhile the Traffic Control app uses RabbitMQ as the message broker, it ne\", \"ver directly references RabbitMQ. Instead, the accompanying Dapr component configuration file named \", \"pubsub.yaml in the /dapr/components folder specifies the message broker:\\n\\n```\\napiVersion: dapr.io/v1\", \"alpha1 kind: Component metadata: name: pubsub namespace: dapr-trafficcontrol spec: type: pubsub.rabb\", \"itmq\\n```\\n\\n```\\nversion: v1 metadata: -name: host value: \\\"amqp://localhost:5672\\\" -name: durable value:\", \" \\\"false\\\" -name: deletedWhenUnused value: \\\"false\\\" -name: autoAck value: \\\"false\\\" -name: reconnectWait \", \"value: \\\"0\\\" -name: concurrency value: parallel scopes: -trafficcontrolservice -finecollectionservice\\n\", \"```\\n\\nThe type element in the configuration, pubsub.rabbitmq instructs the building block to use the \", \"Dapr RabbitMQ component.\\n\\nThe scopes element in the configuration constrains application access to t\", \"he RabbitMQ component. Only the TrafficControl and FineCollection services can consume it.\\n\\nUsing Da\", \"pr pub/sub in the Traffic Control sample application offers the following benefits:\\n\\n1. No infrastru\", \"ctural abstraction of a message broker to maintain.\\n2. Services are temporally decoupled, which incr\", \"eases robustness.\\n3. Publisher and subscribers are unaware of each other. This means that additional\", \" services could be introduced that will react to speeding violations in the future, without the need\", \" to change the TrafficControl service.\\n\\n## Summary\\n\\nThe pub/sub pattern helps you decouple services \", \"in a distributed application. The Dapr publish &amp; subscribe building block simplifies implementin\", \"g this behavior in your application.\\n\\nThrough Dapr pub/sub, you can publish messages to a specific t\", \"opic . As well, the building block will query your service to determine which topic(s) to subscribe \", \"to.\\n\\nYou can use Dapr pub/sub natively over HTTP or by using one of the language-specific SDKs, such\", \" as the .NET SDK for Dapr. The .NET SDK tightly integrates with the ASP.NET core platform.\\n\\nWith Dap\", \"r, you can plug a supported message broker product into your application. You can then swap message \", \"brokers without requiring code changes to your application.\\n\\n## References\\n\\n- Dapr supported pub/sub\", \" brokers\\n\\nExternal\\n\\nResource\\n\\nTwitter\\n\\n\\u2192\\n\\nDapr dapr\\n\\nSidecar\\n\\nYour service\\n\\nExternal\\n\\nResource\\n\\n\\u2192\\n\\nT\", \"wilio SMS\\n\\n## The Dapr bindings building block\\n\\nCloud-based serverless offerings, such as Azure Func\", \"tions and AWS Lambda, have gained wide adoption across the distributed architecture space. Among man\", \"y benefits, they enable a microservice to handle events from or invoke events in an external system \", \"- abstracting away the underlying complexity and plumbing concerns. External resources are many: The\", \"y include datastores, message systems, and web resources, across different platforms and vendors. Th\", \"e Dapr bindings building block brings these same resource binding capabilities to the doorstep of yo\", \"ur Dapr applications.\\n\\n## What it solves\\n\\nDapr resource bindings enable your services to integrate b\", \"usiness operations across external resources outside of the immediate application. An event from an \", \"external system could trigger an operation in your service passing in contextual information. Your s\", \"ervice could then expand the operation by triggering an event in another external system, passing in\", \" contextual payload information. Your service communicates without coupling or awareness of the exte\", \"rnal resource. The plumbing is encapsulated inside pre-defined Dapr components. The Dapr component t\", \"o use can be easily swapped at run time without code changes.\\n\\nConsider, for example, a Twitter acco\", \"unt that triggers an event whenever a user tweets a keyword. Your service exposes an event handler t\", \"hat receives and processes the tweet. Once complete, your service triggers an event that invokes an \", \"external Twilio service. Twilio sends an SMS message that includes the tweet. Figure 8-1 show the co\", \"nceptual architecture of this operation:\\n\\nFigure 8-1. Conceptual architecture of a Dapr resource bin\", \"ding.\\n\\nAt first glance, resource binding behavior may appear similar to the Publish/Subscribe patter\", \"n described earlier in this book. While they share similarities, there are differences. Publish/subs\", \"cribe\\n\\n\\u2192\\n\\nDapr dapr\\n\\nSidecar\\n\\n## How it works\\n\\nPOST http://localhost:6000/tweet focuses on asynchron\", \"ous communication between Dapr services. Resource binding has a much wider scope. It focuses on syst\", \"em interoperability across software platforms. Exchanging information between disparate applications\", \", datastores, and services outside your microservice application.\\n\\nYour service\\n\\nDapr resource bindi\", \"ng starts with a component configuration file. This YAML file describes the type of resource to whic\", \"h you'll bind along with its configuration settings. Once configured, your service can receive event\", \"s from the resource or trigger events on it.\\n\\n| Note                                                \", \"                            |\\n|---------------------------------------------------------------------\", \"------------|\\n| Binding configurations are presented in detail later in the Components section. |\\n\\n#\", \"# Input bindings\\n\\nBinding configuration\\n\\nInput bindings trigger your code with incoming events from \", \"external resources. To receive events and data, you register a public endpoint from your service tha\", \"t becomes the event handler . Figure 8-2 shows the flow:\\n\\nFigure 8-2. Dapr input binding flow.\\n\\nFigu\", \"re 8.2 describes the steps for receiving events from an external Twitter account:\\n\\ncomponent\\n\\n1. The\", \" Dapr sidecar reads the binding configuration file and subscribes to the event specified for the ext\", \"ernal resource. In the example, the event source is a Twitter account.\\n2. When a matching Tweet is p\", \"ublished on Twitter, the binding component running in the Dapr sidecar picks it up and triggers an e\", \"vent.\\n3. The Dapr sidecar invokes the endpoint (that is, event handler) configured for the binding. \", \"In the example, the service listens for an HTTP POST on the /tweet endpoint on port 6000. Because i \", \"t's an HTTP POST operation, the JSON payload for the event is passed in the request body.\\n4. After h\", \"andling the event, the service returns an HTTP status code 200 OK .\\n\\nThe following ASP.NET Core cont\", \"roller provides an example of handling an event triggered by the Twitter binding:\\n\\n```\\n[ApiControlle\", \"r] public class SomeController : ControllerBase { public class TwitterTweet { [JsonPropertyName(\\\"id_\", \"str\\\")] public string ID { get ; set ; } [JsonPropertyName(\\\"text\\\")] public string Text { get ; set ; \", \"} } [HttpPost(\\\"/tweet\\\")] public ActionResult Post(TwitterTweet tweet) { // Handle tweet Console.Writ\", \"eLine(\\\"Tweet received: {0}: {1}\\\", tweet.ID, tweet.Text); // ... // Acknowledge message return Ok(); \", \"} }\\n```\\n\\nIf the operation should error, you would return the appropriate 400 or 500 level HTTP statu\", \"s code. For bindings that feature at-least-once delivery guarantees, the Dapr sidecar will retry the\", \" trigger. Check out Dapr documentation for resource bindings to see whether they offer at-least-once\", \" or exactly-once delivery guarantees.\\n\\n## Output bindings\\n\\nDapr also includes output binding capabil\", \"ities. They enable your service to trigger an event that invokes an external resource. Again, you st\", \"art by configuring a binding configuration YAML file that describes the output binding. Once in plac\", \"e, you trigger an event that invokes the bindings API on the Dapr sidecar of your application. Figur\", \"e 8-3 shows the flow of an output binding:\\n\\nPOST http://localhost:3500/v1.0/bindings/sms\\n\\n7=\\u2022\\n\\n=\\n\\n=\\n\", \"\\nYour service\\n\\nBinding configuration\\n\\nFigure 8-3. Dapr output binding flow.\\n\\n1. The Dapr sidecar rea\", \"ds the binding configuration file with the information on how to connect to the external resource. I\", \"n the example, the external resource is a Twilio SMS account.\\n2. Your application invokes the /v1.0/\", \"bindings/sms endpoint on the Dapr sidecar. In this case, it uses an HTTP POST to invoke the API. It'\", \"s also possible to use gRPC.\\n3. The binding component running in the Dapr sidecar calls the external\", \" messaging system to send the message. The message will contain the payload passed in the POST reque\", \"st.\\n\\nAs an example, you can invoke an output binding by invoking the Dapr API using curl:\\n\\n```\\ncurl \", \"-X POST http://localhost:3500/v1.0/bindings/sms \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"data\\\"\", \": \\\"Welcome to this awesome service\\\", \\\"metadata\\\": { \\\"toNumber\\\": \\\"555-3277\\\" }, \\\"operation\\\": \\\"create\\\" }\", \"'\\n```\\n\\nNote that the HTTP port is the same as used by the Dapr sidecar (in this case, the default Da\", \"pr HTTP port 3500 ).\\n\\nThe structure of the payload (that is, message sent) will vary per binding. In\", \" the example above, the payload contains a data element with a message. Bindings to other types of e\", \"xternal resources can be different, especially for the metadata that is sent. Each payload must also\", \" contain an operation field,\\n\\nDapr\\n\\nExternal\\n\\nthat defines the operation the binding will execute. T\", \"he above example specifies a create operation that creates the SMS message. Common operations includ\", \"e:\\n\\n- create\\n- get\\n- delete\\n- list\\n\\nIt's up to the author of the binding which operations the bindin\", \"g supports. The documentation for each binding describes the available operations and how to invoke \", \"them.\\n\\n## Use the Dapr .NET SDK\\n\\nThe Dapr .NET SDK provides language-specific support for .NET devel\", \"opers. In the following example, the call to the HttpClient.PostAsync() is replaced with the DaprCli\", \"ent.InvokeBindingAsync() method. This specialized method simplifies invoking a configured output bin\", \"ding:\\n\\n```\\nprivate async Task SendSMSAsync([FromServices] DaprClient daprClient) { var message = \\\"We\", \"lcome to this awesome service\\\"; var metadata = new Dictionary<string, string> { { \\\"toNumber\\\", \\\"555-3\", \"277\\\" } }; await daprClient.InvokeBindingAsync(\\\"sms\\\", \\\"create\\\", message, metadata); }\\n```\\n\\nThe method\", \" expects the metadata and message values.\\n\\nWhen used to invoke a binding, the DaprClient uses gRPC t\", \"o call the Dapr API on the Dapr sidecar.\\n\\n## Binding components\\n\\nUnder the hood, resource bindings a\", \"re implemented with Dapr binding components. They're contributed by the community and written in Go.\", \" If you need to integrate with an external resource for which no Dapr binding exists yet, you can cr\", \"eate it yourself. Check out the Dapr componentscontrib repo to see how you can contribute a binding.\", \"\\n\\n## Note\\n\\nDapr and all of its components are written in the Golang (Go) language. Go is considered \", \"a modern, cloud-native programming platform.\\n\\nYou configure bindings using a YAML configuration file\", \". Here's an example configuration for the Twitter binding:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: C\", \"omponent metadata: name: twitter-mention\\n```\\n\\n```\\nnamespace: default spec: type: bindings.twitter ve\", \"rsion: v1 metadata: -name: consumerKey value: \\\"****\\\" # twitter api consumer key, required -name: con\", \"sumerSecret value: \\\"****\\\" # twitter api consumer secret, required -name: accessToken value: \\\"****\\\" #\", \" twitter api access token, required -name: accessSecret value: \\\"****\\\" # twitter api access secret, r\", \"equired -name: query value: \\\"dapr\\\" # your search query, required\\n```\\n\\nEach binding configuration con\", \"tains a general metadata element with a name and namespace field. Dapr will determine the endpoint t\", \"o invoke your service based upon the configured name field. In the above example, Dapr will invoke t\", \"he method annotated with /twitter-mention in your service when an event occurs.\\n\\nIn the spec element\", \", you specify the type of the binding along with binding specific metadata . The example specifies c\", \"redentials for accessing a Twitter account using its API. The metadata can differ between input and \", \"output bindings. For example, to use Twitter as an input binding, you need to specify the text to se\", \"arch for in tweets using the query field. Every time a matching tweet is sent, the Dapr sidecar will\", \" invoke the /twitter-mention endpoint on the service. It will also deliver the contents of the tweet\", \".\\n\\nA binding can be configured for input, output, or both. Interestingly, the binding doesn't explic\", \"itly specify input or output configuration. Instead, the direction is inferred by the usage of the b\", \"inding along with configuration values.\\n\\nThe Dapr documentation for resource bindings provides a com\", \"plete list of the available bindings and their specific configuration settings.\\n\\n## Cron binding\\n\\nPa\", \"y close attention to Dapr's Cron binding. It doesn't subscribe to events from an external system. In\", \"stead, this binding uses a configurable interval schedule to trigger your application. The binding p\", \"rovides a simple way to implement a background worker to wake up and do some work at a regular inter\", \"val, without the need to implement an endless loop with a configurable delay. Here's an example of a\", \" Cron binding configuration:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: check\", \"OrderBacklog namespace: default spec: type: bindings.cron version: v1 metadata: -name: schedule valu\", \"e: \\\"@every 30m\\\"\\n```\\n\\nTrafficControl\\n\\nCamera\\n\\nIn this example, Dapr triggers a service by invoking th\", \"e /checkOrderBacklog endpoint every 30 minutes. There are several patterns available for specifying \", \"the schedule value. For more information, see the Cron binding documentation.\\n\\n2\\n\\n## Sample applicat\", \"ion: Dapr Traffic Control\\n\\nIn the Dapr Traffic Control sample application, the TrafficControl servic\", \"e uses the MQTT input binding to retrieve messages from the CameraSimulation. Figure 8-4 shows the c\", \"onceptual architecture of the Dapr Traffic Control sample application. The Dapr input binding is use\", \"d in flows marked with number 5 in the diagram:\\n\\nSendFine\\n\\nFineCollection\\n\\nService\\n\\nVehicleRegistrat\", \"ion\\n\\nService\\n\\nService invocation\\n\\n2\\n\\nPublish / subscribe\\n\\nFigure 8-4. Conceptual architecture of the\", \" Dapr Traffic Control sample application.\\n\\n12 - 3\\n\\nEntryCam\\n\\n## MQTT input binding\\n\\nMQTT is a lightw\", \"eight pub/sub messaging protocol, often used in IoT scenarios. Producers sent MQTT messages to a top\", \"ic; subscribers then retrieve messages from the topic. There are several MQTT message broker product\", \"s available. The Traffic Control sample application uses Eclipse Mosquitto.\\n\\nThe CameraSimulation do\", \"esn't depend on any Dapr building blocks. It uses the System.Net.Mqtt library to send MQTT messages:\", \"\\n\\n```\\n// ... // simulate entry DateTime entryTimestamp = DateTime.Now; var vehicleRegistered = new V\", \"ehicleRegistered { Lane = _camNumber, LicenseNumber = GenerateRandomLicenseNumber(), Timestamp = ent\", \"ryTimestamp }; _trafficControlService.SendVehicleEntry(vehicleRegistered); // ...\\n```\\n\\nThe code uses\", \" a proxy of type ITrafficControlService to call the TrafficControl service. .NET injects an implemen\", \"tation of the ITrafficControlService interface using constructor injection:\\n\\n:::{custom-style=CodeBo\", \"x} csharp public CameraSimulation(int camNumber, ITrafficControlService trafficControlService) {    \", \" _camNumber = camNumber;     _trafficControlService = trafficControlService; } :::\\n\\nThe MqttTrafficC\", \"ontrolService class implements the ITrafficControlService interface. It exposes two methods: SendVeh\", \"icleEntryAsync and SendVehicleExitAsync . They both use the MQTT client to send messages to the traf\", \"ficcontrol/entrycam and trafficcontrol/exitcam topics respectively:\\n\\n```\\npublic async Task SendVehic\", \"leEntryAsync(VehicleRegistered vehicleRegistered) { var eventJson = JsonSerializer.Serialize(vehicle\", \"Registered); var message = new MqttApplicationMessage(\\\"trafficcontrol/entrycam\\\", Encoding.UTF8.GetBy\", \"tes(eventJson)); await _client.PublishAsync(message, MqttQualityOfService.AtMostOnce); } public asyn\", \"c Task SendVehicleExitAsync(VehicleRegistered vehicleRegistered) { var eventJson = JsonSerializer.Se\", \"rialize(vehicleRegistered); var message = new MqttApplicationMessage(\\\"trafficcontrol/exitcam\\\", Encod\", \"ing.UTF8.GetBytes(eventJson)); await _client.PublishAsync(message, MqttQualityOfService.AtMostOnce);\", \" }\\n```\\n\\nThe constructor sets up the MQTT client to send messages to the MQTT broker (Mosquitto) runn\", \"ing on port 1883.\\n\\nOn the other end, the TrafficControl service uses the MQTT input binding to recei\", \"ve VehicleRegistered messages sent by the CameraSimulation. For each subscribed topic, there's a\\n\\nse\", \"parate component configuration file in the /dapr/components folder. The first one is entrycam.yaml :\", \"\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: entrycam namespace: dapr-trafficc\", \"ontrol spec: type: bindings.mqtt version: v1 metadata: -name: url value: mqtt://localhost:1883 -name\", \": topic value: trafficcontrol/entrycam scopes: -trafficcontrolservice\\n```\\n\\nThe configuration specifi\", \"es the binding type: bindings.mqtt . It also specifies that the broker runs on localhost:1883 , the \", \"standard port that Mosquitto uses. It also exposes the topic , trafficcontrol/entrycam . Using scope\", \"s , the config file specifies that only the service with app-id trafficcontrolservice will have acce\", \"ss to the binding.\\n\\nWhen the TrafficControl service starts, the Dapr sidecar automatically subscribe\", \"s to the trafficcontrol/entrycam MQTT topic specified in the component configuration. When messages \", \"arrive on the topic, the Dapr sidecar invokes an HTTP endpoint on your service. The sidecar determin\", \"es the URL of the HTTP endpoint to call by looking at the metadata.name field in the binding configu\", \"ration. In the example above, the endpoint URL is /entrycam . Within the TrafficControl service, no \", \"code needs to be added to support the endpoint:\\n\\n```\\n[HttpPost(\\\"entrycam\\\")] public async Task<Action\", \"Result> VehicleEntry(VehicleRegistered msg) { // ... }\\n```\\n\\nThe exitcam.yaml component configuration\", \" file configures everything for the exitcam endpoint:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Compon\", \"ent metadata: name: exitcam namespace: dapr-trafficcontrol spec: type: bindings.mqtt version: v1 met\", \"adata: -name: url value: mqtt://localhost:1883 -name: topic value: trafficcontrol/exitcam scopes: -t\", \"rafficcontrolservice\\n```\\n\\nTrafficControl\\n\\n5\\n\\ndapr\\n\\n## SMTP output binding\\n\\nmosquitto\\n\\nThe FineCollec\", \"tion service uses the Dapr SMTP output binding to send emails. Figure 8-5 shows the conceptual archi\", \"tecture of the Dapr Traffic Control sample application. The Dapr input binding is used in flows mark\", \"ed with number 4 in the diagram:\\n\\nRedis\\n\\nFineCollection\\n\\nService\\n\\nVehicleRegistration\\n\\nService\\n\\n2\\n\\nF\", \"igure 8-5. Conceptual architecture of the Dapr Traffic Control sample application.\\n\\nThe CollectFine \", \"method on the CollectionController in the FineCollection service contains code that uses the Dapr cl\", \"ient to invoke the output binding:\\n\\n```\\n// ... // send fine by email (Dapr output binding) var body \", \"= EmailUtils.CreateEmailBody(speedingViolation, vehicleInfo, fineString); var metadata = new Diction\", \"ary<string, string> { [\\\"emailFrom\\\"] = \\\"noreply@cfca.gov\\\", [\\\"emailTo\\\"] = vehicleInfo.OwnerEmail,\\n```\\n\", \"\\n12 - 3\\n\\nEntryCam\\n\\n5\\n\\nCamera\\n\\nSimulation\\n\\n```\\n[\\\"subject\\\"] = $\\\"Speeding violation on the {speedingVio\", \"lation.RoadId}\\\" }; await daprClient.InvokeBindingAsync(\\\"sendmail\\\", \\\"create\\\", body, metadata); // ...\", \"\\n```\\n\\nThe code uses a simple utility class to create an HTML email body containing the necessary inf\", \"ormation. It also creates a dictionary with metadata specific to the SMTP binding. This binding comp\", \"onent interprets the metadata when invoked.\\n\\nThe following arguments are required to invoke the bind\", \"ing:\\n\\n- The name of the binding component. In this case sendmail .\\n- The operation the binding needs\", \" to perform. In this case create .\\n- The body of the message to send. In this case, the HTML email b\", \"ody.\\n- The metadata for sending the email.\\n\\nThe Dapr output binding named sendmail is configured in \", \"the email.yaml component configuration file in the /dapr/components folder:\\n\\n```\\napiVersion: dapr.io\", \"/v1alpha1 kind: Component metadata: name: sendmail namespace: dapr-trafficcontrol spec: type: bindin\", \"gs.smtp version: v1 metadata: -name: host value: localhost -name: port value: 4025 -name: user secre\", \"tKeyRef: name: smtp.user key: smtp.user -name: password secretKeyRef: name: smtp.password key: smtp.\", \"password -name: skipTLSVerify value: true auth: secretStore: trafficcontrol-secrets scopes: -finecol\", \"lectionservice\\n```\\n\\nThe configuration specifies the binding type: bindings.smtp .\\n\\nThe metadata sect\", \"ion contains the information for connecting to the SMTP server. See the binding's documentation for \", \"specific metadata required for this binding. The username and password to connect to the SMTP server\", \" are retrieved from a secrets store. See the Secrets management building block chapter for more info\", \"rmation on how this works.\\n\\nThe scopes element specifies that only the service with app-id finecolle\", \"ctonservice can access this binding.\\n\\nThe Traffic Control sample application uses MailDev. MailDev i\", \"s a development SMTP server that doesn't actually send out emails (by default). Instead, it collects\", \" emails and presents them in an in box web application. MailDev is extremely useful for dev/test and\", \" demo scenarios.\\n\\nUsing Dapr bindings in the Traffic Control sample application provides the followi\", \"ng benefits:\\n\\n1. Using MQTT messaging and SMTP without the need to learn this protocol or a specific\", \" MQTT API.\\n2. Using SMTP to send an email without the need to learn this protocol or a specific SMTP\", \" API.\\n\\n## Summary\\n\\nDapr resource bindings enable you to integrate with different external resources \", \"and systems without taking dependencies on their libraries o r SDKs. These external systems don't ne\", \"cessarily have to be messaging systems like a service bus or message broker. Bindings also exist for\", \" datastores and web resources like Twitter or SendGrid.\\n\\nInput bindings (or triggers) react to event\", \"s occurring in an external system. They invoke the public HTTP endpoints pre-configured in your appl\", \"ication. Dapr uses the name of the binding in the configuration to determine the endpoint to call in\", \" your application.\\n\\nOutput bindings will send messages to an external system. You trigger an output \", \"binding by doing an HTTP POST on the /v1.0/bindings/&lt;binding-name&gt; endpoint on the Dapr sideca\", \"r. You can also use gRPC to invoke the binding. The .NET SDK offers a InvokeBindingAsync method to i\", \"nvoke Dapr bindings using gRPC.\\n\\nYou implement a binding with a Dapr component. These components are\", \" contributed by the community. Each binding component's configuration has metadata that is specific \", \"for the external system it abstracts. Also, the commands it supports and the structure of the payloa\", \"d will differ per binding component.\\n\\n## References\\n\\n- Dapr documentation for resource bindings\\n- Mo\", \"squitto MQTT broker\\n- MailDev development SMTP server\\n\\n## The Dapr actors building block\\n\\nThe actor \", \"model originated in 1973. It was proposed by Carl Hewitt as a conceptual model of concurrent computa\", \"tion, a form of computing in which several computations are executed at the same time. Highly parall\", \"el computers weren't yet available at that tim e, but the more recent advancements of multi-core CPU\", \"s and distributed systems have made the actor model popular.\\n\\nIn the actor model, the actor is an in\", \"dependent unit of compute and state. Actors are completely isolated from each other and they will ne\", \"ver share memory. Actors communicate with each other using messages. When an actor receives a messag\", \"e, it can change its internal state, and send messages to other (possibly new) actors.\\n\\nThe reason w\", \"hy the actor model makes writing concurrent systems easier is that it provides a turnbased (or singl\", \"e-threaded) access model. Multiple actors can run at the same time, but each actor will process rece\", \"ived messages one at a time. This means that you can be sure that at most one thread is active insid\", \"e an actor at any time. That makes writing correct concurrent and parallel systems much easier.\\n\\n## \", \"What it solves\\n\\nActor model implementations are usually tied to a specific language or platform. Wit\", \"h the Dapr actors building block however, you can leverage the actor model from any language or plat\", \"form.\\n\\nDapr's implementation is based on the virtual actor pattern introduced by Project 'Orleans' .\", \" With the virtual actor pattern, you don't need to explicitly create actors. Actors are activated im\", \"plicitly and placed on a node in the cluster the first time a message is sent to the actor. When not\", \" executing operations, actors are silently unloaded from memory. If a node fails, Dapr automatically\", \" moves activated actors to healthy nodes. Besides sending messages between actors, the Dapr actor mo\", \"del also support scheduling future work using timers and reminders.\\n\\nWhile th e actor model can prov\", \"ide great benefits, it's important to carefully consider the actor design. For example, having many \", \"clients call the same actor will result in poor performance because the actor operations execute ser\", \"ially. Here are some criteria to check if a scenario is a good fit for Dapr actors:\\n\\n- Your problem \", \"space involves concurrency. Without actors, you'd have to introduce explicit locking mechanisms in y\", \"our code.\\n\\n- Your problem space can be partitioned into small, independent, and isolated units of st\", \"ate and logic.\\n- You don't need low -latency reads of the actor state. Low-latency reads cannot be g\", \"uaranteed because actor operations execute serially.\\n- You don't need to query state across a set of\", \" actors. Querying across actors is inefficient because each actor's state needs to be read individua\", \"lly and can introduce unpredictable latencies.\\n\\nOne design pattern that fits these criteria quite we\", \"ll is the orchestration-based saga or process manager design pattern. A saga manages a sequence of s\", \"teps that must be taken to reach some outcome. The saga (or process manager) maintains the current s\", \"tate of the sequence and triggers the next step. If a step fails, the saga can execute compensating \", \"actions. Actors make it easy to deal with concurrency in the saga and to keep track of the current s\", \"tate. The eShopOnDapr reference application uses the saga pattern and Dapr actors to implement the O\", \"rdering process.\\n\\n## How it works\\n\\nThe Dapr sidecar provides the HTTP/gRPC API to invoke actors. Thi\", \"s is the base URL of the HTTP API:\\n\\nhttp://localhost:&lt;daprPort&gt;/v1.0/actors/&lt;actorType&gt;/\", \"&lt;actorId&gt;/\\n\\n- &lt;daprPort&gt; : the HTTP port that Dapr listens on.\\n- &lt;actorType&gt; : the\", \" actor type.\\n- &lt;actorId&gt; : the ID of the specific actor to call.\\n\\nThe sidecar manages how, whe\", \"n and where each actor runs, and also routes messages between act ors. When an actor hasn't been use\", \"d for a period of time, the runtime deactivates the actor and removes it from memory. Any state mana\", \"ged by the actor is persisted and will be available when the actor re-activates. Dapr uses an idle t\", \"imer to determine when an actor can be deactivated. When an operation is called on the actor (either\", \" by a method call or a reminder firing), the idle timer is reset and the actor instance will remain \", \"activated.\\n\\nThe sidecar API is only one part of the equation. The service itself also needs to imple\", \"ment an API specification, because the actual code that you write for the actor will run inside the \", \"service itself. Figure 11-1 shows the various API calls between the service and its sidecar:\\n\\nServic\", \"e\\n\\nInvoke actor method\\n\\nGet/persist actor state\\n\\nCreate/Get/Delete reminder -\\n\\n\\u2192\\n\\nFigure 11-1. API c\", \"alls between actor service and Dapr sidecar.\\n\\nTo provide scalability and reliability, actors are par\", \"titioned across all the instances of the actor service. The Dapr placement service is responsible fo\", \"r keeping track of the partitioning information. When a new instance of an actor service is started,\", \" the sidecar registers the supported actor types with the placement service. The placement service c\", \"alculates the updated partitioning information for the given actor type and broadcasts it to all ins\", \"tances. Figure 11-2 shows what happens when a service is scaled out to a second replica:\\n\\n:::image t\", \"ype='content' source='./media/actors/placement.png' alt -text='Diagram of the actor placement servic\", \"e.':::\\n\\nFigure 11-2. Actor placement service.\\n\\n1. On startup, the sidecar makes a call to the actor \", \"service to get the registered actor types as well as actor configuration settings.\\n2. The sidecar se\", \"nds the list of registered actor types to the placement service.\\n3. The placement service broadcasts\", \" the updated partitioning information to all actor service instances. Each instance will keep a cach\", \"ed copy of the partitioning information and use it to invoke actors.\\n\\n## Important\\n\\nBecause actors a\", \"re randomly distributed across service instances, it should be expected that an actor operation alwa\", \"ys requires a call to a different node in the network.\\n\\nPOST http://localhost:3500/1.0/actors/OrderA\", \"ctor/3/method/ship\\n\\nThe next figure shows an ordering service instance running in Pod 1 call the shi\", \"p method of an OrderActor instance with ID 3 . Because the actor with ID 3 is placed in a different \", \"instance, this results in a call to a different node in the cluster:\\n\\nOrdering\\n\\nService\\n\\nOrdering\\n\\nS\", \"ervice\\n\\nFigure 11-3. Calling an actor method.\\n\\n1. The service calls the actor API on the sidecar. Th\", \"e JSON payload in the request body contains the data to send to the actor.\\n2. The sidecar uses the l\", \"ocally cached partitioning information from the placement service to determine which actor service i\", \"nstance (partition) is responsible for hosting the actor with ID 3 . In this example, it's the servi\", \"ce instance in pod 2. The call is forwarded to the appropriate sidecar.\\n3. The sidecar instance in p\", \"od 2 calls the service instance to invoke the actor. The service instance activates the actor (if it\", \" hasn't already) and executes the actor method.\\n\\nActor\\n\\nActor dapr Sidecar\\n\\n## Turn-based access mod\", \"el\\n\\nThe turnbased access model ensures that at any time there's at most one thread active inside an \", \"actor instance. To understand why this is useful, consider the following example of a method that in\", \"crements a counter value:\\n\\n```\\npublic int Increment() { var currentValue = GetValue(); var newValue \", \"= currentValue + 1; SaveValue(newValue); return newValue; }\\n```\\n\\nLet's assume that th e current valu\", \"e returned by the GetValue method is 1 . When two threads call the Increment method at the same time\", \", there's a risk of both of them calling the GetValue method before one of them calls SaveValue . Th\", \"is results in both threads starting with the same initial value ( 1 ). The threads then increment th\", \"e value to 2 and return it to the caller. The resulting value after the two calls is now 2 instead o\", \"f 3 which it should be. This is a simple example to illustrate the kind of issues that can slip into\", \" your code when working with multiple threads, and is easy to solve. In real world applications howe\", \"ver, concurrent and parallel scenarios can become very complex.\\n\\nIn traditional programming models, \", \"you can solve this problem by introducing locking mechanisms. For example:\\n\\n```\\npublic int Increment\", \"() { int newValue; lock (_lockObject) { var currentValue = GetValue(); newValue = currentValue + 1; \", \"SaveValue(newValue); } return newValue; }\\n```\\n\\nUnfortunately, using explicit locking mechanisms is e\", \"rror-prone. They can easily lead to deadlocks and can have serious impact on performance.\\n\\nThanks to\", \" the turnbased access model, you don't need to worry about multiple threads with actors, making it m\", \"uch easier to write concurrent systems. The following actor example closely mirrors the code from th\", \"e previous sample, but doesn't require any locking mechanisms to be correct:\\n\\n```\\npublic async Task<\", \"int> IncrementAsync() { var counterValue = await StateManager.TryGetStateAsync<int>(\\\"counter\\\"); var \", \"currentValue = counterValue.HasValue ? counterValue.Value : 0; var newValue = currentValue + 1;\\n```\\n\", \"\\n```\\nawait StateManager.SetStateAsync(\\\"counter\\\", newValue); return newValue; }\\n```\\n\\n## Timers and re\", \"minders\\n\\nActors can use timers and reminders to schedule calls to themselves. Both concepts support \", \"the configuration of a due time. The difference lies in the lifetime of the callback registrations:\\n\", \"\\n- Timers will only stay active as long as the actor is activated. Timers will not reset the idle-ti\", \"mer, so they cannot keep an actor active on their own.\\n- Reminders outlive actor activations. If an \", \"actor is deactivated, a reminder will re-activate the actor. Reminders will reset the idle-timer.\\n\\nT\", \"imers are registered by making a call to the actor API. In the following example, a timer is registe\", \"red with a due time of 0 and a period of 10 seconds.\\n\\n```\\ncurl -X POST http://localhost:3500/v1.0/ac\", \"tors/<actorType>/<actorId>/timers/<name> \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"dueTime\\\": \\\"0\", \"h0m0s0ms\\\", \\\"period\\\": \\\"0h0m10s0ms\\\" }'\\n```\\n\\nBecause the due time is 0, the timer will fire immediately\", \". After a timer callback has finished, the timer will wait 10 seconds before firing again.\\n\\nReminder\", \"s are registered in a similar way. The following example shows a reminder registration with a due ti\", \"me of 5 minutes, and an empty period:\\n\\n```\\ncurl -X POST http://localhost:3500/v1.0/actors/<actorType\", \">/<actorId>/reminders/<name> \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"dueTime\\\": \\\"0h5m0s0ms\\\", \\\"\", \"period\\\": \\\"\\\" }'\\n```\\n\\nThis reminder will fire in 5 minutes. Because the given period is empty, this wi\", \"ll be a one-time reminder.\\n\\n## Note\\n\\nTimers and reminders both respect the turn-based access model. \", \"When a timer or reminder fires, the callback will not be executed until any other method invocation \", \"or timer/reminder callback has finished.\\n\\n## State persistence\\n\\nActor state is persisted using the D\", \"apr state management building block. Because actors can execute multiple state operations in a singl\", \"e turn, the state store component must support multi-item transactions. At the time of writing, the \", \"following state stores support multi-item transactions:\\n\\n- Azure Cosmos DB\\n- MongoDB\\n- MySQL\\n- Postg\", \"reSQL\\n- Redis\\n- RethinkDB\\n- SQL Server\\n\\nTo configure a state store component for use with actors, yo\", \"u need to append the following metadata to the state store configuration:\\n\\n```\\n-name: actorStateStor\", \"e value: \\\"true\\\"\\n```\\n\\nHere's a complete example for a Redis state store:\\n\\n```\\napiVersion: dapr.io/v1a\", \"lpha1 kind: Component metadata: name: statestore spec: type: state.redis version: v1 metadata: -name\", \": redisHost value: localhost:6379 -name: redisPassword value: \\\"\\\" -name: actorStateStore value: \\\"true\", \"\\\"\\n```\\n\\n## Use the Dapr .NET SDK\\n\\nYou can create an actor model implementation using only HTTP/gRPC c\", \"alls. However, it's much more convenient to use the language specific Dapr SDKs. At the time of writ\", \"ing, the .NET, Java and Python SDKs all provide extensive support for working with actors.\\n\\nTo get s\", \"tarted with the .NET Dapr actors SDK, you add a package reference to Dapr.Actors to your service pro\", \"ject. The first step of creating an actual actor is to define an interface that derives from IActor \", \". Clients use the interface to invoke operations on the actor. Here's a simple example o f an actor \", \"interface for keeping scores:\\n\\n```\\npublic interface IScoreActor : IActor { Task<int> IncrementScoreA\", \"sync(); Task<int> GetScoreAsync(); }\\n```\\n\\n## Important\\n\\nThe return type of an actor method must be T\", \"ask or Task&lt;T&gt; . Also, actor methods can have at most one argument. Both the return type and t\", \"he arguments must be System.Text.Json serializable.\\n\\nNext, implement the actor by deriving a ScoreAc\", \"tor class from Actor . The ScoreActor class must also implement the IScoreActor interface:\\n\\n```\\npubl\", \"ic class ScoreActor : Actor, IScoreActor { public ScoreActor(ActorHost host) : base (host) { } // TO\", \"DO Implement interface methods. }\\n```\\n\\nThe constructor in the snippet above takes a host argument of\", \" type ActorHost . The ActorHost class represents the host for an actor type within the actor runtime\", \". You need to pass this argument to the constructor of the Actor base class. Actors also support dep\", \"endency injection. Any additional arguments that you add to the actor constructor are resolved using\", \" the .NET dependency injection container.\\n\\nLet's now implement the IncrementScoreAsync method of the\", \" interface:\\n\\n```\\npublic Task<int> IncrementScoreAsync() { return StateManager.AddOrUpdateStateAsync(\", \" \\\"score\\\", 1, (key, currentScore) => currentScore + 1 ); }\\n```\\n\\nIn the snippet above, a single call t\", \"o StateManager.AddOrUpdateStateAsync provides the full implementation for the IncrementScoreAsync me\", \"thod. The AddOrUpdateStateAsync method takes three arguments:\\n\\n1. The key of the state to update.\\n2.\", \" The value to write if no score is stored in the state store yet.\\n3. A Func to call if there already\", \" is a score stored in the state store. It takes the state key and current score, and returns the upd\", \"ated score to write back to the state store.\\n\\nThe GetScoreAsync implementation reads the current sco\", \"re from the state store and returns it to the client:\\n\\n```\\npublic async Task<int> GetScoreAsync() { \", \"var scoreValue = await StateManager.TryGetStateAsync<int>(\\\"score\\\"); if (scoreValue.HasValue) { retur\", \"n scoreValue.Value; }\\n```\\n\\n```\\nreturn 0; }\\n```\\n\\nTo host actors in an ASP.NET Core service, you must \", \"add a reference to the Dapr.Actors.AspNetCore package and make some changes in the Program file. In \", \"the following example, the call to MapActorsHandlers registers Dapr Actor endpoints in ASP.NET Core \", \"routing:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); var app = builder.Build(); // Actors\", \" building block does not support HTTPS redirection. //app.UseHttpsRedirection(); app.MapControllers(\", \"); // Add actor endpoints. app.MapActorsHandlers();\\n```\\n\\nThe actors endpoints are necessary because \", \"the Dapr sidecar calls the application to host and interact with actor instances.\\n\\n## Important\\n\\nMak\", \"e sure your Program (or Startup ) class does not contain an app.UseHttpsRedirection call to redirect\", \" clients to the HTTPS endpoint. This will not work with actors. By design, a Dapr sidecar sends requ\", \"ests over unencrypted HTTP by default. The HTTPS middleware will block these requests when enabled.\\n\", \"\\nThe Program file is also the place to register the specific actor types. The following example regi\", \"sters the ScoreActor using the AddActors extension method:\\n\\n```\\nvar builder = WebApplication.CreateB\", \"uilder(args); builder.Services.AddActors(options => { options.Actors.RegisterActor<ScoreActor>(); })\", \";\\n```\\n\\nAt this point, the ASP.NET Core service is ready to host the ScoreActor and accept incoming r\", \"equests. Client applications use actor proxies to invoke operations on actors. The following example\", \" shows how a console client application invokes the IncrementScoreAsync operation on a ScoreActor in\", \"stance:\\n\\n```\\nvar actorId = new ActorId(\\\"scoreActor1\\\"); var proxy = ActorProxy.Create<IScoreActor>(ac\", \"torId, \\\"ScoreActor\\\"); var score = await proxy.IncrementScoreAsync(); Console.WriteLine($\\\"Current sco\", \"re: {score}\\\");\\n```\\n\\nThe above example uses the Dapr.Actors package to call the actor service. To inv\", \"oke an operation on an actor, you need to be able to address it. You'll need two parts for this:\\n\\n1.\", \" The actor type uniquely identifies the actor implementation across the whole application. By defaul\", \"t, the actor type is the name of the implementation class (without namespace). You can customize the\", \" actor type by adding an ActorAttribute to the implementation class and setting its TypeName propert\", \"y.\\n\\n2. The ActorId uniquely identifies an instance of an actor type. You can also use this class to \", \"generate a random actor id by calling ActorId.CreateRandom .\\n\\nThe example uses ActorProxy.Create to \", \"create a proxy instance for the ScoreActor . The Create method takes two arguments: the ActorId iden\", \"tifying the specific actor and the actor type. It also has a generic type parameter to specify the a\", \"ctor interface that the actor type implements. As both the server and client applications need to us\", \"e the actor interfaces, they're typically stored in a separate shared project.\\n\\nThe final step in th\", \"e example calls the IncrementScoreAsync method on the actor and outputs the result. Remember that th\", \"e Dapr placement service distributes the actor instances across the Dapr sidecars. Therefore, expect\", \" an actor call to be a network call to another node.\\n\\n## Call actors from ASP.NET Core clients\\n\\nThe \", \"console client example in the previous section uses the static ActorProxy.Create method directly to \", \"get an actor proxy instance. If the client application is an ASP.NET Core application, you should us\", \"e the IActorProxyFactory interface to create actor proxies. The main benefit is that it allows you t\", \"o manage configuration in one place. The AddActors extension method on IServiceCollection takes a de\", \"legate that allows you to specify actor runtime options, such as the HTTP endpoint of the Dapr sidec\", \"ar. The following example specifies custom JsonSerializerOptions to use for actor state persistence \", \"and message deserialization:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); builder.Services\", \".AddActors(options => { var jsonSerializerOptions = new JsonSerializerOptions() { PropertyNamingPoli\", \"cy = JsonNamingPolicy.CamelCase, PropertyNameCaseInsensitive = true }; options.JsonSerializerOptions\", \" = jsonSerializerOptions; options.Actors.RegisterActor<ScoreActor>(); });\\n```\\n\\nThe call to AddActors\", \" registers the IActorProxyFactory for .NET dependency injection. This allows ASP.NET Core to inject \", \"an IActorProxyFactory instance into your controller classes. The following example calls an actor me\", \"thod from an ASP.NET Core controller class:\\n\\n```\\n[ApiController] [Route(\\\"[controller]\\\")] public clas\", \"s ScoreController : ControllerBase { private readonly IActorProxyFactory _actorProxyFactory; public \", \"ScoreController(IActorProxyFactory actorProxyFactory) { _actorProxyFactory = actorProxyFactory; } [H\", \"ttpPut(\\\"{scoreId}\\\")] public Task<int> IncrementAsync(string scoreId) {\\n```\\n\\n```\\nvar scoreActor = _ac\", \"torProxyFactory.CreateActorProxy<IScoreActor>( new ActorId(scoreId), \\\"ScoreActor\\\"); return scoreActo\", \"r.IncrementScoreAsync(); } }\\n```\\n\\nActors can also call other actors directly. The Actor base class e\", \"xposes an IActorProxyFactory class through the ProxyFactory property. To create an actor proxy from \", \"within an actor, use the ProxyFactory property of the Actor base class. The following example shows \", \"an OrderActor that invokes operations on two other actors:\\n\\n```\\npublic class OrderActor : Actor, IOr\", \"derActor { public OrderActor(ActorHost host) : base (host) { } public async Task ProcessOrderAsync(O\", \"rder order) { var stockActor = ProxyFactory.CreateActorProxy<IStockActor>( new ActorId(order.OrderNu\", \"mber), \\\"StockActor\\\"); await stockActor.ReserveStockAsync(order.OrderLines); var paymentActor = Proxy\", \"Factory.CreateActorProxy<IPaymentActor>( new ActorId(order.OrderNumber), \\\"PaymentActor\\\"); await paym\", \"entActor.ProcessPaymentAsync(order.PaymentDetails); } }\\n```\\n\\n## Note\\n\\nBy default, Dapr actors aren't\", \" reentrant. This means that a Dapr actor cannot be called more than once in the same chain. For exam\", \"ple, the call chain Actor A -&gt; Actor B -&gt; Actor A is not allowed. At the time of writing, ther\", \"e's a preview feature available to support reentrancy. However, there is no SDK support yet. For mor\", \"e details, see the official documentation.\\n\\n## Call non-.NET actors\\n\\nSo far, the examples used stron\", \"gly-typed actor proxies based on .NET interfaces to illustrate actor invocations. This works great w\", \"hen both the actor host and client are .NET applications. However, if the actor host is not a .NET a\", \"pplication, you don't have an actor interface to create a strongly -typed proxy. In these cases, you\", \" can use a weakly-typed proxy.\\n\\nYou create weakly-typed proxies in a similar way to strongly-typed p\", \"roxies. Instead of relying on a .NET interface, you need to pass in the actor method name as a strin\", \"g.\\n\\n```\\n[HttpPut(\\\"{scoreId}\\\")]\\n```\\n\\n```\\npublic Task<int> IncrementAsync(string scoreId)\\n```\\n\\n```\\n{ v\", \"ar scoreActor = _actorProxyFactory.CreateActorProxy( new ActorId(scoreId), \\\"ScoreActor\\\"); return sco\", \"reActor(\\\"IncrementScoreAsync\\\"); }\\n```\\n\\n## Timers and reminders\\n\\nUse the RegisterTimerAsync method of\", \" the Actor base class to schedule actor timers. In the following example, a TimerActor exposes a Sta\", \"rtTimerAsync method. Clients can call the method to start a timer that repeatedly writes a given tex\", \"t to the log output.\\n\\n```\\npublic class TimerActor : Actor, ITimerActor { public TimerActor(ActorHost\", \" host) : base (host) { } public Task StartTimerAsync(string name, string text) { return RegisterTime\", \"rAsync( name, nameof(TimerCallback), Encoding.UTF8.GetBytes(text), TimeSpan.Zero, TimeSpan.FromSecon\", \"ds(3)); } public Task TimerCallbackAsync(byte[] state) { var text = Encoding.UTF8.GetString(state); \", \"Logger.LogInformation($\\\"Timer fired: {text}\\\"); return Task.CompletedTask; } }\\n```\\n\\nThe StartTimerAsy\", \"nc method calls RegisterTimerAsync to schedule the timer. RegisterTimerAsync takes five arguments:\\n\\n\", \"1. The name of the timer.\\n2. The name of the method to call when the timer fires.\\n3. The state to pa\", \"ss to the callback method.\\n4. The amount of time to wait before the callback method is first invoked\", \".\\n5. The time interval between callback method invocations. You can specify TimeSpan.FromMillisecond\", \"s(-1) to disable periodic signaling.\\n\\nThe TimerCallbackAsync method receives the user state in binar\", \"y form. In the example, the callback decodes the state back to a string before writing it to the log\", \".\\n\\nTimers can be stopped by calling UnregisterTimerAsync :\\n\\n```\\npublic class TimerActor : Actor, ITi\", \"merActor { // ... public Task StopTimerAsync(string name) { return UnregisterTimerAsync(name); } }\\n`\", \"``\\n\\nRemember that timers do not reset the actor idle timer. When no other calls are made on the acto\", \"r, it may be deactivated and the timer will be stopped automatically. To schedule work that does res\", \"et the idle timer, use reminders which we'll look at next.\\n\\nTo use reminders in an actor, your actor\", \" class must implement the IRemindable interface:\\n\\n```\\npublic interface IRemindable { Task ReceiveRem\", \"inderAsync( string reminderName, byte[] state, TimeSpan dueTime, TimeSpan period); }\\n```\\n\\nThe Receiv\", \"eReminderAsync method is called when a reminder is fired. It takes 4 arguments:\\n\\n1. The name of the \", \"reminder.\\n2. The user state provided during registration.\\n3. The invocation due time provided during\", \" registration.\\n4. The invocation period provided during registration.\\n\\nTo register a reminder, use t\", \"he RegisterReminderAsync method of the actor base class. The following example sets a reminder to fi\", \"re a single time with a due time of three minutes.\\n\\n```\\npublic class ReminderActor : Actor, IReminde\", \"rActor, IRemindable { public ReminderActor(ActorHost host) : base (host) { } public Task SetReminder\", \"Async(string text) { return RegisterReminderAsync( \\\"DoNotForget\\\", Encoding.UTF8.GetBytes(text), Time\", \"Span.FromSeconds(3), TimeSpan.FromMilliseconds(-1)); } public Task ReceiveReminderAsync( string remi\", \"nderName, byte[] state, TimeSpan dueTime, TimeSpan period) { if (reminderName == \\\"DoNotForget\\\") { va\", \"r text = Encoding.UTF8.GetString(state); Logger.LogInformation($\\\"Don't forget: {text}\\\");\\n```\\n\\n```\\n} \", \"return Task.CompletedTask; } }\\n```\\n\\nThe RegisterReminderAsync method is similar to RegisterTimerAsyn\", \"c but you don't have to specify a callback method explicitly. As the above example shows, you implem\", \"ent IRemindable.ReceiveReminderAsync to handle fired reminders.\\n\\nReminders both reset the idle timer\", \" and are persistent. Even if your actor is deactivated, it will be reactivated at the moment a remin\", \"der fires. To stop a reminder from firing, call UnregisterReminderAsync .\\n\\n## Sample application: Da\", \"pr Traffic Control\\n\\nThe default version of Dapr Traffic Control does not use the actor model. Howeve\", \"r, it does contain an alternative actor-based implementation of the TrafficControl service that you \", \"can enable. To make use of actors in the TrafficControl service, open up the src/TrafficControlServi\", \"ce/Controllers/TrafficController.cs file and uncomment the USE_ACTORMODEL statement at the top of th\", \"e file:\\n\\n```\\n#define USE_ACTORMODEL\\n```\\n\\nWhen the actor model is enabled, the application uses actor\", \"s to represent vehicles. The operations that can be invoked on the vehicle actors are defined in an \", \"IVehicleActor interface:\\n\\n```\\npublic interface IVehicleActor : IActor { Task RegisterEntryAsync(Vehi\", \"cleRegistered msg); Task RegisterExitAsync(VehicleRegistered msg); }\\n```\\n\\nThe (simulated) entry came\", \"ras call the RegisterEntryAsync method when a new vehicle is first detected in the lane. The only re\", \"sponsibility of this method is storing the entry timestamp in the actor state:\\n\\n```\\nvar vehicleState\", \" = new VehicleState { LicenseNumber = msg.LicenseNumber, EntryTimestamp = msg.Timestamp }; await Sta\", \"teManager.SetStateAsync(\\\"VehicleState\\\", vehicleState);\\n```\\n\\nWhen the vehicle reaches the end of the \", \"speed camera zone, the exit camera calls the RegisterExitAsync method. The RegisterExitAsync method \", \"first gets the current states and updates it to include the exit timestamp:\\n\\n```\\nvar vehicleState = \", \"await StateManager.GetStateAsync<VehicleState>(\\\"VehicleState\\\"); vehicleState.ExitTimestamp = msg.Tim\", \"estamp;\\n```\\n\\n## Note\\n\\nThe code above currently assumes that a VehicleState instance has already been\", \" saved by the RegisterEntryAsync method. The code could be improved by first checking to make sure t\", \"he state exists. Thanks to the turn-based access model, no explicit locks are required in the code.\\n\", \"\\nAfter the state is updated, the RegisterExitAsync method checks if the vehicle was driving too fast\", \". If it was, the actor publishes a message to the collectfine pub/sub topic:\\n\\n```\\nint violation = _s\", \"peedingViolationCalculator.DetermineSpeedingViolationInKmh( vehicleState.EntryTimestamp, vehicleStat\", \"e.ExitTimestamp); if (violation > 0) { var speedingViolation = new SpeedingViolation { VehicleId = m\", \"sg.LicenseNumber, RoadId = _roadId, ViolationInKmh = violation, Timestamp = msg.Timestamp }; await _\", \"daprClient.PublishEventAsync(\\\"pubsub\\\", \\\"collectfine\\\", speedingViolation); }\\n```\\n\\nThe code above uses\", \" two external dependencies. The _speedingViolationCalculator encapsulates the business logic for det\", \"ermining whether or not a vehicle has driven too fast. The _daprClient allows the actor to publish m\", \"essages using the Dapr pub/sub building block.\\n\\nBoth dependencies are registered in the Program.cs c\", \"lass and injected into the actor using constructor dependency injection:\\n\\n```\\nprivate readonly DaprC\", \"lient _daprClient; private readonly ISpeedingViolationCalculator _speedingViolationCalculator; priva\", \"te readonly string _roadId; public VehicleActor( ActorHost host, DaprClient daprClient, ISpeedingVio\", \"lationCalculator speedingViolationCalculator) : base (host) { _daprClient = daprClient; _speedingVio\", \"lationCalculator = speedingViolationCalculator; _roadId = _speedingViolationCalculator.GetRoadId(); \", \"}\\n```\\n\\nThe actor based implementation no longer uses the Dapr state management building block direct\", \"ly. Instead, the state is automatically persisted after each operation is executed.\\n\\n## Summary\\n\\nThe\", \" Dapr actors building block makes it easier to write correct concurrent systems. Actors are small un\", \"its of state and logic. They use a turn-based access model which saves you from having to use lockin\", \"g mechanisms to write thread-safe code. Actors are created implicitly and are silently unloaded\\n\\nfro\", \"m memory when no operations are performed. Any state stored in the actor is automatically persisted \", \"and loaded when the actor is reactivated. Actor model implementations are typically created for a sp\", \"ecific language or platform. With the Dapr actors building block however, you can leverage the actor\", \" model from any language or platform.\\n\\nActors support timers and reminders to schedule future work. \", \"Timers do not reset the idle timer and will allow the actor to be deactivated when no other operatio\", \"ns are performed. Reminders do reset the idle timer and are also persisted automatically. Both timer\", \"s and reminders respect the turn-based access model, making sure that no other operations can execut\", \"e while the timer/reminder events are handled.\\n\\nActor state is persisted using the Dapr state manage\", \"ment building block. Any state store that supports multi-item transactions can be used to store acto\", \"r state.\\n\\n## References\\n\\n- Dapr supported state stores\\n\\n## The Dapr observability building block\\n\\nMo\", \"dern distributed systems are complex. You start with small, loosely coupled, independently deployabl\", \"e services. These services cross process and server boundaries. They then consume different kinds of\", \" infrastructure backing services (databases, message brokers, key vaults). Finally, these disparate \", \"pieces compose together to form an application.\\n\\nWith so many separate, moving parts, how do you mak\", \"e sense of what is going on? Unfortunately, legacy monitoring approaches from the past aren't enough\", \". Instead, the system must be observable from end-to-end. Modern observability practices provide vis\", \"ibility and insight into the health of the application at all times. They enable you to infer the in\", \"ternal state by observing the output. Not only is observability mandatory for monitoring and trouble\", \"shooting distributed applications, it needs to be implemented at the start.\\n\\nThe system information \", \"used to gain observability is referred to as telemetry . It can be divided into four broad categorie\", \"s:\\n\\n1. Distributed tracing provides insights into the traffic between services involved in distribut\", \"ed business transactions.\\n2. Metrics provides insights into the performance of a service and its res\", \"ource consumption.\\n3. Logging provides insights into how code is executing and if errors have occurr\", \"ed.\\n4. Health endpoints provide insight into the availability of a service.\\n\\nThe depth of telemetry \", \"is determined by the observability features of an application platform. Consider the Azure cloud. It\", \" provides a rich telemetry experience that includes all of the telemetry categories. With little con\", \"figuration, Azure IaaS and PaaS services will propagate and publish telemetry to the Azure Monitor a\", \"nd Azure Application Insights services. Application Insights presents system logging, tracing, and p\", \"roblem areas with highly visual dashboards. It can even render a diagram showing the dependencies be\", \"tween services based on their communication.\\n\\nHowever, what if an application can't use Azure PaaS a\", \"nd IaaS resources? Is it still possible to take advantage of the rich telemetry experience of Applic\", \"ation Insights? The answer is yes. A non-Azure application can import libraries, add configuration, \", \"and instrument code to emit telemetry to Azure Application Insights. However, this approach tightly \", \"couples the application to Application Insights. Moving the app to a different monitoring platform c\", \"ould involve expensive refactoring. Wouldn't it be great to avoid tight coupling and consume observa\", \"bility outside of the code?\\n\\nWith Dapr, you can. Let's look at how Dapr can add observability to our\", \" distr ibuted applications.\\n\\nService A\\n\\n1\\n\\nService A\\n\\nsidecar dapr\\n\\n## What it solves\\n\\n0\\n\\n2\\n\\nCollect\", \"or\\n\\nThe Dapr observability building block decouples observability from the application. It automatic\", \"ally captures traffic generated by Dapr sidecars and Dapr system services that make up the Dapr cont\", \"rol plane. The block correlates traffic from a single operation that spans multiple services. It als\", \"o exposes performance metrics, resource utilization, and the health of the system. Telemetry is publ\", \"ished in open-standard formats enabling information to be fed into your monitoring back end of choic\", \"e. There, the information can be visualized, queried, and analyzed.\\n\\nAs Dapr abstracts away the plum\", \"bing, the application is unaware of how observability is implemented. There's no need to reference l\", \"ibraries or implement custom instrume ntation code. Dapr allows the developer to focus on building b\", \"usiness logic instead of observability plumbing. Observability is configured at the Dapr system leve\", \"l and is consistent across services, even when created by different teams, and built with different \", \"technology stacks.\\n\\n## How it works\\n\\nDapr's sidecar architecture enables built-in observability feat\", \"ures. As services communicate, Dapr sidecars intercept the traffic and extract tracing, metrics, and\", \" logging information. Telemetry is published in an open standards format. By default, Dapr supports \", \"OpenTelemetry and Zipkin.\\n\\nDapr provides collectors that can publish telemetry to different back-end\", \" monitoring tools. These tools present Dapr telemetry for analysis and querying. Figure 10-1 shows t\", \"he Dapr observability architecture:\\n\\nFigure 10-1. Dapr observability architecture.\\n\\n1. Service A cal\", \"ls an operation on Service B. The call is routed from a Dapr sidecar for Service A to a sidecar for \", \"Service B.\\n2. When Service B completes the operation, a response is sent back to Service A through t\", \"he Dapr sidecars. They gather and publish all available telemetry for every request and response.\\n3.\", \" The configured collector ingests the telemetry and sends it to the monitoring back end.\\n\\nService B\\n\", \"\\nsidecar dapr\\n\\n-2\\n\\nService B\\n\\nService A\\n\\ndapr\\n\\nService C\\n\\nA\\n\\nAs a developer, keep in mind that addin\", \"g observability is different from configuring other Dapr building blocks, like pub/sub or state mana\", \"gement. Instead of referencing a building block, you add a collector and a monitoring back end. Figu\", \"re 101 shows it's possible to configure multiple collectors that integrate with different monitoring\", \" back ends.\\n\\nService A\\n\\nService C\\n\\nAt the beginning of this chapter, four categories of telemetry we\", \"re identified. The following sections will provide detail for each category. They'll include instruc\", \"tion on how to configure collectors that integrate with popular monitoring back ends.\\n\\n## Distribute\", \"d tracing\\n\\nDistributed tracing provides insight into traffic that flows across services in a distrib\", \"uted application. The logs of exchanged request and response messages are a source of invaluable inf\", \"ormation for troubleshooting issues. The hard part is correlating messages that belong to the same b\", \"usiness transaction.\\n\\nDapr uses the W3C Trace Context to correlate related messages. It injects the \", \"same context information into requests and responses that form a unique operation. Figure 10-2 shows\", \" how correlation works:\\n\\n## Note\\n\\nThe trace context is often referred to as a correlation token in m\", \"icroservice terminology.\\n\\nFigure 10-2. W3C Trace Context example.\\n\\n1. Service A invokes an operation\", \" on Service B. As Service A starts the call, Dapr creates a unique trace context and injects it into\", \" the request.\\n2. Service B receives the request and invokes an operation on Service C. Dapr detects \", \"that the incoming request contains a trace context and propagates it by injecting it into the outgoi\", \"ng request to Service C.\\n3. Service C receives the request and handles it. Dapr detects that the inc\", \"oming request contains a trace context and propagates it by injecting it into the outgoing response \", \"back to Service B.\\n4. Service B receives the response and handles it. It then creates a new response\", \" and propagates the trace context by injecting it into the outgoing response back to Service A.\\n\\nA s\", \"et of requests and responses that belong together is called a trace . Figure 10-3 shows a trace:\\n\\nSe\", \"rvice B\\n\\nSpan\\n\\nTrace\\n\\nA =\\u2192 B\\n\\nFigure 10-3. Traces and spans.\\n\\nIn the figure, note how the trace repr\", \"esents a unique application transaction that takes place across many services. A trace is a collecti\", \"on of spans . Each span represents a single operation or unit of work done within the trace. Spans a\", \"re the requests and responses that are sent between services that implement the unique transaction.\\n\", \"\\nThe next sections discuss how to inspect tracing telemetry by publishing it to a monitoring back en\", \"d.\\n\\n## Use a Zipkin monitoring back end\\n\\nZipkin is an open-source distributed tracing system. It can\", \" ingest and visualize telemetry data. Dapr offers default support for Zipkin. The following example \", \"demonstrates how to configure Zipkin to visualize Dapr telemetry.\\n\\n## Enable and configure tracing\\n\\n\", \"To start , tracing must be enabled for the Dapr runtime using a Dapr configuration file. Here's an e\", \"xample of a configuration file named dapr-config.yaml that enables tracing:\\n\\n```\\napiVersion: dapr.io\", \"/v1alpha1 kind: Configuration metadata: name: dapr-config namespace: default spec: tracing: sampling\", \"Rate: \\\"1\\\" zipkin: endpointAddress: \\\"http://zipkin.default.svc.cluster.local:9411/api/v2/spans\\\"\\n```\\n\\n\", \"The samplingRate attribute specifies the interval used for publishing traces. The value must be betw\", \"een 0 (tracing disabled) and 1 (every trace is published). With a value of 0.5 , for example, every \", \"other trace is published, significantly reducing published traffic. The endpointAddress points to an\", \" endpoint on a Zipkin server running in a Kubernetes cluster. The default port for Zipkin is 9411 . \", \"The configuration must be applied to the Kubernetes cluster using the Kubernetes CLI:\\n\\n```\\nkubectl a\", \"pply -f dapr-config.yaml\\n```\\n\\n## Install the Zipkin server\\n\\nWhen installing Dapr in self-hosted mode\", \", a Zipkin server is automatically installed and tracing is enabled in the default configuration fil\", \"e located in $HOME/.dapr/config.yaml or %USERPROFILE%\\\\.dapr\\\\config.yaml on Windows.\\n\\nWhen installing\", \" Dapr on a Kubernetes cluster, Zipkin must be deployed manually. Use the following Kubernetes manife\", \"st file entitled zipkin.yaml to deploy a standard Zipkin server to a Kubernetes cluster:\\n\\n```\\nkind: \", \"Deployment apiVersion: apps/v1 metadata: name: zipkin namespace: dapr-trafficcontrol labels: service\", \": zipkin spec: replicas: 1 selector: matchLabels: service: zipkin template: metadata: labels: servic\", \"e: zipkin spec: containers: -name: zipkin image: openzipkin/zipkin-slim imagePullPolicy: IfNotPresen\", \"t ports: -name: http containerPort: 9411 protocol: TCP ---kind: Service apiVersion: v1 metadata: nam\", \"e: zipkin namespace: dapr-trafficcontrol labels: service: zipkin spec: type: NodePort ports: -port: \", \"9411 targetPort: 9411 nodePort: 32411 protocol: TCP name: zipkin selector: service: zipkin\\n```\\n\\nThe \", \"deployment uses the standard openzipkin/zipkin-slim container image. The Zipkin service exposes the \", \"Zipkin web front end, which you can use to view the telemetry on port 32411 . Use the\\n\\nKubernetes CL\", \"I to apply the Zipkin manifest file to the Kubernetes cluster and deploy the Zipkin server:\\n\\nkubectl\", \" apply -f zipkin.yaml\\n\\n## Configure the services to use the tracing configuration\\n\\nNow everything is\", \" set up correctly to start publishing telemetry. Every Dapr sidecar that is deployed as part of the \", \"application must be instructed to emit telemetry when started. To do that, add a dapr.io/config anno\", \"tation that references the dapr-config configuration to the deployment of each service. Here's an ex\", \"ample of the Traffic Control FineCollection service's manifest file containing the annotation:\\n\\n```\\n\", \"apiVersion: apps/v1 kind: Deployment metadata: name: finecollectionservice namespace: dapr-trafficco\", \"ntrol labels: app: finecollectionservice spec: replicas: 1 selector: matchLabels: app: finecollectio\", \"nservice template: metadata: labels: app: finecollectionservice annotations: dapr.io/enabled: \\\"true\\\"\", \" dapr.io/app-id: \\\"finecollectionservice\\\" dapr.io/app-port: \\\"6001\\\" dapr.io/config: \\\"dapr-config\\\" spec\", \": containers: -name: finecollectionservice image: dapr-trafficcontrol/finecollectionservice:1.0 port\", \"s: -containerPort: 6001\\n```\\n\\n## Inspect the telemetry in Zipkin\\n\\nOnce the application is started, th\", \"e Dapr sidecars will emit telemetry to the Zipkin server. To inspect this telemetry, point a web-bro\", \"wser to http://localhost:32411 . You'll see the Zipkin web front end:\\n\\nZipkin\\n\\nZipkin\\n\\n+\\n\\n+\\n\\n10 Resu\", \"lts\\n\\nRoot trafficcontrolservice: bindings/exitcam\\n\\ntrafficcontrolservice: bindings/exitcam trafficco\", \"ntrolservice: bindings/exitcam\\n\\ntrafficcontrolservice: bindings/exitcam trafficcontrolservice: bindi\", \"ngs/entrycam\\n\\ntrafficcontrolservice: bindings/exitcam trafficcontrolservice: bindings/entrycam\\n\\nSear\", \"ch by trace ID\\n\\nSearch by trace ID\\n\\nRUN GUERY\\n\\n*-\\n\\nS RUN QUERY\\n\\nService filters\\n\\nFigure 10-4. Zipkin\", \" front end.\\n\\nOn the Find a trace tab, you can query traces. Pressing the RUN QUERY button without sp\", \"ecifying any restrictions will show all the ingested traces :\\n\\nFigure 10-5. Zipkin traces overview.\\n\", \"\\nClicking the SHOW button next to a specific trace, will show the details of that trace:\\n\\nQ Find a t\", \"race\\n\\nT\\u00b0 Dependencies\\n\\nQ Find a trace Dependencies\\n\\nXA ENGLISH Y\\n\\n*A ENGLISH V\\n\\nEXPAND ALL\\n\\nCOLLAPSE\", \" ALL\\n\\n\\u2022 Zipkin\\n\\nQ Find a trace\\n\\n\\\" Dependencies\\n\\nTRAFFICCONTROLSERVICE: bindings/entrycam\\n\\nDuration: \", \"5.666ms Services: 1 Depth: 2 Total Spans: 2 Trace ID: 572745da4058a2f8406446420c402657\\n\\n^ v\\n\\n\\u2022 TRAFF\", \"ICCONTROLSERVICE\\n\\nTRAFFICCONTROLSERVICE\\n\\n\\u00ab\\n\\nFigure 10-6. Zipkin trace details.\\n\\nEach item on the det\", \"ails page, is a span that represents a request that is part of the selected trace.\\n\\n## Inspect the d\", \"ependencies between services\\n\\nBecause Dapr sidecars handle traffic between services, Zipkin can use \", \"the trace information to determine the dependencies between the services. To see it in action, go to\", \" the Dependencies tab on the Zipkin web page and select the button with the magnifying glass. Zipkin\", \" will show an overview of the services and their dependencies:\\n\\nJA ENGLISH Y\\n\\nSearch by trace ID\\n\\n* \", \"DOWNLOAD JSON\\n\\nZipkin\\n\\nSelect...\\n\\nQ Find a trace\\n\\n*\\u00b0 Dependencies\\n\\nStart Time\\n\\n05/09/2021 09:58:51\\n\\n\", \"TA ENGLISH V\\n\\nEnd Time\\n\\n05/10/2021 09:58:51\\n\\nQ\\n\\nFigure 10-7. Zipkin dependencies.\\n\\nThe animated dots\", \" on the lines between the services represent requests and move from source to destination. Red dots \", \"indicate a failed request.\\n\\n## Use a Jaeger or New Relic monitoring back end\\n\\nBeyond Zipkin, other m\", \"onitoring back-end software can also ingest telemetry with the Zipkin format. Jaeger is an open sour\", \"ce tracing system created by Uber Technologies. It's used to trace transactions between distributed \", \"services and troubleshoot complex microservices environments. New Relic is a full-stack observabilit\", \"y platform. It links relevant data from a distributed application to provide a complete picture of y\", \"our system. To try them out, specify an endpointAddress pointing to either a Jaeger or New Relic ser\", \"ver in the Dapr configuration file. Here's an example of a configuration file that configures Dapr t\", \"o send telemetry to a Jaeger server. The URL for Jaeger is identical to the URL for the Zipkin. The \", \"only difference is the number of the port on which the server runs:\\n\\n:::{custom-style=CodeBox} yaml \", \" apiVersion: dapr.io/v1alpha1  kind: Configuration  metadata:    name: dapr-config    namespace: def\", \"ault  spec:    tracing:      samplingRate: \\\"1\\\"      zipkin: endpointAddress: \\\"http://localhost:9415/\", \"api/v2/spans\\\" :::\\n\\nTo try out New Relic, specify the endpoint of the New Relic API. Here's an exampl\", \"e of a configuration file for New Relic:\\n\\n:::{custom-style=CodeBox} yaml apiVersion: dapr.io/v1alpha\", \"1  kind: Configuration  metadata:    name: dapr-config    namespace: default  spec:    tracing:     \", \" samplingRate: \\\"1\\\"      zipkin: endpointAddress: \\\"https://trace-api.newrelic.com/trace/v1?Api-Key=&l\", \"t;NR-API-KEY&gt;&amp;DataFormat=zipkin&amp;Data-Format-Version=2\\\" :::\\n\\nSearch by trace ID\\n\\ndapr dapr\", \"\\n\\ndapr dapr\\n\\nSidecar dapr\\n\\nSidecar\\n\\nCheck out the Jaeger and New Relic websites for more information\", \" on how to use them.\\n\\n## Metrics\\n\\nMetrics provide insight into performance and resource consumption.\", \" Under the hood, Dapr emits a wide collection of system and runtime metrics. Dapr uses Prometheus as\", \" a metric standard. Dapr sidecars and system services, expose a metrics endpoint on port 9090 . A Pr\", \"ometheus scraper calls this endpoint at a predefined interval to collect metrics. The scraper sends \", \"metric values to a monitoring back end. Figure 10-8 shows the scraping process: backend\\n\\nPlacement s\", \"ervice\\n\\nSentry service\\n\\n-04\\n\\nmetrics scraper\\n\\nFigure 10-8. Scraping Prometheus metrics.\\n\\nEach sideca\", \"r and system service exposes a metric endpoint that listens on port 9090. The Prometheus Metrics Scr\", \"apper captures metrics from each endpoint and published the information to the monitoring back end.\\n\", \"\\n## Service discovery\\n\\nYou might wonder how the metrics scraper knows where to collect metrics. Prom\", \"etheus can integrate with discovery mechanisms built into target deployment environments. For exampl\", \"e, when running in Kubernetes, Prometheus can integrate with the Kubernetes API to find all availabl\", \"e Kubernetes resources running in the environment.\\n\\n## Metrics list\\n\\nDapr generates a large set of m\", \"etrics for Dapr system services and its runtime. Some examples include:\\n\\nService A\\n\\nService B\\n\\n| Met\", \"ric                                         | Source   | Description                                \", \"                                                    |\\n|---------------------------------------------\", \"---|----------|-------------------------------------------------------------------------------------\", \"-----------|\\n| dapr_operator_service_created_total            | System   | The total number of Dapr \", \"services created by the Dapr Operator service.                        |\\n| dapr_injector_sidecar_inje\", \"ction/requests_total | System   | The total number of sidecar injection requests received by the Dap\", \"r Sidecar- Injector service. |\\n| dapr_placement_runtimes_total                  | System   | The tot\", \"al number of hosts reported to the Dapr Placement service.                              |\\n| dapr_sen\", \"try_cert_sign_request_received_total   | System   | The number of certificate signing requests (CRSs\", \") received by the Dapr Sentry service.         |\\n| dapr_runtime_component_loaded                  | \", \"Runtime  | The number of successfully loaded Dapr components.                                       \", \"      |\\n| dapr_grpc_io_server_completed_rpcs             | Runtime  | Count of gRPC calls by method \", \"and status.                                                      |\\n| dapr_http_server_request_count \", \"                | Runtime  | Number of HTTP requests started in an HTTP server.                     \", \"                        |\\n| dapr_http/client/sent_bytes                    | Runtime  | Total bytes \", \"sent in request body (not including headers) by an HTTP client.                    |\\n\\nFor more infor\", \"mation on available metrics, see the Dapr metrics documentation.\\n\\n## Configure Dapr metrics\\n\\nAt run \", \"time, you can disable the metrics collection endpoint by including the --enablemetrics=false argumen\", \"t in the Dapr command. Or, you can also change the default port for the endpoint with the --metrics-\", \"port 9090 argument.\\n\\nYou can also use a Dapr configuration file to statically enable or disable runt\", \"ime metrics collection:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Configuration metadata: name: dapr-c\", \"onfig namespace: dapr-trafficcontrol spec: tracing: samplingRate: \\\"1\\\" metric: enabled: false\\n```\\n\\n##\", \" Visualize Dapr metrics\\n\\nWith the Prometheus scraper collecting and publishing metrics into the moni\", \"toring back end, how do you make sense of the raw data? A popular visualization tool for analyzing m\", \"etrics is Grafana. With Grafana, you can create dashboards from the available metrics. Here's an exa\", \"mple of a dashboard displaying Dapr system services metrics:\\n\\nQ\\n\\n+\\n\\n88\\n\\n88 Dapr System Services Dash\", \"board * &lt;\\n\\nv Health &amp; Resource\\n\\nUptime dapr-operator\\n\\ndapr-placement-server dapr-sentry\\n\\ndapr\", \"-sidecar-injector v Sidecar Injector\\n\\n5.0\\n\\n4.5\\n\\n4.0\\n\\n3.5\\n\\n3.0\\n\\n20:18:30\\n\\n20:19:00\\n\\n- sidecars reques\", \"ts\\n\\n~ CA Sentry\\n\\nRoot/Issuer cert expirynute\\n\\n52.1 week left\\n\\n6.0 min\\n\\n6.0 min\\n\\n8 ms\\n\\n6 ms\\n\\n15.0 MB\\n\", \"\\n12.5 MB\\n\\n10.0 MB\\n\\n100\\n\\n75\\n\\nFigure 10-9. Grafana dashboard.\\n\\nThe Dapr documentation includes a tutor\", \"ial for installing Prometheus and Grafana.\\n\\n## Logging\\n\\nLogging provides insight into what is happen\", \"ing with a service at run time. When running an application, Dapr automatically emits log entries fr\", \"om Dapr sidecars and Dapr system services. However, logging entries instrumented in your application\", \" code aren't automatically included. To emit logging from application code, you can import a specifi\", \"c SDK like OpenTelemetry SDK for .NET. Logging application code is covered later in this chapter in \", \"the section Using the Dapr .NET SDK .\\n\\n## Log entry structure\\n\\nDapr emits structured logging. Each l\", \"og entry has the following format:\\n\\n| Field    | Description                                        \", \"   | Example                           |\\n|----------|-----------------------------------------------\", \"--------|-----------------------------------|\\n| time     | ISO8601 formatted timestamp              \", \"             | 2021-01-10T14:19:31.000Z          |\\n| level    | Level of the entry ( debug , info , \", \"warn , or error ) | info                              |\\n| type     | Log Type                       \", \"                       | log                               |\\n| msg      | Log Message               \", \"                            | metrics server started on :62408/ |\\n| scope    | Logging Scope        \", \"                                 | dapr.runtime                      |\\n| instance | Hostname where D\", \"apr runs                              | TSTSRV01                          |\\n\\nTotal CPU usage (kernel\", \" and user)\\n\\nHeap Memory usage in bytes\\n\\n1h 4\\n\\n\\u2022 Last 5 minutes\\n\\nNumber of GO routines\\n\\n5s v\\n\\n| Field\", \"   | Description          | Example               |\\n|---------|----------------------|--------------\", \"---------|\\n| app_id  | Dapr App ID          | finecollectionservice |\\n| ver     | Dapr Runtime Versi\", \"on | 1.0                   |\\n\\nWhen searching through logging entries in a troubleshooting scenario, \", \"the time and level fields are especially helpful. The time field orders log entries so that you can \", \"pinpoint specific time periods. When troubleshooting, log entries at the debug level provide more in\", \"formation on the behavior of the code.\\n\\n## Plain text versus JSON format\\n\\nBy default, Dapr emits str\", \"uctured logging in plain-text format. Every log entry is formatted as a string containing key/value \", \"pairs. Here's an example of logging in plain te xt:\\n\\n```\\n== DAPR == time=\\\"2021-01-12T16:11:39.466932\", \"3+01:00\\\" level=info msg=\\\"starting Dapr Runtime - version 1.0 -- commit 196483d\\\" app_id=finecollectio\", \"nservice instance=TSTSRV03 scope=dapr.runtime type=log ver=1.0 == DAPR == time=\\\"2021-01-12T16:11:39.\", \"467933+01:00\\\" level=info msg=\\\"log level set to: info\\\" app_id=finecollectionservice instance=TSTSRV03\", \" scope=dapr.runtime type=log ver=1.0 == DAPR == time=\\\"2021-01-12T16:11:39.467933+01:00\\\" level=info m\", \"sg=\\\"metrics server started on :62408/\\\" app_id=finecollectionservice instance=TSTSRV03 scope=dapr.met\", \"rics type=log ver=1.0\\n```\\n\\nWhile simple, this format is difficult to parse. If viewing log entries w\", \"ith a monitoring tool, you'll want to enable JSON formatted logging. With JSON entries, a monitoring\", \" tool can index and query individual fields. Here's the same log entries in JSON format:\\n\\n```\\n{\\\"app_\", \"id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \\\"starting Dapr Runtime\", \" -- version 1.0 -- commit 196483d\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"time\\\": \\\"2021-01-12T16:11:39.4669323+01\", \":00\\\", \\\"type\\\": \\\"log\\\", \\\"ver\\\": \\\"1.0\\\"} {\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"leve\", \"l\\\": \\\"info\\\", \\\"msg\\\": \\\"log level set to: info\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"2021-0\", \"112T16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"} {\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\"\", \", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \\\"metrics server started on :62408/\\\", \\\"scope\\\": \\\"dapr.metrics\\\", \\\"type\\\": \\\"log\", \"\\\", \\\"time\\\": \\\"202101-12T16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"}\\n```\\n\\nTo enable JSON formatting, you need\", \" to configure each Dapr sidecar. In self-hosted mode, you can specify the flag --log-as-json on the \", \"command line:\\n\\n```\\ndapr run --app-id finecollectionservice --log-level info --log-as-json dotnet run\", \"\\n```\\n\\nIn Kubernetes, you can add a dapr.io/log-as-json annotation to each deployment for the applica\", \"tion:\\n\\n```\\nannotations: dapr.io/enabled: \\\"true\\\" dapr.io/app-id: \\\"finecollectionservice\\\" dapr.io/app-\", \"port: \\\"80\\\" dapr.io/config: \\\"dapr-config\\\" dapr.io/log-as-json: \\\"true\\\"\\n```\\n\\nWhen you install Dapr in a\", \" Kubernetes cluster using Helm, you can enable JSON formatted logging for all the Dapr system servic\", \"es:\\n\\n```\\nhelm repo add dapr https://dapr.github.io/helm-charts/ helm repo update kubectl create name\", \"space dapr-system helm install dapr dapr/dapr --namespace dapr-system --set global.logAsJson=true\\n``\", \"`\\n\\n## Collect logs\\n\\nThe logs emitted by Dapr can be fed into a monitoring back end for analysis. A l\", \"og collector is a component that collects logs from a system and sends them to a monitoring back end\", \". A popular log collector is Fluentd. Check out the How-To: Set up Fluentd, Elastic search and Kiban\", \"a in Kubernetes in the Dapr documentation. This article contains instructions for setting up Fluentd\", \" as log collector and the ELK Stack (Elastic Search and Kibana) as a monitoring back end.\\n\\n## Health\", \" status\\n\\nThe health status of a service provides insight into its availability. Each Dapr sidecar ex\", \"poses a health API that can be used by the hosting environment to determine the health of the sideca\", \"r. The API has one operation:\\n\\n```\\nGET http://localhost:3500/v1.0/healthz\\n```\\n\\nThe operation returns\", \" two HTTP status codes:\\n\\n- 204: When the sidecar is healthy\\n- 500: when the sidecar isn't healthy\\n\\nW\", \"hen running in selfhosted mode, the health API isn't automatically invoked. You can invoke the API t\", \"hough from application code or a health monitoring tool.\\n\\nWhen running in Kubernetes, the Dapr sidec\", \"ar-injector automatically configures Kubernetes to use the health API for executing liveness probes \", \"and readiness probes .\\n\\nKubernetes uses liveness probes to determine whether a container is up and r\", \"unning. If a liveness probe returns a failure code, Kubernetes will assume the container is dead and\", \" automatically restart it. This feature increases the overall availability of your application.\\n\\nKub\", \"ernetes uses readiness probes to determine whether a container is ready to start accepting traffic. \", \"A pod is considered ready when all of its containers are ready. Readiness determines whether a Kuber\", \"netes service can direct traffic to a pod in a loadbalancing scenario. Pods that aren't ready are au\", \"tomatically removed from the load-balancer.\\n\\nLiveness and readiness probes have several configurable\", \" parameters. Both are configured in the container spec section of a pod's manifest file. By default,\", \" Dapr uses the following configuration for each sidecar container:\\n\\n```\\nlivenessProbe: httpGet: path\", \": v1.0/healthz port: 3500 initialDelaySeconds: 5 periodSeconds: 10 timeoutSeconds : 5 failureThresho\", \"ld : 3\\n```\\n\\n```\\nreadinessProbe: httpGet: path: v1.0/healthz port: 3500 initialDelaySeconds: 5 period\", \"Seconds: 10 timeoutSeconds : 5 failureThreshold: 3\\n```\\n\\nThe following parameters are available for t\", \"he probes:\\n\\n- The path specifies the Dapr health API endpoint.\\n- The port specifies the Dapr health \", \"API port.\\n- The initialDelaySeconds specifies the number of seconds Kubernetes will wait before it s\", \"tarts probing a container for the first time.\\n- The periodSeconds specifies the number of seconds Ku\", \"bernetes will wait between each probe.\\n- The timeoutSeconds specifies the number of seconds Kubernet\", \"es will wait on a response from the API before timing out. A timeout is interpreted as a failure.\\n- \", \"The failureThreshold specifies the number of failed status code Kubernetes will accept before consid\", \"ering the container not alive or not ready.\\n\\n## Dapr dashboard\\n\\nDapr offers a dashboard that present\", \"s status information on Dapr applications, components, and configurations. Use the Dapr CLI to start\", \" the dashboard as a web-application on the local machine on port 8080:\\n\\n```\\ndapr dashboard\\n```\\n\\nFor \", \"Dapr application running in Kubernetes, use the following command:\\n\\n```\\ndapr dashboard -k\\n```\\n\\nThe d\", \"ashboard opens with an overview of all services in your application that have a Dapr sidecar. The fo\", \"llowing screenshot shows the Dapr dashboard for the Traffic Control sample application running in Ku\", \"bernetes:\\n\\n:::i mage type='content' source='./media/observability/dapr -dashboardoverview.png' alt -\", \"text='Dapr dashboard overview':::\\n\\nFigure 10-10. Dapr dashboard overview.\\n\\nThe Dapr dashboard is inv\", \"aluable when troubleshooting a Dapr application. It provides information about Dapr sidecars and sys\", \"tem services. You can drill down into the configuration of each service, including the logging entri\", \"es.\\n\\nThe dashboard also shows the configured components (and their configuration) for an application\", \":\\n\\n:::image type='content' source='./media/observability/dapr -dashboardcomponents.png' alt -text='D\", \"apr dashboard components':::\\n\\nFigure 10-11. Dapr dashboard components.\\n\\n\\u2022 Zipkin\\n\\nQ, Find a trace\\n\\n*\", \"' Dependencies\\n\\nTRAFFICCONTROLSERVICE: bindings/exitcam\\n\\nDuration: 1.785s Services: 3 Depth: 3 Total\", \" Spans: 8 Trace ID: b05e9fbd829ac2cd425295dc4c2fdf6a\\n\\nJA ENGLISH v\\n\\nSearch by trace ID\\n\\n* DOWNLOAD J\", \"SON\\n\\n\\u00ab\\n\\nThere's a large amount of information available through the dashboard. You can discover it b\", \"y running a Dapr application and browsing the dashboard.\\n\\nCheck out the Dapr dashboard CLI command r\", \"eference in the Dapr docs for more information on the Dapr dashboard commands.\\n\\nVEHICLEREGISTRATIONS\", \"ERVICE\\n\\nFINECOLLECTIONSERVICE\\n\\ncalllocal/vehicleregistrationservice/vehicleinfo/pl-454-f [101.711ms)\", \"\\n\\n/dapr.proto.runtime.v1.dapr/invokebinding [1.677s]\\n\\n## Use the Dapr .NET SDK\\n\\nThe Dapr .NET SDK do\", \"esn't contain any specific observability features. All observability features are offered at the Dap\", \"r level.\\n\\nIf you want to emit telemetry from your .NET application code, you should consider the Ope\", \"nTelemetry SDK for .NET. The Open Telemetry project is cross-platform, open source, and vendor agnos\", \"tic. It provides an end-to-end implementation to generate, emit, collect, process, and export teleme\", \"try data. There's a single instrumentation library per language that supports automatic and manual i\", \"nstrumentation. Telemetry is published using the Open Telemetry standard. The project has broad indu\", \"stry support and adoption from cloud providers, vendors, and end users.\\n\\n## Sample application: Dapr\", \" Traffic Control\\n\\nBecause the Traffic Control sample application runs with Dapr, all the telemetry d\", \"escribed in this chapter is available. If you run the application and open the Zipkin web fro nt end\", \", you'll see end -toend tracing. Figure 10-12 shows an example:\\n\\nFigure 10-12. Zipkin end-to-end tra\", \"cing example.\\n\\nThis trace shows the communication that occurs when a speeding violation has been det\", \"ected:\\n\\n1. An exiting vehicle triggers the MQTT input binding that sends a message containing the ve\", \"hicle license number, lane, and timestamp.\\n2. The MQTT input binding invokes the TrafficControl serv\", \"ice with the message.\\n3. The TrafficControl service retrieves the state for the vehicle, appends the\", \" entry, and saves the updated vehicle state back to the state store.\\n4. The TrafficControl service p\", \"ublishes the speeding violation using pub/sub to the speedingviolations topic.\\n5. The FineCollection\", \" service receives the speeding violation using a pub/sub subscription on the speedingviolations topi\", \"c.\\n6. The FineCollection service invokes the vehicleinfo endpoint of the VehicleRegistration service\", \" using service invocation.\\n7. The FineCollection service invokes an output binding for sending the e\", \"mail.\\n\\nClick any trace line (span) to see more details. If you click on the last line, you'll see th\", \"e sendmail binding component invoked to send the driver a violation notice.\\n\\nFINECOLLECTIONSERVICE\\n\\n\", \"/dapr.proto.runtime.v1.dapr/invokebinding\\n\\nSpan ID: 496eb0091499dd88 Parent ID:e3785a963afOec45\\n\\nAnn\", \"otations\\n\\nTags dapr.api\\n\\n/dapr.proto.runtime.v1.Dapr/InvokeBinding dapr.protocol\\n\\ngrpc db.connection\", \"_string|\\n\\nbindings doctane\\n\\nsendmail db.statement\\n\\n/dapr.proto.runtime.v1.Dapr/InvokeBinding db.syst\", \"em\\n\\nbindings\\n\\n\\u0433pc.service\\n\\nDapr\\n\\nFigure 10-13. Output binding trace details.\\n\\n## Summary\\n\\nDetailed o\", \"bservability is critical to running a distributed system in production.\\n\\nDapr provides different typ\", \"es of telemetry, including distributed tracing, logging, metrics, and health status.\\n\\nDapr only prod\", \"uces telemetry for the Dapr system services and sidecars. Telemetry from your application code isn't\", \" automatically included. You can however use a specific SDK like the OpenTelemetry SDK for .NET to e\", \"mit telemetry from your application code.\\n\\nDapr telemetry is produced in an open-standards based for\", \"mat so that it can be ingested by a large set of available monitoring tools. Examples include Zipkin\", \", Azure Application Insights, the ELK Stack, New Relic, and Grafana. See Monitor your application wi\", \"th Dapr in the Dapr documentation for tutorials on how to monitor your Dapr applications with specif\", \"ic monitoring back ends.\\n\\nYou'll need a telemetry scraper that ingests telemetry and publishe s it t\", \"o the monitoring back end.\\n\\nDapr can be configured to emit structured logging. Structured logging is\", \" favored as it can be indexed by back-end monitoring tools. Indexed logging enables users to execute\", \" rich queries when searching through the logging.\\n\\nDapr offers a dashboard that presents information\", \" about the Dapr services and configuration.\\n\\n## References\\n\\n- Azure Application Insights\\n- Open Tele\", \"metry\\n- Zipkin\\n- W3C Trace Context\\n- Jaeger\\n- New Relic\\n- Prometheus\\n- Grafana\\n- Open Telemetry SDK \", \"for .NET\\n- Fluentd\\n- ELK stack\\n- Seq\\n- Serilog\\n\\n## The Dapr secrets management building block\\n\\nEnter\", \"prise applications require secrets. Common examples include:\\n\\n- A database connection string that co\", \"ntains a username and password.\\n- An API key for calling an external web API.\\n- A client certificate\", \" for authenticating to an external system.\\n\\nSecrets must be carefully managed so that they're never \", \"disclosed outside of the application.\\n\\nNot long ago, it was popular to store application secrets in \", \"a configuration file inside the application codebase. .NET developers will fondly recall the web.con\", \"fig file. While simple to implement, integrating secrets to along with code was far from secure. A c\", \"ommon misstep was to include the file when pushing to a public GIT repository, exposing the secrets \", \"to the world.\\n\\nA widely accepted methodology for constructing modern distributed applications is The\", \" TwelveFactor App. It describes a set of principles and best practices. Its third factor prescribes \", \"that configuration and secrets be externalized outside of the code base.\\n\\nTo address this concern, t\", \"he .NET platform includes a Secret Manager feature that stores sensitive data in a physical folder o\", \"utside of the project tree. While secrets are outside of source control, this feature doesn't encryp\", \"t data. It's designed for development purposes only.\\n\\nA more modern and secure practice is to isolat\", \"e secrets in a secrets management tool like Hashicorp Vault or Azure Key Vault . These tools enable \", \"you to store secrets externally, vary credentials across environments, and reference them from appli\", \"cation code. However, each tool has its complexities and learning curve.\\n\\nDapr offers a building blo\", \"ck that simplifies managing secrets.\\n\\n## What it solves\\n\\nThe Dapr secrets management building block \", \"abstracts away the complexity of working with secrets and secret management tools.\\n\\n- It hides the u\", \"nderlying plumbing through a unified interface.\\n- It supports various pluggable secret store compone\", \"nts, which can vary between development and production.\\n- Applications don't require direct dependen\", \"cies on secret store libraries.\\n- Developers don't require detailed knowledge of each secret store.\\n\", \"\\nDapr handles all of the above concerns.\\n\\nAccess to the secrets is secured through authentication an\", \"d authorization. Only an application with sufficient rights can access secrets. Applications running\", \" in Kubernetes can also use its built-in secrets management mechanism.\\n\\n## How it works\\n\\nApplication\", \"s use the secrets management building block in two ways:\\n\\n- Retrieve a secret directly from the buil\", \"ding block.\\n- Reference a secret indirectly from a Dapr component configuration.\\n\\nRetrieving secrets\", \" directly is covered first. Referencing a secret from a Dapr component configuration file is address\", \"ed in a later section.\\n\\nThe application interacts with a Dapr sidecar when using the secrets managem\", \"ent building block. The sidecar exposes the secrets API. The API can be called with either HTTP or g\", \"RPC. Use the following URL to call the HTTP API:\\n\\nhttp://localhost:&lt;dapr-port&gt;/v1.0/secrets/&l\", \"t;store-name&gt;/&lt;name&gt;?&lt;metadata&gt;\\n\\nThe URL contains the following segments:\\n\\n- &lt;dapr\", \"-port&gt; specifies the port number upon which the Dapr sidecar is listening.\\n- &lt;store-name&gt; s\", \"pecifies the name of the Dapr secret store.\\n- &lt;name&gt; specifies the name of the secret to retri\", \"eve.\\n- &lt;metadata&gt; provides additional information for the secret. This segment is optional and\", \" metadata properties differ per secret store. For more information on metadata properties, see the [\", \"secrets API reference] INTERNAL-LINK:(Secrets API reference | Dapr Docs ).\\n\\n[!NOTE] The above URL re\", \"presents the native Dapr API call available to any development platform that supports HTTP or gRPC. \", \"Popular platforms like .NET, Java, and Go have their own custom APIs.\\n\\nThe JSON response contains th\", \"e key and value of the secret.\\n\\nFigure 11-1 shows how Dapr handles a request for the secrets API:\\n\\n{\", \"\\n\\n}\\n\\nGET http://localhost:3500/v1.0/secrets/secrets-store/redis-password\\n\\nService A\\n\\nFigure 11-1. Re\", \"trieving a secret with the Dapr secrets API.\\n\\n1. The service calls the Dapr secrets API, along with \", \"the name of the secret store, and secret to retrieve.\\n2. The Dapr sidecar retrieves the specified se\", \"cret from the secret store.\\n3. The Dapr sidecar returns the secret information back to the service.\\n\", \"\\nSome secret stores support storing multiple key/value pairs in a single secret. For those scenarios\", \", the response would contain multiple key/value pairs in a single JSON response as in the following \", \"example:\\n\\nGET http://localhost:3500/v1.0/secrets/secret-store/interestRates?metadata.version_id=3\\n\\n`\", \"``\\n{ \\\"tier1-percentage\\\": \\\"2.5\\\", \\\"tier2-percentage\\\": \\\"3.8\\\", \\\"tier3-percentage\\\": \\\"5.1\\\" }\\n```\\n\\nThe Dapr\", \" secrets API also offers an operation to retrieve all the secrets the application has access to:\\n\\n``\", \"`\\nhttp://localhost:<dapr-port>/v1.0/secrets/<store-name>/bulk\\n```\\n\\n## Use the Dapr .NET SDK\\n\\nFor .NE\", \"T developers, the Dapr .NET SDK streamlines Dapr secret management. Consider the DaprClient.GetSecre\", \"tAsync method. It enables you to retrieve a secret directly from any Dapr secret store with minimal \", \"effort. Here's an example of fetching a connection string secret for a SQL Server database:\\n\\n```\\nvar\", \" metadata = new Dictionary<string, string> { [\\\"version_id\\\"] = \\\"3\\\" }; Dictionary<string, string> secr\", \"ets = await daprClient.GetSecretAsync(\\\"secret-store\\\", \\\"eshopsecrets\\\", metadata); string connectionSt\", \"ring = secrets[\\\"customerdb\\\"];\\n```\\n\\nArguments for the GetSecretAsync method include:\\n\\n- The name of t\", \"he Dapr secret store component ('secret -store')\\n- The secret to retrieve ('eshopsecrets')\\n- Optiona\", \"l metadata key/value pairs ('version_id=3')\\n\\nThe method responds with a dictionary object as a secre\", \"t can contain multiple key/value pairs. In the example above, the secret named customerdb is referen\", \"ced from the collection to return a connection string.\\n\\nThe Dapr .NET SDK also features a .NET confi\", \"guration provider. It loads specified secrets into the underlying .NET configuration API. The runnin\", \"g application can then reference secrets from the IConfiguration dictionary that is registered in AS\", \"P.NET Core dependency injection.\\n\\nThe secrets configuration provider is available from the Dapr.Exte\", \"nsions.Configuration NuGet package. The provider can be registered in the Program.cs of an ASP.NET W\", \"eb API application:\\n\\n```\\nvar builder = WebApplication.CreateBuilder(args); builder.WebHost.Configure\", \"AppConfiguration(config => { var daprClient = new DaprClientBuilder().Build(); var secretDescriptors\", \" = new List<DaprSecretDescriptor> { new DaprSecretDescriptor(\\\"eshopsecrets\\\") }; config.AddDaprSecret\", \"Store(\\\"secret-store\\\", secretDescriptors, daprClient); });\\n```\\n\\nThe above example loads the eshopsecr\", \"ets secrets collection into the .NET configuration system at startup. Registering the provider requi\", \"res an instance of DaprClient to invoke the secrets API on the Dapr sidecar. The other arguments inc\", \"lude the name of the secret store and a DaprSecretDescriptor object with the name of the secret.\\n\\nOn\", \"ce loaded, you can retrieve secrets directly from application code:\\n\\n```\\npublic void GetCustomer(ICo\", \"nfiguration config) { var connectionString = config[\\\"eshopsecrets\\\"][\\\"customerdb\\\"]; }\\n```\\n\\n## Secret \", \"store components\\n\\nThe secrets management building block supports several secret store components. At\", \" the time of writing, the following secret stores are available:\\n\\n- AlibabaCloud OOS Parameter Store\", \"\\n- AWS Secrets Manager\\n- AWS SSM Parameter Store\\n\\n- Azure Key Vault\\n- GCP Secret Manager\\n- HashiCorp\", \" Vault\\n- Kubernetes secrets\\n- Local environment variables\\n- Local file\\n\\n## Important\\n\\nThe local envi\", \"ronment variables and file components are designed for development workloads only.\\n\\nThe following se\", \"ctions show how to configure a secret store.\\n\\n## Configuration\\n\\nYou configure a secret store using a\", \" Dapr component configuration file. The typical structure of the file is shown below:\\n\\n```\\napiVersio\", \"n: dapr.io/v1alpha1 kind: Component metadata: name: [ component name ] namespace: [ namespace ] spec\", \": type: secretstores.[secret store type] version: [ secret store version ] metadata: -name: [ proper\", \"ty name ] value: [ property value ]\\n```\\n\\nAll Dapr component configuration files require a name along\", \" with an optional namespace value. Additionally, the type field in the spec section specifies the ty\", \"pe of secret store component. The properties in the metadata section differ per secret store.\\n\\n## In\", \"directly consume Dapr secrets\\n\\nAs mentioned earlier in this chapter, applications can also consume s\", \"ecrets by referencing them in component configuration files. Consider a state management component t\", \"hat uses Redis cache for storing state:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: \", \"name: eshop-basket-statestore namespace: eshop spec: type: state.redis version: v1 metadata: -name: \", \"redisHost value: localhost:6379 -name: redisPassword value: e$h0p0nD@pr\\n```\\n\\nThe above configuration\", \" file contains a clear-text password for connecting to the Redis server. Hardcoded passwords are alw\", \"ays a bad idea. Pushing this configuration file to a public repository would expose the password. St\", \"oring the password in a secret store would dramatically improve this scenario.\\n\\nThe following exampl\", \"es demonstrate this using several different secret stores.\\n\\n## Local file\\n\\nThe local file component \", \"is designed for development scenarios. It stores secrets on the local filesystem inside a JSON file.\", \" Here's an example named eshop-secrets.json . It contains a single secret - a password for Redis:\\n\\n`\", \"``\\n{ \\\"eShopRedisPassword\\\": \\\"e$h0p0nD@pr\\\" }\\n```\\n\\nYou place this file in a components folder that you \", \"specify when running the Dapr application.\\n\\nThe following secret store configuration file consumes t\", \"he JSON file as a secret store. It's also placed in the components folder:\\n\\n```\\napiVersion: dapr.io/\", \"v1alpha1 kind: Component metadata: name: eshop-local-secret-store namespace: eshop spec: type: secre\", \"tstores.local.file version: v1 metadata: -name: secretsFile value: ./components/eshop-secrets.json -\", \"name: nestedSeparator value: \\\":\\\"\\n```\\n\\nThe component type is secretstore.local.file . The secretsFile\", \" metadata element specifies the path to the secrets file.\\n\\n## Important\\n\\nThe path to a secrets file \", \"can be a absolute or relative path. The relative path is based on the folder in which the applicatio\", \"n starts. In the example, the components folder is a sub-folder of the directory that contains the .\", \"NET application.\\n\\nFrom the application folder, start the Dapr application specifying the components \", \"path as a commandline argument:\\n\\n```\\ndapr run --app-id basket-api --components-path ./components dot\", \"net run\\n```\\n\\n## Note\\n\\nThis above example applies to running Dapr in self-hosted mode. For Kubernetes\", \" hosting, consider using volume mounts.\\n\\nThe nestedSeparator in a Dapr configuration file specifies \", \"a character to flatten a JSON hierarchy. Consider the following snippet:\\n\\n```\\n{ \\\"redisPassword\\\": \\\"so\", \"me password\\\", \\\"connectionStrings\\\": { \\\"customerdb\\\": \\\"some connection string\\\", \\\"productdb\\\": \\\"some conn\", \"ection string\\\" } }\\n```\\n\\nUsing a colon as a separator, you can retrieve the customerdb connection-str\", \"ing using the key connectionStrings:customerdb .\\n\\nNote The colon : is the default separator value.\\n\\n\", \"In the next example, a state management configuration file references the local secret store compone\", \"nt to obtain the password for connecting to the Redis server:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind\", \": Component metadata: name: eshop-basket-statestore namespace: eshop spec: type: state.redis version\", \": v1 metadata: -name: redisHost value: localhost:6379 -name: redisPassword secretKeyRef: name: eShop\", \"RedisPassword key: eShopRedisPassword auth: secretStore: eshop-local-secret-store\\n```\\n\\nThe secretKey\", \"Ref element references the secret containing the password. It replaces the earlier cleartext value. \", \"The secret name and the key name, eShopRedisPassword , reference the secret. The name of the secret \", \"management component eshop-local-secret-store is found in the auth metadata element.\\n\\nYou might wond\", \"er why eShopRedisPassword is identical for both the name and key in the secret reference. In the loc\", \"al file secret store, secrets aren't identified with a separate name. The scenario will be different\", \" in the next example using Kubernetes secrets.\\n\\n## Kubernetes secret\\n\\nThis second example focuses on\", \" a Dapr application running in Kubernetes. It uses the standard secrets mechanism that Kubernetes of\", \"fers. Use the Kubernetes CLI ( kubectl ) to create a secret named eshopredis-secret that contains th\", \"e password:\\n\\nkubectl create secret generic eshopsecrets --from-literal=redisPassword=e$h0p0nD@pr -n \", \"eshop\\n\\nOnce created, you can reference the secret in the component configuration file for state mana\", \"gement:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: eshop-basket-statestore na\", \"mespace: eshop spec: type: state.redis version: v1 metadata: -name: redisHost value: redis:6379 -nam\", \"e: redisPassword secretKeyRef: name: eshopsecrets key: redisPassword auth: secretStore: kubernetes\\n`\", \"``\\n\\nThe secretKeyRef element specifies the name of the Kubernetes secret and the secret's key, eshop\", \"secrets , and redisPassword respectively. The auth metadata section instructs Dapr to use the Kubern\", \"etes secrets management component.\\n\\n## Note\\n\\nAuth is the default value when using Kubernetes secrets\", \" and can be omitted.\\n\\nIn a production setting, secrets are typically created as part of an automated\", \" CI/CD pipeline. Doing so ensures only people with sufficient permissions can access and change the \", \"secrets. Developers create configuration files without knowing the actual value of the secrets.\\n\\n## \", \"Azure Key Vault\\n\\nThe next example is geared toward a real-world production scenario. It uses Azure K\", \"ey Vault as the secret store. Azure Key Vault is a managed Azure service that enables secrets to be \", \"stored securely in the cloud.\\n\\nFor this example to work, the following prerequisites must be satisfi\", \"ed:\\n\\n- You've secured administrative access to an Azure subscription.\\n- You've provisioned an Azure \", \"Key Vault named eshopkv that holds a secret named redisPassword that contains the password for conne\", \"cting to the Redis server.\\n- You've created service principal in Azure Active Directory.\\n\\n- You've i\", \"nstalled an X509 certificate for this service principal ( containing both the public and private key\", \") on the local filesystem.\\n\\n## Note\\n\\nA service principal is an identity that can be used by an appli\", \"cation to authenticate an Azure service. The service principal uses a X509 certificate. The applicat\", \"ion uses this certificate as a credential to authenticate itself.\\n\\nThe Dapr Azure Key Vault secret s\", \"tore documentation provides step-by-step instructions to create and configure a Key Vault environmen\", \"t.\\n\\n## Use Key Vault when running in self-hosted mode\\n\\nUsing Azure Key Vault in Dapr self-hosted mod\", \"e requires the following component configuration file:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Compo\", \"nent metadata: name: eshop-azurekv-secret-store namespace: eshop spec: type: secretstores.azure.keyv\", \"ault version: v1 metadata: -name: vaultName value: eshopkv -name: spnTenantId value: \\\"619926af-a7c3-\", \"4e95-93ed-4ecc4e3e652b\\\" -name: spnClientId value: \\\"6cf48032-6c38-43be-9d6f-2a43ce736b09\\\" -name: spnC\", \"ertificateFile value : \\\"azurekv-spn-cert.pfx\\\"\\n```\\n\\nThe secret store type is secretstores.azure.keyva\", \"ult . The metadata element provides access to the Key Vault with the following properties:\\n\\n- The va\", \"ultName contains the name of the Azure Key Vault.\\n- The spnTenantId contains the tenant ID of the se\", \"rvice principal used to authenticate against the Key Vault.\\n- The spnClientId contains the app ID of\", \" the service principal used to authenticate against the Key Vault.\\n- The spnCertificateFile contains\", \" the path to the certificate file for the service principal to authenticate against the Key Vault.\\n\\n\", \"## Tip\\n\\nYou can copy the service principal information from the Azure portal or Azure CLI .\\n\\nNow the\", \" application can retrieve the Redis password from the Azure Key Vault.\\n\\n## Use Key Vault when runnin\", \"g on Kubernetes\\n\\nConsuming Azure Key Vault with Dapr and Kubernetes also requires a service principa\", \"l to authenticate against the Azure Key Vault.\\n\\nFirst, create a Kubernetes secret that contains a ce\", \"rtificate file using the kubectl CLI tool:\\n\\n```\\nkubectl create secret generic [k8s_spn_secret_name] \", \"--fromfile=[pfx_certificate_file_local_path] -n eshop\\n```\\n\\nThe command requires two command-line arg\", \"uments:\\n\\n- [k8s_spn_secret_name] is the secret name in Kubernetes secret store.\\n- [pfx_certificate_f\", \"ile_local_path] is the path of X509 certificate file.\\n\\nOnce created, you can reference the Kubernete\", \"s secret in the secret store component configuration file:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: C\", \"omponent metadata: name: eshop-azurekv-secret-store namespace: eshop spec: type: secretstores.azure.\", \"keyvault version: v1 metadata: -name: vaultName value: [ your_keyvault_name ] -name: spnTenantId val\", \"ue: \\\"619926af-a7c3-4e95-93ed-4ecc4e3e652b\\\" -name: spnClientId value: \\\"6cf48032-6c38-43be-9d6f-2a43ce\", \"736b09\\\" -name: spnCertificate secretKeyRef: name: [ k8s_spn_secret_name ] key: [ pfx_certificate_fil\", \"e_local_name ] auth: secretStore: kubernetes\\n```\\n\\nAt this point, an application running in Kubernete\", \"s can retrieve the Redis password from the Azure Key Vault.\\n\\n## Important\\n\\nIt's critical to keep the\", \" X509 certificate file for the service principal in a safe place. It's best to place it in a well-kn\", \"own folder outside the source-code repository. The configuration file can then reference the certifi\", \"cate file from this well-known folder. On a local development machine, you're responsible for copyin\", \"g the certificate to the folder. For automated deployments, the pipeline will copy the certificate t\", \"o the machine where the application is deployed. It's a best practice to use a differen t service pr\", \"incipal per environment. Doing so prevents the service principal from a DEVELOPMENT environment to a\", \"ccess secrets in a PRODUCTION environment.\\n\\nWhen running in Azure Kubernetes Service (AKS), it's pre\", \"ferable to use an Azure Managed Identity for authenticating against Azure Key Vault. Managed identit\", \"ies are outside of the scope of this book, but explained in the Azure Key Vault with managed identit\", \"ies documentation.\\n\\n## Scope secrets\\n\\nSecret scopes allow you to control which secrets your applicat\", \"ion can access. You configure scopes in a Dapr sidecar configuration file. The Dapr configuration do\", \"cumentation provides instructions for scoping secrets.\\n\\nHere's an example of a Dapr sidecar configur\", \"ation file that contains secret scopes:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Configuration metada\", \"ta: name: dapr-config namespace: eshop spec: tracing: samplingRate: \\\"1\\\" secrets: scopes: -storeName:\", \" eshop-azurekv-secret-store defaultAccess: allow deniedSecrets: [ \\\"redisPassword\\\" , \\\"apiKey\\\" ]\\n```\\n\\n\", \"You specify scopes per secret store. In the above example, the secret store is named eshop-azurekvse\", \"cret-store . You configure access to secrets using the following properties:\\n\\n| Property       | Val\", \"ue               | Description                                                                      \", \"                                               |\\n|----------------|---------------------|-----------\", \"----------------------------------------------------------------------------------------------------\", \"------------------|\\n| defaultAccess  | allow or deny       | Allows or denies access to all secrets \", \"in the specified secret store. This property is optional with a default value of allow . |\\n| allowed\", \"Secrets | List of secret keys | Secrets specified in the array will be accessible. This property is \", \"optional.                                                   |\\n| deniedSecrets  | List of secret keys\", \" | Secrets specified in the array will NOT be accessible. This property is optional.                \", \"                               |\\n\\nThe allowedSecrets and deniedSecrets properties take precedence ov\", \"er the defaultAccess property. Imagine specifying defaultAccess: allowed and an allowedSecrets list.\", \" In this case, only the secrets in the allowedSecrets list would be accessible by the application.\\n\\n\", \"## Sample application: Dapr Traffic Control\\n\\nIn Dapr Traffic Control sample app, the secrets managem\", \"ent building block is used in several places. Secrets are retrieved from code and referenced by Dapr\", \" component configuration files. Figure 10-2 shows the conceptual architecture of the Dapr Traffic Co\", \"ntrol sample application. The Dapr secrets management building block is used in flows marked with nu\", \"mber 6 in the diagram:\\n\\nTrafficControl\\n\\nService\\n\\nFineCollection\\n\\nService\\n\\nVehicleRegistration\\n\\nServi\", \"ce\\n\\n2\\n\\ndapr\\n\\nSidecar\\n\\n5\\n\\nCamera\\n\\nSimulation\\n\\nFigure 10-2. Conceptual architecture of the Dapr Traffi\", \"c Control sample application.\\n\\nThe FineCollection service uses an SMTP output binding for sending em\", \"ails (see the Bindings chapter). The email component file consumes the secrets management building b\", \"lock to retrieve credentials to connect to the SMTP server. To calculate the fine for a speeding vio\", \"lation, the service uses a fictitious FineCalculator component that requires a license key. It retri\", \"eves this license key from the secrets management building block.\\n\\nThe TrafficControl service stores\", \" vehicle information in a Redis state store (see the State management chapter). It uses the secrets \", \"management building block for retrieving credentials to connect to the Redis server.\\n\\nBecause the Tr\", \"affic Control sample application can run in self-hosted mode or in Kubernetes, there are two ways fo\", \"r specifying secrets:\\n\\n- A local JSON file\\n- A Kubernetes secret\\n\\n2 - 3 -\\n\\nEntryCam\\n\\n5\\n\\n5\\n\\n## Secret\", \"s\\n\\nExamine the secrets-file.yaml component configuration file in the dapr/components folder:\\n\\n```\\nap\", \"iVersion: dapr.io/v1alpha1 kind: Component metadata: name: trafficcontrol-secrets namespace: dapr-tr\", \"afficcontrol spec: type: secretstores.local.file version: v1 metadata: -name: secretsFile value: ../\", \"dapr/components/secrets.json -name: nestedSeparator value: \\\".\\\" scopes: -trafficcontrolservice -finec\", \"ollectionservice\\n```\\n\\nThe file describes a secrets management component entitled trafficcontrol-secr\", \"ets . The type element is set to local.file and the secretsFile to ../dapr/components/secrets.json .\", \" For selfhosted mode, use a Local file component. The path must be relatively specified from the fol\", \"der from which the service starts. The secrets file contains a JSON representation of the secrets:\\n\\n\", \"```\\n{ \\\"state\\\":{ \\\"redisPassword\\\": \\\"\\\" }, \\\"smtp\\\":{ \\\"user\\\": \\\"_username\\\", \\\"password\\\": \\\"_password\\\" }, \\\"fin\", \"ecalculator\\\":{ \\\"licensekey\\\": \\\"HX783-K2L7V-CRJ4A-5PN1G\\\" } }\\n```\\n\\nIn the sample application the Redis \", \"server is used without a password. To connect to the SMTP server, the credentials are _username and \", \"_password . The license key for the FineCalculator license key is a randomly generated string.\\n\\nWhil\", \"e secrets are stored at nested levels, the secrets management building block flattens this hierarchy\", \" when the file is read. It uses a period as a level separator (as specified in the nestedSeparator f\", \"ield in the component configuration file). This construct enables you to reference secrets with a fl\", \"attened name, for example: smtp.user .\\n\\nWhen running in Kubernetes, the secrets are specified using \", \"the built-in Kubernetes secrets store. Examine the following secrets.yaml Kubernetes manifest file i\", \"n the k8s folder:\\n\\n```\\napiVersion: v1 kind: Secret metadata: name: trafficcontrol-secrets namespace:\", \" dapr-trafficcontrol\\n```\\n\\n```\\ntype: Opaque data: smtp.user: X3VzZXJuYW1l smtp.password: X3Bhc3N3b3Jk\", \" finecalculator.licensekey: SFg3ODMtSzJMN1YtQ1JKNEEtNVBOMUc=\\n```\\n\\nThe component is also named traffi\", \"ccontrol-secrets . Secrets are stored as Base64 encoded strings.\\n\\n## Important\\n\\nBase64 representatio\", \"ns encode , but do not encrypt data. Base64 isn't secure for production scenarios.\\n\\nThe following pa\", \"ragraphs describe how secrets are used in the Traffic Control sample application.\\n\\n## SMTP server cr\", \"edentials\\n\\nExamine the email.yaml component configuration file located in the dapr/components folder\", \":\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: sendmail namespace: dapr-traffic\", \"control spec: type: bindings.smtp version: v1 metadata: -name: host value: localhost -name: port val\", \"ue: 4025 -name: user secretKeyRef: name: smtp.user key: smtp.user -name: password secretKeyRef: name\", \": smtp.password key: smtp.password -name: skipTLSVerify value: true auth: secretStore: trafficcontro\", \"l-secrets scopes: -finecollectionservice\\n```\\n\\nThe auth section references the secrets management com\", \"ponent named trafficcontrol-secrets . The user and password entries in the binding metadata referenc\", \"e the secrets: smtp.user and smtp.password respectively.\\n\\nWhen running in Kubernetes, the built-in K\", \"ubernetes secrets store is used. The email.yaml manifest file found in the k8s folder references the\", \" Kubernetes secret for retrieving the credentials for connecting to the smtp server:\\n\\n```\\napiVersion\", \": dapr.io/v1alpha1 kind: Component\\n```\\n\\n```\\nmetadata: name: sendmail namespace: dapr-trafficcontrol \", \"spec: type: bindings.smtp version: v1 metadata: -name: host value: mailserver -name: port value: 25 \", \"-name: user secretKeyRef: name: trafficcontrol-secrets key: smtp.user -name: password secretKeyRef: \", \"name: trafficcontrol-secrets key: smtp.password -name: skipTLSVerify value: true scopes: -finecollec\", \"tionservice\\n```\\n\\nUnlike the local secrets store, the Kubernetes store doesn't explicitly specify a s\", \"ecrets management component to use with the auth section. Instead, the default is the built-in Kuber\", \"netes secrets store.\\n\\n## Redis server credentials\\n\\nNext, examine the statestore.yaml component confi\", \"guration file in the dapr/components folder:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metad\", \"ata: name: statestore namespace: dapr-trafficcontrol spec: type: state.redis version: v1 metadata: -\", \"name: redisHost value: localhost:6379 -name: redisPassword secretKeyRef: name: state.redisPassword k\", \"ey: state.redisPassword -name: actorStateStore value: \\\"true\\\" auth: secretStore: trafficcontrol-secre\", \"ts scopes: -trafficcontrolservice\\n```\\n\\nOnce again, the auth section references the secrets managemen\", \"t component named trafficcontrol-secrets . The redisPassword entries in the binding metadata referen\", \"ce the secret state.redisPassword .\\n\\n## FineCalculator component license key\\n\\nThe FineCollection ser\", \"vice uses a component that calculates the fine based on the information of a speeding violation. Thi\", \"s component is implemented as a domain service and is abstracted by the IFineCalculator interface:\\n\\n\", \"```\\npublic interface IFineCalculator { public int CalculateFine(string licenseKey, int violationInKm\", \"h); }\\n```\\n\\nThe CalculateFine method expects a string containing a licenseKey as its first argument. \", \"This key unlocks the third-party component used by the implementation. To keep the example simple, t\", \"he implementation hard-codes a series of if statements. You can find the implementation in the HardC\", \"odedFineCalculator class in the DomainsServices folder:\\n\\n```\\npublic class HardCodedFineCalculator : \", \"IFineCalculator { public int CalculateFine(string licenseKey, int violationInKmh) { if (licenseKey !\", \"= \\\"HX783-K2L7V-CRJ4A-5PN1G\\\") { throw new InvalidOperationException(\\\"Invalid license-key specified.\\\")\", \"; } int fine = 9; // default administration fee if (violationInKmh < 5 ) { fine += 18; } else if (vi\", \"olationInKmh >= 5 && violationInKmh < 10 ) { fine += 31; } // ... else if (violationInKmh == 35) { f\", \"ine += 372; } else { // violation above 35 KMh will be determined by the prosecutor return 0; } retu\", \"rn fine; } }\\n```\\n\\nThe implementation simulates a check on the licenseKey that is passed in. The Coll\", \"ectionController of the FineCollection service must pass in the correct license key argument when ca\", \"lling the CalculateFine method. It retrieves the license key from the Dapr secrets management buildi\", \"ng block that is exposed by the Dapr client in the Dapr SDK for .NET. If you examine the constructor\", \" of the CollectionController , you can see the call:\\n\\n```\\n// set finecalculator component license-ke\", \"y if (_fineCalculatorLicenseKey == null ) { bool runningInK8s = Convert.ToBoolean(Environment.GetEnv\", \"ironmentVariable(\\\"DOTNET_RUNNING_IN_CONTAINER\\\") ?? \\\"false\\\"); var metadata = new Dictionary<string, s\", \"tring> { { \\\"namespace\\\", \\\"dapr-trafficcontrol\\\" } }; if (runningInK8s) { var k8sSecrets = daprClient.G\", \"etSecretAsync( \\\"kubernetes\\\", \\\"trafficcontrol-secrets\\\", metadata).Result; _fineCalculatorLicenseKey =\", \" k8sSecrets[\\\"finecalculator.licensekey\\\"]; } else { var secrets = daprClient.GetSecretAsync( \\\"traffic\", \"control-secrets\\\", \\\"finecalculator.licensekey\\\", metadata).Result; _fineCalculatorLicenseKey = secrets\", \"[\\\"finecalculator.licensekey\\\"]; } }\\n```\\n\\nThe code determines whether the service is running in Kubern\", \"etes or self-hosted mode. This check is necessary because a different secrets management component m\", \"ust be used for each situation. The first argument of the GetSecretAsync method is the name of the D\", \"apr component. The second argument is the name of the secret. The metadata passed in as the third ar\", \"gument specifies the namespace that contains the secret. The value of the finecalculator.licensekey \", \"secret is stored in a private field for later use.\\n\\nUsing Dapr secrets management offers several ben\", \"efits:\\n\\n1. No sensitive information is stored in code or application configuration files.\\n2. No need\", \" to learn any new API for interacting with a secrets store.\\n\\n## Summary\\n\\nThe Dapr secrets management\", \" building block provides capabilities for storing and retrieving sensitive configuration settings li\", \"ke passwords and connection-strings. It keeps secrets private and prevents them from being accidenta\", \"lly disclosed.\\n\\nThe building block supports several different secret stores and hides their complexi\", \"ty with the Dapr secrets API.\\n\\nThe Dapr .NET SDK provides a DaprClient object to retrieve secrets. I\", \"t also includes a .NET configuration provider that adds secrets to the .NET configuration system. On\", \"ce loaded, you can consume these secrets in your .NET code.\\n\\nYou can use secret scopes to control ac\", \"cess to specific secrets.\\n\\n## References\\n\\n- Beyond the Twelve-Factor Application\\n\\n- Dapr supported s\", \"ecret stores\\n\\nMicrosoft\\n\\n.NET Microservices:\\n\\nArchitecture for\\n\\nContainerized NET\\n\\nApplications\\n\\n## \", \"Dapr reference application\\n\\nOver the co urse of this book, you've learned about the foundational ben\", \"efits of Dapr. You saw how Dapr can help you and your team construct distributed applications while \", \"reducing architectural and operational complexity. Along the way, you've had the opportunity to buil\", \"d some small Dapr apps. Now, it's time to explore how a more complex application can benefit from Da\", \"pr.\\n\\nBut, first a little history.\\n\\n## eShopOnContainers\\n\\nSeveral years ago, Microsoft, in partnershi\", \"p with leading community experts, released a popular guidance book, entitled .NET Microservices for \", \"Containerized .NET Applications. Figure 12-1 shows the book:\\n\\nFigure 12-1. .NET Microservices: Archi\", \"tecture for Containerized .NET Applications.\\n\\nThe book dove deep into the principles, patterns, and \", \"best practices for building distributed applications. It included a full-featured microservice refer\", \"ence application that showcased the architectural concepts. Entitled, eShopOnContainers, the applica\", \"tion hosts an e-Commerce storefront that sells various items, including clothing and coffee mugs. Bu\", \"ilt in .NET, the application is crossplatform and can run in either Linux or Windows containers. Fig\", \"ure 12-2 shows the original eShop architecture.\\n\\nClient apps eShop mobile app\\n\\nXamarin.Forms\\n\\nC#\\n\\nxP\", \"lat. OS:\\n\\niOS\\n\\nAndroid\\n\\nWindows eShop traditional Web app\\n\\nK\\n\\neShop SPA Web app\\n\\nTypeScript/Angular \", \"2\\n\\nFigure 12-2. Original ShopOnContainers reference application.\\n\\nAs you can see, eShopOnContainers \", \"includes many moving parts:\\n\\n1. Three different frontend clients.\\n2. An application gateway to abstr\", \"act backend services from the frontend.\\n3. Several backend core microservices.\\n4. An event bus compo\", \"nent that enables asynchronous pub/sub messaging.\\n\\nThe eShopOnContainers reference application has b\", \"een widely accepted across the .NET community and used to model many large commercial microservice a\", \"pplications.\\n\\n## eShopOnDapr\\n\\nAn updated version of eShop accompanies this book. It's called eShopOn\", \"Dapr. The update evolves the earlier eShopOnContainers application by integrating Dapr building bloc\", \"ks. Figure 12-3 shows the new solution architecture:\\n\\n[eShopOnDapr reference application architectur\", \"e](#g \\ufffd\\ufffd\\ufffd r&amp; \\ufffd &lt; \\ufffd\\ufffd p \\ufffd\\ufffd r \\ufffdm\\u0433z\\ufffd !c(* \\ufffd -\\u03ce\\ufffd 9 \\ufffd\\ufffd\\ufffd\\ufffd &gt;4)\\n\\nFigure 12-3. eShopOnDapr reference\", \" application architecture.\\n\\nWhile eShopOnDapr focuses on Dapr, the architecture has also been stream\", \"lined and simplified.\\n\\n1. A Single Page Application running on Blazor WebAssembly sends user request\", \"s to an API gateway.\\n2. The API gateway abstracts the backend core microservices from the frontend c\", \"lient. It's implemented using Envoy, a high performant, open-source service proxy. Envoy routes inco\", \"ming\\n\\neShopOnContainers reference application\\n\\n(Development environment architecture)\\n\\n-\\n\\n\\u2022 Docker H\", \"ost\\n\\nIdentity microservice (STS+users)\\n\\nSQL Server database\\n\\nAPI Gateways/BFF Catalog microservice S\", \"QL Server\\n\\nBlazor\\n\\nFrontend\\n\\nActors\\n\\nSecrets\\n\\n5\\n\\ndapr\\n\\n3\\n\\nBasket\\n\\n4\\n\\n3\\n\\n4\\n\\nrequests to backend micro\", \"services. Most requests are simple CRUD operations (for example, get the list of brands from the cat\", \"alog) and handled by a direct call to a backend microservice.\\n\\n(Envoy)\\n\\n5\\n\\naggregator\\n\\n5\\n\\n3. Other r\", \"equests are more logically complex and require multiple microservice calls to work together. For the\", \"se cases, eShopOnDapr implements an aggregator microservice that orchestrates a workflow across thos\", \"e microservices needed to complete the operation.\\n\\n3\\n\\n4. The core backend microservices implement th\", \"e required functionality for an e-Commerce store. Each is self-contained and independent of the othe\", \"rs. Following widely accepted domain decomposition patterns, each microservice isolates a specific b\", \"usiness capability : 5\\n2. -The basket service manages the customer's shopping basket experience.\\n3. \", \"-The catalog service manages product items available for sale.\\n4. -The identity service manages auth\", \"entication and identity.\\n5. -The ordering service handles all aspects of placing and managing orders\", \".\\n6. -The payment service transacts the customer's payment.\\n5. Adhering to best practices, each micr\", \"oservice maintains its own persistent storage. The application doesn't share a single datastore.\\n6. \", \"Finally, the event bus wraps the Dapr publish/subscribe components. It enables asynchronous publish/\", \"subscribe messaging across microservices. Developers can plug in any Dapr-supported message broker c\", \"omponent.\\n\\n## Application of Dapr building blocks\\n\\nIn eShopOnDapr, Dapr building blocks replace a la\", \"rge amount of complex, error-prone plumbing code.\\n\\nFigure 12-4 shows the Dapr integration in the app\", \"lication.\\n\\nFigure 12-4. Dapr integration in eShopOnDapr.\\n\\nThe above figure shows the Dapr building b\", \"locks (represented as green numbered boxes) that each eShopOnDapr service consumes.\\n\\n1. The API gate\", \"way and web shopping aggregator services use the service invocation building block to invoke methods\", \" on the backend services.\\n2. The backend services communicate asynchronously using the publish &amp;\", \" subscribe building block.\\n3. The basket service uses the state management building block to store t\", \"he state of the customer's shopping basket.\\n4. The original eShopOnContainers demonstrates DDD conce\", \"pts and patterns in the ordering service. eShopOnDapr uses the actor building block as an alternativ\", \"e implementation. The turnbased access model of actors makes it easy to implement a stateful orderin\", \"g process with support for cancellation.\\n5. The ordering service sends order confirmation e-mails us\", \"ing the bindings building block.\\n6. Secret management is done by the secrets building block.\\n\\nThe fo\", \"llowing sections provide more detail on how the Dapr building blocks are applied in eShopOnDapr.\\n\\n##\", \" State management\\n\\nIn eShopOnDapr, the Basket service uses the state management building block to pe\", \"rsist the contents of the customer's shopping basket. The original eShopOnCont ainers architecture u\", \"sed an IBasketRepository interface to read and write data for the basket service. The RedisBasketRep\", \"ository class provided the implementation using Redis as the underlying data store. To compare and c\", \"ontrast, the original eShopOnContainers implementation is presented below:\\n\\n```\\npublic class RedisBa\", \"sketRepository : IBasketRepository { private readonly ConnectionMultiplexer _redis; private readonly\", \" IDatabase _database; public RedisBasketRepository(ConnectionMultiplexer redis) { _redis = redis; _d\", \"atabase = redis.GetDatabase(); } public async Task<CustomerBasket> GetBasketAsync(string customerId)\", \" { var data = await _database.StringGetAsync(customerId); if (data.IsNullOrEmpty) { return null ; } \", \"return JsonConvert.DeserializeObject<CustomerBasket>(data); } // ... }\\n```\\n\\nThis code uses the third\", \" party StackExchange.Redis NuGet package. The following steps are required to load the shopping bask\", \"et for a given customer:\\n\\n1. Inject a Redis ConnectionMultiplexer into the constructor. The Connecti\", \"onMultiplexer is registered with the dependency injection framework in the Program.cs file:\\n1. Use t\", \"he ConnectionMultiplexer to create an IDatabase instance in each consuming class.\\n2. Use the IDataba\", \"se instance to execute a Redis StringGet call using the given customerId as the key.\\n3. Check if dat\", \"a is loaded from Redis; if not, return null .\\n4. Deserialize the data from Redis to a CustomerBasket\", \" object and return the result.\\n\\n```\\nservices.AddSingleton<ConnectionMultiplexer>(sp => { var setting\", \"s = spGetRequiredService<IOptions<BasketSettings>>().Value; var configuration = ConfigurationOptions\", \".Parse(settingsConnectionString, true ); configuration.ResolveDns = true ; return ConnectionMultiple\", \"xer.Connect(configuration); });\\n```\\n\\nIn the updated eShopOnDapr reference application, a new DaprBas\", \"ketRepository class replaces the RedisBasketRepository class:\\n\\n```\\npublic class DaprBasketRepository\", \" : IBasketRepository { private const string StoreName = \\\"eshop-statestore\\\"; private readonly DaprCli\", \"ent _daprClient; public DaprBasketRepository(DaprClient daprClient) { _daprClient = daprClient; } pu\", \"blic Task<CustomerBasket> GetBasketAsync(string customerId) => _daprClient.GetStateAsync<CustomerBas\", \"ket>(StoreName, customerId); // ... }\\n```\\n\\nThe updated code uses the Dapr .NET SDK to read and write\", \" data using the state management building block. The new steps to load the basket for a customer are\", \" dramatically simplified:\\n\\n1. Inject a DaprClient into the constructor. The DaprClient is registered\", \" with the dependency injection framework in the Program.cs `_ file.\\n2. Use the DaprClient.GetStateAs\", \"ync method to load the customer's shopping basket items from the configured state store and return t\", \"he result.\\n\\nThe updated implementation still uses Redis as the underlying data store. But, note how \", \"Dapr abstracts the StackExchange.Redis references and complexity from the application. The applicati\", \"on no longer requires a direct dependency on Redis. A Dapr configuration file is all that's needed:\\n\", \"\\nhttp\\n\\nBasket\\n\\nThe Dapr implementation also simplifies changing the underlying data store. Switching\", \" to Azure Table Storage, for example, requires only changing the contents of the configuration file.\", \" No code changes are necessary.\\n\\n## Service invocation\\n\\nThe original eShopOnContainers used a mix of\", \" HTTP/REST and gRPC services. The use of gRPC was limited to communication between an aggregator ser\", \"vice and core backend services. Figure 12-5 shows the original architecture:\\n\\nFigure 12-5. gRPC and \", \"HTTP/REST calls in eShopOnContainers.\\n\\nNote the steps from the previous figure:\\n\\n1. The frontend cal\", \"ls the API gateway using HTTP/REST.\\n\\nAPI Gateway\\n\\n(Envoy)\\n\\nhttp\\n\\nFrontend grpo\\n\\ndapr\\n\\nSidecar\\n\\n2. Th\", \"e API gateway forwards simple CRUD (Create, Read, Update, Delete) requests directly to a core backen\", \"d service using HTTP/REST. Sidecar Sidecar catalog\\n3. The API gateway forwards complex requests that\", \" involve coordinated backend service calls to the web shopping aggregator service. Sidecar - http \\u2192\\n\", \"4. The aggregator service uses gRPC to call core backend services.\\n\\nIn the updated eShopOnDapr imple\", \"mentation, Dapr sidecars are added to the services and API gateway. Figure 12-6 show the updated arc\", \"hitecture:\\n\\nFigure 12-6. Updated eShop architecture using Dapr.\\n\\nNote the updated steps from the pre\", \"vious figure:\\n\\n1. The frontend still uses HTTP/REST to call the API gateway.\\n2. The API gateway forw\", \"ards HTTP requests to its Dapr sidecar.\\n3. The API gateway sidecar sends the request to the sidecar \", \"of the aggregator or backend service.\\n4. The aggregator service uses the Dapr .NET SDK to call backe\", \"nd services through their sidecar architecture.\\n\\nDapr implements calls between sidecars with gRPC. S\", \"o even if you're invoking a remote service with HTTP/REST semantics, a part of the transport is impl\", \"emented using gRPC.\\n\\nThe eShopOnDapr reference application benefits from the Dapr service invocation\", \" building block. The benefits also include service discovery, automatic mTLS, and built-in observabi\", \"lity.\\n\\n## Forward HTTP requests using Envoy and Dapr\\n\\nBoth the original and updated eShop applicatio\", \"n leverage the Envoy proxy as an API gateway. Envoy is an open-source proxy and communication bus th\", \"at is popular across modern distributed applications. Originating from Lyft, Envoy is owned and main\", \"tained by the Cloud-Native Computing Foundation.\\n\\nhttp\\u2192\\n\\nBasket\\n\\nIn the original eShopOnContainers i\", \"mplementation, the Envoy API gateway forwarded incoming HTTP requests directly to aggregator or back\", \"end services. In the new eShopOnDapr, the Envoy proxy forwards the request to a Dapr sidecar.\\n\\nEnvoy\", \" is configured using a YAML definition file to control the proxy's behavior. To enable Envoy to forw\", \"ard HTTP requests to a Dapr sidecar container, a dapr cluster is added to the configuration. The clu\", \"ster configuration contains a host that points to the HTTP port on which the Dapr sidecar is listeni\", \"ng:\\n\\n```\\nclusters: -name: dapr connect_timeout: 0.25s type: strict_dns hosts: -socket_address: addre\", \"ss: 127.0.0.1 port_value: 3500\\n```\\n\\nThe Envoy route configuration is updated to rewrite incoming req\", \"uests as calls to the Dapr sidecar (pay close attention to the prefix_rewrite key/value pair):\\n\\n```\\n\", \"-name: \\\"c-short\\\" match: prefix: \\\"/c/\\\" route: auto_host_rewrite: true prefix_rewrite: \\\"/v1.0/invoke/c\", \"atalog-api/method/\\\" cluster: dapr\\n```\\n\\nConsider a scenario where the frontend client wants to retrie\", \"ve a list of catalog items. The Catalog API provides an endpoint for getting the catalog items:\\n\\n```\", \"\\n[Route(\\\"api/v1/[controller]\\\")] [ApiController] public class CatalogController : ControllerBase { [H\", \"ttpGet(\\\"items/by_page\\\")] [ProducesResponseType( typeof (PaginatedItemsViewModel), (int)HttpStatusCod\", \"e.OK)] public async Task<PaginatedItemsViewModel> ItemsAsync( [FromQuery] int typeId = -1, [FromQuer\", \"y] int brandId = -1, [FromQuery] int pageSize = 10, [FromQuery] int pageIndex = 0) { // ... }\\n```\\n\\nF\", \"irst, the frontend makes a direct HTTP call to the Envoy API gateway.\\n\\n```\\nGET http://<api-gateway>/\", \"c/api/v1/catalog/items\\n```\\n\\nThe Envoy proxy matches the route, rewrites the HTTP request, and forwar\", \"ds it to the invoke API of its Dapr sidecar:\\n\\n```\\nGET http://127.0.0.1:3500/v1.0/invoke/catalog-api/\", \"method/api/v1/catalog/items\\n```\\n\\nFrontend update basket\\n\\nAPI gateway\\n\\nWeb shopping update basket\\n\\nTh\", \"e sidecar handles service discovery and routes the request to the Catalog API sidecar. Finally, the \", \"sidecar calls the Catalog API to execute the request, fetch catalog items, and return a response:\\n\\nG\", \"ET http://localhost/api/v1/catalog/items save basket\\n\\n## Make aggregated service calls using the .NE\", \"T SDK\\n\\nMost calls from the eShop frontend are simple CRUD calls. The API gateway forwards them to a \", \"single service for processing. Some scenarios, however, require multiple backend services to work to\", \"gether to complete a request. For the more complex calls, the web shopping aggregator service mediat\", \"es the cross service workflow. Figure 12-7 show the processing sequence of adding an item to your sh\", \"opping basket:\\n\\nFigure 12-7. Backend call requiring multiple services.\\n\\nThe aggregator service first\", \" retrieves catalog items from the Catalog API. It then validates item availability and pricing. Fina\", \"lly, the aggregator service updates the shopping basket by calling the Basket API.\\n\\nThe aggregator s\", \"ervice contains a BasketController that provides an endpoint for updating the shopping basket:\\n\\n```\\n\", \"[Route(\\\"api/v1/[controller]\\\")] [Authorize] [ApiController] public class BasketController : Controlle\", \"rBase { private readonly ICatalogService _catalog; private readonly IBasketService _basket; [HttpPos\", \"t] [HttpPut] [ProducesResponseType((int)HttpStatusCode.BadRequest)] [ProducesResponseType( typeof (B\", \"asketData), (int)HttpStatusCode.OK)] public async Task<ActionResult<BasketData>> UpdateAllBasketAsyn\", \"c( [FromBody] UpdateBasketRequest data, [FromHeader] string authorization) { BasketData basket;\\n```\\n\", \"\\naggregator\\n\\nCatalog API\\n\\nBasket API\\n\\n```\\nif (data.Items is null || !data.Items.Any()) { basket = ne\", \"w (); } else { // Get the item details from the catalog API. var catalogItems = await _catalog.GetCa\", \"talogItemsAsync( data.Items.Select(x => x.ProductId)); if (catalogItems == null ) { return BadReques\", \"t( \\\"Catalog items were not available for the specified items in the basket.\\\"); } // Check item avail\", \"ability and prices; store results in basket object. basket = CreateValidatedBasket(data.Items, catal\", \"ogItems); } // Save the updated shopping basket. await _basket.UpdateAsync(basket, authorization.Sub\", \"string(\\\"Bearer \\\".Length)); return basket; } // ... }\\n```\\n\\nThe UpdateAllBasketAsync method gets the A\", \"uthorization header of the incoming request using a FromHeader attribute. The Authorization header c\", \"ontains the access token that is needed to call protected backend services.\\n\\nAfter receiving a reque\", \"st to update the basket, the aggregator service calls the Catalog API to get the item details. The B\", \"asket controller uses an injected ICatalogService object to make that call and communicate with the \", \"Catalog API. The original implementation of the interface used gRPC to make the call. The updated im\", \"plementation uses Dapr service invocation with HttpClient support:\\n\\n```\\npublic class CatalogService \", \": ICatalogService { private readonly HttpClient _httpClient; public CatalogService(HttpClient httpCl\", \"ient) { _httpClient = httpClient; } public Task<IEnumerable<CatalogItem>> GetCatalogItemsAsync(IEnum\", \"erable<int> ids) { var requestUri = $\\\"api/v1/catalog/items/by_ids?ids={string.Join(\\\",\\\", ids)}\\\"; retu\", \"rn _httpClient.GetFromJsonAsync<IEnumerable<CatalogItem>>(requestUri); } // ... }\\n```\\n\\nNotice how no\", \" Dapr-specific code is required to make the service invocation call. All communication is done using\", \" the standard HttpClient object.\\n\\nThe Dapr HttpClient is configured for the CatalogService class on \", \"program startup:\\n\\n```\\nbuilder.Services.AddSingleton<ICatalogService, CatalogService>( _ => new Catal\", \"ogService(DaprClient.CreateInvokeHttpClient(\\\"catalog-api\\\")));\\n```\\n\\nThe other call made by the aggreg\", \"ator service is to the Basket API. It only allows authorized requests. The access token is passed al\", \"ong in an Authorization request header to ensure the call succeeds:\\n\\n```\\npublic class BasketService \", \": IBasketService { public Task UpdateAsync(BasketData currentBasket, string accessToken) { var reque\", \"st = new HttpRequestMessage(HttpMethod.Post, \\\"api/v1/basket\\\") { Content = JsonContent.Create(current\", \"Basket) }; request.Headers.Authorization = new AuthenticationHeaderValue(\\\"Bearer\\\", accessToken); var\", \" response = await _httpClient.SendAsync(request); response.EnsureSuccessStatusCode(); } // ... }\\n```\", \"\\n\\nIn this example too, only standard HttpClient functionality is used to call the service. This allo\", \"ws developers who are already familiar with HttpClient to reuse their existing skills. It even enabl\", \"es existing HttpClient code to use Dapr service invocation without making any changes.\\n\\n## Publish &\", \"amp; subscribe\\n\\nBoth eShopOnContainers and eShopOnDapr use the pub/sub pattern for communicating int\", \"egration events across microservices. Integration events include:\\n\\n- When a user checks-out a shoppi\", \"ng basket.\\n- When a payment for an order has succeeded.\\n- When the grace-period of a purchase has ex\", \"pired.\\n\\nNote Think of an Integration Event as an event that takes place across multiple services.\\n\\nE\", \"venting in eShopOnContainers is based on the following IEventBus interface:\\n\\n```\\npublic interface IE\", \"ventBus { void Publish(IntegrationEvent integrationEvent); void Subscribe<T, THandler>() where TEven\", \"t : IntegrationEvent where THandler : IIntegrationEventHandler<T>; }\\n```\\n\\nConcrete implementations o\", \"f this interface for both RabbitMQ and Azure Service Bus are found in eShopOnContainers. Each implem\", \"entation included a large amount of custom plumbing code that was complex to understand and difficul\", \"t to maintain.\\n\\nThe newer eShopOnDapr significantly simplifies pub/sub behavior by using Dapr. To st\", \"art, the IEventBus interface was reduced to a single method:\\n\\n```\\npublic interface IEventBus { Task \", \"PublishAsync(IntegrationEvent integrationEvent); }\\n```\\n\\n## Publish events\\n\\nIn eShopOnDapr, a single \", \"DaprEventBus implementation can support any Dapr-supported message broker. The following code block \", \"shows the simplified Publish method. Note how the PublishAsync method uses the Dapr client to publis\", \"h an event:\\n\\n```\\npublic class DaprEventBus : IEventBus { private const string DAPR_PUBSUB_NAME = \\\"pu\", \"bsub\\\"; private readonly DaprClient _dapr; private readonly ILogger _logger; public DaprEventBus(Dapr\", \"Client dapr, ILogger<DaprEventBus> logger) { _dapr = dapr; _logger = logger; } public async Task Pub\", \"lishAsync(IntegrationEvent integrationEvent) { var topicName = integrationEvent.GetType().Name; _log\", \"ger.LogInformation( \\\"Publishing event {@Event} to {PubsubName}.{TopicName}\\\", integrationEvent, DAPR_\", \"PUBSUB_NAME, topicName); // We need to make sure that we pass the concrete type to PublishEventAsync\", \", // which can be accomplished by casting the event to dynamic. This ensures // that all event field\", \"s are properly serialized. await _dapr.PublishEventAsync(DAPR_PUBSUB_NAME, topicName, (object)integr\", \"ationEvent); } }\\n```\\n\\nAs you can see in the code snippet, the topic name is derived from event type'\", \"s name. Because all eShop services use the IEventBus abstraction, retrofitting Dapr required absolut\", \"ely no change to the mainline application code.\\n\\n## Important\\n\\nThe Dapr SDK uses System.Text.Json to\", \" serialize/deserialize messages. However, System.Text.Json doesn't serialize properties of derived c\", \"lasses by default. In the eShop code, an event is sometimes explicitly declared as an IntegrationEve\", \"nt , the base class for integration events. This construct allows the concrete event type to be dete\", \"rmined dynamically at run time based on business logic. As a result, the event is serialized using t\", \"he type information of the base class and not the derived class. To force System.Text.Json to serial\", \"ize the properties of both the base and derived class, the code uses object as the generic type para\", \"meter. For more information, see the .NET documentation.\\n\\nWith Dapr, pub/sub infrastructure code is \", \"dramatically simplified . The application doesn't need to distinguish between message brokers. Dapr \", \"provides this abstraction for you. If needed, you can easily swap out message brokers or configure m\", \"ultiple message broker components with no code changes.\\n\\n## Subscribe to events\\n\\nThe earlier eShopOn\", \"Containers app contains SubscriptionManagers to handle the subscription implementation for each mess\", \"age broker. Each manager contains complex message broker-specific code for handling subscription eve\", \"nts. To receive events, each service has to explicitly register a handler for each event-type.\\n\\neSho\", \"pOnDapr streamlines the plumbing for event subscriptions by using Dapr ASP.NET Core integration. Eac\", \"h event is handled by an action method in a controller. A Topic attribute decorates the action metho\", \"d with the name of the corresponding topic. Here's a code snippet taken from the PaymentService :\\n\\n`\", \"``\\n[Route(\\\"api/v1/[controller]\\\")] [ApiController] public class IntegrationEventController : Controll\", \"erBase { private const string DAPR_PUBSUB_NAME = \\\"pubsub\\\"; [HttpPost(\\\"OrderStatusChangedToValidated\\\"\", \")] [Topic(DAPR_PUBSUB_NAME, nameof(OrderStatusChangedToValidatedIntegrationEvent))] public Task Hand\", \"leAsync( OrderStatusChangedToValidatedIntegrationEvent integrationEvent, [FromServices] OrderStatusC\", \"hangedToValidatedIntegrationEventHandler handler) => handler.Handle(integrationEvent); }\\n```\\n\\nIn the\", \" Topic attribute, the name of the .NET type of the event is used as the topic name. For handling the\", \" event, an event handler that already existed in the earlier eShopOnContainers code base is resolved\", \" using dependency injection and invoked. In the previous example, messages received from the OrderSt\", \"atusChangedToValidatedIntegrationEvent topic invoke the existing OrderStatusChangedToValidatedIntegr\", \"ationEventHandler event handler. Because Dapr implements the underlying plumbing for subscriptions a\", \"nd message brokers, a large amount of original code became obsolete and was removed from the code-ba\", \"se. Much of this code was complex to understand and challenging to maintain.\\n\\n## Use pub/sub compone\", \"nts\\n\\nWithin the eShopOnDapr repository, a deployment folder contains files for deploying the applica\", \"tion using different deployment modes: Docker Compose and Kubernetes . A dapr folder exists within e\", \"ach of these folders that holds a components folder. This folder holds a file eshop-pubsub.yaml . It\", \" specifies the Dapr pub/sub component that the application will use for pub/sub behavior. As you saw\", \" in the earlier code snippets, the name of the pub/sub component used is pubsub . Here's the content\", \" of the eshop-pubsub.yaml file in the deployment/compose/dapr/components folder:\\n\\n```\\napiVersion: da\", \"pr.io/v1alpha1 kind: Component metadata: name: pubsub namespace: eshop spec: type: pubsub.rabbitmq v\", \"ersion: v1 metadata: -name: host value: \\\"amqp://rabbitmq:5672\\\"\\n```\\n\\nThe configuration specifies Rabb\", \"itMQ as the underlying infrastructure. To change message brokers, you need only to configure a diffe\", \"rent message broker, such as NATS or Azure Service Bus and update the yaml file. With Dapr, there ar\", \"e no changes to your mainline service code when switching message brokers.\\n\\nYou can also easily use \", \"multiple message brokers in a single application. Many times a system will handle workloads with dif\", \"ferent characteristics. One event may occur 10 times a day, but another event occurs 5,000 times per\", \" second. You may benefit by partitioning messaging traffic to different message brokers. With Dapr, \", \"you can add multiple pub/sub component configurations, each with a different name.\\n\\n## Bindings\\n\\neSh\", \"opOnDapr uses the bindings building block for sending e-mails. When a user places an order, the appl\", \"ication sends an order confirmation e-mail using the SMTP output binding. You can find this binding \", \"in the eshop-email.yaml file in the components folder:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Compo\", \"nent metadata: name: sendmail namespace: eshop spec: type: bindings.smtp version: v1 metadata: -name\", \": host value: maildev -name: port value: 25 -name: user secretKeyRef: name: Smtp.User\\n```\\n\\n```\\nkey: \", \"Smtp.User -name: password secretKeyRef: name: Smtp.Password key: Smtp.Password -name: skipTLSVerify \", \"value: true auth: secretStore: eshop-secretstore scopes: -ordering-api\\n```\\n\\nDapr gets the username a\", \"nd password for connecting to the SMTP server from a secret reference. This approach keeps secrets o\", \"utside of the configuration file. To learn more about Dapr secrets, read the secrets building block \", \"chapter.\\n\\nThe binding configuration specifies a binding component that can be invoked using the /sen\", \"dmail endpoint on the Dapr sidecar. Here's a code snippet in which an email is sent whenever an orde\", \"r is started:\\n\\n```\\npublic Task Handle(OrderStartedDomainEvent notification, CancellationToken cancel\", \"lationToken) { var message = CreateEmailBody(notification); var metadata = new Dictionary<string, st\", \"ring> { [\\\"emailFrom\\\"] = \\\"eShopOn@dapr.io\\\", [\\\"emailTo\\\" = notification.UserName, [\\\"subject\\\"] = $\\\"Your \", \"eShopOnDapr order #{notification.Order.Id}\\\" }; return _daprClient.InvokeBindingAsync(\\\"sendmail\\\", \\\"cr\", \"eate\\\", message, metadata, cancellationToken); } public Task SendOrderConfirmationAsync(Order order) \", \"{ var message = CreateEmailBody(order); return _daprClient.InvokeBindingAsync( \\\"sendmail\\\", \\\"create\\\",\", \" CreateEmailBody(order), new Dictionary<string, string> { [\\\"emailFrom\\\"] = \\\"eshopondapr@example.com\\\",\", \" [\\\"emailTo\\\"] = order.BuyerEmail, [\\\"subject\\\"] = $\\\"Your eShopOnDapr Order #{order.OrderNumber}\\\" }); }\\n\", \"```\\n\\nAs you can see in this example, message contains the message body. The CreateEmailBody method s\", \"imply formats a string with the body text. The name of the binding to invoke is sendmail and the ope\", \"ration is create . The metadata specifies the email sender, recipient, and subject for the email mes\", \"sage. If these values are static, they can also be included in the metadata fields in the configurat\", \"ion file.\\n\\n## Actors\\n\\nIn the original eShopOnContainers solution, the Ordering service provides a gr\", \"eat example of how to use DDD design patterns in a .NET microservice. As the updated eShopOnDapr foc\", \"uses on Dapr, the Ordering service now uses the actors building block to implement its business logi\", \"c.\\n\\nThe ordering process consists of the following steps:\\n\\n1. The customer submits the order. There'\", \"s a grace period before any further processing occurs. During the grace period, the customer can can\", \"cel the order.\\n2. The system checks that there's available stock.\\n3. The system processes the paymen\", \"t.\\n4. The system ships the order.\\n\\nThe process is implemented using a single OrderingProcessActor ac\", \"tor type. Here's the interface for the actor:\\n\\n```\\npublic interface IOrderingProcessActor : IActor {\", \" Task SubmitAsync( string userId, string userName, string street, string city, string zipCode, strin\", \"g state, string country, CustomerBasket basket); Task NotifyStockConfirmedAsync(); Task NotifyStockR\", \"ejectedAsync(List<int> rejectedProductIds); Task NotifyPaymentSucceededAsync(); Task NotifyPaymentFa\", \"iledAsync(); Task<bool> CancelAsync(); Task<bool> ShipAsync(); Task<Order> GetOrderDetailsAsync(); }\", \"\\n```\\n\\nThe process is started when a customer checks out some products. Upon checkout, the Basket ser\", \"vice publishes a UserCheckoutAcceptedIntegrationEvent message using the Dapr pub/sub building block.\", \" The Ordering service handles the message in the OrderingProcessEventController class and calls the \", \"SubmitAsync method of the actor:\\n\\n```\\n[HttpPost(\\\"UserCheckoutAccepted\\\")] [Topic(DaprPubSubName, \\\"Use\", \"rCheckoutAcceptedIntegrationEvent\\\")] public async Task HandleAsync(UserCheckoutAcceptedIntegrationEv\", \"ent integrationEvent) { if (integrationEvent.RequestId != Guid.Empty) { var actorId = new ActorId(in\", \"tegrationEvent.RequestId.ToString()); var orderingProcess = _actorProxyFactory.CreateActorProxy<IOrd\", \"eringProcessActor>( actorId, nameof(OrderingProcessActor)); await orderingProcess.SubmitAsync(integr\", \"ationEvent.UserId, integrationEvent.UserName,\\n```\\n\\n```\\nintegrationEvent.Street, integrationEvent.Cit\", \"y, integrationEvent.ZipCode, integrationEvent.State, integrationEvent.Country, integrationEvent.Bask\", \"et); } else { _logger.LogWarning( \\\"Invalid IntegrationEvent - RequestId is missing - {@IntegrationEv\", \"ent}\\\", integrationEvent); } }\\n```\\n\\nIn the example above, the Ordering service first uses the origina\", \"l request ID from the UserCheckoutAcceptedIntegrationEvent message as the actor ID. The handler uses\", \" the ActorId to create an actor proxy and invokes the SubmitAsync method. The following snippet show\", \"s the implementation of the SubmitAsync method:\\n\\n```\\npublic async Task SubmitAsync( string buyerId, \", \"string buyerEmail, string street, string city, string state, string country, CustomerBasket basket) \", \"{ var orderState = new OrderState { OrderDate = DateTime.UtcNow, OrderStatus = OrderStatus.Submitted\", \", Description = \\\"Submitted\\\", Address = new OrderAddressState { Street = street, City = city, State =\", \" state, Country = country }, BuyerId = buyerId, BuyerEmail = buyerEmail, OrderItems = basket.Items .\", \"Select(item => new OrderItemState { ProductId = item.ProductId, ProductName = item.ProductName, Unit\", \"Price = item.UnitPrice, Units = item.Quantity, PictureFileName = item.PictureFileName }) .ToList() }\", \"; await StateManager.SetStateAsync(OrderDetailsStateName, orderState); await StateManager.SetStateAs\", \"ync(OrderStatusStateName, OrderStatus.Submitted); await RegisterReminderAsync( GracePeriodElapsedRem\", \"inder, null , TimeSpan.FromSeconds(_settings.Value.GracePeriodTime), TimeSpan.FromMilliseconds(-1));\", \"\\n```\\n\\n```\\nawait _eventBus.PublishAsync( new OrderStatusChangedToSubmittedIntegrationEvent( OrderId, \", \"OrderStatus.Submitted.Name, buyerId, buyerEmail)); }\\n```\\n\\nThere's a lot going on in the Submit metho\", \"d:\\n\\n1. The method takes the given arguments to create an OrderState object and saves it in the actor\", \" state.\\n2. The method saves the current status of the process ( OrderStatus.Submitted ) in the actor\", \" state.\\n3. The method registers a reminder to signal the end of the grace period. Order processing i\", \"s delayed until the end of the grace period to deal with customers changing their mind.\\n4. Lastly, t\", \"he method publishes an OrderStatusChangedToSubmittedIntegrationEvent to notify other services of the\", \" status change.\\n\\nWhen the reminder for the grace period ending fires, the actor runtime calls the Re\", \"ceiveReminderAsync method:\\n\\n```\\npublic Task ReceiveReminderAsync( string reminderName, byte[] state,\", \" TimeSpan dueTime, TimeSpan period) { return reminderName switch { GracePeriodElapsedReminder => OnG\", \"racePeriodElapsedAsync(), StockConfirmedReminder => OnStockConfirmedSimulatedWorkDoneAsync(), StockR\", \"ejectedReminder => OnStockRejectedSimulatedWorkDoneAsync( JsonConvert.DeserializeObject<List<int>>(E\", \"ncoding.UTF8.GetString(state))), PaymentSucceededReminder => OnPaymentSucceededSimulatedWorkDoneAsyn\", \"c(), PaymentFailedReminder => OnPaymentFailedSimulatedWorkDoneAsync(), _ => Task.CompletedTask }; }\\n\", \"```\\n\\nAs shown in the snippet above, the ReceiveReminderAsync method handles not just the grace perio\", \"d reminder. The actor also uses reminders to simulate background work and introduce some delays in t\", \"he ordering process. This makes the process easier to follow in the eShopOnDapr UI where notificatio\", \"ns are shown for each status update. The ReceiveReminderAsync method uses the reminder name to deter\", \"mine which method handles the reminder. The grace period reminder is handled by the OnGracePeriodEla\", \"psedAsync method:\\n\\n```\\npublic async Task OnGracePeriodElapsedAsync() { var statusChanged = await Try\", \"UpdateOrderStatusAsync( OrderStatus.Submitted, OrderStatus.AwaitingStockValidation); if (statusChang\", \"ed) { var order = await StateManager.GetStateAsync<Order>(OrderDetailsStateName); await _eventBus.Pu\", \"blishAsync( new OrderStatusChangedToAwaitingStockValidationIntegrationEvent( OrderId, OrderStatus.Aw\", \"aitingStockValidation.Name, \\\"Grace period elapsed; waiting for stock validation.\\\",\\n```\\n\\n```\\norder.Us\", \"erName, order.OrderItems .Select(orderItem => new OrderStockItem(orderItem.ProductId, orderItem.Unit\", \"s)))); } }\\n```\\n\\nThe OnGracePeriodElapsedAsync method first tries to update the order status to the n\", \"ew AwaitingStockValidation status. If that succeeds, it retrieves the order details from state and p\", \"ublishes an OrderStatusChangedToAwaitingStockValidationIntegrationEvent to inform other service of t\", \"he status change. For example, the Category service subscribes to this event to check the available \", \"stock.\\n\\nLet's look at the TryUpdateOrderStatusAsync method to see under which circumstances it may f\", \"ail to update the order status:\\n\\n```\\nprivate async Task<bool> TryUpdateOrderStatusAsync(OrderStatus \", \"expectedOrderStatus, OrderStatus newOrderStatus) { var orderStatus = await StateManager.TryGetStateA\", \"sync<OrderStatus>(OrderStatusStateName); if (!orderStatus.HasValue) { _logger.LogWarning( \\\"Order wit\", \"h Id: {OrderId} cannot be updated because it doesn't exist\\\", OrderId); return false ; } if (orderSta\", \"tus.Value.Id != expectedOrderStatus.Id) { _logger.LogWarning( \\\"Order with Id: {OrderId} is in status\", \" {Status} instead of expected status {ExpectedStatus}\\\", OrderId, orderStatus.Value.Name, expectedOrd\", \"erStatus.Name); return false ; } await StateManager.SetStateAsync(OrderStatusStateName, newOrderStat\", \"us); return true ; }\\n```\\n\\nFirst, the TryUpdateOrderStatusAsync method checks whether there even is a\", \" current order status. If there isn't, the order doesn't exist. This is a fail -safe that should not\", \" happen with normal application usage. Then, the method checks whether the current order status is t\", \"he status that we expected. Remember that the ordering process is driven by events using the Dapr pu\", \"b/sub building block. Event delivery uses at-least-once semantics, so a single message could be rece\", \"ived multiple times. The order status check ensures that even when the same message is received mult\", \"iple times, it is only processed once.\\n\\nThe other steps in the ordering process are all implemented \", \"in a very similar way to the grace period step. In the next sections, we'll look at some other aspec\", \"ts of the ordering process, namely cancellation and viewing order details.\\n\\n## Order cancellation\\n\\nC\", \"ustomers are allowed to cancel any order that has not been paid or shipped yet. The OrdersController\", \" class handles incoming order cancellations. It invokes the CancelAsync method on the OrderingProces\", \"sActor instance for the given order.\\n\\n```\\npublic async Task<bool> CancelAsync() { var orderStatus = \", \"await StateManager.TryGetStateAsync<OrderStatus>(OrderStatusStateName); if (!orderStatus.HasValue) {\", \" _logger.LogWarning( \\\"Order with Id: {OrderId} cannot be cancelled because it doesn't exist\\\", OrderI\", \"d); return false ; } if (orderStatus.Value.Id == OrderStatus.Paid.Id || orderStatus.Value.Id == Orde\", \"rStatus.Shipped.Id) { _logger.LogWarning( \\\"Order with Id: {OrderId} cannot be cancelled because it's\", \" in status {Status}\\\", OrderId, orderStatus.Value.Name); return false ; } await StateManager.SetState\", \"Async(OrderStatusStateName, OrderStatus.Cancelled); var order = await StateManager.GetStateAsync<Ord\", \"er>(OrderDetailsStateName); await _eventBus.PublishAsync( new OrderStatusChangedToCancelledIntegrati\", \"onEvent( OrderId, OrderStatus.Cancelled.Name, $\\\"The order was cancelled by buyer.\\\", order.UserName))\", \"; return true ; }\\n```\\n\\nThe CancelAsync method consists of the following steps:\\n\\n1. First, the method\", \" ensures that the order exists by retrieving the current order status.\\n2. If the order exists, the m\", \"ethod checks wheth er it's eligible for cancellation. Any order not in the Paid or Shipped state can\", \" be cancelled.\\n3. If the order can be cancelled, the order status is changed to Cancelled .\\n4. Lastl\", \"y, the order details are retrieved from state and used to publish an OrderStatusChangedToCancelledIn\", \"tegrationEvent to inform the other services.\\n\\nThe CancelAsync method is a great example of the usefu\", \"lness of the turn-based access model of actors. Nowhere in the method do we need to worry about mult\", \"iple threads running at the same time. Therefore, the method does not require any explicit locking m\", \"echanisms to be correct.\\n\\n## Order details\\n\\nCustomers can check the status and details of their orde\", \"r in the eShopOnDapr UI. They can also view a complete history of past orders. Directly querying act\", \"or instances for this information is a bad idea because of two reasons:\\n\\n1. Low-latency reads cannot\", \" be guaranteed because actor operations execute serially.\\n2. Querying across actors is inefficient b\", \"ecause each actor's state needs to be read individually and can introduce more unpredictable latenci\", \"es.\\n\\nTo fix this issue, eShopOnDapr uses a separate read model for any queries on order data. The re\", \"ad model is stored in a separate SQL database. An ASP.NET Core controller class named UpdateOrderSta\", \"tusEventController subscribes to the order status events and builds up the view model. The same Upda\", \"teOrderStatusEventController class also sends push notifications to the UI to inform the customer of\", \" order status updates.\\n\\nThe following snippet shows the code for handling the OrderStatusChangedToSu\", \"bmittedIntegrationEvent message:\\n\\n```\\n[HttpPost(\\\"OrderStatusChangedToSubmitted\\\")] [Topic(DaprPubSubN\", \"ame, nameof(OrderStatusChangedToSubmittedIntegrationEvent))] public async Task HandleAsync( OrderSta\", \"tusChangedToSubmittedIntegrationEvent integrationEvent, [FromServices] IOptions<OrderingSettings> se\", \"ttings, [FromServices] IEmailService emailService) { // Gets the order details from Actor state. var\", \" actorId = new ActorId(integrationEvent.OrderId.ToString()); var orderingProcess = _actorProxyFactor\", \"y.CreateActorProxy<IOrderingProcessActor>( actorId, nameof(OrderingProcessActor)); // var actorOrder\", \" = await orderingProcess.GetOrderDetailsAsync(); var readModelOrder = new Order(integrationEvent.Ord\", \"erId, actorOrder); // Add the order to the read model so it can be queried from the API. // It may a\", \"lready exist if this event has been handled before (at-least-once semantics). readModelOrder = await\", \" _orderRepository.AddOrGetOrderAsync(readModelOrder); // Send a SignalR notification to the client. \", \"await SendNotificationAsync(readModelOrder.OrderNumber, integrationEvent.OrderStatus, integrationEve\", \"nt.BuyerId); // Send a confirmation e-mail if enabled. if (settings.Value.SendConfirmationEmail) { a\", \"wait emailService.SendOrderConfirmationAsync(readModelOrder); } }\\n```\\n\\nThe handler contains the code\", \" for all the actions that must occur after an order is submitted successfully. Because the events or\", \"iginate from the OrderingProcessActor , we can be sure that any validations performed by the actor h\", \"ave succeeded.\\n\\nThe handler performs the following steps:\\n\\n1. First, the method creates an actor pro\", \"xy and uses it to retrieve the order details from the actor instance.\\n2. The method maps the order d\", \"etails to the read model and stores it in the database. Due to the at-least-once semantics of the Da\", \"pr pub/sub building block, the order may already exist in the database. In that case, it will not be\", \" overwritten.\\n3. The method publishes a push notification for the status update using SignalR.\\n4. La\", \"stly, if enabled, the method sends a confirmation e-mail to the customer.\\n\\nSubsequent order status u\", \"pdates are all handled equally to each other. The following snippet shows what happens when the orde\", \"r status is updated to AwaitingStockValidation :\\n\\n```\\n[HttpPost(\\\"OrderStatusChangedToAwaitingStockVa\", \"lidation\\\")] [Topic(DaprPubSubName, nameof(OrderStatusChangedToAwaitingStockValidationIntegrationEven\", \"t))] public Task HandleAsync( OrderStatusChangedToAwaitingStockValidationIntegrationEvent integratio\", \"nEvent) { // Save the updated status in the read model and notify the client via SignalR. return Upd\", \"ateReadModelAndSendNotificationAsync(integrationEvent.OrderId, integrationEvent.OrderStatus, integra\", \"tionEvent.Description, integrationEvent.BuyerId); } private async Task UpdateReadModelAndSendNotific\", \"ationAsync( Guid orderId, string orderStatus, string description, string buyerId) { var order = awai\", \"t _orderRepository.GetOrderByIdAsync(orderId); if (order is not null ) { order.OrderStatus = orderSt\", \"atus; order.Description = description; await _orderRepository.UpdateOrderAsync(order); await SendNot\", \"ificationAsync(order.OrderNumber, orderStatus, buyerId); } }\\n```\\n\\nIn the snippet, the handler calls \", \"the UpdateReadModelAndSendNotificationAsync helper method to handle the status update:\\n\\n1. The helpe\", \"r method first loads the current order from the database.\\n2. If that succeeds, it updates the OrderS\", \"tatus and Description fields and saves the updated model back to the database.\\n3. Lastly, it sends a\", \" push notification to notify the client UI.\\n\\n## Observability\\n\\neShopOnDapr uses Zipkin to visualize \", \"distributed traces collected by Dapr. Seq aggregates the eShopOnDapr application logs. The various s\", \"ervices emit structured logging using the SeriLog logging library. Serilog publishes log events to a\", \" construct called a sink . A sink is simply a target platform to which Serilog writes its logging ev\", \"ents. Many Serilog sinks are available, including one for Seq. Seq is the Serilog sink used in eShop\", \"OnDapr.\\n\\neShopOnDapr also includes a custom health dashboard that gives insight into the health of t\", \"he eShop services. This dashboard uses the built-in health checks mechanism of ASP.NET Core. The das\", \"hboard not only provides the health status of the services, but also the health of the dependencies \", \"of the services, including the Dapr sidecars.\\n\\n## Secrets\\n\\nThe eShopOnDapr reference application use\", \"s the secrets building block for various secrets:\\n\\n- The password for connecting to the Redis cache.\", \"\\n- The username and password for the SMTP server.\\n- The connection strings for the SQL databases.\\n\\nW\", \"hen running the application using Docker Compose, the local file secret store is used. The component\", \" configuration file eshop-secretstore.yaml is found in the dapr/components folder of the eShopOnDapr\", \" repository:\\n\\n```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: eshop-secretstore nam\", \"espace: eshop spec: type: secretstores.local.file version: v1 metadata: -name: secretsFile value: ./\", \"components/eshop-secretstore.json -name: nestedSeparator value: \\\".\\\"\\n```\\n\\nThe configuration file refe\", \"rences the local store file eshop-secretstore.json located in the same folder:\\n\\n```\\n{ \\\"ConnectionStr\", \"ings\\\": { \\\"CatalogDB\\\": \\\"**********\\\", \\\"IdentityDB\\\": \\\"**********\\\", \\\"OrderingDB\\\": \\\"**********\\\" }, \\\"Smtp\\\"\", \": { \\\"User\\\": \\\"**********\\\", \\\"Password\\\": \\\"**********\\\" }, \\\"State\\\": { \\\"RedisPassword\\\": \\\"**********\\\" } }\\n`\", \"``\\n\\nThe components folder is specified in the command-line and mounted as a local folder inside the \", \"Dapr sidecar container. Here's a snippet from the docker-compose.override.yml file in the repository\", \" root that specifies the volume mount:\\n\\n```\\ncatalog-api-dapr: command: [ \\\"./daprd\\\" ,\\n```\\n\\n```\\n\\\"-app-\", \"id\\\" , \\\"catalog-api\\\" , \\\"-app-port\\\" , \\\"80\\\" , \\\"-components-path\\\" , \\\"/components\\\" , \\\"-config\\\" , \\\"/config\", \"uration/eshop-config.yaml\\\" ] volumes: -\\\"./dapr/components/:/components\\\" -\\\"./dapr/configuration/:/con\", \"figuration\\\"\\n```\\n\\nThe /components volume mount and --components-path command-line argument are passed\", \" into the daprd startup command.\\n\\nOnce configured, other component configuration files can also refe\", \"rence the secrets. Here's an example of the state store component configuration consuming secrets:\\n\\n\", \"```\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: eshop-statestore namespace: eshop s\", \"pec: type: state.redis version: v1 metadata: -name: redisHost value: redis:6379 -name: redisPassword\", \" secretKeyRef: name: State.RedisPassword key: State.RedisPassword -name: actorStateStore value: \\\"tru\", \"e\\\" auth: secretStore: eshop-secretstore scopes: -basket-api -ordering-api\\n```\\n\\n## Benefits of applyi\", \"ng Dapr to eShop\\n\\nIn general, the use of Dapr building blocks adds observability and flexibility to \", \"the application:\\n\\n1. Observability: By using the Dapr building blocks, you gain rich distributed tra\", \"cing for calls between services and to Dapr components without having to write any code. In eShopOnC\", \"ontainers, a large amount of custom logging is used to provide insight.\\n2. Flexibility: You can now \", \"swap out infrastructure simply by changing a component configuration file. No code changes are neces\", \"sary.\\n\\nHere are some more examples of benefits offered by specific building blocks:\\n\\n## \\u00b7 Service In\", \"vocation\\n\\n- -With Dapr's support for mTLS, services now communicate through encrypted channels.\\n- -W\", \"hen transient errors occur, service calls are automatically retried.\\n\\n- -Automatic service discovery\", \" reduces the amount of configuration needed for services to find each other.\\n- Publish/Subscribe\\n- -\", \"eShopOnContainers included a large amount of custom code to support both Azure Service Bus and Rabbi\", \"tMQ. Developers used Azure Service Bus for production and RabbitMQ for local development and testing\", \". An IEventBus abstraction layer was created to enable swapping between these message brokers. This \", \"layer consisted of approximately 700 lines of error-prone code . The updated implementation with Dap\", \"r requires only 35 lines of code . That's 5% of the original lines of code! More importantly, the im\", \"plementation is straightforward and easy to understand.\\n- -eShopOnDapr uses Dapr's rich ASP.NET Core\", \" integration to use pub/sub. You add Topic attributes to ASP.NET Core controller methods to subscrib\", \"e to messages. Therefore, there's no need to wr ite a separate message handler loop for each message\", \" broker.\\n- -Messages routed to the service as HTTP calls enable the use of ASP.NET Core middleware t\", \"o add functionality, without introducing new concepts or SDKs to learn.\\n- Bindings\\n- -The eShopOnCon\", \"tainers solution contained a to-do item for e-mailing an order confirmation to the customer. With Da\", \"pr, implementing email notification was as easy as configuring a resource binding.\\n- Actors\\n- -The a\", \"ctors building block makes it easy to create long running, stateful workflows. Thanks to the turnbas\", \"ed access model, there's no need for explicit locking mechanisms.\\n- -The complexity of the grace per\", \"iod implementation is greatly reduced by using actor reminders instead of polling on the database.\\n\\n\", \"## Summary\\n\\nIn this chapter, you're introduced to the eShopOnDapr reference application. It's an evo\", \"lution of the widely popular eShopOnContainers microservice reference application. eShopOnDapr repla\", \"ces a large amount of custom functionality with Dapr building blocks and components, dramatically si\", \"mplifying the complexities required to build a microservices application.\\n\\n## References\\n\\n- eShopOnD\", \"apr\\n- eShopOnContainers\\n- .NET Microservices for Containerized .NET Applications\\n- Architecting Clou\", \"d-Native .NET Apps for Azure\\n\\n## Summary and the road ahead\\n\\nWe're at the end of our Dapr flight. Th\", \"e jet plane flying at 20,000 feet from chapter 2 is on final approach and about to land.\\n\\nAs the pla\", \"ne taxis to the gate, let's take a minute to review some important conclusions from this guide:\\n\\n- D\", \"apr - Dapr is a Distributed Application Runtime that streamlines how you build distributed applicati\", \"ons. It exposes an architecture of building blocks and pluggable components. Dapr provides a dynamic\", \" glue that binds your application with infrastructure capabilities that exist in the Dapr runtime. I\", \"nstead of building infrastructure plumbing, you and your team focus on delivering business features \", \"to customers.\\n- Open source and cross-platform - The native Dapr API can be consumed by any platform\", \" that supports HTTP or gRPC. Dapr also provides language-specific SDKs for popular development platf\", \"orms. Dapr v1.0 supports Go, Python, .NET, Java, PHP, and JavaScript.\\n- Building blocks - Dapr build\", \"ing blocks encapsulate distributed application functionality. At the time of this writing, Dapr supp\", \"orts the seven building blocks shown in figure 13-1.\\n\\nState management\\n\\nPublish &amp;\\n\\nsubscribe\\n\\nBi\", \"ndings\\n\\nExtensibility\\n\\nFigure 13-1. Dapr building blocks.\\n\\n- Components - Dapr components provide th\", \"e concrete implementation for each Dapr building block capability. They expose a common interface th\", \"at enables developers to swap out component implementations without changing application code. Figur\", \"e 13-2 shows the relationship among components, building blocks, and your service.\\n\\nService invocati\", \"on\\n\\nDapr API\\n\\nSidecar\\n\\nDapr API\\n\\ndapr dapr\\n\\nComponent\\n\\n(Redis Cache)\\n\\nComponent\\n\\n(Redis Cache)\\n\\nHTTP\", \" /\\n\\ngRPC\\n\\nYour\\n\\nPrimary service service\\n\\nFigure 13-2. Dapr building block integration.\\n\\n- Sidecars -\", \" Dapr runs alongside your application in a sidecar architecture, either as a separate process of a c\", \"ontainer. Your application communicates with the Dapr APIs over HTTP and gRPC. Sidecars provide isol\", \"ation and encapsulation as they aren't part of the service, but connected to it. Figure 13-3 shows a\", \" sidecar architecture.\\n\\nFigure 13-3. Sidecar architecture.\\n\\n- Hosting environments Dapr has cross-pl\", \"atform support and can run in multiple environments. At the time of this writing, the environments i\", \"nclude a local self-hosted mode and Kubernetes.\\n- eShopOnDapr - This book includes an accompanying r\", \"eference application entitled eShopOnDapr. Using a popular e-commerce application domain, the refere\", \"nce application demonstrates the usage of each build ing block. It's an evolution of the widely popu\", \"lar eShopOnContainers, released several years ago.\\n\\n## The road ahead\\n\\nLooking forward, Dapr has the\", \" potential to have a profound impact on distributed application development. What can you expect fro\", \"m the Dapr team and its open-source contributors?\\n\\nAt the time of writing, the list of proposed enha\", \"ncements for Dapr include:\\n\\n- Feature enhancements to existing building blocks:\\n- -Query capabilitie\", \"s in state management enabling you to retrieve multiple values.\\n- -Topic filtering in pub/sub enabli\", \"ng you to filter topics based on their content.\\n- -An application tracing API in observability that \", \"provides tracing in the application directly without having to bind to specific libraries.\\n- -Bindin\", \"g and pub/sub support for actors providing event driven capabilities to the actor programming model.\", \" Bound components will trigger events and messages invoke methods in the actor.\\n- New building block\", \"s:\\n- -Configuration API building block for reading and writing configuration data. The block will bi\", \"nd to providers that include Azure Configuration Manager or GCP Configuration Management.\\n- -Http sc\", \"ale-to-zero autoscale.\\n- -Leader election building block to provide singleton instances and locking \", \"semantic capabilities.\\n- -Transparent proxying building block for service invocation, enabling you t\", \"o route messages based on URLs or DNS addresses at the network level.\\n- -Resiliency building block (\", \"circuit breakers, bulkheads &amp; timeouts).\\n- Integration with frameworks and cloud native technolo\", \"gies. Some examples include:\\n- -Django\\n- -Nodejs\\n- -Express\\n- -Kyma\\n- -Midway\\n- New language SDKs:\\n-\", \" -JavaScript\\n- -RUST\\n- -C++\\n\\n- New hosting platforms:\\n- -VMs\\n- -Azure IoT Edge\\n- -Azure Stack Edge\\n-\", \" -Azure Service Fabric\\n- Developer and operator productivity tooling:\\n- -VS Code extension.\\n- -Remot\", \"e Dev Containers for local debugging a DevOps pipeline development.\\n- -Dapr operational dashboard en\", \"hancements that will provide deeper visibility into the operational concerns of managing Dapr applic\", \"ations.\\n\\nDapr version 1.0 provides developers with a compelling toolbox for building distributed app\", \"lications. As the proposed enhancement list shows, Dapr is under active development with many new ca\", \"pabilities to come. Stay tuned to the Dapr site and Dapr announcement blog for future updates.\"]"