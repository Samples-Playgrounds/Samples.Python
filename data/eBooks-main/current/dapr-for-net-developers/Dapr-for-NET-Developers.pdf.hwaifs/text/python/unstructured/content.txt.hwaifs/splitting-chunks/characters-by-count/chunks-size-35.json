"[\"EDITION v1.2\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Azure Incubations teams\\n\\nA divis\", \"ion of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington 98052-6399\\n\\nCopyright \\u00a9 2023 by\", \" Microsoft Corporation\\n\\nAll rights reserved. No part of the contents of this book may be reproduced \", \"or transmitted in any form or by any means without the written permission of the publisher.\\n\\nThis bo\", \"ok is provided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions, and infor\", \"mation expressed in this book, including URL and other Internet website references, may change witho\", \"ut notice.\\n\\nSome examples depicted herein are provided for illustration only and are fictitious. No \", \"real association or connection is intended or should be inferred.\\n\\nMicrosoft and the trademarks list\", \"ed at https://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are trademarks of the Microsoft group of\", \" companies.\\n\\nMac and macOS are trademarks of Apple Inc.\\n\\nThe Docker whale logo is a registered trade\", \"mark of Docker, Inc. Used by permission.\\n\\nAll other marks and logos are property of their respective\", \" owners.\\n\\nAuthors:\\n\\nRob Vettor, Principal Cloud Solution Architect - thinkingincloudnative.com, Micr\", \"osoft\\n\\nSander Molenkamp, Principal Cloud Architect/Microsoft MVP - sandermolenkamp.com, Info Support\", \"\\n\\nEdwin van Wijk, Principal Solution Architect/Microsoft MVP - defaultconstructor.com, Info Support\\n\", \"\\nParticipants and Reviewers:\\n\\nMark Russinovich, Azure CTO and Technical Fellow, Azure Office of CTO,\", \" Microsoft\\n\\nNish Anil, Senior Program Manager, .NET team, Microsoft\\n\\nMark Fussell, Principal Program\", \" Manager, Azure Incubations, Microsoft\\n\\nYaron Schneider, Principal Software Engineer, Azure Incubati\", \"ons, Microsoft\\n\\nOri Zohar, Senior Program Manager, Azure Incubations, Microsoft\\n\\nEditors:\\n\\nDavid Pin\", \"e, Senior Content Developer, .NET team, Microsoft\\n\\nMaira Wenzel, Senior Program Manager, .NET team, \", \"Microsoft\\n\\nSteve \\u201cardalis\\u201d Smith, Senior Architect and Trainer, NimblePros\\n\\nVersion\\n\\nThis guide has \", \"been written to cover the Dapr 1.9 version. .NET samples are based on .NET 7.\\n\\nWho should use this g\", \"uide\\n\\nThe audience for this guide is mainly developers, development leads, and architects who are in\", \"terested in learning how to build applications designed for the cloud.\\n\\nA secondary audience is tech\", \"nical decision-makers who plan to choose whether to build their applications using a cloud-native ap\", \"proach.\\n\\nHow you can use this guide\\n\\nThis guide is available both in PDF form and online. Feel free \", \"to forward this document or links to its online version to your team to help ensure common understan\", \"ding of these topics. Most of these topics benefit from a consistent understanding of the underlying\", \" principles and patterns, as well as the trade-offs involved in decisions related to these topics. O\", \"ur goal with this document is to equip teams and their leaders with the information they need to mak\", \"e well-informed decisions for their applications\\u2019 architecture, development, and hosting.\\n\\nContents\\n\", \"\\nForeword - Dapr for .NET Developers ...............................................................\", \".................... 1\\n\\nThe world is distributed ...................................................\", \"....................................................... 3\\n\\nSummary .................................\", \"....................................................................................................\", \"................................................ 7\\n\\nDapr at 20,000 feet ............................\", \"..................................................................................... 8\\n\\nDapr and th\", \"e problem it solves ................................................................................\", \".......................................................... 8\\n\\nDapr architecture ....................\", \"....................................................................................................\", \"............................................. 9\\n\\nBuilding blocks ...................................\", \"....................................................................................................\", \".............................. 9\\n\\nComponents .......................................................\", \"....................................................................................................\", \"............ 11\\n\\nSidecar architecture ..............................................................\", \"........................................................................................... 13\\n\\nHost\", \"ing environments ...................................................................................\", \"................................................................. 14\\n\\nDapr performance consideration\", \"s ..................................................................................................\", \"............................... 15\\n\\nDapr and service meshes ........................................\", \"....................................................................................................\", \"....... 16\\n\\nSummary ................................................................................\", \".................................................................................................. 1\", \"8\\n\\nReferences ......................................................................................\", \"..................................................................................... 18\\n\\nGet starte\", \"d with Dapr ........................................................................................\", \"................... 19\\n\\nInstall Dapr into your local environment ...................................\", \".................................................................................. 19\\n\\nBuild your fi\", \"rst Dapr application ...............................................................................\", \"...................................................... 19\\n\\nCreate the application ..................\", \"....................................................................................................\", \".............................. 19\\n\\nAdd Dapr State Management .......................................\", \".............................................................................................. 20\\n\\nC\", \"omponent configuration files .......................................................................\", \"................................................................ 21\\n\\nBuild a multi-container Dapr ap\", \"plication ..........................................................................................\", \".......................... 23\\n\\nCreate the application ..............................................\", \"....................................................................................................\", \".. 23\\n\\nAdd Dapr service invocation .................................................................\", \"....................................................................... 27\\n\\nAdd container support ..\", \"....................................................................................................\", \"............................................. 29\\n\\nSummary ..........................................\", \"....................................................................................................\", \".................................... 35\\n\\nReferences ................................................\", \"....................................................................................................\", \"....................... 35\\n\\nTraffic Control sample application .....................................\", \"................................................. 36\\n\\nUsing Dapr building blocks....................\", \"....................................................................................................\", \"....................... 39\\n\\ni\\n\\nContents\\n\\nHosting ...................................................\", \"....................................................................................................\", \"............................... 40\\n\\nSelf-hosted mode ...............................................\", \"....................................................................................................\", \"......... 40\\n\\nKubernetes ...........................................................................\", \"............................................................................................... 41\\n\\n\", \"Summary ............................................................................................\", \"...................................................................................... 41\\n\\nReference\", \"s ..................................................................................................\", \"......................................................................... 41\\n\\nThe Dapr state managem\", \"ent building block ...................................................................... 42\\n\\nWhat i\", \"t solves ...........................................................................................\", \".............................................................................. 42\\n\\nHow it works ....\", \"....................................................................................................\", \"................................................................... 43\\n\\nConsistency ................\", \"....................................................................................................\", \"..................................................... 43\\n\\nConcurrency ..............................\", \"....................................................................................................\", \"..................................... 45\\n\\nTransactions .............................................\", \"....................................................................................................\", \"...................... 45\\n\\nUse the Dapr .NET SDK ...................................................\", \"....................................................................................................\", \" 46\\n\\nASP.NET Core integration ......................................................................\", \"....................................................................... 47\\n\\nState store components .\", \"....................................................................................................\", \"................................................ 47\\n\\nConfiguration .................................\", \"....................................................................................................\", \"................................ 48\\n\\nKey prefix strategies .........................................\", \"....................................................................................................\", \"........... 49\\n\\nSample application: Dapr Traffic Control ...........................................\", \"......................................................................... 50\\n\\nSummary ..............\", \"....................................................................................................\", \"................................................................ 51\\n\\nReferences ....................\", \"....................................................................................................\", \"................................................... 52\\n\\nThe Dapr service invocation building block .\", \"...................................................................... 53\\n\\nWhat it solves ..........\", \"....................................................................................................\", \"........................................................... 53\\n\\nHow it works .......................\", \"....................................................................................................\", \"................................................ 53\\n\\nUse the Dapr .NET SDK .........................\", \"....................................................................................................\", \".......................... 55\\n\\nInvoke HTTP services using HttpClient ...............................\", \"..................................................................................... 55\\n\\nInvoke HTT\", \"P services using DaprClient ........................................................................\", \"........................................... 57\\n\\nInvoke gRPC services using DaprClient ..............\", \"....................................................................................................\", \". 58\\n\\nName resolution components ...................................................................\", \"...................................................................... 58\\n\\nConfiguration ...........\", \"....................................................................................................\", \"...................................................... 58\\n\\nSample application: Dapr Traffic Control \", \"....................................................................................................\", \"................ 59\\n\\nSummary .......................................................................\", \"....................................................................................................\", \"....... 60\\n\\nReferences .............................................................................\", \".............................................................................................. 60\\n\\ni\", \"i\\n\\nContents\\n\\nThe Dapr publish & subscribe building block ...........................................\", \"......................... 61\\n\\nWhat it solves .......................................................\", \"....................................................................................................\", \".............. 61\\n\\nHow it works ....................................................................\", \"....................................................................................................\", \"... 62\\n\\nCompeting consumers ........................................................................\", \"........................................................................... 66\\n\\nUse the Dapr .NET SD\", \"K ..................................................................................................\", \"..................................................... 66\\n\\nPub/sub components .......................\", \"....................................................................................................\", \"............................... 68\\n\\nConfiguration ..................................................\", \"....................................................................................................\", \"............... 68\\n\\nSample application: Dapr Traffic Control .......................................\", \"............................................................................. 69\\n\\nSummary ..........\", \"....................................................................................................\", \".................................................................... 71\\n\\nReferences ................\", \"....................................................................................................\", \"....................................................... 71\\n\\nThe Dapr bindings building block .......\", \"................................................................................ 72\\n\\nWhat it solves \", \"....................................................................................................\", \"..................................................................... 72\\n\\nHow it works .............\", \"....................................................................................................\", \".......................................................... 73\\n\\nInput bindings ......................\", \"....................................................................................................\", \"......................................... 73\\n\\nOutput bindings ......................................\", \"....................................................................................................\", \"..................... 74\\n\\nUse the Dapr .NET SDK ....................................................\", \"................................................................................................... \", \"76\\n\\nBinding components .............................................................................\", \".............................................................................. 76\\n\\nCron binding ....\", \"....................................................................................................\", \".............................................................. 77\\n\\nSample application: Dapr Traffic \", \"Control ............................................................................................\", \"........................ 78\\n\\nMQTT input binding ....................................................\", \"....................................................................................................\", \" 79\\n\\nSMTP output binding ...........................................................................\", \".......................................................................... 81\\n\\nSummary .............\", \"....................................................................................................\", \"................................................................. 83\\n\\nReferences ...................\", \"....................................................................................................\", \".................................................... 83\\n\\nThe Dapr actors building block ............\", \"................................................................................ 84\\n\\nWhat it solves \", \"....................................................................................................\", \"..................................................................... 84\\n\\nHow it works .............\", \"....................................................................................................\", \".......................................................... 85\\n\\nTurn-based access model .............\", \"....................................................................................................\", \"............................ 88\\n\\nTimers and reminders ..............................................\", \"....................................................................................................\", \"... 89\\n\\nState persistence ..........................................................................\", \".................................................................................... 89\\n\\nUse the Dap\", \"r .NET SDK .........................................................................................\", \".............................................................. 90\\n\\nCall actors from ASP.NET Core cli\", \"ents ...............................................................................................\", \"...................... 93\\n\\niii\\n\\nContents\\n\\nCall non-.NET actors......................................\", \"....................................................................................................\", \".............. 94\\n\\nTimers and reminders ............................................................\", \"......................................................................................... 95\\n\\nSample\", \" application: Dapr Traffic Control .................................................................\", \"................................................... 97\\n\\nSummary ....................................\", \"....................................................................................................\", \".......................................... 98\\n\\nReferences ..........................................\", \"....................................................................................................\", \"............................. 99\\n\\nThe Dapr observability building block ............................\", \".................................................. 100\\n\\nWhat it solves .............................\", \"....................................................................................................\", \"...................................... 101\\n\\nHow it works ...........................................\", \"....................................................................................................\", \".......................... 101\\n\\nDistributed tracing ................................................\", \"....................................................................................................\", \"..... 102\\n\\nMetrics .................................................................................\", \"............................................................................................... 109\\n\", \"\\nLogging ...........................................................................................\", \"................................................................................... 111\\n\\nHealth stat\", \"us .................................................................................................\", \"................................................................... 113\\n\\nDapr dashboard ............\", \"....................................................................................................\", \".............................................. 114\\n\\nUse the Dapr .NET SDK ..........................\", \"....................................................................................................\", \"....................... 115\\n\\nSample application: Dapr Traffic Control ..............................\", \".................................................................................... 115\\n\\nSummary ..\", \"....................................................................................................\", \".......................................................................... 117\\n\\nReferences .........\", \"....................................................................................................\", \"................................................................ 118\\n\\nThe Dapr secrets management bu\", \"ilding block ................................................................ 119\\n\\nWhat it solves ..\", \"....................................................................................................\", \"................................................................. 119\\n\\nHow it works ................\", \"....................................................................................................\", \"..................................................... 120\\n\\nUse the Dapr .NET SDK ...................\", \"....................................................................................................\", \".............................. 121\\n\\nSecret store components ........................................\", \"....................................................................................................\", \"..... 122\\n\\nConfiguration ...........................................................................\", \"........................................................................................ 123\\n\\nIndire\", \"ctly consume Dapr secrets ..........................................................................\", \".................................................... 123\\n\\nLocal file ...............................\", \"....................................................................................................\", \".......................................... 124\\n\\nKubernetes secret ..................................\", \"....................................................................................................\", \".................... 126\\n\\nAzure Key Vault ..........................................................\", \"....................................................................................................\", \". 126\\n\\nScope secrets ...............................................................................\", \".................................................................................... 129\\n\\nSample app\", \"lication: Dapr Traffic Control .....................................................................\", \"............................................. 129\\n\\nSecrets .........................................\", \"....................................................................................................\", \"................................... 131\\n\\nSMTP server credentials ...................................\", \"....................................................................................................\", \"....... 132\\n\\nRedis server credentials ..............................................................\", \"................................................................................. 133\\n\\niv\\n\\nContents\\n\", \"\\nFineCalculator component license key ..............................................................\", \".................................................... 134\\n\\nSummary ..................................\", \"....................................................................................................\", \".......................................... 135\\n\\nReferences .........................................\", \"....................................................................................................\", \"................................ 135\\n\\nDapr reference application ...................................\", \".............................................................. 137\\n\\neShopOnContainers ..............\", \"....................................................................................................\", \"......................................... 137\\n\\neShopOnDapr .........................................\", \"....................................................................................................\", \".......................... 138\\n\\nApplication of Dapr building blocks.................................\", \"........................................................................................... 139\\n\\nSta\", \"te management ......................................................................................\", \".................................................................. 140\\n\\nService invocation .........\", \"....................................................................................................\", \"............................................. 142\\n\\nPublish & subscribe .............................\", \"....................................................................................................\", \"...................... 147\\n\\nBindings ...............................................................\", \"....................................................................................................\", \".......... 150\\n\\nActors .............................................................................\", \"....................................................................................................\", \". 152\\n\\nObservability ...............................................................................\", \"..................................................................................... 158\\n\\nSecrets .\", \"....................................................................................................\", \"........................................................................... 159\\n\\nBenefits of applyin\", \"g Dapr to eShop ....................................................................................\", \"........................................ 160\\n\\nSummary ..............................................\", \"....................................................................................................\", \".............................. 161\\n\\nReferences .....................................................\", \"....................................................................................................\", \"................ 161\\n\\nSummary and the road ahead ...................................................\", \"......................................... 162\\n\\nThe road ahead ......................................\", \"....................................................................................................\", \".......................... 165\\n\\nv\\n\\nContents\\n\\nCHAPTER 1\\n\\nForeword - Dapr for .NET Developers\\n\\nWith th\", \"e wave of cloud adoption underway, there is a major shift happening towards \\u201ccloud native\\u201d developme\", \"nt, often built with microservice-architectures. These microservices are both stateless and stateful\", \", and run on the cloud and edge, embracing the diversity of languages and frameworks available today\", \". This enterprise shift is driven by both the market forces of faster time to market, and the scale \", \"and efficiencies of building services for the cloud. Even before COVID-19, cloud adoption was accele\", \"rating for enterprises, and developers were being asked to do even more to deliver on building these\", \" distributed system applications. That has only accelerated since COVID-19. Developers in enterprise\", \"s seek to focus on business logic, while leaning on platforms to imbue their applications with scale\", \", resiliency, maintainability, elasticity, and the other attributes of cloud-native architectures, w\", \"hich is why there is also shift towards serverless platforms that hide the underlying infrastructure\", \". Developers should not be expected to become distributed systems experts. This is where Dapr steps \", \"in to help you, whether you are building on infrastructure such as Kubernetes, or on a serverless pl\", \"atform.\\n\\nDapr is designed as an enterprise, developer-focused, microservices programming model platf\", \"orm with the mantra \\u201cany language, any framework, run anywhere\\u201d. It makes building distributed appli\", \"cations easy and portable across any infrastructure, from public-cloud, through hierarchical edge, a\", \"nd even down to single node IoT devices. It emerged from both our experiences building services in A\", \"zure and time spent working with customers building applications on Azure Kubernetes Service and Azu\", \"re Service Fabric. Over and over, we saw common problems that they had to address. It became clear t\", \"hat there was a need to provide a \\u201clibrary\\u201d of common microservice best practices that developers co\", \"uld use, not only in new green field applications, but also to aid in the modernization of existing \", \"applications. In the containerized, distributed, and networked cloud native world, the sidecar model\", \" has emerged as the preferred approach, in the same way DLLs are preferred in the client/server gene\", \"ration. Using Dapr\\u2019s sidecar and APIs give you, as a developer, all the power of distributed systems\", \" functionality, with the ease of a single HTTP or gRPC local call.\\n\\nTo address the wide range of sce\", \"narios that developers face, Dapr provides features such as state management, service-to-service inv\", \"ocation, pub/sub, and integration to external systems with I/O bindings, which are based on the trig\", \"gers and bindings of Azure Functions. These in turn take advantage of Dapr\\u2019s component model, which \", \"allows you to \\u201cswap out\\u201d, say different underlying state stores, without having to change any code. \", \"This component model makes code more portable, more flexible, and allows for experimentation of what\", \" best suits your needs. Developers don\\u2019t need to learn\\n\\n1\\n\\nCHAPTER 1 | Foreword - Dapr for .NET Deve\", \"lopers\\n\\nand incorporate service SDKs into their code, or worry about authentication, secret manageme\", \"nt, retries, or conditional code that targets specific deployment environments.\\n\\nThis book shows how\", \" Dapr reduces your development time and overall code maintenance by incrementally \\u201cDaperizing\\u201d the c\", \"anonical .NET reference application, eShop. For example, in the original eShop implementation, signi\", \"ficant amounts of code were written to abstract between Azure Service Bus and RabbitMQ for publishin\", \"g events between services. All this code can be discarded and simply replaced with Dapr\\u2019s pub/sub AP\", \"I and component model, which had an even wider range of pub/sub brokers, rather than just two. Dapr\\u2019\", \"s actor model, when used in the reworked eShop application, shows the ease of building long running,\", \" stateful, event driven, workflow applications with all the difficulties of concurrency and multi-th\", \"reading removed. By the end of this book, you will see the drastic simplification that Dapr brings t\", \"o your application development, and I firmly believe all developers embarking on a cloud native app \", \"building journey should use Dapr.\\n\\nWe publicly announced Dapr with the v0.1 release in Oct 2019 and \", \"now, a year and half later, I am thrilled to say that Dapr is ready for production usage with the v1\", \".0 release. Getting Dapr to v1.0 has truly been a community effort. It has been amazing to see the o\", \"pen-source community coalesce around Dapr and grow since it was first announced \\u2013 from 114 contribut\", \"ors in October 2019 to over 700 in early 2021 - a six-fold increase in 16 months! Contributions to t\", \"he project have gone to every Dapr repo and have ranged from opening issues, commenting on feature p\", \"roposals, providing samples, and, of course, contributing code. The parts of the project community m\", \"embers have contributed to the most include the Dapr runtime, docs, CLI, SDKs, and the creation of a\", \" rich ecosystem of components. Maintaining this openness is critical to Dapr\\u2019s future.\\n\\nDapr is just\", \" getting started, though, and you should expect to see more Dapr capabilities and more support for D\", \"apr in Azure services. I hope that you will take advantage of Dapr to enable you to focus on your co\", \"re business logic and accelerate your microservices development. I am excited to have you join us in\", \" the Dapr community on this journey at https://github.com/dapr/ and on Discord https://aka.ms/dapr-d\", \"iscord.\\n\\nModern distributed systems are complex. You start with small, loosely coupled, independentl\", \"y deployable services. These services cross process and server boundaries. They then consume differe\", \"nt kinds of infrastructure backing services (databases, message brokers, key vaults). Finally, these\", \" disparate pieces compose together to form an application.\\n\\nMark Russinovich Azure CTO and Technical\", \" Fellow Microsoft\\n\\n2\\n\\nCHAPTER 1 | Foreword - Dapr for .NET Developers\\n\\nCHAPTER 2\\n\\nThe world is distr\", \"ibuted\\n\\nJust ask any \\u2018cool kid\\u2019: Modern, distributed systems are in, and monolithic apps are out!\\n\\nB\", \"ut, it\\u2019s not just \\u201ccool kids.\\u201d Progressive IT Leaders, corporate architects, and astute developers a\", \"re echoing these same thoughts as they explore and evaluate modern distributed applications. Many ha\", \"ve bought in. They\\u2019re designing new and replatforming existing enterprise applications following the\", \" principles, patterns, and practices of distributed microservice applications.\\n\\nBut, this evolution \", \"raises many questions\\u2026\\n\\nWhat exactly is a distributed application?\\n\\nWhy are they gaining popularity?\", \"\\n\\nWhat are the costs?\\n\\n\\n\\nAnd, importantly, what are the tradeoffs?\\n\\nTo start, let\\u2019s rewind and look \", \"at the past 15 years. During this period, we typically constructed applications as a single, monolit\", \"hic unit. Figure 1-1 shows the architecture.\\n\\nFigure 1-1. Monolithic architecture.\\n\\nNote how the mod\", \"ules for Ordering, Identity, and Marketing execute in a single-server process. Application data is s\", \"tored in a shared database. Business functionality is exposed via HTML and RESTful interfaces.\\n\\nIn m\", \"any ways, monolithic apps are straightforward. They\\u2019re straightforward to:\\n\\n\\n\\nBuild\\n\\n3\\n\\nCHAPTER 2 | \", \"The world is distributed\\n\\n\\n\\nTest\\n\\n\\n\\nDeploy\\n\\n\\n\\nTroubleshoot\\n\\n\\n\\nScale vertically (scale up)\\n\\nHowever, \", \"monolithic architectures can present significant challenges.\\n\\nOver time, you may reach a point where\", \" you begin to lose control\\u2026\\n\\n\\n\\nThe monolith has become so overwhelmingly complicated that no single \", \"person understands it.\\n\\n\\n\\nYou fear making changes as each brings unintended and costly side effects.\", \"\\n\\n\\n\\nNew features/fixes become time-consuming and expensive to implement.\\n\\n\\n\\nEven the smallest change\", \" requires full deployment of the entire application - expensive and risky.\\n\\n\\n\\nOne unstable component\", \" can crash the entire system.\\n\\n\\n\\nAdding new technologies and frameworks aren\\u2019t an option.\\n\\n\\n\\nImpleme\", \"nting agile delivery methodologies are difficult.\\n\\n\\n\\nArchitectural erosion sets in as the code base \", \"deteriorates with never-ending \\u201cspecial cases.\\u201d\\n\\n\\n\\nEventually the consultants come in and tell you t\", \"o rewrite it.\\n\\nIT practitioners call this condition the Fear Cycle. If you\\u2019ve been in the technology\", \" business for any length of time, good chance you\\u2019ve experienced it. It\\u2019s stressful and exhausts you\", \"r IT budget. Instead of building new and innovative solutions, most of your budget is spent maintain\", \"ing legacy apps.\\n\\nInstead of fear, businesses require speed and agility. They seek an architectural \", \"style with which they can rapidly respond to market conditions. They need to instantaneously update \", \"and individually scale small areas of a live application.\\n\\nAn early attempt to gain speed and agilit\", \"y came in the form of Service Oriented Architecture, or SOA. In this model, service consumers and se\", \"rvice providers collaborated via middleware messaging components, often referred to as an Enterprise\", \" Service Bus, or ESB. Figure 1-2 shows the architecture.\\n\\n4\\n\\nCHAPTER 2 | The world is distributed\\n\\nF\", \"igure 1-2. SOA architecture.\\n\\nWith SOA, centralized service providers registered with the ESB. Busin\", \"ess logic would be built into the ESB to integrate providers and consumers. Service consumers could \", \"then find and communicate with these providers using the ESB.\\n\\nDespite the promises of SOA, implemen\", \"ting this approach often increased complexity and introduced bottlenecks. Maintenance costs became h\", \"igh and ESB middleware expensive. Services tended to be large. They often shared dependencies and da\", \"ta storage. In the end, SOAs often resulted in a \\u2018distributed monolithic\\u2019 structure with centralized\", \" services that were resistant to change.\\n\\nNowadays, many organizations have realized speed and agili\", \"ty by adopting a distributed microservice architectural approach to building systems. Figure 1-3 sho\", \"ws the same system built using distributed techniques and practices.\\n\\n5\\n\\nCHAPTER 2 | The world is di\", \"stributed\\n\\nFigure 1-3. Distributed architecture.\\n\\nNote how the same application is decomposed across\", \" a set of distributed services. Each is self- contained and encapsulates its own code, data, and dep\", \"endencies. Each is deployed in a software container and managed by a container orchestrator. Instead\", \" of a single database shared by multiple services, each service owns a private database. Other servi\", \"ces can\\u2019t access this database directly and can only get to data that is exposed through the public \", \"API of the service that owns it. Note how some services require a full relational database, but othe\", \"rs, a NoSQL datastore. The basket service stores its state in a distributed key/value cache. Note ho\", \"w inbound traffic routes through an API Gateway service. It\\u2019s responsible for directing calls to ser\", \"vices and enforcing cross-cutting concerns. Most importantly, the application takes full advantage o\", \"f the scalability, availability, and resiliency features found in modern cloud platforms.\\n\\nBut, whil\", \"e distributed services can provide agility and speed, they present a different set of challenges. Co\", \"nsider the following\\u2026\\n\\n\\n\\nHow can distributed services discover each other and communicate synchronou\", \"sly?\\n\\n6\\n\\nCHAPTER 2 | The world is distributed\\n\\n\\n\\nHow can they implement asynchronous messaging?\\n\\n\\n\\nH\", \"ow can they maintain contextual information across a transaction?\\n\\n\\n\\nHow can they become resilient t\", \"o failure?\\n\\n\\n\\nHow can they scale to meet fluctuating demand?\\n\\n\\n\\nHow are they monitored and observed?\", \"\\n\\nFor each of these challenges, multiple products are often available. But, shielding your applicati\", \"on from product differences and keeping code maintainable and portable become a challenge.\\n\\nThis boo\", \"k introduces Dapr. Dapr is a distributed application runtime. It directly addresses many of the chal\", \"lenges found that come along with distributed applications. Looking ahead, Dapr has the potential to\", \" have a profound impact on distributed application development.\\n\\nSummary\\n\\nIn this chapter, we discus\", \"sed the adoption of distributed applications. We contrasted a monolithic system approach with that o\", \"f distributed services. We pointed out many of the common challenges when considering a distributed \", \"approach.\\n\\nNow, sit back, relax, and let us introduce you the new world of Dapr.\\n\\n7\\n\\nCHAPTER 2 | The\", \" world is distributed\\n\\nCHAPTER 3\\n\\nDapr at 20,000 feet\\n\\nIn chapter 1, we discussed the appeal of dist\", \"ributed microservice applications. But, we also pointed out that they dramatically increase architec\", \"tural and operational complexity. With that in mind, the question becomes, how can you \\u201chave your ca\", \"ke\\u201d and \\u201ceat it too?\\u201d. That is, how can you take advantage of the agility of distributed architectur\", \"e, and minimize its complexity?\\n\\nDapr, or Distributed Application Runtime, is a new way to build mod\", \"ern distributed applications.\\n\\nWhat started as a prototype has evolved into a highly successful open\", \"-source project. Its sponsor, Microsoft, has closely partnered with customers and the open-source co\", \"mmunity to design and build Dapr. The Dapr project brings together developers from all backgrounds t\", \"o solve some of the toughest challenges of developing distributed applications.\\n\\nThis book looks at \", \"Dapr from the viewpoint of a .NET developer. In this chapter, you\\u2019ll build a conceptual understandin\", \"g of Dapr and how it works. Later on, we present practical, hands-on instruction on how you can use \", \"Dapr in your applications.\\n\\nImagine flying in a jet at 20,000 feet. You look out the window and see \", \"the landscape below from a wide perspective. Let\\u2019s do the same for Dapr. Visualize yourself flying o\", \"ver Dapr at 20,000 feet. What would you see?\\n\\nDapr and the problem it solves\\n\\nDapr addresses a large\", \" challenge inherent in modern distributed applications: Complexity.\\n\\nThrough an architecture of plug\", \"gable components, Dapr greatly simplifies the plumbing behind distributed applications. It provides \", \"a dynamic glue that binds your application with infrastructure capabilities from the Dapr runtime.\\n\\n\", \"Consider a requirement to make one of your services stateful? What would be your design. You could w\", \"rite custom code that targets a state store such as Redis Cache. However, Dapr provides state manage\", \"ment capabilities out-of-the-box. Your service invokes the Dapr state management building block that\", \" dynamically binds to a state store component via a Dapr component configuration yaml file. Dapr shi\", \"ps with several pre-built state store components, including Redis. With this model, your service del\", \"egates state management to the Dapr runtime. Your service has no SDK, library, or direct reference t\", \"o the underlying component. You can even change state stores, say, from Redis to MySQL or Cassandra,\", \" with no code changes.\\n\\nFigure 2-1 shows Dapr from 20,000 feet.\\n\\n8\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\", \"\\nFigure 2-1. Dapr at 20,000 feet.\\n\\nIn the top row of the figure, note how Dapr provides language-spe\", \"cific SDKs for popular development platforms. Dapr v1.0 includes support for Go, Node.js, Python, .N\", \"ET, Java, and JavaScript. This book focuses on the Dapr .NET SDK, which also provides direct support\", \" for ASP.NET Core integration.\\n\\nWhile language-specific SDKs enhance the developer experience, Dapr \", \"is platform agnostic. Under the hood, Dapr\\u2019s programming model exposes capabilities through standard\", \" HTTP/gRPC communication protocols. Any programming platform can call Dapr via its native HTTP and g\", \"RPC APIs.\\n\\nThe blue boxes across the center of the figure represent the Dapr building blocks. Each e\", \"xposes a distributed application capability that your application can consume.\\n\\nThe bottom row highl\", \"ights the portability of Dapr and the diverse environments across which it can run.\\n\\nDapr architectu\", \"re\\n\\nAt this point, the jet turns around and flies back over Dapr, descending in altitude, giving you\", \" a closer look at how Dapr works.\\n\\nBuilding blocks\\n\\nFrom the new perspective, you see a more detaile\", \"d view of the Dapr building blocks.\\n\\nA building block encapsulates a distributed infrastructure capa\", \"bility. You can access the functionality through the HTTP or gRPC APIs. Figure 2-2 shows the availab\", \"le blocks for Dapr v 1.0.\\n\\n9\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\nFigure 2-2. Dapr building blocks.\\n\\nTh\", \"e following table describes the infrastructure services provided by each block.\\n\\nBuilding block\\n\\nDes\", \"cription\\n\\nState management Support contextual information for long running stateful services.\\n\\nServi\", \"ce invocation\\n\\nInvoke direct, secure service-to-service calls using platform agnostic protocols and \", \"well-known endpoints.\\n\\nPublish and subscribe\\n\\nImplement secure, scalable pub/sub messaging between s\", \"ervices.\\n\\n10\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\nBuilding block\\n\\nDescription\\n\\nBindings\\n\\nTrigger code f\", \"rom events raised by external resources with bi-directional communication.\\n\\nObservability\\n\\nMonitor a\", \"nd measure message calls across networked services.\\n\\nSecrets\\n\\nSecurely access external secret stores\", \".\\n\\nActors\\n\\nEncapsulate logic and data in reusable actor objects.\\n\\nBuilding blocks abstract the imple\", \"mentation of distributed application capabilities from your services. Figure 2-3 shows this interact\", \"ion.\\n\\nFigure 2-3. Dapr building block integration.\\n\\nBuilding blocks invoke Dapr components that prov\", \"ide the concrete implementation for each resource. The code for your service is only aware of the bu\", \"ilding block. It takes no dependencies on external SDKs or libraries - Dapr handles the plumbing for\", \" you. Each building block is independent. You can use one, some, or all of them in your application.\", \" As a value-add, Dapr building blocks bake in industry best practices including comprehensive observ\", \"ability.\\n\\nWe provide detailed explanation and code samples for each Dapr building block in the upcom\", \"ing chapters. At this point, the jet descends even more. From the new perspective, you now have a cl\", \"oser look at the Dapr components layer.\\n\\nComponents\\n\\nWhile building blocks expose an API to invoke d\", \"istributed application capabilities, Dapr components provide the concrete implementation to make it \", \"happen.\\n\\n11\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\nConsider, the Dapr state store component. It provides \", \"a uniform way to manage state for CRUD operations. Without any change to your service code, you coul\", \"d switch between any of the following Dapr state components:\\n\\n\\n\\nAWS DynamoDB\\n\\n\\n\\nAerospike\\n\\n\\n\\nAzure B\", \"lob Storage\\n\\n\\n\\nAzure CosmosDB\\n\\n\\n\\nAzure Table Storage\\n\\n\\n\\nCassandra\\n\\n\\n\\nCloud Firestore (Datastore mode\", \")\\n\\n\\n\\nCloudState\\n\\n\\n\\nCouchbase\\n\\n\\n\\nEtcd\\n\\n\\n\\nHashiCorp Consul\\n\\n\\n\\nHazelcast\\n\\nMemcached\\n\\nMongoDB\\n\\n\\n\\nPostgre\", \"SQL\\n\\n\\n\\nRedis\\n\\n\\n\\nRethinkDB\\n\\n\\n\\nSQL Server\\n\\n\\n\\nZookeeper\\n\\nEach component provides the necessary implemen\", \"tation through a common state management interface:\\n\\ntype Store interface { Init(metadata Metadata) \", \"error Delete(req *DeleteRequest) error BulkDelete(req []DeleteRequest) error Get(req *GetRequest) (*\", \"GetResponse, error) Set(req *SetRequest) error BulkSet(req []SetRequest) error }\\n\\nTip\\n\\nThe Dapr runt\", \"ime as well as all of the Dapr components have been written in the Golang, or Go, language. Go is a \", \"popular language across the open source community and attests to cross-platform commitment of Dapr.\\n\", \"\\nPerhaps you start with Azure Redis Cache as your state store. You specify it with the following con\", \"figuration:\\n\\n12\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n:::{custom-style=CodeBox} yaml apiVersion: dapr.io\", \"/v1alpha1 kind: Component metadata: name: statestore namespace: default spec: type: state.redis vers\", \"ion: v1 metadata: - name: redisHost value: <HOST> - name: redisPassword value: <PASSWORD> - name: en\", \"ableTLS value: <bool> # Optional. Allowed: true, false. - name: failover value: <bool> # Optional. A\", \"llowed: true, false. :::\\n\\nIn the spec section, you configure Dapr to use the Redis Cache for state m\", \"anagement. The section also contains component-specific metadata. In this case, you can use it to co\", \"nfigure additional Redis settings.\\n\\nAt a later time, the application is ready to go to production. F\", \"or the production environment, you may want to change your state management to Azure Table Storage. \", \"Azure Table Storage provides state management capabilities that are affordable and highly durable.\\n\\n\", \"At the time of this writing, the following component types are provided by Dapr:\\n\\nComponent\\n\\nDescrip\", \"tion\\n\\nService discovery\\n\\nUsed by the service invocation building block to integrate with the hosting\", \" environment to provide service-to-service discovery.\\n\\nState\\n\\nProvides a uniform interface to intera\", \"ct with a wide variety of state store implementations.\\n\\nPub/sub\\n\\nProvides a uniform interface to int\", \"eract with a wide variety of message bus implementations.\\n\\nBindings\\n\\nProvides a uniform interface to\", \" trigger application events from external systems and invoke external systems with optional data pay\", \"loads.\\n\\nMiddleware\\n\\nAllows custom middleware to plug into the request processing pipeline and invoke\", \" additional actions on a request or response.\\n\\nSecret stores\\n\\nProvides a uniform interface to intera\", \"ct with external secret stores, including cloud, edge, commercial, open-source services.\\n\\nAs the jet\", \" completes its fly over of Dapr, you look back once more and can see how it connects together.\\n\\nSide\", \"car architecture\\n\\nDapr exposes its building blocks and components through a sidecar architecture. A \", \"sidecar enables Dapr to run in a separate memory process or separate container alongside your servic\", \"e. Sidecars provide isolation and encapsulation as they aren\\u2019t part of the service, but connected to\", \" it. This separation enables each to have its own runtime environment and be built upon different pr\", \"ogramming platforms. Figure 2-4 shows a sidecar pattern.\\n\\n13\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\nFigur\", \"e 2-4. Sidecar architecture.\\n\\nThis pattern is named Sidecar because it resembles a sidecar attached \", \"to a motorcycle. In the previous figure, note how the Dapr sidecar is attached to your service to pr\", \"ovide distributed application capabilities.\\n\\nHosting environments\\n\\nDapr has cross-platform support a\", \"nd can run in many different environments. These environments include Kubernetes, a group of VMs, or\", \" edge environments such as Azure IoT Edge.\\n\\nFor local development, the easiest way to get started is\", \" with self-hosted mode. In self-hosted mode, the microservices and Dapr sidecars run in separate loc\", \"al processes without a container orchestrator such as Kubernetes. For more information, see download\", \" and install the Dapr CLI.\\n\\nFigure 2-5 shows an application and Dapr hosted in two separate memory p\", \"rocesses communicating via HTTP or gRPC.\\n\\n14\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\nFigure 2-5. Self-host\", \"ed Dapr sidecar.\\n\\nBy default, Dapr installs Docker containers for Redis and Zipkin to provide defaul\", \"t state management and observability. If you don\\u2019t want to install Docker on your local machine, you\", \" can even run Dapr in self-hosted mode without any Docker containers. However, you must install defa\", \"ult components such as Redis for state management and pub/sub manually.\\n\\nDapr also runs in container\", \"ized environments, such as Kubernetes. Figure 2-6 shows Dapr running in a separate side-car containe\", \"r along with the application container in the same Kubernetes pod.\\n\\nFigure 2-6. Kubernetes-hosted Da\", \"pr sidecar.\\n\\nDapr performance considerations\\n\\nAs you\\u2019ve seen, Dapr exposes a sidecar architecture to\", \" decouple your application from distributed application capabilities. Invoking a Dapr operation requ\", \"ires at least one out-of-process network call. Figure 2-7 presents an example of a Dapr traffic patt\", \"ern.\\n\\n15\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\nFigure 2-7. Dapr traffic patterns.\\n\\nLooking at the previo\", \"us figure, one might question the latency and overhead incurred for each call.\\n\\nThe Dapr team has in\", \"vested heavily in performance. A tremendous amount of engineering effort has gone into making Dapr e\", \"fficient. Calls between Dapr sidecars are always made with gRPC, which delivers high performance and\", \" small binary payloads. In most cases, the additional overhead should be sub-millisecond.\\n\\nTo increa\", \"se performance, developers can call the Dapr building blocks with gRPC.\\n\\ngRPC is a modern, high-perf\", \"ormance framework that evolves the age-old remote procedure call (RPC) protocol. gRPC uses HTTP/2 fo\", \"r its transport protocol, which provides significant performance enhancements over HTTP RESTFul serv\", \"ice, including:\\n\\nMultiplexing support for sending multiple parallel requests over the same connectio\", \"n - HTTP 1.1\\n\\nlimits processing to one request/response message at a time.\\n\\n\\n\\nBidirectional full-dup\", \"lex communication for sending both client requests and server responses simultaneously.\\n\\n\\n\\nBuilt-in \", \"streaming enabling requests and responses to asynchronously stream large data sets.\\n\\nTo learn more, \", \"check out the gRPC overview from the Architecting Cloud-Native .NET Apps for Azure eBook.\\n\\nDapr and \", \"service meshes\\n\\nService mesh is another rapidly evolving technology for distributed applications.\\n\\nA\", \" service mesh is a configurable infrastructure layer with built-in capabilities to handle service-to\", \"- service communication, resiliency, load balancing, and telemetry capture. It moves the responsibil\", \"ity for these concerns out of the services and into the service mesh layer. Like Dapr, a service mes\", \"h also follows a sidecar architecture.\\n\\nFigure 2-8 shows an application that implements service mesh\", \" technology.\\n\\n16\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\nFigure 2-8. Service mesh with a side car.\\n\\nThe pr\", \"evious figure shows how messages are intercepted by a sidecar proxy that runs alongside each service\", \". Each proxy can be configured with traffic rules specific to the service. It understands messages a\", \"nd can route them across your services and the outside world.\\n\\nSo the question becomes, \\u201cIs Dapr a s\", \"ervice mesh?\\u201d.\\n\\nWhile both use a sidecar architecture, each technology has a different purpose. Dapr\", \" provides distributed application features. A service mesh provides a dedicated network infrastructu\", \"re layer.\\n\\nAs each works at a different level, both can work together in the same application. For e\", \"xample, a service mesh could provide networking communication between services. Dapr could provide a\", \"pplication services such as state management or actor services.\\n\\nFigure 2-9 shows an application tha\", \"t implements both Dapr and service mesh technology.\\n\\n17\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\nFigure 2-9\", \". Dapr and service mesh together.\\n\\nThe Dapr online documentation cover Dapr and service mesh integra\", \"tion.\\n\\nSummary\\n\\nThis chapter introduced you to Dapr, a Distributed Application Runtime.\\n\\nDapr is an \", \"open-source project sponsored by Microsoft with close collaboration from customers and the open-sour\", \"ce community.\\n\\nAt its core, Dapr helps reduce the inherent complexity of distributed microservice ap\", \"plications. It\\u2019s built upon a concept of building block APIs. Dapr building blocks expose common dis\", \"tributed application capabilities, such as state management, service-to-service invocation, and pub/\", \"sub messaging. Dapr components lie beneath the building blocks and provide the concrete implementati\", \"on for each capability. Applications bind to various components through configuration files.\\n\\nIn the\", \" next chapters, we present practical, hands-on instruction on how to use Dapr in your applications.\\n\", \"\\nReferences\\n\\n\\n\\nDapr documentation\\n\\n\\n\\nLearning Dapr\\n\\n\\n\\n.NET Microservices: Architecture for Container\", \"ized .NET applications\\n\\n\\n\\nArchitecting Cloud-Native .NET Apps for Azure\\n\\n18\\n\\nCHAPTER 3 | Dapr at 20,\", \"000 feet\\n\\nCHAPTER 4\\n\\nGet started with Dapr\\n\\nIn the first two chapters, you learned basic concepts ab\", \"out Dapr. It\\u2019s time to take it for a test drive. This chapter will guide you through preparing your \", \"local development environment and building two Dapr .NET applications.\\n\\nInstall Dapr into your local\", \" environment\\n\\nYou\\u2019ll start by installing Dapr on your development computer. Once complete, you can b\", \"uild and run Dapr applications in self-hosted mode.\\n\\n1.\\n\\nInstall the Dapr CLI. It enables you to lau\", \"nch, run, and manage Dapr instances. It also provides debugging support.\\n\\n2.\\n\\nInstall Docker Desktop\", \". If you\\u2019re running on Windows, make sure that Docker Desktop for Windows is configured to use Linux\", \" containers.\\n\\n[!NOTE] By default, Dapr uses Docker containers to provide you the best out-of-the-box\", \" experience. To run Dapr outside of Docker, you can skip this step and execute a slim initialization\", \". The examples in this chapter require you use Docker containers.\\n\\n3.\\n\\nInitialize Dapr. This step se\", \"ts up your development environment by installing the latest Dapr binaries and container images.\\n\\n4.\\n\", \"\\nInstall the .NET 7 SDK.\\n\\nNow that Dapr is installed, it\\u2019s time to build your first Dapr application\", \"!\\n\\nBuild your first Dapr application\\n\\nYou\\u2019ll start by building a simple .NET Console application tha\", \"t consumes the Dapr state management building block.\\n\\nCreate the application\\n\\n1. Open up the command\", \" shell or terminal of your choice. You might consider the terminal\\n\\ncapabilities in Visual Studio Co\", \"de. Navigate to the root folder in which you want to build your application. Once there, enter the f\", \"ollowing command to create a new .NET Console application:\\n\\ndotnet new console -o DaprCounter\\n\\nThe c\", \"ommand scaffolds a simple \\\"Hello World\\\" .NET application.\\n\\n19\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n1.\", \"\\n\\nThen, navigate into the new directory created by the previous command:\\n\\ncd DaprCounter\\n\\n1.\\n\\nRun th\", \"e newly created application using the dotnet run command. Doing so writes \\u201cHello World!\\u201d to the cons\", \"ole screen:\\n\\ndotnet run\\n\\nAdd Dapr State Management\\n\\nNext, you\\u2019ll use the Dapr state management build\", \"ing block to implement a stateful counter in the program.\\n\\nYou can invoke Dapr APIs across any devel\", \"opment platform using Dapr\\u2019s native support for HTTP and gRPC. However, .NET Developers will find th\", \"e Dapr .NET SDK more natural and intuitive. It provides a strongly typed .NET client to call the Dap\", \"r APIs. The .NET SDK also tightly integrates with ASP.NET Core.\\n\\n1.\\n\\nFrom the terminal window, add t\", \"he Dapr.Client NuGet package to your application:\\n\\ndotnet add package Dapr.Client\\n\\n1. Open the Progr\", \"am.cs file in your favorite editor and update its contents to the following code:\\n\\nusing Dapr.Client\", \" const string storeName = \\\"statestore\\\"; const string key = \\\"counter\\\" var daprClient = new DaprClient\", \"Builder().Build(); var counter = await daprClient.GetStateAsync<int>(storeName, key) while (true) { \", \"Console.WriteLine($\\\"Counter = {counter++}\\\") await daprClient.SaveStateAsync(storeName, key, counter)\", \"; await Task.Delay(1000); }\\n\\nThe updated code implements the following steps:\\n\\nFirst a new [`DaprCli\", \"ent`]{custom-style=Code} instance is instantiated. This class enables you to interact with the Dapr \", \"sidecar. - From the state store, [`DaprClient.GetStateAsync`]{custom-style=Code} fetches the value f\", \"or the [`counter`]{custom-style=Code} key. If the key doesn't exist, the default value for [`int`]{c\", \"ustom-style=Code} (which is [`0`]{custom-style=Code}) is returned. - The code then iterates, writing\", \" the [`counter`]{custom-style=Code} value to the console and saving an incremented value to the stat\", \"e store. 1. The Dapr CLI run command starts the application. It invokes the underlying Dapr runtime \", \"and enables both the application and Dapr sidecar to run together. If you omit the app-id, Dapr will\", \" generate a unique name for the application. The final segment of the command, dotnet run, instructs\", \" the Dapr runtime to run the .NET application.\\n\\n[!IMPORTANT] Care must be taken to always pass an ex\", \"plicit app-id parameter when consuming the state management building block. The block uses the appli\", \"cation id value as a prefix for its\\n\\n20\\n\\nCHAPTER 4 | Get started with Dapr\\n\\nstate key for each key/v\", \"alue pair. If the application id changes, you can no longer access the previously stored state.\\n\\nNow\", \" run the application with the following command:\\n\\ndapr run --app-id DaprCounter dotnet run\\n\\nTry stop\", \"ping and restarting the application. You'll see that the counter doesn't reset. Instead it continues\", \" from the previously saved state. The Dapr building block makes the application stateful.\\n\\nImportant\", \"\\n\\nIt\\u2019s important to understand your sample application communicates with a pre-configured state comp\", \"onent, but has no direct dependency on it. Dapr abstracts away the dependency. As you\\u2019ll shortly see\", \", the underlying state store component can be changed with a simple configuration update.\\n\\nYou might\", \" be wondering, where exactly is the state stored?\\n\\nComponent configuration files\\n\\nWhen you first ini\", \"tialized Dapr for your local environment, it automatically provisioned a Redis container. Dapr then \", \"configured the Redis container as the default state store component with a component configuration f\", \"ile, entitled statestore.yaml. Here\\u2019s a look at its contents:\\n\\napiVersion: dapr.io/v1alpha1 kind: Co\", \"mponent metadata: name: statestore spec: type: state.redis version: v1 metadata: - name: redisHost v\", \"alue: localhost:6379 - name: redisPassword value: \\\"\\\" - name: actorStateStore value: \\\"true\\\"\\n\\nNote\\n\\nDe\", \"fault component configuration files are stored in the $HOME/.dapr/components folder on Linux/macOS, \", \"and in the %USERPROFILE%\\\\.dapr\\\\components folder on Windows.\\n\\nNote the format of the previous compon\", \"ent configuration file:\\n\\n\\n\\nEach component has a name. In the sample above, the component is named st\", \"atestore. We used that name in our first code example to tell the Dapr sidecar which component to us\", \"e.\\n\\n\\n\\nEach component configuration file has a spec section. It contains a type field that specifies \", \"the component type. The version field specifies the component version. The metadata field\\n\\n21\\n\\nCHAPT\", \"ER 4 | Get started with Dapr\\n\\ncontains information that the component requires, such as connection d\", \"etails and other settings. The metadata values will vary for the different types of components.\\n\\nA D\", \"apr sidecar can consume any Dapr component configured in your application. But, what if you had an a\", \"rchitectural justification to limit the accessibility of a component? How could you restrict the Red\", \"is component to Dapr sidecars running only in a production environment?\\n\\nTo do so, you could define \", \"a namespace for the production environment. You might name it production. In self-hosted mode, you s\", \"pecify the namespace of a Dapr sidecar by setting the NAMESPACE environment variable. When configure\", \"d, the Dapr sidecar will only load the components that match the namespace. For Kubernetes deploymen\", \"ts, the Kubernetes namespace determines the components that are loaded. The following sample shows t\", \"he Redis component placed in a production namespace. Note the namespace declaration in the metadata \", \"element:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore namespace: product\", \"ion spec: type: state.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: re\", \"disPassword value: \\\"\\\" - name: actorStateStore value: \\\"true\\\"\\n\\nImportant\\n\\nA namespaced component is on\", \"ly accessible to applications running in the same namespace. If your Dapr application fails to load \", \"a component, make sure that the application namespace matches the component namespace. This can be e\", \"specially tricky in self-hosted mode where the application namespace is stored in a NAMESPACE enviro\", \"nment variable.\\n\\nIf needed, you could further restrict a component to a particular application. With\", \"in the production namespace, you may want to limit access of the Redis cache to only the DaprCounter\", \" application. You do so by specifying scopes in the component configuration. The following example s\", \"hows how to restrict access to the Redis statestore component to the application DaprCounter in the \", \"production namespace:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore names\", \"pace: production spec: type: state.redis version: v1 metadata: - name: redisHost\\n\\n22\\n\\nCHAPTER 4 | Ge\", \"t started with Dapr\\n\\nvalue: localhost:6379 - name: redisPassword value: \\\"\\\" - name: actorStateStore v\", \"alue: \\\"true\\\" scopes: - DaprCounter\\n\\nBuild a multi-container Dapr application\\n\\nIn the first example, \", \"you created a simple .NET console application that ran side-by-side with a Dapr sidecar. Modern dist\", \"ributed applications, however, often consist of many moving parts. They can simultaneously run indep\", \"endent microservices. These modern applications are typically containerized and require container or\", \"chestration tools such as Docker Compose or Kubernetes.\\n\\nIn the next example, you\\u2019ll create a multi-\", \"container application. You\\u2019ll also use the Dapr service invocation building block to communicate bet\", \"ween services. The solution will consist of a web application that retrieves weather forecasts from \", \"a web API. They will each run in a Docker container. You\\u2019ll use Docker Compose to run the container \", \"locally and enable debugging capabilities.\\n\\nMake sure you\\u2019ve configured your local environment for D\", \"apr and installed the .NET 7 Development Tools (instructions are available at the beginning of this \", \"chapter).\\n\\nAdditionally, you\\u2019ll need to complete this sample using Visual Studio 2022 with the ASP.N\", \"ET and web development workload installed.\\n\\nCreate the application\\n\\n1.\\n\\nIn Visual Studio 2022, creat\", \"e an ASP.NET Core Web App project:\\n\\n23\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n1. Name your project MyFr\", \"ontEnd and your solution DaprMultiContainer:\\n\\n24\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n1.\\n\\nIn the fina\", \"l dialog, keep the defaults. Don\\u2019t select Enable Docker Support. You\\u2019ll add Docker support later.\\n\\n2\", \"5\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n1.\\n\\nFor the backend, add an ASP.NET Core Web API project to th\", \"e same solution:\\n\\n26\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n1. Name the project MyBackEnd:\\n\\n1.\\n\\nBy defa\", \"ult, a Dapr sidecar relies on the network boundary to limit access to its public API. So, clear the \", \"checkbox for Configure for HTTPS:\\n\\n> [!IMPORTANT] > If you leave the **Configure for HTTPS** checkbo\", \"x checked, the generated ASP.NET Core API project includes middleware to redirect client requests to\", \" the HTTPS endpoint. This breaks communication between the Dapr sidecar and your application, unless\", \" you explicitly configure the use of HTTPS when running your Dapr application. To enable the Dapr si\", \"decar to communicate over HTTPS, include the [`--app- ssl`]{custom-style=Code} flag in the Dapr comm\", \"and to start the application. Also specify the HTTPS port using the [`--app-port`]{custom-style=Code\", \"} parameter. The remainder of this walkthrough uses plain HTTP communication between the sidecar and\", \" the application, and requires you to clear the **Configure for HTTPS** checkbox.\\n\\nAdd Dapr service \", \"invocation\\n\\nNow, you\\u2019ll configure communication between the services using Dapr service invocation b\", \"uilding block. You\\u2019ll enable the web app to retrieve weather forecasts from the web API. The service\", \" invocation building block features many benefits. It includes service discovery, automatic retries,\", \" message encryption (using mTLS), and improved observability. You\\u2019ll use the Dapr .NET SDK to invoke\", \" the service invocation API on the Dapr sidecar.\\n\\n27\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n1.\\n\\nIn Visu\", \"al Studio, open the Package Manager Console (Tools > NuGet Package Manager > Package Manager Console\", \") and make sure that MyFrontEnd is the default project. From the console, add the Dapr.AspNetCore Nu\", \"Get package to the project:\\n\\nInstall-Package Dapr.AspNetCore\\n\\n1.\\n\\nIn the MyFrontEnd project, open th\", \"e Program.cs file and add a call to builder.Services.AddDaprClient:\\n\\nvar builder = WebApplication.Cr\", \"eateBuilder(args) // Add services to the container. builder.Services.AddDaprClient(); builder.Servic\", \"es.AddRazorPages() // ...\\n\\nThe [`AddDaprClient`]{custom-style=Code} call registers the [`DaprClient`\", \"]{custom- style=Code} class with the ASP.NET Core dependency injection system. With the client regis\", \"tered, you can now inject an instance of [`DaprClient`]{custom-style=Code} into your service code to\", \" communicate with the Dapr sidecar, building blocks, and components.\\n\\n1.\\n\\nAdd a new C# class file na\", \"med WeatherForecast to the MyFrontEnd project:\\n\\nnamespace MyFrontEnd public class WeatherForecast { \", \"public DateTime Date { get; set; public int TemperatureC { get; set; public int TemperatureF { get; \", \"set; public string Summary { get; set; } = string.Empty; }\\n\\n1. Open the Index.cshtml.cs file in the \", \"Pages folder, and replace its contents with the following\\n\\ncode:\\n\\nusing Dapr.Client; using Microsoft\", \".AspNetCore.Mvc.RazorPages namespace MyFrontEnd.Pages public class IndexModel : PageModel { private \", \"readonly DaprClient _daprClient public IndexModel(DaprClient daprClient) { _daprClient = daprClient;\", \"\\n\\npublic async Task OnGet() { var forecasts = await _daprClient.InvokeMethodAsync<IEnumerable<Weathe\", \"rForecast>>( HttpMethod.Get, \\\"MyBackEnd\\\", \\\"weatherforecast\\\") ViewData[\\\"WeatherForecastData\\\"] = forec\", \"asts; } }\\n\\nYou add Dapr capabilities into the web app by injecting the [`DaprClient`]{custom- style=\", \"Code} class into [`IndexModel`]{custom-style=Code} constructor. In the [`OnGet`]{custom-style=Code} \", \"method, you call the backend API service with the Dapr service invocation building block. The [`OnGe\", \"t`]{custom-style=Code} method is invoked\\n\\n28\\n\\nCHAPTER 4 | Get started with Dapr\\n\\nwhenever a user vis\", \"its the home page. You use the [`DaprClient.InvokeMethodAsync`]{custom-style=Code} method to invoke \", \"the [`weatherforecast`]{custom-style=Code} method of the [`MyBackEnd`]{custom-style=Code} service. Y\", \"ou'll configure the web API to use [`MyBackEnd`]{custom-style=Code} as its application ID later on w\", \"hen configuring it to run with Dapr. Finally, the service response is saved in view data.\\n\\n1.\\n\\nRepla\", \"ce the contents of the Index.cshtml file in the Pages folder, with the following code. It displays t\", \"he weather forecasts stored in the view data to the user:\\n\\n@page @model IndexModel @{ ViewData[\\\"Titl\", \"e\\\"] = \\\"Home page\\\";\\n\\n<div class=\\\"text-center\\\"> <h1 class=\\\"display-4\\\">Welcome</h1> <p>Learn about <a h\", \"ref=\\\"https://learn.microsoft.com/aspnet/core\\\">building Web apps with ASP.NECore</a>.</p> @foreach (v\", \"ar forecast in (IEnumerable<WeatherForecast>)ViewData[\\\"WeatherForecastData\\\"]!) { <p>The forecast for\", \" @forecast.Date is @forecast.Summary!</p> } </div>\\n\\nAdd container support\\n\\nIn the final part of this\", \" example, you\\u2019ll add container support and run the solution using Docker Compose.\\n\\n1.\\n\\nRight-click t\", \"he MyFrontEnd project, and choose Add > Container Orchestrator Support\\u2026. The Add Container Orchestra\", \"tor Support dialog appears:\\n\\nChoose **Docker Compose**.\\n\\n1.\\n\\nIn the next dialog, select Linux as the\", \" Target OS:\\n\\n29\\n\\nCHAPTER 4 | Get started with Dapr\\n\\nVisual Studio creates a *docker-compose.yml*file\", \" and a *.dockerignore* file in the **docker-compose** folder in the solution:\\n\\n30\\n\\nCHAPTER 4 | Get s\", \"tarted with Dapr\\n\\nThe *docker-compose.yml* file has the following content:\\n\\nversion: '3.4 services: \", \"myfrontend: image: ${DOCKER_REGISTRY-}myfrontend build: context: . dockerfile: MyFrontEnd/Dockerfile\", \"\\n\\nThe *.dockerignore* file contains file types and extensions that you don't want Docker to include \", \"in the container. These files are associated with the development environment and source control and\", \" not the app or service you're deploying.\\n\\n31\\n\\nCHAPTER 4 | Get started with Dapr\\n\\nIn the root of the\", \" *MyFrontEnd* project directory, a new *Dockerfile* was created. A *Dockerfile* is a sequence of com\", \"mands that are used to build an image. For more information, see [Dockerfile reference](https://docs\", \".docker.com/engine/reference/builder).\\n\\nThe *Dockerfile* contains the following commands:\\n\\nFROM mcr.\", \"microsoft.com/dotnet/aspnet:7.0 AS base WORKDIR /app EXPOSE 80 EXPOSE 44 FROM mcr.microsoft.com/dotn\", \"et/sdk:7.0 AS build WORKDIR /src COPY [\\\"MyFrontEnd/MyFrontEnd.csproj\\\", \\\"MyFrontEnd/\\\"] RUN dotnet res\", \"tore \\\"MyFrontEnd/MyFrontEnd.csproj\\\" COPY . . WORKDIR \\\"/src/MyFrontEnd\\\" RUN dotnet build \\\"MyFrontEnd.\", \"csproj\\\" -c Release -o /app/buil FROM build AS publish RUN dotnet publish \\\"MyFrontEnd.csproj\\\" -c Rele\", \"ase -o /app/publis FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\\\"d\", \"otnet\\\", \\\"MyFrontEnd.dll\\\"]\\n\\nThe preceding *Dockerfile* sequentially performs the following steps when\", \" invoked:\\n\\n1. Pulls the [`mcr.microsoft.com/dotnet/aspnet:7.0`]{custom-style=Code} image and names i\", \"t [`base`]{custom-style=Code}. 2. Sets the working directory to */app*. 3. Exposes port [`80`]{custo\", \"m-style=Code} and [`443`]{custom-style=Code}. 4. Pulls the [`mcr.microsoft.com/dotnet/sdk:7.0`]{cust\", \"om-style=Code} image and names it [`build`]{custom-style=Code}. 5. Sets the working directory to */s\", \"rc*. 6. Copies the _MyFrontEnd/MyFrontEnd.csproj_ to a new directory named *MyFrontEnd/*. 7. Calls [\", \"[`dotnet restore`]{custom-style=Code}](https://docs.microsoft.com/en- us/dotnet/core/tools/dotnet-re\", \"store) on the project. 8. Copies everything from the root directory into the image's root. 9. Sets t\", \"he working directory to _/src/MyFrontEnd_. 10. Calls [[`dotnet build`]{custom-style=Code}](https://d\", \"ocs.microsoft.com/en- us/dotnet/core/tools/dotnet-build) on the project. - Targeting the **Release**\", \" configuration and outputs to */app/build*. 11. Initializes a new build stage from the existing [`bu\", \"ild`]{custom-style=Code} base image and names it [`publish`]{custom-style=Code}. 12. Calls [`dotnet \", \"publish`]{custom-style=Code} on the project. - Targeting the **Release** configuration and outputs t\", \"o */app/publish*. 13. Initializes a new build stage from the existing [`publish`]{custom-style=Code}\", \" base image and names it [`final`]{custom-style=Code}. 14. Sets the working directory to */app*. 15.\", \" Copies the [`/app/publish`]{custom-style=Code} directory from the [`publish`]{custom-style=Code} im\", \"age into the root of the [`final`]{custom-style=Code} image. 16. Sets the entry point as the image t\", \"o [`dotnet`]{custom-style=Code} and passes the [`MyFrontEnd.dll`]{custom-style=Code} as an arg. 32\\n\\n\", \"CHAPTER 4 | Get started with Dapr\\n\\n1.\\n\\nIn the MyBackEnd web API project, right-click on the project \", \"node, and choose Add > Container Orchestrator Support\\u2026. Choose Docker Compose, and then select Linux\", \" again as the target OS.\\n\\nIn the root of the MyBackEnd project directory, a new Dockerfile was creat\", \"ed. The Dockerfile contains the following commands:\\n\\nFROM mcr.microsoft.com/dotnet/aspnet:7.0 AS bas\", \"e WORKDIR /app EXPOSE 8 FROM mcr.microsoft.com/dotnet/sdk:7.0 AS build WORKDIR /src COPY [\\\"MyBackEnd\", \"/MyBackEnd.csproj\\\", \\\"MyBackEnd/\\\"] RUN dotnet restore \\\"MyBackEnd/MyBackEnd.csproj\\\" COPY . . WORKDIR \\\"\", \"/src/MyBackEnd\\\" RUN dotnet build \\\"MyBackEnd.csproj\\\" -c Release -o /app/buil FROM build AS publish RU\", \"N dotnet publish \\\"MyBackEnd.csproj\\\" -c Release -o /app/publis FROM base AS final WORKDIR /app COPY -\", \"-from=publish /app/publish . ENTRYPOINT [\\\"dotnet\\\", \\\"MyBackEnd.dll\\\"]\\n\\nOpen the *docker-compose.yml* f\", \"ile again and examine its contents. Visual Studio has updated the **Docker Compose** file. Now both \", \"services are included:\\n\\nversion: '3.4 services: myfrontend: image: ${DOCKER_REGISTRY-}myfrontend bui\", \"ld: context: . dockerfile: MyFrontEnd/Dockerfil mybackend: image: ${DOCKER_REGISTRY-}mybackend build\", \": context: . dockerfile: MyBackEnd/Dockerfile\\n\\n1.\\n\\nTo use Dapr building blocks from inside a contain\", \"erized application, you\\u2019ll need to add the Dapr sidecars containers to your Compose file. Carefully \", \"update the content of the docker- compose.yml file to match the following example. Pay close attenti\", \"on to the formatting and spacing and don\\u2019t use tabs.\\n\\nversion: '3.4 services: myfrontend: image: ${D\", \"OCKER_REGISTRY-}myfrontend build: context: . dockerfile: MyFrontEnd/Dockerfile ports: - \\\"51000:50001\", \" myfrontend-dapr: image: \\\"daprio/daprd:latest\\\" command: [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyFrontEnd\\\", \\\"-app-\", \"port\\\", \\\"80\\\" ] depends_on:\\n\\n33\\n\\nCHAPTER 4 | Get started with Dapr\\n\\nmyfrontend network_mode: \\\"service:\", \"myfrontend mybackend: image: ${DOCKER_REGISTRY-}mybackend build: context: . dockerfile: MyBackEnd/Do\", \"ckerfile ports: - \\\"52000:50001 mybackend-dapr: image: \\\"daprio/daprd:latest\\\" command: [ \\\"./daprd\\\", \\\"-\", \"app-id\\\", \\\"MyBackEnd\\\", \\\"-app-port\\\", \\\"80\\\" ] depends_on: - mybackend network_mode: \\\"service:mybackend\\\"\\n\", \"\\nIn the updated file, we've added [`myfrontend-dapr`]{custom-style=Code} and [`mybackend-dapr`]{cust\", \"om-style=Code} sidecars for the [`myfrontend`]{custom- style=Code} and [`mybackend`]{custom-style=Co\", \"de} services respectively. In the updated file, pay close attention to the following changes:\\n\\nThe s\", \"idecars use the [`daprio/daprd:latest`]{custom-style=Code} container image. The use of the [`latest`\", \"]{custom-style=Code} tag isn't recommended for production scenarios. For production, it's better to \", \"use a specific version number. - Each service defined in the Compose file has its own network namesp\", \"ace for network isolation purposes. The sidecars use [`network_mode: \\\"service:...\\\"`]{custom- style=C\", \"ode} to ensure they run in the same network namespace as the application. Doing so allows the sideca\", \"r and the application to communicate using [`localhost`]{custom- style=Code}. - The ports on which t\", \"he Dapr sidecars are listening for gRPC communication (by default 50001) must be exposed to allow th\", \"e sidecars to communicate with each other. 1. Run the solution (F5 or Ctrl+F5) to verify that it wor\", \"ks as expected. If everything is configured correctly, you should see the weather forecast data:\\n\\n34\", \"\\n\\nCHAPTER 4 | Get started with Dapr\\n\\nRunning locally with Docker Compose and Visual Studio, you can \", \"set breakpoints and debug into the application. For production scenarios, it's recommended to host y\", \"our application in Kubernetes. This book includes an accompanying reference application, [eShopOnDap\", \"r](https://github.com/dotnet-architecture/eShopOnDapr), that contains scripts to deploy to Kubernete\", \"s.\\n\\nTo learn more about the Dapr service invocation building block used in this walkthrough, refer t\", \"o [chapter 6](#the-dapr-service-invocation-building-blo).\\n\\nSummary\\n\\nIn this chapter, you had an oppo\", \"rtunity to test drive Dapr. Using the Dapr .NET SDK, you saw how Dapr integrates with the .NET appli\", \"cation platform.\\n\\nThe first example was a simple, stateful, .NET Console application that used the D\", \"apr state management building block.\\n\\nThe second example involved a multi-container application runn\", \"ing in Docker. By using Visual Studio with Docker Compose, you experienced the familiar F5 debugging\", \" experience available across all .NET apps.\\n\\nYou also got a closer look at Dapr component configurat\", \"ion files. They configure the actual infrastructure implementation used by the Dapr building blocks.\", \" You can use namespaces and scopes to restrict component access to particular environments and appli\", \"cations.\\n\\nIn the upcoming chapters, you\\u2019ll dive deep into the building blocks offered by Dapr.\\n\\nRefe\", \"rences\\n\\n\\n\\nDapr documentation - Getting started\\n\\n\\n\\neShopOnDapr\\n\\n35\\n\\nCHAPTER 4 | Get started with Dapr\", \"\\n\\nCHAPTER 5\\n\\nTraffic Control sample application\\n\\nIn the first chapters, you\\u2019ve learned about basic D\", \"apr concepts. You saw how Dapr can help you and your team construct distributed applications while r\", \"educing architectural and operational complexity. This chapter introduces the sample application tha\", \"t you\\u2019ll use to explore the Dapr building blocks. The application targets .NET 7 and uses the latest\", \" C# 11 language features.\\n\\nNote\\n\\nDownload the sample application code from the Dapr Traffic Control \", \"GitHub repo. This repository contains a detailed description on how you can run the sample applicati\", \"on on your machine.\\n\\nThe Traffic Control sample application simulates a highway traffic control syst\", \"em. Its purpose is to detect speeding vehicles and send the offending driver a fine notice. These sy\", \"stems actually exist in real life and here\\u2019s how they work. A set of cameras (one above each lane) i\", \"s placed at the beginning and end of a highway stretch (say 10 kilometers) without on- or off-ramps.\", \" As a vehicle passes underneath a camera, it takes a photograph of the vehicle. Using Optical Charac\", \"ter Recognition (OCR) software, it extracts the license number of the vehicle from the photo. Using \", \"the entry- and exit- timestamp of each vehicle, the system calculates the average speed of that vehi\", \"cle. If the average speed is above the maximum speed limit for that highway stretch, the system retr\", \"ieves the driver information and automatically sends a fine notice.\\n\\nAlthough the simulation is simp\", \"le, responsibilities within the system are separated into several microservices. Figure 4.1 shows an\", \" overview of the services that are part of the application:\\n\\n36\\n\\nCHAPTER 5 | Traffic Control sample \", \"application\\n\\n37\\n\\nCHAPTER 5 | Traffic Control sample application\\n\\nFigure 4-1. The services in the sam\", \"ple application.\\n\\n\\n\\nThe Camera Simulation is a console application that simulates vehicles and sends\", \" messages to the TrafficControl service. Every simulated car invokes both the entry and exit service\", \" endpoints.\\n\\n\\n\\nThe TrafficControl service is an ASP.NET Core Web API application that exposes the /e\", \"ntrycam and /exitcam endpoints. Invoking an endpoint simulates a car passing under one of the entry-\", \" or exit-cameras respectively. The request message payload simply contains the license plate of the \", \"car (no actual OCR is implemented).\\n\\n\\n\\nThe FineCollection service is an ASP.NET Core Web API applica\", \"tion that offers 1 endpoint: /collectfine. Invoking this endpoint will send a fine notice to the dri\", \"ver of the speeding vehicle. The payload of the request contains all the information about the speed\", \"ing violation.\\n\\n\\n\\nThe VehicleRegistration service is an ASP.NET Core Web API application that offers\", \" 1 endpoint: /vehicleinfo/{licensenumber}. It\\u2019s used for obtaining vehicle- and owner-information fo\", \"r a speeding vehicle based on the license number sent in the URL (for example, /vehicleinfo/RV- 752-\", \"S).\\n\\nThe sequence diagram in figure 4.2 shows the simulation flow:\\n\\nFigure 4-2. Sequence diagram of \", \"the simulation flow.\\n\\nThe services communicate by directly invoking each other\\u2019s APIs. This design w\", \"orks fine, but it has some drawbacks.\\n\\n38\\n\\nCHAPTER 5 | Traffic Control sample application\\n\\nThe bigge\", \"st challenge is that the call-chain will break if one of the services is off-line. Decoupling servic\", \"es by replacing direct calls with asynchronous messaging would solve this issue. Asynchronous messag\", \"ing is typically implemented with a message broker like RabbitMQ or Azure Service Bus.\\n\\nAnother draw\", \"back is that the vehicle state for every vehicle is stored in memory in the TrafficControl service. \", \"This state is lost when the service is restarted after an update or a crash. To increase system dura\", \"bility, state should be stored outside the service.\\n\\nUsing Dapr building blocks\\n\\nOne of the goals of\", \" Dapr is to provide cloud-native capabilities for microservices applications. The Traffic Control ap\", \"plication uses Dapr building blocks to increase robustness and mitigate the design drawbacks describ\", \"ed in the previous paragraph. Figure 4.shows a Dapr-enabled version of the traffic control applicati\", \"on:\\n\\nFigure 4-3. Traffic Control application with Dapr building blocks.\\n\\n1.\\n\\nService invocation The \", \"Dapr service invocation building block handles request/response communication between the FineCollec\", \"tionService and the VehicleRegistrationService. Because the call is a query to retrieve required dat\", \"a to complete the operation, a synchronous call is acceptable here. The service invocation building \", \"block provides service discovery. The FineCollection service no longer has to know where the Vehicle\", \"Registration service lives. It also implements automatic retries if the VehicleRegistration service \", \"is off-line.\\n\\n2.\\n\\nPublish & subscribe The publish and subscribe building block handles asynchronous \", \"messaging for sending speeding violations from the TrafficControl service to the FineCollectionServi\", \"ce. This implementation decouples the TrafficControl and FineCollection service. If the FineCollecti\", \"onService were to become temporarily unavailable, data would accumulate in the queue and resume proc\", \"essing at a later time. RabbitMQ is the current message broker that transports messages from the pro\", \"ducers to the consumers. As the Dapr pub/sub building block abstracts the message broker, developers\", \" don\\u2019t need to learn the details of the RabbitMQ client library. Switching to another message broker\", \" doesn\\u2019t require code changes, only configuration.\\n\\n3.\\n\\nState management The TrafficControl service \", \"uses the state management building block to persist vehicle state outside of the service in a Redis \", \"cache. As with pub/sub, developers don\\u2019t need to learn Redis specific APIs. Switching to another dat\", \"a store requires no code changes.\\n\\n4. Output binding The FineCollection service sends fines to the o\", \"wners of speeding vehicles by\\n\\nemail. The Dapr output binding for SMTP abstracts the email transmiss\", \"ion using the SMTP protocol.\\n\\n5.\\n\\nInput binding The CameraSimulation sends messages with simulated c\", \"ar info to the TrafficControl service using the MQTT protocol. It uses a .NET MQTT library for sendi\", \"ng messages to Mosquitto - a lightweight MQTT broker. The TrafficControl service uses the Dapr input\", \" binding for MQTT to subscribe to the MQTT broker and receive messages.\\n\\n6.\\n\\nSecrets management The \", \"FineCollectionService needs credentials for connecting to the smtp server and a license-key for a fi\", \"ne calculator component it uses internally. It uses the secrets management building block to obtain \", \"the credentials and the license-key.\\n\\n39\\n\\nCHAPTER 5 | Traffic Control sample application\\n\\n7. Actors \", \"The TrafficControlService has an alternative implementation based on Dapr actors. In this implementa\", \"tion, the TrafficControl service creates a new actor for every vehicle that is registered by the ent\", \"ry camera. The license number of the vehicle forms the unique actor Id. The actor encapsulates the v\", \"ehicle state, which it persists in the Redis cache. When a vehicle is registered by the exit camera,\", \" it invokes the actor. The actor then calculate the average speed and possibly issue a speeding viol\", \"ation. Figure 4.4 shows a sequence diagram of the flow of the simulation with all the Dapr building \", \"blocks in place:\\n\\nFigure 4-4. Sequence diagram of simulation flow with Dapr building blocks.\\n\\nThe re\", \"st of this book features a chapter for each of the Dapr building blocks. Each chapter explains in de\", \"tail how the building block works, its configuration, and how to use it. Each chapter explains how t\", \"he Traffic Control sample application uses the building block.\\n\\nHosting\\n\\nThe Traffic Control sample \", \"application can run in self-hosted mode or in Kubernetes.\\n\\nSelf-hosted mode\\n\\nThe sample repository c\", \"ontains PowerShell scripts to start the infrastructure services (Redis, RabbitMQ, and Mosquitto) as \", \"Docker containers on your machine. They\\u2019re located in the src/Infrastructure folder. For every appli\", \"cation service in the solution, the repository contains a separate folder. Each of these folders con\", \"tains a start-selfhosted.ps1 PowerShell script to start the service with Dapr.\\n\\n40\\n\\nCHAPTER 5 | Traf\", \"fic Control sample application\\n\\nKubernetes\\n\\nThe src/k8s folder in the sample repository contains the\", \" Kubernetes manifest files to run the application (including the infrastructure services) with Dapr \", \"in Kubernetes. This folder also contains a start.ps1 and stop.ps1 PowerShell script to start and sto\", \"p the solution in Kubernetes. All services will run in the dapr-trafficcontrol namespace.\\n\\nSummary\\n\\n\", \"The Traffic Control sample application is a microservices application that simulates a highway speed\", \" trap.\\n\\nThe application uses several Dapr building blocks to make it robust and cloud-native. The do\", \"main is kept simple to keep the focus on Dapr.\\n\\nThe application will be used in the following chapte\", \"rs that focus on Dapr building block.\\n\\nReferences\\n\\n\\n\\nDapr Traffic Control Sample\\n\\n41\\n\\nCHAPTER 5 | Tr\", \"affic Control sample application\\n\\nCHAPTER 6\\n\\nThe Dapr state management building block\\n\\nDistributed a\", \"pplications are composed of independent services. While each service should be stateless, some servi\", \"ces must track state to complete business operations. Consider a shopping basket service for an e-Co\", \"mmerce site. If the service can\\u2019t track state, the customer could lose the shopping basket content b\", \"y leaving the website, resulting in a lost sale and an unhappy customer experience. For these scenar\", \"ios, state needs to be persisted to a distributed state store. The Dapr state management building bl\", \"ock simplifies state tracking and offers advanced features across various data stores.\\n\\nTo try out t\", \"he state management building block, have a look at the counter application sample in chapter 3.\\n\\nWha\", \"t it solves\\n\\nTracking state in a distributed application can be challenging. For example:\\n\\n\\n\\nThe app\", \"lication may require different types of data stores.\\n\\n\\n\\nDifferent consistency levels may be required\", \" for accessing and updating data.\\n\\nMultiple users may update data at the same time, requiring confli\", \"ct resolution.\\n\\n\\n\\nServices must retry any short-lived transient errors that occur while interacting \", \"with the data store.\\n\\nThe Dapr state management building block addresses these challenges. It stream\", \"lines tracking state without dependencies or a learning curve on third-party storage SDKs.\\n\\nImportan\", \"t\\n\\nDapr state management offers a key/value API. The feature doesn\\u2019t support relational or graph dat\", \"a storage.\\n\\n42\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\nHow it works\\n\\nThe application \", \"interacts with a Dapr sidecar to store and retrieve key/value data. Under the hood, the sidecar API \", \"consumes a configurable state store component to persist data. Developers can choose from a growing \", \"collection of supported state stores that include Azure Cosmos DB, SQL Server, and Cassandra.\\n\\nThe A\", \"PI can be called with either HTTP or gRPC. Use the following URL to call the HTTP API:\\n\\nhttp://local\", \"host:<dapr-port>/v1.0/state/<store-name>/\\n\\n\\n\\n<dapr-port>: the HTTP port that Dapr listens on.\\n\\n\\n\\n<st\", \"ore-name>: the name of the state store component to use.\\n\\nFigure 5-1 shows how a Dapr-enabled shoppi\", \"ng basket service stores a key/value pair using the Dapr state store component named statestore.\\n\\n::\", \":image type=\\u201ccontent\\u201d source=\\u201c./media/state-management/state-management-flow.png\\u201d alt- text=\\u201cDiagram\", \" of storing a key/value pair in a Dapr state store.\\u201d:::\\n\\nFigure 5-1. Storing a key/value pair in a D\", \"apr state store.\\n\\nNote the steps in the previous figure:\\n\\n1.\\n\\nThe basket service calls the state man\", \"agement API on the Dapr sidecar. The body of the request encloses a JSON array that can contain mult\", \"iple key/value pairs.\\n\\n2.\\n\\nThe Dapr sidecar determines the state store based on the component config\", \"uration file. In this case, it\\u2019s a Redis cache state store.\\n\\n3.\\n\\nThe sidecar persists the data to th\", \"e Redis cache.\\n\\nRetrieving the stored data is a similar API call. In the example below, a curl comma\", \"nd retrieves the data by calling the Dapr sidecar API:\\n\\ncurl http://localhost:3500/v1.0/state/states\", \"tore/basket1\\n\\nThe command returns the stored state in the response body:\\n\\n{ \\\"items\\\": [ { \\\"itemId\\\": \\\"\", \"DaprHoodie\\\", \\\"quantity\\\": 1 } ], \\\"customerId\\\": 1 }\\n\\nThe following sections explain how to use the mor\", \"e advanced features of the state management building block.\\n\\nConsistency\\n\\nThe CAP theorem is a set o\", \"f principles that apply to distributed systems that store state. Figure 5-2 shows the three properti\", \"es of the CAP theorem.\\n\\n43\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\n:::image type=\\u201ccon\", \"tent\\u201d source=\\u201c./media/state-management/cap-theorem.png\\u201d alt-text=\\u201cThe CAP theorem.\\u201d:::\\n\\nFigure 5-2. \", \"The CAP theorem.\\n\\nThe theorem states that distributed data systems offer a trade-off between consist\", \"ency, availability, and partition tolerance. And, that any datastore can only guarantee two of the t\", \"hree properties:\\n\\n\\n\\nConsistency (C). Every node in the cluster responds with the most recent data, e\", \"ven if the system must block the request until all replicas update. If you query a \\u201cconsistent syste\", \"m\\u201d for an item that is currently updating, you won\\u2019t get a response until all replicas successfully \", \"update. However, you\\u2019ll always receive the most current data.\\n\\n\\n\\nAvailability (A). Every node return\", \"s an immediate response, even if that response isn\\u2019t the most recent data. If you query an \\u201cavailabl\", \"e system\\u201d for an item that is updating, you\\u2019ll get the best possible answer the service can provide \", \"at that moment.\\n\\n\\n\\nPartition Tolerance (P). Guarantees the system continues to operate even if a rep\", \"licated data node fails or loses connectivity with other replicated data nodes.\\n\\nDistributed applica\", \"tions must handle the P property. As services communicate among each other with network calls, netwo\", \"rk disruptions (P) will occur. With that in mind, distributed applications must either be AP or CP.\\n\", \"\\nAP applications choose availability over consistency. Dapr supports this choice with its eventual c\", \"onsistency strategy. Consider an underlying data store, such as Azure CosmosDB, which stores redunda\", \"nt data on multiple replicas. With eventual consistency, the state store writes the update to one re\", \"plica and completes the write request with the client. After this time, the store will asynchronousl\", \"y update its replicas. Read requests can return data from any of the replicas, including those repli\", \"cas that haven\\u2019t yet received the latest update.\\n\\nCP applications choose consistency over availabili\", \"ty. Dapr supports this choice with its strong consistency strategy. In this scenario, the state stor\", \"e will synchronously update all (or, in some cases, a quorum of) required replicas before completing\", \" the write request. Read operations will return the most up-to-date data consistently across replica\", \"s.\\n\\nThe consistency level for a state operation is specified by attaching a consistency hint to the \", \"operation. The following curl command writes a Hello=World key/value pair to a state store using a s\", \"trong consistency hint:\\n\\ncurl -X POST http://localhost:3500/v1.0/state/<store-name> \\\\ -H \\\"Content-Ty\", \"pe: application/json\\\" \\\\ -d '[ { \\\"key\\\": \\\"Hello\\\", \\\"value\\\": \\\"World\\\", \\\"options\\\": { \\\"consistency\\\": \\\"stron\", \"g\\\" } } ]'\\n\\n44\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\nImportant\\n\\nIt is up to the Dapr\", \" state store component to fulfill the consistency hint attached to the operation. Not all data store\", \"s support both consistency levels. If no consistency hint is set, the default behavior is eventual.\\n\", \"\\nConcurrency\\n\\nIn a multi-user application, there\\u2019s a chance that multiple users will update the same\", \" data concurrently (at the same time). Dapr supports optimistic concurrency control (OCC) to manage \", \"conflicts. OCC is based on an assumption that update conflicts are uncommon because users work on di\", \"fferent parts of the data. It\\u2019s more efficient to assume an update will succeed and retry if it does\", \"n\\u2019t. The alternative, implementing pessimistic locking, can affect performance with long-running loc\", \"king causing data contention.\\n\\nDapr supports optimistic concurrency control (OCC) using ETags. An ET\", \"ag is a value associated with a specific version of a stored key/value pair. Each time a key/value p\", \"air updates, the ETag value updates as well. When a client retrieves a key/value pair, the response \", \"includes the current ETag value. When a client updates or deletes a key/value pair, it must send tha\", \"t ETag value back in the request body. If another client has updated the data in the meantime, the E\", \"Tags won\\u2019t match and the request will fail. At this point, the client must retrieve the updated data\", \", make the change again, and resubmit the update. This strategy is called first-write-wins.\\n\\nDapr al\", \"so supports a last-write-wins strategy. With this approach, the client doesn\\u2019t attach an ETag to the\", \" write request. The state store component will always allow the update, even if the underlying value\", \" has changed during the session. Last-write-wins is useful for high-throughput write scenarios with \", \"low data contention. As well, overwriting an occasional user update can be tolerated.\\n\\nTransactions\\n\", \"\\nDapr can write multi-item changes to a data store as a single operation implemented as a transactio\", \"n. This functionality is only available for data stores that support ACID transactions. At the time \", \"of this writing, these stores include Redis, MongoDB, PostgreSQL, SQL Server, and Azure CosmosDB.\\n\\nI\", \"n the example below, a multi-item operation is sent to the state store in a single transaction. All \", \"operations must succeed for the transaction to commit. If one or more of the operations fail, the en\", \"tire transaction rolls back.\\n\\ncurl -X POST http://localhost:3500/v1.0/state/<store-name>/transaction\", \" \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"operations\\\": [ { \\\"operation\\\": \\\"upsert\\\", \\\"request\\\": {\", \" \\\"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\" } }, { \\\"operation\\\": \\\"delete\\\", \\\"request\\\": { \\\"key\\\": \\\"Key2\\\" } }\\n\\n45\\n\\n\", \"CHAPTER 6 | The Dapr state management building block\\n\\n] }'\\n\\nFor data stores that don\\u2019t support trans\", \"actions, multiple keys can still be sent as a single request. The following example shows a bulk wri\", \"te operation:\\n\\ncurl -X POST http://localhost:3500/v1.0/state/<store-name> \\\\ -H \\\"Content-Type: applic\", \"ation/json\\\" \\\\ -d '[ { \\\"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\" }, { \\\"key\\\": \\\"Key2\\\", \\\"value\\\": \\\"Value2\\\" } ]'\\n\\nF\", \"or bulk operations, Dapr will submit each key/value pair update as a separate request to the data st\", \"ore.\\n\\nUse the Dapr .NET SDK\\n\\nThe Dapr .NET SDK provides language-specific support for the .NET platf\", \"orm. Developers can use the DaprClient class introduced in chapter 3 to read and write data. The fol\", \"lowing example shows how to use the DaprClient.GetStateAsync<TValue> method to read data from a stat\", \"e store. The method expects the store name, statestore, and key, AMS, as parameters:\\n\\nvar weatherFor\", \"ecast = await daprClient.GetStateAsync<WeatherForecast>(\\\"statestore\\\", \\\"AMS\\\");\\n\\nIf the state store co\", \"ntains no data for key AMS, the result will be default(WeatherForecast).\\n\\nTo write data to the data \", \"store, use the DaprClient.SaveStateAsync<TValue> method:\\n\\ndaprClient.SaveStateAsync(\\\"statestore\\\", \\\"A\", \"MS\\\", weatherForecast);\\n\\nThe example uses the last-write-wins strategy as an ETag value isn\\u2019t passed \", \"to the state store component. To use optimistic concurrency control (OCC) with a first-write-wins st\", \"rategy, first retrieve the current ETag using the DaprClient.GetStateAndETagAsync method. Then write\", \" the updated value and pass along the retrieved ETag using the DaprClient.TrySaveStateAsync method.\\n\", \"\\nvar (weatherForecast, etag) = await daprClient.GetStateAndETagAsync<WeatherForecast>(\\\"statestore\\\", \", \"city);\\n\\n// ... make some changes to the retrieved weather forecast\\n\\nvar result = await daprClient.Tr\", \"ySaveStateAsync(\\\"statestore\\\", city, weatherForecast, etag);\\n\\nThe DaprClient.TrySaveStateAsync method\", \" fails when the data (and associated ETag) has been changed in the state store after the data was re\", \"trieved. The method returns a boolean value to indicate whether the call succeeded. A strategy to ha\", \"ndle the failure is to simply reload the updated data from the state store, make the change again, a\", \"nd resubmit the update.\\n\\nIf you always want a write to succeed regardless of other changes to the da\", \"ta, use the last-write-wins strategy.\\n\\nThe SDK provides other methods to retrieve data in bulk, dele\", \"te data, and execute transactions. For more information, see the Dapr .NET SDK repository.\\n\\n46\\n\\nCHAP\", \"TER 6 | The Dapr state management building block\\n\\nASP.NET Core integration\\n\\nDapr also supports ASP.N\", \"ET Core, a cross-platform framework for building modern cloud-based web applications. The Dapr SDK i\", \"ntegrates state management capabilities directly into the ASP.NET Core model binding capabilities. C\", \"onfiguration is simple. In the Program.cs file, call the following extension method on the WebApplic\", \"ation builder:\\n\\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers().\", \"AddDapr();\\n\\nOnce configured, Dapr can inject a key/value pair directly into a controller action usin\", \"g the ASP.NET Core FromState attribute. Referencing the DaprClient object is no longer necessary. Th\", \"e next example shows a Web API that returns the weather forecast for a given city:\\n\\n[HttpGet(\\\"{city}\", \"\\\")] public ActionResult<WeatherForecast> Get([FromState(\\\"statestore\\\", \\\"city\\\")] StateEntry<WeatherFor\", \"ecast> forecast) { if (forecast.Value == null) { return NotFound(); }\\n\\nreturn forecast.Value; }\\n\\nIn \", \"the example, the controller loads the weather forecast using the FromState attribute. The first attr\", \"ibute parameter is the state store, statestore. The second attribute parameter, city, is the name of\", \" the route template variable to get the state key. If you omit the second parameter, the name of the\", \" bound method parameter (forecast) is used to look up the route template variable.\\n\\nThe StateEntry c\", \"lass contains properties for all the information that is retrieved for a single key/value pair: Stor\", \"eName, Key, Value, and ETag. The ETag is useful for implementing optimistic concurrency control (OCC\", \") strategy. The class also provides methods to delete or update retrieved key/value data without req\", \"uiring a DaprClient instance. In the next example, the TrySaveAsync method is used to update the ret\", \"rieved weather forecast using OCC.\\n\\n[HttpPut(\\\"{city}\\\")] public async Task Put(WeatherForecast update\", \"dForecast, [FromState(\\\"statestore\\\", \\\"city\\\")] StateEntry<WeatherForecast> currentForecast) { // updat\", \"e cached current forecast with updated forecast passed into service endpoint currentForecast.Value =\", \" updatedForecast;\\n\\n// update state store var success = await currentForecast.TrySaveAsync();\\n\\n// ...\", \" check result }\\n\\nState store components\\n\\nAt the time of this writing, Dapr provides support for the \", \"following transactional state stores:\\n\\n47\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\n\\n\\nA\", \"zure CosmosDB\\n\\n\\n\\nAzure SQL Server\\n\\n\\n\\nCockroachDB\\n\\n\\n\\nIn Memory\\n\\nMongoDB\\n\\nMySQL\\n\\n\\n\\nOracle Database\\n\\n\\n\\n\", \"PostgreSQL\\n\\n\\n\\nRedis\\n\\n\\n\\nRethinkDB\\n\\nDapr also includes support for state stores that support CRUD oper\", \"ations, but not transactional capabilities:\\n\\n\\n\\nAerospike\\n\\n\\n\\nApache Cassandra\\n\\n\\n\\nAWS DynamoDB\\n\\n\\n\\nAzur\", \"e Blob Storage\\n\\n\\n\\nAzure Table Storage\\n\\n\\n\\nCouchbase\\n\\n\\n\\nGCP Firestore\\n\\n\\n\\nHashicorp Consul\\n\\n\\n\\nHazelcast\", \"\\n\\n\\n\\nJetStream KV\\n\\nMemcached\\n\\n\\n\\nOracle Object Storage\\n\\n\\n\\nZookeeper\\n\\nConfiguration\\n\\nWhen initialized f\", \"or local, self-hosted development, Dapr registers Redis as the default state store. Here\\u2019s an exampl\", \"e of the default state store configuration. Note the default name, statestore:\\n\\napiVersion: dapr.io/\", \"v1alpha1 kind: Component metadata: name: statestore spec: type: state.redis version: v1 metadata: - \", \"name: redisHost value: localhost:6379 - name: redisPassword value: \\\"\\\" - name: actorStateStore value:\", \" \\\"true\\\"\\n\\n48\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\n[!NOTE] Many state stores can be \", \"registered to a single application each with a different name.\\n\\nThe Redis state store requires redis\", \"Host and redisPassword metadata to connect to the Redis instance. In the example above, the Redis pa\", \"ssword (which is an empty string by default) is stored as a plain string. The best practice is to av\", \"oid clear-text strings and always use secret references. To learn more about secret management, see \", \"chapter 10.\\n\\nThe other metadata field, actorStateStore, indicates whether the state store can be con\", \"sumed by the actors building block.\\n\\nKey prefix strategies\\n\\nState store components enable different \", \"strategies to store key/value pairs in the underlying store. Recall the earlier example of a shoppin\", \"g basket service storing items a customer wishes to purchase:\\n\\ncurl -X POST http://localhost:3500/v1\", \".0/state/statestore \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '[{ \\\"key\\\": \\\"basket1\\\", \\\"value\\\": { \\\"cus\", \"tomerId\\\": 1, \\\"items\\\": [ { \\\"itemId\\\": \\\"DaprHoodie\\\", \\\"quantity\\\": 1 } ] } }]'\\n\\nUsing the Redis Console t\", \"ool, look inside the Redis cache to see how the Redis state store component persisted the data:\\n\\n127\", \".0.0.1:6379> KEYS * 1) \\\"basketservice||basket1\\\"\\n\\n127.0.0.1:6379> HGETALL basketservice||basket1 1) \\\"\", \"data\\\" 2) \\\"{\\\\\\\"items\\\\\\\":[{\\\\\\\"itemId\\\\\\\":\\\\\\\"DaprHoodie\\\\\\\",\\\\\\\"quantity\\\\\\\":1}],\\\\\\\"customerId\\\\\\\":1}\\\" 3) \\\"version\\\" 4)\", \" \\\"1\\\"\\n\\nThe output shows the full Redis key for the data as basketservice||basket1. By default, Dapr u\", \"ses the application id of the Dapr instance (basketservice) as a prefix for the key. This naming con\", \"vention enables multiple Dapr instances to share the same data store without key name collisions. Fo\", \"r the developer, it\\u2019s critical always to specify the same application id when running the applicatio\", \"n with Dapr. If omitted, Dapr will generate a unique application ID. If the application id changes, \", \"the application can no longer access the state stored with the previous key prefix.\\n\\nThat said, it\\u2019s\", \" possible to configure a constant value for the key prefix in the keyPrefix metadata field in the st\", \"ate store component file. Consider the following example:\\n\\nspec: metadata: - name: keyPrefix - value\", \": MyPrefix\\n\\n49\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\nA constant key prefix enables \", \"the state store to be accessed across multiple Dapr applications. What\\u2019s more, setting the keyPrefix\", \" to none omits the prefix completely.\\n\\nSample application: Dapr Traffic Control\\n\\nIn the Dapr Traffic\", \" Control sample app, the TrafficControl service uses the Dapr state management building block to per\", \"sist the entry and exit timestamps of each passing vehicle. Figure 5-3 shows the conceptual architec\", \"ture of the Dapr Traffic Control sample application. The Dapr state management building block is use\", \"d in flows marked with number 3 in the diagram:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/state-manag\", \"ement/dapr-solution-state-management.png\\u201d alt-text=\\u201cConceptual architecture of the Dapr Traffic Cont\", \"rol sample application.\\u201d:::\\n\\nFigure 5-3. Conceptual architecture of the Dapr Traffic Control sample \", \"application.\\n\\nEntry and exit event logic is handled by the TrafficController class, an ordinary ASP.\", \"NET Controller. The TrafficController.VehicleEntry method accepts an incoming VehicleRegistered mess\", \"age and saves the enclosed vehicle state:\\n\\n// store vehicle state var vehicleState = new VehicleStat\", \"e { LicenseNumber = msg.LicenseNumber, EntryTimestamp = msg.Timestamp }; await _vehicleStateReposito\", \"ry.SaveVehicleStateAsync(vehicleState);\\n\\nIn the preceding code snippet, the abstraction _vehicleStat\", \"eRepository is responsible for saving state to the data store. Its concrete implementation, DaprVehi\", \"cleStateRepository, is shown below:\\n\\npublic class DaprVehicleStateRepository : IVehicleStateReposito\", \"ry { private const string DAPR_STORE_NAME = \\\"statestore\\\"; private readonly DaprClient _daprClient;\\n\\n\", \"public DaprVehicleStateRepository(DaprClient daprClient) { _daprClient = daprClient; }\\n\\npublic async\", \" Task SaveVehicleStateAsync(VehicleState vehicleState) { await _daprClient.SaveStateAsync<VehicleSta\", \"te>( DAPR_STORE_NAME, vehicleState.LicenseNumber, vehicleState); }\\n\\npublic async Task<VehicleState> \", \"GetVehicleStateAsync(string licenseNumber) { return await _daprClient.GetStateAsync<VehicleState>( D\", \"APR_STORE_NAME, licenseNumber); } }\\n\\nAs the preceding code snippet shows, the implementation of the \", \"DaprVehicleStateRepository class is pretty straightforward. The SaveVehicleStateAsync method uses th\", \"e injected DaprClient object\\n\\n50\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\nto save the \", \"state to the configured Dapr state store. It uses the vehicle\\u2019s license number as the key. The appli\", \"cation can retrieve the saved state by calling the GetVehicleStateAsync method.\\n\\nThe TrafficControl \", \"service uses Redis as its underlying data store. Looking at the code, you\\u2019d never know it. A service\", \" consuming the Dapr state management building block doesn\\u2019t directly reference any state components.\", \" Instead, a Dapr component configuration file specifies the store:\\n\\napiVersion: dapr.io/v1alpha1 kin\", \"d: Component metadata: name: statestore namespace: dapr-trafficcontrol spec: type: state.redis versi\", \"on: v1 metadata: - name: redisHost value: localhost:6379 - name: redisPassword secretKeyRef: name: s\", \"tate.redisPassword key: state.redisPassword scopes: - trafficcontrolservice\\n\\nNote\\n\\nThe component con\", \"figuration file includes an element secretKeyRef. The application uses it to reference the Redis pas\", \"sword value from the Dapr secrets building block. See chapter 10 to learn more about managing secret\", \"s with Dapr.\\n\\nThe type element in the configuration, state.redis instructs the building block to man\", \"age state with Dapr Redis component.\\n\\nThe scopes element in the configuration constrains application\", \" access to the state store component. Only the TrafficControl service can access the state store.\\n\\nS\", \"ummary\\n\\nThe Dapr state management building block offers an API for storing key/value data across var\", \"ious data stores. The API provides support for:\\n\\n\\n\\nBulk operations\\n\\n\\n\\nStrong and eventual consistenc\", \"y\\n\\n\\n\\nOptimistic concurrency control\\n\\nMulti-item transactions\\n\\nThe .NET SDK provides language-specifi\", \"c support for .NET and ASP.NET Core. Model binding integration simplifies accessing and updating sta\", \"te from ASP.NET Core controller action methods.\\n\\nIn the Dapr Traffic Control sample application, the\", \" benefits of using Dapr state management are clear:\\n\\n51\\n\\nCHAPTER 6 | The Dapr state management build\", \"ing block\\n\\n1.\\n\\nIt abstracts away the complexity of using third-party SDKs, such as StackExchange.Red\", \"is.\\n\\n2.\\n\\nReplacing the underlying Redis cache with a different type of data store only requires chan\", \"ges to the component configuration file.\\n\\nReferences\\n\\n\\n\\nDapr supported state stores\\n\\n52\\n\\nCHAPTER 6 |\", \" The Dapr state management building block\\n\\nCHAPTER 7\\n\\nThe Dapr service invocation building block\\n\\nAc\", \"ross a distributed system, one service often needs to communicate with another to complete a busines\", \"s operation. The Dapr service invocation building block can help streamline the communication betwee\", \"n services.\\n\\nWhat it solves\\n\\nMaking calls between services in a distributed application may appear e\", \"asy, but there are many challenges involved. For example:\\n\\nWhere the other services are located.\\n\\n\\n\\n\", \"How to call a service securely, given the service address.\\n\\n\\n\\nHow to handle retries when short-lived\", \" transient errors occur.\\n\\nLastly, as distributed applications compose many different services, captu\", \"ring insights across service call graphs are critical to diagnosing production issues.\\n\\nThe service \", \"invocation building block addresses these challenges by using a Dapr sidecar as a reverse proxy for \", \"your service.\\n\\nHow it works\\n\\nLet\\u2019s start with an example. Consider two services, \\u201cService A\\u201d and \\u201cSe\", \"rvice B\\u201d. Service A needs to call the catalog/items API on Service B. While Service A could take a d\", \"ependency on Service B and make a direct call to it, Service A instead invokes the service invocatio\", \"n API on the Dapr sidecar. Figure 6-1 shows the operation.\\n\\n53\\n\\nCHAPTER 7 | The Dapr service invocat\", \"ion building block\\n\\nFigure 6-1. How Dapr service invocation works.\\n\\nNote the steps from the previous\", \" figure:\\n\\n1.\\n\\nService A makes a call to the catalog/items endpoint in Service B by invoking the serv\", \"ice invocation API on the Service A sidecar.\\n\\n[!NOTE] The sidecar uses a pluggable name resolution c\", \"omponent to resolve the address of Service B. In self-hosted mode, Dapr uses mDNS to find it. When r\", \"unning in Kubernetes mode, the Kubernetes DNS service determines the address.\\n\\n2.\\n\\nThe Service A sid\", \"ecar forwards the request to the Service B sidecar.\\n\\n3.\\n\\nThe Service B sidecar makes the actual cata\", \"log/items request against the Service B API.\\n\\n4.\\n\\nService B executes the request and returns a respo\", \"nse back to its sidecar.\\n\\n5.\\n\\nThe Service B sidecar forwards the response back to the Service A side\", \"car.\\n\\n6.\\n\\nThe Service A sidecar returns the response back to Service A.\\n\\nBecause the calls flow thro\", \"ugh sidecars, Dapr can inject some useful cross-cutting behaviors:\\n\\n\\n\\nAutomatically retry calls upon\", \" failure.\\n\\nMake calls between services secure with mutual (mTLS) authentication, including automatic\", \"\\n\\ncertificate rollover.\\n\\n\\n\\nControl what operations clients can do using access control policies.\\n\\n\\n\\n\", \"Capture traces and metrics for all calls between services to provide insights and diagnostics.\\n\\n54\\n\\n\", \"CHAPTER 7 | The Dapr service invocation building block\\n\\nAny application can invoke a Dapr sidecar by\", \" using the native invoke API built into Dapr. The API can be called with either HTTP or gRPC. Use th\", \"e following URL to call the HTTP API:\\n\\nhttp://localhost:<dapr-port>/v1.0/invoke/<application-id>/met\", \"hod/<method-name>\\n\\n\\n\\n<dapr-port> the HTTP port that Dapr is listening on.\\n\\n\\n\\n<application-id> applic\", \"ation ID of the service to call.\\n\\n\\n\\n<method-name> name of the method to invoke on the remote service\", \".\\n\\nIn the following example, a curl call is made to the catalog/items \\u2018GET\\u2019 endpoint of Service B:\\n\\n\", \"curl http://localhost:3500/v1.0/invoke/serviceb/method/catalog/items\\n\\nNote\\n\\nThe Dapr APIs enable any\", \" application stack that supports HTTP or gRPC to use Dapr building blocks. Therefore, the service in\", \"vocation building block can act as a bridge between protocols. Services can communicate with each ot\", \"her using HTTP, gRPC or a combination of both.\\n\\nIn the next section, you\\u2019ll learn how to use the .NE\", \"T SDK to simplify service invocation calls.\\n\\nUse the Dapr .NET SDK\\n\\nThe Dapr .NET SDK provides .NET \", \"developers with an intuitive and language-specific way to interact with Dapr. The SDK offers develop\", \"ers three ways of making remote service invocation calls:\\n\\n1.\\n\\nInvoke HTTP services using HttpClient\", \"\\n\\n2.\\n\\nInvoke HTTP services using DaprClient\\n\\n3.\\n\\nInvoke gRPC services using DaprClient\\n\\nInvoke HTTP \", \"services using HttpClient\\n\\nThe preferred way to call an HTTP endpoint is to use Dapr\\u2019s rich integrat\", \"ion with HttpClient. The following example submits an order by calling the submit method of the orde\", \"rservice application:\\n\\nvar httpClient = DaprClient.CreateInvokeHttpClient(); await httpClient.PostAs\", \"JsonAsync(\\\"http://orderservice/submit\\\", order);\\n\\nIn the example, DaprClient.CreateInvokeHttpClient r\", \"eturns an HttpClient instance that is used to perform Dapr service invocation. The returned HttpClie\", \"nt uses a special Dapr message handler that rewrites URIs of outgoing requests. The host name is int\", \"erpreted as the application ID of the service to call. The rewritten request that\\u2019s actually being c\", \"alled is:\\n\\nhttp://127.0.0.1:3500/v1/invoke/orderservice/method/submit\\n\\nThis example uses the default\", \" value for the Dapr HTTP endpoint, which is http://127.0.0.1:<dapr- http-port>/. The value of dapr-h\", \"ttp-port is taken from the DAPR_HTTP_PORT environment variable. If it\\u2019s not set, the default port nu\", \"mber 3500 is used.\\n\\n55\\n\\nCHAPTER 7 | The Dapr service invocation building block\\n\\nAlternatively, you c\", \"an configure a custom endpoint in the call to DaprClient.CreateInvokeHttpClient:\\n\\nvar httpClient = D\", \"aprClient.CreateInvokeHttpClient(daprEndpoint: \\\"localhost:4000\\\");\\n\\nYou can also directly set the bas\", \"e address by specifying the application ID. Doing so enables relative URIs when making a call:\\n\\nvar \", \"httpClient = DaprClient.CreateInvokeHttpClient(\\\"orderservice\\\"); await httpClient.PostAsJsonAsync(\\\"/s\", \"ubmit\\\");\\n\\nThe HttpClient object is intended to be long-lived. A single HttpClient instance can be re\", \"used for the lifetime of the application. The next scenario demonstrates how an OrderServiceClient c\", \"lass reuses a Dapr HttpClient instance:\\n\\nvar builder = WebApplication.CreateBuilder(args); builder.S\", \"ervices.AddSingleton<IOrderServiceClient, OrderServiceClient>( _ => new OrderServiceClient(DaprClien\", \"t.CreateInvokeHttpClient(\\\"orderservice\\\")));\\n\\nIn the snippet above, the OrderServiceClient is registe\", \"red as a singleton with the ASP.NET Core dependency injection system. An implementation factory crea\", \"tes a new HttpClient instance by calling DaprClient.CreateInvokeHttpClient. It then uses the newly c\", \"reated HttpClient to instantiate the OrderServiceClient object. By registering the OrderServiceClien\", \"t as a singleton, it will be reused for the lifetime of the application.\\n\\nThe OrderServiceClient its\", \"elf has no Dapr-specific code. Even though Dapr service invocation is used under the hood, you can t\", \"reat the Dapr HttpClient like any other HttpClient:\\n\\npublic class OrderServiceClient : IOrderService\", \"Client { private readonly HttpClient _httpClient;\\n\\npublic OrderServiceClient(HttpClient httpClient) \", \"{ _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient)); }\\n\\npublic async T\", \"ask SubmitOrder(Order order) { var response = await _httpClient.PostAsJsonAsync(\\\"submit\\\", order); re\", \"sponse.EnsureSuccessStatusCode(); } }\\n\\nUsing the HttpClient class with Dapr service invocation has m\", \"any benefits:\\n\\n\\n\\nHttpClient is a well-known class that many developers already use in their code. Us\", \"ing HttpClient for Dapr service invocation allows developers to reuse their existing skills.\\n\\n\\n\\nHttp\", \"Client supports advanced scenarios, such as custom headers, and full control over request and respon\", \"se messages.\\n\\n\\n\\nIn .NET 5, HttpClient supports automatic serialization and deserialization using Sys\", \"tem.Text.Json.\\n\\n\\n\\nHttpClient integrates with many existing frameworks and libraries, such as Refit, \", \"RestSharp, and Polly.\\n\\n56\\n\\nCHAPTER 7 | The Dapr service invocation building block\\n\\nInvoke HTTP servi\", \"ces using DaprClient\\n\\nWhile HttpClient is the preferred way to invoke services using HTTP semantics,\", \" you can also use the DaprClient.InvokeMethodAsync family of methods. The following example submits \", \"an order by calling the submit method of the orderservice application:\\n\\nvar daprClient = new DaprCli\", \"entBuilder().Build(); try { var confirmation = await daprClient.InvokeMethodAsync<Order, OrderConfir\", \"mation>( \\\"orderservice\\\", \\\"submit\\\", order); } catch (InvocationException ex) { // Handle error }\\n\\nThe\", \" third argument, an order object, is serialized internally (with System.Text.JsonSerializer) and sen\", \"t as the request payload. The .NET SDK takes care of the call to the sidecar. It also deserializes t\", \"he response to an OrderConfirmation object. Because no HTTP method is specified, the request is exec\", \"uted as an HTTP POST.\\n\\nThe next example demonstrates how you can make an HTTP GET request by specify\", \"ing the HttpMethod:\\n\\nvar catalogItems = await daprClient.InvokeMethodAsync<IEnumerable<CatalogItem>>\", \"(HttpMethod.Get, \\\"catalogservice\\\", \\\"items\\\");\\n\\nFor some scenarios, you may require more control over \", \"the request message. For example, when you need to specify request headers, or you want to use a cus\", \"tom serializer for the payload. DaprClient.CreateInvokeMethodRequest creates an HttpRequestMessage. \", \"The following example demonstrates how to add an HTTP authorization header to a request message:\\n\\nva\", \"r request = daprClient.CreateInvokeMethodRequest(\\\"orderservice\\\", \\\"submit\\\", order); request.Headers.A\", \"uthorization = new AuthenticationHeaderValue(\\\"bearer\\\", token);\\n\\nThe HttpRequestMessage now has the f\", \"ollowing properties set:\\n\\n\\n\\nUrl = http://127.0.0.1:3500/v1.0/invoke/orderservice/method/submit\\n\\n\\n\\nHt\", \"tpMethod = POST\\n\\n\\n\\nContent = JsonContent object containing the JSON-serialized order\\n\\n\\n\\nHeaders.Auth\", \"orization = \\u201cbearer <token>\\u201d\\n\\nOnce you\\u2019ve got the request set up the way you want, use DaprClient.In\", \"vokeMethodAsync to send it:\\n\\nvar orderConfirmation = await daprClient.InvokeMethodAsync<OrderConfirm\", \"ation>(request);\\n\\nDaprClient.InvokeMethodAsync deserializes the response to an OrderConfirmation obj\", \"ect if the request is successful. Alternatively, you can use DaprClient.InvokeMethodWithResponseAsyn\", \"c to get full access to the underlying HttpResponseMessage:\\n\\n57\\n\\nCHAPTER 7 | The Dapr service invoca\", \"tion building block\\n\\nvar response = await daprClient.InvokeMethodWithResponseAsync(request); respons\", \"e.EnsureSuccessStatusCode();\\n\\nvar orderConfirmation = response.Content.ReadFromJsonAsync<OrderConfir\", \"mation>();\\n\\nNote\\n\\nFor service invocation calls using HTTP, it\\u2019s worth considering using the Dapr Htt\", \"pClient integration presented in the previous section. Using HttpClient gives you additional benefit\", \"s such as integration with existing frameworks and libraries.\\n\\nInvoke gRPC services using DaprClient\", \"\\n\\nDaprClient provides a family of InvokeMethodGrpcAsync methods for calling gRPC endpoints. The main\", \" difference with the HTTP methods is the use of a Protobuf serializer instead of JSON. The following\", \" example invokes the submitOrder method of the orderservice over gRPC.\\n\\nvar daprClient = new DaprCli\", \"entBuilder().Build(); try { var confirmation = await daprClient.InvokeMethodGrpcAsync<Order, OrderCo\", \"nfirmation>(\\\"orderservice\\\", \\\"submitOrder\\\", order); } catch (InvocationException ex) { // Handle erro\", \"r }\\n\\nIn the example above, DaprClient serializes the given order object using Protobuf and uses the \", \"result as the gRPC request body. Likewise, the response body is Protobuf deserialized and returned t\", \"o the caller. Protobuf typically provides better performance than the JSON payloads used in HTTP ser\", \"vice invocation.\\n\\nName resolution components\\n\\nAt the time of writing, Dapr provides support for the \", \"following name resolution components:\\n\\nmDNS (default when running self-hosted)\\n\\n\\n\\nKubernetes Name Re\", \"solution (default when running in Kubernetes)\\n\\n\\n\\nHashiCorp Consul\\n\\nConfiguration\\n\\nTo use a non-defau\", \"lt name resolution component, add a nameResolution spec to the application\\u2019s Dapr configuration file\", \". Here\\u2019s an example of a Dapr configuration file that enables HashiCorp Consul name resolution:\\n\\napi\", \"Version: dapr.io/v1alpha1 kind: Configuration metadata:\\n\\n58\\n\\nCHAPTER 7 | The Dapr service invocation\", \" building block\\n\\nname: dapr-config spec: nameResolution: component: \\\"consul\\\" configuration: selfRegi\", \"ster: true\\n\\nSample application: Dapr Traffic Control\\n\\nIn Dapr Traffic Control sample app, the FineCo\", \"llection service uses the Dapr service invocation building block to retrieve vehicle and owner infor\", \"mation from the VehicleRegistration service. Figure 6-2 shows the conceptual architecture of the Dap\", \"r Traffic Control sample application. The Dapr service invocation building block is used in flows ma\", \"rked with number 1 in the diagram:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/service-invocation/dapr-\", \"solution-service-invocation.png\\u201d alt-text=\\u201cConceptual architecture of the Dapr Traffic Control sampl\", \"e application.\\u201d:::\\n\\nFigure 6-2. Conceptual architecture of the Dapr Traffic Control sample applicati\", \"on.\\n\\nInformation is retrieved by the ASP.NET CollectionController class in the FineCollection servic\", \"e. The CollectFine method expects an incoming SpeedingViolation parameter. It invokes a Dapr service\", \" invocation building block to call to the VehicleRegistration service. The code snippet is presented\", \" below.\\n\\n:::{custom-style=CodeBox} ```csharp [Topic(\\u201cpubsub\\u201d, \\u201cspeedingviolations\\u201d)] [Route(\\u201ccollect\", \"fine\\u201d)] [HttpPost] public async Task CollectFine(SpeedingViolation speedingViolation, [FromServices]\", \" DaprClient daprClient) { // \\u2026\\n\\n// get owner info (Dapr service invocation) var vehicleInfo = _vehic\", \"leRegistrationService.GetVehicleInfo(speedingViolation.VehicleId).Result;\\n\\n// ...\\n\\n} ``` :::\\n\\nThe co\", \"de uses a proxy of type VehicleRegistrationService to call the VehicleRegistration service. ASP.NET \", \"Core injects an instance of the service proxy using constructor injection:\\n\\n:::{custom-style=CodeBox\", \"} csharp public CollectionController( ILogger<CollectionController> logger, IFineCalculator fineCalc\", \"ulator, VehicleRegistrationService vehicleRegistrationService, DaprClient daprClient) { // ... } :::\", \"\\n\\nThe VehicleRegistrationService class contains a single method: GetVehicleInfo. It uses the ASP.NET\", \" Core HttpClient to call the VehicleRegistration service:\\n\\n:::{custom-style=CodeBox} ```csharp publi\", \"c class VehicleRegistrationService { private HttpClient _httpClient; public VehicleRegistrationServi\", \"ce(HttpClient httpClient) { _httpClient = httpClient; }\\n\\npublic async Task<VehicleInfo> GetVehicleIn\", \"fo(string licenseNumber) { return await _httpClient.GetFromJsonAsync<VehicleInfo>(\\n\\n59\\n\\nCHAPTER 7 | \", \"The Dapr service invocation building block\\n\\n$\\\"vehicleinfo/{licenseNumber}\\\"); }\\n\\n} ``` :::\\n\\nThe code \", \"doesn\\u2019t depend on any Dapr classes directly. It instead leverages the Dapr ASP.NET Core integration \", \"as described in the Invoke HTTP services using HttpClient section of this module. The following code\", \" in the ConfigureService method of the Startup class registers the VehicleRegistrationService proxy:\", \"\\n\\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddSingleton<VehicleRegistratio\", \"nService>(_ => new VehicleRegistrationService(DaprClient.CreateInvokeHttpClient( \\\"vehicleregistratio\", \"nservice\\\", $\\\"http://localhost:{daprHttpPort}\\\" )));\\n\\nThe DaprClient.CreateInvokeHttpClient creates an\", \" HttpClient instance that calls the VehicleRegistration service using the service invocation buildin\", \"g block under the covers. It expects both the Dapr app-id of the target service and the URL of its D\", \"apr sidecar. At start time, the daprHttpPort argument contains the port number used for HTTP communi\", \"cation with the Dapr sidecar.\\n\\nUsing Dapr service invocation in the Traffic Control sample applicati\", \"on provides several benefits:\\n\\n1. Decouples the location of the target service.\\n\\n2.\\n\\nAdds resiliency\", \" with automatic retry features.\\n\\n3.\\n\\nAbility to reuse an existing HttpClient based proxy (offered by\", \" the ASP.NET Core integration).\\n\\nSummary\\n\\nIn this chapter, you learned about the service invocation \", \"building block. You saw how to invoke remote methods both by making direct HTTP calls to the Dapr si\", \"decar, and by using the Dapr .NET SDK.\\n\\nThe Dapr .NET SDK provides multiple ways to invoke remote me\", \"thods. HttpClient support is great for developers wanting to reuse existing skills and is compatible\", \" with many existing frameworks and libraries. DaprClient offers support for directly using the Dapr \", \"service invocation API using either HTTP or gRPC semantics.\\n\\nReferences\\n\\n\\n\\nDapr service invocation b\", \"uilding block\\n\\nMonitoring distributed cloud-native applications\\n\\n60\\n\\nCHAPTER 7 | The Dapr service in\", \"vocation building block\\n\\nCHAPTER 8\\n\\nThe Dapr publish & subscribe building block\\n\\nThe Publish-Subscri\", \"be pattern (often referred to as \\u201cpub/sub\\u201d) is a well-known and widely used messaging pattern. Archi\", \"tects commonly embrace it in distributed applications. However, the plumbing to implement it can be \", \"complex. There are often subtle feature differences across different messaging products. Dapr offers\", \" a building block that significantly simplifies implementing pub/sub functionality.\\n\\nWhat it solves\\n\", \"\\nThe primary advantage of the Publish-Subscribe pattern is loose coupling, sometimes referred to as \", \"temporal decoupling. The pattern decouples services that send messages (the publishers) from service\", \"s that consume messages (the subscribers). Both publishers and subscribers are unaware of each other\", \" - both are dependent on a centralized message broker that distributes the messages.\\n\\nFigure 7-1 sho\", \"ws the high-level architecture of the pub/sub pattern.\\n\\nFigure 7-1. The pub/sub pattern.\\n\\nFrom the p\", \"revious figure, note the steps of the pattern:\\n\\n1.\\n\\nPublishers send messages to the message broker.\\n\", \"\\n2.\\n\\nSubscribers bind to a subscription on the message broker.\\n\\n61\\n\\nCHAPTER 8 | The Dapr publish & s\", \"ubscribe building block\\n\\n3.\\n\\nThe message broker forwards a copy of the message to interested subscri\", \"ptions.\\n\\n4.\\n\\nSubscribers consume messages from their subscriptions.\\n\\nMost message brokers encapsulat\", \"e a queueing mechanism that can persist messages once received. With it, the message broker guarante\", \"es durability by storing the message. Subscribers don\\u2019t need to be immediately available or even onl\", \"ine when a publisher sends a message. Once available, the subscriber receives and processes the mess\", \"age. Dapr guarantees At-Least-Once semantics for message delivery. Once a message is published, it w\", \"ill be delivered at least once to any interested subscriber.\\n\\nTip\\n\\nIf your service can only process \", \"a message once, you\\u2019ll need to provide an idempotency check to ensure that the same message is not p\", \"rocessed multiple times. While such logic can be coded, some message brokers, such as Azure Service \", \"Bus, provide built-in duplicate detection messaging capabilities.\\n\\nThere are several message broker \", \"products available - both commercially and open-source. Each has advantages and drawbacks. Your job \", \"is to match your system requirements to the appropriate broker. Once selected, it\\u2019s a best practice \", \"to decouple your application from message broker plumbing. You achieve this functionality by wrappin\", \"g the broker inside an abstraction. The abstraction encapsulates the message plumbing and exposes ge\", \"neric pub/sub operations to your code. Your code communicates with the abstraction, not the actual m\", \"essage broker. While a wise decision, you\\u2019ll have to write and maintain the abstraction and its unde\", \"rlying implementation. This approach requires custom code that can be complex, repetitive, and error\", \"-prone.\\n\\nThe Dapr publish & subscribe building block provides the messaging abstraction and implemen\", \"tation out-of-the-box. The custom code you would have had to write is prebuilt and encapsulated insi\", \"de the Dapr building block. You bind to it and consume it. Instead of writing messaging plumbing cod\", \"e, you and your team focus on creating business functionality that adds value to your customers.\\n\\nHo\", \"w it works\\n\\nThe Dapr publish & subscribe building block provides a platform-agnostic API framework t\", \"o send and receive messages. Your services publish messages to a named topic. Your services subscrib\", \"e to a topic to consume messages.\\n\\nThe service calls the pub/sub API on the Dapr sidecar. The sideca\", \"r then makes calls into a pre-defined Dapr pub/sub component that encapsulates a specific message br\", \"oker product. Figure 7-2 shows the Dapr pub/sub messaging stack.\\n\\n62\\n\\nCHAPTER 8 | The Dapr publish &\", \" subscribe building block\\n\\nFigure 7-2. The Dapr pub/sub stack.\\n\\nThe Dapr publish & subscribe buildin\", \"g block can be invoked in many ways.\\n\\nAt the lowest level, any programming platform can invoke the b\", \"uilding block over HTTP or gRPC using the Dapr native API. To publish a message, you make the follow\", \"ing API call:\\n\\nhttp://localhost:<dapr-port>/v1.0/publish/<pub-sub-name>/<topic>\\n\\nThere are several D\", \"apr specific URL segments in the above call:\\n\\n\\n\\n<dapr-port> provides the port number upon which the \", \"Dapr sidecar is listening.\\n\\n\\n\\n<pub-sub-name> provides the name of the selected Dapr pub/sub componen\", \"t.\\n\\n\\n\\n<topic> provides the name of the topic to which the message is published.\\n\\nUsing the curl comm\", \"and-line tool to publish a message, you can try it out:\\n\\ncurl -X POST http://localhost:3500/v1.0/pub\", \"lish/pubsub/newOrder \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"orderId\\\": \\\"1234\\\", \\\"productId\\\": \\\"\", \"5678\\\", \\\"amount\\\": 2 }'\\n\\nYou receive messages by subscribing to a topic. At startup, the Dapr runtime \", \"will call the application on a well-known endpoint to identify and create the required subscriptions\", \":\\n\\nhttp://localhost:<appPort>/dapr/subscribe\\n\\n63\\n\\nCHAPTER 8 | The Dapr publish & subscribe building \", \"block\\n\\n\\n\\n<appPort> informs the Dapr sidecar of the port upon which the application is listening.\\n\\nYo\", \"u can implement this endpoint yourself. But Dapr provides more intuitive ways of implementing it. We\", \"\\u2019ll address this functionality later in this chapter.\\n\\nThe response from the call contains a list of\", \" topics to which the applications will subscribe. Each includes an endpoint to call when the topic r\", \"eceives a message. Here\\u2019s an example of a response:\\n\\n[ { \\\"pubsubname\\\": \\\"pubsub\\\", \\\"topic\\\": \\\"newOrder\\\"\", \", \\\"route\\\": \\\"/orders\\\" }, { \\\"pubsubname\\\": \\\"pubsub\\\", \\\"topic\\\": \\\"newProduct\\\", \\\"route\\\": \\\"/productCatalog/p\", \"roducts\\\" } ]\\n\\nIn the JSON response, you can see the application wants to subscribe to topics newOrde\", \"r and newProduct. It registers the endpoints /orders and /productCatalog/products for each, respecti\", \"vely. For both subscriptions, the application is binding to the Dapr component named pubsub.\\n\\nFigure\", \" 7-3 presents the flow of the example.\\n\\n64\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\", \"\\nFigure 7-3. Pub/sub flow with Dapr.\\n\\nFrom the previous figure, note the flow:\\n\\n1.\\n\\nThe Dapr sidecar\", \" for Service B calls the /dapr/subscribe endpoint from Service B (the consumer). The service respond\", \"s with the subscriptions it wants to create.\\n\\n2.\\n\\nThe Dapr sidecar for Service B creates the request\", \"ed subscriptions on the message broker.\\n\\n3.\\n\\nService A publishes a message at the /v1.0/publish/<pub\", \"-sub-name>/<topic> endpoint on the Dapr Service A sidecar.\\n\\n4.\\n\\nThe Service A sidecar publishes the \", \"message to the message broker.\\n\\n5.\\n\\nThe message broker sends a copy of the message to the Service B \", \"sidecar.\\n\\n6.\\n\\nThe Service B sidecar calls the endpoint corresponding to the subscription (in this ca\", \"se /orders) on Service B. The service responds with an HTTP status-code 200 OK so the sidecar will c\", \"onsider the message as being handled successfully.\\n\\nIn the example, the message is handled successfu\", \"lly. But if something goes wrong while Service B is handling the request, it can use the response to\", \" specify what needs to happen with the message. When it returns an HTTP status-code 404, an error is\", \" logged and the message is dropped. With any other status-code than 200 or 404, a warning is logged \", \"and the message is retried. Alternatively,\\n\\n65\\n\\nCHAPTER 8 | The Dapr publish & subscribe building bl\", \"ock\\n\\nService B can explicitly specify what needs to happen with the message by including a JSON payl\", \"oad in the body of the response:\\n\\n{ \\\"status\\\": \\\"<status>\\\" }\\n\\nThe following table shows the available \", \"status values:\\n\\nStatus\\n\\nAction\\n\\nSUCCESS\\n\\nThe message is considered as processed successfully and dro\", \"pped.\\n\\nRETRY\\n\\nThe message is retried.\\n\\nDROP\\n\\nA warning is logged and the message is dropped.\\n\\nAny ot\", \"her status The message is retried.\\n\\nCompeting consumers\\n\\nWhen scaling out an application that subscr\", \"ibes to a topic, you have to deal with competing consumers. Only one application instance should han\", \"dle a message sent to the topic. Luckily, Dapr handles that problem. When multiple instances of a se\", \"rvice with the same application-id subscribe to a topic, Dapr delivers each message to only one of t\", \"hem.\\n\\nUse the Dapr .NET SDK\\n\\nFor .NET Developers, the Dapr .NET SDK provides a more productive way o\", \"f working with Dapr. The SDK exposes a DaprClient class through which you can directly invoke Dapr f\", \"unctionality. It\\u2019s intuitive and easy to use.\\n\\nTo publish a message, the DaprClient exposes a Publis\", \"hEventAsync method.\\n\\nvar data = new OrderData { orderId = \\\"123456\\\", productId = \\\"67890\\\", amount = 2 \", \"};\\n\\nvar daprClient = new DaprClientBuilder().Build();\\n\\nawait daprClient.PublishEventAsync<OrderData>\", \"(\\\"pubsub\\\", \\\"newOrder\\\", data);\\n\\n\\n\\nThe first argument pubsub is the name of the Dapr component that pr\", \"ovides the message broker implementation. We\\u2019ll address components later in this chapter.\\n\\n\\n\\nThe sec\", \"ond argument neworder provides the name of the topic to send the message to.\\n\\n\\n\\nThe third argument i\", \"s the payload of the message.\\n\\n\\n\\nYou can specify the .NET type of the message using the generic type\", \" parameter of the method.\\n\\n66\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\nTo receive m\", \"essages, you bind an endpoint to a subscription for a registered topic. The AspNetCore library for D\", \"apr makes this trivial. Assume, for example, that you have an existing ASP.NET WebAPI action method \", \"entitled CreateOrder:\\n\\n[HttpPost(\\\"/orders\\\")] public async Task<ActionResult> CreateOrder(Order order\", \")\\n\\nImportant\\n\\nYou must add a reference to the Dapr.AspNetCore NuGet package in your project to consu\", \"me the Dapr ASP.NET Core integration.\\n\\nTo bind this action method to a topic, you decorate it with t\", \"he Topic attribute:\\n\\n[Topic(\\\"pubsub\\\", \\\"newOrder\\\")] [HttpPost(\\\"/orders\\\")] public async Task<ActionRes\", \"ult> CreateOrder(Order order)\\n\\nYou specify two key elements with this attribute:\\n\\n\\n\\nThe Dapr pub/sub\", \" component to target (in this case pubsub).\\n\\n\\n\\nThe topic to subscribe to (in this case newOrder).\\n\\nD\", \"apr then invokes that action method as it receives messages for that topic.\\n\\nYou\\u2019ll also need to ena\", \"ble ASP.NET Core to use Dapr. The Dapr .NET SDK provides several extension methods that can be used \", \"to do this.\\n\\nIn the Program.cs file, you must call the following extension method on the WebApplicat\", \"ion builder to register Dapr:\\n\\nvar builder = WebApplication.CreateBuilder(args); builder.Services.Ad\", \"dControllers().AddDapr();\\n\\nAppending the AddDapr extension method to the AddControllers extension me\", \"thod registers the necessary services to integrate Dapr into the MVC pipeline. It also registers a D\", \"aprClient instance into the dependency injection container, which then can be injected anywhere into\", \" your service.\\n\\nAfter the WebApplication has been created, you must add the following middleware com\", \"ponents to enable Dapr:\\n\\nvar builder = WebApplication.CreateBuilder(args); var app = builder.Build()\", \"; app.UseCloudEvents(); app.MapControllers(); app.MapSubscribeHandler();\\n\\nThe call to UseCloudEvents\", \" adds CloudEvents middleware into to the ASP.NET Core middleware pipeline. This middleware will unwr\", \"ap requests that use the CloudEvents structured format, so the receiving method can read the event p\", \"ayload directly.\\n\\n67\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\nNote\\n\\nCloudEvents is \", \"a standardized messaging format, providing a common way to describe event information across platfor\", \"ms. Dapr embraces CloudEvents. For more information about CloudEvents, see the cloudevents specifica\", \"tion.\\n\\nThe call to MapSubscribeHandler in the endpoint routing configuration will add a Dapr subscri\", \"be endpoint to the application. This endpoint will respond to requests on /dapr/subscribe. When this\", \" endpoint is called, it will automatically find all WebAPI action methods decorated with the Topic a\", \"ttribute and instruct Dapr to create subscriptions for them.\\n\\nPub/sub components\\n\\nDapr pub/sub compo\", \"nents handle the actual transport of the messages. Several are available. Each encapsulates a specif\", \"ic message broker product to implement the pub/sub functionality. At the time of writing, the follow\", \"ing pub/sub components were available:\\n\\n\\n\\nApache Kafka\\n\\n\\n\\nAWS SNS/SQS\\n\\n\\n\\nAzure Event Hubs\\n\\n\\n\\nAzure S\", \"ervice Bus\\n\\n\\n\\nGCP Pub/Sub\\n\\n\\n\\nHazelcast\\n\\n\\n\\nIn Memory\\n\\n\\n\\nJetStream\\n\\nMQTT\\n\\n\\n\\nNATS Streaming\\n\\n\\n\\nPulsar\\n\\n\", \"\\n\\nRabbitMQ\\n\\n\\n\\nRedis Streams\\n\\nNote\\n\\nThe Azure cloud stack has both messaging functionality (Azure Ser\", \"vice Bus) and event streaming (Azure Event Hub) availability.\\n\\nThese components are created by the c\", \"ommunity in a component-contrib repository on GitHub. You\\u2019re encouraged to write your own Dapr compo\", \"nent for a message broker that isn\\u2019t yet supported.\\n\\nConfiguration\\n\\nUsing a Dapr configuration file,\", \" you can specify the pub/sub component(s) to use. This configuration contains several fields. The na\", \"me field specifies the pub/sub component that you want to use. When sending or receiving a message, \", \"you need to specify this name (as you saw earlier in the PublishEventAsync method signature).\\n\\n68\\n\\nC\", \"HAPTER 8 | The Dapr publish & subscribe building block\\n\\nBelow you see an example of a Dapr configura\", \"tion file for configuring a RabbitMQ message broker component:\\n\\napiVersion: dapr.io/v1alpha1 kind: C\", \"omponent metadata: name: pubsub-rq spec: type: pubsub.rabbitmq version: v1 metadata: - name: host va\", \"lue: \\\"amqp://localhost:5672\\\" - name: durable value: true\\n\\nIn this example, you can see that you can \", \"specify any message broker-specific configuration in the metadata block. In this case, RabbitMQ is c\", \"onfigured to create durable queues. But the RabbitMQ component has more configuration options. Each \", \"of the components\\u2019 configuration will have its own set of possible fields. You can read which fields\", \" are available in the documentation of each pub/sub component.\\n\\nNext to the programmatic way of subs\", \"cribing to a topic from code, Dapr pub/sub also provides a declarative way of subscribing to a topic\", \". This approach removes the Dapr dependency from the application code. Therefore, it also enables an\", \" existing application to subscribe to topics without any changes to the code. The following example \", \"shows a Dapr configuration file for configuring a subscription:\\n\\napiVersion: dapr.io/v1alpha1 kind: \", \"Subscription metadata: name: newOrder-subscription spec: pubsubname: pubsub topic: newOrder route: /\", \"orders scopes: - ServiceB - ServiceC\\n\\nYou have to specify several elements with every subscription:\\n\", \"\\n\\n\\nThe name of the Dapr pub/sub component you want to use (in this case pubsub).\\n\\n\\n\\nThe name of the \", \"topic to subscribe to (in this case newOrder).\\n\\n\\n\\nThe API operation that needs to be called for this\", \" topic (in this case /orders).\\n\\n\\n\\nThe scope can specify which services can publish and subscribe to \", \"a topic.\\n\\nSample application: Dapr Traffic Control\\n\\nIn Dapr Traffic Control sample app, the TrafficC\", \"ontrol service uses the Dapr pub/sub building block to send speeding violations to the FineCollectio\", \"n service. Figure 7-4 shows the conceptual architecture\\n\\n69\\n\\nCHAPTER 8 | The Dapr publish & subscrib\", \"e building block\\n\\nof the Dapr Traffic Control sample application. The Dapr pub/sub building block is\", \" used in flows marked with number 2 in the diagram:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/publish\", \"-subscribe/dapr-solution-pub-sub.png\\u201d alt- text=\\u201cConceptual architecture of the Dapr Traffic Control\", \" sample application.\\u201d:::\\n\\nFigure 7-4. Conceptual architecture of the Dapr Traffic Control sample app\", \"lication.\\n\\nSpeeding violations are handled by the CollectionController, an ordinary ASP.NET Core Con\", \"troller. The CollectionController.CollectFine method subscribes to and handles SpeedingViolation eve\", \"nt messages:\\n\\n[Topic(\\\"pubsub\\\", \\\"speedingviolations\\\")] [Route(\\\"collectfine\\\")] [HttpPost] public async\", \" Task<ActionResult> CollectFine( SpeedingViolation speedingViolation, [FromServices] DaprClient dapr\", \"Client) { // ... }\\n\\nThe method is decorated with the Dapr Topic attribute. It specifies that the pub\", \"/sub component named pubsub should be used to subscribe to messages sent to the speedingviolations t\", \"opic.\\n\\nThe TrafficControl service sends speeding violations. Near the end of the VehicleExit method \", \"in the TrafficController class, the DaprClient object is used to publish SpeedingViolation messages \", \"using the pub/sub building block:\\n\\n/// ...\\n\\nvar speedingViolation = new SpeedingViolation { VehicleI\", \"d = msg.LicenseNumber, RoadId = _roadId, ViolationInKmh = violation, Timestamp = msg.Timestamp };\\n\\n/\", \"/ publish speedingviolation (Dapr publish / subscribe) await daprClient.PublishEventAsync(\\\"pubsub\\\", \", \"\\\"speedingviolations\\\", speedingViolation);\\n\\n/// ...\\n\\nNote how the DaprClient object reduces the call \", \"to a single line of code, again, binding to the speedingviolations topic and the Dapr pubsub compone\", \"nt.\\n\\nWhile the Traffic Control app uses RabbitMQ as the message broker, it never directly references\", \" RabbitMQ. Instead, the accompanying Dapr component configuration file named pubsub.yaml in the /dap\", \"r/components folder specifies the message broker:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component meta\", \"data: name: pubsub namespace: dapr-trafficcontrol spec: type: pubsub.rabbitmq\\n\\n70\\n\\nCHAPTER 8 | The D\", \"apr publish & subscribe building block\\n\\nversion: v1 metadata: - name: host value: \\\"amqp://localhost:\", \"5672\\\" - name: durable value: \\\"false\\\" - name: deletedWhenUnused value: \\\"false\\\" - name: autoAck value:\", \" \\\"false\\\" - name: reconnectWait value: \\\"0\\\" - name: concurrency value: parallel scopes: - trafficcontr\", \"olservice - finecollectionservice\\n\\nThe type element in the configuration, pubsub.rabbitmq instructs \", \"the building block to use the Dapr RabbitMQ component.\\n\\nThe scopes element in the configuration cons\", \"trains application access to the RabbitMQ component. Only the TrafficControl and FineCollection serv\", \"ices can consume it.\\n\\nUsing Dapr pub/sub in the Traffic Control sample application offers the follow\", \"ing benefits:\\n\\n1. No infrastructural abstraction of a message broker to maintain.\\n\\n2.\\n\\nServices are \", \"temporally decoupled, which increases robustness.\\n\\n3.\\n\\nPublisher and subscribers are unaware of each\", \" other. This means that additional services could be introduced that will react to speeding violatio\", \"ns in the future, without the need to change the TrafficControl service.\\n\\nSummary\\n\\nThe pub/sub patte\", \"rn helps you decouple services in a distributed application. The Dapr publish & subscribe building b\", \"lock simplifies implementing this behavior in your application.\\n\\nThrough Dapr pub/sub, you can publi\", \"sh messages to a specific topic. As well, the building block will query your service to determine wh\", \"ich topic(s) to subscribe to.\\n\\nYou can use Dapr pub/sub natively over HTTP or by using one of the la\", \"nguage-specific SDKs, such as the .NET SDK for Dapr. The .NET SDK tightly integrates with the ASP.NE\", \"T core platform.\\n\\nWith Dapr, you can plug a supported message broker product into your application. \", \"You can then swap message brokers without requiring code changes to your application.\\n\\nReferences\\n\\n\\n\", \"\\nDapr supported pub/sub brokers\\n\\n71\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\nCHAPTE\", \"R 9\\n\\nThe Dapr bindings building block\\n\\nCloud-based serverless offerings, such as Azure Functions and\", \" AWS Lambda, have gained wide adoption across the distributed architecture space. Among many benefit\", \"s, they enable a microservice to handle events from or invoke events in an external system - abstrac\", \"ting away the underlying complexity and plumbing concerns. External resources are many: They include\", \" datastores, message systems, and web resources, across different platforms and vendors. The Dapr bi\", \"ndings building block brings these same resource binding capabilities to the doorstep of your Dapr a\", \"pplications.\\n\\nWhat it solves\\n\\nDapr resource bindings enable your services to integrate business oper\", \"ations across external resources outside of the immediate application. An event from an external sys\", \"tem could trigger an operation in your service passing in contextual information. Your service could\", \" then expand the operation by triggering an event in another external system, passing in contextual \", \"payload information. Your service communicates without coupling or awareness of the external resourc\", \"e. The plumbing is encapsulated inside pre-defined Dapr components. The Dapr component to use can be\", \" easily swapped at run time without code changes.\\n\\nConsider, for example, a Twitter account that tri\", \"ggers an event whenever a user tweets a keyword. Your service exposes an event handler that receives\", \" and processes the tweet. Once complete, your service triggers an event that invokes an external Twi\", \"lio service. Twilio sends an SMS message that includes the tweet. Figure 8-1 show the conceptual arc\", \"hitecture of this operation:\\n\\nFigure 8-1. Conceptual architecture of a Dapr resource binding.\\n\\nAt fi\", \"rst glance, resource binding behavior may appear similar to the Publish/Subscribe pattern described \", \"earlier in this book. While they share similarities, there are differences. Publish/subscribe\\n\\n72\\n\\nC\", \"HAPTER 9 | The Dapr bindings building block\\n\\nfocuses on asynchronous communication between Dapr serv\", \"ices. Resource binding has a much wider scope. It focuses on system interoperability across software\", \" platforms. Exchanging information between disparate applications, datastores, and services outside \", \"your microservice application.\\n\\nHow it works\\n\\nDapr resource binding starts with a component configur\", \"ation file. This YAML file describes the type of resource to which you\\u2019ll bind along with its config\", \"uration settings. Once configured, your service can receive events from the resource or trigger even\", \"ts on it.\\n\\nNote\\n\\nBinding configurations are presented in detail later in the Components section.\\n\\nIn\", \"put bindings\\n\\nInput bindings trigger your code with incoming events from external resources. To rece\", \"ive events and data, you register a public endpoint from your service that becomes the event handler\", \". Figure 8-2 shows the flow:\\n\\nFigure 8-2. Dapr input binding flow.\\n\\nFigure 8.2 describes the steps f\", \"or receiving events from an external Twitter account:\\n\\n73\\n\\nCHAPTER 9 | The Dapr bindings building bl\", \"ock\\n\\n1.\\n\\nThe Dapr sidecar reads the binding configuration file and subscribes to the event specified\", \" for the external resource. In the example, the event source is a Twitter account.\\n\\n2. When a matchi\", \"ng Tweet is published on Twitter, the binding component running in the Dapr\\n\\nsidecar picks it up and\", \" triggers an event.\\n\\n3.\\n\\nThe Dapr sidecar invokes the endpoint (that is, event handler) configured f\", \"or the binding. In the example, the service listens for an HTTP POST on the /tweet endpoint on port \", \"6000. Because it\\u2019s an HTTP POST operation, the JSON payload for the event is passed in the request b\", \"ody.\\n\\n4.\\n\\nAfter handling the event, the service returns an HTTP status code 200 OK.\\n\\nThe following A\", \"SP.NET Core controller provides an example of handling an event triggered by the Twitter binding:\\n\\n[\", \"ApiController] public class SomeController : ControllerBase { public class TwitterTweet { [JsonPrope\", \"rtyName(\\\"id_str\\\")] public string ID {get; set; }\\n\\n[JsonPropertyName(\\\"text\\\")] public string Text {get\", \"; set; } }\\n\\n[HttpPost(\\\"/tweet\\\")] public ActionResult Post(TwitterTweet tweet) { // Handle tweet Cons\", \"ole.WriteLine(\\\"Tweet received: {0}: {1}\\\", tweet.ID, tweet.Text);\\n\\n// ...\\n\\n// Acknowledge message ret\", \"urn Ok(); } }\\n\\nIf the operation should error, you would return the appropriate 400 or 500 level HTTP\", \" status code. For bindings that feature at-least-once delivery guarantees, the Dapr sidecar will ret\", \"ry the trigger. Check out Dapr documentation for resource bindings to see whether they offer at-leas\", \"t-once or exactly-once delivery guarantees.\\n\\nOutput bindings\\n\\nDapr also includes output binding capa\", \"bilities. They enable your service to trigger an event that invokes an external resource. Again, you\", \" start by configuring a binding configuration YAML file that describes the output binding. Once in p\", \"lace, you trigger an event that invokes the bindings API on the Dapr sidecar of your application. Fi\", \"gure 8-3 shows the flow of an output binding:\\n\\n74\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\nFig\", \"ure 8-3. Dapr output binding flow.\\n\\n1.\\n\\nThe Dapr sidecar reads the binding configuration file with t\", \"he information on how to connect to the external resource. In the example, the external resource is \", \"a Twilio SMS account.\\n\\n2.\\n\\nYour application invokes the /v1.0/bindings/sms endpoint on the Dapr side\", \"car. In this case, it uses an HTTP POST to invoke the API. It\\u2019s also possible to use gRPC.\\n\\n3.\\n\\nThe \", \"binding component running in the Dapr sidecar calls the external messaging system to send the messag\", \"e. The message will contain the payload passed in the POST request.\\n\\nAs an example, you can invoke a\", \"n output binding by invoking the Dapr API using curl:\\n\\ncurl -X POST http://localhost:3500/v1.0/bindi\", \"ngs/sms \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \\\"data\\\": \\\"Welcome to this awesome service\\\", \\\"me\", \"tadata\\\": { \\\"toNumber\\\": \\\"555-3277\\\" }, \\\"operation\\\": \\\"create\\\" }'\\n\\nNote that the HTTP port is the same a\", \"s used by the Dapr sidecar (in this case, the default Dapr HTTP port 3500).\\n\\nThe structure of the pa\", \"yload (that is, message sent) will vary per binding. In the example above, the payload contains a da\", \"ta element with a message. Bindings to other types of external resources can be different, especiall\", \"y for the metadata that is sent. Each payload must also contain an operation field,\\n\\n75\\n\\nCHAPTER 9 |\", \" The Dapr bindings building block\\n\\nthat defines the operation the binding will execute. The above ex\", \"ample specifies a create operation that creates the SMS message. Common operations include:\\n\\n\\n\\ncreat\", \"e\\n\\n\\n\\nget\\n\\n\\n\\ndelete\\n\\n\\n\\nlist\\n\\nIt\\u2019s up to the author of the binding which operations the binding suppor\", \"ts. The documentation for each binding describes the available operations and how to invoke them.\\n\\nU\", \"se the Dapr .NET SDK\\n\\nThe Dapr .NET SDK provides language-specific support for .NET developers. In t\", \"he following example, the call to the HttpClient.PostAsync() is replaced with the DaprClient.InvokeB\", \"indingAsync() method. This specialized method simplifies invoking a configured output binding:\\n\\npriv\", \"ate async Task SendSMSAsync([FromServices] DaprClient daprClient) { var message = \\\"Welcome to this a\", \"wesome service\\\"; var metadata = new Dictionary<string, string> { { \\\"toNumber\\\", \\\"555-3277\\\" } }; await\", \" daprClient.InvokeBindingAsync(\\\"sms\\\", \\\"create\\\", message, metadata); }\\n\\nThe method expects the metada\", \"ta and message values.\\n\\nWhen used to invoke a binding, the DaprClient uses gRPC to call the Dapr API\", \" on the Dapr sidecar.\\n\\nBinding components\\n\\nUnder the hood, resource bindings are implemented with Da\", \"pr binding components. They\\u2019re contributed by the community and written in Go. If you need to integr\", \"ate with an external resource for which no Dapr binding exists yet, you can create it yourself. Chec\", \"k out the Dapr components- contrib repo to see how you can contribute a binding.\\n\\nNote\\n\\nDapr and all\", \" of its components are written in the Golang (Go) language. Go is considered a modern, cloud-native \", \"programming platform.\\n\\nYou configure bindings using a YAML configuration file. Here\\u2019s an example con\", \"figuration for the Twitter binding:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: tw\", \"itter-mention\\n\\n76\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\nnamespace: default spec: type: bind\", \"ings.twitter version: v1 metadata: - name: consumerKey value: \\\"****\\\" # twitter api consumer key, req\", \"uired - name: consumerSecret value: \\\"****\\\" # twitter api consumer secret, required - name: accessTok\", \"en value: \\\"****\\\" # twitter api access token, required - name: accessSecret value: \\\"****\\\" # twitter a\", \"pi access secret, required - name: query value: \\\"dapr\\\" # your search query, required\\n\\nEach binding c\", \"onfiguration contains a general metadata element with a name and namespace field. Dapr will determin\", \"e the endpoint to invoke your service based upon the configured name field. In the above example, Da\", \"pr will invoke the method annotated with /twitter-mention in your service when an event occurs.\\n\\nIn \", \"the spec element, you specify the type of the binding along with binding specific metadata. The exam\", \"ple specifies credentials for accessing a Twitter account using its API. The metadata can differ bet\", \"ween input and output bindings. For example, to use Twitter as an input binding, you need to specify\", \" the text to search for in tweets using the query field. Every time a matching tweet is sent, the Da\", \"pr sidecar will invoke the /twitter-mention endpoint on the service. It will also deliver the conten\", \"ts of the tweet.\\n\\nA binding can be configured for input, output, or both. Interestingly, the binding\", \" doesn\\u2019t explicitly specify input or output configuration. Instead, the direction is inferred by the\", \" usage of the binding along with configuration values.\\n\\nThe Dapr documentation for resource bindings\", \" provides a complete list of the available bindings and their specific configuration settings.\\n\\nCron\", \" binding\\n\\nPay close attention to Dapr\\u2019s Cron binding. It doesn\\u2019t subscribe to events from an externa\", \"l system. Instead, this binding uses a configurable interval schedule to trigger your application. T\", \"he binding provides a simple way to implement a background worker to wake up and do some work at a r\", \"egular interval, without the need to implement an endless loop with a configurable delay. Here\\u2019s an \", \"example of a Cron binding configuration:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: nam\", \"e: checkOrderBacklog namespace: default spec: type: bindings.cron version: v1 metadata: - name: sche\", \"dule value: \\\"@every 30m\\\"\\n\\n77\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\nIn this example, Dapr tr\", \"iggers a service by invoking the /checkOrderBacklog endpoint every 30 minutes. There are several pat\", \"terns available for specifying the schedule value. For more information, see the Cron binding docume\", \"ntation.\\n\\nSample application: Dapr Traffic Control\\n\\nIn the Dapr Traffic Control sample application, \", \"the TrafficControl service uses the MQTT input binding to retrieve messages from the CameraSimulatio\", \"n. Figure 8-4 shows the conceptual architecture of the Dapr Traffic Control sample application. The \", \"Dapr input binding is used in flows marked with number 5 in the diagram:\\n\\nFigure 8-4. Conceptual arc\", \"hitecture of the Dapr Traffic Control sample application.\\n\\n78\\n\\nCHAPTER 9 | The Dapr bindings buildin\", \"g block\\n\\nMQTT input binding\\n\\nMQTT is a lightweight pub/sub messaging protocol, often used in IoT sce\", \"narios. Producers sent MQTT messages to a topic; subscribers then retrieve messages from the topic. \", \"There are several MQTT message broker products available. The Traffic Control sample application use\", \"s Eclipse Mosquitto.\\n\\nThe CameraSimulation doesn\\u2019t depend on any Dapr building blocks. It uses the S\", \"ystem.Net.Mqtt library to send MQTT messages:\\n\\n// ...\\n\\n// simulate entry DateTime entryTimestamp = D\", \"ateTime.Now; var vehicleRegistered = new VehicleRegistered { Lane = _camNumber, LicenseNumber = Gene\", \"rateRandomLicenseNumber(), Timestamp = entryTimestamp }; _trafficControlService.SendVehicleEntry(veh\", \"icleRegistered);\\n\\n// ...\\n\\nThe code uses a proxy of type ITrafficControlService to call the TrafficCo\", \"ntrol service. .NET injects an implementation of the ITrafficControlService interface using construc\", \"tor injection:\\n\\n:::{custom-style=CodeBox} csharp public CameraSimulation(int camNumber, ITrafficCont\", \"rolService trafficControlService) { _camNumber = camNumber; _trafficControlService = trafficControlS\", \"ervice; } :::\\n\\nThe MqttTrafficControlService class implements the ITrafficControlService interface. \", \"It exposes two methods: SendVehicleEntryAsync and SendVehicleExitAsync. They both use the MQTT clien\", \"t to send messages to the trafficcontrol/entrycam and trafficcontrol/exitcam topics respectively:\\n\\np\", \"ublic async Task SendVehicleEntryAsync(VehicleRegistered vehicleRegistered) { var eventJson = JsonSe\", \"rializer.Serialize(vehicleRegistered); var message = new MqttApplicationMessage(\\\"trafficcontrol/entr\", \"ycam\\\", Encoding.UTF8.GetBytes(eventJson)); await _client.PublishAsync(message, MqttQualityOfService.\", \"AtMostOnce); }\\n\\npublic async Task SendVehicleExitAsync(VehicleRegistered vehicleRegistered) { var ev\", \"entJson = JsonSerializer.Serialize(vehicleRegistered); var message = new MqttApplicationMessage(\\\"tra\", \"fficcontrol/exitcam\\\", Encoding.UTF8.GetBytes(eventJson)); await _client.PublishAsync(message, MqttQu\", \"alityOfService.AtMostOnce); }\\n\\nThe constructor sets up the MQTT client to send messages to the MQTT \", \"broker (Mosquitto) running on port 1883.\\n\\nOn the other end, the TrafficControl service uses the MQTT\", \" input binding to receive VehicleRegistered messages sent by the CameraSimulation. For each subscrib\", \"ed topic, there\\u2019s a\\n\\n79\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\nseparate component configurat\", \"ion file in the /dapr/components folder. The first one is entrycam.yaml:\\n\\napiVersion: dapr.io/v1alph\", \"a1 kind: Component metadata: name: entrycam namespace: dapr-trafficcontrol spec: type: bindings.mqtt\", \" version: v1 metadata: - name: url value: mqtt://localhost:1883 - name: topic value: trafficcontrol/\", \"entrycam scopes: - trafficcontrolservice\\n\\nThe configuration specifies the binding type: bindings.mqt\", \"t. It also specifies that the broker runs on localhost:1883, the standard port that Mosquitto uses. \", \"It also exposes the topic, trafficcontrol/entrycam. Using scopes, the config file specifies that onl\", \"y the service with app-id trafficcontrolservice will have access to the binding.\\n\\nWhen the TrafficCo\", \"ntrol service starts, the Dapr sidecar automatically subscribes to the trafficcontrol/entrycam MQTT \", \"topic specified in the component configuration. When messages arrive on the topic, the Dapr sidecar \", \"invokes an HTTP endpoint on your service. The sidecar determines the URL of the HTTP endpoint to cal\", \"l by looking at the metadata.name field in the binding configuration. In the example above, the endp\", \"oint URL is /entrycam. Within the TrafficControl service, no code needs to be added to support the e\", \"ndpoint:\\n\\n[HttpPost(\\\"entrycam\\\")] public async Task<ActionResult> VehicleEntry(VehicleRegistered msg)\", \" { // ... }\\n\\nThe exitcam.yaml component configuration file configures everything for the exitcam end\", \"point:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: exitcam namespace: dapr-traffic\", \"control spec: type: bindings.mqtt version: v1 metadata: - name: url value: mqtt://localhost:1883 - n\", \"ame: topic value: trafficcontrol/exitcam scopes: - trafficcontrolservice\\n\\n80\\n\\nCHAPTER 9 | The Dapr b\", \"indings building block\\n\\nSMTP output binding\\n\\nThe FineCollection service uses the Dapr SMTP output bi\", \"nding to send emails. Figure 8-5 shows the conceptual architecture of the Dapr Traffic Control sampl\", \"e application. The Dapr input binding is used in flows marked with number 4 in the diagram:\\n\\nFigure \", \"8-5. Conceptual architecture of the Dapr Traffic Control sample application.\\n\\nThe CollectFine method\", \" on the CollectionController in the FineCollection service contains code that uses the Dapr client t\", \"o invoke the output binding:\\n\\n// ...\\n\\n// send fine by email (Dapr output binding) var body = EmailUt\", \"ils.CreateEmailBody(speedingViolation, vehicleInfo, fineString); var metadata = new Dictionary<strin\", \"g, string> { [\\\"emailFrom\\\"] = \\\"noreply@cfca.gov\\\", [\\\"emailTo\\\"] = vehicleInfo.OwnerEmail,\\n\\n81\\n\\nCHAPTER \", \"9 | The Dapr bindings building block\\n\\n[\\\"subject\\\"] = $\\\"Speeding violation on the {speedingViolation.R\", \"oadId}\\\" }; await daprClient.InvokeBindingAsync(\\\"sendmail\\\", \\\"create\\\", body, metadata);\\n\\n// ...\\n\\nThe c\", \"ode uses a simple utility class to create an HTML email body containing the necessary information. I\", \"t also creates a dictionary with metadata specific to the SMTP binding. This binding component inter\", \"prets the metadata when invoked.\\n\\nThe following arguments are required to invoke the binding:\\n\\n\\n\\nThe\", \" name of the binding component. In this case sendmail.\\n\\n\\n\\nThe operation the binding needs to perform\", \". In this case create.\\n\\n\\n\\nThe body of the message to send. In this case, the HTML email body.\\n\\n\\n\\nThe\", \" metadata for sending the email.\\n\\nThe Dapr output binding named sendmail is configured in the email.\", \"yaml component configuration file in the /dapr/components folder:\\n\\napiVersion: dapr.io/v1alpha1 kind\", \": Component metadata: name: sendmail namespace: dapr-trafficcontrol spec: type: bindings.smtp versio\", \"n: v1 metadata: - name: host value: localhost - name: port value: 4025 - name: user secretKeyRef: na\", \"me: smtp.user key: smtp.user - name: password secretKeyRef: name: smtp.password key: smtp.password -\", \" name: skipTLSVerify value: true auth: secretStore: trafficcontrol-secrets scopes: - finecollections\", \"ervice\\n\\nThe configuration specifies the binding type: bindings.smtp.\\n\\nThe metadata section contains \", \"the information for connecting to the SMTP server. See the binding\\u2019s documentation for specific meta\", \"data required for this binding. The username and password to connect to the SMTP server are retrieve\", \"d from a secrets store. See the Secrets management building block chapter for more information on ho\", \"w this works.\\n\\nThe scopes element specifies that only the service with app-id finecollectonservice c\", \"an access this binding.\\n\\n82\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\nThe Traffic Control sampl\", \"e application uses MailDev. MailDev is a development SMTP server that doesn\\u2019t actually send out emai\", \"ls (by default). Instead, it collects emails and presents them in an inbox web application. MailDev \", \"is extremely useful for dev/test and demo scenarios.\\n\\nUsing Dapr bindings in the Traffic Control sam\", \"ple application provides the following benefits:\\n\\n1. Using MQTT messaging and SMTP without the need \", \"to learn this protocol or a specific MQTT\\n\\nAPI.\\n\\n2. Using SMTP to send an email without the need to \", \"learn this protocol or a specific SMTP API.\\n\\nSummary\\n\\nDapr resource bindings enable you to integrate\", \" with different external resources and systems without taking dependencies on their libraries or SDK\", \"s. These external systems don\\u2019t necessarily have to be messaging systems like a service bus or messa\", \"ge broker. Bindings also exist for datastores and web resources like Twitter or SendGrid.\\n\\nInput bin\", \"dings (or triggers) react to events occurring in an external system. They invoke the public HTTP end\", \"points pre-configured in your application. Dapr uses the name of the binding in the configuration to\", \" determine the endpoint to call in your application.\\n\\nOutput bindings will send messages to an exter\", \"nal system. You trigger an output binding by doing an HTTP POST on the /v1.0/bindings/<binding-name>\", \" endpoint on the Dapr sidecar. You can also use gRPC to invoke the binding. The .NET SDK offers a In\", \"vokeBindingAsync method to invoke Dapr bindings using gRPC.\\n\\nYou implement a binding with a Dapr com\", \"ponent. These components are contributed by the community. Each binding component\\u2019s configuration ha\", \"s metadata that is specific for the external system it abstracts. Also, the commands it supports and\", \" the structure of the payload will differ per binding component.\\n\\nReferences\\n\\n\\n\\nDapr documentation f\", \"or resource bindings\\n\\nMosquitto MQTT broker\\n\\nMailDev development SMTP server\\n\\n83\\n\\nCHAPTER 9 | The Da\", \"pr bindings building block\\n\\nCHAPTER 10\\n\\nThe Dapr actors building block\\n\\nThe actor model originated i\", \"n 1973. It was proposed by Carl Hewitt as a conceptual model of concurrent computation, a form of co\", \"mputing in which several computations are executed at the same time. Highly parallel computers weren\", \"\\u2019t yet available at that time, but the more recent advancements of multi-core CPUs and distributed s\", \"ystems have made the actor model popular.\\n\\nIn the actor model, the actor is an independent unit of c\", \"ompute and state. Actors are completely isolated from each other and they will never share memory. A\", \"ctors communicate with each other using messages. When an actor receives a message, it can change it\", \"s internal state, and send messages to other (possibly new) actors.\\n\\nThe reason why the actor model \", \"makes writing concurrent systems easier is that it provides a turn- based (or single-threaded) acces\", \"s model. Multiple actors can run at the same time, but each actor will process received messages one\", \" at a time. This means that you can be sure that at most one thread is active inside an actor at any\", \" time. That makes writing correct concurrent and parallel systems much easier.\\n\\nWhat it solves\\n\\nActo\", \"r model implementations are usually tied to a specific language or platform. With the Dapr actors bu\", \"ilding block however, you can leverage the actor model from any language or platform.\\n\\nDapr\\u2019s implem\", \"entation is based on the virtual actor pattern introduced by Project \\u201cOrleans\\u201d. With the virtual act\", \"or pattern, you don\\u2019t need to explicitly create actors. Actors are activated implicitly and placed o\", \"n a node in the cluster the first time a message is sent to the actor. When not executing operations\", \", actors are silently unloaded from memory. If a node fails, Dapr automatically moves activated acto\", \"rs to healthy nodes. Besides sending messages between actors, the Dapr actor model also support sche\", \"duling future work using timers and reminders.\\n\\nWhile the actor model can provide great benefits, it\", \"\\u2019s important to carefully consider the actor design. For example, having many clients call the same \", \"actor will result in poor performance because the actor operations execute serially. Here are some c\", \"riteria to check if a scenario is a good fit for Dapr actors:\\n\\n\\n\\nYour problem space involves concurr\", \"ency. Without actors, you\\u2019d have to introduce explicit locking mechanisms in your code.\\n\\n84\\n\\nCHAPTER\", \" 10 | The Dapr actors building block\\n\\n\\n\\nYour problem space can be partitioned into small, independen\", \"t, and isolated units of state and logic.\\n\\n\\n\\nYou don\\u2019t need low-latency reads of the actor state. Lo\", \"w-latency reads cannot be guaranteed because actor operations execute serially.\\n\\n\\n\\nYou don\\u2019t need to\", \" query state across a set of actors. Querying across actors is inefficient because each actor\\u2019s stat\", \"e needs to be read individually and can introduce unpredictable latencies.\\n\\nOne design pattern that \", \"fits these criteria quite well is the orchestration-based saga or process manager design pattern. A \", \"saga manages a sequence of steps that must be taken to reach some outcome. The saga (or process mana\", \"ger) maintains the current state of the sequence and triggers the next step. If a step fails, the sa\", \"ga can execute compensating actions. Actors make it easy to deal with concurrency in the saga and to\", \" keep track of the current state. The eShopOnDapr reference application uses the saga pattern and Da\", \"pr actors to implement the Ordering process.\\n\\nHow it works\\n\\nThe Dapr sidecar provides the HTTP/gRPC \", \"API to invoke actors. This is the base URL of the HTTP API:\\n\\nhttp://localhost:<daprPort>/v1.0/actors\", \"/<actorType>/<actorId>/\\n\\n\\n\\n<daprPort>: the HTTP port that Dapr listens on.\\n\\n\\n\\n<actorType>: the actor\", \" type.\\n\\n\\n\\n<actorId>: the ID of the specific actor to call.\\n\\nThe sidecar manages how, when and where \", \"each actor runs, and also routes messages between actors. When an actor hasn\\u2019t been used for a perio\", \"d of time, the runtime deactivates the actor and removes it from memory. Any state managed by the ac\", \"tor is persisted and will be available when the actor re-activates. Dapr uses an idle timer to deter\", \"mine when an actor can be deactivated. When an operation is called on the actor (either by a method \", \"call or a reminder firing), the idle timer is reset and the actor instance will remain activated.\\n\\nT\", \"he sidecar API is only one part of the equation. The service itself also needs to implement an API s\", \"pecification, because the actual code that you write for the actor will run inside the service itsel\", \"f. Figure 11-1 shows the various API calls between the service and its sidecar:\\n\\n85\\n\\nCHAPTER 10 | Th\", \"e Dapr actors building block\\n\\nFigure 11-1. API calls between actor service and Dapr sidecar.\\n\\nTo pro\", \"vide scalability and reliability, actors are partitioned across all the instances of the actor servi\", \"ce. The Dapr placement service is responsible for keeping track of the partitioning information. Whe\", \"n a new instance of an actor service is started, the sidecar registers the supported actor types wit\", \"h the placement service. The placement service calculates the updated partitioning information for t\", \"he given actor type and broadcasts it to all instances. Figure 11-2 shows what happens when a servic\", \"e is scaled out to a second replica:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/actors/placement.png\\u201d \", \"alt-text=\\u201cDiagram of the actor placement service.\\u201d:::\\n\\nFigure 11-2. Actor placement service.\\n\\n1. On \", \"startup, the sidecar makes a call to the actor service to get the registered actor types as well\\n\\nas\", \" actor configuration settings.\\n\\n2.\\n\\nThe sidecar sends the list of registered actor types to the plac\", \"ement service.\\n\\n3.\\n\\nThe placement service broadcasts the updated partitioning information to all act\", \"or service instances. Each instance will keep a cached copy of the partitioning information and use \", \"it to invoke actors.\\n\\nImportant\\n\\nBecause actors are randomly distributed across service instances, i\", \"t should be expected that an actor operation always requires a call to a different node in the netwo\", \"rk.\\n\\n86\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\nThe next figure shows an ordering service inst\", \"ance running in Pod 1 call the ship method of an OrderActor instance with ID 3. Because the actor wi\", \"th ID 3 is placed in a different instance, this results in a call to a different node in the cluster\", \":\\n\\nFigure 11-3. Calling an actor method.\\n\\n1.\\n\\nThe service calls the actor API on the sidecar. The JS\", \"ON payload in the request body contains the data to send to the actor.\\n\\n2.\\n\\nThe sidecar uses the loc\", \"ally cached partitioning information from the placement service to determine which actor service ins\", \"tance (partition) is responsible for hosting the actor with ID 3. In this example, it\\u2019s the service \", \"instance in pod 2. The call is forwarded to the appropriate sidecar.\\n\\n3.\\n\\nThe sidecar instance in po\", \"d 2 calls the service instance to invoke the actor. The service instance activates the actor (if it \", \"hasn\\u2019t already) and executes the actor method.\\n\\n87\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\nTur\", \"n-based access model\\n\\nThe turn-based access model ensures that at any time there\\u2019s at most one threa\", \"d active inside an actor instance. To understand why this is useful, consider the following example \", \"of a method that increments a counter value:\\n\\npublic int Increment() { var currentValue = GetValue()\", \"; var newValue = currentValue + 1;\\n\\nSaveValue(newValue);\\n\\nreturn newValue; }\\n\\nLet\\u2019s assume that the \", \"current value returned by the GetValue method is 1. When two threads call the Increment method at th\", \"e same time, there\\u2019s a risk of both of them calling the GetValue method before one of them calls Sav\", \"eValue. This results in both threads starting with the same initial value (1). The threads then incr\", \"ement the value to 2 and return it to the caller. The resulting value after the two calls is now 2 i\", \"nstead of 3 which it should be. This is a simple example to illustrate the kind of issues that can s\", \"lip into your code when working with multiple threads, and is easy to solve. In real world applicati\", \"ons however, concurrent and parallel scenarios can become very complex.\\n\\nIn traditional programming \", \"models, you can solve this problem by introducing locking mechanisms. For example:\\n\\npublic int Incre\", \"ment() { int newValue;\\n\\nlock (_lockObject) { var currentValue = GetValue(); newValue = currentValue \", \"+ 1;\\n\\nSaveValue(newValue); }\\n\\nreturn newValue; }\\n\\nUnfortunately, using explicit locking mechanisms i\", \"s error-prone. They can easily lead to deadlocks and can have serious impact on performance.\\n\\nThanks\", \" to the turn-based access model, you don\\u2019t need to worry about multiple threads with actors, making \", \"it much easier to write concurrent systems. The following actor example closely mirrors the code fro\", \"m the previous sample, but doesn\\u2019t require any locking mechanisms to be correct:\\n\\npublic async Task<\", \"int> IncrementAsync() { var counterValue = await StateManager.TryGetStateAsync<int>(\\\"counter\\\");\\n\\nvar\", \" currentValue = counterValue.HasValue ? counterValue.Value : 0; var newValue = currentValue + 1;\\n\\n88\", \"\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\nawait StateManager.SetStateAsync(\\\"counter\\\", newValue)\", \";\\n\\nreturn newValue; }\\n\\nTimers and reminders\\n\\nActors can use timers and reminders to schedule calls t\", \"o themselves. Both concepts support the configuration of a due time. The difference lies in the life\", \"time of the callback registrations:\\n\\n\\n\\nTimers will only stay active as long as the actor is activate\", \"d. Timers will not reset the idle-timer, so they cannot keep an actor active on their own.\\n\\n\\n\\nRemind\", \"ers outlive actor activations. If an actor is deactivated, a reminder will re-activate the actor. Re\", \"minders will reset the idle-timer.\\n\\nTimers are registered by making a call to the actor API. In the \", \"following example, a timer is registered with a due time of 0 and a period of 10 seconds.\\n\\ncurl -X P\", \"OST http://localhost:3500/v1.0/actors/<actorType>/<actorId>/timers/<name> \\\\ -H \\\"Content-Type: applic\", \"ation/json\\\" \\\\ -d '{ \\\"dueTime\\\": \\\"0h0m0s0ms\\\", \\\"period\\\": \\\"0h0m10s0ms\\\" }'\\n\\nBecause the due time is 0, th\", \"e timer will fire immediately. After a timer callback has finished, the timer will wait 10 seconds b\", \"efore firing again.\\n\\nReminders are registered in a similar way. The following example shows a remind\", \"er registration with a due time of 5 minutes, and an empty period:\\n\\ncurl -X POST http://localhost:35\", \"00/v1.0/actors/<actorType>/<actorId>/reminders/<name> \\\\ -H \\\"Content-Type: application/json\\\" \\\\ -d '{ \", \"\\\"dueTime\\\": \\\"0h5m0s0ms\\\", \\\"period\\\": \\\"\\\" }'\\n\\nThis reminder will fire in 5 minutes. Because the given per\", \"iod is empty, this will be a one-time reminder.\\n\\nNote\\n\\nTimers and reminders both respect the turn-ba\", \"sed access model. When a timer or reminder fires, the callback will not be executed until any other \", \"method invocation or timer/reminder callback has finished.\\n\\nState persistence\\n\\nActor state is persis\", \"ted using the Dapr state management building block. Because actors can execute multiple state operat\", \"ions in a single turn, the state store component must support multi-item transactions. At the time o\", \"f writing, the following state stores support multi-item transactions:\\n\\n89\\n\\nCHAPTER 10 | The Dapr ac\", \"tors building block\\n\\n\\n\\nAzure Cosmos DB\\n\\nMongoDB\\n\\nMySQL\\n\\n\\n\\nPostgreSQL\\n\\n\\n\\nRedis\\n\\n\\n\\nRethinkDB\\n\\n\\n\\nSQL Se\", \"rver\\n\\nTo configure a state store component for use with actors, you need to append the following met\", \"adata to the state store configuration:\\n\\nname: actorStateStore value: \\\"true\\\"\\n\\nHere\\u2019s a complete exam\", \"ple for a Redis state store:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestor\", \"e spec: type: state.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: redi\", \"sPassword value: \\\"\\\" - name: actorStateStore value: \\\"true\\\"\\n\\nUse the Dapr .NET SDK\\n\\nYou can create an \", \"actor model implementation using only HTTP/gRPC calls. However, it\\u2019s much more convenient to use the\", \" language specific Dapr SDKs. At the time of writing, the .NET, Java and Python SDKs all provide ext\", \"ensive support for working with actors.\\n\\nTo get started with the .NET Dapr actors SDK, you add a pac\", \"kage reference to Dapr.Actors to your service project. The first step of creating an actual actor is\", \" to define an interface that derives from IActor. Clients use the interface to invoke operations on \", \"the actor. Here\\u2019s a simple example of an actor interface for keeping scores:\\n\\npublic interface IScor\", \"eActor : IActor { Task<int> IncrementScoreAsync();\\n\\nTask<int> GetScoreAsync(); }\\n\\n90\\n\\nCHAPTER 10 | T\", \"he Dapr actors building block\\n\\nImportant\\n\\nThe return type of an actor method must be Task or Task<T>\", \". Also, actor methods can have at most one argument. Both the return type and the arguments must be \", \"System.Text.Json serializable.\\n\\nNext, implement the actor by deriving a ScoreActor class from Actor.\", \" The ScoreActor class must also implement the IScoreActor interface:\\n\\npublic class ScoreActor : Acto\", \"r, IScoreActor { public ScoreActor(ActorHost host) : base(host) { }\\n\\n// TODO Implement interface met\", \"hods. }\\n\\nThe constructor in the snippet above takes a host argument of type ActorHost. The ActorHost\", \" class represents the host for an actor type within the actor runtime. You need to pass this argumen\", \"t to the constructor of the Actor base class. Actors also support dependency injection. Any addition\", \"al arguments that you add to the actor constructor are resolved using the .NET dependency injection \", \"container.\\n\\nLet\\u2019s now implement the IncrementScoreAsync method of the interface:\\n\\npublic Task<int> I\", \"ncrementScoreAsync() { return StateManager.AddOrUpdateStateAsync( \\\"score\\\", 1, (key, currentScore) =>\", \" currentScore + 1 ); }\\n\\nIn the snippet above, a single call to StateManager.AddOrUpdateStateAsync pr\", \"ovides the full implementation for the IncrementScoreAsync method. The AddOrUpdateStateAsync method \", \"takes three arguments:\\n\\n1.\\n\\nThe key of the state to update.\\n\\n2.\\n\\nThe value to write if no score is s\", \"tored in the state store yet.\\n\\n3.\\n\\nA Func to call if there already is a score stored in the state st\", \"ore. It takes the state key and current score, and returns the updated score to write back to the st\", \"ate store.\\n\\nThe GetScoreAsync implementation reads the current score from the state store and return\", \"s it to the client:\\n\\npublic async Task<int> GetScoreAsync() { var scoreValue = await StateManager.Tr\", \"yGetStateAsync<int>(\\\"score\\\"); if (scoreValue.HasValue) { return scoreValue.Value; }\\n\\n91\\n\\nCHAPTER 10 \", \"| The Dapr actors building block\\n\\nreturn 0; }\\n\\nTo host actors in an ASP.NET Core service, you must a\", \"dd a reference to the Dapr.Actors.AspNetCore package and make some changes in the Program file. In t\", \"he following example, the call to MapActorsHandlers registers Dapr Actor endpoints in ASP.NET Core r\", \"outing:\\n\\nvar builder = WebApplication.CreateBuilder(args); var app = builder.Build(); // Actors buil\", \"ding block does not support HTTPS redirection. //app.UseHttpsRedirection(); app.MapControllers(); //\", \" Add actor endpoints. app.MapActorsHandlers();\\n\\nThe actors endpoints are necessary because the Dapr \", \"sidecar calls the application to host and interact with actor instances.\\n\\nImportant\\n\\nMake sure your \", \"Program (or Startup) class does not contain an app.UseHttpsRedirection call to redirect clients to t\", \"he HTTPS endpoint. This will not work with actors. By design, a Dapr sidecar sends requests over une\", \"ncrypted HTTP by default. The HTTPS middleware will block these requests when enabled.\\n\\nThe Program \", \"file is also the place to register the specific actor types. The following example registers the Sco\", \"reActor using the AddActors extension method:\\n\\nvar builder = WebApplication.CreateBuilder(args); bui\", \"lder.Services.AddActors(options => { options.Actors.RegisterActor<ScoreActor>(); });\\n\\nAt this point,\", \" the ASP.NET Core service is ready to host the ScoreActor and accept incoming requests. Client appli\", \"cations use actor proxies to invoke operations on actors. The following example shows how a console \", \"client application invokes the IncrementScoreAsync operation on a ScoreActor instance:\\n\\nvar actorId \", \"= new ActorId(\\\"scoreActor1\\\");\\n\\nvar proxy = ActorProxy.Create<IScoreActor>(actorId, \\\"ScoreActor\\\");\\n\\nv\", \"ar score = await proxy.IncrementScoreAsync();\\n\\nConsole.WriteLine($\\\"Current score: {score}\\\");\\n\\nThe ab\", \"ove example uses the Dapr.Actors package to call the actor service. To invoke an operation on an act\", \"or, you need to be able to address it. You\\u2019ll need two parts for this:\\n\\n1.\\n\\nThe actor type uniquely \", \"identifies the actor implementation across the whole application. By default, the actor type is the \", \"name of the implementation class (without namespace). You can customize the actor type by adding an \", \"ActorAttribute to the implementation class and setting its TypeName property.\\n\\n92\\n\\nCHAPTER 10 | The \", \"Dapr actors building block\\n\\n2.\\n\\nThe ActorId uniquely identifies an instance of an actor type. You ca\", \"n also use this class to generate a random actor id by calling ActorId.CreateRandom.\\n\\nThe example us\", \"es ActorProxy.Create to create a proxy instance for the ScoreActor. The Create method takes two argu\", \"ments: the ActorId identifying the specific actor and the actor type. It also has a generic type par\", \"ameter to specify the actor interface that the actor type implements. As both the server and client \", \"applications need to use the actor interfaces, they\\u2019re typically stored in a separate shared project\", \".\\n\\nThe final step in the example calls the IncrementScoreAsync method on the actor and outputs the r\", \"esult. Remember that the Dapr placement service distributes the actor instances across the Dapr side\", \"cars. Therefore, expect an actor call to be a network call to another node.\\n\\nCall actors from ASP.NE\", \"T Core clients\\n\\nThe console client example in the previous section uses the static ActorProxy.Create\", \" method directly to get an actor proxy instance. If the client application is an ASP.NET Core applic\", \"ation, you should use the IActorProxyFactory interface to create actor proxies. The main benefit is \", \"that it allows you to manage configuration in one place. The AddActors extension method on IServiceC\", \"ollection takes a delegate that allows you to specify actor runtime options, such as the HTTP endpoi\", \"nt of the Dapr sidecar. The following example specifies custom JsonSerializerOptions to use for acto\", \"r state persistence and message deserialization:\\n\\nvar builder = WebApplication.CreateBuilder(args); \", \"builder.Services.AddActors(options => { var jsonSerializerOptions = new JsonSerializerOptions() { Pr\", \"opertyNamingPolicy = JsonNamingPolicy.CamelCase, PropertyNameCaseInsensitive = true };\\n\\noptions.Json\", \"SerializerOptions = jsonSerializerOptions; options.Actors.RegisterActor<ScoreActor>(); });\\n\\nThe call\", \" to AddActors registers the IActorProxyFactory for .NET dependency injection. This allows ASP.NET Co\", \"re to inject an IActorProxyFactory instance into your controller classes. The following example call\", \"s an actor method from an ASP.NET Core controller class:\\n\\n[ApiController] [Route(\\\"[controller]\\\")] pu\", \"blic class ScoreController : ControllerBase { private readonly IActorProxyFactory _actorProxyFactory\", \";\\n\\npublic ScoreController(IActorProxyFactory actorProxyFactory) { _actorProxyFactory = actorProxyFac\", \"tory; }\\n\\n[HttpPut(\\\"{scoreId}\\\")] public Task<int> IncrementAsync(string scoreId) {\\n\\n93\\n\\nCHAPTER 10 | \", \"The Dapr actors building block\\n\\nvar scoreActor = _actorProxyFactory.CreateActorProxy<IScoreActor>( n\", \"ew ActorId(scoreId), \\\"ScoreActor\\\");\\n\\nreturn scoreActor.IncrementScoreAsync(); } }\\n\\nActors can also c\", \"all other actors directly. The Actor base class exposes an IActorProxyFactory class through the Prox\", \"yFactory property. To create an actor proxy from within an actor, use the ProxyFactory property of t\", \"he Actor base class. The following example shows an OrderActor that invokes operations on two other \", \"actors:\\n\\npublic class OrderActor : Actor, IOrderActor { public OrderActor(ActorHost host) : base(hos\", \"t) { }\\n\\npublic async Task ProcessOrderAsync(Order order) { var stockActor = ProxyFactory.CreateActor\", \"Proxy<IStockActor>( new ActorId(order.OrderNumber), \\\"StockActor\\\");\\n\\nawait stockActor.ReserveStockAsy\", \"nc(order.OrderLines);\\n\\nvar paymentActor = ProxyFactory.CreateActorProxy<IPaymentActor>( new ActorId(\", \"order.OrderNumber), \\\"PaymentActor\\\");\\n\\nawait paymentActor.ProcessPaymentAsync(order.PaymentDetails); \", \"} }\\n\\nNote\\n\\nBy default, Dapr actors aren\\u2019t reentrant. This means that a Dapr actor cannot be called m\", \"ore than once in the same chain. For example, the call chain Actor A -> Actor B -> Actor A is not al\", \"lowed. At the time of writing, there\\u2019s a preview feature available to support reentrancy. However, t\", \"here is no SDK support yet. For more details, see the official documentation.\\n\\nCall non-.NET actors\\n\", \"\\nSo far, the examples used strongly-typed actor proxies based on .NET interfaces to illustrate actor\", \" invocations. This works great when both the actor host and client are .NET applications. However, i\", \"f the actor host is not a .NET application, you don\\u2019t have an actor interface to create a strongly-t\", \"yped proxy. In these cases, you can use a weakly-typed proxy.\\n\\nYou create weakly-typed proxies in a \", \"similar way to strongly-typed proxies. Instead of relying on a .NET interface, you need to pass in t\", \"he actor method name as a string.\\n\\n[HttpPut(\\\"{scoreId}\\\")] public Task<int> IncrementAsync(string sco\", \"reId)\\n\\n94\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n{ var scoreActor = _actorProxyFactory.Create\", \"ActorProxy( new ActorId(scoreId), \\\"ScoreActor\\\");\\n\\nreturn scoreActor(\\\"IncrementScoreAsync\\\"); }\\n\\nTimer\", \"s and reminders\\n\\nUse the RegisterTimerAsync method of the Actor base class to schedule actor timers.\", \" In the following example, a TimerActor exposes a StartTimerAsync method. Clients can call the metho\", \"d to start a timer that repeatedly writes a given text to the log output.\\n\\npublic class TimerActor :\", \" Actor, ITimerActor { public TimerActor(ActorHost host) : base(host) { }\\n\\npublic Task StartTimerAsyn\", \"c(string name, string text) { return RegisterTimerAsync( name, nameof(TimerCallback), Encoding.UTF8.\", \"GetBytes(text), TimeSpan.Zero, TimeSpan.FromSeconds(3)); }\\n\\npublic Task TimerCallbackAsync(byte[] st\", \"ate) { var text = Encoding.UTF8.GetString(state);\\n\\nLogger.LogInformation($\\\"Timer fired: {text}\\\");\\n\\nr\", \"eturn Task.CompletedTask; } }\\n\\nThe StartTimerAsync method calls RegisterTimerAsync to schedule the t\", \"imer. RegisterTimerAsync takes five arguments:\\n\\n1.\\n\\nThe name of the timer.\\n\\n2.\\n\\nThe name of the meth\", \"od to call when the timer fires.\\n\\n3.\\n\\nThe state to pass to the callback method.\\n\\n4.\\n\\nThe amount of t\", \"ime to wait before the callback method is first invoked.\\n\\n5.\\n\\nThe time interval between callback met\", \"hod invocations. You can specify TimeSpan.FromMilliseconds(-1) to disable periodic signaling.\\n\\nThe T\", \"imerCallbackAsync method receives the user state in binary form. In the example, the callback decode\", \"s the state back to a string before writing it to the log.\\n\\nTimers can be stopped by calling Unregis\", \"terTimerAsync:\\n\\n95\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\npublic class TimerActor : Actor, IT\", \"imerActor { // ...\\n\\npublic Task StopTimerAsync(string name) { return UnregisterTimerAsync(name); } }\", \"\\n\\nRemember that timers do not reset the actor idle timer. When no other calls are made on the actor,\", \" it may be deactivated and the timer will be stopped automatically. To schedule work that does reset\", \" the idle timer, use reminders which we\\u2019ll look at next.\\n\\nTo use reminders in an actor, your actor c\", \"lass must implement the IRemindable interface:\\n\\npublic interface IRemindable { Task ReceiveReminderA\", \"sync( string reminderName, byte[] state, TimeSpan dueTime, TimeSpan period); }\\n\\nThe ReceiveReminderA\", \"sync method is called when a reminder is fired. It takes 4 arguments:\\n\\n1.\\n\\nThe name of the reminder.\", \"\\n\\n2.\\n\\nThe user state provided during registration.\\n\\n3.\\n\\nThe invocation due time provided during regi\", \"stration.\\n\\n4.\\n\\nThe invocation period provided during registration.\\n\\nTo register a reminder, use the \", \"RegisterReminderAsync method of the actor base class. The following example sets a reminder to fire \", \"a single time with a due time of three minutes.\\n\\npublic class ReminderActor : Actor, IReminderActor,\", \" IRemindable { public ReminderActor(ActorHost host) : base(host) { }\\n\\npublic Task SetReminderAsync(s\", \"tring text) { return RegisterReminderAsync( \\\"DoNotForget\\\", Encoding.UTF8.GetBytes(text), TimeSpan.Fr\", \"omSeconds(3), TimeSpan.FromMilliseconds(-1)); }\\n\\npublic Task ReceiveReminderAsync( string reminderNa\", \"me, byte[] state, TimeSpan dueTime, TimeSpan period) { if (reminderName == \\\"DoNotForget\\\") { var text\", \" = Encoding.UTF8.GetString(state);\\n\\nLogger.LogInformation($\\\"Don't forget: {text}\\\");\\n\\n96\\n\\nCHAPTER 10 \", \"| The Dapr actors building block\\n\\n}\\n\\nreturn Task.CompletedTask; } }\\n\\nThe RegisterReminderAsync metho\", \"d is similar to RegisterTimerAsync but you don\\u2019t have to specify a callback method explicitly. As th\", \"e above example shows, you implement IRemindable.ReceiveReminderAsync to handle fired reminders.\\n\\nRe\", \"minders both reset the idle timer and are persistent. Even if your actor is deactivated, it will be \", \"reactivated at the moment a reminder fires. To stop a reminder from firing, call UnregisterReminderA\", \"sync.\\n\\nSample application: Dapr Traffic Control\\n\\nThe default version of Dapr Traffic Control does no\", \"t use the actor model. However, it does contain an alternative actor-based implementation of the Tra\", \"fficControl service that you can enable. To make use of actors in the TrafficControl service, open u\", \"p the src/TrafficControlService/Controllers/TrafficController.cs file and uncomment the USE_ACTORMOD\", \"EL statement at the top of the file:\\n\\n#define USE_ACTORMODEL\\n\\nWhen the actor model is enabled, the a\", \"pplication uses actors to represent vehicles. The operations that can be invoked on the vehicle acto\", \"rs are defined in an IVehicleActor interface:\\n\\npublic interface IVehicleActor : IActor { Task Regist\", \"erEntryAsync(VehicleRegistered msg); Task RegisterExitAsync(VehicleRegistered msg); }\\n\\nThe (simulate\", \"d) entry cameras call the RegisterEntryAsync method when a new vehicle is first detected in the lane\", \". The only responsibility of this method is storing the entry timestamp in the actor state:\\n\\nvar veh\", \"icleState = new VehicleState { LicenseNumber = msg.LicenseNumber, EntryTimestamp = msg.Timestamp }; \", \"await StateManager.SetStateAsync(\\\"VehicleState\\\", vehicleState);\\n\\nWhen the vehicle reaches the end of\", \" the speed camera zone, the exit camera calls the RegisterExitAsync method. The RegisterExitAsync me\", \"thod first gets the current states and updates it to include the exit timestamp:\\n\\nvar vehicleState =\", \" await StateManager.GetStateAsync<VehicleState>(\\\"VehicleState\\\"); vehicleState.ExitTimestamp = msg.Ti\", \"mestamp;\\n\\n97\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\nNote\\n\\nThe code above currently assumes th\", \"at a VehicleState instance has already been saved by the RegisterEntryAsync method. The code could b\", \"e improved by first checking to make sure the state exists. Thanks to the turn-based access model, n\", \"o explicit locks are required in the code.\\n\\nAfter the state is updated, the RegisterExitAsync method\", \" checks if the vehicle was driving too fast. If it was, the actor publishes a message to the collect\", \"fine pub/sub topic:\\n\\nint violation = _speedingViolationCalculator.DetermineSpeedingViolationInKmh( v\", \"ehicleState.EntryTimestamp, vehicleState.ExitTimestamp);\\n\\nif (violation > 0) { var speedingViolation\", \" = new SpeedingViolation { VehicleId = msg.LicenseNumber, RoadId = _roadId, ViolationInKmh = violati\", \"on, Timestamp = msg.Timestamp };\\n\\nawait _daprClient.PublishEventAsync(\\\"pubsub\\\", \\\"collectfine\\\", speed\", \"ingViolation); }\\n\\nThe code above uses two external dependencies. The _speedingViolationCalculator en\", \"capsulates the business logic for determining whether or not a vehicle has driven too fast. The _dap\", \"rClient allows the actor to publish messages using the Dapr pub/sub building block.\\n\\nBoth dependenci\", \"es are registered in the Program.cs class and injected into the actor using constructor dependency i\", \"njection:\\n\\nprivate readonly DaprClient _daprClient; private readonly ISpeedingViolationCalculator _s\", \"peedingViolationCalculator; private readonly string _roadId;\\n\\npublic VehicleActor( ActorHost host, D\", \"aprClient daprClient, ISpeedingViolationCalculator speedingViolationCalculator) : base(host) { _dapr\", \"Client = daprClient; _speedingViolationCalculator = speedingViolationCalculator; _roadId = _speeding\", \"ViolationCalculator.GetRoadId(); }\\n\\nThe actor based implementation no longer uses the Dapr state man\", \"agement building block directly. Instead, the state is automatically persisted after each operation \", \"is executed.\\n\\nSummary\\n\\nThe Dapr actors building block makes it easier to write correct concurrent sy\", \"stems. Actors are small units of state and logic. They use a turn-based access model which saves you\", \" from having to use locking mechanisms to write thread-safe code. Actors are created implicitly and \", \"are silently unloaded\\n\\n98\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\nfrom memory when no operatio\", \"ns are performed. Any state stored in the actor is automatically persisted and loaded when the actor\", \" is reactivated. Actor model implementations are typically created for a specific language or platfo\", \"rm. With the Dapr actors building block however, you can leverage the actor model from any language \", \"or platform.\\n\\nActors support timers and reminders to schedule future work. Timers do not reset the i\", \"dle timer and will allow the actor to be deactivated when no other operations are performed. Reminde\", \"rs do reset the idle timer and are also persisted automatically. Both timers and reminders respect t\", \"he turn-based access model, making sure that no other operations can execute while the timer/reminde\", \"r events are handled.\\n\\nActor state is persisted using the Dapr state management building block. Any \", \"state store that supports multi-item transactions can be used to store actor state.\\n\\nReferences\\n\\n\\n\\nD\", \"apr supported state stores\\n\\n99\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\nCHAPTER 11\\n\\nThe Dapr ob\", \"servability building block\\n\\nModern distributed systems are complex. You start with small, loosely co\", \"upled, independently deployable services. These services cross process and server boundaries. They t\", \"hen consume different kinds of infrastructure backing services (databases, message brokers, key vaul\", \"ts). Finally, these disparate pieces compose together to form an application.\\n\\nWith so many separate\", \", moving parts, how do you make sense of what is going on? Unfortunately, legacy monitoring approach\", \"es from the past aren\\u2019t enough. Instead, the system must be observable from end-to-end. Modern obser\", \"vability practices provide visibility and insight into the health of the application at all times. T\", \"hey enable you to infer the internal state by observing the output. Not only is observability mandat\", \"ory for monitoring and troubleshooting distributed applications, it needs to be implemented at the s\", \"tart.\\n\\nThe system information used to gain observability is referred to as telemetry. It can be divi\", \"ded into four broad categories:\\n\\n1. Distributed tracing provides insights into the traffic between s\", \"ervices involved in distributed\\n\\nbusiness transactions.\\n\\n2. Metrics provides insights into the perfo\", \"rmance of a service and its resource consumption.\\n\\n3.\\n\\nLogging provides insights into how code is ex\", \"ecuting and if errors have occurred.\\n\\n4. Health endpoints provide insight into the availability of a\", \" service.\\n\\nThe depth of telemetry is determined by the observability features of an application plat\", \"form. Consider the Azure cloud. It provides a rich telemetry experience that includes all of the tel\", \"emetry categories. With little configuration, Azure IaaS and PaaS services will propagate and publis\", \"h telemetry to the Azure Monitor and Azure Application Insights services. Application Insights prese\", \"nts system logging, tracing, and problem areas with highly visual dashboards. It can even render a d\", \"iagram showing the dependencies between services based on their communication.\\n\\nHowever, what if an \", \"application can\\u2019t use Azure PaaS and IaaS resources? Is it still possible to take advantage of the r\", \"ich telemetry experience of Application Insights? The answer is yes. A non-Azure application can imp\", \"ort libraries, add configuration, and instrument code to emit telemetry to Azure Application Insight\", \"s. However, this approach tightly couples the application to Application Insights. Moving the app to\", \" a different monitoring platform could involve expensive refactoring. Wouldn\\u2019t it be great to avoid \", \"tight coupling and consume observability outside of the code?\\n\\nWith Dapr, you can. Let\\u2019s look at how\", \" Dapr can add observability to our distributed applications.\\n\\n100\\n\\nCHAPTER 11 | The Dapr observabili\", \"ty building block\\n\\nWhat it solves\\n\\nThe Dapr observability building block decouples observability fro\", \"m the application. It automatically captures traffic generated by Dapr sidecars and Dapr system serv\", \"ices that make up the Dapr control plane. The block correlates traffic from a single operation that \", \"spans multiple services. It also exposes performance metrics, resource utilization, and the health o\", \"f the system. Telemetry is published in open-standard formats enabling information to be fed into yo\", \"ur monitoring back end of choice. There, the information can be visualized, queried, and analyzed.\\n\\n\", \"As Dapr abstracts away the plumbing, the application is unaware of how observability is implemented.\", \" There\\u2019s no need to reference libraries or implement custom instrumentation code. Dapr allows the de\", \"veloper to focus on building business logic instead of observability plumbing. Observability is conf\", \"igured at the Dapr system level and is consistent across services, even when created by different te\", \"ams, and built with different technology stacks.\\n\\nHow it works\\n\\nDapr\\u2019s sidecar architecture enables \", \"built-in observability features. As services communicate, Dapr sidecars intercept the traffic and ex\", \"tract tracing, metrics, and logging information. Telemetry is published in an open standards format.\", \" By default, Dapr supports OpenTelemetry and Zipkin.\\n\\nDapr provides collectors that can publish tele\", \"metry to different back-end monitoring tools. These tools present Dapr telemetry for analysis and qu\", \"erying. Figure 10-1 shows the Dapr observability architecture:\\n\\nFigure 10-1. Dapr observability arch\", \"itecture.\\n\\n1.\\n\\nService A calls an operation on Service B. The call is routed from a Dapr sidecar for\", \" Service A to a sidecar for Service B.\\n\\n2. When Service B completes the operation, a response is sen\", \"t back to Service A through the Dapr sidecars. They gather and publish all available telemetry for e\", \"very request and response. 3. The configured collector ingests the telemetry and sends it to the mon\", \"itoring back end.\\n\\n101\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nAs a developer, keep in \", \"mind that adding observability is different from configuring other Dapr building blocks, like pub/su\", \"b or state management. Instead of referencing a building block, you add a collector and a monitoring\", \" back end. Figure 10-1 shows it\\u2019s possible to configure multiple collectors that integrate with diff\", \"erent monitoring back ends.\\n\\nAt the beginning of this chapter, four categories of telemetry were ide\", \"ntified. The following sections will provide detail for each category. They\\u2019ll include instruction o\", \"n how to configure collectors that integrate with popular monitoring back ends.\\n\\nDistributed tracing\", \"\\n\\nDistributed tracing provides insight into traffic that flows across services in a distributed appl\", \"ication. The logs of exchanged request and response messages are a source of invaluable information \", \"for troubleshooting issues. The hard part is correlating messages that belong to the same business t\", \"ransaction.\\n\\nDapr uses the W3C Trace Context to correlate related messages. It injects the same cont\", \"ext information into requests and responses that form a unique operation. Figure 10-2 shows how corr\", \"elation works:\\n\\nNote\\n\\nThe trace context is often referred to as a correlation token in microservice \", \"terminology.\\n\\nFigure 10-2. W3C Trace Context example.\\n\\n1.\\n\\nService A invokes an operation on Service\", \" B. As Service A starts the call, Dapr creates a unique trace context and injects it into the reques\", \"t.\\n\\n2.\\n\\nService B receives the request and invokes an operation on Service C. Dapr detects that the \", \"incoming request contains a trace context and propagates it by injecting it into the outgoing reques\", \"t to Service C.\\n\\n3.\\n\\nService C receives the request and handles it. Dapr detects that the incoming r\", \"equest contains a trace context and propagates it by injecting it into the outgoing response back to\", \" Service B.\\n\\n4.\\n\\nService B receives the response and handles it. It then creates a new response and \", \"propagates the trace context by injecting it into the outgoing response back to Service A.\\n\\nA set of\", \" requests and responses that belong together is called a trace. Figure 10-3 shows a trace:\\n\\n102\\n\\nCHA\", \"PTER 11 | The Dapr observability building block\\n\\nFigure 10-3. Traces and spans.\\n\\nIn the figure, note\", \" how the trace represents a unique application transaction that takes place across many services. A \", \"trace is a collection of spans. Each span represents a single operation or unit of work done within \", \"the trace. Spans are the requests and responses that are sent between services that implement the un\", \"ique transaction.\\n\\nThe next sections discuss how to inspect tracing telemetry by publishing it to a \", \"monitoring back end.\\n\\nUse a Zipkin monitoring back end\\n\\nZipkin is an open-source distributed tracing\", \" system. It can ingest and visualize telemetry data. Dapr offers default support for Zipkin. The fol\", \"lowing example demonstrates how to configure Zipkin to visualize Dapr telemetry.\\n\\nEnable and configu\", \"re tracing\\n\\nTo start, tracing must be enabled for the Dapr runtime using a Dapr configuration file. \", \"Here\\u2019s an example of a configuration file named dapr-config.yaml that enables tracing:\\n\\napiVersion: \", \"dapr.io/v1alpha1 kind: Configuration metadata: name: dapr-config namespace: default spec: tracing: s\", \"amplingRate: \\\"1\\\" zipkin: endpointAddress: \\\"http://zipkin.default.svc.cluster.local:9411/api/v2/spans\", \"\\\"\\n\\nThe samplingRate attribute specifies the interval used for publishing traces. The value must be b\", \"etween 0 (tracing disabled) and 1 (every trace is published). With a value of 0.5, for example, ever\", \"y other trace is published, significantly reducing published traffic. The endpointAddress points to \", \"an endpoint on a Zipkin server running in a Kubernetes cluster. The default port for Zipkin is 9411.\", \" The configuration must be applied to the Kubernetes cluster using the Kubernetes CLI:\\n\\nkubectl appl\", \"y -f dapr-config.yaml\\n\\n103\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nInstall the Zipkin s\", \"erver\\n\\nWhen installing Dapr in self-hosted mode, a Zipkin server is automatically installed and trac\", \"ing is enabled in the default configuration file located in $HOME/.dapr/config.yaml or %USERPROFILE%\", \"\\\\.dapr\\\\config.yaml on Windows.\\n\\nWhen installing Dapr on a Kubernetes cluster, Zipkin must be deploye\", \"d manually. Use the following Kubernetes manifest file entitled zipkin.yaml to deploy a standard Zip\", \"kin server to a Kubernetes cluster:\\n\\nkind: Deployment apiVersion: apps/v1 metadata: name: zipkin nam\", \"espace: dapr-trafficcontrol labels: service: zipkin spec: replicas: 1 selector: matchLabels: service\", \": zipkin template: metadata: labels: service: zipkin spec: containers: - name: zipkin image: openzip\", \"kin/zipkin-slim imagePullPolicy: IfNotPresent ports: - name: http containerPort: 9411 protocol: TCP\\n\", \"\\n---\\n\\nkind: Service apiVersion: v1 metadata: name: zipkin namespace: dapr-trafficcontrol labels: ser\", \"vice: zipkin spec: type: NodePort ports: - port: 9411 targetPort: 9411 nodePort: 32411 protocol: TCP\", \" name: zipkin selector: service: zipkin\\n\\nThe deployment uses the standard openzipkin/zipkin-slim con\", \"tainer image. The Zipkin service exposes the Zipkin web front end, which you can use to view the tel\", \"emetry on port 32411. Use the\\n\\n104\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nKubernetes C\", \"LI to apply the Zipkin manifest file to the Kubernetes cluster and deploy the Zipkin server:\\n\\nkubect\", \"l apply -f zipkin.yaml\\n\\nConfigure the services to use the tracing configuration\\n\\nNow everything is s\", \"et up correctly to start publishing telemetry. Every Dapr sidecar that is deployed as part of the ap\", \"plication must be instructed to emit telemetry when started. To do that, add a dapr.io/config annota\", \"tion that references the dapr-config configuration to the deployment of each service. Here\\u2019s an exam\", \"ple of the Traffic Control FineCollection service\\u2019s manifest file containing the annotation:\\n\\napiVer\", \"sion: apps/v1 kind: Deployment metadata: name: finecollectionservice namespace: dapr-trafficcontrol \", \"labels: app: finecollectionservice spec: replicas: 1 selector: matchLabels: app: finecollectionservi\", \"ce template: metadata: labels: app: finecollectionservice annotations: dapr.io/enabled: \\\"true\\\" dapr.\", \"io/app-id: \\\"finecollectionservice\\\" dapr.io/app-port: \\\"6001\\\" dapr.io/config: \\\"dapr-config\\\" spec: cont\", \"ainers: - name: finecollectionservice image: dapr-trafficcontrol/finecollectionservice:1.0 ports: - \", \"containerPort: 6001\\n\\nInspect the telemetry in Zipkin\\n\\nOnce the application is started, the Dapr side\", \"cars will emit telemetry to the Zipkin server. To inspect this telemetry, point a web-browser to htt\", \"p://localhost:32411. You\\u2019ll see the Zipkin web front end:\\n\\n105\\n\\nCHAPTER 11 | The Dapr observability \", \"building block\\n\\nFigure 10-4. Zipkin front end.\\n\\nOn the Find a trace tab, you can query traces. Press\", \"ing the RUN QUERY button without specifying any restrictions will show all the ingested traces:\\n\\nFig\", \"ure 10-5. Zipkin traces overview.\\n\\nClicking the SHOW button next to a specific trace, will show the \", \"details of that trace:\\n\\n106\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nFigure 10-6. Zipkin\", \" trace details.\\n\\nEach item on the details page, is a span that represents a request that is part of \", \"the selected trace.\\n\\nInspect the dependencies between services\\n\\nBecause Dapr sidecars handle traffic\", \" between services, Zipkin can use the trace information to determine the dependencies between the se\", \"rvices. To see it in action, go to the Dependencies tab on the Zipkin web page and select the button\", \" with the magnifying glass. Zipkin will show an overview of the services and their dependencies:\\n\\n10\", \"7\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nFigure 10-7. Zipkin dependencies.\\n\\nThe animat\", \"ed dots on the lines between the services represent requests and move from source to destination. Re\", \"d dots indicate a failed request.\\n\\nUse a Jaeger or New Relic monitoring back end\\n\\nBeyond Zipkin, oth\", \"er monitoring back-end software can also ingest telemetry with the Zipkin format. Jaeger is an open \", \"source tracing system created by Uber Technologies. It\\u2019s used to trace transactions between distribu\", \"ted services and troubleshoot complex microservices environments. New Relic is a full-stack observab\", \"ility platform. It links relevant data from a distributed application to provide a complete picture \", \"of your system. To try them out, specify an endpointAddress pointing to either a Jaeger or New Relic\", \" server in the Dapr configuration file. Here\\u2019s an example of a configuration file that configures Da\", \"pr to send telemetry to a Jaeger server. The URL for Jaeger is identical to the URL for the Zipkin. \", \"The only difference is the number of the port on which the server runs:\\n\\n:::{custom-style=CodeBox} y\", \"aml apiVersion: dapr.io/v1alpha1 kind: Configuration metadata: name: dapr-config namespace: default \", \"spec: tracing: samplingRate: \\\"1\\\" zipkin: endpointAddress: \\\"http://localhost:9415/api/v2/spans\\\" :::\\n\\n\", \"To try out New Relic, specify the endpoint of the New Relic API. Here\\u2019s an example of a configuratio\", \"n file for New Relic:\\n\\n:::{custom-style=CodeBox} yaml apiVersion: dapr.io/v1alpha1 kind: Configurati\", \"on metadata: name: dapr-config namespace: default spec: tracing: samplingRate: \\\"1\\\" zipkin: endpointA\", \"ddress: \\\"https://trace-api.newrelic.com/trace/v1?Api-Key=<NR-API-KEY>&Data- Format=zipkin&Data-Forma\", \"t-Version=2\\\" :::\\n\\n108\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nCheck out the Jaeger and \", \"New Relic websites for more information on how to use them.\\n\\nMetrics\\n\\nMetrics provide insight into p\", \"erformance and resource consumption. Under the hood, Dapr emits a wide collection of system and runt\", \"ime metrics. Dapr uses Prometheus as a metric standard. Dapr sidecars and system services, expose a \", \"metrics endpoint on port 9090. A Prometheus scraper calls this endpoint at a predefined interval to \", \"collect metrics. The scraper sends metric values to a monitoring back end. Figure 10-8 shows the scr\", \"aping process:\\n\\nFigure 10-8. Scraping Prometheus metrics.\\n\\nEach sidecar and system service exposes a\", \" metric endpoint that listens on port 9090. The Prometheus Metrics Scrapper captures metrics from ea\", \"ch endpoint and published the information to the monitoring back end.\\n\\nService discovery\\n\\nYou might \", \"wonder how the metrics scraper knows where to collect metrics. Prometheus can integrate with discove\", \"ry mechanisms built into target deployment environments. For example, when running in Kubernetes, Pr\", \"ometheus can integrate with the Kubernetes API to find all available Kubernetes resources running in\", \" the environment.\\n\\nMetrics list\\n\\nDapr generates a large set of metrics for Dapr system services and \", \"its runtime. Some examples include:\\n\\n109\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nMetric\", \"\\n\\nSource\\n\\nDescription\\n\\ndapr_operator_service_created_total\\n\\nSystem\\n\\nThe total number of Dapr service\", \"s created by the Dapr Operator service.\\n\\ndapr_injector_sidecar_injection/requests_total\\n\\nSystem\\n\\nThe\", \" total number of sidecar injection requests received by the Dapr Sidecar- Injector service.\\n\\ndapr_pl\", \"acement_runtimes_total\\n\\nSystem\\n\\nThe total number of hosts reported to the Dapr Placement service.\\n\\nd\", \"apr_sentry_cert_sign_request_received_total\\n\\nSystem\\n\\nThe number of certificate signing requests (CRS\", \"s) received by the Dapr Sentry service.\\n\\ndapr_runtime_component_loaded\\n\\nRuntime The number of succes\", \"sfully loaded Dapr\\n\\ncomponents.\\n\\ndapr_grpc_io_server_completed_rpcs\\n\\nRuntime Count of gRPC calls by \", \"method and status.\\n\\ndapr_http_server_request_count\\n\\nRuntime Number of HTTP requests started in an\\n\\nH\", \"TTP server.\\n\\ndapr_http/client/sent_bytes\\n\\nRuntime Total bytes sent in request body (not including he\", \"aders) by an HTTP client.\\n\\nFor more information on available metrics, see the Dapr metrics documenta\", \"tion.\\n\\nConfigure Dapr metrics\\n\\nAt run time, you can disable the metrics collection endpoint by inclu\", \"ding the --enable- metrics=false argument in the Dapr command. Or, you can also change the default p\", \"ort for the endpoint with the --metrics-port 9090 argument.\\n\\nYou can also use a Dapr configuration f\", \"ile to statically enable or disable runtime metrics collection:\\n\\napiVersion: dapr.io/v1alpha1 kind: \", \"Configuration metadata: name: dapr-config namespace: dapr-trafficcontrol spec: tracing: samplingRate\", \": \\\"1\\\" metric: enabled: false\\n\\nVisualize Dapr metrics\\n\\nWith the Prometheus scraper collecting and pub\", \"lishing metrics into the monitoring back end, how do you make sense of the raw data? A popular visua\", \"lization tool for analyzing metrics is Grafana. With Grafana, you can create dashboards from the ava\", \"ilable metrics. Here\\u2019s an example of a dashboard displaying Dapr system services metrics:\\n\\n110\\n\\nCHAP\", \"TER 11 | The Dapr observability building block\\n\\nFigure 10-9. Grafana dashboard.\\n\\nThe Dapr documentat\", \"ion includes a tutorial for installing Prometheus and Grafana.\\n\\nLogging\\n\\nLogging provides insight in\", \"to what is happening with a service at run time. When running an application, Dapr automatically emi\", \"ts log entries from Dapr sidecars and Dapr system services. However, logging entries instrumented in\", \" your application code aren\\u2019t automatically included. To emit logging from application code, you can\", \" import a specific SDK like OpenTelemetry SDK for .NET. Logging application code is covered later in\", \" this chapter in the section Using the Dapr .NET SDK.\\n\\nLog entry structure\\n\\nDapr emits structured lo\", \"gging. Each log entry has the following format:\\n\\nField\\n\\nDescription\\n\\nExample\\n\\ntime\\n\\nISO8601 formatte\", \"d timestamp\\n\\n2021-01-10T14:19:31.000Z\\n\\nlevel\\n\\nLevel of the entry (debug, info, warn, or error) info\\n\", \"\\ntype\\n\\nLog Type\\n\\nlog\\n\\nmsg\\n\\nLog Message\\n\\nmetrics server started on :62408/\\n\\nscope\\n\\nLogging Scope\\n\\ndap\", \"r.runtime\\n\\ninstance Hostname where Dapr runs\\n\\nTSTSRV01\\n\\n111\\n\\nCHAPTER 11 | The Dapr observability bui\", \"lding block\\n\\nField\\n\\nDescription\\n\\nExample\\n\\napp_id\\n\\nDapr App ID\\n\\nfinecollectionservice\\n\\nver\\n\\nDapr Runt\", \"ime Version\\n\\n1.0\\n\\nWhen searching through logging entries in a troubleshooting scenario, the time and\", \" level fields are especially helpful. The time field orders log entries so that you can pinpoint spe\", \"cific time periods. When troubleshooting, log entries at the debug level provide more information on\", \" the behavior of the code.\\n\\nPlain text versus JSON format\\n\\nBy default, Dapr emits structured logging\", \" in plain-text format. Every log entry is formatted as a string containing key/value pairs. Here\\u2019s a\", \"n example of logging in plain text:\\n\\n== DAPR == time=\\\"2021-01-12T16:11:39.4669323+01:00\\\" level=info \", \"msg=\\\"starting Dapr Runtime - - version 1.0 -- commit 196483d\\\" app_id=finecollectionservice instance=\", \"TSTSRV03 scope=dapr.runtime type=log ver=1.0 == DAPR == time=\\\"2021-01-12T16:11:39.467933+01:00\\\" leve\", \"l=info msg=\\\"log level set to: info\\\" app_id=finecollectionservice instance=TSTSRV03 scope=dapr.runtim\", \"e type=log ver=1.0 == DAPR == time=\\\"2021-01-12T16:11:39.467933+01:00\\\" level=info msg=\\\"metrics server\", \" started on :62408/\\\" app_id=finecollectionservice instance=TSTSRV03 scope=dapr.metrics type=log ver=\", \"1.0\\n\\nWhile simple, this format is difficult to parse. If viewing log entries with a monitoring tool,\", \" you\\u2019ll want to enable JSON formatted logging. With JSON entries, a monitoring tool can index and qu\", \"ery individual fields. Here\\u2019s the same log entries in JSON format:\\n\\n{\\\"app_id\\\": \\\"finecollectionservic\", \"e\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \\\"starting Dapr Runtime -- version 1.0 -- commit \", \"196483d\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"time\\\": \\\"2021-01-12T16:11:39.4669323+01:00\\\", \\\"type\\\": \\\"log\\\", \\\"ver\\\"\", \": \\\"1.0\\\"} {\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \\\"log le\", \"vel set to: info\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"2021-01- 12T16:11:39.467933+01:0\", \"0\\\", \\\"ver\\\": \\\"1.0\\\"} {\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\"\", \": \\\"metrics server started on :62408/\\\", \\\"scope\\\": \\\"dapr.metrics\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"2021- 01-12T\", \"16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"}\\n\\nTo enable JSON formatting, you need to configure each Dapr si\", \"decar. In self-hosted mode, you can specify the flag --log-as-json on the command line:\\n\\ndapr run --\", \"app-id finecollectionservice --log-level info --log-as-json dotnet run\\n\\nIn Kubernetes, you can add a\", \" dapr.io/log-as-json annotation to each deployment for the application:\\n\\nannotations: dapr.io/enable\", \"d: \\\"true\\\" dapr.io/app-id: \\\"finecollectionservice\\\" dapr.io/app-port: \\\"80\\\" dapr.io/config: \\\"dapr-confi\", \"g\\\" dapr.io/log-as-json: \\\"true\\\"\\n\\nWhen you install Dapr in a Kubernetes cluster using Helm, you can en\", \"able JSON formatted logging for all the Dapr system services:\\n\\n112\\n\\nCHAPTER 11 | The Dapr observabil\", \"ity building block\\n\\nhelm repo add dapr https://dapr.github.io/helm-charts/ helm repo update kubectl \", \"create namespace dapr-system helm install dapr dapr/dapr --namespace dapr-system --set global.logAsJ\", \"son=true\\n\\nCollect logs\\n\\nThe logs emitted by Dapr can be fed into a monitoring back end for analysis.\", \" A log collector is a component that collects logs from a system and sends them to a monitoring back\", \" end. A popular log collector is Fluentd. Check out the How-To: Set up Fluentd, Elastic search and K\", \"ibana in Kubernetes in the Dapr documentation. This article contains instructions for setting up Flu\", \"entd as log collector and the ELK Stack (Elastic Search and Kibana) as a monitoring back end.\\n\\nHealt\", \"h status\\n\\nThe health status of a service provides insight into its availability. Each Dapr sidecar e\", \"xposes a health API that can be used by the hosting environment to determine the health of the sidec\", \"ar. The API has one operation:\\n\\nGET http://localhost:3500/v1.0/healthz\\n\\nThe operation returns two HT\", \"TP status codes:\\n\\n\\n\\n204: When the sidecar is healthy\\n\\n\\n\\n500: when the sidecar isn\\u2019t healthy\\n\\nWhen ru\", \"nning in self-hosted mode, the health API isn\\u2019t automatically invoked. You can invoke the API though\", \" from application code or a health monitoring tool.\\n\\nWhen running in Kubernetes, the Dapr sidecar-in\", \"jector automatically configures Kubernetes to use the health API for executing liveness probes and r\", \"eadiness probes.\\n\\nKubernetes uses liveness probes to determine whether a container is up and running\", \". If a liveness probe returns a failure code, Kubernetes will assume the container is dead and autom\", \"atically restart it. This feature increases the overall availability of your application.\\n\\nKubernete\", \"s uses readiness probes to determine whether a container is ready to start accepting traffic. A pod \", \"is considered ready when all of its containers are ready. Readiness determines whether a Kubernetes \", \"service can direct traffic to a pod in a load-balancing scenario. Pods that aren\\u2019t ready are automat\", \"ically removed from the load-balancer.\\n\\nLiveness and readiness probes have several configurable para\", \"meters. Both are configured in the container spec section of a pod\\u2019s manifest file. By default, Dapr\", \" uses the following configuration for each sidecar container:\\n\\nlivenessProbe: httpGet: path: v1.0/he\", \"althz port: 3500 initialDelaySeconds: 5 periodSeconds: 10 timeoutSeconds : 5 failureThreshold : 3\\n\\n1\", \"13\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nreadinessProbe: httpGet: path: v1.0/healthz \", \"port: 3500 initialDelaySeconds: 5 periodSeconds: 10 timeoutSeconds : 5 failureThreshold: 3\\n\\nThe foll\", \"owing parameters are available for the probes:\\n\\n\\n\\nThe path specifies the Dapr health API endpoint.\\n\\n\", \"\\n\\nThe port specifies the Dapr health API port.\\n\\n\\n\\nThe initialDelaySecondsspecifies the number of sec\", \"onds Kubernetes will wait before it starts probing a container for the first time.\\n\\n\\n\\nThe periodSeco\", \"nds specifies the number of seconds Kubernetes will wait between each probe.\\n\\n\\n\\nThe timeoutSeconds s\", \"pecifies the number of seconds Kubernetes will wait on a response from the API before timing out. A \", \"timeout is interpreted as a failure.\\n\\n\\n\\nThe failureThresholdspecifies the number of failed status co\", \"de Kubernetes will accept before considering the container not alive or not ready.\\n\\nDapr dashboard\\n\\n\", \"Dapr offers a dashboard that presents status information on Dapr applications, components, and confi\", \"gurations. Use the Dapr CLI to start the dashboard as a web-application on the local machine on port\", \" 8080:\\n\\ndapr dashboard\\n\\nFor Dapr application running in Kubernetes, use the following command:\\n\\ndapr\", \" dashboard -k\\n\\nThe dashboard opens with an overview of all services in your application that have a \", \"Dapr sidecar. The following screenshot shows the Dapr dashboard for the Traffic Control sample appli\", \"cation running in Kubernetes:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/observability/dapr-dashboard-\", \"overview.png\\u201d alt-text=\\u201cDapr dashboard overview\\u201d:::\\n\\nFigure 10-10. Dapr dashboard overview.\\n\\nThe Dap\", \"r dashboard is invaluable when troubleshooting a Dapr application. It provides information about Dap\", \"r sidecars and system services. You can drill down into the configuration of each service, including\", \" the logging entries.\\n\\nThe dashboard also shows the configured components (and their configuration) \", \"for an application:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/observability/dapr-dashboard-components\", \".png\\u201d alt- text=\\u201cDapr dashboard components\\u201d:::\\n\\nFigure 10-11. Dapr dashboard components.\\n\\n114\\n\\nCHAPT\", \"ER 11 | The Dapr observability building block\\n\\nThere\\u2019s a large amount of information available throu\", \"gh the dashboard. You can discover it by running a Dapr application and browsing the dashboard.\\n\\nChe\", \"ck out the Dapr dashboard CLI command reference in the Dapr docs for more information on the Dapr da\", \"shboard commands.\\n\\nUse the Dapr .NET SDK\\n\\nThe Dapr .NET SDK doesn\\u2019t contain any specific observabili\", \"ty features. All observability features are offered at the Dapr level.\\n\\nIf you want to emit telemetr\", \"y from your .NET application code, you should consider the OpenTelemetry SDK for .NET. The Open Tele\", \"metry project is cross-platform, open source, and vendor agnostic. It provides an end-to-end impleme\", \"ntation to generate, emit, collect, process, and export telemetry data. There\\u2019s a single instrumenta\", \"tion library per language that supports automatic and manual instrumentation. Telemetry is published\", \" using the Open Telemetry standard. The project has broad industry support and adoption from cloud p\", \"roviders, vendors, and end users.\\n\\nSample application: Dapr Traffic Control\\n\\nBecause the Traffic Con\", \"trol sample application runs with Dapr, all the telemetry described in this chapter is available. If\", \" you run the application and open the Zipkin web front end, you\\u2019ll see end-to- end tracing. Figure 1\", \"0-12 shows an example:\\n\\nFigure 10-12. Zipkin end-to-end tracing example.\\n\\nThis trace shows the commu\", \"nication that occurs when a speeding violation has been detected:\\n\\n115\\n\\nCHAPTER 11 | The Dapr observ\", \"ability building block\\n\\n1.\\n\\nAn exiting vehicle triggers the MQTT input binding that sends a message \", \"containing the vehicle license number, lane, and timestamp.\\n\\n2.\\n\\nThe MQTT input binding invokes the \", \"TrafficControl service with the message.\\n\\n3.\\n\\nThe TrafficControl service retrieves the state for the\", \" vehicle, appends the entry, and saves the updated vehicle state back to the state store.\\n\\n4.\\n\\nThe T\", \"rafficControl service publishes the speeding violation using pub/sub to the speedingviolations topic\", \".\\n\\n5.\\n\\nThe FineCollection service receives the speeding violation using a pub/sub subscription on th\", \"e speedingviolations topic.\\n\\n6.\\n\\nThe FineCollection service invokes the vehicleinfo endpoint of the \", \"VehicleRegistration service using service invocation.\\n\\n7.\\n\\nThe FineCollection service invokes an out\", \"put binding for sending the email.\\n\\nClick any trace line (span) to see more details. If you click on\", \" the last line, you\\u2019ll see the sendmail binding component invoked to send the driver a violation not\", \"ice.\\n\\n116\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nFigure 10-13. Output binding trace de\", \"tails.\\n\\nSummary\\n\\nDetailed observability is critical to running a distributed system in production.\\n\\n\", \"Dapr provides different types of telemetry, including distributed tracing, logging, metrics, and hea\", \"lth status.\\n\\nDapr only produces telemetry for the Dapr system services and sidecars. Telemetry from \", \"your application code isn\\u2019t automatically included. You can however use a specific SDK like the Open\", \"Telemetry SDK for .NET to emit telemetry from your application code.\\n\\n117\\n\\nCHAPTER 11 | The Dapr obs\", \"ervability building block\\n\\nDapr telemetry is produced in an open-standards based format so that it c\", \"an be ingested by a large set of available monitoring tools. Examples include Zipkin, Azure Applicat\", \"ion Insights, the ELK Stack, New Relic, and Grafana. See Monitor your application with Dapr in the D\", \"apr documentation for tutorials on how to monitor your Dapr applications with specific monitoring ba\", \"ck ends.\\n\\nYou\\u2019ll need a telemetry scraper that ingests telemetry and publishes it to the monitoring \", \"back end.\\n\\nDapr can be configured to emit structured logging. Structured logging is favored as it ca\", \"n be indexed by back-end monitoring tools. Indexed logging enables users to execute rich queries whe\", \"n searching through the logging.\\n\\nDapr offers a dashboard that presents information about the Dapr s\", \"ervices and configuration.\\n\\nReferences\\n\\n\\n\\nAzure Application Insights\\n\\n\\n\\nOpen Telemetry\\n\\n\\n\\nZipkin\\n\\nW3\", \"C Trace Context\\n\\n\\n\\nJaeger\\n\\n\\n\\nNew Relic\\n\\n\\n\\nPrometheus\\n\\n\\n\\nGrafana\\n\\n\\n\\nOpen Telemetry SDK for .NET\\n\\n\\n\\nFl\", \"uentd\\n\\n\\n\\nELK stack\\n\\n\\n\\nSeq\\n\\n\\n\\nSerilog\\n\\n118\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\nCHAPT\", \"ER 12\\n\\nThe Dapr secrets management building block\\n\\nEnterprise applications require secrets. Common e\", \"xamples include:\\n\\n\\n\\nA database connection string that contains a username and password.\\n\\n\\n\\nAn API ke\", \"y for calling an external web API.\\n\\n\\n\\nA client certificate for authenticating to an external system.\", \"\\n\\nSecrets must be carefully managed so that they\\u2019re never disclosed outside of the application.\\n\\nNot\", \" long ago, it was popular to store application secrets in a configuration file inside the applicatio\", \"n codebase. .NET developers will fondly recall the web.config file. While simple to implement, integ\", \"rating secrets to along with code was far from secure. A common misstep was to include the file when\", \" pushing to a public GIT repository, exposing the secrets to the world.\\n\\nA widely accepted methodolo\", \"gy for constructing modern distributed applications is The Twelve- Factor App. It describes a set of\", \" principles and best practices. Its third factor prescribes that configuration and secrets be extern\", \"alized outside of the code base.\\n\\nTo address this concern, the .NET platform includes a Secret Manag\", \"er feature that stores sensitive data in a physical folder outside of the project tree. While secret\", \"s are outside of source control, this feature doesn\\u2019t encrypt data. It\\u2019s designed for development pu\", \"rposes only.\\n\\nA more modern and secure practice is to isolate secrets in a secrets management tool l\", \"ike Hashicorp Vault or Azure Key Vault. These tools enable you to store secrets externally, vary cre\", \"dentials across environments, and reference them from application code. However, each tool has its c\", \"omplexities and learning curve.\\n\\nDapr offers a building block that simplifies managing secrets.\\n\\nWha\", \"t it solves\\n\\nThe Dapr secrets management building block abstracts away the complexity of working wit\", \"h secrets and secret management tools.\\n\\n119\\n\\nCHAPTER 12 | The Dapr secrets management building block\", \"\\n\\n\\n\\nIt hides the underlying plumbing through a unified interface.\\n\\n\\n\\nIt supports various pluggable s\", \"ecret store components, which can vary between development and production.\\n\\n\\n\\nApplications don\\u2019t req\", \"uire direct dependencies on secret store libraries.\\n\\n\\n\\nDevelopers don\\u2019t require detailed knowledge o\", \"f each secret store.\\n\\nDapr handles all of the above concerns.\\n\\nAccess to the secrets is secured thro\", \"ugh authentication and authorization. Only an application with sufficient rights can access secrets.\", \" Applications running in Kubernetes can also use its built-in secrets management mechanism.\\n\\nHow it \", \"works\\n\\nApplications use the secrets management building block in two ways:\\n\\n\\n\\nRetrieve a secret dire\", \"ctly from the building block.\\n\\n\\n\\nReference a secret indirectly from a Dapr component configuration.\\n\", \"\\nRetrieving secrets directly is covered first. Referencing a secret from a Dapr component configurat\", \"ion file is addressed in a later section.\\n\\nThe application interacts with a Dapr sidecar when using \", \"the secrets management building block. The sidecar exposes the secrets API. The API can be called wi\", \"th either HTTP or gRPC. Use the following URL to call the HTTP API:\\n\\nhttp://localhost:<dapr-port>/v1\", \".0/secrets/<store-name>/<name>?<metadata>\\n\\nThe URL contains the following segments:\\n\\n\\n\\n<dapr-port> s\", \"pecifies the port number upon which the Dapr sidecar is listening.\\n\\n\\n\\n<store-name> specifies the nam\", \"e of the Dapr secret store.\\n\\n\\n\\n<name> specifies the name of the secret to retrieve.\\n\\n\\n\\n<metadata> pr\", \"ovides additional information for the secret. This segment is optional and metadata properties diffe\", \"r per secret store. For more information on metadata properties, see the [secrets API reference]INTE\", \"RNAL-LINK:(Secrets API reference | Dapr Docs).\\n\\n[!NOTE] The above URL represents the native Dapr API\", \" call available to any development platform that supports HTTP or gRPC. Popular platforms like .NET,\", \" Java, and Go have their own custom APIs.\\n\\nThe JSON response contains the key and value of the secre\", \"t.\\n\\nFigure 11-1 shows how Dapr handles a request for the secrets API:\\n\\n120\\n\\nCHAPTER 12 | The Dapr se\", \"crets management building block\\n\\nFigure 11-1. Retrieving a secret with the Dapr secrets API.\\n\\n1.\\n\\nTh\", \"e service calls the Dapr secrets API, along with the name of the secret store, and secret to retriev\", \"e.\\n\\n2.\\n\\nThe Dapr sidecar retrieves the specified secret from the secret store.\\n\\n3.\\n\\nThe Dapr sidecar\", \" returns the secret information back to the service.\\n\\nSome secret stores support storing multiple ke\", \"y/value pairs in a single secret. For those scenarios, the response would contain multiple key/value\", \" pairs in a single JSON response as in the following example:\\n\\nGET http://localhost:3500/v1.0/secret\", \"s/secret-store/interestRates?metadata.version_id=3\\n\\n{ \\\"tier1-percentage\\\": \\\"2.5\\\", \\\"tier2-percentage\\\":\", \" \\\"3.8\\\", \\\"tier3-percentage\\\": \\\"5.1\\\" }\\n\\nThe Dapr secrets API also offers an operation to retrieve all t\", \"he secrets the application has access to:\\n\\nhttp://localhost:<dapr-port>/v1.0/secrets/<store-name>/bu\", \"lk\\n\\nUse the Dapr .NET SDK\\n\\nFor .NET developers, the Dapr .NET SDK streamlines Dapr secret management\", \". Consider the DaprClient.GetSecretAsync method. It enables you to retrieve a secret directly from a\", \"ny Dapr secret store with minimal effort. Here\\u2019s an example of fetching a connection string secret f\", \"or a SQL Server database:\\n\\n121\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\nvar metadat\", \"a = new Dictionary<string, string> { [\\\"version_id\\\"] = \\\"3\\\" }; Dictionary<string, string> secrets = aw\", \"ait daprClient.GetSecretAsync(\\\"secret-store\\\", \\\"eshopsecrets\\\", metadata); string connectionString = s\", \"ecrets[\\\"customerdb\\\"];\\n\\nArguments for the GetSecretAsync method include:\\n\\n\\n\\nThe name of the Dapr secr\", \"et store component (\\u2018secret-store\\u2019)\\n\\n\\n\\nThe secret to retrieve (\\u2018eshopsecrets\\u2019)\\n\\n\\n\\nOptional metadata \", \"key/value pairs (\\u2018version_id=3\\u2019)\\n\\nThe method responds with a dictionary object as a secret can conta\", \"in multiple key/value pairs. In the example above, the secret named customerdb is referenced from th\", \"e collection to return a connection string.\\n\\nThe Dapr .NET SDK also features a .NET configuration pr\", \"ovider. It loads specified secrets into the underlying .NET configuration API. The running applicati\", \"on can then reference secrets from the IConfiguration dictionary that is registered in ASP.NET Core \", \"dependency injection.\\n\\nThe secrets configuration provider is available from the Dapr.Extensions.Conf\", \"iguration NuGet package. The provider can be registered in the Program.cs of an ASP.NET Web API appl\", \"ication:\\n\\nvar builder = WebApplication.CreateBuilder(args); builder.WebHost.ConfigureAppConfiguratio\", \"n(config => { var daprClient = new DaprClientBuilder().Build(); var secretDescriptors = new List<Dap\", \"rSecretDescriptor> { new DaprSecretDescriptor(\\\"eshopsecrets\\\") }; config.AddDaprSecretStore(\\\"secret-s\", \"tore\\\", secretDescriptors, daprClient); });\\n\\nThe above example loads the eshopsecrets secrets collect\", \"ion into the .NET configuration system at startup. Registering the provider requires an instance of \", \"DaprClient to invoke the secrets API on the Dapr sidecar. The other arguments include the name of th\", \"e secret store and a DaprSecretDescriptor object with the name of the secret.\\n\\nOnce loaded, you can \", \"retrieve secrets directly from application code:\\n\\npublic void GetCustomer(IConfiguration config) { v\", \"ar connectionString = config[\\\"eshopsecrets\\\"][\\\"customerdb\\\"]; }\\n\\nSecret store components\\n\\nThe secrets \", \"management building block supports several secret store components. At the time of writing, the foll\", \"owing secret stores are available:\\n\\n\\n\\nAlibabaCloud OOS Parameter Store\\n\\n\\n\\nAWS Secrets Manager\\n\\n\\n\\nAWS\", \" SSM Parameter Store\\n\\n122\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\n\\nAzure Key Vaul\", \"t\\n\\n\\n\\nGCP Secret Manager\\n\\n\\n\\nHashiCorp Vault\\n\\n\\n\\nKubernetes secrets\\n\\n\\n\\nLocal environment variables\\n\\n\\n\\nL\", \"ocal file\\n\\nImportant\\n\\nThe local environment variables and file components are designed for developme\", \"nt workloads only.\\n\\nThe following sections show how to configure a secret store.\\n\\nConfiguration\\n\\nYou\", \" configure a secret store using a Dapr component configuration file. The typical structure of the fi\", \"le is shown below:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: [component name] na\", \"mespace: [namespace] spec: type: secretstores.[secret store type] version: [secret store version] me\", \"tadata: - name: [property name] value: [property value]\\n\\nAll Dapr component configuration files requ\", \"ire a name along with an optional namespace value. Additionally, the type field in the spec section \", \"specifies the type of secret store component. The properties in the metadata section differ per secr\", \"et store.\\n\\nIndirectly consume Dapr secrets\\n\\nAs mentioned earlier in this chapter, applications can a\", \"lso consume secrets by referencing them in component configuration files. Consider a state managemen\", \"t component that uses Redis cache for storing state:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component m\", \"etadata: name: eshop-basket-statestore namespace: eshop spec: type: state.redis version: v1 metadata\", \": - name: redisHost value: localhost:6379 - name: redisPassword value: e$h0p0nD@pr\\n\\n123\\n\\nCHAPTER 12 \", \"| The Dapr secrets management building block\\n\\nThe above configuration file contains a clear-text pas\", \"sword for connecting to the Redis server. Hardcoded passwords are always a bad idea. Pushing this co\", \"nfiguration file to a public repository would expose the password. Storing the password in a secret \", \"store would dramatically improve this scenario.\\n\\nThe following examples demonstrate this using sever\", \"al different secret stores.\\n\\nLocal file\\n\\nThe local file component is designed for development scenar\", \"ios. It stores secrets on the local filesystem inside a JSON file. Here\\u2019s an example named eshop-sec\", \"rets.json. It contains a single secret - a password for Redis:\\n\\n{ \\\"eShopRedisPassword\\\": \\\"e$h0p0nD@pr\", \"\\\" }\\n\\nYou place this file in a components folder that you specify when running the Dapr application.\\n\", \"\\nThe following secret store configuration file consumes the JSON file as a secret store. It\\u2019s also p\", \"laced in the components folder:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: eshop-\", \"local-secret-store namespace: eshop spec: type: secretstores.local.file version: v1 metadata: - name\", \": secretsFile value: ./components/eshop-secrets.json - name: nestedSeparator value: \\\":\\\"\\n\\nThe compone\", \"nt type is secretstore.local.file. The secretsFile metadata element specifies the path to the secret\", \"s file.\\n\\nImportant\\n\\nThe path to a secrets file can be a absolute or relative path. The relative path\", \" is based on the folder in which the application starts. In the example, the components folder is a \", \"sub-folder of the directory that contains the .NET application.\\n\\nFrom the application folder, start \", \"the Dapr application specifying the components path as a command- line argument:\\n\\ndapr run --app-id \", \"basket-api --components-path ./components dotnet run\\n\\n124\\n\\nCHAPTER 12 | The Dapr secrets management \", \"building block\\n\\nNote\\n\\nThis above example applies to running Dapr in self-hosted mode. For Kubernetes\", \" hosting, consider using volume mounts.\\n\\nThe nestedSeparator in a Dapr configuration file specifies \", \"a character to flatten a JSON hierarchy. Consider the following snippet:\\n\\n{ \\\"redisPassword\\\": \\\"some p\", \"assword\\\", \\\"connectionStrings\\\": { \\\"customerdb\\\": \\\"some connection string\\\", \\\"productdb\\\": \\\"some connecti\", \"on string\\\" } }\\n\\nUsing a colon as a separator, you can retrieve the customerdb connection-string usin\", \"g the key connectionStrings:customerdb.\\n\\nNote\\n\\nThe colon : is the default separator value.\\n\\nIn the n\", \"ext example, a state management configuration file references the local secret store component to ob\", \"tain the password for connecting to the Redis server:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component \", \"metadata: name: eshop-basket-statestore namespace: eshop spec: type: state.redis version: v1 metadat\", \"a: - name: redisHost value: localhost:6379 - name: redisPassword secretKeyRef: name: eShopRedisPassw\", \"ord key: eShopRedisPassword auth: secretStore: eshop-local-secret-store\\n\\nThe secretKeyRef element re\", \"ferences the secret containing the password. It replaces the earlier clear- text value. The secret n\", \"ame and the key name, eShopRedisPassword, reference the secret. The name of the secret management co\", \"mponent eshop-local-secret-store is found in the auth metadata element.\\n\\nYou might wonder why eShopR\", \"edisPassword is identical for both the name and key in the secret reference. In the local file secre\", \"t store, secrets aren\\u2019t identified with a separate name. The scenario will be different in the next \", \"example using Kubernetes secrets.\\n\\n125\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\nKub\", \"ernetes secret\\n\\nThis second example focuses on a Dapr application running in Kubernetes. It uses the\", \" standard secrets mechanism that Kubernetes offers. Use the Kubernetes CLI (kubectl) to create a sec\", \"ret named eshop- redis-secret that contains the password:\\n\\nkubectl create secret generic eshopsecret\", \"s --from-literal=redisPassword=e$h0p0nD@pr -n eshop\\n\\nOnce created, you can reference the secret in t\", \"he component configuration file for state management:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component \", \"metadata: name: eshop-basket-statestore namespace: eshop spec: type: state.redis version: v1 metadat\", \"a: - name: redisHost value: redis:6379 - name: redisPassword secretKeyRef: name: eshopsecrets key: r\", \"edisPassword auth: secretStore: kubernetes\\n\\nThe secretKeyRef element specifies the name of the Kuber\", \"netes secret and the secret\\u2019s key, eshopsecrets, and redisPassword respectively. The auth metadata s\", \"ection instructs Dapr to use the Kubernetes secrets management component.\\n\\nNote\\n\\nAuth is the default\", \" value when using Kubernetes secrets and can be omitted.\\n\\nIn a production setting, secrets are typic\", \"ally created as part of an automated CI/CD pipeline. Doing so ensures only people with sufficient pe\", \"rmissions can access and change the secrets. Developers create configuration files without knowing t\", \"he actual value of the secrets.\\n\\nAzure Key Vault\\n\\nThe next example is geared toward a real-world pro\", \"duction scenario. It uses Azure Key Vault as the secret store. Azure Key Vault is a managed Azure se\", \"rvice that enables secrets to be stored securely in the cloud.\\n\\nFor this example to work, the follow\", \"ing prerequisites must be satisfied:\\n\\n\\n\\nYou\\u2019ve secured administrative access to an Azure subscriptio\", \"n.\\n\\n\\n\\nYou\\u2019ve provisioned an Azure Key Vault named eshopkv that holds a secret named redisPassword th\", \"at contains the password for connecting to the Redis server.\\n\\n\\n\\nYou\\u2019ve created service principal in \", \"Azure Active Directory.\\n\\n126\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\n\\nYou\\u2019ve inst\", \"alled an X509 certificate for this service principal (containing both the public and private key) on\", \" the local filesystem.\\n\\nNote\\n\\nA service principal is an identity that can be used by an application \", \"to authenticate an Azure service. The service principal uses a X509 certificate. The application use\", \"s this certificate as a credential to authenticate itself.\\n\\nThe Dapr Azure Key Vault secret store do\", \"cumentation provides step-by-step instructions to create and configure a Key Vault environment.\\n\\nUse\", \" Key Vault when running in self-hosted mode\\n\\nUsing Azure Key Vault in Dapr self-hosted mode requires\", \" the following component configuration file:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata:\", \" name: eshop-azurekv-secret-store namespace: eshop spec: type: secretstores.azure.keyvault version: \", \"v1 metadata: - name: vaultName value: eshopkv - name: spnTenantId value: \\\"619926af-a7c3-4e95-93ed-4e\", \"cc4e3e652b\\\" - name: spnClientId value: \\\"6cf48032-6c38-43be-9d6f-2a43ce736b09\\\" - name: spnCertificate\", \"File value : \\\"azurekv-spn-cert.pfx\\\"\\n\\nThe secret store type is secretstores.azure.keyvault. The metad\", \"ata element provides access to the Key Vault with the following properties:\\n\\n\\n\\nThe vaultName contain\", \"s the name of the Azure Key Vault.\\n\\n\\n\\nThe spnTenantId contains the tenant ID of the service principa\", \"l used to authenticate against the Key Vault.\\n\\n\\n\\nThe spnClientId contains the app ID of the service \", \"principal used to authenticate against the Key Vault.\\n\\n\\n\\nThe spnCertificateFile contains the path to\", \" the certificate file for the service principal to authenticate against the Key Vault.\\n\\nTip\\n\\nYou can\", \" copy the service principal information from the Azure portal or Azure CLI .\\n\\nNow the application ca\", \"n retrieve the Redis password from the Azure Key Vault.\\n\\n127\\n\\nCHAPTER 12 | The Dapr secrets manageme\", \"nt building block\\n\\nUse Key Vault when running on Kubernetes\\n\\nConsuming Azure Key Vault with Dapr and\", \" Kubernetes also requires a service principal to authenticate against the Azure Key Vault.\\n\\nFirst, c\", \"reate a Kubernetes secret that contains a certificate file using the kubectl CLI tool:\\n\\nkubectl crea\", \"te secret generic [k8s_spn_secret_name] --from- file=[pfx_certificate_file_local_path] -n eshop\\n\\nThe\", \" command requires two command-line arguments:\\n\\n\\n\\n[k8s_spn_secret_name] is the secret name in Kuberne\", \"tes secret store.\\n\\n\\n\\n[pfx_certificate_file_local_path] is the path of X509 certificate file.\\n\\nOnce c\", \"reated, you can reference the Kubernetes secret in the secret store component configuration file:\\n\\na\", \"piVersion: dapr.io/v1alpha1 kind: Component metadata: name: eshop-azurekv-secret-store namespace: es\", \"hop spec: type: secretstores.azure.keyvault version: v1 metadata: - name: vaultName value: [your_key\", \"vault_name] - name: spnTenantId value: \\\"619926af-a7c3-4e95-93ed-4ecc4e3e652b\\\" - name: spnClientId va\", \"lue: \\\"6cf48032-6c38-43be-9d6f-2a43ce736b09\\\" - name: spnCertificate secretKeyRef: name: [k8s_spn_secr\", \"et_name] key: [pfx_certificate_file_local_name] auth: secretStore: kubernetes\\n\\nAt this point, an app\", \"lication running in Kubernetes can retrieve the Redis password from the Azure Key Vault.\\n\\nImportant\\n\", \"\\nIt\\u2019s critical to keep the X509 certificate file for the service principal in a safe place. It\\u2019s bes\", \"t to place it in a well-known folder outside the source-code repository. The configuration file can \", \"then reference the certificate file from this well-known folder. On a local development machine, you\", \"\\u2019re responsible for copying the certificate to the folder. For automated deployments, the pipeline w\", \"ill copy the certificate to the machine where the application is deployed. It\\u2019s a best practice to u\", \"se a different service principal per environment. Doing so prevents the service principal from a DEV\", \"ELOPMENT environment to access secrets in a PRODUCTION environment.\\n\\n128\\n\\nCHAPTER 12 | The Dapr secr\", \"ets management building block\\n\\nWhen running in Azure Kubernetes Service (AKS), it\\u2019s preferable to us\", \"e an Azure Managed Identity for authenticating against Azure Key Vault. Managed identities are outsi\", \"de of the scope of this book, but explained in the Azure Key Vault with managed identities documenta\", \"tion.\\n\\nScope secrets\\n\\nSecret scopes allow you to control which secrets your application can access. \", \"You configure scopes in a Dapr sidecar configuration file. The Dapr configuration documentation prov\", \"ides instructions for scoping secrets.\\n\\nHere\\u2019s an example of a Dapr sidecar configuration file that \", \"contains secret scopes:\\n\\napiVersion: dapr.io/v1alpha1 kind: Configuration metadata: name: dapr-confi\", \"g namespace: eshop spec: tracing: samplingRate: \\\"1\\\" secrets: scopes: - storeName: eshop-azurekv-secr\", \"et-store defaultAccess: allow deniedSecrets: [\\\"redisPassword\\\", \\\"apiKey\\\"]\\n\\nYou specify scopes per sec\", \"ret store. In the above example, the secret store is named eshop-azurekv- secret-store. You configur\", \"e access to secrets using the following properties:\\n\\nProperty\\n\\nValue\\n\\nDescription\\n\\ndefaultAccess\\n\\nal\", \"low or deny\\n\\nAllows or denies access to all secrets in the specified secret store. This property is \", \"optional with a default value of allow.\\n\\nallowedSecrets List of\\n\\nsecret keys\\n\\nSecrets specified in t\", \"he array will be accessible. This property is optional.\\n\\ndeniedSecrets\\n\\nList of secret keys\\n\\nSecrets\", \" specified in the array will NOT be accessible. This property is optional.\\n\\nThe allowedSecrets and d\", \"eniedSecrets properties take precedence over the defaultAccess property. Imagine specifying defaultA\", \"ccess: allowed and an allowedSecrets list. In this case, only the secrets in the allowedSecrets list\", \" would be accessible by the application.\\n\\nSample application: Dapr Traffic Control\\n\\nIn Dapr Traffic \", \"Control sample app, the secrets management building block is used in several places. Secrets are ret\", \"rieved from code and referenced by Dapr component configuration files. Figure 10-2 shows the concept\", \"ual architecture of the Dapr Traffic Control sample application. The Dapr secrets management buildin\", \"g block is used in flows marked with number 6 in the diagram:\\n\\n129\\n\\nCHAPTER 12 | The Dapr secrets ma\", \"nagement building block\\n\\nFigure 10-2. Conceptual architecture of the Dapr Traffic Control sample app\", \"lication.\\n\\nThe FineCollection service uses an SMTP output binding for sending emails (see the Bindin\", \"gs chapter). The email component file consumes the secrets management building block to retrieve cre\", \"dentials to connect to the SMTP server. To calculate the fine for a speeding violation, the service \", \"uses a fictitious FineCalculator component that requires a license key. It retrieves this license ke\", \"y from the secrets management building block.\\n\\nThe TrafficControl service stores vehicle information\", \" in a Redis state store (see the State management chapter). It uses the secrets management building \", \"block for retrieving credentials to connect to the Redis server.\\n\\nBecause the Traffic Control sample\", \" application can run in self-hosted mode or in Kubernetes, there are two ways for specifying secrets\", \":\\n\\n\\n\\nA local JSON file\\n\\n\\n\\nA Kubernetes secret\\n\\n130\\n\\nCHAPTER 12 | The Dapr secrets management buildin\", \"g block\\n\\nSecrets\\n\\nExamine the secrets-file.yaml component configuration file in the dapr/components \", \"folder:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: trafficcontrol-secrets namespa\", \"ce: dapr-trafficcontrol spec: type: secretstores.local.file version: v1 metadata: - name: secretsFil\", \"e value: ../dapr/components/secrets.json - name: nestedSeparator value: \\\".\\\" scopes: - trafficcontrol\", \"service - finecollectionservice\\n\\nThe file describes a secrets management component entitled trafficc\", \"ontrol-secrets. The type element is set to local.file and the secretsFile to ../dapr/components/secr\", \"ets.json. For self- hosted mode, use a Local file component. The path must be relatively specified f\", \"rom the folder from which the service starts. The secrets file contains a JSON representation of the\", \" secrets:\\n\\n{ \\\"state\\\":{ \\\"redisPassword\\\": \\\"\\\" }, \\\"smtp\\\":{ \\\"user\\\": \\\"_username\\\", \\\"password\\\": \\\"_password\\\" \", \"}, \\\"finecalculator\\\":{ \\\"licensekey\\\": \\\"HX783-K2L7V-CRJ4A-5PN1G\\\" } }\\n\\nIn the sample application the Red\", \"is server is used without a password. To connect to the SMTP server, the credentials are _username a\", \"nd _password. The license key for the FineCalculator license key is a randomly generated string.\\n\\nWh\", \"ile secrets are stored at nested levels, the secrets management building block flattens this hierarc\", \"hy when the file is read. It uses a period as a level separator (as specified in the nestedSeparator\", \" field in the component configuration file). This construct enables you to reference secrets with a \", \"flattened name, for example: smtp.user.\\n\\nWhen running in Kubernetes, the secrets are specified using\", \" the built-in Kubernetes secrets store. Examine the following secrets.yaml Kubernetes manifest file \", \"in the k8s folder:\\n\\napiVersion: v1 kind: Secret metadata: name: trafficcontrol-secrets namespace: da\", \"pr-trafficcontrol\\n\\n131\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\ntype: Opaque data: \", \"smtp.user: X3VzZXJuYW1l smtp.password: X3Bhc3N3b3Jk finecalculator.licensekey: SFg3ODMtSzJMN1YtQ1JKN\", \"EEtNVBOMUc=\\n\\nThe component is also named trafficcontrol-secrets. Secrets are stored as Base64 encode\", \"d strings.\\n\\nImportant\\n\\nBase64 representations encode, but do not encrypt data. Base64 isn\\u2019t secure f\", \"or production scenarios.\\n\\nThe following paragraphs describe how secrets are used in the Traffic Cont\", \"rol sample application.\\n\\nSMTP server credentials\\n\\nExamine the email.yaml component configuration fil\", \"e located in the dapr/components folder:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: nam\", \"e: sendmail namespace: dapr-trafficcontrol spec: type: bindings.smtp version: v1 metadata: - name: h\", \"ost value: localhost - name: port value: 4025 - name: user secretKeyRef: name: smtp.user key: smtp.u\", \"ser - name: password secretKeyRef: name: smtp.password key: smtp.password - name: skipTLSVerify valu\", \"e: true auth: secretStore: trafficcontrol-secrets scopes: - finecollectionservice\\n\\nThe auth section \", \"references the secrets management component named trafficcontrol-secrets. The user and password entr\", \"ies in the binding metadata reference the secrets: smtp.user and smtp.password respectively.\\n\\nWhen r\", \"unning in Kubernetes, the built-in Kubernetes secrets store is used. The email.yaml manifest file fo\", \"und in the k8s folder references the Kubernetes secret for retrieving the credentials for connecting\", \" to the smtp server:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component\\n\\n132\\n\\nCHAPTER 12 | The Dapr secre\", \"ts management building block\\n\\nmetadata: name: sendmail namespace: dapr-trafficcontrol spec: type: bi\", \"ndings.smtp version: v1 metadata: - name: host value: mailserver - name: port value: 25 - name: user\", \" secretKeyRef: name: trafficcontrol-secrets key: smtp.user - name: password secretKeyRef: name: traf\", \"ficcontrol-secrets key: smtp.password - name: skipTLSVerify value: true scopes: - finecollectionserv\", \"ice\\n\\nUnlike the local secrets store, the Kubernetes store doesn\\u2019t explicitly specify a secrets manag\", \"ement component to use with the auth section. Instead, the default is the built-in Kubernetes secret\", \"s store.\\n\\nRedis server credentials\\n\\nNext, examine the statestore.yaml component configuration file i\", \"n the dapr/components folder:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statesto\", \"re namespace: dapr-trafficcontrol spec: type: state.redis version: v1 metadata: - name: redisHost va\", \"lue: localhost:6379 - name: redisPassword secretKeyRef: name: state.redisPassword key: state.redisPa\", \"ssword - name: actorStateStore value: \\\"true\\\" auth: secretStore: trafficcontrol-secrets scopes: - tra\", \"fficcontrolservice\\n\\nOnce again, the auth section references the secrets management component named t\", \"rafficcontrol-secrets. The redisPassword entries in the binding metadata reference the secret state.\", \"redisPassword.\\n\\n133\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\nFineCalculator compone\", \"nt license key\\n\\nThe FineCollection service uses a component that calculates the fine based on the in\", \"formation of a speeding violation. This component is implemented as a domain service and is abstract\", \"ed by the IFineCalculator interface:\\n\\npublic interface IFineCalculator { public int CalculateFine(st\", \"ring licenseKey, int violationInKmh); }\\n\\nThe CalculateFine method expects a string containing a lice\", \"nseKey as its first argument. This key unlocks the third-party component used by the implementation.\", \" To keep the example simple, the implementation hard-codes a series of if statements. You can find t\", \"he implementation in the HardCodedFineCalculator class in the DomainsServices folder:\\n\\npublic class \", \"HardCodedFineCalculator : IFineCalculator { public int CalculateFine(string licenseKey, int violatio\", \"nInKmh) { if (licenseKey != \\\"HX783-K2L7V-CRJ4A-5PN1G\\\") { throw new InvalidOperationException(\\\"Invali\", \"d license-key specified.\\\"); }\\n\\nint fine = 9; // default administration fee if (violationInKmh < 5 ) \", \"{ fine += 18; } else if (violationInKmh >= 5 && violationInKmh < 10 ) { fine += 31; }\\n\\n// ...\\n\\nelse \", \"if (violationInKmh == 35) { fine += 372; } else { // violation above 35 KMh will be determined by th\", \"e prosecutor return 0; }\\n\\nreturn fine; } }\\n\\nThe implementation simulates a check on the licenseKey t\", \"hat is passed in. The CollectionController of the FineCollection service must pass in the correct li\", \"cense key argument when calling the CalculateFine method. It retrieves the license key from the Dapr\", \" secrets management building block that is exposed by the Dapr client in the Dapr SDK for .NET. If y\", \"ou examine the constructor of the CollectionController, you can see the call:\\n\\n134\\n\\nCHAPTER 12 | The\", \" Dapr secrets management building block\\n\\n// set finecalculator component license-key if (_fineCalcul\", \"atorLicenseKey == null) { bool runningInK8s = Convert.ToBoolean(Environment.GetEnvironmentVariable(\\\"\", \"DOTNET_RUNNING_IN_CONTAINER\\\") ?? \\\"false\\\"); var metadata = new Dictionary<string, string> { { \\\"namesp\", \"ace\\\", \\\"dapr-trafficcontrol\\\" } }; if (runningInK8s) { var k8sSecrets = daprClient.GetSecretAsync( \\\"ku\", \"bernetes\\\", \\\"trafficcontrol-secrets\\\", metadata).Result; _fineCalculatorLicenseKey = k8sSecrets[\\\"finec\", \"alculator.licensekey\\\"]; } else { var secrets = daprClient.GetSecretAsync( \\\"trafficcontrol-secrets\\\", \", \"\\\"finecalculator.licensekey\\\", metadata).Result; _fineCalculatorLicenseKey = secrets[\\\"finecalculator.l\", \"icensekey\\\"]; } }\\n\\nThe code determines whether the service is running in Kubernetes or self-hosted mo\", \"de. This check is necessary because a different secrets management component must be used for each s\", \"ituation. The first argument of the GetSecretAsync method is the name of the Dapr component. The sec\", \"ond argument is the name of the secret. The metadata passed in as the third argument specifies the n\", \"amespace that contains the secret. The value of the finecalculator.licensekey secret is stored in a \", \"private field for later use.\\n\\nUsing Dapr secrets management offers several benefits:\\n\\n1. No sensitiv\", \"e information is stored in code or application configuration files.\\n\\n2. No need to learn any new API\", \" for interacting with a secrets store.\\n\\nSummary\\n\\nThe Dapr secrets management building block provides\", \" capabilities for storing and retrieving sensitive configuration settings like passwords and connect\", \"ion-strings. It keeps secrets private and prevents them from being accidentally disclosed.\\n\\nThe buil\", \"ding block supports several different secret stores and hides their complexity with the Dapr secrets\", \" API.\\n\\nThe Dapr .NET SDK provides a DaprClient object to retrieve secrets. It also includes a .NET c\", \"onfiguration provider that adds secrets to the .NET configuration system. Once loaded, you can consu\", \"me these secrets in your .NET code.\\n\\nYou can use secret scopes to control access to specific secrets\", \".\\n\\nReferences\\n\\n\\n\\nBeyond the Twelve-Factor Application\\n\\n135\\n\\nCHAPTER 12 | The Dapr secrets management\", \" building block\\n\\n\\n\\nDapr supported secret stores\\n\\n136\\n\\nCHAPTER 12 | The Dapr secrets management build\", \"ing block\\n\\nCHAPTER 13\\n\\nDapr reference application\\n\\nOver the course of this book, you\\u2019ve learned abou\", \"t the foundational benefits of Dapr. You saw how Dapr can help you and your team construct distribut\", \"ed applications while reducing architectural and operational complexity. Along the way, you\\u2019ve had t\", \"he opportunity to build some small Dapr apps. Now, it\\u2019s time to explore how a more complex applicati\", \"on can benefit from Dapr.\\n\\nBut, first a little history.\\n\\neShopOnContainers\\n\\nSeveral years ago, Micro\", \"soft, in partnership with leading community experts, released a popular guidance book, entitled .NET\", \" Microservices for Containerized .NET Applications. Figure 12-1 shows the book:\\n\\nFigure 12-1. .NET M\", \"icroservices: Architecture for Containerized .NET Applications.\\n\\nThe book dove deep into the princip\", \"les, patterns, and best practices for building distributed applications. It included a full-featured\", \" microservice reference application that showcased the architectural concepts. Entitled, eShopOnCont\", \"ainers, the application hosts an e-Commerce storefront that sells various items, including clothing \", \"and coffee mugs. Built in .NET, the application is cross- platform and can run in either Linux or Wi\", \"ndows containers. Figure 12-2 shows the original eShop architecture.\\n\\n137\\n\\nCHAPTER 13 | Dapr referen\", \"ce application\\n\\nFigure 12-2. Original ShopOnContainers reference application.\\n\\nAs you can see, eShop\", \"OnContainers includes many moving parts:\\n\\n1.\\n\\nThree different frontend clients.\\n\\n2.\\n\\nAn application \", \"gateway to abstract backend services from the frontend.\\n\\n3.\\n\\nSeveral backend core microservices.\\n\\n4.\", \"\\n\\nAn event bus component that enables asynchronous pub/sub messaging.\\n\\nThe eShopOnContainers referen\", \"ce application has been widely accepted across the .NET community and used to model many large comme\", \"rcial microservice applications.\\n\\neShopOnDapr\\n\\nAn updated version of eShop accompanies this book. It\", \"\\u2019s called eShopOnDapr. The update evolves the earlier eShopOnContainers application by integrating D\", \"apr building blocks. Figure 12-3 shows the new solution architecture:\\n\\n[eShopOnDapr reference applic\", \"ation architecture](#g\\ufffd\\ufffd\\ufffdr&\\ufffd<\\ufffd\\ufffdp\\ufffd\\ufffdr\\ufffdm\\u0433z\\ufffd!c(*\\ufffd- \\u03ce\\ufffd9\\ufffd\\ufffd\\ufffd\\ufffd>4)\\n\\nFigure 12-3. eShopOnDapr reference applic\", \"ation architecture.\\n\\nWhile eShopOnDapr focuses on Dapr, the architecture has also been streamlined a\", \"nd simplified.\\n\\n1.\\n\\nA Single Page Application running on Blazor WebAssembly sends user requests to a\", \"n API gateway.\\n\\n2.\\n\\nThe API gateway abstracts the backend core microservices from the frontend clien\", \"t. It\\u2019s implemented using Envoy, a high performant, open-source service proxy. Envoy routes incoming\", \"\\n\\n138\\n\\nCHAPTER 13 | Dapr reference application\\n\\nrequests to backend microservices. Most requests are\", \" simple CRUD operations (for example, get the list of brands from the catalog) and handled by a dire\", \"ct call to a backend microservice.\\n\\n3. Other requests are more logically complex and require multipl\", \"e microservice calls to work together. For these cases, eShopOnDapr implements an aggregator microse\", \"rvice that orchestrates a workflow across those microservices needed to complete the operation.\\n\\n4.\\n\", \"\\nThe core backend microservices implement the required functionality for an e-Commerce store. Each i\", \"s self-contained and independent of the others. Following widely accepted domain decomposition patte\", \"rns, each microservice isolates a specific business capability:\\n\\n\\u2013\\n\\nThe basket service manages the c\", \"ustomer\\u2019s shopping basket experience.\\n\\n\\u2013\\n\\nThe catalog service manages product items available for sa\", \"le.\\n\\n\\u2013\\n\\nThe identity service manages authentication and identity.\\n\\n\\u2013\\n\\nThe ordering service handles a\", \"ll aspects of placing and managing orders.\\n\\n\\u2013\\n\\nThe payment service transacts the customer\\u2019s payment.\", \"\\n\\n5.\\n\\nAdhering to best practices, each microservice maintains its own persistent storage. The applic\", \"ation doesn\\u2019t share a single datastore.\\n\\n6.\\n\\nFinally, the event bus wraps the Dapr publish/subscribe\", \" components. It enables asynchronous publish/subscribe messaging across microservices. Developers ca\", \"n plug in any Dapr-supported message broker component.\\n\\nApplication of Dapr building blocks\\n\\nIn eSho\", \"pOnDapr, Dapr building blocks replace a large amount of complex, error-prone plumbing code.\\n\\nFigure \", \"12-4 shows the Dapr integration in the application.\\n\\nFigure 12-4. Dapr integration in eShopOnDapr.\\n\\n\", \"139\\n\\nCHAPTER 13 | Dapr reference application\\n\\nThe above figure shows the Dapr building blocks (repre\", \"sented as green numbered boxes) that each eShopOnDapr service consumes.\\n\\n1.\\n\\nThe API gateway and web\", \" shopping aggregator services use the service invocation building block to invoke methods on the bac\", \"kend services.\\n\\n2.\\n\\nThe backend services communicate asynchronously using the publish & subscribe bu\", \"ilding block.\\n\\n3.\\n\\nThe basket service uses the state management building block to store the state of\", \" the customer\\u2019s shopping basket.\\n\\n4.\\n\\nThe original eShopOnContainers demonstrates DDD concepts and p\", \"atterns in the ordering service. eShopOnDapr uses the actor building block as an alternative impleme\", \"ntation. The turn- based access model of actors makes it easy to implement a stateful ordering proce\", \"ss with support for cancellation.\\n\\n5.\\n\\nThe ordering service sends order confirmation e-mails using t\", \"he bindings building block.\\n\\n6.\\n\\nSecret management is done by the secrets building block.\\n\\nThe follo\", \"wing sections provide more detail on how the Dapr building blocks are applied in eShopOnDapr.\\n\\nState\", \" management\\n\\nIn eShopOnDapr, the Basket service uses the state management building block to persist \", \"the contents of the customer\\u2019s shopping basket. The original eShopOnContainers architecture used an \", \"IBasketRepository interface to read and write data for the basket service. The RedisBasketRepository\", \" class provided the implementation using Redis as the underlying data store. To compare and contrast\", \", the original eShopOnContainers implementation is presented below:\\n\\npublic class RedisBasketReposit\", \"ory : IBasketRepository { private readonly ConnectionMultiplexer _redis; private readonly IDatabase \", \"_database;\\n\\npublic RedisBasketRepository(ConnectionMultiplexer redis) { _redis = redis; _database = \", \"redis.GetDatabase(); }\\n\\npublic async Task<CustomerBasket> GetBasketAsync(string customerId) { var da\", \"ta = await _database.StringGetAsync(customerId);\\n\\nif (data.IsNullOrEmpty) { return null; }\\n\\nreturn J\", \"sonConvert.DeserializeObject<CustomerBasket>(data); }\\n\\n// ... }\\n\\n140\\n\\nCHAPTER 13 | Dapr reference ap\", \"plication\\n\\nThis code uses the third party StackExchange.Redis NuGet package. The following steps are\", \" required to load the shopping basket for a given customer:\\n\\n1.\\n\\nInject a Redis ConnectionMultiplexe\", \"r into the constructor. The ConnectionMultiplexer is registered with the dependency injection framew\", \"ork in the Program.cs file:\\n\\nservices.AddSingleton<ConnectionMultiplexer>(sp => { var settings = spG\", \"etRequiredService<IOptions<BasketSettings>>().Value; var configuration = ConfigurationOptions.Parse(\", \"settingsConnectionString, true); configuration.ResolveDns = true; return ConnectionMultiplexer.Conne\", \"ct(configuration); });\\n\\n1. Use the ConnectionMultiplexer to create an IDatabase instance in each con\", \"suming class.\\n\\n2. Use the IDatabase instance to execute a Redis StringGet call using the given custo\", \"merId as the\\n\\nkey.\\n\\n3.\\n\\nCheck if data is loaded from Redis; if not, return null.\\n\\n4. Deserialize the\", \" data from Redis to a CustomerBasket object and return the result.\\n\\nIn the updated eShopOnDapr refer\", \"ence application, a new DaprBasketRepository class replaces the RedisBasketRepository class:\\n\\npublic\", \" class DaprBasketRepository : IBasketRepository { private const string StoreName = \\\"eshop-statestore\", \"\\\";\\n\\nprivate readonly DaprClient _daprClient;\\n\\npublic DaprBasketRepository(DaprClient daprClient) { _\", \"daprClient = daprClient; }\\n\\npublic Task<CustomerBasket> GetBasketAsync(string customerId) => _daprCl\", \"ient.GetStateAsync<CustomerBasket>(StoreName, customerId);\\n\\n// ... }\\n\\nThe updated code uses the Dapr\", \" .NET SDK to read and write data using the state management building block. The new steps to load th\", \"e basket for a customer are dramatically simplified:\\n\\n1.\\n\\nInject a DaprClient into the constructor. \", \"The DaprClient is registered with the dependency injection framework in the Program.cs`_ file.\\n\\n2. U\", \"se the DaprClient.GetStateAsync method to load the customer\\u2019s shopping basket items from the configu\", \"red state store and return the result.\\n\\nThe updated implementation still uses Redis as the underlyin\", \"g data store. But, note how Dapr abstracts the StackExchange.Redis references and complexity from th\", \"e application. The application no longer requires a direct dependency on Redis. A Dapr configuration\", \" file is all that\\u2019s needed:\\n\\n141\\n\\nCHAPTER 13 | Dapr reference application\\n\\napiVersion: dapr.io/v1alp\", \"ha1 kind: Component metadata: name: eshop-statestore namespace: eshop spec: type: state.redis versio\", \"n: v1 metadata: - name: redisHost value: redis:6379 - name: redisPassword secretKeyRef: name: redisP\", \"assword auth: secretStore: eshop-secretstore\\n\\nThe Dapr implementation also simplifies changing the u\", \"nderlying data store. Switching to Azure Table Storage, for example, requires only changing the cont\", \"ents of the configuration file. No code changes are necessary.\\n\\nService invocation\\n\\nThe original eSh\", \"opOnContainers used a mix of HTTP/REST and gRPC services. The use of gRPC was limited to communicati\", \"on between an aggregator service and core backend services. Figure 12-5 shows the original architect\", \"ure:\\n\\nFigure 12-5. gRPC and HTTP/REST calls in eShopOnContainers.\\n\\nNote the steps from the previous \", \"figure:\\n\\n1.\\n\\nThe frontend calls the API gateway using HTTP/REST.\\n\\n142\\n\\nCHAPTER 13 | Dapr reference a\", \"pplication\\n\\n2.\\n\\nThe API gateway forwards simple CRUD (Create, Read, Update, Delete) requests directl\", \"y to a core backend service using HTTP/REST.\\n\\n3.\\n\\nThe API gateway forwards complex requests that inv\", \"olve coordinated backend service calls to the web shopping aggregator service.\\n\\n4.\\n\\nThe aggregator s\", \"ervice uses gRPC to call core backend services.\\n\\nIn the updated eShopOnDapr implementation, Dapr sid\", \"ecars are added to the services and API gateway. Figure 12-6 show the updated architecture:\\n\\nFigure \", \"12-6. Updated eShop architecture using Dapr.\\n\\nNote the updated steps from the previous figure:\\n\\n1.\\n\\n\", \"The frontend still uses HTTP/REST to call the API gateway.\\n\\n2.\\n\\nThe API gateway forwards HTTP reques\", \"ts to its Dapr sidecar.\\n\\n3.\\n\\nThe API gateway sidecar sends the request to the sidecar of the aggrega\", \"tor or backend service.\\n\\n4.\\n\\nThe aggregator service uses the Dapr .NET SDK to call backend services \", \"through their sidecar architecture.\\n\\nDapr implements calls between sidecars with gRPC. So even if yo\", \"u\\u2019re invoking a remote service with HTTP/REST semantics, a part of the transport is implemented usin\", \"g gRPC.\\n\\nThe eShopOnDapr reference application benefits from the Dapr service invocation building bl\", \"ock. The benefits also include service discovery, automatic mTLS, and built-in observability.\\n\\nForwa\", \"rd HTTP requests using Envoy and Dapr\\n\\nBoth the original and updated eShop application leverage the \", \"Envoy proxy as an API gateway. Envoy is an open-source proxy and communication bus that is popular a\", \"cross modern distributed applications. Originating from Lyft, Envoy is owned and maintained by the C\", \"loud-Native Computing Foundation.\\n\\n143\\n\\nCHAPTER 13 | Dapr reference application\\n\\nIn the original eSh\", \"opOnContainers implementation, the Envoy API gateway forwarded incoming HTTP requests directly to ag\", \"gregator or backend services. In the new eShopOnDapr, the Envoy proxy forwards the request to a Dapr\", \" sidecar.\\n\\nEnvoy is configured using a YAML definition file to control the proxy\\u2019s behavior. To enab\", \"le Envoy to forward HTTP requests to a Dapr sidecar container, a dapr cluster is added to the config\", \"uration. The cluster configuration contains a host that points to the HTTP port on which the Dapr si\", \"decar is listening:\\n\\nclusters: - name: dapr connect_timeout: 0.25s type: strict_dns hosts: - socket_\", \"address: address: 127.0.0.1 port_value: 3500\\n\\nThe Envoy route configuration is updated to rewrite in\", \"coming requests as calls to the Dapr sidecar (pay close attention to the prefix_rewrite key/value pa\", \"ir):\\n\\nname: \\\"c-short\\\" match: prefix: \\\"/c/\\\" route: auto_host_rewrite: true prefix_rewrite: \\\"/v1.0/inv\", \"oke/catalog-api/method/\\\" cluster: dapr\\n\\nConsider a scenario where the frontend client wants to retri\", \"eve a list of catalog items. The Catalog API provides an endpoint for getting the catalog items:\\n\\n[R\", \"oute(\\\"api/v1/[controller]\\\")] [ApiController] public class CatalogController : ControllerBase {\\n\\n[Htt\", \"pGet(\\\"items/by_page\\\")] [ProducesResponseType(typeof(PaginatedItemsViewModel), (int)HttpStatusCode.OK\", \")] public async Task<PaginatedItemsViewModel> ItemsAsync( [FromQuery] int typeId = -1, [FromQuery] i\", \"nt brandId = -1, [FromQuery] int pageSize = 10, [FromQuery] int pageIndex = 0) { // ... }\\n\\nFirst, th\", \"e frontend makes a direct HTTP call to the Envoy API gateway.\\n\\nGET http://<api-gateway>/c/api/v1/cat\", \"alog/items\\n\\nThe Envoy proxy matches the route, rewrites the HTTP request, and forwards it to the inv\", \"oke API of its Dapr sidecar:\\n\\nGET http://127.0.0.1:3500/v1.0/invoke/catalog-api/method/api/v1/catalo\", \"g/items\\n\\n144\\n\\nCHAPTER 13 | Dapr reference application\\n\\nThe sidecar handles service discovery and rou\", \"tes the request to the Catalog API sidecar. Finally, the sidecar calls the Catalog API to execute th\", \"e request, fetch catalog items, and return a response:\\n\\nGET http://localhost/api/v1/catalog/items\\n\\nM\", \"ake aggregated service calls using the .NET SDK\\n\\nMost calls from the eShop frontend are simple CRUD \", \"calls. The API gateway forwards them to a single service for processing. Some scenarios, however, re\", \"quire multiple backend services to work together to complete a request. For the more complex calls, \", \"the web shopping aggregator service mediates the cross service workflow. Figure 12-7 show the proces\", \"sing sequence of adding an item to your shopping basket:\\n\\nFigure 12-7. Backend call requiring multip\", \"le services.\\n\\nThe aggregator service first retrieves catalog items from the Catalog API. It then val\", \"idates item availability and pricing. Finally, the aggregator service updates the shopping basket by\", \" calling the Basket API.\\n\\nThe aggregator service contains a BasketController that provides an endpoi\", \"nt for updating the shopping basket:\\n\\n[Route(\\\"api/v1/[controller]\\\")] [Authorize] [ApiController] pub\", \"lic class BasketController : ControllerBase { private readonly ICatalogService _catalog; private rea\", \"donly IBasketService _basket;\\n\\n[HttpPost] [HttpPut] [ProducesResponseType((int)HttpStatusCode.BadReq\", \"uest)] [ProducesResponseType(typeof(BasketData), (int)HttpStatusCode.OK)] public async Task<ActionRe\", \"sult<BasketData>> UpdateAllBasketAsync( [FromBody] UpdateBasketRequest data, [FromHeader] string aut\", \"horization) { BasketData basket;\\n\\n145\\n\\nCHAPTER 13 | Dapr reference application\\n\\nif (data.Items is nu\", \"ll || !data.Items.Any()) { basket = new(); } else { // Get the item details from the catalog API. va\", \"r catalogItems = await _catalog.GetCatalogItemsAsync( data.Items.Select(x => x.ProductId));\\n\\nif (cat\", \"alogItems == null) { return BadRequest( \\\"Catalog items were not available for the specified items in\", \" the basket.\\\"); }\\n\\n// Check item availability and prices; store results in basket object. basket = C\", \"reateValidatedBasket(data.Items, catalogItems); }\\n\\n// Save the updated shopping basket. await _baske\", \"t.UpdateAsync(basket, authorization.Substring(\\\"Bearer \\\".Length));\\n\\nreturn basket; }\\n\\n// ... }\\n\\nThe U\", \"pdateAllBasketAsync method gets the Authorization header of the incoming request using a FromHeader \", \"attribute. The Authorization header contains the access token that is needed to call protected backe\", \"nd services.\\n\\nAfter receiving a request to update the basket, the aggregator service calls the Catal\", \"og API to get the item details. The Basket controller uses an injected ICatalogService object to mak\", \"e that call and communicate with the Catalog API. The original implementation of the interface used \", \"gRPC to make the call. The updated implementation uses Dapr service invocation with HttpClient suppo\", \"rt:\\n\\npublic class CatalogService : ICatalogService { private readonly HttpClient _httpClient;\\n\\npubli\", \"c CatalogService(HttpClient httpClient) { _httpClient = httpClient; }\\n\\npublic Task<IEnumerable<Catal\", \"ogItem>> GetCatalogItemsAsync(IEnumerable<int> ids) { var requestUri = $\\\"api/v1/catalog/items/by_ids\", \"?ids={string.Join(\\\",\\\", ids)}\\\";\\n\\nreturn _httpClient.GetFromJsonAsync<IEnumerable<CatalogItem>>(reques\", \"tUri); }\\n\\n// ... }\\n\\n146\\n\\nCHAPTER 13 | Dapr reference application\\n\\nNotice how no Dapr-specific code i\", \"s required to make the service invocation call. All communication is done using the standard HttpCli\", \"ent object.\\n\\nThe Dapr HttpClient is configured for the CatalogService class on program startup:\\n\\nbui\", \"lder.Services.AddSingleton<ICatalogService, CatalogService>( _ => new CatalogService(DaprClient.Crea\", \"teInvokeHttpClient(\\\"catalog-api\\\")));\\n\\nThe other call made by the aggregator service is to the Basket\", \" API. It only allows authorized requests. The access token is passed along in an Authorization reque\", \"st header to ensure the call succeeds:\\n\\npublic class BasketService : IBasketService { public Task Up\", \"dateAsync(BasketData currentBasket, string accessToken) { var request = new HttpRequestMessage(HttpM\", \"ethod.Post, \\\"api/v1/basket\\\") { Content = JsonContent.Create(currentBasket) }; request.Headers.Author\", \"ization = new AuthenticationHeaderValue(\\\"Bearer\\\", accessToken);\\n\\nvar response = await _httpClient.Se\", \"ndAsync(request); response.EnsureSuccessStatusCode(); }\\n\\n// ... }\\n\\nIn this example too, only standar\", \"d HttpClient functionality is used to call the service. This allows developers who are already famil\", \"iar with HttpClient to reuse their existing skills. It even enables existing HttpClient code to use \", \"Dapr service invocation without making any changes.\\n\\nPublish & subscribe\\n\\nBoth eShopOnContainers and\", \" eShopOnDapr use the pub/sub pattern for communicating integration events across microservices. Inte\", \"gration events include:\\n\\nWhen a user checks-out a shopping basket.\\n\\nWhen a payment for an order has \", \"succeeded.\\n\\nWhen the grace-period of a purchase has expired.\\n\\nNote\\n\\nThink of an Integration Event as\", \" an event that takes place across multiple services.\\n\\nEventing in eShopOnContainers is based on the \", \"following IEventBus interface:\\n\\npublic interface IEventBus { void Publish(IntegrationEvent integrati\", \"onEvent);\\n\\nvoid Subscribe<T, THandler>() where TEvent : IntegrationEvent where THandler : IIntegrati\", \"onEventHandler<T>; }\\n\\n147\\n\\nCHAPTER 13 | Dapr reference application\\n\\nConcrete implementations of this\", \" interface for both RabbitMQ and Azure Service Bus are found in eShopOnContainers. Each implementati\", \"on included a large amount of custom plumbing code that was complex to understand and difficult to m\", \"aintain.\\n\\nThe newer eShopOnDapr significantly simplifies pub/sub behavior by using Dapr. To start, t\", \"he IEventBus interface was reduced to a single method:\\n\\npublic interface IEventBus { Task PublishAsy\", \"nc(IntegrationEvent integrationEvent); }\\n\\nPublish events\\n\\nIn eShopOnDapr, a single DaprEventBus impl\", \"ementation can support any Dapr-supported message broker. The following code block shows the simplif\", \"ied Publish method. Note how the PublishAsync method uses the Dapr client to publish an event:\\n\\npubl\", \"ic class DaprEventBus : IEventBus { private const string DAPR_PUBSUB_NAME = \\\"pubsub\\\";\\n\\nprivate reado\", \"nly DaprClient _dapr; private readonly ILogger _logger;\\n\\npublic DaprEventBus(DaprClient dapr, ILogge\", \"r<DaprEventBus> logger) { _dapr = dapr; _logger = logger; }\\n\\npublic async Task PublishAsync(Integrat\", \"ionEvent integrationEvent) { var topicName = integrationEvent.GetType().Name;\\n\\n_logger.LogInformatio\", \"n( \\\"Publishing event {@Event} to {PubsubName}.{TopicName}\\\", integrationEvent, DAPR_PUBSUB_NAME, topi\", \"cName);\\n\\n// We need to make sure that we pass the concrete type to PublishEventAsync, // which can b\", \"e accomplished by casting the event to dynamic. This ensures // that all event fields are properly s\", \"erialized. await _dapr.PublishEventAsync(DAPR_PUBSUB_NAME, topicName, (object)integrationEvent); } }\", \"\\n\\nAs you can see in the code snippet, the topic name is derived from event type\\u2019s name. Because all \", \"eShop services use the IEventBus abstraction, retrofitting Dapr required absolutely no change to the\", \" mainline application code.\\n\\n148\\n\\nCHAPTER 13 | Dapr reference application\\n\\nImportant\\n\\nThe Dapr SDK u\", \"ses System.Text.Json to serialize/deserialize messages. However, System.Text.Json doesn\\u2019t serialize \", \"properties of derived classes by default. In the eShop code, an event is sometimes explicitly declar\", \"ed as an IntegrationEvent, the base class for integration events. This construct allows the concrete\", \" event type to be determined dynamically at run time based on business logic. As a result, the event\", \" is serialized using the type information of the base class and not the derived class. To force Syst\", \"em.Text.Json to serialize the properties of both the base and derived class, the code uses object as\", \" the generic type parameter. For more information, see the .NET documentation.\\n\\nWith Dapr, pub/sub i\", \"nfrastructure code is dramatically simplified. The application doesn\\u2019t need to distinguish between m\", \"essage brokers. Dapr provides this abstraction for you. If needed, you can easily swap out message b\", \"rokers or configure multiple message broker components with no code changes.\\n\\nSubscribe to events\\n\\nT\", \"he earlier eShopOnContainers app contains SubscriptionManagers to handle the subscription implementa\", \"tion for each message broker. Each manager contains complex message broker-specific code for handlin\", \"g subscription events. To receive events, each service has to explicitly register a handler for each\", \" event-type.\\n\\neShopOnDapr streamlines the plumbing for event subscriptions by using Dapr ASP.NET Cor\", \"e integration. Each event is handled by an action method in a controller. A Topic attribute decorate\", \"s the action method with the name of the corresponding topic. Here\\u2019s a code snippet taken from the P\", \"aymentService:\\n\\n[Route(\\\"api/v1/[controller]\\\")] [ApiController] public class IntegrationEventControll\", \"er : ControllerBase { private const string DAPR_PUBSUB_NAME = \\\"pubsub\\\";\\n\\n[HttpPost(\\\"OrderStatusChang\", \"edToValidated\\\")] [Topic(DAPR_PUBSUB_NAME, nameof(OrderStatusChangedToValidatedIntegrationEvent))] pu\", \"blic Task HandleAsync( OrderStatusChangedToValidatedIntegrationEvent integrationEvent, [FromServices\", \"] OrderStatusChangedToValidatedIntegrationEventHandler handler) => handler.Handle(integrationEvent);\", \" }\\n\\nIn the Topic attribute, the name of the .NET type of the event is used as the topic name. For ha\", \"ndling the event, an event handler that already existed in the earlier eShopOnContainers code base i\", \"s resolved using dependency injection and invoked. In the previous example, messages received from t\", \"he OrderStatusChangedToValidatedIntegrationEvent topic invoke the existing OrderStatusChangedToValid\", \"atedIntegrationEventHandler event handler. Because Dapr implements the underlying plumbing for subsc\", \"riptions and message brokers, a large amount of original code became obsolete and was removed from t\", \"he code-base. Much of this code was complex to understand and challenging to maintain.\\n\\n149\\n\\nCHAPTER\", \" 13 | Dapr reference application\\n\\nUse pub/sub components\\n\\nWithin the eShopOnDapr repository, a deplo\", \"yment folder contains files for deploying the application using different deployment modes: Docker C\", \"ompose and Kubernetes. A dapr folder exists within each of these folders that holds a components fol\", \"der. This folder holds a file eshop-pubsub.yaml. It specifies the Dapr pub/sub component that the ap\", \"plication will use for pub/sub behavior. As you saw in the earlier code snippets, the name of the pu\", \"b/sub component used is pubsub. Here\\u2019s the content of the eshop-pubsub.yaml file in the deployment/c\", \"ompose/dapr/components folder:\\n\\napiVersion: dapr.io/v1alpha1 kind: Component metadata: name: pubsub \", \"namespace: eshop spec: type: pubsub.rabbitmq version: v1 metadata: - name: host value: \\\"amqp://rabbi\", \"tmq:5672\\\"\\n\\nThe configuration specifies RabbitMQ as the underlying infrastructure. To change message \", \"brokers, you need only to configure a different message broker, such as NATS or Azure Service Bus an\", \"d update the yaml file. With Dapr, there are no changes to your mainline service code when switching\", \" message brokers.\\n\\nYou can also easily use multiple message brokers in a single application. Many ti\", \"mes a system will handle workloads with different characteristics. One event may occur 10 times a da\", \"y, but another event occurs 5,000 times per second. You may benefit by partitioning messaging traffi\", \"c to different message brokers. With Dapr, you can add multiple pub/sub component configurations, ea\", \"ch with a different name.\\n\\nBindings\\n\\neShopOnDapr uses the bindings building block for sending e-mail\", \"s. When a user places an order, the application sends an order confirmation e-mail using the SMTP ou\", \"tput binding. You can find this binding in the eshop-email.yaml file in the components folder:\\n\\napiV\", \"ersion: dapr.io/v1alpha1 kind: Component metadata: name: sendmail namespace: eshop spec: type: bindi\", \"ngs.smtp version: v1 metadata: - name: host value: maildev - name: port value: 25 - name: user secre\", \"tKeyRef: name: Smtp.User\\n\\n150\\n\\nCHAPTER 13 | Dapr reference application\\n\\nkey: Smtp.User - name: passw\", \"ord secretKeyRef: name: Smtp.Password key: Smtp.Password - name: skipTLSVerify value: true auth: sec\", \"retStore: eshop-secretstore scopes: - ordering-api\\n\\nDapr gets the username and password for connecti\", \"ng to the SMTP server from a secret reference. This approach keeps secrets outside of the configurat\", \"ion file. To learn more about Dapr secrets, read the secrets building block chapter.\\n\\nThe binding co\", \"nfiguration specifies a binding component that can be invoked using the /sendmail endpoint on the Da\", \"pr sidecar. Here\\u2019s a code snippet in which an email is sent whenever an order is started:\\n\\npublic Ta\", \"sk Handle(OrderStartedDomainEvent notification, CancellationToken cancellationToken) { var message =\", \" CreateEmailBody(notification); var metadata = new Dictionary<string, string> { [\\\"emailFrom\\\"] = \\\"eSh\", \"opOn@dapr.io\\\", [\\\"emailTo\\\" = notification.UserName, [\\\"subject\\\"] = $\\\"Your eShopOnDapr order #{notifica\", \"tion.Order.Id}\\\" }; return _daprClient.InvokeBindingAsync(\\\"sendmail\\\", \\\"create\\\", message, metadata, ca\", \"ncellationToken); }\\n\\npublic Task SendOrderConfirmationAsync(Order order) { var message = CreateEmail\", \"Body(order);\\n\\nreturn _daprClient.InvokeBindingAsync( \\\"sendmail\\\", \\\"create\\\", CreateEmailBody(order), n\", \"ew Dictionary<string, string> { [\\\"emailFrom\\\"] = \\\"eshopondapr@example.com\\\", [\\\"emailTo\\\"] = order.Buyer\", \"Email, [\\\"subject\\\"] = $\\\"Your eShopOnDapr Order #{order.OrderNumber}\\\" }); }\\n\\nAs you can see in this ex\", \"ample, message contains the message body. The CreateEmailBody method simply formats a string with th\", \"e body text. The name of the binding to invoke is sendmail and the operation is create. The metadata\", \" specifies the email sender, recipient, and subject for the email message. If these values are stati\", \"c, they can also be included in the metadata fields in the configuration file.\\n\\n151\\n\\nCHAPTER 13 | Da\", \"pr reference application\\n\\nActors\\n\\nIn the original eShopOnContainers solution, the Ordering service p\", \"rovides a great example of how to use DDD design patterns in a .NET microservice. As the updated eSh\", \"opOnDapr focuses on Dapr, the Ordering service now uses the actors building block to implement its b\", \"usiness logic.\\n\\nThe ordering process consists of the following steps:\\n\\n1.\\n\\nThe customer submits the \", \"order. There\\u2019s a grace period before any further processing occurs. During the grace period, the cus\", \"tomer can cancel the order.\\n\\n2.\\n\\nThe system checks that there\\u2019s available stock.\\n\\n3.\\n\\nThe system pro\", \"cesses the payment.\\n\\n4.\\n\\nThe system ships the order.\\n\\nThe process is implemented using a single Orde\", \"ringProcessActor actor type. Here\\u2019s the interface for the actor:\\n\\npublic interface IOrderingProcessA\", \"ctor : IActor { Task SubmitAsync( string userId, string userName, string street, string city, string\", \" zipCode, string state, string country, CustomerBasket basket);\\n\\nTask NotifyStockConfirmedAsync();\\n\\n\", \"Task NotifyStockRejectedAsync(List<int> rejectedProductIds);\\n\\nTask NotifyPaymentSucceededAsync();\\n\\nT\", \"ask NotifyPaymentFailedAsync();\\n\\nTask<bool> CancelAsync();\\n\\nTask<bool> ShipAsync();\\n\\nTask<Order> Get\", \"OrderDetailsAsync(); }\\n\\nThe process is started when a customer checks out some products. Upon checko\", \"ut, the Basket service publishes a UserCheckoutAcceptedIntegrationEvent message using the Dapr pub/s\", \"ub building block. The Ordering service handles the message in the OrderingProcessEventController cl\", \"ass and calls the SubmitAsync method of the actor:\\n\\n[HttpPost(\\\"UserCheckoutAccepted\\\")] [Topic(DaprPu\", \"bSubName, \\\"UserCheckoutAcceptedIntegrationEvent\\\")] public async Task HandleAsync(UserCheckoutAccepte\", \"dIntegrationEvent integrationEvent) { if (integrationEvent.RequestId != Guid.Empty) { var actorId = \", \"new ActorId(integrationEvent.RequestId.ToString()); var orderingProcess = _actorProxyFactory.CreateA\", \"ctorProxy<IOrderingProcessActor>( actorId, nameof(OrderingProcessActor));\\n\\nawait orderingProcess.Sub\", \"mitAsync(integrationEvent.UserId, integrationEvent.UserName,\\n\\n152\\n\\nCHAPTER 13 | Dapr reference appli\", \"cation\\n\\nintegrationEvent.Street, integrationEvent.City, integrationEvent.ZipCode, integrationEvent.S\", \"tate, integrationEvent.Country, integrationEvent.Basket); } else { _logger.LogWarning( \\\"Invalid Inte\", \"grationEvent - RequestId is missing - {@IntegrationEvent}\\\", integrationEvent); } }\\n\\nIn the example a\", \"bove, the Ordering service first uses the original request ID from the UserCheckoutAcceptedIntegrati\", \"onEvent message as the actor ID. The handler uses the ActorId to create an actor proxy and invokes t\", \"he SubmitAsync method. The following snippet shows the implementation of the SubmitAsync method:\\n\\npu\", \"blic async Task SubmitAsync( string buyerId, string buyerEmail, string street, string city, string s\", \"tate, string country, CustomerBasket basket) { var orderState = new OrderState { OrderDate = DateTim\", \"e.UtcNow, OrderStatus = OrderStatus.Submitted, Description = \\\"Submitted\\\", Address = new OrderAddress\", \"State { Street = street, City = city, State = state, Country = country }, BuyerId = buyerId, BuyerEm\", \"ail = buyerEmail, OrderItems = basket.Items .Select(item => new OrderItemState { ProductId = item.Pr\", \"oductId, ProductName = item.ProductName, UnitPrice = item.UnitPrice, Units = item.Quantity, PictureF\", \"ileName = item.PictureFileName }) .ToList() };\\n\\nawait StateManager.SetStateAsync(OrderDetailsStateNa\", \"me, orderState); await StateManager.SetStateAsync(OrderStatusStateName, OrderStatus.Submitted);\\n\\nawa\", \"it RegisterReminderAsync( GracePeriodElapsedReminder, null, TimeSpan.FromSeconds(_settings.Value.Gra\", \"cePeriodTime), TimeSpan.FromMilliseconds(-1));\\n\\n153\\n\\nCHAPTER 13 | Dapr reference application\\n\\nawait \", \"_eventBus.PublishAsync(new OrderStatusChangedToSubmittedIntegrationEvent( OrderId, OrderStatus.Submi\", \"tted.Name, buyerId, buyerEmail)); }\\n\\nThere\\u2019s a lot going on in the Submit method:\\n\\n1.\\n\\nThe method ta\", \"kes the given arguments to create an OrderState object and saves it in the actor state.\\n\\n2.\\n\\nThe met\", \"hod saves the current status of the process (OrderStatus.Submitted) in the actor state.\\n\\n3.\\n\\nThe met\", \"hod registers a reminder to signal the end of the grace period. Order processing is delayed until th\", \"e end of the grace period to deal with customers changing their mind.\\n\\n4.\\n\\nLastly, the method publis\", \"hes an OrderStatusChangedToSubmittedIntegrationEvent to notify other services of the status change.\\n\", \"\\nWhen the reminder for the grace period ending fires, the actor runtime calls the ReceiveReminderAsy\", \"nc method:\\n\\npublic Task ReceiveReminderAsync( string reminderName, byte[] state, TimeSpan dueTime, T\", \"imeSpan period) { return reminderName switch { GracePeriodElapsedReminder => OnGracePeriodElapsedAsy\", \"nc(), StockConfirmedReminder => OnStockConfirmedSimulatedWorkDoneAsync(), StockRejectedReminder => O\", \"nStockRejectedSimulatedWorkDoneAsync( JsonConvert.DeserializeObject<List<int>>(Encoding.UTF8.GetStri\", \"ng(state))), PaymentSucceededReminder => OnPaymentSucceededSimulatedWorkDoneAsync(), PaymentFailedRe\", \"minder => OnPaymentFailedSimulatedWorkDoneAsync(), _ => Task.CompletedTask }; }\\n\\nAs shown in the sni\", \"ppet above, the ReceiveReminderAsync method handles not just the grace period reminder. The actor al\", \"so uses reminders to simulate background work and introduce some delays in the ordering process. Thi\", \"s makes the process easier to follow in the eShopOnDapr UI where notifications are shown for each st\", \"atus update. The ReceiveReminderAsync method uses the reminder name to determine which method handle\", \"s the reminder. The grace period reminder is handled by the OnGracePeriodElapsedAsync method:\\n\\npubli\", \"c async Task OnGracePeriodElapsedAsync() { var statusChanged = await TryUpdateOrderStatusAsync( Orde\", \"rStatus.Submitted, OrderStatus.AwaitingStockValidation); if (statusChanged) { var order = await Stat\", \"eManager.GetStateAsync<Order>(OrderDetailsStateName);\\n\\nawait _eventBus.PublishAsync(new OrderStatusC\", \"hangedToAwaitingStockValidationIntegrationEvent( OrderId, OrderStatus.AwaitingStockValidation.Name, \", \"\\\"Grace period elapsed; waiting for stock validation.\\\",\\n\\n154\\n\\nCHAPTER 13 | Dapr reference application\", \"\\n\\norder.UserName, order.OrderItems .Select(orderItem => new OrderStockItem(orderItem.ProductId, orde\", \"rItem.Units)))); } }\\n\\nThe OnGracePeriodElapsedAsync method first tries to update the order status to\", \" the new AwaitingStockValidation status. If that succeeds, it retrieves the order details from state\", \" and publishes an OrderStatusChangedToAwaitingStockValidationIntegrationEvent to inform other servic\", \"e of the status change. For example, the Category service subscribes to this event to check the avai\", \"lable stock.\\n\\nLet\\u2019s look at the TryUpdateOrderStatusAsync method to see under which circumstances it\", \" may fail to update the order status:\\n\\nprivate async Task<bool> TryUpdateOrderStatusAsync(OrderStatu\", \"s expectedOrderStatus, OrderStatus newOrderStatus) { var orderStatus = await StateManager.TryGetStat\", \"eAsync<OrderStatus>(OrderStatusStateName); if (!orderStatus.HasValue) { _logger.LogWarning( \\\"Order w\", \"ith Id: {OrderId} cannot be updated because it doesn't exist\\\", OrderId);\\n\\nreturn false; }\\n\\nif (order\", \"Status.Value.Id != expectedOrderStatus.Id) { _logger.LogWarning( \\\"Order with Id: {OrderId} is in sta\", \"tus {Status} instead of expected status {ExpectedStatus}\\\", OrderId, orderStatus.Value.Name, expected\", \"OrderStatus.Name);\\n\\nreturn false; }\\n\\nawait StateManager.SetStateAsync(OrderStatusStateName, newOrder\", \"Status);\\n\\nreturn true; }\\n\\nFirst, the TryUpdateOrderStatusAsync method checks whether there even is a\", \" current order status. If there isn\\u2019t, the order doesn\\u2019t exist. This is a fail-safe that should not \", \"happen with normal application usage. Then, the method checks whether the current order status is th\", \"e status that we expected. Remember that the ordering process is driven by events using the Dapr pub\", \"/sub building block. Event delivery uses at-least-once semantics, so a single message could be recei\", \"ved multiple times. The order status check ensures that even when the same message is received multi\", \"ple times, it is only processed once.\\n\\nThe other steps in the ordering process are all implemented i\", \"n a very similar way to the grace period step. In the next sections, we\\u2019ll look at some other aspect\", \"s of the ordering process, namely cancellation and viewing order details.\\n\\n155\\n\\nCHAPTER 13 | Dapr re\", \"ference application\\n\\nOrder cancellation\\n\\nCustomers are allowed to cancel any order that has not been\", \" paid or shipped yet. The OrdersController class handles incoming order cancellations. It invokes th\", \"e CancelAsync method on the OrderingProcessActor instance for the given order.\\n\\npublic async Task<bo\", \"ol> CancelAsync() { var orderStatus = await StateManager.TryGetStateAsync<OrderStatus>(OrderStatusSt\", \"ateName); if (!orderStatus.HasValue) { _logger.LogWarning( \\\"Order with Id: {OrderId} cannot be cance\", \"lled because it doesn't exist\\\", OrderId);\\n\\nreturn false; }\\n\\nif (orderStatus.Value.Id == OrderStatus.\", \"Paid.Id || orderStatus.Value.Id == OrderStatus.Shipped.Id) { _logger.LogWarning( \\\"Order with Id: {Or\", \"derId} cannot be cancelled because it's in status {Status}\\\", OrderId, orderStatus.Value.Name);\\n\\nretu\", \"rn false; }\\n\\nawait StateManager.SetStateAsync(OrderStatusStateName, OrderStatus.Cancelled);\\n\\nvar ord\", \"er = await StateManager.GetStateAsync<Order>(OrderDetailsStateName);\\n\\nawait _eventBus.PublishAsync(n\", \"ew OrderStatusChangedToCancelledIntegrationEvent( OrderId, OrderStatus.Cancelled.Name, $\\\"The order w\", \"as cancelled by buyer.\\\", order.UserName));\\n\\nreturn true; }\\n\\nThe CancelAsync method consists of the f\", \"ollowing steps:\\n\\n1.\\n\\nFirst, the method ensures that the order exists by retrieving the current order\", \" status.\\n\\n2.\\n\\nIf the order exists, the method checks whether it\\u2019s eligible for cancellation. Any ord\", \"er not in the Paid or Shipped state can be cancelled.\\n\\n3.\\n\\nIf the order can be cancelled, the order \", \"status is changed to Cancelled.\\n\\n4.\\n\\nLastly, the order details are retrieved from state and used to \", \"publish an OrderStatusChangedToCancelledIntegrationEvent to inform the other services.\\n\\nThe CancelAs\", \"ync method is a great example of the usefulness of the turn-based access model of actors. Nowhere in\", \" the method do we need to worry about multiple threads running at the same time. Therefore, the meth\", \"od does not require any explicit locking mechanisms to be correct.\\n\\n156\\n\\nCHAPTER 13 | Dapr reference\", \" application\\n\\nOrder details\\n\\nCustomers can check the status and details of their order in the eShopO\", \"nDapr UI. They can also view a complete history of past orders. Directly querying actor instances fo\", \"r this information is a bad idea because of two reasons:\\n\\n1.\\n\\nLow-latency reads cannot be guaranteed\", \" because actor operations execute serially.\\n\\n2. Querying across actors is inefficient because each a\", \"ctor\\u2019s state needs to be read individually and\\n\\ncan introduce more unpredictable latencies.\\n\\nTo fix \", \"this issue, eShopOnDapr uses a separate read model for any queries on order data. The read model is \", \"stored in a separate SQL database. An ASP.NET Core controller class named UpdateOrderStatusEventCont\", \"roller subscribes to the order status events and builds up the view model. The same UpdateOrderStatu\", \"sEventController class also sends push notifications to the UI to inform the customer of order statu\", \"s updates.\\n\\nThe following snippet shows the code for handling the OrderStatusChangedToSubmittedInteg\", \"rationEvent message:\\n\\n[HttpPost(\\\"OrderStatusChangedToSubmitted\\\")] [Topic(DaprPubSubName, nameof(Orde\", \"rStatusChangedToSubmittedIntegrationEvent))] public async Task HandleAsync( OrderStatusChangedToSubm\", \"ittedIntegrationEvent integrationEvent, [FromServices] IOptions<OrderingSettings> settings, [FromSer\", \"vices] IEmailService emailService) { // Gets the order details from Actor state. var actorId = new A\", \"ctorId(integrationEvent.OrderId.ToString()); var orderingProcess = _actorProxyFactory.CreateActorPro\", \"xy<IOrderingProcessActor>( actorId, nameof(OrderingProcessActor)); // var actorOrder = await orderin\", \"gProcess.GetOrderDetailsAsync(); var readModelOrder = new Order(integrationEvent.OrderId, actorOrder\", \");\\n\\n// Add the order to the read model so it can be queried from the API. // It may already exist if\", \" this event has been handled before (at-least-once semantics). readModelOrder = await _orderReposito\", \"ry.AddOrGetOrderAsync(readModelOrder);\\n\\n// Send a SignalR notification to the client. await SendNoti\", \"ficationAsync(readModelOrder.OrderNumber, integrationEvent.OrderStatus, integrationEvent.BuyerId);\\n\\n\", \"// Send a confirmation e-mail if enabled. if (settings.Value.SendConfirmationEmail) { await emailSer\", \"vice.SendOrderConfirmationAsync(readModelOrder); } }\\n\\nThe handler contains the code for all the acti\", \"ons that must occur after an order is submitted successfully. Because the events originate from the \", \"OrderingProcessActor, we can be sure that any validations performed by the actor have succeeded.\\n\\nTh\", \"e handler performs the following steps:\\n\\n157\\n\\nCHAPTER 13 | Dapr reference application\\n\\n1.\\n\\nFirst, th\", \"e method creates an actor proxy and uses it to retrieve the order details from the actor instance.\\n\\n\", \"2.\\n\\nThe method maps the order details to the read model and stores it in the database. Due to the at\", \"-least-once semantics of the Dapr pub/sub building block, the order may already exist in the databas\", \"e. In that case, it will not be overwritten.\\n\\n3.\\n\\nThe method publishes a push notification for the s\", \"tatus update using SignalR.\\n\\n4.\\n\\nLastly, if enabled, the method sends a confirmation e-mail to the c\", \"ustomer.\\n\\nSubsequent order status updates are all handled equally to each other. The following snipp\", \"et shows what happens when the order status is updated to AwaitingStockValidation:\\n\\n[HttpPost(\\\"Order\", \"StatusChangedToAwaitingStockValidation\\\")] [Topic(DaprPubSubName, nameof(OrderStatusChangedToAwaiting\", \"StockValidationIntegrationEvent))] public Task HandleAsync( OrderStatusChangedToAwaitingStockValidat\", \"ionIntegrationEvent integrationEvent) { // Save the updated status in the read model and notify the \", \"client via SignalR. return UpdateReadModelAndSendNotificationAsync(integrationEvent.OrderId, integra\", \"tionEvent.OrderStatus, integrationEvent.Description, integrationEvent.BuyerId); }\\n\\nprivate async Tas\", \"k UpdateReadModelAndSendNotificationAsync( Guid orderId, string orderStatus, string description, str\", \"ing buyerId) { var order = await _orderRepository.GetOrderByIdAsync(orderId); if (order is not null)\", \" { order.OrderStatus = orderStatus; order.Description = description;\\n\\nawait _orderRepository.UpdateO\", \"rderAsync(order); await SendNotificationAsync(order.OrderNumber, orderStatus, buyerId); } }\\n\\nIn the \", \"snippet, the handler calls the UpdateReadModelAndSendNotificationAsync helper method to handle the s\", \"tatus update:\\n\\n1.\\n\\nThe helper method first loads the current order from the database.\\n\\n2.\\n\\nIf that s\", \"ucceeds, it updates the OrderStatus and Description fields and saves the updated model back to the d\", \"atabase.\\n\\n3.\\n\\nLastly, it sends a push notification to notify the client UI.\\n\\nObservability\\n\\neShopOnD\", \"apr uses Zipkin to visualize distributed traces collected by Dapr. Seq aggregates the eShopOnDapr ap\", \"plication logs. The various services emit structured logging using the SeriLog logging library. Seri\", \"log publishes log events to a construct called a sink. A sink is simply a target platform to which S\", \"erilog writes its logging events. Many Serilog sinks are available, including one for Seq. Seq is th\", \"e Serilog sink used in eShopOnDapr.\\n\\n158\\n\\nCHAPTER 13 | Dapr reference application\\n\\neShopOnDapr also \", \"includes a custom health dashboard that gives insight into the health of the eShop services. This da\", \"shboard uses the built-in health checks mechanism of ASP.NET Core. The dashboard not only provides t\", \"he health status of the services, but also the health of the dependencies of the services, including\", \" the Dapr sidecars.\\n\\nSecrets\\n\\nThe eShopOnDapr reference application uses the secrets building block \", \"for various secrets:\\n\\n\\n\\nThe password for connecting to the Redis cache.\\n\\n\\n\\nThe username and password\", \" for the SMTP server.\\n\\n\\n\\nThe connection strings for the SQL databases.\\n\\nWhen running the application\", \" using Docker Compose, the local file secret store is used. The component configuration file eshop-s\", \"ecretstore.yaml is found in the dapr/components folder of the eShopOnDapr repository:\\n\\napiVersion: d\", \"apr.io/v1alpha1 kind: Component metadata: name: eshop-secretstore namespace: eshop spec: type: secre\", \"tstores.local.file version: v1 metadata: - name: secretsFile value: ./components/eshop-secretstore.j\", \"son - name: nestedSeparator value: \\\".\\\"\\n\\nThe configuration file references the local store file eshop\", \"-secretstore.json located in the same folder:\\n\\n{ \\\"ConnectionStrings\\\": { \\\"CatalogDB\\\": \\\"**********\\\", \\\"\", \"IdentityDB\\\": \\\"**********\\\", \\\"OrderingDB\\\": \\\"**********\\\" }, \\\"Smtp\\\": { \\\"User\\\": \\\"**********\\\", \\\"Password\\\":\", \" \\\"**********\\\" }, \\\"State\\\": { \\\"RedisPassword\\\": \\\"**********\\\" } }\\n\\nThe components folder is specified in\", \" the command-line and mounted as a local folder inside the Dapr sidecar container. Here\\u2019s a snippet \", \"from the docker-compose.override.yml file in the repository root that specifies the volume mount:\\n\\nc\", \"atalog-api-dapr: command: [\\\"./daprd\\\",\\n\\n159\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\\"-app-id\\\", \\\"cat\", \"alog-api\\\", \\\"-app-port\\\", \\\"80\\\", \\\"-components-path\\\", \\\"/components\\\", \\\"-config\\\", \\\"/configuration/eshop-co\", \"nfig.yaml\\\" ] volumes: - \\\"./dapr/components/:/components\\\" - \\\"./dapr/configuration/:/configuration\\\"\\n\\nT\", \"he /components volume mount and --components-path command-line argument are passed into the daprd st\", \"artup command.\\n\\nOnce configured, other component configuration files can also reference the secrets.\", \" Here\\u2019s an example of the state store component configuration consuming secrets:\\n\\napiVersion: dapr.i\", \"o/v1alpha1 kind: Component metadata: name: eshop-statestore namespace: eshop spec: type: state.redis\", \" version: v1 metadata: - name: redisHost value: redis:6379 - name: redisPassword secretKeyRef: name:\", \" State.RedisPassword key: State.RedisPassword - name: actorStateStore value: \\\"true\\\" auth: secretStor\", \"e: eshop-secretstore scopes: - basket-api - ordering-api\\n\\nBenefits of applying Dapr to eShop\\n\\nIn gen\", \"eral, the use of Dapr building blocks adds observability and flexibility to the application:\\n\\n1. Obs\", \"ervability: By using the Dapr building blocks, you gain rich distributed tracing for calls\\n\\nbetween \", \"services and to Dapr components without having to write any code. In eShopOnContainers, a large amou\", \"nt of custom logging is used to provide insight.\\n\\n2.\\n\\nFlexibility: You can now swap out infrastructu\", \"re simply by changing a component configuration file. No code changes are necessary.\\n\\nHere are some \", \"more examples of benefits offered by specific building blocks:\\n\\n\\n\\nService Invocation\\n\\n\\u2013 With Dapr\\u2019s \", \"support for mTLS, services now communicate through encrypted channels.\\n\\n\\u2013 When transient errors occu\", \"r, service calls are automatically retried.\\n\\n160\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\u2013\\n\\nAutoma\", \"tic service discovery reduces the amount of configuration needed for services to find each other.\\n\\n\\n\", \"\\nPublish/Subscribe\\n\\n\\u2013\\n\\neShopOnContainers included a large amount of custom code to support both Azur\", \"e Service Bus and RabbitMQ. Developers used Azure Service Bus for production and RabbitMQ for local \", \"development and testing. An IEventBus abstraction layer was created to enable swapping between these\", \" message brokers. This layer consisted of approximately 700 lines of error-prone code. The updated i\", \"mplementation with Dapr requires only 35 lines of code. That\\u2019s 5% of the original lines of code! Mor\", \"e importantly, the implementation is straightforward and easy to understand.\\n\\n\\u2013\\n\\neShopOnDapr uses Da\", \"pr\\u2019s rich ASP.NET Core integration to use pub/sub. You add Topic attributes to ASP.NET Core controll\", \"er methods to subscribe to messages. Therefore, there\\u2019s no need to write a separate message handler \", \"loop for each message broker.\\n\\n\\u2013 Messages routed to the service as HTTP calls enable the use of ASP.\", \"NET Core\\n\\nmiddleware to add functionality, without introducing new concepts or SDKs to learn.\\n\\n\\n\\nBin\", \"dings\\n\\n\\u2013\\n\\nThe eShopOnContainers solution contained a to-do item for e-mailing an order confirmation \", \"to the customer. With Dapr, implementing email notification was as easy as configuring a resource bi\", \"nding.\\n\\n\\n\\nActors\\n\\n\\u2013\\n\\nThe actors building block makes it easy to create long running, stateful workfl\", \"ows. Thanks to the turn-based access model, there\\u2019s no need for explicit locking mechanisms.\\n\\n\\u2013\\n\\nThe\", \" complexity of the grace period implementation is greatly reduced by using actor reminders instead o\", \"f polling on the database.\\n\\nSummary\\n\\nIn this chapter, you\\u2019re introduced to the eShopOnDapr reference\", \" application. It\\u2019s an evolution of the widely popular eShopOnContainers microservice reference appli\", \"cation. eShopOnDapr replaces a large amount of custom functionality with Dapr building blocks and co\", \"mponents, dramatically simplifying the complexities required to build a microservices application.\\n\\n\", \"References\\n\\n\\n\\neShopOnDapr\\n\\n\\n\\neShopOnContainers\\n\\n\\n\\n.NET Microservices for Containerized .NET Applicat\", \"ions\\n\\n\\n\\nArchitecting Cloud-Native .NET Apps for Azure\\n\\n161\\n\\nCHAPTER 13 | Dapr reference application\\n\", \"\\nCHAPTER 14\\n\\nSummary and the road ahead\\n\\nWe\\u2019re at the end of our Dapr flight. The jet plane flying a\", \"t 20,000 feet from chapter 2 is on final approach and about to land.\\n\\nAs the plane taxis to the gate\", \", let\\u2019s take a minute to review some important conclusions from this guide:\\n\\n\\n\\nDapr - Dapr is a Dist\", \"ributed Application Runtime that streamlines how you build distributed applications. It exposes an a\", \"rchitecture of building blocks and pluggable components. Dapr provides a dynamic glue that binds you\", \"r application with infrastructure capabilities that exist in the Dapr runtime. Instead of building i\", \"nfrastructure plumbing, you and your team focus on delivering business features to customers.\\n\\n\\n\\nOpe\", \"n source and cross-platform - The native Dapr API can be consumed by any platform that supports HTTP\", \" or gRPC. Dapr also provides language-specific SDKs for popular development platforms. Dapr v1.0 sup\", \"ports Go, Python, .NET, Java, PHP, and JavaScript.\\n\\n\\n\\nBuilding blocks - Dapr building blocks encapsu\", \"late distributed application functionality. At the time of this writing, Dapr supports the seven bui\", \"lding blocks shown in figure 13-1.\\n\\n162\\n\\nCHAPTER 14 | Summary and the road ahead\\n\\nFigure 13-1. Dapr \", \"building blocks.\\n\\n\\n\\nComponents - Dapr components provide the concrete implementation for each Dapr b\", \"uilding block capability. They expose a common interface that enables developers to swap out compone\", \"nt implementations without changing application code. Figure 13-2 shows the relationship among compo\", \"nents, building blocks, and your service.\\n\\n163\\n\\nCHAPTER 14 | Summary and the road ahead\\n\\nFigure 13-2\", \". Dapr building block integration.\\n\\n\\n\\nSidecars - Dapr runs alongside your application in a sidecar a\", \"rchitecture, either as a separate process of a container. Your application communicates with the Dap\", \"r APIs over HTTP and gRPC. Sidecars provide isolation and encapsulation as they aren\\u2019t part of the s\", \"ervice, but connected to it. Figure 13-3 shows a sidecar architecture.\\n\\nFigure 13-3. Sidecar archite\", \"cture.\\n\\n164\\n\\nCHAPTER 14 | Summary and the road ahead\\n\\n\\n\\nHosting environments Dapr has cross-platform\", \" support and can run in multiple environments. At the time of this writing, the environments include\", \" a local self-hosted mode and Kubernetes.\\n\\n\\n\\neShopOnDapr - This book includes an accompanying refere\", \"nce application entitled eShopOnDapr. Using a popular e-commerce application domain, the reference a\", \"pplication demonstrates the usage of each building block. It\\u2019s an evolution of the widely popular eS\", \"hopOnContainers, released several years ago.\\n\\nThe road ahead\\n\\nLooking forward, Dapr has the potentia\", \"l to have a profound impact on distributed application development. What can you expect from the Dap\", \"r team and its open-source contributors?\\n\\nAt the time of writing, the list of proposed enhancements \", \"for Dapr include:\\n\\n\\n\\nFeature enhancements to existing building blocks:\\n\\n\\u2013\\n\\nQuery capabilities in sta\", \"te management enabling you to retrieve multiple values.\\n\\n\\u2013\\n\\nTopic filtering in pub/sub enabling you \", \"to filter topics based on their content.\\n\\n\\u2013\\n\\nAn application tracing API in observability that provid\", \"es tracing in the application directly without having to bind to specific libraries.\\n\\n\\u2013\\n\\nBinding and\", \" pub/sub support for actors providing event driven capabilities to the actor programming model. Boun\", \"d components will trigger events and messages invoke methods in the actor.\\n\\n\\n\\nNew building blocks:\\n\\n\", \"\\u2013\\n\\nConfiguration API building block for reading and writing configuration data. The block will bind \", \"to providers that include Azure Configuration Manager or GCP Configuration Management.\\n\\n\\u2013\\n\\nHttp scal\", \"e-to-zero autoscale.\\n\\n\\u2013\\n\\nLeader election building block to provide singleton instances and locking s\", \"emantic capabilities.\\n\\n\\u2013\\n\\nTransparent proxying building block for service invocation, enabling you t\", \"o route messages based on URLs or DNS addresses at the network level.\\n\\n\\u2013\\n\\nResiliency building block \", \"(circuit breakers, bulkheads & timeouts).\\n\\n\\n\\nIntegration with frameworks and cloud native technologi\", \"es. Some examples include:\\n\\n\\u2013\\n\\nDjango\\n\\n\\u2013\\n\\nNodejs\\n\\n\\u2013\\n\\nExpress\\n\\n\\u2013\\n\\nKyma\\n\\n\\u2013 Midway\\n\\n\\n\\nNew language SDKs\", \":\\n\\n\\u2013\\n\\nJavaScript\\n\\n\\u2013\\n\\nRUST\\n\\n\\u2013\\n\\nC++\\n\\n165\\n\\nCHAPTER 14 | Summary and the road ahead\\n\\n\\n\\nNew hosting platf\", \"orms:\\n\\n\\u2013\\n\\nVMs\\n\\n\\u2013\\n\\nAzure IoT Edge\\n\\n\\u2013\\n\\nAzure Stack Edge\\n\\n\\u2013\\n\\nAzure Service Fabric\\n\\n\\n\\nDeveloper and oper\", \"ator productivity tooling:\\n\\n\\u2013\\n\\nVS Code extension.\\n\\n\\u2013\\n\\nRemote Dev Containers for local debugging a De\", \"vOps pipeline development.\\n\\n\\u2013\\n\\nDapr operational dashboard enhancements that will provide deeper visi\", \"bility into the operational concerns of managing Dapr applications.\\n\\nDapr version 1.0 provides devel\", \"opers with a compelling toolbox for building distributed applications. As the proposed enhancement l\", \"ist shows, Dapr is under active development with many new capabilities to come. Stay tuned to the Da\", \"pr site and Dapr announcement blog for future updates.\\n\\n166\\n\\nCHAPTER 14 | Summary and the road ahead\"]"