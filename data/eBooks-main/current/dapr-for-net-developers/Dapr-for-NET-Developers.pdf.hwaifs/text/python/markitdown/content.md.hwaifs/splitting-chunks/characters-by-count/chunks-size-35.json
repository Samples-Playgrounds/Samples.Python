"[\"\\n\\n\\fEDITION v1.2\\n\\nPUBLISHED BY\\n\\nMicrosoft Developer Division, .NET, and Azure Incubations teams\\n\\nA di\", \"vision of Microsoft Corporation\\n\\nOne Microsoft Way\\n\\nRedmond, Washington 98052-6399\\n\\nCopyright \\u00a9 2023\", \" by Microsoft Corporation\\n\\nAll rights reserved. No part of the contents of this book may be reproduc\", \"ed or transmitted in any\\nform or by any means without the written permission of the publisher.\\n\\nThis\", \" book is provided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions, and\\nin\", \"formation expressed in this book, including URL and other Internet website references, may change\\nwi\", \"thout notice.\\n\\nSome examples depicted herein are provided for illustration only and are fictitious. \", \"No real association\\nor connection is intended or should be inferred.\\n\\nMicrosoft and the trademarks l\", \"isted at https://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are\\ntrademarks of the Microsoft group\", \" of companies.\\n\\nMac and macOS are trademarks of Apple Inc.\\n\\nThe Docker whale logo is a registered tr\", \"ademark of Docker, Inc. Used by permission.\\n\\nAll other marks and logos are property of their respect\", \"ive owners.\\n\\nAuthors:\\n\\nRob Vettor, Principal Cloud Solution Architect - thinkingincloudnative.com, M\", \"icrosoft\\n\\nSander Molenkamp, Principal Cloud Architect/Microsoft MVP - sandermolenkamp.com, Info Supp\", \"ort\\n\\nEdwin van Wijk, Principal Solution Architect/Microsoft MVP - defaultconstructor.com, Info Suppo\", \"rt\\n\\nParticipants and Reviewers:\\n\\nMark Russinovich, Azure CTO and Technical Fellow, Azure Office of C\", \"TO, Microsoft\\n\\nNish Anil, Senior Program Manager, .NET team, Microsoft\\n\\nMark Fussell, Principal Prog\", \"ram Manager, Azure Incubations, Microsoft\\n\\nYaron Schneider, Principal Software Engineer, Azure Incub\", \"ations, Microsoft\\n\\nOri Zohar, Senior Program Manager, Azure Incubations, Microsoft\\n\\nEditors:\\n\\nDavid \", \"Pine, Senior Content Developer, .NET team, Microsoft\\n\\nMaira Wenzel, Senior Program Manager, .NET tea\", \"m, Microsoft\\n\\n\\fSteve \\u201cardalis\\u201d Smith, Senior Architect and Trainer, NimblePros\\n\\nVersion\\n\\nThis guide \", \"has been written to cover the Dapr 1.9 version. .NET samples are based on .NET 7.\\n\\nWho should use th\", \"is guide\\n\\nThe audience for this guide is mainly developers, development leads, and architects who ar\", \"e\\ninterested in learning how to build applications designed for the cloud.\\n\\nA secondary audience is \", \"technical decision-makers who plan to choose whether to build their\\napplications using a cloud-nativ\", \"e approach.\\n\\nHow you can use this guide\\n\\nThis guide is available both in PDF form and online. Feel f\", \"ree to forward this document or links to its\\nonline version to your team to help ensure common under\", \"standing of these topics. Most of these\\ntopics benefit from a consistent understanding of the underl\", \"ying principles and patterns, as well as\\nthe trade-offs involved in decisions related to these topic\", \"s. Our goal with this document is to equip\\nteams and their leaders with the information they need to\", \" make well-informed decisions for their\\napplications\\u2019 architecture, development, and hosting.\\n\\n\\fCont\", \"ents\\n\\nForeword - Dapr for .NET Developers ..........................................................\", \"......................... 1\\n\\nThe world is distributed ..............................................\", \"............................................................ 3\\n\\nSummary ............................\", \"....................................................................................................\", \"..................................................... 7\\n\\nDapr at 20,000 feet .......................\", \".......................................................................................... 8\\n\\nDapr a\", \"nd the problem it solves ...........................................................................\", \"............................................................... 8\\n\\nDapr architecture ...............\", \"....................................................................................................\", \".................................................. 9\\n\\nBuilding blocks ..............................\", \"....................................................................................................\", \"................................... 9\\n\\nComponents ..................................................\", \"....................................................................................................\", \"................. 11\\n\\nSidecar architecture .........................................................\", \"................................................................................................ 13\\n\", \"\\nHosting environments ..............................................................................\", \"...................................................................... 14\\n\\nDapr performance consider\", \"ations .............................................................................................\", \".................................... 15\\n\\nDapr and service meshes ...................................\", \"....................................................................................................\", \"............ 16\\n\\nSummary ...........................................................................\", \"....................................................................................................\", \"... 18\\n\\nReferences .................................................................................\", \".......................................................................................... 18\\n\\nGet s\", \"tarted with Dapr ...................................................................................\", \"........................ 19\\n\\nInstall Dapr into your local environment ..............................\", \"....................................................................................... 19\\n\\nBuild yo\", \"ur first Dapr application ..........................................................................\", \"........................................................... 19\\n\\nCreate the application .............\", \"....................................................................................................\", \"................................... 19\\n\\nAdd Dapr State Management ..................................\", \"................................................................................................... \", \"20\\n\\nComponent configuration files ..................................................................\", \"..................................................................... 21\\n\\nBuild a multi-container Da\", \"pr application .....................................................................................\", \"............................... 23\\n\\nCreate the application .........................................\", \"....................................................................................................\", \"....... 23\\n\\nAdd Dapr service invocation ............................................................\", \"............................................................................ 27\\n\\nAdd container suppo\", \"rt .................................................................................................\", \".................................................. 29\\n\\nSummary .....................................\", \"....................................................................................................\", \"......................................... 35\\n\\nReferences ...........................................\", \"....................................................................................................\", \"............................ 35\\n\\nTraffic Control sample application ................................\", \"...................................................... 36\\n\\nUsing Dapr building blocks...............\", \"....................................................................................................\", \"............................ 39\\n\\ni\\n\\nContents\\n\\n\\fHosting .............................................\", \"....................................................................................................\", \"..................................... 40\\n\\nSelf-hosted mode .........................................\", \"....................................................................................................\", \"............... 40\\n\\nKubernetes .....................................................................\", \"....................................................................................................\", \". 41\\n\\nSummary ......................................................................................\", \"............................................................................................ 41\\n\\nRef\", \"erences ............................................................................................\", \"............................................................................... 41\\n\\nThe Dapr state m\", \"anagement building block ...................................................................... 42\\n\\n\", \"What it solves .....................................................................................\", \".................................................................................... 42\\n\\nHow it work\", \"s ..................................................................................................\", \"......................................................................... 43\\n\\nConsistency ..........\", \"....................................................................................................\", \"........................................................... 43\\n\\nConcurrency ........................\", \"....................................................................................................\", \"........................................... 45\\n\\nTransactions .......................................\", \"....................................................................................................\", \"............................ 45\\n\\nUse the Dapr .NET SDK .............................................\", \"....................................................................................................\", \"...... 46\\n\\nASP.NET Core integration ................................................................\", \"............................................................................. 47\\n\\nState store compon\", \"ents ...............................................................................................\", \"...................................................... 47\\n\\nConfiguration ...........................\", \"....................................................................................................\", \"...................................... 48\\n\\nKey prefix strategies ...................................\", \"....................................................................................................\", \"................. 49\\n\\nSample application: Dapr Traffic Control .....................................\", \"............................................................................... 50\\n\\nSummary ........\", \"....................................................................................................\", \"...................................................................... 51\\n\\nReferences ..............\", \"....................................................................................................\", \"......................................................... 52\\n\\nThe Dapr service invocation building b\", \"lock ....................................................................... 53\\n\\nWhat it solves ....\", \"....................................................................................................\", \"................................................................. 53\\n\\nHow it works .................\", \"....................................................................................................\", \"...................................................... 53\\n\\nUse the Dapr .NET SDK ...................\", \"....................................................................................................\", \"................................ 55\\n\\nInvoke HTTP services using HttpClient .........................\", \"........................................................................................... 55\\n\\nInvo\", \"ke HTTP services using DaprClient ..................................................................\", \"................................................. 57\\n\\nInvoke gRPC services using DaprClient ........\", \"....................................................................................................\", \"....... 58\\n\\nName resolution components .............................................................\", \"............................................................................ 58\\n\\nConfiguration .....\", \"....................................................................................................\", \"............................................................ 58\\n\\nSample application: Dapr Traffic Co\", \"ntrol ..............................................................................................\", \"...................... 59\\n\\nSummary .................................................................\", \"....................................................................................................\", \"............. 60\\n\\nReferences .......................................................................\", \"....................................................................................................\", \" 60\\n\\nii\\n\\nContents\\n\\n\\fThe Dapr publish & subscribe building block ....................................\", \"................................ 61\\n\\nWhat it solves ................................................\", \"....................................................................................................\", \"..................... 61\\n\\nHow it works .............................................................\", \"....................................................................................................\", \".......... 62\\n\\nCompeting consumers .................................................................\", \".................................................................................. 66\\n\\nUse the Dapr \", \".NET SDK ...........................................................................................\", \"............................................................ 66\\n\\nPub/sub components ................\", \"....................................................................................................\", \"...................................... 68\\n\\nConfiguration ...........................................\", \"....................................................................................................\", \"...................... 68\\n\\nSample application: Dapr Traffic Control ................................\", \".................................................................................... 69\\n\\nSummary ...\", \"....................................................................................................\", \"........................................................................... 71\\n\\nReferences .........\", \"....................................................................................................\", \".............................................................. 71\\n\\nThe Dapr bindings building block \", \"....................................................................................... 72\\n\\nWhat it \", \"solves .............................................................................................\", \"............................................................................ 72\\n\\nHow it works ......\", \"....................................................................................................\", \"................................................................. 73\\n\\nInput bindings ...............\", \"....................................................................................................\", \"................................................ 73\\n\\nOutput bindings ...............................\", \"....................................................................................................\", \"............................ 74\\n\\nUse the Dapr .NET SDK .............................................\", \"....................................................................................................\", \"...... 76\\n\\nBinding components ......................................................................\", \"..................................................................................... 76\\n\\nCron bindi\", \"ng .................................................................................................\", \"..................................................................... 77\\n\\nSample application: Dapr T\", \"raffic Control .....................................................................................\", \"............................... 78\\n\\nMQTT input binding .............................................\", \"....................................................................................................\", \"....... 79\\n\\nSMTP output binding ....................................................................\", \"................................................................................. 81\\n\\nSummary ......\", \"....................................................................................................\", \"........................................................................ 83\\n\\nReferences ............\", \"....................................................................................................\", \"........................................................... 83\\n\\nThe Dapr actors building block .....\", \"....................................................................................... 84\\n\\nWhat it \", \"solves .............................................................................................\", \"............................................................................ 84\\n\\nHow it works ......\", \"....................................................................................................\", \"................................................................. 85\\n\\nTurn-based access model ......\", \"....................................................................................................\", \"................................... 88\\n\\nTimers and reminders .......................................\", \"....................................................................................................\", \".......... 89\\n\\nState persistence ...................................................................\", \"........................................................................................... 89\\n\\nUse \", \"the Dapr .NET SDK ..................................................................................\", \"..................................................................... 90\\n\\nCall actors from ASP.NET C\", \"ore clients ........................................................................................\", \"............................. 93\\n\\niii\\n\\nContents\\n\\n\\fCall non-.NET actors..............................\", \"....................................................................................................\", \"...................... 94\\n\\nTimers and reminders ....................................................\", \"................................................................................................. 95\", \"\\n\\nSample application: Dapr Traffic Control .........................................................\", \"........................................................... 97\\n\\nSummary ............................\", \"....................................................................................................\", \".................................................. 98\\n\\nReferences ..................................\", \"....................................................................................................\", \"..................................... 99\\n\\nThe Dapr observability building block ....................\", \".......................................................... 100\\n\\nWhat it solves .....................\", \"....................................................................................................\", \".............................................. 101\\n\\nHow it works ...................................\", \"....................................................................................................\", \".................................. 101\\n\\nDistributed tracing ........................................\", \"....................................................................................................\", \"............. 102\\n\\nMetrics .........................................................................\", \"....................................................................................................\", \"... 109\\n\\nLogging ...................................................................................\", \"........................................................................................... 111\\n\\nHea\", \"lth status .........................................................................................\", \"........................................................................... 113\\n\\nDapr dashboard ....\", \"....................................................................................................\", \"...................................................... 114\\n\\nUse the Dapr .NET SDK ..................\", \"....................................................................................................\", \"............................... 115\\n\\nSample application: Dapr Traffic Control ......................\", \"............................................................................................ 115\\n\\nSu\", \"mmary ..............................................................................................\", \".................................................................................. 117\\n\\nReferences .\", \"....................................................................................................\", \"........................................................................ 118\\n\\nThe Dapr secrets manag\", \"ement building block ................................................................ 119\\n\\nWhat it s\", \"olves ..............................................................................................\", \"......................................................................... 119\\n\\nHow it works ........\", \"....................................................................................................\", \"............................................................. 120\\n\\nUse the Dapr .NET SDK ...........\", \"....................................................................................................\", \"...................................... 121\\n\\nSecret store components ................................\", \"....................................................................................................\", \"............. 122\\n\\nConfiguration ...................................................................\", \"................................................................................................ 123\", \"\\n\\nIndirectly consume Dapr secrets ..................................................................\", \"............................................................ 123\\n\\nLocal file .......................\", \"....................................................................................................\", \".................................................. 124\\n\\nKubernetes secret ..........................\", \"....................................................................................................\", \"............................ 126\\n\\nAzure Key Vault ..................................................\", \"....................................................................................................\", \"......... 126\\n\\nScope secrets .......................................................................\", \"............................................................................................ 129\\n\\nSa\", \"mple application: Dapr Traffic Control .............................................................\", \"..................................................... 129\\n\\nSecrets .................................\", \"....................................................................................................\", \"........................................... 131\\n\\nSMTP server credentials ...........................\", \"....................................................................................................\", \"............... 132\\n\\nRedis server credentials ......................................................\", \"......................................................................................... 133\\n\\niv\\n\\nC\", \"ontents\\n\\n\\fFineCalculator component license key .....................................................\", \"............................................................. 134\\n\\nSummary .........................\", \"....................................................................................................\", \"................................................... 135\\n\\nReferences ................................\", \"....................................................................................................\", \"......................................... 135\\n\\nDapr reference application ..........................\", \"....................................................................... 137\\n\\neShopOnContainers .....\", \"....................................................................................................\", \".................................................. 137\\n\\neShopOnDapr ................................\", \"....................................................................................................\", \"................................... 138\\n\\nApplication of Dapr building blocks........................\", \"....................................................................................................\", \" 139\\n\\nState management .............................................................................\", \"........................................................................... 140\\n\\nService invocation \", \"....................................................................................................\", \"...................................................... 142\\n\\nPublish & subscribe ....................\", \"....................................................................................................\", \"............................... 147\\n\\nBindings ......................................................\", \"....................................................................................................\", \"................... 150\\n\\nActors ....................................................................\", \"....................................................................................................\", \".......... 152\\n\\nObservability ......................................................................\", \".............................................................................................. 158\\n\\n\", \"Secrets ............................................................................................\", \".................................................................................... 159\\n\\nBenefits o\", \"f applying Dapr to eShop ...........................................................................\", \"................................................. 160\\n\\nSummary .....................................\", \"....................................................................................................\", \"....................................... 161\\n\\nReferences ............................................\", \"....................................................................................................\", \"......................... 161\\n\\nSummary and the road ahead ..........................................\", \".................................................. 162\\n\\nThe road ahead .............................\", \"....................................................................................................\", \"................................... 165\\n\\nv\\n\\nContents\\n\\n\\fCHAPTER  1\\n\\nForeword - Dapr for .NET\\nDevelope\", \"rs\\n\\nWith the wave of cloud adoption underway, there is a major shift happening towards \\u201ccloud native\", \"\\u201d\\ndevelopment, often built with microservice-architectures. These microservices are both stateless a\", \"nd\\nstateful, and run on the cloud and edge, embracing the diversity of languages and frameworks\\navai\", \"lable today. This enterprise shift is driven by both the market forces of faster time to market, and\", \"\\nthe scale and efficiencies of building services for the cloud. Even before COVID-19, cloud adoption\", \"\\nwas accelerating for enterprises, and developers were being asked to do even more to deliver on\\nbui\", \"lding these distributed system applications. That has only accelerated since COVID-19. Developers\\nin\", \" enterprises seek to focus on business logic, while leaning on platforms to imbue their applications\", \"\\nwith scale, resiliency, maintainability, elasticity, and the other attributes of cloud-native archi\", \"tectures,\\nwhich is why there is also shift towards serverless platforms that hide the underlying inf\", \"rastructure.\\nDevelopers should not be expected to become distributed systems experts. This is where \", \"Dapr steps\\nin to help you, whether you are building on infrastructure such as Kubernetes, or on a se\", \"rverless\\nplatform.\\n\\nDapr is designed as an enterprise, developer-focused, microservices programming \", \"model platform\\nwith the mantra \\u201cany language, any framework, run anywhere\\u201d. It makes building distri\", \"buted\\napplications easy and portable across any infrastructure, from public-cloud, through hierarchi\", \"cal edge,\\nand even down to single node IoT devices. It emerged from both our experiences building se\", \"rvices in\\nAzure and time spent working with customers building applications on Azure Kubernetes Serv\", \"ice and\\nAzure Service Fabric. Over and over, we saw common problems that they had to address. It bec\", \"ame\\nclear that there was a need to provide a \\u201clibrary\\u201d of common microservice best practices that\\nde\", \"velopers could use, not only in new green field applications, but also to aid in the modernization o\", \"f\\nexisting applications. In the containerized, distributed, and networked cloud native world, the si\", \"decar\\nmodel has emerged as the preferred approach, in the same way DLLs are preferred in the client/\", \"server\\ngeneration. Using Dapr\\u2019s sidecar and APIs give you, as a developer, all the power of distribu\", \"ted\\nsystems functionality, with the ease of a single HTTP or gRPC local call.\\n\\nTo address the wide r\", \"ange of scenarios that developers face, Dapr provides features such as state\\nmanagement, service-to-\", \"service invocation, pub/sub, and integration to external systems with I/O\\nbindings, which are based \", \"on the triggers and bindings of Azure Functions. These in turn take\\nadvantage of Dapr\\u2019s component mo\", \"del, which allows you to \\u201cswap out\\u201d, say different underlying state\\nstores, without having to change\", \" any code. This component model makes code more portable, more\\nflexible, and allows for experimentat\", \"ion of what best suits your needs. Developers don\\u2019t need to learn\\n\\n1\\n\\nCHAPTER 1 | Foreword - Dapr fo\", \"r .NET Developers\\n\\n\\fand incorporate service SDKs into their code, or worry about authentication, sec\", \"ret management,\\nretries, or conditional code that targets specific deployment environments.\\n\\nThis bo\", \"ok shows how Dapr reduces your development time and overall code maintenance by\\nincrementally \\u201cDaper\", \"izing\\u201d the canonical .NET reference application, eShop. For example, in the\\noriginal eShop implement\", \"ation, significant amounts of code were written to abstract between Azure\\nService Bus and RabbitMQ f\", \"or publishing events between services. All this code can be discarded and\\nsimply replaced with Dapr\\u2019\", \"s pub/sub API and component model, which had an even wider range of\\npub/sub brokers, rather than jus\", \"t two. Dapr\\u2019s actor model, when used in the reworked eShop\\napplication, shows the ease of building l\", \"ong running, stateful, event driven, workflow applications with\\nall the difficulties of concurrency \", \"and multi-threading removed. By the end of this book, you will see\\nthe drastic simplification that D\", \"apr brings to your application development, and I firmly believe all\\ndevelopers embarking on a cloud\", \" native app building journey should use Dapr.\\n\\nWe publicly announced Dapr with the v0.1 release in O\", \"ct 2019 and now, a year and half later, I am\\nthrilled to say that Dapr is ready for production usage\", \" with the v1.0 release. Getting Dapr to v1.0 has\\ntruly been a community effort. It has been amazing \", \"to see the open-source community coalesce\\naround Dapr and grow since it was first announced \\u2013 from 1\", \"14 contributors in October 2019 to over\\n700 in early 2021 - a six-fold increase in 16 months! Contri\", \"butions to the project have gone to every\\nDapr repo and have ranged from opening issues, commenting \", \"on feature proposals, providing\\nsamples, and, of course, contributing code. The parts of the project\", \" community members have\\ncontributed to the most include the Dapr runtime, docs, CLI, SDKs, and the c\", \"reation of a rich\\necosystem of components. Maintaining this openness is critical to Dapr\\u2019s future.\\n\\n\", \"Dapr is just getting started, though, and you should expect to see more Dapr capabilities and more\\ns\", \"upport for Dapr in Azure services. I hope that you will take advantage of Dapr to enable you to focu\", \"s\\non your core business logic and accelerate your microservices development. I am excited to have yo\", \"u\\njoin us in the Dapr community on this journey at https://github.com/dapr/ and on Discord\\nhttps://a\", \"ka.ms/dapr-discord.\\n\\nModern distributed systems are complex. You start with small, loosely coupled, \", \"independently\\ndeployable services. These services cross process and server boundaries. They then con\", \"sume different\\nkinds of infrastructure backing services (databases, message brokers, key vaults). Fi\", \"nally, these\\ndisparate pieces compose together to form an application.\\n\\nMark Russinovich Azure CTO a\", \"nd Technical Fellow Microsoft\\n\\n2\\n\\nCHAPTER 1 | Foreword - Dapr for .NET Developers\\n\\n\\fCHAPTER  2\\n\\nThe \", \"world is distributed\\n\\nJust ask any \\u2018cool kid\\u2019: Modern, distributed systems are in, and monolithic ap\", \"ps are out!\\n\\nBut, it\\u2019s not just \\u201ccool kids.\\u201d Progressive IT Leaders, corporate architects, and astut\", \"e developers are\\nechoing these same thoughts as they explore and evaluate modern distributed applica\", \"tions. Many\\nhave bought in. They\\u2019re designing new and replatforming existing enterprise applications\", \" following\\nthe principles, patterns, and practices of distributed microservice applications.\\n\\nBut, t\", \"his evolution raises many questions\\u2026\\n\\n\\u2022  What exactly is a distributed application?\\n\\n\\u2022  Why are they\", \" gaining popularity?\\n\\n\\u2022  What are the costs?\\n\\n\\u2022\\n\\nAnd, importantly, what are the tradeoffs?\\n\\nTo start\", \", let\\u2019s rewind and look at the past 15 years. During this period, we typically constructed\\napplicati\", \"ons as a single, monolithic unit. Figure 1-1 shows the architecture.\\n\\nFigure 1-1. Monolithic archite\", \"cture.\\n\\nNote how the modules for Ordering, Identity, and Marketing execute in a single-server proces\", \"s.\\nApplication data is stored in a shared database. Business functionality is exposed via HTML and\\nR\", \"ESTful interfaces.\\n\\nIn many ways, monolithic apps are straightforward. They\\u2019re straightforward to:\\n\\n\", \"Build\\n\\n\\u2022\\n\\n3\\n\\nCHAPTER 2 | The world is distributed\\n\\n\\f\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nTest\\n\\nDeploy\\n\\nTroubleshoot\\n\\nScale ve\", \"rtically (scale up)\\n\\nHowever, monolithic architectures can present significant challenges.\\n\\nOver tim\", \"e, you may reach a point where you begin to lose control\\u2026\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe monolith h\", \"as become so overwhelmingly complicated that no single person understands it.\\n\\nYou fear making chang\", \"es as each brings unintended and costly side effects.\\n\\nNew features/fixes become time-consuming and \", \"expensive to implement.\\n\\nEven the smallest change requires full deployment of the entire application\", \" - expensive and\\nrisky.\\n\\nOne unstable component can crash the entire system.\\n\\nAdding new technologie\", \"s and frameworks aren\\u2019t an option.\\n\\nImplementing agile delivery methodologies are difficult.\\n\\nArchit\", \"ectural erosion sets in as the code base deteriorates with never-ending \\u201cspecial cases.\\u201d\\n\\nEventually\", \" the consultants come in and tell you to rewrite it.\\n\\nIT practitioners call this condition the Fear \", \"Cycle. If you\\u2019ve been in the technology business for any\\nlength of time, good chance you\\u2019ve experien\", \"ced it. It\\u2019s stressful and exhausts your IT budget. Instead\\nof building new and innovative solutions\", \", most of your budget is spent maintaining legacy apps.\\n\\nInstead of fear, businesses require speed a\", \"nd agility. They seek an architectural style with which\\nthey can rapidly respond to market condition\", \"s. They need to instantaneously update and individually\\nscale small areas of a live application.\\n\\nAn\", \" early attempt to gain speed and agility came in the form of Service Oriented Architecture, or SOA.\\n\", \"In this model, service consumers and service providers collaborated via middleware messaging\\ncompone\", \"nts, often referred to as an Enterprise Service Bus, or ESB. Figure 1-2 shows the architecture.\\n\\n4\\n\\n\", \"CHAPTER 2 | The world is distributed\\n\\n\\fFigure 1-2. SOA architecture.\\n\\nWith SOA, centralized service \", \"providers registered with the ESB. Business logic would be built into the\\nESB to integrate providers\", \" and consumers. Service consumers could then find and communicate with\\nthese providers using the ESB\", \".\\n\\nDespite the promises of SOA, implementing this approach often increased complexity and introduced\", \"\\nbottlenecks. Maintenance costs became high and ESB middleware expensive. Services tended to be\\nlarg\", \"e. They often shared dependencies and data storage. In the end, SOAs often resulted in a\\n\\u2018distribute\", \"d monolithic\\u2019 structure with centralized services that were resistant to change.\\n\\nNowadays, many org\", \"anizations have realized speed and agility by adopting a distributed microservice\\narchitectural appr\", \"oach to building systems. Figure 1-3 shows the same system built using distributed\\ntechniques and pr\", \"actices.\\n\\n5\\n\\nCHAPTER 2 | The world is distributed\\n\\n\\fFigure 1-3. Distributed architecture.\\n\\nNote how \", \"the same application is decomposed across a set of distributed services. Each is self-\\ncontained and\", \" encapsulates its own code, data, and dependencies. Each is deployed in a software\\ncontainer and man\", \"aged by a container orchestrator. Instead of a single database shared by multiple\\nservices, each ser\", \"vice owns a private database. Other services can\\u2019t access this database directly and\\ncan only get to\", \" data that is exposed through the public API of the service that owns it. Note how\\nsome services req\", \"uire a full relational database, but others, a NoSQL datastore. The basket service\\nstores its state \", \"in a distributed key/value cache. Note how inbound traffic routes through an API\\nGateway service. It\", \"\\u2019s responsible for directing calls to services and enforcing cross-cutting concerns.\\nMost importantl\", \"y, the application takes full advantage of the scalability, availability, and resiliency\\nfeatures fo\", \"und in modern cloud platforms.\\n\\nBut, while distributed services can provide agility and speed, they \", \"present a different set of challenges.\\nConsider the following\\u2026\\n\\n\\u2022\\n\\n6\\n\\nHow can distributed services d\", \"iscover each other and communicate synchronously?\\n\\nCHAPTER 2 | The world is distributed\\n\\n\\f\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\", \"\\n\\n\\u2022\\n\\nHow can they implement asynchronous messaging?\\n\\nHow can they maintain contextual information ac\", \"ross a transaction?\\n\\nHow can they become resilient to failure?\\n\\nHow can they scale to meet fluctuati\", \"ng demand?\\n\\nHow are they monitored and observed?\\n\\nFor each of these challenges, multiple products ar\", \"e often available. But, shielding your application\\nfrom product differences and keeping code maintai\", \"nable and portable become a challenge.\\n\\nThis book introduces Dapr. Dapr is a distributed application\", \" runtime. It directly addresses many of the\\nchallenges found that come along with distributed applic\", \"ations. Looking ahead, Dapr has the\\npotential to have a profound impact on distributed application d\", \"evelopment.\\n\\nSummary\\n\\nIn this chapter, we discussed the adoption of distributed applications. We con\", \"trasted a monolithic\\nsystem approach with that of distributed services. We pointed out many of the c\", \"ommon challenges\\nwhen considering a distributed approach.\\n\\nNow, sit back, relax, and let us introduc\", \"e you the new world of Dapr.\\n\\n7\\n\\nCHAPTER 2 | The world is distributed\\n\\n\\fCHAPTER  3\\n\\nDapr at 20,000 f\", \"eet\\n\\nIn chapter 1, we discussed the appeal of distributed microservice applications. But, we also po\", \"inted\\nout that they dramatically increase architectural and operational complexity. With that in min\", \"d, the\\nquestion becomes, how can you \\u201chave your cake\\u201d and \\u201ceat it too?\\u201d. That is, how can you take\\na\", \"dvantage of the agility of distributed architecture, and minimize its complexity?\\n\\nDapr, or Distribu\", \"ted Application Runtime, is a new way to build modern distributed applications.\\n\\nWhat started as a p\", \"rototype has evolved into a highly successful open-source project. Its sponsor,\\nMicrosoft, has close\", \"ly partnered with customers and the open-source community to design and build\\nDapr. The Dapr project\", \" brings together developers from all backgrounds to solve some of the\\ntoughest challenges of develop\", \"ing distributed applications.\\n\\nThis book looks at Dapr from the viewpoint of a .NET developer. In th\", \"is chapter, you\\u2019ll build a\\nconceptual understanding of Dapr and how it works. Later on, we present p\", \"ractical, hands-on\\ninstruction on how you can use Dapr in your applications.\\n\\nImagine flying in a je\", \"t at 20,000 feet. You look out the window and see the landscape below from a\\nwide perspective. Let\\u2019s\", \" do the same for Dapr. Visualize yourself flying over Dapr at 20,000 feet. What\\nwould you see?\\n\\nDapr\", \" and the problem it solves\\n\\nDapr addresses a large challenge inherent in modern distributed applicat\", \"ions: Complexity.\\n\\nThrough an architecture of pluggable components, Dapr greatly simplifies the plum\", \"bing behind\\ndistributed applications. It provides a dynamic glue that binds your application with in\", \"frastructure\\ncapabilities from the Dapr runtime.\\n\\nConsider a requirement to make one of your service\", \"s stateful? What would be your design. You could\\nwrite custom code that targets a state store such a\", \"s Redis Cache. However, Dapr provides state\\nmanagement capabilities out-of-the-box. Your service inv\", \"okes the Dapr state management building\\nblock that dynamically binds to a state store component via \", \"a Dapr component configuration yaml\\nfile. Dapr ships with several pre-built state store components, \", \"including Redis. With this model, your\\nservice delegates state management to the Dapr runtime. Your \", \"service has no SDK, library, or direct\\nreference to the underlying component. You can even change st\", \"ate stores, say, from Redis to MySQL\\nor Cassandra, with no code changes.\\n\\nFigure 2-1 shows Dapr from\", \" 20,000 feet.\\n\\n8\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n\\fFigure 2-1. Dapr at 20,000 feet.\\n\\nIn the top row\", \" of the figure, note how Dapr provides language-specific SDKs for popular development\\nplatforms. Dap\", \"r v1.0 includes support for Go, Node.js, Python, .NET, Java, and JavaScript. This book\\nfocuses on th\", \"e Dapr .NET SDK, which also provides direct support for ASP.NET Core integration.\\n\\nWhile language-sp\", \"ecific SDKs enhance the developer experience, Dapr is platform agnostic. Under the\\nhood, Dapr\\u2019s prog\", \"ramming model exposes capabilities through standard HTTP/gRPC communication\\nprotocols. Any programmi\", \"ng platform can call Dapr via its native HTTP and gRPC APIs.\\n\\nThe blue boxes across the center of th\", \"e figure represent the Dapr building blocks. Each exposes a\\ndistributed application capability that \", \"your application can consume.\\n\\nThe bottom row highlights the portability of Dapr and the diverse env\", \"ironments across which it can\\nrun.\\n\\nDapr architecture\\n\\nAt this point, the jet turns around and flies\", \" back over Dapr, descending in altitude, giving you a closer\\nlook at how Dapr works.\\n\\nBuilding block\", \"s\\n\\nFrom the new perspective, you see a more detailed view of the Dapr building blocks.\\n\\nA building b\", \"lock encapsulates a distributed infrastructure capability. You can access the functionality\\nthrough \", \"the HTTP or gRPC APIs. Figure 2-2 shows the available blocks for Dapr v 1.0.\\n\\n9\\n\\nCHAPTER 3 | Dapr at\", \" 20,000 feet\\n\\n\\fFigure 2-2. Dapr building blocks.\\n\\nThe following table describes the infrastructure s\", \"ervices provided by each block.\\n\\nBuilding block\\n\\nDescription\\n\\nState management  Support contextual i\", \"nformation for long running stateful services.\\n\\nService invocation\\n\\nInvoke direct, secure service-to\", \"-service calls using platform agnostic protocols\\nand well-known endpoints.\\n\\nPublish and\\nsubscribe\\n\\n1\", \"0\\n\\nImplement secure, scalable pub/sub messaging between services.\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n\", \"\\fBuilding block\\n\\nBindings\\n\\nDescription\\n\\nTrigger code from events raised by external resources with b\", \"i-directional\\ncommunication.\\n\\nObservability\\n\\nMonitor and measure message calls across networked serv\", \"ices.\\n\\nSecrets\\n\\nActors\\n\\nSecurely access external secret stores.\\n\\nEncapsulate logic and data in reusa\", \"ble actor objects.\\n\\nBuilding blocks abstract the implementation of distributed application capabilit\", \"ies from your services.\\nFigure 2-3 shows this interaction.\\n\\nFigure 2-3. Dapr building block integrat\", \"ion.\\n\\nBuilding blocks invoke Dapr components that provide the concrete implementation for each resou\", \"rce.\\nThe code for your service is only aware of the building block. It takes no dependencies on exte\", \"rnal\\nSDKs or libraries - Dapr handles the plumbing for you. Each building block is independent. You \", \"can\\nuse one, some, or all of them in your application. As a value-add, Dapr building blocks bake in\\n\", \"industry best practices including comprehensive observability.\\n\\nWe provide detailed explanation and \", \"code samples for each Dapr building block in the upcoming\\nchapters. At this point, the jet descends \", \"even more. From the new perspective, you now have a closer\\nlook at the Dapr components layer.\\n\\nCompo\", \"nents\\n\\nWhile building blocks expose an API to invoke distributed application capabilities, Dapr comp\", \"onents\\nprovide the concrete implementation to make it happen.\\n\\n11\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n\", \"\\fConsider, the Dapr state store component. It provides a uniform way to manage state for CRUD\\noperat\", \"ions. Without any change to your service code, you could switch between any of the following\\nDapr st\", \"ate components:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nAWS DynamoDB\\n\\nAerospike\\n\\nAzure Blob Storage\\n\\nAz\", \"ure CosmosDB\\n\\nAzure Table Storage\\n\\nCassandra\\n\\nCloud Firestore (Datastore mode)\\n\\nCloudState\\n\\nCouchbas\", \"e\\n\\nEtcd\\n\\nHashiCorp Consul\\n\\nHazelcast\\n\\n\\u2022  Memcached\\n\\n\\u2022  MongoDB\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nPostgreSQL\\n\\nRedis\\n\\nRe\", \"thinkDB\\n\\nSQL Server\\n\\nZookeeper\\n\\nEach component provides the necessary implementation through a commo\", \"n state management\\ninterface:\\n\\n type Store interface {\\n   Init(metadata Metadata) error\\n   Delete(re\", \"q *DeleteRequest) error\\n   BulkDelete(req []DeleteRequest) error\\n   Get(req *GetRequest) (*GetRespon\", \"se, error)\\n   Set(req *SetRequest) error\\n   BulkSet(req []SetRequest) error\\n}\\n\\nTip\\n\\nThe Dapr runtime\", \" as well as all of the Dapr components have been written in the Golang, or Go,\\nlanguage. Go is a pop\", \"ular language across the open source community and attests to cross-platform\\ncommitment of Dapr.\\n\\nPe\", \"rhaps you start with Azure Redis Cache as your state store. You specify it with the following\\nconfig\", \"uration:\\n\\n12\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n\\f:::{custom-style=CodeBox} yaml  apiVersion: dapr.io/\", \"v1alpha1  kind: Component  metadata:    name:\\nstatestore    namespace: default  spec:    type: state\", \".redis    version: v1    metadata:    - name: redisHost\\nvalue: <HOST>    - name: redisPassword      \", \"value: <PASSWORD>    - name: enableTLS      value:\\n<bool> # Optional. Allowed: true, false.    - nam\", \"e: failover      value: <bool> # Optional. Allowed: true,\\nfalse. :::\\n\\nIn the spec section, you confi\", \"gure Dapr to use the Redis Cache for state management. The section\\nalso contains component-specific \", \"metadata. In this case, you can use it to configure additional Redis\\nsettings.\\n\\nAt a later time, the\", \" application is ready to go to production. For the production environment, you may\\nwant to change yo\", \"ur state management to Azure Table Storage. Azure Table Storage provides state\\nmanagement capabiliti\", \"es that are affordable and highly durable.\\n\\nAt the time of this writing, the following component typ\", \"es are provided by Dapr:\\n\\nComponent\\n\\nDescription\\n\\nService\\ndiscovery\\n\\nState\\n\\nPub/sub\\n\\nBindings\\n\\nUsed \", \"by the service invocation building block to integrate with the hosting\\nenvironment to provide servic\", \"e-to-service discovery.\\n\\nProvides a uniform interface to interact with a wide variety of state store\", \"\\nimplementations.\\n\\nProvides a uniform interface to interact with a wide variety of message bus\\nimple\", \"mentations.\\n\\nProvides a uniform interface to trigger application events from external systems and\\nin\", \"voke external systems with optional data payloads.\\n\\nMiddleware\\n\\nAllows custom middleware to plug int\", \"o the request processing pipeline and invoke\\nadditional actions on a request or response.\\n\\nSecret st\", \"ores\\n\\nProvides a uniform interface to interact with external secret stores, including cloud,\\nedge, c\", \"ommercial, open-source services.\\n\\nAs the jet completes its fly over of Dapr, you look back once more\", \" and can see how it connects\\ntogether.\\n\\nSidecar architecture\\n\\nDapr exposes its building blocks and c\", \"omponents through a sidecar architecture. A sidecar enables\\nDapr to run in a separate memory process\", \" or separate container alongside your service. Sidecars\\nprovide isolation and encapsulation as they \", \"aren\\u2019t part of the service, but connected to it. This\\nseparation enables each to have its own runtim\", \"e environment and be built upon different\\nprogramming platforms. Figure 2-4 shows a sidecar pattern.\", \"\\n\\n13\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n\\fFigure 2-4. Sidecar architecture.\\n\\nThis pattern is named Sid\", \"ecar because it resembles a sidecar attached to a motorcycle. In the previous\\nfigure, note how the D\", \"apr sidecar is attached to your service to provide distributed application\\ncapabilities.\\n\\nHosting en\", \"vironments\\n\\nDapr has cross-platform support and can run in many different environments. These enviro\", \"nments\\ninclude Kubernetes, a group of VMs, or edge environments such as Azure IoT Edge.\\n\\nFor local d\", \"evelopment, the easiest way to get started is with self-hosted mode. In self-hosted mode,\\nthe micros\", \"ervices and Dapr sidecars run in separate local processes without a container orchestrator\\nsuch as K\", \"ubernetes. For more information, see download and install the Dapr CLI.\\n\\nFigure 2-5 shows an applica\", \"tion and Dapr hosted in two separate memory processes communicating\\nvia HTTP or gRPC.\\n\\n14\\n\\nCHAPTER 3\", \" | Dapr at 20,000 feet\\n\\n\\fFigure 2-5. Self-hosted Dapr sidecar.\\n\\nBy default, Dapr installs Docker con\", \"tainers for Redis and Zipkin to provide default state management\\nand observability. If you don\\u2019t wan\", \"t to install Docker on your local machine, you can even run Dapr in\\nself-hosted mode without any Doc\", \"ker containers. However, you must install default components such\\nas Redis for state management and \", \"pub/sub manually.\\n\\nDapr also runs in containerized environments, such as Kubernetes. Figure 2-6 show\", \"s Dapr running in a\\nseparate side-car container along with the application container in the same Kub\", \"ernetes pod.\\n\\nFigure 2-6. Kubernetes-hosted Dapr sidecar.\\n\\nDapr performance considerations\\n\\nAs you\\u2019v\", \"e seen, Dapr exposes a sidecar architecture to decouple your application from distributed\\napplicatio\", \"n capabilities. Invoking a Dapr operation requires at least one out-of-process network call.\\nFigure \", \"2-7 presents an example of a Dapr traffic pattern.\\n\\n15\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n\\fFigure 2-7\", \". Dapr traffic patterns.\\n\\nLooking at the previous figure, one might question the latency and overhea\", \"d incurred for each call.\\n\\nThe Dapr team has invested heavily in performance. A tremendous amount of\", \" engineering effort has\\ngone into making Dapr efficient. Calls between Dapr sidecars are always made\", \" with gRPC, which\\ndelivers high performance and small binary payloads. In most cases, the additional\", \" overhead should\\nbe sub-millisecond.\\n\\nTo increase performance, developers can call the Dapr building\", \" blocks with gRPC.\\n\\ngRPC is a modern, high-performance framework that evolves the age-old remote pro\", \"cedure call (RPC)\\nprotocol. gRPC uses HTTP/2 for its transport protocol, which provides significant \", \"performance\\nenhancements over HTTP RESTFul service, including:\\n\\n\\u2022  Multiplexing support for sending \", \"multiple parallel requests over the same connection - HTTP 1.1\\n\\nlimits processing to one request/res\", \"ponse message at a time.\\n\\n\\u2022\\n\\n\\u2022\\n\\nBidirectional full-duplex communication for sending both client requ\", \"ests and server responses\\nsimultaneously.\\n\\nBuilt-in streaming enabling requests and responses to asy\", \"nchronously stream large data sets.\\n\\nTo learn more, check out the gRPC overview from the Architectin\", \"g Cloud-Native .NET Apps for Azure\\neBook.\\n\\nDapr and service meshes\\n\\nService mesh is another rapidly \", \"evolving technology for distributed applications.\\n\\nA service mesh is a configurable infrastructure l\", \"ayer with built-in capabilities to handle service-to-\\nservice communication, resiliency, load balanc\", \"ing, and telemetry capture. It moves the responsibility\\nfor these concerns out of the services and i\", \"nto the service mesh layer. Like Dapr, a service mesh also\\nfollows a sidecar architecture.\\n\\nFigure 2\", \"-8 shows an application that implements service mesh technology.\\n\\n16\\n\\nCHAPTER 3 | Dapr at 20,000 fee\", \"t\\n\\n\\fFigure 2-8. Service mesh with a side car.\\n\\nThe previous figure shows how messages are intercepte\", \"d by a sidecar proxy that runs alongside each\\nservice. Each proxy can be configured with traffic rul\", \"es specific to the service. It understands messages\\nand can route them across your services and the \", \"outside world.\\n\\nSo the question becomes, \\u201cIs Dapr a service mesh?\\u201d.\\n\\nWhile both use a sidecar archit\", \"ecture, each technology has a different purpose. Dapr provides\\ndistributed application features. A s\", \"ervice mesh provides a dedicated network infrastructure layer.\\n\\nAs each works at a different level, \", \"both can work together in the same application. For example, a\\nservice mesh could provide networking\", \" communication between services. Dapr could provide\\napplication services such as state management or\", \" actor services.\\n\\nFigure 2-9 shows an application that implements both Dapr and service mesh technol\", \"ogy.\\n\\n17\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n\\fFigure 2-9. Dapr and service mesh together.\\n\\nThe Dapr on\", \"line documentation cover Dapr and service mesh integration.\\n\\nSummary\\n\\nThis chapter introduced you to\", \" Dapr, a Distributed Application Runtime.\\n\\nDapr is an open-source project sponsored by Microsoft wit\", \"h close collaboration from customers and\\nthe open-source community.\\n\\nAt its core, Dapr helps reduce \", \"the inherent complexity of distributed microservice applications. It\\u2019s\\nbuilt upon a concept of build\", \"ing block APIs. Dapr building blocks expose common distributed\\napplication capabilities, such as sta\", \"te management, service-to-service invocation, and pub/sub\\nmessaging. Dapr components lie beneath the\", \" building blocks and provide the concrete\\nimplementation for each capability. Applications bind to v\", \"arious components through configuration\\nfiles.\\n\\nIn the next chapters, we present practical, hands-on\", \" instruction on how to use Dapr in your\\napplications.\\n\\nReferences\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n18\\n\\nDapr documentatio\", \"n\\n\\nLearning Dapr\\n\\n.NET Microservices: Architecture for Containerized .NET applications\\n\\nArchitecting\", \" Cloud-Native .NET Apps for Azure\\n\\nCHAPTER 3 | Dapr at 20,000 feet\\n\\n\\fCHAPTER  4\\n\\nGet started with Da\", \"pr\\n\\nIn the first two chapters, you learned basic concepts about Dapr. It\\u2019s time to take it for a tes\", \"t drive. This\\nchapter will guide you through preparing your local development environment and buildi\", \"ng two Dapr\\n.NET applications.\\n\\nInstall Dapr into your local environment\\n\\nYou\\u2019ll start by installing\", \" Dapr on your development computer. Once complete, you can build and run\\nDapr applications in self-h\", \"osted mode.\\n\\n1.\\n\\n2.\\n\\nInstall the Dapr CLI. It enables you to launch, run, and manage Dapr instances.\", \" It also provides\\ndebugging support.\\n\\nInstall Docker Desktop. If you\\u2019re running on Windows, make sur\", \"e that Docker Desktop for\\nWindows is configured to use Linux containers.\\n\\n[!NOTE] By default, Dapr u\", \"ses Docker containers to provide you the best out-of-the-box\\nexperience. To run Dapr outside of Dock\", \"er, you can skip this step and execute a slim\\ninitialization. The examples in this chapter require y\", \"ou use Docker containers.\\n\\n3.\\n\\nInitialize Dapr. This step sets up your development environment by in\", \"stalling the latest Dapr\\nbinaries and container images.\\n\\n4.\\n\\nInstall the .NET 7 SDK.\\n\\nNow that Dapr \", \"is installed, it\\u2019s time to build your first Dapr application!\\n\\nBuild your first Dapr application\\n\\nYo\", \"u\\u2019ll start by building a simple .NET Console application that consumes the Dapr state management\\nbui\", \"lding block.\\n\\nCreate the application\\n\\n1.  Open up the command shell or terminal of your choice. You \", \"might consider the terminal\\n\\ncapabilities in Visual Studio Code. Navigate to the root folder in whic\", \"h you want to build your\\napplication. Once there, enter the following command to create a new .NET C\", \"onsole application:\\n\\ndotnet new console -o DaprCounter\\n\\nThe command scaffolds a simple \\\"Hello World\\\"\", \" .NET application.\\n\\n19\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\f1.\\n\\nThen, navigate into the new director\", \"y created by the previous command:\\n\\ncd DaprCounter\\n\\n1.\\n\\nRun the newly created application using the \", \"dotnet run command. Doing so writes \\u201cHello\\nWorld!\\u201d to the console screen:\\n\\ndotnet run\\n\\nAdd Dapr Stat\", \"e Management\\n\\nNext, you\\u2019ll use the Dapr state management building block to implement a stateful coun\", \"ter in the\\nprogram.\\n\\nYou can invoke Dapr APIs across any development platform using Dapr\\u2019s native su\", \"pport for HTTP and\\ngRPC. However, .NET Developers will find the Dapr .NET SDK more natural and intui\", \"tive. It provides a\\nstrongly typed .NET client to call the Dapr APIs. The .NET SDK also tightly inte\", \"grates with ASP.NET\\nCore.\\n\\n1.\\n\\nFrom the terminal window, add the Dapr.Client NuGet package to your a\", \"pplication:\\n\\ndotnet add package Dapr.Client\\n\\n1.  Open the Program.cs file in your favorite editor an\", \"d update its contents to the following code:\\n\\nusing Dapr.Client\\nconst string storeName = \\\"statestore\", \"\\\";\\nconst string key = \\\"counter\\\"\\nvar daprClient = new DaprClientBuilder().Build();\\nvar counter = awai\", \"t daprClient.GetStateAsync<int>(storeName, key)\\nwhile (true)\\n{\\n    Console.WriteLine($\\\"Counter = {co\", \"unter++}\\\")\\n    await daprClient.SaveStateAsync(storeName, key, counter);\\n    await Task.Delay(1000);\", \"\\n}\\n\\nThe updated code implements the following steps:\\n\\n- First a new [`DaprClient`]{custom-style=Code\", \"} instance is instantiated. This class\\nenables you to interact with the Dapr sidecar.\\n- From the sta\", \"te store, [`DaprClient.GetStateAsync`]{custom-style=Code} fetches the\\nvalue for the [`counter`]{cust\", \"om-style=Code} key. If the key doesn't exist, the\\ndefault value for [`int`]{custom-style=Code} (whic\", \"h is [`0`]{custom-style=Code}) is\\nreturned.\\n- The code then iterates, writing the [`counter`]{custom\", \"-style=Code} value to the\\nconsole and saving an incremented value to the state store.\\n\\n1.\\n\\nThe Dapr \", \"CLI run command starts the application. It invokes the underlying Dapr runtime and\\nenables both the \", \"application and Dapr sidecar to run together. If you omit the app-id, Dapr will\\ngenerate a unique na\", \"me for the application. The final segment of the command, dotnet run,\\ninstructs the Dapr runtime to \", \"run the .NET application.\\n\\n[!IMPORTANT] Care must be taken to always pass an explicit app-id paramet\", \"er when consuming\\nthe state management building block. The block uses the application id value as a \", \"prefix for its\\n\\n20\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\fstate key for each key/value pair. If the ap\", \"plication id changes, you can no longer access the\\npreviously stored state.\\n\\nNow run the application\", \" with the following command:\\n\\ndapr run --app-id DaprCounter dotnet run\\n\\nTry stopping and restarting \", \"the application. You'll see that the counter doesn't\\nreset. Instead it continues from the previously\", \" saved state. The Dapr building block\\nmakes the application stateful.\\n\\nImportant\\n\\nIt\\u2019s important to \", \"understand your sample application communicates with a pre-configured state\\ncomponent, but has no di\", \"rect dependency on it. Dapr abstracts away the dependency. As you\\u2019ll\\nshortly see, the underlying sta\", \"te store component can be changed with a simple configuration update.\\n\\nYou might be wondering, where\", \" exactly is the state stored?\\n\\nComponent configuration files\\n\\nWhen you first initialized Dapr for yo\", \"ur local environment, it automatically provisioned a Redis\\ncontainer. Dapr then configured the Redis\", \" container as the default state store component with a\\ncomponent configuration file, entitled states\", \"tore.yaml. Here\\u2019s a look at its contents:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  \", \"name: statestore\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    value: \", \"localhost:6379\\n  - name: redisPassword\\n    value: \\\"\\\"\\n  - name: actorStateStore\\n    value: \\\"true\\\"\\n\\nNo\", \"te\\n\\nDefault component configuration files are stored in the $HOME/.dapr/components folder on\\nLinux/m\", \"acOS, and in the %USERPROFILE%\\\\.dapr\\\\components folder on Windows.\\n\\nNote the format of the previous \", \"component configuration file:\\n\\n\\u2022\\n\\n\\u2022\\n\\n21\\n\\nEach component has a name. In the sample above, the compone\", \"nt is named statestore. We\\nused that name in our first code example to tell the Dapr sidecar which c\", \"omponent to use.\\n\\nEach component configuration file has a spec section. It contains a type field tha\", \"t specifies the\\ncomponent type. The version field specifies the component version. The metadata fiel\", \"d\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\fcontains information that the component requires, such as con\", \"nection details and other settings.\\nThe metadata values will vary for the different types of compone\", \"nts.\\n\\nA Dapr sidecar can consume any Dapr component configured in your application. But, what if you\", \" had\\nan architectural justification to limit the accessibility of a component? How could you restric\", \"t the Redis\\ncomponent to Dapr sidecars running only in a production environment?\\n\\nTo do so, you coul\", \"d define a namespace for the production environment. You might name it\\nproduction. In self-hosted mo\", \"de, you specify the namespace of a Dapr sidecar by setting the\\nNAMESPACE environment variable. When \", \"configured, the Dapr sidecar will only load the components\\nthat match the namespace. For Kubernetes \", \"deployments, the Kubernetes namespace determines the\\ncomponents that are loaded. The following sampl\", \"e shows the Redis component placed in a\\nproduction namespace. Note the namespace declaration in the \", \"metadata element:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: statestore\\n  names\", \"pace: production\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    value: \", \"localhost:6379\\n  - name: redisPassword\\n    value: \\\"\\\"\\n  - name: actorStateStore\\n    value: \\\"true\\\"\\n\\nIm\", \"portant\\n\\nA namespaced component is only accessible to applications running in the same namespace. If\", \" your\\nDapr application fails to load a component, make sure that the application namespace matches t\", \"he\\ncomponent namespace. This can be especially tricky in self-hosted mode where the application\\nname\", \"space is stored in a NAMESPACE environment variable.\\n\\nIf needed, you could further restrict a compon\", \"ent to a particular application. Within the production\\nnamespace, you may want to limit access of th\", \"e Redis cache to only the DaprCounter application. You\\ndo so by specifying scopes in the component c\", \"onfiguration. The following example shows how to\\nrestrict access to the Redis statestore component t\", \"o the application DaprCounter in the production\\nnamespace:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Compo\", \"nent\\nmetadata:\\n  name: statestore\\n  namespace: production\\nspec:\\n  type: state.redis\\n  version: v1\\n  \", \"metadata:\\n  - name: redisHost\\n\\n22\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\f    value: localhost:6379\\n  -\", \" name: redisPassword\\n    value: \\\"\\\"\\n  - name: actorStateStore\\n    value: \\\"true\\\"\\n  scopes:\\n  - DaprCou\", \"nter\\n\\nBuild a multi-container Dapr application\\n\\nIn the first example, you created a simple .NET cons\", \"ole application that ran side-by-side with a Dapr\\nsidecar. Modern distributed applications, however,\", \" often consist of many moving parts. They can\\nsimultaneously run independent microservices. These mo\", \"dern applications are typically containerized\\nand require container orchestration tools such as Dock\", \"er Compose or Kubernetes.\\n\\nIn the next example, you\\u2019ll create a multi-container application. You\\u2019ll \", \"also use the Dapr service\\ninvocation building block to communicate between services. The solution wi\", \"ll consist of a web\\napplication that retrieves weather forecasts from a web API. They will each run \", \"in a Docker container.\\nYou\\u2019ll use Docker Compose to run the container locally and enable debugging c\", \"apabilities.\\n\\nMake sure you\\u2019ve configured your local environment for Dapr and installed the .NET 7 D\", \"evelopment\\nTools (instructions are available at the beginning of this chapter).\\n\\nAdditionally, you\\u2019l\", \"l need to complete this sample using Visual Studio 2022 with the ASP.NET and web\\ndevelopment workloa\", \"d installed.\\n\\nCreate the application\\n\\n1.\\n\\nIn Visual Studio 2022, create an ASP.NET Core Web App proj\", \"ect:\\n\\n23\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\f1.  Name your project MyFrontEnd and your solution Dap\", \"rMultiContainer:\\n\\n24\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\f1.\\n\\nIn the final dialog, keep the defaults\", \". Don\\u2019t select Enable Docker Support. You\\u2019ll add Docker\\nsupport later.\\n\\n25\\n\\nCHAPTER 4 | Get started \", \"with Dapr\\n\\n\\f1.\\n\\nFor the backend, add an ASP.NET Core Web API project to the same solution:\\n\\n26\\n\\nCHAP\", \"TER 4 | Get started with Dapr\\n\\n\\f1.  Name the project MyBackEnd:\\n\\n1.\\n\\nBy default, a Dapr sidecar reli\", \"es on the network boundary to limit access to its public API. So,\\nclear the checkbox for Configure f\", \"or HTTPS:\\n\\n> [!IMPORTANT]\\n> If you leave the **Configure for HTTPS** checkbox checked, the generated\", \" ASP.NET\\nCore API project includes middleware to redirect client requests to the HTTPS\\nendpoint. Thi\", \"s breaks communication between the Dapr sidecar and your application,\\nunless you explicitly configur\", \"e the use of HTTPS when running your Dapr application.\\nTo enable the Dapr sidecar to communicate ove\", \"r HTTPS, include the [`--app-\\nssl`]{custom-style=Code} flag in the Dapr command to start the applica\", \"tion. Also\\nspecify the HTTPS port using the [`--app-port`]{custom-style=Code} parameter. The\\nremaind\", \"er of this walkthrough uses plain HTTP communication between the sidecar and\\nthe application, and re\", \"quires you to clear the **Configure for HTTPS** checkbox.\\n\\nAdd Dapr service invocation\\n\\nNow, you\\u2019ll \", \"configure communication between the services using Dapr service invocation building\\nblock. You\\u2019ll en\", \"able the web app to retrieve weather forecasts from the web API. The service\\ninvocation building blo\", \"ck features many benefits. It includes service discovery, automatic retries,\\nmessage encryption (usi\", \"ng mTLS), and improved observability. You\\u2019ll use the Dapr .NET SDK to invoke\\nthe service invocation \", \"API on the Dapr sidecar.\\n\\n27\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\f1.\\n\\nIn Visual Studio, open the Pac\", \"kage Manager Console (Tools > NuGet Package Manager >\\nPackage Manager Console) and make sure that My\", \"FrontEnd is the default project. From the\\nconsole, add the Dapr.AspNetCore NuGet package to the proj\", \"ect:\\n\\nInstall-Package Dapr.AspNetCore\\n\\n1.\\n\\nIn the MyFrontEnd project, open the Program.cs file and a\", \"dd a call to\\nbuilder.Services.AddDaprClient:\\n\\nvar builder = WebApplication.CreateBuilder(args)\\n// Ad\", \"d services to the container.\\nbuilder.Services.AddDaprClient();\\nbuilder.Services.AddRazorPages()\\n// .\", \"..\\n\\nThe [`AddDaprClient`]{custom-style=Code} call registers the [`DaprClient`]{custom-\\nstyle=Code} c\", \"lass with the ASP.NET Core dependency injection system. With the client\\nregistered, you can now inje\", \"ct an instance of [`DaprClient`]{custom-style=Code} into\\nyour service code to communicate with the D\", \"apr sidecar, building blocks, and\\ncomponents.\\n\\n1.\\n\\nAdd a new C# class file named WeatherForecast to \", \"the MyFrontEnd project:\\n\\nnamespace MyFrontEnd\\npublic class WeatherForecast\\n{\\n    public DateTime Dat\", \"e { get; set;\\n    public int TemperatureC { get; set;\\n    public int TemperatureF { get; set;\\n    pu\", \"blic string Summary { get; set; } = string.Empty;\\n}\\n\\n1.  Open the Index.cshtml.cs file in the Pages \", \"folder, and replace its contents with the following\\n\\ncode:\\n\\nusing Dapr.Client;\\nusing Microsoft.AspNe\", \"tCore.Mvc.RazorPages\\nnamespace MyFrontEnd.Pages\\npublic class IndexModel : PageModel\\n{\\n    private re\", \"adonly DaprClient _daprClient\\n    public IndexModel(DaprClient daprClient)\\n    {\\n        _daprClient\", \" = daprClient;\\n\\n    public async Task OnGet()\\n    {\\n        var forecasts = await _daprClient.Invoke\", \"MethodAsync<IEnumerable<WeatherForecast>>(\\n            HttpMethod.Get,\\n            \\\"MyBackEnd\\\",\\n    \", \"        \\\"weatherforecast\\\")\\n        ViewData[\\\"WeatherForecastData\\\"] = forecasts;\\n    }\\n}\\n\\nYou add Dap\", \"r capabilities into the web app by injecting the [`DaprClient`]{custom-\\nstyle=Code} class into [`Ind\", \"exModel`]{custom-style=Code} constructor. In the\\n[`OnGet`]{custom-style=Code} method, you call the b\", \"ackend API service with the Dapr\\nservice invocation building block. The [`OnGet`]{custom-style=Code}\", \" method is invoked\\n\\n28\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\fwhenever a user visits the home page. Yo\", \"u use the\\n[`DaprClient.InvokeMethodAsync`]{custom-style=Code} method to invoke the\\n[`weatherforecast\", \"`]{custom-style=Code} method of the [`MyBackEnd`]{custom-style=Code}\\nservice. You'll configure the w\", \"eb API to use [`MyBackEnd`]{custom-style=Code} as its\\napplication ID later on when configuring it to\", \" run with Dapr. Finally, the service\\nresponse is saved in view data.\\n\\n1.\\n\\nReplace the contents of th\", \"e Index.cshtml file in the Pages folder, with the following code. It\\ndisplays the weather forecasts \", \"stored in the view data to the user:\\n\\n@page\\n@model IndexModel\\n@{\\n    ViewData[\\\"Title\\\"] = \\\"Home page\\\"\", \";\\n\\n<div class=\\\"text-center\\\">\\n    <h1 class=\\\"display-4\\\">Welcome</h1>\\n    <p>Learn about <a href=\\\"http\", \"s://learn.microsoft.com/aspnet/core\\\">building Web apps with\\nASP.NECore</a>.</p>\\n    @foreach (var fo\", \"recast in\\n(IEnumerable<WeatherForecast>)ViewData[\\\"WeatherForecastData\\\"]!)\\n    {\\n        <p>The forec\", \"ast for @forecast.Date is @forecast.Summary!</p>\\n    }\\n</div>\\n\\nAdd container support\\n\\nIn the final p\", \"art of this example, you\\u2019ll add container support and run the solution using Docker\\nCompose.\\n\\n1.\\n\\nRi\", \"ght-click the MyFrontEnd project, and choose Add > Container Orchestrator Support\\u2026. The\\nAdd Containe\", \"r Orchestrator Support dialog appears:\\n\\nChoose **Docker Compose**.\\n\\n1.\\n\\nIn the next dialog, select L\", \"inux as the Target OS:\\n\\n29\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\fVisual Studio creates a *docker-comp\", \"ose.yml*file and a *.dockerignore* file in the\\n**docker-compose** folder in the solution:\\n\\n30\\n\\nCHAPT\", \"ER 4 | Get started with Dapr\\n\\n\\fThe *docker-compose.yml* file has the following content:\\n\\nversion: '3\", \".4\\nservices:\\nmyfrontend:\\n    image: ${DOCKER_REGISTRY-}myfrontend\\n    build:\\n    context: .\\n    dock\", \"erfile: MyFrontEnd/Dockerfile\\n\\nThe *.dockerignore* file contains file types and extensions that you \", \"don't want Docker\\nto include in the container. These files are associated with the development\\nenvir\", \"onment and source control and not the app or service you're deploying.\\n\\n31\\n\\nCHAPTER 4 | Get started \", \"with Dapr\\n\\n\\fIn the root of the *MyFrontEnd* project directory, a new *Dockerfile* was created. A\\n*Do\", \"ckerfile* is a sequence of commands that are used to build an image. For more\\ninformation, see [Dock\", \"erfile\\nreference](https://docs.docker.com/engine/reference/builder).\\n\\nThe *Dockerfile* contains the \", \"following commands:\\n\\nFROM mcr.microsoft.com/dotnet/aspnet:7.0 AS base\\nWORKDIR /app\\nEXPOSE 80\\nEXPOSE \", \"44\\nFROM mcr.microsoft.com/dotnet/sdk:7.0 AS build\\nWORKDIR /src\\nCOPY [\\\"MyFrontEnd/MyFrontEnd.csproj\\\",\", \" \\\"MyFrontEnd/\\\"]\\nRUN dotnet restore \\\"MyFrontEnd/MyFrontEnd.csproj\\\"\\nCOPY . .\\nWORKDIR \\\"/src/MyFrontEnd\\\"\", \"\\nRUN dotnet build \\\"MyFrontEnd.csproj\\\" -c Release -o /app/buil\\nFROM build AS publish\\nRUN dotnet publi\", \"sh \\\"MyFrontEnd.csproj\\\" -c Release -o /app/publis\\nFROM base AS final\\nWORKDIR /app\\nCOPY --from=publish\", \" /app/publish .\\nENTRYPOINT [\\\"dotnet\\\", \\\"MyFrontEnd.dll\\\"]\\n\\nThe preceding *Dockerfile* sequentially per\", \"forms the following steps when invoked:\\n\\n1. Pulls the [`mcr.microsoft.com/dotnet/aspnet:7.0`]{custom\", \"-style=Code} image and\\nnames it [`base`]{custom-style=Code}.\\n2. Sets the working directory to */app*\", \".\\n3. Exposes port [`80`]{custom-style=Code} and [`443`]{custom-style=Code}.\\n4. Pulls the [`mcr.micro\", \"soft.com/dotnet/sdk:7.0`]{custom-style=Code} image and names\\nit [`build`]{custom-style=Code}.\\n5. Set\", \"s the working directory to */src*.\\n6. Copies the _MyFrontEnd/MyFrontEnd.csproj_ to a new directory n\", \"amed *MyFrontEnd/*.\\n7. Calls [[`dotnet restore`]{custom-style=Code}](https://docs.microsoft.com/en-\\n\", \"us/dotnet/core/tools/dotnet-restore) on the project.\\n8. Copies everything from the root directory in\", \"to the image's root.\\n9. Sets the working directory to _/src/MyFrontEnd_.\\n10. Calls [[`dotnet build`]\", \"{custom-style=Code}](https://docs.microsoft.com/en-\\nus/dotnet/core/tools/dotnet-build) on the projec\", \"t.\\n    - Targeting the **Release** configuration and outputs to */app/build*.\\n11. Initializes a new \", \"build stage from the existing [`build`]{custom-style=Code} base\\nimage and names it [`publish`]{custo\", \"m-style=Code}.\\n12. Calls [`dotnet publish`]{custom-style=Code} on the project.\\n    - Targeting the *\", \"*Release** configuration and outputs to */app/publish*.\\n13. Initializes a new build stage from the e\", \"xisting [`publish`]{custom-style=Code}\\nbase image and names it [`final`]{custom-style=Code}.\\n14. Set\", \"s the working directory to */app*.\\n15. Copies the [`/app/publish`]{custom-style=Code} directory from\", \" the\\n[`publish`]{custom-style=Code} image into the root of the [`final`]{custom-style=Code}\\nimage.\\n1\", \"6. Sets the entry point as the image to [`dotnet`]{custom-style=Code} and passes the\\n[`MyFrontEnd.dl\", \"l`]{custom-style=Code} as an arg.\\n\\n32\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\f1.\\n\\nIn the MyBackEnd web \", \"API project, right-click on the project node, and choose Add > Container\\nOrchestrator Support\\u2026. Choo\", \"se Docker Compose, and then select Linux again as the target\\nOS.\\n\\nIn the root of the MyBackEnd proje\", \"ct directory, a new Dockerfile was created. The Dockerfile\\ncontains the following commands:\\n\\nFROM mc\", \"r.microsoft.com/dotnet/aspnet:7.0 AS base\\nWORKDIR /app\\nEXPOSE 8\\nFROM mcr.microsoft.com/dotnet/sdk:7.\", \"0 AS build\\nWORKDIR /src\\nCOPY [\\\"MyBackEnd/MyBackEnd.csproj\\\", \\\"MyBackEnd/\\\"]\\nRUN dotnet restore \\\"MyBack\", \"End/MyBackEnd.csproj\\\"\\nCOPY . .\\nWORKDIR \\\"/src/MyBackEnd\\\"\\nRUN dotnet build \\\"MyBackEnd.csproj\\\" -c Relea\", \"se -o /app/buil\\nFROM build AS publish\\nRUN dotnet publish \\\"MyBackEnd.csproj\\\" -c Release -o /app/publi\", \"s\\nFROM base AS final\\nWORKDIR /app\\nCOPY --from=publish /app/publish .\\nENTRYPOINT [\\\"dotnet\\\", \\\"MyBackEn\", \"d.dll\\\"]\\n\\nOpen the *docker-compose.yml* file again and examine its contents. Visual Studio has\\nupdate\", \"d the **Docker Compose** file. Now both services are included:\\n\\nversion: '3.4\\nservices:\\n  myfrontend\", \":\\n    image: ${DOCKER_REGISTRY-}myfrontend\\n    build:\\n      context: .\\n      dockerfile: MyFrontEnd/\", \"Dockerfil\\n  mybackend:\\n    image: ${DOCKER_REGISTRY-}mybackend\\n    build:\\n      context: .\\n      doc\", \"kerfile: MyBackEnd/Dockerfile\\n\\n1.\\n\\nTo use Dapr building blocks from inside a containerized applicati\", \"on, you\\u2019ll need to add the Dapr\\nsidecars containers to your Compose file. Carefully update the conte\", \"nt of the docker-\\ncompose.yml file to match the following example. Pay close attention to the format\", \"ting and\\nspacing and don\\u2019t use tabs.\\n\\nversion: '3.4\\nservices:\\n  myfrontend:\\n    image: ${DOCKER_REGI\", \"STRY-}myfrontend\\n    build:\\n      context: .\\n      dockerfile: MyFrontEnd/Dockerfile\\n    ports:\\n    \", \"  - \\\"51000:50001\\n  myfrontend-dapr:\\n    image: \\\"daprio/daprd:latest\\\"\\n    command: [ \\\"./daprd\\\", \\\"-app\", \"-id\\\", \\\"MyFrontEnd\\\", \\\"-app-port\\\", \\\"80\\\" ]\\n    depends_on:\\n\\n33\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\f   \", \"   - myfrontend\\n    network_mode: \\\"service:myfrontend\\n  mybackend:\\n    image: ${DOCKER_REGISTRY-}myb\", \"ackend\\n    build:\\n      context: .\\n      dockerfile: MyBackEnd/Dockerfile\\n    ports:\\n      - \\\"52000:\", \"50001\\n  mybackend-dapr:\\n    image: \\\"daprio/daprd:latest\\\"\\n    command: [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyBac\", \"kEnd\\\", \\\"-app-port\\\", \\\"80\\\" ]\\n    depends_on:\\n      - mybackend\\n    network_mode: \\\"service:mybackend\\\"\\n\\n\", \"In the updated file, we've added [`myfrontend-dapr`]{custom-style=Code} and\\n[`mybackend-dapr`]{custo\", \"m-style=Code} sidecars for the [`myfrontend`]{custom-\\nstyle=Code} and [`mybackend`]{custom-style=Cod\", \"e} services respectively. In the updated\\nfile, pay close attention to the following changes:\\n\\n- The \", \"sidecars use the [`daprio/daprd:latest`]{custom-style=Code} container image. The\\nuse of the [`latest\", \"`]{custom-style=Code} tag isn't recommended for production\\nscenarios. For production, it's better to\", \" use a specific version number.\\n- Each service defined in the Compose file has its own network names\", \"pace for network\\nisolation purposes. The sidecars use [`network_mode: \\\"service:...\\\"`]{custom-\\nstyle=\", \"Code} to ensure they run in the same network namespace as the application. Doing\\nso allows the sidec\", \"ar and the application to communicate using [`localhost`]{custom-\\nstyle=Code}.\\n- The ports on which \", \"the Dapr sidecars are listening for gRPC communication (by\\ndefault 50001) must be exposed to allow t\", \"he sidecars to communicate with each other.\\n\\n1.\\n\\nRun the solution (F5 or Ctrl+F5) to verify that it \", \"works as expected. If everything is configured\\ncorrectly, you should see the weather forecast data:\\n\", \"\\n34\\n\\nCHAPTER 4 | Get started with Dapr\\n\\n\\fRunning locally with Docker Compose and Visual Studio, you \", \"can set breakpoints and\\ndebug into the application. For production scenarios, it's recommended to ho\", \"st your\\napplication in Kubernetes. This book includes an accompanying reference application,\\n[eShopO\", \"nDapr](https://github.com/dotnet-architecture/eShopOnDapr), that contains\\nscripts to deploy to Kuber\", \"netes.\\n\\nTo learn more about the Dapr service invocation building block used in this\\nwalkthrough, ref\", \"er to [chapter 6](#the-dapr-service-invocation-building-blo).\\n\\nSummary\\n\\nIn this chapter, you had an \", \"opportunity to test drive Dapr. Using the Dapr .NET SDK, you saw how\\nDapr integrates with the .NET a\", \"pplication platform.\\n\\nThe first example was a simple, stateful, .NET Console application that used t\", \"he Dapr state\\nmanagement building block.\\n\\nThe second example involved a multi-container application \", \"running in Docker. By using Visual Studio\\nwith Docker Compose, you experienced the familiar F5 debug\", \"ging experience available across all .NET\\napps.\\n\\nYou also got a closer look at Dapr component config\", \"uration files. They configure the actual\\ninfrastructure implementation used by the Dapr building blo\", \"cks. You can use namespaces and scopes\\nto restrict component access to particular environments and a\", \"pplications.\\n\\nIn the upcoming chapters, you\\u2019ll dive deep into the building blocks offered by Dapr.\\n\\n\", \"References\\n\\nDapr documentation - Getting started\\n\\neShopOnDapr\\n\\n\\u2022\\n\\n\\u2022\\n\\n35\\n\\nCHAPTER 4 | Get started wit\", \"h Dapr\\n\\n\\fCHAPTER  5\\n\\nTraffic Control sample\\napplication\\n\\nIn the first chapters, you\\u2019ve learned about\", \" basic Dapr concepts. You saw how Dapr can help you and\\nyour team construct distributed applications\", \" while reducing architectural and operational complexity.\\nThis chapter introduces the sample applica\", \"tion that you\\u2019ll use to explore the Dapr building blocks. The\\napplication targets .NET 7 and uses th\", \"e latest C# 11 language features.\\n\\nNote\\n\\nDownload the sample application code from the Dapr Traffic \", \"Control GitHub repo. This repository\\ncontains a detailed description on how you can run the sample a\", \"pplication on your machine.\\n\\nThe Traffic Control sample application simulates a highway traffic cont\", \"rol system. Its purpose is to\\ndetect speeding vehicles and send the offending driver a fine notice. \", \"These systems actually exist in\\nreal life and here\\u2019s how they work. A set of cameras (one above each\", \" lane) is placed at the beginning\\nand end of a highway stretch (say 10 kilometers) without on- or of\", \"f-ramps. As a vehicle passes\\nunderneath a camera, it takes a photograph of the vehicle. Using Optica\", \"l Character Recognition (OCR)\\nsoftware, it extracts the license number of the vehicle from the photo\", \". Using the entry- and exit-\\ntimestamp of each vehicle, the system calculates the average speed of t\", \"hat vehicle. If the average\\nspeed is above the maximum speed limit for that highway stretch, the sys\", \"tem retrieves the driver\\ninformation and automatically sends a fine notice.\\n\\nAlthough the simulation\", \" is simple, responsibilities within the system are separated into several\\nmicroservices. Figure 4.1 \", \"shows an overview of the services that are part of the application:\\n\\n36\\n\\nCHAPTER 5 | Traffic Control\", \" sample application\\n\\n\\f37\\n\\nCHAPTER 5 | Traffic Control sample application\\n\\n\\fFigure 4-1. The services \", \"in the sample application.\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe Camera Simulation is a console application that simulate\", \"s vehicles and sends messages to\\nthe TrafficControl service. Every simulated car invokes both the en\", \"try and exit service endpoints.\\n\\nThe TrafficControl service is an ASP.NET Core Web API application t\", \"hat exposes the /entrycam\\nand /exitcam endpoints. Invoking an endpoint simulates a car passing under\", \" one of the entry-\\nor exit-cameras respectively. The request message payload simply contains the lic\", \"ense plate of\\nthe car (no actual OCR is implemented).\\n\\nThe FineCollection service is an ASP.NET Core\", \" Web API application that offers 1 endpoint:\\n/collectfine. Invoking this endpoint will send a fine n\", \"otice to the driver of the speeding\\nvehicle. The payload of the request contains all the information\", \" about the speeding violation.\\n\\nThe VehicleRegistration service is an ASP.NET Core Web API applicati\", \"on that offers 1 endpoint:\\n/vehicleinfo/{licensenumber}. It\\u2019s used for obtaining vehicle- and owner-\", \"information for a\\nspeeding vehicle based on the license number sent in the URL (for example, /vehicl\", \"einfo/RV-\\n752-S).\\n\\nThe sequence diagram in figure 4.2 shows the simulation flow:\\n\\nFigure 4-2. Sequen\", \"ce diagram of the simulation flow.\\n\\nThe services communicate by directly invoking each other\\u2019s APIs.\", \" This design works fine, but it has\\nsome drawbacks.\\n\\n38\\n\\nCHAPTER 5 | Traffic Control sample applicat\", \"ion\\n\\n\\fThe biggest challenge is that the call-chain will break if one of the services is off-line. De\", \"coupling\\nservices by replacing direct calls with asynchronous messaging would solve this issue. Asyn\", \"chronous\\nmessaging is typically implemented with a message broker like RabbitMQ or Azure Service Bus\", \".\\n\\nAnother drawback is that the vehicle state for every vehicle is stored in memory in the TrafficCo\", \"ntrol\\nservice. This state is lost when the service is restarted after an update or a crash. To incre\", \"ase system\\ndurability, state should be stored outside the service.\\n\\nUsing Dapr building blocks\\n\\nOne \", \"of the goals of Dapr is to provide cloud-native capabilities for microservices applications. The\\nTra\", \"ffic Control application uses Dapr building blocks to increase robustness and mitigate the design\\ndr\", \"awbacks described in the previous paragraph. Figure 4.shows a Dapr-enabled version of the traffic\\nco\", \"ntrol application:\\n\\nFigure 4-3. Traffic Control application with Dapr building blocks.\\n\\n1.\\n\\n2.\\n\\nServ\", \"ice invocation The Dapr service invocation building block handles request/response\\ncommunication bet\", \"ween the FineCollectionService and the VehicleRegistrationService. Because\\nthe call is a query to re\", \"trieve required data to complete the operation, a synchronous call is\\nacceptable here. The service i\", \"nvocation building block provides service discovery. The\\nFineCollection service no longer has to kno\", \"w where the VehicleRegistration service lives. It also\\nimplements automatic retries if the VehicleRe\", \"gistration service is off-line.\\n\\nPublish & subscribe The publish and subscribe building block handle\", \"s asynchronous messaging\\nfor sending speeding violations from the TrafficControl service to the Fine\", \"CollectionService. This\\nimplementation decouples the TrafficControl and FineCollection service. If t\", \"he\\nFineCollectionService were to become temporarily unavailable, data would accumulate in the\\nqueue \", \"and resume processing at a later time. RabbitMQ is the current message broker that\\ntransports messag\", \"es from the producers to the consumers. As the Dapr pub/sub building block\\nabstracts the message bro\", \"ker, developers don\\u2019t need to learn the details of the RabbitMQ client\\nlibrary. Switching to another\", \" message broker doesn\\u2019t require code changes, only configuration.\\n\\n3.\\n\\nState management The TrafficC\", \"ontrol service uses the state management building block to\\npersist vehicle state outside of the serv\", \"ice in a Redis cache. As with pub/sub, developers don\\u2019t\\nneed to learn Redis specific APIs. Switching\", \" to another data store requires no code changes.\\n\\n4.  Output binding The FineCollection service send\", \"s fines to the owners of speeding vehicles by\\n\\nemail. The Dapr output binding for SMTP abstracts the\", \" email transmission using the SMTP\\nprotocol.\\n\\n5.\\n\\n6.\\n\\n39\\n\\nInput binding The CameraSimulation sends m\", \"essages with simulated car info to the\\nTrafficControl service using the MQTT protocol. It uses a .NE\", \"T MQTT library for sending\\nmessages to Mosquitto - a lightweight MQTT broker. The TrafficControl ser\", \"vice uses the Dapr\\ninput binding for MQTT to subscribe to the MQTT broker and receive messages.\\n\\nSec\", \"rets management The FineCollectionService needs credentials for connecting to the smtp\\nserver and a \", \"license-key for a fine calculator component it uses internally. It uses the secrets\\nmanagement build\", \"ing block to obtain the credentials and the license-key.\\n\\nCHAPTER 5 | Traffic Control sample applica\", \"tion\\n\\n\\f7.  Actors The TrafficControlService has an alternative implementation based on Dapr actors. \", \"In this\\nimplementation, the TrafficControl service creates a new actor for every vehicle that is reg\", \"istered\\nby the entry camera. The license number of the vehicle forms the unique actor Id. The actor\\n\", \"encapsulates the vehicle state, which it persists in the Redis cache. When a vehicle is registered\\nb\", \"y the exit camera, it invokes the actor. The actor then calculate the average speed and possibly\\niss\", \"ue a speeding violation.\\n\\nFigure 4.4 shows a sequence diagram of the flow of the simulation with all\", \" the Dapr building blocks in\\nplace:\\n\\nFigure 4-4. Sequence diagram of simulation flow with Dapr build\", \"ing blocks.\\n\\nThe rest of this book features a chapter for each of the Dapr building blocks. Each cha\", \"pter explains in\\ndetail how the building block works, its configuration, and how to use it. Each cha\", \"pter explains how\\nthe Traffic Control sample application uses the building block.\\n\\nHosting\\n\\nThe Traf\", \"fic Control sample application can run in self-hosted mode or in Kubernetes.\\n\\nSelf-hosted mode\\n\\nThe \", \"sample repository contains PowerShell scripts to start the infrastructure services (Redis,\\nRabbitMQ,\", \" and Mosquitto) as Docker containers on your machine. They\\u2019re located in the\\nsrc/Infrastructure fold\", \"er. For every application service in the solution, the repository contains a\\nseparate folder. Each o\", \"f these folders contains a start-selfhosted.ps1 PowerShell script to start the\\nservice with Dapr.\\n\\n4\", \"0\\n\\nCHAPTER 5 | Traffic Control sample application\\n\\n\\fKubernetes\\n\\nThe src/k8s folder in the sample rep\", \"ository contains the Kubernetes manifest files to run the\\napplication (including the infrastructure \", \"services) with Dapr in Kubernetes. This folder also contains a\\nstart.ps1 and stop.ps1 PowerShell scr\", \"ipt to start and stop the solution in Kubernetes. All services\\nwill run in the dapr-trafficcontrol n\", \"amespace.\\n\\nSummary\\n\\nThe Traffic Control sample application is a microservices application that simul\", \"ates a highway speed\\ntrap.\\n\\nThe application uses several Dapr building blocks to make it robust and \", \"cloud-native. The domain is\\nkept simple to keep the focus on Dapr.\\n\\nThe application will be used in \", \"the following chapters that focus on Dapr building block.\\n\\nReferences\\n\\n\\u2022\\n\\nDapr Traffic Control Sampl\", \"e\\n\\n41\\n\\nCHAPTER 5 | Traffic Control sample application\\n\\n\\fCHAPTER  6\\n\\nThe Dapr state\\nmanagement buildi\", \"ng\\nblock\\n\\nDistributed applications are composed of independent services. While each service should b\", \"e\\nstateless, some services must track state to complete business operations. Consider a shopping bas\", \"ket\\nservice for an e-Commerce site. If the service can\\u2019t track state, the customer could lose the sh\", \"opping\\nbasket content by leaving the website, resulting in a lost sale and an unhappy customer exper\", \"ience.\\nFor these scenarios, state needs to be persisted to a distributed state store. The Dapr state\", \"\\nmanagement building block simplifies state tracking and offers advanced features across various dat\", \"a\\nstores.\\n\\nTo try out the state management building block, have a look at the counter application sa\", \"mple in\\nchapter 3.\\n\\nWhat it solves\\n\\nTracking state in a distributed application can be challenging. \", \"For example:\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe application may require different types of data stores.\\n\\nDifferent consisten\", \"cy levels may be required for accessing and updating data.\\n\\n\\u2022  Multiple users may update data at the\", \" same time, requiring conflict resolution.\\n\\n\\u2022\\n\\nServices must retry any short-lived transient errors \", \"that occur while interacting with the data\\nstore.\\n\\nThe Dapr state management building block addresse\", \"s these challenges. It streamlines tracking state\\nwithout dependencies or a learning curve on third-\", \"party storage SDKs.\\n\\nImportant\\n\\nDapr state management offers a key/value API. The feature doesn\\u2019t su\", \"pport relational or graph data\\nstorage.\\n\\n42\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\n\\f\", \"How it works\\n\\nThe application interacts with a Dapr sidecar to store and retrieve key/value data. Un\", \"der the hood, the\\nsidecar API consumes a configurable state store component to persist data. Develop\", \"ers can choose\\nfrom a growing collection of supported state stores that include Azure Cosmos DB, SQL\", \" Server, and\\nCassandra.\\n\\nThe API can be called with either HTTP or gRPC. Use the following URL to ca\", \"ll the HTTP API:\\n\\nhttp://localhost:<dapr-port>/v1.0/state/<store-name>/\\n\\n\\u2022\\n\\n\\u2022\\n\\n<dapr-port>: the HTTP\", \" port that Dapr listens on.\\n\\n<store-name>: the name of the state store component to use.\\n\\nFigure 5-1\", \" shows how a Dapr-enabled shopping basket service stores a key/value pair using the Dapr\\nstate store\", \" component named statestore.\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/state-management/state-managem\", \"ent-flow.png\\u201d alt-\\ntext=\\u201cDiagram of storing a key/value pair in a Dapr state store.\\u201d:::\\n\\nFigure 5-1.\", \" Storing a key/value pair in a Dapr state store.\\n\\nNote the steps in the previous figure:\\n\\n1.\\n\\n2.\\n\\nTh\", \"e basket service calls the state management API on the Dapr sidecar. The body of the request\\nenclose\", \"s a JSON array that can contain multiple key/value pairs.\\n\\nThe Dapr sidecar determines the state sto\", \"re based on the component configuration file. In this\\ncase, it\\u2019s a Redis cache state store.\\n\\n3.\\n\\nThe\", \" sidecar persists the data to the Redis cache.\\n\\nRetrieving the stored data is a similar API call. In\", \" the example below, a curl command retrieves the\\ndata by calling the Dapr sidecar API:\\n\\ncurl http://\", \"localhost:3500/v1.0/state/statestore/basket1\\n\\nThe command returns the stored state in the response b\", \"ody:\\n\\n{\\n  \\\"items\\\": [\\n    {\\n      \\\"itemId\\\": \\\"DaprHoodie\\\",\\n      \\\"quantity\\\": 1\\n    }\\n  ],\\n  \\\"customerI\", \"d\\\": 1\\n}\\n\\nThe following sections explain how to use the more advanced features of the state managemen\", \"t\\nbuilding block.\\n\\nConsistency\\n\\nThe CAP theorem is a set of principles that apply to distributed sys\", \"tems that store state. Figure 5-2\\nshows the three properties of the CAP theorem.\\n\\n43\\n\\nCHAPTER 6 | Th\", \"e Dapr state management building block\\n\\n\\f:::image type=\\u201ccontent\\u201d source=\\u201c./media/state-management/ca\", \"p-theorem.png\\u201d alt-text=\\u201cThe CAP\\ntheorem.\\u201d:::\\n\\nFigure 5-2. The CAP theorem.\\n\\nThe theorem states that\", \" distributed data systems offer a trade-off between consistency, availability,\\nand partition toleran\", \"ce. And, that any datastore can only guarantee two of the three properties:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nConsistency (C\", \"). Every node in the cluster responds with the most recent data, even if the system\\nmust block the r\", \"equest until all replicas update. If you query a \\u201cconsistent system\\u201d for an item\\nthat is currently u\", \"pdating, you won\\u2019t get a response until all replicas successfully update.\\nHowever, you\\u2019ll always rec\", \"eive the most current data.\\n\\nAvailability (A). Every node returns an immediate response, even if tha\", \"t response isn\\u2019t the most\\nrecent data. If you query an \\u201cavailable system\\u201d for an item that is updati\", \"ng, you\\u2019ll get the best\\npossible answer the service can provide at that moment.\\n\\nPartition Tolerance\", \" (P). Guarantees the system continues to operate even if a replicated data\\nnode fails or loses conne\", \"ctivity with other replicated data nodes.\\n\\nDistributed applications must handle the P property. As s\", \"ervices communicate among each other with\\nnetwork calls, network disruptions (P) will occur. With th\", \"at in mind, distributed applications must\\neither be AP or CP.\\n\\nAP applications choose availability o\", \"ver consistency. Dapr supports this choice with its eventual\\nconsistency strategy. Consider an under\", \"lying data store, such as Azure CosmosDB, which stores\\nredundant data on multiple replicas. With eve\", \"ntual consistency, the state store writes the update to\\none replica and completes the write request \", \"with the client. After this time, the store will\\nasynchronously update its replicas. Read requests c\", \"an return data from any of the replicas, including\\nthose replicas that haven\\u2019t yet received the late\", \"st update.\\n\\nCP applications choose consistency over availability. Dapr supports this choice with its\", \" strong\\nconsistency strategy. In this scenario, the state store will synchronously update all (or, i\", \"n some cases,\\na quorum of) required replicas before completing the write request. Read operations wi\", \"ll return the\\nmost up-to-date data consistently across replicas.\\n\\nThe consistency level for a state \", \"operation is specified by attaching a consistency hint to the operation.\\nThe following curl command \", \"writes a Hello=World key/value pair to a state store using a strong\\nconsistency hint:\\n\\ncurl -X POST \", \"http://localhost:3500/v1.0/state/<store-name> \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  -d '[\\n    \", \"    {\\n          \\\"key\\\": \\\"Hello\\\",\\n          \\\"value\\\": \\\"World\\\",\\n          \\\"options\\\": {\\n            \\\"cons\", \"istency\\\": \\\"strong\\\"\\n          }\\n        }\\n      ]'\\n\\n44\\n\\nCHAPTER 6 | The Dapr state management buildin\", \"g block\\n\\n\\fImportant\\n\\nIt is up to the Dapr state store component to fulfill the consistency hint atta\", \"ched to the operation. Not\\nall data stores support both consistency levels. If no consistency hint i\", \"s set, the default behavior is\\neventual.\\n\\nConcurrency\\n\\nIn a multi-user application, there\\u2019s a chance\", \" that multiple users will update the same data concurrently\\n(at the same time). Dapr supports optimi\", \"stic concurrency control (OCC) to manage conflicts. OCC is\\nbased on an assumption that update confli\", \"cts are uncommon because users work on different parts of\\nthe data. It\\u2019s more efficient to assume an\", \" update will succeed and retry if it doesn\\u2019t. The alternative,\\nimplementing pessimistic locking, can\", \" affect performance with long-running locking causing data\\ncontention.\\n\\nDapr supports optimistic con\", \"currency control (OCC) using ETags. An ETag is a value associated with a\\nspecific version of a store\", \"d key/value pair. Each time a key/value pair updates, the ETag value updates\\nas well. When a client \", \"retrieves a key/value pair, the response includes the current ETag value. When a\\nclient updates or d\", \"eletes a key/value pair, it must send that ETag value back in the request body. If\\nanother client ha\", \"s updated the data in the meantime, the ETags won\\u2019t match and the request will fail.\\nAt this point, \", \"the client must retrieve the updated data, make the change again, and resubmit the\\nupdate. This stra\", \"tegy is called first-write-wins.\\n\\nDapr also supports a last-write-wins strategy. With this approach,\", \" the client doesn\\u2019t attach an ETag\\nto the write request. The state store component will always allow\", \" the update, even if the underlying\\nvalue has changed during the session. Last-write-wins is useful \", \"for high-throughput write scenarios\\nwith low data contention. As well, overwriting an occasional use\", \"r update can be tolerated.\\n\\nTransactions\\n\\nDapr can write multi-item changes to a data store as a sin\", \"gle operation implemented as a transaction.\\nThis functionality is only available for data stores tha\", \"t support ACID transactions. At the time of this\\nwriting, these stores include Redis, MongoDB, Postg\", \"reSQL, SQL Server, and Azure CosmosDB.\\n\\nIn the example below, a multi-item operation is sent to the \", \"state store in a single transaction. All\\noperations must succeed for the transaction to commit. If o\", \"ne or more of the operations fail, the\\nentire transaction rolls back.\\n\\ncurl -X POST http://localhost\", \":3500/v1.0/state/<store-name>/transaction \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  -d '{\\n        \", \"\\\"operations\\\": [\\n          {\\n            \\\"operation\\\": \\\"upsert\\\",\\n            \\\"request\\\": { \\\"key\\\": \\\"Key1\", \"\\\", \\\"value\\\": \\\"Value1\\\"\\n            }\\n          },\\n          {\\n            \\\"operation\\\": \\\"delete\\\",\\n     \", \"       \\\"request\\\": { \\\"key\\\": \\\"Key2\\\" }\\n          }\\n\\n45\\n\\nCHAPTER 6 | The Dapr state management building \", \"block\\n\\n\\f        ]\\n      }'\\n\\nFor data stores that don\\u2019t support transactions, multiple keys can still\", \" be sent as a single request. The\\nfollowing example shows a bulk write operation:\\n\\ncurl -X POST http\", \"://localhost:3500/v1.0/state/<store-name> \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  -d '[\\n        \", \"{ \\\"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\" },\\n        { \\\"key\\\": \\\"Key2\\\", \\\"value\\\": \\\"Value2\\\" }\\n      ]'\\n\\nFor bul\", \"k operations, Dapr will submit each key/value pair update as a separate request to the data\\nstore.\\n\\n\", \"Use the Dapr .NET SDK\\n\\nThe Dapr .NET SDK provides language-specific support for the .NET platform. D\", \"evelopers can use the\\nDaprClient class introduced in chapter 3 to read and write data. The following\", \" example shows how to\\nuse the DaprClient.GetStateAsync<TValue> method to read data from a state stor\", \"e. The method\\nexpects the store name, statestore, and key, AMS, as parameters:\\n\\nvar weatherForecast \", \"= await daprClient.GetStateAsync<WeatherForecast>(\\\"statestore\\\", \\\"AMS\\\");\\n\\nIf the state store contains\", \" no data for key AMS, the result will be default(WeatherForecast).\\n\\nTo write data to the data store,\", \" use the DaprClient.SaveStateAsync<TValue> method:\\n\\ndaprClient.SaveStateAsync(\\\"statestore\\\", \\\"AMS\\\", w\", \"eatherForecast);\\n\\nThe example uses the last-write-wins strategy as an ETag value isn\\u2019t passed to the\", \" state store\\ncomponent. To use optimistic concurrency control (OCC) with a first-write-wins strategy\", \", first retrieve\\nthe current ETag using the DaprClient.GetStateAndETagAsync method. Then write the u\", \"pdated\\nvalue and pass along the retrieved ETag using the DaprClient.TrySaveStateAsync method.\\n\\nvar (\", \"weatherForecast, etag) = await\\ndaprClient.GetStateAndETagAsync<WeatherForecast>(\\\"statestore\\\", city);\", \"\\n\\n// ... make some changes to the retrieved weather forecast\\n\\nvar result = await daprClient.TrySaveS\", \"tateAsync(\\\"statestore\\\", city, weatherForecast, etag);\\n\\nThe DaprClient.TrySaveStateAsync method fails\", \" when the data (and associated ETag) has been\\nchanged in the state store after the data was retrieve\", \"d. The method returns a boolean value to\\nindicate whether the call succeeded. A strategy to handle t\", \"he failure is to simply reload the updated\\ndata from the state store, make the change again, and res\", \"ubmit the update.\\n\\nIf you always want a write to succeed regardless of other changes to the data, us\", \"e the last-write-wins\\nstrategy.\\n\\nThe SDK provides other methods to retrieve data in bulk, delete dat\", \"a, and execute transactions. For\\nmore information, see the Dapr .NET SDK repository.\\n\\n46\\n\\nCHAPTER 6 \", \"| The Dapr state management building block\\n\\n\\fASP.NET Core integration\\n\\nDapr also supports ASP.NET Co\", \"re, a cross-platform framework for building modern cloud-based web\\napplications. The Dapr SDK integr\", \"ates state management capabilities directly into the ASP.NET Core\\nmodel binding capabilities. Config\", \"uration is simple. In the Program.cs file, call the following extension\\nmethod on the WebApplication\", \" builder:\\n\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder.Services.AddControllers().AddDa\", \"pr();\\n\\nOnce configured, Dapr can inject a key/value pair directly into a controller action using the\", \" ASP.NET\\nCore FromState attribute. Referencing the DaprClient object is no longer necessary. The nex\", \"t\\nexample shows a Web API that returns the weather forecast for a given city:\\n\\n[HttpGet(\\\"{city}\\\")]\\np\", \"ublic ActionResult<WeatherForecast> Get([FromState(\\\"statestore\\\", \\\"city\\\")]\\nStateEntry<WeatherForecast\", \"> forecast)\\n{\\n    if (forecast.Value == null)\\n    {\\n      return NotFound();\\n    }\\n\\n    return forec\", \"ast.Value;\\n}\\n\\nIn the example, the controller loads the weather forecast using the FromState attribut\", \"e. The first\\nattribute parameter is the state store, statestore. The second attribute parameter, cit\", \"y, is the name\\nof the route template variable to get the state key. If you omit the second parameter\", \", the name of the\\nbound method parameter (forecast) is used to look up the route template variable.\\n\", \"\\nThe StateEntry class contains properties for all the information that is retrieved for a single key\", \"/value\\npair: StoreName, Key, Value, and ETag. The ETag is useful for implementing optimistic concurr\", \"ency\\ncontrol (OCC) strategy. The class also provides methods to delete or update retrieved key/value\", \" data\\nwithout requiring a DaprClient instance. In the next example, the TrySaveAsync method is used \", \"to\\nupdate the retrieved weather forecast using OCC.\\n\\n[HttpPut(\\\"{city}\\\")]\\npublic async Task Put(Weath\", \"erForecast updatedForecast, [FromState(\\\"statestore\\\", \\\"city\\\")]\\nStateEntry<WeatherForecast> currentFor\", \"ecast)\\n{\\n    // update cached current forecast with updated forecast passed into service endpoint\\n  \", \"  currentForecast.Value = updatedForecast;\\n\\n    // update state store\\n    var success = await curren\", \"tForecast.TrySaveAsync();\\n\\n    // ... check result\\n}\\n\\nState store components\\n\\nAt the time of this wr\", \"iting, Dapr provides support for the following transactional state stores:\\n\\n47\\n\\nCHAPTER 6 | The Dapr\", \" state management building block\\n\\n\\f\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nAzure CosmosDB\\n\\nAzure SQL Server\\n\\nCockroachDB\\n\\nIn Mem\", \"ory\\n\\n\\u2022  MongoDB\\n\\n\\u2022  MySQL\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nOracle Database\\n\\nPostgreSQL\\n\\nRedis\\n\\nRethinkDB\\n\\nDapr also incl\", \"udes support for state stores that support CRUD operations, but not transactional\\ncapabilities:\\n\\n\\u2022\\n\\n\", \"\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nAerospike\\n\\nApache Cassandra\\n\\nAWS DynamoDB\\n\\nAzure Blob Storage\\n\\nAzure Tabl\", \"e Storage\\n\\nCouchbase\\n\\nGCP Firestore\\n\\nHashicorp Consul\\n\\nHazelcast\\n\\nJetStream KV\\n\\n\\u2022  Memcached\\n\\n\\u2022\\n\\n\\u2022\\n\\n\", \"Oracle Object Storage\\n\\nZookeeper\\n\\nConfiguration\\n\\nWhen initialized for local, self-hosted development\", \", Dapr registers Redis as the default state store.\\nHere\\u2019s an example of the default state store conf\", \"iguration. Note the default name, statestore:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata\", \":\\n  name: statestore\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    val\", \"ue: localhost:6379\\n  - name: redisPassword\\n    value: \\\"\\\"\\n  - name: actorStateStore\\n    value: \\\"true\\\"\", \"\\n\\n48\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\n\\f[!NOTE] Many state stores can be regist\", \"ered to a single application each with a different name.\\n\\nThe Redis state store requires redisHost a\", \"nd redisPassword metadata to connect to the Redis\\ninstance. In the example above, the Redis password\", \" (which is an empty string by default) is stored as a\\nplain string. The best practice is to avoid cl\", \"ear-text strings and always use secret references. To learn\\nmore about secret management, see chapte\", \"r 10.\\n\\nThe other metadata field, actorStateStore, indicates whether the state store can be consumed \", \"by\\nthe actors building block.\\n\\nKey prefix strategies\\n\\nState store components enable different strate\", \"gies to store key/value pairs in the underlying store.\\nRecall the earlier example of a shopping bask\", \"et service storing items a customer wishes to purchase:\\n\\ncurl -X POST http://localhost:3500/v1.0/sta\", \"te/statestore \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  -d '[{\\n        \\\"key\\\": \\\"basket1\\\",\\n        \\\"\", \"value\\\": {\\n          \\\"customerId\\\": 1,\\n          \\\"items\\\": [\\n            { \\\"itemId\\\": \\\"DaprHoodie\\\", \\\"qua\", \"ntity\\\": 1 }\\n          ]\\n        }\\n     }]'\\n\\nUsing the Redis Console tool, look inside the Redis cach\", \"e to see how the Redis state store component\\npersisted the data:\\n\\n127.0.0.1:6379> KEYS *\\n1) \\\"baskets\", \"ervice||basket1\\\"\\n\\n127.0.0.1:6379> HGETALL basketservice||basket1\\n1) \\\"data\\\"\\n2) \\\"{\\\\\\\"items\\\\\\\":[{\\\\\\\"itemId\", \"\\\\\\\":\\\\\\\"DaprHoodie\\\\\\\",\\\\\\\"quantity\\\\\\\":1}],\\\\\\\"customerId\\\\\\\":1}\\\"\\n3) \\\"version\\\"\\n4) \\\"1\\\"\\n\\nThe output shows the full\", \" Redis key for the data as basketservice||basket1. By default, Dapr uses\\nthe application id of the D\", \"apr instance (basketservice) as a prefix for the key. This naming\\nconvention enables multiple Dapr i\", \"nstances to share the same data store without key name collisions.\\nFor the developer, it\\u2019s critical \", \"always to specify the same application id when running the\\napplication with Dapr. If omitted, Dapr w\", \"ill generate a unique application ID. If the application id\\nchanges, the application can no longer a\", \"ccess the state stored with the previous key prefix.\\n\\nThat said, it\\u2019s possible to configure a consta\", \"nt value for the key prefix in the keyPrefix metadata field\\nin the state store component file. Consi\", \"der the following example:\\n\\nspec:\\n  metadata:\\n  - name: keyPrefix\\n  - value: MyPrefix\\n\\n49\\n\\nCHAPTER 6\", \" | The Dapr state management building block\\n\\n\\fA constant key prefix enables the state store to be ac\", \"cessed across multiple Dapr applications. What\\u2019s\\nmore, setting the keyPrefix to none omits the prefi\", \"x completely.\\n\\nSample application: Dapr Traffic Control\\n\\nIn the Dapr Traffic Control sample app, the\", \" TrafficControl service uses the Dapr state management\\nbuilding block to persist the entry and exit \", \"timestamps of each passing vehicle. Figure 5-3 shows the\\nconceptual architecture of the Dapr Traffic\", \" Control sample application. The Dapr state management\\nbuilding block is used in flows marked with n\", \"umber 3 in the diagram:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/state-management/dapr-solution-stat\", \"e-management.png\\u201d\\nalt-text=\\u201cConceptual architecture of the Dapr Traffic Control sample application.\\u201d\", \":::\\n\\nFigure 5-3. Conceptual architecture of the Dapr Traffic Control sample application.\\n\\nEntry and \", \"exit event logic is handled by the TrafficController class, an ordinary ASP.NET Controller.\\nThe Traf\", \"ficController.VehicleEntry method accepts an incoming VehicleRegistered message\\nand saves the enclos\", \"ed vehicle state:\\n\\n// store vehicle state\\nvar vehicleState = new VehicleState\\n{\\n    LicenseNumber = \", \"msg.LicenseNumber,\\n    EntryTimestamp = msg.Timestamp\\n};\\nawait _vehicleStateRepository.SaveVehicleSt\", \"ateAsync(vehicleState);\\n\\nIn the preceding code snippet, the abstraction _vehicleStateRepository is r\", \"esponsible for saving\\nstate to the data store. Its concrete implementation, DaprVehicleStateReposito\", \"ry, is shown below:\\n\\npublic class DaprVehicleStateRepository : IVehicleStateRepository\\n{\\n    private\", \" const string DAPR_STORE_NAME = \\\"statestore\\\";\\n    private readonly DaprClient _daprClient;\\n\\n    publ\", \"ic DaprVehicleStateRepository(DaprClient daprClient)\\n    {\\n        _daprClient = daprClient;\\n    }\\n\\n\", \"    public async Task SaveVehicleStateAsync(VehicleState vehicleState)\\n    {\\n        await _daprClie\", \"nt.SaveStateAsync<VehicleState>(\\n            DAPR_STORE_NAME, vehicleState.LicenseNumber, vehicleSta\", \"te);\\n    }\\n\\n    public async Task<VehicleState> GetVehicleStateAsync(string licenseNumber)\\n    {\\n   \", \"     return await _daprClient.GetStateAsync<VehicleState>(\\n            DAPR_STORE_NAME, licenseNumbe\", \"r);\\n    }\\n}\\n\\nAs the preceding code snippet shows, the implementation of the DaprVehicleStateReposito\", \"ry class\\nis pretty straightforward. The SaveVehicleStateAsync method uses the injected DaprClient ob\", \"ject\\n\\n50\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\n\\fto save the state to the configured\", \" Dapr state store. It uses the vehicle\\u2019s license number as the key.\\nThe application can retrieve the\", \" saved state by calling the GetVehicleStateAsync method.\\n\\nThe TrafficControl service uses Redis as i\", \"ts underlying data store. Looking at the code, you\\u2019d never\\nknow it. A service consuming the Dapr sta\", \"te management building block doesn\\u2019t directly reference\\nany state components. Instead, a Dapr compon\", \"ent configuration file specifies the store:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n\", \"  name: statestore\\n  namespace: dapr-trafficcontrol\\nspec:\\n  type: state.redis\\n  version: v1\\n  metada\", \"ta:\\n  - name: redisHost\\n    value: localhost:6379\\n  - name: redisPassword\\n    secretKeyRef:\\n      na\", \"me: state.redisPassword\\n      key: state.redisPassword\\nscopes:\\n  - trafficcontrolservice\\n\\nNote\\n\\nThe \", \"component configuration file includes an element secretKeyRef. The application uses it to\\nreference \", \"the Redis password value from the Dapr secrets building block. See chapter 10 to learn\\nmore about ma\", \"naging secrets with Dapr.\\n\\nThe type element in the configuration, state.redis instructs the building\", \" block to manage state with\\nDapr Redis component.\\n\\nThe scopes element in the configuration constrain\", \"s application access to the state store component.\\nOnly the TrafficControl service can access the st\", \"ate store.\\n\\nSummary\\n\\nThe Dapr state management building block offers an API for storing key/value da\", \"ta across various\\ndata stores. The API provides support for:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nBulk operations\\n\\nStrong and e\", \"ventual consistency\\n\\nOptimistic concurrency control\\n\\n\\u2022  Multi-item transactions\\n\\nThe .NET SDK provid\", \"es language-specific support for .NET and ASP.NET Core. Model binding\\nintegration simplifies accessi\", \"ng and updating state from ASP.NET Core controller action methods.\\n\\nIn the Dapr Traffic Control samp\", \"le application, the benefits of using Dapr state management are clear:\\n\\n51\\n\\nCHAPTER 6 | The Dapr sta\", \"te management building block\\n\\n\\f1.\\n\\n2.\\n\\nIt abstracts away the complexity of using third-party SDKs, s\", \"uch as StackExchange.Redis.\\n\\nReplacing the underlying Redis cache with a different type of data stor\", \"e only requires changes to\\nthe component configuration file.\\n\\nReferences\\n\\n\\u2022\\n\\nDapr supported state st\", \"ores\\n\\n52\\n\\nCHAPTER 6 | The Dapr state management building block\\n\\n\\fCHAPTER  7\\n\\nThe Dapr service\\ninvoca\", \"tion building block\\n\\nAcross a distributed system, one service often needs to communicate with anothe\", \"r to complete a\\nbusiness operation. The Dapr service invocation building block can help streamline t\", \"he\\ncommunication between services.\\n\\nWhat it solves\\n\\nMaking calls between services in a distributed a\", \"pplication may appear easy, but there are many\\nchallenges involved. For example:\\n\\n\\u2022  Where the other\", \" services are located.\\n\\n\\u2022\\n\\n\\u2022\\n\\nHow to call a service securely, given the service address.\\n\\nHow to han\", \"dle retries when short-lived transient errors occur.\\n\\nLastly, as distributed applications compose ma\", \"ny different services, capturing insights across service\\ncall graphs are critical to diagnosing prod\", \"uction issues.\\n\\nThe service invocation building block addresses these challenges by using a Dapr sid\", \"ecar as a reverse\\nproxy for your service.\\n\\nHow it works\\n\\nLet\\u2019s start with an example. Consider two s\", \"ervices, \\u201cService A\\u201d and \\u201cService B\\u201d. Service A needs to call\\nthe catalog/items API on Service B. Wh\", \"ile Service A could take a dependency on Service B and make\\na direct call to it, Service A instead i\", \"nvokes the service invocation API on the Dapr sidecar. Figure 6-1\\nshows the operation.\\n\\n53\\n\\nCHAPTER \", \"7 | The Dapr service invocation building block\\n\\n\\fFigure 6-1. How Dapr service invocation works.\\n\\nNot\", \"e the steps from the previous figure:\\n\\n1.\\n\\nService A makes a call to the catalog/items endpoint in S\", \"ervice B by invoking the service\\ninvocation API on the Service A sidecar.\\n\\n[!NOTE] The sidecar uses \", \"a pluggable name resolution component to resolve the address of\\nService B. In self-hosted mode, Dapr\", \" uses mDNS to find it. When running in Kubernetes mode,\\nthe Kubernetes DNS service determines the ad\", \"dress.\\n\\nThe Service A sidecar forwards the request to the Service B sidecar.\\n\\nThe Service B sidecar \", \"makes the actual catalog/items request against the Service B API.\\n\\nService B executes the request an\", \"d returns a response back to its sidecar.\\n\\nThe Service B sidecar forwards the response back to the S\", \"ervice A sidecar.\\n\\nThe Service A sidecar returns the response back to Service A.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\n5.\\n\\n6.\", \"\\n\\nBecause the calls flow through sidecars, Dapr can inject some useful cross-cutting behaviors:\\n\\n\\u2022\\n\\n\", \"Automatically retry calls upon failure.\\n\\n\\u2022  Make calls between services secure with mutual (mTLS) au\", \"thentication, including automatic\\n\\ncertificate rollover.\\n\\n\\u2022\\n\\n\\u2022\\n\\n54\\n\\nControl what operations clients \", \"can do using access control policies.\\n\\nCapture traces and metrics for all calls between services to \", \"provide insights and diagnostics.\\n\\nCHAPTER 7 | The Dapr service invocation building block\\n\\n\\fAny appl\", \"ication can invoke a Dapr sidecar by using the native invoke API built into Dapr. The API can\\nbe cal\", \"led with either HTTP or gRPC. Use the following URL to call the HTTP API:\\n\\nhttp://localhost:<dapr-po\", \"rt>/v1.0/invoke/<application-id>/method/<method-name>\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n<dapr-port> the HTTP port that Dapr \", \"is listening on.\\n\\n<application-id> application ID of the service to call.\\n\\n<method-name> name of the\", \" method to invoke on the remote service.\\n\\nIn the following example, a curl call is made to the catal\", \"og/items \\u2018GET\\u2019 endpoint of Service B:\\n\\ncurl http://localhost:3500/v1.0/invoke/serviceb/method/catalo\", \"g/items\\n\\nNote\\n\\nThe Dapr APIs enable any application stack that supports HTTP or gRPC to use Dapr bui\", \"lding blocks.\\nTherefore, the service invocation building block can act as a bridge between protocols\", \". Services can\\ncommunicate with each other using HTTP, gRPC or a combination of both.\\n\\nIn the next s\", \"ection, you\\u2019ll learn how to use the .NET SDK to simplify service invocation calls.\\n\\nUse the Dapr .NE\", \"T SDK\\n\\nThe Dapr .NET SDK provides .NET developers with an intuitive and language-specific way to int\", \"eract\\nwith Dapr. The SDK offers developers three ways of making remote service invocation calls:\\n\\n1.\", \"\\n\\n2.\\n\\n3.\\n\\nInvoke HTTP services using HttpClient\\n\\nInvoke HTTP services using DaprClient\\n\\nInvoke gRPC \", \"services using DaprClient\\n\\nInvoke HTTP services using HttpClient\\n\\nThe preferred way to call an HTTP \", \"endpoint is to use Dapr\\u2019s rich integration with HttpClient. The\\nfollowing example submits an order b\", \"y calling the submit method of the orderservice application:\\n\\nvar httpClient = DaprClient.CreateInvo\", \"keHttpClient();\\nawait httpClient.PostAsJsonAsync(\\\"http://orderservice/submit\\\", order);\\n\\nIn the examp\", \"le, DaprClient.CreateInvokeHttpClient returns an HttpClient instance that is used to\\nperform Dapr se\", \"rvice invocation. The returned HttpClient uses a special Dapr message handler that\\nrewrites URIs of \", \"outgoing requests. The host name is interpreted as the application ID of the service to\\ncall. The re\", \"written request that\\u2019s actually being called is:\\n\\nhttp://127.0.0.1:3500/v1/invoke/orderservice/metho\", \"d/submit\\n\\nThis example uses the default value for the Dapr HTTP endpoint, which is http://127.0.0.1:\", \"<dapr-\\nhttp-port>/. The value of dapr-http-port is taken from the DAPR_HTTP_PORT environment variabl\", \"e.\\nIf it\\u2019s not set, the default port number 3500 is used.\\n\\n55\\n\\nCHAPTER 7 | The Dapr service invocati\", \"on building block\\n\\n\\fAlternatively, you can configure a custom endpoint in the call to\\nDaprClient.Cre\", \"ateInvokeHttpClient:\\n\\nvar httpClient = DaprClient.CreateInvokeHttpClient(daprEndpoint: \\\"localhost:40\", \"00\\\");\\n\\nYou can also directly set the base address by specifying the application ID. Doing so enables\", \" relative\\nURIs when making a call:\\n\\nvar httpClient = DaprClient.CreateInvokeHttpClient(\\\"orderservice\", \"\\\");\\nawait httpClient.PostAsJsonAsync(\\\"/submit\\\");\\n\\nThe HttpClient object is intended to be long-lived\", \". A single HttpClient instance can be reused for\\nthe lifetime of the application. The next scenario \", \"demonstrates how an OrderServiceClient class\\nreuses a Dapr HttpClient instance:\\n\\nvar builder = WebAp\", \"plication.CreateBuilder(args);\\nbuilder.Services.AddSingleton<IOrderServiceClient, OrderServiceClient\", \">(\\n    _ => new OrderServiceClient(DaprClient.CreateInvokeHttpClient(\\\"orderservice\\\")));\\n\\nIn the snip\", \"pet above, the OrderServiceClient is registered as a singleton with the ASP.NET Core\\ndependency inje\", \"ction system. An implementation factory creates a new HttpClient instance by\\ncalling DaprClient.Crea\", \"teInvokeHttpClient. It then uses the newly created HttpClient to\\ninstantiate the OrderServiceClient \", \"object. By registering the OrderServiceClient as a singleton, it\\nwill be reused for the lifetime of \", \"the application.\\n\\nThe OrderServiceClient itself has no Dapr-specific code. Even though Dapr service \", \"invocation is\\nused under the hood, you can treat the Dapr HttpClient like any other HttpClient:\\n\\npub\", \"lic class OrderServiceClient : IOrderServiceClient\\n{\\n    private readonly HttpClient _httpClient;\\n\\n \", \"   public OrderServiceClient(HttpClient httpClient)\\n    {\\n        _httpClient = httpClient ?? throw \", \"new ArgumentNullException(nameof(httpClient));\\n    }\\n\\n    public async Task SubmitOrder(Order order)\", \"\\n    {\\n        var response = await _httpClient.PostAsJsonAsync(\\\"submit\\\", order);\\n        response.E\", \"nsureSuccessStatusCode();\\n    }\\n}\\n\\nUsing the HttpClient class with Dapr service invocation has many \", \"benefits:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n56\\n\\nHttpClient is a well-known class that many developers already use in thei\", \"r code. Using HttpClient\\nfor Dapr service invocation allows developers to reuse their existing skill\", \"s.\\n\\nHttpClient supports advanced scenarios, such as custom headers, and full control over request\\nan\", \"d response messages.\\n\\nIn .NET 5, HttpClient supports automatic serialization and deserialization usi\", \"ng System.Text.Json.\\n\\nHttpClient integrates with many existing frameworks and libraries, such as Ref\", \"it, RestSharp, and\\nPolly.\\n\\nCHAPTER 7 | The Dapr service invocation building block\\n\\n\\fInvoke HTTP serv\", \"ices using DaprClient\\n\\nWhile HttpClient is the preferred way to invoke services using HTTP semantics\", \", you can also use the\\nDaprClient.InvokeMethodAsync family of methods. The following example submits\", \" an order by\\ncalling the submit method of the orderservice application:\\n\\nvar daprClient = new DaprCl\", \"ientBuilder().Build();\\ntry\\n{\\n    var confirmation =\\n        await daprClient.InvokeMethodAsync<Order\", \", OrderConfirmation>(\\n            \\\"orderservice\\\", \\\"submit\\\", order);\\n}\\ncatch (InvocationException ex)\", \"\\n{\\n    // Handle error\\n}\\n\\nThe third argument, an order object, is serialized internally (with System\", \".Text.JsonSerializer) and\\nsent as the request payload. The .NET SDK takes care of the call to the si\", \"decar. It also deserializes the\\nresponse to an OrderConfirmation object. Because no HTTP method is s\", \"pecified, the request is\\nexecuted as an HTTP POST.\\n\\nThe next example demonstrates how you can make a\", \"n HTTP GET request by specifying the\\nHttpMethod:\\n\\nvar catalogItems = await\\ndaprClient.InvokeMethodAs\", \"ync<IEnumerable<CatalogItem>>(HttpMethod.Get, \\\"catalogservice\\\",\\n\\\"items\\\");\\n\\nFor some scenarios, you m\", \"ay require more control over the request message. For example, when you\\nneed to specify request head\", \"ers, or you want to use a custom serializer for the payload.\\nDaprClient.CreateInvokeMethodRequest cr\", \"eates an HttpRequestMessage. The following example\\ndemonstrates how to add an HTTP authorization hea\", \"der to a request message:\\n\\nvar request = daprClient.CreateInvokeMethodRequest(\\\"orderservice\\\", \\\"submi\", \"t\\\", order);\\nrequest.Headers.Authorization = new AuthenticationHeaderValue(\\\"bearer\\\", token);\\n\\nThe Htt\", \"pRequestMessage now has the following properties set:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nUrl = http://127.0.0.1:3500/v1.0/\", \"invoke/orderservice/method/submit\\n\\nHttpMethod = POST\\n\\nContent = JsonContent object containing the JS\", \"ON-serialized order\\n\\nHeaders.Authorization = \\u201cbearer <token>\\u201d\\n\\nOnce you\\u2019ve got the request set up th\", \"e way you want, use DaprClient.InvokeMethodAsync to send it:\\n\\nvar orderConfirmation = await daprClie\", \"nt.InvokeMethodAsync<OrderConfirmation>(request);\\n\\nDaprClient.InvokeMethodAsync deserializes the res\", \"ponse to an OrderConfirmation object if the\\nrequest is successful. Alternatively, you can use DaprCl\", \"ient.InvokeMethodWithResponseAsync to get\\nfull access to the underlying HttpResponseMessage:\\n\\n57\\n\\nCH\", \"APTER 7 | The Dapr service invocation building block\\n\\n\\fvar response = await daprClient.InvokeMethodW\", \"ithResponseAsync(request);\\nresponse.EnsureSuccessStatusCode();\\n\\nvar orderConfirmation = response.Con\", \"tent.ReadFromJsonAsync<OrderConfirmation>();\\n\\nNote\\n\\nFor service invocation calls using HTTP, it\\u2019s wo\", \"rth considering using the Dapr HttpClient integration\\npresented in the previous section. Using HttpC\", \"lient gives you additional benefits such as integration\\nwith existing frameworks and libraries.\\n\\nInv\", \"oke gRPC services using DaprClient\\n\\nDaprClient provides a family of InvokeMethodGrpcAsync methods fo\", \"r calling gRPC endpoints. The\\nmain difference with the HTTP methods is the use of a Protobuf seriali\", \"zer instead of JSON. The\\nfollowing example invokes the submitOrder method of the orderservice over g\", \"RPC.\\n\\nvar daprClient = new DaprClientBuilder().Build();\\ntry\\n{\\n    var confirmation = await daprClien\", \"t.InvokeMethodGrpcAsync<Order,\\nOrderConfirmation>(\\\"orderservice\\\", \\\"submitOrder\\\", order);\\n}\\ncatch (In\", \"vocationException ex)\\n{\\n    // Handle error\\n}\\n\\nIn the example above, DaprClient serializes the given\", \" order object using Protobuf and uses the result\\nas the gRPC request body. Likewise, the response bo\", \"dy is Protobuf deserialized and returned to the\\ncaller. Protobuf typically provides better performan\", \"ce than the JSON payloads used in HTTP service\\ninvocation.\\n\\nName resolution components\\n\\nAt the time \", \"of writing, Dapr provides support for the following name resolution components:\\n\\n\\u2022  mDNS (default wh\", \"en running self-hosted)\\n\\n\\u2022\\n\\n\\u2022\\n\\nKubernetes Name Resolution (default when running in Kubernetes)\\n\\nHash\", \"iCorp Consul\\n\\nConfiguration\\n\\nTo use a non-default name resolution component, add a nameResolution sp\", \"ec to the application\\u2019s\\nDapr configuration file. Here\\u2019s an example of a Dapr configuration file that\", \" enables HashiCorp Consul\\nname resolution:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Configuration\\nmetadat\", \"a:\\n\\n58\\n\\nCHAPTER 7 | The Dapr service invocation building block\\n\\n\\f  name: dapr-config\\nspec:\\n  nameRes\", \"olution:\\n    component: \\\"consul\\\"\\n    configuration:\\n      selfRegister: true\\n\\nSample application: Da\", \"pr Traffic Control\\n\\nIn Dapr Traffic Control sample app, the FineCollection service uses the Dapr ser\", \"vice invocation\\nbuilding block to retrieve vehicle and owner information from the VehicleRegistratio\", \"n service. Figure\\n6-2 shows the conceptual architecture of the Dapr Traffic Control sample applicati\", \"on. The Dapr service\\ninvocation building block is used in flows marked with number 1 in the diagram:\", \"\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/service-invocation/dapr-solution-service-invocation.png\\u201d\\na\", \"lt-text=\\u201cConceptual architecture of the Dapr Traffic Control sample application.\\u201d:::\\n\\nFigure 6-2. Co\", \"nceptual architecture of the Dapr Traffic Control sample application.\\n\\nInformation is retrieved by t\", \"he ASP.NET CollectionController class in the FineCollection service.\\nThe CollectFine method expects \", \"an incoming SpeedingViolation parameter. It invokes a Dapr\\nservice invocation building block to call\", \" to the VehicleRegistration service. The code snippet is\\npresented below.\\n\\n:::{custom-style=CodeBox}\", \" ```csharp [Topic(\\u201cpubsub\\u201d, \\u201cspeedingviolations\\u201d)] [Route(\\u201ccollectfine\\u201d)]\\n[HttpPost] public async Ta\", \"sk CollectFine(SpeedingViolation speedingViolation, [FromServices]\\nDaprClient daprClient) { // \\u2026\\n\\n//\", \" get owner info (Dapr service invocation)\\nvar vehicleInfo =\\n_vehicleRegistrationService.GetVehicleIn\", \"fo(speedingViolation.VehicleId).Result;\\n\\n// ...\\n\\n} ``` :::\\n\\nThe code uses a proxy of type VehicleReg\", \"istrationService to call the VehicleRegistration service.\\nASP.NET Core injects an instance of the se\", \"rvice proxy using constructor injection:\\n\\n:::{custom-style=CodeBox} csharp  public CollectionControl\", \"ler(      ILogger<CollectionController>\\nlogger,      IFineCalculator fineCalculator,      VehicleReg\", \"istrationService vehicleRegistrationService,\\nDaprClient daprClient)  {      // ...  } :::\\n\\nThe Vehic\", \"leRegistrationService class contains a single method: GetVehicleInfo. It uses the\\nASP.NET Core HttpC\", \"lient to call the VehicleRegistration service:\\n\\n:::{custom-style=CodeBox} ```csharp public class Veh\", \"icleRegistrationService { private HttpClient\\n_httpClient; public VehicleRegistrationService(HttpClie\", \"nt httpClient) { _httpClient = httpClient; }\\n\\n public async Task<VehicleInfo> GetVehicleInfo(string \", \"licenseNumber)\\n {\\n     return await _httpClient.GetFromJsonAsync<VehicleInfo>(\\n\\n59\\n\\nCHAPTER 7 | The \", \"Dapr service invocation building block\\n\\n\\f         $\\\"vehicleinfo/{licenseNumber}\\\");\\n }\\n\\n} ``` :::\\n\\nTh\", \"e code doesn\\u2019t depend on any Dapr classes directly. It instead leverages the Dapr ASP.NET Core\\ninteg\", \"ration as described in the Invoke HTTP services using HttpClient section of this module. The\\nfollowi\", \"ng code in the ConfigureService method of the Startup class registers the\\nVehicleRegistrationService\", \" proxy:\\n\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder.Services.AddSingleton<VehicleRegi\", \"strationService>(_ =>\\n    new VehicleRegistrationService(DaprClient.CreateInvokeHttpClient(\\n        \", \"\\\"vehicleregistrationservice\\\", $\\\"http://localhost:{daprHttpPort}\\\"\\n    )));\\n\\nThe DaprClient.CreateInvo\", \"keHttpClient creates an HttpClient instance that calls the\\nVehicleRegistration service using the ser\", \"vice invocation building block under the covers. It expects\\nboth the Dapr app-id of the target servi\", \"ce and the URL of its Dapr sidecar. At start time, the\\ndaprHttpPort argument contains the port numbe\", \"r used for HTTP communication with the Dapr\\nsidecar.\\n\\nUsing Dapr service invocation in the Traffic C\", \"ontrol sample application provides several benefits:\\n\\n1.  Decouples the location of the target servi\", \"ce.\\n\\n2.\\n\\n3.\\n\\nAdds resiliency with automatic retry features.\\n\\nAbility to reuse an existing HttpClient\", \" based proxy (offered by the ASP.NET Core integration).\\n\\nSummary\\n\\nIn this chapter, you learned about\", \" the service invocation building block. You saw how to invoke\\nremote methods both by making direct H\", \"TTP calls to the Dapr sidecar, and by using the Dapr .NET\\nSDK.\\n\\nThe Dapr .NET SDK provides multiple \", \"ways to invoke remote methods. HttpClient support is great for\\ndevelopers wanting to reuse existing \", \"skills and is compatible with many existing frameworks and\\nlibraries. DaprClient offers support for \", \"directly using the Dapr service invocation API using either HTTP\\nor gRPC semantics.\\n\\nReferences\\n\\n\\u2022\\n\\n\", \"Dapr service invocation building block\\n\\n\\u2022  Monitoring distributed cloud-native applications\\n\\n60\\n\\nCHA\", \"PTER 7 | The Dapr service invocation building block\\n\\n\\fCHAPTER  8\\n\\nThe Dapr publish &\\nsubscribe build\", \"ing block\\n\\nThe Publish-Subscribe pattern (often referred to as \\u201cpub/sub\\u201d) is a well-known and widely\", \" used\\nmessaging pattern. Architects commonly embrace it in distributed applications. However, the\\npl\", \"umbing to implement it can be complex. There are often subtle feature differences across different\\nm\", \"essaging products. Dapr offers a building block that significantly simplifies implementing pub/sub\\nf\", \"unctionality.\\n\\nWhat it solves\\n\\nThe primary advantage of the Publish-Subscribe pattern is loose coupl\", \"ing, sometimes referred to as\\ntemporal decoupling. The pattern decouples services that send messages\", \" (the publishers) from\\nservices that consume messages (the subscribers). Both publishers and subscri\", \"bers are unaware of\\neach other - both are dependent on a centralized message broker that distributes\", \" the messages.\\n\\nFigure 7-1 shows the high-level architecture of the pub/sub pattern.\\n\\nFigure 7-1. Th\", \"e pub/sub pattern.\\n\\nFrom the previous figure, note the steps of the pattern:\\n\\n1.\\n\\n2.\\n\\n61\\n\\nPublishers\", \" send messages to the message broker.\\n\\nSubscribers bind to a subscription on the message broker.\\n\\nCH\", \"APTER 8 | The Dapr publish & subscribe building block\\n\\n\\f3.\\n\\n4.\\n\\nThe message broker forwards a copy o\", \"f the message to interested subscriptions.\\n\\nSubscribers consume messages from their subscriptions.\\n\\n\", \"Most message brokers encapsulate a queueing mechanism that can persist messages once received.\\nWith \", \"it, the message broker guarantees durability by storing the message. Subscribers don\\u2019t need to\\nbe im\", \"mediately available or even online when a publisher sends a message. Once available, the\\nsubscriber \", \"receives and processes the message. Dapr guarantees At-Least-Once semantics for\\nmessage delivery. On\", \"ce a message is published, it will be delivered at least once to any interested\\nsubscriber.\\n\\nTip\\n\\nIf\", \" your service can only process a message once, you\\u2019ll need to provide an idempotency check to\\nensure\", \" that the same message is not processed multiple times. While such logic can be coded, some\\nmessage \", \"brokers, such as Azure Service Bus, provide built-in duplicate detection messaging\\ncapabilities.\\n\\nTh\", \"ere are several message broker products available - both commercially and open-source. Each has\\nadva\", \"ntages and drawbacks. Your job is to match your system requirements to the appropriate broker.\\nOnce \", \"selected, it\\u2019s a best practice to decouple your application from message broker plumbing. You\\nachiev\", \"e this functionality by wrapping the broker inside an abstraction. The abstraction encapsulates\\nthe \", \"message plumbing and exposes generic pub/sub operations to your code. Your code\\ncommunicates with th\", \"e abstraction, not the actual message broker. While a wise decision, you\\u2019ll have\\nto write and mainta\", \"in the abstraction and its underlying implementation. This approach requires\\ncustom code that can be\", \" complex, repetitive, and error-prone.\\n\\nThe Dapr publish & subscribe building block provides the mes\", \"saging abstraction and implementation\\nout-of-the-box. The custom code you would have had to write is\", \" prebuilt and encapsulated inside the\\nDapr building block. You bind to it and consume it. Instead of\", \" writing messaging plumbing code, you\\nand your team focus on creating business functionality that ad\", \"ds value to your customers.\\n\\nHow it works\\n\\nThe Dapr publish & subscribe building block provides a pl\", \"atform-agnostic API framework to send and\\nreceive messages. Your services publish messages to a name\", \"d topic. Your services subscribe to a topic\\nto consume messages.\\n\\nThe service calls the pub/sub API \", \"on the Dapr sidecar. The sidecar then makes calls into a pre-defined\\nDapr pub/sub component that enc\", \"apsulates a specific message broker product. Figure 7-2 shows the\\nDapr pub/sub messaging stack.\\n\\n62\\n\", \"\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\n\\fFigure 7-2. The Dapr pub/sub stack.\\n\\nThe \", \"Dapr publish & subscribe building block can be invoked in many ways.\\n\\nAt the lowest level, any progr\", \"amming platform can invoke the building block over HTTP or gRPC\\nusing the Dapr native API. To publis\", \"h a message, you make the following API call:\\n\\nhttp://localhost:<dapr-port>/v1.0/publish/<pub-sub-na\", \"me>/<topic>\\n\\nThere are several Dapr specific URL segments in the above call:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n<dapr-port> p\", \"rovides the port number upon which the Dapr sidecar is listening.\\n\\n<pub-sub-name> provides the name \", \"of the selected Dapr pub/sub component.\\n\\n<topic> provides the name of the topic to which the message\", \" is published.\\n\\nUsing the curl command-line tool to publish a message, you can try it out:\\n\\ncurl -X \", \"POST http://localhost:3500/v1.0/publish/pubsub/newOrder \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  \", \"-d '{ \\\"orderId\\\": \\\"1234\\\", \\\"productId\\\": \\\"5678\\\", \\\"amount\\\": 2 }'\\n\\nYou receive messages by subscribing to\", \" a topic. At startup, the Dapr runtime will call the application\\non a well-known endpoint to identif\", \"y and create the required subscriptions:\\n\\nhttp://localhost:<appPort>/dapr/subscribe\\n\\n63\\n\\nCHAPTER 8 |\", \" The Dapr publish & subscribe building block\\n\\n\\f\\u2022\\n\\n<appPort> informs the Dapr sidecar of the port upo\", \"n which the application is listening.\\n\\nYou can implement this endpoint yourself. But Dapr provides m\", \"ore intuitive ways of implementing it.\\nWe\\u2019ll address this functionality later in this chapter.\\n\\nThe \", \"response from the call contains a list of topics to which the applications will subscribe. Each\\nincl\", \"udes an endpoint to call when the topic receives a message. Here\\u2019s an example of a response:\\n\\n[\\n  {\\n\", \"    \\\"pubsubname\\\": \\\"pubsub\\\",\\n    \\\"topic\\\": \\\"newOrder\\\",\\n    \\\"route\\\": \\\"/orders\\\"\\n  },\\n  {\\n    \\\"pubsubname\", \"\\\": \\\"pubsub\\\",\\n    \\\"topic\\\": \\\"newProduct\\\",\\n    \\\"route\\\": \\\"/productCatalog/products\\\"\\n  }\\n]\\n\\nIn the JSON r\", \"esponse, you can see the application wants to subscribe to topics newOrder and\\nnewProduct. It regist\", \"ers the endpoints /orders and /productCatalog/products for each,\\nrespectively. For both subscription\", \"s, the application is binding to the Dapr component named pubsub.\\n\\nFigure 7-3 presents the flow of t\", \"he example.\\n\\n64\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\n\\fFigure 7-3. Pub/sub flow \", \"with Dapr.\\n\\nFrom the previous figure, note the flow:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\n5.\\n\\n6.\\n\\nThe Dapr sidecar for S\", \"ervice B calls the /dapr/subscribe endpoint from Service B (the\\nconsumer). The service responds with\", \" the subscriptions it wants to create.\\n\\nThe Dapr sidecar for Service B creates the requested subscri\", \"ptions on the message broker.\\n\\nService A publishes a message at the /v1.0/publish/<pub-sub-name>/<to\", \"pic> endpoint on\\nthe Dapr Service A sidecar.\\n\\nThe Service A sidecar publishes the message to the mes\", \"sage broker.\\n\\nThe message broker sends a copy of the message to the Service B sidecar.\\n\\nThe Service \", \"B sidecar calls the endpoint corresponding to the subscription (in this case /orders)\\non Service B. \", \"The service responds with an HTTP status-code 200 OK so the sidecar will consider\\nthe message as bei\", \"ng handled successfully.\\n\\nIn the example, the message is handled successfully. But if something goes\", \" wrong while Service B is\\nhandling the request, it can use the response to specify what needs to hap\", \"pen with the message.\\nWhen it returns an HTTP status-code 404, an error is logged and the message is\", \" dropped. With any\\nother status-code than 200 or 404, a warning is logged and the message is retried\", \". Alternatively,\\n\\n65\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\n\\fService B can explic\", \"itly specify what needs to happen with the message by including a JSON payload\\nin the body of the re\", \"sponse:\\n\\n{\\n  \\\"status\\\": \\\"<status>\\\"\\n}\\n\\nThe following table shows the available status values:\\n\\nStatus\\n\", \"\\nAction\\n\\nSUCCESS\\n\\nThe message is considered as processed successfully and dropped.\\n\\nRETRY\\n\\nDROP\\n\\nThe\", \" message is retried.\\n\\nA warning is logged and the message is dropped.\\n\\nAny other status  The message\", \" is retried.\\n\\nCompeting consumers\\n\\nWhen scaling out an application that subscribes to a topic, you h\", \"ave to deal with competing\\nconsumers. Only one application instance should handle a message sent to \", \"the topic. Luckily, Dapr\\nhandles that problem. When multiple instances of a service with the same ap\", \"plication-id subscribe to\\na topic, Dapr delivers each message to only one of them.\\n\\nUse the Dapr .NE\", \"T SDK\\n\\nFor .NET Developers, the Dapr .NET SDK provides a more productive way of working with Dapr. T\", \"he\\nSDK exposes a DaprClient class through which you can directly invoke Dapr functionality. It\\u2019s int\", \"uitive\\nand easy to use.\\n\\nTo publish a message, the DaprClient exposes a PublishEventAsync method.\\n\\nv\", \"ar data = new OrderData\\n{\\n  orderId = \\\"123456\\\",\\n  productId = \\\"67890\\\",\\n  amount = 2\\n};\\n\\nvar daprClie\", \"nt = new DaprClientBuilder().Build();\\n\\nawait daprClient.PublishEventAsync<OrderData>(\\\"pubsub\\\", \\\"newO\", \"rder\\\", data);\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n66\\n\\nThe first argument pubsub is the name of the Dapr component that prov\", \"ides the message broker\\nimplementation. We\\u2019ll address components later in this chapter.\\n\\nThe second \", \"argument neworder provides the name of the topic to send the message to.\\n\\nThe third argument is the \", \"payload of the message.\\n\\nYou can specify the .NET type of the message using the generic type paramet\", \"er of the method.\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\n\\fTo receive messages, yo\", \"u bind an endpoint to a subscription for a registered topic. The AspNetCore\\nlibrary for Dapr makes t\", \"his trivial. Assume, for example, that you have an existing ASP.NET WebAPI\\naction method entitled Cr\", \"eateOrder:\\n\\n[HttpPost(\\\"/orders\\\")]\\npublic async Task<ActionResult> CreateOrder(Order order)\\n\\nImportan\", \"t\\n\\nYou must add a reference to the Dapr.AspNetCore NuGet package in your project to consume the\\nDapr\", \" ASP.NET Core integration.\\n\\nTo bind this action method to a topic, you decorate it with the Topic at\", \"tribute:\\n\\n[Topic(\\\"pubsub\\\", \\\"newOrder\\\")]\\n[HttpPost(\\\"/orders\\\")]\\npublic async Task<ActionResult> Create\", \"Order(Order order)\\n\\nYou specify two key elements with this attribute:\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe Dapr pub/sub compon\", \"ent to target (in this case pubsub).\\n\\nThe topic to subscribe to (in this case newOrder).\\n\\nDapr then \", \"invokes that action method as it receives messages for that topic.\\n\\nYou\\u2019ll also need to enable ASP.N\", \"ET Core to use Dapr. The Dapr .NET SDK provides several extension\\nmethods that can be used to do thi\", \"s.\\n\\nIn the Program.cs file, you must call the following extension method on the WebApplication build\", \"er\\nto register Dapr:\\n\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder.Services.AddControll\", \"ers().AddDapr();\\n\\nAppending the AddDapr extension method to the AddControllers extension method regi\", \"sters the\\nnecessary services to integrate Dapr into the MVC pipeline. It also registers a DaprClient\", \" instance\\ninto the dependency injection container, which then can be injected anywhere into your ser\", \"vice.\\n\\nAfter the WebApplication has been created, you must add the following middleware components t\", \"o\\nenable Dapr:\\n\\nvar builder = WebApplication.CreateBuilder(args);\\nvar app = builder.Build();\\napp.Use\", \"CloudEvents();\\napp.MapControllers();\\napp.MapSubscribeHandler();\\n\\nThe call to UseCloudEvents adds Clo\", \"udEvents middleware into to the ASP.NET Core middleware\\npipeline. This middleware will unwrap reques\", \"ts that use the CloudEvents structured format, so the\\nreceiving method can read the event payload di\", \"rectly.\\n\\n67\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\n\\fNote\\n\\nCloudEvents is a standa\", \"rdized messaging format, providing a common way to describe event\\ninformation across platforms. Dapr\", \" embraces CloudEvents. For more information about CloudEvents,\\nsee the cloudevents specification.\\n\\nT\", \"he call to MapSubscribeHandler in the endpoint routing configuration will add a Dapr subscribe\\nendpo\", \"int to the application. This endpoint will respond to requests on /dapr/subscribe. When this\\nendpoin\", \"t is called, it will automatically find all WebAPI action methods decorated with the Topic\\nattribute\", \" and instruct Dapr to create subscriptions for them.\\n\\nPub/sub components\\n\\nDapr pub/sub components ha\", \"ndle the actual transport of the messages. Several are available. Each\\nencapsulates a specific messa\", \"ge broker product to implement the pub/sub functionality. At the time\\nof writing, the following pub/\", \"sub components were available:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nApache Kafka\\n\\nAWS SNS/SQS\\n\\nAzure Event Hubs\\n\", \"\\nAzure Service Bus\\n\\nGCP Pub/Sub\\n\\nHazelcast\\n\\nIn Memory\\n\\nJetStream\\n\\n\\u2022  MQTT\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nNATS Streamin\", \"g\\n\\nPulsar\\n\\nRabbitMQ\\n\\nRedis Streams\\n\\nNote\\n\\nThe Azure cloud stack has both messaging functionality (Az\", \"ure Service Bus) and event streaming\\n(Azure Event Hub) availability.\\n\\nThese components are created b\", \"y the community in a component-contrib repository on GitHub.\\nYou\\u2019re encouraged to write your own Dap\", \"r component for a message broker that isn\\u2019t yet supported.\\n\\nConfiguration\\n\\nUsing a Dapr configuratio\", \"n file, you can specify the pub/sub component(s) to use. This configuration\\ncontains several fields.\", \" The name field specifies the pub/sub component that you want to use. When\\nsending or receiving a me\", \"ssage, you need to specify this name (as you saw earlier in the\\nPublishEventAsync method signature).\", \"\\n\\n68\\n\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\n\\fBelow you see an example of a Dapr c\", \"onfiguration file for configuring a RabbitMQ message broker\\ncomponent:\\n\\napiVersion: dapr.io/v1alpha1\", \"\\nkind: Component\\nmetadata:\\n  name: pubsub-rq\\nspec:\\n  type: pubsub.rabbitmq\\n  version: v1\\n  metadata:\", \"\\n  - name: host\\n    value: \\\"amqp://localhost:5672\\\"\\n  - name: durable\\n    value: true\\n\\nIn this exampl\", \"e, you can see that you can specify any message broker-specific configuration in the\\nmetadata block.\", \" In this case, RabbitMQ is configured to create durable queues. But the RabbitMQ\\ncomponent has more \", \"configuration options. Each of the components\\u2019 configuration will have its own\\nset of possible field\", \"s. You can read which fields are available in the documentation of each pub/sub\\ncomponent.\\n\\nNext to \", \"the programmatic way of subscribing to a topic from code, Dapr pub/sub also provides a\\ndeclarative w\", \"ay of subscribing to a topic. This approach removes the Dapr dependency from the\\napplication code. T\", \"herefore, it also enables an existing application to subscribe to topics without any\\nchanges to the \", \"code. The following example shows a Dapr configuration file for configuring a\\nsubscription:\\n\\napiVers\", \"ion: dapr.io/v1alpha1\\nkind: Subscription\\nmetadata:\\n  name: newOrder-subscription\\nspec:\\n  pubsubname:\", \" pubsub\\n  topic: newOrder\\n  route: /orders\\nscopes:\\n- ServiceB\\n- ServiceC\\n\\nYou have to specify severa\", \"l elements with every subscription:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe name of the Dapr pub/sub component you want to \", \"use (in this case pubsub).\\n\\nThe name of the topic to subscribe to (in this case newOrder).\\n\\nThe API \", \"operation that needs to be called for this topic (in this case /orders).\\n\\nThe scope can specify whic\", \"h services can publish and subscribe to a topic.\\n\\nSample application: Dapr Traffic Control\\n\\nIn Dapr \", \"Traffic Control sample app, the TrafficControl service uses the Dapr pub/sub building block to\\nsend \", \"speeding violations to the FineCollection service. Figure 7-4 shows the conceptual architecture\\n\\n69\\n\", \"\\nCHAPTER 8 | The Dapr publish & subscribe building block\\n\\n\\fof the Dapr Traffic Control sample applic\", \"ation. The Dapr pub/sub building block is used in flows\\nmarked with number 2 in the diagram:\\n\\n:::ima\", \"ge type=\\u201ccontent\\u201d source=\\u201c./media/publish-subscribe/dapr-solution-pub-sub.png\\u201d alt-\\ntext=\\u201cConceptual\", \" architecture of the Dapr Traffic Control sample application.\\u201d:::\\n\\nFigure 7-4. Conceptual architectu\", \"re of the Dapr Traffic Control sample application.\\n\\nSpeeding violations are handled by the Collectio\", \"nController, an ordinary ASP.NET Core Controller.\\nThe CollectionController.CollectFine method subscr\", \"ibes to and handles SpeedingViolation\\nevent messages:\\n\\n[Topic(\\\"pubsub\\\", \\\"speedingviolations\\\")]\\n[Rout\", \"e(\\\"collectfine\\\")]\\n[HttpPost]\\npublic async Task<ActionResult> CollectFine(\\n    SpeedingViolation spee\", \"dingViolation, [FromServices] DaprClient daprClient)\\n{\\n    // ...\\n}\\n\\nThe method is decorated with th\", \"e Dapr Topic attribute. It specifies that the pub/sub component\\nnamed pubsub should be used to subsc\", \"ribe to messages sent to the speedingviolations topic.\\n\\nThe TrafficControl service sends speeding vi\", \"olations. Near the end of the VehicleExit method in the\\nTrafficController class, the DaprClient obje\", \"ct is used to publish SpeedingViolation messages\\nusing the pub/sub building block:\\n\\n/// ...\\n\\nvar spe\", \"edingViolation = new SpeedingViolation\\n{\\n    VehicleId = msg.LicenseNumber,\\n    RoadId = _roadId,\\n  \", \"  ViolationInKmh = violation,\\n    Timestamp = msg.Timestamp\\n};\\n\\n// publish speedingviolation (Dapr p\", \"ublish / subscribe)\\nawait daprClient.PublishEventAsync(\\\"pubsub\\\", \\\"speedingviolations\\\", speedingViola\", \"tion);\\n\\n/// ...\\n\\nNote how the DaprClient object reduces the call to a single line of code, again, bi\", \"nding to the\\nspeedingviolations topic and the Dapr pubsub component.\\n\\nWhile the Traffic Control app \", \"uses RabbitMQ as the message broker, it never directly references\\nRabbitMQ. Instead, the accompanyin\", \"g Dapr component configuration file named pubsub.yaml in the\\n/dapr/components folder specifies the m\", \"essage broker:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: pubsub\\n  namespace: d\", \"apr-trafficcontrol\\nspec:\\n  type: pubsub.rabbitmq\\n\\n70\\n\\nCHAPTER 8 | The Dapr publish & subscribe build\", \"ing block\\n\\n\\f  version: v1\\n  metadata:\\n  - name: host\\n    value: \\\"amqp://localhost:5672\\\"\\n  - name: du\", \"rable\\n    value: \\\"false\\\"\\n  - name: deletedWhenUnused\\n    value: \\\"false\\\"\\n  - name: autoAck\\n    value:\", \" \\\"false\\\"\\n  - name: reconnectWait\\n    value: \\\"0\\\"\\n  - name: concurrency\\n    value: parallel\\nscopes:\\n  \", \"- trafficcontrolservice\\n  - finecollectionservice\\n\\nThe type element in the configuration, pubsub.rab\", \"bitmq instructs the building block to use the Dapr\\nRabbitMQ component.\\n\\nThe scopes element in the co\", \"nfiguration constrains application access to the RabbitMQ component.\\nOnly the TrafficControl and Fin\", \"eCollection services can consume it.\\n\\nUsing Dapr pub/sub in the Traffic Control sample application o\", \"ffers the following benefits:\\n\\n1.  No infrastructural abstraction of a message broker to maintain.\\n\\n\", \"2.\\n\\n3.\\n\\nServices are temporally decoupled, which increases robustness.\\n\\nPublisher and subscribers ar\", \"e unaware of each other. This means that additional services could\\nbe introduced that will react to \", \"speeding violations in the future, without the need to change the\\nTrafficControl service.\\n\\nSummary\\n\\n\", \"The pub/sub pattern helps you decouple services in a distributed application. The Dapr publish &\\nsub\", \"scribe building block simplifies implementing this behavior in your application.\\n\\nThrough Dapr pub/s\", \"ub, you can publish messages to a specific topic. As well, the building block will\\nquery your servic\", \"e to determine which topic(s) to subscribe to.\\n\\nYou can use Dapr pub/sub natively over HTTP or by us\", \"ing one of the language-specific SDKs, such as\\nthe .NET SDK for Dapr. The .NET SDK tightly integrate\", \"s with the ASP.NET core platform.\\n\\nWith Dapr, you can plug a supported message broker product into y\", \"our application. You can then\\nswap message brokers without requiring code changes to your applicatio\", \"n.\\n\\nReferences\\n\\n\\u2022\\n\\nDapr supported pub/sub brokers\\n\\n71\\n\\nCHAPTER 8 | The Dapr publish & subscribe buil\", \"ding block\\n\\n\\fCHAPTER  9\\n\\nThe Dapr bindings\\nbuilding block\\n\\nCloud-based serverless offerings, such as\", \" Azure Functions and AWS Lambda, have gained wide\\nadoption across the distributed architecture space\", \". Among many benefits, they enable a microservice\\nto handle events from or invoke events in an exter\", \"nal system - abstracting away the underlying\\ncomplexity and plumbing concerns. External resources ar\", \"e many: They include datastores, message\\nsystems, and web resources, across different platforms and \", \"vendors. The Dapr bindings building block\\nbrings these same resource binding capabilities to the doo\", \"rstep of your Dapr applications.\\n\\nWhat it solves\\n\\nDapr resource bindings enable your services to int\", \"egrate business operations across external\\nresources outside of the immediate application. An event \", \"from an external system could trigger an\\noperation in your service passing in contextual information\", \". Your service could then expand the\\noperation by triggering an event in another external system, pa\", \"ssing in contextual payload\\ninformation. Your service communicates without coupling or awareness of \", \"the external resource. The\\nplumbing is encapsulated inside pre-defined Dapr components. The Dapr com\", \"ponent to use can be\\neasily swapped at run time without code changes.\\n\\nConsider, for example, a Twit\", \"ter account that triggers an event whenever a user tweets a keyword.\\nYour service exposes an event h\", \"andler that receives and processes the tweet. Once complete, your\\nservice triggers an event that inv\", \"okes an external Twilio service. Twilio sends an SMS message that\\nincludes the tweet. Figure 8-1 sho\", \"w the conceptual architecture of this operation:\\n\\nFigure 8-1. Conceptual architecture of a Dapr reso\", \"urce binding.\\n\\nAt first glance, resource binding behavior may appear similar to the Publish/Subscrib\", \"e pattern\\ndescribed earlier in this book. While they share similarities, there are differences. Publ\", \"ish/subscribe\\n\\n72\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\n\\ffocuses on asynchronous communicat\", \"ion between Dapr services. Resource binding has a much wider\\nscope. It focuses on system interoperab\", \"ility across software platforms. Exchanging information\\nbetween disparate applications, datastores, \", \"and services outside your microservice application.\\n\\nHow it works\\n\\nDapr resource binding starts with\", \" a component configuration file. This YAML file describes the type of\\nresource to which you\\u2019ll bind \", \"along with its configuration settings. Once configured, your service can\\nreceive events from the res\", \"ource or trigger events on it.\\n\\nNote\\n\\nBinding configurations are presented in detail later in the Co\", \"mponents section.\\n\\nInput bindings\\n\\nInput bindings trigger your code with incoming events from extern\", \"al resources. To receive events and\\ndata, you register a public endpoint from your service that beco\", \"mes the event handler. Figure 8-2\\nshows the flow:\\n\\nFigure 8-2. Dapr input binding flow.\\n\\nFigure 8.2 \", \"describes the steps for receiving events from an external Twitter account:\\n\\n73\\n\\nCHAPTER 9 | The Dapr\", \" bindings building block\\n\\n\\f1.\\n\\nThe Dapr sidecar reads the binding configuration file and subscribes \", \"to the event specified for\\nthe external resource. In the example, the event source is a Twitter acco\", \"unt.\\n\\n2.  When a matching Tweet is published on Twitter, the binding component running in the Dapr\\n\\n\", \"sidecar picks it up and triggers an event.\\n\\n3.\\n\\nThe Dapr sidecar invokes the endpoint (that is, even\", \"t handler) configured for the binding. In the\\nexample, the service listens for an HTTP POST on the /\", \"tweet endpoint on port 6000. Because it\\u2019s\\nan HTTP POST operation, the JSON payload for the event is \", \"passed in the request body.\\n\\n4.\\n\\nAfter handling the event, the service returns an HTTP status code 2\", \"00 OK.\\n\\nThe following ASP.NET Core controller provides an example of handling an event triggered by \", \"the\\nTwitter binding:\\n\\n[ApiController]\\npublic class SomeController : ControllerBase\\n{\\n    public clas\", \"s TwitterTweet\\n    {\\n        [JsonPropertyName(\\\"id_str\\\")]\\n        public string ID {get; set; }\\n\\n   \", \"     [JsonPropertyName(\\\"text\\\")]\\n        public string Text {get; set; }\\n    }\\n\\n    [HttpPost(\\\"/tweet\", \"\\\")]\\n    public ActionResult Post(TwitterTweet tweet)\\n    {\\n        // Handle tweet\\n        Console.W\", \"riteLine(\\\"Tweet received: {0}: {1}\\\", tweet.ID, tweet.Text);\\n\\n        // ...\\n\\n        // Acknowledge \", \"message\\n        return Ok();\\n    }\\n}\\n\\nIf the operation should error, you would return the appropriat\", \"e 400 or 500 level HTTP status code. For\\nbindings that feature at-least-once delivery guarantees, th\", \"e Dapr sidecar will retry the trigger. Check\\nout Dapr documentation for resource bindings to see whe\", \"ther they offer at-least-once or exactly-once\\ndelivery guarantees.\\n\\nOutput bindings\\n\\nDapr also inclu\", \"des output binding capabilities. They enable your service to trigger an event that\\ninvokes an extern\", \"al resource. Again, you start by configuring a binding configuration YAML file that\\ndescribes the ou\", \"tput binding. Once in place, you trigger an event that invokes the bindings API on the\\nDapr sidecar \", \"of your application. Figure 8-3 shows the flow of an output binding:\\n\\n74\\n\\nCHAPTER 9 | The Dapr bindi\", \"ngs building block\\n\\n\\fFigure 8-3. Dapr output binding flow.\\n\\n1.\\n\\n2.\\n\\n3.\\n\\nThe Dapr sidecar reads the b\", \"inding configuration file with the information on how to connect to\\nthe external resource. In the ex\", \"ample, the external resource is a Twilio SMS account.\\n\\nYour application invokes the /v1.0/bindings/s\", \"ms endpoint on the Dapr sidecar. In this case, it\\nuses an HTTP POST to invoke the API. It\\u2019s also pos\", \"sible to use gRPC.\\n\\nThe binding component running in the Dapr sidecar calls the external messaging s\", \"ystem to send\\nthe message. The message will contain the payload passed in the POST request.\\n\\nAs an e\", \"xample, you can invoke an output binding by invoking the Dapr API using curl:\\n\\ncurl -X POST http://l\", \"ocalhost:3500/v1.0/bindings/sms \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  -d '{\\n        \\\"data\\\": \\\"W\", \"elcome to this awesome service\\\",\\n        \\\"metadata\\\": {\\n          \\\"toNumber\\\": \\\"555-3277\\\"\\n        },\\n \", \"       \\\"operation\\\": \\\"create\\\"\\n      }'\\n\\nNote that the HTTP port is the same as used by the Dapr sidec\", \"ar (in this case, the default Dapr HTTP\\nport 3500).\\n\\nThe structure of the payload (that is, message \", \"sent) will vary per binding. In the example above, the\\npayload contains a data element with a messag\", \"e. Bindings to other types of external resources can be\\ndifferent, especially for the metadata that \", \"is sent. Each payload must also contain an operation field,\\n\\n75\\n\\nCHAPTER 9 | The Dapr bindings build\", \"ing block\\n\\n\\fthat defines the operation the binding will execute. The above example specifies a creat\", \"e operation\\nthat creates the SMS message. Common operations include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\ncreate\\n\\nget\\n\\ndelet\", \"e\\n\\nlist\\n\\nIt\\u2019s up to the author of the binding which operations the binding supports. The documentati\", \"on for\\neach binding describes the available operations and how to invoke them.\\n\\nUse the Dapr .NET SD\", \"K\\n\\nThe Dapr .NET SDK provides language-specific support for .NET developers. In the following exampl\", \"e,\\nthe call to the HttpClient.PostAsync() is replaced with the DaprClient.InvokeBindingAsync()\\nmetho\", \"d. This specialized method simplifies invoking a configured output binding:\\n\\nprivate async Task Send\", \"SMSAsync([FromServices] DaprClient daprClient)\\n{\\n    var message = \\\"Welcome to this awesome service\\\"\", \";\\n    var metadata = new Dictionary<string, string>\\n    {\\n      { \\\"toNumber\\\", \\\"555-3277\\\" }\\n    };\\n  \", \"  await daprClient.InvokeBindingAsync(\\\"sms\\\", \\\"create\\\", message, metadata);\\n}\\n\\nThe method expects the\", \" metadata and message values.\\n\\nWhen used to invoke a binding, the DaprClient uses gRPC to call the D\", \"apr API on the Dapr sidecar.\\n\\nBinding components\\n\\nUnder the hood, resource bindings are implemented \", \"with Dapr binding components. They\\u2019re\\ncontributed by the community and written in Go. If you need to\", \" integrate with an external resource\\nfor which no Dapr binding exists yet, you can create it yoursel\", \"f. Check out the Dapr components-\\ncontrib repo to see how you can contribute a binding.\\n\\nNote\\n\\nDapr \", \"and all of its components are written in the Golang (Go) language. Go is considered a modern,\\ncloud-\", \"native programming platform.\\n\\nYou configure bindings using a YAML configuration file. Here\\u2019s an exam\", \"ple configuration for the\\nTwitter binding:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n \", \" name: twitter-mention\\n\\n76\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\n\\f  namespace: default\\nspec\", \":\\n  type: bindings.twitter\\n  version: v1\\n  metadata:\\n  - name: consumerKey\\n    value: \\\"****\\\" # twitt\", \"er api consumer key, required\\n  - name: consumerSecret\\n    value: \\\"****\\\" # twitter api consumer secr\", \"et, required\\n  - name: accessToken\\n    value: \\\"****\\\" # twitter api access token, required\\n  - name: \", \"accessSecret\\n    value: \\\"****\\\" # twitter api access secret, required\\n  - name: query\\n    value: \\\"dap\", \"r\\\" # your search query, required\\n\\nEach binding configuration contains a general metadata element wit\", \"h a name and namespace field.\\nDapr will determine the endpoint to invoke your service based upon the\", \" configured name field. In the\\nabove example, Dapr will invoke the method annotated with /twitter-me\", \"ntion in your service when\\nan event occurs.\\n\\nIn the spec element, you specify the type of the bindin\", \"g along with binding specific metadata. The\\nexample specifies credentials for accessing a Twitter ac\", \"count using its API. The metadata can differ\\nbetween input and output bindings. For example, to use \", \"Twitter as an input binding, you need to\\nspecify the text to search for in tweets using the query fi\", \"eld. Every time a matching tweet is sent, the\\nDapr sidecar will invoke the /twitter-mention endpoint\", \" on the service. It will also deliver the\\ncontents of the tweet.\\n\\nA binding can be configured for in\", \"put, output, or both. Interestingly, the binding doesn\\u2019t explicitly\\nspecify input or output configur\", \"ation. Instead, the direction is inferred by the usage of the binding\\nalong with configuration value\", \"s.\\n\\nThe Dapr documentation for resource bindings provides a complete list of the available bindings \", \"and\\ntheir specific configuration settings.\\n\\nCron binding\\n\\nPay close attention to Dapr\\u2019s Cron binding\", \". It doesn\\u2019t subscribe to events from an external system.\\nInstead, this binding uses a configurable \", \"interval schedule to trigger your application. The binding\\nprovides a simple way to implement a back\", \"ground worker to wake up and do some work at a regular\\ninterval, without the need to implement an en\", \"dless loop with a configurable delay. Here\\u2019s an example\\nof a Cron binding configuration:\\n\\napiVersion\", \": dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: checkOrderBacklog\\n  namespace: default\\nspec:\\n  \", \"type: bindings.cron\\n  version: v1\\n  metadata:\\n  - name: schedule\\n    value: \\\"@every 30m\\\"\\n\\n77\\n\\nCHAPTE\", \"R 9 | The Dapr bindings building block\\n\\n\\fIn this example, Dapr triggers a service by invoking the /c\", \"heckOrderBacklog endpoint every 30\\nminutes. There are several patterns available for specifying the \", \"schedule value. For more information,\\nsee the Cron binding documentation.\\n\\nSample application: Dapr \", \"Traffic Control\\n\\nIn the Dapr Traffic Control sample application, the TrafficControl service uses the\", \" MQTT input binding\\nto retrieve messages from the CameraSimulation. Figure 8-4 shows the conceptual \", \"architecture of the\\nDapr Traffic Control sample application. The Dapr input binding is used in flows\", \" marked with number\\n5 in the diagram:\\n\\nFigure 8-4. Conceptual architecture of the Dapr Traffic Contr\", \"ol sample application.\\n\\n78\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\n\\fMQTT input binding\\n\\nMQTT \", \"is a lightweight pub/sub messaging protocol, often used in IoT scenarios. Producers sent MQTT\\nmessag\", \"es to a topic; subscribers then retrieve messages from the topic. There are several MQTT\\nmessage bro\", \"ker products available. The Traffic Control sample application uses Eclipse Mosquitto.\\n\\nThe CameraSi\", \"mulation doesn\\u2019t depend on any Dapr building blocks. It uses the System.Net.Mqtt\\nlibrary to send MQT\", \"T messages:\\n\\n// ...\\n\\n// simulate entry\\nDateTime entryTimestamp = DateTime.Now;\\nvar vehicleRegistered\", \" = new VehicleRegistered\\n{\\n    Lane = _camNumber,\\n    LicenseNumber = GenerateRandomLicenseNumber(),\", \"\\n    Timestamp = entryTimestamp\\n};\\n_trafficControlService.SendVehicleEntry(vehicleRegistered);\\n\\n// .\", \"..\\n\\nThe code uses a proxy of type ITrafficControlService to call the TrafficControl service. .NET in\", \"jects\\nan implementation of the ITrafficControlService interface using constructor injection:\\n\\n:::{cu\", \"stom-style=CodeBox} csharp public CameraSimulation(int camNumber, ITrafficControlService\\ntrafficCont\", \"rolService) {     _camNumber = camNumber;     _trafficControlService = trafficControlService;\\n} :::\\n\", \"\\nThe MqttTrafficControlService class implements the ITrafficControlService interface. It\\nexposes two\", \" methods: SendVehicleEntryAsync and SendVehicleExitAsync. They both use the\\nMQTT client to send mess\", \"ages to the trafficcontrol/entrycam and trafficcontrol/exitcam\\ntopics respectively:\\n\\npublic async Ta\", \"sk SendVehicleEntryAsync(VehicleRegistered vehicleRegistered)\\n{\\n    var eventJson = JsonSerializer.S\", \"erialize(vehicleRegistered);\\n    var message = new MqttApplicationMessage(\\\"trafficcontrol/entrycam\\\",\", \"\\nEncoding.UTF8.GetBytes(eventJson));\\n    await _client.PublishAsync(message, MqttQualityOfService.At\", \"MostOnce);\\n}\\n\\npublic async Task SendVehicleExitAsync(VehicleRegistered vehicleRegistered)\\n{\\n    var \", \"eventJson = JsonSerializer.Serialize(vehicleRegistered);\\n    var message = new MqttApplicationMessag\", \"e(\\\"trafficcontrol/exitcam\\\",\\nEncoding.UTF8.GetBytes(eventJson));\\n    await _client.PublishAsync(messa\", \"ge, MqttQualityOfService.AtMostOnce);\\n}\\n\\nThe constructor sets up the MQTT client to send messages to\", \" the MQTT broker (Mosquitto) running\\non port 1883.\\n\\nOn the other end, the TrafficControl service use\", \"s the MQTT input binding to receive\\nVehicleRegistered messages sent by the CameraSimulation. For eac\", \"h subscribed topic, there\\u2019s a\\n\\n79\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\n\\fseparate component\", \" configuration file in the /dapr/components folder. The first one is\\nentrycam.yaml:\\n\\napiVersion: dap\", \"r.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: entrycam\\n  namespace: dapr-trafficcontrol\\nspec:\\n  ty\", \"pe: bindings.mqtt\\n  version: v1\\n  metadata:\\n  - name: url\\n    value: mqtt://localhost:1883\\n  - name:\", \" topic\\n    value: trafficcontrol/entrycam\\nscopes:\\n  - trafficcontrolservice\\n\\nThe configuration speci\", \"fies the binding type: bindings.mqtt. It also specifies that the broker runs on\\nlocalhost:1883, the \", \"standard port that Mosquitto uses. It also exposes the topic,\\ntrafficcontrol/entrycam. Using scopes,\", \" the config file specifies that only the service with app-id\\ntrafficcontrolservice will have access \", \"to the binding.\\n\\nWhen the TrafficControl service starts, the Dapr sidecar automatically subscribes t\", \"o the\\ntrafficcontrol/entrycam MQTT topic specified in the component configuration. When messages\\narr\", \"ive on the topic, the Dapr sidecar invokes an HTTP endpoint on your service. The sidecar\\ndetermines \", \"the URL of the HTTP endpoint to call by looking at the metadata.name field in the binding\\nconfigurat\", \"ion. In the example above, the endpoint URL is /entrycam. Within the TrafficControl service,\\nno code\", \" needs to be added to support the endpoint:\\n\\n[HttpPost(\\\"entrycam\\\")]\\npublic async Task<ActionResult> \", \"VehicleEntry(VehicleRegistered msg)\\n{\\n    // ...\\n}\\n\\nThe exitcam.yaml component configuration file co\", \"nfigures everything for the exitcam endpoint:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata\", \":\\n  name: exitcam\\n  namespace: dapr-trafficcontrol\\nspec:\\n  type: bindings.mqtt\\n  version: v1\\n  metad\", \"ata:\\n  - name: url\\n    value: mqtt://localhost:1883\\n  - name: topic\\n    value: trafficcontrol/exitca\", \"m\\nscopes:\\n  - trafficcontrolservice\\n\\n80\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\n\\fSMTP output \", \"binding\\n\\nThe FineCollection service uses the Dapr SMTP output binding to send emails. Figure 8-5 sho\", \"ws the\\nconceptual architecture of the Dapr Traffic Control sample application. The Dapr input bindin\", \"g is used\\nin flows marked with number 4 in the diagram:\\n\\nFigure 8-5. Conceptual architecture of the \", \"Dapr Traffic Control sample application.\\n\\nThe CollectFine method on the CollectionController in the \", \"FineCollection service contains code that\\nuses the Dapr client to invoke the output binding:\\n\\n// ...\", \"\\n\\n// send fine by email (Dapr output binding)\\nvar body = EmailUtils.CreateEmailBody(speedingViolatio\", \"n, vehicleInfo, fineString);\\nvar metadata = new Dictionary<string, string>\\n{\\n    [\\\"emailFrom\\\"] = \\\"no\", \"reply@cfca.gov\\\",\\n    [\\\"emailTo\\\"] = vehicleInfo.OwnerEmail,\\n\\n81\\n\\nCHAPTER 9 | The Dapr bindings buildi\", \"ng block\\n\\n\\f    [\\\"subject\\\"] = $\\\"Speeding violation on the {speedingViolation.RoadId}\\\"\\n};\\nawait daprCl\", \"ient.InvokeBindingAsync(\\\"sendmail\\\", \\\"create\\\", body, metadata);\\n\\n// ...\\n\\nThe code uses a simple utili\", \"ty class to create an HTML email body containing the necessary\\ninformation. It also creates a dictio\", \"nary with metadata specific to the SMTP binding. This binding\\ncomponent interprets the metadata when\", \" invoked.\\n\\nThe following arguments are required to invoke the binding:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe name of the \", \"binding component. In this case sendmail.\\n\\nThe operation the binding needs to perform. In this case \", \"create.\\n\\nThe body of the message to send. In this case, the HTML email body.\\n\\nThe metadata for sendi\", \"ng the email.\\n\\nThe Dapr output binding named sendmail is configured in the email.yaml component conf\", \"iguration\\nfile in the /dapr/components folder:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadat\", \"a:\\n  name: sendmail\\n  namespace: dapr-trafficcontrol\\nspec:\\n  type: bindings.smtp\\n  version: v1\\n  met\", \"adata:\\n  - name: host\\n    value: localhost\\n  - name: port\\n    value: 4025\\n  - name: user\\n    secretK\", \"eyRef:\\n      name: smtp.user\\n      key: smtp.user\\n  - name: password\\n    secretKeyRef:\\n      name: s\", \"mtp.password\\n      key: smtp.password\\n  - name: skipTLSVerify\\n    value: true\\nauth:\\n  secretStore: t\", \"rafficcontrol-secrets\\nscopes:\\n  - finecollectionservice\\n\\nThe configuration specifies the binding typ\", \"e: bindings.smtp.\\n\\nThe metadata section contains the information for connecting to the SMTP server. \", \"See the binding\\u2019s\\ndocumentation for specific metadata required for this binding. The username and pa\", \"ssword to\\nconnect to the SMTP server are retrieved from a secrets store. See the Secrets management \", \"building\\nblock chapter for more information on how this works.\\n\\nThe scopes element specifies that on\", \"ly the service with app-id finecollectonservice can access this\\nbinding.\\n\\n82\\n\\nCHAPTER 9 | The Dapr b\", \"indings building block\\n\\n\\fThe Traffic Control sample application uses MailDev. MailDev is a developme\", \"nt SMTP server that\\ndoesn\\u2019t actually send out emails (by default). Instead, it collects emails and p\", \"resents them in an inbox\\nweb application. MailDev is extremely useful for dev/test and demo scenario\", \"s.\\n\\nUsing Dapr bindings in the Traffic Control sample application provides the following benefits:\\n\\n\", \"1.  Using MQTT messaging and SMTP without the need to learn this protocol or a specific MQTT\\n\\nAPI.\\n\\n\", \"2.  Using SMTP to send an email without the need to learn this protocol or a specific SMTP API.\\n\\nSum\", \"mary\\n\\nDapr resource bindings enable you to integrate with different external resources and systems w\", \"ithout\\ntaking dependencies on their libraries or SDKs. These external systems don\\u2019t necessarily have\", \" to be\\nmessaging systems like a service bus or message broker. Bindings also exist for datastores an\", \"d web\\nresources like Twitter or SendGrid.\\n\\nInput bindings (or triggers) react to events occurring in\", \" an external system. They invoke the public\\nHTTP endpoints pre-configured in your application. Dapr \", \"uses the name of the binding in the\\nconfiguration to determine the endpoint to call in your applicat\", \"ion.\\n\\nOutput bindings will send messages to an external system. You trigger an output binding by doi\", \"ng an\\nHTTP POST on the /v1.0/bindings/<binding-name> endpoint on the Dapr sidecar. You can also use\\n\", \"gRPC to invoke the binding. The .NET SDK offers a InvokeBindingAsync method to invoke Dapr\\nbindings \", \"using gRPC.\\n\\nYou implement a binding with a Dapr component. These components are contributed by the\\n\", \"community. Each binding component\\u2019s configuration has metadata that is specific for the external\\nsys\", \"tem it abstracts. Also, the commands it supports and the structure of the payload will differ per\\nbi\", \"nding component.\\n\\nReferences\\n\\n\\u2022\\n\\nDapr documentation for resource bindings\\n\\n\\u2022  Mosquitto MQTT broker\\n\", \"\\n\\u2022  MailDev development SMTP server\\n\\n83\\n\\nCHAPTER 9 | The Dapr bindings building block\\n\\n\\fCHAPTER  10\\n\", \"\\nThe Dapr actors building\\nblock\\n\\nThe actor model originated in 1973. It was proposed by Carl Hewitt \", \"as a conceptual model of\\nconcurrent computation, a form of computing in which several computations a\", \"re executed at the\\nsame time. Highly parallel computers weren\\u2019t yet available at that time, but the \", \"more recent\\nadvancements of multi-core CPUs and distributed systems have made the actor model popula\", \"r.\\n\\nIn the actor model, the actor is an independent unit of compute and state. Actors are completely\", \"\\nisolated from each other and they will never share memory. Actors communicate with each other\\nusing\", \" messages. When an actor receives a message, it can change its internal state, and send\\nmessages to \", \"other (possibly new) actors.\\n\\nThe reason why the actor model makes writing concurrent systems easier\", \" is that it provides a turn-\\nbased (or single-threaded) access model. Multiple actors can run at the\", \" same time, but each actor will\\nprocess received messages one at a time. This means that you can be \", \"sure that at most one thread is\\nactive inside an actor at any time. That makes writing correct concu\", \"rrent and parallel systems much\\neasier.\\n\\nWhat it solves\\n\\nActor model implementations are usually tie\", \"d to a specific language or platform. With the Dapr actors\\nbuilding block however, you can leverage \", \"the actor model from any language or platform.\\n\\nDapr\\u2019s implementation is based on the virtual actor \", \"pattern introduced by Project \\u201cOrleans\\u201d. With the\\nvirtual actor pattern, you don\\u2019t need to explicitl\", \"y create actors. Actors are activated implicitly and\\nplaced on a node in the cluster the first time \", \"a message is sent to the actor. When not executing\\noperations, actors are silently unloaded from mem\", \"ory. If a node fails, Dapr automatically moves\\nactivated actors to healthy nodes. Besides sending me\", \"ssages between actors, the Dapr actor model\\nalso support scheduling future work using timers and rem\", \"inders.\\n\\nWhile the actor model can provide great benefits, it\\u2019s important to carefully consider the \", \"actor design.\\nFor example, having many clients call the same actor will result in poor performance b\", \"ecause the actor\\noperations execute serially. Here are some criteria to check if a scenario is a goo\", \"d fit for Dapr actors:\\n\\n\\u2022\\n\\nYour problem space involves concurrency. Without actors, you\\u2019d have to in\", \"troduce explicit\\nlocking mechanisms in your code.\\n\\n84\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\", \"\\f\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nYour problem space can be partitioned into small, independent, and isolated units of state\", \" and\\nlogic.\\n\\nYou don\\u2019t need low-latency reads of the actor state. Low-latency reads cannot be guaran\", \"teed\\nbecause actor operations execute serially.\\n\\nYou don\\u2019t need to query state across a set of actor\", \"s. Querying across actors is inefficient because\\neach actor\\u2019s state needs to be read individually an\", \"d can introduce unpredictable latencies.\\n\\nOne design pattern that fits these criteria quite well is \", \"the orchestration-based saga or process\\nmanager design pattern. A saga manages a sequence of steps t\", \"hat must be taken to reach some\\noutcome. The saga (or process manager) maintains the current state o\", \"f the sequence and triggers the\\nnext step. If a step fails, the saga can execute compensating action\", \"s. Actors make it easy to deal with\\nconcurrency in the saga and to keep track of the current state. \", \"The eShopOnDapr reference\\napplication uses the saga pattern and Dapr actors to implement the Orderin\", \"g process.\\n\\nHow it works\\n\\nThe Dapr sidecar provides the HTTP/gRPC API to invoke actors. This is the \", \"base URL of the HTTP API:\\n\\nhttp://localhost:<daprPort>/v1.0/actors/<actorType>/<actorId>/\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\", \"<daprPort>: the HTTP port that Dapr listens on.\\n\\n<actorType>: the actor type.\\n\\n<actorId>: the ID of \", \"the specific actor to call.\\n\\nThe sidecar manages how, when and where each actor runs, and also route\", \"s messages between\\nactors. When an actor hasn\\u2019t been used for a period of time, the runtime deactiva\", \"tes the actor and\\nremoves it from memory. Any state managed by the actor is persisted and will be av\", \"ailable when the\\nactor re-activates. Dapr uses an idle timer to determine when an actor can be deact\", \"ivated. When an\\noperation is called on the actor (either by a method call or a reminder firing), the\", \" idle timer is reset\\nand the actor instance will remain activated.\\n\\nThe sidecar API is only one part\", \" of the equation. The service itself also needs to implement an API\\nspecification, because the actua\", \"l code that you write for the actor will run inside the service itself.\\nFigure 11-1 shows the variou\", \"s API calls between the service and its sidecar:\\n\\n85\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\f\", \"Figure 11-1. API calls between actor service and Dapr sidecar.\\n\\nTo provide scalability and reliabili\", \"ty, actors are partitioned across all the instances of the actor service.\\nThe Dapr placement service\", \" is responsible for keeping track of the partitioning information. When a\\nnew instance of an actor s\", \"ervice is started, the sidecar registers the supported actor types with the\\nplacement service. The p\", \"lacement service calculates the updated partitioning information for the\\ngiven actor type and broadc\", \"asts it to all instances. Figure 11-2 shows what happens when a service is\\nscaled out to a second re\", \"plica:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/actors/placement.png\\u201d alt-text=\\u201cDiagram of the actor\", \"\\nplacement service.\\u201d:::\\n\\nFigure 11-2. Actor placement service.\\n\\n1.  On startup, the sidecar makes a \", \"call to the actor service to get the registered actor types as well\\n\\nas actor configuration settings\", \".\\n\\n2.\\n\\n3.\\n\\nThe sidecar sends the list of registered actor types to the placement service.\\n\\nThe place\", \"ment service broadcasts the updated partitioning information to all actor service\\ninstances. Each in\", \"stance will keep a cached copy of the partitioning information and use it to\\ninvoke actors.\\n\\nImporta\", \"nt\\n\\nBecause actors are randomly distributed across service instances, it should be expected that an \", \"actor\\noperation always requires a call to a different node in the network.\\n\\n86\\n\\nCHAPTER 10 | The Dap\", \"r actors building block\\n\\n\\fThe next figure shows an ordering service instance running in Pod 1 call t\", \"he ship method of an\\nOrderActor instance with ID 3. Because the actor with ID 3 is placed in a diffe\", \"rent instance, this results\\nin a call to a different node in the cluster:\\n\\nFigure 11-3. Calling an a\", \"ctor method.\\n\\n1.\\n\\n2.\\n\\nThe service calls the actor API on the sidecar. The JSON payload in the reques\", \"t body contains the\\ndata to send to the actor.\\n\\nThe sidecar uses the locally cached partitioning inf\", \"ormation from the placement service to\\ndetermine which actor service instance (partition) is respons\", \"ible for hosting the actor with ID 3.\\nIn this example, it\\u2019s the service instance in pod 2. The call \", \"is forwarded to the appropriate\\nsidecar.\\n\\n3.\\n\\nThe sidecar instance in pod 2 calls the service instan\", \"ce to invoke the actor. The service instance\\nactivates the actor (if it hasn\\u2019t already) and executes\", \" the actor method.\\n\\n87\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\fTurn-based access model\\n\\nThe t\", \"urn-based access model ensures that at any time there\\u2019s at most one thread active inside an\\nactor in\", \"stance. To understand why this is useful, consider the following example of a method that\\nincrements\", \" a counter value:\\n\\npublic int Increment()\\n{\\n    var currentValue = GetValue();\\n    var newValue = cu\", \"rrentValue + 1;\\n\\n    SaveValue(newValue);\\n\\n    return newValue;\\n}\\n\\nLet\\u2019s assume that the current val\", \"ue returned by the GetValue method is 1. When two threads call the\\nIncrement method at the same time\", \", there\\u2019s a risk of both of them calling the GetValue method\\nbefore one of them calls SaveValue. Thi\", \"s results in both threads starting with the same initial value (1).\\nThe threads then increment the v\", \"alue to 2 and return it to the caller. The resulting value after the two\\ncalls is now 2 instead of 3\", \" which it should be. This is a simple example to illustrate the kind of issues\\nthat can slip into yo\", \"ur code when working with multiple threads, and is easy to solve. In real world\\napplications however\", \", concurrent and parallel scenarios can become very complex.\\n\\nIn traditional programming models, you\", \" can solve this problem by introducing locking mechanisms.\\nFor example:\\n\\npublic int Increment()\\n{\\n  \", \"  int newValue;\\n\\n    lock (_lockObject)\\n    {\\n        var currentValue = GetValue();\\n        newValu\", \"e = currentValue + 1;\\n\\n        SaveValue(newValue);\\n    }\\n\\n    return newValue;\\n}\\n\\nUnfortunately, us\", \"ing explicit locking mechanisms is error-prone. They can easily lead to deadlocks and\\ncan have serio\", \"us impact on performance.\\n\\nThanks to the turn-based access model, you don\\u2019t need to worry about mult\", \"iple threads with actors,\\nmaking it much easier to write concurrent systems. The following actor exa\", \"mple closely mirrors the\\ncode from the previous sample, but doesn\\u2019t require any locking mechanisms t\", \"o be correct:\\n\\npublic async Task<int> IncrementAsync()\\n{\\n    var counterValue = await StateManager.T\", \"ryGetStateAsync<int>(\\\"counter\\\");\\n\\n    var currentValue = counterValue.HasValue ? counterValue.Value \", \": 0;\\n    var newValue = currentValue + 1;\\n\\n88\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\f    awa\", \"it StateManager.SetStateAsync(\\\"counter\\\", newValue);\\n\\n    return newValue;\\n}\\n\\nTimers and reminders\\n\\nA\", \"ctors can use timers and reminders to schedule calls to themselves. Both concepts support the\\nconfig\", \"uration of a due time. The difference lies in the lifetime of the callback registrations:\\n\\n\\u2022\\n\\n\\u2022\\n\\nTim\", \"ers will only stay active as long as the actor is activated. Timers will not reset the idle-timer,\\ns\", \"o they cannot keep an actor active on their own.\\n\\nReminders outlive actor activations. If an actor i\", \"s deactivated, a reminder will re-activate the\\nactor. Reminders will reset the idle-timer.\\n\\nTimers a\", \"re registered by making a call to the actor API. In the following example, a timer is registered\\nwit\", \"h a due time of 0 and a period of 10 seconds.\\n\\ncurl -X POST http://localhost:3500/v1.0/actors/<actor\", \"Type>/<actorId>/timers/<name> \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  -d '{\\n        \\\"dueTime\\\": \\\"\", \"0h0m0s0ms\\\",\\n        \\\"period\\\": \\\"0h0m10s0ms\\\"\\n      }'\\n\\nBecause the due time is 0, the timer will fire \", \"immediately. After a timer callback has finished, the timer\\nwill wait 10 seconds before firing again\", \".\\n\\nReminders are registered in a similar way. The following example shows a reminder registration wi\", \"th a\\ndue time of 5 minutes, and an empty period:\\n\\ncurl -X POST http://localhost:3500/v1.0/actors/<ac\", \"torType>/<actorId>/reminders/<name> \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  -d '{\\n        \\\"dueTi\", \"me\\\": \\\"0h5m0s0ms\\\",\\n        \\\"period\\\": \\\"\\\"\\n      }'\\n\\nThis reminder will fire in 5 minutes. Because the g\", \"iven period is empty, this will be a one-time\\nreminder.\\n\\nNote\\n\\nTimers and reminders both respect the\", \" turn-based access model. When a timer or reminder fires, the\\ncallback will not be executed until an\", \"y other method invocation or timer/reminder callback has\\nfinished.\\n\\nState persistence\\n\\nActor state i\", \"s persisted using the Dapr state management building block. Because actors can execute\\nmultiple stat\", \"e operations in a single turn, the state store component must support multi-item\\ntransactions. At th\", \"e time of writing, the following state stores support multi-item transactions:\\n\\n89\\n\\nCHAPTER 10 | The\", \" Dapr actors building block\\n\\n\\f\\u2022\\n\\nAzure Cosmos DB\\n\\n\\u2022  MongoDB\\n\\n\\u2022  MySQL\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nPostgreSQL\\n\\nRedi\", \"s\\n\\nRethinkDB\\n\\nSQL Server\\n\\nTo configure a state store component for use with actors, you need to appe\", \"nd the following metadata\\nto the state store configuration:\\n\\n- name: actorStateStore\\n  value: \\\"true\\\"\", \"\\n\\nHere\\u2019s a complete example for a Redis state store:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nm\", \"etadata:\\n  name: statestore\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n\", \"    value: localhost:6379\\n  - name: redisPassword\\n    value: \\\"\\\"\\n  - name: actorStateStore\\n    value:\", \" \\\"true\\\"\\n\\nUse the Dapr .NET SDK\\n\\nYou can create an actor model implementation using only HTTP/gRPC ca\", \"lls. However, it\\u2019s much more\\nconvenient to use the language specific Dapr SDKs. At the time of writi\", \"ng, the .NET, Java and Python\\nSDKs all provide extensive support for working with actors.\\n\\nTo get st\", \"arted with the .NET Dapr actors SDK, you add a package reference to Dapr.Actors to your\\nservice proj\", \"ect. The first step of creating an actual actor is to define an interface that derives from\\nIActor. \", \"Clients use the interface to invoke operations on the actor. Here\\u2019s a simple example of an\\nactor int\", \"erface for keeping scores:\\n\\npublic interface IScoreActor : IActor\\n{\\n    Task<int> IncrementScoreAsyn\", \"c();\\n\\n    Task<int> GetScoreAsync();\\n}\\n\\n90\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\fImportant\\n\", \"\\nThe return type of an actor method must be Task or Task<T>. Also, actor methods can have at most\\non\", \"e argument. Both the return type and the arguments must be System.Text.Json serializable.\\n\\nNext, imp\", \"lement the actor by deriving a ScoreActor class from Actor. The ScoreActor class must also\\nimplement\", \" the IScoreActor interface:\\n\\npublic class ScoreActor : Actor, IScoreActor\\n{\\n    public ScoreActor(Ac\", \"torHost host) : base(host)\\n    {\\n    }\\n\\n    // TODO Implement interface methods.\\n}\\n\\nThe constructor \", \"in the snippet above takes a host argument of type ActorHost. The ActorHost class\\nrepresents the hos\", \"t for an actor type within the actor runtime. You need to pass this argument to the\\nconstructor of t\", \"he Actor base class. Actors also support dependency injection. Any additional\\narguments that you add\", \" to the actor constructor are resolved using the .NET dependency injection\\ncontainer.\\n\\nLet\\u2019s now imp\", \"lement the IncrementScoreAsync method of the interface:\\n\\npublic Task<int> IncrementScoreAsync()\\n{\\n  \", \"  return StateManager.AddOrUpdateStateAsync(\\n        \\\"score\\\",\\n        1,\\n        (key, currentScore)\", \" => currentScore + 1\\n    );\\n}\\n\\nIn the snippet above, a single call to StateManager.AddOrUpdateStateA\", \"sync provides the full\\nimplementation for the IncrementScoreAsync method. The AddOrUpdateStateAsync \", \"method takes\\nthree arguments:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\nThe key of the state to update.\\n\\nThe value to write if no\", \" score is stored in the state store yet.\\n\\nA Func to call if there already is a score stored in the s\", \"tate store. It takes the state key and\\ncurrent score, and returns the updated score to write back to\", \" the state store.\\n\\nThe GetScoreAsync implementation reads the current score from the state store and\", \" returns it to the\\nclient:\\n\\npublic async Task<int> GetScoreAsync()\\n{\\n    var scoreValue = await Stat\", \"eManager.TryGetStateAsync<int>(\\\"score\\\");\\n    if (scoreValue.HasValue)\\n    {\\n        return scoreValu\", \"e.Value;\\n    }\\n\\n91\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\f    return 0;\\n}\\n\\nTo host actors in\", \" an ASP.NET Core service, you must add a reference to the Dapr.Actors.AspNetCore\\npackage and make so\", \"me changes in the Program file. In the following example, the call to\\nMapActorsHandlers registers Da\", \"pr Actor endpoints in ASP.NET Core routing:\\n\\nvar builder = WebApplication.CreateBuilder(args);\\nvar a\", \"pp = builder.Build();\\n// Actors building block does not support HTTPS redirection.\\n//app.UseHttpsRed\", \"irection();\\napp.MapControllers();\\n// Add actor endpoints.\\napp.MapActorsHandlers();\\n\\nThe actors endpo\", \"ints are necessary because the Dapr sidecar calls the application to host and interact\\nwith actor in\", \"stances.\\n\\nImportant\\n\\nMake sure your Program (or Startup) class does not contain an app.UseHttpsRedir\", \"ection call to\\nredirect clients to the HTTPS endpoint. This will not work with actors. By design, a \", \"Dapr sidecar sends\\nrequests over unencrypted HTTP by default. The HTTPS middleware will block these \", \"requests when\\nenabled.\\n\\nThe Program file is also the place to register the specific actor types. The\", \" following example registers\\nthe ScoreActor using the AddActors extension method:\\n\\nvar builder = Web\", \"Application.CreateBuilder(args);\\nbuilder.Services.AddActors(options =>\\n{\\n    options.Actors.Register\", \"Actor<ScoreActor>();\\n});\\n\\nAt this point, the ASP.NET Core service is ready to host the ScoreActor an\", \"d accept incoming requests.\\nClient applications use actor proxies to invoke operations on actors. Th\", \"e following example shows\\nhow a console client application invokes the IncrementScoreAsync operation\", \" on a ScoreActor\\ninstance:\\n\\nvar actorId = new ActorId(\\\"scoreActor1\\\");\\n\\nvar proxy = ActorProxy.Create\", \"<IScoreActor>(actorId, \\\"ScoreActor\\\");\\n\\nvar score = await proxy.IncrementScoreAsync();\\n\\nConsole.Write\", \"Line($\\\"Current score: {score}\\\");\\n\\nThe above example uses the Dapr.Actors package to call the actor s\", \"ervice. To invoke an operation on\\nan actor, you need to be able to address it. You\\u2019ll need two parts\", \" for this:\\n\\n1.\\n\\n92\\n\\nThe actor type uniquely identifies the actor implementation across the whole app\", \"lication. By\\ndefault, the actor type is the name of the implementation class (without namespace). Yo\", \"u can\\ncustomize the actor type by adding an ActorAttribute to the implementation class and setting\\ni\", \"ts TypeName property.\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\f2.\\n\\nThe ActorId uniquely identi\", \"fies an instance of an actor type. You can also use this class to\\ngenerate a random actor id by call\", \"ing ActorId.CreateRandom.\\n\\nThe example uses ActorProxy.Create to create a proxy instance for the Sco\", \"reActor. The Create\\nmethod takes two arguments: the ActorId identifying the specific actor and the a\", \"ctor type. It also has\\na generic type parameter to specify the actor interface that the actor type i\", \"mplements. As both the\\nserver and client applications need to use the actor interfaces, they\\u2019re typi\", \"cally stored in a separate\\nshared project.\\n\\nThe final step in the example calls the IncrementScoreAs\", \"ync method on the actor and outputs the\\nresult. Remember that the Dapr placement service distributes\", \" the actor instances across the Dapr\\nsidecars. Therefore, expect an actor call to be a network call \", \"to another node.\\n\\nCall actors from ASP.NET Core clients\\n\\nThe console client example in the previous \", \"section uses the static ActorProxy.Create method directly\\nto get an actor proxy instance. If the cli\", \"ent application is an ASP.NET Core application, you should use\\nthe IActorProxyFactory interface to c\", \"reate actor proxies. The main benefit is that it allows you to\\nmanage configuration in one place. Th\", \"e AddActors extension method on IServiceCollection takes\\na delegate that allows you to specify actor\", \" runtime options, such as the HTTP endpoint of the Dapr\\nsidecar. The following example specifies cus\", \"tom JsonSerializerOptions to use for actor state\\npersistence and message deserialization:\\n\\nvar build\", \"er = WebApplication.CreateBuilder(args);\\nbuilder.Services.AddActors(options =>\\n{\\n    var jsonSeriali\", \"zerOptions = new JsonSerializerOptions()\\n    {\\n        PropertyNamingPolicy = JsonNamingPolicy.Camel\", \"Case,\\n        PropertyNameCaseInsensitive = true\\n    };\\n\\n    options.JsonSerializerOptions = jsonSer\", \"ializerOptions;\\n    options.Actors.RegisterActor<ScoreActor>();\\n});\\n\\nThe call to AddActors registers\", \" the IActorProxyFactory for .NET dependency injection. This allows\\nASP.NET Core to inject an IActorP\", \"roxyFactory instance into your controller classes. The following\\nexample calls an actor method from \", \"an ASP.NET Core controller class:\\n\\n[ApiController]\\n[Route(\\\"[controller]\\\")]\\npublic class ScoreControl\", \"ler : ControllerBase\\n{\\n    private readonly IActorProxyFactory _actorProxyFactory;\\n\\n    public Score\", \"Controller(IActorProxyFactory actorProxyFactory)\\n    {\\n        _actorProxyFactory = actorProxyFactor\", \"y;\\n    }\\n\\n    [HttpPut(\\\"{scoreId}\\\")]\\n    public Task<int> IncrementAsync(string scoreId)\\n    {\\n\\n93\\n\\n\", \"CHAPTER 10 | The Dapr actors building block\\n\\n\\f        var scoreActor = _actorProxyFactory.CreateActo\", \"rProxy<IScoreActor>(\\n            new ActorId(scoreId),\\n            \\\"ScoreActor\\\");\\n\\n        return sc\", \"oreActor.IncrementScoreAsync();\\n    }\\n}\\n\\nActors can also call other actors directly. The Actor base \", \"class exposes an IActorProxyFactory class\\nthrough the ProxyFactory property. To create an actor prox\", \"y from within an actor, use the\\nProxyFactory property of the Actor base class. The following example\", \" shows an OrderActor that\\ninvokes operations on two other actors:\\n\\npublic class OrderActor : Actor, \", \"IOrderActor\\n{\\n    public OrderActor(ActorHost host) : base(host)\\n    {\\n    }\\n\\n    public async Task \", \"ProcessOrderAsync(Order order)\\n    {\\n        var stockActor = ProxyFactory.CreateActorProxy<IStockAc\", \"tor>(\\n            new ActorId(order.OrderNumber),\\n            \\\"StockActor\\\");\\n\\n        await stockAct\", \"or.ReserveStockAsync(order.OrderLines);\\n\\n        var paymentActor = ProxyFactory.CreateActorProxy<IP\", \"aymentActor>(\\n            new ActorId(order.OrderNumber),\\n            \\\"PaymentActor\\\");\\n\\n        awai\", \"t paymentActor.ProcessPaymentAsync(order.PaymentDetails);\\n    }\\n}\\n\\nNote\\n\\nBy default, Dapr actors are\", \"n\\u2019t reentrant. This means that a Dapr actor cannot be called more than once\\nin the same chain. For e\", \"xample, the call chain Actor A -> Actor B -> Actor A is not allowed. At the\\ntime of writing, there\\u2019s\", \" a preview feature available to support reentrancy. However, there is no SDK\\nsupport yet. For more d\", \"etails, see the official documentation.\\n\\nCall non-.NET actors\\n\\nSo far, the examples used strongly-ty\", \"ped actor proxies based on .NET interfaces to illustrate actor\\ninvocations. This works great when bo\", \"th the actor host and client are .NET applications. However, if\\nthe actor host is not a .NET applica\", \"tion, you don\\u2019t have an actor interface to create a strongly-typed\\nproxy. In these cases, you can us\", \"e a weakly-typed proxy.\\n\\nYou create weakly-typed proxies in a similar way to strongly-typed proxies.\", \" Instead of relying on a\\n.NET interface, you need to pass in the actor method name as a string.\\n\\n[Ht\", \"tpPut(\\\"{scoreId}\\\")]\\npublic Task<int> IncrementAsync(string scoreId)\\n\\n94\\n\\nCHAPTER 10 | The Dapr actor\", \"s building block\\n\\n\\f{\\n    var scoreActor = _actorProxyFactory.CreateActorProxy(\\n        new ActorId(s\", \"coreId),\\n        \\\"ScoreActor\\\");\\n\\n    return scoreActor(\\\"IncrementScoreAsync\\\");\\n}\\n\\nTimers and reminde\", \"rs\\n\\nUse the RegisterTimerAsync method of the Actor base class to schedule actor timers. In the\\nfollo\", \"wing example, a TimerActor exposes a StartTimerAsync method. Clients can call the method to\\nstart a \", \"timer that repeatedly writes a given text to the log output.\\n\\npublic class TimerActor : Actor, ITime\", \"rActor\\n{\\n    public TimerActor(ActorHost host) : base(host)\\n    {\\n    }\\n\\n    public Task StartTimerA\", \"sync(string name, string text)\\n    {\\n        return RegisterTimerAsync(\\n            name,\\n          \", \"  nameof(TimerCallback),\\n            Encoding.UTF8.GetBytes(text),\\n            TimeSpan.Zero,\\n      \", \"      TimeSpan.FromSeconds(3));\\n    }\\n\\n    public Task TimerCallbackAsync(byte[] state)\\n    {\\n      \", \"  var text = Encoding.UTF8.GetString(state);\\n\\n        Logger.LogInformation($\\\"Timer fired: {text}\\\");\", \"\\n\\n        return Task.CompletedTask;\\n    }\\n}\\n\\nThe StartTimerAsync method calls RegisterTimerAsync to\", \" schedule the timer. RegisterTimerAsync\\ntakes five arguments:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\n5.\\n\\nThe name of the t\", \"imer.\\n\\nThe name of the method to call when the timer fires.\\n\\nThe state to pass to the callback metho\", \"d.\\n\\nThe amount of time to wait before the callback method is first invoked.\\n\\nThe time interval betwe\", \"en callback method invocations. You can specify\\nTimeSpan.FromMilliseconds(-1) to disable periodic si\", \"gnaling.\\n\\nThe TimerCallbackAsync method receives the user state in binary form. In the example, the \", \"callback\\ndecodes the state back to a string before writing it to the log.\\n\\nTimers can be stopped by \", \"calling UnregisterTimerAsync:\\n\\n95\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\fpublic class TimerA\", \"ctor : Actor, ITimerActor\\n{\\n    // ...\\n\\n    public Task StopTimerAsync(string name)\\n    {\\n        re\", \"turn UnregisterTimerAsync(name);\\n    }\\n}\\n\\nRemember that timers do not reset the actor idle timer. Wh\", \"en no other calls are made on the actor, it\\nmay be deactivated and the timer will be stopped automat\", \"ically. To schedule work that does reset the\\nidle timer, use reminders which we\\u2019ll look at next.\\n\\nTo\", \" use reminders in an actor, your actor class must implement the IRemindable interface:\\n\\npublic inter\", \"face IRemindable\\n{\\n    Task ReceiveReminderAsync(\\n        string reminderName, byte[] state,\\n       \", \" TimeSpan dueTime, TimeSpan period);\\n}\\n\\nThe ReceiveReminderAsync method is called when a reminder is\", \" fired. It takes 4 arguments:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\nThe name of the reminder.\\n\\nThe user state provided du\", \"ring registration.\\n\\nThe invocation due time provided during registration.\\n\\nThe invocation period pro\", \"vided during registration.\\n\\nTo register a reminder, use the RegisterReminderAsync method of the acto\", \"r base class. The following\\nexample sets a reminder to fire a single time with a due time of three m\", \"inutes.\\n\\npublic class ReminderActor : Actor, IReminderActor, IRemindable\\n{\\n    public ReminderActor(\", \"ActorHost host) : base(host)\\n    {\\n    }\\n\\n    public Task SetReminderAsync(string text)\\n    {\\n      \", \"  return RegisterReminderAsync(\\n            \\\"DoNotForget\\\",\\n            Encoding.UTF8.GetBytes(text),\", \"\\n            TimeSpan.FromSeconds(3),\\n            TimeSpan.FromMilliseconds(-1));\\n    }\\n\\n    public \", \"Task ReceiveReminderAsync(\\n        string reminderName, byte[] state,\\n        TimeSpan dueTime, Time\", \"Span period)\\n    {\\n        if (reminderName == \\\"DoNotForget\\\")\\n        {\\n            var text = Encod\", \"ing.UTF8.GetString(state);\\n\\n            Logger.LogInformation($\\\"Don't forget: {text}\\\");\\n\\n96\\n\\nCHAPTER\", \" 10 | The Dapr actors building block\\n\\n\\f        }\\n\\n        return Task.CompletedTask;\\n    }\\n}\\n\\nThe Re\", \"gisterReminderAsync method is similar to RegisterTimerAsync but you don\\u2019t have to specify\\na callback\", \" method explicitly. As the above example shows, you implement\\nIRemindable.ReceiveReminderAsync to ha\", \"ndle fired reminders.\\n\\nReminders both reset the idle timer and are persistent. Even if your actor is\", \" deactivated, it will be\\nreactivated at the moment a reminder fires. To stop a reminder from firing,\", \" call\\nUnregisterReminderAsync.\\n\\nSample application: Dapr Traffic Control\\n\\nThe default version of Dap\", \"r Traffic Control does not use the actor model. However, it does contain an\\nalternative actor-based \", \"implementation of the TrafficControl service that you can enable. To make use\\nof actors in the Traff\", \"icControl service, open up the\\nsrc/TrafficControlService/Controllers/TrafficController.cs file and u\", \"ncomment the\\nUSE_ACTORMODEL statement at the top of the file:\\n\\n#define USE_ACTORMODEL\\n\\nWhen the acto\", \"r model is enabled, the application uses actors to represent vehicles. The operations\\nthat can be in\", \"voked on the vehicle actors are defined in an IVehicleActor interface:\\n\\npublic interface IVehicleAct\", \"or : IActor\\n{\\n    Task RegisterEntryAsync(VehicleRegistered msg);\\n    Task RegisterExitAsync(Vehicle\", \"Registered msg);\\n}\\n\\nThe (simulated) entry cameras call the RegisterEntryAsync method when a new vehi\", \"cle is first\\ndetected in the lane. The only responsibility of this method is storing the entry times\", \"tamp in the actor\\nstate:\\n\\nvar vehicleState = new VehicleState\\n{\\n    LicenseNumber = msg.LicenseNumbe\", \"r,\\n    EntryTimestamp = msg.Timestamp\\n};\\nawait StateManager.SetStateAsync(\\\"VehicleState\\\", vehicleSta\", \"te);\\n\\nWhen the vehicle reaches the end of the speed camera zone, the exit camera calls the\\nRegisterE\", \"xitAsync method. The RegisterExitAsync method first gets the current states and\\nupdates it to includ\", \"e the exit timestamp:\\n\\nvar vehicleState = await StateManager.GetStateAsync<VehicleState>(\\\"VehicleSta\", \"te\\\");\\nvehicleState.ExitTimestamp = msg.Timestamp;\\n\\n97\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\", \"\\fNote\\n\\nThe code above currently assumes that a VehicleState instance has already been saved by the\\nR\", \"egisterEntryAsync method. The code could be improved by first checking to make sure the state\\nexists\", \". Thanks to the turn-based access model, no explicit locks are required in the code.\\n\\nAfter the stat\", \"e is updated, the RegisterExitAsync method checks if the vehicle was driving too fast. If\\nit was, th\", \"e actor publishes a message to the collectfine pub/sub topic:\\n\\nint violation = _speedingViolationCal\", \"culator.DetermineSpeedingViolationInKmh(\\n    vehicleState.EntryTimestamp, vehicleState.ExitTimestamp\", \");\\n\\nif (violation > 0)\\n{\\n    var speedingViolation = new SpeedingViolation\\n    {\\n        VehicleId =\", \" msg.LicenseNumber,\\n        RoadId = _roadId,\\n        ViolationInKmh = violation,\\n        Timestamp \", \"= msg.Timestamp\\n    };\\n\\n    await _daprClient.PublishEventAsync(\\\"pubsub\\\", \\\"collectfine\\\", speedingVio\", \"lation);\\n}\\n\\nThe code above uses two external dependencies. The _speedingViolationCalculator encapsul\", \"ates\\nthe business logic for determining whether or not a vehicle has driven too fast. The _daprClien\", \"t\\nallows the actor to publish messages using the Dapr pub/sub building block.\\n\\nBoth dependencies are\", \" registered in the Program.cs class and injected into the actor using constructor\\ndependency injecti\", \"on:\\n\\nprivate readonly DaprClient _daprClient;\\nprivate readonly ISpeedingViolationCalculator _speedin\", \"gViolationCalculator;\\nprivate readonly string _roadId;\\n\\npublic VehicleActor(\\n    ActorHost host, Dap\", \"rClient daprClient,\\n    ISpeedingViolationCalculator speedingViolationCalculator)\\n    : base(host)\\n{\", \"\\n    _daprClient = daprClient;\\n    _speedingViolationCalculator = speedingViolationCalculator;\\n    _\", \"roadId = _speedingViolationCalculator.GetRoadId();\\n}\\n\\nThe actor based implementation no longer uses \", \"the Dapr state management building block directly.\\nInstead, the state is automatically persisted aft\", \"er each operation is executed.\\n\\nSummary\\n\\nThe Dapr actors building block makes it easier to write cor\", \"rect concurrent systems. Actors are small\\nunits of state and logic. They use a turn-based access mod\", \"el which saves you from having to use\\nlocking mechanisms to write thread-safe code. Actors are creat\", \"ed implicitly and are silently unloaded\\n\\n98\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\ffrom memo\", \"ry when no operations are performed. Any state stored in the actor is automatically\\npersisted and lo\", \"aded when the actor is reactivated. Actor model implementations are typically created\\nfor a specific\", \" language or platform. With the Dapr actors building block however, you can leverage the\\nactor model\", \" from any language or platform.\\n\\nActors support timers and reminders to schedule future work. Timers\", \" do not reset the idle timer and\\nwill allow the actor to be deactivated when no other operations are\", \" performed. Reminders do reset\\nthe idle timer and are also persisted automatically. Both timers and \", \"reminders respect the turn-based\\naccess model, making sure that no other operations can execute whil\", \"e the timer/reminder events are\\nhandled.\\n\\nActor state is persisted using the Dapr state management b\", \"uilding block. Any state store that\\nsupports multi-item transactions can be used to store actor stat\", \"e.\\n\\nReferences\\n\\n\\u2022\\n\\nDapr supported state stores\\n\\n99\\n\\nCHAPTER 10 | The Dapr actors building block\\n\\n\\fCH\", \"APTER  11\\n\\nThe Dapr observability\\nbuilding block\\n\\nModern distributed systems are complex. You start \", \"with small, loosely coupled, independently\\ndeployable services. These services cross process and ser\", \"ver boundaries. They then consume different\\nkinds of infrastructure backing services (databases, mes\", \"sage brokers, key vaults). Finally, these\\ndisparate pieces compose together to form an application.\\n\", \"\\nWith so many separate, moving parts, how do you make sense of what is going on? Unfortunately,\\nlega\", \"cy monitoring approaches from the past aren\\u2019t enough. Instead, the system must be observable\\nfrom en\", \"d-to-end. Modern observability practices provide visibility and insight into the health of the\\nappli\", \"cation at all times. They enable you to infer the internal state by observing the output. Not only i\", \"s\\nobservability mandatory for monitoring and troubleshooting distributed applications, it needs to b\", \"e\\nimplemented at the start.\\n\\nThe system information used to gain observability is referred to as tel\", \"emetry. It can be divided into\\nfour broad categories:\\n\\n1.  Distributed tracing provides insights int\", \"o the traffic between services involved in distributed\\n\\nbusiness transactions.\\n\\n2.  Metrics provides\", \" insights into the performance of a service and its resource consumption.\\n\\n3.\\n\\nLogging provides insi\", \"ghts into how code is executing and if errors have occurred.\\n\\n4.  Health endpoints provide insight i\", \"nto the availability of a service.\\n\\nThe depth of telemetry is determined by the observability featur\", \"es of an application platform.\\nConsider the Azure cloud. It provides a rich telemetry experience tha\", \"t includes all of the telemetry\\ncategories. With little configuration, Azure IaaS and PaaS services \", \"will propagate and publish\\ntelemetry to the Azure Monitor and Azure Application Insights services. A\", \"pplication Insights presents\\nsystem logging, tracing, and problem areas with highly visual dashboard\", \"s. It can even render a\\ndiagram showing the dependencies between services based on their communicati\", \"on.\\n\\nHowever, what if an application can\\u2019t use Azure PaaS and IaaS resources? Is it still possible t\", \"o take\\nadvantage of the rich telemetry experience of Application Insights? The answer is yes. A non-\", \"Azure\\napplication can import libraries, add configuration, and instrument code to emit telemetry to \", \"Azure\\nApplication Insights. However, this approach tightly couples the application to Application In\", \"sights.\\nMoving the app to a different monitoring platform could involve expensive refactoring. Would\", \"n\\u2019t it be\\ngreat to avoid tight coupling and consume observability outside of the code?\\n\\nWith Dapr, y\", \"ou can. Let\\u2019s look at how Dapr can add observability to our distributed applications.\\n\\n100\\n\\nCHAPTER \", \"11 | The Dapr observability building block\\n\\n\\fWhat it solves\\n\\nThe Dapr observability building block d\", \"ecouples observability from the application. It automatically\\ncaptures traffic generated by Dapr sid\", \"ecars and Dapr system services that make up the Dapr control\\nplane. The block correlates traffic fro\", \"m a single operation that spans multiple services. It also exposes\\nperformance metrics, resource uti\", \"lization, and the health of the system. Telemetry is published in\\nopen-standard formats enabling inf\", \"ormation to be fed into your monitoring back end of choice.\\nThere, the information can be visualized\", \", queried, and analyzed.\\n\\nAs Dapr abstracts away the plumbing, the application is unaware of how obs\", \"ervability is implemented.\\nThere\\u2019s no need to reference libraries or implement custom instrumentatio\", \"n code. Dapr allows the\\ndeveloper to focus on building business logic instead of observability plumb\", \"ing. Observability is\\nconfigured at the Dapr system level and is consistent across services, even wh\", \"en created by different\\nteams, and built with different technology stacks.\\n\\nHow it works\\n\\nDapr\\u2019s sid\", \"ecar architecture enables built-in observability features. As services communicate, Dapr\\nsidecars in\", \"tercept the traffic and extract tracing, metrics, and logging information. Telemetry is\\npublished in\", \" an open standards format. By default, Dapr supports OpenTelemetry and Zipkin.\\n\\nDapr provides collec\", \"tors that can publish telemetry to different back-end monitoring tools. These\\ntools present Dapr tel\", \"emetry for analysis and querying. Figure 10-1 shows the Dapr observability\\narchitecture:\\n\\nFigure 10-\", \"1. Dapr observability architecture.\\n\\n1.\\n\\nService A calls an operation on Service B. The call is rout\", \"ed from a Dapr sidecar for Service A to a\\nsidecar for Service B.\\n\\n2.  When Service B completes the o\", \"peration, a response is sent back to Service A through the Dapr\\nsidecars. They gather and publish al\", \"l available telemetry for every request and response.\\n\\n3.\\n\\nThe configured collector ingests the tele\", \"metry and sends it to the monitoring back end.\\n\\n101\\n\\nCHAPTER 11 | The Dapr observability building bl\", \"ock\\n\\n\\fAs a developer, keep in mind that adding observability is different from configuring other Dap\", \"r\\nbuilding blocks, like pub/sub or state management. Instead of referencing a building block, you ad\", \"d a\\ncollector and a monitoring back end. Figure 10-1 shows it\\u2019s possible to configure multiple colle\", \"ctors\\nthat integrate with different monitoring back ends.\\n\\nAt the beginning of this chapter, four ca\", \"tegories of telemetry were identified. The following sections\\nwill provide detail for each category.\", \" They\\u2019ll include instruction on how to configure collectors that\\nintegrate with popular monitoring b\", \"ack ends.\\n\\nDistributed tracing\\n\\nDistributed tracing provides insight into traffic that flows across \", \"services in a distributed application.\\nThe logs of exchanged request and response messages are a sou\", \"rce of invaluable information for\\ntroubleshooting issues. The hard part is correlating messages that\", \" belong to the same business\\ntransaction.\\n\\nDapr uses the W3C Trace Context to correlate related mess\", \"ages. It injects the same context\\ninformation into requests and responses that form a unique operati\", \"on. Figure 10-2 shows how\\ncorrelation works:\\n\\nNote\\n\\nThe trace context is often referred to as a corr\", \"elation token in microservice terminology.\\n\\nFigure 10-2. W3C Trace Context example.\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\", \"\\nService A invokes an operation on Service B. As Service A starts the call, Dapr creates a unique\\ntr\", \"ace context and injects it into the request.\\n\\nService B receives the request and invokes an operatio\", \"n on Service C. Dapr detects that the\\nincoming request contains a trace context and propagates it by\", \" injecting it into the outgoing\\nrequest to Service C.\\n\\nService C receives the request and handles it\", \". Dapr detects that the incoming request contains a\\ntrace context and propagates it by injecting it \", \"into the outgoing response back to Service B.\\n\\nService B receives the response and handles it. It th\", \"en creates a new response and propagates\\nthe trace context by injecting it into the outgoing respons\", \"e back to Service A.\\n\\nA set of requests and responses that belong together is called a trace. Figure\", \" 10-3 shows a trace:\\n\\n102\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fFigure 10-3. Traces \", \"and spans.\\n\\nIn the figure, note how the trace represents a unique application transaction that takes\", \" place across\\nmany services. A trace is a collection of spans. Each span represents a single operati\", \"on or unit of work\\ndone within the trace. Spans are the requests and responses that are sent between\", \" services that\\nimplement the unique transaction.\\n\\nThe next sections discuss how to inspect tracing t\", \"elemetry by publishing it to a monitoring back end.\\n\\nUse a Zipkin monitoring back end\\n\\nZipkin is an \", \"open-source distributed tracing system. It can ingest and visualize telemetry data. Dapr\\noffers defa\", \"ult support for Zipkin. The following example demonstrates how to configure Zipkin to\\nvisualize Dapr\", \" telemetry.\\n\\nEnable and configure tracing\\n\\nTo start, tracing must be enabled for the Dapr runtime us\", \"ing a Dapr configuration file. Here\\u2019s an\\nexample of a configuration file named dapr-config.yaml that\", \" enables tracing:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Configuration\\nmetadata:\\n  name: dapr-config\\n  \", \"namespace: default\\nspec:\\n  tracing:\\n    samplingRate: \\\"1\\\"\\n    zipkin:\\n      endpointAddress: \\\"http:/\", \"/zipkin.default.svc.cluster.local:9411/api/v2/spans\\\"\\n\\nThe samplingRate attribute specifies the inter\", \"val used for publishing traces. The value must be\\nbetween 0 (tracing disabled) and 1 (every trace is\", \" published). With a value of 0.5, for example, every\\nother trace is published, significantly reducin\", \"g published traffic. The endpointAddress points to an\\nendpoint on a Zipkin server running in a Kuber\", \"netes cluster. The default port for Zipkin is 9411. The\\nconfiguration must be applied to the Kuberne\", \"tes cluster using the Kubernetes CLI:\\n\\nkubectl apply -f dapr-config.yaml\\n\\n103\\n\\nCHAPTER 11 | The Dapr\", \" observability building block\\n\\n\\fInstall the Zipkin server\\n\\nWhen installing Dapr in self-hosted mode,\", \" a Zipkin server is automatically installed and tracing is\\nenabled in the default configuration file\", \" located in $HOME/.dapr/config.yaml or\\n%USERPROFILE%\\\\.dapr\\\\config.yaml on Windows.\\n\\nWhen installing \", \"Dapr on a Kubernetes cluster, Zipkin must be deployed manually. Use the following\\nKubernetes manifes\", \"t file entitled zipkin.yaml to deploy a standard Zipkin server to a Kubernetes\\ncluster:\\n\\nkind: Deplo\", \"yment\\napiVersion: apps/v1\\nmetadata:\\n  name: zipkin\\n  namespace: dapr-trafficcontrol\\n  labels:\\n    se\", \"rvice: zipkin\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      service: zipkin\\n  template:\\n   \", \" metadata:\\n      labels:\\n        service: zipkin\\n    spec:\\n      containers:\\n        - name: zipkin\\n\", \"          image: openzipkin/zipkin-slim\\n          imagePullPolicy: IfNotPresent\\n          ports:\\n   \", \"         - name: http\\n              containerPort: 9411\\n              protocol: TCP\\n\\n---\\n\\nkind: Serv\", \"ice\\napiVersion: v1\\nmetadata:\\n  name: zipkin\\n  namespace: dapr-trafficcontrol\\n  labels:\\n    service: \", \"zipkin\\nspec:\\n  type: NodePort\\n  ports:\\n    - port: 9411\\n      targetPort: 9411\\n      nodePort: 32411\", \"\\n      protocol: TCP\\n      name: zipkin\\n  selector:\\n    service: zipkin\\n\\nThe deployment uses the sta\", \"ndard openzipkin/zipkin-slim container image. The Zipkin service\\nexposes the Zipkin web front end, w\", \"hich you can use to view the telemetry on port 32411. Use the\\n\\n104\\n\\nCHAPTER 11 | The Dapr observabil\", \"ity building block\\n\\n\\fKubernetes CLI to apply the Zipkin manifest file to the Kubernetes cluster and \", \"deploy the Zipkin\\nserver:\\n\\nkubectl apply -f zipkin.yaml\\n\\nConfigure the services to use the tracing c\", \"onfiguration\\n\\nNow everything is set up correctly to start publishing telemetry. Every Dapr sidecar t\", \"hat is deployed as\\npart of the application must be instructed to emit telemetry when started. To do \", \"that, add a\\ndapr.io/config annotation that references the dapr-config configuration to the deploymen\", \"t of\\neach service. Here\\u2019s an example of the Traffic Control FineCollection service\\u2019s manifest file c\", \"ontaining\\nthe annotation:\\n\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: finecollectionserv\", \"ice\\n  namespace: dapr-trafficcontrol\\n  labels:\\n    app: finecollectionservice\\nspec:\\n  replicas: 1\\n  \", \"selector:\\n    matchLabels:\\n      app: finecollectionservice\\n  template:\\n    metadata:\\n      labels:\\n\", \"        app: finecollectionservice\\n      annotations:\\n        dapr.io/enabled: \\\"true\\\"\\n        dapr.i\", \"o/app-id: \\\"finecollectionservice\\\"\\n        dapr.io/app-port: \\\"6001\\\"\\n        dapr.io/config: \\\"dapr-con\", \"fig\\\"\\n    spec:\\n      containers:\\n      - name: finecollectionservice\\n        image: dapr-trafficcont\", \"rol/finecollectionservice:1.0\\n        ports:\\n        - containerPort: 6001\\n\\nInspect the telemetry in\", \" Zipkin\\n\\nOnce the application is started, the Dapr sidecars will emit telemetry to the Zipkin server\", \". To inspect\\nthis telemetry, point a web-browser to http://localhost:32411. You\\u2019ll see the Zipkin we\", \"b front end:\\n\\n105\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fFigure 10-4. Zipkin front en\", \"d.\\n\\nOn the Find a trace tab, you can query traces. Pressing the RUN QUERY button without specifying \", \"any\\nrestrictions will show all the ingested traces:\\n\\nFigure 10-5. Zipkin traces overview.\\n\\nClicking \", \"the SHOW button next to a specific trace, will show the details of that trace:\\n\\n106\\n\\nCHAPTER 11 | Th\", \"e Dapr observability building block\\n\\n\\fFigure 10-6. Zipkin trace details.\\n\\nEach item on the details p\", \"age, is a span that represents a request that is part of the selected trace.\\n\\nInspect the dependenci\", \"es between services\\n\\nBecause Dapr sidecars handle traffic between services, Zipkin can use the trace\", \" information to\\ndetermine the dependencies between the services. To see it in action, go to the Depe\", \"ndencies tab on\\nthe Zipkin web page and select the button with the magnifying glass. Zipkin will sho\", \"w an overview of\\nthe services and their dependencies:\\n\\n107\\n\\nCHAPTER 11 | The Dapr observability buil\", \"ding block\\n\\n\\fFigure 10-7. Zipkin dependencies.\\n\\nThe animated dots on the lines between the services \", \"represent requests and move from source to\\ndestination. Red dots indicate a failed request.\\n\\nUse a J\", \"aeger or New Relic monitoring back end\\n\\nBeyond Zipkin, other monitoring back-end software can also i\", \"ngest telemetry with the Zipkin format.\\nJaeger is an open source tracing system created by Uber Tech\", \"nologies. It\\u2019s used to trace transactions\\nbetween distributed services and troubleshoot complex micr\", \"oservices environments. New Relic is a\\nfull-stack observability platform. It links relevant data fro\", \"m a distributed application to provide a\\ncomplete picture of your system. To try them out, specify a\", \"n endpointAddress pointing to either a\\nJaeger or New Relic server in the Dapr configuration file. He\", \"re\\u2019s an example of a configuration file that\\nconfigures Dapr to send telemetry to a Jaeger server. T\", \"he URL for Jaeger is identical to the URL for the\\nZipkin. The only difference is the number of the p\", \"ort on which the server runs:\\n\\n:::{custom-style=CodeBox} yaml  apiVersion: dapr.io/v1alpha1  kind: C\", \"onfiguration  metadata:    name:\\ndapr-config    namespace: default  spec:    tracing:      samplingR\", \"ate: \\\"1\\\"      zipkin:\\nendpointAddress: \\\"http://localhost:9415/api/v2/spans\\\" :::\\n\\nTo try out New Reli\", \"c, specify the endpoint of the New Relic API. Here\\u2019s an example of a configuration\\nfile for New Reli\", \"c:\\n\\n:::{custom-style=CodeBox} yaml apiVersion: dapr.io/v1alpha1  kind: Configuration  metadata:    n\", \"ame:\\ndapr-config    namespace: default  spec:    tracing:      samplingRate: \\\"1\\\"      zipkin:\\nendpoi\", \"ntAddress: \\\"https://trace-api.newrelic.com/trace/v1?Api-Key=<NR-API-KEY>&Data-\\nFormat=zipkin&Data-Fo\", \"rmat-Version=2\\\" :::\\n\\n108\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fCheck out the Jaeger \", \"and New Relic websites for more information on how to use them.\\n\\nMetrics\\n\\nMetrics provide insight in\", \"to performance and resource consumption. Under the hood, Dapr emits a\\nwide collection of system and \", \"runtime metrics. Dapr uses Prometheus as a metric standard. Dapr\\nsidecars and system services, expos\", \"e a metrics endpoint on port 9090. A Prometheus scraper calls this\\nendpoint at a predefined interval\", \" to collect metrics. The scraper sends metric values to a monitoring\\nback end. Figure 10-8 shows the\", \" scraping process:\\n\\nFigure 10-8. Scraping Prometheus metrics.\\n\\nEach sidecar and system service expos\", \"es a metric endpoint that listens on port 9090. The Prometheus\\nMetrics Scrapper captures metrics fro\", \"m each endpoint and published the information to the\\nmonitoring back end.\\n\\nService discovery\\n\\nYou mi\", \"ght wonder how the metrics scraper knows where to collect metrics. Prometheus can integrate\\nwith dis\", \"covery mechanisms built into target deployment environments. For example, when running in\\nKubernetes\", \", Prometheus can integrate with the Kubernetes API to find all available Kubernetes\\nresources runnin\", \"g in the environment.\\n\\nMetrics list\\n\\nDapr generates a large set of metrics for Dapr system services \", \"and its runtime. Some examples\\ninclude:\\n\\n109\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fM\", \"etric\\n\\ndapr_operator_service_created_total\\n\\nSource\\n\\nSystem\\n\\ndapr_injector_sidecar_injection/requests\", \"_total\\n\\nSystem\\n\\nDescription\\n\\nThe total number of Dapr services created\\nby the Dapr Operator service.\", \"\\n\\nThe total number of sidecar injection\\nrequests received by the Dapr Sidecar-\\nInjector service.\\n\\nda\", \"pr_placement_runtimes_total\\n\\nSystem\\n\\nThe total number of hosts reported to the\\nDapr Placement servic\", \"e.\\n\\ndapr_sentry_cert_sign_request_received_total\\n\\nSystem\\n\\nThe number of certificate signing requests\", \"\\n(CRSs) received by the Dapr Sentry service.\\n\\ndapr_runtime_component_loaded\\n\\nRuntime  The number of \", \"successfully loaded Dapr\\n\\ncomponents.\\n\\ndapr_grpc_io_server_completed_rpcs\\n\\nRuntime  Count of gRPC ca\", \"lls by method and status.\\n\\ndapr_http_server_request_count\\n\\nRuntime  Number of HTTP requests started \", \"in an\\n\\ndapr_http/client/sent_bytes\\n\\nHTTP server.\\n\\nRuntime  Total bytes sent in request body (not\\ninc\", \"luding headers) by an HTTP client.\\n\\nFor more information on available metrics, see the Dapr metrics \", \"documentation.\\n\\nConfigure Dapr metrics\\n\\nAt run time, you can disable the metrics collection endpoint\", \" by including the --enable-\\nmetrics=false argument in the Dapr command. Or, you can also change the \", \"default port for the\\nendpoint with the --metrics-port 9090 argument.\\n\\nYou can also use a Dapr config\", \"uration file to statically enable or disable runtime metrics collection:\\n\\napiVersion: dapr.io/v1alph\", \"a1\\nkind: Configuration\\nmetadata:\\n  name: dapr-config\\n  namespace: dapr-trafficcontrol\\nspec:\\n  tracin\", \"g:\\n    samplingRate: \\\"1\\\"\\n  metric:\\n    enabled: false\\n\\nVisualize Dapr metrics\\n\\nWith the Prometheus s\", \"craper collecting and publishing metrics into the monitoring back end, how do\\nyou make sense of the \", \"raw data? A popular visualization tool for analyzing metrics is Grafana. With\\nGrafana, you can creat\", \"e dashboards from the available metrics. Here\\u2019s an example of a dashboard\\ndisplaying Dapr system ser\", \"vices metrics:\\n\\n110\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fFigure 10-9. Grafana dashb\", \"oard.\\n\\nThe Dapr documentation includes a tutorial for installing Prometheus and Grafana.\\n\\nLogging\\n\\nL\", \"ogging provides insight into what is happening with a service at run time. When running an\\napplicati\", \"on, Dapr automatically emits log entries from Dapr sidecars and Dapr system services.\\nHowever, loggi\", \"ng entries instrumented in your application code aren\\u2019t automatically included. To\\nemit logging from\", \" application code, you can import a specific SDK like OpenTelemetry SDK for .NET.\\nLogging applicatio\", \"n code is covered later in this chapter in the section Using the Dapr .NET SDK.\\n\\nLog entry structure\", \"\\n\\nDapr emits structured logging. Each log entry has the following format:\\n\\nField\\n\\nDescription\\n\\nExamp\", \"le\\n\\ntime\\n\\nlevel\\n\\ntype\\n\\nmsg\\n\\nISO8601 formatted timestamp\\n\\n2021-01-10T14:19:31.000Z\\n\\nLevel of the entr\", \"y (debug, info, warn, or error)  info\\n\\nLog Type\\n\\nLog Message\\n\\nlog\\n\\nmetrics server started on :62408/\", \"\\n\\nscope\\n\\nLogging Scope\\n\\ninstance  Hostname where Dapr runs\\n\\ndapr.runtime\\n\\nTSTSRV01\\n\\n111\\n\\nCHAPTER 11 \", \"| The Dapr observability building block\\n\\n\\fField\\n\\nDescription\\n\\nExample\\n\\napp_id\\n\\nDapr App ID\\n\\nver\\n\\nDap\", \"r Runtime Version\\n\\nfinecollectionservice\\n\\n1.0\\n\\nWhen searching through logging entries in a troublesh\", \"ooting scenario, the time and level fields are\\nespecially helpful. The time field orders log entries\", \" so that you can pinpoint specific time periods.\\nWhen troubleshooting, log entries at the debug leve\", \"l provide more information on the behavior of the\\ncode.\\n\\nPlain text versus JSON format\\n\\nBy default, \", \"Dapr emits structured logging in plain-text format. Every log entry is formatted as a string\\ncontain\", \"ing key/value pairs. Here\\u2019s an example of logging in plain text:\\n\\n== DAPR == time=\\\"2021-01-12T16:11:\", \"39.4669323+01:00\\\" level=info msg=\\\"starting Dapr Runtime -\\n- version 1.0 -- commit 196483d\\\" app_id=fi\", \"necollectionservice instance=TSTSRV03\\nscope=dapr.runtime type=log ver=1.0\\n== DAPR == time=\\\"2021-01-1\", \"2T16:11:39.467933+01:00\\\" level=info msg=\\\"log level set to: info\\\"\\napp_id=finecollectionservice instan\", \"ce=TSTSRV03 scope=dapr.runtime type=log ver=1.0\\n== DAPR == time=\\\"2021-01-12T16:11:39.467933+01:00\\\" l\", \"evel=info msg=\\\"metrics server started\\non :62408/\\\" app_id=finecollectionservice instance=TSTSRV03 sco\", \"pe=dapr.metrics type=log\\nver=1.0\\n\\nWhile simple, this format is difficult to parse. If viewing log en\", \"tries with a monitoring tool, you\\u2019ll want\\nto enable JSON formatted logging. With JSON entries, a mon\", \"itoring tool can index and query\\nindividual fields. Here\\u2019s the same log entries in JSON format:\\n\\n{\\\"a\", \"pp_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\":\\n\\\"starting Dapr Runt\", \"ime -- version 1.0 -- commit 196483d\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"time\\\":\\n\\\"2021-01-12T16:11:39.4669323\", \"+01:00\\\", \\\"type\\\": \\\"log\\\", \\\"ver\\\": \\\"1.0\\\"}\\n{\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"l\", \"evel\\\": \\\"info\\\", \\\"msg\\\": \\\"log\\nlevel set to: info\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"202\", \"1-01-\\n12T16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"}\\n{\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTS\", \"RV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\":\\n\\\"metrics server started on :62408/\\\", \\\"scope\\\": \\\"dapr.metrics\\\", \\\"type\\\":\", \" \\\"log\\\", \\\"time\\\": \\\"2021-\\n01-12T16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"}\\n\\nTo enable JSON formatting, you n\", \"eed to configure each Dapr sidecar. In self-hosted mode, you can\\nspecify the flag --log-as-json on t\", \"he command line:\\n\\ndapr run --app-id finecollectionservice --log-level info --log-as-json dotnet run\\n\", \"\\nIn Kubernetes, you can add a dapr.io/log-as-json annotation to each deployment for the\\napplication:\", \"\\n\\nannotations:\\n   dapr.io/enabled: \\\"true\\\"\\n   dapr.io/app-id: \\\"finecollectionservice\\\"\\n   dapr.io/app-\", \"port: \\\"80\\\"\\n   dapr.io/config: \\\"dapr-config\\\"\\n   dapr.io/log-as-json: \\\"true\\\"\\n\\nWhen you install Dapr in\", \" a Kubernetes cluster using Helm, you can enable JSON formatted logging for\\nall the Dapr system serv\", \"ices:\\n\\n112\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fhelm repo add dapr https://dapr.git\", \"hub.io/helm-charts/\\nhelm repo update\\nkubectl create namespace dapr-system\\nhelm install dapr dapr/dap\", \"r --namespace dapr-system --set global.logAsJson=true\\n\\nCollect logs\\n\\nThe logs emitted by Dapr can be\", \" fed into a monitoring back end for analysis. A log collector is a\\ncomponent that collects logs from\", \" a system and sends them to a monitoring back end. A popular log\\ncollector is Fluentd. Check out the\", \" How-To: Set up Fluentd, Elastic search and Kibana in Kubernetes in\\nthe Dapr documentation. This art\", \"icle contains instructions for setting up Fluentd as log collector and\\nthe ELK Stack (Elastic Search\", \" and Kibana) as a monitoring back end.\\n\\nHealth status\\n\\nThe health status of a service provides insig\", \"ht into its availability. Each Dapr sidecar exposes a health\\nAPI that can be used by the hosting env\", \"ironment to determine the health of the sidecar. The API has\\none operation:\\n\\nGET http://localhost:35\", \"00/v1.0/healthz\\n\\nThe operation returns two HTTP status codes:\\n\\n\\u2022\\n\\n\\u2022\\n\\n204: When the sidecar is health\", \"y\\n\\n500: when the sidecar isn\\u2019t healthy\\n\\nWhen running in self-hosted mode, the health API isn\\u2019t autom\", \"atically invoked. You can invoke the API\\nthough from application code or a health monitoring tool.\\n\\n\", \"When running in Kubernetes, the Dapr sidecar-injector automatically configures Kubernetes to use the\", \"\\nhealth API for executing liveness probes and readiness probes.\\n\\nKubernetes uses liveness probes to \", \"determine whether a container is up and running. If a liveness\\nprobe returns a failure code, Kuberne\", \"tes will assume the container is dead and automatically restart it.\\nThis feature increases the overa\", \"ll availability of your application.\\n\\nKubernetes uses readiness probes to determine whether a contai\", \"ner is ready to start accepting traffic.\\nA pod is considered ready when all of its containers are re\", \"ady. Readiness determines whether a\\nKubernetes service can direct traffic to a pod in a load-balanci\", \"ng scenario. Pods that aren\\u2019t ready are\\nautomatically removed from the load-balancer.\\n\\nLiveness and \", \"readiness probes have several configurable parameters. Both are configured in the\\ncontainer spec sec\", \"tion of a pod\\u2019s manifest file. By default, Dapr uses the following configuration for\\neach sidecar co\", \"ntainer:\\n\\nlivenessProbe:\\n      httpGet:\\n        path: v1.0/healthz\\n        port: 3500\\n      initialD\", \"elaySeconds: 5\\n      periodSeconds: 10\\n      timeoutSeconds : 5\\n      failureThreshold : 3\\n\\n113\\n\\nCHA\", \"PTER 11 | The Dapr observability building block\\n\\n\\freadinessProbe:\\n      httpGet:\\n        path: v1.0/\", \"healthz\\n        port: 3500\\n      initialDelaySeconds: 5\\n      periodSeconds: 10\\n      timeoutSeconds\", \" : 5\\n      failureThreshold: 3\\n\\nThe following parameters are available for the probes:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\", \"\\u2022\\n\\n\\u2022\\n\\nThe path specifies the Dapr health API endpoint.\\n\\nThe port specifies the Dapr health API port.\", \"\\n\\nThe initialDelaySecondsspecifies the number of seconds Kubernetes will wait before it starts\\nprobi\", \"ng a container for the first time.\\n\\nThe periodSeconds specifies the number of seconds Kubernetes wil\", \"l wait between each probe.\\n\\nThe timeoutSeconds specifies the number of seconds Kubernetes will wait \", \"on a response from\\nthe API before timing out. A timeout is interpreted as a failure.\\n\\nThe failureThr\", \"esholdspecifies the number of failed status code Kubernetes will accept before\\nconsidering the conta\", \"iner not alive or not ready.\\n\\nDapr dashboard\\n\\nDapr offers a dashboard that presents status informati\", \"on on Dapr applications, components, and\\nconfigurations. Use the Dapr CLI to start the dashboard as \", \"a web-application on the local machine on\\nport 8080:\\n\\ndapr dashboard\\n\\nFor Dapr application running i\", \"n Kubernetes, use the following command:\\n\\ndapr dashboard -k\\n\\nThe dashboard opens with an overview of\", \" all services in your application that have a Dapr sidecar. The\\nfollowing screenshot shows the Dapr \", \"dashboard for the Traffic Control sample application running in\\nKubernetes:\\n\\n:::image type=\\u201ccontent\\u201d\", \" source=\\u201c./media/observability/dapr-dashboard-overview.png\\u201d alt-text=\\u201cDapr\\ndashboard overview\\u201d:::\\n\\nF\", \"igure 10-10. Dapr dashboard overview.\\n\\nThe Dapr dashboard is invaluable when troubleshooting a Dapr \", \"application. It provides information\\nabout Dapr sidecars and system services. You can drill down int\", \"o the configuration of each service,\\nincluding the logging entries.\\n\\nThe dashboard also shows the co\", \"nfigured components (and their configuration) for an application:\\n\\n:::image type=\\u201ccontent\\u201d source=\\u201c.\", \"/media/observability/dapr-dashboard-components.png\\u201d alt-\\ntext=\\u201cDapr dashboard components\\u201d:::\\n\\nFigure\", \" 10-11. Dapr dashboard components.\\n\\n114\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fThere\\u2019\", \"s a large amount of information available through the dashboard. You can discover it by\\nrunning a Da\", \"pr application and browsing the dashboard.\\n\\nCheck out the Dapr dashboard CLI command reference in th\", \"e Dapr docs for more information on the\\nDapr dashboard commands.\\n\\nUse the Dapr .NET SDK\\n\\nThe Dapr .N\", \"ET SDK doesn\\u2019t contain any specific observability features. All observability features are\\noffered a\", \"t the Dapr level.\\n\\nIf you want to emit telemetry from your .NET application code, you should conside\", \"r the\\nOpenTelemetry SDK for .NET. The Open Telemetry project is cross-platform, open source, and ven\", \"dor\\nagnostic. It provides an end-to-end implementation to generate, emit, collect, process, and expo\", \"rt\\ntelemetry data. There\\u2019s a single instrumentation library per language that supports automatic and\", \"\\nmanual instrumentation. Telemetry is published using the Open Telemetry standard. The project has\\nb\", \"road industry support and adoption from cloud providers, vendors, and end users.\\n\\nSample application\", \": Dapr Traffic Control\\n\\nBecause the Traffic Control sample application runs with Dapr, all the telem\", \"etry described in this\\nchapter is available. If you run the application and open the Zipkin web fron\", \"t end, you\\u2019ll see end-to-\\nend tracing. Figure 10-12 shows an example:\\n\\nFigure 10-12. Zipkin end-to-e\", \"nd tracing example.\\n\\nThis trace shows the communication that occurs when a speeding violation has be\", \"en detected:\\n\\n115\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\f1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\n5.\\n\\n6.\\n\\nAn e\", \"xiting vehicle triggers the MQTT input binding that sends a message containing the vehicle\\nlicense n\", \"umber, lane, and timestamp.\\n\\nThe MQTT input binding invokes the TrafficControl service with the mess\", \"age.\\n\\nThe TrafficControl service retrieves the state for the vehicle, appends the entry, and saves t\", \"he\\nupdated vehicle state back to the state store.\\n\\nThe TrafficControl service publishes the speeding\", \" violation using pub/sub to the\\nspeedingviolations topic.\\n\\nThe FineCollection service receives the s\", \"peeding violation using a pub/sub subscription on the\\nspeedingviolations topic.\\n\\nThe FineCollection \", \"service invokes the vehicleinfo endpoint of the VehicleRegistration service\\nusing service invocation\", \".\\n\\n7.\\n\\nThe FineCollection service invokes an output binding for sending the email.\\n\\nClick any trace \", \"line (span) to see more details. If you click on the last line, you\\u2019ll see the sendmail\\nbinding comp\", \"onent invoked to send the driver a violation notice.\\n\\n116\\n\\nCHAPTER 11 | The Dapr observability build\", \"ing block\\n\\n\\fFigure 10-13. Output binding trace details.\\n\\nSummary\\n\\nDetailed observability is critical\", \" to running a distributed system in production.\\n\\nDapr provides different types of telemetry, includi\", \"ng distributed tracing, logging, metrics, and health\\nstatus.\\n\\nDapr only produces telemetry for the D\", \"apr system services and sidecars. Telemetry from your\\napplication code isn\\u2019t automatically included.\", \" You can however use a specific SDK like the\\nOpenTelemetry SDK for .NET to emit telemetry from your \", \"application code.\\n\\n117\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fDapr telemetry is produ\", \"ced in an open-standards based format so that it can be ingested by a large\\nset of available monitor\", \"ing tools. Examples include Zipkin, Azure Application Insights, the ELK Stack,\\nNew Relic, and Grafan\", \"a. See Monitor your application with Dapr in the Dapr documentation for\\ntutorials on how to monitor \", \"your Dapr applications with specific monitoring back ends.\\n\\nYou\\u2019ll need a telemetry scraper that ing\", \"ests telemetry and publishes it to the monitoring back end.\\n\\nDapr can be configured to emit structur\", \"ed logging. Structured logging is favored as it can be indexed\\nby back-end monitoring tools. Indexed\", \" logging enables users to execute rich queries when searching\\nthrough the logging.\\n\\nDapr offers a da\", \"shboard that presents information about the Dapr services and configuration.\\n\\nReferences\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nA\", \"zure Application Insights\\n\\nOpen Telemetry\\n\\nZipkin\\n\\n\\u2022  W3C Trace Context\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\", \"Jaeger\\n\\nNew Relic\\n\\nPrometheus\\n\\nGrafana\\n\\nOpen Telemetry SDK for .NET\\n\\nFluentd\\n\\nELK stack\\n\\nSeq\\n\\nSerilo\", \"g\\n\\n118\\n\\nCHAPTER 11 | The Dapr observability building block\\n\\n\\fCHAPTER  12\\n\\nThe Dapr secrets\\nmanagemen\", \"t building\\nblock\\n\\nEnterprise applications require secrets. Common examples include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nA data\", \"base connection string that contains a username and password.\\n\\nAn API key for calling an external we\", \"b API.\\n\\nA client certificate for authenticating to an external system.\\n\\nSecrets must be carefully ma\", \"naged so that they\\u2019re never disclosed outside of the application.\\n\\nNot long ago, it was popular to s\", \"tore application secrets in a configuration file inside the application\\ncodebase. .NET developers wi\", \"ll fondly recall the web.config file. While simple to implement, integrating\\nsecrets to along with c\", \"ode was far from secure. A common misstep was to include the file when\\npushing to a public GIT repos\", \"itory, exposing the secrets to the world.\\n\\nA widely accepted methodology for constructing modern dis\", \"tributed applications is The Twelve-\\nFactor App. It describes a set of principles and best practices\", \". Its third factor prescribes that\\nconfiguration and secrets be externalized outside of the code bas\", \"e.\\n\\nTo address this concern, the .NET platform includes a Secret Manager feature that stores sensiti\", \"ve\\ndata in a physical folder outside of the project tree. While secrets are outside of source contro\", \"l, this\\nfeature doesn\\u2019t encrypt data. It\\u2019s designed for development purposes only.\\n\\nA more modern an\", \"d secure practice is to isolate secrets in a secrets management tool like Hashicorp\\nVault or Azure K\", \"ey Vault. These tools enable you to store secrets externally, vary credentials across\\nenvironments, \", \"and reference them from application code. However, each tool has its complexities and\\nlearning curve\", \".\\n\\nDapr offers a building block that simplifies managing secrets.\\n\\nWhat it solves\\n\\nThe Dapr secrets \", \"management building block abstracts away the complexity of working with secrets\\nand secret managemen\", \"t tools.\\n\\n119\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\f\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nIt hides the un\", \"derlying plumbing through a unified interface.\\n\\nIt supports various pluggable secret store component\", \"s, which can vary between development\\nand production.\\n\\nApplications don\\u2019t require direct dependencie\", \"s on secret store libraries.\\n\\nDevelopers don\\u2019t require detailed knowledge of each secret store.\\n\\nDap\", \"r handles all of the above concerns.\\n\\nAccess to the secrets is secured through authentication and au\", \"thorization. Only an application with\\nsufficient rights can access secrets. Applications running in \", \"Kubernetes can also use its built-in secrets\\nmanagement mechanism.\\n\\nHow it works\\n\\nApplications use t\", \"he secrets management building block in two ways:\\n\\n\\u2022\\n\\n\\u2022\\n\\nRetrieve a secret directly from the buildin\", \"g block.\\n\\nReference a secret indirectly from a Dapr component configuration.\\n\\nRetrieving secrets dir\", \"ectly is covered first. Referencing a secret from a Dapr component configuration\\nfile is addressed i\", \"n a later section.\\n\\nThe application interacts with a Dapr sidecar when using the secrets management \", \"building block. The\\nsidecar exposes the secrets API. The API can be called with either HTTP or gRPC.\", \" Use the following\\nURL to call the HTTP API:\\n\\nhttp://localhost:<dapr-port>/v1.0/secrets/<store-name>\", \"/<name>?<metadata>\\n\\nThe URL contains the following segments:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n<dapr-port> specifies the \", \"port number upon which the Dapr sidecar is listening.\\n\\n<store-name> specifies the name of the Dapr s\", \"ecret store.\\n\\n<name> specifies the name of the secret to retrieve.\\n\\n<metadata> provides additional i\", \"nformation for the secret. This segment is optional and\\nmetadata properties differ per secret store.\", \" For more information on metadata properties, see\\nthe [secrets API reference]INTERNAL-LINK:(Secrets \", \"API reference | Dapr Docs).\\n\\n[!NOTE] The above URL represents the native Dapr API call available to \", \"any development platform that\\nsupports HTTP or gRPC. Popular platforms like .NET, Java, and Go have \", \"their own custom APIs.\\n\\nThe JSON response contains the key and value of the secret.\\n\\nFigure 11-1 sho\", \"ws how Dapr handles a request for the secrets API:\\n\\n120\\n\\nCHAPTER 12 | The Dapr secrets management bu\", \"ilding block\\n\\n\\fFigure 11-1. Retrieving a secret with the Dapr secrets API.\\n\\n1.\\n\\n2.\\n\\n3.\\n\\nThe service \", \"calls the Dapr secrets API, along with the name of the secret store, and secret to\\nretrieve.\\n\\nThe Da\", \"pr sidecar retrieves the specified secret from the secret store.\\n\\nThe Dapr sidecar returns the secre\", \"t information back to the service.\\n\\nSome secret stores support storing multiple key/value pairs in a\", \" single secret. For those scenarios, the\\nresponse would contain multiple key/value pairs in a single\", \" JSON response as in the following\\nexample:\\n\\nGET http://localhost:3500/v1.0/secrets/secret-store/int\", \"erestRates?metadata.version_id=3\\n\\n{\\n  \\\"tier1-percentage\\\": \\\"2.5\\\",\\n  \\\"tier2-percentage\\\": \\\"3.8\\\",\\n  \\\"tie\", \"r3-percentage\\\": \\\"5.1\\\"\\n}\\n\\nThe Dapr secrets API also offers an operation to retrieve all the secrets t\", \"he application has access to:\\n\\nhttp://localhost:<dapr-port>/v1.0/secrets/<store-name>/bulk\\n\\nUse the \", \"Dapr .NET SDK\\n\\nFor .NET developers, the Dapr .NET SDK streamlines Dapr secret management. Consider t\", \"he\\nDaprClient.GetSecretAsync method. It enables you to retrieve a secret directly from any Dapr secr\", \"et\\nstore with minimal effort. Here\\u2019s an example of fetching a connection string secret for a SQL Ser\", \"ver\\ndatabase:\\n\\n121\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\fvar metadata = new Dic\", \"tionary<string, string> { [\\\"version_id\\\"] = \\\"3\\\" };\\nDictionary<string, string> secrets = await daprCli\", \"ent.GetSecretAsync(\\\"secret-store\\\",\\n\\\"eshopsecrets\\\", metadata);\\nstring connectionString = secrets[\\\"cus\", \"tomerdb\\\"];\\n\\nArguments for the GetSecretAsync method include:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe name of the Dapr secret s\", \"tore component (\\u2018secret-store\\u2019)\\n\\nThe secret to retrieve (\\u2018eshopsecrets\\u2019)\\n\\nOptional metadata key/valu\", \"e pairs (\\u2018version_id=3\\u2019)\\n\\nThe method responds with a dictionary object as a secret can contain multi\", \"ple key/value pairs. In the\\nexample above, the secret named customerdb is referenced from the collec\", \"tion to return a connection\\nstring.\\n\\nThe Dapr .NET SDK also features a .NET configuration provider. \", \"It loads specified secrets into the\\nunderlying .NET configuration API. The running application can t\", \"hen reference secrets from the\\nIConfiguration dictionary that is registered in ASP.NET Core dependen\", \"cy injection.\\n\\nThe secrets configuration provider is available from the Dapr.Extensions.Configuratio\", \"n NuGet\\npackage. The provider can be registered in the Program.cs of an ASP.NET Web API application:\", \"\\n\\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder.WebHost.ConfigureAppConfiguration(config\", \" =>\\n{\\n    var daprClient = new DaprClientBuilder().Build();\\n    var secretDescriptors = new List<Dap\", \"rSecretDescriptor>\\n    {\\n        new DaprSecretDescriptor(\\\"eshopsecrets\\\")\\n    };\\n    config.AddDaprS\", \"ecretStore(\\\"secret-store\\\", secretDescriptors, daprClient);\\n});\\n\\nThe above example loads the eshopsec\", \"rets secrets collection into the .NET configuration system at\\nstartup. Registering the provider requ\", \"ires an instance of DaprClient to invoke the secrets API on the\\nDapr sidecar. The other arguments in\", \"clude the name of the secret store and a DaprSecretDescriptor\\nobject with the name of the secret.\\n\\nO\", \"nce loaded, you can retrieve secrets directly from application code:\\n\\npublic void GetCustomer(IConfi\", \"guration config)\\n{\\n    var connectionString = config[\\\"eshopsecrets\\\"][\\\"customerdb\\\"];\\n}\\n\\nSecret store \", \"components\\n\\nThe secrets management building block supports several secret store components. At the t\", \"ime of\\nwriting, the following secret stores are available:\\n\\nAlibabaCloud OOS Parameter Store\\n\\nAWS Se\", \"crets Manager\\n\\nAWS SSM Parameter Store\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n122\\n\\nCHAPTER 12 | The Dapr secrets management build\", \"ing block\\n\\n\\f\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nAzure Key Vault\\n\\nGCP Secret Manager\\n\\nHashiCorp Vault\\n\\nKubernetes secre\", \"ts\\n\\nLocal environment variables\\n\\nLocal file\\n\\nImportant\\n\\nThe local environment variables and file com\", \"ponents are designed for development workloads only.\\n\\nThe following sections show how to configure a\", \" secret store.\\n\\nConfiguration\\n\\nYou configure a secret store using a Dapr component configuration fil\", \"e. The typical structure of the\\nfile is shown below:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nm\", \"etadata:\\n  name: [component name]\\n  namespace: [namespace]\\nspec:\\n  type: secretstores.[secret store \", \"type]\\n  version: [secret store version]\\n  metadata:\\n  - name: [property name]\\n    value: [property v\", \"alue]\\n\\nAll Dapr component configuration files require a name along with an optional namespace value.\", \"\\nAdditionally, the type field in the spec section specifies the type of secret store component. The\\n\", \"properties in the metadata section differ per secret store.\\n\\nIndirectly consume Dapr secrets\\n\\nAs men\", \"tioned earlier in this chapter, applications can also consume secrets by referencing them in\\ncompone\", \"nt configuration files. Consider a state management component that uses Redis cache for\\nstoring stat\", \"e:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: eshop-basket-statestore\\n  namespa\", \"ce: eshop\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    value: localho\", \"st:6379\\n  - name: redisPassword\\n    value: e$h0p0nD@pr\\n\\n123\\n\\nCHAPTER 12 | The Dapr secrets managemen\", \"t building block\\n\\n\\fThe above configuration file contains a clear-text password for connecting to the\", \" Redis server.\\nHardcoded passwords are always a bad idea. Pushing this configuration file to a publi\", \"c repository\\nwould expose the password. Storing the password in a secret store would dramatically im\", \"prove this\\nscenario.\\n\\nThe following examples demonstrate this using several different secret stores.\", \"\\n\\nLocal file\\n\\nThe local file component is designed for development scenarios. It stores secrets on t\", \"he local\\nfilesystem inside a JSON file. Here\\u2019s an example named eshop-secrets.json. It contains a si\", \"ngle\\nsecret - a password for Redis:\\n\\n{\\n  \\\"eShopRedisPassword\\\": \\\"e$h0p0nD@pr\\\"\\n}\\n\\nYou place this file \", \"in a components folder that you specify when running the Dapr application.\\n\\nThe following secret sto\", \"re configuration file consumes the JSON file as a secret store. It\\u2019s also placed\\nin the components f\", \"older:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: eshop-local-secret-store\\n  na\", \"mespace: eshop\\nspec:\\n  type: secretstores.local.file\\n  version: v1\\n  metadata:\\n  - name: secretsFile\", \"\\n    value: ./components/eshop-secrets.json\\n  - name: nestedSeparator\\n    value: \\\":\\\"\\n\\nThe component \", \"type is secretstore.local.file. The secretsFile metadata element specifies the\\npath to the secrets f\", \"ile.\\n\\nImportant\\n\\nThe path to a secrets file can be a absolute or relative path. The relative path is\", \" based on the folder in\\nwhich the application starts. In the example, the components folder is a sub\", \"-folder of the directory that\\ncontains the .NET application.\\n\\nFrom the application folder, start the\", \" Dapr application specifying the components path as a command-\\nline argument:\\n\\ndapr run --app-id bas\", \"ket-api --components-path ./components dotnet run\\n\\n124\\n\\nCHAPTER 12 | The Dapr secrets management bui\", \"lding block\\n\\n\\fNote\\n\\nThis above example applies to running Dapr in self-hosted mode. For Kubernetes h\", \"osting, consider\\nusing volume mounts.\\n\\nThe nestedSeparator in a Dapr configuration file specifies a \", \"character to flatten a JSON hierarchy.\\nConsider the following snippet:\\n\\n{\\n    \\\"redisPassword\\\": \\\"some\", \" password\\\",\\n    \\\"connectionStrings\\\": {\\n        \\\"customerdb\\\": \\\"some connection string\\\",\\n        \\\"prod\", \"uctdb\\\": \\\"some connection string\\\"\\n    }\\n}\\n\\nUsing a colon as a separator, you can retrieve the custome\", \"rdb connection-string using the key\\nconnectionStrings:customerdb.\\n\\nNote\\n\\nThe colon : is the default \", \"separator value.\\n\\nIn the next example, a state management configuration file references the local se\", \"cret store\\ncomponent to obtain the password for connecting to the Redis server:\\n\\napiVersion: dapr.io\", \"/v1alpha1\\nkind: Component\\nmetadata:\\n  name: eshop-basket-statestore\\n  namespace: eshop\\nspec:\\n  type:\", \" state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    value: localhost:6379\\n  - name: redis\", \"Password\\n    secretKeyRef:\\n      name: eShopRedisPassword\\n      key: eShopRedisPassword\\nauth:\\n  secr\", \"etStore: eshop-local-secret-store\\n\\nThe secretKeyRef element references the secret containing the pas\", \"sword. It replaces the earlier clear-\\ntext value. The secret name and the key name, eShopRedisPasswo\", \"rd, reference the secret. The name\\nof the secret management component eshop-local-secret-store is fo\", \"und in the auth metadata\\nelement.\\n\\nYou might wonder why eShopRedisPassword is identical for both the\", \" name and key in the secret\\nreference. In the local file secret store, secrets aren\\u2019t identified wit\", \"h a separate name. The scenario will\\nbe different in the next example using Kubernetes secrets.\\n\\n125\", \"\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\fKubernetes secret\\n\\nThis second example f\", \"ocuses on a Dapr application running in Kubernetes. It uses the standard secrets\\nmechanism that Kube\", \"rnetes offers. Use the Kubernetes CLI (kubectl) to create a secret named eshop-\\nredis-secret that co\", \"ntains the password:\\n\\nkubectl create secret generic eshopsecrets --from-literal=redisPassword=e$h0p0\", \"nD@pr -n\\neshop\\n\\nOnce created, you can reference the secret in the component configuration file for s\", \"tate management:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: eshop-basket-states\", \"tore\\n  namespace: eshop\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    \", \"value: redis:6379\\n  - name: redisPassword\\n    secretKeyRef:\\n      name: eshopsecrets\\n      key: redi\", \"sPassword\\nauth:\\n  secretStore: kubernetes\\n\\nThe secretKeyRef element specifies the name of the Kubern\", \"etes secret and the secret\\u2019s key,\\neshopsecrets, and redisPassword respectively. The auth metadata se\", \"ction instructs Dapr to use the\\nKubernetes secrets management component.\\n\\nNote\\n\\nAuth is the default \", \"value when using Kubernetes secrets and can be omitted.\\n\\nIn a production setting, secrets are typica\", \"lly created as part of an automated CI/CD pipeline. Doing so\\nensures only people with sufficient per\", \"missions can access and change the secrets. Developers create\\nconfiguration files without knowing th\", \"e actual value of the secrets.\\n\\nAzure Key Vault\\n\\nThe next example is geared toward a real-world prod\", \"uction scenario. It uses Azure Key Vault as the\\nsecret store. Azure Key Vault is a managed Azure ser\", \"vice that enables secrets to be stored securely in\\nthe cloud.\\n\\nFor this example to work, the followi\", \"ng prerequisites must be satisfied:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n126\\n\\nYou\\u2019ve secured administrative access to an Azure \", \"subscription.\\n\\nYou\\u2019ve provisioned an Azure Key Vault named eshopkv that holds a secret named\\nredisPa\", \"ssword that contains the password for connecting to the Redis server.\\n\\nYou\\u2019ve created service princi\", \"pal in Azure Active Directory.\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\f\\u2022\\n\\nYou\\u2019ve \", \"installed an X509 certificate for this service principal (containing both the public and\\nprivate key\", \") on the local filesystem.\\n\\nNote\\n\\nA service principal is an identity that can be used by an applicat\", \"ion to authenticate an Azure service.\\nThe service principal uses a X509 certificate. The application\", \" uses this certificate as a credential to\\nauthenticate itself.\\n\\nThe Dapr Azure Key Vault secret stor\", \"e documentation provides step-by-step instructions to create\\nand configure a Key Vault environment.\\n\", \"\\nUse Key Vault when running in self-hosted mode\\n\\nUsing Azure Key Vault in Dapr self-hosted mode requ\", \"ires the following component configuration file:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetad\", \"ata:\\n  name: eshop-azurekv-secret-store\\n  namespace: eshop\\nspec:\\n  type: secretstores.azure.keyvault\", \"\\n  version: v1\\n  metadata:\\n  - name: vaultName\\n    value: eshopkv\\n  - name: spnTenantId\\n    value: \\\"\", \"619926af-a7c3-4e95-93ed-4ecc4e3e652b\\\"\\n  - name: spnClientId\\n    value: \\\"6cf48032-6c38-43be-9d6f-2a43\", \"ce736b09\\\"\\n  - name: spnCertificateFile\\n    value : \\\"azurekv-spn-cert.pfx\\\"\\n\\nThe secret store type is \", \"secretstores.azure.keyvault. The metadata element provides access to the\\nKey Vault with the followin\", \"g properties:\\n\\nThe vaultName contains the name of the Azure Key Vault.\\n\\nThe spnTenantId contains the\", \" tenant ID of the service principal used to authenticate against the\\nKey Vault.\\n\\nThe spnClientId con\", \"tains the app ID of the service principal used to authenticate against the\\nKey Vault.\\n\\nThe spnCertif\", \"icateFile contains the path to the certificate file for the service principal to\\nauthenticate agains\", \"t the Key Vault.\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nTip\\n\\nYou can copy the service principal information from the Azure por\", \"tal or Azure CLI .\\n\\nNow the application can retrieve the Redis password from the Azure Key Vault.\\n\\n1\", \"27\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\fUse Key Vault when running on Kubernet\", \"es\\n\\nConsuming Azure Key Vault with Dapr and Kubernetes also requires a service principal to authenti\", \"cate\\nagainst the Azure Key Vault.\\n\\nFirst, create a Kubernetes secret that contains a certificate fil\", \"e using the kubectl CLI tool:\\n\\nkubectl create secret generic [k8s_spn_secret_name] --from-\\nfile=[pfx\", \"_certificate_file_local_path] -n eshop\\n\\nThe command requires two command-line arguments:\\n\\n\\u2022\\n\\n\\u2022\\n\\n[k8s\", \"_spn_secret_name] is the secret name in Kubernetes secret store.\\n\\n[pfx_certificate_file_local_path] \", \"is the path of X509 certificate file.\\n\\nOnce created, you can reference the Kubernetes secret in the \", \"secret store component configuration\\nfile:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n \", \" name: eshop-azurekv-secret-store\\n  namespace: eshop\\nspec:\\n  type: secretstores.azure.keyvault\\n  ver\", \"sion: v1\\n  metadata:\\n  - name: vaultName\\n    value: [your_keyvault_name]\\n  - name: spnTenantId\\n    v\", \"alue: \\\"619926af-a7c3-4e95-93ed-4ecc4e3e652b\\\"\\n  - name: spnClientId\\n    value: \\\"6cf48032-6c38-43be-9d\", \"6f-2a43ce736b09\\\"\\n  - name: spnCertificate\\n    secretKeyRef:\\n      name: [k8s_spn_secret_name]\\n      \", \"key: [pfx_certificate_file_local_name]\\nauth:\\n    secretStore: kubernetes\\n\\nAt this point, an applicat\", \"ion running in Kubernetes can retrieve the Redis password from the Azure\\nKey Vault.\\n\\nImportant\\n\\nIt\\u2019s\", \" critical to keep the X509 certificate file for the service principal in a safe place. It\\u2019s best to \", \"place it in\\na well-known folder outside the source-code repository. The configuration file can then \", \"reference the\\ncertificate file from this well-known folder. On a local development machine, you\\u2019re r\", \"esponsible for\\ncopying the certificate to the folder. For automated deployments, the pipeline will c\", \"opy the certificate\\nto the machine where the application is deployed. It\\u2019s a best practice to use a \", \"different service\\nprincipal per environment. Doing so prevents the service principal from a DEVELOPM\", \"ENT environment\\nto access secrets in a PRODUCTION environment.\\n\\n128\\n\\nCHAPTER 12 | The Dapr secrets m\", \"anagement building block\\n\\n\\fWhen running in Azure Kubernetes Service (AKS), it\\u2019s preferable to use an\", \" Azure Managed Identity for\\nauthenticating against Azure Key Vault. Managed identities are outside o\", \"f the scope of this book, but\\nexplained in the Azure Key Vault with managed identities documentation\", \".\\n\\nScope secrets\\n\\nSecret scopes allow you to control which secrets your application can access. You \", \"configure scopes in\\na Dapr sidecar configuration file. The Dapr configuration documentation provides\", \" instructions for\\nscoping secrets.\\n\\nHere\\u2019s an example of a Dapr sidecar configuration file that cont\", \"ains secret scopes:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Configuration\\nmetadata:\\n  name: dapr-config\\n\", \"  namespace: eshop\\nspec:\\n  tracing:\\n    samplingRate: \\\"1\\\"\\n  secrets:\\n    scopes:\\n      - storeName: \", \"eshop-azurekv-secret-store\\n        defaultAccess: allow\\n        deniedSecrets: [\\\"redisPassword\\\", \\\"ap\", \"iKey\\\"]\\n\\nYou specify scopes per secret store. In the above example, the secret store is named eshop-a\", \"zurekv-\\nsecret-store. You configure access to secrets using the following properties:\\n\\nProperty\\n\\nVal\", \"ue\\n\\nDescription\\n\\ndefaultAccess\\n\\nallow or\\ndeny\\n\\nAllows or denies access to all secrets in the specifi\", \"ed secret store.\\nThis property is optional with a default value of allow.\\n\\nallowedSecrets  List of\\n\\n\", \"secret keys\\n\\nSecrets specified in the array will be accessible. This property is\\noptional.\\n\\ndeniedSe\", \"crets\\n\\nList of\\nsecret keys\\n\\nSecrets specified in the array will NOT be accessible. This property is\\n\", \"optional.\\n\\nThe allowedSecrets and deniedSecrets properties take precedence over the defaultAccess\\npr\", \"operty. Imagine specifying defaultAccess: allowed and an allowedSecrets list. In this case, only\\nthe\", \" secrets in the allowedSecrets list would be accessible by the application.\\n\\nSample application: Dap\", \"r Traffic Control\\n\\nIn Dapr Traffic Control sample app, the secrets management building block is used\", \" in several places.\\nSecrets are retrieved from code and referenced by Dapr component configuration f\", \"iles. Figure 10-2\\nshows the conceptual architecture of the Dapr Traffic Control sample application. \", \"The Dapr secrets\\nmanagement building block is used in flows marked with number 6 in the diagram:\\n\\n12\", \"9\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\fFigure 10-2. Conceptual architecture of\", \" the Dapr Traffic Control sample application.\\n\\nThe FineCollection service uses an SMTP output bindin\", \"g for sending emails (see the Bindings chapter).\\nThe email component file consumes the secrets manag\", \"ement building block to retrieve credentials to\\nconnect to the SMTP server. To calculate the fine fo\", \"r a speeding violation, the service uses a fictitious\\nFineCalculator component that requires a licen\", \"se key. It retrieves this license key from the secrets\\nmanagement building block.\\n\\nThe TrafficContro\", \"l service stores vehicle information in a Redis state store (see the State management\\nchapter). It u\", \"ses the secrets management building block for retrieving credentials to connect to the\\nRedis server.\", \"\\n\\nBecause the Traffic Control sample application can run in self-hosted mode or in Kubernetes, there\", \" are\\ntwo ways for specifying secrets:\\n\\nA local JSON file\\n\\nA Kubernetes secret\\n\\n\\u2022\\n\\n\\u2022\\n\\n130\\n\\nCHAPTER 12\", \" | The Dapr secrets management building block\\n\\n\\fSecrets\\n\\nExamine the secrets-file.yaml component con\", \"figuration file in the dapr/components folder:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadat\", \"a:\\n  name: trafficcontrol-secrets\\n  namespace: dapr-trafficcontrol\\nspec:\\n  type: secretstores.local.\", \"file\\n  version: v1\\n  metadata:\\n  - name: secretsFile\\n    value: ../dapr/components/secrets.json\\n  - \", \"name: nestedSeparator\\n    value: \\\".\\\"\\nscopes:\\n  - trafficcontrolservice\\n  - finecollectionservice\\n\\nTh\", \"e file describes a secrets management component entitled trafficcontrol-secrets. The type\\nelement is\", \" set to local.file and the secretsFile to ../dapr/components/secrets.json. For self-\\nhosted mode, us\", \"e a Local file component. The path must be relatively specified from the folder from\\nwhich the servi\", \"ce starts. The secrets file contains a JSON representation of the secrets:\\n\\n{\\n    \\\"state\\\":{\\n        \", \"\\\"redisPassword\\\": \\\"\\\"\\n    },\\n    \\\"smtp\\\":{\\n        \\\"user\\\": \\\"_username\\\",\\n        \\\"password\\\": \\\"_password\\\"\", \"\\n    },\\n    \\\"finecalculator\\\":{\\n        \\\"licensekey\\\": \\\"HX783-K2L7V-CRJ4A-5PN1G\\\"\\n    }\\n}\\n\\nIn the sampl\", \"e application the Redis server is used without a password. To connect to the SMTP server,\\nthe creden\", \"tials are _username and _password. The license key for the FineCalculator license key is a\\nrandomly \", \"generated string.\\n\\nWhile secrets are stored at nested levels, the secrets management building block \", \"flattens this\\nhierarchy when the file is read. It uses a period as a level separator (as specified i\", \"n the\\nnestedSeparator field in the component configuration file). This construct enables you to refe\", \"rence\\nsecrets with a flattened name, for example: smtp.user.\\n\\nWhen running in Kubernetes, the secret\", \"s are specified using the built-in Kubernetes secrets store.\\nExamine the following secrets.yaml Kube\", \"rnetes manifest file in the k8s folder:\\n\\napiVersion: v1\\nkind: Secret\\nmetadata:\\n  name: trafficcontro\", \"l-secrets\\n  namespace: dapr-trafficcontrol\\n\\n131\\n\\nCHAPTER 12 | The Dapr secrets management building b\", \"lock\\n\\n\\ftype: Opaque\\ndata:\\n  smtp.user: X3VzZXJuYW1l\\n  smtp.password: X3Bhc3N3b3Jk\\n  finecalculator.l\", \"icensekey: SFg3ODMtSzJMN1YtQ1JKNEEtNVBOMUc=\\n\\nThe component is also named trafficcontrol-secrets. Sec\", \"rets are stored as Base64 encoded\\nstrings.\\n\\nImportant\\n\\nBase64 representations encode, but do not enc\", \"rypt data. Base64 isn\\u2019t secure for production scenarios.\\n\\nThe following paragraphs describe how secr\", \"ets are used in the Traffic Control sample application.\\n\\nSMTP server credentials\\n\\nExamine the email.\", \"yaml component configuration file located in the dapr/components folder:\\n\\napiVersion: dapr.io/v1alph\", \"a1\\nkind: Component\\nmetadata:\\n  name: sendmail\\n  namespace: dapr-trafficcontrol\\nspec:\\n  type: binding\", \"s.smtp\\n  version: v1\\n  metadata:\\n  - name: host\\n    value: localhost\\n  - name: port\\n    value: 4025\\n\", \"  - name: user\\n    secretKeyRef:\\n      name: smtp.user\\n      key: smtp.user\\n  - name: password\\n    s\", \"ecretKeyRef:\\n      name: smtp.password\\n      key: smtp.password\\n  - name: skipTLSVerify\\n    value: t\", \"rue\\nauth:\\n  secretStore: trafficcontrol-secrets\\nscopes:\\n  - finecollectionservice\\n\\nThe auth section \", \"references the secrets management component named trafficcontrol-secrets.\\nThe user and password entr\", \"ies in the binding metadata reference the secrets: smtp.user and\\nsmtp.password respectively.\\n\\nWhen r\", \"unning in Kubernetes, the built-in Kubernetes secrets store is used. The email.yaml manifest\\nfile fo\", \"und in the k8s folder references the Kubernetes secret for retrieving the credentials for\\nconnecting\", \" to the smtp server:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\n\\n132\\n\\nCHAPTER 12 | The Dapr secre\", \"ts management building block\\n\\n\\fmetadata:\\n  name: sendmail\\n  namespace: dapr-trafficcontrol\\nspec:\\n  t\", \"ype: bindings.smtp\\n  version: v1\\n  metadata:\\n  - name: host\\n    value: mailserver\\n  - name: port\\n   \", \" value: 25\\n  - name: user\\n    secretKeyRef:\\n      name: trafficcontrol-secrets\\n      key: smtp.user\\n\", \"  - name: password\\n    secretKeyRef:\\n      name: trafficcontrol-secrets\\n      key: smtp.password\\n  -\", \" name: skipTLSVerify\\n    value: true\\nscopes:\\n  - finecollectionservice\\n\\nUnlike the local secrets sto\", \"re, the Kubernetes store doesn\\u2019t explicitly specify a secrets management\\ncomponent to use with the a\", \"uth section. Instead, the default is the built-in Kubernetes secrets store.\\n\\nRedis server credential\", \"s\\n\\nNext, examine the statestore.yaml component configuration file in the dapr/components folder:\\n\\nap\", \"iVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: statestore\\n  namespace: dapr-trafficcon\", \"trol\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    value: localhost:63\", \"79\\n  - name: redisPassword\\n    secretKeyRef:\\n      name: state.redisPassword\\n      key: state.redisP\", \"assword\\n  - name: actorStateStore\\n    value: \\\"true\\\"\\nauth:\\n  secretStore: trafficcontrol-secrets\\nscop\", \"es:\\n  - trafficcontrolservice\\n\\nOnce again, the auth section references the secrets management compon\", \"ent named\\ntrafficcontrol-secrets. The redisPassword entries in the binding metadata reference the se\", \"cret\\nstate.redisPassword.\\n\\n133\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\fFineCalcul\", \"ator component license key\\n\\nThe FineCollection service uses a component that calculates the fine bas\", \"ed on the information of a\\nspeeding violation. This component is implemented as a domain service and\", \" is abstracted by the\\nIFineCalculator interface:\\n\\npublic interface IFineCalculator\\n{\\n    public int \", \"CalculateFine(string licenseKey, int violationInKmh);\\n}\\n\\nThe CalculateFine method expects a string c\", \"ontaining a licenseKey as its first argument. This key\\nunlocks the third-party component used by the\", \" implementation. To keep the example simple, the\\nimplementation hard-codes a series of if statements\", \". You can find the implementation in the\\nHardCodedFineCalculator class in the DomainsServices folder\", \":\\n\\n    public class HardCodedFineCalculator : IFineCalculator\\n    {\\n        public int CalculateFine\", \"(string licenseKey, int violationInKmh)\\n        {\\n            if (licenseKey != \\\"HX783-K2L7V-CRJ4A-5\", \"PN1G\\\")\\n            {\\n                throw new InvalidOperationException(\\\"Invalid license-key specif\", \"ied.\\\");\\n            }\\n\\n            int fine = 9; // default administration fee\\n            if (viola\", \"tionInKmh < 5 )\\n            {\\n                fine += 18;\\n            }\\n            else if (violati\", \"onInKmh >= 5 && violationInKmh < 10 )\\n            {\\n                fine += 31;\\n            }\\n\\n     \", \"       // ...\\n\\n            else if (violationInKmh == 35)\\n            {\\n                fine += 372;\", \"\\n            }\\n            else\\n            {\\n                // violation above 35 KMh will be dete\", \"rmined by the prosecutor\\n                return 0;\\n            }\\n\\n            return fine;\\n        }\", \"\\n    }\\n\\nThe implementation simulates a check on the licenseKey that is passed in. The\\nCollectionCont\", \"roller of the FineCollection service must pass in the correct license key argument\\nwhen calling the \", \"CalculateFine method. It retrieves the license key from the Dapr secrets\\nmanagement building block t\", \"hat is exposed by the Dapr client in the Dapr SDK for .NET. If you\\nexamine the constructor of the Co\", \"llectionController, you can see the call:\\n\\n134\\n\\nCHAPTER 12 | The Dapr secrets management building bl\", \"ock\\n\\n\\f// set finecalculator component license-key\\nif (_fineCalculatorLicenseKey == null)\\n{\\n    bool \", \"runningInK8s =\\nConvert.ToBoolean(Environment.GetEnvironmentVariable(\\\"DOTNET_RUNNING_IN_CONTAINER\\\") ?\", \"?\\n\\\"false\\\");\\n    var metadata = new Dictionary<string, string> { { \\\"namespace\\\", \\\"dapr-trafficcontrol\\\"\", \" }\\n};\\n    if (runningInK8s)\\n    {\\n        var k8sSecrets = daprClient.GetSecretAsync(\\n            \\\"k\", \"ubernetes\\\", \\\"trafficcontrol-secrets\\\", metadata).Result;\\n        _fineCalculatorLicenseKey = k8sSecre\", \"ts[\\\"finecalculator.licensekey\\\"];\\n    }\\n    else\\n    {\\n        var secrets = daprClient.GetSecretAsyn\", \"c(\\n            \\\"trafficcontrol-secrets\\\", \\\"finecalculator.licensekey\\\", metadata).Result;\\n        _fin\", \"eCalculatorLicenseKey = secrets[\\\"finecalculator.licensekey\\\"];\\n    }\\n}\\n\\nThe code determines whether t\", \"he service is running in Kubernetes or self-hosted mode. This check is\\nnecessary because a different\", \" secrets management component must be used for each situation. The\\nfirst argument of the GetSecretAs\", \"ync method is the name of the Dapr component. The second\\nargument is the name of the secret. The met\", \"adata passed in as the third argument specifies the\\nnamespace that contains the secret. The value of\", \" the finecalculator.licensekey secret is stored in\\na private field for later use.\\n\\nUsing Dapr secret\", \"s management offers several benefits:\\n\\n1.  No sensitive information is stored in code or application\", \" configuration files.\\n\\n2.  No need to learn any new API for interacting with a secrets store.\\n\\nSumma\", \"ry\\n\\nThe Dapr secrets management building block provides capabilities for storing and retrieving sens\", \"itive\\nconfiguration settings like passwords and connection-strings. It keeps secrets private and pre\", \"vents\\nthem from being accidentally disclosed.\\n\\nThe building block supports several different secret \", \"stores and hides their complexity with the Dapr\\nsecrets API.\\n\\nThe Dapr .NET SDK provides a DaprClien\", \"t object to retrieve secrets. It also includes a .NET\\nconfiguration provider that adds secrets to th\", \"e .NET configuration system. Once loaded, you can\\nconsume these secrets in your .NET code.\\n\\nYou can \", \"use secret scopes to control access to specific secrets.\\n\\nReferences\\n\\n\\u2022\\n\\nBeyond the Twelve-Factor Ap\", \"plication\\n\\n135\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\f\\u2022\\n\\nDapr supported secret s\", \"tores\\n\\n136\\n\\nCHAPTER 12 | The Dapr secrets management building block\\n\\n\\fCHAPTER  13\\n\\nDapr reference ap\", \"plication\\n\\nOver the course of this book, you\\u2019ve learned about the foundational benefits of Dapr. You\", \" saw how\\nDapr can help you and your team construct distributed applications while reducing architect\", \"ural and\\noperational complexity. Along the way, you\\u2019ve had the opportunity to build some small Dapr \", \"apps.\\nNow, it\\u2019s time to explore how a more complex application can benefit from Dapr.\\n\\nBut, first a \", \"little history.\\n\\neShopOnContainers\\n\\nSeveral years ago, Microsoft, in partnership with leading commun\", \"ity experts, released a popular\\nguidance book, entitled .NET Microservices for Containerized .NET Ap\", \"plications. Figure 12-1 shows the\\nbook:\\n\\nFigure 12-1. .NET Microservices: Architecture for Container\", \"ized .NET Applications.\\n\\nThe book dove deep into the principles, patterns, and best practices for bu\", \"ilding distributed\\napplications. It included a full-featured microservice reference application that\", \" showcased the\\narchitectural concepts. Entitled, eShopOnContainers, the application hosts an e-Comme\", \"rce storefront\\nthat sells various items, including clothing and coffee mugs. Built in .NET, the appl\", \"ication is cross-\\nplatform and can run in either Linux or Windows containers. Figure 12-2 shows the \", \"original eShop\\narchitecture.\\n\\n137\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fFigure 12-2. Original S\", \"hopOnContainers reference application.\\n\\nAs you can see, eShopOnContainers includes many moving parts\", \":\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\nThree different frontend clients.\\n\\nAn application gateway to abstract backend ser\", \"vices from the frontend.\\n\\nSeveral backend core microservices.\\n\\nAn event bus component that enables a\", \"synchronous pub/sub messaging.\\n\\nThe eShopOnContainers reference application has been widely accepted\", \" across the .NET community\\nand used to model many large commercial microservice applications.\\n\\neShop\", \"OnDapr\\n\\nAn updated version of eShop accompanies this book. It\\u2019s called eShopOnDapr. The update evolv\", \"es\\nthe earlier eShopOnContainers application by integrating Dapr building blocks. Figure 12-3 shows \", \"the\\nnew solution architecture:\\n\\n[eShopOnDapr reference application architecture](#g\\ufffd\\ufffd\\ufffdr&\\ufffd<\\ufffd\\ufffdp\\ufffd\\ufffdr\\ufffdm\\u0433z\", \"\\ufffd!c(*\\ufffd-\\n\\u03ce\\ufffd9\\ufffd\\ufffd\\ufffd\\ufffd>4)\\n\\nFigure 12-3. eShopOnDapr reference application architecture.\\n\\nWhile eShopOnDapr \", \"focuses on Dapr, the architecture has also been streamlined and simplified.\\n\\n1.\\n\\n2.\\n\\n138\\n\\nA Single P\", \"age Application running on Blazor WebAssembly sends user requests to an API\\ngateway.\\n\\nThe API gatewa\", \"y abstracts the backend core microservices from the frontend client. It\\u2019s\\nimplemented using Envoy, a\", \" high performant, open-source service proxy. Envoy routes incoming\\n\\nCHAPTER 13 | Dapr reference appl\", \"ication\\n\\n\\frequests to backend microservices. Most requests are simple CRUD operations (for example, \", \"get\\nthe list of brands from the catalog) and handled by a direct call to a backend microservice.\\n\\n3.\", \"  Other requests are more logically complex and require multiple microservice calls to work\\ntogether\", \". For these cases, eShopOnDapr implements an aggregator microservice that\\norchestrates a workflow ac\", \"ross those microservices needed to complete the operation.\\n\\n4.\\n\\nThe core backend microservices imple\", \"ment the required functionality for an e-Commerce store.\\nEach is self-contained and independent of t\", \"he others. Following widely accepted domain\\ndecomposition patterns, each microservice isolates a spe\", \"cific business capability:\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\nThe basket service manages the customer\\u2019s shopping basket\", \" experience.\\n\\nThe catalog service manages product items available for sale.\\n\\nThe identity service ma\", \"nages authentication and identity.\\n\\nThe ordering service handles all aspects of placing and managing\", \" orders.\\n\\nThe payment service transacts the customer\\u2019s payment.\\n\\n5.\\n\\n6.\\n\\nAdhering to best practices,\", \" each microservice maintains its own persistent storage. The\\napplication doesn\\u2019t share a single data\", \"store.\\n\\nFinally, the event bus wraps the Dapr publish/subscribe components. It enables asynchronous\\n\", \"publish/subscribe messaging across microservices. Developers can plug in any Dapr-supported\\nmessage \", \"broker component.\\n\\nApplication of Dapr building blocks\\n\\nIn eShopOnDapr, Dapr building blocks replace\", \" a large amount of complex, error-prone plumbing\\ncode.\\n\\nFigure 12-4 shows the Dapr integration in th\", \"e application.\\n\\nFigure 12-4. Dapr integration in eShopOnDapr.\\n\\n139\\n\\nCHAPTER 13 | Dapr reference appl\", \"ication\\n\\n\\fThe above figure shows the Dapr building blocks (represented as green numbered boxes) that\", \" each\\neShopOnDapr service consumes.\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\n5.\\n\\n6.\\n\\nThe API gateway and web shopping aggreg\", \"ator services use the service invocation building\\nblock to invoke methods on the backend services.\\n\\n\", \"The backend services communicate asynchronously using the publish & subscribe building\\nblock.\\n\\nThe b\", \"asket service uses the state management building block to store the state of the\\ncustomer\\u2019s shopping\", \" basket.\\n\\nThe original eShopOnContainers demonstrates DDD concepts and patterns in the ordering\\nserv\", \"ice. eShopOnDapr uses the actor building block as an alternative implementation. The turn-\\nbased acc\", \"ess model of actors makes it easy to implement a stateful ordering process with\\nsupport for cancella\", \"tion.\\n\\nThe ordering service sends order confirmation e-mails using the bindings building block.\\n\\nSec\", \"ret management is done by the secrets building block.\\n\\nThe following sections provide more detail on\", \" how the Dapr building blocks are applied in\\neShopOnDapr.\\n\\nState management\\n\\nIn eShopOnDapr, the Bas\", \"ket service uses the state management building block to persist the contents\\nof the customer\\u2019s shopp\", \"ing basket. The original eShopOnContainers architecture used an\\nIBasketRepository interface to read \", \"and write data for the basket service. The\\nRedisBasketRepository class provided the implementation u\", \"sing Redis as the underlying data store.\\nTo compare and contrast, the original eShopOnContainers imp\", \"lementation is presented below:\\n\\npublic class RedisBasketRepository : IBasketRepository\\n{\\n    privat\", \"e readonly ConnectionMultiplexer _redis;\\n    private readonly IDatabase _database;\\n\\n    public Redis\", \"BasketRepository(ConnectionMultiplexer redis)\\n    {\\n        _redis = redis;\\n        _database = redi\", \"s.GetDatabase();\\n    }\\n\\n    public async Task<CustomerBasket> GetBasketAsync(string customerId)\\n    \", \"{\\n        var data = await _database.StringGetAsync(customerId);\\n\\n        if (data.IsNullOrEmpty)\\n  \", \"      {\\n            return null;\\n        }\\n\\n        return JsonConvert.DeserializeObject<CustomerBas\", \"ket>(data);\\n    }\\n\\n    // ...\\n}\\n\\n140\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fThis code uses the t\", \"hird party StackExchange.Redis NuGet package. The following steps are required\\nto load the shopping \", \"basket for a given customer:\\n\\n1.\\n\\nInject a Redis ConnectionMultiplexer into the constructor. The Con\", \"nectionMultiplexer is\\nregistered with the dependency injection framework in the Program.cs file:\\n\\nse\", \"rvices.AddSingleton<ConnectionMultiplexer>(sp =>\\n{\\n    var settings = spGetRequiredService<IOptions<\", \"BasketSettings>>().Value;\\n    var configuration = ConfigurationOptions.Parse(settingsConnectionStrin\", \"g, true);\\n    configuration.ResolveDns = true;\\n    return ConnectionMultiplexer.Connect(configuratio\", \"n);\\n});\\n\\n1.  Use the ConnectionMultiplexer to create an IDatabase instance in each consuming class.\\n\", \"\\n2.  Use the IDatabase instance to execute a Redis StringGet call using the given customerId as the\\n\", \"\\nkey.\\n\\n3.\\n\\nCheck if data is loaded from Redis; if not, return null.\\n\\n4.  Deserialize the data from R\", \"edis to a CustomerBasket object and return the result.\\n\\nIn the updated eShopOnDapr reference applica\", \"tion, a new DaprBasketRepository class replaces the\\nRedisBasketRepository class:\\n\\npublic class DaprB\", \"asketRepository : IBasketRepository\\n{\\n    private const string StoreName = \\\"eshop-statestore\\\";\\n\\n    \", \"private readonly DaprClient _daprClient;\\n\\n    public DaprBasketRepository(DaprClient daprClient)\\n   \", \" {\\n        _daprClient = daprClient;\\n    }\\n\\n    public Task<CustomerBasket> GetBasketAsync(string cu\", \"stomerId) =>\\n        _daprClient.GetStateAsync<CustomerBasket>(StoreName, customerId);\\n\\n    // ...\\n}\", \"\\n\\nThe updated code uses the Dapr .NET SDK to read and write data using the state management\\nbuilding\", \" block. The new steps to load the basket for a customer are dramatically simplified:\\n\\n1.\\n\\nInject a D\", \"aprClient into the constructor. The DaprClient is registered with the dependency\\ninjection framework\", \" in the Program.cs`_ file.\\n\\n2.  Use the DaprClient.GetStateAsync method to load the customer\\u2019s shopp\", \"ing basket items from\\n\\nthe configured state store and return the result.\\n\\nThe updated implementation\", \" still uses Redis as the underlying data store. But, note how Dapr\\nabstracts the StackExchange.Redis\", \" references and complexity from the application. The application\\nno longer requires a direct depende\", \"ncy on Redis. A Dapr configuration file is all that\\u2019s needed:\\n\\n141\\n\\nCHAPTER 13 | Dapr reference appl\", \"ication\\n\\n\\fapiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: eshop-statestore\\n  namespac\", \"e: eshop\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    value: redis:63\", \"79\\n  - name: redisPassword\\n    secretKeyRef:\\n      name: redisPassword\\nauth:\\n  secretStore: eshop-se\", \"cretstore\\n\\nThe Dapr implementation also simplifies changing the underlying data store. Switching to \", \"Azure Table\\nStorage, for example, requires only changing the contents of the configuration file. No \", \"code changes\\nare necessary.\\n\\nService invocation\\n\\nThe original eShopOnContainers used a mix of HTTP/R\", \"EST and gRPC services. The use of gRPC was\\nlimited to communication between an aggregator service an\", \"d core backend services. Figure 12-5\\nshows the original architecture:\\n\\nFigure 12-5. gRPC and HTTP/RE\", \"ST calls in eShopOnContainers.\\n\\nNote the steps from the previous figure:\\n\\n1.\\n\\nThe frontend calls the\", \" API gateway using HTTP/REST.\\n\\n142\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\f2.\\n\\n3.\\n\\nThe API gatewa\", \"y forwards simple CRUD (Create, Read, Update, Delete) requests directly to a core\\nbackend service us\", \"ing HTTP/REST.\\n\\nThe API gateway forwards complex requests that involve coordinated backend service c\", \"alls to\\nthe web shopping aggregator service.\\n\\n4.\\n\\nThe aggregator service uses gRPC to call core back\", \"end services.\\n\\nIn the updated eShopOnDapr implementation, Dapr sidecars are added to the services an\", \"d API\\ngateway. Figure 12-6 show the updated architecture:\\n\\nFigure 12-6. Updated eShop architecture u\", \"sing Dapr.\\n\\nNote the updated steps from the previous figure:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\nThe frontend still use\", \"s HTTP/REST to call the API gateway.\\n\\nThe API gateway forwards HTTP requests to its Dapr sidecar.\\n\\nT\", \"he API gateway sidecar sends the request to the sidecar of the aggregator or backend service.\\n\\nThe a\", \"ggregator service uses the Dapr .NET SDK to call backend services through their sidecar\\narchitecture\", \".\\n\\nDapr implements calls between sidecars with gRPC. So even if you\\u2019re invoking a remote service wit\", \"h\\nHTTP/REST semantics, a part of the transport is implemented using gRPC.\\n\\nThe eShopOnDapr reference\", \" application benefits from the Dapr service invocation building block. The\\nbenefits also include ser\", \"vice discovery, automatic mTLS, and built-in observability.\\n\\nForward HTTP requests using Envoy and D\", \"apr\\n\\nBoth the original and updated eShop application leverage the Envoy proxy as an API gateway. Env\", \"oy\\nis an open-source proxy and communication bus that is popular across modern distributed\\napplicati\", \"ons. Originating from Lyft, Envoy is owned and maintained by the Cloud-Native Computing\\nFoundation.\\n\", \"\\n143\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fIn the original eShopOnContainers implementation, th\", \"e Envoy API gateway forwarded incoming HTTP\\nrequests directly to aggregator or backend services. In \", \"the new eShopOnDapr, the Envoy proxy\\nforwards the request to a Dapr sidecar.\\n\\nEnvoy is configured us\", \"ing a YAML definition file to control the proxy\\u2019s behavior. To enable Envoy to\\nforward HTTP requests\", \" to a Dapr sidecar container, a dapr cluster is added to the configuration. The\\ncluster configuratio\", \"n contains a host that points to the HTTP port on which the Dapr sidecar is\\nlistening:\\n\\nclusters:\\n- \", \"name: dapr\\n  connect_timeout: 0.25s\\n  type: strict_dns\\n  hosts:\\n  - socket_address:\\n    address: 127\", \".0.0.1\\n    port_value: 3500\\n\\nThe Envoy route configuration is updated to rewrite incoming requests a\", \"s calls to the Dapr sidecar\\n(pay close attention to the prefix_rewrite key/value pair):\\n\\n- name: \\\"c-\", \"short\\\"\\n  match:\\n    prefix: \\\"/c/\\\"\\n  route:\\n    auto_host_rewrite: true\\n    prefix_rewrite: \\\"/v1.0/in\", \"voke/catalog-api/method/\\\"\\n    cluster: dapr\\n\\nConsider a scenario where the frontend client wants to \", \"retrieve a list of catalog items. The Catalog API\\nprovides an endpoint for getting the catalog items\", \":\\n\\n[Route(\\\"api/v1/[controller]\\\")]\\n[ApiController]\\npublic class CatalogController : ControllerBase\\n{\\n\", \"\\n    [HttpGet(\\\"items/by_page\\\")]\\n    [ProducesResponseType(typeof(PaginatedItemsViewModel), (int)Http\", \"StatusCode.OK)]\\n    public async Task<PaginatedItemsViewModel> ItemsAsync(\\n        [FromQuery] int t\", \"ypeId = -1,\\n        [FromQuery] int brandId = -1,\\n        [FromQuery] int pageSize = 10,\\n        [Fr\", \"omQuery] int pageIndex = 0)\\n    {\\n        // ...\\n    }\\n\\nFirst, the frontend makes a direct HTTP call\", \" to the Envoy API gateway.\\n\\nGET http://<api-gateway>/c/api/v1/catalog/items\\n\\nThe Envoy proxy matches\", \" the route, rewrites the HTTP request, and forwards it to the invoke API of its\\nDapr sidecar:\\n\\nGET h\", \"ttp://127.0.0.1:3500/v1.0/invoke/catalog-api/method/api/v1/catalog/items\\n\\n144\\n\\nCHAPTER 13 | Dapr ref\", \"erence application\\n\\n\\fThe sidecar handles service discovery and routes the request to the Catalog API\", \" sidecar. Finally, the\\nsidecar calls the Catalog API to execute the request, fetch catalog items, an\", \"d return a response:\\n\\nGET http://localhost/api/v1/catalog/items\\n\\nMake aggregated service calls using\", \" the .NET SDK\\n\\nMost calls from the eShop frontend are simple CRUD calls. The API gateway forwards th\", \"em to a single\\nservice for processing. Some scenarios, however, require multiple backend services to\", \" work together\\nto complete a request. For the more complex calls, the web shopping aggregator servic\", \"e mediates the\\ncross service workflow. Figure 12-7 show the processing sequence of adding an item to\", \" your\\nshopping basket:\\n\\nFigure 12-7. Backend call requiring multiple services.\\n\\nThe aggregator servi\", \"ce first retrieves catalog items from the Catalog API. It then validates item\\navailability and prici\", \"ng. Finally, the aggregator service updates the shopping basket by calling the\\nBasket API.\\n\\nThe aggr\", \"egator service contains a BasketController that provides an endpoint for updating the\\nshopping baske\", \"t:\\n\\n[Route(\\\"api/v1/[controller]\\\")]\\n[Authorize]\\n[ApiController]\\npublic class BasketController : Contr\", \"ollerBase\\n{\\n    private readonly ICatalogService _catalog;\\n    private readonly IBasketService _bask\", \"et;\\n\\n    [HttpPost]\\n    [HttpPut]\\n    [ProducesResponseType((int)HttpStatusCode.BadRequest)]\\n    [Pr\", \"oducesResponseType(typeof(BasketData), (int)HttpStatusCode.OK)]\\n    public async Task<ActionResult<B\", \"asketData>> UpdateAllBasketAsync(\\n        [FromBody] UpdateBasketRequest data,\\n        [FromHeader] \", \"string authorization)\\n    {\\n        BasketData basket;\\n\\n145\\n\\nCHAPTER 13 | Dapr reference application\", \"\\n\\n\\f        if (data.Items is null || !data.Items.Any())\\n        {\\n            basket = new();\\n      \", \"  }\\n        else\\n        {\\n            // Get the item details from the catalog API.\\n            var\", \" catalogItems = await _catalog.GetCatalogItemsAsync(\\n                data.Items.Select(x => x.Produc\", \"tId));\\n\\n            if (catalogItems == null)\\n            {\\n                return BadRequest(\\n     \", \"               \\\"Catalog items were not available for the specified items in the\\nbasket.\\\");\\n         \", \"   }\\n\\n            // Check item availability and prices; store results in basket object.\\n           \", \" basket = CreateValidatedBasket(data.Items, catalogItems);\\n        }\\n\\n        // Save the updated sh\", \"opping basket.\\n        await _basket.UpdateAsync(basket, authorization.Substring(\\\"Bearer \\\".Length));\", \"\\n\\n        return basket;\\n    }\\n\\n    // ...\\n}\\n\\nThe UpdateAllBasketAsync method gets the Authorization\", \" header of the incoming request using a\\nFromHeader attribute. The Authorization header contains the \", \"access token that is needed to call\\nprotected backend services.\\n\\nAfter receiving a request to update\", \" the basket, the aggregator service calls the Catalog API to get the\\nitem details. The Basket contro\", \"ller uses an injected ICatalogService object to make that call and\\ncommunicate with the Catalog API.\", \" The original implementation of the interface used gRPC to make\\nthe call. The updated implementation\", \" uses Dapr service invocation with HttpClient support:\\n\\npublic class CatalogService : ICatalogServic\", \"e\\n{\\n    private readonly HttpClient _httpClient;\\n\\n    public CatalogService(HttpClient httpClient)\\n \", \"   {\\n        _httpClient = httpClient;\\n    }\\n\\n    public Task<IEnumerable<CatalogItem>> GetCatalogIt\", \"emsAsync(IEnumerable<int> ids)\\n    {\\n        var requestUri = $\\\"api/v1/catalog/items/by_ids?ids={str\", \"ing.Join(\\\",\\\", ids)}\\\";\\n\\n        return _httpClient.GetFromJsonAsync<IEnumerable<CatalogItem>>(request\", \"Uri);\\n    }\\n\\n    // ...\\n}\\n\\n146\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fNotice how no Dapr-specifi\", \"c code is required to make the service invocation call. All communication is\\ndone using the standard\", \" HttpClient object.\\n\\nThe Dapr HttpClient is configured for the CatalogService class on program start\", \"up:\\n\\nbuilder.Services.AddSingleton<ICatalogService, CatalogService>(\\n    _ => new CatalogService(Dap\", \"rClient.CreateInvokeHttpClient(\\\"catalog-api\\\")));\\n\\nThe other call made by the aggregator service is t\", \"o the Basket API. It only allows authorized requests.\\nThe access token is passed along in an Authori\", \"zation request header to ensure the call succeeds:\\n\\npublic class BasketService : IBasketService\\n{\\n  \", \"  public Task UpdateAsync(BasketData currentBasket, string accessToken)\\n    {\\n        var request = \", \"new HttpRequestMessage(HttpMethod.Post, \\\"api/v1/basket\\\")\\n        {\\n            Content = JsonContent\", \".Create(currentBasket)\\n        };\\n        request.Headers.Authorization = new AuthenticationHeaderVa\", \"lue(\\\"Bearer\\\",\\naccessToken);\\n\\n        var response = await _httpClient.SendAsync(request);\\n        re\", \"sponse.EnsureSuccessStatusCode();\\n    }\\n\\n    // ...\\n}\\n\\nIn this example too, only standard HttpClient\", \" functionality is used to call the service. This allows\\ndevelopers who are already familiar with Htt\", \"pClient to reuse their existing skills. It even enables\\nexisting HttpClient code to use Dapr service\", \" invocation without making any changes.\\n\\nPublish & subscribe\\n\\nBoth eShopOnContainers and eShopOnDapr\", \" use the pub/sub pattern for communicating integration\\nevents across microservices. Integration even\", \"ts include:\\n\\n\\u2022  When a user checks-out a shopping basket.\\n\\n\\u2022  When a payment for an order has succee\", \"ded.\\n\\n\\u2022  When the grace-period of a purchase has expired.\\n\\nNote\\n\\nThink of an Integration Event as an\", \" event that takes place across multiple services.\\n\\nEventing in eShopOnContainers is based on the fol\", \"lowing IEventBus interface:\\n\\npublic interface IEventBus\\n{\\n    void Publish(IntegrationEvent integrat\", \"ionEvent);\\n\\n    void Subscribe<T, THandler>()\\n        where TEvent : IntegrationEvent\\n        where \", \"THandler : IIntegrationEventHandler<T>;\\n}\\n\\n147\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fConcrete i\", \"mplementations of this interface for both RabbitMQ and Azure Service Bus are found in\\neShopOnContain\", \"ers. Each implementation included a large amount of custom plumbing code that\\nwas complex to underst\", \"and and difficult to maintain.\\n\\nThe newer eShopOnDapr significantly simplifies pub/sub behavior by u\", \"sing Dapr. To start, the\\nIEventBus interface was reduced to a single method:\\n\\npublic interface IEven\", \"tBus\\n{\\n    Task PublishAsync(IntegrationEvent integrationEvent);\\n}\\n\\nPublish events\\n\\nIn eShopOnDapr, \", \"a single DaprEventBus implementation can support any Dapr-supported message\\nbroker. The following co\", \"de block shows the simplified Publish method. Note how the PublishAsync\\nmethod uses the Dapr client \", \"to publish an event:\\n\\npublic class DaprEventBus : IEventBus\\n{\\n    private const string DAPR_PUBSUB_N\", \"AME = \\\"pubsub\\\";\\n\\n    private readonly DaprClient _dapr;\\n    private readonly ILogger _logger;\\n\\n    p\", \"ublic DaprEventBus(DaprClient dapr, ILogger<DaprEventBus> logger)\\n    {\\n        _dapr = dapr;\\n      \", \"  _logger = logger;\\n    }\\n\\n    public async Task PublishAsync(IntegrationEvent integrationEvent)\\n   \", \" {\\n        var topicName = integrationEvent.GetType().Name;\\n\\n        _logger.LogInformation(\\n       \", \"     \\\"Publishing event {@Event} to {PubsubName}.{TopicName}\\\",\\n            integrationEvent,\\n        \", \"    DAPR_PUBSUB_NAME,\\n            topicName);\\n\\n        // We need to make sure that we pass the conc\", \"rete type to PublishEventAsync,\\n        // which can be accomplished by casting the event to dynamic\", \". This ensures\\n        // that all event fields are properly serialized.\\n        await _dapr.Publish\", \"EventAsync(DAPR_PUBSUB_NAME, topicName,\\n(object)integrationEvent);\\n    }\\n}\\n\\nAs you can see in the co\", \"de snippet, the topic name is derived from event type\\u2019s name. Because all\\neShop services use the IEv\", \"entBus abstraction, retrofitting Dapr required absolutely no change to the\\nmainline application code\", \".\\n\\n148\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fImportant\\n\\nThe Dapr SDK uses System.Text.Json to s\", \"erialize/deserialize messages. However, System.Text.Json\\ndoesn\\u2019t serialize properties of derived cla\", \"sses by default. In the eShop code, an event is sometimes\\nexplicitly declared as an IntegrationEvent\", \", the base class for integration events. This construct allows\\nthe concrete event type to be determi\", \"ned dynamically at run time based on business logic. As a result,\\nthe event is serialized using the \", \"type information of the base class and not the derived class. To force\\nSystem.Text.Json to serialize\", \" the properties of both the base and derived class, the code uses\\nobject as the generic type paramet\", \"er. For more information, see the .NET documentation.\\n\\nWith Dapr, pub/sub infrastructure code is dra\", \"matically simplified. The application doesn\\u2019t need to\\ndistinguish between message brokers. Dapr prov\", \"ides this abstraction for you. If needed, you can easily\\nswap out message brokers or configure multi\", \"ple message broker components with no code changes.\\n\\nSubscribe to events\\n\\nThe earlier eShopOnContain\", \"ers app contains SubscriptionManagers to handle the subscription\\nimplementation for each message bro\", \"ker. Each manager contains complex message broker-specific\\ncode for handling subscription events. To\", \" receive events, each service has to explicitly register a\\nhandler for each event-type.\\n\\neShopOnDapr\", \" streamlines the plumbing for event subscriptions by using Dapr ASP.NET Core\\nintegration. Each event\", \" is handled by an action method in a controller. A Topic attribute decorates the\\naction method with \", \"the name of the corresponding topic. Here\\u2019s a code snippet taken from the\\nPaymentService:\\n\\n[Route(\\\"a\", \"pi/v1/[controller]\\\")]\\n[ApiController]\\npublic class IntegrationEventController : ControllerBase\\n{\\n   \", \" private const string DAPR_PUBSUB_NAME = \\\"pubsub\\\";\\n\\n    [HttpPost(\\\"OrderStatusChangedToValidated\\\")]\\n\", \"    [Topic(DAPR_PUBSUB_NAME, nameof(OrderStatusChangedToValidatedIntegrationEvent))]\\n    public Task\", \" HandleAsync(\\n        OrderStatusChangedToValidatedIntegrationEvent integrationEvent,\\n        [FromS\", \"ervices] OrderStatusChangedToValidatedIntegrationEventHandler handler) =>\\n        handler.Handle(int\", \"egrationEvent);\\n}\\n\\nIn the Topic attribute, the name of the .NET type of the event is used as the top\", \"ic name. For handling\\nthe event, an event handler that already existed in the earlier eShopOnContain\", \"ers code base is\\nresolved using dependency injection and invoked. In the previous example, messages \", \"received from\\nthe OrderStatusChangedToValidatedIntegrationEvent topic invoke the existing\\nOrderStatu\", \"sChangedToValidatedIntegrationEventHandler event handler. Because Dapr\\nimplements the underlying plu\", \"mbing for subscriptions and message brokers, a large amount of\\noriginal code became obsolete and was\", \" removed from the code-base. Much of this code was complex\\nto understand and challenging to maintain\", \".\\n\\n149\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fUse pub/sub components\\n\\nWithin the eShopOnDapr rep\", \"ository, a deployment folder contains files for deploying the application\\nusing different deployment\", \" modes: Docker Compose and Kubernetes. A dapr folder exists within each\\nof these folders that holds \", \"a components folder. This folder holds a file eshop-pubsub.yaml. It\\nspecifies the Dapr pub/sub compo\", \"nent that the application will use for pub/sub behavior. As you saw\\nin the earlier code snippets, th\", \"e name of the pub/sub component used is pubsub. Here\\u2019s the content\\nof the eshop-pubsub.yaml file in \", \"the deployment/compose/dapr/components folder:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadat\", \"a:\\n  name: pubsub\\n  namespace: eshop\\nspec:\\n  type: pubsub.rabbitmq\\n  version: v1\\n  metadata:\\n  - nam\", \"e: host\\n    value: \\\"amqp://rabbitmq:5672\\\"\\n\\nThe configuration specifies RabbitMQ as the underlying in\", \"frastructure. To change message brokers,\\nyou need only to configure a different message broker, such\", \" as NATS or Azure Service Bus and update\\nthe yaml file. With Dapr, there are no changes to your main\", \"line service code when switching message\\nbrokers.\\n\\nYou can also easily use multiple message brokers \", \"in a single application. Many times a system will\\nhandle workloads with different characteristics. O\", \"ne event may occur 10 times a day, but another\\nevent occurs 5,000 times per second. You may benefit \", \"by partitioning messaging traffic to different\\nmessage brokers. With Dapr, you can add multiple pub/\", \"sub component configurations, each with a\\ndifferent name.\\n\\nBindings\\n\\neShopOnDapr uses the bindings b\", \"uilding block for sending e-mails. When a user places an order, the\\napplication sends an order confi\", \"rmation e-mail using the SMTP output binding. You can find this\\nbinding in the eshop-email.yaml file\", \" in the components folder:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: sendmail\\n\", \"  namespace: eshop\\nspec:\\n  type: bindings.smtp\\n  version: v1\\n  metadata:\\n  - name: host\\n    value: m\", \"aildev\\n  - name: port\\n    value: 25\\n  - name: user\\n    secretKeyRef:\\n      name: Smtp.User\\n\\n150\\n\\nCHA\", \"PTER 13 | Dapr reference application\\n\\n\\f      key: Smtp.User\\n  - name: password\\n    secretKeyRef:\\n   \", \"   name: Smtp.Password\\n      key: Smtp.Password\\n  - name: skipTLSVerify\\n    value: true\\nauth:\\n  secr\", \"etStore: eshop-secretstore\\nscopes:\\n- ordering-api\\n\\nDapr gets the username and password for connectin\", \"g to the SMTP server from a secret reference. This\\napproach keeps secrets outside of the configurati\", \"on file. To learn more about Dapr secrets, read the\\nsecrets building block chapter.\\n\\nThe binding con\", \"figuration specifies a binding component that can be invoked using the /sendmail\\nendpoint on the Dap\", \"r sidecar. Here\\u2019s a code snippet in which an email is sent whenever an order is\\nstarted:\\n\\npublic Tas\", \"k Handle(OrderStartedDomainEvent notification, CancellationToken\\ncancellationToken)\\n{\\n    var messag\", \"e = CreateEmailBody(notification);\\n    var metadata = new Dictionary<string, string>\\n    {\\n        [\", \"\\\"emailFrom\\\"] = \\\"eShopOn@dapr.io\\\",\\n        [\\\"emailTo\\\" = notification.UserName,\\n        [\\\"subject\\\"] = \", \"$\\\"Your eShopOnDapr order #{notification.Order.Id}\\\"\\n    };\\n    return _daprClient.InvokeBindingAsync(\", \"\\\"sendmail\\\", \\\"create\\\", message, metadata,\\ncancellationToken);\\n}\\n\\npublic Task SendOrderConfirmationAsy\", \"nc(Order order)\\n{\\n    var message = CreateEmailBody(order);\\n\\n    return _daprClient.InvokeBindingAsy\", \"nc(\\n        \\\"sendmail\\\",\\n        \\\"create\\\",\\n        CreateEmailBody(order),\\n        new Dictionary<str\", \"ing, string>\\n        {\\n            [\\\"emailFrom\\\"] = \\\"eshopondapr@example.com\\\",\\n            [\\\"emailTo\\\"\", \"] = order.BuyerEmail,\\n            [\\\"subject\\\"] = $\\\"Your eShopOnDapr Order #{order.OrderNumber}\\\"\\n     \", \"   });\\n}\\n\\nAs you can see in this example, message contains the message body. The CreateEmailBody met\", \"hod\\nsimply formats a string with the body text. The name of the binding to invoke is sendmail and th\", \"e\\noperation is create. The metadata specifies the email sender, recipient, and subject for the email\", \"\\nmessage. If these values are static, they can also be included in the metadata fields in the\\nconfig\", \"uration file.\\n\\n151\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fActors\\n\\nIn the original eShopOnContain\", \"ers solution, the Ordering service provides a great example of how to\\nuse DDD design patterns in a .\", \"NET microservice. As the updated eShopOnDapr focuses on Dapr, the\\nOrdering service now uses the acto\", \"rs building block to implement its business logic.\\n\\nThe ordering process consists of the following s\", \"teps:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\nThe customer submits the order. There\\u2019s a grace period before any further pro\", \"cessing occurs.\\nDuring the grace period, the customer can cancel the order.\\n\\nThe system checks that \", \"there\\u2019s available stock.\\n\\nThe system processes the payment.\\n\\nThe system ships the order.\\n\\nThe proces\", \"s is implemented using a single OrderingProcessActor actor type. Here\\u2019s the interface for\\nthe actor:\", \"\\n\\npublic interface IOrderingProcessActor : IActor\\n{\\n    Task SubmitAsync(\\n        string userId, str\", \"ing userName, string street, string city,\\n        string zipCode, string state, string country, Cust\", \"omerBasket basket);\\n\\n    Task NotifyStockConfirmedAsync();\\n\\n    Task NotifyStockRejectedAsync(List<i\", \"nt> rejectedProductIds);\\n\\n    Task NotifyPaymentSucceededAsync();\\n\\n    Task NotifyPaymentFailedAsync\", \"();\\n\\n    Task<bool> CancelAsync();\\n\\n    Task<bool> ShipAsync();\\n\\n    Task<Order> GetOrderDetailsAsyn\", \"c();\\n}\\n\\nThe process is started when a customer checks out some products. Upon checkout, the Basket s\", \"ervice\\npublishes a UserCheckoutAcceptedIntegrationEvent message using the Dapr pub/sub building\\nbloc\", \"k. The Ordering service handles the message in the OrderingProcessEventController class and\\ncalls th\", \"e SubmitAsync method of the actor:\\n\\n[HttpPost(\\\"UserCheckoutAccepted\\\")]\\n[Topic(DaprPubSubName, \\\"UserC\", \"heckoutAcceptedIntegrationEvent\\\")]\\npublic async Task HandleAsync(UserCheckoutAcceptedIntegrationEven\", \"t integrationEvent)\\n{\\n    if (integrationEvent.RequestId != Guid.Empty)\\n    {\\n        var actorId = \", \"new ActorId(integrationEvent.RequestId.ToString());\\n        var orderingProcess = _actorProxyFactory\", \".CreateActorProxy<IOrderingProcessActor>(\\n            actorId,\\n            nameof(OrderingProcessAct\", \"or));\\n\\n        await orderingProcess.SubmitAsync(integrationEvent.UserId,\\nintegrationEvent.UserName,\", \"\\n\\n152\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\f            integrationEvent.Street, integrationEve\", \"nt.City, integrationEvent.ZipCode,\\n            integrationEvent.State, integrationEvent.Country, int\", \"egrationEvent.Basket);\\n    }\\n    else\\n    {\\n        _logger.LogWarning(\\n            \\\"Invalid Integra\", \"tionEvent - RequestId is missing - {@IntegrationEvent}\\\",\\n            integrationEvent);\\n    }\\n}\\n\\nIn \", \"the example above, the Ordering service first uses the original request ID from the\\nUserCheckoutAcce\", \"ptedIntegrationEvent message as the actor ID. The handler uses the ActorId to\\ncreate an actor proxy \", \"and invokes the SubmitAsync method. The following snippet shows the\\nimplementation of the SubmitAsyn\", \"c method:\\n\\npublic async Task SubmitAsync(\\n    string buyerId,\\n    string buyerEmail,\\n    string stre\", \"et,\\n    string city,\\n    string state,\\n    string country,\\n    CustomerBasket basket)\\n{\\n    var orde\", \"rState = new OrderState\\n    {\\n        OrderDate = DateTime.UtcNow,\\n        OrderStatus = OrderStatus\", \".Submitted,\\n        Description = \\\"Submitted\\\",\\n        Address = new OrderAddressState\\n        {\\n   \", \"         Street = street,\\n            City = city,\\n            State = state,\\n            Country = \", \"country\\n        },\\n        BuyerId = buyerId,\\n        BuyerEmail = buyerEmail,\\n        OrderItems = \", \"basket.Items\\n            .Select(item => new OrderItemState\\n            {\\n                ProductId \", \"= item.ProductId,\\n                ProductName = item.ProductName,\\n                UnitPrice = item.U\", \"nitPrice,\\n                Units = item.Quantity,\\n                PictureFileName = item.PictureFileN\", \"ame\\n            })\\n            .ToList()\\n    };\\n\\n    await StateManager.SetStateAsync(OrderDetailsSt\", \"ateName, orderState);\\n    await StateManager.SetStateAsync(OrderStatusStateName, OrderStatus.Submitt\", \"ed);\\n\\n    await RegisterReminderAsync(\\n        GracePeriodElapsedReminder,\\n        null,\\n        Tim\", \"eSpan.FromSeconds(_settings.Value.GracePeriodTime),\\n        TimeSpan.FromMilliseconds(-1));\\n\\n153\\n\\nCH\", \"APTER 13 | Dapr reference application\\n\\n\\f    await _eventBus.PublishAsync(new OrderStatusChangedToSub\", \"mittedIntegrationEvent(\\n        OrderId,\\n        OrderStatus.Submitted.Name,\\n        buyerId,\\n      \", \"  buyerEmail));\\n}\\n\\nThere\\u2019s a lot going on in the Submit method:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\nThe method takes th\", \"e given arguments to create an OrderState object and saves it in the actor\\nstate.\\n\\nThe method saves \", \"the current status of the process (OrderStatus.Submitted) in the actor state.\\n\\nThe method registers \", \"a reminder to signal the end of the grace period. Order processing is\\ndelayed until the end of the g\", \"race period to deal with customers changing their mind.\\n\\nLastly, the method publishes an OrderStatus\", \"ChangedToSubmittedIntegrationEvent to notify\\nother services of the status change.\\n\\nWhen the reminder\", \" for the grace period ending fires, the actor runtime calls the\\nReceiveReminderAsync method:\\n\\npublic\", \" Task ReceiveReminderAsync(\\n    string reminderName, byte[] state, TimeSpan dueTime, TimeSpan period\", \")\\n{\\n    return reminderName switch\\n    {\\n        GracePeriodElapsedReminder => OnGracePeriodElapsedA\", \"sync(),\\n        StockConfirmedReminder => OnStockConfirmedSimulatedWorkDoneAsync(),\\n        StockRej\", \"ectedReminder => OnStockRejectedSimulatedWorkDoneAsync(\\n            JsonConvert.DeserializeObject<Li\", \"st<int>>(Encoding.UTF8.GetString(state))),\\n        PaymentSucceededReminder => OnPaymentSucceededSim\", \"ulatedWorkDoneAsync(),\\n        PaymentFailedReminder => OnPaymentFailedSimulatedWorkDoneAsync(),\\n   \", \"     _ => Task.CompletedTask\\n    };\\n}\\n\\nAs shown in the snippet above, the ReceiveReminderAsync metho\", \"d handles not just the grace period\\nreminder. The actor also uses reminders to simulate background w\", \"ork and introduce some delays in\\nthe ordering process. This makes the process easier to follow in th\", \"e eShopOnDapr UI where\\nnotifications are shown for each status update. The ReceiveReminderAsync meth\", \"od uses the\\nreminder name to determine which method handles the reminder. The grace period reminder \", \"is\\nhandled by the OnGracePeriodElapsedAsync method:\\n\\npublic async Task OnGracePeriodElapsedAsync()\\n{\", \"\\n    var statusChanged = await TryUpdateOrderStatusAsync(\\n        OrderStatus.Submitted, OrderStatus\", \".AwaitingStockValidation);\\n    if (statusChanged)\\n    {\\n        var order = await StateManager.GetSt\", \"ateAsync<Order>(OrderDetailsStateName);\\n\\n        await _eventBus.PublishAsync(new\\nOrderStatusChanged\", \"ToAwaitingStockValidationIntegrationEvent(\\n            OrderId,\\n            OrderStatus.AwaitingStoc\", \"kValidation.Name,\\n            \\\"Grace period elapsed; waiting for stock validation.\\\",\\n\\n154\\n\\nCHAPTER 1\", \"3 | Dapr reference application\\n\\n\\f            order.UserName,\\n            order.OrderItems\\n          \", \"      .Select(orderItem => new OrderStockItem(orderItem.ProductId,\\norderItem.Units))));\\n    }\\n}\\n\\nThe\", \" OnGracePeriodElapsedAsync method first tries to update the order status to the new\\nAwaitingStockVal\", \"idation status. If that succeeds, it retrieves the order details from state and\\npublishes an OrderSt\", \"atusChangedToAwaitingStockValidationIntegrationEvent to inform other\\nservice of the status change. F\", \"or example, the Category service subscribes to this event to check the\\navailable stock.\\n\\nLet\\u2019s look \", \"at the TryUpdateOrderStatusAsync method to see under which circumstances it may fail to\\nupdate the o\", \"rder status:\\n\\nprivate async Task<bool> TryUpdateOrderStatusAsync(OrderStatus expectedOrderStatus,\\nOr\", \"derStatus newOrderStatus)\\n{\\n    var orderStatus = await\\nStateManager.TryGetStateAsync<OrderStatus>(O\", \"rderStatusStateName);\\n    if (!orderStatus.HasValue)\\n    {\\n        _logger.LogWarning(\\n            \\\"\", \"Order with Id: {OrderId} cannot be updated because it doesn't exist\\\",\\n            OrderId);\\n\\n       \", \" return false;\\n    }\\n\\n    if (orderStatus.Value.Id != expectedOrderStatus.Id)\\n    {\\n        _logger.\", \"LogWarning(\\n            \\\"Order with Id: {OrderId} is in status {Status} instead of expected status\\n{\", \"ExpectedStatus}\\\",\\n            OrderId, orderStatus.Value.Name, expectedOrderStatus.Name);\\n\\n        r\", \"eturn false;\\n    }\\n\\n    await StateManager.SetStateAsync(OrderStatusStateName, newOrderStatus);\\n\\n   \", \" return true;\\n}\\n\\nFirst, the TryUpdateOrderStatusAsync method checks whether there even is a current \", \"order status. If\\nthere isn\\u2019t, the order doesn\\u2019t exist. This is a fail-safe that should not happen wi\", \"th normal application\\nusage. Then, the method checks whether the current order status is the status \", \"that we expected.\\nRemember that the ordering process is driven by events using the Dapr pub/sub buil\", \"ding block. Event\\ndelivery uses at-least-once semantics, so a single message could be received multi\", \"ple times. The order\\nstatus check ensures that even when the same message is received multiple times\", \", it is only processed\\nonce.\\n\\nThe other steps in the ordering process are all implemented in a very \", \"similar way to the grace period\\nstep. In the next sections, we\\u2019ll look at some other aspects of the \", \"ordering process, namely\\ncancellation and viewing order details.\\n\\n155\\n\\nCHAPTER 13 | Dapr reference a\", \"pplication\\n\\n\\fOrder cancellation\\n\\nCustomers are allowed to cancel any order that has not been paid or\", \" shipped yet. The\\nOrdersController class handles incoming order cancellations. It invokes the Cancel\", \"Async method on\\nthe OrderingProcessActor instance for the given order.\\n\\npublic async Task<bool> Canc\", \"elAsync()\\n{\\n    var orderStatus = await\\nStateManager.TryGetStateAsync<OrderStatus>(OrderStatusStateN\", \"ame);\\n    if (!orderStatus.HasValue)\\n    {\\n        _logger.LogWarning(\\n           \\\"Order with Id: {O\", \"rderId} cannot be cancelled because it doesn't exist\\\",\\n            OrderId);\\n\\n        return false;\\n\", \"    }\\n\\n    if (orderStatus.Value.Id == OrderStatus.Paid.Id || orderStatus.Value.Id ==\\nOrderStatus.Sh\", \"ipped.Id)\\n    {\\n        _logger.LogWarning(\\n           \\\"Order with Id: {OrderId} cannot be cancelled\", \" because it's in status {Status}\\\",\\n            OrderId, orderStatus.Value.Name);\\n\\n        return fal\", \"se;\\n    }\\n\\n    await StateManager.SetStateAsync(OrderStatusStateName, OrderStatus.Cancelled);\\n\\n    v\", \"ar order = await StateManager.GetStateAsync<Order>(OrderDetailsStateName);\\n\\n    await _eventBus.Publ\", \"ishAsync(new OrderStatusChangedToCancelledIntegrationEvent(\\n        OrderId,\\n        OrderStatus.Can\", \"celled.Name,\\n        $\\\"The order was cancelled by buyer.\\\",\\n        order.UserName));\\n\\n    return tru\", \"e;\\n}\\n\\nThe CancelAsync method consists of the following steps:\\n\\n1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\nFirst, the method ens\", \"ures that the order exists by retrieving the current order status.\\n\\nIf the order exists, the method \", \"checks whether it\\u2019s eligible for cancellation. Any order not in the\\nPaid or Shipped state can be can\", \"celled.\\n\\nIf the order can be cancelled, the order status is changed to Cancelled.\\n\\nLastly, the order\", \" details are retrieved from state and used to publish an\\nOrderStatusChangedToCancelledIntegrationEve\", \"nt to inform the other services.\\n\\nThe CancelAsync method is a great example of the usefulness of the\", \" turn-based access model of\\nactors. Nowhere in the method do we need to worry about multiple threads\", \" running at the same time.\\nTherefore, the method does not require any explicit locking mechanisms to\", \" be correct.\\n\\n156\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fOrder details\\n\\nCustomers can check the \", \"status and details of their order in the eShopOnDapr UI. They can also view\\na complete history of pa\", \"st orders. Directly querying actor instances for this information is a bad idea\\nbecause of two reaso\", \"ns:\\n\\n1.\\n\\nLow-latency reads cannot be guaranteed because actor operations execute serially.\\n\\n2.  Quer\", \"ying across actors is inefficient because each actor\\u2019s state needs to be read individually and\\n\\ncan \", \"introduce more unpredictable latencies.\\n\\nTo fix this issue, eShopOnDapr uses a separate read model f\", \"or any queries on order data. The read\\nmodel is stored in a separate SQL database. An ASP.NET Core c\", \"ontroller class named\\nUpdateOrderStatusEventController subscribes to the order status events and bui\", \"lds up the view\\nmodel. The same UpdateOrderStatusEventController class also sends push notifications\", \" to the UI\\nto inform the customer of order status updates.\\n\\nThe following snippet shows the code for\", \" handling the\\nOrderStatusChangedToSubmittedIntegrationEvent message:\\n\\n[HttpPost(\\\"OrderStatusChangedT\", \"oSubmitted\\\")]\\n[Topic(DaprPubSubName, nameof(OrderStatusChangedToSubmittedIntegrationEvent))]\\npublic \", \"async Task HandleAsync(\\n    OrderStatusChangedToSubmittedIntegrationEvent integrationEvent,\\n    [Fro\", \"mServices] IOptions<OrderingSettings> settings,\\n    [FromServices] IEmailService emailService)\\n{\\n   \", \" // Gets the order details from Actor state.\\n    var actorId = new ActorId(integrationEvent.OrderId.\", \"ToString());\\n    var orderingProcess = _actorProxyFactory.CreateActorProxy<IOrderingProcessActor>(\\n \", \"       actorId,\\n        nameof(OrderingProcessActor));\\n    //\\n    var actorOrder = await orderingPro\", \"cess.GetOrderDetailsAsync();\\n    var readModelOrder = new Order(integrationEvent.OrderId, actorOrder\", \");\\n\\n    // Add the order to the read model so it can be queried from the API.\\n    // It may already \", \"exist if this event has been handled before (at-least-once\\nsemantics).\\n    readModelOrder = await _o\", \"rderRepository.AddOrGetOrderAsync(readModelOrder);\\n\\n    // Send a SignalR notification to the client\", \".\\n    await SendNotificationAsync(readModelOrder.OrderNumber, integrationEvent.OrderStatus,\\n        \", \"integrationEvent.BuyerId);\\n\\n    // Send a confirmation e-mail if enabled.\\n    if (settings.Value.Sen\", \"dConfirmationEmail)\\n    {\\n        await emailService.SendOrderConfirmationAsync(readModelOrder);\\n   \", \" }\\n}\\n\\nThe handler contains the code for all the actions that must occur after an order is submitted\\n\", \"successfully. Because the events originate from the OrderingProcessActor, we can be sure that any\\nva\", \"lidations performed by the actor have succeeded.\\n\\nThe handler performs the following steps:\\n\\n157\\n\\nCH\", \"APTER 13 | Dapr reference application\\n\\n\\f1.\\n\\n2.\\n\\n3.\\n\\n4.\\n\\nFirst, the method creates an actor proxy and\", \" uses it to retrieve the order details from the actor\\ninstance.\\n\\nThe method maps the order details t\", \"o the read model and stores it in the database. Due to the\\nat-least-once semantics of the Dapr pub/s\", \"ub building block, the order may already exist in the\\ndatabase. In that case, it will not be overwri\", \"tten.\\n\\nThe method publishes a push notification for the status update using SignalR.\\n\\nLastly, if ena\", \"bled, the method sends a confirmation e-mail to the customer.\\n\\nSubsequent order status updates are a\", \"ll handled equally to each other. The following snippet shows\\nwhat happens when the order status is \", \"updated to AwaitingStockValidation:\\n\\n[HttpPost(\\\"OrderStatusChangedToAwaitingStockValidation\\\")]\\n[Topi\", \"c(DaprPubSubName,\\nnameof(OrderStatusChangedToAwaitingStockValidationIntegrationEvent))]\\npublic Task \", \"HandleAsync(\\n    OrderStatusChangedToAwaitingStockValidationIntegrationEvent integrationEvent)\\n{\\n   \", \" // Save the updated status in the read model and notify the client via SignalR.\\n    return UpdateRe\", \"adModelAndSendNotificationAsync(integrationEvent.OrderId,\\n        integrationEvent.OrderStatus, inte\", \"grationEvent.Description,\\nintegrationEvent.BuyerId);\\n}\\n\\nprivate async Task UpdateReadModelAndSendNot\", \"ificationAsync(\\n    Guid orderId, string orderStatus, string description, string buyerId)\\n{\\n    var \", \"order = await _orderRepository.GetOrderByIdAsync(orderId);\\n    if (order is not null)\\n    {\\n        \", \"order.OrderStatus = orderStatus;\\n        order.Description = description;\\n\\n        await _orderRepos\", \"itory.UpdateOrderAsync(order);\\n        await SendNotificationAsync(order.OrderNumber, orderStatus, b\", \"uyerId);\\n    }\\n}\\n\\nIn the snippet, the handler calls the UpdateReadModelAndSendNotificationAsync help\", \"er method to\\nhandle the status update:\\n\\n1.\\n\\n2.\\n\\nThe helper method first loads the current order from\", \" the database.\\n\\nIf that succeeds, it updates the OrderStatus and Description fields and saves the up\", \"dated\\nmodel back to the database.\\n\\n3.\\n\\nLastly, it sends a push notification to notify the client UI.\", \"\\n\\nObservability\\n\\neShopOnDapr uses Zipkin to visualize distributed traces collected by Dapr. Seq aggr\", \"egates the\\neShopOnDapr application logs. The various services emit structured logging using the Seri\", \"Log logging\\nlibrary. Serilog publishes log events to a construct called a sink. A sink is simply a t\", \"arget platform to\\nwhich Serilog writes its logging events. Many Serilog sinks are available, includi\", \"ng one for Seq. Seq is\\nthe Serilog sink used in eShopOnDapr.\\n\\n158\\n\\nCHAPTER 13 | Dapr reference appli\", \"cation\\n\\n\\feShopOnDapr also includes a custom health dashboard that gives insight into the health of t\", \"he eShop\\nservices. This dashboard uses the built-in health checks mechanism of ASP.NET Core. The das\", \"hboard\\nnot only provides the health status of the services, but also the health of the dependencies \", \"of the\\nservices, including the Dapr sidecars.\\n\\nSecrets\\n\\nThe eShopOnDapr reference application uses t\", \"he secrets building block for various secrets:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nThe password for connecting to the Redis ca\", \"che.\\n\\nThe username and password for the SMTP server.\\n\\nThe connection strings for the SQL databases.\\n\", \"\\nWhen running the application using Docker Compose, the local file secret store is used. The\\ncompone\", \"nt configuration file eshop-secretstore.yaml is found in the dapr/components folder of\\nthe eShopOnDa\", \"pr repository:\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: eshop-secretstore\\n  n\", \"amespace: eshop\\nspec:\\n  type: secretstores.local.file\\n  version: v1\\n  metadata:\\n  - name: secretsFil\", \"e\\n    value: ./components/eshop-secretstore.json\\n  - name: nestedSeparator\\n    value: \\\".\\\"\\n\\nThe confi\", \"guration file references the local store file eshop-secretstore.json located in the same\\nfolder:\\n\\n{\\n\", \"  \\\"ConnectionStrings\\\": {\\n    \\\"CatalogDB\\\": \\\"**********\\\",\\n    \\\"IdentityDB\\\": \\\"**********\\\",\\n    \\\"Orderin\", \"gDB\\\": \\\"**********\\\"\\n  },\\n  \\\"Smtp\\\": {\\n    \\\"User\\\": \\\"**********\\\",\\n    \\\"Password\\\": \\\"**********\\\"\\n  },\\n  \\\"S\", \"tate\\\": {\\n    \\\"RedisPassword\\\": \\\"**********\\\"\\n  }\\n}\\n\\nThe components folder is specified in the command-\", \"line and mounted as a local folder inside the Dapr\\nsidecar container. Here\\u2019s a snippet from the dock\", \"er-compose.override.yml file in the repository root\\nthat specifies the volume mount:\\n\\ncatalog-api-da\", \"pr:\\n  command: [\\\"./daprd\\\",\\n\\n159\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\f    \\\"-app-id\\\", \\\"catalog-a\", \"pi\\\",\\n    \\\"-app-port\\\", \\\"80\\\",\\n    \\\"-components-path\\\", \\\"/components\\\",\\n    \\\"-config\\\", \\\"/configuration/es\", \"hop-config.yaml\\\"\\n    ]\\n  volumes:\\n    - \\\"./dapr/components/:/components\\\"\\n    - \\\"./dapr/configuration\", \"/:/configuration\\\"\\n\\nThe /components volume mount and --components-path command-line argument are pass\", \"ed into\\nthe daprd startup command.\\n\\nOnce configured, other component configuration files can also re\", \"ference the secrets. Here\\u2019s an\\nexample of the state store component configuration consuming secrets:\", \"\\n\\napiVersion: dapr.io/v1alpha1\\nkind: Component\\nmetadata:\\n  name: eshop-statestore\\n  namespace: eshop\", \"\\nspec:\\n  type: state.redis\\n  version: v1\\n  metadata:\\n  - name: redisHost\\n    value: redis:6379\\n  - n\", \"ame: redisPassword\\n    secretKeyRef:\\n      name: State.RedisPassword\\n      key: State.RedisPassword\\n\", \"  - name: actorStateStore\\n    value: \\\"true\\\"\\nauth:\\n  secretStore: eshop-secretstore\\nscopes:\\n- basket-\", \"api\\n- ordering-api\\n\\nBenefits of applying Dapr to eShop\\n\\nIn general, the use of Dapr building blocks \", \"adds observability and flexibility to the application:\\n\\n1.  Observability: By using the Dapr buildin\", \"g blocks, you gain rich distributed tracing for calls\\n\\nbetween services and to Dapr components witho\", \"ut having to write any code. In\\neShopOnContainers, a large amount of custom logging is used to provi\", \"de insight.\\n\\n2.\\n\\nFlexibility: You can now swap out infrastructure simply by changing a component con\", \"figuration\\nfile. No code changes are necessary.\\n\\nHere are some more examples of benefits offered by \", \"specific building blocks:\\n\\n\\u2022\\n\\nService Invocation\\n\\n\\u2013  With Dapr\\u2019s support for mTLS, services now comm\", \"unicate through encrypted channels.\\n\\n\\u2013  When transient errors occur, service calls are automatically\", \" retried.\\n\\n160\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\f\\u2013\\n\\nAutomatic service discovery reduces the\", \" amount of configuration needed for services to\\nfind each other.\\n\\n\\u2022\\n\\nPublish/Subscribe\\n\\n\\u2013\\n\\n\\u2013\\n\\neShopO\", \"nContainers included a large amount of custom code to support both Azure\\nService Bus and RabbitMQ. D\", \"evelopers used Azure Service Bus for production and\\nRabbitMQ for local development and testing. An I\", \"EventBus abstraction layer was\\ncreated to enable swapping between these message brokers. This layer \", \"consisted of\\napproximately 700 lines of error-prone code. The updated implementation with Dapr\\nrequi\", \"res only 35 lines of code. That\\u2019s 5% of the original lines of code! More importantly,\\nthe implementa\", \"tion is straightforward and easy to understand.\\n\\neShopOnDapr uses Dapr\\u2019s rich ASP.NET Core integrati\", \"on to use pub/sub. You add Topic\\nattributes to ASP.NET Core controller methods to subscribe to messa\", \"ges. Therefore,\\nthere\\u2019s no need to write a separate message handler loop for each message broker.\\n\\n\\u2013\", \"  Messages routed to the service as HTTP calls enable the use of ASP.NET Core\\n\\nmiddleware to add fun\", \"ctionality, without introducing new concepts or SDKs to learn.\\n\\n\\u2022\\n\\nBindings\\n\\n\\u2013\\n\\nThe eShopOnContainer\", \"s solution contained a to-do item for e-mailing an order\\nconfirmation to the customer. With Dapr, im\", \"plementing email notification was as easy as\\nconfiguring a resource binding.\\n\\n\\u2022\\n\\nActors\\n\\n\\u2013\\n\\n\\u2013\\n\\nThe a\", \"ctors building block makes it easy to create long running, stateful workflows.\\nThanks to the turn-ba\", \"sed access model, there\\u2019s no need for explicit locking mechanisms.\\n\\nThe complexity of the grace peri\", \"od implementation is greatly reduced by using actor\\nreminders instead of polling on the database.\\n\\nS\", \"ummary\\n\\nIn this chapter, you\\u2019re introduced to the eShopOnDapr reference application. It\\u2019s an evoluti\", \"on of the\\nwidely popular eShopOnContainers microservice reference application. eShopOnDapr replaces \", \"a large\\namount of custom functionality with Dapr building blocks and components, dramatically simpli\", \"fying\\nthe complexities required to build a microservices application.\\n\\nReferences\\n\\neShopOnDapr\\n\\neSho\", \"pOnContainers\\n\\n.NET Microservices for Containerized .NET Applications\\n\\nArchitecting Cloud-Native .NE\", \"T Apps for Azure\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\n161\\n\\nCHAPTER 13 | Dapr reference application\\n\\n\\fCHAPTER  14\\n\\nSummary an\", \"d the road\\nahead\\n\\nWe\\u2019re at the end of our Dapr flight. The jet plane flying at 20,000 feet from chap\", \"ter 2 is on final\\napproach and about to land.\\n\\nAs the plane taxis to the gate, let\\u2019s take a minute t\", \"o review some important conclusions from this\\nguide:\\n\\n\\u2022\\n\\n\\u2022\\n\\n\\u2022\\n\\nDapr - Dapr is a Distributed Applicat\", \"ion Runtime that streamlines how you build distributed\\napplications. It exposes an architecture of b\", \"uilding blocks and pluggable components. Dapr\\nprovides a dynamic glue that binds your application wi\", \"th infrastructure capabilities that exist in\\nthe Dapr runtime. Instead of building infrastructure pl\", \"umbing, you and your team focus on\\ndelivering business features to customers.\\n\\nOpen source and cross\", \"-platform - The native Dapr API can be consumed by any platform that\\nsupports HTTP or gRPC. Dapr als\", \"o provides language-specific SDKs for popular development\\nplatforms. Dapr v1.0 supports Go, Python, \", \".NET, Java, PHP, and JavaScript.\\n\\nBuilding blocks - Dapr building blocks encapsulate distributed app\", \"lication functionality. At the\\ntime of this writing, Dapr supports the seven building blocks shown i\", \"n figure 13-1.\\n\\n162\\n\\nCHAPTER 14 | Summary and the road ahead\\n\\n\\fFigure 13-1. Dapr building blocks.\\n\\n\\u2022\", \"\\n\\nComponents - Dapr components provide the concrete implementation for each Dapr building\\nblock capa\", \"bility. They expose a common interface that enables developers to swap out\\ncomponent implementations\", \" without changing application code. Figure 13-2 shows the\\nrelationship among components, building bl\", \"ocks, and your service.\\n\\n163\\n\\nCHAPTER 14 | Summary and the road ahead\\n\\n\\fFigure 13-2. Dapr building b\", \"lock integration.\\n\\n\\u2022\\n\\nSidecars - Dapr runs alongside your application in a sidecar architecture, eit\", \"her as a separate\\nprocess of a container. Your application communicates with the Dapr APIs over HTTP\", \" and gRPC.\\nSidecars provide isolation and encapsulation as they aren\\u2019t part of the service, but conn\", \"ected to\\nit. Figure 13-3 shows a sidecar architecture.\\n\\nFigure 13-3. Sidecar architecture.\\n\\n164\\n\\nCHA\", \"PTER 14 | Summary and the road ahead\\n\\n\\f\\u2022\\n\\n\\u2022\\n\\nHosting environments Dapr has cross-platform support an\", \"d can run in multiple environments.\\nAt the time of this writing, the environments include a local se\", \"lf-hosted mode and Kubernetes.\\n\\neShopOnDapr - This book includes an accompanying reference applicati\", \"on entitled\\neShopOnDapr. Using a popular e-commerce application domain, the reference application\\nde\", \"monstrates the usage of each building block. It\\u2019s an evolution of the widely popular\\neShopOnContaine\", \"rs, released several years ago.\\n\\nThe road ahead\\n\\nLooking forward, Dapr has the potential to have a p\", \"rofound impact on distributed application\\ndevelopment. What can you expect from the Dapr team and it\", \"s open-source contributors?\\n\\nAt the time of writing, the list of proposed enhancements for Dapr incl\", \"ude:\\n\\n\\u2022\\n\\nFeature enhancements to existing building blocks:\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\nQuery capabilities in state \", \"management enabling you to retrieve multiple values.\\n\\nTopic filtering in pub/sub enabling you to fil\", \"ter topics based on their content.\\n\\nAn application tracing API in observability that provides tracin\", \"g in the application\\ndirectly without having to bind to specific libraries.\\n\\nBinding and pub/sub sup\", \"port for actors providing event driven capabilities to the actor\\nprogramming model. Bound components\", \" will trigger events and messages invoke\\nmethods in the actor.\\n\\n\\u2022\\n\\nNew building blocks:\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\", \"\\n\\u2013\\n\\nConfiguration API building block for reading and writing configuration data. The block\\nwill bind\", \" to providers that include Azure Configuration Manager or GCP Configuration\\nManagement.\\n\\nHttp scale-\", \"to-zero autoscale.\\n\\nLeader election building block to provide singleton instances and locking semant\", \"ic\\ncapabilities.\\n\\nTransparent proxying building block for service invocation, enabling you to route\\n\", \"messages based on URLs or DNS addresses at the network level.\\n\\nResiliency building block (circuit br\", \"eakers, bulkheads & timeouts).\\n\\n\\u2022\\n\\nIntegration with frameworks and cloud native technologies. Some e\", \"xamples include:\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\nDjango\\n\\nNodejs\\n\\nExpress\\n\\nKyma\\n\\n\\u2013  Midway\\n\\n\\u2022\\n\\nNew language SDKs:\\n\\n\\u2013\\n\\n\\u2013\\n\", \"\\n\\u2013\\n\\nJavaScript\\n\\nRUST\\n\\nC++\\n\\n165\\n\\nCHAPTER 14 | Summary and the road ahead\\n\\n\\f\\u2022\\n\\nNew hosting platforms:\\n\", \"\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\nVMs\\n\\nAzure IoT Edge\\n\\nAzure Stack Edge\\n\\nAzure Service Fabric\\n\\n\\u2022\\n\\nDeveloper and operator \", \"productivity tooling:\\n\\n\\u2013\\n\\n\\u2013\\n\\n\\u2013\\n\\nVS Code extension.\\n\\nRemote Dev Containers for local debugging a DevO\", \"ps pipeline development.\\n\\nDapr operational dashboard enhancements that will provide deeper visibilit\", \"y into the\\noperational concerns of managing Dapr applications.\\n\\nDapr version 1.0 provides developers\", \" with a compelling toolbox for building distributed applications.\\nAs the proposed enhancement list s\", \"hows, Dapr is under active development with many new\\ncapabilities to come. Stay tuned to the Dapr si\", \"te and Dapr announcement blog for future updates.\\n\\n166\\n\\nCHAPTER 14 | Summary and the road ahead\\n\\n\"]"