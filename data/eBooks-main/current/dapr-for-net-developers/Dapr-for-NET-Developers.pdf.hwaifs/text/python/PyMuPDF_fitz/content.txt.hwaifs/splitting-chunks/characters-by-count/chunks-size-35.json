"[\" \\n \\n \\n \\n \\nEDITION v1.2 \\nPUBLISHED BY \\nMicrosoft Developer Division, .NET, and Azure Incubations team\", \"s \\nA division of Microsoft Corporation \\nOne Microsoft Way \\nRedmond, Washington 98052-6399 \\nCopyright\", \" \\u00a9 2023 by Microsoft Corporation \\nAll rights reserved. No part of the contents of this book may be r\", \"eproduced or transmitted in any \\nform or by any means without the written permission of the publishe\", \"r. \\nThis book is provided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The views, opinions\", \", and \\ninformation expressed in this book, including URL and other Internet website references, may \", \"change \\nwithout notice. \\nSome examples depicted herein are provided for illustration only and are fi\", \"ctitious. No real association \\nor connection is intended or should be inferred. \\nMicrosoft and the t\", \"rademarks listed at https://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Mic\", \"rosoft group of companies. \\nMac and macOS are trademarks of Apple Inc. \\nThe Docker whale logo is a r\", \"egistered trademark of Docker, Inc. Used by permission. \\nAll other marks and logos are property of t\", \"heir respective owners. \\nAuthors: \\nRob Vettor, Principal Cloud Solution Architect - thinkingincloudn\", \"ative.com, Microsoft \\nSander Molenkamp, Principal Cloud Architect/Microsoft MVP - sandermolenkamp.co\", \"m, Info Support \\nEdwin van Wijk, Principal Solution Architect/Microsoft MVP - defaultconstructor.com\", \", Info Support \\nParticipants and Reviewers: \\nMark Russinovich, Azure CTO and Technical Fellow, Azure\", \" Office of CTO, Microsoft \\nNish Anil, Senior Program Manager, .NET team, Microsoft \\nMark Fussell, Pr\", \"incipal Program Manager, Azure Incubations, Microsoft \\nYaron Schneider, Principal Software Engineer,\", \" Azure Incubations, Microsoft \\nOri Zohar, Senior Program Manager, Azure Incubations, Microsoft \\nEdit\", \"ors: \\nDavid Pine, Senior Content Developer, .NET team, Microsoft \\nMaira Wenzel, Senior Program Manag\", \"er, .NET team, Microsoft \\n \\n \\nSteve \\u201cardalis\\u201d Smith, Senior Architect and Trainer, NimblePros \\nVersi\", \"on \\nThis guide has been written to cover the Dapr 1.9 version. .NET samples are based on .NET 7. \\nWh\", \"o should use this guide \\nThe audience for this guide is mainly developers, development leads, and ar\", \"chitects who are \\ninterested in learning how to build applications designed for the cloud. \\nA second\", \"ary audience is technical decision-makers who plan to choose whether to build their \\napplications us\", \"ing a cloud-native approach. \\nHow you can use this guide \\nThis guide is available both in PDF form a\", \"nd online. Feel free to forward this document or links to its \\nonline version to your team to help e\", \"nsure common understanding of these topics. Most of these \\ntopics benefit from a consistent understa\", \"nding of the underlying principles and patterns, as well as \\nthe trade-offs involved in decisions re\", \"lated to these topics. Our goal with this document is to equip \\nteams and their leaders with the inf\", \"ormation they need to make well-informed decisions for their \\napplications\\u2019 architecture, developmen\", \"t, and hosting. \\n \\ni \\nContents \\n \\nContents \\nForeword - Dapr for .NET Developers ....................\", \"............................................................... 1 \\nThe world is distributed ........\", \".................................................................................................. 3\", \" \\nSummary ..........................................................................................\", \"........................................................................................... 7 \\nDapr \", \"at 20,000 feet .....................................................................................\", \"............................ 8 \\nDapr and the problem it solves .....................................\", \"....................................................................................................\", \". 8 \\nDapr architecture .............................................................................\", \"........................................................................................ 9 \\nBuilding\", \" blocks ............................................................................................\", \"......................................................................... 9 \\nComponents ............\", \"....................................................................................................\", \"....................................................... 11 \\nSidecar architecture ...................\", \"....................................................................................................\", \".................................. 13 \\nHosting environments ........................................\", \"....................................................................................................\", \"........ 14 \\nDapr performance considerations .......................................................\", \".......................................................................... 15 \\nDapr and service mesh\", \"es .................................................................................................\", \".................................................. 16 \\nSummary .....................................\", \"....................................................................................................\", \"......................................... 18 \\nReferences ...........................................\", \"....................................................................................................\", \"............................ 18 \\nGet started with Dapr .............................................\", \".............................................................. 19 \\nInstall Dapr into your local envi\", \"ronment ............................................................................................\", \"......................... 19 \\nBuild your first Dapr application ....................................\", \"................................................................................................. 19\", \" \\nCreate the application ...........................................................................\", \"......................................................................... 19 \\nAdd Dapr State Managem\", \"ent ................................................................................................\", \"..................................... 20 \\nComponent configuration files ............................\", \"....................................................................................................\", \"....... 21 \\nBuild a multi-container Dapr application ...............................................\", \"..................................................................... 23 \\nCreate the application ...\", \"....................................................................................................\", \"............................................. 23 \\nAdd Dapr service invocation ......................\", \"....................................................................................................\", \".............. 27 \\nAdd container support ...........................................................\", \"........................................................................................ 29 \\nSummary\", \" ...................................................................................................\", \"............................................................................... 35 \\nReferences .....\", \"....................................................................................................\", \".................................................................. 35 \\nTraffic Control sample applic\", \"ation ...................................................................................... 36 \\nUsi\", \"ng Dapr building blocks.............................................................................\", \".................................................................. 39 \\n \\nii \\nContents \\nHosting .....\", \"....................................................................................................\", \"............................................................................. 40 \\nSelf-hosted mode .\", \"....................................................................................................\", \"....................................................... 40 \\nKubernetes .............................\", \"....................................................................................................\", \"......................................... 41 \\nSummary ..............................................\", \"....................................................................................................\", \"................................ 41 \\nReferences ....................................................\", \"....................................................................................................\", \"................... 41 \\nThe Dapr state management building block ...................................\", \"................................... 42 \\nWhat it solves .............................................\", \"....................................................................................................\", \"........................ 42 \\nHow it works ..........................................................\", \"....................................................................................................\", \"............. 43 \\nConsistency ......................................................................\", \"................................................................................................... \", \"43 \\nConcurrency ....................................................................................\", \"................................................................................... 45 \\nTransactions\", \" ...................................................................................................\", \".................................................................... 45 \\nUse the Dapr .NET SDK .....\", \"....................................................................................................\", \".............................................. 46 \\nASP.NET Core integration ........................\", \"....................................................................................................\", \"................. 47 \\nState store components .......................................................\", \".............................................................................................. 47 \\nC\", \"onfiguration .......................................................................................\", \".............................................................................. 48 \\nKey prefix strate\", \"gies ...............................................................................................\", \"......................................................... 49 \\nSample application: Dapr Traffic Contr\", \"ol .................................................................................................\", \"................... 50 \\nSummary ....................................................................\", \"....................................................................................................\", \".......... 51 \\nReferences ..........................................................................\", \"................................................................................................. 52\", \" \\nThe Dapr service invocation building block .......................................................\", \"................ 53 \\nWhat it solves ................................................................\", \"....................................................................................................\", \"..... 53 \\nHow it works .............................................................................\", \".............................................................................................. 53 \\nU\", \"se the Dapr .NET SDK ...............................................................................\", \"........................................................................ 55 \\nInvoke HTTP services us\", \"ing HttpClient .....................................................................................\", \"............................... 55 \\nInvoke HTTP services using DaprClient ..........................\", \"......................................................................................... 57 \\nInvoke\", \" gRPC services using DaprClient ....................................................................\", \"............................................... 58 \\nName resolution components .....................\", \"....................................................................................................\", \"................ 58 \\nConfiguration .................................................................\", \"....................................................................................................\", \" 58 \\nSample application: Dapr Traffic Control ......................................................\", \".............................................................. 59 \\nSummary .........................\", \"....................................................................................................\", \"..................................................... 60 \\nReferences ...............................\", \"....................................................................................................\", \"........................................ 60 \\n \\niii \\nContents \\nThe Dapr publish & subscribe building \", \"block .................................................................... 61 \\nWhat it solves ......\", \"....................................................................................................\", \"............................................................... 61 \\nHow it works ...................\", \"....................................................................................................\", \".................................................... 62 \\nCompeting consumers .......................\", \"....................................................................................................\", \"........................ 66 \\nUse the Dapr .NET SDK .................................................\", \"....................................................................................................\", \".. 66 \\nPub/sub components ..........................................................................\", \"................................................................................ 68 \\nConfiguration .\", \"....................................................................................................\", \"................................................................ 68 \\nSample application: Dapr Traffi\", \"c Control ..........................................................................................\", \".......................... 69 \\nSummary .............................................................\", \"....................................................................................................\", \"................. 71 \\nReferences ...................................................................\", \"....................................................................................................\", \".... 71 \\nThe Dapr bindings building block ..........................................................\", \"............................. 72 \\nWhat it solves ...................................................\", \"....................................................................................................\", \".................. 72 \\nHow it works ................................................................\", \"....................................................................................................\", \"....... 73 \\nInput bindings .........................................................................\", \".......................................................................................... 73 \\nOutpu\", \"t bindings .........................................................................................\", \"...................................................................... 74 \\nUse the Dapr .NET SDK ...\", \"....................................................................................................\", \"................................................ 76 \\nBinding components ............................\", \"....................................................................................................\", \"........................... 76 \\nCron binding .......................................................\", \"....................................................................................................\", \"........... 77 \\nSample application: Dapr Traffic Control ...........................................\", \"......................................................................... 78 \\nMQTT input binding ...\", \"....................................................................................................\", \"................................................. 79 \\nSMTP output binding ..........................\", \"....................................................................................................\", \"....................... 81 \\nSummary ................................................................\", \"....................................................................................................\", \".............. 83 \\nReferences ......................................................................\", \"....................................................................................................\", \". 83 \\nThe Dapr actors building block ...............................................................\", \"............................. 84 \\nWhat it solves ...................................................\", \"....................................................................................................\", \".................. 84 \\nHow it works ................................................................\", \"....................................................................................................\", \"....... 85 \\nTurn-based access model ................................................................\", \"............................................................................. 88 \\nTimers and reminde\", \"rs .................................................................................................\", \".................................................... 89 \\nState persistence .........................\", \"....................................................................................................\", \"................................. 89 \\nUse the Dapr .NET SDK ........................................\", \"....................................................................................................\", \"........... 90 \\nCall actors from ASP.NET Core clients ..............................................\", \"....................................................................... 93 \\n \\niv \\nContents \\nCall non\", \"-.NET actors........................................................................................\", \"................................................................ 94 \\nTimers and reminders ..........\", \"....................................................................................................\", \"....................................... 95 \\nSample application: Dapr Traffic Control ...............\", \"....................................................................................................\", \". 97 \\nSummary ......................................................................................\", \"............................................................................................ 98 \\nRef\", \"erences ............................................................................................\", \"............................................................................... 99 \\nThe Dapr observa\", \"bility building block ..............................................................................\", \" 100 \\nWhat it solves ...............................................................................\", \"........................................................................................ 101 \\nHow it\", \" works .............................................................................................\", \"............................................................................ 101 \\nDistributed tracin\", \"g ..................................................................................................\", \"....................................................... 102 \\nMetrics ...............................\", \"....................................................................................................\", \"............................................. 109 \\nLogging .........................................\", \"....................................................................................................\", \"................................. 111 \\nHealth status ...............................................\", \"....................................................................................................\", \"................. 113 \\nDapr dashboard ..............................................................\", \"................................................................................................ 114\", \" \\nUse the Dapr .NET SDK ............................................................................\", \"......................................................................... 115 \\nSample application: D\", \"apr Traffic Control ................................................................................\", \".................................. 115 \\nSummary ....................................................\", \"....................................................................................................\", \"........................ 117 \\nReferences ...........................................................\", \"....................................................................................................\", \".............. 118 \\nThe Dapr secrets management building block .....................................\", \"........................... 119 \\nWhat it solves ....................................................\", \"....................................................................................................\", \"............... 119 \\nHow it works ..................................................................\", \"....................................................................................................\", \"... 120 \\nUse the Dapr .NET SDK .....................................................................\", \"................................................................................ 121 \\nSecret store c\", \"omponents ..........................................................................................\", \"....................................................... 122 \\nConfiguration .........................\", \"....................................................................................................\", \"...................................... 123 \\nIndirectly consume Dapr secrets ........................\", \"....................................................................................................\", \".. 123 \\nLocal file .................................................................................\", \"............................................................................................ 124 \\nKu\", \"bernetes secret ....................................................................................\", \"...................................................................... 126 \\nAzure Key Vault ........\", \"....................................................................................................\", \"................................................... 126 \\nScope secrets .............................\", \"....................................................................................................\", \".................................. 129 \\nSample application: Dapr Traffic Control ...................\", \"............................................................................................... 129 \", \"\\nSecrets ...........................................................................................\", \"..................................................................................... 131 \\nSMTP serv\", \"er credentials .....................................................................................\", \"......................................................... 132 \\nRedis server credentials ............\", \"....................................................................................................\", \"............................... 133 \\n \\nv \\nContents \\nFineCalculator component license key ...........\", \"....................................................................................................\", \"... 134 \\nSummary ...................................................................................\", \"............................................................................................. 135 \\nR\", \"eferences ..........................................................................................\", \"................................................................................... 135 \\nDapr refere\", \"nce application ....................................................................................\", \"............. 137 \\neShopOnContainers ...............................................................\", \"............................................................................................ 137 \\neS\", \"hopOnDapr ..........................................................................................\", \"............................................................................. 138 \\nApplication of Da\", \"pr building blocks..................................................................................\", \".......................................... 139 \\nState management ...................................\", \"....................................................................................................\", \"................. 140 \\nService invocation ..........................................................\", \"................................................................................................ 142\", \" \\nPublish & subscribe ..............................................................................\", \"......................................................................... 147 \\nBindings ............\", \"....................................................................................................\", \"............................................................. 150 \\nActors ..........................\", \"....................................................................................................\", \".................................................... 152 \\nObservability ............................\", \"....................................................................................................\", \".................................... 158 \\nSecrets ..................................................\", \"....................................................................................................\", \".......................... 159 \\nBenefits of applying Dapr to eShop .................................\", \"........................................................................................... 160 \\nSum\", \"mary ...............................................................................................\", \"................................................................................. 161 \\nReferences ..\", \"....................................................................................................\", \"................................................................... 161 \\nSummary and the road ahead \", \"............................................................................................ 162 \\nTh\", \"e road ahead .......................................................................................\", \"............................................................................. 165 \\n \\n1 \\nCHAPTER 1 | \", \"Foreword - Dapr for .NET Developers \\n \\nCHAPTER 1 \\nForeword - Dapr for .NET \\nDevelopers \\nWith the wav\", \"e of cloud adoption underway, there is a major shift happening towards \\u201ccloud native\\u201d \\ndevelopment, \", \"often built with microservice-architectures. These microservices are both stateless and \\nstateful, a\", \"nd run on the cloud and edge, embracing the diversity of languages and frameworks \\navailable today. \", \"This enterprise shift is driven by both the market forces of faster time to market, and \\nthe scale a\", \"nd efficiencies of building services for the cloud. Even before COVID-19, cloud adoption \\nwas accele\", \"rating for enterprises, and developers were being asked to do even more to deliver on \\nbuilding thes\", \"e distributed system applications. That has only accelerated since COVID-19. Developers \\nin enterpri\", \"ses seek to focus on business logic, while leaning on platforms to imbue their applications \\nwith sc\", \"ale, resiliency, maintainability, elasticity, and the other attributes of cloud-native architectures\", \", \\nwhich is why there is also shift towards serverless platforms that hide the underlying infrastruc\", \"ture. \\nDevelopers should not be expected to become distributed systems experts. This is where Dapr s\", \"teps \\nin to help you, whether you are building on infrastructure such as Kubernetes, or on a serverl\", \"ess \\nplatform. \\nDapr is designed as an enterprise, developer-focused, microservices programming mode\", \"l platform \\nwith the mantra \\u201cany language, any framework, run anywhere\\u201d. It makes building distribut\", \"ed \\napplications easy and portable across any infrastructure, from public-cloud, through hierarchica\", \"l edge, \\nand even down to single node IoT devices. It emerged from both our experiences building ser\", \"vices in \\nAzure and time spent working with customers building applications on Azure Kubernetes Serv\", \"ice and \\nAzure Service Fabric. Over and over, we saw common problems that they had to address. It be\", \"came \\nclear that there was a need to provide a \\u201clibrary\\u201d of common microservice best practices that \", \"\\ndevelopers could use, not only in new green field applications, but also to aid in the modernizatio\", \"n of \\nexisting applications. In the containerized, distributed, and networked cloud native world, th\", \"e sidecar \\nmodel has emerged as the preferred approach, in the same way DLLs are preferred in the cl\", \"ient/server \\ngeneration. Using Dapr\\u2019s sidecar and APIs give you, as a developer, all the power of di\", \"stributed \\nsystems functionality, with the ease of a single HTTP or gRPC local call. \\nTo address the\", \" wide range of scenarios that developers face, Dapr provides features such as state \\nmanagement, ser\", \"vice-to-service invocation, pub/sub, and integration to external systems with I/O \\nbindings, which a\", \"re based on the triggers and bindings of Azure Functions. These in turn take \\nadvantage of Dapr\\u2019s co\", \"mponent model, which allows you to \\u201cswap out\\u201d, say different underlying state \\nstores, without havin\", \"g to change any code. This component model makes code more portable, more \\nflexible, and allows for \", \"experimentation of what best suits your needs. Developers don\\u2019t need to learn \\n \\n2 \\nCHAPTER 1 | Fore\", \"word - Dapr for .NET Developers \\n \\nand incorporate service SDKs into their code, or worry about auth\", \"entication, secret management, \\nretries, or conditional code that targets specific deployment enviro\", \"nments. \\nThis book shows how Dapr reduces your development time and overall code maintenance by \\ninc\", \"rementally \\u201cDaperizing\\u201d the canonical .NET reference application, eShop. For example, in the \\norigin\", \"al eShop implementation, significant amounts of code were written to abstract between Azure \\nService\", \" Bus and RabbitMQ for publishing events between services. All this code can be discarded and \\nsimply\", \" replaced with Dapr\\u2019s pub/sub API and component model, which had an even wider range of \\npub/sub bro\", \"kers, rather than just two. Dapr\\u2019s actor model, when used in the reworked eShop \\napplication, shows \", \"the ease of building long running, stateful, event driven, workflow applications with \\nall the diffi\", \"culties of concurrency and multi-threading removed. By the end of this book, you will see \\nthe drast\", \"ic simplification that Dapr brings to your application development, and I firmly believe all \\ndevelo\", \"pers embarking on a cloud native app building journey should use Dapr. \\nWe publicly announced Dapr w\", \"ith the v0.1 release in Oct 2019 and now, a year and half later, I am \\nthrilled to say that Dapr is \", \"ready for production usage with the v1.0 release. Getting Dapr to v1.0 has \\ntruly been a community e\", \"ffort. It has been amazing to see the open-source community coalesce \\naround Dapr and grow since it \", \"was first announced \\u2013 from 114 contributors in October 2019 to over \\n700 in early 2021 - a six-fold \", \"increase in 16 months! Contributions to the project have gone to every \\nDapr repo and have ranged fr\", \"om opening issues, commenting on feature proposals, providing \\nsamples, and, of course, contributing\", \" code. The parts of the project community members have \\ncontributed to the most include the Dapr run\", \"time, docs, CLI, SDKs, and the creation of a rich \\necosystem of components. Maintaining this opennes\", \"s is critical to Dapr\\u2019s future. \\nDapr is just getting started, though, and you should expect to see \", \"more Dapr capabilities and more \\nsupport for Dapr in Azure services. I hope that you will take advan\", \"tage of Dapr to enable you to focus \\non your core business logic and accelerate your microservices d\", \"evelopment. I am excited to have you \\njoin us in the Dapr community on this journey at https://githu\", \"b.com/dapr/ and on Discord \\nhttps://aka.ms/dapr-discord. \\nModern distributed systems are complex. Yo\", \"u start with small, loosely coupled, independently \\ndeployable services. These services cross proces\", \"s and server boundaries. They then consume different \\nkinds of infrastructure backing services (data\", \"bases, message brokers, key vaults). Finally, these \\ndisparate pieces compose together to form an ap\", \"plication. \\nMark Russinovich Azure CTO and Technical Fellow Microsoft \\n \\n3 \\nCHAPTER 2 | The world is\", \" distributed \\n \\nCHAPTER 2 \\nThe world is distributed \\nJust ask any \\u2018cool kid\\u2019: Modern, distributed sy\", \"stems are in, and monolithic apps are out! \\nBut, it\\u2019s not just \\u201ccool kids.\\u201d Progressive IT Leaders, \", \"corporate architects, and astute developers are \\nechoing these same thoughts as they explore and eva\", \"luate modern distributed applications. Many \\nhave bought in. They\\u2019re designing new and replatforming\", \" existing enterprise applications following \\nthe principles, patterns, and practices of distributed \", \"microservice applications. \\nBut, this evolution raises many questions\\u2026 \\n\\u2022 \\nWhat exactly is a distrib\", \"uted application? \\n\\u2022 \\nWhy are they gaining popularity? \\n\\u2022 \\nWhat are the costs? \\n\\u2022 \\nAnd, importantly,\", \" what are the tradeoffs? \\nTo start, let\\u2019s rewind and look at the past 15 years. During this period, \", \"we typically constructed \\napplications as a single, monolithic unit. Figure 1-1 shows the architectu\", \"re. \\n \\nFigure 1-1. Monolithic architecture. \\nNote how the modules for Ordering, Identity, and Market\", \"ing execute in a single-server process. \\nApplication data is stored in a shared database. Business f\", \"unctionality is exposed via HTML and \\nRESTful interfaces. \\nIn many ways, monolithic apps are straigh\", \"tforward. They\\u2019re straightforward to: \\n\\u2022 \\nBuild \\n \\n4 \\nCHAPTER 2 | The world is distributed \\n \\n\\u2022 \\nTes\", \"t \\n\\u2022 \\nDeploy \\n\\u2022 \\nTroubleshoot \\n\\u2022 \\nScale vertically (scale up) \\nHowever, monolithic architectures can\", \" present significant challenges. \\nOver time, you may reach a point where you begin to lose control\\u2026 \", \"\\n\\u2022 \\nThe monolith has become so overwhelmingly complicated that no single person understands it. \\n\\u2022 \\n\", \"You fear making changes as each brings unintended and costly side effects. \\n\\u2022 \\nNew features/fixes be\", \"come time-consuming and expensive to implement. \\n\\u2022 \\nEven the smallest change requires full deploymen\", \"t of the entire application - expensive and \\nrisky. \\n\\u2022 \\nOne unstable component can crash the entire \", \"system. \\n\\u2022 \\nAdding new technologies and frameworks aren\\u2019t an option. \\n\\u2022 \\nImplementing agile delivery\", \" methodologies are difficult. \\n\\u2022 \\nArchitectural erosion sets in as the code base deteriorates with n\", \"ever-ending \\u201cspecial cases.\\u201d \\n\\u2022 \\nEventually the consultants come in and tell you to rewrite it. \\nIT \", \"practitioners call this condition the Fear Cycle. If you\\u2019ve been in the technology business for any \", \"\\nlength of time, good chance you\\u2019ve experienced it. It\\u2019s stressful and exhausts your IT budget. Inst\", \"ead \\nof building new and innovative solutions, most of your budget is spent maintaining legacy apps.\", \" \\nInstead of fear, businesses require speed and agility. They seek an architectural style with which\", \" \\nthey can rapidly respond to market conditions. They need to instantaneously update and individuall\", \"y \\nscale small areas of a live application. \\nAn early attempt to gain speed and agility came in the \", \"form of Service Oriented Architecture, or SOA. \\nIn this model, service consumers and service provide\", \"rs collaborated via middleware messaging \\ncomponents, often referred to as an Enterprise Service Bus\", \", or ESB. Figure 1-2 shows the architecture. \\n \\n5 \\nCHAPTER 2 | The world is distributed \\n \\n \\nFigure \", \"1-2. SOA architecture. \\nWith SOA, centralized service providers registered with the ESB. Business lo\", \"gic would be built into the \\nESB to integrate providers and consumers. Service consumers could then \", \"find and communicate with \\nthese providers using the ESB. \\nDespite the promises of SOA, implementing\", \" this approach often increased complexity and introduced \\nbottlenecks. Maintenance costs became high\", \" and ESB middleware expensive. Services tended to be \\nlarge. They often shared dependencies and data\", \" storage. In the end, SOAs often resulted in a \\n\\u2018distributed monolithic\\u2019 structure with centralized \", \"services that were resistant to change. \\nNowadays, many organizations have realized speed and agilit\", \"y by adopting a distributed microservice \\narchitectural approach to building systems. Figure 1-3 sho\", \"ws the same system built using distributed \\ntechniques and practices. \\n \\n6 \\nCHAPTER 2 | The world is\", \" distributed \\n \\n \\nFigure 1-3. Distributed architecture. \\nNote how the same application is decomposed\", \" across a set of distributed services. Each is self-\\ncontained and encapsulates its own code, data, \", \"and dependencies. Each is deployed in a software \\ncontainer and managed by a container orchestrator.\", \" Instead of a single database shared by multiple \\nservices, each service owns a private database. Ot\", \"her services can\\u2019t access this database directly and \\ncan only get to data that is exposed through t\", \"he public API of the service that owns it. Note how \\nsome services require a full relational databas\", \"e, but others, a NoSQL datastore. The basket service \\nstores its state in a distributed key/value ca\", \"che. Note how inbound traffic routes through an API \\nGateway service. It\\u2019s responsible for directing\", \" calls to services and enforcing cross-cutting concerns. \\nMost importantly, the application takes fu\", \"ll advantage of the scalability, availability, and resiliency \\nfeatures found in modern cloud platfo\", \"rms. \\nBut, while distributed services can provide agility and speed, they present a different set of\", \" challenges. \\nConsider the following\\u2026 \\n\\u2022 \\nHow can distributed services discover each other and commu\", \"nicate synchronously? \\n \\n7 \\nCHAPTER 2 | The world is distributed \\n \\n\\u2022 \\nHow can they implement asynch\", \"ronous messaging? \\n\\u2022 \\nHow can they maintain contextual information across a transaction? \\n\\u2022 \\nHow can\", \" they become resilient to failure? \\n\\u2022 \\nHow can they scale to meet fluctuating demand? \\n\\u2022 \\nHow are th\", \"ey monitored and observed? \\nFor each of these challenges, multiple products are often available. But\", \", shielding your application \\nfrom product differences and keeping code maintainable and portable be\", \"come a challenge. \\nThis book introduces Dapr. Dapr is a distributed application runtime. It directly\", \" addresses many of the \\nchallenges found that come along with distributed applications. Looking ahea\", \"d, Dapr has the \\npotential to have a profound impact on distributed application development. \\nSummar\", \"y \\nIn this chapter, we discussed the adoption of distributed applications. We contrasted a monolithi\", \"c \\nsystem approach with that of distributed services. We pointed out many of the common challenges \\n\", \"when considering a distributed approach. \\nNow, sit back, relax, and let us introduce you the new wor\", \"ld of Dapr. \\n \\n8 \\nCHAPTER 3 | Dapr at 20,000 feet \\n \\nCHAPTER 3 \\nDapr at 20,000 feet \\nIn chapter 1, w\", \"e discussed the appeal of distributed microservice applications. But, we also pointed \\nout that they\", \" dramatically increase architectural and operational complexity. With that in mind, the \\nquestion be\", \"comes, how can you \\u201chave your cake\\u201d and \\u201ceat it too?\\u201d. That is, how can you take \\nadvantage of the a\", \"gility of distributed architecture, and minimize its complexity? \\nDapr, or Distributed Application R\", \"untime, is a new way to build modern distributed applications. \\nWhat started as a prototype has evol\", \"ved into a highly successful open-source project. Its sponsor, \\nMicrosoft, has closely partnered wit\", \"h customers and the open-source community to design and build \\nDapr. The Dapr project brings togethe\", \"r developers from all backgrounds to solve some of the \\ntoughest challenges of developing distribute\", \"d applications. \\nThis book looks at Dapr from the viewpoint of a .NET developer. In this chapter, yo\", \"u\\u2019ll build a \\nconceptual understanding of Dapr and how it works. Later on, we present practical, han\", \"ds-on \\ninstruction on how you can use Dapr in your applications. \\nImagine flying in a jet at 20,000 \", \"feet. You look out the window and see the landscape below from a \\nwide perspective. Let\\u2019s do the sam\", \"e for Dapr. Visualize yourself flying over Dapr at 20,000 feet. What \\nwould you see? \\nDapr and the p\", \"roblem it solves \\nDapr addresses a large challenge inherent in modern distributed applications: Comp\", \"lexity. \\nThrough an architecture of pluggable components, Dapr greatly simplifies the plumbing behin\", \"d \\ndistributed applications. It provides a dynamic glue that binds your application with infrastruct\", \"ure \\ncapabilities from the Dapr runtime. \\nConsider a requirement to make one of your services statef\", \"ul? What would be your design. You could \\nwrite custom code that targets a state store such as Redis\", \" Cache. However, Dapr provides state \\nmanagement capabilities out-of-the-box. Your service invokes t\", \"he Dapr state management building \\nblock that dynamically binds to a state store component via a Dap\", \"r component configuration yaml \\nfile. Dapr ships with several pre-built state store components, incl\", \"uding Redis. With this model, your \\nservice delegates state management to the Dapr runtime. Your ser\", \"vice has no SDK, library, or direct \\nreference to the underlying component. You can even change stat\", \"e stores, say, from Redis to MySQL \\nor Cassandra, with no code changes. \\nFigure 2-1 shows Dapr from \", \"20,000 feet. \\n \\n9 \\nCHAPTER 3 | Dapr at 20,000 feet \\n \\n \\nFigure 2-1. Dapr at 20,000 feet. \\nIn the top\", \" row of the figure, note how Dapr provides language-specific SDKs for popular development \\nplatforms\", \". Dapr v1.0 includes support for Go, Node.js, Python, .NET, Java, and JavaScript. This book \\nfocuses\", \" on the Dapr .NET SDK, which also provides direct support for ASP.NET Core integration. \\nWhile langu\", \"age-specific SDKs enhance the developer experience, Dapr is platform agnostic. Under the \\nhood, Dapr\", \"\\u2019s programming model exposes capabilities through standard HTTP/gRPC communication \\nprotocols. Any p\", \"rogramming platform can call Dapr via its native HTTP and gRPC APIs. \\nThe blue boxes across the cent\", \"er of the figure represent the Dapr building blocks. Each exposes a \\ndistributed application capabil\", \"ity that your application can consume. \\nThe bottom row highlights the portability of Dapr and the di\", \"verse environments across which it can \\nrun. \\nDapr architecture \\nAt this point, the jet turns around\", \" and flies back over Dapr, descending in altitude, giving you a closer \\nlook at how Dapr works. \\nBui\", \"lding blocks \\nFrom the new perspective, you see a more detailed view of the Dapr building blocks. \\nA\", \" building block encapsulates a distributed infrastructure capability. You can access the functionali\", \"ty \\nthrough the HTTP or gRPC APIs. Figure 2-2 shows the available blocks for Dapr v 1.0. \\n \\n10 \\nCHAP\", \"TER 3 | Dapr at 20,000 feet \\n \\n \\nFigure 2-2. Dapr building blocks. \\nThe following table describes th\", \"e infrastructure services provided by each block. \\nBuilding block \\nDescription \\nState management \\nSu\", \"pport contextual information for long running stateful services. \\nService invocation \\nInvoke direct,\", \" secure service-to-service calls using platform agnostic protocols \\nand well-known endpoints. \\nPubli\", \"sh and \\nsubscribe \\nImplement secure, scalable pub/sub messaging between services. \\n \\n11 \\nCHAPTER 3 |\", \" Dapr at 20,000 feet \\n \\nBuilding block \\nDescription \\nBindings \\nTrigger code from events raised by ex\", \"ternal resources with bi-directional \\ncommunication. \\nObservability \\nMonitor and measure message cal\", \"ls across networked services. \\nSecrets \\nSecurely access external secret stores. \\nActors \\nEncapsulate\", \" logic and data in reusable actor objects. \\nBuilding blocks abstract the implementation of distribut\", \"ed application capabilities from your services. \\nFigure 2-3 shows this interaction. \\n \\nFigure 2-3. D\", \"apr building block integration. \\nBuilding blocks invoke Dapr components that provide the concrete im\", \"plementation for each resource. \\nThe code for your service is only aware of the building block. It t\", \"akes no dependencies on external \\nSDKs or libraries - Dapr handles the plumbing for you. Each buildi\", \"ng block is independent. You can \\nuse one, some, or all of them in your application. As a value-add,\", \" Dapr building blocks bake in \\nindustry best practices including comprehensive observability. \\nWe pr\", \"ovide detailed explanation and code samples for each Dapr building block in the upcoming \\nchapters. \", \"At this point, the jet descends even more. From the new perspective, you now have a closer \\nlook at \", \"the Dapr components layer. \\nComponents \\nWhile building blocks expose an API to invoke distributed ap\", \"plication capabilities, Dapr components \\nprovide the concrete implementation to make it happen. \\n \\n1\", \"2 \\nCHAPTER 3 | Dapr at 20,000 feet \\n \\nConsider, the Dapr state store component. It provides a unifor\", \"m way to manage state for CRUD \\noperations. Without any change to your service code, you could switc\", \"h between any of the following \\nDapr state components: \\n\\u2022 \\nAWS DynamoDB \\n\\u2022 \\nAerospike \\n\\u2022 \\nAzure Blob\", \" Storage \\n\\u2022 \\nAzure CosmosDB \\n\\u2022 \\nAzure Table Storage \\n\\u2022 \\nCassandra \\n\\u2022 \\nCloud Firestore (Datastore mod\", \"e) \\n\\u2022 \\nCloudState \\n\\u2022 \\nCouchbase \\n\\u2022 \\nEtcd \\n\\u2022 \\nHashiCorp Consul \\n\\u2022 \\nHazelcast \\n\\u2022 \\nMemcached \\n\\u2022 \\nMongoD\", \"B \\n\\u2022 \\nPostgreSQL \\n\\u2022 \\nRedis \\n\\u2022 \\nRethinkDB \\n\\u2022 \\nSQL Server \\n\\u2022 \\nZookeeper \\nEach component provides the n\", \"ecessary implementation through a common state management \\ninterface: \\n type Store interface { \\n   I\", \"nit(metadata Metadata) error \\n   Delete(req *DeleteRequest) error \\n   BulkDelete(req []DeleteRequest\", \") error \\n   Get(req *GetRequest) (*GetResponse, error) \\n   Set(req *SetRequest) error \\n   BulkSet(re\", \"q []SetRequest) error \\n} \\n \\n \\nTip \\nThe Dapr runtime as well as all of the Dapr components have been \", \"written in the Golang, or Go, \\nlanguage. Go is a popular language across the open source community a\", \"nd attests to cross-platform \\ncommitment of Dapr. \\nPerhaps you start with Azure Redis Cache as your \", \"state store. You specify it with the following \\nconfiguration: \\n \\n13 \\nCHAPTER 3 | Dapr at 20,000 fee\", \"t \\n \\n:::{custom-style=CodeBox} yaml  apiVersion: dapr.io/v1alpha1  kind: Component  metadata:    nam\", \"e: \\nstatestore    namespace: default  spec:    type: state.redis    version: v1    metadata:    - na\", \"me: redisHost      \\nvalue: <HOST>    - name: redisPassword      value: <PASSWORD>    - name: enableT\", \"LS      value: \\n<bool> # Optional. Allowed: true, false.    - name: failover      value: <bool> # Op\", \"tional. Allowed: true, \\nfalse. ::: \\nIn the spec section, you configure Dapr to use the Redis Cache f\", \"or state management. The section \\nalso contains component-specific metadata. In this case, you can u\", \"se it to configure additional Redis \\nsettings. \\nAt a later time, the application is ready to go to p\", \"roduction. For the production environment, you may \\nwant to change your state management to Azure Ta\", \"ble Storage. Azure Table Storage provides state \\nmanagement capabilities that are affordable and hig\", \"hly durable. \\nAt the time of this writing, the following component types are provided by Dapr: \\nComp\", \"onent \\nDescription \\nService \\ndiscovery \\nUsed by the service invocation building block to integrate w\", \"ith the hosting \\nenvironment to provide service-to-service discovery. \\nState \\nProvides a uniform int\", \"erface to interact with a wide variety of state store \\nimplementations. \\nPub/sub \\nProvides a uniform\", \" interface to interact with a wide variety of message bus \\nimplementations. \\nBindings \\nProvides a un\", \"iform interface to trigger application events from external systems and \\ninvoke external systems wit\", \"h optional data payloads. \\nMiddleware \\nAllows custom middleware to plug into the request processing \", \"pipeline and invoke \\nadditional actions on a request or response. \\nSecret stores \\nProvides a uniform\", \" interface to interact with external secret stores, including cloud, \\nedge, commercial, open-source \", \"services. \\nAs the jet completes its fly over of Dapr, you look back once more and can see how it con\", \"nects \\ntogether. \\nSidecar architecture \\nDapr exposes its building blocks and components through a si\", \"decar architecture. A sidecar enables \\nDapr to run in a separate memory process or separate containe\", \"r alongside your service. Sidecars \\nprovide isolation and encapsulation as they aren\\u2019t part of the s\", \"ervice, but connected to it. This \\nseparation enables each to have its own runtime environment and b\", \"e built upon different \\nprogramming platforms. Figure 2-4 shows a sidecar pattern. \\n \\n14 \\nCHAPTER 3 \", \"| Dapr at 20,000 feet \\n \\n \\nFigure 2-4. Sidecar architecture. \\nThis pattern is named Sidecar because \", \"it resembles a sidecar attached to a motorcycle. In the previous \\nfigure, note how the Dapr sidecar \", \"is attached to your service to provide distributed application \\ncapabilities. \\nHosting environments \", \"\\nDapr has cross-platform support and can run in many different environments. These environments \\ninc\", \"lude Kubernetes, a group of VMs, or edge environments such as Azure IoT Edge. \\nFor local development\", \", the easiest way to get started is with self-hosted mode. In self-hosted mode, \\nthe microservices a\", \"nd Dapr sidecars run in separate local processes without a container orchestrator \\nsuch as Kubernete\", \"s. For more information, see download and install the Dapr CLI. \\nFigure 2-5 shows an application and\", \" Dapr hosted in two separate memory processes communicating \\nvia HTTP or gRPC. \\n \\n15 \\nCHAPTER 3 | Da\", \"pr at 20,000 feet \\n \\n \\nFigure 2-5. Self-hosted Dapr sidecar. \\nBy default, Dapr installs Docker conta\", \"iners for Redis and Zipkin to provide default state management \\nand observability. If you don\\u2019t want\", \" to install Docker on your local machine, you can even run Dapr in \\nself-hosted mode without any Doc\", \"ker containers. However, you must install default components such \\nas Redis for state management and\", \" pub/sub manually. \\nDapr also runs in containerized environments, such as Kubernetes. Figure 2-6 sho\", \"ws Dapr running in a \\nseparate side-car container along with the application container in the same K\", \"ubernetes pod. \\n \\nFigure 2-6. Kubernetes-hosted Dapr sidecar. \\nDapr performance considerations \\nAs y\", \"ou\\u2019ve seen, Dapr exposes a sidecar architecture to decouple your application from distributed \\nappli\", \"cation capabilities. Invoking a Dapr operation requires at least one out-of-process network call. \\nF\", \"igure 2-7 presents an example of a Dapr traffic pattern. \\n \\n16 \\nCHAPTER 3 | Dapr at 20,000 feet \\n \\n \", \"\\nFigure 2-7. Dapr traffic patterns. \\nLooking at the previous figure, one might question the latency \", \"and overhead incurred for each call. \\nThe Dapr team has invested heavily in performance. A tremendou\", \"s amount of engineering effort has \\ngone into making Dapr efficient. Calls between Dapr sidecars are\", \" always made with gRPC, which \\ndelivers high performance and small binary payloads. In most cases, t\", \"he additional overhead should \\nbe sub-millisecond. \\nTo increase performance, developers can call the\", \" Dapr building blocks with gRPC. \\ngRPC is a modern, high-performance framework that evolves the age-\", \"old remote procedure call (RPC) \\nprotocol. gRPC uses HTTP/2 for its transport protocol, which provid\", \"es significant performance \\nenhancements over HTTP RESTFul service, including: \\n\\u2022 \\nMultiplexing supp\", \"ort for sending multiple parallel requests over the same connection - HTTP 1.1 \\nlimits processing to\", \" one request/response message at a time. \\n\\u2022 \\nBidirectional full-duplex communication for sending bot\", \"h client requests and server responses \\nsimultaneously. \\n\\u2022 \\nBuilt-in streaming enabling requests and\", \" responses to asynchronously stream large data sets. \\nTo learn more, check out the gRPC overview fro\", \"m the Architecting Cloud-Native .NET Apps for Azure \\neBook. \\nDapr and service meshes \\nService mesh i\", \"s another rapidly evolving technology for distributed applications. \\nA service mesh is a configurabl\", \"e infrastructure layer with built-in capabilities to handle service-to-\\nservice communication, resil\", \"iency, load balancing, and telemetry capture. It moves the responsibility \\nfor these concerns out of\", \" the services and into the service mesh layer. Like Dapr, a service mesh also \\nfollows a sidecar arc\", \"hitecture. \\nFigure 2-8 shows an application that implements service mesh technology. \\n \\n17 \\nCHAPTER \", \"3 | Dapr at 20,000 feet \\n \\n \\nFigure 2-8. Service mesh with a side car. \\nThe previous figure shows ho\", \"w messages are intercepted by a sidecar proxy that runs alongside each \\nservice. Each proxy can be c\", \"onfigured with traffic rules specific to the service. It understands messages \\nand can route them ac\", \"ross your services and the outside world. \\nSo the question becomes, \\u201cIs Dapr a service mesh?\\u201d. \\nWhil\", \"e both use a sidecar architecture, each technology has a different purpose. Dapr provides \\ndistribut\", \"ed application features. A service mesh provides a dedicated network infrastructure layer. \\nAs each \", \"works at a different level, both can work together in the same application. For example, a \\nservice \", \"mesh could provide networking communication between services. Dapr could provide \\napplication servic\", \"es such as state management or actor services. \\nFigure 2-9 shows an application that implements both\", \" Dapr and service mesh technology. \\n \\n18 \\nCHAPTER 3 | Dapr at 20,000 feet \\n \\n \\nFigure 2-9. Dapr and \", \"service mesh together. \\nThe Dapr online documentation cover Dapr and service mesh integration. \\nSumm\", \"ary \\nThis chapter introduced you to Dapr, a Distributed Application Runtime. \\nDapr is an open-source\", \" project sponsored by Microsoft with close collaboration from customers and \\nthe open-source communi\", \"ty. \\nAt its core, Dapr helps reduce the inherent complexity of distributed microservice applications\", \". It\\u2019s \\nbuilt upon a concept of building block APIs. Dapr building blocks expose common distributed \", \"\\napplication capabilities, such as state management, service-to-service invocation, and pub/sub \\nmes\", \"saging. Dapr components lie beneath the building blocks and provide the concrete \\nimplementation for\", \" each capability. Applications bind to various components through configuration \\nfiles. \\nIn the next\", \" chapters, we present practical, hands-on instruction on how to use Dapr in your \\napplications. \\nRef\", \"erences \\n\\u2022 \\nDapr documentation \\n\\u2022 \\nLearning Dapr \\n\\u2022 \\n.NET Microservices: Architecture for Containeri\", \"zed .NET applications \\n\\u2022 \\nArchitecting Cloud-Native .NET Apps for Azure \\n \\n19 \\nCHAPTER 4 | Get start\", \"ed with Dapr \\n \\nCHAPTER 4 \\nGet started with Dapr \\nIn the first two chapters, you learned basic conce\", \"pts about Dapr. It\\u2019s time to take it for a test drive. This \\nchapter will guide you through preparin\", \"g your local development environment and building two Dapr \\n.NET applications. \\nInstall Dapr into yo\", \"ur local environment \\nYou\\u2019ll start by installing Dapr on your development computer. Once complete, y\", \"ou can build and run \\nDapr applications in self-hosted mode. \\n1. \\nInstall the Dapr CLI. It enables y\", \"ou to launch, run, and manage Dapr instances. It also provides \\ndebugging support. \\n2. \\nInstall Dock\", \"er Desktop. If you\\u2019re running on Windows, make sure that Docker Desktop for \\nWindows is configured t\", \"o use Linux containers. \\n  \\n[!NOTE] By default, Dapr uses Docker containers to provide you the best \", \"out-of-the-box \\nexperience. To run Dapr outside of Docker, you can skip this step and execute a slim\", \" \\ninitialization. The examples in this chapter require you use Docker containers. \\n3. \\nInitialize Da\", \"pr. This step sets up your development environment by installing the latest Dapr \\nbinaries and conta\", \"iner images. \\n4. \\nInstall the .NET 7 SDK. \\nNow that Dapr is installed, it\\u2019s time to build your first\", \" Dapr application! \\nBuild your first Dapr application \\nYou\\u2019ll start by building a simple .NET Consol\", \"e application that consumes the Dapr state management \\nbuilding block. \\nCreate the application \\n1. \\n\", \"Open up the command shell or terminal of your choice. You might consider the terminal \\ncapabilities \", \"in Visual Studio Code. Navigate to the root folder in which you want to build your \\napplication. Onc\", \"e there, enter the following command to create a new .NET Console application: \\ndotnet new console -\", \"o DaprCounter \\nThe command scaffolds a simple \\\"Hello World\\\" .NET application. \\n \\n20 \\nCHAPTER 4 | Get\", \" started with Dapr \\n \\n1. \\nThen, navigate into the new directory created by the previous command: \\ncd\", \" DaprCounter \\n1. \\nRun the newly created application using the dotnet run command. Doing so writes \\u201cH\", \"ello \\nWorld!\\u201d to the console screen: \\ndotnet run \\nAdd Dapr State Management \\nNext, you\\u2019ll use the Da\", \"pr state management building block to implement a stateful counter in the \\nprogram. \\nYou can invoke \", \"Dapr APIs across any development platform using Dapr\\u2019s native support for HTTP and \\ngRPC. However, .\", \"NET Developers will find the Dapr .NET SDK more natural and intuitive. It provides a \\nstrongly typed\", \" .NET client to call the Dapr APIs. The .NET SDK also tightly integrates with ASP.NET \\nCore. \\n1. \\nFr\", \"om the terminal window, add the Dapr.Client NuGet package to your application: \\ndotnet add package D\", \"apr.Client \\n1. \\nOpen the Program.cs file in your favorite editor and update its contents to the foll\", \"owing code: \\nusing Dapr.Client \\nconst string storeName = \\\"statestore\\\"; \\nconst string key = \\\"counter\\\"\", \" \\nvar daprClient = new DaprClientBuilder().Build(); \\nvar counter = await daprClient.GetStateAsync<in\", \"t>(storeName, key) \\nwhile (true) \\n{ \\n    Console.WriteLine($\\\"Counter = {counter++}\\\") \\n    await dapr\", \"Client.SaveStateAsync(storeName, key, counter); \\n    await Task.Delay(1000); \\n} \\nThe updated code im\", \"plements the following steps: \\n \\n- First a new [`DaprClient`]{custom-style=Code} instance is instant\", \"iated. This class \\nenables you to interact with the Dapr sidecar. \\n- From the state store, [`DaprCli\", \"ent.GetStateAsync`]{custom-style=Code} fetches the \\nvalue for the [`counter`]{custom-style=Code} key\", \". If the key doesn't exist, the \\ndefault value for [`int`]{custom-style=Code} (which is [`0`]{custom\", \"-style=Code}) is \\nreturned. \\n- The code then iterates, writing the [`counter`]{custom-style=Code} va\", \"lue to the \\nconsole and saving an incremented value to the state store. \\n1. \\nThe Dapr CLI run comman\", \"d starts the application. It invokes the underlying Dapr runtime and \\nenables both the application a\", \"nd Dapr sidecar to run together. If you omit the app-id, Dapr will \\ngenerate a unique name for the a\", \"pplication. The final segment of the command, dotnet run, \\ninstructs the Dapr runtime to run the .NE\", \"T application. \\n  \\n[!IMPORTANT] Care must be taken to always pass an explicit app-id parameter when \", \"consuming \\nthe state management building block. The block uses the application id value as a prefix \", \"for its \\n \\n21 \\nCHAPTER 4 | Get started with Dapr \\n \\nstate key for each key/value pair. If the applic\", \"ation id changes, you can no longer access the \\npreviously stored state. \\n  \\nNow run the application\", \" with the following command: \\ndapr run --app-id DaprCounter dotnet run \\nTry stopping and restarting \", \"the application. You'll see that the counter doesn't \\nreset. Instead it continues from the previousl\", \"y saved state. The Dapr building block \\nmakes the application stateful. \\nImportant \\nIt\\u2019s important t\", \"o understand your sample application communicates with a pre-configured state \\ncomponent, but has no\", \" direct dependency on it. Dapr abstracts away the dependency. As you\\u2019ll \\nshortly see, the underlying\", \" state store component can be changed with a simple configuration update. \\nYou might be wondering, w\", \"here exactly is the state stored? \\nComponent configuration files \\nWhen you first initialized Dapr fo\", \"r your local environment, it automatically provisioned a Redis \\ncontainer. Dapr then configured the \", \"Redis container as the default state store component with a \\ncomponent configuration file, entitled \", \"statestore.yaml. Here\\u2019s a look at its contents: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmeta\", \"data: \\n  name: statestore \\nspec: \\n  type: state.redis \\n  version: v1 \\n  metadata: \\n  - name: redisHo\", \"st \\n    value: localhost:6379 \\n  - name: redisPassword \\n    value: \\\"\\\" \\n  - name: actorStateStore \\n  \", \"  value: \\\"true\\\" \\n \\n \\nNote \\nDefault component configuration files are stored in the $HOME/.dapr/compo\", \"nents folder on \\nLinux/macOS, and in the %USERPROFILE%\\\\.dapr\\\\components folder on Windows. \\nNote the\", \" format of the previous component configuration file: \\n\\u2022 \\nEach component has a name. In the sample a\", \"bove, the component is named statestore. We \\nused that name in our first code example to tell the Da\", \"pr sidecar which component to use. \\n\\u2022 \\nEach component configuration file has a spec section. It cont\", \"ains a type field that specifies the \\ncomponent type. The version field specifies the component vers\", \"ion. The metadata field \\n \\n22 \\nCHAPTER 4 | Get started with Dapr \\n \\ncontains information that the co\", \"mponent requires, such as connection details and other settings. \\nThe metadata values will vary for \", \"the different types of components. \\nA Dapr sidecar can consume any Dapr component configured in your\", \" application. But, what if you had \\nan architectural justification to limit the accessibility of a c\", \"omponent? How could you restrict the Redis \\ncomponent to Dapr sidecars running only in a production \", \"environment? \\nTo do so, you could define a namespace for the production environment. You might name \", \"it \\nproduction. In self-hosted mode, you specify the namespace of a Dapr sidecar by setting the \\nNAM\", \"ESPACE environment variable. When configured, the Dapr sidecar will only load the components \\nthat m\", \"atch the namespace. For Kubernetes deployments, the Kubernetes namespace determines the \\ncomponents \", \"that are loaded. The following sample shows the Redis component placed in a \\nproduction namespace. N\", \"ote the namespace declaration in the metadata element: \\napiVersion: dapr.io/v1alpha1 \\nkind: Componen\", \"t \\nmetadata: \\n  name: statestore \\n  namespace: production \\nspec: \\n  type: state.redis \\n  version: v1\", \" \\n  metadata: \\n  - name: redisHost \\n    value: localhost:6379 \\n  - name: redisPassword \\n    value: \\\"\", \"\\\" \\n  - name: actorStateStore \\n    value: \\\"true\\\" \\n \\n \\nImportant \\nA namespaced component is only acces\", \"sible to applications running in the same namespace. If your \\nDapr application fails to load a compo\", \"nent, make sure that the application namespace matches the \\ncomponent namespace. This can be especia\", \"lly tricky in self-hosted mode where the application \\nnamespace is stored in a NAMESPACE environment\", \" variable. \\nIf needed, you could further restrict a component to a particular application. Within th\", \"e production \\nnamespace, you may want to limit access of the Redis cache to only the DaprCounter app\", \"lication. You \\ndo so by specifying scopes in the component configuration. The following example show\", \"s how to \\nrestrict access to the Redis statestore component to the application DaprCounter in the pr\", \"oduction \\nnamespace: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: statestore \\n\", \"  namespace: production \\nspec: \\n  type: state.redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost\", \" \\n \\n23 \\nCHAPTER 4 | Get started with Dapr \\n \\n    value: localhost:6379 \\n  - name: redisPassword \\n   \", \" value: \\\"\\\" \\n  - name: actorStateStore \\n    value: \\\"true\\\" \\n  scopes: \\n  - DaprCounter \\nBuild a multi-\", \"container Dapr application \\nIn the first example, you created a simple .NET console application that\", \" ran side-by-side with a Dapr \\nsidecar. Modern distributed applications, however, often consist of m\", \"any moving parts. They can \\nsimultaneously run independent microservices. These modern applications \", \"are typically containerized \\nand require container orchestration tools such as Docker Compose or Kub\", \"ernetes. \\nIn the next example, you\\u2019ll create a multi-container application. You\\u2019ll also use the Dapr\", \" service \\ninvocation building block to communicate between services. The solution will consist of a \", \"web \\napplication that retrieves weather forecasts from a web API. They will each run in a Docker con\", \"tainer. \\nYou\\u2019ll use Docker Compose to run the container locally and enable debugging capabilities. \\n\", \"Make sure you\\u2019ve configured your local environment for Dapr and installed the .NET 7 Development \\nTo\", \"ols (instructions are available at the beginning of this chapter). \\nAdditionally, you\\u2019ll need to com\", \"plete this sample using Visual Studio 2022 with the ASP.NET and web \\ndevelopment workload installed.\", \" \\nCreate the application \\n1. \\nIn Visual Studio 2022, create an ASP.NET Core Web App project: \\n \\n24 \\n\", \"CHAPTER 4 | Get started with Dapr \\n \\n \\n1. \\nName your project MyFrontEnd and your solution DaprMultiC\", \"ontainer: \\n \\n25 \\nCHAPTER 4 | Get started with Dapr \\n \\n \\n1. \\nIn the final dialog, keep the defaults. \", \"Don\\u2019t select Enable Docker Support. You\\u2019ll add Docker \\nsupport later. \\n \\n26 \\nCHAPTER 4 | Get started\", \" with Dapr \\n \\n \\n1. \\nFor the backend, add an ASP.NET Core Web API project to the same solution: \\n \\n27\", \" \\nCHAPTER 4 | Get started with Dapr \\n \\n \\n1. \\nName the project MyBackEnd: \\n \\n1. \\nBy default, a Dapr s\", \"idecar relies on the network boundary to limit access to its public API. So, \\nclear the checkbox for\", \" Configure for HTTPS: \\n \\n> [!IMPORTANT] \\n> If you leave the **Configure for HTTPS** checkbox checked\", \", the generated ASP.NET \\nCore API project includes middleware to redirect client requests to the HTT\", \"PS \\nendpoint. This breaks communication between the Dapr sidecar and your application, \\nunless you e\", \"xplicitly configure the use of HTTPS when running your Dapr application. \\nTo enable the Dapr sidecar\", \" to communicate over HTTPS, include the [`--app-\\nssl`]{custom-style=Code} flag in the Dapr command t\", \"o start the application. Also \\nspecify the HTTPS port using the [`--app-port`]{custom-style=Code} pa\", \"rameter. The \\nremainder of this walkthrough uses plain HTTP communication between the sidecar and \\nt\", \"he application, and requires you to clear the **Configure for HTTPS** checkbox. \\nAdd Dapr service in\", \"vocation \\nNow, you\\u2019ll configure communication between the services using Dapr service invocation bui\", \"lding \\nblock. You\\u2019ll enable the web app to retrieve weather forecasts from the web API. The service \", \"\\ninvocation building block features many benefits. It includes service discovery, automatic retries,\", \" \\nmessage encryption (using mTLS), and improved observability. You\\u2019ll use the Dapr .NET SDK to invok\", \"e \\nthe service invocation API on the Dapr sidecar. \\n \\n28 \\nCHAPTER 4 | Get started with Dapr \\n \\n1. \\nI\", \"n Visual Studio, open the Package Manager Console (Tools > NuGet Package Manager > \\nPackage Manager \", \"Console) and make sure that MyFrontEnd is the default project. From the \\nconsole, add the Dapr.AspNe\", \"tCore NuGet package to the project: \\nInstall-Package Dapr.AspNetCore \\n1. \\nIn the MyFrontEnd project,\", \" open the Program.cs file and add a call to \\nbuilder.Services.AddDaprClient: \\nvar builder = WebAppli\", \"cation.CreateBuilder(args) \\n// Add services to the container. \\nbuilder.Services.AddDaprClient(); \\nbu\", \"ilder.Services.AddRazorPages() \\n// ... \\nThe [`AddDaprClient`]{custom-style=Code} call registers the \", \"[`DaprClient`]{custom-\\nstyle=Code} class with the ASP.NET Core dependency injection system. With the\", \" client \\nregistered, you can now inject an instance of [`DaprClient`]{custom-style=Code} into \\nyour \", \"service code to communicate with the Dapr sidecar, building blocks, and \\ncomponents. \\n1. \\nAdd a new \", \"C# class file named WeatherForecast to the MyFrontEnd project: \\nnamespace MyFrontEnd \\npublic class W\", \"eatherForecast \\n{ \\n    public DateTime Date { get; set;  \\n    public int TemperatureC { get; set;  \\n\", \"    public int TemperatureF { get; set;  \\n    public string Summary { get; set; } = string.Empty; \\n}\", \" \\n1. \\nOpen the Index.cshtml.cs file in the Pages folder, and replace its contents with the following\", \" \\ncode: \\nusing Dapr.Client; \\nusing Microsoft.AspNetCore.Mvc.RazorPages \\nnamespace MyFrontEnd.Pages \\n\", \"public class IndexModel : PageModel \\n{ \\n    private readonly DaprClient _daprClient \\n    public Inde\", \"xModel(DaprClient daprClient) \\n    { \\n        _daprClient = daprClient; \\n     \\n    public async Task\", \" OnGet() \\n    { \\n        var forecasts = await _daprClient.InvokeMethodAsync<IEnumerable<WeatherFore\", \"cast>>( \\n            HttpMethod.Get, \\n            \\\"MyBackEnd\\\", \\n            \\\"weatherforecast\\\") \\n    \", \"    ViewData[\\\"WeatherForecastData\\\"] = forecasts; \\n    } \\n} \\nYou add Dapr capabilities into the web a\", \"pp by injecting the [`DaprClient`]{custom-\\nstyle=Code} class into [`IndexModel`]{custom-style=Code} \", \"constructor. In the \\n[`OnGet`]{custom-style=Code} method, you call the backend API service with the \", \"Dapr \\nservice invocation building block. The [`OnGet`]{custom-style=Code} method is invoked \\n \\n29 \\nC\", \"HAPTER 4 | Get started with Dapr \\n \\nwhenever a user visits the home page. You use the \\n[`DaprClient.\", \"InvokeMethodAsync`]{custom-style=Code} method to invoke the \\n[`weatherforecast`]{custom-style=Code} \", \"method of the [`MyBackEnd`]{custom-style=Code} \\nservice. You'll configure the web API to use [`MyBac\", \"kEnd`]{custom-style=Code} as its \\napplication ID later on when configuring it to run with Dapr. Fina\", \"lly, the service \\nresponse is saved in view data. \\n1. \\nReplace the contents of the Index.cshtml file\", \" in the Pages folder, with the following code. It \\ndisplays the weather forecasts stored in the view\", \" data to the user: \\n@page \\n@model IndexModel \\n@{ \\n    ViewData[\\\"Title\\\"] = \\\"Home page\\\"; \\n \\n<div class\", \"=\\\"text-center\\\"> \\n    <h1 class=\\\"display-4\\\">Welcome</h1> \\n    <p>Learn about <a href=\\\"https://learn.m\", \"icrosoft.com/aspnet/core\\\">building Web apps with \\nASP.NECore</a>.</p> \\n    @foreach (var forecast in\", \" \\n(IEnumerable<WeatherForecast>)ViewData[\\\"WeatherForecastData\\\"]!) \\n    { \\n        <p>The forecast fo\", \"r @forecast.Date is @forecast.Summary!</p> \\n    } \\n</div> \\nAdd container support \\nIn the final part \", \"of this example, you\\u2019ll add container support and run the solution using Docker \\nCompose. \\n1. \\nRight\", \"-click the MyFrontEnd project, and choose Add > Container Orchestrator Support\\u2026. The \\nAdd Container \", \"Orchestrator Support dialog appears: \\n \\nChoose **Docker Compose**. \\n1. \\nIn the next dialog, select L\", \"inux as the Target OS: \\n \\n30 \\nCHAPTER 4 | Get started with Dapr \\n \\n \\nVisual Studio creates a *docker\", \"-compose.yml*file and a *.dockerignore* file in the \\n**docker-compose** folder in the solution: \\n \\n3\", \"1 \\nCHAPTER 4 | Get started with Dapr \\n \\n \\nThe *docker-compose.yml* file has the following content: \\n\", \"version: '3.4 \\nservices: \\nmyfrontend: \\n    image: ${DOCKER_REGISTRY-}myfrontend \\n    build: \\n    con\", \"text: . \\n    dockerfile: MyFrontEnd/Dockerfile \\nThe *.dockerignore* file contains file types and ext\", \"ensions that you don't want Docker \\nto include in the container. These files are associated with the\", \" development \\nenvironment and source control and not the app or service you're deploying. \\n \\n32 \\nCHA\", \"PTER 4 | Get started with Dapr \\n \\n \\nIn the root of the *MyFrontEnd* project directory, a new *Docker\", \"file* was created. A \\n*Dockerfile* is a sequence of commands that are used to build an image. For mo\", \"re \\ninformation, see [Dockerfile \\nreference](https://docs.docker.com/engine/reference/builder). \\n \\nT\", \"he *Dockerfile* contains the following commands: \\nFROM mcr.microsoft.com/dotnet/aspnet:7.0 AS base \\n\", \"WORKDIR /app \\nEXPOSE 80 \\nEXPOSE 44 \\nFROM mcr.microsoft.com/dotnet/sdk:7.0 AS build \\nWORKDIR /src \\nCO\", \"PY [\\\"MyFrontEnd/MyFrontEnd.csproj\\\", \\\"MyFrontEnd/\\\"] \\nRUN dotnet restore \\\"MyFrontEnd/MyFrontEnd.csproj\", \"\\\" \\nCOPY . . \\nWORKDIR \\\"/src/MyFrontEnd\\\" \\nRUN dotnet build \\\"MyFrontEnd.csproj\\\" -c Release -o /app/buil\", \" \\nFROM build AS publish \\nRUN dotnet publish \\\"MyFrontEnd.csproj\\\" -c Release -o /app/publis \\nFROM base\", \" AS final \\nWORKDIR /app \\nCOPY --from=publish /app/publish . \\nENTRYPOINT [\\\"dotnet\\\", \\\"MyFrontEnd.dll\\\"]\", \" \\nThe preceding *Dockerfile* sequentially performs the following steps when invoked: \\n \\n1. Pulls the\", \" [`mcr.microsoft.com/dotnet/aspnet:7.0`]{custom-style=Code} image and \\nnames it [`base`]{custom-styl\", \"e=Code}. \\n2. Sets the working directory to */app*. \\n3. Exposes port [`80`]{custom-style=Code} and [`\", \"443`]{custom-style=Code}. \\n4. Pulls the [`mcr.microsoft.com/dotnet/sdk:7.0`]{custom-style=Code} imag\", \"e and names \\nit [`build`]{custom-style=Code}. \\n5. Sets the working directory to */src*. \\n6. Copies t\", \"he _MyFrontEnd/MyFrontEnd.csproj_ to a new directory named *MyFrontEnd/*. \\n7. Calls [[`dotnet restor\", \"e`]{custom-style=Code}](https://docs.microsoft.com/en-\\nus/dotnet/core/tools/dotnet-restore) on the p\", \"roject. \\n8. Copies everything from the root directory into the image's root. \\n9. Sets the working di\", \"rectory to _/src/MyFrontEnd_. \\n10. Calls [[`dotnet build`]{custom-style=Code}](https://docs.microsof\", \"t.com/en-\\nus/dotnet/core/tools/dotnet-build) on the project. \\n    - Targeting the **Release** config\", \"uration and outputs to */app/build*. \\n11. Initializes a new build stage from the existing [`build`]{\", \"custom-style=Code} base \\nimage and names it [`publish`]{custom-style=Code}. \\n12. Calls [`dotnet publ\", \"ish`]{custom-style=Code} on the project. \\n    - Targeting the **Release** configuration and outputs \", \"to */app/publish*. \\n13. Initializes a new build stage from the existing [`publish`]{custom-style=Cod\", \"e} \\nbase image and names it [`final`]{custom-style=Code}. \\n14. Sets the working directory to */app*.\", \" \\n15. Copies the [`/app/publish`]{custom-style=Code} directory from the \\n[`publish`]{custom-style=Co\", \"de} image into the root of the [`final`]{custom-style=Code} \\nimage. \\n16. Sets the entry point as the\", \" image to [`dotnet`]{custom-style=Code} and passes the \\n[`MyFrontEnd.dll`]{custom-style=Code} as an \", \"arg. \\n \\n33 \\nCHAPTER 4 | Get started with Dapr \\n \\n1. \\nIn the MyBackEnd web API project, right-click o\", \"n the project node, and choose Add > Container \\nOrchestrator Support\\u2026. Choose Docker Compose, and th\", \"en select Linux again as the target \\nOS. \\n  \\nIn the root of the MyBackEnd project directory, a new D\", \"ockerfile was created. The Dockerfile \\ncontains the following commands: \\nFROM mcr.microsoft.com/dotn\", \"et/aspnet:7.0 AS base \\nWORKDIR /app \\nEXPOSE 8 \\nFROM mcr.microsoft.com/dotnet/sdk:7.0 AS build \\nWORKD\", \"IR /src \\nCOPY [\\\"MyBackEnd/MyBackEnd.csproj\\\", \\\"MyBackEnd/\\\"] \\nRUN dotnet restore \\\"MyBackEnd/MyBackEnd.\", \"csproj\\\" \\nCOPY . . \\nWORKDIR \\\"/src/MyBackEnd\\\" \\nRUN dotnet build \\\"MyBackEnd.csproj\\\" -c Release -o /app/\", \"buil \\nFROM build AS publish \\nRUN dotnet publish \\\"MyBackEnd.csproj\\\" -c Release -o /app/publis \\nFROM b\", \"ase AS final \\nWORKDIR /app \\nCOPY --from=publish /app/publish . \\nENTRYPOINT [\\\"dotnet\\\", \\\"MyBackEnd.dll\", \"\\\"] \\nOpen the *docker-compose.yml* file again and examine its contents. Visual Studio has \\nupdated th\", \"e **Docker Compose** file. Now both services are included: \\nversion: '3.4 \\nservices: \\n  myfrontend: \", \"\\n    image: ${DOCKER_REGISTRY-}myfrontend \\n    build: \\n      context: . \\n      dockerfile: MyFrontEn\", \"d/Dockerfil \\n  mybackend: \\n    image: ${DOCKER_REGISTRY-}mybackend \\n    build: \\n      context: . \\n  \", \"    dockerfile: MyBackEnd/Dockerfile \\n1. \\nTo use Dapr building blocks from inside a containerized ap\", \"plication, you\\u2019ll need to add the Dapr \\nsidecars containers to your Compose file. Carefully update t\", \"he content of the docker-\\ncompose.yml file to match the following example. Pay close attention to th\", \"e formatting and \\nspacing and don\\u2019t use tabs. \\nversion: '3.4 \\nservices: \\n  myfrontend: \\n    image: $\", \"{DOCKER_REGISTRY-}myfrontend \\n    build: \\n      context: . \\n      dockerfile: MyFrontEnd/Dockerfile \", \"\\n    ports: \\n      - \\\"51000:50001 \\n  myfrontend-dapr: \\n    image: \\\"daprio/daprd:latest\\\" \\n    command\", \": [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyFrontEnd\\\", \\\"-app-port\\\", \\\"80\\\" ] \\n    depends_on: \\n \\n34 \\nCHAPTER 4 | Get \", \"started with Dapr \\n \\n      - myfrontend \\n    network_mode: \\\"service:myfrontend \\n  mybackend: \\n    im\", \"age: ${DOCKER_REGISTRY-}mybackend \\n    build: \\n      context: . \\n      dockerfile: MyBackEnd/Dockerf\", \"ile \\n    ports: \\n      - \\\"52000:50001 \\n  mybackend-dapr: \\n    image: \\\"daprio/daprd:latest\\\" \\n    comm\", \"and: [ \\\"./daprd\\\", \\\"-app-id\\\", \\\"MyBackEnd\\\", \\\"-app-port\\\", \\\"80\\\" ] \\n    depends_on: \\n      - mybackend \\n \", \"   network_mode: \\\"service:mybackend\\\" \\nIn the updated file, we've added [`myfrontend-dapr`]{custom-st\", \"yle=Code} and \\n[`mybackend-dapr`]{custom-style=Code} sidecars for the [`myfrontend`]{custom-\\nstyle=C\", \"ode} and [`mybackend`]{custom-style=Code} services respectively. In the updated \\nfile, pay close att\", \"ention to the following changes: \\n \\n- The sidecars use the [`daprio/daprd:latest`]{custom-style=Code\", \"} container image. The \\nuse of the [`latest`]{custom-style=Code} tag isn't recommended for productio\", \"n \\nscenarios. For production, it's better to use a specific version number. \\n- Each service defined \", \"in the Compose file has its own network namespace for network \\nisolation purposes. The sidecars use \", \"[`network_mode: \\\"service:...\\\"`]{custom-\\nstyle=Code} to ensure they run in the same network namespace\", \" as the application. Doing \\nso allows the sidecar and the application to communicate using [`localho\", \"st`]{custom-\\nstyle=Code}. \\n- The ports on which the Dapr sidecars are listening for gRPC communicati\", \"on (by \\ndefault 50001) must be exposed to allow the sidecars to communicate with each other. \\n1. \\nRu\", \"n the solution (F5 or Ctrl+F5) to verify that it works as expected. If everything is configured \\ncor\", \"rectly, you should see the weather forecast data: \\n \\n35 \\nCHAPTER 4 | Get started with Dapr \\n \\n \\nRunn\", \"ing locally with Docker Compose and Visual Studio, you can set breakpoints and \\ndebug into the appli\", \"cation. For production scenarios, it's recommended to host your \\napplication in Kubernetes. This boo\", \"k includes an accompanying reference application, \\n[eShopOnDapr](https://github.com/dotnet-architect\", \"ure/eShopOnDapr), that contains \\nscripts to deploy to Kubernetes. \\n \\nTo learn more about the Dapr se\", \"rvice invocation building block used in this \\nwalkthrough, refer to [chapter 6](#the-dapr-service-in\", \"vocation-building-blo). \\nSummary \\nIn this chapter, you had an opportunity to test drive Dapr. Using \", \"the Dapr .NET SDK, you saw how \\nDapr integrates with the .NET application platform. \\nThe first examp\", \"le was a simple, stateful, .NET Console application that used the Dapr state \\nmanagement building bl\", \"ock. \\nThe second example involved a multi-container application running in Docker. By using Visual S\", \"tudio \\nwith Docker Compose, you experienced the familiar F5 debugging experience available across al\", \"l .NET \\napps. \\nYou also got a closer look at Dapr component configuration files. They configure the \", \"actual \\ninfrastructure implementation used by the Dapr building blocks. You can use namespaces and s\", \"copes \\nto restrict component access to particular environments and applications. \\nIn the upcoming ch\", \"apters, you\\u2019ll dive deep into the building blocks offered by Dapr. \\nReferences \\n\\u2022 \\nDapr documentatio\", \"n - Getting started \\n\\u2022 \\neShopOnDapr \\n \\n36 \\nCHAPTER 5 | Traffic Control sample application \\n \\nCHAPTER\", \" 5 \\nTraffic Control sample \\napplication \\nIn the first chapters, you\\u2019ve learned about basic Dapr conc\", \"epts. You saw how Dapr can help you and \\nyour team construct distributed applications while reducing\", \" architectural and operational complexity. \\nThis chapter introduces the sample application that you\\u2019\", \"ll use to explore the Dapr building blocks. The \\napplication targets .NET 7 and uses the latest C# 1\", \"1 language features. \\nNote \\nDownload the sample application code from the Dapr Traffic Control GitHu\", \"b repo. This repository \\ncontains a detailed description on how you can run the sample application o\", \"n your machine. \\nThe Traffic Control sample application simulates a highway traffic control system. \", \"Its purpose is to \\ndetect speeding vehicles and send the offending driver a fine notice. These syste\", \"ms actually exist in \\nreal life and here\\u2019s how they work. A set of cameras (one above each lane) is \", \"placed at the beginning \\nand end of a highway stretch (say 10 kilometers) without on- or off-ramps. \", \"As a vehicle passes \\nunderneath a camera, it takes a photograph of the vehicle. Using Optical Charac\", \"ter Recognition (OCR) \\nsoftware, it extracts the license number of the vehicle from the photo. Using\", \" the entry- and exit-\\ntimestamp of each vehicle, the system calculates the average speed of that veh\", \"icle. If the average \\nspeed is above the maximum speed limit for that highway stretch, the system re\", \"trieves the driver \\ninformation and automatically sends a fine notice. \\nAlthough the simulation is s\", \"imple, responsibilities within the system are separated into several \\nmicroservices. Figure 4.1 show\", \"s an overview of the services that are part of the application: \\n \\n37 \\nCHAPTER 5 | Traffic Control s\", \"ample application \\n \\n \\n \\n38 \\nCHAPTER 5 | Traffic Control sample application \\n \\nFigure 4-1. The servi\", \"ces in the sample application. \\n\\u2022 \\nThe Camera Simulation is a console application that simulates veh\", \"icles and sends messages to \\nthe TrafficControl service. Every simulated car invokes both the entry \", \"and exit service endpoints. \\n\\u2022 \\nThe TrafficControl service is an ASP.NET Core Web API application th\", \"at exposes the /entrycam \\nand /exitcam endpoints. Invoking an endpoint simulates a car passing under\", \" one of the entry- \\nor exit-cameras respectively. The request message payload simply contains the li\", \"cense plate of \\nthe car (no actual OCR is implemented). \\n\\u2022 \\nThe FineCollection service is an ASP.NET\", \" Core Web API application that offers 1 endpoint: \\n/collectfine. Invoking this endpoint will send a \", \"fine notice to the driver of the speeding \\nvehicle. The payload of the request contains all the info\", \"rmation about the speeding violation. \\n\\u2022 \\nThe VehicleRegistration service is an ASP.NET Core Web API\", \" application that offers 1 endpoint: \\n/vehicleinfo/{licensenumber}. It\\u2019s used for obtaining vehicle-\", \" and owner-information for a \\nspeeding vehicle based on the license number sent in the URL (for exam\", \"ple, /vehicleinfo/RV-\\n752-S). \\nThe sequence diagram in figure 4.2 shows the simulation flow: \\n \\nFigu\", \"re 4-2. Sequence diagram of the simulation flow. \\nThe services communicate by directly invoking each\", \" other\\u2019s APIs. This design works fine, but it has \\nsome drawbacks. \\n \\n39 \\nCHAPTER 5 | Traffic Contro\", \"l sample application \\n \\nThe biggest challenge is that the call-chain will break if one of the servic\", \"es is off-line. Decoupling \\nservices by replacing direct calls with asynchronous messaging would sol\", \"ve this issue. Asynchronous \\nmessaging is typically implemented with a message broker like RabbitMQ \", \"or Azure Service Bus. \\nAnother drawback is that the vehicle state for every vehicle is stored in mem\", \"ory in the TrafficControl \\nservice. This state is lost when the service is restarted after an update\", \" or a crash. To increase system \\ndurability, state should be stored outside the service. \\nUsing Dapr\", \" building blocks \\nOne of the goals of Dapr is to provide cloud-native capabilities for microservices\", \" applications. The \\nTraffic Control application uses Dapr building blocks to increase robustness and\", \" mitigate the design \\ndrawbacks described in the previous paragraph. Figure 4.shows a Dapr-enabled v\", \"ersion of the traffic \\ncontrol application: \\n \\nFigure 4-3. Traffic Control application with Dapr bui\", \"lding blocks. \\n1. \\nService invocation The Dapr service invocation building block handles request/res\", \"ponse \\ncommunication between the FineCollectionService and the VehicleRegistrationService. Because \\n\", \"the call is a query to retrieve required data to complete the operation, a synchronous call is \\nacce\", \"ptable here. The service invocation building block provides service discovery. The \\nFineCollection s\", \"ervice no longer has to know where the VehicleRegistration service lives. It also \\nimplements automa\", \"tic retries if the VehicleRegistration service is off-line. \\n2. \\nPublish & subscribe The publish and\", \" subscribe building block handles asynchronous messaging \\nfor sending speeding violations from the T\", \"rafficControl service to the FineCollectionService. This \\nimplementation decouples the TrafficContro\", \"l and FineCollection service. If the \\nFineCollectionService were to become temporarily unavailable, \", \"data would accumulate in the \\nqueue and resume processing at a later time. RabbitMQ is the current m\", \"essage broker that \\ntransports messages from the producers to the consumers. As the Dapr pub/sub bui\", \"lding block \\nabstracts the message broker, developers don\\u2019t need to learn the details of the RabbitM\", \"Q client \\nlibrary. Switching to another message broker doesn\\u2019t require code changes, only configurat\", \"ion. \\n \\n3. \\nState management The TrafficControl service uses the state management building block to \", \"\\npersist vehicle state outside of the service in a Redis cache. As with pub/sub, developers don\\u2019t \\nn\", \"eed to learn Redis specific APIs. Switching to another data store requires no code changes. \\n4. \\nOut\", \"put binding The FineCollection service sends fines to the owners of speeding vehicles by \\nemail. The\", \" Dapr output binding for SMTP abstracts the email transmission using the SMTP \\nprotocol. \\n5. \\nInput \", \"binding The CameraSimulation sends messages with simulated car info to the \\nTrafficControl service u\", \"sing the MQTT protocol. It uses a .NET MQTT library for sending \\nmessages to Mosquitto - a lightweig\", \"ht MQTT broker. The TrafficControl service uses the Dapr \\ninput binding for MQTT to subscribe to the\", \" MQTT broker and receive messages. \\n6. \\nSecrets management The FineCollectionService needs credentia\", \"ls for connecting to the smtp \\nserver and a license-key for a fine calculator component it uses inte\", \"rnally. It uses the secrets \\nmanagement building block to obtain the credentials and the license-key\", \". \\n \\n40 \\nCHAPTER 5 | Traffic Control sample application \\n \\n7. \\nActors The TrafficControlService has \", \"an alternative implementation based on Dapr actors. In this \\nimplementation, the TrafficControl serv\", \"ice creates a new actor for every vehicle that is registered \\nby the entry camera. The license numbe\", \"r of the vehicle forms the unique actor Id. The actor \\nencapsulates the vehicle state, which it pers\", \"ists in the Redis cache. When a vehicle is registered \\nby the exit camera, it invokes the actor. The\", \" actor then calculate the average speed and possibly \\nissue a speeding violation. \\nFigure 4.4 shows \", \"a sequence diagram of the flow of the simulation with all the Dapr building blocks in \\nplace: \\n \\nFig\", \"ure 4-4. Sequence diagram of simulation flow with Dapr building blocks. \\nThe rest of this book featu\", \"res a chapter for each of the Dapr building blocks. Each chapter explains in \\ndetail how the buildin\", \"g block works, its configuration, and how to use it. Each chapter explains how \\nthe Traffic Control \", \"sample application uses the building block. \\nHosting \\nThe Traffic Control sample application can run\", \" in self-hosted mode or in Kubernetes. \\nSelf-hosted mode \\nThe sample repository contains PowerShell \", \"scripts to start the infrastructure services (Redis, \\nRabbitMQ, and Mosquitto) as Docker containers \", \"on your machine. They\\u2019re located in the \\nsrc/Infrastructure folder. For every application service in\", \" the solution, the repository contains a \\nseparate folder. Each of these folders contains a start-se\", \"lfhosted.ps1 PowerShell script to start the \\nservice with Dapr. \\n \\n41 \\nCHAPTER 5 | Traffic Control s\", \"ample application \\n \\nKubernetes \\nThe src/k8s folder in the sample repository contains the Kubernetes\", \" manifest files to run the \\napplication (including the infrastructure services) with Dapr in Kuberne\", \"tes. This folder also contains a \\nstart.ps1 and stop.ps1 PowerShell script to start and stop the sol\", \"ution in Kubernetes. All services \\nwill run in the dapr-trafficcontrol namespace. \\nSummary \\nThe Traf\", \"fic Control sample application is a microservices application that simulates a highway speed \\ntrap. \", \"\\nThe application uses several Dapr building blocks to make it robust and cloud-native. The domain is\", \" \\nkept simple to keep the focus on Dapr. \\nThe application will be used in the following chapters tha\", \"t focus on Dapr building block. \\nReferences \\n\\u2022 \\nDapr Traffic Control Sample \\n \\n42 \\nCHAPTER 6 | The D\", \"apr state management building block \\n \\nCHAPTER 6 \\nThe Dapr state \\nmanagement building \\nblock \\nDistri\", \"buted applications are composed of independent services. While each service should be \\nstateless, so\", \"me services must track state to complete business operations. Consider a shopping basket \\nservice fo\", \"r an e-Commerce site. If the service can\\u2019t track state, the customer could lose the shopping \\nbasket\", \" content by leaving the website, resulting in a lost sale and an unhappy customer experience. \\nFor t\", \"hese scenarios, state needs to be persisted to a distributed state store. The Dapr state \\nmanagement\", \" building block simplifies state tracking and offers advanced features across various data \\nstores. \", \"\\nTo try out the state management building block, have a look at the counter application sample in \\nc\", \"hapter 3. \\nWhat it solves \\nTracking state in a distributed application can be challenging. For examp\", \"le: \\n\\u2022 \\nThe application may require different types of data stores. \\n\\u2022 \\nDifferent consistency levels\", \" may be required for accessing and updating data. \\n\\u2022 \\nMultiple users may update data at the same tim\", \"e, requiring conflict resolution. \\n\\u2022 \\nServices must retry any short-lived transient errors that occu\", \"r while interacting with the data \\nstore. \\nThe Dapr state management building block addresses these \", \"challenges. It streamlines tracking state \\nwithout dependencies or a learning curve on third-party s\", \"torage SDKs. \\nImportant \\nDapr state management offers a key/value API. The feature doesn\\u2019t support r\", \"elational or graph data \\nstorage. \\n \\n43 \\nCHAPTER 6 | The Dapr state management building block \\n \\nHow\", \" it works \\nThe application interacts with a Dapr sidecar to store and retrieve key/value data. Under\", \" the hood, the \\nsidecar API consumes a configurable state store component to persist data. Developer\", \"s can choose \\nfrom a growing collection of supported state stores that include Azure Cosmos DB, SQL \", \"Server, and \\nCassandra. \\nThe API can be called with either HTTP or gRPC. Use the following URL to ca\", \"ll the HTTP API: \\nhttp://localhost:<dapr-port>/v1.0/state/<store-name>/ \\n\\u2022 \\n<dapr-port>: the HTTP po\", \"rt that Dapr listens on. \\n\\u2022 \\n<store-name>: the name of the state store component to use. \\nFigure 5-1\", \" shows how a Dapr-enabled shopping basket service stores a key/value pair using the Dapr \\nstate stor\", \"e component named statestore. \\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/state-management/state-manage\", \"ment-flow.png\\u201d alt-\\ntext=\\u201cDiagram of storing a key/value pair in a Dapr state store.\\u201d::: \\nFigure 5-1\", \". Storing a key/value pair in a Dapr state store. \\nNote the steps in the previous figure: \\n1. \\nThe b\", \"asket service calls the state management API on the Dapr sidecar. The body of the request \\nencloses \", \"a JSON array that can contain multiple key/value pairs. \\n2. \\nThe Dapr sidecar determines the state s\", \"tore based on the component configuration file. In this \\ncase, it\\u2019s a Redis cache state store. \\n3. \\n\", \"The sidecar persists the data to the Redis cache. \\nRetrieving the stored data is a similar API call.\", \" In the example below, a curl command retrieves the \\ndata by calling the Dapr sidecar API: \\ncurl htt\", \"p://localhost:3500/v1.0/state/statestore/basket1 \\nThe command returns the stored state in the respon\", \"se body: \\n{ \\n  \\\"items\\\": [ \\n    { \\n      \\\"itemId\\\": \\\"DaprHoodie\\\", \\n      \\\"quantity\\\": 1 \\n    } \\n  ], \\n \", \" \\\"customerId\\\": 1 \\n} \\nThe following sections explain how to use the more advanced features of the sta\", \"te management \\nbuilding block. \\nConsistency \\nThe CAP theorem is a set of principles that apply to di\", \"stributed systems that store state. Figure 5-2 \\nshows the three properties of the CAP theorem. \\n \\n44\", \" \\nCHAPTER 6 | The Dapr state management building block \\n \\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/st\", \"ate-management/cap-theorem.png\\u201d alt-text=\\u201cThe CAP \\ntheorem.\\u201d::: \\nFigure 5-2. The CAP theorem. \\nThe t\", \"heorem states that distributed data systems offer a trade-off between consistency, availability, \\nan\", \"d partition tolerance. And, that any datastore can only guarantee two of the three properties: \\n\\u2022 \\nC\", \"onsistency (C). Every node in the cluster responds with the most recent data, even if the system \\nmu\", \"st block the request until all replicas update. If you query a \\u201cconsistent system\\u201d for an item \\nthat\", \" is currently updating, you won\\u2019t get a response until all replicas successfully update. \\nHowever, y\", \"ou\\u2019ll always receive the most current data. \\n\\u2022 \\nAvailability (A). Every node returns an immediate re\", \"sponse, even if that response isn\\u2019t the most \\nrecent data. If you query an \\u201cavailable system\\u201d for an\", \" item that is updating, you\\u2019ll get the best \\npossible answer the service can provide at that moment.\", \" \\n\\u2022 \\nPartition Tolerance (P). Guarantees the system continues to operate even if a replicated data \\n\", \"node fails or loses connectivity with other replicated data nodes. \\nDistributed applications must ha\", \"ndle the P property. As services communicate among each other with \\nnetwork calls, network disruptio\", \"ns (P) will occur. With that in mind, distributed applications must \\neither be AP or CP. \\nAP applica\", \"tions choose availability over consistency. Dapr supports this choice with its eventual \\nconsistency\", \" strategy. Consider an underlying data store, such as Azure CosmosDB, which stores \\nredundant data o\", \"n multiple replicas. With eventual consistency, the state store writes the update to \\none replica an\", \"d completes the write request with the client. After this time, the store will \\nasynchronously updat\", \"e its replicas. Read requests can return data from any of the replicas, including \\nthose replicas th\", \"at haven\\u2019t yet received the latest update. \\nCP applications choose consistency over availability. Da\", \"pr supports this choice with its strong \\nconsistency strategy. In this scenario, the state store wil\", \"l synchronously update all (or, in some cases, \\na quorum of) required replicas before completing the\", \" write request. Read operations will return the \\nmost up-to-date data consistently across replicas. \", \"\\nThe consistency level for a state operation is specified by attaching a consistency hint to the ope\", \"ration. \\nThe following curl command writes a Hello=World key/value pair to a state store using a str\", \"ong \\nconsistency hint: \\ncurl -X POST http://localhost:3500/v1.0/state/<store-name> \\\\ \\n  -H \\\"Content-\", \"Type: application/json\\\" \\\\ \\n  -d '[ \\n        { \\n          \\\"key\\\": \\\"Hello\\\", \\n          \\\"value\\\": \\\"World\\\"\", \", \\n          \\\"options\\\": { \\n            \\\"consistency\\\": \\\"strong\\\" \\n          } \\n        } \\n      ]' \\n \\n\", \" \\n \\n45 \\nCHAPTER 6 | The Dapr state management building block \\n \\nImportant \\nIt is up to the Dapr stat\", \"e store component to fulfill the consistency hint attached to the operation. Not \\nall data stores su\", \"pport both consistency levels. If no consistency hint is set, the default behavior is \\neventual. \\nCo\", \"ncurrency \\nIn a multi-user application, there\\u2019s a chance that multiple users will update the same da\", \"ta concurrently \\n(at the same time). Dapr supports optimistic concurrency control (OCC) to manage co\", \"nflicts. OCC is \\nbased on an assumption that update conflicts are uncommon because users work on dif\", \"ferent parts of \\nthe data. It\\u2019s more efficient to assume an update will succeed and retry if it does\", \"n\\u2019t. The alternative, \\nimplementing pessimistic locking, can affect performance with long-running lo\", \"cking causing data \\ncontention. \\nDapr supports optimistic concurrency control (OCC) using ETags. An \", \"ETag is a value associated with a \\nspecific version of a stored key/value pair. Each time a key/valu\", \"e pair updates, the ETag value updates \\nas well. When a client retrieves a key/value pair, the respo\", \"nse includes the current ETag value. When a \\nclient updates or deletes a key/value pair, it must sen\", \"d that ETag value back in the request body. If \\nanother client has updated the data in the meantime,\", \" the ETags won\\u2019t match and the request will fail. \\nAt this point, the client must retrieve the updat\", \"ed data, make the change again, and resubmit the \\nupdate. This strategy is called first-write-wins. \", \"\\nDapr also supports a last-write-wins strategy. With this approach, the client doesn\\u2019t attach an ETa\", \"g \\nto the write request. The state store component will always allow the update, even if the underly\", \"ing \\nvalue has changed during the session. Last-write-wins is useful for high-throughput write scena\", \"rios \\nwith low data contention. As well, overwriting an occasional user update can be tolerated. \\nTr\", \"ansactions \\nDapr can write multi-item changes to a data store as a single operation implemented as a\", \" transaction. \\nThis functionality is only available for data stores that support ACID transactions. \", \"At the time of this \\nwriting, these stores include Redis, MongoDB, PostgreSQL, SQL Server, and Azure\", \" CosmosDB. \\nIn the example below, a multi-item operation is sent to the state store in a single tran\", \"saction. All \\noperations must succeed for the transaction to commit. If one or more of the operation\", \"s fail, the \\nentire transaction rolls back. \\ncurl -X POST http://localhost:3500/v1.0/state/<store-na\", \"me>/transaction \\\\ \\n  -H \\\"Content-Type: application/json\\\" \\\\ \\n  -d '{ \\n        \\\"operations\\\": [ \\n      \", \"    { \\n            \\\"operation\\\": \\\"upsert\\\", \\n            \\\"request\\\": { \\\"key\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\"\", \" \\n            } \\n          }, \\n          { \\n            \\\"operation\\\": \\\"delete\\\", \\n            \\\"request\", \"\\\": { \\\"key\\\": \\\"Key2\\\" } \\n          } \\n \\n46 \\nCHAPTER 6 | The Dapr state management building block \\n \\n   \", \"     ] \\n      }' \\nFor data stores that don\\u2019t support transactions, multiple keys can still be sent a\", \"s a single request. The \\nfollowing example shows a bulk write operation: \\ncurl -X POST http://localh\", \"ost:3500/v1.0/state/<store-name> \\\\ \\n  -H \\\"Content-Type: application/json\\\" \\\\ \\n  -d '[ \\n        { \\\"key\", \"\\\": \\\"Key1\\\", \\\"value\\\": \\\"Value1\\\" }, \\n        { \\\"key\\\": \\\"Key2\\\", \\\"value\\\": \\\"Value2\\\" } \\n      ]' \\nFor bulk op\", \"erations, Dapr will submit each key/value pair update as a separate request to the data \\nstore. \\nUse\", \" the Dapr .NET SDK \\nThe Dapr .NET SDK provides language-specific support for the .NET platform. Deve\", \"lopers can use the \\nDaprClient class introduced in chapter 3 to read and write data. The following e\", \"xample shows how to \\nuse the DaprClient.GetStateAsync<TValue> method to read data from a state store\", \". The method \\nexpects the store name, statestore, and key, AMS, as parameters: \\nvar weatherForecast \", \"= await daprClient.GetStateAsync<WeatherForecast>(\\\"statestore\\\", \\\"AMS\\\"); \\nIf the state store contains\", \" no data for key AMS, the result will be default(WeatherForecast). \\nTo write data to the data store,\", \" use the DaprClient.SaveStateAsync<TValue> method: \\ndaprClient.SaveStateAsync(\\\"statestore\\\", \\\"AMS\\\", w\", \"eatherForecast); \\nThe example uses the last-write-wins strategy as an ETag value isn\\u2019t passed to the\", \" state store \\ncomponent. To use optimistic concurrency control (OCC) with a first-write-wins strateg\", \"y, first retrieve \\nthe current ETag using the DaprClient.GetStateAndETagAsync method. Then write the\", \" updated \\nvalue and pass along the retrieved ETag using the DaprClient.TrySaveStateAsync method. \\nva\", \"r (weatherForecast, etag) = await \\ndaprClient.GetStateAndETagAsync<WeatherForecast>(\\\"statestore\\\", ci\", \"ty); \\n \\n// ... make some changes to the retrieved weather forecast \\n \\nvar result = await daprClient.\", \"TrySaveStateAsync(\\\"statestore\\\", city, weatherForecast, etag); \\nThe DaprClient.TrySaveStateAsync meth\", \"od fails when the data (and associated ETag) has been \\nchanged in the state store after the data was\", \" retrieved. The method returns a boolean value to \\nindicate whether the call succeeded. A strategy t\", \"o handle the failure is to simply reload the updated \\ndata from the state store, make the change aga\", \"in, and resubmit the update. \\nIf you always want a write to succeed regardless of other changes to t\", \"he data, use the last-write-wins \\nstrategy. \\nThe SDK provides other methods to retrieve data in bulk\", \", delete data, and execute transactions. For \\nmore information, see the Dapr .NET SDK repository. \\n \", \"\\n47 \\nCHAPTER 6 | The Dapr state management building block \\n \\nASP.NET Core integration \\nDapr also sup\", \"ports ASP.NET Core, a cross-platform framework for building modern cloud-based web \\napplications. Th\", \"e Dapr SDK integrates state management capabilities directly into the ASP.NET Core \\nmodel binding ca\", \"pabilities. Configuration is simple. In the Program.cs file, call the following extension \\nmethod on\", \" the WebApplication builder: \\nvar builder = WebApplication.CreateBuilder(args); \\nbuilder.Services.Ad\", \"dControllers().AddDapr(); \\nOnce configured, Dapr can inject a key/value pair directly into a control\", \"ler action using the ASP.NET \\nCore FromState attribute. Referencing the DaprClient object is no long\", \"er necessary. The next \\nexample shows a Web API that returns the weather forecast for a given city: \", \"\\n[HttpGet(\\\"{city}\\\")] \\npublic ActionResult<WeatherForecast> Get([FromState(\\\"statestore\\\", \\\"city\\\")] \\nSt\", \"ateEntry<WeatherForecast> forecast) \\n{ \\n    if (forecast.Value == null) \\n    { \\n      return NotFoun\", \"d(); \\n    } \\n \\n    return forecast.Value; \\n} \\nIn the example, the controller loads the weather forec\", \"ast using the FromState attribute. The first \\nattribute parameter is the state store, statestore. Th\", \"e second attribute parameter, city, is the name \\nof the route template variable to get the state key\", \". If you omit the second parameter, the name of the \\nbound method parameter (forecast) is used to lo\", \"ok up the route template variable. \\nThe StateEntry class contains properties for all the information\", \" that is retrieved for a single key/value \\npair: StoreName, Key, Value, and ETag. The ETag is useful\", \" for implementing optimistic concurrency \\ncontrol (OCC) strategy. The class also provides methods to\", \" delete or update retrieved key/value data \\nwithout requiring a DaprClient instance. In the next exa\", \"mple, the TrySaveAsync method is used to \\nupdate the retrieved weather forecast using OCC. \\n[HttpPut\", \"(\\\"{city}\\\")] \\npublic async Task Put(WeatherForecast updatedForecast, [FromState(\\\"statestore\\\", \\\"city\\\")\", \"] \\nStateEntry<WeatherForecast> currentForecast) \\n{ \\n    // update cached current forecast with updat\", \"ed forecast passed into service endpoint \\n    currentForecast.Value = updatedForecast; \\n \\n    // upd\", \"ate state store \\n    var success = await currentForecast.TrySaveAsync(); \\n \\n    // ... check result \", \"\\n} \\nState store components \\nAt the time of this writing, Dapr provides support for the following tra\", \"nsactional state stores: \\n \\n48 \\nCHAPTER 6 | The Dapr state management building block \\n \\n\\u2022 \\nAzure Cos\", \"mosDB \\n\\u2022 \\nAzure SQL Server \\n\\u2022 \\nCockroachDB \\n\\u2022 \\nIn Memory \\n\\u2022 \\nMongoDB \\n\\u2022 \\nMySQL \\n\\u2022 \\nOracle Database \\n\", \"\\u2022 \\nPostgreSQL \\n\\u2022 \\nRedis \\n\\u2022 \\nRethinkDB \\nDapr also includes support for state stores that support CRUD\", \" operations, but not transactional \\ncapabilities: \\n\\u2022 \\nAerospike \\n\\u2022 \\nApache Cassandra \\n\\u2022 \\nAWS DynamoD\", \"B \\n\\u2022 \\nAzure Blob Storage \\n\\u2022 \\nAzure Table Storage \\n\\u2022 \\nCouchbase \\n\\u2022 \\nGCP Firestore \\n\\u2022 \\nHashicorp Consu\", \"l \\n\\u2022 \\nHazelcast \\n\\u2022 \\nJetStream KV \\n\\u2022 \\nMemcached \\n\\u2022 \\nOracle Object Storage \\n\\u2022 \\nZookeeper \\nConfiguratio\", \"n \\nWhen initialized for local, self-hosted development, Dapr registers Redis as the default state st\", \"ore. \\nHere\\u2019s an example of the default state store configuration. Note the default name, statestore:\", \" \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: statestore \\nspec: \\n  type: state\", \".redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    value: localhost:6379 \\n  - name: redisP\", \"assword \\n    value: \\\"\\\" \\n  - name: actorStateStore \\n    value: \\\"true\\\" \\n \\n49 \\nCHAPTER 6 | The Dapr sta\", \"te management building block \\n \\n[!NOTE] Many state stores can be registered to a single application \", \"each with a different name. \\nThe Redis state store requires redisHost and redisPassword metadata to \", \"connect to the Redis \\ninstance. In the example above, the Redis password (which is an empty string b\", \"y default) is stored as a \\nplain string. The best practice is to avoid clear-text strings and always\", \" use secret references. To learn \\nmore about secret management, see chapter 10. \\nThe other metadata \", \"field, actorStateStore, indicates whether the state store can be consumed by \\nthe actors building bl\", \"ock. \\nKey prefix strategies \\nState store components enable different strategies to store key/value p\", \"airs in the underlying store. \\nRecall the earlier example of a shopping basket service storing items\", \" a customer wishes to purchase: \\ncurl -X POST http://localhost:3500/v1.0/state/statestore \\\\ \\n  -H \\\"C\", \"ontent-Type: application/json\\\" \\\\ \\n  -d '[{ \\n        \\\"key\\\": \\\"basket1\\\", \\n        \\\"value\\\": { \\n         \", \" \\\"customerId\\\": 1, \\n          \\\"items\\\": [ \\n            { \\\"itemId\\\": \\\"DaprHoodie\\\", \\\"quantity\\\": 1 } \\n    \", \"      ] \\n        } \\n     }]' \\nUsing the Redis Console tool, look inside the Redis cache to see how t\", \"he Redis state store component \\npersisted the data: \\n127.0.0.1:6379> KEYS * \\n1) \\\"basketservice||bask\", \"et1\\\" \\n \\n127.0.0.1:6379> HGETALL basketservice||basket1 \\n1) \\\"data\\\" \\n2) \\\"{\\\\\\\"items\\\\\\\":[{\\\\\\\"itemId\\\\\\\":\\\\\\\"Dap\", \"rHoodie\\\\\\\",\\\\\\\"quantity\\\\\\\":1}],\\\\\\\"customerId\\\\\\\":1}\\\" \\n3) \\\"version\\\" \\n4) \\\"1\\\" \\nThe output shows the full Redis\", \" key for the data as basketservice||basket1. By default, Dapr uses \\nthe application id of the Dapr i\", \"nstance (basketservice) as a prefix for the key. This naming \\nconvention enables multiple Dapr insta\", \"nces to share the same data store without key name collisions. \\nFor the developer, it\\u2019s critical alw\", \"ays to specify the same application id when running the \\napplication with Dapr. If omitted, Dapr wil\", \"l generate a unique application ID. If the application id \\nchanges, the application can no longer ac\", \"cess the state stored with the previous key prefix. \\nThat said, it\\u2019s possible to configure a constan\", \"t value for the key prefix in the keyPrefix metadata field \\nin the state store component file. Consi\", \"der the following example: \\nspec: \\n  metadata: \\n  - name: keyPrefix \\n  - value: MyPrefix \\n \\n50 \\nCHAP\", \"TER 6 | The Dapr state management building block \\n \\nA constant key prefix enables the state store to\", \" be accessed across multiple Dapr applications. What\\u2019s \\nmore, setting the keyPrefix to none omits th\", \"e prefix completely. \\nSample application: Dapr Traffic Control \\nIn the Dapr Traffic Control sample a\", \"pp, the TrafficControl service uses the Dapr state management \\nbuilding block to persist the entry a\", \"nd exit timestamps of each passing vehicle. Figure 5-3 shows the \\nconceptual architecture of the Dap\", \"r Traffic Control sample application. The Dapr state management \\nbuilding block is used in flows mar\", \"ked with number 3 in the diagram: \\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/state-management/dapr-sol\", \"ution-state-management.png\\u201d \\nalt-text=\\u201cConceptual architecture of the Dapr Traffic Control sample ap\", \"plication.\\u201d::: \\nFigure 5-3. Conceptual architecture of the Dapr Traffic Control sample application. \", \"\\nEntry and exit event logic is handled by the TrafficController class, an ordinary ASP.NET Controlle\", \"r. \\nThe TrafficController.VehicleEntry method accepts an incoming VehicleRegistered message \\nand sav\", \"es the enclosed vehicle state: \\n// store vehicle state \\nvar vehicleState = new VehicleState \\n{ \\n    \", \"LicenseNumber = msg.LicenseNumber, \\n    EntryTimestamp = msg.Timestamp \\n}; \\nawait _vehicleStateRepos\", \"itory.SaveVehicleStateAsync(vehicleState); \\nIn the preceding code snippet, the abstraction _vehicleS\", \"tateRepository is responsible for saving \\nstate to the data store. Its concrete implementation, Dapr\", \"VehicleStateRepository, is shown below: \\npublic class DaprVehicleStateRepository : IVehicleStateRepo\", \"sitory \\n{ \\n    private const string DAPR_STORE_NAME = \\\"statestore\\\"; \\n    private readonly DaprClient\", \" _daprClient; \\n \\n    public DaprVehicleStateRepository(DaprClient daprClient) \\n    { \\n        _daprC\", \"lient = daprClient; \\n    } \\n \\n    public async Task SaveVehicleStateAsync(VehicleState vehicleState)\", \" \\n    { \\n        await _daprClient.SaveStateAsync<VehicleState>( \\n            DAPR_STORE_NAME, vehic\", \"leState.LicenseNumber, vehicleState); \\n    } \\n \\n    public async Task<VehicleState> GetVehicleStateA\", \"sync(string licenseNumber) \\n    { \\n        return await _daprClient.GetStateAsync<VehicleState>( \\n  \", \"          DAPR_STORE_NAME, licenseNumber); \\n    } \\n} \\nAs the preceding code snippet shows, the imple\", \"mentation of the DaprVehicleStateRepository class \\nis pretty straightforward. The SaveVehicleStateAs\", \"ync method uses the injected DaprClient object \\n \\n51 \\nCHAPTER 6 | The Dapr state management building\", \" block \\n \\nto save the state to the configured Dapr state store. It uses the vehicle\\u2019s license number\", \" as the key. \\nThe application can retrieve the saved state by calling the GetVehicleStateAsync metho\", \"d. \\nThe TrafficControl service uses Redis as its underlying data store. Looking at the code, you\\u2019d n\", \"ever \\nknow it. A service consuming the Dapr state management building block doesn\\u2019t directly referen\", \"ce \\nany state components. Instead, a Dapr component configuration file specifies the store: \\napiVers\", \"ion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: statestore \\n  namespace: dapr-trafficcont\", \"rol \\nspec: \\n  type: state.redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    value: localho\", \"st:6379 \\n  - name: redisPassword \\n    secretKeyRef: \\n      name: state.redisPassword \\n      key: sta\", \"te.redisPassword \\nscopes: \\n  - trafficcontrolservice \\n \\n \\nNote \\nThe component configuration file inc\", \"ludes an element secretKeyRef. The application uses it to \\nreference the Redis password value from t\", \"he Dapr secrets building block. See chapter 10 to learn \\nmore about managing secrets with Dapr. \\nThe\", \" type element in the configuration, state.redis instructs the building block to manage state with \\nD\", \"apr Redis component. \\nThe scopes element in the configuration constrains application access to the s\", \"tate store component. \\nOnly the TrafficControl service can access the state store. \\nSummary \\nThe Dap\", \"r state management building block offers an API for storing key/value data across various \\ndata stor\", \"es. The API provides support for: \\n\\u2022 \\nBulk operations \\n\\u2022 \\nStrong and eventual consistency \\n\\u2022 \\nOptimi\", \"stic concurrency control \\n\\u2022 \\nMulti-item transactions \\nThe .NET SDK provides language-specific suppor\", \"t for .NET and ASP.NET Core. Model binding \\nintegration simplifies accessing and updating state from\", \" ASP.NET Core controller action methods. \\nIn the Dapr Traffic Control sample application, the benefi\", \"ts of using Dapr state management are clear: \\n \\n52 \\nCHAPTER 6 | The Dapr state management building b\", \"lock \\n \\n1. \\nIt abstracts away the complexity of using third-party SDKs, such as StackExchange.Redis.\", \" \\n2. \\nReplacing the underlying Redis cache with a different type of data store only requires changes\", \" to \\nthe component configuration file. \\nReferences \\n\\u2022 \\nDapr supported state stores \\n \\n53 \\nCHAPTER 7 \", \"| The Dapr service invocation building block \\n \\nCHAPTER 7 \\nThe Dapr service \\ninvocation building blo\", \"ck \\nAcross a distributed system, one service often needs to communicate with another to complete a \\n\", \"business operation. The Dapr service invocation building block can help streamline the \\ncommunicatio\", \"n between services. \\nWhat it solves \\nMaking calls between services in a distributed application may \", \"appear easy, but there are many \\nchallenges involved. For example: \\n\\u2022 \\nWhere the other services are \", \"located. \\n\\u2022 \\nHow to call a service securely, given the service address. \\n\\u2022 \\nHow to handle retries wh\", \"en short-lived transient errors occur. \\nLastly, as distributed applications compose many different s\", \"ervices, capturing insights across service \\ncall graphs are critical to diagnosing production issues\", \". \\nThe service invocation building block addresses these challenges by using a Dapr sidecar as a rev\", \"erse \\nproxy for your service. \\nHow it works \\nLet\\u2019s start with an example. Consider two services, \\u201cSe\", \"rvice A\\u201d and \\u201cService B\\u201d. Service A needs to call \\nthe catalog/items API on Service B. While Service\", \" A could take a dependency on Service B and make \\na direct call to it, Service A instead invokes the\", \" service invocation API on the Dapr sidecar. Figure 6-1 \\nshows the operation. \\n \\n54 \\nCHAPTER 7 | The\", \" Dapr service invocation building block \\n \\n \\nFigure 6-1. How Dapr service invocation works. \\nNote th\", \"e steps from the previous figure: \\n1. \\nService A makes a call to the catalog/items endpoint in Servi\", \"ce B by invoking the service \\ninvocation API on the Service A sidecar. \\n  \\n[!NOTE] The sidecar uses \", \"a pluggable name resolution component to resolve the address of \\nService B. In self-hosted mode, Dap\", \"r uses mDNS to find it. When running in Kubernetes mode, \\nthe Kubernetes DNS service determines the \", \"address. \\n2. \\nThe Service A sidecar forwards the request to the Service B sidecar. \\n3. \\nThe Service \", \"B sidecar makes the actual catalog/items request against the Service B API. \\n4. \\nService B executes \", \"the request and returns a response back to its sidecar. \\n5. \\nThe Service B sidecar forwards the resp\", \"onse back to the Service A sidecar. \\n6. \\nThe Service A sidecar returns the response back to Service \", \"A. \\nBecause the calls flow through sidecars, Dapr can inject some useful cross-cutting behaviors: \\n\\u2022\", \" \\nAutomatically retry calls upon failure. \\n\\u2022 \\nMake calls between services secure with mutual (mTLS) \", \"authentication, including automatic \\ncertificate rollover. \\n\\u2022 \\nControl what operations clients can d\", \"o using access control policies. \\n\\u2022 \\nCapture traces and metrics for all calls between services to pr\", \"ovide insights and diagnostics. \\n \\n55 \\nCHAPTER 7 | The Dapr service invocation building block \\n \\nAny\", \" application can invoke a Dapr sidecar by using the native invoke API built into Dapr. The API can \\n\", \"be called with either HTTP or gRPC. Use the following URL to call the HTTP API: \\nhttp://localhost:<d\", \"apr-port>/v1.0/invoke/<application-id>/method/<method-name> \\n\\u2022 \\n<dapr-port> the HTTP port that Dapr \", \"is listening on. \\n\\u2022 \\n<application-id> application ID of the service to call. \\n\\u2022 \\n<method-name> name \", \"of the method to invoke on the remote service. \\nIn the following example, a curl call is made to the\", \" catalog/items \\u2018GET\\u2019 endpoint of Service B: \\ncurl http://localhost:3500/v1.0/invoke/serviceb/method/\", \"catalog/items \\n \\n \\nNote \\nThe Dapr APIs enable any application stack that supports HTTP or gRPC to us\", \"e Dapr building blocks. \\nTherefore, the service invocation building block can act as a bridge betwee\", \"n protocols. Services can \\ncommunicate with each other using HTTP, gRPC or a combination of both. \\nI\", \"n the next section, you\\u2019ll learn how to use the .NET SDK to simplify service invocation calls. \\nUse \", \"the Dapr .NET SDK \\nThe Dapr .NET SDK provides .NET developers with an intuitive and language-specifi\", \"c way to interact \\nwith Dapr. The SDK offers developers three ways of making remote service invocati\", \"on calls: \\n1. \\nInvoke HTTP services using HttpClient \\n2. \\nInvoke HTTP services using DaprClient \\n3. \", \"\\nInvoke gRPC services using DaprClient \\nInvoke HTTP services using HttpClient \\nThe preferred way to \", \"call an HTTP endpoint is to use Dapr\\u2019s rich integration with HttpClient. The \\nfollowing example subm\", \"its an order by calling the submit method of the orderservice application: \\nvar httpClient = DaprCli\", \"ent.CreateInvokeHttpClient(); \\nawait httpClient.PostAsJsonAsync(\\\"http://orderservice/submit\\\", order)\", \"; \\nIn the example, DaprClient.CreateInvokeHttpClient returns an HttpClient instance that is used to \", \"\\nperform Dapr service invocation. The returned HttpClient uses a special Dapr message handler that \\n\", \"rewrites URIs of outgoing requests. The host name is interpreted as the application ID of the servic\", \"e to \\ncall. The rewritten request that\\u2019s actually being called is: \\nhttp://127.0.0.1:3500/v1/invoke/\", \"orderservice/method/submit \\nThis example uses the default value for the Dapr HTTP endpoint, which is\", \" http://127.0.0.1:<dapr-\\nhttp-port>/. The value of dapr-http-port is taken from the DAPR_HTTP_PORT e\", \"nvironment variable. \\nIf it\\u2019s not set, the default port number 3500 is used. \\n \\n56 \\nCHAPTER 7 | The \", \"Dapr service invocation building block \\n \\nAlternatively, you can configure a custom endpoint in the \", \"call to \\nDaprClient.CreateInvokeHttpClient: \\nvar httpClient = DaprClient.CreateInvokeHttpClient(dapr\", \"Endpoint: \\\"localhost:4000\\\"); \\nYou can also directly set the base address by specifying the applicati\", \"on ID. Doing so enables relative \\nURIs when making a call: \\nvar httpClient = DaprClient.CreateInvoke\", \"HttpClient(\\\"orderservice\\\"); \\nawait httpClient.PostAsJsonAsync(\\\"/submit\\\"); \\nThe HttpClient object is \", \"intended to be long-lived. A single HttpClient instance can be reused for \\nthe lifetime of the appli\", \"cation. The next scenario demonstrates how an OrderServiceClient class \\nreuses a Dapr HttpClient ins\", \"tance: \\nvar builder = WebApplication.CreateBuilder(args); \\nbuilder.Services.AddSingleton<IOrderServi\", \"ceClient, OrderServiceClient>( \\n    _ => new OrderServiceClient(DaprClient.CreateInvokeHttpClient(\\\"o\", \"rderservice\\\"))); \\nIn the snippet above, the OrderServiceClient is registered as a singleton with the\", \" ASP.NET Core \\ndependency injection system. An implementation factory creates a new HttpClient insta\", \"nce by \\ncalling DaprClient.CreateInvokeHttpClient. It then uses the newly created HttpClient to \\nins\", \"tantiate the OrderServiceClient object. By registering the OrderServiceClient as a singleton, it \\nwi\", \"ll be reused for the lifetime of the application. \\nThe OrderServiceClient itself has no Dapr-specifi\", \"c code. Even though Dapr service invocation is \\nused under the hood, you can treat the Dapr HttpClie\", \"nt like any other HttpClient: \\npublic class OrderServiceClient : IOrderServiceClient \\n{ \\n    private\", \" readonly HttpClient _httpClient; \\n \\n    public OrderServiceClient(HttpClient httpClient) \\n    { \\n  \", \"      _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient)); \\n    } \\n \\n   \", \" public async Task SubmitOrder(Order order) \\n    { \\n        var response = await _httpClient.PostAsJ\", \"sonAsync(\\\"submit\\\", order); \\n        response.EnsureSuccessStatusCode(); \\n    } \\n} \\nUsing the HttpCli\", \"ent class with Dapr service invocation has many benefits: \\n\\u2022 \\nHttpClient is a well-known class that \", \"many developers already use in their code. Using HttpClient \\nfor Dapr service invocation allows deve\", \"lopers to reuse their existing skills. \\n\\u2022 \\nHttpClient supports advanced scenarios, such as custom he\", \"aders, and full control over request \\nand response messages. \\n\\u2022 \\nIn .NET 5, HttpClient supports auto\", \"matic serialization and deserialization using System.Text.Json. \\n\\u2022 \\nHttpClient integrates with many \", \"existing frameworks and libraries, such as Refit, RestSharp, and \\nPolly. \\n \\n57 \\nCHAPTER 7 | The Dapr\", \" service invocation building block \\n \\nInvoke HTTP services using DaprClient \\nWhile HttpClient is the\", \" preferred way to invoke services using HTTP semantics, you can also use the \\nDaprClient.InvokeMetho\", \"dAsync family of methods. The following example submits an order by \\ncalling the submit method of th\", \"e orderservice application: \\nvar daprClient = new DaprClientBuilder().Build(); \\ntry \\n{ \\n    var conf\", \"irmation = \\n        await daprClient.InvokeMethodAsync<Order, OrderConfirmation>( \\n            \\\"orde\", \"rservice\\\", \\\"submit\\\", order); \\n} \\ncatch (InvocationException ex) \\n{ \\n    // Handle error \\n} \\nThe thir\", \"d argument, an order object, is serialized internally (with System.Text.JsonSerializer) and \\nsent as\", \" the request payload. The .NET SDK takes care of the call to the sidecar. It also deserializes the \\n\", \"response to an OrderConfirmation object. Because no HTTP method is specified, the request is \\nexecut\", \"ed as an HTTP POST. \\nThe next example demonstrates how you can make an HTTP GET request by specifyin\", \"g the \\nHttpMethod: \\nvar catalogItems = await \\ndaprClient.InvokeMethodAsync<IEnumerable<CatalogItem>>\", \"(HttpMethod.Get, \\\"catalogservice\\\", \\n\\\"items\\\"); \\nFor some scenarios, you may require more control over\", \" the request message. For example, when you \\nneed to specify request headers, or you want to use a c\", \"ustom serializer for the payload. \\nDaprClient.CreateInvokeMethodRequest creates an HttpRequestMessag\", \"e. The following example \\ndemonstrates how to add an HTTP authorization header to a request message:\", \" \\nvar request = daprClient.CreateInvokeMethodRequest(\\\"orderservice\\\", \\\"submit\\\", order); \\nrequest.Head\", \"ers.Authorization = new AuthenticationHeaderValue(\\\"bearer\\\", token); \\nThe HttpRequestMessage now has \", \"the following properties set: \\n\\u2022 \\nUrl = http://127.0.0.1:3500/v1.0/invoke/orderservice/method/submit\", \" \\n\\u2022 \\nHttpMethod = POST \\n\\u2022 \\nContent = JsonContent object containing the JSON-serialized order \\n\\u2022 \\nHea\", \"ders.Authorization = \\u201cbearer <token>\\u201d \\nOnce you\\u2019ve got the request set up the way you want, use Dapr\", \"Client.InvokeMethodAsync to send it: \\nvar orderConfirmation = await daprClient.InvokeMethodAsync<Ord\", \"erConfirmation>(request); \\nDaprClient.InvokeMethodAsync deserializes the response to an OrderConfirm\", \"ation object if the \\nrequest is successful. Alternatively, you can use DaprClient.InvokeMethodWithRe\", \"sponseAsync to get \\nfull access to the underlying HttpResponseMessage: \\n \\n58 \\nCHAPTER 7 | The Dapr s\", \"ervice invocation building block \\n \\nvar response = await daprClient.InvokeMethodWithResponseAsync(re\", \"quest); \\nresponse.EnsureSuccessStatusCode(); \\n \\nvar orderConfirmation = response.Content.ReadFromJso\", \"nAsync<OrderConfirmation>(); \\n \\n \\nNote \\nFor service invocation calls using HTTP, it\\u2019s worth consider\", \"ing using the Dapr HttpClient integration \\npresented in the previous section. Using HttpClient gives\", \" you additional benefits such as integration \\nwith existing frameworks and libraries. \\nInvoke gRPC s\", \"ervices using DaprClient \\nDaprClient provides a family of InvokeMethodGrpcAsync methods for calling \", \"gRPC endpoints. The \\nmain difference with the HTTP methods is the use of a Protobuf serializer inste\", \"ad of JSON. The \\nfollowing example invokes the submitOrder method of the orderservice over gRPC. \\nva\", \"r daprClient = new DaprClientBuilder().Build(); \\ntry \\n{ \\n    var confirmation = await daprClient.Inv\", \"okeMethodGrpcAsync<Order, \\nOrderConfirmation>(\\\"orderservice\\\", \\\"submitOrder\\\", order); \\n} \\ncatch (Invo\", \"cationException ex) \\n{ \\n    // Handle error \\n} \\nIn the example above, DaprClient serializes the give\", \"n order object using Protobuf and uses the result \\nas the gRPC request body. Likewise, the response \", \"body is Protobuf deserialized and returned to the \\ncaller. Protobuf typically provides better perfor\", \"mance than the JSON payloads used in HTTP service \\ninvocation. \\nName resolution components \\nAt the t\", \"ime of writing, Dapr provides support for the following name resolution components: \\n\\u2022 \\nmDNS (defaul\", \"t when running self-hosted) \\n\\u2022 \\nKubernetes Name Resolution (default when running in Kubernetes) \\n\\u2022 \\n\", \"HashiCorp Consul \\nConfiguration \\nTo use a non-default name resolution component, add a nameResolutio\", \"n spec to the application\\u2019s \\nDapr configuration file. Here\\u2019s an example of a Dapr configuration file\", \" that enables HashiCorp Consul \\nname resolution: \\napiVersion: dapr.io/v1alpha1 \\nkind: Configuration \", \"\\nmetadata: \\n \\n59 \\nCHAPTER 7 | The Dapr service invocation building block \\n \\n  name: dapr-config \\nspe\", \"c: \\n  nameResolution: \\n    component: \\\"consul\\\" \\n    configuration: \\n      selfRegister: true \\nSample\", \" application: Dapr Traffic Control \\nIn Dapr Traffic Control sample app, the FineCollection service u\", \"ses the Dapr service invocation \\nbuilding block to retrieve vehicle and owner information from the V\", \"ehicleRegistration service. Figure \\n6-2 shows the conceptual architecture of the Dapr Traffic Contro\", \"l sample application. The Dapr service \\ninvocation building block is used in flows marked with numbe\", \"r 1 in the diagram: \\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/service-invocation/dapr-solution-servic\", \"e-invocation.png\\u201d \\nalt-text=\\u201cConceptual architecture of the Dapr Traffic Control sample application.\", \"\\u201d::: \\nFigure 6-2. Conceptual architecture of the Dapr Traffic Control sample application. \\nInformati\", \"on is retrieved by the ASP.NET CollectionController class in the FineCollection service. \\nThe Collec\", \"tFine method expects an incoming SpeedingViolation parameter. It invokes a Dapr \\nservice invocation \", \"building block to call to the VehicleRegistration service. The code snippet is \\npresented below. \\n::\", \":{custom-style=CodeBox} ```csharp [Topic(\\u201cpubsub\\u201d, \\u201cspeedingviolations\\u201d)] [Route(\\u201ccollectfine\\u201d)] \\n[H\", \"ttpPost] public async Task CollectFine(SpeedingViolation speedingViolation, [FromServices] \\nDaprClie\", \"nt daprClient) { // \\u2026 \\n// get owner info (Dapr service invocation) \\nvar vehicleInfo = \\n_vehicleRegis\", \"trationService.GetVehicleInfo(speedingViolation.VehicleId).Result; \\n \\n// ... \\n} ``` ::: \\nThe code us\", \"es a proxy of type VehicleRegistrationService to call the VehicleRegistration service. \\nASP.NET Core\", \" injects an instance of the service proxy using constructor injection: \\n:::{custom-style=CodeBox} cs\", \"harp  public CollectionController(      ILogger<CollectionController> \\nlogger,      IFineCalculator \", \"fineCalculator,      VehicleRegistrationService vehicleRegistrationService,      \\nDaprClient daprCli\", \"ent)  {      // ...  } ::: \\nThe VehicleRegistrationService class contains a single method: GetVehicl\", \"eInfo. It uses the \\nASP.NET Core HttpClient to call the VehicleRegistration service: \\n:::{custom-sty\", \"le=CodeBox} ```csharp public class VehicleRegistrationService { private HttpClient \\n_httpClient; pub\", \"lic VehicleRegistrationService(HttpClient httpClient) { _httpClient = httpClient; } \\n public async T\", \"ask<VehicleInfo> GetVehicleInfo(string licenseNumber) \\n { \\n     return await _httpClient.GetFromJson\", \"Async<VehicleInfo>( \\n \\n60 \\nCHAPTER 7 | The Dapr service invocation building block \\n \\n         $\\\"vehi\", \"cleinfo/{licenseNumber}\\\"); \\n } \\n} ``` ::: \\nThe code doesn\\u2019t depend on any Dapr classes directly. It \", \"instead leverages the Dapr ASP.NET Core \\nintegration as described in the Invoke HTTP services using \", \"HttpClient section of this module. The \\nfollowing code in the ConfigureService method of the Startup\", \" class registers the \\nVehicleRegistrationService proxy: \\nvar builder = WebApplication.CreateBuilder(\", \"args); \\nbuilder.Services.AddSingleton<VehicleRegistrationService>(_ => \\n    new VehicleRegistrationS\", \"ervice(DaprClient.CreateInvokeHttpClient( \\n        \\\"vehicleregistrationservice\\\", $\\\"http://localhost:\", \"{daprHttpPort}\\\" \\n    ))); \\nThe DaprClient.CreateInvokeHttpClient creates an HttpClient instance that\", \" calls the \\nVehicleRegistration service using the service invocation building block under the covers\", \". It expects \\nboth the Dapr app-id of the target service and the URL of its Dapr sidecar. At start t\", \"ime, the \\ndaprHttpPort argument contains the port number used for HTTP communication with the Dapr \\n\", \"sidecar. \\nUsing Dapr service invocation in the Traffic Control sample application provides several b\", \"enefits: \\n1. \\nDecouples the location of the target service. \\n2. \\nAdds resiliency with automatic retr\", \"y features. \\n3. \\nAbility to reuse an existing HttpClient based proxy (offered by the ASP.NET Core in\", \"tegration). \\nSummary \\nIn this chapter, you learned about the service invocation building block. You \", \"saw how to invoke \\nremote methods both by making direct HTTP calls to the Dapr sidecar, and by using\", \" the Dapr .NET \\nSDK. \\nThe Dapr .NET SDK provides multiple ways to invoke remote methods. HttpClient \", \"support is great for \\ndevelopers wanting to reuse existing skills and is compatible with many existi\", \"ng frameworks and \\nlibraries. DaprClient offers support for directly using the Dapr service invocati\", \"on API using either HTTP \\nor gRPC semantics. \\nReferences \\n\\u2022 \\nDapr service invocation building block \", \"\\n\\u2022 \\nMonitoring distributed cloud-native applications \\n \\n61 \\nCHAPTER 8 | The Dapr publish & subscribe\", \" building block \\n \\nCHAPTER 8 \\nThe Dapr publish & \\nsubscribe building block \\nThe Publish-Subscribe pa\", \"ttern (often referred to as \\u201cpub/sub\\u201d) is a well-known and widely used \\nmessaging pattern. Architect\", \"s commonly embrace it in distributed applications. However, the \\nplumbing to implement it can be com\", \"plex. There are often subtle feature differences across different \\nmessaging products. Dapr offers a\", \" building block that significantly simplifies implementing pub/sub \\nfunctionality. \\nWhat it solves \\n\", \"The primary advantage of the Publish-Subscribe pattern is loose coupling, sometimes referred to as \\n\", \"temporal decoupling. The pattern decouples services that send messages (the publishers) from \\nservic\", \"es that consume messages (the subscribers). Both publishers and subscribers are unaware of \\neach oth\", \"er - both are dependent on a centralized message broker that distributes the messages. \\nFigure 7-1 s\", \"hows the high-level architecture of the pub/sub pattern. \\n \\nFigure 7-1. The pub/sub pattern. \\nFrom t\", \"he previous figure, note the steps of the pattern: \\n1. \\nPublishers send messages to the message brok\", \"er. \\n2. \\nSubscribers bind to a subscription on the message broker. \\n \\n62 \\nCHAPTER 8 | The Dapr publi\", \"sh & subscribe building block \\n \\n3. \\nThe message broker forwards a copy of the message to interested\", \" subscriptions. \\n4. \\nSubscribers consume messages from their subscriptions. \\nMost message brokers en\", \"capsulate a queueing mechanism that can persist messages once received. \\nWith it, the message broker\", \" guarantees durability by storing the message. Subscribers don\\u2019t need to \\nbe immediately available o\", \"r even online when a publisher sends a message. Once available, the \\nsubscriber receives and process\", \"es the message. Dapr guarantees At-Least-Once semantics for \\nmessage delivery. Once a message is pub\", \"lished, it will be delivered at least once to any interested \\nsubscriber. \\nTip \\nIf your service can \", \"only process a message once, you\\u2019ll need to provide an idempotency check to \\nensure that the same me\", \"ssage is not processed multiple times. While such logic can be coded, some \\nmessage brokers, such as\", \" Azure Service Bus, provide built-in duplicate detection messaging \\ncapabilities. \\nThere are several\", \" message broker products available - both commercially and open-source. Each has \\nadvantages and dra\", \"wbacks. Your job is to match your system requirements to the appropriate broker. \\nOnce selected, it\\u2019\", \"s a best practice to decouple your application from message broker plumbing. You \\nachieve this funct\", \"ionality by wrapping the broker inside an abstraction. The abstraction encapsulates \\nthe message plu\", \"mbing and exposes generic pub/sub operations to your code. Your code \\ncommunicates with the abstract\", \"ion, not the actual message broker. While a wise decision, you\\u2019ll have \\nto write and maintain the ab\", \"straction and its underlying implementation. This approach requires \\ncustom code that can be complex\", \", repetitive, and error-prone. \\nThe Dapr publish & subscribe building block provides the messaging a\", \"bstraction and implementation \\nout-of-the-box. The custom code you would have had to write is prebui\", \"lt and encapsulated inside the \\nDapr building block. You bind to it and consume it. Instead of writi\", \"ng messaging plumbing code, you \\nand your team focus on creating business functionality that adds va\", \"lue to your customers. \\nHow it works \\nThe Dapr publish & subscribe building block provides a platfor\", \"m-agnostic API framework to send and \\nreceive messages. Your services publish messages to a named to\", \"pic. Your services subscribe to a topic \\nto consume messages. \\nThe service calls the pub/sub API on \", \"the Dapr sidecar. The sidecar then makes calls into a pre-defined \\nDapr pub/sub component that encap\", \"sulates a specific message broker product. Figure 7-2 shows the \\nDapr pub/sub messaging stack. \\n \\n63\", \" \\nCHAPTER 8 | The Dapr publish & subscribe building block \\n \\n \\nFigure 7-2. The Dapr pub/sub stack. \\n\", \"The Dapr publish & subscribe building block can be invoked in many ways. \\nAt the lowest level, any p\", \"rogramming platform can invoke the building block over HTTP or gRPC \\nusing the Dapr native API. To p\", \"ublish a message, you make the following API call: \\nhttp://localhost:<dapr-port>/v1.0/publish/<pub-s\", \"ub-name>/<topic> \\nThere are several Dapr specific URL segments in the above call: \\n\\u2022 \\n<dapr-port> pr\", \"ovides the port number upon which the Dapr sidecar is listening. \\n\\u2022 \\n<pub-sub-name> provides the nam\", \"e of the selected Dapr pub/sub component. \\n\\u2022 \\n<topic> provides the name of the topic to which the me\", \"ssage is published. \\nUsing the curl command-line tool to publish a message, you can try it out: \\ncur\", \"l -X POST http://localhost:3500/v1.0/publish/pubsub/newOrder \\\\ \\n  -H \\\"Content-Type: application/json\", \"\\\" \\\\ \\n  -d '{ \\\"orderId\\\": \\\"1234\\\", \\\"productId\\\": \\\"5678\\\", \\\"amount\\\": 2 }' \\nYou receive messages by subscri\", \"bing to a topic. At startup, the Dapr runtime will call the application \\non a well-known endpoint to\", \" identify and create the required subscriptions: \\nhttp://localhost:<appPort>/dapr/subscribe \\n \\n64 \\nC\", \"HAPTER 8 | The Dapr publish & subscribe building block \\n \\n\\u2022 \\n<appPort> informs the Dapr sidecar of t\", \"he port upon which the application is listening. \\nYou can implement this endpoint yourself. But Dapr\", \" provides more intuitive ways of implementing it. \\nWe\\u2019ll address this functionality later in this ch\", \"apter. \\nThe response from the call contains a list of topics to which the applications will subscrib\", \"e. Each \\nincludes an endpoint to call when the topic receives a message. Here\\u2019s an example of a resp\", \"onse: \\n[ \\n  { \\n    \\\"pubsubname\\\": \\\"pubsub\\\", \\n    \\\"topic\\\": \\\"newOrder\\\", \\n    \\\"route\\\": \\\"/orders\\\" \\n  }, \\n\", \"  { \\n    \\\"pubsubname\\\": \\\"pubsub\\\", \\n    \\\"topic\\\": \\\"newProduct\\\", \\n    \\\"route\\\": \\\"/productCatalog/products\", \"\\\" \\n  } \\n] \\nIn the JSON response, you can see the application wants to subscribe to topics newOrder a\", \"nd \\nnewProduct. It registers the endpoints /orders and /productCatalog/products for each, \\nrespectiv\", \"ely. For both subscriptions, the application is binding to the Dapr component named pubsub. \\nFigure \", \"7-3 presents the flow of the example. \\n \\n65 \\nCHAPTER 8 | The Dapr publish & subscribe building block\", \" \\n \\n \\nFigure 7-3. Pub/sub flow with Dapr. \\nFrom the previous figure, note the flow: \\n1. \\nThe Dapr si\", \"decar for Service B calls the /dapr/subscribe endpoint from Service B (the \\nconsumer). The service r\", \"esponds with the subscriptions it wants to create. \\n2. \\nThe Dapr sidecar for Service B creates the r\", \"equested subscriptions on the message broker. \\n3. \\nService A publishes a message at the /v1.0/publis\", \"h/<pub-sub-name>/<topic> endpoint on \\nthe Dapr Service A sidecar. \\n4. \\nThe Service A sidecar publish\", \"es the message to the message broker. \\n5. \\nThe message broker sends a copy of the message to the Ser\", \"vice B sidecar. \\n6. \\nThe Service B sidecar calls the endpoint corresponding to the subscription (in \", \"this case /orders) \\non Service B. The service responds with an HTTP status-code 200 OK so the sideca\", \"r will consider \\nthe message as being handled successfully. \\nIn the example, the message is handled \", \"successfully. But if something goes wrong while Service B is \\nhandling the request, it can use the r\", \"esponse to specify what needs to happen with the message. \\nWhen it returns an HTTP status-code 404, \", \"an error is logged and the message is dropped. With any \\nother status-code than 200 or 404, a warnin\", \"g is logged and the message is retried. Alternatively, \\n \\n66 \\nCHAPTER 8 | The Dapr publish & subscri\", \"be building block \\n \\nService B can explicitly specify what needs to happen with the message by inclu\", \"ding a JSON payload \\nin the body of the response: \\n{ \\n  \\\"status\\\": \\\"<status>\\\" \\n} \\nThe following table\", \" shows the available status values: \\nStatus \\nAction \\nSUCCESS \\nThe message is considered as processed\", \" successfully and dropped. \\nRETRY \\nThe message is retried. \\nDROP \\nA warning is logged and the messag\", \"e is dropped. \\nAny other status \\nThe message is retried. \\nCompeting consumers \\nWhen scaling out an a\", \"pplication that subscribes to a topic, you have to deal with competing \\nconsumers. Only one applicat\", \"ion instance should handle a message sent to the topic. Luckily, Dapr \\nhandles that problem. When mu\", \"ltiple instances of a service with the same application-id subscribe to \\na topic, Dapr delivers each\", \" message to only one of them. \\nUse the Dapr .NET SDK \\nFor .NET Developers, the Dapr .NET SDK provide\", \"s a more productive way of working with Dapr. The \\nSDK exposes a DaprClient class through which you \", \"can directly invoke Dapr functionality. It\\u2019s intuitive \\nand easy to use. \\nTo publish a message, the \", \"DaprClient exposes a PublishEventAsync method. \\nvar data = new OrderData \\n{ \\n  orderId = \\\"123456\\\", \\n\", \"  productId = \\\"67890\\\", \\n  amount = 2 \\n}; \\n \\nvar daprClient = new DaprClientBuilder().Build(); \\n \\nawa\", \"it daprClient.PublishEventAsync<OrderData>(\\\"pubsub\\\", \\\"newOrder\\\", data); \\n\\u2022 \\nThe first argument pubsu\", \"b is the name of the Dapr component that provides the message broker \\nimplementation. We\\u2019ll address \", \"components later in this chapter. \\n\\u2022 \\nThe second argument neworder provides the name of the topic to\", \" send the message to. \\n\\u2022 \\nThe third argument is the payload of the message. \\n\\u2022 \\nYou can specify the \", \".NET type of the message using the generic type parameter of the method. \\n \\n67 \\nCHAPTER 8 | The Dapr\", \" publish & subscribe building block \\n \\nTo receive messages, you bind an endpoint to a subscription f\", \"or a registered topic. The AspNetCore \\nlibrary for Dapr makes this trivial. Assume, for example, tha\", \"t you have an existing ASP.NET WebAPI \\naction method entitled CreateOrder: \\n[HttpPost(\\\"/orders\\\")] \\np\", \"ublic async Task<ActionResult> CreateOrder(Order order) \\n \\n \\nImportant \\nYou must add a reference to \", \"the Dapr.AspNetCore NuGet package in your project to consume the \\nDapr ASP.NET Core integration. \\nTo\", \" bind this action method to a topic, you decorate it with the Topic attribute: \\n[Topic(\\\"pubsub\\\", \\\"ne\", \"wOrder\\\")] \\n[HttpPost(\\\"/orders\\\")] \\npublic async Task<ActionResult> CreateOrder(Order order) \\nYou spec\", \"ify two key elements with this attribute: \\n\\u2022 \\nThe Dapr pub/sub component to target (in this case pub\", \"sub). \\n\\u2022 \\nThe topic to subscribe to (in this case newOrder). \\nDapr then invokes that action method a\", \"s it receives messages for that topic. \\nYou\\u2019ll also need to enable ASP.NET Core to use Dapr. The Dap\", \"r .NET SDK provides several extension \\nmethods that can be used to do this. \\nIn the Program.cs file,\", \" you must call the following extension method on the WebApplication builder \\nto register Dapr: \\nvar \", \"builder = WebApplication.CreateBuilder(args); \\nbuilder.Services.AddControllers().AddDapr(); \\nAppendi\", \"ng the AddDapr extension method to the AddControllers extension method registers the \\nnecessary serv\", \"ices to integrate Dapr into the MVC pipeline. It also registers a DaprClient instance \\ninto the depe\", \"ndency injection container, which then can be injected anywhere into your service. \\nAfter the WebApp\", \"lication has been created, you must add the following middleware components to \\nenable Dapr: \\nvar bu\", \"ilder = WebApplication.CreateBuilder(args); \\nvar app = builder.Build(); \\napp.UseCloudEvents(); \\napp.\", \"MapControllers(); \\napp.MapSubscribeHandler(); \\nThe call to UseCloudEvents adds CloudEvents middlewar\", \"e into to the ASP.NET Core middleware \\npipeline. This middleware will unwrap requests that use the C\", \"loudEvents structured format, so the \\nreceiving method can read the event payload directly. \\n \\n68 \\nC\", \"HAPTER 8 | The Dapr publish & subscribe building block \\n \\nNote \\nCloudEvents is a standardized messag\", \"ing format, providing a common way to describe event \\ninformation across platforms. Dapr embraces Cl\", \"oudEvents. For more information about CloudEvents, \\nsee the cloudevents specification. \\nThe call to \", \"MapSubscribeHandler in the endpoint routing configuration will add a Dapr subscribe \\nendpoint to the\", \" application. This endpoint will respond to requests on /dapr/subscribe. When this \\nendpoint is call\", \"ed, it will automatically find all WebAPI action methods decorated with the Topic \\nattribute and ins\", \"truct Dapr to create subscriptions for them. \\nPub/sub components \\nDapr pub/sub components handle the\", \" actual transport of the messages. Several are available. Each \\nencapsulates a specific message brok\", \"er product to implement the pub/sub functionality. At the time \\nof writing, the following pub/sub co\", \"mponents were available: \\n\\u2022 \\nApache Kafka \\n\\u2022 \\nAWS SNS/SQS \\n\\u2022 \\nAzure Event Hubs \\n\\u2022 \\nAzure Service Bus\", \" \\n\\u2022 \\nGCP Pub/Sub \\n\\u2022 \\nHazelcast \\n\\u2022 \\nIn Memory \\n\\u2022 \\nJetStream \\n\\u2022 \\nMQTT \\n\\u2022 \\nNATS Streaming \\n\\u2022 \\nPulsar \\n\\u2022\", \" \\nRabbitMQ \\n\\u2022 \\nRedis Streams \\nNote \\nThe Azure cloud stack has both messaging functionality (Azure Se\", \"rvice Bus) and event streaming \\n(Azure Event Hub) availability. \\nThese components are created by the\", \" community in a component-contrib repository on GitHub. \\nYou\\u2019re encouraged to write your own Dapr co\", \"mponent for a message broker that isn\\u2019t yet supported. \\nConfiguration \\nUsing a Dapr configuration fi\", \"le, you can specify the pub/sub component(s) to use. This configuration \\ncontains several fields. Th\", \"e name field specifies the pub/sub component that you want to use. When \\nsending or receiving a mess\", \"age, you need to specify this name (as you saw earlier in the \\nPublishEventAsync method signature). \", \"\\n \\n69 \\nCHAPTER 8 | The Dapr publish & subscribe building block \\n \\nBelow you see an example of a Dapr\", \" configuration file for configuring a RabbitMQ message broker \\ncomponent: \\napiVersion: dapr.io/v1alp\", \"ha1 \\nkind: Component \\nmetadata: \\n  name: pubsub-rq \\nspec: \\n  type: pubsub.rabbitmq \\n  version: v1 \\n \", \" metadata: \\n  - name: host \\n    value: \\\"amqp://localhost:5672\\\" \\n  - name: durable \\n    value: true \\n\", \"In this example, you can see that you can specify any message broker-specific configuration in the \\n\", \"metadata block. In this case, RabbitMQ is configured to create durable queues. But the RabbitMQ \\ncom\", \"ponent has more configuration options. Each of the components\\u2019 configuration will have its own \\nset \", \"of possible fields. You can read which fields are available in the documentation of each pub/sub \\nco\", \"mponent. \\nNext to the programmatic way of subscribing to a topic from code, Dapr pub/sub also provid\", \"es a \\ndeclarative way of subscribing to a topic. This approach removes the Dapr dependency from the \", \"\\napplication code. Therefore, it also enables an existing application to subscribe to topics without\", \" any \\nchanges to the code. The following example shows a Dapr configuration file for configuring a \\n\", \"subscription: \\napiVersion: dapr.io/v1alpha1 \\nkind: Subscription \\nmetadata: \\n  name: newOrder-subscri\", \"ption \\nspec: \\n  pubsubname: pubsub \\n  topic: newOrder \\n  route: /orders \\nscopes: \\n- ServiceB \\n- Serv\", \"iceC \\nYou have to specify several elements with every subscription: \\n\\u2022 \\nThe name of the Dapr pub/sub\", \" component you want to use (in this case pubsub). \\n\\u2022 \\nThe name of the topic to subscribe to (in this\", \" case newOrder). \\n\\u2022 \\nThe API operation that needs to be called for this topic (in this case /orders)\", \". \\n\\u2022 \\nThe scope can specify which services can publish and subscribe to a topic. \\nSample application\", \": Dapr Traffic Control \\nIn Dapr Traffic Control sample app, the TrafficControl service uses the Dapr\", \" pub/sub building block to \\nsend speeding violations to the FineCollection service. Figure 7-4 shows\", \" the conceptual architecture \\n \\n70 \\nCHAPTER 8 | The Dapr publish & subscribe building block \\n \\nof th\", \"e Dapr Traffic Control sample application. The Dapr pub/sub building block is used in flows \\nmarked \", \"with number 2 in the diagram: \\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/publish-subscribe/dapr-soluti\", \"on-pub-sub.png\\u201d alt-\\ntext=\\u201cConceptual architecture of the Dapr Traffic Control sample application.\\u201d:\", \":: \\nFigure 7-4. Conceptual architecture of the Dapr Traffic Control sample application. \\nSpeeding vi\", \"olations are handled by the CollectionController, an ordinary ASP.NET Core Controller. \\nThe Collecti\", \"onController.CollectFine method subscribes to and handles SpeedingViolation \\nevent messages: \\n[Topic\", \"(\\\"pubsub\\\", \\\"speedingviolations\\\")] \\n[Route(\\\"collectfine\\\")] \\n[HttpPost] \\npublic async Task<ActionResul\", \"t> CollectFine( \\n    SpeedingViolation speedingViolation, [FromServices] DaprClient daprClient) \\n{ \\n\", \"    // ... \\n} \\nThe method is decorated with the Dapr Topic attribute. It specifies that the pub/sub \", \"component \\nnamed pubsub should be used to subscribe to messages sent to the speedingviolations topic\", \". \\nThe TrafficControl service sends speeding violations. Near the end of the VehicleExit method in t\", \"he \\nTrafficController class, the DaprClient object is used to publish SpeedingViolation messages \\nus\", \"ing the pub/sub building block: \\n/// ... \\n \\nvar speedingViolation = new SpeedingViolation \\n{ \\n    Ve\", \"hicleId = msg.LicenseNumber, \\n    RoadId = _roadId, \\n    ViolationInKmh = violation, \\n    Timestamp \", \"= msg.Timestamp \\n}; \\n \\n// publish speedingviolation (Dapr publish / subscribe) \\nawait daprClient.Pub\", \"lishEventAsync(\\\"pubsub\\\", \\\"speedingviolations\\\", speedingViolation); \\n \\n/// ... \\nNote how the DaprClie\", \"nt object reduces the call to a single line of code, again, binding to the \\nspeedingviolations topic\", \" and the Dapr pubsub component. \\nWhile the Traffic Control app uses RabbitMQ as the message broker, \", \"it never directly references \\nRabbitMQ. Instead, the accompanying Dapr component configuration file \", \"named pubsub.yaml in the \\n/dapr/components folder specifies the message broker: \\napiVersion: dapr.io\", \"/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: pubsub \\n  namespace: dapr-trafficcontrol \\nspec: \\n  ty\", \"pe: pubsub.rabbitmq \\n \\n71 \\nCHAPTER 8 | The Dapr publish & subscribe building block \\n \\n  version: v1 \", \"\\n  metadata: \\n  - name: host \\n    value: \\\"amqp://localhost:5672\\\" \\n  - name: durable \\n    value: \\\"fal\", \"se\\\" \\n  - name: deletedWhenUnused \\n    value: \\\"false\\\" \\n  - name: autoAck \\n    value: \\\"false\\\" \\n  - nam\", \"e: reconnectWait \\n    value: \\\"0\\\" \\n  - name: concurrency \\n    value: parallel \\nscopes: \\n  - trafficco\", \"ntrolservice \\n  - finecollectionservice \\nThe type element in the configuration, pubsub.rabbitmq inst\", \"ructs the building block to use the Dapr \\nRabbitMQ component. \\nThe scopes element in the configurati\", \"on constrains application access to the RabbitMQ component. \\nOnly the TrafficControl and FineCollect\", \"ion services can consume it. \\nUsing Dapr pub/sub in the Traffic Control sample application offers th\", \"e following benefits: \\n1. \\nNo infrastructural abstraction of a message broker to maintain. \\n2. \\nServ\", \"ices are temporally decoupled, which increases robustness. \\n3. \\nPublisher and subscribers are unawar\", \"e of each other. This means that additional services could \\nbe introduced that will react to speedin\", \"g violations in the future, without the need to change the \\nTrafficControl service. \\nSummary \\nThe pu\", \"b/sub pattern helps you decouple services in a distributed application. The Dapr publish & \\nsubscrib\", \"e building block simplifies implementing this behavior in your application. \\nThrough Dapr pub/sub, y\", \"ou can publish messages to a specific topic. As well, the building block will \\nquery your service to\", \" determine which topic(s) to subscribe to. \\nYou can use Dapr pub/sub natively over HTTP or by using \", \"one of the language-specific SDKs, such as \\nthe .NET SDK for Dapr. The .NET SDK tightly integrates w\", \"ith the ASP.NET core platform. \\nWith Dapr, you can plug a supported message broker product into your\", \" application. You can then \\nswap message brokers without requiring code changes to your application.\", \" \\nReferences \\n\\u2022 \\nDapr supported pub/sub brokers \\n \\n72 \\nCHAPTER 9 | The Dapr bindings building block \", \"\\n \\nCHAPTER 9 \\nThe Dapr bindings \\nbuilding block \\nCloud-based serverless offerings, such as Azure Fun\", \"ctions and AWS Lambda, have gained wide \\nadoption across the distributed architecture space. Among m\", \"any benefits, they enable a microservice \\nto handle events from or invoke events in an external syst\", \"em - abstracting away the underlying \\ncomplexity and plumbing concerns. External resources are many:\", \" They include datastores, message \\nsystems, and web resources, across different platforms and vendor\", \"s. The Dapr bindings building block \\nbrings these same resource binding capabilities to the doorstep\", \" of your Dapr applications. \\nWhat it solves \\nDapr resource bindings enable your services to integrat\", \"e business operations across external \\nresources outside of the immediate application. An event from\", \" an external system could trigger an \\noperation in your service passing in contextual information. Y\", \"our service could then expand the \\noperation by triggering an event in another external system, pass\", \"ing in contextual payload \\ninformation. Your service communicates without coupling or awareness of t\", \"he external resource. The \\nplumbing is encapsulated inside pre-defined Dapr components. The Dapr com\", \"ponent to use can be \\neasily swapped at run time without code changes. \\nConsider, for example, a Twi\", \"tter account that triggers an event whenever a user tweets a keyword. \\nYour service exposes an event\", \" handler that receives and processes the tweet. Once complete, your \\nservice triggers an event that \", \"invokes an external Twilio service. Twilio sends an SMS message that \\nincludes the tweet. Figure 8-1\", \" show the conceptual architecture of this operation: \\n \\nFigure 8-1. Conceptual architecture of a Dap\", \"r resource binding. \\nAt first glance, resource binding behavior may appear similar to the Publish/Su\", \"bscribe pattern \\ndescribed earlier in this book. While they share similarities, there are difference\", \"s. Publish/subscribe \\n \\n73 \\nCHAPTER 9 | The Dapr bindings building block \\n \\nfocuses on asynchronous \", \"communication between Dapr services. Resource binding has a much wider \\nscope. It focuses on system \", \"interoperability across software platforms. Exchanging information \\nbetween disparate applications, \", \"datastores, and services outside your microservice application. \\nHow it works \\nDapr resource binding\", \" starts with a component configuration file. This YAML file describes the type of \\nresource to which\", \" you\\u2019ll bind along with its configuration settings. Once configured, your service can \\nreceive event\", \"s from the resource or trigger events on it. \\nNote \\nBinding configurations are presented in detail l\", \"ater in the Components section. \\nInput bindings \\nInput bindings trigger your code with incoming even\", \"ts from external resources. To receive events and \\ndata, you register a public endpoint from your se\", \"rvice that becomes the event handler. Figure 8-2 \\nshows the flow: \\n \\nFigure 8-2. Dapr input binding \", \"flow. \\nFigure 8.2 describes the steps for receiving events from an external Twitter account: \\n \\n74 \\n\", \"CHAPTER 9 | The Dapr bindings building block \\n \\n1. \\nThe Dapr sidecar reads the binding configuration\", \" file and subscribes to the event specified for \\nthe external resource. In the example, the event so\", \"urce is a Twitter account. \\n2. \\nWhen a matching Tweet is published on Twitter, the binding component\", \" running in the Dapr \\nsidecar picks it up and triggers an event. \\n3. \\nThe Dapr sidecar invokes the e\", \"ndpoint (that is, event handler) configured for the binding. In the \\nexample, the service listens fo\", \"r an HTTP POST on the /tweet endpoint on port 6000. Because it\\u2019s \\nan HTTP POST operation, the JSON p\", \"ayload for the event is passed in the request body. \\n4. \\nAfter handling the event, the service retur\", \"ns an HTTP status code 200 OK. \\nThe following ASP.NET Core controller provides an example of handlin\", \"g an event triggered by the \\nTwitter binding: \\n[ApiController] \\npublic class SomeController : Contro\", \"llerBase \\n{ \\n    public class TwitterTweet \\n    { \\n        [JsonPropertyName(\\\"id_str\\\")] \\n        pub\", \"lic string ID {get; set; } \\n \\n        [JsonPropertyName(\\\"text\\\")] \\n        public string Text {get; s\", \"et; } \\n    } \\n \\n    [HttpPost(\\\"/tweet\\\")] \\n    public ActionResult Post(TwitterTweet tweet) \\n    { \\n \", \"       // Handle tweet \\n        Console.WriteLine(\\\"Tweet received: {0}: {1}\\\", tweet.ID, tweet.Text);\", \" \\n \\n        // ... \\n \\n        // Acknowledge message \\n        return Ok(); \\n    } \\n} \\nIf the operati\", \"on should error, you would return the appropriate 400 or 500 level HTTP status code. For \\nbindings t\", \"hat feature at-least-once delivery guarantees, the Dapr sidecar will retry the trigger. Check \\nout D\", \"apr documentation for resource bindings to see whether they offer at-least-once or exactly-once \\ndel\", \"ivery guarantees. \\nOutput bindings \\nDapr also includes output binding capabilities. They enable your\", \" service to trigger an event that \\ninvokes an external resource. Again, you start by configuring a b\", \"inding configuration YAML file that \\ndescribes the output binding. Once in place, you trigger an eve\", \"nt that invokes the bindings API on the \\nDapr sidecar of your application. Figure 8-3 shows the flow\", \" of an output binding: \\n \\n75 \\nCHAPTER 9 | The Dapr bindings building block \\n \\n \\nFigure 8-3. Dapr out\", \"put binding flow. \\n1. \\nThe Dapr sidecar reads the binding configuration file with the information on\", \" how to connect to \\nthe external resource. In the example, the external resource is a Twilio SMS acc\", \"ount. \\n2. \\nYour application invokes the /v1.0/bindings/sms endpoint on the Dapr sidecar. In this cas\", \"e, it \\nuses an HTTP POST to invoke the API. It\\u2019s also possible to use gRPC. \\n3. \\nThe binding compone\", \"nt running in the Dapr sidecar calls the external messaging system to send \\nthe message. The message\", \" will contain the payload passed in the POST request. \\nAs an example, you can invoke an output bindi\", \"ng by invoking the Dapr API using curl: \\ncurl -X POST http://localhost:3500/v1.0/bindings/sms \\\\ \\n  -\", \"H \\\"Content-Type: application/json\\\" \\\\ \\n  -d '{ \\n        \\\"data\\\": \\\"Welcome to this awesome service\\\", \\n \", \"       \\\"metadata\\\": { \\n          \\\"toNumber\\\": \\\"555-3277\\\" \\n        }, \\n        \\\"operation\\\": \\\"create\\\" \\n \", \"     }' \\nNote that the HTTP port is the same as used by the Dapr sidecar (in this case, the default \", \"Dapr HTTP \\nport 3500). \\nThe structure of the payload (that is, message sent) will vary per binding. \", \"In the example above, the \\npayload contains a data element with a message. Bindings to other types o\", \"f external resources can be \\ndifferent, especially for the metadata that is sent. Each payload must \", \"also contain an operation field, \\n \\n76 \\nCHAPTER 9 | The Dapr bindings building block \\n \\nthat defines\", \" the operation the binding will execute. The above example specifies a create operation \\nthat create\", \"s the SMS message. Common operations include: \\n\\u2022 \\ncreate \\n\\u2022 \\nget \\n\\u2022 \\ndelete \\n\\u2022 \\nlist \\nIt\\u2019s up to the\", \" author of the binding which operations the binding supports. The documentation for \\neach binding de\", \"scribes the available operations and how to invoke them. \\nUse the Dapr .NET SDK \\nThe Dapr .NET SDK p\", \"rovides language-specific support for .NET developers. In the following example, \\nthe call to the Ht\", \"tpClient.PostAsync() is replaced with the DaprClient.InvokeBindingAsync() \\nmethod. This specialized \", \"method simplifies invoking a configured output binding: \\nprivate async Task SendSMSAsync([FromServic\", \"es] DaprClient daprClient) \\n{ \\n    var message = \\\"Welcome to this awesome service\\\"; \\n    var metadat\", \"a = new Dictionary<string, string> \\n    { \\n      { \\\"toNumber\\\", \\\"555-3277\\\" } \\n    }; \\n    await daprC\", \"lient.InvokeBindingAsync(\\\"sms\\\", \\\"create\\\", message, metadata); \\n} \\nThe method expects the metadata an\", \"d message values. \\nWhen used to invoke a binding, the DaprClient uses gRPC to call the Dapr API on t\", \"he Dapr sidecar. \\nBinding components \\nUnder the hood, resource bindings are implemented with Dapr bi\", \"nding components. They\\u2019re \\ncontributed by the community and written in Go. If you need to integrate \", \"with an external resource \\nfor which no Dapr binding exists yet, you can create it yourself. Check o\", \"ut the Dapr components-\\ncontrib repo to see how you can contribute a binding. \\nNote \\nDapr and all of\", \" its components are written in the Golang (Go) language. Go is considered a modern, \\ncloud-native pr\", \"ogramming platform. \\nYou configure bindings using a YAML configuration file. Here\\u2019s an example confi\", \"guration for the \\nTwitter binding: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name\", \": twitter-mention \\n \\n77 \\nCHAPTER 9 | The Dapr bindings building block \\n \\n  namespace: default \\nspec:\", \" \\n  type: bindings.twitter \\n  version: v1 \\n  metadata: \\n  - name: consumerKey \\n    value: \\\"****\\\" # t\", \"witter api consumer key, required \\n  - name: consumerSecret \\n    value: \\\"****\\\" # twitter api consume\", \"r secret, required \\n  - name: accessToken \\n    value: \\\"****\\\" # twitter api access token, required \\n \", \" - name: accessSecret \\n    value: \\\"****\\\" # twitter api access secret, required \\n  - name: query \\n   \", \" value: \\\"dapr\\\" # your search query, required \\nEach binding configuration contains a general metadata\", \" element with a name and namespace field. \\nDapr will determine the endpoint to invoke your service b\", \"ased upon the configured name field. In the \\nabove example, Dapr will invoke the method annotated wi\", \"th /twitter-mention in your service when \\nan event occurs. \\nIn the spec element, you specify the typ\", \"e of the binding along with binding specific metadata. The \\nexample specifies credentials for access\", \"ing a Twitter account using its API. The metadata can differ \\nbetween input and output bindings. For\", \" example, to use Twitter as an input binding, you need to \\nspecify the text to search for in tweets \", \"using the query field. Every time a matching tweet is sent, the \\nDapr sidecar will invoke the /twitt\", \"er-mention endpoint on the service. It will also deliver the \\ncontents of the tweet. \\nA binding can \", \"be configured for input, output, or both. Interestingly, the binding doesn\\u2019t explicitly \\nspecify inp\", \"ut or output configuration. Instead, the direction is inferred by the usage of the binding \\nalong wi\", \"th configuration values. \\nThe Dapr documentation for resource bindings provides a complete list of t\", \"he available bindings and \\ntheir specific configuration settings. \\nCron binding \\nPay close attention\", \" to Dapr\\u2019s Cron binding. It doesn\\u2019t subscribe to events from an external system. \\nInstead, this bind\", \"ing uses a configurable interval schedule to trigger your application. The binding \\nprovides a simpl\", \"e way to implement a background worker to wake up and do some work at a regular \\ninterval, without t\", \"he need to implement an endless loop with a configurable delay. Here\\u2019s an example \\nof a Cron binding\", \" configuration: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: checkOrderBacklog\", \" \\n  namespace: default \\nspec: \\n  type: bindings.cron \\n  version: v1 \\n  metadata: \\n  - name: schedule\", \" \\n    value: \\\"@every 30m\\\" \\n \\n78 \\nCHAPTER 9 | The Dapr bindings building block \\n \\nIn this example, Da\", \"pr triggers a service by invoking the /checkOrderBacklog endpoint every 30 \\nminutes. There are sever\", \"al patterns available for specifying the schedule value. For more information, \\nsee the Cron binding\", \" documentation. \\nSample application: Dapr Traffic Control \\nIn the Dapr Traffic Control sample applic\", \"ation, the TrafficControl service uses the MQTT input binding \\nto retrieve messages from the CameraS\", \"imulation. Figure 8-4 shows the conceptual architecture of the \\nDapr Traffic Control sample applicat\", \"ion. The Dapr input binding is used in flows marked with number \\n5 in the diagram: \\n \\nFigure 8-4. Co\", \"nceptual architecture of the Dapr Traffic Control sample application. \\n \\n79 \\nCHAPTER 9 | The Dapr bi\", \"ndings building block \\n \\nMQTT input binding \\nMQTT is a lightweight pub/sub messaging protocol, often\", \" used in IoT scenarios. Producers sent MQTT \\nmessages to a topic; subscribers then retrieve messages\", \" from the topic. There are several MQTT \\nmessage broker products available. The Traffic Control samp\", \"le application uses Eclipse Mosquitto. \\nThe CameraSimulation doesn\\u2019t depend on any Dapr building blo\", \"cks. It uses the System.Net.Mqtt \\nlibrary to send MQTT messages: \\n// ... \\n \\n// simulate entry \\nDateT\", \"ime entryTimestamp = DateTime.Now; \\nvar vehicleRegistered = new VehicleRegistered \\n{ \\n    Lane = _ca\", \"mNumber, \\n    LicenseNumber = GenerateRandomLicenseNumber(), \\n    Timestamp = entryTimestamp \\n}; \\n_t\", \"rafficControlService.SendVehicleEntry(vehicleRegistered); \\n \\n// ... \\nThe code uses a proxy of type I\", \"TrafficControlService to call the TrafficControl service. .NET injects \\nan implementation of the ITr\", \"afficControlService interface using constructor injection: \\n:::{custom-style=CodeBox} csharp public \", \"CameraSimulation(int camNumber, ITrafficControlService \\ntrafficControlService) {     _camNumber = ca\", \"mNumber;     _trafficControlService = trafficControlService; \\n} ::: \\nThe MqttTrafficControlService c\", \"lass implements the ITrafficControlService interface. It \\nexposes two methods: SendVehicleEntryAsync\", \" and SendVehicleExitAsync. They both use the \\nMQTT client to send messages to the trafficcontrol/ent\", \"rycam and trafficcontrol/exitcam \\ntopics respectively: \\npublic async Task SendVehicleEntryAsync(Vehi\", \"cleRegistered vehicleRegistered) \\n{ \\n    var eventJson = JsonSerializer.Serialize(vehicleRegistered)\", \"; \\n    var message = new MqttApplicationMessage(\\\"trafficcontrol/entrycam\\\", \\nEncoding.UTF8.GetBytes(e\", \"ventJson)); \\n    await _client.PublishAsync(message, MqttQualityOfService.AtMostOnce); \\n} \\n \\npublic \", \"async Task SendVehicleExitAsync(VehicleRegistered vehicleRegistered) \\n{ \\n    var eventJson = JsonSer\", \"ializer.Serialize(vehicleRegistered); \\n    var message = new MqttApplicationMessage(\\\"trafficcontrol/\", \"exitcam\\\", \\nEncoding.UTF8.GetBytes(eventJson)); \\n    await _client.PublishAsync(message, MqttQualityO\", \"fService.AtMostOnce); \\n} \\nThe constructor sets up the MQTT client to send messages to the MQTT broke\", \"r (Mosquitto) running \\non port 1883. \\nOn the other end, the TrafficControl service uses the MQTT inp\", \"ut binding to receive \\nVehicleRegistered messages sent by the CameraSimulation. For each subscribed \", \"topic, there\\u2019s a \\n \\n80 \\nCHAPTER 9 | The Dapr bindings building block \\n \\nseparate component configura\", \"tion file in the /dapr/components folder. The first one is \\nentrycam.yaml: \\napiVersion: dapr.io/v1al\", \"pha1 \\nkind: Component \\nmetadata: \\n  name: entrycam \\n  namespace: dapr-trafficcontrol \\nspec: \\n  type:\", \" bindings.mqtt \\n  version: v1 \\n  metadata: \\n  - name: url \\n    value: mqtt://localhost:1883 \\n  - nam\", \"e: topic \\n    value: trafficcontrol/entrycam \\nscopes: \\n  - trafficcontrolservice \\nThe configuration \", \"specifies the binding type: bindings.mqtt. It also specifies that the broker runs on \\nlocalhost:1883\", \", the standard port that Mosquitto uses. It also exposes the topic, \\ntrafficcontrol/entrycam. Using \", \"scopes, the config file specifies that only the service with app-id \\ntrafficcontrolservice will have\", \" access to the binding. \\nWhen the TrafficControl service starts, the Dapr sidecar automatically subs\", \"cribes to the \\ntrafficcontrol/entrycam MQTT topic specified in the component configuration. When mes\", \"sages \\narrive on the topic, the Dapr sidecar invokes an HTTP endpoint on your service. The sidecar \\n\", \"determines the URL of the HTTP endpoint to call by looking at the metadata.name field in the binding\", \" \\nconfiguration. In the example above, the endpoint URL is /entrycam. Within the TrafficControl serv\", \"ice, \\nno code needs to be added to support the endpoint: \\n[HttpPost(\\\"entrycam\\\")] \\npublic async Task<\", \"ActionResult> VehicleEntry(VehicleRegistered msg) \\n{ \\n    // ... \\n} \\nThe exitcam.yaml component conf\", \"iguration file configures everything for the exitcam endpoint: \\napiVersion: dapr.io/v1alpha1 \\nkind: \", \"Component \\nmetadata: \\n  name: exitcam \\n  namespace: dapr-trafficcontrol \\nspec: \\n  type: bindings.mqt\", \"t \\n  version: v1 \\n  metadata: \\n  - name: url \\n    value: mqtt://localhost:1883 \\n  - name: topic \\n   \", \" value: trafficcontrol/exitcam \\nscopes: \\n  - trafficcontrolservice \\n \\n81 \\nCHAPTER 9 | The Dapr bindi\", \"ngs building block \\n \\nSMTP output binding \\nThe FineCollection service uses the Dapr SMTP output bind\", \"ing to send emails. Figure 8-5 shows the \\nconceptual architecture of the Dapr Traffic Control sample\", \" application. The Dapr input binding is used \\nin flows marked with number 4 in the diagram: \\n \\nFigur\", \"e 8-5. Conceptual architecture of the Dapr Traffic Control sample application. \\nThe CollectFine meth\", \"od on the CollectionController in the FineCollection service contains code that \\nuses the Dapr clien\", \"t to invoke the output binding: \\n// ... \\n \\n// send fine by email (Dapr output binding) \\nvar body = E\", \"mailUtils.CreateEmailBody(speedingViolation, vehicleInfo, fineString); \\nvar metadata = new Dictionar\", \"y<string, string> \\n{ \\n    [\\\"emailFrom\\\"] = \\\"noreply@cfca.gov\\\", \\n    [\\\"emailTo\\\"] = vehicleInfo.OwnerEm\", \"ail, \\n \\n82 \\nCHAPTER 9 | The Dapr bindings building block \\n \\n    [\\\"subject\\\"] = $\\\"Speeding violation o\", \"n the {speedingViolation.RoadId}\\\" \\n}; \\nawait daprClient.InvokeBindingAsync(\\\"sendmail\\\", \\\"create\\\", bod\", \"y, metadata); \\n \\n// ... \\nThe code uses a simple utility class to create an HTML email body containin\", \"g the necessary \\ninformation. It also creates a dictionary with metadata specific to the SMTP bindin\", \"g. This binding \\ncomponent interprets the metadata when invoked. \\nThe following arguments are requir\", \"ed to invoke the binding: \\n\\u2022 \\nThe name of the binding component. In this case sendmail. \\n\\u2022 \\nThe oper\", \"ation the binding needs to perform. In this case create. \\n\\u2022 \\nThe body of the message to send. In thi\", \"s case, the HTML email body. \\n\\u2022 \\nThe metadata for sending the email. \\nThe Dapr output binding named \", \"sendmail is configured in the email.yaml component configuration \\nfile in the /dapr/components folde\", \"r: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: sendmail \\n  namespace: dapr-tr\", \"afficcontrol \\nspec: \\n  type: bindings.smtp \\n  version: v1 \\n  metadata: \\n  - name: host \\n    value: l\", \"ocalhost \\n  - name: port \\n    value: 4025 \\n  - name: user \\n    secretKeyRef: \\n      name: smtp.user \", \"\\n      key: smtp.user \\n  - name: password \\n    secretKeyRef: \\n      name: smtp.password \\n      key: \", \"smtp.password \\n  - name: skipTLSVerify \\n    value: true \\nauth: \\n  secretStore: trafficcontrol-secret\", \"s \\nscopes: \\n  - finecollectionservice \\nThe configuration specifies the binding type: bindings.smtp. \", \"\\nThe metadata section contains the information for connecting to the SMTP server. See the binding\\u2019s \", \"\\ndocumentation for specific metadata required for this binding. The username and password to \\nconnec\", \"t to the SMTP server are retrieved from a secrets store. See the Secrets management building \\nblock \", \"chapter for more information on how this works. \\nThe scopes element specifies that only the service \", \"with app-id finecollectonservice can access this \\nbinding. \\n \\n83 \\nCHAPTER 9 | The Dapr bindings buil\", \"ding block \\n \\nThe Traffic Control sample application uses MailDev. MailDev is a development SMTP ser\", \"ver that \\ndoesn\\u2019t actually send out emails (by default). Instead, it collects emails and presents th\", \"em in an inbox \\nweb application. MailDev is extremely useful for dev/test and demo scenarios. \\nUsing\", \" Dapr bindings in the Traffic Control sample application provides the following benefits: \\n1. \\nUsing\", \" MQTT messaging and SMTP without the need to learn this protocol or a specific MQTT \\nAPI. \\n2. \\nUsing\", \" SMTP to send an email without the need to learn this protocol or a specific SMTP API. \\nSummary \\nDap\", \"r resource bindings enable you to integrate with different external resources and systems without \\nt\", \"aking dependencies on their libraries or SDKs. These external systems don\\u2019t necessarily have to be \\n\", \"messaging systems like a service bus or message broker. Bindings also exist for datastores and web \\n\", \"resources like Twitter or SendGrid. \\nInput bindings (or triggers) react to events occurring in an ex\", \"ternal system. They invoke the public \\nHTTP endpoints pre-configured in your application. Dapr uses \", \"the name of the binding in the \\nconfiguration to determine the endpoint to call in your application.\", \" \\nOutput bindings will send messages to an external system. You trigger an output binding by doing a\", \"n \\nHTTP POST on the /v1.0/bindings/<binding-name> endpoint on the Dapr sidecar. You can also use \\ngR\", \"PC to invoke the binding. The .NET SDK offers a InvokeBindingAsync method to invoke Dapr \\nbindings u\", \"sing gRPC. \\nYou implement a binding with a Dapr component. These components are contributed by the \\n\", \"community. Each binding component\\u2019s configuration has metadata that is specific for the external \\nsy\", \"stem it abstracts. Also, the commands it supports and the structure of the payload will differ per \\n\", \"binding component. \\nReferences \\n\\u2022 \\nDapr documentation for resource bindings \\n\\u2022 \\nMosquitto MQTT broke\", \"r \\n\\u2022 \\nMailDev development SMTP server \\n \\n84 \\nCHAPTER 10 | The Dapr actors building block \\n \\nCHAPTER \", \"10 \\nThe Dapr actors building \\nblock \\nThe actor model originated in 1973. It was proposed by Carl Hew\", \"itt as a conceptual model of \\nconcurrent computation, a form of computing in which several computati\", \"ons are executed at the \\nsame time. Highly parallel computers weren\\u2019t yet available at that time, bu\", \"t the more recent \\nadvancements of multi-core CPUs and distributed systems have made the actor model\", \" popular. \\nIn the actor model, the actor is an independent unit of compute and state. Actors are com\", \"pletely \\nisolated from each other and they will never share memory. Actors communicate with each oth\", \"er \\nusing messages. When an actor receives a message, it can change its internal state, and send \\nme\", \"ssages to other (possibly new) actors. \\nThe reason why the actor model makes writing concurrent syst\", \"ems easier is that it provides a turn-\\nbased (or single-threaded) access model. Multiple actors can \", \"run at the same time, but each actor will \\nprocess received messages one at a time. This means that \", \"you can be sure that at most one thread is \\nactive inside an actor at any time. That makes writing c\", \"orrect concurrent and parallel systems much \\neasier. \\nWhat it solves \\nActor model implementations ar\", \"e usually tied to a specific language or platform. With the Dapr actors \\nbuilding block however, you\", \" can leverage the actor model from any language or platform. \\nDapr\\u2019s implementation is based on the \", \"virtual actor pattern introduced by Project \\u201cOrleans\\u201d. With the \\nvirtual actor pattern, you don\\u2019t ne\", \"ed to explicitly create actors. Actors are activated implicitly and \\nplaced on a node in the cluster\", \" the first time a message is sent to the actor. When not executing \\noperations, actors are silently \", \"unloaded from memory. If a node fails, Dapr automatically moves \\nactivated actors to healthy nodes. \", \"Besides sending messages between actors, the Dapr actor model \\nalso support scheduling future work u\", \"sing timers and reminders. \\nWhile the actor model can provide great benefits, it\\u2019s important to care\", \"fully consider the actor design. \\nFor example, having many clients call the same actor will result i\", \"n poor performance because the actor \\noperations execute serially. Here are some criteria to check i\", \"f a scenario is a good fit for Dapr actors: \\n\\u2022 \\nYour problem space involves concurrency. Without act\", \"ors, you\\u2019d have to introduce explicit \\nlocking mechanisms in your code. \\n \\n85 \\nCHAPTER 10 | The Dapr\", \" actors building block \\n \\n\\u2022 \\nYour problem space can be partitioned into small, independent, and isol\", \"ated units of state and \\nlogic. \\n\\u2022 \\nYou don\\u2019t need low-latency reads of the actor state. Low-latency\", \" reads cannot be guaranteed \\nbecause actor operations execute serially. \\n\\u2022 \\nYou don\\u2019t need to query \", \"state across a set of actors. Querying across actors is inefficient because \\neach actor\\u2019s state need\", \"s to be read individually and can introduce unpredictable latencies. \\nOne design pattern that fits t\", \"hese criteria quite well is the orchestration-based saga or process \\nmanager design pattern. A saga \", \"manages a sequence of steps that must be taken to reach some \\noutcome. The saga (or process manager)\", \" maintains the current state of the sequence and triggers the \\nnext step. If a step fails, the saga \", \"can execute compensating actions. Actors make it easy to deal with \\nconcurrency in the saga and to k\", \"eep track of the current state. The eShopOnDapr reference \\napplication uses the saga pattern and Dap\", \"r actors to implement the Ordering process. \\nHow it works \\nThe Dapr sidecar provides the HTTP/gRPC A\", \"PI to invoke actors. This is the base URL of the HTTP API: \\nhttp://localhost:<daprPort>/v1.0/actors/\", \"<actorType>/<actorId>/ \\n\\u2022 \\n<daprPort>: the HTTP port that Dapr listens on. \\n\\u2022 \\n<actorType>: the acto\", \"r type. \\n\\u2022 \\n<actorId>: the ID of the specific actor to call. \\nThe sidecar manages how, when and wher\", \"e each actor runs, and also routes messages between \\nactors. When an actor hasn\\u2019t been used for a pe\", \"riod of time, the runtime deactivates the actor and \\nremoves it from memory. Any state managed by th\", \"e actor is persisted and will be available when the \\nactor re-activates. Dapr uses an idle timer to \", \"determine when an actor can be deactivated. When an \\noperation is called on the actor (either by a m\", \"ethod call or a reminder firing), the idle timer is reset \\nand the actor instance will remain activa\", \"ted. \\nThe sidecar API is only one part of the equation. The service itself also needs to implement a\", \"n API \\nspecification, because the actual code that you write for the actor will run inside the servi\", \"ce itself. \\nFigure 11-1 shows the various API calls between the service and its sidecar: \\n \\n86 \\nCHAP\", \"TER 10 | The Dapr actors building block \\n \\n \\nFigure 11-1. API calls between actor service and Dapr s\", \"idecar. \\nTo provide scalability and reliability, actors are partitioned across all the instances of \", \"the actor service. \\nThe Dapr placement service is responsible for keeping track of the partitioning \", \"information. When a \\nnew instance of an actor service is started, the sidecar registers the supporte\", \"d actor types with the \\nplacement service. The placement service calculates the updated partitioning\", \" information for the \\ngiven actor type and broadcasts it to all instances. Figure 11-2 shows what ha\", \"ppens when a service is \\nscaled out to a second replica: \\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/ac\", \"tors/placement.png\\u201d alt-text=\\u201cDiagram of the actor \\nplacement service.\\u201d::: \\nFigure 11-2. Actor place\", \"ment service. \\n1. \\nOn startup, the sidecar makes a call to the actor service to get the registered a\", \"ctor types as well \\nas actor configuration settings. \\n2. \\nThe sidecar sends the list of registered a\", \"ctor types to the placement service. \\n3. \\nThe placement service broadcasts the updated partitioning \", \"information to all actor service \\ninstances. Each instance will keep a cached copy of the partitioni\", \"ng information and use it to \\ninvoke actors. \\nImportant \\nBecause actors are randomly distributed acr\", \"oss service instances, it should be expected that an actor \\noperation always requires a call to a di\", \"fferent node in the network. \\n \\n87 \\nCHAPTER 10 | The Dapr actors building block \\n \\nThe next figure s\", \"hows an ordering service instance running in Pod 1 call the ship method of an \\nOrderActor instance w\", \"ith ID 3. Because the actor with ID 3 is placed in a different instance, this results \\nin a call to \", \"a different node in the cluster: \\n \\nFigure 11-3. Calling an actor method. \\n1. \\nThe service calls the\", \" actor API on the sidecar. The JSON payload in the request body contains the \\ndata to send to the ac\", \"tor. \\n2. \\nThe sidecar uses the locally cached partitioning information from the placement service to\", \" \\ndetermine which actor service instance (partition) is responsible for hosting the actor with ID 3.\", \" \\nIn this example, it\\u2019s the service instance in pod 2. The call is forwarded to the appropriate \\nsid\", \"ecar. \\n3. \\nThe sidecar instance in pod 2 calls the service instance to invoke the actor. The service\", \" instance \\nactivates the actor (if it hasn\\u2019t already) and executes the actor method. \\n \\n88 \\nCHAPTER \", \"10 | The Dapr actors building block \\n \\nTurn-based access model \\nThe turn-based access model ensures \", \"that at any time there\\u2019s at most one thread active inside an \\nactor instance. To understand why this\", \" is useful, consider the following example of a method that \\nincrements a counter value: \\npublic int\", \" Increment() \\n{ \\n    var currentValue = GetValue(); \\n    var newValue = currentValue + 1; \\n \\n    Sav\", \"eValue(newValue); \\n \\n    return newValue; \\n} \\nLet\\u2019s assume that the current value returned by the Ge\", \"tValue method is 1. When two threads call the \\nIncrement method at the same time, there\\u2019s a risk of \", \"both of them calling the GetValue method \\nbefore one of them calls SaveValue. This results in both t\", \"hreads starting with the same initial value (1). \\nThe threads then increment the value to 2 and retu\", \"rn it to the caller. The resulting value after the two \\ncalls is now 2 instead of 3 which it should \", \"be. This is a simple example to illustrate the kind of issues \\nthat can slip into your code when wor\", \"king with multiple threads, and is easy to solve. In real world \\napplications however, concurrent an\", \"d parallel scenarios can become very complex. \\nIn traditional programming models, you can solve this\", \" problem by introducing locking mechanisms. \\nFor example: \\npublic int Increment() \\n{ \\n    int newVal\", \"ue; \\n \\n    lock (_lockObject) \\n    { \\n        var currentValue = GetValue(); \\n        newValue = cur\", \"rentValue + 1; \\n \\n        SaveValue(newValue); \\n    } \\n \\n    return newValue; \\n} \\nUnfortunately, usi\", \"ng explicit locking mechanisms is error-prone. They can easily lead to deadlocks and \\ncan have serio\", \"us impact on performance. \\nThanks to the turn-based access model, you don\\u2019t need to worry about mult\", \"iple threads with actors, \\nmaking it much easier to write concurrent systems. The following actor ex\", \"ample closely mirrors the \\ncode from the previous sample, but doesn\\u2019t require any locking mechanisms\", \" to be correct: \\npublic async Task<int> IncrementAsync() \\n{ \\n    var counterValue = await StateManag\", \"er.TryGetStateAsync<int>(\\\"counter\\\"); \\n \\n    var currentValue = counterValue.HasValue ? counterValue.\", \"Value : 0; \\n    var newValue = currentValue + 1; \\n \\n89 \\nCHAPTER 10 | The Dapr actors building block \", \"\\n \\n \\n    await StateManager.SetStateAsync(\\\"counter\\\", newValue); \\n \\n    return newValue; \\n} \\nTimers a\", \"nd reminders \\nActors can use timers and reminders to schedule calls to themselves. Both concepts sup\", \"port the \\nconfiguration of a due time. The difference lies in the lifetime of the callback registrat\", \"ions: \\n\\u2022 \\nTimers will only stay active as long as the actor is activated. Timers will not reset the \", \"idle-timer, \\nso they cannot keep an actor active on their own. \\n\\u2022 \\nReminders outlive actor activatio\", \"ns. If an actor is deactivated, a reminder will re-activate the \\nactor. Reminders will reset the idl\", \"e-timer. \\nTimers are registered by making a call to the actor API. In the following example, a timer\", \" is registered \\nwith a due time of 0 and a period of 10 seconds. \\ncurl -X POST http://localhost:3500\", \"/v1.0/actors/<actorType>/<actorId>/timers/<name> \\\\ \\n  -H \\\"Content-Type: application/json\\\" \\\\ \\n  -d '{\", \" \\n        \\\"dueTime\\\": \\\"0h0m0s0ms\\\", \\n        \\\"period\\\": \\\"0h0m10s0ms\\\" \\n      }' \\nBecause the due time is\", \" 0, the timer will fire immediately. After a timer callback has finished, the timer \\nwill wait 10 se\", \"conds before firing again. \\nReminders are registered in a similar way. The following example shows a\", \" reminder registration with a \\ndue time of 5 minutes, and an empty period: \\ncurl -X POST http://loca\", \"lhost:3500/v1.0/actors/<actorType>/<actorId>/reminders/<name> \\\\ \\n  -H \\\"Content-Type: application/jso\", \"n\\\" \\\\ \\n  -d '{ \\n        \\\"dueTime\\\": \\\"0h5m0s0ms\\\", \\n        \\\"period\\\": \\\"\\\" \\n      }' \\nThis reminder will f\", \"ire in 5 minutes. Because the given period is empty, this will be a one-time \\nreminder. \\nNote \\nTimer\", \"s and reminders both respect the turn-based access model. When a timer or reminder fires, the \\ncallb\", \"ack will not be executed until any other method invocation or timer/reminder callback has \\nfinished.\", \" \\nState persistence \\nActor state is persisted using the Dapr state management building block. Becaus\", \"e actors can execute \\nmultiple state operations in a single turn, the state store component must sup\", \"port multi-item \\ntransactions. At the time of writing, the following state stores support multi-item\", \" transactions: \\n \\n90 \\nCHAPTER 10 | The Dapr actors building block \\n \\n\\u2022 \\nAzure Cosmos DB \\n\\u2022 \\nMongoDB \", \"\\n\\u2022 \\nMySQL \\n\\u2022 \\nPostgreSQL \\n\\u2022 \\nRedis \\n\\u2022 \\nRethinkDB \\n\\u2022 \\nSQL Server \\nTo configure a state store componen\", \"t for use with actors, you need to append the following metadata \\nto the state store configuration: \", \"\\n- name: actorStateStore \\n  value: \\\"true\\\" \\nHere\\u2019s a complete example for a Redis state store: \\napiVe\", \"rsion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: statestore \\nspec: \\n  type: state.redis \", \"\\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    value: localhost:6379 \\n  - name: redisPassword\", \" \\n    value: \\\"\\\" \\n  - name: actorStateStore \\n    value: \\\"true\\\" \\nUse the Dapr .NET SDK \\nYou can create\", \" an actor model implementation using only HTTP/gRPC calls. However, it\\u2019s much more \\nconvenient to us\", \"e the language specific Dapr SDKs. At the time of writing, the .NET, Java and Python \\nSDKs all provi\", \"de extensive support for working with actors. \\nTo get started with the .NET Dapr actors SDK, you add\", \" a package reference to Dapr.Actors to your \\nservice project. The first step of creating an actual a\", \"ctor is to define an interface that derives from \\nIActor. Clients use the interface to invoke operat\", \"ions on the actor. Here\\u2019s a simple example of an \\nactor interface for keeping scores: \\npublic interf\", \"ace IScoreActor : IActor \\n{ \\n    Task<int> IncrementScoreAsync(); \\n \\n    Task<int> GetScoreAsync(); \", \"\\n} \\n \\n \\n \\n91 \\nCHAPTER 10 | The Dapr actors building block \\n \\nImportant \\nThe return type of an actor \", \"method must be Task or Task<T>. Also, actor methods can have at most \\none argument. Both the return \", \"type and the arguments must be System.Text.Json serializable. \\nNext, implement the actor by deriving\", \" a ScoreActor class from Actor. The ScoreActor class must also \\nimplement the IScoreActor interface:\", \" \\npublic class ScoreActor : Actor, IScoreActor \\n{ \\n    public ScoreActor(ActorHost host) : base(host\", \") \\n    { \\n    } \\n \\n    // TODO Implement interface methods. \\n} \\nThe constructor in the snippet above\", \" takes a host argument of type ActorHost. The ActorHost class \\nrepresents the host for an actor type\", \" within the actor runtime. You need to pass this argument to the \\nconstructor of the Actor base clas\", \"s. Actors also support dependency injection. Any additional \\narguments that you add to the actor con\", \"structor are resolved using the .NET dependency injection \\ncontainer. \\nLet\\u2019s now implement the Incre\", \"mentScoreAsync method of the interface: \\npublic Task<int> IncrementScoreAsync() \\n{ \\n    return State\", \"Manager.AddOrUpdateStateAsync( \\n        \\\"score\\\", \\n        1, \\n        (key, currentScore) => current\", \"Score + 1 \\n    ); \\n} \\nIn the snippet above, a single call to StateManager.AddOrUpdateStateAsync prov\", \"ides the full \\nimplementation for the IncrementScoreAsync method. The AddOrUpdateStateAsync method t\", \"akes \\nthree arguments: \\n1. \\nThe key of the state to update. \\n2. \\nThe value to write if no score is s\", \"tored in the state store yet. \\n3. \\nA Func to call if there already is a score stored in the state st\", \"ore. It takes the state key and \\ncurrent score, and returns the updated score to write back to the s\", \"tate store. \\nThe GetScoreAsync implementation reads the current score from the state store and retur\", \"ns it to the \\nclient: \\npublic async Task<int> GetScoreAsync() \\n{ \\n    var scoreValue = await StateMa\", \"nager.TryGetStateAsync<int>(\\\"score\\\"); \\n    if (scoreValue.HasValue) \\n    { \\n        return scoreValu\", \"e.Value; \\n    } \\n \\n \\n92 \\nCHAPTER 10 | The Dapr actors building block \\n \\n    return 0; \\n} \\nTo host ac\", \"tors in an ASP.NET Core service, you must add a reference to the Dapr.Actors.AspNetCore \\npackage and\", \" make some changes in the Program file. In the following example, the call to \\nMapActorsHandlers reg\", \"isters Dapr Actor endpoints in ASP.NET Core routing: \\nvar builder = WebApplication.CreateBuilder(arg\", \"s); \\nvar app = builder.Build(); \\n// Actors building block does not support HTTPS redirection. \\n//app\", \".UseHttpsRedirection(); \\napp.MapControllers(); \\n// Add actor endpoints. \\napp.MapActorsHandlers(); \\nT\", \"he actors endpoints are necessary because the Dapr sidecar calls the application to host and interac\", \"t \\nwith actor instances. \\nImportant \\nMake sure your Program (or Startup) class does not contain an a\", \"pp.UseHttpsRedirection call to \\nredirect clients to the HTTPS endpoint. This will not work with acto\", \"rs. By design, a Dapr sidecar sends \\nrequests over unencrypted HTTP by default. The HTTPS middleware\", \" will block these requests when \\nenabled. \\nThe Program file is also the place to register the specif\", \"ic actor types. The following example registers \\nthe ScoreActor using the AddActors extension method\", \": \\nvar builder = WebApplication.CreateBuilder(args); \\nbuilder.Services.AddActors(options => \\n{ \\n    \", \"options.Actors.RegisterActor<ScoreActor>(); \\n}); \\nAt this point, the ASP.NET Core service is ready t\", \"o host the ScoreActor and accept incoming requests. \\nClient applications use actor proxies to invoke\", \" operations on actors. The following example shows \\nhow a console client application invokes the Inc\", \"rementScoreAsync operation on a ScoreActor \\ninstance: \\nvar actorId = new ActorId(\\\"scoreActor1\\\"); \\n \\n\", \"var proxy = ActorProxy.Create<IScoreActor>(actorId, \\\"ScoreActor\\\"); \\n \\nvar score = await proxy.Increm\", \"entScoreAsync(); \\n \\nConsole.WriteLine($\\\"Current score: {score}\\\"); \\nThe above example uses the Dapr.A\", \"ctors package to call the actor service. To invoke an operation on \\nan actor, you need to be able to\", \" address it. You\\u2019ll need two parts for this: \\n1. \\nThe actor type uniquely identifies the actor imple\", \"mentation across the whole application. By \\ndefault, the actor type is the name of the implementatio\", \"n class (without namespace). You can \\ncustomize the actor type by adding an ActorAttribute to the im\", \"plementation class and setting \\nits TypeName property. \\n \\n93 \\nCHAPTER 10 | The Dapr actors building \", \"block \\n \\n2. \\nThe ActorId uniquely identifies an instance of an actor type. You can also use this cla\", \"ss to \\ngenerate a random actor id by calling ActorId.CreateRandom. \\nThe example uses ActorProxy.Crea\", \"te to create a proxy instance for the ScoreActor. The Create \\nmethod takes two arguments: the ActorI\", \"d identifying the specific actor and the actor type. It also has \\na generic type parameter to specif\", \"y the actor interface that the actor type implements. As both the \\nserver and client applications ne\", \"ed to use the actor interfaces, they\\u2019re typically stored in a separate \\nshared project. \\nThe final s\", \"tep in the example calls the IncrementScoreAsync method on the actor and outputs the \\nresult. Rememb\", \"er that the Dapr placement service distributes the actor instances across the Dapr \\nsidecars. Theref\", \"ore, expect an actor call to be a network call to another node. \\nCall actors from ASP.NET Core clien\", \"ts \\nThe console client example in the previous section uses the static ActorProxy.Create method dire\", \"ctly \\nto get an actor proxy instance. If the client application is an ASP.NET Core application, you \", \"should use \\nthe IActorProxyFactory interface to create actor proxies. The main benefit is that it al\", \"lows you to \\nmanage configuration in one place. The AddActors extension method on IServiceCollection\", \" takes \\na delegate that allows you to specify actor runtime options, such as the HTTP endpoint of th\", \"e Dapr \\nsidecar. The following example specifies custom JsonSerializerOptions to use for actor state\", \" \\npersistence and message deserialization: \\nvar builder = WebApplication.CreateBuilder(args); \\nbuild\", \"er.Services.AddActors(options => \\n{ \\n    var jsonSerializerOptions = new JsonSerializerOptions() \\n  \", \"  { \\n        PropertyNamingPolicy = JsonNamingPolicy.CamelCase, \\n        PropertyNameCaseInsensitive\", \" = true \\n    }; \\n \\n    options.JsonSerializerOptions = jsonSerializerOptions; \\n    options.Actors.Re\", \"gisterActor<ScoreActor>(); \\n}); \\nThe call to AddActors registers the IActorProxyFactory for .NET dep\", \"endency injection. This allows \\nASP.NET Core to inject an IActorProxyFactory instance into your cont\", \"roller classes. The following \\nexample calls an actor method from an ASP.NET Core controller class: \", \"\\n[ApiController] \\n[Route(\\\"[controller]\\\")] \\npublic class ScoreController : ControllerBase \\n{ \\n    pri\", \"vate readonly IActorProxyFactory _actorProxyFactory; \\n \\n    public ScoreController(IActorProxyFactor\", \"y actorProxyFactory) \\n    { \\n        _actorProxyFactory = actorProxyFactory; \\n    } \\n \\n    [HttpPut(\", \"\\\"{scoreId}\\\")] \\n    public Task<int> IncrementAsync(string scoreId) \\n    { \\n \\n94 \\nCHAPTER 10 | The Da\", \"pr actors building block \\n \\n        var scoreActor = _actorProxyFactory.CreateActorProxy<IScoreActor\", \">( \\n            new ActorId(scoreId), \\n            \\\"ScoreActor\\\"); \\n \\n        return scoreActor.Incre\", \"mentScoreAsync(); \\n    } \\n} \\nActors can also call other actors directly. The Actor base class expose\", \"s an IActorProxyFactory class \\nthrough the ProxyFactory property. To create an actor proxy from with\", \"in an actor, use the \\nProxyFactory property of the Actor base class. The following example shows an \", \"OrderActor that \\ninvokes operations on two other actors: \\npublic class OrderActor : Actor, IOrderAct\", \"or \\n{ \\n    public OrderActor(ActorHost host) : base(host) \\n    { \\n    } \\n \\n    public async Task Pro\", \"cessOrderAsync(Order order) \\n    { \\n        var stockActor = ProxyFactory.CreateActorProxy<IStockAct\", \"or>( \\n            new ActorId(order.OrderNumber), \\n            \\\"StockActor\\\"); \\n \\n        await stock\", \"Actor.ReserveStockAsync(order.OrderLines); \\n \\n        var paymentActor = ProxyFactory.CreateActorPro\", \"xy<IPaymentActor>( \\n            new ActorId(order.OrderNumber), \\n            \\\"PaymentActor\\\"); \\n \\n   \", \"     await paymentActor.ProcessPaymentAsync(order.PaymentDetails); \\n    } \\n} \\n \\n \\nNote \\nBy default, \", \"Dapr actors aren\\u2019t reentrant. This means that a Dapr actor cannot be called more than once \\nin the s\", \"ame chain. For example, the call chain Actor A -> Actor B -> Actor A is not allowed. At the \\ntime of\", \" writing, there\\u2019s a preview feature available to support reentrancy. However, there is no SDK \\nsuppo\", \"rt yet. For more details, see the official documentation. \\nCall non-.NET actors \\nSo far, the example\", \"s used strongly-typed actor proxies based on .NET interfaces to illustrate actor \\ninvocations. This \", \"works great when both the actor host and client are .NET applications. However, if \\nthe actor host i\", \"s not a .NET application, you don\\u2019t have an actor interface to create a strongly-typed \\nproxy. In th\", \"ese cases, you can use a weakly-typed proxy. \\nYou create weakly-typed proxies in a similar way to st\", \"rongly-typed proxies. Instead of relying on a \\n.NET interface, you need to pass in the actor method \", \"name as a string. \\n[HttpPut(\\\"{scoreId}\\\")] \\npublic Task<int> IncrementAsync(string scoreId) \\n \\n95 \\nCH\", \"APTER 10 | The Dapr actors building block \\n \\n{ \\n    var scoreActor = _actorProxyFactory.CreateActorP\", \"roxy( \\n        new ActorId(scoreId), \\n        \\\"ScoreActor\\\"); \\n \\n    return scoreActor(\\\"IncrementScor\", \"eAsync\\\"); \\n} \\nTimers and reminders \\nUse the RegisterTimerAsync method of the Actor base class to sch\", \"edule actor timers. In the \\nfollowing example, a TimerActor exposes a StartTimerAsync method. Client\", \"s can call the method to \\nstart a timer that repeatedly writes a given text to the log output. \\npubl\", \"ic class TimerActor : Actor, ITimerActor \\n{ \\n    public TimerActor(ActorHost host) : base(host) \\n   \", \" { \\n    } \\n \\n    public Task StartTimerAsync(string name, string text) \\n    { \\n        return Regist\", \"erTimerAsync( \\n            name, \\n            nameof(TimerCallback), \\n            Encoding.UTF8.GetB\", \"ytes(text), \\n            TimeSpan.Zero, \\n            TimeSpan.FromSeconds(3)); \\n    } \\n \\n    public \", \"Task TimerCallbackAsync(byte[] state) \\n    { \\n        var text = Encoding.UTF8.GetString(state); \\n \\n\", \"        Logger.LogInformation($\\\"Timer fired: {text}\\\"); \\n \\n        return Task.CompletedTask; \\n    } \", \"\\n} \\nThe StartTimerAsync method calls RegisterTimerAsync to schedule the timer. RegisterTimerAsync \\nt\", \"akes five arguments: \\n1. \\nThe name of the timer. \\n2. \\nThe name of the method to call when the timer \", \"fires. \\n3. \\nThe state to pass to the callback method. \\n4. \\nThe amount of time to wait before the cal\", \"lback method is first invoked. \\n5. \\nThe time interval between callback method invocations. You can s\", \"pecify \\nTimeSpan.FromMilliseconds(-1) to disable periodic signaling. \\nThe TimerCallbackAsync method \", \"receives the user state in binary form. In the example, the callback \\ndecodes the state back to a st\", \"ring before writing it to the log. \\nTimers can be stopped by calling UnregisterTimerAsync: \\n \\n96 \\nCH\", \"APTER 10 | The Dapr actors building block \\n \\npublic class TimerActor : Actor, ITimerActor \\n{ \\n    //\", \" ... \\n \\n    public Task StopTimerAsync(string name) \\n    { \\n        return UnregisterTimerAsync(name\", \"); \\n    } \\n} \\nRemember that timers do not reset the actor idle timer. When no other calls are made o\", \"n the actor, it \\nmay be deactivated and the timer will be stopped automatically. To schedule work th\", \"at does reset the \\nidle timer, use reminders which we\\u2019ll look at next. \\nTo use reminders in an actor\", \", your actor class must implement the IRemindable interface: \\npublic interface IRemindable \\n{ \\n    T\", \"ask ReceiveReminderAsync( \\n        string reminderName, byte[] state, \\n        TimeSpan dueTime, Tim\", \"eSpan period); \\n} \\nThe ReceiveReminderAsync method is called when a reminder is fired. It takes 4 ar\", \"guments: \\n1. \\nThe name of the reminder. \\n2. \\nThe user state provided during registration. \\n3. \\nThe i\", \"nvocation due time provided during registration. \\n4. \\nThe invocation period provided during registra\", \"tion. \\nTo register a reminder, use the RegisterReminderAsync method of the actor base class. The fol\", \"lowing \\nexample sets a reminder to fire a single time with a due time of three minutes. \\npublic clas\", \"s ReminderActor : Actor, IReminderActor, IRemindable \\n{ \\n    public ReminderActor(ActorHost host) : \", \"base(host) \\n    { \\n    } \\n \\n    public Task SetReminderAsync(string text) \\n    { \\n        return Reg\", \"isterReminderAsync( \\n            \\\"DoNotForget\\\", \\n            Encoding.UTF8.GetBytes(text), \\n        \", \"    TimeSpan.FromSeconds(3), \\n            TimeSpan.FromMilliseconds(-1)); \\n    } \\n \\n    public Task \", \"ReceiveReminderAsync( \\n        string reminderName, byte[] state, \\n        TimeSpan dueTime, TimeSpa\", \"n period) \\n    { \\n        if (reminderName == \\\"DoNotForget\\\") \\n        { \\n            var text = Enco\", \"ding.UTF8.GetString(state); \\n \\n            Logger.LogInformation($\\\"Don't forget: {text}\\\"); \\n \\n97 \\nCH\", \"APTER 10 | The Dapr actors building block \\n \\n        } \\n \\n        return Task.CompletedTask; \\n    } \", \"\\n} \\nThe RegisterReminderAsync method is similar to RegisterTimerAsync but you don\\u2019t have to specify \", \"\\na callback method explicitly. As the above example shows, you implement \\nIRemindable.ReceiveReminde\", \"rAsync to handle fired reminders. \\nReminders both reset the idle timer and are persistent. Even if y\", \"our actor is deactivated, it will be \\nreactivated at the moment a reminder fires. To stop a reminder\", \" from firing, call \\nUnregisterReminderAsync. \\nSample application: Dapr Traffic Control \\nThe default \", \"version of Dapr Traffic Control does not use the actor model. However, it does contain an \\nalternati\", \"ve actor-based implementation of the TrafficControl service that you can enable. To make use \\nof act\", \"ors in the TrafficControl service, open up the \\nsrc/TrafficControlService/Controllers/TrafficControl\", \"ler.cs file and uncomment the \\nUSE_ACTORMODEL statement at the top of the file: \\n#define USE_ACTORMO\", \"DEL \\nWhen the actor model is enabled, the application uses actors to represent vehicles. The operati\", \"ons \\nthat can be invoked on the vehicle actors are defined in an IVehicleActor interface: \\npublic in\", \"terface IVehicleActor : IActor \\n{ \\n    Task RegisterEntryAsync(VehicleRegistered msg); \\n    Task Reg\", \"isterExitAsync(VehicleRegistered msg); \\n} \\nThe (simulated) entry cameras call the RegisterEntryAsync\", \" method when a new vehicle is first \\ndetected in the lane. The only responsibility of this method is\", \" storing the entry timestamp in the actor \\nstate: \\nvar vehicleState = new VehicleState \\n{ \\n    Licen\", \"seNumber = msg.LicenseNumber, \\n    EntryTimestamp = msg.Timestamp \\n}; \\nawait StateManager.SetStateAs\", \"ync(\\\"VehicleState\\\", vehicleState); \\nWhen the vehicle reaches the end of the speed camera zone, the e\", \"xit camera calls the \\nRegisterExitAsync method. The RegisterExitAsync method first gets the current \", \"states and \\nupdates it to include the exit timestamp: \\nvar vehicleState = await StateManager.GetStat\", \"eAsync<VehicleState>(\\\"VehicleState\\\"); \\nvehicleState.ExitTimestamp = msg.Timestamp; \\n \\n \\n \\n98 \\nCHAPTE\", \"R 10 | The Dapr actors building block \\n \\nNote \\nThe code above currently assumes that a VehicleState \", \"instance has already been saved by the \\nRegisterEntryAsync method. The code could be improved by fir\", \"st checking to make sure the state \\nexists. Thanks to the turn-based access model, no explicit locks\", \" are required in the code. \\nAfter the state is updated, the RegisterExitAsync method checks if the v\", \"ehicle was driving too fast. If \\nit was, the actor publishes a message to the collectfine pub/sub to\", \"pic: \\nint violation = _speedingViolationCalculator.DetermineSpeedingViolationInKmh( \\n    vehicleStat\", \"e.EntryTimestamp, vehicleState.ExitTimestamp); \\n \\nif (violation > 0) \\n{ \\n    var speedingViolation =\", \" new SpeedingViolation \\n    { \\n        VehicleId = msg.LicenseNumber, \\n        RoadId = _roadId, \\n  \", \"      ViolationInKmh = violation, \\n        Timestamp = msg.Timestamp \\n    }; \\n \\n    await _daprClien\", \"t.PublishEventAsync(\\\"pubsub\\\", \\\"collectfine\\\", speedingViolation); \\n} \\nThe code above uses two externa\", \"l dependencies. The _speedingViolationCalculator encapsulates \\nthe business logic for determining wh\", \"ether or not a vehicle has driven too fast. The _daprClient \\nallows the actor to publish messages us\", \"ing the Dapr pub/sub building block. \\nBoth dependencies are registered in the Program.cs class and i\", \"njected into the actor using constructor \\ndependency injection: \\nprivate readonly DaprClient _daprCl\", \"ient; \\nprivate readonly ISpeedingViolationCalculator _speedingViolationCalculator; \\nprivate readonly\", \" string _roadId; \\n \\npublic VehicleActor( \\n    ActorHost host, DaprClient daprClient, \\n    ISpeedingV\", \"iolationCalculator speedingViolationCalculator) \\n    : base(host) \\n{ \\n    _daprClient = daprClient; \", \"\\n    _speedingViolationCalculator = speedingViolationCalculator; \\n    _roadId = _speedingViolationCa\", \"lculator.GetRoadId(); \\n} \\nThe actor based implementation no longer uses the Dapr state management bu\", \"ilding block directly. \\nInstead, the state is automatically persisted after each operation is execut\", \"ed. \\nSummary \\nThe Dapr actors building block makes it easier to write correct concurrent systems. Ac\", \"tors are small \\nunits of state and logic. They use a turn-based access model which saves you from ha\", \"ving to use \\nlocking mechanisms to write thread-safe code. Actors are created implicitly and are sil\", \"ently unloaded \\n \\n99 \\nCHAPTER 10 | The Dapr actors building block \\n \\nfrom memory when no operations \", \"are performed. Any state stored in the actor is automatically \\npersisted and loaded when the actor i\", \"s reactivated. Actor model implementations are typically created \\nfor a specific language or platfor\", \"m. With the Dapr actors building block however, you can leverage the \\nactor model from any language \", \"or platform. \\nActors support timers and reminders to schedule future work. Timers do not reset the i\", \"dle timer and \\nwill allow the actor to be deactivated when no other operations are performed. Remind\", \"ers do reset \\nthe idle timer and are also persisted automatically. Both timers and reminders respect\", \" the turn-based \\naccess model, making sure that no other operations can execute while the timer/remi\", \"nder events are \\nhandled. \\nActor state is persisted using the Dapr state management building block. \", \"Any state store that \\nsupports multi-item transactions can be used to store actor state. \\nReferences\", \" \\n\\u2022 \\nDapr supported state stores \\n \\n100 \\nCHAPTER 11 | The Dapr observability building block \\n \\nCHAPT\", \"ER 11 \\nThe Dapr observability \\nbuilding block \\nModern distributed systems are complex. You start wit\", \"h small, loosely coupled, independently \\ndeployable services. These services cross process and serve\", \"r boundaries. They then consume different \\nkinds of infrastructure backing services (databases, mess\", \"age brokers, key vaults). Finally, these \\ndisparate pieces compose together to form an application. \", \"\\nWith so many separate, moving parts, how do you make sense of what is going on? Unfortunately, \\nleg\", \"acy monitoring approaches from the past aren\\u2019t enough. Instead, the system must be observable \\nfrom \", \"end-to-end. Modern observability practices provide visibility and insight into the health of the \\nap\", \"plication at all times. They enable you to infer the internal state by observing the output. Not onl\", \"y is \\nobservability mandatory for monitoring and troubleshooting distributed applications, it needs \", \"to be \\nimplemented at the start. \\nThe system information used to gain observability is referred to a\", \"s telemetry. It can be divided into \\nfour broad categories: \\n1. \\nDistributed tracing provides insigh\", \"ts into the traffic between services involved in distributed \\nbusiness transactions. \\n2. \\nMetrics pr\", \"ovides insights into the performance of a service and its resource consumption. \\n3. \\nLogging provide\", \"s insights into how code is executing and if errors have occurred. \\n4. \\nHealth endpoints provide ins\", \"ight into the availability of a service. \\nThe depth of telemetry is determined by the observability \", \"features of an application platform. \\nConsider the Azure cloud. It provides a rich telemetry experie\", \"nce that includes all of the telemetry \\ncategories. With little configuration, Azure IaaS and PaaS s\", \"ervices will propagate and publish \\ntelemetry to the Azure Monitor and Azure Application Insights se\", \"rvices. Application Insights presents \\nsystem logging, tracing, and problem areas with highly visual\", \" dashboards. It can even render a \\ndiagram showing the dependencies between services based on their \", \"communication. \\nHowever, what if an application can\\u2019t use Azure PaaS and IaaS resources? Is it still\", \" possible to take \\nadvantage of the rich telemetry experience of Application Insights? The answer is\", \" yes. A non-Azure \\napplication can import libraries, add configuration, and instrument code to emit \", \"telemetry to Azure \\nApplication Insights. However, this approach tightly couples the application to \", \"Application Insights. \\nMoving the app to a different monitoring platform could involve expensive ref\", \"actoring. Wouldn\\u2019t it be \\ngreat to avoid tight coupling and consume observability outside of the cod\", \"e? \\nWith Dapr, you can. Let\\u2019s look at how Dapr can add observability to our distributed applications\", \". \\n \\n101 \\nCHAPTER 11 | The Dapr observability building block \\n \\nWhat it solves \\nThe Dapr observabili\", \"ty building block decouples observability from the application. It automatically \\ncaptures traffic g\", \"enerated by Dapr sidecars and Dapr system services that make up the Dapr control \\nplane. The block c\", \"orrelates traffic from a single operation that spans multiple services. It also exposes \\nperformance\", \" metrics, resource utilization, and the health of the system. Telemetry is published in \\nopen-standa\", \"rd formats enabling information to be fed into your monitoring back end of choice. \\nThere, the infor\", \"mation can be visualized, queried, and analyzed. \\nAs Dapr abstracts away the plumbing, the applicati\", \"on is unaware of how observability is implemented. \\nThere\\u2019s no need to reference libraries or implem\", \"ent custom instrumentation code. Dapr allows the \\ndeveloper to focus on building business logic inst\", \"ead of observability plumbing. Observability is \\nconfigured at the Dapr system level and is consiste\", \"nt across services, even when created by different \\nteams, and built with different technology stack\", \"s. \\nHow it works \\nDapr\\u2019s sidecar architecture enables built-in observability features. As services c\", \"ommunicate, Dapr \\nsidecars intercept the traffic and extract tracing, metrics, and logging informati\", \"on. Telemetry is \\npublished in an open standards format. By default, Dapr supports OpenTelemetry and\", \" Zipkin. \\nDapr provides collectors that can publish telemetry to different back-end monitoring tools\", \". These \\ntools present Dapr telemetry for analysis and querying. Figure 10-1 shows the Dapr observab\", \"ility \\narchitecture: \\n \\nFigure 10-1. Dapr observability architecture. \\n1. \\nService A calls an operat\", \"ion on Service B. The call is routed from a Dapr sidecar for Service A to a \\nsidecar for Service B. \", \"\\n2. \\nWhen Service B completes the operation, a response is sent back to Service A through the Dapr \\n\", \"sidecars. They gather and publish all available telemetry for every request and response. \\n3. \\nThe c\", \"onfigured collector ingests the telemetry and sends it to the monitoring back end. \\n \\n102 \\nCHAPTER 1\", \"1 | The Dapr observability building block \\n \\nAs a developer, keep in mind that adding observability \", \"is different from configuring other Dapr \\nbuilding blocks, like pub/sub or state management. Instead\", \" of referencing a building block, you add a \\ncollector and a monitoring back end. Figure 10-1 shows \", \"it\\u2019s possible to configure multiple collectors \\nthat integrate with different monitoring back ends. \", \"\\nAt the beginning of this chapter, four categories of telemetry were identified. The following secti\", \"ons \\nwill provide detail for each category. They\\u2019ll include instruction on how to configure collecto\", \"rs that \\nintegrate with popular monitoring back ends. \\nDistributed tracing \\nDistributed tracing prov\", \"ides insight into traffic that flows across services in a distributed application. \\nThe logs of exch\", \"anged request and response messages are a source of invaluable information for \\ntroubleshooting issu\", \"es. The hard part is correlating messages that belong to the same business \\ntransaction. \\nDapr uses \", \"the W3C Trace Context to correlate related messages. It injects the same context \\ninformation into r\", \"equests and responses that form a unique operation. Figure 10-2 shows how \\ncorrelation works: \\n \\nNot\", \"e \\nThe trace context is often referred to as a correlation token in microservice terminology. \\nFigur\", \"e 10-2. W3C Trace Context example. \\n1. \\nService A invokes an operation on Service B. As Service A st\", \"arts the call, Dapr creates a unique \\ntrace context and injects it into the request. \\n2. \\nService B \", \"receives the request and invokes an operation on Service C. Dapr detects that the \\nincoming request \", \"contains a trace context and propagates it by injecting it into the outgoing \\nrequest to Service C. \", \"\\n3. \\nService C receives the request and handles it. Dapr detects that the incoming request contains \", \"a \\ntrace context and propagates it by injecting it into the outgoing response back to Service B. \\n4.\", \" \\nService B receives the response and handles it. It then creates a new response and propagates \\nthe\", \" trace context by injecting it into the outgoing response back to Service A. \\nA set of requests and \", \"responses that belong together is called a trace. Figure 10-3 shows a trace: \\n \\n103 \\nCHAPTER 11 | Th\", \"e Dapr observability building block \\n \\n \\nFigure 10-3. Traces and spans. \\nIn the figure, note how the\", \" trace represents a unique application transaction that takes place across \\nmany services. A trace i\", \"s a collection of spans. Each span represents a single operation or unit of work \\ndone within the tr\", \"ace. Spans are the requests and responses that are sent between services that \\nimplement the unique \", \"transaction. \\nThe next sections discuss how to inspect tracing telemetry by publishing it to a monit\", \"oring back end. \\nUse a Zipkin monitoring back end \\nZipkin is an open-source distributed tracing syst\", \"em. It can ingest and visualize telemetry data. Dapr \\noffers default support for Zipkin. The followi\", \"ng example demonstrates how to configure Zipkin to \\nvisualize Dapr telemetry. \\nEnable and configure \", \"tracing \\nTo start, tracing must be enabled for the Dapr runtime using a Dapr configuration file. Her\", \"e\\u2019s an \\nexample of a configuration file named dapr-config.yaml that enables tracing: \\napiVersion: da\", \"pr.io/v1alpha1 \\nkind: Configuration \\nmetadata: \\n  name: dapr-config \\n  namespace: default \\nspec: \\n  \", \"tracing: \\n    samplingRate: \\\"1\\\" \\n    zipkin: \\n      endpointAddress: \\\"http://zipkin.default.svc.clus\", \"ter.local:9411/api/v2/spans\\\" \\nThe samplingRate attribute specifies the interval used for publishing \", \"traces. The value must be \\nbetween 0 (tracing disabled) and 1 (every trace is published). With a val\", \"ue of 0.5, for example, every \\nother trace is published, significantly reducing published traffic. T\", \"he endpointAddress points to an \\nendpoint on a Zipkin server running in a Kubernetes cluster. The de\", \"fault port for Zipkin is 9411. The \\nconfiguration must be applied to the Kubernetes cluster using th\", \"e Kubernetes CLI: \\nkubectl apply -f dapr-config.yaml \\n \\n104 \\nCHAPTER 11 | The Dapr observability bui\", \"lding block \\n \\nInstall the Zipkin server \\nWhen installing Dapr in self-hosted mode, a Zipkin server \", \"is automatically installed and tracing is \\nenabled in the default configuration file located in $HOM\", \"E/.dapr/config.yaml or \\n%USERPROFILE%\\\\.dapr\\\\config.yaml on Windows. \\nWhen installing Dapr on a Kuber\", \"netes cluster, Zipkin must be deployed manually. Use the following \\nKubernetes manifest file entitle\", \"d zipkin.yaml to deploy a standard Zipkin server to a Kubernetes \\ncluster: \\nkind: Deployment \\napiVer\", \"sion: apps/v1 \\nmetadata: \\n  name: zipkin \\n  namespace: dapr-trafficcontrol \\n  labels: \\n    service: \", \"zipkin \\nspec: \\n  replicas: 1 \\n  selector: \\n    matchLabels: \\n      service: zipkin \\n  template: \\n   \", \" metadata: \\n      labels: \\n        service: zipkin \\n    spec: \\n      containers: \\n        - name: zi\", \"pkin \\n          image: openzipkin/zipkin-slim \\n          imagePullPolicy: IfNotPresent \\n          po\", \"rts: \\n            - name: http \\n              containerPort: 9411 \\n              protocol: TCP \\n \\n--\", \"- \\n \\nkind: Service \\napiVersion: v1 \\nmetadata: \\n  name: zipkin \\n  namespace: dapr-trafficcontrol \\n  l\", \"abels: \\n    service: zipkin \\nspec: \\n  type: NodePort \\n  ports: \\n    - port: 9411 \\n      targetPort: \", \"9411 \\n      nodePort: 32411 \\n      protocol: TCP \\n      name: zipkin \\n  selector: \\n    service: zipk\", \"in \\nThe deployment uses the standard openzipkin/zipkin-slim container image. The Zipkin service \\nexp\", \"oses the Zipkin web front end, which you can use to view the telemetry on port 32411. Use the \\n \\n105\", \" \\nCHAPTER 11 | The Dapr observability building block \\n \\nKubernetes CLI to apply the Zipkin manifest \", \"file to the Kubernetes cluster and deploy the Zipkin \\nserver: \\nkubectl apply -f zipkin.yaml \\nConfigu\", \"re the services to use the tracing configuration \\nNow everything is set up correctly to start publis\", \"hing telemetry. Every Dapr sidecar that is deployed as \\npart of the application must be instructed t\", \"o emit telemetry when started. To do that, add a \\ndapr.io/config annotation that references the dapr\", \"-config configuration to the deployment of \\neach service. Here\\u2019s an example of the Traffic Control F\", \"ineCollection service\\u2019s manifest file containing \\nthe annotation: \\napiVersion: apps/v1 \\nkind: Deploy\", \"ment \\nmetadata: \\n  name: finecollectionservice \\n  namespace: dapr-trafficcontrol \\n  labels: \\n    app\", \": finecollectionservice \\nspec: \\n  replicas: 1 \\n  selector: \\n    matchLabels: \\n      app: finecollect\", \"ionservice \\n  template: \\n    metadata: \\n      labels: \\n        app: finecollectionservice \\n      ann\", \"otations: \\n        dapr.io/enabled: \\\"true\\\" \\n        dapr.io/app-id: \\\"finecollectionservice\\\" \\n       \", \" dapr.io/app-port: \\\"6001\\\" \\n        dapr.io/config: \\\"dapr-config\\\" \\n    spec: \\n      containers: \\n    \", \"  - name: finecollectionservice \\n        image: dapr-trafficcontrol/finecollectionservice:1.0 \\n     \", \"   ports: \\n        - containerPort: 6001 \\nInspect the telemetry in Zipkin \\nOnce the application is s\", \"tarted, the Dapr sidecars will emit telemetry to the Zipkin server. To inspect \\nthis telemetry, poin\", \"t a web-browser to http://localhost:32411. You\\u2019ll see the Zipkin web front end: \\n \\n106 \\nCHAPTER 11 |\", \" The Dapr observability building block \\n \\n \\nFigure 10-4. Zipkin front end. \\nOn the Find a trace tab,\", \" you can query traces. Pressing the RUN QUERY button without specifying any \\nrestrictions will show \", \"all the ingested traces: \\n \\nFigure 10-5. Zipkin traces overview. \\nClicking the SHOW button next to a\", \" specific trace, will show the details of that trace: \\n \\n107 \\nCHAPTER 11 | The Dapr observability bu\", \"ilding block \\n \\n \\nFigure 10-6. Zipkin trace details. \\nEach item on the details page, is a span that \", \"represents a request that is part of the selected trace. \\nInspect the dependencies between services \", \"\\nBecause Dapr sidecars handle traffic between services, Zipkin can use the trace information to \\ndet\", \"ermine the dependencies between the services. To see it in action, go to the Dependencies tab on \\nth\", \"e Zipkin web page and select the button with the magnifying glass. Zipkin will show an overview of \\n\", \"the services and their dependencies: \\n \\n108 \\nCHAPTER 11 | The Dapr observability building block \\n \\n \", \"\\nFigure 10-7. Zipkin dependencies. \\nThe animated dots on the lines between the services represent re\", \"quests and move from source to \\ndestination. Red dots indicate a failed request. \\nUse a Jaeger or Ne\", \"w Relic monitoring back end \\nBeyond Zipkin, other monitoring back-end software can also ingest telem\", \"etry with the Zipkin format. \\nJaeger is an open source tracing system created by Uber Technologies. \", \"It\\u2019s used to trace transactions \\nbetween distributed services and troubleshoot complex microservices\", \" environments. New Relic is a \\nfull-stack observability platform. It links relevant data from a dist\", \"ributed application to provide a \\ncomplete picture of your system. To try them out, specify an endpo\", \"intAddress pointing to either a \\nJaeger or New Relic server in the Dapr configuration file. Here\\u2019s a\", \"n example of a configuration file that \\nconfigures Dapr to send telemetry to a Jaeger server. The UR\", \"L for Jaeger is identical to the URL for the \\nZipkin. The only difference is the number of the port \", \"on which the server runs: \\n:::{custom-style=CodeBox} yaml  apiVersion: dapr.io/v1alpha1  kind: Confi\", \"guration  metadata:    name: \\ndapr-config    namespace: default  spec:    tracing:      samplingRate\", \": \\\"1\\\"      zipkin:        \\nendpointAddress: \\\"http://localhost:9415/api/v2/spans\\\" ::: \\nTo try out New\", \" Relic, specify the endpoint of the New Relic API. Here\\u2019s an example of a configuration \\nfile for Ne\", \"w Relic: \\n:::{custom-style=CodeBox} yaml apiVersion: dapr.io/v1alpha1  kind: Configuration  metadata\", \":    name: \\ndapr-config    namespace: default  spec:    tracing:      samplingRate: \\\"1\\\"      zipkin:\", \"        \\nendpointAddress: \\\"https://trace-api.newrelic.com/trace/v1?Api-Key=<NR-API-KEY>&Data-\\nFormat\", \"=zipkin&Data-Format-Version=2\\\" ::: \\n \\n109 \\nCHAPTER 11 | The Dapr observability building block \\n \\nChe\", \"ck out the Jaeger and New Relic websites for more information on how to use them. \\nMetrics \\nMetrics \", \"provide insight into performance and resource consumption. Under the hood, Dapr emits a \\nwide collec\", \"tion of system and runtime metrics. Dapr uses Prometheus as a metric standard. Dapr \\nsidecars and sy\", \"stem services, expose a metrics endpoint on port 9090. A Prometheus scraper calls this \\nendpoint at \", \"a predefined interval to collect metrics. The scraper sends metric values to a monitoring \\nback end.\", \" Figure 10-8 shows the scraping process: \\n \\nFigure 10-8. Scraping Prometheus metrics. \\nEach sidecar \", \"and system service exposes a metric endpoint that listens on port 9090. The Prometheus \\nMetrics Scra\", \"pper captures metrics from each endpoint and published the information to the \\nmonitoring back end. \", \"\\nService discovery \\nYou might wonder how the metrics scraper knows where to collect metrics. Prometh\", \"eus can integrate \\nwith discovery mechanisms built into target deployment environments. For example,\", \" when running in \\nKubernetes, Prometheus can integrate with the Kubernetes API to find all available\", \" Kubernetes \\nresources running in the environment. \\nMetrics list \\nDapr generates a large set of metr\", \"ics for Dapr system services and its runtime. Some examples \\ninclude: \\n \\n110 \\nCHAPTER 11 | The Dapr \", \"observability building block \\n \\nMetric \\nSource \\nDescription \\ndapr_operator_service_created_total \\nSy\", \"stem \\nThe total number of Dapr services created \\nby the Dapr Operator service. \\ndapr_injector_sideca\", \"r_injection/requests_total \\nSystem \\nThe total number of sidecar injection \\nrequests received by the \", \"Dapr Sidecar-\\nInjector service. \\ndapr_placement_runtimes_total \\nSystem \\nThe total number of hosts re\", \"ported to the \\nDapr Placement service. \\ndapr_sentry_cert_sign_request_received_total \\nSystem \\nThe nu\", \"mber of certificate signing requests \\n(CRSs) received by the Dapr Sentry service. \\ndapr_runtime_comp\", \"onent_loaded \\nRuntime \\nThe number of successfully loaded Dapr \\ncomponents. \\ndapr_grpc_io_server_comp\", \"leted_rpcs \\nRuntime \\nCount of gRPC calls by method and status. \\ndapr_http_server_request_count \\nRunt\", \"ime \\nNumber of HTTP requests started in an \\nHTTP server. \\ndapr_http/client/sent_bytes \\nRuntime \\nTota\", \"l bytes sent in request body (not \\nincluding headers) by an HTTP client. \\nFor more information on av\", \"ailable metrics, see the Dapr metrics documentation. \\nConfigure Dapr metrics \\nAt run time, you can d\", \"isable the metrics collection endpoint by including the --enable-\\nmetrics=false argument in the Dapr\", \" command. Or, you can also change the default port for the \\nendpoint with the --metrics-port 9090 ar\", \"gument. \\nYou can also use a Dapr configuration file to statically enable or disable runtime metrics \", \"collection: \\napiVersion: dapr.io/v1alpha1 \\nkind: Configuration \\nmetadata: \\n  name: dapr-config \\n  na\", \"mespace: dapr-trafficcontrol \\nspec: \\n  tracing: \\n    samplingRate: \\\"1\\\" \\n  metric: \\n    enabled: fals\", \"e \\nVisualize Dapr metrics \\nWith the Prometheus scraper collecting and publishing metrics into the mo\", \"nitoring back end, how do \\nyou make sense of the raw data? A popular visualization tool for analyzin\", \"g metrics is Grafana. With \\nGrafana, you can create dashboards from the available metrics. Here\\u2019s an\", \" example of a dashboard \\ndisplaying Dapr system services metrics: \\n \\n111 \\nCHAPTER 11 | The Dapr obse\", \"rvability building block \\n \\n \\nFigure 10-9. Grafana dashboard. \\nThe Dapr documentation includes a tut\", \"orial for installing Prometheus and Grafana. \\nLogging \\nLogging provides insight into what is happeni\", \"ng with a service at run time. When running an \\napplication, Dapr automatically emits log entries fr\", \"om Dapr sidecars and Dapr system services. \\nHowever, logging entries instrumented in your applicatio\", \"n code aren\\u2019t automatically included. To \\nemit logging from application code, you can import a speci\", \"fic SDK like OpenTelemetry SDK for .NET. \\nLogging application code is covered later in this chapter \", \"in the section Using the Dapr .NET SDK. \\nLog entry structure \\nDapr emits structured logging. Each lo\", \"g entry has the following format: \\nField \\nDescription \\nExample \\ntime \\nISO8601 formatted timestamp \\n2\", \"021-01-10T14:19:31.000Z \\nlevel \\nLevel of the entry (debug, info, warn, or error) \\ninfo \\ntype \\nLog Ty\", \"pe \\nlog \\nmsg \\nLog Message \\nmetrics server started on :62408/ \\nscope \\nLogging Scope \\ndapr.runtime \\nin\", \"stance \\nHostname where Dapr runs \\nTSTSRV01 \\n \\n112 \\nCHAPTER 11 | The Dapr observability building bloc\", \"k \\n \\nField \\nDescription \\nExample \\napp_id \\nDapr App ID \\nfinecollectionservice \\nver \\nDapr Runtime Vers\", \"ion \\n1.0 \\nWhen searching through logging entries in a troubleshooting scenario, the time and level f\", \"ields are \\nespecially helpful. The time field orders log entries so that you can pinpoint specific t\", \"ime periods. \\nWhen troubleshooting, log entries at the debug level provide more information on the b\", \"ehavior of the \\ncode. \\nPlain text versus JSON format \\nBy default, Dapr emits structured logging in p\", \"lain-text format. Every log entry is formatted as a string \\ncontaining key/value pairs. Here\\u2019s an ex\", \"ample of logging in plain text: \\n== DAPR == time=\\\"2021-01-12T16:11:39.4669323+01:00\\\" level=info msg=\", \"\\\"starting Dapr Runtime -\\n- version 1.0 -- commit 196483d\\\" app_id=finecollectionservice instance=TSTS\", \"RV03 \\nscope=dapr.runtime type=log ver=1.0 \\n== DAPR == time=\\\"2021-01-12T16:11:39.467933+01:00\\\" level=\", \"info msg=\\\"log level set to: info\\\" \\napp_id=finecollectionservice instance=TSTSRV03 scope=dapr.runtime\", \" type=log ver=1.0 \\n== DAPR == time=\\\"2021-01-12T16:11:39.467933+01:00\\\" level=info msg=\\\"metrics server\", \" started \\non :62408/\\\" app_id=finecollectionservice instance=TSTSRV03 scope=dapr.metrics type=log \\nve\", \"r=1.0 \\nWhile simple, this format is difficult to parse. If viewing log entries with a monitoring too\", \"l, you\\u2019ll want \\nto enable JSON formatted logging. With JSON entries, a monitoring tool can index and\", \" query \\nindividual fields. Here\\u2019s the same log entries in JSON format: \\n{\\\"app_id\\\": \\\"finecollectionse\", \"rvice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \\n\\\"starting Dapr Runtime -- version 1.0 -- co\", \"mmit 196483d\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"time\\\": \\n\\\"2021-01-12T16:11:39.4669323+01:00\\\", \\\"type\\\": \\\"log\\\",\", \" \\\"ver\\\": \\\"1.0\\\"} \\n{\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"info\\\", \\\"msg\\\": \", \"\\\"log \\nlevel set to: info\\\", \\\"scope\\\": \\\"dapr.runtime\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"2021-01-\\n12T16:11:39.467\", \"933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"} \\n{\\\"app_id\\\": \\\"finecollectionservice\\\", \\\"instance\\\": \\\"TSTSRV03\\\", \\\"level\\\": \\\"inf\", \"o\\\", \\\"msg\\\": \\n\\\"metrics server started on :62408/\\\", \\\"scope\\\": \\\"dapr.metrics\\\", \\\"type\\\": \\\"log\\\", \\\"time\\\": \\\"20\", \"21-\\n01-12T16:11:39.467933+01:00\\\", \\\"ver\\\": \\\"1.0\\\"} \\nTo enable JSON formatting, you need to configure ea\", \"ch Dapr sidecar. In self-hosted mode, you can \\nspecify the flag --log-as-json on the command line: \\n\", \"dapr run --app-id finecollectionservice --log-level info --log-as-json dotnet run \\nIn Kubernetes, yo\", \"u can add a dapr.io/log-as-json annotation to each deployment for the \\napplication: \\nannotations: \\n \", \"  dapr.io/enabled: \\\"true\\\" \\n   dapr.io/app-id: \\\"finecollectionservice\\\" \\n   dapr.io/app-port: \\\"80\\\" \\n  \", \" dapr.io/config: \\\"dapr-config\\\" \\n   dapr.io/log-as-json: \\\"true\\\" \\nWhen you install Dapr in a Kubernete\", \"s cluster using Helm, you can enable JSON formatted logging for \\nall the Dapr system services: \\n \\n11\", \"3 \\nCHAPTER 11 | The Dapr observability building block \\n \\nhelm repo add dapr https://dapr.github.io/h\", \"elm-charts/ \\nhelm repo update \\nkubectl create namespace dapr-system \\nhelm install dapr dapr/dapr --n\", \"amespace dapr-system --set global.logAsJson=true \\nCollect logs \\nThe logs emitted by Dapr can be fed \", \"into a monitoring back end for analysis. A log collector is a \\ncomponent that collects logs from a s\", \"ystem and sends them to a monitoring back end. A popular log \\ncollector is Fluentd. Check out the Ho\", \"w-To: Set up Fluentd, Elastic search and Kibana in Kubernetes in \\nthe Dapr documentation. This artic\", \"le contains instructions for setting up Fluentd as log collector and \\nthe ELK Stack (Elastic Search \", \"and Kibana) as a monitoring back end. \\nHealth status \\nThe health status of a service provides insigh\", \"t into its availability. Each Dapr sidecar exposes a health \\nAPI that can be used by the hosting env\", \"ironment to determine the health of the sidecar. The API has \\none operation: \\nGET http://localhost:3\", \"500/v1.0/healthz \\nThe operation returns two HTTP status codes: \\n\\u2022 \\n204: When the sidecar is healthy \", \"\\n\\u2022 \\n500: when the sidecar isn\\u2019t healthy \\nWhen running in self-hosted mode, the health API isn\\u2019t auto\", \"matically invoked. You can invoke the API \\nthough from application code or a health monitoring tool.\", \" \\nWhen running in Kubernetes, the Dapr sidecar-injector automatically configures Kubernetes to use t\", \"he \\nhealth API for executing liveness probes and readiness probes. \\nKubernetes uses liveness probes \", \"to determine whether a container is up and running. If a liveness \\nprobe returns a failure code, Kub\", \"ernetes will assume the container is dead and automatically restart it. \\nThis feature increases the \", \"overall availability of your application. \\nKubernetes uses readiness probes to determine whether a c\", \"ontainer is ready to start accepting traffic. \\nA pod is considered ready when all of its containers \", \"are ready. Readiness determines whether a \\nKubernetes service can direct traffic to a pod in a load-\", \"balancing scenario. Pods that aren\\u2019t ready are \\nautomatically removed from the load-balancer. \\nLiven\", \"ess and readiness probes have several configurable parameters. Both are configured in the \\ncontainer\", \" spec section of a pod\\u2019s manifest file. By default, Dapr uses the following configuration for \\neach \", \"sidecar container: \\nlivenessProbe: \\n      httpGet: \\n        path: v1.0/healthz \\n        port: 3500 \\n\", \"      initialDelaySeconds: 5 \\n      periodSeconds: 10 \\n      timeoutSeconds : 5 \\n      failureThresh\", \"old : 3 \\n \\n114 \\nCHAPTER 11 | The Dapr observability building block \\n \\nreadinessProbe: \\n      httpGet\", \": \\n        path: v1.0/healthz \\n        port: 3500 \\n      initialDelaySeconds: 5 \\n      periodSeconds\", \": 10 \\n      timeoutSeconds : 5 \\n      failureThreshold: 3 \\nThe following parameters are available fo\", \"r the probes: \\n\\u2022 \\nThe path specifies the Dapr health API endpoint. \\n\\u2022 \\nThe port specifies the Dapr h\", \"ealth API port. \\n\\u2022 \\nThe initialDelaySecondsspecifies the number of seconds Kubernetes will wait befo\", \"re it starts \\nprobing a container for the first time. \\n\\u2022 \\nThe periodSeconds specifies the number of \", \"seconds Kubernetes will wait between each probe. \\n\\u2022 \\nThe timeoutSeconds specifies the number of seco\", \"nds Kubernetes will wait on a response from \\nthe API before timing out. A timeout is interpreted as \", \"a failure. \\n\\u2022 \\nThe failureThresholdspecifies the number of failed status code Kubernetes will accept\", \" before \\nconsidering the container not alive or not ready. \\nDapr dashboard \\nDapr offers a dashboard \", \"that presents status information on Dapr applications, components, and \\nconfigurations. Use the Dapr\", \" CLI to start the dashboard as a web-application on the local machine on \\nport 8080: \\ndapr dashboard\", \" \\nFor Dapr application running in Kubernetes, use the following command: \\ndapr dashboard -k \\nThe das\", \"hboard opens with an overview of all services in your application that have a Dapr sidecar. The \\nfol\", \"lowing screenshot shows the Dapr dashboard for the Traffic Control sample application running in \\nKu\", \"bernetes: \\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/observability/dapr-dashboard-overview.png\\u201d alt-te\", \"xt=\\u201cDapr \\ndashboard overview\\u201d::: \\nFigure 10-10. Dapr dashboard overview. \\nThe Dapr dashboard is inva\", \"luable when troubleshooting a Dapr application. It provides information \\nabout Dapr sidecars and sys\", \"tem services. You can drill down into the configuration of each service, \\nincluding the logging entr\", \"ies. \\nThe dashboard also shows the configured components (and their configuration) for an applicatio\", \"n: \\n:::image type=\\u201ccontent\\u201d source=\\u201c./media/observability/dapr-dashboard-components.png\\u201d alt-\\ntext=\\u201c\", \"Dapr dashboard components\\u201d::: \\nFigure 10-11. Dapr dashboard components. \\n \\n115 \\nCHAPTER 11 | The Dap\", \"r observability building block \\n \\nThere\\u2019s a large amount of information available through the dashbo\", \"ard. You can discover it by \\nrunning a Dapr application and browsing the dashboard. \\nCheck out the D\", \"apr dashboard CLI command reference in the Dapr docs for more information on the \\nDapr dashboard com\", \"mands. \\nUse the Dapr .NET SDK \\nThe Dapr .NET SDK doesn\\u2019t contain any specific observability features\", \". All observability features are \\noffered at the Dapr level. \\nIf you want to emit telemetry from you\", \"r .NET application code, you should consider the \\nOpenTelemetry SDK for .NET. The Open Telemetry pro\", \"ject is cross-platform, open source, and vendor \\nagnostic. It provides an end-to-end implementation \", \"to generate, emit, collect, process, and export \\ntelemetry data. There\\u2019s a single instrumentation li\", \"brary per language that supports automatic and \\nmanual instrumentation. Telemetry is published using\", \" the Open Telemetry standard. The project has \\nbroad industry support and adoption from cloud provid\", \"ers, vendors, and end users. \\nSample application: Dapr Traffic Control \\nBecause the Traffic Control \", \"sample application runs with Dapr, all the telemetry described in this \\nchapter is available. If you\", \" run the application and open the Zipkin web front end, you\\u2019ll see end-to-\\nend tracing. Figure 10-12\", \" shows an example: \\n \\nFigure 10-12. Zipkin end-to-end tracing example. \\nThis trace shows the communi\", \"cation that occurs when a speeding violation has been detected: \\n \\n116 \\nCHAPTER 11 | The Dapr observ\", \"ability building block \\n \\n1. \\nAn exiting vehicle triggers the MQTT input binding that sends a messag\", \"e containing the vehicle \\nlicense number, lane, and timestamp. \\n2. \\nThe MQTT input binding invokes t\", \"he TrafficControl service with the message. \\n3. \\nThe TrafficControl service retrieves the state for \", \"the vehicle, appends the entry, and saves the \\nupdated vehicle state back to the state store. \\n4. \\nT\", \"he TrafficControl service publishes the speeding violation using pub/sub to the \\nspeedingviolations \", \"topic. \\n5. \\nThe FineCollection service receives the speeding violation using a pub/sub subscription \", \"on the \\nspeedingviolations topic. \\n6. \\nThe FineCollection service invokes the vehicleinfo endpoint o\", \"f the VehicleRegistration service \\nusing service invocation. \\n7. \\nThe FineCollection service invokes\", \" an output binding for sending the email. \\nClick any trace line (span) to see more details. If you c\", \"lick on the last line, you\\u2019ll see the sendmail \\nbinding component invoked to send the driver a viola\", \"tion notice. \\n \\n117 \\nCHAPTER 11 | The Dapr observability building block \\n \\n \\nFigure 10-13. Output bi\", \"nding trace details. \\nSummary \\nDetailed observability is critical to running a distributed system in\", \" production. \\nDapr provides different types of telemetry, including distributed tracing, logging, me\", \"trics, and health \\nstatus. \\nDapr only produces telemetry for the Dapr system services and sidecars. \", \"Telemetry from your \\napplication code isn\\u2019t automatically included. You can however use a specific S\", \"DK like the \\nOpenTelemetry SDK for .NET to emit telemetry from your application code. \\n \\n118 \\nCHAPTE\", \"R 11 | The Dapr observability building block \\n \\nDapr telemetry is produced in an open-standards base\", \"d format so that it can be ingested by a large \\nset of available monitoring tools. Examples include \", \"Zipkin, Azure Application Insights, the ELK Stack, \\nNew Relic, and Grafana. See Monitor your applica\", \"tion with Dapr in the Dapr documentation for \\ntutorials on how to monitor your Dapr applications wit\", \"h specific monitoring back ends. \\nYou\\u2019ll need a telemetry scraper that ingests telemetry and publish\", \"es it to the monitoring back end. \\nDapr can be configured to emit structured logging. Structured log\", \"ging is favored as it can be indexed \\nby back-end monitoring tools. Indexed logging enables users to\", \" execute rich queries when searching \\nthrough the logging. \\nDapr offers a dashboard that presents in\", \"formation about the Dapr services and configuration. \\nReferences \\n\\u2022 \\nAzure Application Insights \\n\\u2022 \\n\", \"Open Telemetry \\n\\u2022 \\nZipkin \\n\\u2022 \\nW3C Trace Context \\n\\u2022 \\nJaeger \\n\\u2022 \\nNew Relic \\n\\u2022 \\nPrometheus \\n\\u2022 \\nGrafana \", \"\\n\\u2022 \\nOpen Telemetry SDK for .NET \\n\\u2022 \\nFluentd \\n\\u2022 \\nELK stack \\n\\u2022 \\nSeq \\n\\u2022 \\nSerilog \\n \\n119 \\nCHAPTER 12 | T\", \"he Dapr secrets management building block \\n \\nCHAPTER 12 \\nThe Dapr secrets \\nmanagement building \\nbloc\", \"k \\nEnterprise applications require secrets. Common examples include: \\n\\u2022 \\nA database connection strin\", \"g that contains a username and password. \\n\\u2022 \\nAn API key for calling an external web API. \\n\\u2022 \\nA clien\", \"t certificate for authenticating to an external system. \\nSecrets must be carefully managed so that t\", \"hey\\u2019re never disclosed outside of the application. \\nNot long ago, it was popular to store applicatio\", \"n secrets in a configuration file inside the application \\ncodebase. .NET developers will fondly reca\", \"ll the web.config file. While simple to implement, integrating \\nsecrets to along with code was far f\", \"rom secure. A common misstep was to include the file when \\npushing to a public GIT repository, expos\", \"ing the secrets to the world. \\nA widely accepted methodology for constructing modern distributed app\", \"lications is The Twelve-\\nFactor App. It describes a set of principles and best practices. Its third \", \"factor prescribes that \\nconfiguration and secrets be externalized outside of the code base. \\nTo addr\", \"ess this concern, the .NET platform includes a Secret Manager feature that stores sensitive \\ndata in\", \" a physical folder outside of the project tree. While secrets are outside of source control, this \\nf\", \"eature doesn\\u2019t encrypt data. It\\u2019s designed for development purposes only. \\nA more modern and secure \", \"practice is to isolate secrets in a secrets management tool like Hashicorp \\nVault or Azure Key Vault\", \". These tools enable you to store secrets externally, vary credentials across \\nenvironments, and ref\", \"erence them from application code. However, each tool has its complexities and \\nlearning curve. \\nDap\", \"r offers a building block that simplifies managing secrets. \\nWhat it solves \\nThe Dapr secrets manage\", \"ment building block abstracts away the complexity of working with secrets \\nand secret management too\", \"ls. \\n \\n120 \\nCHAPTER 12 | The Dapr secrets management building block \\n \\n\\u2022 \\nIt hides the underlying pl\", \"umbing through a unified interface. \\n\\u2022 \\nIt supports various pluggable secret store components, which\", \" can vary between development \\nand production. \\n\\u2022 \\nApplications don\\u2019t require direct dependencies on\", \" secret store libraries. \\n\\u2022 \\nDevelopers don\\u2019t require detailed knowledge of each secret store. \\nDapr\", \" handles all of the above concerns. \\nAccess to the secrets is secured through authentication and aut\", \"horization. Only an application with \\nsufficient rights can access secrets. Applications running in \", \"Kubernetes can also use its built-in secrets \\nmanagement mechanism. \\nHow it works \\nApplications use \", \"the secrets management building block in two ways: \\n\\u2022 \\nRetrieve a secret directly from the building \", \"block. \\n\\u2022 \\nReference a secret indirectly from a Dapr component configuration. \\nRetrieving secrets di\", \"rectly is covered first. Referencing a secret from a Dapr component configuration \\nfile is addressed\", \" in a later section. \\nThe application interacts with a Dapr sidecar when using the secrets managemen\", \"t building block. The \\nsidecar exposes the secrets API. The API can be called with either HTTP or gR\", \"PC. Use the following \\nURL to call the HTTP API: \\nhttp://localhost:<dapr-port>/v1.0/secrets/<store-n\", \"ame>/<name>?<metadata> \\nThe URL contains the following segments: \\n\\u2022 \\n<dapr-port> specifies the port \", \"number upon which the Dapr sidecar is listening. \\n\\u2022 \\n<store-name> specifies the name of the Dapr sec\", \"ret store. \\n\\u2022 \\n<name> specifies the name of the secret to retrieve. \\n\\u2022 \\n<metadata> provides addition\", \"al information for the secret. This segment is optional and \\nmetadata properties differ per secret s\", \"tore. For more information on metadata properties, see \\nthe [secrets API reference]INTERNAL-LINK:(Se\", \"crets API reference | Dapr Docs). \\n[!NOTE] The above URL represents the native Dapr API call availab\", \"le to any development platform that \\nsupports HTTP or gRPC. Popular platforms like .NET, Java, and G\", \"o have their own custom APIs. \\nThe JSON response contains the key and value of the secret. \\nFigure 1\", \"1-1 shows how Dapr handles a request for the secrets API: \\n \\n121 \\nCHAPTER 12 | The Dapr secrets mana\", \"gement building block \\n \\n \\nFigure 11-1. Retrieving a secret with the Dapr secrets API. \\n1. \\nThe serv\", \"ice calls the Dapr secrets API, along with the name of the secret store, and secret to \\nretrieve. \\n2\", \". \\nThe Dapr sidecar retrieves the specified secret from the secret store. \\n3. \\nThe Dapr sidecar retu\", \"rns the secret information back to the service. \\nSome secret stores support storing multiple key/val\", \"ue pairs in a single secret. For those scenarios, the \\nresponse would contain multiple key/value pai\", \"rs in a single JSON response as in the following \\nexample: \\nGET http://localhost:3500/v1.0/secrets/s\", \"ecret-store/interestRates?metadata.version_id=3 \\n \\n \\n{ \\n  \\\"tier1-percentage\\\": \\\"2.5\\\", \\n  \\\"tier2-perce\", \"ntage\\\": \\\"3.8\\\", \\n  \\\"tier3-percentage\\\": \\\"5.1\\\" \\n} \\nThe Dapr secrets API also offers an operation to ret\", \"rieve all the secrets the application has access to: \\nhttp://localhost:<dapr-port>/v1.0/secrets/<sto\", \"re-name>/bulk \\nUse the Dapr .NET SDK \\nFor .NET developers, the Dapr .NET SDK streamlines Dapr secret\", \" management. Consider the \\nDaprClient.GetSecretAsync method. It enables you to retrieve a secret dir\", \"ectly from any Dapr secret \\nstore with minimal effort. Here\\u2019s an example of fetching a connection st\", \"ring secret for a SQL Server \\ndatabase: \\n \\n122 \\nCHAPTER 12 | The Dapr secrets management building bl\", \"ock \\n \\nvar metadata = new Dictionary<string, string> { [\\\"version_id\\\"] = \\\"3\\\" }; \\nDictionary<string, s\", \"tring> secrets = await daprClient.GetSecretAsync(\\\"secret-store\\\", \\n\\\"eshopsecrets\\\", metadata); \\nstring\", \" connectionString = secrets[\\\"customerdb\\\"]; \\nArguments for the GetSecretAsync method include: \\n\\u2022 \\nThe\", \" name of the Dapr secret store component (\\u2018secret-store\\u2019) \\n\\u2022 \\nThe secret to retrieve (\\u2018eshopsecrets\\u2019\", \") \\n\\u2022 \\nOptional metadata key/value pairs (\\u2018version_id=3\\u2019) \\nThe method responds with a dictionary obje\", \"ct as a secret can contain multiple key/value pairs. In the \\nexample above, the secret named custome\", \"rdb is referenced from the collection to return a connection \\nstring. \\nThe Dapr .NET SDK also featur\", \"es a .NET configuration provider. It loads specified secrets into the \\nunderlying .NET configuration\", \" API. The running application can then reference secrets from the \\nIConfiguration dictionary that is\", \" registered in ASP.NET Core dependency injection. \\nThe secrets configuration provider is available f\", \"rom the Dapr.Extensions.Configuration NuGet \\npackage. The provider can be registered in the Program.\", \"cs of an ASP.NET Web API application: \\nvar builder = WebApplication.CreateBuilder(args); \\nbuilder.We\", \"bHost.ConfigureAppConfiguration(config => \\n{ \\n    var daprClient = new DaprClientBuilder().Build(); \", \"\\n    var secretDescriptors = new List<DaprSecretDescriptor> \\n    { \\n        new DaprSecretDescriptor\", \"(\\\"eshopsecrets\\\") \\n    }; \\n    config.AddDaprSecretStore(\\\"secret-store\\\", secretDescriptors, daprClien\", \"t); \\n}); \\nThe above example loads the eshopsecrets secrets collection into the .NET configuration sy\", \"stem at \\nstartup. Registering the provider requires an instance of DaprClient to invoke the secrets \", \"API on the \\nDapr sidecar. The other arguments include the name of the secret store and a DaprSecretD\", \"escriptor \\nobject with the name of the secret. \\nOnce loaded, you can retrieve secrets directly from \", \"application code: \\npublic void GetCustomer(IConfiguration config) \\n{ \\n    var connectionString = con\", \"fig[\\\"eshopsecrets\\\"][\\\"customerdb\\\"]; \\n} \\nSecret store components \\nThe secrets management building bloc\", \"k supports several secret store components. At the time of \\nwriting, the following secret stores are\", \" available: \\n\\u2022 \\nAlibabaCloud OOS Parameter Store \\n\\u2022 \\nAWS Secrets Manager \\n\\u2022 \\nAWS SSM Parameter Store\", \" \\n \\n123 \\nCHAPTER 12 | The Dapr secrets management building block \\n \\n\\u2022 \\nAzure Key Vault \\n\\u2022 \\nGCP Secre\", \"t Manager \\n\\u2022 \\nHashiCorp Vault \\n\\u2022 \\nKubernetes secrets \\n\\u2022 \\nLocal environment variables \\n\\u2022 \\nLocal file \", \"\\nImportant \\nThe local environment variables and file components are designed for development workloa\", \"ds only. \\nThe following sections show how to configure a secret store. \\nConfiguration \\nYou configure\", \" a secret store using a Dapr component configuration file. The typical structure of the \\nfile is sho\", \"wn below: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: [component name] \\n  nam\", \"espace: [namespace] \\nspec: \\n  type: secretstores.[secret store type] \\n  version: [secret store versi\", \"on] \\n  metadata: \\n  - name: [property name] \\n    value: [property value] \\nAll Dapr component configu\", \"ration files require a name along with an optional namespace value. \\nAdditionally, the type field in\", \" the spec section specifies the type of secret store component. The \\nproperties in the metadata sect\", \"ion differ per secret store. \\nIndirectly consume Dapr secrets \\nAs mentioned earlier in this chapter,\", \" applications can also consume secrets by referencing them in \\ncomponent configuration files. Consid\", \"er a state management component that uses Redis cache for \\nstoring state: \\napiVersion: dapr.io/v1alp\", \"ha1 \\nkind: Component \\nmetadata: \\n  name: eshop-basket-statestore \\n  namespace: eshop \\nspec: \\n  type:\", \" state.redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    value: localhost:6379 \\n  - name: \", \"redisPassword \\n    value: e$h0p0nD@pr \\n \\n124 \\nCHAPTER 12 | The Dapr secrets management building bloc\", \"k \\n \\nThe above configuration file contains a clear-text password for connecting to the Redis server.\", \" \\nHardcoded passwords are always a bad idea. Pushing this configuration file to a public repository \", \"\\nwould expose the password. Storing the password in a secret store would dramatically improve this \\n\", \"scenario. \\nThe following examples demonstrate this using several different secret stores. \\nLocal fil\", \"e \\nThe local file component is designed for development scenarios. It stores secrets on the local \\nf\", \"ilesystem inside a JSON file. Here\\u2019s an example named eshop-secrets.json. It contains a single \\nsecr\", \"et - a password for Redis: \\n{ \\n  \\\"eShopRedisPassword\\\": \\\"e$h0p0nD@pr\\\" \\n} \\nYou place this file in a co\", \"mponents folder that you specify when running the Dapr application. \\nThe following secret store conf\", \"iguration file consumes the JSON file as a secret store. It\\u2019s also placed \\nin the components folder:\", \" \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: eshop-local-secret-store \\n  name\", \"space: eshop \\nspec: \\n  type: secretstores.local.file \\n  version: v1 \\n  metadata: \\n  - name: secretsF\", \"ile \\n    value: ./components/eshop-secrets.json \\n  - name: nestedSeparator \\n    value: \\\":\\\" \\nThe comp\", \"onent type is secretstore.local.file. The secretsFile metadata element specifies the \\npath to the se\", \"crets file. \\nImportant \\nThe path to a secrets file can be a absolute or relative path. The relative \", \"path is based on the folder in \\nwhich the application starts. In the example, the components folder \", \"is a sub-folder of the directory that \\ncontains the .NET application. \\nFrom the application folder, \", \"start the Dapr application specifying the components path as a command-\\nline argument: \\ndapr run --a\", \"pp-id basket-api --components-path ./components dotnet run \\n \\n \\n \\n125 \\nCHAPTER 12 | The Dapr secrets\", \" management building block \\n \\nNote \\nThis above example applies to running Dapr in self-hosted mode. \", \"For Kubernetes hosting, consider \\nusing volume mounts. \\nThe nestedSeparator in a Dapr configuration \", \"file specifies a character to flatten a JSON hierarchy. \\nConsider the following snippet: \\n{ \\n    \\\"re\", \"disPassword\\\": \\\"some password\\\", \\n    \\\"connectionStrings\\\": { \\n        \\\"customerdb\\\": \\\"some connection s\", \"tring\\\", \\n        \\\"productdb\\\": \\\"some connection string\\\" \\n    } \\n} \\nUsing a colon as a separator, you \", \"can retrieve the customerdb connection-string using the key \\nconnectionStrings:customerdb. \\nNote \\nTh\", \"e colon : is the default separator value. \\nIn the next example, a state management configuration fil\", \"e references the local secret store \\ncomponent to obtain the password for connecting to the Redis se\", \"rver: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: eshop-basket-statestore \\n  \", \"namespace: eshop \\nspec: \\n  type: state.redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    v\", \"alue: localhost:6379 \\n  - name: redisPassword \\n    secretKeyRef: \\n      name: eShopRedisPassword \\n  \", \"    key: eShopRedisPassword \\nauth: \\n  secretStore: eshop-local-secret-store \\nThe secretKeyRef elemen\", \"t references the secret containing the password. It replaces the earlier clear-\\ntext value. The secr\", \"et name and the key name, eShopRedisPassword, reference the secret. The name \\nof the secret manageme\", \"nt component eshop-local-secret-store is found in the auth metadata \\nelement. \\nYou might wonder why \", \"eShopRedisPassword is identical for both the name and key in the secret \\nreference. In the local fil\", \"e secret store, secrets aren\\u2019t identified with a separate name. The scenario will \\nbe different in t\", \"he next example using Kubernetes secrets. \\n \\n126 \\nCHAPTER 12 | The Dapr secrets management building \", \"block \\n \\nKubernetes secret \\nThis second example focuses on a Dapr application running in Kubernetes.\", \" It uses the standard secrets \\nmechanism that Kubernetes offers. Use the Kubernetes CLI (kubectl) to\", \" create a secret named eshop-\\nredis-secret that contains the password: \\nkubectl create secret generi\", \"c eshopsecrets --from-literal=redisPassword=e$h0p0nD@pr -n \\neshop \\nOnce created, you can reference t\", \"he secret in the component configuration file for state management: \\napiVersion: dapr.io/v1alpha1 \\nk\", \"ind: Component \\nmetadata: \\n  name: eshop-basket-statestore \\n  namespace: eshop \\nspec: \\n  type: state\", \".redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    value: redis:6379 \\n  - name: redisPassw\", \"ord \\n    secretKeyRef: \\n      name: eshopsecrets \\n      key: redisPassword \\nauth: \\n  secretStore: ku\", \"bernetes \\nThe secretKeyRef element specifies the name of the Kubernetes secret and the secret\\u2019s key,\", \" \\neshopsecrets, and redisPassword respectively. The auth metadata section instructs Dapr to use the \", \"\\nKubernetes secrets management component. \\nNote \\nAuth is the default value when using Kubernetes sec\", \"rets and can be omitted. \\nIn a production setting, secrets are typically created as part of an autom\", \"ated CI/CD pipeline. Doing so \\nensures only people with sufficient permissions can access and change\", \" the secrets. Developers create \\nconfiguration files without knowing the actual value of the secrets\", \". \\nAzure Key Vault \\nThe next example is geared toward a real-world production scenario. It uses Azur\", \"e Key Vault as the \\nsecret store. Azure Key Vault is a managed Azure service that enables secrets to\", \" be stored securely in \\nthe cloud. \\nFor this example to work, the following prerequisites must be sa\", \"tisfied: \\n\\u2022 \\nYou\\u2019ve secured administrative access to an Azure subscription. \\n\\u2022 \\nYou\\u2019ve provisioned a\", \"n Azure Key Vault named eshopkv that holds a secret named \\nredisPassword that contains the password \", \"for connecting to the Redis server. \\n\\u2022 \\nYou\\u2019ve created service principal in Azure Active Directory. \", \"\\n \\n127 \\nCHAPTER 12 | The Dapr secrets management building block \\n \\n\\u2022 \\nYou\\u2019ve installed an X509 certi\", \"ficate for this service principal (containing both the public and \\nprivate key) on the local filesys\", \"tem. \\nNote \\nA service principal is an identity that can be used by an application to authenticate an\", \" Azure service. \\nThe service principal uses a X509 certificate. The application uses this certificat\", \"e as a credential to \\nauthenticate itself. \\nThe Dapr Azure Key Vault secret store documentation prov\", \"ides step-by-step instructions to create \\nand configure a Key Vault environment. \\nUse Key Vault when\", \" running in self-hosted mode \\nUsing Azure Key Vault in Dapr self-hosted mode requires the following \", \"component configuration file: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: esh\", \"op-azurekv-secret-store \\n  namespace: eshop \\nspec: \\n  type: secretstores.azure.keyvault \\n  version: \", \"v1 \\n  metadata: \\n  - name: vaultName \\n    value: eshopkv \\n  - name: spnTenantId \\n    value: \\\"619926a\", \"f-a7c3-4e95-93ed-4ecc4e3e652b\\\" \\n  - name: spnClientId \\n    value: \\\"6cf48032-6c38-43be-9d6f-2a43ce736\", \"b09\\\" \\n  - name: spnCertificateFile \\n    value : \\\"azurekv-spn-cert.pfx\\\" \\nThe secret store type is sec\", \"retstores.azure.keyvault. The metadata element provides access to the \\nKey Vault with the following \", \"properties: \\n\\u2022 \\nThe vaultName contains the name of the Azure Key Vault. \\n\\u2022 \\nThe spnTenantId contains\", \" the tenant ID of the service principal used to authenticate against the \\nKey Vault. \\n\\u2022 \\nThe spnClie\", \"ntId contains the app ID of the service principal used to authenticate against the \\nKey Vault. \\n\\u2022 \\nT\", \"he spnCertificateFile contains the path to the certificate file for the service principal to \\nauthen\", \"ticate against the Key Vault. \\nTip \\nYou can copy the service principal information from the Azure po\", \"rtal or Azure CLI . \\nNow the application can retrieve the Redis password from the Azure Key Vault. \\n\", \" \\n128 \\nCHAPTER 12 | The Dapr secrets management building block \\n \\nUse Key Vault when running on Kube\", \"rnetes \\nConsuming Azure Key Vault with Dapr and Kubernetes also requires a service principal to auth\", \"enticate \\nagainst the Azure Key Vault. \\nFirst, create a Kubernetes secret that contains a certificat\", \"e file using the kubectl CLI tool: \\nkubectl create secret generic [k8s_spn_secret_name] --from-\\nfile\", \"=[pfx_certificate_file_local_path] -n eshop \\nThe command requires two command-line arguments: \\n\\u2022 \\n[k\", \"8s_spn_secret_name] is the secret name in Kubernetes secret store. \\n\\u2022 \\n[pfx_certificate_file_local_p\", \"ath] is the path of X509 certificate file. \\nOnce created, you can reference the Kubernetes secret in\", \" the secret store component configuration \\nfile: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmet\", \"adata: \\n  name: eshop-azurekv-secret-store \\n  namespace: eshop \\nspec: \\n  type: secretstores.azure.ke\", \"yvault \\n  version: v1 \\n  metadata: \\n  - name: vaultName \\n    value: [your_keyvault_name] \\n  - name: \", \"spnTenantId \\n    value: \\\"619926af-a7c3-4e95-93ed-4ecc4e3e652b\\\" \\n  - name: spnClientId \\n    value: \\\"6\", \"cf48032-6c38-43be-9d6f-2a43ce736b09\\\" \\n  - name: spnCertificate \\n    secretKeyRef: \\n      name: [k8s_\", \"spn_secret_name] \\n      key: [pfx_certificate_file_local_name] \\nauth: \\n    secretStore: kubernetes \\n\", \"At this point, an application running in Kubernetes can retrieve the Redis password from the Azure \\n\", \"Key Vault. \\nImportant \\nIt\\u2019s critical to keep the X509 certificate file for the service principal in \", \"a safe place. It\\u2019s best to place it in \\na well-known folder outside the source-code repository. The \", \"configuration file can then reference the \\ncertificate file from this well-known folder. On a local \", \"development machine, you\\u2019re responsible for \\ncopying the certificate to the folder. For automated de\", \"ployments, the pipeline will copy the certificate \\nto the machine where the application is deployed.\", \" It\\u2019s a best practice to use a different service \\nprincipal per environment. Doing so prevents the s\", \"ervice principal from a DEVELOPMENT environment \\nto access secrets in a PRODUCTION environment. \\n \\n1\", \"29 \\nCHAPTER 12 | The Dapr secrets management building block \\n \\nWhen running in Azure Kubernetes Serv\", \"ice (AKS), it\\u2019s preferable to use an Azure Managed Identity for \\nauthenticating against Azure Key Va\", \"ult. Managed identities are outside of the scope of this book, but \\nexplained in the Azure Key Vault\", \" with managed identities documentation. \\nScope secrets \\nSecret scopes allow you to control which sec\", \"rets your application can access. You configure scopes in \\na Dapr sidecar configuration file. The Da\", \"pr configuration documentation provides instructions for \\nscoping secrets. \\nHere\\u2019s an example of a D\", \"apr sidecar configuration file that contains secret scopes: \\napiVersion: dapr.io/v1alpha1 \\nkind: Con\", \"figuration \\nmetadata: \\n  name: dapr-config \\n  namespace: eshop \\nspec: \\n  tracing: \\n    samplingRate:\", \" \\\"1\\\" \\n  secrets: \\n    scopes: \\n      - storeName: eshop-azurekv-secret-store \\n        defaultAccess:\", \" allow \\n        deniedSecrets: [\\\"redisPassword\\\", \\\"apiKey\\\"] \\nYou specify scopes per secret store. In \", \"the above example, the secret store is named eshop-azurekv-\\nsecret-store. You configure access to se\", \"crets using the following properties: \\nProperty \\nValue \\nDescription \\ndefaultAccess \\nallow or \\ndeny \\n\", \"Allows or denies access to all secrets in the specified secret store. \\nThis property is optional wit\", \"h a default value of allow. \\nallowedSecrets \\nList of \\nsecret keys \\nSecrets specified in the array wi\", \"ll be accessible. This property is \\noptional. \\ndeniedSecrets \\nList of \\nsecret keys \\nSecrets specifie\", \"d in the array will NOT be accessible. This property is \\noptional. \\nThe allowedSecrets and deniedSec\", \"rets properties take precedence over the defaultAccess \\nproperty. Imagine specifying defaultAccess: \", \"allowed and an allowedSecrets list. In this case, only \\nthe secrets in the allowedSecrets list would\", \" be accessible by the application. \\nSample application: Dapr Traffic Control \\nIn Dapr Traffic Contro\", \"l sample app, the secrets management building block is used in several places. \\nSecrets are retrieve\", \"d from code and referenced by Dapr component configuration files. Figure 10-2 \\nshows the conceptual \", \"architecture of the Dapr Traffic Control sample application. The Dapr secrets \\nmanagement building b\", \"lock is used in flows marked with number 6 in the diagram: \\n \\n130 \\nCHAPTER 12 | The Dapr secrets man\", \"agement building block \\n \\n \\nFigure 10-2. Conceptual architecture of the Dapr Traffic Control sample \", \"application. \\nThe FineCollection service uses an SMTP output binding for sending emails (see the Bin\", \"dings chapter). \\nThe email component file consumes the secrets management building block to retrieve\", \" credentials to \\nconnect to the SMTP server. To calculate the fine for a speeding violation, the ser\", \"vice uses a fictitious \\nFineCalculator component that requires a license key. It retrieves this lice\", \"nse key from the secrets \\nmanagement building block. \\nThe TrafficControl service stores vehicle info\", \"rmation in a Redis state store (see the State management \\nchapter). It uses the secrets management b\", \"uilding block for retrieving credentials to connect to the \\nRedis server. \\nBecause the Traffic Contr\", \"ol sample application can run in self-hosted mode or in Kubernetes, there are \\ntwo ways for specifyi\", \"ng secrets: \\n\\u2022 \\nA local JSON file \\n\\u2022 \\nA Kubernetes secret \\n \\n131 \\nCHAPTER 12 | The Dapr secrets mana\", \"gement building block \\n \\nSecrets \\nExamine the secrets-file.yaml component configuration file in the \", \"dapr/components folder: \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: trafficco\", \"ntrol-secrets \\n  namespace: dapr-trafficcontrol \\nspec: \\n  type: secretstores.local.file \\n  version: \", \"v1 \\n  metadata: \\n  - name: secretsFile \\n    value: ../dapr/components/secrets.json \\n  - name: nested\", \"Separator \\n    value: \\\".\\\" \\nscopes: \\n  - trafficcontrolservice \\n  - finecollectionservice \\nThe file d\", \"escribes a secrets management component entitled trafficcontrol-secrets. The type \\nelement is set to\", \" local.file and the secretsFile to ../dapr/components/secrets.json. For self-\\nhosted mode, use a Loc\", \"al file component. The path must be relatively specified from the folder from \\nwhich the service sta\", \"rts. The secrets file contains a JSON representation of the secrets: \\n{ \\n    \\\"state\\\":{ \\n        \\\"red\", \"isPassword\\\": \\\"\\\" \\n    }, \\n    \\\"smtp\\\":{ \\n        \\\"user\\\": \\\"_username\\\", \\n        \\\"password\\\": \\\"_password\\\"\", \" \\n    }, \\n    \\\"finecalculator\\\":{ \\n        \\\"licensekey\\\": \\\"HX783-K2L7V-CRJ4A-5PN1G\\\" \\n    } \\n} \\nIn the \", \"sample application the Redis server is used without a password. To connect to the SMTP server, \\nthe \", \"credentials are _username and _password. The license key for the FineCalculator license key is a \\nra\", \"ndomly generated string. \\nWhile secrets are stored at nested levels, the secrets management building\", \" block flattens this \\nhierarchy when the file is read. It uses a period as a level separator (as spe\", \"cified in the \\nnestedSeparator field in the component configuration file). This construct enables yo\", \"u to reference \\nsecrets with a flattened name, for example: smtp.user. \\nWhen running in Kubernetes, \", \"the secrets are specified using the built-in Kubernetes secrets store. \\nExamine the following secret\", \"s.yaml Kubernetes manifest file in the k8s folder: \\napiVersion: v1 \\nkind: Secret \\nmetadata: \\n  name:\", \" trafficcontrol-secrets \\n  namespace: dapr-trafficcontrol \\n \\n132 \\nCHAPTER 12 | The Dapr secrets mana\", \"gement building block \\n \\ntype: Opaque \\ndata: \\n  smtp.user: X3VzZXJuYW1l \\n  smtp.password: X3Bhc3N3b3\", \"Jk \\n  finecalculator.licensekey: SFg3ODMtSzJMN1YtQ1JKNEEtNVBOMUc= \\nThe component is also named traff\", \"iccontrol-secrets. Secrets are stored as Base64 encoded \\nstrings. \\nImportant \\nBase64 representations\", \" encode, but do not encrypt data. Base64 isn\\u2019t secure for production scenarios. \\nThe following parag\", \"raphs describe how secrets are used in the Traffic Control sample application. \\nSMTP server credenti\", \"als \\nExamine the email.yaml component configuration file located in the dapr/components folder: \\napi\", \"Version: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: sendmail \\n  namespace: dapr-trafficco\", \"ntrol \\nspec: \\n  type: bindings.smtp \\n  version: v1 \\n  metadata: \\n  - name: host \\n    value: localhos\", \"t \\n  - name: port \\n    value: 4025 \\n  - name: user \\n    secretKeyRef: \\n      name: smtp.user \\n      \", \"key: smtp.user \\n  - name: password \\n    secretKeyRef: \\n      name: smtp.password \\n      key: smtp.pa\", \"ssword \\n  - name: skipTLSVerify \\n    value: true \\nauth: \\n  secretStore: trafficcontrol-secrets \\nscop\", \"es: \\n  - finecollectionservice \\nThe auth section references the secrets management component named t\", \"rafficcontrol-secrets. \\nThe user and password entries in the binding metadata reference the secrets:\", \" smtp.user and \\nsmtp.password respectively. \\nWhen running in Kubernetes, the built-in Kubernetes sec\", \"rets store is used. The email.yaml manifest \\nfile found in the k8s folder references the Kubernetes \", \"secret for retrieving the credentials for \\nconnecting to the smtp server: \\napiVersion: dapr.io/v1alp\", \"ha1 \\nkind: Component \\n \\n133 \\nCHAPTER 12 | The Dapr secrets management building block \\n \\nmetadata: \\n \", \" name: sendmail \\n  namespace: dapr-trafficcontrol \\nspec: \\n  type: bindings.smtp \\n  version: v1 \\n  me\", \"tadata: \\n  - name: host \\n    value: mailserver \\n  - name: port \\n    value: 25 \\n  - name: user \\n    s\", \"ecretKeyRef: \\n      name: trafficcontrol-secrets \\n      key: smtp.user \\n  - name: password \\n    secr\", \"etKeyRef: \\n      name: trafficcontrol-secrets \\n      key: smtp.password \\n  - name: skipTLSVerify \\n  \", \"  value: true \\nscopes: \\n  - finecollectionservice \\nUnlike the local secrets store, the Kubernetes st\", \"ore doesn\\u2019t explicitly specify a secrets management \\ncomponent to use with the auth section. Instead\", \", the default is the built-in Kubernetes secrets store. \\nRedis server credentials \\nNext, examine the\", \" statestore.yaml component configuration file in the dapr/components folder: \\napiVersion: dapr.io/v1\", \"alpha1 \\nkind: Component \\nmetadata: \\n  name: statestore \\n  namespace: dapr-trafficcontrol \\nspec: \\n  t\", \"ype: state.redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    value: localhost:6379 \\n  - na\", \"me: redisPassword \\n    secretKeyRef: \\n      name: state.redisPassword \\n      key: state.redisPasswor\", \"d \\n  - name: actorStateStore \\n    value: \\\"true\\\" \\nauth: \\n  secretStore: trafficcontrol-secrets \\nscope\", \"s: \\n  - trafficcontrolservice \\nOnce again, the auth section references the secrets management compon\", \"ent named \\ntrafficcontrol-secrets. The redisPassword entries in the binding metadata reference the s\", \"ecret \\nstate.redisPassword. \\n \\n134 \\nCHAPTER 12 | The Dapr secrets management building block \\n \\nFineC\", \"alculator component license key \\nThe FineCollection service uses a component that calculates the fin\", \"e based on the information of a \\nspeeding violation. This component is implemented as a domain servi\", \"ce and is abstracted by the \\nIFineCalculator interface: \\npublic interface IFineCalculator \\n{ \\n    pu\", \"blic int CalculateFine(string licenseKey, int violationInKmh); \\n} \\nThe CalculateFine method expects \", \"a string containing a licenseKey as its first argument. This key \\nunlocks the third-party component \", \"used by the implementation. To keep the example simple, the \\nimplementation hard-codes a series of i\", \"f statements. You can find the implementation in the \\nHardCodedFineCalculator class in the DomainsSe\", \"rvices folder: \\n    public class HardCodedFineCalculator : IFineCalculator \\n    { \\n        public in\", \"t CalculateFine(string licenseKey, int violationInKmh) \\n        { \\n            if (licenseKey != \\\"HX\", \"783-K2L7V-CRJ4A-5PN1G\\\") \\n            { \\n                throw new InvalidOperationException(\\\"Invalid\", \" license-key specified.\\\"); \\n            } \\n \\n            int fine = 9; // default administration fee\", \" \\n            if (violationInKmh < 5 ) \\n            { \\n                fine += 18; \\n            } \\n \", \"           else if (violationInKmh >= 5 && violationInKmh < 10 ) \\n            { \\n                fin\", \"e += 31; \\n            } \\n \\n            // ... \\n \\n            else if (violationInKmh == 35) \\n       \", \"     { \\n                fine += 372; \\n            } \\n            else \\n            { \\n              \", \"  // violation above 35 KMh will be determined by the prosecutor \\n                return 0; \\n       \", \"     } \\n \\n            return fine; \\n        } \\n    } \\nThe implementation simulates a check on the li\", \"censeKey that is passed in. The \\nCollectionController of the FineCollection service must pass in the\", \" correct license key argument \\nwhen calling the CalculateFine method. It retrieves the license key f\", \"rom the Dapr secrets \\nmanagement building block that is exposed by the Dapr client in the Dapr SDK f\", \"or .NET. If you \\nexamine the constructor of the CollectionController, you can see the call: \\n \\n135 \\n\", \"CHAPTER 12 | The Dapr secrets management building block \\n \\n// set finecalculator component license-k\", \"ey \\nif (_fineCalculatorLicenseKey == null) \\n{ \\n    bool runningInK8s = \\nConvert.ToBoolean(Environmen\", \"t.GetEnvironmentVariable(\\\"DOTNET_RUNNING_IN_CONTAINER\\\") ?? \\n\\\"false\\\"); \\n    var metadata = new Dictio\", \"nary<string, string> { { \\\"namespace\\\", \\\"dapr-trafficcontrol\\\" } \\n}; \\n    if (runningInK8s) \\n    { \\n   \", \"     var k8sSecrets = daprClient.GetSecretAsync( \\n            \\\"kubernetes\\\", \\\"trafficcontrol-secrets\\\"\", \", metadata).Result; \\n        _fineCalculatorLicenseKey = k8sSecrets[\\\"finecalculator.licensekey\\\"]; \\n \", \"   } \\n    else \\n    { \\n        var secrets = daprClient.GetSecretAsync( \\n            \\\"trafficcontrol\", \"-secrets\\\", \\\"finecalculator.licensekey\\\", metadata).Result; \\n        _fineCalculatorLicenseKey = secre\", \"ts[\\\"finecalculator.licensekey\\\"]; \\n    } \\n} \\nThe code determines whether the service is running in Ku\", \"bernetes or self-hosted mode. This check is \\nnecessary because a different secrets management compon\", \"ent must be used for each situation. The \\nfirst argument of the GetSecretAsync method is the name of\", \" the Dapr component. The second \\nargument is the name of the secret. The metadata passed in as the t\", \"hird argument specifies the \\nnamespace that contains the secret. The value of the finecalculator.lic\", \"ensekey secret is stored in \\na private field for later use. \\nUsing Dapr secrets management offers se\", \"veral benefits: \\n1. \\nNo sensitive information is stored in code or application configuration files. \", \"\\n2. \\nNo need to learn any new API for interacting with a secrets store. \\nSummary \\nThe Dapr secrets m\", \"anagement building block provides capabilities for storing and retrieving sensitive \\nconfiguration s\", \"ettings like passwords and connection-strings. It keeps secrets private and prevents \\nthem from bein\", \"g accidentally disclosed. \\nThe building block supports several different secret stores and hides the\", \"ir complexity with the Dapr \\nsecrets API. \\nThe Dapr .NET SDK provides a DaprClient object to retriev\", \"e secrets. It also includes a .NET \\nconfiguration provider that adds secrets to the .NET configurati\", \"on system. Once loaded, you can \\nconsume these secrets in your .NET code. \\nYou can use secret scopes\", \" to control access to specific secrets. \\nReferences \\n\\u2022 \\nBeyond the Twelve-Factor Application \\n \\n136 \", \"\\nCHAPTER 12 | The Dapr secrets management building block \\n \\n\\u2022 \\nDapr supported secret stores \\n \\n137 \\n\", \"CHAPTER 13 | Dapr reference application \\n \\nCHAPTER 13 \\nDapr reference application \\nOver the course o\", \"f this book, you\\u2019ve learned about the foundational benefits of Dapr. You saw how \\nDapr can help you \", \"and your team construct distributed applications while reducing architectural and \\noperational compl\", \"exity. Along the way, you\\u2019ve had the opportunity to build some small Dapr apps. \\nNow, it\\u2019s time to e\", \"xplore how a more complex application can benefit from Dapr. \\nBut, first a little history. \\neShopOnC\", \"ontainers \\nSeveral years ago, Microsoft, in partnership with leading community experts, released a p\", \"opular \\nguidance book, entitled .NET Microservices for Containerized .NET Applications. Figure 12-1 \", \"shows the \\nbook: \\n \\nFigure 12-1. .NET Microservices: Architecture for Containerized .NET Application\", \"s. \\nThe book dove deep into the principles, patterns, and best practices for building distributed \\na\", \"pplications. It included a full-featured microservice reference application that showcased the \\narch\", \"itectural concepts. Entitled, eShopOnContainers, the application hosts an e-Commerce storefront \\ntha\", \"t sells various items, including clothing and coffee mugs. Built in .NET, the application is cross-\\n\", \"platform and can run in either Linux or Windows containers. Figure 12-2 shows the original eShop \\nar\", \"chitecture. \\n \\n138 \\nCHAPTER 13 | Dapr reference application \\n \\n \\nFigure 12-2. Original ShopOnContain\", \"ers reference application. \\nAs you can see, eShopOnContainers includes many moving parts: \\n1. \\nThree\", \" different frontend clients. \\n2. \\nAn application gateway to abstract backend services from the front\", \"end. \\n3. \\nSeveral backend core microservices. \\n4. \\nAn event bus component that enables asynchronous \", \"pub/sub messaging. \\nThe eShopOnContainers reference application has been widely accepted across the \", \".NET community \\nand used to model many large commercial microservice applications. \\neShopOnDapr \\nAn \", \"updated version of eShop accompanies this book. It\\u2019s called eShopOnDapr. The update evolves \\nthe ear\", \"lier eShopOnContainers application by integrating Dapr building blocks. Figure 12-3 shows the \\nnew s\", \"olution architecture: \\n[eShopOnDapr reference application architecture](#g\\u0b1b\\u0b1b\\u0b1br&\\u0b1b<\\u0b1b\\u0b1bp\\u0b1b\\u0b1br\\u0b1bm\\u0433z\\u0b1b!c(*\\u0b1b-\\n\\u03ce\", \"\\u0b1b9\\u0b1b\\u0b1b\\u0b1b\\u0b1b>4) \\nFigure 12-3. eShopOnDapr reference application architecture. \\nWhile eShopOnDapr focuses o\", \"n Dapr, the architecture has also been streamlined and simplified. \\n1. \\nA Single Page Application ru\", \"nning on Blazor WebAssembly sends user requests to an API \\ngateway. \\n2. \\nThe API gateway abstracts t\", \"he backend core microservices from the frontend client. It\\u2019s \\nimplemented using Envoy, a high perfor\", \"mant, open-source service proxy. Envoy routes incoming \\n \\n139 \\nCHAPTER 13 | Dapr reference applicati\", \"on \\n \\nrequests to backend microservices. Most requests are simple CRUD operations (for example, get \", \"\\nthe list of brands from the catalog) and handled by a direct call to a backend microservice. \\n3. \\nO\", \"ther requests are more logically complex and require multiple microservice calls to work \\ntogether. \", \"For these cases, eShopOnDapr implements an aggregator microservice that \\norchestrates a workflow acr\", \"oss those microservices needed to complete the operation. \\n4. \\nThe core backend microservices implem\", \"ent the required functionality for an e-Commerce store. \\nEach is self-contained and independent of t\", \"he others. Following widely accepted domain \\ndecomposition patterns, each microservice isolates a sp\", \"ecific business capability: \\n\\u2013 \\nThe basket service manages the customer\\u2019s shopping basket experience\", \". \\n\\u2013 \\nThe catalog service manages product items available for sale. \\n\\u2013 \\nThe identity service manages\", \" authentication and identity. \\n\\u2013 \\nThe ordering service handles all aspects of placing and managing o\", \"rders. \\n\\u2013 \\nThe payment service transacts the customer\\u2019s payment. \\n5. \\nAdhering to best practices, ea\", \"ch microservice maintains its own persistent storage. The \\napplication doesn\\u2019t share a single datast\", \"ore. \\n6. \\nFinally, the event bus wraps the Dapr publish/subscribe components. It enables asynchronou\", \"s \\npublish/subscribe messaging across microservices. Developers can plug in any Dapr-supported \\nmess\", \"age broker component. \\nApplication of Dapr building blocks \\nIn eShopOnDapr, Dapr building blocks rep\", \"lace a large amount of complex, error-prone plumbing \\ncode. \\nFigure 12-4 shows the Dapr integration \", \"in the application. \\n \\nFigure 12-4. Dapr integration in eShopOnDapr. \\n \\n140 \\nCHAPTER 13 | Dapr refer\", \"ence application \\n \\nThe above figure shows the Dapr building blocks (represented as green numbered b\", \"oxes) that each \\neShopOnDapr service consumes. \\n1. \\nThe API gateway and web shopping aggregator serv\", \"ices use the service invocation building \\nblock to invoke methods on the backend services. \\n2. \\nThe \", \"backend services communicate asynchronously using the publish & subscribe building \\nblock. \\n3. \\nThe \", \"basket service uses the state management building block to store the state of the \\ncustomer\\u2019s shoppi\", \"ng basket. \\n4. \\nThe original eShopOnContainers demonstrates DDD concepts and patterns in the orderin\", \"g \\nservice. eShopOnDapr uses the actor building block as an alternative implementation. The turn-\\nba\", \"sed access model of actors makes it easy to implement a stateful ordering process with \\nsupport for \", \"cancellation. \\n5. \\nThe ordering service sends order confirmation e-mails using the bindings building\", \" block. \\n6. \\nSecret management is done by the secrets building block. \\nThe following sections provid\", \"e more detail on how the Dapr building blocks are applied in \\neShopOnDapr. \\nState management \\nIn eSh\", \"opOnDapr, the Basket service uses the state management building block to persist the contents \\nof th\", \"e customer\\u2019s shopping basket. The original eShopOnContainers architecture used an \\nIBasketRepository\", \" interface to read and write data for the basket service. The \\nRedisBasketRepository class provided \", \"the implementation using Redis as the underlying data store. \\nTo compare and contrast, the original \", \"eShopOnContainers implementation is presented below: \\npublic class RedisBasketRepository : IBasketRe\", \"pository \\n{ \\n    private readonly ConnectionMultiplexer _redis; \\n    private readonly IDatabase _dat\", \"abase; \\n \\n    public RedisBasketRepository(ConnectionMultiplexer redis) \\n    { \\n        _redis = red\", \"is; \\n        _database = redis.GetDatabase(); \\n    } \\n \\n    public async Task<CustomerBasket> GetBas\", \"ketAsync(string customerId) \\n    { \\n        var data = await _database.StringGetAsync(customerId); \\n\", \" \\n        if (data.IsNullOrEmpty) \\n        { \\n            return null; \\n        } \\n \\n        return \", \"JsonConvert.DeserializeObject<CustomerBasket>(data); \\n    } \\n \\n    // ... \\n} \\n \\n141 \\nCHAPTER 13 | Da\", \"pr reference application \\n \\nThis code uses the third party StackExchange.Redis NuGet package. The fo\", \"llowing steps are required \\nto load the shopping basket for a given customer: \\n1. \\nInject a Redis Co\", \"nnectionMultiplexer into the constructor. The ConnectionMultiplexer is \\nregistered with the dependen\", \"cy injection framework in the Program.cs file: \\nservices.AddSingleton<ConnectionMultiplexer>(sp => \\n\", \"{ \\n    var settings = spGetRequiredService<IOptions<BasketSettings>>().Value; \\n    var configuration\", \" = ConfigurationOptions.Parse(settingsConnectionString, true); \\n    configuration.ResolveDns = true;\", \" \\n    return ConnectionMultiplexer.Connect(configuration); \\n}); \\n1. \\nUse the ConnectionMultiplexer t\", \"o create an IDatabase instance in each consuming class. \\n2. \\nUse the IDatabase instance to execute a\", \" Redis StringGet call using the given customerId as the \\nkey. \\n3. \\nCheck if data is loaded from Redi\", \"s; if not, return null. \\n4. \\nDeserialize the data from Redis to a CustomerBasket object and return t\", \"he result. \\nIn the updated eShopOnDapr reference application, a new DaprBasketRepository class repla\", \"ces the \\nRedisBasketRepository class: \\npublic class DaprBasketRepository : IBasketRepository \\n{ \\n   \", \" private const string StoreName = \\\"eshop-statestore\\\"; \\n \\n    private readonly DaprClient _daprClient\", \"; \\n \\n    public DaprBasketRepository(DaprClient daprClient) \\n    { \\n        _daprClient = daprClient\", \"; \\n    } \\n \\n    public Task<CustomerBasket> GetBasketAsync(string customerId) => \\n        _daprClien\", \"t.GetStateAsync<CustomerBasket>(StoreName, customerId); \\n \\n    // ... \\n} \\nThe updated code uses the \", \"Dapr .NET SDK to read and write data using the state management \\nbuilding block. The new steps to lo\", \"ad the basket for a customer are dramatically simplified: \\n1. \\nInject a DaprClient into the construc\", \"tor. The DaprClient is registered with the dependency \\ninjection framework in the Program.cs`_ file.\", \" \\n2. \\nUse the DaprClient.GetStateAsync method to load the customer\\u2019s shopping basket items from \\nthe\", \" configured state store and return the result. \\nThe updated implementation still uses Redis as the u\", \"nderlying data store. But, note how Dapr \\nabstracts the StackExchange.Redis references and complexit\", \"y from the application. The application \\nno longer requires a direct dependency on Redis. A Dapr con\", \"figuration file is all that\\u2019s needed: \\n \\n142 \\nCHAPTER 13 | Dapr reference application \\n \\napiVersion:\", \" dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: eshop-statestore \\n  namespace: eshop \\nspec: \\n\", \"  type: state.redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    value: redis:6379 \\n  - nam\", \"e: redisPassword \\n    secretKeyRef: \\n      name: redisPassword \\nauth: \\n  secretStore: eshop-secretst\", \"ore \\nThe Dapr implementation also simplifies changing the underlying data store. Switching to Azure \", \"Table \\nStorage, for example, requires only changing the contents of the configuration file. No code \", \"changes \\nare necessary. \\nService invocation \\nThe original eShopOnContainers used a mix of HTTP/REST \", \"and gRPC services. The use of gRPC was \\nlimited to communication between an aggregator service and c\", \"ore backend services. Figure 12-5 \\nshows the original architecture: \\n \\nFigure 12-5. gRPC and HTTP/RE\", \"ST calls in eShopOnContainers. \\nNote the steps from the previous figure: \\n1. \\nThe frontend calls the\", \" API gateway using HTTP/REST. \\n \\n143 \\nCHAPTER 13 | Dapr reference application \\n \\n2. \\nThe API gateway\", \" forwards simple CRUD (Create, Read, Update, Delete) requests directly to a core \\nbackend service us\", \"ing HTTP/REST. \\n3. \\nThe API gateway forwards complex requests that involve coordinated backend servi\", \"ce calls to \\nthe web shopping aggregator service. \\n4. \\nThe aggregator service uses gRPC to call core\", \" backend services. \\nIn the updated eShopOnDapr implementation, Dapr sidecars are added to the servic\", \"es and API \\ngateway. Figure 12-6 show the updated architecture: \\n \\nFigure 12-6. Updated eShop archit\", \"ecture using Dapr. \\nNote the updated steps from the previous figure: \\n1. \\nThe frontend still uses HT\", \"TP/REST to call the API gateway. \\n2. \\nThe API gateway forwards HTTP requests to its Dapr sidecar. \\n3\", \". \\nThe API gateway sidecar sends the request to the sidecar of the aggregator or backend service. \\n4\", \". \\nThe aggregator service uses the Dapr .NET SDK to call backend services through their sidecar \\narc\", \"hitecture. \\nDapr implements calls between sidecars with gRPC. So even if you\\u2019re invoking a remote se\", \"rvice with \\nHTTP/REST semantics, a part of the transport is implemented using gRPC. \\nThe eShopOnDapr\", \" reference application benefits from the Dapr service invocation building block. The \\nbenefits also \", \"include service discovery, automatic mTLS, and built-in observability. \\nForward HTTP requests using \", \"Envoy and Dapr \\nBoth the original and updated eShop application leverage the Envoy proxy as an API g\", \"ateway. Envoy \\nis an open-source proxy and communication bus that is popular across modern distribut\", \"ed \\napplications. Originating from Lyft, Envoy is owned and maintained by the Cloud-Native Computing\", \" \\nFoundation. \\n \\n144 \\nCHAPTER 13 | Dapr reference application \\n \\nIn the original eShopOnContainers i\", \"mplementation, the Envoy API gateway forwarded incoming HTTP \\nrequests directly to aggregator or bac\", \"kend services. In the new eShopOnDapr, the Envoy proxy \\nforwards the request to a Dapr sidecar. \\nEnv\", \"oy is configured using a YAML definition file to control the proxy\\u2019s behavior. To enable Envoy to \\nf\", \"orward HTTP requests to a Dapr sidecar container, a dapr cluster is added to the configuration. The \", \"\\ncluster configuration contains a host that points to the HTTP port on which the Dapr sidecar is \\nli\", \"stening: \\nclusters: \\n- name: dapr \\n  connect_timeout: 0.25s \\n  type: strict_dns \\n  hosts: \\n  - socke\", \"t_address: \\n    address: 127.0.0.1 \\n    port_value: 3500 \\nThe Envoy route configuration is updated t\", \"o rewrite incoming requests as calls to the Dapr sidecar \\n(pay close attention to the prefix_rewrite\", \" key/value pair): \\n- name: \\\"c-short\\\" \\n  match: \\n    prefix: \\\"/c/\\\" \\n  route: \\n    auto_host_rewrite: \", \"true \\n    prefix_rewrite: \\\"/v1.0/invoke/catalog-api/method/\\\" \\n    cluster: dapr \\nConsider a scenario\", \" where the frontend client wants to retrieve a list of catalog items. The Catalog API \\nprovides an e\", \"ndpoint for getting the catalog items: \\n[Route(\\\"api/v1/[controller]\\\")] \\n[ApiController] \\npublic clas\", \"s CatalogController : ControllerBase \\n{ \\n \\n    [HttpGet(\\\"items/by_page\\\")] \\n    [ProducesResponseType\", \"(typeof(PaginatedItemsViewModel), (int)HttpStatusCode.OK)] \\n    public async Task<PaginatedItemsView\", \"Model> ItemsAsync( \\n        [FromQuery] int typeId = -1, \\n        [FromQuery] int brandId = -1, \\n   \", \"     [FromQuery] int pageSize = 10, \\n        [FromQuery] int pageIndex = 0) \\n    { \\n        // ... \\n\", \"    } \\nFirst, the frontend makes a direct HTTP call to the Envoy API gateway. \\nGET http://<api-gatew\", \"ay>/c/api/v1/catalog/items \\nThe Envoy proxy matches the route, rewrites the HTTP request, and forwar\", \"ds it to the invoke API of its \\nDapr sidecar: \\nGET http://127.0.0.1:3500/v1.0/invoke/catalog-api/met\", \"hod/api/v1/catalog/items \\n \\n145 \\nCHAPTER 13 | Dapr reference application \\n \\nThe sidecar handles serv\", \"ice discovery and routes the request to the Catalog API sidecar. Finally, the \\nsidecar calls the Cat\", \"alog API to execute the request, fetch catalog items, and return a response: \\nGET http://localhost/a\", \"pi/v1/catalog/items \\nMake aggregated service calls using the .NET SDK \\nMost calls from the eShop fro\", \"ntend are simple CRUD calls. The API gateway forwards them to a single \\nservice for processing. Some\", \" scenarios, however, require multiple backend services to work together \\nto complete a request. For \", \"the more complex calls, the web shopping aggregator service mediates the \\ncross service workflow. Fi\", \"gure 12-7 show the processing sequence of adding an item to your \\nshopping basket: \\n \\nFigure 12-7. B\", \"ackend call requiring multiple services. \\nThe aggregator service first retrieves catalog items from \", \"the Catalog API. It then validates item \\navailability and pricing. Finally, the aggregator service u\", \"pdates the shopping basket by calling the \\nBasket API. \\nThe aggregator service contains a BasketCont\", \"roller that provides an endpoint for updating the \\nshopping basket: \\n[Route(\\\"api/v1/[controller]\\\")] \", \"\\n[Authorize] \\n[ApiController] \\npublic class BasketController : ControllerBase \\n{ \\n    private readon\", \"ly ICatalogService _catalog; \\n    private readonly IBasketService _basket; \\n \\n    [HttpPost] \\n    [H\", \"ttpPut] \\n    [ProducesResponseType((int)HttpStatusCode.BadRequest)] \\n    [ProducesResponseType(typeo\", \"f(BasketData), (int)HttpStatusCode.OK)] \\n    public async Task<ActionResult<BasketData>> UpdateAllBa\", \"sketAsync( \\n        [FromBody] UpdateBasketRequest data, \\n        [FromHeader] string authorization)\", \" \\n    { \\n        BasketData basket; \\n \\n146 \\nCHAPTER 13 | Dapr reference application \\n \\n \\n        if \", \"(data.Items is null || !data.Items.Any()) \\n        { \\n            basket = new(); \\n        } \\n      \", \"  else \\n        { \\n            // Get the item details from the catalog API. \\n            var catalo\", \"gItems = await _catalog.GetCatalogItemsAsync( \\n                data.Items.Select(x => x.ProductId));\", \" \\n \\n            if (catalogItems == null) \\n            { \\n                return BadRequest( \\n      \", \"              \\\"Catalog items were not available for the specified items in the \\nbasket.\\\"); \\n        \", \"    } \\n \\n            // Check item availability and prices; store results in basket object. \\n       \", \"     basket = CreateValidatedBasket(data.Items, catalogItems); \\n        } \\n \\n        // Save the upd\", \"ated shopping basket. \\n        await _basket.UpdateAsync(basket, authorization.Substring(\\\"Bearer \\\".L\", \"ength)); \\n \\n        return basket; \\n    } \\n \\n    // ... \\n} \\nThe UpdateAllBasketAsync method gets the\", \" Authorization header of the incoming request using a \\nFromHeader attribute. The Authorization heade\", \"r contains the access token that is needed to call \\nprotected backend services. \\nAfter receiving a r\", \"equest to update the basket, the aggregator service calls the Catalog API to get the \\nitem details. \", \"The Basket controller uses an injected ICatalogService object to make that call and \\ncommunicate wit\", \"h the Catalog API. The original implementation of the interface used gRPC to make \\nthe call. The upd\", \"ated implementation uses Dapr service invocation with HttpClient support: \\npublic class CatalogServi\", \"ce : ICatalogService \\n{ \\n    private readonly HttpClient _httpClient; \\n \\n    public CatalogService(H\", \"ttpClient httpClient) \\n    { \\n        _httpClient = httpClient; \\n    } \\n \\n    public Task<IEnumerabl\", \"e<CatalogItem>> GetCatalogItemsAsync(IEnumerable<int> ids) \\n    { \\n        var requestUri = $\\\"api/v1\", \"/catalog/items/by_ids?ids={string.Join(\\\",\\\", ids)}\\\"; \\n \\n        return _httpClient.GetFromJsonAsync<I\", \"Enumerable<CatalogItem>>(requestUri); \\n    } \\n \\n    // ... \\n} \\n \\n147 \\nCHAPTER 13 | Dapr reference ap\", \"plication \\n \\nNotice how no Dapr-specific code is required to make the service invocation call. All c\", \"ommunication is \\ndone using the standard HttpClient object. \\nThe Dapr HttpClient is configured for t\", \"he CatalogService class on program startup: \\nbuilder.Services.AddSingleton<ICatalogService, CatalogS\", \"ervice>( \\n    _ => new CatalogService(DaprClient.CreateInvokeHttpClient(\\\"catalog-api\\\"))); \\nThe other\", \" call made by the aggregator service is to the Basket API. It only allows authorized requests. \\nThe \", \"access token is passed along in an Authorization request header to ensure the call succeeds: \\npublic\", \" class BasketService : IBasketService \\n{ \\n    public Task UpdateAsync(BasketData currentBasket, stri\", \"ng accessToken) \\n    { \\n        var request = new HttpRequestMessage(HttpMethod.Post, \\\"api/v1/basket\", \"\\\") \\n        { \\n            Content = JsonContent.Create(currentBasket) \\n        }; \\n        request.\", \"Headers.Authorization = new AuthenticationHeaderValue(\\\"Bearer\\\", \\naccessToken); \\n \\n        var respon\", \"se = await _httpClient.SendAsync(request); \\n        response.EnsureSuccessStatusCode(); \\n    } \\n \\n  \", \"  // ... \\n} \\nIn this example too, only standard HttpClient functionality is used to call the service\", \". This allows \\ndevelopers who are already familiar with HttpClient to reuse their existing skills. I\", \"t even enables \\nexisting HttpClient code to use Dapr service invocation without making any changes. \", \"\\nPublish & subscribe \\nBoth eShopOnContainers and eShopOnDapr use the pub/sub pattern for communicati\", \"ng integration \\nevents across microservices. Integration events include: \\n\\u2022 \\nWhen a user checks-out \", \"a shopping basket. \\n\\u2022 \\nWhen a payment for an order has succeeded. \\n\\u2022 \\nWhen the grace-period of a pur\", \"chase has expired. \\nNote \\nThink of an Integration Event as an event that takes place across multiple\", \" services. \\nEventing in eShopOnContainers is based on the following IEventBus interface: \\npublic int\", \"erface IEventBus \\n{ \\n    void Publish(IntegrationEvent integrationEvent); \\n \\n    void Subscribe<T, T\", \"Handler>() \\n        where TEvent : IntegrationEvent \\n        where THandler : IIntegrationEventHandl\", \"er<T>; \\n} \\n \\n148 \\nCHAPTER 13 | Dapr reference application \\n \\nConcrete implementations of this interf\", \"ace for both RabbitMQ and Azure Service Bus are found in \\neShopOnContainers. Each implementation inc\", \"luded a large amount of custom plumbing code that \\nwas complex to understand and difficult to mainta\", \"in. \\nThe newer eShopOnDapr significantly simplifies pub/sub behavior by using Dapr. To start, the \\nI\", \"EventBus interface was reduced to a single method: \\npublic interface IEventBus \\n{ \\n    Task PublishA\", \"sync(IntegrationEvent integrationEvent); \\n} \\nPublish events \\nIn eShopOnDapr, a single DaprEventBus i\", \"mplementation can support any Dapr-supported message \\nbroker. The following code block shows the sim\", \"plified Publish method. Note how the PublishAsync \\nmethod uses the Dapr client to publish an event: \", \"\\npublic class DaprEventBus : IEventBus \\n{ \\n    private const string DAPR_PUBSUB_NAME = \\\"pubsub\\\"; \\n \\n\", \"    private readonly DaprClient _dapr; \\n    private readonly ILogger _logger; \\n \\n    public DaprEven\", \"tBus(DaprClient dapr, ILogger<DaprEventBus> logger) \\n    { \\n        _dapr = dapr; \\n        _logger =\", \" logger; \\n    } \\n \\n    public async Task PublishAsync(IntegrationEvent integrationEvent) \\n    { \\n   \", \"     var topicName = integrationEvent.GetType().Name; \\n \\n        _logger.LogInformation( \\n          \", \"  \\\"Publishing event {@Event} to {PubsubName}.{TopicName}\\\", \\n            integrationEvent, \\n         \", \"   DAPR_PUBSUB_NAME, \\n            topicName); \\n \\n        // We need to make sure that we pass the co\", \"ncrete type to PublishEventAsync, \\n        // which can be accomplished by casting the event to dyna\", \"mic. This ensures \\n        // that all event fields are properly serialized. \\n        await _dapr.Pu\", \"blishEventAsync(DAPR_PUBSUB_NAME, topicName, \\n(object)integrationEvent); \\n    } \\n} \\nAs you can see i\", \"n the code snippet, the topic name is derived from event type\\u2019s name. Because all \\neShop services us\", \"e the IEventBus abstraction, retrofitting Dapr required absolutely no change to the \\nmainline applic\", \"ation code. \\n \\n149 \\nCHAPTER 13 | Dapr reference application \\n \\nImportant \\nThe Dapr SDK uses System.T\", \"ext.Json to serialize/deserialize messages. However, System.Text.Json \\ndoesn\\u2019t serialize properties \", \"of derived classes by default. In the eShop code, an event is sometimes \\nexplicitly declared as an I\", \"ntegrationEvent, the base class for integration events. This construct allows \\nthe concrete event ty\", \"pe to be determined dynamically at run time based on business logic. As a result, \\nthe event is seri\", \"alized using the type information of the base class and not the derived class. To force \\nSystem.Text\", \".Json to serialize the properties of both the base and derived class, the code uses \\nobject as the g\", \"eneric type parameter. For more information, see the .NET documentation. \\nWith Dapr, pub/sub infrast\", \"ructure code is dramatically simplified. The application doesn\\u2019t need to \\ndistinguish between messag\", \"e brokers. Dapr provides this abstraction for you. If needed, you can easily \\nswap out message broke\", \"rs or configure multiple message broker components with no code changes. \\nSubscribe to events \\nThe e\", \"arlier eShopOnContainers app contains SubscriptionManagers to handle the subscription \\nimplementatio\", \"n for each message broker. Each manager contains complex message broker-specific \\ncode for handling \", \"subscription events. To receive events, each service has to explicitly register a \\nhandler for each \", \"event-type. \\neShopOnDapr streamlines the plumbing for event subscriptions by using Dapr ASP.NET Core\", \" \\nintegration. Each event is handled by an action method in a controller. A Topic attribute decorate\", \"s the \\naction method with the name of the corresponding topic. Here\\u2019s a code snippet taken from the \", \"\\nPaymentService: \\n[Route(\\\"api/v1/[controller]\\\")] \\n[ApiController] \\npublic class IntegrationEventCont\", \"roller : ControllerBase \\n{ \\n    private const string DAPR_PUBSUB_NAME = \\\"pubsub\\\"; \\n \\n    [HttpPost(\\\"\", \"OrderStatusChangedToValidated\\\")] \\n    [Topic(DAPR_PUBSUB_NAME, nameof(OrderStatusChangedToValidatedI\", \"ntegrationEvent))] \\n    public Task HandleAsync( \\n        OrderStatusChangedToValidatedIntegrationEv\", \"ent integrationEvent, \\n        [FromServices] OrderStatusChangedToValidatedIntegrationEventHandler h\", \"andler) => \\n        handler.Handle(integrationEvent); \\n} \\nIn the Topic attribute, the name of the .N\", \"ET type of the event is used as the topic name. For handling \\nthe event, an event handler that alrea\", \"dy existed in the earlier eShopOnContainers code base is \\nresolved using dependency injection and in\", \"voked. In the previous example, messages received from \\nthe OrderStatusChangedToValidatedIntegration\", \"Event topic invoke the existing \\nOrderStatusChangedToValidatedIntegrationEventHandler event handler.\", \" Because Dapr \\nimplements the underlying plumbing for subscriptions and message brokers, a large amo\", \"unt of \\noriginal code became obsolete and was removed from the code-base. Much of this code was comp\", \"lex \\nto understand and challenging to maintain. \\n \\n150 \\nCHAPTER 13 | Dapr reference application \\n \\nU\", \"se pub/sub components \\nWithin the eShopOnDapr repository, a deployment folder contains files for dep\", \"loying the application \\nusing different deployment modes: Docker Compose and Kubernetes. A dapr fold\", \"er exists within each \\nof these folders that holds a components folder. This folder holds a file esh\", \"op-pubsub.yaml. It \\nspecifies the Dapr pub/sub component that the application will use for pub/sub b\", \"ehavior. As you saw \\nin the earlier code snippets, the name of the pub/sub component used is pubsub.\", \" Here\\u2019s the content \\nof the eshop-pubsub.yaml file in the deployment/compose/dapr/components folder:\", \" \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: pubsub \\n  namespace: eshop \\nspec\", \": \\n  type: pubsub.rabbitmq \\n  version: v1 \\n  metadata: \\n  - name: host \\n    value: \\\"amqp://rabbitmq:\", \"5672\\\" \\nThe configuration specifies RabbitMQ as the underlying infrastructure. To change message brok\", \"ers, \\nyou need only to configure a different message broker, such as NATS or Azure Service Bus and u\", \"pdate \\nthe yaml file. With Dapr, there are no changes to your mainline service code when switching m\", \"essage \\nbrokers. \\nYou can also easily use multiple message brokers in a single application. Many tim\", \"es a system will \\nhandle workloads with different characteristics. One event may occur 10 times a da\", \"y, but another \\nevent occurs 5,000 times per second. You may benefit by partitioning messaging traff\", \"ic to different \\nmessage brokers. With Dapr, you can add multiple pub/sub component configurations, \", \"each with a \\ndifferent name. \\nBindings \\neShopOnDapr uses the bindings building block for sending e-m\", \"ails. When a user places an order, the \\napplication sends an order confirmation e-mail using the SMT\", \"P output binding. You can find this \\nbinding in the eshop-email.yaml file in the components folder: \", \"\\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: sendmail \\n  namespace: eshop \\nspe\", \"c: \\n  type: bindings.smtp \\n  version: v1 \\n  metadata: \\n  - name: host \\n    value: maildev \\n  - name:\", \" port \\n    value: 25 \\n  - name: user \\n    secretKeyRef: \\n      name: Smtp.User \\n \\n151 \\nCHAPTER 13 | \", \"Dapr reference application \\n \\n      key: Smtp.User \\n  - name: password \\n    secretKeyRef: \\n      nam\", \"e: Smtp.Password \\n      key: Smtp.Password \\n  - name: skipTLSVerify \\n    value: true \\nauth: \\n  secre\", \"tStore: eshop-secretstore \\nscopes: \\n- ordering-api \\nDapr gets the username and password for connecti\", \"ng to the SMTP server from a secret reference. This \\napproach keeps secrets outside of the configura\", \"tion file. To learn more about Dapr secrets, read the \\nsecrets building block chapter. \\nThe binding \", \"configuration specifies a binding component that can be invoked using the /sendmail \\nendpoint on the\", \" Dapr sidecar. Here\\u2019s a code snippet in which an email is sent whenever an order is \\nstarted: \\npubli\", \"c Task Handle(OrderStartedDomainEvent notification, CancellationToken \\ncancellationToken) \\n{ \\n    va\", \"r message = CreateEmailBody(notification); \\n    var metadata = new Dictionary<string, string> \\n    {\", \" \\n        [\\\"emailFrom\\\"] = \\\"eShopOn@dapr.io\\\", \\n        [\\\"emailTo\\\" = notification.UserName, \\n        [\", \"\\\"subject\\\"] = $\\\"Your eShopOnDapr order #{notification.Order.Id}\\\" \\n    }; \\n    return _daprClient.Invo\", \"keBindingAsync(\\\"sendmail\\\", \\\"create\\\", message, metadata, \\ncancellationToken); \\n} \\n \\n \\npublic Task Sen\", \"dOrderConfirmationAsync(Order order) \\n{ \\n    var message = CreateEmailBody(order); \\n \\n    return _da\", \"prClient.InvokeBindingAsync( \\n        \\\"sendmail\\\", \\n        \\\"create\\\", \\n        CreateEmailBody(order)\", \", \\n        new Dictionary<string, string> \\n        { \\n            [\\\"emailFrom\\\"] = \\\"eshopondapr@examp\", \"le.com\\\", \\n            [\\\"emailTo\\\"] = order.BuyerEmail, \\n            [\\\"subject\\\"] = $\\\"Your eShopOnDapr \", \"Order #{order.OrderNumber}\\\" \\n        }); \\n} \\nAs you can see in this example, message contains the me\", \"ssage body. The CreateEmailBody method \\nsimply formats a string with the body text. The name of the \", \"binding to invoke is sendmail and the \\noperation is create. The metadata specifies the email sender,\", \" recipient, and subject for the email \\nmessage. If these values are static, they can also be include\", \"d in the metadata fields in the \\nconfiguration file. \\n \\n152 \\nCHAPTER 13 | Dapr reference application\", \" \\n \\nActors \\nIn the original eShopOnContainers solution, the Ordering service provides a great exampl\", \"e of how to \\nuse DDD design patterns in a .NET microservice. As the updated eShopOnDapr focuses on D\", \"apr, the \\nOrdering service now uses the actors building block to implement its business logic. \\nThe \", \"ordering process consists of the following steps: \\n1. \\nThe customer submits the order. There\\u2019s a gra\", \"ce period before any further processing occurs. \\nDuring the grace period, the customer can cancel th\", \"e order. \\n2. \\nThe system checks that there\\u2019s available stock. \\n3. \\nThe system processes the payment.\", \" \\n4. \\nThe system ships the order. \\nThe process is implemented using a single OrderingProcessActor ac\", \"tor type. Here\\u2019s the interface for \\nthe actor: \\npublic interface IOrderingProcessActor : IActor \\n{ \\n\", \"    Task SubmitAsync( \\n        string userId, string userName, string street, string city, \\n        \", \"string zipCode, string state, string country, CustomerBasket basket); \\n \\n    Task NotifyStockConfirm\", \"edAsync(); \\n \\n    Task NotifyStockRejectedAsync(List<int> rejectedProductIds); \\n \\n    Task NotifyPay\", \"mentSucceededAsync(); \\n \\n    Task NotifyPaymentFailedAsync(); \\n \\n    Task<bool> CancelAsync(); \\n \\n  \", \"  Task<bool> ShipAsync(); \\n \\n    Task<Order> GetOrderDetailsAsync(); \\n} \\nThe process is started when\", \" a customer checks out some products. Upon checkout, the Basket service \\npublishes a UserCheckoutAcc\", \"eptedIntegrationEvent message using the Dapr pub/sub building \\nblock. The Ordering service handles t\", \"he message in the OrderingProcessEventController class and \\ncalls the SubmitAsync method of the acto\", \"r: \\n[HttpPost(\\\"UserCheckoutAccepted\\\")] \\n[Topic(DaprPubSubName, \\\"UserCheckoutAcceptedIntegrationEvent\", \"\\\")] \\npublic async Task HandleAsync(UserCheckoutAcceptedIntegrationEvent integrationEvent) \\n{ \\n    if\", \" (integrationEvent.RequestId != Guid.Empty) \\n    { \\n        var actorId = new ActorId(integrationEve\", \"nt.RequestId.ToString()); \\n        var orderingProcess = _actorProxyFactory.CreateActorProxy<IOrderi\", \"ngProcessActor>( \\n            actorId, \\n            nameof(OrderingProcessActor)); \\n \\n        await \", \"orderingProcess.SubmitAsync(integrationEvent.UserId, \\nintegrationEvent.UserName, \\n \\n153 \\nCHAPTER 13 \", \"| Dapr reference application \\n \\n            integrationEvent.Street, integrationEvent.City, integrat\", \"ionEvent.ZipCode, \\n            integrationEvent.State, integrationEvent.Country, integrationEvent.Ba\", \"sket); \\n    } \\n    else \\n    { \\n        _logger.LogWarning( \\n            \\\"Invalid IntegrationEvent -\", \" RequestId is missing - {@IntegrationEvent}\\\", \\n            integrationEvent); \\n    } \\n} \\nIn the exam\", \"ple above, the Ordering service first uses the original request ID from the \\nUserCheckoutAcceptedInt\", \"egrationEvent message as the actor ID. The handler uses the ActorId to \\ncreate an actor proxy and in\", \"vokes the SubmitAsync method. The following snippet shows the \\nimplementation of the SubmitAsync met\", \"hod: \\npublic async Task SubmitAsync( \\n    string buyerId, \\n    string buyerEmail, \\n    string street\", \", \\n    string city, \\n    string state, \\n    string country, \\n    CustomerBasket basket) \\n{ \\n    var \", \"orderState = new OrderState \\n    { \\n        OrderDate = DateTime.UtcNow, \\n        OrderStatus = Orde\", \"rStatus.Submitted, \\n        Description = \\\"Submitted\\\", \\n        Address = new OrderAddressState \\n   \", \"     { \\n            Street = street, \\n            City = city, \\n            State = state, \\n        \", \"    Country = country \\n        }, \\n        BuyerId = buyerId, \\n        BuyerEmail = buyerEmail, \\n   \", \"     OrderItems = basket.Items \\n            .Select(item => new OrderItemState \\n            { \\n     \", \"           ProductId = item.ProductId, \\n                ProductName = item.ProductName, \\n           \", \"     UnitPrice = item.UnitPrice, \\n                Units = item.Quantity, \\n                PictureFil\", \"eName = item.PictureFileName \\n            }) \\n            .ToList() \\n    }; \\n \\n    await StateManage\", \"r.SetStateAsync(OrderDetailsStateName, orderState); \\n    await StateManager.SetStateAsync(OrderStatu\", \"sStateName, OrderStatus.Submitted); \\n \\n    await RegisterReminderAsync( \\n        GracePeriodElapsedR\", \"eminder, \\n        null, \\n        TimeSpan.FromSeconds(_settings.Value.GracePeriodTime), \\n        Tim\", \"eSpan.FromMilliseconds(-1)); \\n \\n154 \\nCHAPTER 13 | Dapr reference application \\n \\n \\n    await _eventBu\", \"s.PublishAsync(new OrderStatusChangedToSubmittedIntegrationEvent( \\n        OrderId, \\n        OrderSt\", \"atus.Submitted.Name, \\n        buyerId, \\n        buyerEmail)); \\n} \\nThere\\u2019s a lot going on in the Subm\", \"it method: \\n1. \\nThe method takes the given arguments to create an OrderState object and saves it in \", \"the actor \\nstate. \\n2. \\nThe method saves the current status of the process (OrderStatus.Submitted) in\", \" the actor state. \\n3. \\nThe method registers a reminder to signal the end of the grace period. Order \", \"processing is \\ndelayed until the end of the grace period to deal with customers changing their mind.\", \" \\n4. \\nLastly, the method publishes an OrderStatusChangedToSubmittedIntegrationEvent to notify \\nother\", \" services of the status change. \\nWhen the reminder for the grace period ending fires, the actor runt\", \"ime calls the \\nReceiveReminderAsync method: \\npublic Task ReceiveReminderAsync( \\n    string reminderN\", \"ame, byte[] state, TimeSpan dueTime, TimeSpan period) \\n{ \\n    return reminderName switch \\n    { \\n   \", \"     GracePeriodElapsedReminder => OnGracePeriodElapsedAsync(), \\n        StockConfirmedReminder => O\", \"nStockConfirmedSimulatedWorkDoneAsync(), \\n        StockRejectedReminder => OnStockRejectedSimulatedW\", \"orkDoneAsync( \\n            JsonConvert.DeserializeObject<List<int>>(Encoding.UTF8.GetString(state)))\", \", \\n        PaymentSucceededReminder => OnPaymentSucceededSimulatedWorkDoneAsync(), \\n        PaymentF\", \"ailedReminder => OnPaymentFailedSimulatedWorkDoneAsync(), \\n        _ => Task.CompletedTask \\n    }; \\n\", \"} \\nAs shown in the snippet above, the ReceiveReminderAsync method handles not just the grace period \", \"\\nreminder. The actor also uses reminders to simulate background work and introduce some delays in \\nt\", \"he ordering process. This makes the process easier to follow in the eShopOnDapr UI where \\nnotificati\", \"ons are shown for each status update. The ReceiveReminderAsync method uses the \\nreminder name to det\", \"ermine which method handles the reminder. The grace period reminder is \\nhandled by the OnGracePeriod\", \"ElapsedAsync method: \\npublic async Task OnGracePeriodElapsedAsync() \\n{ \\n    var statusChanged = awai\", \"t TryUpdateOrderStatusAsync( \\n        OrderStatus.Submitted, OrderStatus.AwaitingStockValidation); \\n\", \"    if (statusChanged) \\n    { \\n        var order = await StateManager.GetStateAsync<Order>(OrderDeta\", \"ilsStateName); \\n \\n        await _eventBus.PublishAsync(new \\nOrderStatusChangedToAwaitingStockValidat\", \"ionIntegrationEvent( \\n            OrderId, \\n            OrderStatus.AwaitingStockValidation.Name, \\n \", \"           \\\"Grace period elapsed; waiting for stock validation.\\\", \\n \\n155 \\nCHAPTER 13 | Dapr referenc\", \"e application \\n \\n            order.UserName, \\n            order.OrderItems \\n                .Select(\", \"orderItem => new OrderStockItem(orderItem.ProductId, \\norderItem.Units)))); \\n    } \\n} \\nThe OnGracePer\", \"iodElapsedAsync method first tries to update the order status to the new \\nAwaitingStockValidation st\", \"atus. If that succeeds, it retrieves the order details from state and \\npublishes an OrderStatusChang\", \"edToAwaitingStockValidationIntegrationEvent to inform other \\nservice of the status change. For examp\", \"le, the Category service subscribes to this event to check the \\navailable stock. \\nLet\\u2019s look at the \", \"TryUpdateOrderStatusAsync method to see under which circumstances it may fail to \\nupdate the order s\", \"tatus: \\nprivate async Task<bool> TryUpdateOrderStatusAsync(OrderStatus expectedOrderStatus, \\nOrderSt\", \"atus newOrderStatus) \\n{ \\n    var orderStatus = await \\nStateManager.TryGetStateAsync<OrderStatus>(Ord\", \"erStatusStateName); \\n    if (!orderStatus.HasValue) \\n    { \\n        _logger.LogWarning( \\n           \", \" \\\"Order with Id: {OrderId} cannot be updated because it doesn't exist\\\", \\n            OrderId); \\n \\n  \", \"      return false; \\n    } \\n \\n    if (orderStatus.Value.Id != expectedOrderStatus.Id) \\n    { \\n      \", \"  _logger.LogWarning( \\n            \\\"Order with Id: {OrderId} is in status {Status} instead of expect\", \"ed status \\n{ExpectedStatus}\\\", \\n            OrderId, orderStatus.Value.Name, expectedOrderStatus.Name\", \"); \\n \\n        return false; \\n    } \\n \\n    await StateManager.SetStateAsync(OrderStatusStateName, new\", \"OrderStatus); \\n \\n    return true; \\n} \\nFirst, the TryUpdateOrderStatusAsync method checks whether the\", \"re even is a current order status. If \\nthere isn\\u2019t, the order doesn\\u2019t exist. This is a fail-safe tha\", \"t should not happen with normal application \\nusage. Then, the method checks whether the current orde\", \"r status is the status that we expected. \\nRemember that the ordering process is driven by events usi\", \"ng the Dapr pub/sub building block. Event \\ndelivery uses at-least-once semantics, so a single messag\", \"e could be received multiple times. The order \\nstatus check ensures that even when the same message \", \"is received multiple times, it is only processed \\nonce. \\nThe other steps in the ordering process are\", \" all implemented in a very similar way to the grace period \\nstep. In the next sections, we\\u2019ll look a\", \"t some other aspects of the ordering process, namely \\ncancellation and viewing order details. \\n \\n156\", \" \\nCHAPTER 13 | Dapr reference application \\n \\nOrder cancellation \\nCustomers are allowed to cancel any\", \" order that has not been paid or shipped yet. The \\nOrdersController class handles incoming order can\", \"cellations. It invokes the CancelAsync method on \\nthe OrderingProcessActor instance for the given or\", \"der. \\npublic async Task<bool> CancelAsync() \\n{ \\n    var orderStatus = await \\nStateManager.TryGetStat\", \"eAsync<OrderStatus>(OrderStatusStateName); \\n    if (!orderStatus.HasValue) \\n    { \\n        _logger.L\", \"ogWarning( \\n           \\\"Order with Id: {OrderId} cannot be cancelled because it doesn't exist\\\", \\n   \", \"         OrderId); \\n \\n        return false; \\n    } \\n \\n    if (orderStatus.Value.Id == OrderStatus.Pa\", \"id.Id || orderStatus.Value.Id == \\nOrderStatus.Shipped.Id) \\n    { \\n        _logger.LogWarning( \\n     \", \"      \\\"Order with Id: {OrderId} cannot be cancelled because it's in status {Status}\\\", \\n            O\", \"rderId, orderStatus.Value.Name); \\n \\n        return false; \\n    } \\n \\n    await StateManager.SetStateA\", \"sync(OrderStatusStateName, OrderStatus.Cancelled); \\n \\n    var order = await StateManager.GetStateAsy\", \"nc<Order>(OrderDetailsStateName); \\n \\n    await _eventBus.PublishAsync(new OrderStatusChangedToCancel\", \"ledIntegrationEvent( \\n        OrderId, \\n        OrderStatus.Cancelled.Name, \\n        $\\\"The order was\", \" cancelled by buyer.\\\", \\n        order.UserName)); \\n \\n    return true; \\n} \\nThe CancelAsync method con\", \"sists of the following steps: \\n1. \\nFirst, the method ensures that the order exists by retrieving the\", \" current order status. \\n2. \\nIf the order exists, the method checks whether it\\u2019s eligible for cancell\", \"ation. Any order not in the \\nPaid or Shipped state can be cancelled. \\n3. \\nIf the order can be cancel\", \"led, the order status is changed to Cancelled. \\n4. \\nLastly, the order details are retrieved from sta\", \"te and used to publish an \\nOrderStatusChangedToCancelledIntegrationEvent to inform the other service\", \"s. \\nThe CancelAsync method is a great example of the usefulness of the turn-based access model of \\na\", \"ctors. Nowhere in the method do we need to worry about multiple threads running at the same time. \\nT\", \"herefore, the method does not require any explicit locking mechanisms to be correct. \\n \\n157 \\nCHAPTER\", \" 13 | Dapr reference application \\n \\nOrder details \\nCustomers can check the status and details of the\", \"ir order in the eShopOnDapr UI. They can also view \\na complete history of past orders. Directly quer\", \"ying actor instances for this information is a bad idea \\nbecause of two reasons: \\n1. \\nLow-latency re\", \"ads cannot be guaranteed because actor operations execute serially. \\n2. \\nQuerying across actors is i\", \"nefficient because each actor\\u2019s state needs to be read individually and \\ncan introduce more unpredic\", \"table latencies. \\nTo fix this issue, eShopOnDapr uses a separate read model for any queries on order\", \" data. The read \\nmodel is stored in a separate SQL database. An ASP.NET Core controller class named \", \"\\nUpdateOrderStatusEventController subscribes to the order status events and builds up the view \\nmode\", \"l. The same UpdateOrderStatusEventController class also sends push notifications to the UI \\nto infor\", \"m the customer of order status updates. \\nThe following snippet shows the code for handling the \\nOrde\", \"rStatusChangedToSubmittedIntegrationEvent message: \\n[HttpPost(\\\"OrderStatusChangedToSubmitted\\\")] \\n[To\", \"pic(DaprPubSubName, nameof(OrderStatusChangedToSubmittedIntegrationEvent))] \\npublic async Task Handl\", \"eAsync( \\n    OrderStatusChangedToSubmittedIntegrationEvent integrationEvent, \\n    [FromServices] IOp\", \"tions<OrderingSettings> settings, \\n    [FromServices] IEmailService emailService) \\n{ \\n    // Gets th\", \"e order details from Actor state. \\n    var actorId = new ActorId(integrationEvent.OrderId.ToString()\", \"); \\n    var orderingProcess = _actorProxyFactory.CreateActorProxy<IOrderingProcessActor>( \\n        a\", \"ctorId, \\n        nameof(OrderingProcessActor)); \\n    // \\n    var actorOrder = await orderingProcess.\", \"GetOrderDetailsAsync(); \\n    var readModelOrder = new Order(integrationEvent.OrderId, actorOrder); \\n\", \" \\n    // Add the order to the read model so it can be queried from the API. \\n    // It may already e\", \"xist if this event has been handled before (at-least-once \\nsemantics). \\n    readModelOrder = await _\", \"orderRepository.AddOrGetOrderAsync(readModelOrder); \\n \\n    // Send a SignalR notification to the cli\", \"ent. \\n    await SendNotificationAsync(readModelOrder.OrderNumber, integrationEvent.OrderStatus, \\n   \", \"     integrationEvent.BuyerId); \\n \\n    // Send a confirmation e-mail if enabled. \\n    if (settings.V\", \"alue.SendConfirmationEmail) \\n    { \\n        await emailService.SendOrderConfirmationAsync(readModelO\", \"rder); \\n    } \\n} \\nThe handler contains the code for all the actions that must occur after an order i\", \"s submitted \\nsuccessfully. Because the events originate from the OrderingProcessActor, we can be sur\", \"e that any \\nvalidations performed by the actor have succeeded. \\nThe handler performs the following s\", \"teps: \\n \\n158 \\nCHAPTER 13 | Dapr reference application \\n \\n1. \\nFirst, the method creates an actor prox\", \"y and uses it to retrieve the order details from the actor \\ninstance. \\n2. \\nThe method maps the order\", \" details to the read model and stores it in the database. Due to the \\nat-least-once semantics of the\", \" Dapr pub/sub building block, the order may already exist in the \\ndatabase. In that case, it will no\", \"t be overwritten. \\n3. \\nThe method publishes a push notification for the status update using SignalR.\", \" \\n4. \\nLastly, if enabled, the method sends a confirmation e-mail to the customer. \\nSubsequent order \", \"status updates are all handled equally to each other. The following snippet shows \\nwhat happens when\", \" the order status is updated to AwaitingStockValidation: \\n[HttpPost(\\\"OrderStatusChangedToAwaitingSto\", \"ckValidation\\\")] \\n[Topic(DaprPubSubName, \\nnameof(OrderStatusChangedToAwaitingStockValidationIntegrati\", \"onEvent))] \\npublic Task HandleAsync( \\n    OrderStatusChangedToAwaitingStockValidationIntegrationEven\", \"t integrationEvent) \\n{ \\n    // Save the updated status in the read model and notify the client via S\", \"ignalR. \\n    return UpdateReadModelAndSendNotificationAsync(integrationEvent.OrderId, \\n        integ\", \"rationEvent.OrderStatus, integrationEvent.Description, \\nintegrationEvent.BuyerId); \\n} \\n \\nprivate asy\", \"nc Task UpdateReadModelAndSendNotificationAsync( \\n    Guid orderId, string orderStatus, string descr\", \"iption, string buyerId) \\n{ \\n    var order = await _orderRepository.GetOrderByIdAsync(orderId); \\n    \", \"if (order is not null) \\n    { \\n        order.OrderStatus = orderStatus; \\n        order.Description =\", \" description; \\n \\n        await _orderRepository.UpdateOrderAsync(order); \\n        await SendNotifica\", \"tionAsync(order.OrderNumber, orderStatus, buyerId); \\n    } \\n} \\nIn the snippet, the handler calls the\", \" UpdateReadModelAndSendNotificationAsync helper method to \\nhandle the status update: \\n1. \\nThe helper\", \" method first loads the current order from the database. \\n2. \\nIf that succeeds, it updates the Order\", \"Status and Description fields and saves the updated \\nmodel back to the database. \\n3. \\nLastly, it sen\", \"ds a push notification to notify the client UI. \\nObservability \\neShopOnDapr uses Zipkin to visualize\", \" distributed traces collected by Dapr. Seq aggregates the \\neShopOnDapr application logs. The various\", \" services emit structured logging using the SeriLog logging \\nlibrary. Serilog publishes log events t\", \"o a construct called a sink. A sink is simply a target platform to \\nwhich Serilog writes its logging\", \" events. Many Serilog sinks are available, including one for Seq. Seq is \\nthe Serilog sink used in e\", \"ShopOnDapr. \\n \\n159 \\nCHAPTER 13 | Dapr reference application \\n \\neShopOnDapr also includes a custom he\", \"alth dashboard that gives insight into the health of the eShop \\nservices. This dashboard uses the bu\", \"ilt-in health checks mechanism of ASP.NET Core. The dashboard \\nnot only provides the health status o\", \"f the services, but also the health of the dependencies of the \\nservices, including the Dapr sidecar\", \"s. \\nSecrets \\nThe eShopOnDapr reference application uses the secrets building block for various secre\", \"ts: \\n\\u2022 \\nThe password for connecting to the Redis cache. \\n\\u2022 \\nThe username and password for the SMTP s\", \"erver. \\n\\u2022 \\nThe connection strings for the SQL databases. \\nWhen running the application using Docker \", \"Compose, the local file secret store is used. The \\ncomponent configuration file eshop-secretstore.ya\", \"ml is found in the dapr/components folder of \\nthe eShopOnDapr repository: \\napiVersion: dapr.io/v1alp\", \"ha1 \\nkind: Component \\nmetadata: \\n  name: eshop-secretstore \\n  namespace: eshop \\nspec: \\n  type: secre\", \"tstores.local.file \\n  version: v1 \\n  metadata: \\n  - name: secretsFile \\n    value: ./components/eshop\", \"-secretstore.json \\n  - name: nestedSeparator \\n    value: \\\".\\\" \\nThe configuration file references the \", \"local store file eshop-secretstore.json located in the same \\nfolder: \\n{ \\n  \\\"ConnectionStrings\\\": { \\n \", \"   \\\"CatalogDB\\\": \\\"**********\\\", \\n    \\\"IdentityDB\\\": \\\"**********\\\", \\n    \\\"OrderingDB\\\": \\\"**********\\\" \\n  },\", \" \\n  \\\"Smtp\\\": { \\n    \\\"User\\\": \\\"**********\\\", \\n    \\\"Password\\\": \\\"**********\\\" \\n  }, \\n  \\\"State\\\": { \\n    \\\"Red\", \"isPassword\\\": \\\"**********\\\" \\n  } \\n} \\nThe components folder is specified in the command-line and mounte\", \"d as a local folder inside the Dapr \\nsidecar container. Here\\u2019s a snippet from the docker-compose.ove\", \"rride.yml file in the repository root \\nthat specifies the volume mount: \\ncatalog-api-dapr: \\n  comman\", \"d: [\\\"./daprd\\\", \\n \\n160 \\nCHAPTER 13 | Dapr reference application \\n \\n    \\\"-app-id\\\", \\\"catalog-api\\\", \\n   \", \" \\\"-app-port\\\", \\\"80\\\", \\n    \\\"-components-path\\\", \\\"/components\\\", \\n    \\\"-config\\\", \\\"/configuration/eshop-co\", \"nfig.yaml\\\" \\n    ] \\n  volumes: \\n    - \\\"./dapr/components/:/components\\\" \\n    - \\\"./dapr/configuration/:\", \"/configuration\\\" \\nThe /components volume mount and --components-path command-line argument are passed\", \" into \\nthe daprd startup command. \\nOnce configured, other component configuration files can also ref\", \"erence the secrets. Here\\u2019s an \\nexample of the state store component configuration consuming secrets:\", \" \\napiVersion: dapr.io/v1alpha1 \\nkind: Component \\nmetadata: \\n  name: eshop-statestore \\n  namespace: e\", \"shop \\nspec: \\n  type: state.redis \\n  version: v1 \\n  metadata: \\n  - name: redisHost \\n    value: redis:\", \"6379 \\n  - name: redisPassword \\n    secretKeyRef: \\n      name: State.RedisPassword \\n      key: State.\", \"RedisPassword \\n  - name: actorStateStore \\n    value: \\\"true\\\" \\nauth: \\n  secretStore: eshop-secretstore\", \" \\nscopes: \\n- basket-api \\n- ordering-api \\nBenefits of applying Dapr to eShop \\nIn general, the use of \", \"Dapr building blocks adds observability and flexibility to the application: \\n1. \\nObservability: By u\", \"sing the Dapr building blocks, you gain rich distributed tracing for calls \\nbetween services and to \", \"Dapr components without having to write any code. In \\neShopOnContainers, a large amount of custom lo\", \"gging is used to provide insight. \\n2. \\nFlexibility: You can now swap out infrastructure simply by ch\", \"anging a component configuration \\nfile. No code changes are necessary. \\nHere are some more examples \", \"of benefits offered by specific building blocks: \\n\\u2022 \\nService Invocation \\n\\u2013 \\nWith Dapr\\u2019s support for \", \"mTLS, services now communicate through encrypted channels. \\n\\u2013 \\nWhen transient errors occur, service \", \"calls are automatically retried. \\n \\n161 \\nCHAPTER 13 | Dapr reference application \\n \\n\\u2013 \\nAutomatic ser\", \"vice discovery reduces the amount of configuration needed for services to \\nfind each other. \\n\\u2022 \\nPubl\", \"ish/Subscribe \\n\\u2013 \\neShopOnContainers included a large amount of custom code to support both Azure \\nSe\", \"rvice Bus and RabbitMQ. Developers used Azure Service Bus for production and \\nRabbitMQ for local dev\", \"elopment and testing. An IEventBus abstraction layer was \\ncreated to enable swapping between these m\", \"essage brokers. This layer consisted of \\napproximately 700 lines of error-prone code. The updated im\", \"plementation with Dapr \\nrequires only 35 lines of code. That\\u2019s 5% of the original lines of code! Mor\", \"e importantly, \\nthe implementation is straightforward and easy to understand. \\n\\u2013 \\neShopOnDapr uses D\", \"apr\\u2019s rich ASP.NET Core integration to use pub/sub. You add Topic \\nattributes to ASP.NET Core contro\", \"ller methods to subscribe to messages. Therefore, \\nthere\\u2019s no need to write a separate message handl\", \"er loop for each message broker. \\n\\u2013 \\nMessages routed to the service as HTTP calls enable the use of \", \"ASP.NET Core \\nmiddleware to add functionality, without introducing new concepts or SDKs to learn. \\n\\u2022\", \" \\nBindings \\n\\u2013 \\nThe eShopOnContainers solution contained a to-do item for e-mailing an order \\nconfirm\", \"ation to the customer. With Dapr, implementing email notification was as easy as \\nconfiguring a reso\", \"urce binding. \\n\\u2022 \\nActors \\n\\u2013 \\nThe actors building block makes it easy to create long running, statefu\", \"l workflows. \\nThanks to the turn-based access model, there\\u2019s no need for explicit locking mechanisms\", \". \\n\\u2013 \\nThe complexity of the grace period implementation is greatly reduced by using actor \\nreminders\", \" instead of polling on the database. \\nSummary \\nIn this chapter, you\\u2019re introduced to the eShopOnDapr\", \" reference application. It\\u2019s an evolution of the \\nwidely popular eShopOnContainers microservice refe\", \"rence application. eShopOnDapr replaces a large \\namount of custom functionality with Dapr building b\", \"locks and components, dramatically simplifying \\nthe complexities required to build a microservices a\", \"pplication. \\nReferences \\n\\u2022 \\neShopOnDapr \\n\\u2022 \\neShopOnContainers \\n\\u2022 \\n.NET Microservices for Containeriz\", \"ed .NET Applications \\n\\u2022 \\nArchitecting Cloud-Native .NET Apps for Azure \\n \\n162 \\nCHAPTER 14 | Summary \", \"and the road ahead \\n \\nCHAPTER 14 \\nSummary and the road \\nahead \\nWe\\u2019re at the end of our Dapr flight. \", \"The jet plane flying at 20,000 feet from chapter 2 is on final \\napproach and about to land. \\nAs the \", \"plane taxis to the gate, let\\u2019s take a minute to review some important conclusions from this \\nguide: \", \"\\n\\u2022 \\nDapr - Dapr is a Distributed Application Runtime that streamlines how you build distributed \\napp\", \"lications. It exposes an architecture of building blocks and pluggable components. Dapr \\nprovides a \", \"dynamic glue that binds your application with infrastructure capabilities that exist in \\nthe Dapr ru\", \"ntime. Instead of building infrastructure plumbing, you and your team focus on \\ndelivering business \", \"features to customers. \\n\\u2022 \\nOpen source and cross-platform - The native Dapr API can be consumed by a\", \"ny platform that \\nsupports HTTP or gRPC. Dapr also provides language-specific SDKs for popular devel\", \"opment \\nplatforms. Dapr v1.0 supports Go, Python, .NET, Java, PHP, and JavaScript. \\n\\u2022 \\nBuilding bloc\", \"ks - Dapr building blocks encapsulate distributed application functionality. At the \\ntime of this wr\", \"iting, Dapr supports the seven building blocks shown in figure 13-1. \\n \\n163 \\nCHAPTER 14 | Summary an\", \"d the road ahead \\n \\n \\nFigure 13-1. Dapr building blocks. \\n\\u2022 \\nComponents - Dapr components provide th\", \"e concrete implementation for each Dapr building \\nblock capability. They expose a common interface t\", \"hat enables developers to swap out \\ncomponent implementations without changing application code. Fig\", \"ure 13-2 shows the \\nrelationship among components, building blocks, and your service. \\n \\n164 \\nCHAPTE\", \"R 14 | Summary and the road ahead \\n \\n \\nFigure 13-2. Dapr building block integration. \\n\\u2022 \\nSidecars - \", \"Dapr runs alongside your application in a sidecar architecture, either as a separate \\nprocess of a c\", \"ontainer. Your application communicates with the Dapr APIs over HTTP and gRPC. \\nSidecars provide iso\", \"lation and encapsulation as they aren\\u2019t part of the service, but connected to \\nit. Figure 13-3 shows\", \" a sidecar architecture. \\n \\nFigure 13-3. Sidecar architecture. \\n \\n165 \\nCHAPTER 14 | Summary and the \", \"road ahead \\n \\n\\u2022 \\nHosting environments Dapr has cross-platform support and can run in multiple enviro\", \"nments. \\nAt the time of this writing, the environments include a local self-hosted mode and Kubernet\", \"es. \\n\\u2022 \\neShopOnDapr - This book includes an accompanying reference application entitled \\neShopOnDapr\", \". Using a popular e-commerce application domain, the reference application \\ndemonstrates the usage o\", \"f each building block. It\\u2019s an evolution of the widely popular \\neShopOnContainers, released several \", \"years ago. \\nThe road ahead \\nLooking forward, Dapr has the potential to have a profound impact on dis\", \"tributed application \\ndevelopment. What can you expect from the Dapr team and its open-source contri\", \"butors? \\nAt the time of writing, the list of proposed enhancements for Dapr include: \\n\\u2022 \\nFeature enh\", \"ancements to existing building blocks: \\n\\u2013 \\nQuery capabilities in state management enabling you to re\", \"trieve multiple values. \\n\\u2013 \\nTopic filtering in pub/sub enabling you to filter topics based on their \", \"content. \\n\\u2013 \\nAn application tracing API in observability that provides tracing in the application \\nd\", \"irectly without having to bind to specific libraries. \\n\\u2013 \\nBinding and pub/sub support for actors pro\", \"viding event driven capabilities to the actor \\nprogramming model. Bound components will trigger even\", \"ts and messages invoke \\nmethods in the actor. \\n\\u2022 \\nNew building blocks: \\n\\u2013 \\nConfiguration API buildin\", \"g block for reading and writing configuration data. The block \\nwill bind to providers that include A\", \"zure Configuration Manager or GCP Configuration \\nManagement. \\n\\u2013 \\nHttp scale-to-zero autoscale. \\n\\u2013 \\nL\", \"eader election building block to provide singleton instances and locking semantic \\ncapabilities. \\n\\u2013 \", \"\\nTransparent proxying building block for service invocation, enabling you to route \\nmessages based o\", \"n URLs or DNS addresses at the network level. \\n\\u2013 \\nResiliency building block (circuit breakers, bulkh\", \"eads & timeouts). \\n\\u2022 \\nIntegration with frameworks and cloud native technologies. Some examples inclu\", \"de: \\n\\u2013 \\nDjango \\n\\u2013 \\nNodejs \\n\\u2013 \\nExpress \\n\\u2013 \\nKyma \\n\\u2013 \\nMidway \\n\\u2022 \\nNew language SDKs: \\n\\u2013 \\nJavaScript \\n\\u2013 \\n\", \"RUST \\n\\u2013 \\nC++ \\n \\n166 \\nCHAPTER 14 | Summary and the road ahead \\n \\n\\u2022 \\nNew hosting platforms: \\n\\u2013 \\nVMs \\n\\u2013\", \" \\nAzure IoT Edge \\n\\u2013 \\nAzure Stack Edge \\n\\u2013 \\nAzure Service Fabric \\n\\u2022 \\nDeveloper and operator productivi\", \"ty tooling: \\n\\u2013 \\nVS Code extension. \\n\\u2013 \\nRemote Dev Containers for local debugging a DevOps pipeline d\", \"evelopment. \\n\\u2013 \\nDapr operational dashboard enhancements that will provide deeper visibility into the\", \" \\noperational concerns of managing Dapr applications. \\nDapr version 1.0 provides developers with a c\", \"ompelling toolbox for building distributed applications. \\nAs the proposed enhancement list shows, Da\", \"pr is under active development with many new \\ncapabilities to come. Stay tuned to the Dapr site and \", \"Dapr announcement blog for future updates. \\n\"]"