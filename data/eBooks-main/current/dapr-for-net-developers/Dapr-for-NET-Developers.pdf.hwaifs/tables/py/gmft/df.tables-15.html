<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>•</td>
      <td>&lt;daprPort&gt;: the HTTP port that Dapr listens on.</td>
    </tr>
    <tr>
      <th>1</th>
      <td>•</td>
      <td>&lt;actorType&gt;: the actor type.</td>
    </tr>
    <tr>
      <th>2</th>
      <td>•</td>
      <td>&lt;actorId&gt;: the ID of the specific actor to call.</td>
    </tr>
    <tr>
      <th>3</th>
      <td>The</td>
      <td>sidecar manages how, when and where each actor runs, and also routes messages between</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>actors. When an actor hasn’t been used for a period of time, the runtime deactivates the actor and removes it from memory. Any state managed by the actor is persisted and will be available when the</td>
    </tr>
    <tr>
      <th>5</th>
      <td>and</td>
      <td>actor re-activates. Dapr uses an idle timer to determine when an actor can be deactivated. When an operation is called on the actor (either by a method call or a reminder firing), the idle timer is reset the actor instance will remain activated.</td>
    </tr>
    <tr>
      <th>6</th>
      <td>The</td>
      <td>sidecar API is only one part of the equation. The service itself also needs to implement an API specification, because the actual code that you write for the actor will run inside the service itself. Figure 11-1 shows the various API calls between the service and its sidecar:</td>
    </tr>
  </tbody>
</table>