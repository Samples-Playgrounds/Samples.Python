"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\nEDITION v6.0.0 - Updated to ASP.NET Core 6\", \".0 \\nRefer changelog for the book updates and community contributions. \\nThis guide is a general overv\", \"iew for developing and deploying containerized ASP.NET Core \\napplications with Docker, using the Mic\", \"rosoft platform and tools. The guide includes a high-level \\nintroduction to Azure DevOps, for implem\", \"enting CI/CD pipelines, as well as Azure Container Registry \\n(ACR) and Azure Kubernetes Services AKS\", \" for deployment. \\nFor low-level, development-related details you can see the .NET Microservices: Arc\", \"hitecture for \\nContainerized .NET Applications guide and it related reference application eShopOnCon\", \"tainers. \\nCredits \\nAuthor: \\nCesar de la Torre, Sr. PM, .NET product team, Microsoft Corp. \\nAcquisiti\", \"ons Editor: \\nJanine Patrick \\nDevelopmental Editor: \\nBob Russell, Solutions Professional at Microsoft\", \" \\nOctal Publishing, Inc. \\nEditorial Production: \\nDianne Russell \\nOctal Publishing, Inc. \\nCopyeditor:\", \" \\nBob Russell, Solutions Professional at Microsoft \\nParticipants and reviewers: \\nNish Anil, Sr. Prog\", \"ram Manager, .NET team, Microsoft \\nMiguel Veloso, Software Development Engineer at Plain Concepts \\nS\", \"umit Ghosh, Principal Consultant at Neudesic \\nColin Dembovsky, DevOps Practice Lead, Cognizant Micro\", \"soft Business Group \\nCopyright \\nPUBLISHED BY \\nMicrosoft Developer Division, .NET and Visual Studio p\", \"roduct teams \\nA division of Microsoft Corporation \\nOne Microsoft Way \\nRedmond, Washington 98052-6399\", \" \\nCopyright \\u00a9 2022 by Microsoft Corporation \\nAll rights reserved. No part of the contents of this bo\", \"ok may be reproduced or transmitted in any \\nform or by any means without the written permission of t\", \"he publisher. \\nThis book is provided \\u201cas-is\\u201d and expresses the author\\u2019s views and opinions. The view\", \"s, opinions, and \\ninformation expressed in this book, including URL and other Internet website refer\", \"ences, may change \\nwithout notice. \\nSome examples depicted herein are provided for illustration only\", \" and are fictitious. No real association \\nor connection is intended or should be inferred. \\nMicrosof\", \"t and the trademarks listed at https://www.microsoft.com on the \\u201cTrademarks\\u201d webpage are \\ntrademarks\", \" of the Microsoft group of companies. \\nMac and macOS are trademarks of Apple Inc. \\nThe Docker whale \", \"logo is a registered trademark of Docker, Inc. Used by permission. \\nAll other marks and logos are pr\", \"operty of their respective owners. \\n \\ni \\nContents \\n \\nContents \\nOverview of Containers and Docker ...\", \"................................................................................... 1 \\nLearn Docker \", \"....................................................................................................\", \".......................................................................... 2 \\nComparing Docker conta\", \"iners with virtual machines ........................................................................\", \"................... 3 \\nA simple analogy ............................................................\", \"....................................................................................................\", \". 4 \\nLearn Docker specific terminologies ...........................................................\", \"..................................................................... 4 \\nLearn docker containers, im\", \"ages, and registries ...............................................................................\", \".......................... 6 \\nRoad to modern applications based on containers ......................\", \"............................................................................. 8 \\nIntroduction to the\", \" Docker application life cycle ................................................................ 9 \\nC\", \"ontainers as the foundation for DevOps collaboration ...............................................\", \".......................................... 9 \\nChallenges in the application life cycle when using Do\", \"cker. .......................................................................... 10 \\nIntroduction to\", \" a generic end-to-end Docker application life cycle workflow .......................................\", \" 11 \\nBenefits of DevOps for containerized applications .............................................\", \"............................................... 12 \\nIntroduction to the Microsoft platform and tools\", \" for containerized apps ..................... 13 \\nDesigning and developing containerized apps using \", \"Docker and Microsoft Azure ...... 17 \\nDesign Docker applications ...................................\", \"....................................................................................................\", \"....... 17 \\nCommon container design principles .....................................................\", \"...................................................................... 18 \\nContainer equals a proces\", \"s ..................................................................................................\", \"........................................ 18 \\nMonolithic applications ...............................\", \"....................................................................................................\", \"................... 18 \\nMonolithic application deployed as a container .............................\", \".................................................................... 21 \\nPublish a single Docker con\", \"tainer app to Azure App Service ....................................................................\", \".... 21 \\nState and data in Docker applications......................................................\", \".................................................................... 22 \\nService-oriented applicatio\", \"ns .................................................................................................\", \"......................................... 25 \\nOrchestrating microservices and multi-container applic\", \"ations for high scalability and availability.... 25 \\nSoftware platforms for container clustering, or\", \"chestration, and scheduling ........................................... 27 \\nUsing container-based or\", \"chestrators in Azure ...............................................................................\", \"...................... 28 \\nUsing Azure Kubernetes Service ..........................................\", \"...................................................................................... 29 \\nDevelopme\", \"nt environment for Kubernetes ......................................................................\", \"..................................... 30 \\nGet started with Azure Kubernetes Service (AKS) ..........\", \"..................................................................................... 31 \\n \\nii \\nCont\", \"ents \\nDeploy with Helm charts into Kubernetes clusters .............................................\", \"................................................ 31 \\nAdditional resources ..........................\", \"....................................................................................................\", \"......................... 32 \\nUsing Azure Service Fabric ...........................................\", \"................................................................................................ 32 \", \"\\nStateless versus stateful microservices ...........................................................\", \"......................................................... 35 \\nUsing Azure Service Fabric Mesh ......\", \"....................................................................................................\", \"..................... 36 \\nChoosing orchestrators in Azure ..........................................\", \"..................................................................................... 37 \\nDeploy to \", \"Azure Kubernetes Service (AKS) .....................................................................\", \"........................................... 38 \\nCreate the AKS environment in Azure ................\", \"....................................................................................................\", \". 38 \\nCreate the AKS cluster .......................................................................\", \"............................................................................. 38 \\nDevelopment enviro\", \"nment for Docker apps ..............................................................................\", \"............................... 40 \\nDevelopment tools choices: IDE or editor .......................\", \"....................................................................................... 40 \\nLanguage\", \" and framework choices .............................................................................\", \"............................................... 41 \\nInner-loop development workflow for Docker apps \", \".............................................................................................. 41 \\nB\", \"uilding a single app within a Docker container using Visual Studio Code and Docker CLI............. \", \"42 \\nUse Docker Tools in Visual Studio on Windows ...................................................\", \".................................................... 52 \\nConfigure your local environment ..........\", \"....................................................................................................\", \".............. 52 \\nDocker support in Visual Studio .................................................\", \"............................................................................... 52 \\nConfigure Docker\", \" tools .............................................................................................\", \"..................................................... 55 \\nUsing Windows PowerShell commands in a Doc\", \"kerFile to set up Windows Containers (Docker \\nstandard based) ......................................\", \"....................................................................................................\", \"........................... 56 \\nBuild ASP.NET Core applications deployed as Linux containers into an\", \" AKS/Kubernetes orchestrator\\n ......................................................................\", \"....................................................................................................\", \"............................ 57 \\nCreating the ASP.NET Core Project using Visual Studio 2022.........\", \"............................................................... 57 \\nRegister the Solution in an Azur\", \"e Container Registry (ACR) .........................................................................\", \". 66 \\nDocker application DevOps workflow with Microsoft tools ......................................\", \"....... 74 \\nSteps in the outer-loop DevOps workflow for a Docker application .......................\", \"........................................ 75 \\nStep 1: Inner-loop development workflow ...............\", \"............................................................................................. 76 \\nSt\", \"ep 2: Source-Code Control integration and management with Azure DevOps Services and Git 76 \\nStep 3: \", \"Build, CI, Integrate, and Test with Azure DevOps Services/GitHub and Docker ...................... 7\", \"6 \\nStep 4: CD, Deploy ..............................................................................\", \"............................................................................. 83 \\nStep 5: Run and ma\", \"nage ...............................................................................................\", \"................................................ 89 \\nStep 6: Monitor and diagnose ..................\", \"....................................................................................................\", \".............. 89 \\n \\niii \\nContents \\nCreate CI/CD pipelines in Azure DevOps Services for a .NET appli\", \"cation on Containers and \\ndeploying to a Kubernetes cluster ........................................\", \"......................................................................................... 89 \\nRun, m\", \"anage, and monitor Docker production environments ........................................ 93 \\nRun c\", \"omposed and microservices-based applications in production environments ............................\", \"... 93 \\nIntroduction to orchestrators, schedulers, and container clusters ..........................\", \"..................................... 93 \\nManage production Docker environments ....................\", \"............................................................................................ 94 \\nCon\", \"tainer Service and management tools ................................................................\", \"............................................. 94 \\nAzure Service Fabric .............................\", \"....................................................................................................\", \"....................... 95 \\nMonitor containerized application services .............................\", \".................................................................................. 96 \\nAzure Monitor\", \" ...................................................................................................\", \"................................................................ 96 \\nSecurity and backup services...\", \"....................................................................................................\", \"................................ 96 \\nContainerized Docker Application Lifecycle key takeaways ......\", \"....................................... 98 \\n \\n1 \\nCHAPTER 1 | Overview of Containers and Docker \\n \\nCH\", \"APTER 1 \\nOverview of Containers \\nand Docker \\nContainerization is an approach to software development\", \" in which an application or service, its \\ndependencies, and its configuration (abstracted as deploym\", \"ent manifest files) are packaged together as \\na container image. You then can test the containerized\", \" application as a unit and deploy it as a container \\nimage instance to the host operating system (OS\", \"). \\nJust as shipping containers allow goods to be transported by ship, train, or truck regardless of\", \" the \\ncargo inside, software containers act as a standard unit of software deployment that can conta\", \"in \\ndifferent code and dependencies. Containerizing software this way enables developers and IT \\npro\", \"fessionals to deploy them across environments with little or no modification. \\nContainers also isola\", \"te applications from each other on a shared OS. Containerized applications run \\non top of a containe\", \"r host that in turn runs on the OS (Linux or Windows). Containers therefore have a \\nmuch smaller foo\", \"tprint than virtual machine (VM) images. \\nEach container can run a whole web application or a servic\", \"e, as shown in Figure 1-1. In this example, \\nDocker host is a container host, and App1, App2, Svc1, \", \"and Svc2 are containerized applications or \\nservices. \\n \\nFigure 1-1. Multiple containers running on \", \"a container host \\nAnother benefit you can derive from containerization is scalability. You can scale\", \" out quickly by \\ncreating new containers for short-term tasks. From an application point of view, in\", \"stantiating an \\nimage (creating a container) is similar to instantiating a process like a service or\", \" web app. For \\nreliability, however, when you run multiple instances of the same image across multip\", \"le host servers, \\nyou typically want each container (image instance) to run in a different host serv\", \"er or VM in different \\nfault domains. \\nIn short, containers offer the benefits of isolation, portabi\", \"lity, agility, scalability, and control across the \\nentire application lifecycle workflow. The most \", \"important benefit is the environment isolation \\nprovided between Dev and Ops. \\n \\n2 \\nCHAPTER 1 | Over\", \"view of Containers and Docker \\n \\nLearn Docker \\nDocker is an open-source project for automating the d\", \"eployment of applications as portable, self-\\nsufficient containers that can run on the cloud or on-p\", \"remises. Docker is also a company that \\npromotes and evolves this technology, working in collaborati\", \"on with cloud, Linux, and Windows \\nvendors, including Microsoft. \\n \\nFigure 1-2. Docker deploys conta\", \"iners at all layers of the hybrid cloud \\nAs shown in the above diagram, Docker containers can run an\", \"ywhere, on-premises in the customer \\ndatacenter, in an external service provider or in the cloud, on\", \" Azure. Docker image containers can also \\nrun natively on Linux and Windows. However, Windows images\", \" can run only on Windows hosts and \\nLinux images can run on Linux hosts and Windows hosts (using a H\", \"yper-V Linux VM, so far), where \\nhost means a server or a VM. \\nDevelopers can use development enviro\", \"nments on Windows, Linux, or macOS. On the development \\ncomputer, the developer runs a Docker host w\", \"here Docker images are deployed, including the app \\nand its dependencies. Developers who work on Lin\", \"ux or on the Mac, use a Docker host that\\u2019s Linux-\\nbased, and they can only create images for Linux c\", \"ontainers. (Developers working on the Mac can edit \\ncode or run the Docker command-line interface (C\", \"LI) from macOS, but as of this writing, containers \\ndon\\u2019t run directly on macOS.) Developers who wor\", \"k on Windows can create images for either Linux or \\nWindows Containers. \\nTo host containers in devel\", \"opment environments and provide additional developer tools, Docker \\nships Docker Desktop for Windows\", \" or for macOS. These products install the necessary VM (the Docker \\nhost) to host the containers. \\nT\", \"o run Windows Containers, there are two types of runtimes: \\n\\u2022 \\nWindows Server Containers provide app\", \"lication isolation through process and namespace \\nisolation technology. A Windows Server Container s\", \"hares a kernel with the container host and \\nwith all containers running on the host. \\n\\u2022 \\nHyper-V Con\", \"tainers expand on the isolation provided by Windows Server Containers by \\nrunning each container in \", \"a highly optimized virtual machine. In this configuration, the kernel \\nof the container host isn\\u2019t s\", \"hared with the Hyper-V Containers, providing better isolation. \\n \\n3 \\nCHAPTER 1 | Overview of Contain\", \"ers and Docker \\n \\nThe images for these containers are created and work just the same way. The differ\", \"ence is in how the \\ncontainer is created from the image\\u2014running a Hyper-V Container requires an extr\", \"a parameter. For \\ndetails, see Hyper-V Containers. \\nComparing Docker containers with virtual machine\", \"s \\nFigure 1-3 shows a comparison between VMs and Docker containers. \\n \\nFigure 1-3. Comparison of tra\", \"ditional virtual machines to Docker containers \\nAs shown in the above diagram, for VMs, there are th\", \"ree base layers in the host server. From the \\nbottom-up: Infrastructure, Host Operating System, and \", \"a Hypervisor. On top of all that, each VM has \\nits own OS and all necessary libraries. On the other \", \"hand, for Docker, the host server only has the \\nInfrastructure and the OS. On top of that, the conta\", \"iner engine keeps containers isolated, but lets \\nthem share the single base OS\\u2019s services. \\nBecause \", \"containers require far fewer resources (for example, they don\\u2019t need a full OS), they\\u2019re easy to \\nde\", \"ploy and they start fast. This allows you to have higher density, meaning that it allows you to run \", \"\\nmore services on the same hardware unit, thereby reducing costs. \\nAs a side effect of running on th\", \"e same kernel, you get less isolation than VMs. \\nThe main goal of an image is to ensure the same env\", \"ironment (dependencies) across different \\ndeployments. This means that you can debug it on your mach\", \"ine and then deploy it to another \\nmachine, the same environment guaranteed. \\nA container image is a\", \" way to package an app or service and deploy it in a reliable and reproducible \\nway. You could say t\", \"hat Docker isn\\u2019t only a technology but also a philosophy and a process. \\n \\n4 \\nCHAPTER 1 | Overview o\", \"f Containers and Docker \\n \\nWhen using Docker, you won\\u2019t hear developers say, \\u201cIt works on my machine\", \", why not in production?\\u201d \\nThey can just say, \\u201cIt runs on Docker\\u201d, because the packaged Docker appli\", \"cation can be executed on \\nany supported Docker environment, and it runs the way it was intended to \", \"on all deployment targets \\n(such as Dev, QA, staging, and production). \\nA simple analogy \\nPerhaps a \", \"simple analogy can help getting the grasp of the core concept of Docker. \\nLet\\u2019s go back in time to t\", \"he 1950s for a moment. There were no word processors, and the \\nphotocopiers were used everywhere (we\", \"ll, kind of). \\nImagine you\\u2019re responsible for quickly issuing batches of letters as required, to mai\", \"l them to \\ncustomers, using real paper and envelopes, to be delivered physically to each customer\\u2019s \", \"address \\n(there was no email back then). \\nAt some point, you realize the letters are just a composit\", \"ion of a large set of paragraphs, which are \\npicked and arranged as needed, according to the purpose\", \" of the letter, so you devise a system to \\nissue letters quickly, expecting to get a hefty raise. \\nT\", \"he system is simple: \\n1. \\nYou begin with a deck of transparent sheets containing one paragraph each.\", \" \\n2. \\nTo issue a set of letters, you pick the sheets with the paragraphs you need, then you stack an\", \"d \\nalign them so they look and read fine. \\n3. \\nFinally, you place the set in the photocopier and pre\", \"ss start to produce as many letters as \\nrequired. \\nSo, simplifying, that\\u2019s the core idea of Docker. \", \"\\nIn Docker, each layer is the resulting set of changes that happen to the filesystem after executing\", \" a \\ncommand, such as, installing a program. \\nSo, when you \\u201clook\\u201d at the filesystem after the layer h\", \"as been copied, you see all the files, included the \\nlayer when the program was installed. \\nYou can \", \"think of an image as an auxiliary read-only hard disk ready to be installed in a \\u201ccomputer\\u201d \\nwhere t\", \"he operating system is already installed. \\nSimilarly, you can think of a container as the \\u201ccomputer\\u201d\", \" with the image hard disk installed. The \\ncontainer, just like a computer, can be powered on or off.\", \" \\nLearn Docker specific terminologies \\nThis section lists terms and definitions you should be famili\", \"ar with before getting deeper into Docker. \\nFor further definitions, see the extensive glossary prov\", \"ided by Docker. \\nContainer image: A package with all the dependencies and information needed to crea\", \"te a container. \\nAn image includes all the dependencies (such as frameworks) plus deployment and exe\", \"cution \\n \\n5 \\nCHAPTER 1 | Overview of Containers and Docker \\n \\nconfiguration to be used by a containe\", \"r runtime. Usually, an image derives from multiple base images \\nthat are layers stacked on top of ea\", \"ch other to form the container\\u2019s filesystem. An image is immutable \\nonce it has been created. \\nDocke\", \"rfile: A text file that contains instructions for building a Docker image. It\\u2019s like a batch script,\", \" \\nthe first line states the base image to begin with and then follow the instructions to install req\", \"uired \\nprograms, copy files, and so on, until you get the working environment you need. \\nBuild: The \", \"action of building a container image based on the information and context provided by its \\nDockerfil\", \"e, plus additional files in the folder where the image is built. You can build images with the \\nfoll\", \"owing Docker command: \\ndocker build \\nContainer: An instance of a Docker image. A container represent\", \"s the execution of a single \\napplication, process, or service. It consists of the contents of a Dock\", \"er image, an execution \\nenvironment, and a standard set of instructions. When scaling a service, you\", \" create multiple instances \\nof a container from the same image. Or a batch job can create multiple c\", \"ontainers from the same \\nimage, passing different parameters to each instance. \\nVolumes: Offer a wri\", \"table filesystem that the container can use. Since images are read-only but most \\nprograms need to w\", \"rite to the filesystem, volumes add a writable layer, on top of the container image, \\nso the program\", \"s have access to a writable filesystem. The program doesn\\u2019t know it\\u2019s accessing a \\nlayered filesyste\", \"m, it\\u2019s just the filesystem as usual. Volumes live in the host system and are managed \\nby Docker. \\nT\", \"ag: A mark or label you can apply to images so that different images or versions of the same image \\n\", \"(depending on the version number or the target environment) can be identified. \\nMulti-stage Build: I\", \"s a feature, since Docker 17.05 or higher, that helps to reduce the size of the final \\nimages. For e\", \"xample, a large base image, containing the SDK can be used for compiling and \\npublishing and then a \", \"small runtime-only base image can be used to host the application. \\nRepository (repo): A collection \", \"of related Docker images, labeled with a tag that indicates the image \\nversion. Some repos contain m\", \"ultiple variants of a specific image, such as an image containing SDKs \\n(heavier), an image containi\", \"ng only runtimes (lighter), etc. Those variants can be marked with tags. A \\nsingle repo can contain \", \"platform variants, such as a Linux image and a Windows image. \\nRegistry: A service that provides acc\", \"ess to repositories. The default registry for most public images is \\nDocker Hub (owned by Docker as \", \"an organization). A registry usually contains repositories from \\nmultiple teams. Companies often hav\", \"e private registries to store and manage images they\\u2019ve created. \\nAzure Container Registry is anothe\", \"r example. \\nMulti-arch image: For multi-architecture, it\\u2019s a feature that simplifies the selection o\", \"f the appropriate \\nimage, according to the platform where Docker is running. For example, when a Doc\", \"kerfile requests a \\nbase image FROM mcr.microsoft.com/dotnet/sdk:6.0 from the registry, it actually \", \"gets 6.0-\\nnanoserver-20H2, 6.0-nanoserver-1809 or 6.0-bullseye-slim, depending on the operating syst\", \"em \\nand version where Docker is running. \\n \\n6 \\nCHAPTER 1 | Overview of Containers and Docker \\n \\nDock\", \"er Hub: A public registry to upload images and work with them. Docker Hub provides Docker \\nimage hos\", \"ting, public or private registries, build triggers and web hooks, and integration with GitHub \\nand B\", \"itbucket. \\nAzure Container Registry: A public resource for working with Docker images and its compon\", \"ents in \\nAzure. This provides a registry that\\u2019s close to your deployments in Azure and that gives yo\", \"u control \\nover access, making it possible to use your Azure Active Directory groups and permissions\", \". \\nDocker Trusted Registry (DTR): A Docker registry service (from Docker) that can be installed on-\\n\", \"premises so it lives within the organization\\u2019s datacenter and network. It\\u2019s convenient for private \\n\", \"images that should be managed within the enterprise. Docker Trusted Registry is included as part of \", \"\\nthe Docker Datacenter product. \\nDocker Desktop: Development tools for Windows and macOS for buildin\", \"g, running, and testing \\ncontainers locally. Docker Desktop for Windows provides development environ\", \"ments for both Linux \\nand Windows Containers. The Linux Docker host on Windows is based on a Hyper-V\", \" virtual machine. \\nThe host for Windows Containers is directly based on Windows. Docker Desktop for \", \"Mac is based on \\nthe Apple Hypervisor framework and the xhyve hypervisor, which provides a Linux Doc\", \"ker host virtual \\nmachine on macOS. Docker Desktop for Windows and for Mac replaces Docker Toolbox, \", \"which was \\nbased on Oracle VirtualBox. \\nCompose: A command-line tool and YAML file format with metad\", \"ata for defining and running multi-\\ncontainer applications. You define a single application based on\", \" multiple images with one or more \\n.yml files that can override values depending on the environment.\", \" After you\\u2019ve created the definitions, \\nyou can deploy the whole multi-container application with a \", \"single command (docker-compose up) \\nthat creates a container per image on the Docker host. \\nCluster:\", \" A collection of Docker hosts exposed as if it were a single virtual Docker host, so that the \\nappli\", \"cation can scale to multiple instances of the services spread across multiple hosts within the \\nclus\", \"ter. Docker clusters can be created with Kubernetes, Azure Service Fabric, Docker Swarm and \\nMesosph\", \"ere DC/OS. \\nOrchestrator: A tool that simplifies the management of clusters and Docker hosts. Orches\", \"trators \\nenable you to manage their images, containers, and hosts through a command-line interface (\", \"CLI) or a \\ngraphical UI. You can manage container networking, configurations, load balancing, servic\", \"e discovery, \\nhigh availability, Docker host configuration, and more. An orchestrator is responsible\", \" for running, \\ndistributing, scaling, and healing workloads across a collection of nodes. Typically,\", \" orchestrator \\nproducts are the same products that provide cluster infrastructure, like Kubernetes a\", \"nd Azure Service \\nFabric, among other offerings in the market. \\nLearn docker containers, images, and\", \" registries \\nWhen using Docker, you create an app or service and package it and its dependencies int\", \"o a \\ncontainer image. An image is a static representation of the app or service and its configuratio\", \"n and \\ndependencies. \\nTo run the app or service, the app\\u2019s image is instantiated to create a contain\", \"er, which will be running \\non the Docker host. Containers are initially tested in a development envi\", \"ronment or PC. \\n \\n7 \\nCHAPTER 1 | Overview of Containers and Docker \\n \\nYou store images in a registry\", \" that acts as a library of images. You need a registry when deploying to \\nproduction orchestrators. \", \"Docker maintains a public registry via Docker Hub; other vendors provide \\nregistries for different c\", \"ollections of images, including Azure Container Registry. Alternatively, \\nenterprises can have a pri\", \"vate registry on-premises for their own Docker images. \\nFigure 1-4 shows how images and registries i\", \"n Docker relate to other components. It also shows the \\nmultiple registry offerings from vendors. \\n \", \"\\nFigure 1-4. Taxonomy of Docker terms and concepts \\nThe registry is like a bookshelf where images ar\", \"e stored and available to be pulled for building \\ncontainers to run services or web apps. There are \", \"private Docker registries on-premises and on the \\npublic cloud. Docker Hub is a public registry main\", \"tained by Docker, along the Docker Trusted Registry \\nan enterprise-grade solution, Azure offers the \", \"Azure Container Registry. AWS, Google and others also \\nhave container registries. \\nBy putting images\", \" in a registry, you can store static and immutable application bits, including all \\nof their depende\", \"ncies, at a framework level. You then can version and deploy images in multiple \\nenvironments and th\", \"us provide a consistent deployment unit. \\n \\n8 \\nCHAPTER 1 | Overview of Containers and Docker \\n \\nPriv\", \"ate image registries, either hosted on-premises or in the cloud, are recommended when: \\n\\u2022 \\nYour imag\", \"es must not be shared publicly due to confidentiality. \\n\\u2022 \\nYou want to have minimum network latency \", \"between your images and your chosen \\ndeployment environment. For example, if your production environ\", \"ment is Azure, you probably \\nwant to store your images in Azure Container Registry so that network l\", \"atency is minimal. In a \\nsimilar way, if your production environment is on-premises, you might want \", \"to have an on-\\npremises Docker Trusted Registry available within the same local network. \\nRoad to mo\", \"dern applications based on containers \\nYou\\u2019re probably reading this book because you\\u2019re planning the\", \" development of new applications or \\nyou\\u2019re assessing the impact of using Docker, Containers, and ne\", \"w approaches like Microservices in \\nyour company. \\nThe adoption of new development paradigms must be\", \" taken with caution before starting a project, to \\nassess the impact on your dev teams, your budget,\", \" or your infrastructure. \\nMicrosoft has been working on rich guidance, sample applications, and a su\", \"ite of e-books that can \\nhelp you make an informed decision and guide your team through a successful\", \" development, \\ndeployment, and operations of your new applications. \\nThis book belongs to a Microsof\", \"t suite of guides that cover many of the needs and challenges you\\u2019ll \\nface during the process of dev\", \"eloping new modern applications based on containers. \\nYou can find additional Microsoft e-books rela\", \"ted to Docker containers in the list below: \\n\\u2022 \\n.NET Microservices: Architecture for Containerized .\", \"NET Applications \\nhttps://learn.microsoft.com/dotnet/architecture/microservices/ \\n\\u2022 \\nModernize exist\", \"ing .NET applications with Azure cloud and Windows Containers \\nhttps://learn.microsoft.com/dotnet/ar\", \"chitecture/modernize-with-azure-containers/ \\n \\n9 \\nCHAPTER 2 | Introduction to the Docker application\", \" life cycle \\n \\nCHAPTER 2 \\nIntroduction to the Docker \\napplication life cycle \\nThe life cycle of cont\", \"ainerized applications is a journey that begins with the developer. The developer \\nchooses to implem\", \"ent containers and Docker because it eliminates frictions in deployments and IT \\noperations, which u\", \"ltimately helps everyone to be more agile, more productive end-to-end, and faster. \\nContainers as th\", \"e foundation for DevOps \\ncollaboration \\nBy the very nature of the containers and Docker technology, \", \"developers can share their software and \\ndependencies easily with IT operations and production envir\", \"onments while eliminating the typical \\u201cit \\nworks on my machine\\u201d excuse. Containers solve application\", \" conflicts between different environments. \\nIndirectly, containers and Docker bring developers and I\", \"T operations closer together, making it easier \\nfor them to collaborate effectively. Adopting the co\", \"ntainer workflow provides many customers \\nwith the DevOps continuity they\\u2019ve sought but previously h\", \"ad to implement via more complex \\nconfiguration for release and build pipelines. Containers simplify\", \" the build/test/deploy pipelines \\nin DevOps. \\n \\nFigure 2-1. Main workloads per \\u201cpersonas\\u201d in the lif\", \"e cycle for containerized Docker applications \\nWith Docker containers, developers own what\\u2019s within \", \"the container (application and service, and \\ndependencies to frameworks and components) and how the \", \"containers and services behave together \\nas an application composed by a collection of services. The\", \" interdependencies of the multiple \\ncontainers are defined in a docker-compose.yml file, or what cou\", \"ld be called a deployment manifest. \\nMeanwhile, IT operations teams (IT professionals and management\", \") can focus on the management \\n \\n10 \\nCHAPTER 2 | Introduction to the Docker application life cycle \\n\", \" \\nof production environments; infrastructure; scalability; monitoring; and, ultimately, ensuring tha\", \"t the \\napplications are delivering properly for the end users, without having to know the contents o\", \"f the \\nvarious containers. Hence, the name \\u201ccontainer,\\u201d recalling the analogy to real-world shipping\", \" \\ncontainers. Thus, the owners of a container\\u2019s content need not concern themselves with how the \\nco\", \"ntainer will be shipped, and the shipping company transports a container from its point of origin \\nt\", \"o its destination without knowing or caring about the contents. In a similar manner, developers can \", \"\\ncreate and own the contents within a Docker container without the need to concern themselves with \\n\", \"the \\u201ctransport\\u201d mechanisms. \\nIn the pillar on the left side of Figure 2-1, developers write and run \", \"code locally in Docker containers \\nby using Docker for Windows or Mac. They define the operating env\", \"ironment for the code by using a \\nDockerfile that specifies the base operating system to run as well\", \" as the build steps for building their \\ncode into a Docker image. The developers define how one or m\", \"ore images will interoperate using the \\naforementioned docker-compose.yml file deployment manifest. \", \"As they complete their local \\ndevelopment, they push their application code plus the Docker configur\", \"ation files to the code \\nrepository of their choice (that is, Git repository). \\nThe DevOps pillar de\", \"fines the build\\u2013Continuous Integration (CI) pipelines using the Dockerfile \\nprovided in the code rep\", \"ository. The CI system pulls the base container images from the selected \\nDocker registry and builds\", \" the custom Docker images for the application. The images then are \\nvalidated and pushed to the Dock\", \"er registry used for the deployments to multiple environments. \\nIn the pillar on the right, operatio\", \"ns teams manage deployed applications and infrastructure in \\nproduction while monitoring the environ\", \"ment and applications so that they can provide feedback and \\ninsights to the development team about \", \"how the application might be improved. Container apps are \\ntypically run in production using contain\", \"er orchestrators like Kubernetes, where usually Helm charts \\nare used to configure deployment units,\", \" instead of docker-compose files. \\nThe two teams are collaborating through a foundational platform (\", \"Docker containers) that provides \\na separation of concerns as a contract, while greatly improving th\", \"e two teams\\u2019 collaboration in the \\napplication life cycle. The developers own the container contents\", \", its operating environment, and the \\ncontainer interdependencies, whereas the operations teams take\", \" the built images along with the \\nmanifest and runs them in their orchestration system. \\nChallenges \", \"in the application life cycle when using Docker. \\nThere are many reasons that will increase the numb\", \"er of containerized applications in the upcoming \\nyears, and one of these reasons is the creation of\", \" applications based on microservices. \\nDuring the last 15 years, the use of web services has been th\", \"e base of thousands of applications, and \\nprobably, after a few years, you\\u2019ll find the same situatio\", \"n with microservice-based applications \\nrunning on Docker containers. \\nIt is also worth to mention t\", \"hat you can also use Docker containers for monolithic applications and \\nyou still get most of the be\", \"nefits of Docker. Containers are not targeting only microservices. \\nThe use of Docker containerizati\", \"on and microservices causes new challenges in the development \\nprocess of your organizations and the\", \"refore, you need a solid strategy to maintain many containers \\n \\n11 \\nCHAPTER 2 | Introduction to the\", \" Docker application life cycle \\n \\nand microservices running on production systems. Eventually, enter\", \"prise applications will have \\nhundreds or thousands of containers/instances running in production. \\n\", \"These challenges create new demands when using DevOps tools, so you\\u2019ll have to define new \\nprocesses\", \" in your DevOps activities, and find answers for the following type of questions: \\n\\u2022 \\nWhich tools ca\", \"n I use for development, CI/CD, management and operations?? \\n\\u2022 \\nHow can my company manage errors in \", \"containers when running in production? \\n\\u2022 \\nHow can we change pieces of our software in production wi\", \"th minimum downtime? \\n\\u2022 \\nHow can we scale and monitor our production system? \\n\\u2022 \\nHow can we include \", \"the testing and deployment of containers in our release pipeline? \\n\\u2022 \\nHow can we use Open Source too\", \"ls/platforms for containers in Microsoft Azure? \\nIf you can answer all those questions, you\\u2019ll be be\", \"tter prepared to move your applications (existing or \\nnew apps) to Docker containers. \\nIntroduction \", \"to a generic end-to-end Docker application life cycle \\nworkflow \\nFigure 2-2 presents a more detailed\", \" workflow for a Docker application life cycle, focusing in this \\ninstance on specific DevOps activit\", \"ies and assets. \\n \\nFigure 2-2. High-level workflow for the Docker containerized application life cyc\", \"le \\nEverything begins with the developer, who starts writing code in the inner-loop workflow. The in\", \"ner-\\nloop stage is where developers define everything that happens before pushing code into the code\", \" \\nrepository (for example, a source control system such as Git). After it\\u2019s committed, the repositor\", \"y \\ntriggers Continuous Integration (CI) and the rest of the workflow. \\n \\n12 \\nCHAPTER 2 | Introductio\", \"n to the Docker application life cycle \\n \\nThe inner loop consists of typical steps like \\u201ccode,\\u201d \\u201crun\", \",\\u201d \\u201ctest,\\u201d and \\u201cdebug,\\u201d plus the additional steps \\nneeded right before running the app locally. This\", \" is the developer\\u2019s process to run and test the app as \\na Docker container. The inner-loop workflow \", \"will be explained in the sections that follow. \\nTaking a step back to look at the end-to-end workflo\", \"w, the DevOps workflow is more than a \\ntechnology or a tool set, it\\u2019s a mindset that requires cultur\", \"al evolution. It\\u2019s people, processes, and the \\nappropriate tools to make your application life cycle\", \" faster and more predictable. Enterprises that \\nadopt a containerized workflow typically restructure\", \" their organizations to represent people and \\nprocesses that match the containerized workflow. \\nPrac\", \"ticing DevOps can help teams respond faster together to competitive pressures by replacing \\nerror-pr\", \"one manual processes with automation, which results in improved traceability and repeatable \\nworkflo\", \"ws. Organizations also can manage environments more efficiently and realize cost savings with \\na com\", \"bination of on-premises and cloud resources as well as tightly integrated tooling. \\nWhen implementin\", \"g your DevOps workflow for Docker applications, you\\u2019ll see that Docker \\ntechnologies are present in \", \"almost every stage of the workflow, from your development box while \\nworking in the inner loop (code\", \", run, debug), the build-test-CI phase, and, finally, the deployment of \\nthose containers to the sta\", \"ging and production environments. \\nImprovement of quality practices helps to identify defects early \", \"in the development cycle, which \\nreduces the cost of fixing them. By including the environment and d\", \"ependencies in the image and \\nadopting a philosophy of deploying the same image across multiple envi\", \"ronments, you promote a \\ndiscipline of extracting the environment-specific configurations making dep\", \"loyments more reliable. \\nRich data obtained through effective instrumentation (monitoring and diagno\", \"stics) provides insight \\ninto performance issues and user behavior to guide future priorities and in\", \"vestments. \\nDevOps should be considered a journey, not a destination. It should be implemented incre\", \"mentally \\nthrough appropriately scoped projects from which you can demonstrate success, learn, and e\", \"volve. \\nBenefits of DevOps for containerized applications \\nHere are some of the most important benef\", \"its provided by a solid DevOps workflow: \\n\\u2022 \\nDeliver better-quality software, faster and with better\", \" compliance. \\n\\u2022 \\nDrive continuous improvement and adjustments earlier and more economically. \\n\\u2022 \\nInc\", \"rease transparency and collaboration among stakeholders involved in delivering and \\noperating softwa\", \"re. \\n\\u2022 \\nControl costs and utilize provisioned resources more effectively while minimizing security \\n\", \"risks. \\n\\u2022 \\nPlug and play well with many of your existing DevOps investments, including investments i\", \"n \\nopen-source. \\n \\n13 \\nCHAPTER 3 | Introduction to the Microsoft platform and tools for containerize\", \"d apps \\n \\nCHAPTER 3 \\nIntroduction to the \\nMicrosoft platform \\nand tools for containerized \\napps \\nVis\", \"ion: Create an adaptable, enterprise-grade, containerized application life cycle that spans your \\nde\", \"velopment, IT operations, and production management. \\nFigure 3-1 shows the main pillars in the life \", \"cycle of Docker apps classified by the type of work \\ndelivered by multiple teams (app-development, D\", \"evOps infrastructure processes, and IT management \\nand operations). Usually, in the enterprise, the \", \"profiles of \\u201cthe persona\\u201d responsible for each area are \\ndifferent. So are their skills. \\n \\n14 \\nCHAP\", \"TER 3 | Introduction to the Microsoft platform and tools for containerized apps \\n \\n \\nFigure 3-1. Mai\", \"n pillars in the life cycle for containerized Docker applications with Microsoft platform and tools \", \"\\nA containerized Docker life-cycle workflow can be initially prescriptive based on \\u201cby-default produ\", \"ct \\nchoices,\\u201d making it easier for developers to get started faster, but it\\u2019s fundamental that under\", \" the \\nhood there must be an open framework so that it will be a flexible workflow capable of adjusti\", \"ng to \\nthe different contexts from each organization or enterprise. The workflow infrastructure (com\", \"ponents \\nand products) must be flexible enough to cover the environment that each company will have \", \"in the \\nfuture, even being capable of swapping development or DevOps products to others. This flexib\", \"ility, \\nopenness, and the broad choice of technologies in the platform and infrastructure are precis\", \"ely the \\nMicrosoft priorities for containerized Docker applications, as explained in the chapters th\", \"at follow. \\nTable 3-1 demonstrates that the intention of the Azure DevOps for containerized Docker a\", \"pplications \\nis to provide an open DevOps workflow so that you can choose what products to use for e\", \"ach phase \\n(Microsoft or third-party) while providing a simplified workflow that provides \\u201cby-defaul\", \"t-products\\u201d \\nalready connected; thus, you can quickly get started with your enterprise-level DevOps \", \"workflow for \\nDocker apps. \\nTable 3-1. DevOps workflows, open to any technology \\nHost \\nMicrosoft tec\", \"hnologies \\nThird-party (Azure pluggable) \\nPlatform for \\nDocker apps \\n\\u2022 Microsoft Visual Studio and \\n\", \"Visual Studio Code \\n\\u2022 .NET \\n\\u2022 Microsoft Azure Kubernetes \\nService (AKS) \\n\\u2022 Azure Container Registry\\\\\", \" \\n\\u2022 Any code editor (for example, Sublime) \\n\\u2022 Any language (Node.js, Java, Go, etc.) \\n\\u2022 Any orchestr\", \"ator and scheduler \\n\\u2022 Any Docker registry\\\\ \\n \\n15 \\nCHAPTER 3 | Introduction to the Microsoft platform\", \" and tools for containerized apps \\n \\nHost \\nMicrosoft technologies \\nThird-party (Azure pluggable) \\nDe\", \"vOps for \\nDocker apps \\n\\u2022 Azure DevOps Services \\n\\u2022 Microsoft Team Foundation \\nServer \\n\\u2022 GitHub \\n\\u2022 Azu\", \"re Kubernetes Service \\n(AKS)\\\\ \\n\\u2022 GitHub, Git, Subversion, etc. \\n\\u2022 Jenkins, Chef, Puppet, Velocity, C\", \"ircleCI, \\nTravisCI, etc. \\n\\u2022 On-premises Docker Datacenter, Kubernetes, \\nMesos DC/OS, etc.\\\\ \\nManageme\", \"nt \\nand \\nmonitoring \\n\\u2022 Azure Monitor \\n\\u2022 Marathon, Chronos, etc.\\\\ \\nThe Microsoft platform and tools f\", \"or containerized Docker apps, as defined in Table 3-1, comprise the \\nfollowing components: \\n\\u2022 \\nPlatf\", \"orm for Docker Apps development The development of a service, or collection of \\nservices that make u\", \"p an \\u201capp.\\u201d The development platform provides all the work developers \\nrequires prior to pushing the\", \"ir code to a shared code repository. Developing services, \\ndeployed as containers, are similar to th\", \"e development of the same apps or services without \\nDocker. You continue to use your preferred langu\", \"age (.NET, Node.js, Go, etc.) and preferred \\neditor or IDE like Visual Studio or Visual Studio Code.\", \" However, rather than consider Docker a \\ndeployment destination, you develop your services in the Do\", \"cker environment. You build, run, \\ntest, and debug your code in containers locally, providing the de\", \"stination environment at \\ndevelopment time. By providing the destination environment locally, Docker\", \" containers set up \\nwhat will drastically help you improve your DevOps life cycle. Visual Studio and\", \" Visual Studio \\nCode have extensions to integrate Docker containers within your development process.\", \" \\n\\u2022 \\nDevOps for Docker Apps Developers creating Docker applications can use Azure DevOps, \\nGitHub or\", \" any other third-party product, like Jenkins, to build out a comprehensive \\nautomated application li\", \"fe-cycle management (ALM). \\n  \\nWith Azure DevOps and/or GitHub, developers can create container-focu\", \"sed DevOps for a \\nfast, iterative process that covers source-code control from anywhere (Azure DevOp\", \"s-Git, \\nGitHub, any remote Git repository, or Subversion), Continuous Integration (CI), internal uni\", \"t \\ntests, inter-container/service integration tests, Continuous Delivery (CD), and release \\nmanageme\", \"nt (RM). Developers also can automate their Docker application releases into Azure \\nKubernetes Servi\", \"ce (AKS), from development to staging and production environments. \\n\\u2022 \\nManagement and Monitoring IT \", \"can manage and monitor production applications and \\nservices in several ways, integrating both persp\", \"ectives in a consolidated experience. \\n\\u2013 \\nAzure portal Azure Kubernetes Service (AKS) helps you to s\", \"et up and maintain your \\nDocker environments. You can also use other orchestrators to visualize and \", \"configure \\nyour cluster. \\n\\u2013 \\nDocker tools You can manage your container applications using familiar \", \"tools. \\nThere\\u2019s no need to change your existing Docker management practices to move \\ncontainer workl\", \"oads to the cloud. Use the application management tools you\\u2019re \\n \\n16 \\nCHAPTER 3 | Introduction to th\", \"e Microsoft platform and tools for containerized apps \\n \\nalready familiar with and connect via the s\", \"tandard API endpoints for the orchestrator \\nof your choice. You also can use other third-party tools\", \" to manage your Docker \\napplications or even CLI Docker tools. \\n  \\nEven if you\\u2019re familiar with Linu\", \"x commands, you can manage your container \\napplications using Microsoft Windows and PowerShell with \", \"a Linux Subsystem \\ncommand line and the products (Docker, Kubernetes\\u2026) clients running on this Linux\", \" \\nSubsystem capability. You\\u2019ll learn more about using these tools under Linux \\nSubsystem using your \", \"favorite Microsoft Windows OS later in this book. \\n\\u2013 \\nOpen-source tools Because AKS exposes the stan\", \"dard API endpoints for the \\norchestration engine, the most popular tools are compatible with AKS and\", \", in most \\ncases, will work out of the box\\u2014including visualizers, monitoring, command-line \\ntools, a\", \"nd even future tools as they become available. \\n\\u2013 \\nGitHub Advanced Security GitHub Advanced Security\", \" offers a suite of tools for \\nsecuring the software supply chain that can seamlessly integrate secur\", \"ity into the \\ndaily workflow of teams developing containerized applications. \\n\\u2013 \\nAzure Monitor Is Az\", \"ure\\u2019s solution to monitor every angle of your production \\nenvironment. You can monitor production Do\", \"cker applications by just setting up its \\nSDK into your services so that you can get system-generate\", \"d log data from the \\napplications. \\nThus, Microsoft offers a complete foundation for an end-to-end c\", \"ontainerized Docker application life \\ncycle. However, it\\u2019s a collection of products and technologies\", \" that allow you to optionally select and \\nintegrate with existing tools and processes. The flexibili\", \"ty in a broad approach along with the strength \\nin the depth of capabilities place Microsoft in a st\", \"rong position for containerized Docker application \\ndevelopment. \\n \\n17 \\nCHAPTER 4 | Designing and de\", \"veloping containerized apps using Docker and Microsoft Azure \\n \\nCHAPTER 4 \\nDesigning and developing \", \"\\ncontainerized apps using \\nDocker and Microsoft \\nAzure \\nVision: Design and develop scalable solution\", \"s with Docker in mind. \\nThere are many great-fit use cases for containers, not just for microservice\", \"s-oriented architectures, but \\nalso when you simply have regular services or web applications to run\", \" and you want to reduce frictions \\nbetween development and production environment deployments. \\nDesi\", \"gn Docker applications \\nChapter 1 introduced the fundamental concepts regarding containers and Docke\", \"r. That information is \\nthe basic level of information you need to get started. But, enterprise appl\", \"ications can be complex and \\ncomposed of multiple services instead of a single service or container.\", \" For those optional use cases, \\nyou need to know additional approaches to design, such as Service-Or\", \"iented Architecture (SOA) and \\nthe more advanced microservices concepts and container orchestration \", \"concepts. The scope of this \\ndocument is not limited to microservices but to any Docker application \", \"life cycle, therefore, it does \\nnot explore microservices architecture in depth because you can also\", \" use containers and Docker with \\nregular SOA, background tasks or jobs, or even with monolithic appl\", \"ication deployment approaches. \\nMore info To learn more about enterprise applications and microservi\", \"ces architecture in depth, read \\nthe guide NET Microservices: Architecture for Containerized .NET Ap\", \"plications that you can also \\ndownload from https://aka.ms/MicroservicesEbook. \\nHowever, before you \", \"get into the application life cycle and DevOps, it\\u2019s important to know how you\\u2019re \\ngoing to design a\", \"nd construct your application and what are your design choices. \\n \\n18 \\nCHAPTER 4 | Designing and dev\", \"eloping containerized apps using Docker and Microsoft Azure \\n \\nCommon container design principles \\nA\", \"head of getting into the development process there are a few basic concepts worth mentioning with \\nr\", \"egard to how you use containers. \\nContainer equals a process \\nIn the container model, a container re\", \"presents a single process. By defining a container as a process \\nboundary, you begin to create the p\", \"rimitives used to scale, or batch-off, processes. When you run a \\nDocker container, you\\u2019ll see an EN\", \"TRYPOINT definition. This defines the process and the lifetime of \\nthe container. When the process c\", \"ompletes, the container life-cycle ends. There are long-running \\nprocesses, such as web servers, and\", \" short-lived processes, such as batch jobs, which might have \\nbeen implemented as Microsoft Azure We\", \"bJobs. If the process fails, the container ends, and the \\norchestrator takes over. If the orchestrat\", \"or was instructed to keep five instances running and one fails, \\nthe orchestrator will create anothe\", \"r container to replace the failed process. In a batch job, the process \\nis started with parameters. \", \"When the process completes, the work is complete. \\nYou might find a scenario in which you want multi\", \"ple processes running in a single container. In any \\narchitecture document, there\\u2019s never a \\u201cnever,\\u201d\", \" nor is there always an \\u201calways.\\u201d For scenarios requiring \\nmultiple processes, a common pattern is t\", \"o use Supervisor. \\nMonolithic applications \\nIn this scenario, you\\u2019re building a single and monolithi\", \"c web application or service and deploying it as \\na container. Within the application, the structure\", \" might not be monolithic; it might comprise several \\nlibraries, components, or even layers (applicat\", \"ion layer, domain layer, data access layer, etc.). \\nExternally, it\\u2019s a single container, like a sing\", \"le process, single web application, or single service. \\nTo manage this model, you deploy a single co\", \"ntainer to represent the application. To scale it, just add \\na few more copies with a load balancer \", \"in front. The simplicity comes from managing a single \\ndeployment in a single container or virtual m\", \"achine (VM). \\nFollowing the principal that a container does one thing only, and does it in one proce\", \"ss, the \\nmonolithic pattern is in conflict. You can include multiple components/libraries or interna\", \"l layers \\nwithin each container, as illustrated in Figure 4-1. \\n \\n19 \\nCHAPTER 4 | Designing and deve\", \"loping containerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-1. An example of monolithic\", \" application architecture \\nA monolithic app has all or most of its functionality within a single pro\", \"cess or container and it\\u2019s \\ncomponentized in internal layers or libraries. The downside to this appr\", \"oach comes if or when the \\napplication grows, requiring it to scale. If the entire application scale\", \"d, it\\u2019s not really a problem. \\nHowever, in most cases, a few parts of the application are the choke \", \"points that require scaling, \\nwhereas other components are used less. \\nUsing the typical e-commerce \", \"example, what you likely need is to scale the product information \\ncomponent. Many more customers br\", \"owse products than purchase them. More customers use their \\nbasket than use the payment pipeline. Fe\", \"wer customers add comments or view their purchase history. \\nAnd you likely have only a handful of em\", \"ployees, in a single region, that need to manage the content \\nand marketing campaigns. By scaling th\", \"e monolithic design, all of the code is deployed multiple times. \\nIn addition to the \\u201cscale-everythi\", \"ng\\u201d problem, changes to a single component require complete \\nretesting of the entire application as \", \"well as a complete redeployment of all the instances. \\nThe monolithic approach is common, and many o\", \"rganizations are developing with this architectural \\nmethod. Many enjoy good enough results, whereas\", \" others encounter limits. Many designed their \\napplications in this model because the tools and infr\", \"astructure were too difficult to build SOAs, and \\nthey didn\\u2019t see the need\\u2014until the app grew. \\nFrom\", \" an infrastructure perspective, each server can run many applications within the same host and \\nhave\", \" an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2. \\n \\n20 \\nCHAPTER 4\", \" | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-2. A h\", \"ost running multiple apps/containers \\nFinally, from an availability perspective, monolithic applicat\", \"ions must be deployed as a whole; that \\nmeans that in case you must stop and start, all functionalit\", \"y and all users will be affected during the \\ndeployment window. In certain situations, the use of Az\", \"ure and containers can minimize these \\nsituations and reduce the probability of downtime of your app\", \"lication, as you can see in Figure 4-3. \\nYou can deploy monolithic applications in Azure by using de\", \"dicated VMs for each instance. Using \\nAzure VM Scale Sets, you can scale the VMs easily. \\nYou can al\", \"so use Azure App Services to run monolithic applications and easily scale instances without \\nhaving \", \"to manage the VMs. Azure App Services can run single instances of Docker containers, as well, \\nsimpl\", \"ifying the deployment. \\nYou can deploy multiple VMs as Docker hosts and run any number of containers\", \" per VM. Then, by \\nusing an Azure Load Balancer, as illustrated in the Figure 4-3, you can manage sc\", \"aling. \\n \\nFigure 4-3. Multiple hosts scaling out a single Docker application \\nYou can manage the dep\", \"loyment of the hosts themselves via traditional deployment techniques. \\nYou can manage Docker contai\", \"ners from the command line by using commands like docker run and \\ndocker-compose up, and you can als\", \"o automate it in Continuous Delivery (CD) pipelines and deploy \\nto Docker hosts from Azure DevOps Se\", \"rvices, for instance. \\n \\n21 \\nCHAPTER 4 | Designing and developing containerized apps using Docker an\", \"d Microsoft Azure \\n \\nMonolithic application deployed as a container \\nThere are benefits to using con\", \"tainers to manage monolithic deployments. Scaling the instances of \\ncontainers is far faster and eas\", \"ier than deploying additional VMs. \\nDeploying updates as Docker images is far faster and network eff\", \"icient. Docker containers typically \\nstart in seconds, speeding rollouts. Tearing down a Docker cont\", \"ainer is as easy as invoking the docker \\nstop command, typically completing in less than a second. \\n\", \"Because containers are inherently immutable, by design, you never need to worry about corrupted \\nVMs\", \" because an update script forgot to account for some specific configuration or file left on disk. \\nA\", \"lthough monolithic apps can benefit from Docker, we\\u2019re touching on only the tips of the benefits. \\nT\", \"he larger benefits of managing containers come from deploying with container orchestrators that \\nman\", \"age the various instances and life cycle of each container instance. Breaking up the monolithic \\napp\", \"lication into subsystems that can be scaled, developed, and deployed individually is your entry \\npoi\", \"nt into the realm of microservices. \\nTo learn about how to \\u201clift and shift\\u201d monolithic applications \", \"with containers and how you can \\nmodernize your applications, you can read this additional Microsoft\", \" guide, Modernize existing .NET \\napplications with Azure cloud and Windows Containers, which you can\", \" also download as PDF from \\nhttps://aka.ms/LiftAndShiftWithContainersEbook. \\nPublish a single Docker\", \" container app to Azure App Service \\nEither because you want to get a quick validation of a containe\", \"r deployed to Azure or because the \\napp is simply a single-container app, Azure App Services provide\", \"s a great way to provide scalable \\nsingle-container services. \\nUsing Azure App Service is intuitive \", \"and you can get up and running quickly because it provides great \\nGit integration to take your code,\", \" build it in Microsoft Visual Studio, and directly deploy it to Azure. \\nBut, traditionally (with no \", \"Docker), if you needed other capabilities, frameworks, or dependencies that \\naren\\u2019t supported in App\", \" Services, you needed to wait for it until the Azure team updates those \\ndependencies in App Service\", \" or switched to other services like Service Fabric, Cloud Services, or even \\nplain VMs, for which yo\", \"u have further control and can install a required component or framework for \\nyour application. \\nNow\", \", as shown in Figure 4-4, when using Visual Studio 2022, container support in Azure App Service \\ngiv\", \"es you the ability to include whatever you want in your app environment. If you added a \\ndependency \", \"to your app, because you\\u2019re running it in a container, you get the capability of including \\nthose de\", \"pendencies in your Dockerfile or Docker image. \\n \\n22 \\nCHAPTER 4 | Designing and developing container\", \"ized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-4. Publishing a container to Azure App Serv\", \"ice from Visual Studio apps/containers \\nFigure 4-4 also shows that the publish flow pushes an image \", \"through a Container Registry, which can \\nbe the Azure Container Registry (a registry near to your de\", \"ployments in Azure and secured by Azure \\nActive Directory groups and accounts) or any other Docker R\", \"egistry like Docker Hub or on-premises \\nregistries. \\nState and data in Docker applications \\nIn most \", \"cases, you can think of a container as an instance of a process. A process does not maintain \\npersis\", \"tent state. While a container can write to its local storage, assuming that an instance will be \\naro\", \"und indefinitely is like assuming that a single location in memory will be durable. Container \\nimage\", \"s, like processes, should be assumed to have multiple instances and that they will eventually be \\nki\", \"lled; if they\\u2019re managed with a container orchestrator, it should be assumed that they might get \\nmo\", \"ved from one node or VM to another. \\nThe following solutions are used to manage persistent data in D\", \"ocker applications: \\nFrom the Docker host, as Docker Volumes: \\n\\u2022 \\nVolumes are stored in an area of t\", \"he host filesystem that\\u2019s managed by Docker. \\n\\u2022 \\nBind mounts can map to any folder in the host files\", \"ystem, so access can\\u2019t be controlled from \\na Docker process and can pose a security risk as a contai\", \"ner could access sensitive OS folders. \\n \\n23 \\nCHAPTER 4 | Designing and developing containerized app\", \"s using Docker and Microsoft Azure \\n \\n\\u2022 \\ntmpfs mounts are like virtual folders that only exist in th\", \"e host\\u2019s memory and are never \\nwritten to the filesystem. \\nFrom remote storage: \\n\\u2022 \\nAzure Storage pr\", \"ovides geo-distributable storage, providing a good long-term persistence \\nsolution for containers. \\n\", \"\\u2022 \\nRemote relational databases like Azure SQL Database, NoSQL databases like Azure Cosmos \\nDB, or ca\", \"che services like Redis. \\nFrom the Docker container: \\n\\u2022 \\nDocker provides a feature named the overlay\", \" file system. This feature implements a copy-on-\\nwrite task that stores updated information to the r\", \"oot file system of the container. That \\ninformation \\u201clays on top of\\u201d the original image on which the\", \" container is based. If the \\ncontainer is deleted from the system, those changes are lost. Therefore\", \", while it\\u2019s possible to \\nsave the state of a container within its local storage, designing a system\", \" based on this feature \\nwould conflict with the premise of container design, which by default is sta\", \"teless. \\n\\u2022 \\nHowever, Docker Volumes is now the preferred way to handle local data in Docker. If you \", \"\\nneed more information about storage in containers, check on Docker storage drivers and \\nAbout image\", \"s, containers, and storage drivers. \\nThe following provides additional detail about these options. \\n\", \"Volumes are directories mapped from the host OS to directories in containers. When code in the \\ncont\", \"ainer has access to the directory, that access is actually to a directory on the host OS. This \\ndire\", \"ctory is not tied to the lifetime of the container itself, and the directory is managed by Docker an\", \"d \\nisolated from the core functionality of the host machine. Thus, data volumes are designed to pers\", \"ist \\ndata independently of the life of the container. If you delete a container or an image from the\", \" Docker \\nhost, the data persisted in the data volume is not deleted. \\nVolumes can be named or anonym\", \"ous (the default). Named volumes are the evolution of Data \\nVolume Containers and make it easy to sh\", \"are data between containers. Volumes also support \\nvolume drivers that allow you to store data on re\", \"mote hosts, among other options. \\nBind mounts have been available for a long time and allow the mapp\", \"ing of any folder to a mount \\npoint in a container. Bind mounts have more limitations than volumes a\", \"nd some important security \\nissues, so volumes are the recommended option. \\ntmpfs mounts are virtual\", \" folders that live only in the host\\u2019s memory and are never written to the \\nfilesystem. They are fast\", \" and secure but use memory and are only meant for non-persistent data. \\nAs shown in Figure 4-5, regu\", \"lar Docker volumes can be stored outside of the containers themselves \\nbut within the physical bound\", \"aries of the host server or VM. However, Docker containers cannot \\naccess a volume from one host ser\", \"ver or VM to another. In other words, with these volumes, it isn\\u2019t \\npossible to manage data shared b\", \"etween containers that run on different Docker hosts, although it \\ncould be achieved with a volume d\", \"river that supports remote hosts. \\n \\n24 \\nCHAPTER 4 | Designing and developing containerized apps usi\", \"ng Docker and Microsoft Azure \\n \\n \\nFigure 4-5. Volumes and external data sources for container-based\", \" applications \\nIn addition, when Docker containers are managed by an orchestrator, containers might \", \"\\u201cmove\\u201d \\nbetween hosts, depending on the optimizations performed by the cluster. Therefore, it isn\\u2019t \", \"\\nrecommended that you use data volumes for business data. But they are a good mechanism to work \\nwit\", \"h trace files, temporal files, or similar, that will not impact business data consistency. \\nRemote d\", \"ata sources and cache tools like Azure SQL Database, Azure Cosmos DB, or a remote cache \\nlike Redis \", \"can be used in containerized applications the same way they are used when developing \\nwithout contai\", \"ners. This is a proven way to store business application data. \\nAzure Storage. Business data usually\", \" needs to be placed in external resources or databases, like \\nAzure Storage. Azure Storage provides \", \"the following services in the cloud: \\n\\u2022 \\nBlob storage stores unstructured object data. A blob can be\", \" any type of text or binary data, \\nsuch as document or media files (images, audio, and video files).\", \" Blob storage is also referred \\nto as Object storage. \\n\\u2022 \\nFile storage offers shared storage for leg\", \"acy applications using the standard SMB protocol. \\nAzure virtual machines and cloud services can sha\", \"re file data across application components \\nvia mounted shares. On-premises applications can access \", \"file data in a share via the File \\nService REST API. \\n\\u2022 \\nTable storage stores structured datasets. T\", \"able storage is a NoSQL key-attribute data store, \\nwhich allows rapid development and fast access to\", \" large quantities of data. \\nRelational databases and NoSQL databases. There are many choices for ext\", \"ernal databases, from \\nrelational databases like SQL Server, PostgreSQL, Oracle, or NoSQL databases \", \"like Azure Cosmos DB, \\nMongoDB, etc. These databases are not going to be explained as part of this g\", \"uide since they are a \\ndifferent topic altogether. \\n \\n25 \\nCHAPTER 4 | Designing and developing conta\", \"inerized apps using Docker and Microsoft Azure \\n \\nService-oriented applications \\nService-Oriented Ar\", \"chitecture (SOA) was an overused term that meant many different things to \\ndifferent people. But as \", \"a common denominator, SOA means that you structure the architecture of \\nyour application by decompos\", \"ing it into several services (most commonly as HTTP services) that can \\nbe classified in different t\", \"ypes like subsystems or, in other cases, as tiers. \\nToday, you can deploy those services as Docker c\", \"ontainers, which solve deployment-related issues \\nbecause all of the dependencies are included in th\", \"e container image. However, when you need to \\nscale out SOAs, you might encounter challenges if you\\u2019\", \"re deploying based on single instances. This \\nchallenge can be handled using Docker clustering softw\", \"are or an orchestrator. You\\u2019ll get to look at \\norchestrators in greater detail in the next section, \", \"when you explore microservices approaches. \\nDocker containers are useful (but not required) for both\", \" traditional service-oriented architectures and \\nthe more advanced microservices architectures. \\nAt \", \"the end of the day, the container clustering solutions are useful for both a traditional SOA \\narchit\", \"ecture and for a more advanced microservices architecture in which each microservice owns its \\ndata \", \"model. And thanks to multiple databases, you can also scale out the data tier instead of working \\nwi\", \"th monolithic databases shared by the SOA services. However, the discussion about splitting the \\ndat\", \"a is purely about architecture and design. \\nOrchestrating microservices and multi-container \\napplica\", \"tions for high scalability and availability \\nUsing orchestrators for production-ready applications i\", \"s essential if your application is based on \\nmicroservices or split across multiple containers. As i\", \"ntroduced previously, in a microservice-based \\napproach, each microservice owns its model and data s\", \"o that it will be autonomous from a \\ndevelopment and deployment point of view. But even if you have \", \"a more traditional application that\\u2019s \\ncomposed of multiple services (like SOA), you\\u2019ll also have mu\", \"ltiple containers or services comprising a \\nsingle business application that need to be deployed as \", \"a distributed system. These kinds of systems \\nare complex to scale out and manage; therefore, you ab\", \"solutely need an orchestrator if you want to \\nhave a production-ready and scalable multi-container a\", \"pplication. \\nFigure 4-6 illustrates deployment into a cluster of an application composed of multiple\", \" microservices \\n(containers). \\n \\n26 \\nCHAPTER 4 | Designing and developing containerized apps using D\", \"ocker and Microsoft Azure \\n \\n \\nFigure 4-6. A cluster of containers \\nIt looks like a logical approach\", \". But how are you handling load balancing, routing, and orchestrating \\nthese composed applications? \", \"\\nThe Docker CLI meets the needs of managing one container on one host, but it falls short when it \\nc\", \"omes to managing multiple containers deployed on multiple hosts for more complex distributed \\napplic\", \"ations. In most cases, you need a management platform that will automatically start containers, \\nsca\", \"le out containers with multiple instances per image, suspend them, or shut them down when \\nneeded, a\", \"nd ideally also control how they access resources like the network and data storage. \\nTo go beyond t\", \"he management of individual containers or simple composed apps and move toward \\nlarger enterprise ap\", \"plications with microservices, you must turn to orchestration and clustering \\nplatforms. \\nFrom an ar\", \"chitecture and development point of view, if you\\u2019re building large, enterprise, \\nmicroservices-based\", \", applications, it\\u2019s important to understand the following platforms and products \\nthat support adva\", \"nced scenarios: \\n\\u2022 \\nClusters and orchestrators. When you need to scale out applications across many \", \"Docker \\nhosts, such as with a large microservices-based application, it\\u2019s critical to be able to man\", \"age \\nall of those hosts as a single cluster by abstracting the complexity of the underlying platform\", \". \\nThat\\u2019s what the container clusters and orchestrators provide. Examples of orchestrators are \\nAzur\", \"e Service Fabric and Kubernetes. Kubernetes is available in Azure through Azure \\nKubernetes Service.\", \" \\n \\n27 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n\", \"\\u2022 \\nSchedulers. Scheduling means to have the capability for an administrator to launch containers \\nin\", \" a cluster, so schedulers also provide a user interface for doing so. A cluster scheduler has \\nsever\", \"al responsibilities: to use the cluster\\u2019s resources efficiently, to set the constraints \\nprovided by\", \" the user, to efficiently load-balance containers across nodes or hosts, and to be \\nrobust against e\", \"rrors while providing high availability. \\nThe concepts of a cluster and a scheduler are closely rela\", \"ted, so the products provided by different \\nvendors often provide both sets of capabilities. The sec\", \"tion below shows the most important platform \\nand software choices you have for clusters and schedul\", \"ers. These orchestrators are widely offered in \\npublic clouds like Azure. \\nSoftware platforms for co\", \"ntainer clustering, orchestration, and \\nscheduling \\nPlatform \\nComments \\nKubernetes \\n \\nKubernetes is \", \"an open-source product that \\nprovides functionality that ranges from \\ncluster infrastructure and con\", \"tainer \\nscheduling to orchestrating capabilities. It \\nlets you automate deployment, scaling, \\nand op\", \"erations of application containers \\nacross clusters of hosts. \\n \\nKubernetes provides a container-cen\", \"tric \\ninfrastructure that groups application \\ncontainers into logical units for easy \\nmanagement and\", \" discovery. \\n \\nKubernetes is mature in Linux, less mature \\nin Windows. \\nAzure Kubernetes Service (AK\", \"S) \\n \\nAzure Kubernetes Service (AKS) is a \\nmanaged Kubernetes container \\norchestration service in Az\", \"ure that \\nsimplifies Kubernetes cluster\\u2019s \\nmanagement, deployment, and \\noperations. \\n \\n28 \\nCHAPTER 4\", \" | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\nPlatform \\nComment\", \"s \\nAzure Service Fabric \\n \\nService Fabric is a Microsoft microservices \\nplatform for building applic\", \"ations. It\\u2019s an \\norchestrator of services and creates \\nclusters of machines. Service Fabric can \\ndep\", \"loy services as containers or as plain \\nprocesses. It can even mix services in \\nprocesses with servi\", \"ces in containers \\nwithin the same application and cluster. \\n \\nService Fabric clusters can be deploy\", \"ed in \\nAzure, on-premises or in any cloud. \\nHowever, deployment in Azure is \\nsimplified with a manag\", \"ed approach. \\n \\nService Fabric provides additional and \\noptional prescriptive Service Fabric \\nprogra\", \"mming models like stateful services \\nand Reliable Actors. \\n \\nService Fabric is mature in Windows (ye\", \"ars \\nevolving in Windows), less mature in Linux. \\n \\nBoth Linux and Windows containers are \\nsupported\", \" in Service Fabric since 2017. \\nAzure Service Fabric Mesh  \\n | Azure Service Fabric Mesh offers the \", \"same reliability, mission-\\ncritical performance and scale as Service Fabric, but also offers a fully\", \" managed and serverless \\nplatform. You don\\u2019t need to manage a cluster, VMs, storage or networking co\", \"nfiguration. You just \\nfocus on your application\\u2019s development.   Service Fabric Mesh supports both \", \"Windows and Linux \\ncontainers, allowing you to develop with any programming language and framework o\", \"f your choice. \\nAzure Container Apps  \\n | Azure Container Apps is a \\nmanaged serverless container se\", \"rvice for building and deploying modern apps at scale. | \\nUsing container-based orchestrators in Azu\", \"re \\nSeveral cloud vendors offer Docker containers support plus Docker clusters and orchestration sup\", \"port, \\nincluding Azure, Amazon EC2 Container Service, and Google Container Engine. Azure provides Do\", \"cker \\n \\n29 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure\", \" \\n \\ncluster and orchestrator support through Azure Kubernetes Service (AKS), Azure Service Fabric, a\", \"nd \\nAzure Service Fabric Mesh. \\nUsing Azure Kubernetes Service \\nA Kubernetes cluster pools several D\", \"ocker hosts and exposes them as a single virtual Docker host, so \\nyou can deploy multiple containers\", \" into the cluster and scale-out with any number of container \\ninstances. The cluster will handle all\", \" the complex management plumbing, like scalability, health, and \\nso forth. \\nAKS provides a way to si\", \"mplify the creation, configuration, and management of a cluster of virtual \\nmachines in Azure that a\", \"re preconfigured to run containerized applications. Using an optimized \\nconfiguration of popular ope\", \"n-source scheduling and orchestration tools, AKS enables you to use \\nyour existing skills or draw on\", \" a large and growing body of community expertise to deploy and \\nmanage container-based applications \", \"on Microsoft Azure. \\nAzure Kubernetes Service optimizes the configuration of popular Docker clusteri\", \"ng open-source tools \\nand technologies specifically for Azure. You get an open solution that offers \", \"portability for both your \\ncontainers and your application configuration. You select the size, the n\", \"umber of hosts, and the \\norchestrator tools, and AKS handles everything else. \\n \\n30 \\nCHAPTER 4 | Des\", \"igning and developing containerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-7. Kubernete\", \"s cluster\\u2019s simplified structure and topology \\nFigure 4-7 shows the structure of a Kubernetes cluste\", \"r where a master node (VM) controls most of the \\ncoordination of the cluster, and you can deploy con\", \"tainers to the rest of the nodes that are managed \\nas a single pool from an application point of vie\", \"w. This allows you to scale to thousands or even tens \\nof thousands of containers. \\nDevelopment envi\", \"ronment for Kubernetes \\nIn the development environment that Docker announced in July 2018, Kubernete\", \"s can also run in a \\nsingle development machine (Windows 10 or macOS) by just installing Docker Desk\", \"top. You can later \\ndeploy to the cloud (AKS) for further integration tests, as shown in figure 4-8.\", \" \\n \\n31 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n\", \" \\nFigure 4-8. Running Kubernetes in dev machine and the cloud \\nGet started with Azure Kubernetes Ser\", \"vice (AKS) \\nTo begin using AKS, you deploy an AKS cluster from the Azure portal or by using the CLI.\", \" For more \\ninformation on deploying a Kubernetes cluster to Azure, see Deploy an Azure Kubernetes Se\", \"rvice \\n(AKS) cluster. \\nThere are no fees for any of the software installed by default as part of AKS\", \". All default options are \\nimplemented with open-source software. AKS is available for multiple virt\", \"ual machines in Azure. \\nYou\\u2019re charged only for the compute instances you choose, as well as the oth\", \"er underlying \\ninfrastructure resources consumed, such as storage and networking. There are no incre\", \"mental charges \\nfor AKS itself. \\nFor further implementation information on deployment to Kubernetes \", \"based on kubectl and original \\n.yaml files, see Deploy to Azure Kubernetes Service (AKS). \\nDeploy wi\", \"th Helm charts into Kubernetes clusters \\nWhen deploying an application to a Kubernetes cluster, you \", \"can use the original kubectl.exe CLI tool \\nusing deployment files based on the native format (.yaml \", \"files), as already mentioned in the previous \\nsection. However, for more complex Kubernetes applicat\", \"ions such as when deploying complex \\nmicroservice-based applications, it\\u2019s recommended to use Helm. \", \"\\nHelm Charts helps you define, version, install, share, upgrade, or rollback even the most complex \\n\", \"Kubernetes application. Helm is maintained by the Cloud Native Computing Foundation (CNCF) in \\ncolla\", \"boration with Microsoft, Google, Bitnami, and the Helm contributor community. \\nFor further implement\", \"ation information on Helm charts and Kubernetes, see the section called Install \\neShopOnContainers u\", \"sing Helm. \\n \\n32 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft\", \" Azure \\n \\nAdditional resources \\n\\u2022 \\nGetting started with Azure Kubernetes Service (AKS) \\nhttps://lear\", \"n.microsoft.com/azure/aks/kubernetes-walkthrough-portal \\n\\u2022 \\nKubernetes. The official site. \\nhttps://\", \"kubernetes.io/ \\nUsing Azure Service Fabric \\nAzure Service Fabric arose from Microsoft\\u2019s transition f\", \"rom delivering \\u201cbox\\u201d products, which were \\ntypically monolithic in style, to delivering services. Th\", \"e experience of building and operating large \\nservices at scale, such as Azure SQL Database, Azure C\", \"osmos DB, Azure Service Bus, or Cortana\\u2019s \\nBackend, shaped Service Fabric. The platform evolved over\", \" time as more and more services adopted \\nit. Importantly, Service Fabric had to run not only in Azur\", \"e but also in standalone Windows Server \\ndeployments. \\nThe aim of Service Fabric is to solve the har\", \"d problems of building and running a service and utilizing \\ninfrastructure resources efficiently, so\", \" that teams can solve business problems using a microservices \\napproach. \\nService Fabric provides tw\", \"o broad areas to help you build applications that use a microservices \\napproach: \\n\\u2022 \\nA platform that\", \" provides system services to deploy, scale, upgrade, detect, and restart failed \\nservices, discover \", \"service location, manage state, and monitor health. These system services in \\neffect enable many of \", \"the characteristics of microservices described previously. \\n\\u2022 \\nProgramming APIs, or frameworks, to h\", \"elp you build applications as microservices: reliable \\nactors and reliable services. You can choose \", \"any code to build your microservice, but these \\nAPIs make the job more straightforward, and they int\", \"egrate with the platform at a deeper \\nlevel. This way you can get health and diagnostics information\", \", or you can take advantage of \\nreliable state management. \\nService Fabric is agnostic with respect \", \"to how you build your service, and you can use any technology. \\nHowever, it provides built-in progra\", \"mming APIs that make it easier to build microservices. \\nAs shown in Figure 4-10, you can create and \", \"run microservices in Service Fabric either as simple \\nprocesses or as Docker containers. It\\u2019s also p\", \"ossible to mix container-based microservices with \\nprocess-based microservices within the same Servi\", \"ce Fabric cluster. \\n \\n33 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and M\", \"icrosoft Azure \\n \\n \\nFigure 4-10. Deploying microservices as processes or as containers in Azure Serv\", \"ice Fabric \\nIn the first image, you see microservices as processes, where each node runs one process\", \" for each \\nmicroservice. In the second image, you see microservices as containers, where each node r\", \"uns Docker \\nwith several containers, one container per microservice. Service Fabric clusters based o\", \"n Linux and \\nWindows hosts can run Docker Linux containers and Windows Containers, respectively. \\nFo\", \"r up-to-date information about containers support in Azure Service Fabric, see Service Fabric and \\nc\", \"ontainers. \\nService Fabric is a good example of a platform where you can define a different logical \", \"architecture \\n(business microservices or Bounded Contexts) than the physical implementation. For exa\", \"mple, if you \\nimplement Stateful Reliable Services in Azure Service Fabric, which are introduced in \", \"the next section, \\n\\u201cStateless versus stateful microservices,\\u201d you have a business microservice conce\", \"pt with multiple \\nphysical services. \\nAs shown in Figure 4-10, and thinking from a logical/business \", \"microservice perspective, when \\nimplementing a Service Fabric Stateful Reliable Service, you usually\", \" will need to implement two tiers \\nof services. The first is the back-end stateful reliable service,\", \" which handles multiple partitions (each \\npartition is a stateful service). The second is the front-\", \"end service, or Gateway service, in charge of \\nrouting and data aggregation across multiple partitio\", \"ns or stateful service instances. That Gateway \\nservice also handles client-side communication with \", \"retry loops accessing the back-end service. It\\u2019s \\ncalled a Gateway service if you implement your cus\", \"tom service, or alternatively you can also use the \\nout-of-the-box Service Fabric reverse proxy. \\n \\n\", \"34 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n \\nFi\", \"gure 4-11. Business microservice with several stateful service instances and a custom gateway front \", \"end \\nIn any case, when you use Service Fabric Stateful Reliable Services, you also have a logical or\", \" business \\nmicroservice (Bounded Context) that\\u2019s composed of multiple physical services. Each of the\", \"m, the \\nGateway service, and Partition service could be implemented as ASP.NET Web API services, as \", \"shown \\nin Figure 4-11. Service Fabric has prescription to support several stateful reliable services\", \" in containers. \\nIn Service Fabric, you can group and deploy groups of services as a Service Fabric \", \"Application, which is \\nthe unit of packaging and deployment for the orchestrator or cluster. Therefo\", \"re, the Service Fabric \\nApplication could be mapped to this autonomous business and logical microser\", \"vice boundary or \\nBounded Context, as well, so you could deploy these services autonomously. \\nServic\", \"e Fabric and containers \\nWith regard to containers in Service Fabric, you can also deploy services i\", \"n container images within a \\nService Fabric cluster. As Figure 4-12 shows, most of the time there wi\", \"ll only be one container per \\nservice. \\n \\nFigure 4-12. Business microservice with several services (\", \"containers) in Service Fabric \\n \\n35 \\nCHAPTER 4 | Designing and developing containerized apps using D\", \"ocker and Microsoft Azure \\n \\nA Service Fabric application can run several containers accessing an ex\", \"ternal database and the whole \\nset would be the logical boundary of a Business Microservice. However\", \", so-called \\u201csidecar\\u201d containers \\n(two containers that must be deployed together as part of a logica\", \"l service) are also possible in \\nService Fabric. The important thing is that a business microservice\", \" is the logical boundary around \\nseveral cohesive elements. In many cases, it might be a single serv\", \"ice with a single data model, but in \\nsome other cases you might have several physical services as w\", \"ell. \\nNote that you can mix services in processes, and services in containers, in the same Service F\", \"abric \\napplication, as shown in Figure 4-13. \\n \\nFigure 4-13. Business microservice mapped to a Servi\", \"ce Fabric application with containers and stateful services \\nFor more information about container su\", \"pport in Azure Service Fabric, see Service Fabric and \\ncontainers. \\nStateless versus stateful micros\", \"ervices \\nAs mentioned earlier, each microservice (logical Bounded Context) must own its domain model\", \" (data \\nand logic). In the case of stateless microservices, the databases will be external, employin\", \"g relational \\noptions like SQL Server, or NoSQL options like Azure Cosmos DB or MongoDB. \\nBut the se\", \"rvices themselves can also be stateful in Service Fabric, which means that the data resides \\nwithin \", \"the microservice. This data might exist not just on the same server, but within the microservice \\npr\", \"ocess, in memory and persisted on hard drives and replicated to other nodes. Figure 4-14 shows the \\n\", \"different approaches. \\n \\n36 \\nCHAPTER 4 | Designing and developing containerized apps using Docker an\", \"d Microsoft Azure \\n \\n \\nFigure 4-14. Stateless versus stateful microservices \\nIn stateless services, \", \"the state (persistence, database) is kept out of the microservice. In stateful \\nservices, state is k\", \"ept inside the microservice. A stateless approach is perfectly valid and is easier to \\nimplement tha\", \"n stateful microservices, since the approach is similar to traditional and well-known \\npatterns. But\", \" stateless microservices impose latency between the process and data sources. They also \\ninvolve mor\", \"e moving pieces when you\\u2019re trying to improve performance with additional cache and \\nqueues. The res\", \"ult is that you can end up with complex architectures that have too many tiers. \\nIn contrast, statef\", \"ul microservices can excel in advanced scenarios, because there\\u2019s no latency between \\nthe domain log\", \"ic and data. Heavy data processing, gaming back ends, databases as a service, and \\nother low-latency\", \" scenarios all benefit from stateful services, which enable local state for faster access. \\nStateles\", \"s and stateful services are complementary. For instance, as you can see in the right diagram in \\nFig\", \"ure 4-14, a stateful service can be split into multiple partitions. To access those partitions, you \", \"\\nmight need a stateless service acting as a gateway service that knows how to address each partition\", \" \\nbased on partition keys. \\nStateful services do have drawbacks. They impose a high complexity level\", \" to be scaled out. \\nFunctionality that would usually be implemented by external database systems mus\", \"t be addressed for \\ntasks such as data replication across stateful microservices and data partitioni\", \"ng. However, this is one \\nof the areas where an orchestrator like Azure Service Fabric with its stat\", \"eful reliable services can help \\nthe most\\u2014by simplifying the development and lifecycle of stateful m\", \"icroservices using the Reliable \\nServices API and Reliable Actors. \\nOther microservice frameworks th\", \"at allow stateful services, support the Actor pattern, and improve \\nfault tolerance and latency betw\", \"een business logic and data are Microsoft Orleans, from Microsoft \\nResearch, and Akka.NET. Both fram\", \"eworks are currently improving their support for Docker. \\nRemember that Docker containers are themse\", \"lves stateless. If you want to implement a stateful \\nservice, you need one of the additional prescri\", \"ptive and higher-level frameworks noted earlier. \\nUsing Azure Service Fabric Mesh \\nAzure Service Fab\", \"ric Mesh is a fully managed service that enables developers to build and deploy \\nmission critical ap\", \"plications without managing any infrastructure. Use Service Fabric Mesh to build \\nand run secure, di\", \"stributed microservices applications that scale on demand. \\n \\n37 \\nCHAPTER 4 | Designing and developi\", \"ng containerized apps using Docker and Microsoft Azure \\n \\nAs shown in figure 4-15, applications host\", \"ed on Service Fabric Mesh run and scale without you \\nworrying about the infrastructure powering it. \", \"\\n \\nFigure 4-15. Deploying a microservice/containers application to Service Fabric Mesh \\nUnder the co\", \"vers, Service Fabric Mesh consists of clusters of thousands of machines. All cluster \\noperations are\", \" hidden from the developer. You simply need to upload your containers and specify \\nresources you nee\", \"d, availability requirements, and resource limits. Service Fabric Mesh automatically \\nallocates the \", \"infrastructure requested by your application deployment and also handles infrastructure \\nfailures, m\", \"aking sure your applications are highly available. You only need to care about the health \\nand respo\", \"nsiveness of your application, not the infrastructure. \\nFor further information, see the Service Fab\", \"ric Mesh documentation. \\nChoosing orchestrators in Azure \\nThe following table provides guidance on w\", \"hat orchestrator to use depending on workloads and OS \\nfocus. \\n \\nFigure 4-16. Orchestrator selection\", \" in Azure guidance \\n \\n38 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and M\", \"icrosoft Azure \\n \\nDeploy to Azure Kubernetes Service (AKS) \\nYou can interact with AKS using your pre\", \"ferred client operating system (Windows, macOS, or Linux) \\nwith Azure command-line interface (Azure \", \"CLI) installed. For more details, refer Azure CLI \\ndocumentation and Installation guide for the avai\", \"lable environments. \\nCreate the AKS environment in Azure \\nThere are several ways to create the AKS E\", \"nvironment. It can be done by using Azure CLI commands \\nor by using the Azure portal. \\nHere you can \", \"explore some examples using the Azure CLI to create the cluster and the Azure portal to \\nreview the \", \"results. You also need to have Kubectl and Docker in your development machine. \\nCreate the AKS clust\", \"er \\nCreate the AKS cluster using this command (the resource group must exist): \\naz aks create --reso\", \"urce-group explore-docker-aks-rg --name explore-docker-aks --node-\\nvm-size Standard_B2s --node-count\", \" 1 --generate-ssh-keys --location westeurope \\n \\n \\nNote \\nThe --node-vm-size and --node-count paramete\", \"r values are good enough for a sample/dev \\napplication. \\nAfter the creation job finishes, you can se\", \"e: \\n\\u2022 \\nThe AKS cluster created in the initial resource group \\n\\u2022 \\nA new, related resource group, cont\", \"aining the resources related to the AKS cluster, as show in \\nthe following images. \\nThe initial reso\", \"urce group, with the AKS cluster: \\n \\n39 \\nCHAPTER 4 | Designing and developing containerized apps usi\", \"ng Docker and Microsoft Azure \\n \\n \\nFigure 4-17. AKS Resource Group view from Azure. \\nThe AKS cluster\", \" resource group: \\n \\nFigure 4-18. AKS view from Azure. \\nImportant \\nIn general, you shouldn\\u2019t need to \", \"modify the resources in the AKS cluster resource group. For \\nexample, the resource group is deleted \", \"when you delete the AKS cluster. \\nYou can also view the node created using Azure CLI and Kubectl. \\nF\", \"irst, getting the credentials: \\naz aks get-credentials --resource-group explore-docker-aks-rg --name\", \" explore-docker-\\naks \\n \\n40 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and\", \" Microsoft Azure \\n \\n \\nFigure 4-19. aks get-credentials command result. \\nAnd then, getting nodes from\", \" Kubectl: \\nkubectl get nodes \\n \\nFigure 4-20. kubectl get nodes command result. \\nDevelopment environm\", \"ent for Docker apps \\nDevelopment tools choices: IDE or editor \\nNo matter if you prefer a full and po\", \"werful IDE or a lightweight and agile editor, Microsoft has you \\ncovered when it comes to developing\", \" Docker applications. \\nVisual Studio Code and Docker CLI (cross-platform tools for Mac, Linux, and \\n\", \"Windows) \\nIf you prefer a lightweight, cross-platform editor supporting any development language, yo\", \"u can use \\nVisual Studio Code and Docker CLI. These products provide a simple yet robust experience,\", \" which is \\ncritical for streamlining the developer workflow. By installing \\u201cDocker for Mac\\u201d or \\u201cDock\", \"er for \\nWindows\\u201d (development environment), Docker developers can use a single Docker CLI to build a\", \"pps \\nfor both Windows or Linux (runtime environment). Plus, Visual Studio Code supports extensions f\", \"or \\nDocker with IntelliSense for Dockerfiles and shortcut-tasks to run Docker commands from the edit\", \"or. \\nNote \\nTo download Visual Studio Code, go to https://code.visualstudio.com/download. \\nTo downloa\", \"d Docker for Mac and Windows, go to https://www.docker.com/products/docker. \\nVisual Studio with Dock\", \"er Tools (Windows development machine) \\nIt\\u2019s recommended that you use Visual Studio 2022 or later wi\", \"th the built-in Docker Tools enabled. \\nWith Visual Studio, you can develop, run, and validate your a\", \"pplications directly in the chosen Docker \\nenvironment. Press F5 to debug your application (single c\", \"ontainer or multiple containers) directly in a \\nDocker host, or press Ctrl+F5 to edit and refresh yo\", \"ur app without having to rebuild the container. It\\u2019s \\nthe simplest and most powerful choice for Wind\", \"ows developers to create Docker containers for Linux \\nor Windows. \\n \\n41 \\nCHAPTER 4 | Designing and d\", \"eveloping containerized apps using Docker and Microsoft Azure \\n \\nVisual Studio for Mac (Mac developm\", \"ent machine) \\nYou can use Visual Studio for Mac when developing Docker-based applications. Visual St\", \"udio for Mac \\noffers a richer IDE when compared to Visual Studio Code for Mac. \\nLanguage and framewo\", \"rk choices \\nYou can develop Docker applications using Microsoft tools with most modern languages. Th\", \"e \\nfollowing is an initial list, but you\\u2019re not limited to it: \\n\\u2022 \\n.NET and ASP.NET Core \\n\\u2022 \\nNode.js\", \" \\n\\u2022 \\nGo \\n\\u2022 \\nJava \\n\\u2022 \\nRuby \\n\\u2022 \\nPython \\nBasically, you can use any modern language supported by Docker\", \" in Linux or Windows. \\nInner-loop development workflow for Docker apps \\nBefore triggering the outer-\", \"loop workflow spanning the entire DevOps cycle, it all begins on each \\ndeveloper\\u2019s machine, coding t\", \"he app itself, using their preferred languages or platforms, and testing it \\nlocally (Figure 4-21). \", \"But in every case, you\\u2019ll have an important point in common, no matter what \\nlanguage, framework, or\", \" platforms you choose. In this specific workflow, you\\u2019re always developing and \\ntesting Docker conta\", \"iners in no other environments, but locally. \\n \\nFigure 4-21. Inner-loop development context \\nThe con\", \"tainer or instance of a Docker image will contain these components: \\n\\u2022 \\nAn operating system selectio\", \"n (for example, a Linux distribution or Windows) \\n\\u2022 \\nFiles added by the developer (for example, app \", \"binaries) \\n\\u2022 \\nConfiguration (for example, environment settings and dependencies) \\n\\u2022 \\nInstructions fo\", \"r what processes to run by Docker \\nYou can set up the inner-loop development workflow that utilizes \", \"Docker as the process (described in \\nthe next section). Consider that the initial steps to set up th\", \"e environment are not included, because \\nyou only need to do it once. \\n \\n42 \\nCHAPTER 4 | Designing a\", \"nd developing containerized apps using Docker and Microsoft Azure \\n \\nBuilding a single app within a \", \"Docker container using Visual Studio \\nCode and Docker CLI \\nApps are made up from your own services p\", \"lus additional libraries (dependencies). \\nFigure 4-22 shows the basic steps that you usually need to\", \" carry out when building a Docker app, \\nfollowed by detailed descriptions of each step. \\n \\nFigure 4-\", \"22. High-level workflow for the life cycle for Docker containerized applications using Docker CLI \\nS\", \"tep 1: Start coding in Visual Studio Code and create your initial app/service \\nbaseline \\nThe way you\", \" develop your application is similar to the way you do it without Docker. The difference is \\nthat wh\", \"ile developing, you\\u2019re deploying and testing your application or services running within Docker \\ncon\", \"tainers placed in your local environment (like a Linux VM or Windows). \\nSetting up your local enviro\", \"nment \\nWith the latest versions of Docker Desktop for Mac and Windows, it\\u2019s easier than ever to deve\", \"lop \\nDocker applications, and the setup is straightforward. \\nTip \\nFor instructions on setting up Doc\", \"ker Desktop for Windows, go to https://docs.docker.com/docker-\\nfor-windows/. \\nFor instructions on se\", \"tting up Docker Desktop for Mac, go to https://docs.docker.com/docker-for-\\nmac/. \\nIn addition, you\\u2019l\", \"l need a code editor so that you can actually develop your application while using \\nDocker CLI. \\n \\n4\", \"3 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\nMicro\", \"soft provides Visual Studio Code, which is a lightweight code editor that\\u2019s supported on \\nWindows, L\", \"inux, and macOS, and provides IntelliSense with support for many languages (JavaScript, \\n.NET, Go, J\", \"ava, Ruby, Python, and most modern languages), debugging, integration with Git and \\nextensions suppo\", \"rt. This editor is a great fit for macOS and Linux developers. In Windows, you also \\ncan use Visual \", \"Studio. \\nTip \\nFor instructions on installing Visual Studio Code for Windows, Linux, or macOS, go to \", \"\\nhttps://code.visualstudio.com/docs/setup/setup-overview/. \\nFor instructions on setting up Docker fo\", \"r Mac, go to https://docs.docker.com/docker-for-mac/. \\nYou can work with Docker CLI and write your c\", \"ode using any code editor, but using Visual Studio \\nCode with the Docker extension makes it easy to \", \"author Dockerfile and docker-compose.yml files in \\nyour workspace. You can also run tasks and script\", \"s from the Visual Studio Code IDE to execute Docker \\ncommands using the Docker CLI underneath. \\nThe \", \"Docker extension for VS Code provides the following features: \\n\\u2022 \\nAutomatic Dockerfile and docker-co\", \"mpose.yml file generation \\n\\u2022 \\nSyntax highlighting and hover tips for docker-compose.yml and Dockerfi\", \"le files \\n\\u2022 \\nIntelliSense (completions) for Dockerfile and docker-compose.yml files \\n\\u2022 \\nLinting (err\", \"ors and warnings) for Dockerfile files \\n\\u2022 \\nCommand Palette (F1) integration for the most common Dock\", \"er commands \\n\\u2022 \\nExplorer integration for managing Images and Containers \\n\\u2022 \\nDeploy images from Docke\", \"rHub and Azure Container Registries to Azure App Service \\nTo install the Docker extension, press Ctr\", \"l+Shift+P, type ext install, and then run the Install Extension \\ncommand to bring up the Marketplace\", \" extension list. Next, type docker to filter the results, and then \\nselect the Docker Support extens\", \"ion, as depicted in Figure 4-23. \\n \\nFigure 4-23. Installing the Docker Extension in Visual Studio Co\", \"de \\n \\n44 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\", \" \\nStep 2: Create a DockerFile related to an existing image (plain OS or dev \\nenvironments like .NET,\", \" Node.js, and Ruby) \\nYou\\u2019ll need a DockerFile per custom image to be built and per container to be d\", \"eployed. If your app is \\nmade up of single custom service, you\\u2019ll need a single DockerFile. But if y\", \"our app is composed of \\nmultiple services (as in a microservices architecture), you\\u2019ll need one Dock\", \"erfile per service. \\nThe DockerFile is commonly placed in the root folder of your app or service and\", \" contains the required \\ncommands so that Docker knows how to set up and run that app or service. You\", \" can create your \\nDockerFile and add it to your project along with your code (node.js, .NET, etc.), \", \"or, if you\\u2019re new to the \\nenvironment, take a look at the following Tip. \\nTip \\nYou can use the Docke\", \"r extension to guide you when using the Dockerfile and docker-compose.yml \\nfiles related to your Doc\", \"ker containers. Eventually, you\\u2019ll probably write these kinds of files without \\nthis tool, but using\", \" the Docker extension is a good starting point that will accelerate your learning \\ncurve. \\nIn Figure\", \" 4-24, you can see the steps to add the docker files to a project by using the Docker \\nExtension for\", \" VS Code: \\n1. \\nOpen the command palette, type \\u201cdocker\\u201d and select \\u201cAdd Docker Files to Workspace\\u201d. \\n\", \"2. \\nSelect Application Platform (ASP.NET Core) \\n3. \\nSelect Operating System (Linux) \\n4. \\nInclude opt\", \"ional Docker Compose files \\n5. \\nEnter ports to publish (80, 443) \\n6. \\nSelect the project \\n \\n45 \\nCHAP\", \"TER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-2\", \"4. Docker files added using the Add Docker files to Workspace command \\nWhen you add a DockerFile, yo\", \"u specify what base Docker image you\\u2019ll be using (like using FROM \\nmcr.microsoft.com/dotnet/aspnet).\", \" You\\u2019ll usually build your custom image on top of a base image \\nthat you get from any official repos\", \"itory at the Docker Hub registry (like an image for .NET or the one \\nfor Node.js). \\nTip \\nYou\\u2019ll have\", \" to repeat this procedure for every project in your application. However, the extension will \\nask to\", \" overwrite the generated docker-compose file after the first time. You should reply to not \\noverwrit\", \"e it, so the extension creates separate docker-compose files, that you can then merge by \\nhand, prio\", \"r to running docker-compose. \\nUse an existing official Docker image \\nUsing an official repository of\", \" a language stack with a version number ensures that the same language \\nfeatures are available on al\", \"l machines (including development, testing, and production). \\nThe following is a sample DockerFile f\", \"or a .NET container: \\n \\n46 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and\", \" Microsoft Azure \\n \\nFROM mcr.microsoft.com/dotnet/aspnet:6.0 AS base \\nWORKDIR /app \\nEXPOSE 80 \\nEXPOS\", \"E 443 \\n \\nFROM mcr.microsoft.com/dotnet/sdk:6.0 AS build \\nWORKDIR /src \\nCOPY [\\\"src/WebApi/WebApi.cspr\", \"oj\\\", \\\"src/WebApi/\\\"] \\nRUN dotnet restore \\\"src/WebApi/WebApi.csproj\\\" \\nCOPY . . \\nWORKDIR \\\"/src/src/WebA\", \"pi\\\" \\nRUN dotnet build \\\"WebApi.csproj\\\" -c Release -o /app/build \\n \\nFROM build AS publish \\nRUN dotnet \", \"publish \\\"WebApi.csproj\\\" -c Release -o /app/publish \\n \\nFROM base AS final \\nWORKDIR /app \\nCOPY --from=\", \"publish /app/publish . \\nENTRYPOINT [\\\"dotnet\\\", \\\"WebApi.dll\\\"] \\nIn this case, the image is based on ver\", \"sion 6.0 of the official ASP.NET Core Docker image (multi-arch \\nfor Linux and Windows), as per the l\", \"ine FROM mcr.microsoft.com/dotnet/aspnet:6.0. (For more \\ninformation about this topic, see the ASP.N\", \"ET Core Docker Image page and the .NET Docker Image \\npage). \\nIn the DockerFile, you can also instruc\", \"t Docker to listen to the TCP port that you\\u2019ll use at run time \\n(such as port 80 or 443). \\nYou can s\", \"pecify additional configuration settings in the Dockerfile, depending on the language and \\nframework\", \" you\\u2019re using. For instance, the ENTRYPOINT line with [\\\"dotnet\\\", \\\"WebMvcApplication.dll\\\"] \\ntells Doc\", \"ker to run a .NET application. If you\\u2019re using the SDK and the .NET CLI (dotnet CLI) to build \\nand r\", \"un the .NET application, this setting would be different. The key point here is that the \\nENTRYPOINT\", \" line and other settings depend on the language and platform you choose for your \\napplication. \\nTip \", \"\\nFor more information about building Docker images for .NET applications, see \\nhttps://learn.microso\", \"ft.com/dotnet/core/docker/build-container. \\nTo learn more about building your own images, go to \\nhtt\", \"ps://docs.docker.com/engine/tutorials/dockerimages/. \\nUse multi-arch image repositories \\nA single im\", \"age name in a repo can contain platform variants, such as a Linux image and a Windows \\nimage. This f\", \"eature allows vendors like Microsoft (base image creators) to create a single repo to \\ncover multipl\", \"e platforms (that is, Linux and Windows). For example, the dotnet/aspnet repository \\navailable in th\", \"e Docker Hub registry provides support for Linux and Windows Nano Server by using \\nthe same image na\", \"me. \\nPulling the dotnet/aspnet image from a Windows host pulls the Windows variant, whereas pulling \", \"the \\nsame image name from a Linux host pulls the Linux variant. \\n \\n47 \\nCHAPTER 4 | Designing and dev\", \"eloping containerized apps using Docker and Microsoft Azure \\n \\nCreate your base image from scratch \\n\", \"You can create your own Docker base image from scratch as explained in this article from Docker. Thi\", \"s \\nscenario is probably not the best for you if you\\u2019re just starting with Docker, but if you want to\", \" set the \\nspecific bits of your own base image, you can do it. \\nStep 3: Create your custom Docker im\", \"ages embedding your service in it \\nFor each custom service that comprises your app, you\\u2019ll need to c\", \"reate a related image. If your app is \\nmade up of a single service or web app, you\\u2019ll need just a si\", \"ngle image. \\nNote \\nWhen taking into account the \\u201couter-loop DevOps workflow\\u201d, the images will be cre\", \"ated by an \\nautomated build process whenever you push your source code to a Git repository (Continuo\", \"us \\nIntegration), so the images will be created in that global environment from your source code. \\nB\", \"ut before you consider going to that outer-loop route, you need to ensure that the Docker \\napplicati\", \"on is actually working properly so that they don\\u2019t push code that might not work properly to \\nthe so\", \"urce control system (Git, etc.). \\nTherefore, each developer first needs to do the entire inner-loop \", \"process to test locally and continue \\ndeveloping until they want to push a complete feature or chang\", \"e to the source control system. \\nTo create an image in your local environment and using the DockerFi\", \"le, you can use the docker build \\ncommand, as shown in Figure 4-25, because it already tags the imag\", \"e for you and builds the images \\nfor all services in the application with a simple command. \\n \\nFigur\", \"e 4-25. Running docker build \\nOptionally, instead of directly running docker build from the project \", \"folder, you first can generate a \\ndeployable folder with the .NET libraries needed by using the run \", \"dotnet publish command, and then \\nrun docker build. \\nThis example creates a Docker image with the na\", \"me webapi:latest (:latest is a tag, like a specific \\nversion). You can take this step for each custo\", \"m image you need to create for your composed Docker \\n \\n48 \\nCHAPTER 4 | Designing and developing cont\", \"ainerized apps using Docker and Microsoft Azure \\n \\napplication with several containers. However, we\\u2019\", \"ll see in the next section that it\\u2019s easier to do this \\nusing docker-compose. \\nYou can find the exis\", \"ting images in your local repository (your development machine) by using the \\ndocker images command,\", \" as illustrated in Figure 4-26. \\n \\nFigure 4-26. Viewing existing images using docker images \\nStep 4:\", \" Define your services in docker-compose.yml when building a composed \\nDocker app with multiple servi\", \"ces \\nWith the docker-compose.yml file, you can define a set of related services to be deployed as a \", \"\\ncomposed application with the deployment commands explained in the next step section. \\nCreate that \", \"file in your main or root solution folder; it should have content similar to that shown in this \\ndoc\", \"ker-compose.yml file: \\nversion: \\\"3.4\\\" \\n \\nservices: \\n  webapi: \\n    image: webapi \\n    build: \\n      \", \"context: . \\n      dockerfile: src/WebApi/Dockerfile \\n    ports: \\n      - 51080:80 \\n    depends_on: \\n\", \"      - redis \\n    environment: \\n      - ASPNETCORE_ENVIRONMENT=Development \\n      - ASPNETCORE_URLS\", \"=http://+:80 \\n \\n  webapp: \\n    image: webapp \\n    build: \\n      context: . \\n      dockerfile: src/We\", \"bApp/Dockerfile \\n    ports: \\n      - 50080:80 \\n    environment: \\n      - ASPNETCORE_ENVIRONMENT=Deve\", \"lopment \\n      - ASPNETCORE_URLS=http://+:80 \\n      - WebApiBaseAddress=http://webapi \\n \\n  redis: \\n \", \"   image: redis \\nIn this particular case, this file defines three services: the web API service (you\", \"r custom service), a web \\napplication, and the Redis service (a popular cache service). Each service\", \" will be deployed as a \\ncontainer, so you need to use a concrete Docker image for each. For this par\", \"ticular application: \\n \\n49 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and\", \" Microsoft Azure \\n \\n\\u2022 \\nThe web API service is built from the DockerFile in the src/WebApi/Dockerfile\", \" directory. \\n\\u2022 \\nThe host port 51080 is forwarded to the exposed port 80 on the webapi container. \\n\\u2022 \", \"\\nThe web API service depends on the Redis service \\n\\u2022 \\nThe web application accesses the web API servi\", \"ce using the internal address: http://webapi. \\n\\u2022 \\nThe Redis service uses the latest public redis ima\", \"ge pulled from the Docker Hub registry. \\nRedis is a popular cache system for server-side application\", \"s. \\nStep 5: Build and run your Docker app \\nIf your app has only a single container, you just need to\", \" run it by deploying it to your Docker Host \\n(VM or physical server). However, if your app is made u\", \"p of multiple services, you need to compose it, \\ntoo. Let\\u2019s see the different options. \\nOption A: Ru\", \"n a single container or service \\nYou can run the Docker image by using the docker run command, as sh\", \"own here: \\ndocker run -t -d -p 50080:80 webapp:latest \\nFor this particular deployment, we\\u2019ll be redi\", \"recting requests sent to port 50080 on the host to the \\ninternal port 80. \\nOption B: Compose and run\", \" a multiple-container application \\nIn most enterprise scenarios, a Docker application will be compos\", \"ed of multiple services. For these \\ncases, you can run the docker-compose up command (Figure 4-27), \", \"which will use the docker-\\ncompose.yml file that you created previously. Running this command builds\", \" all custom images and \\ndeploys the composed application with all of its related containers. \\n \\n50 \\n\", \"CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n \\nFigure\", \" 4-27. Results of running the \\u201cdocker-compose up\\u201d command \\nAfter you run docker-compose up, you depl\", \"oy your application and its related container(s) into your \\nDocker Host, as illustrated in Figure 4-\", \"28, in the VM representation. \\n \\nFigure 4-28. VM with Docker containers deployed \\nStep 6: Test your \", \"Docker application (locally, in your local CD VM) \\nThis step will vary depending on what your app is\", \" doing. \\nIn a simple .NET Web API \\u201cHello World\\u201d deployed as a single container or service, you\\u2019d jus\", \"t need to \\naccess the service by providing the TCP port specified in the DockerFile. \\nOn the Docker \", \"host, open a browser and navigate to that site; you should see your app/service \\nrunning, as demonst\", \"rated in Figure 4-29. \\n \\n51 \\nCHAPTER 4 | Designing and developing containerized apps using Docker an\", \"d Microsoft Azure \\n \\n \\nFigure 4-29. Testing your Docker application locally by using the browser \\nNo\", \"te that it\\u2019s using port 50080, but internally it\\u2019s being redirected to port 80, because that\\u2019s how i\", \"t \\nwas deployed with docker compose, as explained earlier. \\nYou can test this by using the browser u\", \"sing CURL from the terminal, as depicted in Figure 4-30. \\n \\nFigure 4-30. Testing a Docker applicatio\", \"n locally by using CURL \\nDebugging a container running on Docker \\nVisual Studio Code supports debugg\", \"ing Docker if you\\u2019re using Node.js and other platforms like .NET \\ncontainers. \\n \\n52 \\nCHAPTER 4 | Des\", \"igning and developing containerized apps using Docker and Microsoft Azure \\n \\nYou also can debug .NET\", \" or .NET Framework containers in Docker when using Visual Studio for \\nWindows or Mac, as described i\", \"n the next section. \\nTip \\nTo learn more about debugging Node.js Docker containers, see \\nhttps://lear\", \"n.microsoft.com/archive/blogs/user_ed/visual-studio-code-new-features-13-big-\\ndebugging-updates-rich\", \"-object-hover-conditional-breakpoints-node-js-mono-more. \\nUse Docker Tools in Visual Studio on Windo\", \"ws \\nThe developer workflow when using the Docker Tools included in Visual Studio 2022 version 17.0 a\", \"nd \\nlater, is similar to using Visual Studio Code and Docker CLI (in fact, it\\u2019s based on the same Do\", \"cker CLI), \\nbut it\\u2019s easier to get started, simplifies the process, and provides greater productivit\", \"y for the build, \\nrun, and compose tasks. It can also run and debug your containers via the usual F5\", \" and Ctrl+F5keys \\nfrom Visual Studio. You can even debug a whole solution if its containers are defi\", \"ned in the same \\ndocker-compose.yml file at the solution level. \\nConfigure your local environment \\nW\", \"ith the latest versions of Docker for Windows, it\\u2019s easier than ever to develop Docker applications \", \"\\nbecause the setup is straightforward, as explained in the following references. \\nTip \\nTo learn more\", \" about installing Docker for Windows, go to (https://docs.docker.com/docker-for-\\nwindows/). \\nDocker \", \"support in Visual Studio \\nThere are two levels of Docker support you can add to a project. In ASP.NE\", \"T Core projects, you can \\njust add a Dockerfile file to the project by enabling Docker support. The \", \"next level is container \\norchestration support, which adds a Dockerfile to the project (if it doesn\\u2019\", \"t already exist) and a docker-\\ncompose.yml file at the solution level. Container orchestration suppo\", \"rt, via Docker Compose, is \\navailable in Visual Studio 2022 versions 17.0. Container orchestration s\", \"upport is an opt-in feature in \\nVisual Studio 2022 versions 17.0 or later. Visual Studio 2022 also s\", \"upports Kubernetes/Helm \\ndeployment. \\nThe Add > Docker Support and Add > Container Orchestrator Supp\", \"ort commands are located on \\nthe right-click menu (or context menu) of the project node for an ASP.N\", \"ET Core project in Solution \\nExplorer, as shown in Figure 4-31: \\n \\n53 \\nCHAPTER 4 | Designing and dev\", \"eloping containerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-31. Adding Docker support \", \"to a Visual Studio project \\nAdd Docker support \\nBesides the option to add Docker support to an exist\", \"ing application, as shown in the previous section, \\nyou can also enable Docker support during projec\", \"t creation by selecting Enable Docker Support in \\nthe New ASP.NET Core Web Application dialog box th\", \"at opens after you click OK in the New \\nProject dialog box, as shown in Figure 4-32. \\n \\n54 \\nCHAPTER \", \"4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-32. E\", \"nable Docker support during project creation in Visual Studio \\nWhen you add or enable Docker support\", \", Visual Studio adds a Dockerfile file to the project, that \\nincludes references to all required pro\", \"ject from the solution. \\nAdd container orchestration support \\nWhen you want to compose a multi-conta\", \"iner solution, add container orchestration support to your \\nprojects. This lets you run and debug a \", \"group of containers (a whole solution) at the same time if \\nthey\\u2019re defined in the same docker-compo\", \"se.yml file. \\nTo add container orchestration support, right-click on the project node in Solution Ex\", \"plorer, and \\nchoose Add > Container Orchestration Support. Then choose Docker Compose to manage the \", \"\\ncontainers. \\nAfter you add container orchestration support to your project, you see a Dockerfile ad\", \"ded to the \\nproject and a docker-compose folder added to the solution in Solution Explorer, as shown\", \" in Figure \\n4-33: \\n \\n55 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Mi\", \"crosoft Azure \\n \\n \\nFigure 4-33. Docker files in Solution Explorer in Visual Studio \\nIf docker-compos\", \"e.yml already exists, Visual Studio just adds the required lines of configuration code \\nto it. \\nConf\", \"igure Docker tools \\nFrom the main menu, choose Tools > Options, and expand Container Tools > Setting\", \"s. The \\ncontainer tools settings appear. \\n \\n56 \\nCHAPTER 4 | Designing and developing containerized a\", \"pps using Docker and Microsoft Azure \\n \\n \\nFigure 4-34. Docker Tools Options \\nFor more detailed confi\", \"gurations refer to Container Tools settings \\nTip \\nFor further details on the services implementation\", \" and use of Visual Studio Tools for Docker, read the \\nfollowing articles: \\nUse the Containers tool w\", \"indow to view container details such as the filesystem, logs, environment, \\nports, and more: https:/\", \"/learn.microsoft.com/visualstudio/containers/view-and-diagnose-containers \\nDebug apps in a local Doc\", \"ker container: https://learn.microsoft.com/visualstudio/containers/edit-and-\\nrefresh \\nDeploy an ASP.\", \"NET container to a container registry using Visual Studio: \\nhttps://learn.microsoft.com/visualstudio\", \"/containers/hosting-web-apps-in-docker \\nUsing Windows PowerShell commands in a \\nDockerFile to set up\", \" Windows Containers (Docker \\nstandard based) \\nWith Windows Containers, you can convert your existing\", \" Windows applications to Docker images and \\ndeploy them with the same tools as the rest of the Docke\", \"r ecosystem. \\n \\n57 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microso\", \"ft Azure \\n \\nTo use Windows Containers, you just need to write Windows PowerShell commands in the Doc\", \"kerFile, \\nas demonstrated in the following example: \\nFROM mcr.microsoft.com/windows/servercore:ltsc2\", \"019 \\nLABEL Description=\\\"IIS\\\" Vendor=\\\"Microsoft\\\" Version=\\\"10\\\" \\nRUN powershell Get-WindowsFeature web-\", \"server \\nRUN powershell Install-windowsfeature web-server \\nRUN powershell add-windowsfeature web-asp-\", \"net45 \\nCMD [ \\\"ping\\\", \\\"localhost\\\", \\\"-t\\\" ] \\nIn this case, we\\u2019re using Windows PowerShell to install a \", \"Windows Server Core base image as well \\nas IIS. \\nIn a similar way, you also could use Windows PowerS\", \"hell commands to set up additional components \\nlike the traditional ASP.NET 4.x and .NET Framework 4\", \".6 or any other Windows software, as shown \\nhere: \\nRUN powershell add-windowsfeature web-asp-net45 \\n\", \"Build ASP.NET Core applications deployed as Linux \\ncontainers into an AKS/Kubernetes orchestrator \\nA\", \"zure Kubernetes Services (AKS) is Azure\\u2019s managed Kubernetes orchestrations services that simplify \\n\", \"container deployment and management. \\nThe main features of AKS are: \\n\\u2022 \\nAn Azure-hosted control plan\", \"e. \\n\\u2022 \\nAutomated upgrades. \\n\\u2022 \\nSelf-healing. \\n\\u2022 \\nUser-configurable scaling. \\n\\u2022 \\nSimpler user experie\", \"nce for both developers and cluster operators. \\nThe following examples explore the creation of an AS\", \"P.NET Core 6.0 application that runs on Linux \\nand deploys to an AKS Cluster in Azure. Development i\", \"s done using Visual Studio 2022 version 17.0. \\nCreating the ASP.NET Core Project using Visual Studio\", \" 2022 \\nASP.NET Core is a general-purpose development platform maintained by Microsoft and the .NET \\n\", \"community on GitHub. It\\u2019s cross-platform, supporting Windows, macOS and Linux, and can be used in \\nd\", \"evice, cloud, and embedded/IoT scenarios. \\nThis example uses a couple of simple projects based on Vi\", \"sual Studio templates, so you don\\u2019t need \\nmuch additional knowledge to create the sample. You only h\", \"ave to create the project using a \\nstandard template that includes all the elements to run a small p\", \"roject with a REST API and a Web \\nApp with Razor pages, using ASP.NET Core 6.0 technology. \\nFor refe\", \"rence, you can download the sample from .NET Application Architecture\\u2019s repo explore-\\ndocker. \\n \\n58 \", \"\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n \\nFigur\", \"e 4-35. Creating an ASP.NET Core Web Application in Visual Studio 2022. \\nTo create the sample projec\", \"t in Visual Studio, select File > New > Project, select the Web project \\ntype and then the ASP.NET C\", \"ore Web Api template. You can also search for the template if you need \\nit. \\nThen enter the applicat\", \"ion name and location as shown in the next image. \\n \\n59 \\nCHAPTER 4 | Designing and developing contai\", \"nerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-36. Enter the project name and location \", \"in Visual Studio 2022. \\nVerify that you\\u2019ve selected ASP.NET Core 6.0 as the framework. .NET 6 is inc\", \"luded in the latest release \\nof Visual Studio 2022 and is automatically installed and configured for\", \" you when you install Visual \\nStudio. \\n \\n60 \\nCHAPTER 4 | Designing and developing containerized apps\", \" using Docker and Microsoft Azure \\n \\n \\nFigure 4-37. Selecting ASP.NET CORE 6.0 and Web API project t\", \"ype \\nNotice Docker support is not enabled now. You\\u2019ll do that in the next step after the project cre\", \"ation. \\nYou\\u2019ll also notice that by default controller option is checked. You can uncheck that if you\", \" want to \\nCreate a minimal web API with ASP.NET Core. \\nTo show you can \\u201cDockerize\\u201d your project at a\", \"ny time, you\\u2019ll add Docker support now. So right-click \\non the project node in Solution Explorer and\", \" select Add > Docker support on the context menu. \\n \\n61 \\nCHAPTER 4 | Designing and developing contai\", \"nerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-38. Adding Docker support to an existing\", \" project \\nTo complete adding Docker support, you can choose Windows or Linux. In this case, select L\", \"inux. \\n \\nFigure 4-39. Selecting Linux containers. \\n \\n62 \\nCHAPTER 4 | Designing and developing contai\", \"nerized apps using Docker and Microsoft Azure \\n \\nWith these simple steps, you have your ASP.NET Core\", \" 6.0 application running on a Linux container. \\nIn a similar way, you can also add a very simple Web\", \"App project (Figure 4-40) to consume the web \\nAPI endpoint, although the details can be seen in the \", \"code repo. \\nAfter that, you add orchestrator support for your WebApi project as shown next, in image\", \" 4-40. \\n \\nFigure 4-40. Adding orchestrator support to WebApi project. \\nWhen you choose the Docker Co\", \"mpose option, which is fine for local development, Visual Studio \\nadds the docker-compose project, w\", \"ith the docker-compose files as shown in image 4-41. \\n \\n63 \\nCHAPTER 4 | Designing and developing con\", \"tainerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-41. Adding orchestrator support to We\", \"bApi project. \\nThe initial files added are similar to these ones: \\ndocker-compose.yml \\nversion: \\\"3.4\", \"\\\" \\n \\nservices: \\n  webapi: \\n    image: ${DOCKER_REGISTRY-}webapi \\n    build: \\n      context: . \\n     \", \" dockerfile: WebApi/Dockerfile \\n \\n  webapp: \\n    image: ${DOCKER_REGISTRY-}webapp \\n    build: \\n     \", \" context: . \\n      dockerfile: WebApp/Dockerfile \\ndocker-compose.override.yml \\nversion: \\\"3.4\\\" \\n \\nser\", \"vices: \\n  webapi: \\n    environment: \\n      - ASPNETCORE_ENVIRONMENT=Development \\n      - ASPNETCORE_\", \"URLS=https://+:443;http://+:80 \\n    ports: \\n      - \\\"80\\\" \\n      - \\\"443\\\" \\n    volumes: \\n      - ${APP\", \"DATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro \\n      - ${APPDATA}/ASP.NET/Https:/root/\", \".aspnet/https:ro \\n  webapp: \\n    environment: \\n      - ASPNETCORE_ENVIRONMENT=Development \\n      - A\", \"SPNETCORE_URLS=https://+:443;http://+:80 \\n    ports: \\n      - \\\"80\\\" \\n      - \\\"443\\\" \\n \\n64 \\nCHAPTER 4 |\", \" Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n    volumes: \\n     \", \" - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro \\n      - ${APPDATA}/ASP.NET/Http\", \"s:/root/.aspnet/https:ro \\nTo run your app with Docker Compose, you just have to make a few tweaks to\", \" docker-\\ncompose.override.yml. \\nservices: \\n  webapi: \\n    #... \\n    ports: \\n      - \\\"51080:80\\\" \\n    \", \"  - \\\"51443:443\\\" \\n    #... \\n  webapp: \\n    environment: \\n      #... \\n      - WebApiBaseAddress=http:/\", \"/webapi \\n    ports: \\n      - \\\"50080:80\\\" \\n      - \\\"50443:443\\\" \\n    #... \\nNow you can run your applica\", \"tion with the F5 key, or by using the Play button, or the Ctrl+F5 key, \\nselecting the docker-compose\", \" project, as shown in image 4-42. \\n \\nFigure 4-42. Adding orchestrator support to WebApi project. \\nWh\", \"en running the docker-compose application as explained, you get: \\n1. \\nThe images built and container\", \"s created as per the docker-compose file. \\n2. \\nThe browser open in the address configured in the \\u201cPr\", \"operties\\u201d dialog for the docker-\\ncompose project. \\n3. \\nThe Container window open (in Visual Studio 2\", \"022 version 17.0 and later). \\n4. \\nDebugger support for all projects in the solution, as shown in the\", \" following images. \\nBrowser opened: \\n \\n65 \\nCHAPTER 4 | Designing and developing containerized apps u\", \"sing Docker and Microsoft Azure \\n \\n \\nFigure 4-43. Browser window with an application running on mult\", \"iple containers. \\nContainers window: \\n \\nFigure 4-44. Visual Studio \\u201cContainers\\u201d window \\nThe Containe\", \"rs window lets you view running containers, browse available images, view environment \\nvariables, lo\", \"gs, and port mappings, inspect the filesystem, attach a debugger, or open a terminal \\nwindow inside \", \"the container environment. \\nAs you can see, the integration between Visual Studio 2022 and Docker is\", \" completely oriented to the \\ndeveloper\\u2019s productivity. \\nOf course, you can also list the images usin\", \"g the docker images command. You should see the webapi \\nand webapp images with the dev tags created \", \"by the automatic deployment of our project with Visual \\nStudio 2022. \\ndocker images \\n \\n66 \\nCHAPTER 4\", \" | Designing and developing containerized apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-45. Vi\", \"ew of Docker images \\nRegister the Solution in an Azure Container Registry (ACR) \\nYou can upload the \", \"images to the Azure Container Registry (ACR), but you could also use Docker Hub \\nor any other regist\", \"ry, so the images can be deployed to the AKS cluster from that registry. \\nCreate an ACR instance \\nRu\", \"n the following command from the az cli: \\naz acr create --name exploredocker --resource-group explor\", \"e-docker-aks-rg --sku basic \\n--admin-enabled \\n \\n \\nNote \\nThe container registry name (for example, ex\", \"ploredocker) must be unique within Azure and contain 5-\\n50 alphanumeric characters. For more details\", \", see Create a container registry. \\nCreate the image in Release mode \\nYou\\u2019ll now create the image in\", \" Release mode (ready for production) by changing to Release, as \\nshown in Figure 4-46, and running t\", \"he application as you did before. \\n \\nFigure 4-46. Selecting Release Mode \\nIf you execute the docker \", \"images command, you\\u2019ll see both images created, one for debug (dev) and \\nthe other for release (late\", \"st) mode. \\nCreate a new Tag for the Image \\nEach container image needs to be tagged with the loginSer\", \"ver name of the registry. This tag is used \\nfor routing when pushing container images to an image re\", \"gistry. \\nYou can view the loginServer name from the Azure portal, taking the information from the Az\", \"ure \\nContainer Registry \\n \\n67 \\nCHAPTER 4 | Designing and developing containerized apps using Docker \", \"and Microsoft Azure \\n \\n \\nFigure 4-47. View of the name of the Registry \\nOr by running the following \", \"command: \\naz acr list --resource-group <resource-group-name> --query \\n\\\"[].{acrLoginServer:loginServe\", \"r}\\\" --output table \\n \\nFigure 4-48. Get the name of the registry using az cli \\nIn both cases, you\\u2019ll \", \"obtain the name. In our example, exploredocker.azurecr.io. \\nNow you can tag the image, taking the la\", \"test image (the Release image), with the command: \\ndocker tag <image-name>:latest <login-server-name\", \">/<image-name>:v1 \\nAfter running the docker tag command, list the images with the docker images comm\", \"and, and you \\nshould see the image with the new tag. \\n \\nFigure 4-49. View of tagged images \\nPush the\", \" image into the Azure ACR \\nLog in to the Azure Container Registry \\naz acr login --name exploredocker\", \" \\nPush the image into the Azure ACR, using the following command: \\ndocker push <login-server-name>/<\", \"image-name>:v1 \\n \\n68 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Micro\", \"soft Azure \\n \\nThis command takes a while uploading the images but gives you feedback in the process.\", \" In the \\nfollowing image, you can see the output from one image completed and another in progress. \\n\", \" \\nFigure 4-50. Console output from the push command. \\nTo deploy your multi-container app into your A\", \"KS cluster you need some manifest .yaml files that \\nhave, most of the properties taken from the dock\", \"er-compose.yml and docker-compose.override.yml \\nfiles. \\ndeploy-webapi.yml \\napiVersion: apps/v1 \\nkind\", \": Deployment \\nmetadata: \\n  name: webapi \\n  labels: \\n    app: weather-forecast \\nspec: \\n  replicas: 1 \", \"\\n  selector: \\n    matchLabels: \\n      service: webapi \\n  template: \\n    metadata: \\n      labels: \\n  \", \"      app: weather-forecast \\n        service: webapi \\n    spec: \\n      containers: \\n        - name: \", \"webapi \\n          image: exploredocker.azurecr.io/webapi:v1 \\n          imagePullPolicy: IfNotPresent\", \" \\n          ports: \\n            - containerPort: 80 \\n              protocol: TCP \\n          env: \\n  \", \"          - name: ASPNETCORE_URLS \\n              value: http://+:80 \\n \\n69 \\nCHAPTER 4 | Designing and\", \" developing containerized apps using Docker and Microsoft Azure \\n \\n--- \\napiVersion: v1 \\nkind: Servic\", \"e \\nmetadata: \\n  name: webapi \\n  labels: \\n    app: weather-forecast \\n    service: webapi \\nspec: \\n  po\", \"rts: \\n    - port: 80 \\n      targetPort: 80 \\n      protocol: TCP \\n  selector: \\n    service: webapi \\nd\", \"eploy-webapp.yml \\napiVersion: apps/v1 \\nkind: Deployment \\nmetadata: \\n  name: webapp \\n  labels: \\n    a\", \"pp: weather-forecast \\nspec: \\n  replicas: 1 \\n  selector: \\n    matchLabels: \\n      service: webapp \\n  \", \"template: \\n    metadata: \\n      labels: \\n        app: weather-forecast \\n        service: webapp \\n   \", \" spec: \\n      containers: \\n        - name: webapp \\n          image: exploredocker.azurecr.io/webapp:\", \"v1 \\n          imagePullPolicy: IfNotPresent \\n          ports: \\n            - containerPort: 80 \\n    \", \"          protocol: TCP \\n          env: \\n            - name: ASPNETCORE_URLS \\n              value: h\", \"ttp://+:80 \\n            - name: WebApiBaseAddress \\n              value: http://webapi \\n--- \\napiVersi\", \"on: v1 \\nkind: Service \\nmetadata: \\n  name: webapp \\n  labels: \\n    app: weather-forecast \\n    service:\", \" webapp \\nspec: \\n  type: LoadBalancer \\n  ports: \\n    - port: 80 \\n      targetPort: 80 \\n      protocol\", \": TCP \\n  selector: \\n    service: webapp \\n \\n70 \\nCHAPTER 4 | Designing and developing containerized ap\", \"ps using Docker and Microsoft Azure \\n \\n \\n \\nNote \\nThe previous .yml files only enable the HTTP ports,\", \" using the ASPNETCORE_URLS parameter, to avoid \\nissues with the missing certificate in the sample ap\", \"p. \\n \\n \\nTip \\nYou can see how to create the AKS Cluster for this sample in section Deploy to Azure Ku\", \"bernetes \\nService (AKS) on this guide. \\nNow you\\u2019re almost ready to deploy using kubectl, but first y\", \"ou must get the credentials from the AKS \\nCluster with this command: \\naz aks get-credentials --resou\", \"rce-group explore-docker-aks-rg --name explore-docker-aks \\n \\nFigure 4-51. Getting credentials from A\", \"KS into the kubectl environment. \\nYou also have to allow the AKS cluster to pull images from the ACR\", \", using this command: \\naz aks update --name explore-docker-aks --resource-group explore-docker-aks-r\", \"g --attach-acr \\nexploredocker \\nThe previous command might take a couple of minutes to complete. Then\", \", use the kubectl apply \\ncommand to launch the deployments, and then kubectl get all to list the clu\", \"ster objects. \\nkubectl apply -f deploy-webapi.yml \\nkubectl apply -f deploy-webapp.yml \\n \\nkubectl get\", \" all \\n \\n71 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure\", \" \\n \\n \\nFigure 4-52. Deployment to Kubernetes \\nYou\\u2019ll have to wait a while until the load balancer get\", \"s the external IP, checking with kubectl get \\nservices, and then the application should be available\", \" at that address, as shown in the next image: \\n \\n72 \\nCHAPTER 4 | Designing and developing containeri\", \"zed apps using Docker and Microsoft Azure \\n \\n \\nFigure 4-53. Deployment to Kubernetes \\nWhen the deplo\", \"yment completes, you can access the Kubernetes Web UI with a local proxy, using an \\nssh tunnel. \\nFir\", \"st you must create a ClusterRoleBinding with the following command: \\nkubectl create clusterrolebindi\", \"ng kubernetes-dashboard --clusterrole=cluster-admin --\\nserviceaccount=kube-system:kubernetes-dashboa\", \"rd \\nAnd then this command to start the proxy: \\naz aks browse --resource-group exploredocker-aks-rg -\", \"-name explore-docker-aks \\nA browser window should open at http://127.0.0.1:8001 with a view similar \", \"to this one: \\n \\n73 \\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microso\", \"ft Azure \\n \\n \\nFigure 4-54. View Kubernetes cluster information \\nNow you have your ASP.NET Core appli\", \"cation, running in Linux containers, and deployed to an AKS \\ncluster on Azure. \\nNote \\nFor more infor\", \"mation on deployment with Kubernetes see: \\nhttps://kubernetes.io/docs/reference/kubectl/cheatsheet/ \", \"\\n \\n74 \\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n \\nCHAPTER 5 \\nDocker appl\", \"ication \\nDevOps workflow with \\nMicrosoft tools \\nMicrosoft Visual Studio, Azure DevOps Services and/o\", \"r GitHub, Team Foundation Server, and Azure \\nMonitor provide a comprehensive ecosystem for developme\", \"nt and IT operations that give your team the \\ntools to manage projects and rapidly build, test, and \", \"deploy containerized applications. \\nTeams can choose which tools and platforms they want to use for \", \"end to end DevOps. With Visual \\nStudio and Azure DevOps Services in the cloud, along with Team Found\", \"ation Server on-premises, \\ndevelopment teams can productively build, test, and release containerized\", \" applications that target \\neither Windows or Linux. Alternatively, teams can also use Visual Studio \", \"Code and GitHub. Teams can \\neven use combinations: for example, storing source code in GitHub and us\", \"ing Azure Boards for work \\nitem tracking and Azure Pipelines for CI/CD. \\nMicrosoft tools can automat\", \"e the pipeline for specific implementations of containerized \\napplications\\u2014Docker, .NET, or any comb\", \"ination with other platforms\\u2014from global builds and \\nContinuous Integration (CI) and tests with Azur\", \"e DevOps Services, Team Foundation Server or GitHub, \\nto Continuous Deployment (CD) to Docker enviro\", \"nments (Development, Staging, Production), and to \\ntransmit analytics information about the services\", \" to the development team through Azure Monitor. \\nEvery code commit can initiate a build (CI) and aut\", \"omatically deploy the services to specific \\ncontainerized environments (CD). \\nDevelopers and testers\", \" can easily and quickly provision production-like development and test \\nenvironments based on Docker\", \" by using templates in Microsoft Azure. \\nThe complexity of containerized application development inc\", \"reases steadily depending on the \\nbusiness complexity and scalability needs. A good example of this \", \"complexity are applications based \\non microservices architectures. To succeed in such an environment\", \", your project must automate the \\nentire life cycle\\u2014not only the build and deployment, but it also m\", \"ust manage versions along with \\nthe collection of telemetry. Azure DevOps Services, GitHub and Azure\", \" offer the following capabilities: \\n\\u2022 \\nAzure DevOps Services/Team Foundation Server source code mana\", \"gement (based on Git or \\nTeam Foundation Version Control), Agile planning (Agile, Scrum, and CMMI ar\", \"e supported), \\nCI, release management, and other tools for Agile teams. \\n \\n75 \\nCHAPTER 5 | Docker ap\", \"plication DevOps workflow with Microsoft tools \\n \\n\\u2022 \\nAzure DevOps Services and Team Foundation Serve\", \"r include a powerful and growing \\necosystem of first and third-party extensions with which you easil\", \"y can construct a CI, build, \\ntest, delivery, and release management pipeline for microservices. \\n\\u2022 \", \"\\nGitHub or GitHub Enterprise Server offer similar capabilities, with source control based on Git, \\nP\", \"rojects and Issues for project tracking, GitHub Actions for automating workflows including \\nCI/CD, a\", \"nd GitHub Advanced Security for dependency, secret and vulnerability scanning. \\n\\u2022 \\nRun automated tes\", \"ts as part of your build pipeline in Azure DevOps Services or through \\nGitHub Actions \\n\\u2022 \\nAzure DevO\", \"ps Services/GitHub can tighten the DevOps life cycle with delivery to multiple \\nenvironments, not ju\", \"st for production environments, but also for testing, including A/B \\nexperimentation, canary release\", \"s, and so on. \\n\\u2022 \\nOrganizations easily can provision Docker containers from private images stored in\", \" Azure \\nContainer Registry along with any dependency on Azure components (Data, PaaS, etc.) using \\nA\", \"zure Resource Manager templates with tools they\\u2019re already comfortable with. \\nSteps in the outer-loo\", \"p DevOps workflow for a \\nDocker application \\nFigure 5-1 presents an end-to-end depiction of the step\", \"s comprising the DevOps outer-loop \\nworkflow. It shows the \\u201couter loop\\u201d of DevOps. When code is push\", \"ed to the repo, a CI pipeline is \\nstarted, then begins the CD pipeline, where the application gets d\", \"eployed. Metrics collected from \\ndeployed applications are fed back into the development workload, w\", \"here the \\u201cinner loop\\u201d occurs, so \\ndevelopment teams have actual data to respond to user and business\", \" needs. \\n \\nFigure 5-1. DevOps outer-loop workflow for Docker applications with Microsoft tools \\nNow,\", \" let\\u2019s examine each of these steps in greater detail. \\n \\n76 \\nCHAPTER 5 | Docker application DevOps w\", \"orkflow with Microsoft tools \\n \\nStep 1: Inner-loop development workflow \\nThis step is explained in d\", \"etail in Chapter 4, but, to recap, here is where the outer-loop begins, the \\nmoment at which a devel\", \"oper pushes code to the source control management system (like Git) \\ninitiating CI pipeline actions.\", \" \\nStep 2: Source-Code Control integration and management with Azure \\nDevOps Services and Git \\nAt thi\", \"s step, you need to have a version-control system to gather a consolidated version of all the \\ncode \", \"coming from the different developers in the team. \\nEven though source-code control (SCC) and source-\", \"code management might seem second-nature to \\nmost developers, when creating Docker applications in a\", \" DevOps life cycle, it\\u2019s critical to emphasize \\nthat you must not submit the Docker images with the \", \"application directly to the global Docker \\nRegistry (like Azure Container Registry or Docker Hub) fr\", \"om the developer\\u2019s machine. On the contrary, \\nthe Docker images to be released and deployed to produ\", \"ction environments must be created solely \\non the source code that\\u2019s being integrated in your global\", \" build or CI pipeline based on your source-\\ncode repository (like Git). \\nThe local images, generated\", \" by developers, should just be used by them when testing within their \\nown machines. That\\u2019s why it\\u2019s\", \" critical to have the DevOps pipeline activated from the SCC code. \\nAzure DevOps Services and Team F\", \"oundation Server support Git and Team Foundation Version \\nControl. You can choose between them and u\", \"se it for an end-to-end Microsoft experience. However, \\nyou can also manage your code in external re\", \"positories (like GitHub, on-premises Git repositories, or \\nSubversion) and still be able to connect \", \"to it and get the code as the starting point for your DevOps CI \\npipeline. You can also use GitHub A\", \"ctions for CI/CD pipelines. \\nStep 3: Build, CI, Integrate, and Test with Azure DevOps \\nServices/GitH\", \"ub and Docker \\nCI has emerged as a standard for modern software testing and delivery. The Docker sol\", \"ution \\nmaintains a clear separation of concerns between the development and operations teams. The \\ni\", \"mmutability of Docker images ensures a repeatable deployment between what\\u2019s developed, tested \\nthrou\", \"gh CI, and run in production. Docker Engine deployed across the developer laptops and test \\ninfrastr\", \"ucture makes the containers portable across environments. \\nAt this point, after you have a version-c\", \"ontrol system with the correct code submitted, you need a \\nbuild service to pick up the code and run\", \" the global build and tests. \\nThe internal workflow for this step (CI, build, test) is about the con\", \"struction of a CI pipeline consisting \\nof your code repository (Git, etc.), your build server (Azure\", \" DevOps Services/GitHub), Docker Engine, \\nand a Docker Registry. \\nYou can use Azure DevOps Services \", \"as the foundation for building your applications and setting your \\nCI pipeline, and for publishing t\", \"he built \\u201cartifacts\\u201d to an \\u201cartifacts repository,\\u201d which is explained in the \\nnext step. Alternative\", \"ly, you can use GitHub to implement the same workflow. \\n \\n77 \\nCHAPTER 5 | Docker application DevOps \", \"workflow with Microsoft tools \\n \\nWhen using Docker for the deployment, the \\u201cfinal artifacts\\u201d to be d\", \"eployed are Docker images with \\nyour application or services embedded within them. Those images are \", \"pushed or published to a \\nDocker Registry (a private repository like the ones you can have in Azure \", \"Container Registry, or a \\npublic one like Docker Hub Registry or GitHub Container Registry, which is\", \" commonly used for official \\nbase images). \\nHere is the basic concept: The CI pipeline will be kicke\", \"d-off by a commit to an SCC repository like Git. \\nThe commit will cause Azure DevOps Services/GitHub\", \" to run a build job within a Docker container \\nand, upon successful completion of that job, push a D\", \"ocker image to the Docker Registry, as \\nillustrated in Figure 5-2. The first part of the outer loop \", \"involves steps 1 to 3, from code, run, debug \\nand validate, then the code repo up to the build and t\", \"est CI step. \\n \\nFigure 5-2. The steps involved in CI \\nHere are the basic CI workflow steps with Dock\", \"er and Azure DevOps Services: \\n \\n78 \\nCHAPTER 5 | Docker application DevOps workflow with Microsoft t\", \"ools \\n \\n1. \\nThe developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, \\n\", \"etc.). \\n2. \\nIf you\\u2019re using Azure DevOps Services or Git, CI is built in, which means that it\\u2019s as s\", \"imple as \\nselecting a check box in Azure DevOps Services. If you\\u2019re using an external SCC (like GitH\", \"ub), \\na webhook will notify Azure DevOps Services of the update or push to Git/GitHub. \\n3. \\nAzure De\", \"vOps Services pulls the SCC repository, including the Dockerfile describing the \\nimage, as well as t\", \"he application and test code. \\n4. \\nAzure DevOps Services builds a Docker image and labels it with a \", \"build number. \\n5. \\nAzure DevOps Services instantiates the Docker container within the provisioned Do\", \"cker Host, \\nand runs the appropriate tests. \\n6. \\nIf the tests are successful, the image is first rel\", \"abeled to a meaningful name so that you know \\nit\\u2019s a \\u201cblessed build\\u201d (like \\u201c/1.0.0\\u201d or any other lab\", \"el), and then pushed up to your Docker \\nRegistry (Docker Hub, Azure Container Registry, DTR, etc.) \\n\", \"Here are the basic CI workflow steps with Docker and GitHub: \\n1. \\nThe developer pushes a commit to a\", \" GitHub repo. \\n2. \\nCI is built in, so Actions will trigger base on the event filters. \\n3. \\nGitHub pu\", \"lls the SCC repository, including the Dockerfile describing the image, as well as the \\napplication a\", \"nd test code. \\n4. \\nGitHub builds a Docker image and labels it with a build number. \\n5. \\nGitHub insta\", \"ntiates the Docker container within the provisioned Docker Host, and runs the \\nappropriate tests. \\n6\", \". \\nIf the tests are successful, the image is first relabeled to a meaningful name so that you know \\n\", \"it\\u2019s a \\u201cblessed build\\u201d (like \\u201c/1.0.0\\u201d or any other label), and then pushed up to your Docker \\nRegist\", \"ry (Docker Hub, Azure Container Registry, DTR, etc.) \\nImplement a CI pipeline with Azure DevOps Serv\", \"ices and the Docker extension for \\nAzure DevOps Services \\nVisual Studio Azure DevOps Services contai\", \"ns Build & Release Templates that you can use in your \\nCI/CD pipeline with which you can build Docke\", \"r images, push Docker images to an authenticated \\nDocker registry, run Docker images, or run other o\", \"perations offered by the Docker CLI. It also adds a \\nDocker Compose task that you can use to build, \", \"push, and run multi-container Docker applications, or \\nrun other operations offered by the Docker Co\", \"mpose CLI, as shown in Figure 5-3. \\n \\n79 \\nCHAPTER 5 | Docker application DevOps workflow with Micros\", \"oft tools \\n \\n \\nFigure 5-3. The Docker CI pipeline in Azure DevOps Services including Build & Release\", \" Templates and associated tasks. \\nYou can use these templates and tasks to construct your CI/CD arti\", \"facts to Build / Test and Deploy in \\nAzure Service Fabric, Azure Kubernetes Service, and similar off\", \"erings. \\nWith these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in A\", \"zure and \\nyour preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, \", \"or any \\nother Docker registry) you can assemble your Docker CI pipeline in a very consistent way. \\nR\", \"equirements: \\n\\u2022 \\nAzure DevOps Services, or for on-premises installations, Team Foundation Server 201\", \"5 \\nUpdate 3 or later. \\n\\u2022 \\nAn Azure DevOps Services agent that has the Docker binaries. \\n  \\nAn easy w\", \"ay to create one of these agents is to use Docker to run a container based on the \\nAzure DevOps Serv\", \"ices agent Docker image. \\nTip \\nTo read more about assembling an Azure DevOps Services Docker CI pipe\", \"line and view the \\nwalkthroughs, visit these sites: \\n\\u2022 \\nRunning a Visual Studio Team Services (Now A\", \"zure DevOps Services) agent as a Docker \\ncontainer: \\nhttps://hub.docker.com/_/microsoft-azure-pipeli\", \"nes-vsts-agent \\n \\n80 \\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n \\n\\u2022 \\nBuil\", \"ding .NET Linux Docker images with Azure DevOps Services: \\nhttps://learn.microsoft.com/archive/blogs\", \"/stevelasker/building-net-core-linux-docker-\\nimages-with-visual-studio-team-services \\n\\u2022 \\nBuilding a \", \"Linux-based Visual Studio Team Service build machine with Docker support: \\nhttps://www.donovanbrown.\", \"com/post/Building-a-Linux-Based-Visual-Studio-Team-Service-\\nBuild-Machine-with-Docker-Support \\nImple\", \"ment a CI pipeline with GitHub Actions \\nGitHub Actions allow you to create automation scripts that c\", \"an build Docker images, push Docker \\nimages to an authenticated Docker registry, run Docker images, \", \"or run other operations offered by \\nthe Docker CLI. \\nYou can use public Actions (such as Azure Login\", \") and run (shell) commands to construct your CI/CD \\nartifacts to Build / Test and Deploy in Azure Se\", \"rvice Fabric, Azure Kubernetes Service, and similar \\nofferings. \\nWith these Actions, a build Linux-D\", \"ocker Host/VM provisioned in Azure and your preferred Docker \\nregistry (Azure Container Registry, Do\", \"cker Hub, private Docker DTR, or any other Docker registry) you \\ncan assemble your Docker CI pipelin\", \"e in a very consistent way. \\nIntegrate, test, and validate multi-container Docker applications \\nTypi\", \"cally, most Docker applications are composed of multiple containers rather than a single \\ncontainer.\", \" A good example is a microservices-oriented application for which you would have one \\ncontainer per \", \"microservice. But, even without strictly following the microservices approach patterns, \\nit\\u2019s probab\", \"le that your Docker application would be composed of multiple containers or services. \\nTherefore, af\", \"ter building the application containers in the CI pipeline, you also need to deploy, \\nintegrate, and\", \" test the application as a whole with all of its containers within an integration Docker \\nhost or ev\", \"en into a test cluster to which your containers are distributed. \\nIf you\\u2019re using a single host, you\", \" can use Docker commands such as docker-compose to build and \\ndeploy related containers to test and \", \"validate the Docker environment in a single VM. But, if you\\u2019re \\nworking with an orchestrator cluster\", \" like DC/OS, Kubernetes, or Docker Swarm, you need to deploy \\nyour containers through a different me\", \"chanism or orchestrator, depending on your selected \\ncluster/scheduler. \\nThe following are several t\", \"ypes of tests that you can run against Docker containers: \\n\\u2022 \\nUnit tests for Docker containers \\n\\u2022 \\nT\", \"esting groups of interrelated applications or microservices \\n\\u2022 \\nTest in production and \\u201ccanary\\u201d rele\", \"ases \\nThe important point is that when running integration and functional tests, you must run those \", \"tests \\nfrom outside of the containers. Tests are not contained or run in the containers you\\u2019re deplo\", \"ying, \\nbecause the containers are based on static images that should be exactly like the ones you\\u2019ll\", \" be \\ndeploying to production. \\n \\n81 \\nCHAPTER 5 | Docker application DevOps workflow with Microsoft t\", \"ools \\n \\nA practical option when testing more advanced scenarios, like including several clusters (te\", \"st cluster, \\nstaging cluster, and production cluster) is to publish the images to a registry, so it \", \"can be tested in \\nvarious clusters. \\nPush the custom application Docker image into your global Docke\", \"r Registry \\nAfter the Docker images have been tested and validated, you\\u2019ll want to tag and publish t\", \"hem to your \\nDocker registry. The Docker registry is a critical piece in the Docker application life\", \" cycle because it\\u2019s \\nthe central place where you store your custom test (also known as \\u201cblessed imag\", \"es\\u201d) to be deployed \\ninto QA and production environments. \\nSimilar to how the application code store\", \"d in your SCC repository (Git, etc.) is your \\u201csource of truth,\\u201d \\nthe Docker registry is your \\u201csource\", \" of truth\\u201d for your binary application or bits to be deployed to the \\nQA or production environments.\", \" \\nTypically, you might want to have your private repositories for your custom images either in a pri\", \"vate \\nrepository in Azure Container Registry or in an on-premises registry like Docker Trusted Regis\", \"try, or in \\na public-cloud registry with restricted access (like Docker Hub), although in this last \", \"case if your code \\nis not open source, you must trust the vendor\\u2019s security. Either way, the method \", \"you use is similar and \\nis based on the docker push command, as shown in Figure 5-4. \\n \\n82 \\nCHAPTER \", \"5 | Docker application DevOps workflow with Microsoft tools \\n \\n \\nFigure 5-4. Publishing custom image\", \"s to Docker Registry \\n \\n83 \\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n \\nI\", \"n step 3, for building integration and testing (CI) you might publish the resulting docker images to\", \" a \\nprivate or public registry. There are multiple offerings of Docker registries from cloud vendors\", \" like \\nAzure Container Registry, Amazon Web Services Container Registry, Google Container Registry, \", \"\\nGitHub Container Registry, Quay Registry, and so on. \\nUsing the Docker tasks, you can push a set of\", \" service images defined by a docker-compose.yml file, \\nwith multiple tags, to an authenticated Docke\", \"r registry (like Azure Container Registry), as shown in \\nFigure 5-5. \\n \\nFigure 5-5. Using Azure DevO\", \"ps Services to publishing custom images to a Docker Registry \\nTip \\nFor more information about Azure \", \"Container Registry, see https://aka.ms/azurecontainerregistry. \\nStep 4: CD, Deploy \\nThe immutability\", \" of Docker images ensures a repeatable deployment with what\\u2019s developed, tested \\nthrough CI, and run\", \" in production. After you have the application Docker images published in your \\nDocker registry (eit\", \"her private or public), you can deploy them to the several environments that you \\nmight have (produc\", \"tion, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services \\npipeline tasks, Azure\", \" DevOps Services Release Management or GitHub Actions. \\n \\n84 \\nCHAPTER 5 | Docker application DevOps \", \"workflow with Microsoft tools \\n \\nHowever, at this point it depends on what kind of Docker applicatio\", \"n you\\u2019re deploying. Deploying a \\nsimple application (from a composition and deployment point of view\", \") like a monolithic application \\ncomprising a few containers or services and deployed to a few serve\", \"rs or VMs is different from \\ndeploying a more complex application like a microservices-oriented appl\", \"ication with hyperscale \\ncapabilities. These two scenarios are explained in the following sections. \", \"\\nDeploying composed Docker applications to multiple Docker environments \\nLet\\u2019s look first at the les\", \"s-complex scenario: deploying to simple Docker hosts (VMs or servers) in a \\nsingle environment or mu\", \"ltiple environments (QA, staging, and production). In this scenario, internally \\nyour CD pipeline ca\", \"n use docker-compose (from your Azure DevOps Services deployment tasks) to \\ndeploy the Docker applic\", \"ations with its related set of containers or services, as illustrated in Figure 5-6. \\n \\nFigure 5-6. \", \"Deploying application containers to simple Docker host environments registry \\nFigure 5-7 highlights \", \"how you can connect your build CI to QA/test environments via Azure DevOps \\nServices by clicking Doc\", \"ker Compose in the Add Task dialog box. However, when deploying to staging \\nor production environmen\", \"ts, you would usually use Release Management features handling multiple \\nenvironments (like QA, stag\", \"ing, and production). If you\\u2019re deploying to single Docker hosts, it is using \\nthe Azure DevOps Serv\", \"ices \\u201cDocker Compose\\u201d task (which is invoking the docker-compose up \\ncommand under the hood). If you\", \"\\u2019re deploying to Azure Kubernetes Service (AKS), it uses the Docker \\n \\n85 \\nCHAPTER 5 | Docker applic\", \"ation DevOps workflow with Microsoft tools \\n \\nDeployment task, as explained in the section that foll\", \"ows. Similar steps can be built for deployment \\nusing GitHub Actions. \\n \\nFigure 5-7. Adding a Docker\", \" Compose task in an Azure DevOps Services pipeline or GitHub workflow \\nWhen you create a release in \", \"Azure DevOps Services, it takes a set of input artifacts. These artifacts are \\nintended to be immuta\", \"ble for the lifetime of the release, across all environments. When you introduce \\ncontainers, the in\", \"put artifacts identify images in a registry to deploy. Depending on how these images \\nare identified\", \", they are not guaranteed to remain the same throughout the duration of the release, the \\nmost obvio\", \"us case being when you reference myimage:latest from a docker-compose file. \\nThe Azure DevOps Servic\", \"es templates give you the ability to generate build artifacts that contain \\nspecific registry image \", \"digests that are guaranteed to uniquely identify the same image binary. These \\nare what you really w\", \"ant to use as input to a release. You can invoke docker-compose in a run step \\ninside GitHub Actions\", \" to accomplish the same goal. \\nManaging releases to Docker environments by using Azure DevOps Servic\", \"es \\nRelease Management or GitHub Actions \\nThrough the Azure DevOps Services templates, you can build\", \" a new image, publish it to a Docker \\nregistry, run it on Linux or Windows hosts, and use commands s\", \"uch as docker-compose to deploy \\nmultiple containers as an entire application, all through the Azure\", \" DevOps Services Release \\nManagement capabilities intended for multiple environments, as shown in Fi\", \"gure 5-8. \\n \\n86 \\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n \\n \\nFigure 5-8\", \". Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release \\nManagem\", \"ent \\nHowever, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a \", \"\\nsimple one (it\\u2019s deploying to single Docker hosts and VMs, and there will be a single container or \", \"\\ninstance per image) and probably should be used only for development or test scenarios. In most \\nen\", \"terprise production scenarios, you would want to have High Availability (HA) and easy-to-manage \\nsca\", \"lability by load balancing across multiple nodes, servers, and VMs, plus \\u201cintelligent failovers\\u201d so \", \"if a \\nserver or node fails, its services and containers will be moved to another host server or VM. \", \"In that \\ncase, you need more advanced technologies such as container clusters, orchestrators, and sc\", \"hedulers. \\nThus, the way to deploy to those clusters is by handling the advanced scenarios explained\", \" in the next \\nsection. \\nGitHub Actions can be used in the same manner, including the use of environm\", \"ents for approvals. \\nDeploying Docker applications to Docker clusters \\nThe nature of distributed app\", \"lications requires compute resources that are also distributed. To have \\nproduction-scale capabiliti\", \"es, you need to have clustering capabilities that provide high scalability and \\nhigh availability ba\", \"sed on pooled resources. \\nYou could deploy containers manually to those clusters from a CLI tool or \", \"a web UI, but you should \\nreserve that kind of manual work to spot deployment testing or management \", \"purposes like scaling-\\nout or monitoring. \\nFrom a CD point of view, you can use Azure DevOps Service\", \"s or GitHub Actions to run specially made \\ndeployment tasks from your environments that will deploy \", \"your containerized applications to \\ndistributed clusters in Container Service, as illustrated in Fig\", \"ure 5-9. \\n \\n87 \\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n \\n \\nFigure 5-9.\", \" Deploying distributed applications to Container Service \\nInitially, when deploying to certain clust\", \"ers or orchestrators, you would traditionally use specific \\ndeployment scripts and mechanisms per ea\", \"ch orchestrator (that is, Kubernetes and Service Fabric \\nhave different deployment mechanisms) inste\", \"ad of the simpler and easy-to-use docker-compose tool \\nbased on the docker-compose.yml definition fi\", \"le. However, thanks to the Azure DevOps Services \\nDocker Deploy task, shown in Figure 5-10, now you \", \"can also deploy to the supported orchestrators by \\njust using your familiar docker-compose.yml file \", \"because the tool performs that \\u201ctranslation\\u201d for you \\n(from your docker-compose.yml file to the form\", \"at needed by the orchestrator). \\n \\n88 \\nCHAPTER 5 | Docker application DevOps workflow with Microsoft\", \" tools \\n \\n \\nFigure 5-10. Adding the Deploy to Kubernetes task to your Environment \\nFigure 5-11 demon\", \"strates how you can edit the Deploy to Kubernetes task with the sections available \\nfor configuratio\", \"n. This is the task that will retrieve your ready-to-use custom Docker images to be \\ndeployed as con\", \"tainers in the cluster. \\n \\nFigure 5-11. Docker Deploy task definition deploying to ACS DC/OS \\n \\n89 \\n\", \"CHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n \\nTip \\nTo read more about the C\", \"D pipeline with Azure DevOps Services and Docker, visit \\nhttps://azure.microsoft.com/services/devops\", \"/pipelines \\n \\n \\nTip \\nTo see GitHub Actions workflows for CI, visit https://github.com/dotnet-\\narchit\", \"ecture/eShopOnContainers/wiki/GitHub-Actions. For a walkthrough of GitHub Actions \\nperforming deploy\", \"ment to an Azure Kubernetes environment, visit https://github.com/dotnet-\\narchitecture/eShopOnContai\", \"ners/wiki/Deployment-With-GitHub-Actions. \\nStep 5: Run and manage \\nBecause running and managing appl\", \"ications at enterprise-production level is a major subject in and of \\nitself, and due to the type of\", \" operations and people working at that level (IT operations) as well as the \\nlarge scope of this are\", \"a, the entire next chapter is devoted to explaining it. \\nStep 6: Monitor and diagnose \\nThis topic al\", \"so is covered in the next chapter as part of the tasks that IT performs in production \\nsystems; howe\", \"ver, is important to highlight that the insights obtained in this step must feed back to \\nthe develo\", \"pment team so that the application is constantly improved. From that point of view, it\\u2019s also \\npart \", \"of DevOps, although the tasks and operations are commonly performed by IT. \\nOnly when monitoring and\", \" diagnostics are 100% within the realm of DevOps are the monitoring \\nprocesses and analytics perform\", \"ed by the development team against testing or beta environments. \\nThis is done either by performing \", \"load testing or by monitoring beta or QA environments, where beta \\ntesters are trying the new versio\", \"ns. \\nCreate CI/CD pipelines in Azure DevOps Services for \\na .NET application on Containers and deplo\", \"ying to a \\nKubernetes cluster \\nIn Figure 5-12 you can see the end-to-end DevOps scenario covering th\", \"e code management, code \\ncompilation, Docker images build, Docker images push to a Docker registry a\", \"nd finally the \\ndeployment to a Kubernetes cluster in Azure. \\n \\n90 \\nCHAPTER 5 | Docker application D\", \"evOps workflow with Microsoft tools \\n \\n \\nFigure 5-12. CI/CD scenario creating Docker images and depl\", \"oying to a Kubernetes cluster in Azure \\nIt is important to highlight that the two pipelines, build/C\", \"I, and release/CD, are connected through the \\nDocker Registry (such as Docker Hub or Azure Container\", \" Registry). The Docker registry is one of the \\nmain differences compared to a traditional CI/CD proc\", \"ess without Docker. \\nAs shown in Figure 5-13, the first phase is the build/CI pipeline. In Azure Dev\", \"Ops Services you can \\ncreate build/CI pipelines that will compile the code, create the Docker images\", \", and push them to a \\nDocker Registry like Docker Hub or Azure Container Registry. \\n \\n91 \\nCHAPTER 5 \", \"| Docker application DevOps workflow with Microsoft tools \\n \\n \\nFigure 5-13. Build/CI pipeline in Azu\", \"re DevOps building Docker images and pushing images to a Docker registry \\nThe second phase is to cre\", \"ate a deployment/release pipeline. In Azure DevOps Services, you can easily \\ncreate a deployment pip\", \"eline targeting a Kubernetes cluster by using the Kubernetes tasks for Azure \\nDevOps Services, as sh\", \"own in Figure 5-14. \\n \\nFigure 5-14. Release/CD pipeline in Azure DevOps Services deploying to a Kube\", \"rnetes cluster \\n[!Walkthrough] Deploying eShopModernized to Kubernetes: \\n \\n92 \\nCHAPTER 5 | Docker ap\", \"plication DevOps workflow with Microsoft tools \\n \\nFor a detailed walkthrough of Azure DevOps CI/CD p\", \"ipelines deploying to Kubernetes, see this post: \\nhttps://github.com/dotnet-architecture/eShopModern\", \"izing/wiki/04.-How-to-deploy-your-Windows-\\nContainers-based-apps-into-Kubernetes-in-Azure-Container-\", \"Service-(Including-CI-CD) \\n \\n93 \\nCHAPTER 6 | Run, manage, and monitor Docker production environments\", \" \\n \\nCHAPTER 6 \\nRun, manage, and monitor \\nDocker production \\nenvironments \\nVision: Enterprise applica\", \"tions need to run with high availability and high scalability; IT operations \\nneed to be able to man\", \"age and monitor the environments and the applications themselves. \\nThis last pillar in the container\", \"ized Docker applications life cycle is centered on how you can run, \\nmanage, and monitor your applic\", \"ations in scalable, high availability (HA) production environments. \\nThe way you run your containeri\", \"zed applications in production (infrastructure architecture and \\nplatform technologies) is very much\", \" related and based on the chosen architecture and development \\nplatforms discussed in Chapter 1 of t\", \"his e-book. \\nThis chapter examines specific products and technologies from Microsoft and other vendo\", \"rs that you \\ncan use to effectively run scalable, HA distributed applications plus how you can manag\", \"e and monitor \\nthem from the IT perspective. \\nRun composed and microservices-based \\napplications in \", \"production environments \\nApplications composed by multiple microservices do need to be deployed into\", \" orchestrator clusters in \\norder to simplify the complexity of deployment and make it viable from an\", \" IT point of view. Without \\nan orchestrator cluster, it would be difficult to deploy and scale out a\", \" complex microservices \\napplication. \\nIntroduction to orchestrators, schedulers, and container clust\", \"ers \\nEarlier in this e-book, clusters and schedulers were introduced as part of the discussion on so\", \"ftware \\narchitecture and development. Kubernetes and Service Fabric are examples of Docker clusters.\", \" Both of \\nthese orchestrators can run as a part of the infrastructure provided by Microsoft Azure Ku\", \"bernetes \\nService. \\n \\n94 \\nCHAPTER 6 | Run, manage, and monitor Docker production environments \\n \\nWhe\", \"n applications are scaled-out across multiple host systems, the ability to manage each host \\nsystem \", \"and abstract away the complexity of the underlying platform becomes attractive. That\\u2019s \\nprecisely wh\", \"at orchestrators and schedulers provide. Let\\u2019s take a brief look at them here: \\n\\u2022 \\nSchedulers. \\u201cSche\", \"duling\\u201d refers to the ability for an administrator to load a service file onto \\na host system that e\", \"stablishes how to run a specific container. Launching containers in a \\nDocker cluster tends to be kn\", \"own as scheduling. Although scheduling refers to the specific act \\nof loading the service definition\", \", in a more general sense, schedulers are responsible for \\nhooking into a host\\u2019s init system to mana\", \"ge services in whatever capacity needed. \\n  \\nA cluster scheduler has multiple goals: using the clust\", \"er\\u2019s resources efficiently, working with \\nuser-supplied placement constraints, scheduling applicatio\", \"ns rapidly to not leave them in a \\npending state, having a degree of \\u201cfairness,\\u201d being robust to err\", \"ors, and always be available. \\n\\u2022 \\nOrchestrators. Platforms extend life-cycle management capabilities\", \" to complex, multi-\\ncontainer workloads deployed on a cluster of hosts. By abstracting the host infr\", \"astructure, \\norchestration tools give users a way to treat the entire cluster as a single deployment\", \" target. \\n  \\nThe process of orchestration involves tooling and a platform that can automate all aspe\", \"cts of \\napplication management from initial placement or deployment per container; moving \\ncontainer\", \"s to different hosts depending on its host\\u2019s health or performance; versioning and \\nrolling updates \", \"and health monitoring functions that support scaling and failover; and many \\nmore. \\n  \\nOrchestration\", \" is a broad term that refers to container scheduling, cluster management, and \\npossibly the provisio\", \"ning of additional hosts. \\nThe capabilities provided by orchestrators and schedulers are complex to \", \"develop and create from \\nscratch, therefore you usually would want to use orchestration solutions of\", \"fered by vendors. \\nManage production Docker environments \\nCluster management and orchestration is th\", \"e process of controlling a group of hosts. This can involve \\nadding and removing hosts from a cluste\", \"r, getting information about the current state of hosts and \\ncontainers, and starting and stopping p\", \"rocesses. Cluster management and orchestration are closely \\ntied to scheduling because the scheduler\", \" must have access to each host in the cluster in order to \\nschedule services. For this reason, the s\", \"ame tool is often used for both purposes. \\nContainer Service and management tools \\nContainer Service\", \" provides rapid deployment of popular open-source container clustering and \\norchestration solutions.\", \" It uses Docker images to ensure that your application containers are fully \\nportable. By using Cont\", \"ainer Service, you can deploy DC/OS (powered by Mesosphere and Apache \\nMesos) and Docker Swarm clust\", \"ers with Azure Resource Manager templates or the Azure portal to \\nensure that you can scale these ap\", \"plications to thousands\\u2014even tens of thousands\\u2014of containers. \\nYou deploy these clusters by using Az\", \"ure Virtual Machine Scale Sets, and the clusters take advantage \\nof Azure networking and storage off\", \"erings. To access Container Service, you need an Azure \\n \\n95 \\nCHAPTER 6 | Run, manage, and monitor D\", \"ocker production environments \\n \\nsubscription. With Container Service, you can take advantage of the\", \" enterprise-grade features of \\nAzure while still maintaining application portability, including at t\", \"he orchestration layers. \\nTable 6-1 lists common management tools related to their orchestrators, sc\", \"hedulers, and clustering \\nplatform. \\nTable 6-1. Docker management tools \\nManagement tools \\nDescripti\", \"on \\nRelated orchestrators \\nAzure Monitor for Containers \\nAzure dedicated \\nKubernetes \\nmanagement too\", \"l \\nAzure Kubernetes Services (AKS) \\nKubernetes Web UI \\n(dashboard) \\nKubernetes \\nmanagement tool, \\nca\", \"n monitor and \\nmanage local \\nKubernetes cluster \\nAzure Kubernetes Service (AKS) \\nLocal Kubernetes \\nA\", \"zure portal for Service Fabric \\nAzure Service Fabric Explorer \\nOnline and desktop \\nversion for manag\", \"ing \\nService Fabric \\nclusters, on Azure, on \\npremises, local \\ndevelopment, and \\nother clouds \\nAzure \", \"Service Fabric \\nContainer Monitoring (Azure \\nMonitor) \\nGeneral container \\nmanagement y \\nmonitoring s\", \"olution. \\nCan manage \\nKubernetes clusters \\nthrough Azure \\nMonitor for \\nContainers. \\nAzure Service Fa\", \"bric \\nAzure Kubernetes Service (AKS) \\nMesosphere DC/OS and others. \\nAzure Service Fabric \\nAnother ch\", \"oice for cluster-deployment and management is Azure Service Fabric. Service Fabric is a \\nMicrosoft m\", \"icroservices platform that includes container orchestration as well as developer \\nprogramming models\", \" to build highly scalable microservices applications. Service Fabric supports \\nDocker in Linux and W\", \"indows Containers and can run in Windows and Linux servers. \\nThe following are Service Fabric manage\", \"ment tools: \\n\\u2022 \\nAzure portal for Service Fabric cluster-related operations (create/update/delete) a \", \"cluster or \\nconfigure its infrastructure (VMs, load balancer, networking, etc.) \\n\\u2022 \\nAzure Service Fa\", \"bric Explorer is a specialized web UI and desktop multi-platform tool that \\nprovides insights and ce\", \"rtain operations on the Service Fabric cluster, from the nodes/VMs \\npoint of view and from the appli\", \"cation and services point of view. \\n \\n96 \\nCHAPTER 6 | Run, manage, and monitor Docker production env\", \"ironments \\n \\nMonitor containerized application services \\nIt\\u2019s critical for applications split into m\", \"ultiple containers and microservices to have a way to monitor \\nand analyze the behavior of the whole\", \" application. \\nAzure Monitor \\nAzure Monitor is an extensible analytics service that monitors your li\", \"ve application. It helps you to \\ndetect and diagnose performance issues and to understand what users\", \" actually do with your app. It\\u2019s \\ndesigned for developers, with the intent of helping you to continu\", \"ously improve the performance and \\nusability of your services or applications. Azure Monitor works w\", \"ith both web/services and standalone \\napps on a wide variety of platforms like .NET, Java, Node.js a\", \"nd many other platforms, hosted on-\\npremises or in the cloud. \\nAdditional resources \\n\\u2022 \\nOverview of \", \"Azure Monitor \\nhttps://learn.microsoft.com/azure/azure-monitor/overview \\n\\u2022 \\nWhat is Application Insi\", \"ghts? \\nhttps://learn.microsoft.com/azure/azure-monitor/app/app-insights-overview \\n\\u2022 \\nWhat is Azure M\", \"onitor Metrics? \\nhttps://learn.microsoft.com/azure/azure-monitor/platform/data-platform-metrics \\n\\u2022 \\n\", \"Container Monitoring solution in Azure Monitor \\nhttps://learn.microsoft.com/azure/azure-monitor/insi\", \"ghts/containers \\nSecurity and backup services \\nThere are many support chores with lots of details th\", \"at you have to handle to ensure your applications \\nand infrastructure are in top notch condition to \", \"support business needs, and the situation becomes \\nmore complicated in the microservices realm, so y\", \"ou need a way to have both high-level and detailed \\nviews when you need to take action. \\nAzure has t\", \"he tools to manage and provide a unified view of four critical aspects of both your cloud \\nand on-pr\", \"emises resources: \\n\\u2022 \\nSecurity. With Azure Security Center. \\n\\u2013 \\nGet full visibility and control over\", \" the security of your virtual machines, apps, and \\nworkloads. \\n\\u2013 \\nCentralize the management of your \", \"security policies and integrate existing processes \\nand tools. \\n\\u2013 \\nDetect real threats with advanced\", \" analytics. \\n\\u2022 \\nBackup. With Azure Backup. \\n\\u2013 \\nAvoid costly business disruptions, meet compliance go\", \"als, and protect your data \\nagainst ransomware and human errors. \\n\\u2013 \\nKeep your backup data encrypted\", \" in transit and at rest. \\n \\n97 \\nCHAPTER 6 | Run, manage, and monitor Docker production environments \", \"\\n \\n\\u2013 \\nEnsure access based on multifactor authentication to prevent unauthorized use. \\n\\u2022 \\nOn-premises\", \" resources. With hybrid cloud solutions. \\n \\n98 \\nCHAPTER 7 | Containerized Docker Application Lifecyc\", \"le key takeaways \\n \\nCHAPTER 7 \\nContainerized Docker \\nApplication Lifecycle key \\ntakeaways \\n\\u2022 \\nContai\", \"ner-based solutions provide important cost-saving benefits because containers solve \\ndeployment prob\", \"lems caused by dependency failures in production environments, thereby \\nimproving DevOps and product\", \"ion operations significantly. \\n\\u2022 \\nDocker has become the de facto standard in the container industry \", \"and is supported by the \\nmost significant vendors in the Linux and Windows ecosystems, including Mic\", \"rosoft. In the \\nfuture, Docker will be ubiquitous in any datacenter in the cloud or on-premises. \\n\\u2022 \", \"\\nA Docker container is becoming the standard unit of deployment for any server-based \\napplication or\", \" service. \\n\\u2022 \\nDocker orchestrators like the ones provided in Azure Kubernetes Service (AKS) and Azur\", \"e \\nService Fabric are fundamental and indispensable for any microservices-based or multi-\\ncontainer \", \"applications that have significant complexity and scalability needs. \\n\\u2022 \\nAn end-to-end DevOps enviro\", \"nment that supports Continuous Integration/Continuous \\nDeployment (CI/CD) and connects to the produc\", \"tion Docker environments can provide agility \\nand ultimately improve the time to market of your appl\", \"ications. \\n\\u2022 \\nAzure DevOps Services greatly simplifies your DevOps environment by deploying to Docke\", \"r \\nenvironments from your CI/CD pipelines. This statement applies to simple Docker \\nenvironments as \", \"well as to advanced microservice and container orchestrators based on \\nAzure. \\n\"]"