"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\fEDITION v6.0.0 - Updated to ASP.NET Core \", \"6.0 \\n\\nRefer changelog for the book updates and community contributions. \\n\\nThis guide is a general ov\", \"erview for developing and deploying containerized ASP.NET Core \\napplications with Docker, using the \", \"Microsoft platform and tools. The guide includes a high-level \\nintroduction to Azure DevOps, for imp\", \"lementing CI/CD pipelines, as well as Azure Container Registry \\n(ACR) and Azure Kubernetes Services \", \"AKS for deployment. \\n\\nFor low-level, development-related details you can see the .NET Microservices:\", \" Architecture for \\nContainerized .NET Applications guide and it related reference application eShopO\", \"nContainers. \\n\\nCredits \\n\\nAuthor: \\n\\nCesar de la Torre, Sr. PM, .NET product team, Microsoft Corp. \\n\\nA\", \"cquisitions Editor: \\n\\nJanine Patrick \\n\\nDevelopmental Editor: \\n\\nBob Russell, Solutions Professional a\", \"t Microsoft \\n\\nOctal Publishing, Inc. \\n\\nEditorial Production: \\n\\nDianne Russell \\n\\nOctal Publishing, In\", \"c. \\n\\nCopyeditor: \\n\\nBob Russell, Solutions Professional at Microsoft \\n\\nParticipants and reviewers: \\n\\n\", \"Nish Anil, Sr. Program Manager, .NET team, Microsoft \\n\\nMiguel Veloso, Software Development Engineer \", \"at Plain Concepts \\n\\nSumit Ghosh, Principal Consultant at Neudesic \\n\\nColin Dembovsky, DevOps Practice\", \" Lead, Cognizant Microsoft Business Group \\n\\nCopyright \\n\\nPUBLISHED BY \\n\\nMicrosoft Developer Division,\", \" .NET and Visual Studio product teams \\n\\nA division of Microsoft Corporation \\n\\n\\fOne Microsoft Way \\n\\nR\", \"edmond, Washington 98052-6399 \\n\\nCopyright \\u00a9 2022 by Microsoft Corporation \\n\\nAll rights reserved. No \", \"part of the contents of this book may be reproduced or transmitted in any \\nform or by any means with\", \"out the written permission of the publisher. \\n\\nThis book is provided \\u201cas-is\\u201d and expresses the autho\", \"r\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in this book, including URL \", \"and other Internet website references, may change \\nwithout notice. \\n\\nSome examples depicted herein a\", \"re provided for illustration only and are fictitious. No real association \\nor connection is intended\", \" or should be inferred. \\n\\nMicrosoft and the trademarks listed at https://www.microsoft.com on the \\u201cT\", \"rademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies. \\n\\nMac and macOS are trademar\", \"ks of Apple Inc. \\n\\nThe Docker whale logo is a registered trademark of Docker, Inc. Used by permissio\", \"n. \\n\\nAll other marks and logos are property of their respective owners. \\n\\n\\fContents \\n\\nOverview of Co\", \"ntainers and Docker ................................................................................\", \"...... 1 \\n\\nLearn Docker ............................................................................\", \".................................................................................................. 2\", \" \\n\\nComparing Docker containers with virtual machines ...............................................\", \"............................................ 3 \\n\\nA simple analogy ..................................\", \"....................................................................................................\", \"........................... 4 \\n\\nLearn Docker specific terminologies ................................\", \"................................................................................................ 4 \\n\", \"\\nLearn docker containers, images, and registries ...................................................\", \"...................................................... 6 \\n\\nRoad to modern applications based on cont\", \"ainers .............................................................................................\", \"...... 8 \\n\\nIntroduction to the Docker application life cycle .......................................\", \"......................... 9 \\n\\nContainers as the foundation for DevOps collaboration ................\", \"......................................................................... 9 \\n\\nChallenges in the appl\", \"ication life cycle when using Docker. ..............................................................\", \"............ 10 \\n\\nIntroduction to a generic end-to-end Docker application life cycle workflow ......\", \"................................. 11 \\n\\nBenefits of DevOps for containerized applications ...........\", \"................................................................................. 12 \\n\\nIntroduction \", \"to the Microsoft platform and tools for containerized apps ..................... 13 \\n\\nDesigning and \", \"developing containerized apps using Docker and Microsoft Azure ...... 17 \\n\\nDesign Docker application\", \"s ..................................................................................................\", \"............................................ 17 \\n\\nCommon container design principles ...............\", \"....................................................................................................\", \"........ 18 \\n\\nContainer equals a process ...........................................................\", \"............................................................................... 18 \\n\\nMonolithic appl\", \"ications ...........................................................................................\", \"........................................................... 18 \\n\\nMonolithic application deployed as \", \"a container ........................................................................................\", \"......... 21 \\n\\nPublish a single Docker container app to Azure App Service ..........................\", \".............................................. 21 \\n\\nState and data in Docker applications...........\", \"....................................................................................................\", \"........... 22 \\n\\nService-oriented applications .....................................................\", \"..................................................................................... 25 \\n\\nOrchestra\", \"ting microservices and multi-container applications for high scalability and availability.... 25 \\n\\nS\", \"oftware platforms for container clustering, orchestration, and scheduling ..........................\", \"................. 27 \\n\\nUsing container-based orchestrators in Azure ................................\", \"..................................................................... 28 \\n\\nUsing Azure Kubernetes Se\", \"rvice ..............................................................................................\", \".................................. 29 \\n\\nDevelopment environment for Kubernetes .....................\", \"...................................................................................... 30 \\n\\nGet star\", \"ted with Azure Kubernetes Service (AKS) ............................................................\", \"................................... 31 \\n\\ni \\n\\nContents \\n\\n \\n \\n\\fDeploy with Helm charts into Kubernetes\", \" clusters ..........................................................................................\", \"... 31 \\n\\nAdditional resources ......................................................................\", \"................................................................................. 32 \\n\\nUsing Azure S\", \"ervice Fabric ......................................................................................\", \"..................................................... 32 \\n\\nStateless versus stateful microservices .\", \"....................................................................................................\", \"............... 35 \\n\\nUsing Azure Service Fabric Mesh ...............................................\", \"................................................................................ 36 \\n\\nChoosing orche\", \"strators in Azure ..................................................................................\", \"............................................. 37 \\n\\nDeploy to Azure Kubernetes Service (AKS) ........\", \"....................................................................................................\", \".... 38 \\n\\nCreate the AKS environment in Azure ......................................................\", \"............................................................... 38 \\n\\nCreate the AKS cluster ........\", \"....................................................................................................\", \"........................................ 38 \\n\\nDevelopment environment for Docker apps ..............\", \"............................................................................................... 40 \\n\", \"\\nDevelopment tools choices: IDE or editor ..........................................................\", \".................................................... 40 \\n\\nLanguage and framework choices ...........\", \"....................................................................................................\", \"............. 41 \\n\\nInner-loop development workflow for Docker apps .................................\", \"............................................................. 41 \\n\\nBuilding a single app within a Do\", \"cker container using Visual Studio Code and Docker CLI............. 42 \\n\\nUse Docker Tools in Visual \", \"Studio on Windows ..................................................................................\", \"..................... 52 \\n\\nConfigure your local environment ........................................\", \".................................................................................... 52 \\n\\nDocker sup\", \"port in Visual Studio ..............................................................................\", \".................................................. 52 \\n\\nConfigure Docker tools .....................\", \"....................................................................................................\", \"......................... 55 \\n\\nUsing Windows PowerShell commands in a DockerFile to set up Windows C\", \"ontainers (Docker \\nstandard based) .................................................................\", \"....................................................................................................\", \" 56 \\n\\nBuild ASP.NET Core applications deployed as Linux containers into an AKS/Kubernetes orchestrat\", \"or\\n ................................................................................................\", \"....................................................................................................\", \".. 57 \\n\\nCreating the ASP.NET Core Project using Visual Studio 2022..................................\", \"...................................... 57 \\n\\nRegister the Solution in an Azure Container Registry (AC\", \"R) .......................................................................... 66 \\n\\nDocker applicatio\", \"n DevOps workflow with Microsoft tools ............................................. 74 \\n\\nSteps in t\", \"he outer-loop DevOps workflow for a Docker application .............................................\", \".................. 75 \\n\\nStep 1: Inner-loop development workflow ....................................\", \"........................................................................ 76 \\n\\nStep 2: Source-Code Co\", \"ntrol integration and management with Azure DevOps Services and Git 76 \\n\\nStep 3: Build, CI, Integrat\", \"e, and Test with Azure DevOps Services/GitHub and Docker ...................... 76 \\n\\nStep 4: CD, Dep\", \"loy ................................................................................................\", \"........................................................... 83 \\n\\nStep 5: Run and manage ............\", \"....................................................................................................\", \"............................... 89 \\n\\nStep 6: Monitor and diagnose ..................................\", \".................................................................................................. 8\", \"9 \\n\\nii \\n\\nContents \\n\\n \\n\\fCreate CI/CD pipelines in Azure DevOps Services for a .NET application on Con\", \"tainers and \\ndeploying to a Kubernetes cluster .....................................................\", \"............................................................................ 89 \\n\\nRun, manage, and m\", \"onitor Docker production environments ........................................ 93 \\n\\nRun composed and\", \" microservices-based applications in production environments ............................... 93 \\n\\nIn\", \"troduction to orchestrators, schedulers, and container clusters ....................................\", \"........................... 93 \\n\\nManage production Docker environments .............................\", \"................................................................................... 94 \\n\\nContainer S\", \"ervice and management tools ........................................................................\", \"..................................... 94 \\n\\nAzure Service Fabric ....................................\", \"....................................................................................................\", \"................ 95 \\n\\nMonitor containerized application services ...................................\", \"............................................................................ 96 \\n\\nAzure Monitor ....\", \"....................................................................................................\", \"........................................................... 96 \\n\\nSecurity and backup services.......\", \"....................................................................................................\", \"............................ 96 \\n\\nContainerized Docker Application Lifecycle key takeaways .........\", \".................................... 98 \\n\\niii \\n\\nContents \\n\\n \\n\\fCHAPTER  1 \\n\\nOverview of Containers \\na\", \"nd Docker \\n\\nContainerization is an approach to software development in which an application or servi\", \"ce, its \\ndependencies, and its configuration (abstracted as deployment manifest files) are packaged \", \"together as \\na container image. You then can test the containerized application as a unit and deploy\", \" it as a container \\nimage instance to the host operating system (OS). \\n\\nJust as shipping containers \", \"allow goods to be transported by ship, train, or truck regardless of the \\ncargo inside, software con\", \"tainers act as a standard unit of software deployment that can contain \\ndifferent code and dependenc\", \"ies. Containerizing software this way enables developers and IT \\nprofessionals to deploy them across\", \" environments with little or no modification. \\n\\nContainers also isolate applications from each other\", \" on a shared OS. Containerized applications run \\non top of a container host that in turn runs on the\", \" OS (Linux or Windows). Containers therefore have a \\nmuch smaller footprint than virtual machine (VM\", \") images. \\n\\nEach container can run a whole web application or a service, as shown in Figure 1-1. In \", \"this example, \\nDocker host is a container host, and App1, App2, Svc1, and Svc2 are containerized app\", \"lications or \\nservices. \\n\\nFigure 1-1. Multiple containers running on a container host \\n\\nAnother bene\", \"fit you can derive from containerization is scalability. You can scale out quickly by \\ncreating new \", \"containers for short-term tasks. From an application point of view, instantiating an \\nimage (creatin\", \"g a container) is similar to instantiating a process like a service or web app. For \\nreliability, ho\", \"wever, when you run multiple instances of the same image across multiple host servers, \\nyou typicall\", \"y want each container (image instance) to run in a different host server or VM in different \\nfault d\", \"omains. \\n\\nIn short, containers offer the benefits of isolation, portability, agility, scalability, a\", \"nd control across the \\nentire application lifecycle workflow. The most important benefit is the envi\", \"ronment isolation \\nprovided between Dev and Ops. \\n\\n1 \\n\\nCHAPTER 1 | Overview of Containers and Docker\", \" \\n\\n \\n \\n \\n\\fLearn Docker \\n\\nDocker is an open-source project for automating the deployment of applicati\", \"ons as portable, self-\\nsufficient containers that can run on the cloud or on-premises. Docker is als\", \"o a company that \\npromotes and evolves this technology, working in collaboration with cloud, Linux, \", \"and Windows \\nvendors, including Microsoft. \\n\\nFigure 1-2. Docker deploys containers at all layers of \", \"the hybrid cloud \\n\\nAs shown in the above diagram, Docker containers can run anywhere, on-premises in\", \" the customer \\ndatacenter, in an external service provider or in the cloud, on Azure. Docker image c\", \"ontainers can also \\nrun natively on Linux and Windows. However, Windows images can run only on Windo\", \"ws hosts and \\nLinux images can run on Linux hosts and Windows hosts (using a Hyper-V Linux VM, so fa\", \"r), where \\nhost means a server or a VM. \\n\\nDevelopers can use development environments on Windows, Li\", \"nux, or macOS. On the development \\ncomputer, the developer runs a Docker host where Docker images ar\", \"e deployed, including the app \\nand its dependencies. Developers who work on Linux or on the Mac, use\", \" a Docker host that\\u2019s Linux-\\nbased, and they can only create images for Linux containers. (Developer\", \"s working on the Mac can edit \\ncode or run the Docker command-line interface (CLI) from macOS, but a\", \"s of this writing, containers \\ndon\\u2019t run directly on macOS.) Developers who work on Windows can crea\", \"te images for either Linux or \\nWindows Containers. \\n\\nTo host containers in development environments \", \"and provide additional developer tools, Docker \\nships Docker Desktop for Windows or for macOS. These\", \" products install the necessary VM (the Docker \\nhost) to host the containers. \\n\\nTo run Windows Conta\", \"iners, there are two types of runtimes: \\n\\n\\u2022  Windows Server Containers provide application isolation\", \" through process and namespace \\n\\nisolation technology. A Windows Server Container shares a kernel wi\", \"th the container host and \\nwith all containers running on the host. \\n\\n\\u2022 \\n\\nHyper-V Containers expand \", \"on the isolation provided by Windows Server Containers by \\nrunning each container in a highly optimi\", \"zed virtual machine. In this configuration, the kernel \\nof the container host isn\\u2019t shared with the \", \"Hyper-V Containers, providing better isolation. \\n\\n2 \\n\\nCHAPTER 1 | Overview of Containers and Docker \", \"\\n\\n \\n \\n \\n\\fThe images for these containers are created and work just the same way. The difference is i\", \"n how the \\ncontainer is created from the image\\u2014running a Hyper-V Container requires an extra paramet\", \"er. For \\ndetails, see Hyper-V Containers. \\n\\nComparing Docker containers with virtual machines \\n\\nFigu\", \"re 1-3 shows a comparison between VMs and Docker containers. \\n\\nFigure 1-3. Comparison of traditional\", \" virtual machines to Docker containers \\n\\nAs shown in the above diagram, for VMs, there are three bas\", \"e layers in the host server. From the \\nbottom-up: Infrastructure, Host Operating System, and a Hyper\", \"visor. On top of all that, each VM has \\nits own OS and all necessary libraries. On the other hand, f\", \"or Docker, the host server only has the \\nInfrastructure and the OS. On top of that, the container en\", \"gine keeps containers isolated, but lets \\nthem share the single base OS\\u2019s services. \\n\\nBecause contai\", \"ners require far fewer resources (for example, they don\\u2019t need a full OS), they\\u2019re easy to \\ndeploy a\", \"nd they start fast. This allows you to have higher density, meaning that it allows you to run \\nmore \", \"services on the same hardware unit, thereby reducing costs. \\n\\nAs a side effect of running on the sam\", \"e kernel, you get less isolation than VMs. \\n\\nThe main goal of an image is to ensure the same environ\", \"ment (dependencies) across different \\ndeployments. This means that you can debug it on your machine \", \"and then deploy it to another \\nmachine, the same environment guaranteed. \\n\\nA container image is a wa\", \"y to package an app or service and deploy it in a reliable and reproducible \\nway. You could say that\", \" Docker isn\\u2019t only a technology but also a philosophy and a process. \\n\\n3 \\n\\nCHAPTER 1 | Overview of C\", \"ontainers and Docker \\n\\n \\n \\n \\n\\fWhen using Docker, you won\\u2019t hear developers say, \\u201cIt works on my mach\", \"ine, why not in production?\\u201d \\nThey can just say, \\u201cIt runs on Docker\\u201d, because the packaged Docker ap\", \"plication can be executed on \\nany supported Docker environment, and it runs the way it was intended \", \"to on all deployment targets \\n(such as Dev, QA, staging, and production). \\n\\nA simple analogy \\n\\nPerha\", \"ps a simple analogy can help getting the grasp of the core concept of Docker. \\n\\nLet\\u2019s go back in tim\", \"e to the 1950s for a moment. There were no word processors, and the \\nphotocopiers were used everywhe\", \"re (well, kind of). \\n\\nImagine you\\u2019re responsible for quickly issuing batches of letters as required,\", \" to mail them to \\ncustomers, using real paper and envelopes, to be delivered physically to each cust\", \"omer\\u2019s address \\n(there was no email back then). \\n\\nAt some point, you realize the letters are just a \", \"composition of a large set of paragraphs, which are \\npicked and arranged as needed, according to the\", \" purpose of the letter, so you devise a system to \\nissue letters quickly, expecting to get a hefty r\", \"aise. \\n\\nThe system is simple: \\n\\n1. \\n\\n2. \\n\\n3. \\n\\nYou begin with a deck of transparent sheets containin\", \"g one paragraph each. \\n\\nTo issue a set of letters, you pick the sheets with the paragraphs you need,\", \" then you stack and \\nalign them so they look and read fine. \\n\\nFinally, you place the set in the phot\", \"ocopier and press start to produce as many letters as \\nrequired. \\n\\nSo, simplifying, that\\u2019s the core \", \"idea of Docker. \\n\\nIn Docker, each layer is the resulting set of changes that happen to the filesyste\", \"m after executing a \\ncommand, such as, installing a program. \\n\\nSo, when you \\u201clook\\u201d at the filesystem\", \" after the layer has been copied, you see all the files, included the \\nlayer when the program was in\", \"stalled. \\n\\nYou can think of an image as an auxiliary read-only hard disk ready to be installed in a \", \"\\u201ccomputer\\u201d \\nwhere the operating system is already installed. \\n\\nSimilarly, you can think of a contain\", \"er as the \\u201ccomputer\\u201d with the image hard disk installed. The \\ncontainer, just like a computer, can b\", \"e powered on or off. \\n\\nLearn Docker specific terminologies \\n\\nThis section lists terms and definition\", \"s you should be familiar with before getting deeper into Docker. \\nFor further definitions, see the e\", \"xtensive glossary provided by Docker. \\n\\nContainer image: A package with all the dependencies and inf\", \"ormation needed to create a container. \\nAn image includes all the dependencies (such as frameworks) \", \"plus deployment and execution \\n\\n4 \\n\\nCHAPTER 1 | Overview of Containers and Docker \\n\\n \\n \\n\\fconfigurati\", \"on to be used by a container runtime. Usually, an image derives from multiple base images \\nthat are \", \"layers stacked on top of each other to form the container\\u2019s filesystem. An image is immutable \\nonce \", \"it has been created. \\n\\nDockerfile: A text file that contains instructions for building a Docker imag\", \"e. It\\u2019s like a batch script, \\nthe first line states the base image to begin with and then follow the\", \" instructions to install required \\nprograms, copy files, and so on, until you get the working enviro\", \"nment you need. \\n\\nBuild: The action of building a container image based on the information and conte\", \"xt provided by its \\nDockerfile, plus additional files in the folder where the image is built. You ca\", \"n build images with the \\nfollowing Docker command: \\n\\ndocker build \\n\\nContainer: An instance of a Dock\", \"er image. A container represents the execution of a single \\napplication, process, or service. It con\", \"sists of the contents of a Docker image, an execution \\nenvironment, and a standard set of instructio\", \"ns. When scaling a service, you create multiple instances \\nof a container from the same image. Or a \", \"batch job can create multiple containers from the same \\nimage, passing different parameters to each \", \"instance. \\n\\nVolumes: Offer a writable filesystem that the container can use. Since images are read-o\", \"nly but most \\nprograms need to write to the filesystem, volumes add a writable layer, on top of the \", \"container image, \\nso the programs have access to a writable filesystem. The program doesn\\u2019t know it\\u2019\", \"s accessing a \\nlayered filesystem, it\\u2019s just the filesystem as usual. Volumes live in the host syste\", \"m and are managed \\nby Docker. \\n\\nTag: A mark or label you can apply to images so that different image\", \"s or versions of the same image \\n(depending on the version number or the target environment) can be \", \"identified. \\n\\nMulti-stage Build: Is a feature, since Docker 17.05 or higher, that helps to reduce th\", \"e size of the final \\nimages. For example, a large base image, containing the SDK can be used for com\", \"piling and \\npublishing and then a small runtime-only base image can be used to host the application.\", \" \\n\\nRepository (repo): A collection of related Docker images, labeled with a tag that indicates the i\", \"mage \\nversion. Some repos contain multiple variants of a specific image, such as an image containing\", \" SDKs \\n(heavier), an image containing only runtimes (lighter), etc. Those variants can be marked wit\", \"h tags. A \\nsingle repo can contain platform variants, such as a Linux image and a Windows image. \\n\\nR\", \"egistry: A service that provides access to repositories. The default registry for most public images\", \" is \\nDocker Hub (owned by Docker as an organization). A registry usually contains repositories from \", \"\\nmultiple teams. Companies often have private registries to store and manage images they\\u2019ve created.\", \" \\nAzure Container Registry is another example. \\n\\nMulti-arch image: For multi-architecture, it\\u2019s a fe\", \"ature that simplifies the selection of the appropriate \\nimage, according to the platform where Docke\", \"r is running. For example, when a Dockerfile requests a \\nbase image FROM mcr.microsoft.com/dotnet/sd\", \"k:6.0 from the registry, it actually gets 6.0-\\nnanoserver-20H2, 6.0-nanoserver-1809 or 6.0-bullseye-\", \"slim, depending on the operating system \\nand version where Docker is running. \\n\\n5 \\n\\nCHAPTER 1 | Over\", \"view of Containers and Docker \\n\\n \\n \\n\\fDocker Hub: A public registry to upload images and work with th\", \"em. Docker Hub provides Docker \\nimage hosting, public or private registries, build triggers and web \", \"hooks, and integration with GitHub \\nand Bitbucket. \\n\\nAzure Container Registry: A public resource for\", \" working with Docker images and its components in \\nAzure. This provides a registry that\\u2019s close to y\", \"our deployments in Azure and that gives you control \\nover access, making it possible to use your Azu\", \"re Active Directory groups and permissions. \\n\\nDocker Trusted Registry (DTR): A Docker registry servi\", \"ce (from Docker) that can be installed on-\\npremises so it lives within the organization\\u2019s datacenter\", \" and network. It\\u2019s convenient for private \\nimages that should be managed within the enterprise. Dock\", \"er Trusted Registry is included as part of \\nthe Docker Datacenter product. \\n\\nDocker Desktop: Develop\", \"ment tools for Windows and macOS for building, running, and testing \\ncontainers locally. Docker Desk\", \"top for Windows provides development environments for both Linux \\nand Windows Containers. The Linux \", \"Docker host on Windows is based on a Hyper-V virtual machine. \\nThe host for Windows Containers is di\", \"rectly based on Windows. Docker Desktop for Mac is based on \\nthe Apple Hypervisor framework and the \", \"xhyve hypervisor, which provides a Linux Docker host virtual \\nmachine on macOS. Docker Desktop for W\", \"indows and for Mac replaces Docker Toolbox, which was \\nbased on Oracle VirtualBox. \\n\\nCompose: A comm\", \"and-line tool and YAML file format with metadata for defining and running multi-\\ncontainer applicati\", \"ons. You define a single application based on multiple images with one or more \\n.yml files that can \", \"override values depending on the environment. After you\\u2019ve created the definitions, \\nyou can deploy \", \"the whole multi-container application with a single command (docker-compose up) \\nthat creates a cont\", \"ainer per image on the Docker host. \\n\\nCluster: A collection of Docker hosts exposed as if it were a \", \"single virtual Docker host, so that the \\napplication can scale to multiple instances of the services\", \" spread across multiple hosts within the \\ncluster. Docker clusters can be created with Kubernetes, A\", \"zure Service Fabric, Docker Swarm and \\nMesosphere DC/OS. \\n\\nOrchestrator: A tool that simplifies the \", \"management of clusters and Docker hosts. Orchestrators \\nenable you to manage their images, container\", \"s, and hosts through a command-line interface (CLI) or a \\ngraphical UI. You can manage container net\", \"working, configurations, load balancing, service discovery, \\nhigh availability, Docker host configur\", \"ation, and more. An orchestrator is responsible for running, \\ndistributing, scaling, and healing wor\", \"kloads across a collection of nodes. Typically, orchestrator \\nproducts are the same products that pr\", \"ovide cluster infrastructure, like Kubernetes and Azure Service \\nFabric, among other offerings in th\", \"e market. \\n\\nLearn docker containers, images, and registries \\n\\nWhen using Docker, you create an app o\", \"r service and package it and its dependencies into a \\ncontainer image. An image is a static represen\", \"tation of the app or service and its configuration and \\ndependencies. \\n\\nTo run the app or service, t\", \"he app\\u2019s image is instantiated to create a container, which will be running \\non the Docker host. Con\", \"tainers are initially tested in a development environment or PC. \\n\\n6 \\n\\nCHAPTER 1 | Overview of Conta\", \"iners and Docker \\n\\n \\n \\n\\fYou store images in a registry that acts as a library of images. You need a \", \"registry when deploying to \\nproduction orchestrators. Docker maintains a public registry via Docker \", \"Hub; other vendors provide \\nregistries for different collections of images, including Azure Containe\", \"r Registry. Alternatively, \\nenterprises can have a private registry on-premises for their own Docker\", \" images. \\n\\nFigure 1-4 shows how images and registries in Docker relate to other components. It also \", \"shows the \\nmultiple registry offerings from vendors. \\n\\nFigure 1-4. Taxonomy of Docker terms and conc\", \"epts \\n\\nThe registry is like a bookshelf where images are stored and available to be pulled for build\", \"ing \\ncontainers to run services or web apps. There are private Docker registries on-premises and on \", \"the \\npublic cloud. Docker Hub is a public registry maintained by Docker, along the Docker Trusted Re\", \"gistry \\nan enterprise-grade solution, Azure offers the Azure Container Registry. AWS, Google and oth\", \"ers also \\nhave container registries. \\n\\nBy putting images in a registry, you can store static and imm\", \"utable application bits, including all \\nof their dependencies, at a framework level. You then can ve\", \"rsion and deploy images in multiple \\nenvironments and thus provide a consistent deployment unit. \\n\\n7\", \" \\n\\nCHAPTER 1 | Overview of Containers and Docker \\n\\n \\n \\n \\n\\fPrivate image registries, either hosted on\", \"-premises or in the cloud, are recommended when: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nYour images must not be shared publicly d\", \"ue to confidentiality. \\n\\nYou want to have minimum network latency between your images and your chose\", \"n \\ndeployment environment. For example, if your production environment is Azure, you probably \\nwant \", \"to store your images in Azure Container Registry so that network latency is minimal. In a \\nsimilar w\", \"ay, if your production environment is on-premises, you might want to have an on-\\npremises Docker Tru\", \"sted Registry available within the same local network. \\n\\nRoad to modern applications based on contai\", \"ners \\n\\nYou\\u2019re probably reading this book because you\\u2019re planning the development of new applications\", \" or \\nyou\\u2019re assessing the impact of using Docker, Containers, and new approaches like Microservices \", \"in \\nyour company. \\n\\nThe adoption of new development paradigms must be taken with caution before star\", \"ting a project, to \\nassess the impact on your dev teams, your budget, or your infrastructure. \\n\\nMicr\", \"osoft has been working on rich guidance, sample applications, and a suite of e-books that can \\nhelp \", \"you make an informed decision and guide your team through a successful development, \\ndeployment, and\", \" operations of your new applications. \\n\\nThis book belongs to a Microsoft suite of guides that cover \", \"many of the needs and challenges you\\u2019ll \\nface during the process of developing new modern applicatio\", \"ns based on containers. \\n\\nYou can find additional Microsoft e-books related to Docker containers in \", \"the list below: \\n\\n\\u2022 \\n\\n.NET Microservices: Architecture for Containerized .NET Applications \\nhttps://\", \"learn.microsoft.com/dotnet/architecture/microservices/ \\n\\n\\u2022  Modernize existing .NET applications wit\", \"h Azure cloud and Windows Containers \\n\\nhttps://learn.microsoft.com/dotnet/architecture/modernize-wit\", \"h-azure-containers/ \\n\\n8 \\n\\nCHAPTER 1 | Overview of Containers and Docker \\n\\n \\n \\n\\fCHAPTER  2 \\n\\nIntroduc\", \"tion to the Docker \\napplication life cycle \\n\\nThe life cycle of containerized applications is a journ\", \"ey that begins with the developer. The developer \\nchooses to implement containers and Docker because\", \" it eliminates frictions in deployments and IT \\noperations, which ultimately helps everyone to be mo\", \"re agile, more productive end-to-end, and faster. \\n\\nContainers as the foundation for DevOps \\ncollabo\", \"ration \\n\\nBy the very nature of the containers and Docker technology, developers can share their soft\", \"ware and \\ndependencies easily with IT operations and production environments while eliminating the t\", \"ypical \\u201cit \\nworks on my machine\\u201d excuse. Containers solve application conflicts between different en\", \"vironments. \\nIndirectly, containers and Docker bring developers and IT operations closer together, m\", \"aking it easier \\nfor them to collaborate effectively. Adopting the container workflow provides many \", \"customers \\nwith the DevOps continuity they\\u2019ve sought but previously had to implement via more comple\", \"x \\nconfiguration for release and build pipelines. Containers simplify the build/test/deploy pipeline\", \"s \\nin DevOps. \\n\\nFigure 2-1. Main workloads per \\u201cpersonas\\u201d in the life cycle for containerized Docker\", \" applications \\n\\nWith Docker containers, developers own what\\u2019s within the container (application and \", \"service, and \\ndependencies to frameworks and components) and how the containers and services behave \", \"together \\nas an application composed by a collection of services. The interdependencies of the multi\", \"ple \\ncontainers are defined in a docker-compose.yml file, or what could be called a deployment manif\", \"est. \\nMeanwhile, IT operations teams (IT professionals and management) can focus on the management \\n\", \"\\n9 \\n\\nCHAPTER 2 | Introduction to the Docker application life cycle \\n\\n \\n \\n \\n\\fof production environmen\", \"ts; infrastructure; scalability; monitoring; and, ultimately, ensuring that the \\napplications are de\", \"livering properly for the end users, without having to know the contents of the \\nvarious containers.\", \" Hence, the name \\u201ccontainer,\\u201d recalling the analogy to real-world shipping \\ncontainers. Thus, the ow\", \"ners of a container\\u2019s content need not concern themselves with how the \\ncontainer will be shipped, a\", \"nd the shipping company transports a container from its point of origin \\nto its destination without \", \"knowing or caring about the contents. In a similar manner, developers can \\ncreate and own the conten\", \"ts within a Docker container without the need to concern themselves with \\nthe \\u201ctransport\\u201d mechanisms\", \". \\n\\nIn the pillar on the left side of Figure 2-1, developers write and run code locally in Docker co\", \"ntainers \\nby using Docker for Windows or Mac. They define the operating environment for the code by \", \"using a \\nDockerfile that specifies the base operating system to run as well as the build steps for b\", \"uilding their \\ncode into a Docker image. The developers define how one or more images will interoper\", \"ate using the \\naforementioned docker-compose.yml file deployment manifest. As they complete their lo\", \"cal \\ndevelopment, they push their application code plus the Docker configuration files to the code \\n\", \"repository of their choice (that is, Git repository). \\n\\nThe DevOps pillar defines the build\\u2013Continuo\", \"us Integration (CI) pipelines using the Dockerfile \\nprovided in the code repository. The CI system p\", \"ulls the base container images from the selected \\nDocker registry and builds the custom Docker image\", \"s for the application. The images then are \\nvalidated and pushed to the Docker registry used for the\", \" deployments to multiple environments. \\n\\nIn the pillar on the right, operations teams manage deploye\", \"d applications and infrastructure in \\nproduction while monitoring the environment and applications s\", \"o that they can provide feedback and \\ninsights to the development team about how the application mig\", \"ht be improved. Container apps are \\ntypically run in production using container orchestrators like K\", \"ubernetes, where usually Helm charts \\nare used to configure deployment units, instead of docker-comp\", \"ose files. \\n\\nThe two teams are collaborating through a foundational platform (Docker containers) tha\", \"t provides \\na separation of concerns as a contract, while greatly improving the two teams\\u2019 collabora\", \"tion in the \\napplication life cycle. The developers own the container contents, its operating enviro\", \"nment, and the \\ncontainer interdependencies, whereas the operations teams take the built images alon\", \"g with the \\nmanifest and runs them in their orchestration system. \\n\\nChallenges in the application li\", \"fe cycle when using Docker. \\n\\nThere are many reasons that will increase the number of containerized \", \"applications in the upcoming \\nyears, and one of these reasons is the creation of applications based \", \"on microservices. \\n\\nDuring the last 15 years, the use of web services has been the base of thousands\", \" of applications, and \\nprobably, after a few years, you\\u2019ll find the same situation with microservice\", \"-based applications \\nrunning on Docker containers. \\n\\nIt is also worth to mention that you can also u\", \"se Docker containers for monolithic applications and \\nyou still get most of the benefits of Docker. \", \"Containers are not targeting only microservices. \\n\\nThe use of Docker containerization and microservi\", \"ces causes new challenges in the development \\nprocess of your organizations and therefore, you need \", \"a solid strategy to maintain many containers \\n\\n10 \\n\\nCHAPTER 2 | Introduction to the Docker applicati\", \"on life cycle \\n\\n \\n \\n\\fand microservices running on production systems. Eventually, enterprise applica\", \"tions will have \\nhundreds or thousands of containers/instances running in production. \\n\\nThese challe\", \"nges create new demands when using DevOps tools, so you\\u2019ll have to define new \\nprocesses in your Dev\", \"Ops activities, and find answers for the following type of questions: \\n\\n\\u2022  Which tools can I use for\", \" development, CI/CD, management and operations?? \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nHow can my company manage err\", \"ors in containers when running in production? \\n\\nHow can we change pieces of our software in producti\", \"on with minimum downtime? \\n\\nHow can we scale and monitor our production system? \\n\\nHow can we include\", \" the testing and deployment of containers in our release pipeline? \\n\\nHow can we use Open Source tool\", \"s/platforms for containers in Microsoft Azure? \\n\\nIf you can answer all those questions, you\\u2019ll be be\", \"tter prepared to move your applications (existing or \\nnew apps) to Docker containers. \\n\\nIntroduction\", \" to a generic end-to-end Docker application life cycle \\nworkflow \\n\\nFigure 2-2 presents a more detail\", \"ed workflow for a Docker application life cycle, focusing in this \\ninstance on specific DevOps activ\", \"ities and assets. \\n\\nFigure 2-2. High-level workflow for the Docker containerized application life cy\", \"cle \\n\\nEverything begins with the developer, who starts writing code in the inner-loop workflow. The \", \"inner-\\nloop stage is where developers define everything that happens before pushing code into the co\", \"de \\nrepository (for example, a source control system such as Git). After it\\u2019s committed, the reposit\", \"ory \\ntriggers Continuous Integration (CI) and the rest of the workflow. \\n\\n11 \\n\\nCHAPTER 2 | Introduct\", \"ion to the Docker application life cycle \\n\\n \\n \\n \\n\\fThe inner loop consists of typical steps like \\u201ccod\", \"e,\\u201d \\u201crun,\\u201d \\u201ctest,\\u201d and \\u201cdebug,\\u201d plus the additional steps \\nneeded right before running the app local\", \"ly. This is the developer\\u2019s process to run and test the app as \\na Docker container. The inner-loop w\", \"orkflow will be explained in the sections that follow. \\n\\nTaking a step back to look at the end-to-en\", \"d workflow, the DevOps workflow is more than a \\ntechnology or a tool set, it\\u2019s a mindset that requir\", \"es cultural evolution. It\\u2019s people, processes, and the \\nappropriate tools to make your application l\", \"ife cycle faster and more predictable. Enterprises that \\nadopt a containerized workflow typically re\", \"structure their organizations to represent people and \\nprocesses that match the containerized workfl\", \"ow. \\n\\nPracticing DevOps can help teams respond faster together to competitive pressures by replacing\", \" \\nerror-prone manual processes with automation, which results in improved traceability and repeatabl\", \"e \\nworkflows. Organizations also can manage environments more efficiently and realize cost savings w\", \"ith \\na combination of on-premises and cloud resources as well as tightly integrated tooling. \\n\\nWhen \", \"implementing your DevOps workflow for Docker applications, you\\u2019ll see that Docker \\ntechnologies are \", \"present in almost every stage of the workflow, from your development box while \\nworking in the inner\", \" loop (code, run, debug), the build-test-CI phase, and, finally, the deployment of \\nthose containers\", \" to the staging and production environments. \\n\\nImprovement of quality practices helps to identify de\", \"fects early in the development cycle, which \\nreduces the cost of fixing them. By including the envir\", \"onment and dependencies in the image and \\nadopting a philosophy of deploying the same image across m\", \"ultiple environments, you promote a \\ndiscipline of extracting the environment-specific configuration\", \"s making deployments more reliable. \\n\\nRich data obtained through effective instrumentation (monitori\", \"ng and diagnostics) provides insight \\ninto performance issues and user behavior to guide future prio\", \"rities and investments. \\n\\nDevOps should be considered a journey, not a destination. It should be imp\", \"lemented incrementally \\nthrough appropriately scoped projects from which you can demonstrate success\", \", learn, and evolve. \\n\\nBenefits of DevOps for containerized applications \\n\\nHere are some of the most\", \" important benefits provided by a solid DevOps workflow: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nDeliver better-qualit\", \"y software, faster and with better compliance. \\n\\nDrive continuous improvement and adjustments earlie\", \"r and more economically. \\n\\nIncrease transparency and collaboration among stakeholders involved in de\", \"livering and \\noperating software. \\n\\nControl costs and utilize provisioned resources more effectively\", \" while minimizing security \\nrisks. \\n\\nPlug and play well with many of your existing DevOps investment\", \"s, including investments in \\nopen-source. \\n\\n12 \\n\\nCHAPTER 2 | Introduction to the Docker application \", \"life cycle \\n\\n \\n \\n\\fCHAPTER  3 \\n\\nIntroduction to the \\nMicrosoft platform \\nand tools for containerized \", \"\\napps \\n\\nVision: Create an adaptable, enterprise-grade, containerized application life cycle that spa\", \"ns your \\ndevelopment, IT operations, and production management. \\n\\nFigure 3-1 shows the main pillars \", \"in the life cycle of Docker apps classified by the type of work \\ndelivered by multiple teams (app-de\", \"velopment, DevOps infrastructure processes, and IT management \\nand operations). Usually, in the ente\", \"rprise, the profiles of \\u201cthe persona\\u201d responsible for each area are \\ndifferent. So are their skills.\", \" \\n\\n13 \\n\\nCHAPTER 3 | Introduction to the Microsoft platform and tools for containerized apps \\n\\n \\n \\n\\fF\", \"igure 3-1. Main pillars in the life cycle for containerized Docker applications with Microsoft platf\", \"orm and tools \\n\\nA containerized Docker life-cycle workflow can be initially prescriptive based on \\u201cb\", \"y-default product \\nchoices,\\u201d making it easier for developers to get started faster, but it\\u2019s fundame\", \"ntal that under the \\nhood there must be an open framework so that it will be a flexible workflow cap\", \"able of adjusting to \\nthe different contexts from each organization or enterprise. The workflow infr\", \"astructure (components \\nand products) must be flexible enough to cover the environment that each com\", \"pany will have in the \\nfuture, even being capable of swapping development or DevOps products to othe\", \"rs. This flexibility, \\nopenness, and the broad choice of technologies in the platform and infrastruc\", \"ture are precisely the \\nMicrosoft priorities for containerized Docker applications, as explained in \", \"the chapters that follow. \\n\\nTable 3-1 demonstrates that the intention of the Azure DevOps for contai\", \"nerized Docker applications \\nis to provide an open DevOps workflow so that you can choose what produ\", \"cts to use for each phase \\n(Microsoft or third-party) while providing a simplified workflow that pro\", \"vides \\u201cby-default-products\\u201d \\nalready connected; thus, you can quickly get started with your enterpri\", \"se-level DevOps workflow for \\nDocker apps. \\n\\nTable 3-1. DevOps workflows, open to any technology \\n\\nH\", \"ost \\n\\nMicrosoft technologies \\n\\nThird-party (Azure pluggable) \\n\\nPlatform for \\nDocker apps \\n\\n\\u2022 Microso\", \"ft Visual Studio and \\nVisual Studio Code \\n\\u2022 .NET \\n\\u2022 Microsoft Azure Kubernetes \\nService (AKS) \\n\\u2022 Azu\", \"re Container Registry\\\\ \\n\\n\\u2022 Any code editor (for example, Sublime) \\n\\u2022 Any language (Node.js, Java, Go\", \", etc.) \\n\\u2022 Any orchestrator and scheduler \\n\\u2022 Any Docker registry\\\\ \\n\\n14 \\n\\nCHAPTER 3 | Introduction to\", \" the Microsoft platform and tools for containerized apps \\n\\n \\n \\n \\n\\fHost \\n\\nMicrosoft technologies \\n\\nTh\", \"ird-party (Azure pluggable) \\n\\n\\u2022 Azure DevOps Services \\n\\u2022 Microsoft Team Foundation \\nServer \\n\\u2022 GitHub\", \" \\n\\u2022 Azure Kubernetes Service \\n(AKS)\\\\ \\n\\n\\u2022 GitHub, Git, Subversion, etc. \\n\\u2022 Jenkins, Chef, Puppet, Vel\", \"ocity, CircleCI, \\nTravisCI, etc. \\n\\u2022 On-premises Docker Datacenter, Kubernetes, \\nMesos DC/OS, etc.\\\\ \\n\", \"\\n\\u2022 Azure Monitor \\n\\n\\u2022 Marathon, Chronos, etc.\\\\ \\n\\nDevOps for \\nDocker apps \\n\\nManagement \\nand \\nmonitorin\", \"g \\n\\nThe Microsoft platform and tools for containerized Docker apps, as defined in Table 3-1, compris\", \"e the \\nfollowing components: \\n\\n\\u2022 \\n\\nPlatform for Docker Apps development The development of a service\", \", or collection of \\nservices that make up an \\u201capp.\\u201d The development platform provides all the work d\", \"evelopers \\nrequires prior to pushing their code to a shared code repository. Developing services, \\nd\", \"eployed as containers, are similar to the development of the same apps or services without \\nDocker. \", \"You continue to use your preferred language (.NET, Node.js, Go, etc.) and preferred \\neditor or IDE l\", \"ike Visual Studio or Visual Studio Code. However, rather than consider Docker a \\ndeployment destinat\", \"ion, you develop your services in the Docker environment. You build, run, \\ntest, and debug your code\", \" in containers locally, providing the destination environment at \\ndevelopment time. By providing the\", \" destination environment locally, Docker containers set up \\nwhat will drastically help you improve y\", \"our DevOps life cycle. Visual Studio and Visual Studio \\nCode have extensions to integrate Docker con\", \"tainers within your development process. \\n\\n\\u2022 \\n\\nDevOps for Docker Apps Developers creating Docker app\", \"lications can use Azure DevOps, \\nGitHub or any other third-party product, like Jenkins, to build out\", \" a comprehensive \\nautomated application life-cycle management (ALM). \\n\\n   With Azure DevOps and/or G\", \"itHub, developers can create container-focused DevOps for a \\n\\nfast, iterative process that covers so\", \"urce-code control from anywhere (Azure DevOps-Git, \\nGitHub, any remote Git repository, or Subversion\", \"), Continuous Integration (CI), internal unit \\ntests, inter-container/service integration tests, Con\", \"tinuous Delivery (CD), and release \\nmanagement (RM). Developers also can automate their Docker appli\", \"cation releases into Azure \\nKubernetes Service (AKS), from development to staging and production env\", \"ironments. \\n\\n\\u2022  Management and Monitoring IT can manage and monitor production applications and \\nser\", \"vices in several ways, integrating both perspectives in a consolidated experience. \\n\\n\\u2013 \\n\\n\\u2013 \\n\\nAzure p\", \"ortal  Azure Kubernetes Service (AKS) helps you to set up and maintain your \\nDocker environments. Yo\", \"u can also use other orchestrators to visualize and configure \\nyour cluster. \\n\\nDocker tools  You can\", \" manage your container applications using familiar tools. \\nThere\\u2019s no need to change your existing D\", \"ocker management practices to move \\ncontainer workloads to the cloud. Use the application management\", \" tools you\\u2019re \\n\\n15 \\n\\nCHAPTER 3 | Introduction to the Microsoft platform and tools for containerized \", \"apps \\n\\n \\n \\n\\falready familiar with and connect via the standard API endpoints for the orchestrator \\no\", \"f your choice. You also can use other third-party tools to manage your Docker \\napplications or even \", \"CLI Docker tools. \\n\\nEven if you\\u2019re familiar with Linux commands, you can manage your container \\nappl\", \"ications using Microsoft Windows and PowerShell with a Linux Subsystem \\ncommand line and the product\", \"s (Docker, Kubernetes\\u2026) clients running on this Linux \\nSubsystem capability. You\\u2019ll learn more about\", \" using these tools under Linux \\nSubsystem using your favorite Microsoft Windows OS later in this boo\", \"k. \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\nOpen-source tools  Because AKS exposes the standard API endpoints for the \\norchestr\", \"ation engine, the most popular tools are compatible with AKS and, in most \\ncases, will work out of t\", \"he box\\u2014including visualizers, monitoring, command-line \\ntools, and even future tools as they become \", \"available. \\n\\nGitHub Advanced Security  GitHub Advanced Security offers a suite of tools for \\nsecurin\", \"g the software supply chain that can seamlessly integrate security into the \\ndaily workflow of teams\", \" developing containerized applications. \\n\\nAzure Monitor Is Azure\\u2019s solution to monitor every angle o\", \"f your production \\nenvironment. You can monitor production Docker applications by just setting up it\", \"s \\nSDK into your services so that you can get system-generated log data from the \\napplications. \\n\\nTh\", \"us, Microsoft offers a complete foundation for an end-to-end containerized Docker application life \\n\", \"cycle. However, it\\u2019s a collection of products and technologies that allow you to optionally select a\", \"nd \\nintegrate with existing tools and processes. The flexibility in a broad approach along with the \", \"strength \\nin the depth of capabilities place Microsoft in a strong position for containerized Docker\", \" application \\ndevelopment. \\n\\n16 \\n\\nCHAPTER 3 | Introduction to the Microsoft platform and tools for c\", \"ontainerized apps \\n\\n \\n \\n  \\n\\fCHAPTER  4 \\n\\nDesigning and developing \\ncontainerized apps using \\nDocker \", \"and Microsoft \\nAzure \\n\\nVision: Design and develop scalable solutions with Docker in mind. \\n\\nThere ar\", \"e many great-fit use cases for containers, not just for microservices-oriented architectures, but \\na\", \"lso when you simply have regular services or web applications to run and you want to reduce friction\", \"s \\nbetween development and production environment deployments. \\n\\nDesign Docker applications \\n\\nChapte\", \"r 1 introduced the fundamental concepts regarding containers and Docker. That information is \\nthe ba\", \"sic level of information you need to get started. But, enterprise applications can be complex and \\nc\", \"omposed of multiple services instead of a single service or container. For those optional use cases,\", \" \\nyou need to know additional approaches to design, such as Service-Oriented Architecture (SOA) and \", \"\\nthe more advanced microservices concepts and container orchestration concepts. The scope of this \\nd\", \"ocument is not limited to microservices but to any Docker application life cycle, therefore, it does\", \" \\nnot explore microservices architecture in depth because you can also use containers and Docker wit\", \"h \\nregular SOA, background tasks or jobs, or even with monolithic application deployment approaches.\", \" \\n\\nMore info To learn more about enterprise applications and microservices architecture in depth, re\", \"ad \\nthe guide NET Microservices: Architecture for Containerized .NET Applications that you can also \", \"\\ndownload from https://aka.ms/MicroservicesEbook. \\n\\nHowever, before you get into the application lif\", \"e cycle and DevOps, it\\u2019s important to know how you\\u2019re \\ngoing to design and construct your applicatio\", \"n and what are your design choices. \\n\\n17 \\n\\nCHAPTER 4 | Designing and developing containerized apps u\", \"sing Docker and Microsoft Azure \\n\\n \\n \\n\\fCommon container design principles \\n\\nAhead of getting into th\", \"e development process there are a few basic concepts worth mentioning with \\nregard to how you use co\", \"ntainers. \\n\\nContainer equals a process \\n\\nIn the container model, a container represents a single pro\", \"cess. By defining a container as a process \\nboundary, you begin to create the primitives used to sca\", \"le, or batch-off, processes. When you run a \\nDocker container, you\\u2019ll see an ENTRYPOINT definition. \", \"This defines the process and the lifetime of \\nthe container. When the process completes, the contain\", \"er life-cycle ends. There are long-running \\nprocesses, such as web servers, and short-lived processe\", \"s, such as batch jobs, which might have \\nbeen implemented as Microsoft Azure WebJobs. If the process\", \" fails, the container ends, and the \\norchestrator takes over. If the orchestrator was instructed to \", \"keep five instances running and one fails, \\nthe orchestrator will create another container to replac\", \"e the failed process. In a batch job, the process \\nis started with parameters. When the process comp\", \"letes, the work is complete. \\n\\nYou might find a scenario in which you want multiple processes runnin\", \"g in a single container. In any \\narchitecture document, there\\u2019s never a \\u201cnever,\\u201d nor is there always\", \" an \\u201calways.\\u201d For scenarios requiring \\nmultiple processes, a common pattern is to use Supervisor. \\n\\n\", \"Monolithic applications \\n\\nIn this scenario, you\\u2019re building a single and monolithic web application \", \"or service and deploying it as \\na container. Within the application, the structure might not be mono\", \"lithic; it might comprise several \\nlibraries, components, or even layers (application layer, domain \", \"layer, data access layer, etc.). \\nExternally, it\\u2019s a single container, like a single process, single\", \" web application, or single service. \\n\\nTo manage this model, you deploy a single container to repres\", \"ent the application. To scale it, just add \\na few more copies with a load balancer in front. The sim\", \"plicity comes from managing a single \\ndeployment in a single container or virtual machine (VM). \\n\\nFo\", \"llowing the principal that a container does one thing only, and does it in one process, the \\nmonolit\", \"hic pattern is in conflict. You can include multiple components/libraries or internal layers \\nwithin\", \" each container, as illustrated in Figure 4-1. \\n\\n18 \\n\\nCHAPTER 4 | Designing and developing container\", \"ized apps using Docker and Microsoft Azure \\n\\n \\n \\n\\fFigure 4-1. An example of monolithic application a\", \"rchitecture \\n\\nA monolithic app has all or most of its functionality within a single process or conta\", \"iner and it\\u2019s \\ncomponentized in internal layers or libraries. The downside to this approach comes if\", \" or when the \\napplication grows, requiring it to scale. If the entire application scaled, it\\u2019s not r\", \"eally a problem. \\nHowever, in most cases, a few parts of the application are the choke points that r\", \"equire scaling, \\nwhereas other components are used less. \\n\\nUsing the typical e-commerce example, wha\", \"t you likely need is to scale the product information \\ncomponent. Many more customers browse product\", \"s than purchase them. More customers use their \\nbasket than use the payment pipeline. Fewer customer\", \"s add comments or view their purchase history. \\nAnd you likely have only a handful of employees, in \", \"a single region, that need to manage the content \\nand marketing campaigns. By scaling the monolithic\", \" design, all of the code is deployed multiple times. \\n\\nIn addition to the \\u201cscale-everything\\u201d problem\", \", changes to a single component require complete \\nretesting of the entire application as well as a c\", \"omplete redeployment of all the instances. \\n\\nThe monolithic approach is common, and many organizatio\", \"ns are developing with this architectural \\nmethod. Many enjoy good enough results, whereas others en\", \"counter limits. Many designed their \\napplications in this model because the tools and infrastructure\", \" were too difficult to build SOAs, and \\nthey didn\\u2019t see the need\\u2014until the app grew. \\n\\nFrom an infra\", \"structure perspective, each server can run many applications within the same host and \\nhave an accep\", \"table ratio of efficiency in your resources usage, as shown in Figure 4-2. \\n\\n19 \\n\\nCHAPTER 4 | Design\", \"ing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-2. A host r\", \"unning multiple apps/containers \\n\\nFinally, from an availability perspective, monolithic applications\", \" must be deployed as a whole; that \\nmeans that in case you must stop and start, all functionality an\", \"d all users will be affected during the \\ndeployment window. In certain situations, the use of Azure \", \"and containers can minimize these \\nsituations and reduce the probability of downtime of your applica\", \"tion, as you can see in Figure 4-3. \\n\\nYou can deploy monolithic applications in Azure by using dedic\", \"ated VMs for each instance. Using \\nAzure VM Scale Sets, you can scale the VMs easily. \\n\\nYou can also\", \" use Azure App Services to run monolithic applications and easily scale instances without \\nhaving to\", \" manage the VMs. Azure App Services can run single instances of Docker containers, as well, \\nsimplif\", \"ying the deployment. \\n\\nYou can deploy multiple VMs as Docker hosts and run any number of containers \", \"per VM. Then, by \\nusing an Azure Load Balancer, as illustrated in the Figure 4-3, you can manage sca\", \"ling. \\n\\nFigure 4-3. Multiple hosts scaling out a single Docker application \\n\\nYou can manage the depl\", \"oyment of the hosts themselves via traditional deployment techniques. \\n\\nYou can manage Docker contai\", \"ners from the command line by using commands like docker run and \\ndocker-compose up, and you can als\", \"o automate it in Continuous Delivery (CD) pipelines and deploy \\nto Docker hosts from Azure DevOps Se\", \"rvices, for instance. \\n\\n20 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker an\", \"d Microsoft Azure \\n\\n \\n \\n \\n \\n\\fMonolithic application deployed as a container \\n\\nThere are benefits to \", \"using containers to manage monolithic deployments. Scaling the instances of \\ncontainers is far faste\", \"r and easier than deploying additional VMs. \\n\\nDeploying updates as Docker images is far faster and n\", \"etwork efficient. Docker containers typically \\nstart in seconds, speeding rollouts. Tearing down a D\", \"ocker container is as easy as invoking the docker \\nstop command, typically completing in less than a\", \" second. \\n\\nBecause containers are inherently immutable, by design, you never need to worry about cor\", \"rupted \\nVMs because an update script forgot to account for some specific configuration or file left \", \"on disk. \\n\\nAlthough monolithic apps can benefit from Docker, we\\u2019re touching on only the tips of the \", \"benefits. \\nThe larger benefits of managing containers come from deploying with container orchestrato\", \"rs that \\nmanage the various instances and life cycle of each container instance. Breaking up the mon\", \"olithic \\napplication into subsystems that can be scaled, developed, and deployed individually is you\", \"r entry \\npoint into the realm of microservices. \\n\\nTo learn about how to \\u201clift and shift\\u201d monolithic \", \"applications with containers and how you can \\nmodernize your applications, you can read this additio\", \"nal Microsoft guide, Modernize existing .NET \\napplications with Azure cloud and Windows Containers, \", \"which you can also download as PDF from \\nhttps://aka.ms/LiftAndShiftWithContainersEbook. \\n\\nPublish a\", \" single Docker container app to Azure App Service \\n\\nEither because you want to get a quick validatio\", \"n of a container deployed to Azure or because the \\napp is simply a single-container app, Azure App S\", \"ervices provides a great way to provide scalable \\nsingle-container services. \\n\\nUsing Azure App Servi\", \"ce is intuitive and you can get up and running quickly because it provides great \\nGit integration to\", \" take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure. \\nBut, traditi\", \"onally (with no Docker), if you needed other capabilities, frameworks, or dependencies that \\naren\\u2019t \", \"supported in App Services, you needed to wait for it until the Azure team updates those \\ndependencie\", \"s in App Service or switched to other services like Service Fabric, Cloud Services, or even \\nplain V\", \"Ms, for which you have further control and can install a required component or framework for \\nyour a\", \"pplication. \\n\\nNow, as shown in Figure 4-4, when using Visual Studio 2022, container support in Azure\", \" App Service \\ngives you the ability to include whatever you want in your app environment. If you add\", \"ed a \\ndependency to your app, because you\\u2019re running it in a container, you get the capability of in\", \"cluding \\nthose dependencies in your Dockerfile or Docker image. \\n\\n21 \\n\\nCHAPTER 4 | Designing and dev\", \"eloping containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n\\fFigure 4-4. Publishing a containe\", \"r to Azure App Service from Visual Studio apps/containers \\n\\nFigure 4-4 also shows that the publish f\", \"low pushes an image through a Container Registry, which can \\nbe the Azure Container Registry (a regi\", \"stry near to your deployments in Azure and secured by Azure \\nActive Directory groups and accounts) o\", \"r any other Docker Registry like Docker Hub or on-premises \\nregistries. \\n\\nState and data in Docker a\", \"pplications \\n\\nIn most cases, you can think of a container as an instance of a process. A process doe\", \"s not maintain \\npersistent state. While a container can write to its local storage, assuming that an\", \" instance will be \\naround indefinitely is like assuming that a single location in memory will be dur\", \"able. Container \\nimages, like processes, should be assumed to have multiple instances and that they \", \"will eventually be \\nkilled; if they\\u2019re managed with a container orchestrator, it should be assumed t\", \"hat they might get \\nmoved from one node or VM to another. \\n\\nThe following solutions are used to mana\", \"ge persistent data in Docker applications: \\n\\nFrom the Docker host, as Docker Volumes: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nVolu\", \"mes are stored in an area of the host filesystem that\\u2019s managed by Docker. \\n\\nBind mounts can map to \", \"any folder in the host filesystem, so access can\\u2019t be controlled from \\na Docker process and can pose\", \" a security risk as a container could access sensitive OS folders. \\n\\n22 \\n\\nCHAPTER 4 | Designing and \", \"developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\f\\u2022 \\n\\ntmpfs mounts are like vi\", \"rtual folders that only exist in the host\\u2019s memory and are never \\nwritten to the filesystem. \\n\\nFrom \", \"remote storage: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAzure Storage provides geo-distributable storage, providing a good long-te\", \"rm persistence \\nsolution for containers. \\n\\nRemote relational databases like Azure SQL Database, NoSQ\", \"L databases like Azure Cosmos \\nDB, or cache services like Redis. \\n\\nFrom the Docker container: \\n\\n\\u2022 \\n\\n\", \"\\u2022 \\n\\nDocker provides a feature named the overlay file system. This feature implements a copy-on-\\nwrit\", \"e task that stores updated information to the root file system of the container. That \\ninformation \\u201c\", \"lays on top of\\u201d the original image on which the container is based. If the \\ncontainer is deleted fro\", \"m the system, those changes are lost. Therefore, while it\\u2019s possible to \\nsave the state of a contain\", \"er within its local storage, designing a system based on this feature \\nwould conflict with the premi\", \"se of container design, which by default is stateless. \\n\\nHowever, Docker Volumes is now the preferre\", \"d way to handle local data in Docker. If you \\nneed more information about storage in containers, che\", \"ck on Docker storage drivers and \\nAbout images, containers, and storage drivers. \\n\\nThe following pro\", \"vides additional detail about these options. \\n\\nVolumes are directories mapped from the host OS to di\", \"rectories in containers. When code in the \\ncontainer has access to the directory, that access is act\", \"ually to a directory on the host OS. This \\ndirectory is not tied to the lifetime of the container it\", \"self, and the directory is managed by Docker and \\nisolated from the core functionality of the host m\", \"achine. Thus, data volumes are designed to persist \\ndata independently of the life of the container.\", \" If you delete a container or an image from the Docker \\nhost, the data persisted in the data volume \", \"is not deleted. \\n\\nVolumes can be named or anonymous (the default). Named volumes are the evolution o\", \"f Data \\nVolume Containers and make it easy to share data between containers. Volumes also support \\nv\", \"olume drivers that allow you to store data on remote hosts, among other options. \\n\\nBind mounts have \", \"been available for a long time and allow the mapping of any folder to a mount \\npoint in a container.\", \" Bind mounts have more limitations than volumes and some important security \\nissues, so volumes are \", \"the recommended option. \\n\\ntmpfs mounts are virtual folders that live only in the host\\u2019s memory and a\", \"re never written to the \\nfilesystem. They are fast and secure but use memory and are only meant for \", \"non-persistent data. \\n\\nAs shown in Figure 4-5, regular Docker volumes can be stored outside of the c\", \"ontainers themselves \\nbut within the physical boundaries of the host server or VM. However, Docker c\", \"ontainers cannot \\naccess a volume from one host server or VM to another. In other words, with these \", \"volumes, it isn\\u2019t \\npossible to manage data shared between containers that run on different Docker ho\", \"sts, although it \\ncould be achieved with a volume driver that supports remote hosts. \\n\\n23 \\n\\nCHAPTER \", \"4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n\\fFigure 4-5. \", \"Volumes and external data sources for container-based applications \\n\\nIn addition, when Docker contai\", \"ners are managed by an orchestrator, containers might \\u201cmove\\u201d \\nbetween hosts, depending on the optimi\", \"zations performed by the cluster. Therefore, it isn\\u2019t \\nrecommended that you use data volumes for bus\", \"iness data. But they are a good mechanism to work \\nwith trace files, temporal files, or similar, tha\", \"t will not impact business data consistency. \\n\\nRemote data sources and cache tools like Azure SQL Da\", \"tabase, Azure Cosmos DB, or a remote cache \\nlike Redis can be used in containerized applications the\", \" same way they are used when developing \\nwithout containers. This is a proven way to store business \", \"application data. \\n\\nAzure Storage. Business data usually needs to be placed in external resources or\", \" databases, like \\nAzure Storage. Azure Storage provides the following services in the cloud: \\n\\n\\u2022 \\n\\n\\u2022\", \" \\n\\n\\u2022 \\n\\nBlob storage stores unstructured object data. A blob can be any type of text or binary data, \", \"\\nsuch as document or media files (images, audio, and video files). Blob storage is also referred \\nto\", \" as Object storage. \\n\\nFile storage offers shared storage for legacy applications using the standard \", \"SMB protocol. \\nAzure virtual machines and cloud services can share file data across application comp\", \"onents \\nvia mounted shares. On-premises applications can access file data in a share via the File \\nS\", \"ervice REST API. \\n\\nTable storage stores structured datasets. Table storage is a NoSQL key-attribute \", \"data store, \\nwhich allows rapid development and fast access to large quantities of data. \\n\\nRelationa\", \"l databases and NoSQL databases. There are many choices for external databases, from \\nrelational dat\", \"abases like SQL Server, PostgreSQL, Oracle, or NoSQL databases like Azure Cosmos DB, \\nMongoDB, etc. \", \"These databases are not going to be explained as part of this guide since they are a \\ndifferent topi\", \"c altogether. \\n\\n24 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Micros\", \"oft Azure \\n\\n \\n \\n \\n\\fService-oriented applications \\n\\nService-Oriented Architecture (SOA) was an overus\", \"ed term that meant many different things to \\ndifferent people. But as a common denominator, SOA mean\", \"s that you structure the architecture of \\nyour application by decomposing it into several services (\", \"most commonly as HTTP services) that can \\nbe classified in different types like subsystems or, in ot\", \"her cases, as tiers. \\n\\nToday, you can deploy those services as Docker containers, which solve deploy\", \"ment-related issues \\nbecause all of the dependencies are included in the container image. However, w\", \"hen you need to \\nscale out SOAs, you might encounter challenges if you\\u2019re deploying based on single \", \"instances. This \\nchallenge can be handled using Docker clustering software or an orchestrator. You\\u2019l\", \"l get to look at \\norchestrators in greater detail in the next section, when you explore microservice\", \"s approaches. \\n\\nDocker containers are useful (but not required) for both traditional service-oriente\", \"d architectures and \\nthe more advanced microservices architectures. \\n\\nAt the end of the day, the con\", \"tainer clustering solutions are useful for both a traditional SOA \\narchitecture and for a more advan\", \"ced microservices architecture in which each microservice owns its \\ndata model. And thanks to multip\", \"le databases, you can also scale out the data tier instead of working \\nwith monolithic databases sha\", \"red by the SOA services. However, the discussion about splitting the \\ndata is purely about architect\", \"ure and design. \\n\\nOrchestrating microservices and multi-container \\napplications for high scalability\", \" and availability \\n\\nUsing orchestrators for production-ready applications is essential if your appli\", \"cation is based on \\nmicroservices or split across multiple containers. As introduced previously, in \", \"a microservice-based \\napproach, each microservice owns its model and data so that it will be autonom\", \"ous from a \\ndevelopment and deployment point of view. But even if you have a more traditional applic\", \"ation that\\u2019s \\ncomposed of multiple services (like SOA), you\\u2019ll also have multiple containers or serv\", \"ices comprising a \\nsingle business application that need to be deployed as a distributed system. The\", \"se kinds of systems \\nare complex to scale out and manage; therefore, you absolutely need an orchestr\", \"ator if you want to \\nhave a production-ready and scalable multi-container application. \\n\\nFigure 4-6 \", \"illustrates deployment into a cluster of an application composed of multiple microservices \\n(contain\", \"ers). \\n\\n25 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azur\", \"e \\n\\n \\n \\n\\fFigure 4-6. A cluster of containers \\n\\nIt looks like a logical approach. But how are you han\", \"dling load balancing, routing, and orchestrating \\nthese composed applications? \\n\\nThe Docker CLI meet\", \"s the needs of managing one container on one host, but it falls short when it \\ncomes to managing mul\", \"tiple containers deployed on multiple hosts for more complex distributed \\napplications. In most case\", \"s, you need a management platform that will automatically start containers, \\nscale out containers wi\", \"th multiple instances per image, suspend them, or shut them down when \\nneeded, and ideally also cont\", \"rol how they access resources like the network and data storage. \\n\\nTo go beyond the management of in\", \"dividual containers or simple composed apps and move toward \\nlarger enterprise applications with mic\", \"roservices, you must turn to orchestration and clustering \\nplatforms. \\n\\nFrom an architecture and dev\", \"elopment point of view, if you\\u2019re building large, enterprise, \\nmicroservices-based, applications, it\", \"\\u2019s important to understand the following platforms and products \\nthat support advanced scenarios: \\n\\n\", \"\\u2022 \\n\\nClusters and orchestrators. When you need to scale out applications across many Docker \\nhosts, s\", \"uch as with a large microservices-based application, it\\u2019s critical to be able to manage \\nall of thos\", \"e hosts as a single cluster by abstracting the complexity of the underlying platform. \\nThat\\u2019s what t\", \"he container clusters and orchestrators provide. Examples of orchestrators are \\nAzure Service Fabric\", \" and Kubernetes. Kubernetes is available in Azure through Azure \\nKubernetes Service. \\n\\n26 \\n\\nCHAPTER \", \"4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\f\\u2022 \\n\\nSchedu\", \"lers. Scheduling means to have the capability for an administrator to launch containers \\nin a cluste\", \"r, so schedulers also provide a user interface for doing so. A cluster scheduler has \\nseveral respon\", \"sibilities: to use the cluster\\u2019s resources efficiently, to set the constraints \\nprovided by the user\", \", to efficiently load-balance containers across nodes or hosts, and to be \\nrobust against errors whi\", \"le providing high availability. \\n\\nThe concepts of a cluster and a scheduler are closely related, so \", \"the products provided by different \\nvendors often provide both sets of capabilities. The section bel\", \"ow shows the most important platform \\nand software choices you have for clusters and schedulers. The\", \"se orchestrators are widely offered in \\npublic clouds like Azure. \\n\\nSoftware platforms for container\", \" clustering, orchestration, and \\nscheduling \\n\\nPlatform \\n\\nKubernetes \\n\\nAzure Kubernetes Service (AKS)\", \" \\n\\nComments \\n\\nKubernetes is an open-source product that \\nprovides functionality that ranges from \\ncl\", \"uster infrastructure and container \\nscheduling to orchestrating capabilities. It \\nlets you automate \", \"deployment, scaling, \\nand operations of application containers \\nacross clusters of hosts. \\n\\nKubernet\", \"es provides a container-centric \\ninfrastructure that groups application \\ncontainers into logical uni\", \"ts for easy \\nmanagement and discovery. \\n\\nKubernetes is mature in Linux, less mature \\nin Windows. \\n\\nA\", \"zure Kubernetes Service (AKS) is a \\nmanaged Kubernetes container \\norchestration service in Azure tha\", \"t \\nsimplifies Kubernetes cluster\\u2019s \\nmanagement, deployment, and \\noperations. \\n\\n27 \\n\\nCHAPTER 4 | Desi\", \"gning and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n \\n \\n\\fPlatform \\n\\nA\", \"zure Service Fabric \\n\\nComments \\n\\nService Fabric is a Microsoft microservices \\nplatform for building \", \"applications. It\\u2019s an \\norchestrator of services and creates \\nclusters of machines. Service Fabric ca\", \"n \\ndeploy services as containers or as plain \\nprocesses. It can even mix services in \\nprocesses with\", \" services in containers \\nwithin the same application and cluster. \\n\\nService Fabric clusters can be d\", \"eployed in \\nAzure, on-premises or in any cloud. \\nHowever, deployment in Azure is \\nsimplified with a \", \"managed approach. \\n\\nService Fabric provides additional and \\noptional prescriptive Service Fabric \\npr\", \"ogramming models like stateful services \\nand Reliable Actors. \\n\\nService Fabric is mature in Windows \", \"(years \\nevolving in Windows), less mature in Linux. \\n\\nBoth Linux and Windows containers are \\nsupport\", \"ed in Service Fabric since 2017. \\n\\n | Azure Service Fabric Mesh offers the same reliability, mission\", \"-\\n\\nAzure Service Fabric Mesh  \\ncritical performance and scale as Service Fabric, but also offers a f\", \"ully managed and serverless \\nplatform. You don\\u2019t need to manage a cluster, VMs, storage or networkin\", \"g configuration. You just \\nfocus on your application\\u2019s development.   Service Fabric Mesh supports b\", \"oth Windows and Linux \\ncontainers, allowing you to develop with any programming language and framewo\", \"rk of your choice. \\n\\nAzure Container Apps  \\nmanaged serverless container service for building and de\", \"ploying modern apps at scale. | \\n\\n | Azure Container Apps is a \\n\\nUsing container-based orchestrators\", \" in Azure \\n\\nSeveral cloud vendors offer Docker containers support plus Docker clusters and orchestra\", \"tion support, \\nincluding Azure, Amazon EC2 Container Service, and Google Container Engine. Azure pro\", \"vides Docker \\n\\n28 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microso\", \"ft Azure \\n\\n \\n \\n \\n \\n \\n \\n \\n\\fcluster and orchestrator support through Azure Kubernetes Service (AKS), A\", \"zure Service Fabric, and \\nAzure Service Fabric Mesh. \\n\\nUsing Azure Kubernetes Service \\n\\nA Kubernetes\", \" cluster pools several Docker hosts and exposes them as a single virtual Docker host, so \\nyou can de\", \"ploy multiple containers into the cluster and scale-out with any number of container \\ninstances. The\", \" cluster will handle all the complex management plumbing, like scalability, health, and \\nso forth. \\n\", \"\\nAKS provides a way to simplify the creation, configuration, and management of a cluster of virtual \", \"\\nmachines in Azure that are preconfigured to run containerized applications. Using an optimized \\ncon\", \"figuration of popular open-source scheduling and orchestration tools, AKS enables you to use \\nyour e\", \"xisting skills or draw on a large and growing body of community expertise to deploy and \\nmanage cont\", \"ainer-based applications on Microsoft Azure. \\n\\nAzure Kubernetes Service optimizes the configuration \", \"of popular Docker clustering open-source tools \\nand technologies specifically for Azure. You get an \", \"open solution that offers portability for both your \\ncontainers and your application configuration. \", \"You select the size, the number of hosts, and the \\norchestrator tools, and AKS handles everything el\", \"se. \\n\\n29 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \", \"\\n\\n \\n \\n\\fFigure 4-7. Kubernetes cluster\\u2019s simplified structure and topology \\n\\nFigure 4-7 shows the str\", \"ucture of a Kubernetes cluster where a master node (VM) controls most of the \\ncoordination of the cl\", \"uster, and you can deploy containers to the rest of the nodes that are managed \\nas a single pool fro\", \"m an application point of view. This allows you to scale to thousands or even tens \\nof thousands of \", \"containers. \\n\\nDevelopment environment for Kubernetes \\n\\nIn the development environment that Docker an\", \"nounced in July 2018, Kubernetes can also run in a \\nsingle development machine (Windows 10 or macOS)\", \" by just installing Docker Desktop. You can later \\ndeploy to the cloud (AKS) for further integration\", \" tests, as shown in figure 4-8. \\n\\n30 \\n\\nCHAPTER 4 | Designing and developing containerized apps using\", \" Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-8. Running Kubernetes in dev machine and the cloud \\n\\nG\", \"et started with Azure Kubernetes Service (AKS) \\n\\nTo begin using AKS, you deploy an AKS cluster from \", \"the Azure portal or by using the CLI. For more \\ninformation on deploying a Kubernetes cluster to Azu\", \"re, see Deploy an Azure Kubernetes Service \\n(AKS) cluster. \\n\\nThere are no fees for any of the softwa\", \"re installed by default as part of AKS. All default options are \\nimplemented with open-source softwa\", \"re. AKS is available for multiple virtual machines in Azure. \\nYou\\u2019re charged only for the compute in\", \"stances you choose, as well as the other underlying \\ninfrastructure resources consumed, such as stor\", \"age and networking. There are no incremental charges \\nfor AKS itself. \\n\\nFor further implementation i\", \"nformation on deployment to Kubernetes based on kubectl and original \\n.yaml files, see Deploy to Azu\", \"re Kubernetes Service (AKS). \\n\\nDeploy with Helm charts into Kubernetes clusters \\n\\nWhen deploying an \", \"application to a Kubernetes cluster, you can use the original kubectl.exe CLI tool \\nusing deployment\", \" files based on the native format (.yaml files), as already mentioned in the previous \\nsection. Howe\", \"ver, for more complex Kubernetes applications such as when deploying complex \\nmicroservice-based app\", \"lications, it\\u2019s recommended to use Helm. \\n\\nHelm Charts helps you define, version, install, share, up\", \"grade, or rollback even the most complex \\nKubernetes application. Helm is maintained by the Cloud Na\", \"tive Computing Foundation (CNCF) in \\ncollaboration with Microsoft, Google, Bitnami, and the Helm con\", \"tributor community. \\n\\nFor further implementation information on Helm charts and Kubernetes, see the \", \"section called Install \\neShopOnContainers using Helm. \\n\\n31 \\n\\nCHAPTER 4 | Designing and developing co\", \"ntainerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fAdditional resources \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nGetting st\", \"arted with Azure Kubernetes Service (AKS) \\nhttps://learn.microsoft.com/azure/aks/kubernetes-walkthro\", \"ugh-portal \\n\\nKubernetes. The official site. \\nhttps://kubernetes.io/ \\n\\nUsing Azure Service Fabric \\n\\nA\", \"zure Service Fabric arose from Microsoft\\u2019s transition from delivering \\u201cbox\\u201d products, which were \\nty\", \"pically monolithic in style, to delivering services. The experience of building and operating large \", \"\\nservices at scale, such as Azure SQL Database, Azure Cosmos DB, Azure Service Bus, or Cortana\\u2019s \\nBa\", \"ckend, shaped Service Fabric. The platform evolved over time as more and more services adopted \\nit. \", \"Importantly, Service Fabric had to run not only in Azure but also in standalone Windows Server \\ndepl\", \"oyments. \\n\\nThe aim of Service Fabric is to solve the hard problems of building and running a service\", \" and utilizing \\ninfrastructure resources efficiently, so that teams can solve business problems usin\", \"g a microservices \\napproach. \\n\\nService Fabric provides two broad areas to help you build application\", \"s that use a microservices \\napproach: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nA platform that provides system services to deploy, \", \"scale, upgrade, detect, and restart failed \\nservices, discover service location, manage state, and m\", \"onitor health. These system services in \\neffect enable many of the characteristics of microservices \", \"described previously. \\n\\nProgramming APIs, or frameworks, to help you build applications as microserv\", \"ices: reliable \\nactors and reliable services. You can choose any code to build your microservice, bu\", \"t these \\nAPIs make the job more straightforward, and they integrate with the platform at a deeper \\nl\", \"evel. This way you can get health and diagnostics information, or you can take advantage of \\nreliabl\", \"e state management. \\n\\nService Fabric is agnostic with respect to how you build your service, and you\", \" can use any technology. \\nHowever, it provides built-in programming APIs that make it easier to buil\", \"d microservices. \\n\\nAs shown in Figure 4-10, you can create and run microservices in Service Fabric e\", \"ither as simple \\nprocesses or as Docker containers. It\\u2019s also possible to mix container-based micros\", \"ervices with \\nprocess-based microservices within the same Service Fabric cluster. \\n\\n32 \\n\\nCHAPTER 4 |\", \" Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n\\fFigure 4-10. De\", \"ploying microservices as processes or as containers in Azure Service Fabric \\n\\nIn the first image, yo\", \"u see microservices as processes, where each node runs one process for each \\nmicroservice. In the se\", \"cond image, you see microservices as containers, where each node runs Docker \\nwith several container\", \"s, one container per microservice. Service Fabric clusters based on Linux and \\nWindows hosts can run\", \" Docker Linux containers and Windows Containers, respectively. \\n\\nFor up-to-date information about co\", \"ntainers support in Azure Service Fabric, see Service Fabric and \\ncontainers. \\n\\nService Fabric is a \", \"good example of a platform where you can define a different logical architecture \\n(business microser\", \"vices or Bounded Contexts) than the physical implementation. For example, if you \\nimplement Stateful\", \" Reliable Services in Azure Service Fabric, which are introduced in the next section, \\n\\u201cStateless ve\", \"rsus stateful microservices,\\u201d you have a business microservice concept with multiple \\nphysical servi\", \"ces. \\n\\nAs shown in Figure 4-10, and thinking from a logical/business microservice perspective, when \", \"\\nimplementing a Service Fabric Stateful Reliable Service, you usually will need to implement two tie\", \"rs \\nof services. The first is the back-end stateful reliable service, which handles multiple partiti\", \"ons (each \\npartition is a stateful service). The second is the front-end service, or Gateway service\", \", in charge of \\nrouting and data aggregation across multiple partitions or stateful service instance\", \"s. That Gateway \\nservice also handles client-side communication with retry loops accessing the back-\", \"end service. It\\u2019s \\ncalled a Gateway service if you implement your custom service, or alternatively y\", \"ou can also use the \\nout-of-the-box Service Fabric reverse proxy. \\n\\n33 \\n\\nCHAPTER 4 | Designing and d\", \"eveloping containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-11. Business microse\", \"rvice with several stateful service instances and a custom gateway front end \\n\\nIn any case, when you\", \" use Service Fabric Stateful Reliable Services, you also have a logical or business \\nmicroservice (B\", \"ounded Context) that\\u2019s composed of multiple physical services. Each of them, the \\nGateway service, a\", \"nd Partition service could be implemented as ASP.NET Web API services, as shown \\nin Figure 4-11. Ser\", \"vice Fabric has prescription to support several stateful reliable services in containers. \\n\\nIn Servi\", \"ce Fabric, you can group and deploy groups of services as a Service Fabric Application, which is \\nth\", \"e unit of packaging and deployment for the orchestrator or cluster. Therefore, the Service Fabric \\nA\", \"pplication could be mapped to this autonomous business and logical microservice boundary or \\nBounded\", \" Context, as well, so you could deploy these services autonomously. \\n\\nService Fabric and containers \", \"\\n\\nWith regard to containers in Service Fabric, you can also deploy services in container images with\", \"in a \\nService Fabric cluster. As Figure 4-12 shows, most of the time there will only be one containe\", \"r per \\nservice. \\n\\nFigure 4-12. Business microservice with several services (containers) in Service F\", \"abric \\n\\n34 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azur\", \"e \\n\\n \\n \\n \\n \\n\\fA Service Fabric application can run several containers accessing an external database \", \"and the whole \\nset would be the logical boundary of a Business Microservice. However, so-called \\u201csid\", \"ecar\\u201d containers \\n(two containers that must be deployed together as part of a logical service) are a\", \"lso possible in \\nService Fabric. The important thing is that a business microservice is the logical \", \"boundary around \\nseveral cohesive elements. In many cases, it might be a single service with a singl\", \"e data model, but in \\nsome other cases you might have several physical services as well. \\n\\nNote that\", \" you can mix services in processes, and services in containers, in the same Service Fabric \\napplicat\", \"ion, as shown in Figure 4-13. \\n\\nFigure 4-13. Business microservice mapped to a Service Fabric applic\", \"ation with containers and stateful services \\n\\nFor more information about container support in Azure \", \"Service Fabric, see Service Fabric and \\ncontainers. \\n\\nStateless versus stateful microservices \\n\\nAs m\", \"entioned earlier, each microservice (logical Bounded Context) must own its domain model (data \\nand l\", \"ogic). In the case of stateless microservices, the databases will be external, employing relational \", \"\\noptions like SQL Server, or NoSQL options like Azure Cosmos DB or MongoDB. \\n\\nBut the services thems\", \"elves can also be stateful in Service Fabric, which means that the data resides \\nwithin the microser\", \"vice. This data might exist not just on the same server, but within the microservice \\nprocess, in me\", \"mory and persisted on hard drives and replicated to other nodes. Figure 4-14 shows the \\ndifferent ap\", \"proaches. \\n\\n35 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft \", \"Azure \\n\\n \\n \\n \\n\\fFigure 4-14. Stateless versus stateful microservices \\n\\nIn stateless services, the sta\", \"te (persistence, database) is kept out of the microservice. In stateful \\nservices, state is kept ins\", \"ide the microservice. A stateless approach is perfectly valid and is easier to \\nimplement than state\", \"ful microservices, since the approach is similar to traditional and well-known \\npatterns. But statel\", \"ess microservices impose latency between the process and data sources. They also \\ninvolve more movin\", \"g pieces when you\\u2019re trying to improve performance with additional cache and \\nqueues. The result is \", \"that you can end up with complex architectures that have too many tiers. \\n\\nIn contrast, stateful mic\", \"roservices can excel in advanced scenarios, because there\\u2019s no latency between \\nthe domain logic and\", \" data. Heavy data processing, gaming back ends, databases as a service, and \\nother low-latency scena\", \"rios all benefit from stateful services, which enable local state for faster access. \\n\\nStateless and\", \" stateful services are complementary. For instance, as you can see in the right diagram in \\nFigure 4\", \"-14, a stateful service can be split into multiple partitions. To access those partitions, you \\nmigh\", \"t need a stateless service acting as a gateway service that knows how to address each partition \\nbas\", \"ed on partition keys. \\n\\nStateful services do have drawbacks. They impose a high complexity level to \", \"be scaled out. \\nFunctionality that would usually be implemented by external database systems must be\", \" addressed for \\ntasks such as data replication across stateful microservices and data partitioning. \", \"However, this is one \\nof the areas where an orchestrator like Azure Service Fabric with its stateful\", \" reliable services can help \\nthe most\\u2014by simplifying the development and lifecycle of stateful micro\", \"services using the Reliable \\nServices API and Reliable Actors. \\n\\nOther microservice frameworks that \", \"allow stateful services, support the Actor pattern, and improve \\nfault tolerance and latency between\", \" business logic and data are Microsoft Orleans, from Microsoft \\nResearch, and Akka.NET. Both framewo\", \"rks are currently improving their support for Docker. \\n\\nRemember that Docker containers are themselv\", \"es stateless. If you want to implement a stateful \\nservice, you need one of the additional prescript\", \"ive and higher-level frameworks noted earlier. \\n\\nUsing Azure Service Fabric Mesh \\n\\nAzure Service Fab\", \"ric Mesh is a fully managed service that enables developers to build and deploy \\nmission critical ap\", \"plications without managing any infrastructure. Use Service Fabric Mesh to build \\nand run secure, di\", \"stributed microservices applications that scale on demand. \\n\\n36 \\n\\nCHAPTER 4 | Designing and developi\", \"ng containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fAs shown in figure 4-15, application\", \"s hosted on Service Fabric Mesh run and scale without you \\nworrying about the infrastructure powerin\", \"g it. \\n\\nFigure 4-15. Deploying a microservice/containers application to Service Fabric Mesh \\n\\nUnder \", \"the covers, Service Fabric Mesh consists of clusters of thousands of machines. All cluster \\noperatio\", \"ns are hidden from the developer. You simply need to upload your containers and specify \\nresources y\", \"ou need, availability requirements, and resource limits. Service Fabric Mesh automatically \\nallocate\", \"s the infrastructure requested by your application deployment and also handles infrastructure \\nfailu\", \"res, making sure your applications are highly available. You only need to care about the health \\nand\", \" responsiveness of your application, not the infrastructure. \\n\\nFor further information, see the Serv\", \"ice Fabric Mesh documentation. \\n\\nChoosing orchestrators in Azure \\n\\nThe following table provides guid\", \"ance on what orchestrator to use depending on workloads and OS \\nfocus. \\n\\nFigure 4-16. Orchestrator s\", \"election in Azure guidance \\n\\n37 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Dock\", \"er and Microsoft Azure \\n\\n \\n \\n \\n \\n\\fDeploy to Azure Kubernetes Service (AKS) \\n\\nYou can interact with A\", \"KS using your preferred client operating system (Windows, macOS, or Linux) \\nwith Azure command-line \", \"interface (Azure CLI) installed. For more details, refer Azure CLI \\ndocumentation and Installation g\", \"uide for the available environments. \\n\\nCreate the AKS environment in Azure \\n\\nThere are several ways \", \"to create the AKS Environment. It can be done by using Azure CLI commands \\nor by using the Azure por\", \"tal. \\n\\nHere you can explore some examples using the Azure CLI to create the cluster and the Azure po\", \"rtal to \\nreview the results. You also need to have Kubectl and Docker in your development machine. \\n\", \"\\nCreate the AKS cluster \\n\\nCreate the AKS cluster using this command (the resource group must exist):\", \" \\n\\naz aks create --resource-group explore-docker-aks-rg --name explore-docker-aks --node-\\nvm-size St\", \"andard_B2s --node-count 1 --generate-ssh-keys --location westeurope \\n\\nNote \\n\\nThe --node-vm-size and \", \"--node-count parameter values are good enough for a sample/dev \\napplication. \\n\\nAfter the creation jo\", \"b finishes, you can see: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nThe AKS cluster created in the initial resource group \\n\\nA new, re\", \"lated resource group, containing the resources related to the AKS cluster, as show in \\nthe following\", \" images. \\n\\nThe initial resource group, with the AKS cluster: \\n\\n38 \\n\\nCHAPTER 4 | Designing and develo\", \"ping containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n\\fFigure 4-17. AKS Resource Group \", \"view from Azure. \\n\\nThe AKS cluster resource group: \\n\\nFigure 4-18. AKS view from Azure. \\n\\nImportant \\n\", \"\\nIn general, you shouldn\\u2019t need to modify the resources in the AKS cluster resource group. For \\nexam\", \"ple, the resource group is deleted when you delete the AKS cluster. \\n\\nYou can also view the node cre\", \"ated using Azure CLI and Kubectl. \\n\\nFirst, getting the credentials: \\n\\naz aks get-credentials --resou\", \"rce-group explore-docker-aks-rg --name explore-docker-\\naks \\n\\n39 \\n\\nCHAPTER 4 | Designing and developi\", \"ng containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n\\fFigure 4-19. aks get-credentials c\", \"ommand result. \\n\\nAnd then, getting nodes from Kubectl: \\n\\nkubectl get nodes \\n\\nFigure 4-20. kubectl ge\", \"t nodes command result. \\n\\nDevelopment environment for Docker apps \\n\\nDevelopment tools choices: IDE o\", \"r editor \\n\\nNo matter if you prefer a full and powerful IDE or a lightweight and agile editor, Micros\", \"oft has you \\ncovered when it comes to developing Docker applications. \\n\\nVisual Studio Code and Docke\", \"r CLI (cross-platform tools for Mac, Linux, and \\nWindows) \\n\\nIf you prefer a lightweight, cross-platf\", \"orm editor supporting any development language, you can use \\nVisual Studio Code and Docker CLI. Thes\", \"e products provide a simple yet robust experience, which is \\ncritical for streamlining the developer\", \" workflow. By installing \\u201cDocker for Mac\\u201d or \\u201cDocker for \\nWindows\\u201d (development environment), Docker\", \" developers can use a single Docker CLI to build apps \\nfor both Windows or Linux (runtime environmen\", \"t). Plus, Visual Studio Code supports extensions for \\nDocker with IntelliSense for Dockerfiles and s\", \"hortcut-tasks to run Docker commands from the editor. \\n\\nNote \\n\\nTo download Visual Studio Code, go to\", \" https://code.visualstudio.com/download. \\n\\nTo download Docker for Mac and Windows, go to https://www\", \".docker.com/products/docker. \\n\\nVisual Studio with Docker Tools (Windows development machine) \\n\\nIt\\u2019s \", \"recommended that you use Visual Studio 2022 or later with the built-in Docker Tools enabled. \\nWith V\", \"isual Studio, you can develop, run, and validate your applications directly in the chosen Docker \\nen\", \"vironment. Press F5 to debug your application (single container or multiple containers) directly in \", \"a \\nDocker host, or press Ctrl+F5 to edit and refresh your app without having to rebuild the containe\", \"r. It\\u2019s \\nthe simplest and most powerful choice for Windows developers to create Docker containers fo\", \"r Linux \\nor Windows. \\n\\n40 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and\", \" Microsoft Azure \\n\\n \\n \\n \\n \\n\\fVisual Studio for Mac (Mac development machine) \\n\\nYou can use Visual Stu\", \"dio for Mac when developing Docker-based applications. Visual Studio for Mac \\noffers a richer IDE wh\", \"en compared to Visual Studio Code for Mac. \\n\\nLanguage and framework choices \\n\\nYou can develop Docker\", \" applications using Microsoft tools with most modern languages. The \\nfollowing is an initial list, b\", \"ut you\\u2019re not limited to it: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n.NET and ASP.NET Core \\n\\nNode.js \\n\\nGo \\n\\nJava \\n\", \"\\nRuby \\n\\nPython \\n\\nBasically, you can use any modern language supported by Docker in Linux or Windows.\", \" \\n\\nInner-loop development workflow for Docker apps \\n\\nBefore triggering the outer-loop workflow spann\", \"ing the entire DevOps cycle, it all begins on each \\ndeveloper\\u2019s machine, coding the app itself, usin\", \"g their preferred languages or platforms, and testing it \\nlocally (Figure 4-21). But in every case, \", \"you\\u2019ll have an important point in common, no matter what \\nlanguage, framework, or platforms you choo\", \"se. In this specific workflow, you\\u2019re always developing and \\ntesting Docker containers in no other e\", \"nvironments, but locally. \\n\\nFigure 4-21. Inner-loop development context \\n\\nThe container or instance \", \"of a Docker image will contain these components: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAn operating system selection (fo\", \"r example, a Linux distribution or Windows) \\n\\nFiles added by the developer (for example, app binarie\", \"s) \\n\\nConfiguration (for example, environment settings and dependencies) \\n\\nInstructions for what proc\", \"esses to run by Docker \\n\\nYou can set up the inner-loop development workflow that utilizes Docker as \", \"the process (described in \\nthe next section). Consider that the initial steps to set up the environm\", \"ent are not included, because \\nyou only need to do it once. \\n\\n41 \\n\\nCHAPTER 4 | Designing and develop\", \"ing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fBuilding a single app within a Dock\", \"er container using Visual Studio \\nCode and Docker CLI \\n\\nApps are made up from your own services plus\", \" additional libraries (dependencies). \\n\\nFigure 4-22 shows the basic steps that you usually need to c\", \"arry out when building a Docker app, \\nfollowed by detailed descriptions of each step. \\n\\nFigure 4-22.\", \" High-level workflow for the life cycle for Docker containerized applications using Docker CLI \\n\\nSte\", \"p 1: Start coding in Visual Studio Code and create your initial app/service \\nbaseline \\n\\nThe way you \", \"develop your application is similar to the way you do it without Docker. The difference is \\nthat whi\", \"le developing, you\\u2019re deploying and testing your application or services running within Docker \\ncont\", \"ainers placed in your local environment (like a Linux VM or Windows). \\n\\nSetting up your local enviro\", \"nment \\n\\nWith the latest versions of Docker Desktop for Mac and Windows, it\\u2019s easier than ever to dev\", \"elop \\nDocker applications, and the setup is straightforward. \\n\\nTip \\n\\nFor instructions on setting up \", \"Docker Desktop for Windows, go to https://docs.docker.com/docker-\\nfor-windows/. \\n\\nFor instructions o\", \"n setting up Docker Desktop for Mac, go to https://docs.docker.com/docker-for-\\nmac/. \\n\\nIn addition, \", \"you\\u2019ll need a code editor so that you can actually develop your application while using \\nDocker CLI.\", \" \\n\\n42 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \", \"\\n \\n \\n\\fMicrosoft provides Visual Studio Code, which is a lightweight code editor that\\u2019s supported on \", \"\\nWindows, Linux, and macOS, and provides IntelliSense with support for many languages (JavaScript, \\n\", \".NET, Go, Java, Ruby, Python, and most modern languages), debugging, integration with Git and \\nexten\", \"sions support. This editor is a great fit for macOS and Linux developers. In Windows, you also \\ncan \", \"use Visual Studio. \\n\\nTip \\n\\nFor instructions on installing Visual Studio Code for Windows, Linux, or \", \"macOS, go to \\nhttps://code.visualstudio.com/docs/setup/setup-overview/. \\n\\nFor instructions on settin\", \"g up Docker for Mac, go to https://docs.docker.com/docker-for-mac/. \\n\\nYou can work with Docker CLI a\", \"nd write your code using any code editor, but using Visual Studio \\nCode with the Docker extension ma\", \"kes it easy to author Dockerfile and docker-compose.yml files in \\nyour workspace. You can also run t\", \"asks and scripts from the Visual Studio Code IDE to execute Docker \\ncommands using the Docker CLI un\", \"derneath. \\n\\nThe Docker extension for VS Code provides the following features: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\", \"\\u2022 \\n\\n\\u2022 \\n\\nAutomatic Dockerfile and docker-compose.yml file generation \\n\\nSyntax highlighting and hover \", \"tips for docker-compose.yml and Dockerfile files \\n\\nIntelliSense (completions) for Dockerfile and doc\", \"ker-compose.yml files \\n\\nLinting (errors and warnings) for Dockerfile files \\n\\nCommand Palette (F1) in\", \"tegration for the most common Docker commands \\n\\nExplorer integration for managing Images and Contain\", \"ers \\n\\nDeploy images from DockerHub and Azure Container Registries to Azure App Service \\n\\nTo install \", \"the Docker extension, press Ctrl+Shift+P, type ext install, and then run the Install Extension \\ncomm\", \"and to bring up the Marketplace extension list. Next, type docker to filter the results, and then \\ns\", \"elect the Docker Support extension, as depicted in Figure 4-23. \\n\\nFigure 4-23. Installing the Docker\", \" Extension in Visual Studio Code \\n\\n43 \\n\\nCHAPTER 4 | Designing and developing containerized apps usin\", \"g Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fStep 2: Create a DockerFile related to an existing image (plai\", \"n OS or dev \\nenvironments like .NET, Node.js, and Ruby) \\n\\nYou\\u2019ll need a DockerFile per custom image \", \"to be built and per container to be deployed. If your app is \\nmade up of single custom service, you\\u2019\", \"ll need a single DockerFile. But if your app is composed of \\nmultiple services (as in a microservice\", \"s architecture), you\\u2019ll need one Dockerfile per service. \\n\\nThe DockerFile is commonly placed in the \", \"root folder of your app or service and contains the required \\ncommands so that Docker knows how to s\", \"et up and run that app or service. You can create your \\nDockerFile and add it to your project along \", \"with your code (node.js, .NET, etc.), or, if you\\u2019re new to the \\nenvironment, take a look at the foll\", \"owing Tip. \\n\\nTip \\n\\nYou can use the Docker extension to guide you when using the Dockerfile and docke\", \"r-compose.yml \\nfiles related to your Docker containers. Eventually, you\\u2019ll probably write these kind\", \"s of files without \\nthis tool, but using the Docker extension is a good starting point that will acc\", \"elerate your learning \\ncurve. \\n\\nIn Figure 4-24, you can see the steps to add the docker files to a p\", \"roject by using the Docker \\nExtension for VS Code: \\n\\n1.  Open the command palette, type \\u201cdocker\\u201d and\", \" select \\u201cAdd Docker Files to Workspace\\u201d. \\n\\n2. \\n\\n3. \\n\\n4. \\n\\n5. \\n\\n6. \\n\\nSelect Application Platform (ASP\", \".NET Core) \\n\\nSelect Operating System (Linux) \\n\\nInclude optional Docker Compose files \\n\\nEnter ports t\", \"o publish (80, 443) \\n\\nSelect the project \\n\\n44 \\n\\nCHAPTER 4 | Designing and developing containerized a\", \"pps using Docker and Microsoft Azure \\n\\n \\n \\n\\fFigure 4-24. Docker files added using the Add Docker fil\", \"es to Workspace command \\n\\nWhen you add a DockerFile, you specify what base Docker image you\\u2019ll be us\", \"ing (like using FROM \\nmcr.microsoft.com/dotnet/aspnet). You\\u2019ll usually build your custom image on to\", \"p of a base image \\nthat you get from any official repository at the Docker Hub registry (like an ima\", \"ge for .NET or the one \\nfor Node.js). \\n\\nTip \\n\\nYou\\u2019ll have to repeat this procedure for every project\", \" in your application. However, the extension will \\nask to overwrite the generated docker-compose fil\", \"e after the first time. You should reply to not \\noverwrite it, so the extension creates separate doc\", \"ker-compose files, that you can then merge by \\nhand, prior to running docker-compose. \\n\\nUse an exist\", \"ing official Docker image \\n\\nUsing an official repository of a language stack with a version number e\", \"nsures that the same language \\nfeatures are available on all machines (including development, testin\", \"g, and production). \\n\\nThe following is a sample DockerFile for a .NET container: \\n\\n45 \\n\\nCHAPTER 4 | \", \"Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFROM mcr.micro\", \"soft.com/dotnet/aspnet:6.0 AS base \\nWORKDIR /app \\nEXPOSE 80 \\nEXPOSE 443 \\n\\nFROM mcr.microsoft.com/dot\", \"net/sdk:6.0 AS build \\nWORKDIR /src \\nCOPY [\\\"src/WebApi/WebApi.csproj\\\", \\\"src/WebApi/\\\"] \\nRUN dotnet res\", \"tore \\\"src/WebApi/WebApi.csproj\\\" \\nCOPY . . \\nWORKDIR \\\"/src/src/WebApi\\\" \\nRUN dotnet build \\\"WebApi.cspro\", \"j\\\" -c Release -o /app/build \\n\\nFROM build AS publish \\nRUN dotnet publish \\\"WebApi.csproj\\\" -c Release -\", \"o /app/publish \\n\\nFROM base AS final \\nWORKDIR /app \\nCOPY --from=publish /app/publish . \\nENTRYPOINT [\\\"\", \"dotnet\\\", \\\"WebApi.dll\\\"] \\n\\nIn this case, the image is based on version 6.0 of the official ASP.NET Cor\", \"e Docker image (multi-arch \\nfor Linux and Windows), as per the line FROM mcr.microsoft.com/dotnet/as\", \"pnet:6.0. (For more \\ninformation about this topic, see the ASP.NET Core Docker Image page and the .N\", \"ET Docker Image \\npage). \\n\\nIn the DockerFile, you can also instruct Docker to listen to the TCP port \", \"that you\\u2019ll use at run time \\n(such as port 80 or 443). \\n\\nYou can specify additional configuration se\", \"ttings in the Dockerfile, depending on the language and \\nframework you\\u2019re using. For instance, the E\", \"NTRYPOINT line with [\\\"dotnet\\\", \\\"WebMvcApplication.dll\\\"] \\ntells Docker to run a .NET application. If \", \"you\\u2019re using the SDK and the .NET CLI (dotnet CLI) to build \\nand run the .NET application, this sett\", \"ing would be different. The key point here is that the \\nENTRYPOINT line and other settings depend on\", \" the language and platform you choose for your \\napplication. \\n\\nTip \\n\\nFor more information about buil\", \"ding Docker images for .NET applications, see \\nhttps://learn.microsoft.com/dotnet/core/docker/build-\", \"container. \\n\\nTo learn more about building your own images, go to \\nhttps://docs.docker.com/engine/tut\", \"orials/dockerimages/. \\n\\nUse multi-arch image repositories \\n\\nA single image name in a repo can contai\", \"n platform variants, such as a Linux image and a Windows \\nimage. This feature allows vendors like Mi\", \"crosoft (base image creators) to create a single repo to \\ncover multiple platforms (that is, Linux a\", \"nd Windows). For example, the dotnet/aspnet repository \\navailable in the Docker Hub registry provide\", \"s support for Linux and Windows Nano Server by using \\nthe same image name. \\n\\nPulling the dotnet/aspn\", \"et image from a Windows host pulls the Windows variant, whereas pulling the \\nsame image name from a \", \"Linux host pulls the Linux variant. \\n\\n46 \\n\\nCHAPTER 4 | Designing and developing containerized apps u\", \"sing Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n \\n\\fCreate your base image from scratch \\n\\nYou can create yo\", \"ur own Docker base image from scratch as explained in this article from Docker. This \\nscenario is pr\", \"obably not the best for you if you\\u2019re just starting with Docker, but if you want to set the \\nspecifi\", \"c bits of your own base image, you can do it. \\n\\nStep 3: Create your custom Docker images embedding y\", \"our service in it \\n\\nFor each custom service that comprises your app, you\\u2019ll need to create a related\", \" image. If your app is \\nmade up of a single service or web app, you\\u2019ll need just a single image. \\n\\nN\", \"ote \\n\\nWhen taking into account the \\u201couter-loop DevOps workflow\\u201d, the images will be created by an \\na\", \"utomated build process whenever you push your source code to a Git repository (Continuous \\nIntegrati\", \"on), so the images will be created in that global environment from your source code. \\n\\nBut before yo\", \"u consider going to that outer-loop route, you need to ensure that the Docker \\napplication is actual\", \"ly working properly so that they don\\u2019t push code that might not work properly to \\nthe source control\", \" system (Git, etc.). \\n\\nTherefore, each developer first needs to do the entire inner-loop process to \", \"test locally and continue \\ndeveloping until they want to push a complete feature or change to the so\", \"urce control system. \\n\\nTo create an image in your local environment and using the DockerFile, you ca\", \"n use the docker build \\ncommand, as shown in Figure 4-25, because it already tags the image for you \", \"and builds the images \\nfor all services in the application with a simple command. \\n\\nFigure 4-25. Run\", \"ning docker build \\n\\nOptionally, instead of directly running docker build from the project folder, yo\", \"u first can generate a \\ndeployable folder with the .NET libraries needed by using the run dotnet pub\", \"lish command, and then \\nrun docker build. \\n\\nThis example creates a Docker image with the name webapi\", \":latest (:latest is a tag, like a specific \\nversion). You can take this step for each custom image y\", \"ou need to create for your composed Docker \\n\\n47 \\n\\nCHAPTER 4 | Designing and developing containerized\", \" apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fapplication with several containers. However, we\\u2019ll \", \"see in the next section that it\\u2019s easier to do this \\nusing docker-compose. \\n\\nYou can find the existi\", \"ng images in your local repository (your development machine) by using the \\ndocker images command, a\", \"s illustrated in Figure 4-26. \\n\\nFigure 4-26. Viewing existing images using docker images \\n\\nStep 4: D\", \"efine your services in docker-compose.yml when building a composed \\nDocker app with multiple service\", \"s \\n\\nWith the docker-compose.yml file, you can define a set of related services to be deployed as a \\n\", \"composed application with the deployment commands explained in the next step section. \\n\\nCreate that \", \"file in your main or root solution folder; it should have content similar to that shown in this \\ndoc\", \"ker-compose.yml file: \\n\\nversion: \\\"3.4\\\" \\n\\nservices: \\n  webapi: \\n    image: webapi \\n    build: \\n      \", \"context: . \\n      dockerfile: src/WebApi/Dockerfile \\n    ports: \\n      - 51080:80 \\n    depends_on: \\n\", \"      - redis \\n    environment: \\n      - ASPNETCORE_ENVIRONMENT=Development \\n      - ASPNETCORE_URLS\", \"=http://+:80 \\n\\n  webapp: \\n    image: webapp \\n    build: \\n      context: . \\n      dockerfile: src/Web\", \"App/Dockerfile \\n    ports: \\n      - 50080:80 \\n    environment: \\n      - ASPNETCORE_ENVIRONMENT=Devel\", \"opment \\n      - ASPNETCORE_URLS=http://+:80 \\n      - WebApiBaseAddress=http://webapi \\n\\n  redis: \\n   \", \" image: redis \\n\\nIn this particular case, this file defines three services: the web API service (your\", \" custom service), a web \\napplication, and the Redis service (a popular cache service). Each service \", \"will be deployed as a \\ncontainer, so you need to use a concrete Docker image for each. For this part\", \"icular application: \\n\\n48 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and \", \"Microsoft Azure \\n\\n \\n \\n \\n \\n \\n \\n\\f\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nThe web API service is built from the DockerFile \", \"in the src/WebApi/Dockerfile directory. \\n\\nThe host port 51080 is forwarded to the exposed port 80 on\", \" the webapi container. \\n\\nThe web API service depends on the Redis service \\n\\nThe web application acce\", \"sses the web API service using the internal address: http://webapi. \\n\\nThe Redis service uses the lat\", \"est public redis image pulled from the Docker Hub registry. \\nRedis is a popular cache system for ser\", \"ver-side applications. \\n\\nStep 5: Build and run your Docker app \\n\\nIf your app has only a single conta\", \"iner, you just need to run it by deploying it to your Docker Host \\n(VM or physical server). However,\", \" if your app is made up of multiple services, you need to compose it, \\ntoo. Let\\u2019s see the different \", \"options. \\n\\nOption A: Run a single container or service \\n\\nYou can run the Docker image by using the d\", \"ocker run command, as shown here: \\n\\ndocker run -t -d -p 50080:80 webapp:latest \\n\\nFor this particular\", \" deployment, we\\u2019ll be redirecting requests sent to port 50080 on the host to the \\ninternal port 80. \", \"\\n\\nOption B: Compose and run a multiple-container application \\n\\nIn most enterprise scenarios, a Docke\", \"r application will be composed of multiple services. For these \\ncases, you can run the docker-compos\", \"e up command (Figure 4-27), which will use the docker-\\ncompose.yml file that you created previously.\", \" Running this command builds all custom images and \\ndeploys the composed application with all of its\", \" related containers. \\n\\n49 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and\", \" Microsoft Azure \\n\\n \\n \\n\\fFigure 4-27. Results of running the \\u201cdocker-compose up\\u201d command \\n\\nAfter you \", \"run docker-compose up, you deploy your application and its related container(s) into your \\nDocker Ho\", \"st, as illustrated in Figure 4-28, in the VM representation. \\n\\nFigure 4-28. VM with Docker container\", \"s deployed \\n\\nStep 6: Test your Docker application (locally, in your local CD VM) \\n\\nThis step will va\", \"ry depending on what your app is doing. \\n\\nIn a simple .NET Web API \\u201cHello World\\u201d deployed as a singl\", \"e container or service, you\\u2019d just need to \\naccess the service by providing the TCP port specified i\", \"n the DockerFile. \\n\\nOn the Docker host, open a browser and navigate to that site; you should see you\", \"r app/service \\nrunning, as demonstrated in Figure 4-29. \\n\\n50 \\n\\nCHAPTER 4 | Designing and developing \", \"containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n\\fFigure 4-29. Testing your Docker appl\", \"ication locally by using the browser \\n\\nNote that it\\u2019s using port 50080, but internally it\\u2019s being re\", \"directed to port 80, because that\\u2019s how it \\nwas deployed with docker compose, as explained earlier. \", \"\\n\\nYou can test this by using the browser using CURL from the terminal, as depicted in Figure 4-30. \\n\", \"\\nFigure 4-30. Testing a Docker application locally by using CURL \\n\\nDebugging a container running on \", \"Docker \\n\\nVisual Studio Code supports debugging Docker if you\\u2019re using Node.js and other platforms li\", \"ke .NET \\ncontainers. \\n\\n51 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and\", \" Microsoft Azure \\n\\n \\n \\n \\n \\n\\fYou also can debug .NET or .NET Framework containers in Docker when usin\", \"g Visual Studio for \\nWindows or Mac, as described in the next section. \\n\\nTip \\n\\nTo learn more about d\", \"ebugging Node.js Docker containers, see \\nhttps://learn.microsoft.com/archive/blogs/user_ed/visual-st\", \"udio-code-new-features-13-big-\\ndebugging-updates-rich-object-hover-conditional-breakpoints-node-js-m\", \"ono-more. \\n\\nUse Docker Tools in Visual Studio on Windows \\n\\nThe developer workflow when using the Doc\", \"ker Tools included in Visual Studio 2022 version 17.0 and \\nlater, is similar to using Visual Studio \", \"Code and Docker CLI (in fact, it\\u2019s based on the same Docker CLI), \\nbut it\\u2019s easier to get started, s\", \"implifies the process, and provides greater productivity for the build, \\nrun, and compose tasks. It \", \"can also run and debug your containers via the usual F5 and Ctrl+F5keys \\nfrom Visual Studio. You can\", \" even debug a whole solution if its containers are defined in the same \\ndocker-compose.yml file at t\", \"he solution level. \\n\\nConfigure your local environment \\n\\nWith the latest versions of Docker for Windo\", \"ws, it\\u2019s easier than ever to develop Docker applications \\nbecause the setup is straightforward, as e\", \"xplained in the following references. \\n\\nTip \\n\\nTo learn more about installing Docker for Windows, go \", \"to (https://docs.docker.com/docker-for-\\nwindows/). \\n\\nDocker support in Visual Studio \\n\\nThere are two\", \" levels of Docker support you can add to a project. In ASP.NET Core projects, you can \\njust add a Do\", \"ckerfile file to the project by enabling Docker support. The next level is container \\norchestration \", \"support, which adds a Dockerfile to the project (if it doesn\\u2019t already exist) and a docker-\\ncompose.\", \"yml file at the solution level. Container orchestration support, via Docker Compose, is \\navailable i\", \"n Visual Studio 2022 versions 17.0. Container orchestration support is an opt-in feature in \\nVisual \", \"Studio 2022 versions 17.0 or later. Visual Studio 2022 also supports Kubernetes/Helm \\ndeployment. \\n\\n\", \"The Add > Docker Support and Add > Container Orchestrator Support commands are located on \\nthe right\", \"-click menu (or context menu) of the project node for an ASP.NET Core project in Solution \\nExplorer,\", \" as shown in Figure 4-31: \\n\\n52 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docke\", \"r and Microsoft Azure \\n\\n \\n \\n\\fFigure 4-31. Adding Docker support to a Visual Studio project \\n\\nAdd Doc\", \"ker support \\n\\nBesides the option to add Docker support to an existing application, as shown in the p\", \"revious section, \\nyou can also enable Docker support during project creation by selecting Enable Doc\", \"ker Support in \\nthe New ASP.NET Core Web Application dialog box that opens after you click OK in the\", \" New \\nProject dialog box, as shown in Figure 4-32. \\n\\n53 \\n\\nCHAPTER 4 | Designing and developing conta\", \"inerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-32. Enable Docker support during pr\", \"oject creation in Visual Studio \\n\\nWhen you add or enable Docker support, Visual Studio adds a Docker\", \"file file to the project, that \\nincludes references to all required project from the solution. \\n\\nAdd\", \" container orchestration support \\n\\nWhen you want to compose a multi-container solution, add containe\", \"r orchestration support to your \\nprojects. This lets you run and debug a group of containers (a whol\", \"e solution) at the same time if \\nthey\\u2019re defined in the same docker-compose.yml file. \\n\\nTo add conta\", \"iner orchestration support, right-click on the project node in Solution Explorer, and \\nchoose Add > \", \"Container Orchestration Support. Then choose Docker Compose to manage the \\ncontainers. \\n\\nAfter you a\", \"dd container orchestration support to your project, you see a Dockerfile added to the \\nproject and a\", \" docker-compose folder added to the solution in Solution Explorer, as shown in Figure \\n4-33: \\n\\n54 \\n\\n\", \"CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFi\", \"gure 4-33. Docker files in Solution Explorer in Visual Studio \\n\\nIf docker-compose.yml already exists\", \", Visual Studio just adds the required lines of configuration code \\nto it. \\n\\nConfigure Docker tools \", \"\\n\\nFrom the main menu, choose Tools > Options, and expand Container Tools > Settings. The \\ncontainer \", \"tools settings appear. \\n\\n55 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker a\", \"nd Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-34. Docker Tools Options \\n\\nFor more detailed configurations ref\", \"er to Container Tools settings \\n\\nTip \\n\\nFor further details on the services implementation and use of\", \" Visual Studio Tools for Docker, read the \\nfollowing articles: \\n\\nUse the Containers tool window to v\", \"iew container details such as the filesystem, logs, environment, \\nports, and more: https://learn.mic\", \"rosoft.com/visualstudio/containers/view-and-diagnose-containers \\nDebug apps in a local Docker contai\", \"ner: https://learn.microsoft.com/visualstudio/containers/edit-and-\\nrefresh \\n\\nDeploy an ASP.NET conta\", \"iner to a container registry using Visual Studio: \\nhttps://learn.microsoft.com/visualstudio/containe\", \"rs/hosting-web-apps-in-docker \\n\\nUsing Windows PowerShell commands in a \\nDockerFile to set up Windows\", \" Containers (Docker \\nstandard based) \\n\\nWith Windows Containers, you can convert your existing Window\", \"s applications to Docker images and \\ndeploy them with the same tools as the rest of the Docker ecosy\", \"stem. \\n\\n56 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azur\", \"e \\n\\n \\n \\n \\n\\fTo use Windows Containers, you just need to write Windows PowerShell commands in the Dock\", \"erFile, \\nas demonstrated in the following example: \\n\\nFROM mcr.microsoft.com/windows/servercore:ltsc2\", \"019 \\nLABEL Description=\\\"IIS\\\" Vendor=\\\"Microsoft\\\" Version=\\\"10\\\" \\nRUN powershell Get-WindowsFeature web-\", \"server \\nRUN powershell Install-windowsfeature web-server \\nRUN powershell add-windowsfeature web-asp-\", \"net45 \\nCMD [ \\\"ping\\\", \\\"localhost\\\", \\\"-t\\\" ] \\n\\nIn this case, we\\u2019re using Windows PowerShell to install a\", \" Windows Server Core base image as well \\nas IIS. \\n\\nIn a similar way, you also could use Windows Powe\", \"rShell commands to set up additional components \\nlike the traditional ASP.NET 4.x and .NET Framework\", \" 4.6 or any other Windows software, as shown \\nhere: \\n\\nRUN powershell add-windowsfeature web-asp-net4\", \"5 \\n\\nBuild ASP.NET Core applications deployed as Linux \\ncontainers into an AKS/Kubernetes orchestrato\", \"r \\n\\nAzure Kubernetes Services (AKS) is Azure\\u2019s managed Kubernetes orchestrations services that simpl\", \"ify \\ncontainer deployment and management. \\n\\nThe main features of AKS are: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAn A\", \"zure-hosted control plane. \\n\\nAutomated upgrades. \\n\\nSelf-healing. \\n\\nUser-configurable scaling. \\n\\nSimp\", \"ler user experience for both developers and cluster operators. \\n\\nThe following examples explore the \", \"creation of an ASP.NET Core 6.0 application that runs on Linux \\nand deploys to an AKS Cluster in Azu\", \"re. Development is done using Visual Studio 2022 version 17.0. \\n\\nCreating the ASP.NET Core Project u\", \"sing Visual Studio 2022 \\n\\nASP.NET Core is a general-purpose development platform maintained by Micro\", \"soft and the .NET \\ncommunity on GitHub. It\\u2019s cross-platform, supporting Windows, macOS and Linux, an\", \"d can be used in \\ndevice, cloud, and embedded/IoT scenarios. \\n\\nThis example uses a couple of simple \", \"projects based on Visual Studio templates, so you don\\u2019t need \\nmuch additional knowledge to create th\", \"e sample. You only have to create the project using a \\nstandard template that includes all the eleme\", \"nts to run a small project with a REST API and a Web \\nApp with Razor pages, using ASP.NET Core 6.0 t\", \"echnology. \\n\\nFor reference, you can download the sample from .NET Application Architecture\\u2019s repo ex\", \"plore-\\ndocker. \\n\\n57 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Micro\", \"soft Azure \\n\\n \\n \\n\\fFigure 4-35. Creating an ASP.NET Core Web Application in Visual Studio 2022. \\n\\nTo \", \"create the sample project in Visual Studio, select File > New > Project, select the Web project \\ntyp\", \"e and then the ASP.NET Core Web Api template. You can also search for the template if you need \\nit. \", \"\\n\\nThen enter the application name and location as shown in the next image. \\n\\n58 \\n\\nCHAPTER 4 | Design\", \"ing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-36. Enter t\", \"he project name and location in Visual Studio 2022. \\n\\nVerify that you\\u2019ve selected ASP.NET Core 6.0 a\", \"s the framework. .NET 6 is included in the latest release \\nof Visual Studio 2022 and is automaticall\", \"y installed and configured for you when you install Visual \\nStudio. \\n\\n59 \\n\\nCHAPTER 4 | Designing and\", \" developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-37. Selecting ASP.\", \"NET CORE 6.0 and Web API project type \\n\\nNotice Docker support is not enabled now. You\\u2019ll do that in \", \"the next step after the project creation. \\nYou\\u2019ll also notice that by default controller option is c\", \"hecked. You can uncheck that if you want to \\nCreate a minimal web API with ASP.NET Core. \\n\\nTo show y\", \"ou can \\u201cDockerize\\u201d your project at any time, you\\u2019ll add Docker support now. So right-click \\non the p\", \"roject node in Solution Explorer and select Add > Docker support on the context menu. \\n\\n60 \\n\\nCHAPTER\", \" 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-\", \"38. Adding Docker support to an existing project \\n\\nTo complete adding Docker support, you can choose\", \" Windows or Linux. In this case, select Linux. \\n\\nFigure 4-39. Selecting Linux containers. \\n\\n61 \\n\\nCHA\", \"PTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n\\fWit\", \"h these simple steps, you have your ASP.NET Core 6.0 application running on a Linux container. \\n\\nIn \", \"a similar way, you can also add a very simple WebApp project (Figure 4-40) to consume the web \\nAPI e\", \"ndpoint, although the details can be seen in the code repo. \\n\\nAfter that, you add orchestrator suppo\", \"rt for your WebApi project as shown next, in image 4-40. \\n\\nFigure 4-40. Adding orchestrator support \", \"to WebApi project. \\n\\nWhen you choose the Docker Compose option, which is fine for local development,\", \" Visual Studio \\nadds the docker-compose project, with the docker-compose files as shown in image 4-4\", \"1. \\n\\n62 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\", \"\\n \\n \\n \\n\\fFigure 4-41. Adding orchestrator support to WebApi project. \\n\\nThe initial files added are si\", \"milar to these ones: \\n\\ndocker-compose.yml \\n\\nversion: \\\"3.4\\\" \\n\\nservices: \\n  webapi: \\n    image: ${DOCK\", \"ER_REGISTRY-}webapi \\n    build: \\n      context: . \\n      dockerfile: WebApi/Dockerfile \\n\\n  webapp: \\n\", \"    image: ${DOCKER_REGISTRY-}webapp \\n    build: \\n      context: . \\n      dockerfile: WebApp/Dockerf\", \"ile \\n\\ndocker-compose.override.yml \\n\\nversion: \\\"3.4\\\" \\n\\nservices: \\n  webapi: \\n    environment: \\n      -\", \" ASPNETCORE_ENVIRONMENT=Development \\n      - ASPNETCORE_URLS=https://+:443;http://+:80 \\n    ports: \\n\", \"      - \\\"80\\\" \\n      - \\\"443\\\" \\n    volumes: \\n      - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft\", \"/usersecrets:ro \\n      - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro \\n  webapp: \\n    environment\", \": \\n      - ASPNETCORE_ENVIRONMENT=Development \\n      - ASPNETCORE_URLS=https://+:443;http://+:80 \\n  \", \"  ports: \\n      - \\\"80\\\" \\n      - \\\"443\\\" \\n\\n63 \\n\\nCHAPTER 4 | Designing and developing containerized apps\", \" using Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n \\n \\n\\f    volumes: \\n      - ${APPDATA}/Microsoft/UserSecr\", \"ets:/root/.microsoft/usersecrets:ro \\n      - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro \\n\\nTo ru\", \"n your app with Docker Compose, you just have to make a few tweaks to docker-\\ncompose.override.yml. \", \"\\n\\nservices: \\n  webapi: \\n    #... \\n    ports: \\n      - \\\"51080:80\\\" \\n      - \\\"51443:443\\\" \\n    #... \\n  w\", \"ebapp: \\n    environment: \\n      #... \\n      - WebApiBaseAddress=http://webapi \\n    ports: \\n      - \\\"\", \"50080:80\\\" \\n      - \\\"50443:443\\\" \\n    #... \\n\\nNow you can run your application with the F5 key, or by u\", \"sing the Play button, or the Ctrl+F5 key, \\nselecting the docker-compose project, as shown in image 4\", \"-42. \\n\\nFigure 4-42. Adding orchestrator support to WebApi project. \\n\\nWhen running the docker-compose\", \" application as explained, you get: \\n\\n1. \\n\\n2. \\n\\nThe images built and containers created as per the d\", \"ocker-compose file. \\n\\nThe browser open in the address configured in the \\u201cProperties\\u201d dialog for the \", \"docker-\\ncompose project. \\n\\n3. \\n\\nThe Container window open (in Visual Studio 2022 version 17.0 and la\", \"ter). \\n\\n4.  Debugger support for all projects in the solution, as shown in the following images. \\n\\nB\", \"rowser opened: \\n\\n64 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Micro\", \"soft Azure \\n\\n \\n \\n \\n\\fFigure 4-43. Browser window with an application running on multiple containers. \", \"\\n\\nContainers window: \\n\\nFigure 4-44. Visual Studio \\u201cContainers\\u201d window \\n\\nThe Containers window lets y\", \"ou view running containers, browse available images, view environment \\nvariables, logs, and port map\", \"pings, inspect the filesystem, attach a debugger, or open a terminal \\nwindow inside the container en\", \"vironment. \\n\\nAs you can see, the integration between Visual Studio 2022 and Docker is completely ori\", \"ented to the \\ndeveloper\\u2019s productivity. \\n\\nOf course, you can also list the images using the docker i\", \"mages command. You should see the webapi \\nand webapp images with the dev tags created by the automat\", \"ic deployment of our project with Visual \\nStudio 2022. \\n\\ndocker images \\n\\n65 \\n\\nCHAPTER 4 | Designing \", \"and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n\\fFigure 4-45. View of D\", \"ocker images \\n\\nRegister the Solution in an Azure Container Registry (ACR) \\n\\nYou can upload the image\", \"s to the Azure Container Registry (ACR), but you could also use Docker Hub \\nor any other registry, s\", \"o the images can be deployed to the AKS cluster from that registry. \\n\\nCreate an ACR instance \\n\\nRun t\", \"he following command from the az cli: \\n\\naz acr create --name exploredocker --resource-group explore-\", \"docker-aks-rg --sku basic \\n--admin-enabled \\n\\nNote \\n\\nThe container registry name (for example, explor\", \"edocker) must be unique within Azure and contain 5-\\n50 alphanumeric characters. For more details, se\", \"e Create a container registry. \\n\\nCreate the image in Release mode \\n\\nYou\\u2019ll now create the image in R\", \"elease mode (ready for production) by changing to Release, as \\nshown in Figure 4-46, and running the\", \" application as you did before. \\n\\nFigure 4-46. Selecting Release Mode \\n\\nIf you execute the docker im\", \"ages command, you\\u2019ll see both images created, one for debug (dev) and \\nthe other for release (latest\", \") mode. \\n\\nCreate a new Tag for the Image \\n\\nEach container image needs to be tagged with the loginSer\", \"ver name of the registry. This tag is used \\nfor routing when pushing container images to an image re\", \"gistry. \\n\\nYou can view the loginServer name from the Azure portal, taking the information from the A\", \"zure \\nContainer Registry \\n\\n66 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker\", \" and Microsoft Azure \\n\\n \\n \\n \\n \\n \\n \\n\\fFigure 4-47. View of the name of the Registry \\n\\nOr by running th\", \"e following command: \\n\\naz acr list --resource-group <resource-group-name> --query \\n\\\"[].{acrLoginServ\", \"er:loginServer}\\\" --output table \\n\\nFigure 4-48. Get the name of the registry using az cli \\n\\nIn both c\", \"ases, you\\u2019ll obtain the name. In our example, exploredocker.azurecr.io. \\n\\nNow you can tag the image,\", \" taking the latest image (the Release image), with the command: \\n\\ndocker tag <image-name>:latest <lo\", \"gin-server-name>/<image-name>:v1 \\n\\nAfter running the docker tag command, list the images with the do\", \"cker images command, and you \\nshould see the image with the new tag. \\n\\nFigure 4-49. View of tagged i\", \"mages \\n\\nPush the image into the Azure ACR \\n\\nLog in to the Azure Container Registry \\n\\naz acr login --\", \"name exploredocker \\n\\nPush the image into the Azure ACR, using the following command: \\n\\ndocker push <\", \"login-server-name>/<image-name>:v1 \\n\\n67 \\n\\nCHAPTER 4 | Designing and developing containerized apps us\", \"ing Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n \\n\\fThis command takes a while uploading the images but give\", \"s you feedback in the process. In the \\nfollowing image, you can see the output from one image comple\", \"ted and another in progress. \\n\\nFigure 4-50. Console output from the push command. \\n\\nTo deploy your m\", \"ulti-container app into your AKS cluster you need some manifest .yaml files that \\nhave, most of the \", \"properties taken from the docker-compose.yml and docker-compose.override.yml \\nfiles. \\n\\ndeploy-webapi\", \".yml \\n\\napiVersion: apps/v1 \\nkind: Deployment \\nmetadata: \\n  name: webapi \\n  labels: \\n    app: weather\", \"-forecast \\nspec: \\n  replicas: 1 \\n  selector: \\n    matchLabels: \\n      service: webapi \\n  template: \\n\", \"    metadata: \\n      labels: \\n        app: weather-forecast \\n        service: webapi \\n    spec: \\n   \", \"   containers: \\n        - name: webapi \\n          image: exploredocker.azurecr.io/webapi:v1 \\n       \", \"   imagePullPolicy: IfNotPresent \\n          ports: \\n            - containerPort: 80 \\n              p\", \"rotocol: TCP \\n          env: \\n            - name: ASPNETCORE_URLS \\n              value: http://+:80 \", \"\\n\\n68 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n\", \" \\n \\n\\f--- \\napiVersion: v1 \\nkind: Service \\nmetadata: \\n  name: webapi \\n  labels: \\n    app: weather-fore\", \"cast \\n    service: webapi \\nspec: \\n  ports: \\n    - port: 80 \\n      targetPort: 80 \\n      protocol: TC\", \"P \\n  selector: \\n    service: webapi \\ndeploy-webapp.yml \\napiVersion: apps/v1 \\nkind: Deployment \\nmetad\", \"ata: \\n  name: webapp \\n  labels: \\n    app: weather-forecast \\nspec: \\n  replicas: 1 \\n  selector: \\n    m\", \"atchLabels: \\n      service: webapp \\n  template: \\n    metadata: \\n      labels: \\n        app: weather-\", \"forecast \\n        service: webapp \\n    spec: \\n      containers: \\n        - name: webapp \\n          i\", \"mage: exploredocker.azurecr.io/webapp:v1 \\n          imagePullPolicy: IfNotPresent \\n          ports: \", \"\\n            - containerPort: 80 \\n              protocol: TCP \\n          env: \\n            - name: A\", \"SPNETCORE_URLS \\n              value: http://+:80 \\n            - name: WebApiBaseAddress \\n           \", \"   value: http://webapi \\n--- \\napiVersion: v1 \\nkind: Service \\nmetadata: \\n  name: webapp \\n  labels: \\n \", \"   app: weather-forecast \\n    service: webapp \\nspec: \\n  type: LoadBalancer \\n  ports: \\n    - port: 80\", \" \\n      targetPort: 80 \\n      protocol: TCP \\n  selector: \\n    service: webapp \\n\\n69 \\n\\nCHAPTER 4 | Des\", \"igning and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n\\fNote \\n\\nThe previous\", \" .yml files only enable the HTTP ports, using the ASPNETCORE_URLS parameter, to avoid \\nissues with t\", \"he missing certificate in the sample app. \\n\\nTip \\n\\nYou can see how to create the AKS Cluster for this\", \" sample in section Deploy to Azure Kubernetes \\nService (AKS) on this guide. \\n\\nNow you\\u2019re almost read\", \"y to deploy using kubectl, but first you must get the credentials from the AKS \\nCluster with this co\", \"mmand: \\n\\naz aks get-credentials --resource-group explore-docker-aks-rg --name explore-docker-aks \\n\\nF\", \"igure 4-51. Getting credentials from AKS into the kubectl environment. \\n\\nYou also have to allow the \", \"AKS cluster to pull images from the ACR, using this command: \\n\\naz aks update --name explore-docker-a\", \"ks --resource-group explore-docker-aks-rg --attach-acr \\nexploredocker \\n\\nThe previous command might t\", \"ake a couple of minutes to complete. Then, use the kubectl apply \\ncommand to launch the deployments,\", \" and then kubectl get all to list the cluster objects. \\n\\nkubectl apply -f deploy-webapi.yml \\nkubectl\", \" apply -f deploy-webapp.yml \\n\\nkubectl get all \\n\\n70 \\n\\nCHAPTER 4 | Designing and developing containeri\", \"zed apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n\\fFigure 4-52. Deployment to Kubernetes \\n\", \"\\nYou\\u2019ll have to wait a while until the load balancer gets the external IP, checking with kubectl get\", \" \\nservices, and then the application should be available at that address, as shown in the next image\", \": \\n\\n71 \\n\\nCHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure \\n\\n\", \" \\n \\n \\n\\fFigure 4-53. Deployment to Kubernetes \\n\\nWhen the deployment completes, you can access the Kub\", \"ernetes Web UI with a local proxy, using an \\nssh tunnel. \\n\\nFirst you must create a ClusterRoleBindin\", \"g with the following command: \\n\\nkubectl create clusterrolebinding kubernetes-dashboard --clusterrole\", \"=cluster-admin --\\nserviceaccount=kube-system:kubernetes-dashboard \\n\\nAnd then this command to start t\", \"he proxy: \\n\\naz aks browse --resource-group exploredocker-aks-rg --name explore-docker-aks \\n\\nA browse\", \"r window should open at http://127.0.0.1:8001 with a view similar to this one: \\n\\n72 \\n\\nCHAPTER 4 | De\", \"signing and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fFigure 4-54. Vie\", \"w Kubernetes cluster information \\n\\nNow you have your ASP.NET Core application, running in Linux cont\", \"ainers, and deployed to an AKS \\ncluster on Azure. \\n\\nNote \\n\\nFor more information on deployment with K\", \"ubernetes see: \\nhttps://kubernetes.io/docs/reference/kubectl/cheatsheet/ \\n\\n73 \\n\\nCHAPTER 4 | Designin\", \"g and developing containerized apps using Docker and Microsoft Azure \\n\\n \\n \\n \\n\\fCHAPTER  5 \\n\\nDocker ap\", \"plication \\nDevOps workflow with \\nMicrosoft tools \\n\\nMicrosoft Visual Studio, Azure DevOps Services an\", \"d/or GitHub, Team Foundation Server, and Azure \\nMonitor provide a comprehensive ecosystem for develo\", \"pment and IT operations that give your team the \\ntools to manage projects and rapidly build, test, a\", \"nd deploy containerized applications. \\n\\nTeams can choose which tools and platforms they want to use \", \"for end to end DevOps. With Visual \\nStudio and Azure DevOps Services in the cloud, along with Team F\", \"oundation Server on-premises, \\ndevelopment teams can productively build, test, and release container\", \"ized applications that target \\neither Windows or Linux. Alternatively, teams can also use Visual Stu\", \"dio Code and GitHub. Teams can \\neven use combinations: for example, storing source code in GitHub an\", \"d using Azure Boards for work \\nitem tracking and Azure Pipelines for CI/CD. \\n\\nMicrosoft tools can au\", \"tomate the pipeline for specific implementations of containerized \\napplications\\u2014Docker, .NET, or any\", \" combination with other platforms\\u2014from global builds and \\nContinuous Integration (CI) and tests with\", \" Azure DevOps Services, Team Foundation Server or GitHub, \\nto Continuous Deployment (CD) to Docker e\", \"nvironments (Development, Staging, Production), and to \\ntransmit analytics information about the ser\", \"vices to the development team through Azure Monitor. \\nEvery code commit can initiate a build (CI) an\", \"d automatically deploy the services to specific \\ncontainerized environments (CD). \\n\\nDevelopers and t\", \"esters can easily and quickly provision production-like development and test \\nenvironments based on \", \"Docker by using templates in Microsoft Azure. \\n\\nThe complexity of containerized application developm\", \"ent increases steadily depending on the \\nbusiness complexity and scalability needs. A good example o\", \"f this complexity are applications based \\non microservices architectures. To succeed in such an envi\", \"ronment, your project must automate the \\nentire life cycle\\u2014not only the build and deployment, but it\", \" also must manage versions along with \\nthe collection of telemetry. Azure DevOps Services, GitHub an\", \"d Azure offer the following capabilities: \\n\\n\\u2022 \\n\\nAzure DevOps Services/Team Foundation Server source \", \"code management (based on Git or \\nTeam Foundation Version Control), Agile planning (Agile, Scrum, an\", \"d CMMI are supported), \\nCI, release management, and other tools for Agile teams. \\n\\n74 \\n\\nCHAPTER 5 | \", \"Docker application DevOps workflow with Microsoft tools \\n\\n \\n \\n\\f\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAzure DevOps Serv\", \"ices and Team Foundation Server include a powerful and growing \\necosystem of first and third-party e\", \"xtensions with which you easily can construct a CI, build, \\ntest, delivery, and release management p\", \"ipeline for microservices. \\n\\nGitHub or GitHub Enterprise Server offer similar capabilities, with sou\", \"rce control based on Git, \\nProjects and Issues for project tracking, GitHub Actions for automating w\", \"orkflows including \\nCI/CD, and GitHub Advanced Security for dependency, secret and vulnerability sca\", \"nning. \\n\\nRun automated tests as part of your build pipeline in Azure DevOps Services or through \\nGit\", \"Hub Actions \\n\\nAzure DevOps Services/GitHub can tighten the DevOps life cycle with delivery to multip\", \"le \\nenvironments, not just for production environments, but also for testing, including A/B \\nexperim\", \"entation, canary releases, and so on. \\n\\nOrganizations easily can provision Docker containers from pr\", \"ivate images stored in Azure \\nContainer Registry along with any dependency on Azure components (Data\", \", PaaS, etc.) using \\nAzure Resource Manager templates with tools they\\u2019re already comfortable with. \\n\", \"\\nSteps in the outer-loop DevOps workflow for a \\nDocker application \\n\\nFigure 5-1 presents an end-to-e\", \"nd depiction of the steps comprising the DevOps outer-loop \\nworkflow. It shows the \\u201couter loop\\u201d of D\", \"evOps. When code is pushed to the repo, a CI pipeline is \\nstarted, then begins the CD pipeline, wher\", \"e the application gets deployed. Metrics collected from \\ndeployed applications are fed back into the\", \" development workload, where the \\u201cinner loop\\u201d occurs, so \\ndevelopment teams have actual data to resp\", \"ond to user and business needs. \\n\\nFigure 5-1. DevOps outer-loop workflow for Docker applications wit\", \"h Microsoft tools \\n\\nNow, let\\u2019s examine each of these steps in greater detail. \\n\\n75 \\n\\nCHAPTER 5 | Doc\", \"ker application DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n\\fStep 1: Inner-loop development workflo\", \"w \\n\\nThis step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begin\", \"s, the \\nmoment at which a developer pushes code to the source control management system (like Git) \\n\", \"initiating CI pipeline actions. \\n\\nStep 2: Source-Code Control integration and management with Azure \", \"\\nDevOps Services and Git \\n\\nAt this step, you need to have a version-control system to gather a conso\", \"lidated version of all the \\ncode coming from the different developers in the team. \\n\\nEven though sou\", \"rce-code control (SCC) and source-code management might seem second-nature to \\nmost developers, when\", \" creating Docker applications in a DevOps life cycle, it\\u2019s critical to emphasize \\nthat you must not \", \"submit the Docker images with the application directly to the global Docker \\nRegistry (like Azure Co\", \"ntainer Registry or Docker Hub) from the developer\\u2019s machine. On the contrary, \\nthe Docker images to\", \" be released and deployed to production environments must be created solely \\non the source code that\", \"\\u2019s being integrated in your global build or CI pipeline based on your source-\\ncode repository (like \", \"Git). \\n\\nThe local images, generated by developers, should just be used by them when testing within t\", \"heir \\nown machines. That\\u2019s why it\\u2019s critical to have the DevOps pipeline activated from the SCC code\", \". \\n\\nAzure DevOps Services and Team Foundation Server support Git and Team Foundation Version \\nContro\", \"l. You can choose between them and use it for an end-to-end Microsoft experience. However, \\nyou can \", \"also manage your code in external repositories (like GitHub, on-premises Git repositories, or \\nSubve\", \"rsion) and still be able to connect to it and get the code as the starting point for your DevOps CI \", \"\\npipeline. You can also use GitHub Actions for CI/CD pipelines. \\n\\nStep 3: Build, CI, Integrate, and \", \"Test with Azure DevOps \\nServices/GitHub and Docker \\n\\nCI has emerged as a standard for modern softwar\", \"e testing and delivery. The Docker solution \\nmaintains a clear separation of concerns between the de\", \"velopment and operations teams. The \\nimmutability of Docker images ensures a repeatable deployment b\", \"etween what\\u2019s developed, tested \\nthrough CI, and run in production. Docker Engine deployed across th\", \"e developer laptops and test \\ninfrastructure makes the containers portable across environments. \\n\\nAt\", \" this point, after you have a version-control system with the correct code submitted, you need a \\nbu\", \"ild service to pick up the code and run the global build and tests. \\n\\nThe internal workflow for this\", \" step (CI, build, test) is about the construction of a CI pipeline consisting \\nof your code reposito\", \"ry (Git, etc.), your build server (Azure DevOps Services/GitHub), Docker Engine, \\nand a Docker Regis\", \"try. \\n\\nYou can use Azure DevOps Services as the foundation for building your applications and settin\", \"g your \\nCI pipeline, and for publishing the built \\u201cartifacts\\u201d to an \\u201cartifacts repository,\\u201d which is\", \" explained in the \\nnext step. Alternatively, you can use GitHub to implement the same workflow. \\n\\n76\", \" \\n\\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n\\n \\n \\n\\fWhen using Docker for \", \"the deployment, the \\u201cfinal artifacts\\u201d to be deployed are Docker images with \\nyour application or ser\", \"vices embedded within them. Those images are pushed or published to a \\nDocker Registry (a private re\", \"pository like the ones you can have in Azure Container Registry, or a \\npublic one like Docker Hub Re\", \"gistry or GitHub Container Registry, which is commonly used for official \\nbase images). \\n\\nHere is th\", \"e basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git. \\nThe \", \"commit will cause Azure DevOps Services/GitHub to run a build job within a Docker container \\nand, up\", \"on successful completion of that job, push a Docker image to the Docker Registry, as \\nillustrated in\", \" Figure 5-2. The first part of the outer loop involves steps 1 to 3, from code, run, debug \\nand vali\", \"date, then the code repo up to the build and test CI step. \\n\\nFigure 5-2. The steps involved in CI \\n\\n\", \"Here are the basic CI workflow steps with Docker and Azure DevOps Services: \\n\\n77 \\n\\nCHAPTER 5 | Docke\", \"r application DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n\\f1. \\n\\n2. \\n\\n3. \\n\\n4. \\n\\n5. \\n\\n6. \\n\\nThe develo\", \"per pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, \\netc.). \\n\\nIf you\\u2019re usi\", \"ng Azure DevOps Services or Git, CI is built in, which means that it\\u2019s as simple as \\nselecting a che\", \"ck box in Azure DevOps Services. If you\\u2019re using an external SCC (like GitHub), \\na webhook will noti\", \"fy Azure DevOps Services of the update or push to Git/GitHub. \\n\\nAzure DevOps Services pulls the SCC \", \"repository, including the Dockerfile describing the \\nimage, as well as the application and test code\", \". \\n\\nAzure DevOps Services builds a Docker image and labels it with a build number. \\n\\nAzure DevOps Se\", \"rvices instantiates the Docker container within the provisioned Docker Host, \\nand runs the appropria\", \"te tests. \\n\\nIf the tests are successful, the image is first relabeled to a meaningful name so that y\", \"ou know \\nit\\u2019s a \\u201cblessed build\\u201d (like \\u201c/1.0.0\\u201d or any other label), and then pushed up to your Docke\", \"r \\nRegistry (Docker Hub, Azure Container Registry, DTR, etc.) \\n\\nHere are the basic CI workflow steps\", \" with Docker and GitHub: \\n\\n1. \\n\\n2. \\n\\n3. \\n\\n4. \\n\\n5. \\n\\n6. \\n\\nThe developer pushes a commit to a GitHub r\", \"epo. \\n\\nCI is built in, so Actions will trigger base on the event filters. \\n\\nGitHub pulls the SCC rep\", \"ository, including the Dockerfile describing the image, as well as the \\napplication and test code. \\n\", \"\\nGitHub builds a Docker image and labels it with a build number. \\n\\nGitHub instantiates the Docker co\", \"ntainer within the provisioned Docker Host, and runs the \\nappropriate tests. \\n\\nIf the tests are succ\", \"essful, the image is first relabeled to a meaningful name so that you know \\nit\\u2019s a \\u201cblessed build\\u201d (\", \"like \\u201c/1.0.0\\u201d or any other label), and then pushed up to your Docker \\nRegistry (Docker Hub, Azure Co\", \"ntainer Registry, DTR, etc.) \\n\\nImplement a CI pipeline with Azure DevOps Services and the Docker ext\", \"ension for \\nAzure DevOps Services \\n\\nVisual Studio Azure DevOps Services contains Build & Release Tem\", \"plates that you can use in your \\nCI/CD pipeline with which you can build Docker images, push Docker \", \"images to an authenticated \\nDocker registry, run Docker images, or run other operations offered by t\", \"he Docker CLI. It also adds a \\nDocker Compose task that you can use to build, push, and run multi-co\", \"ntainer Docker applications, or \\nrun other operations offered by the Docker Compose CLI, as shown in\", \" Figure 5-3. \\n\\n78 \\n\\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n\\n \\n \\n\\fFigur\", \"e 5-3. The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and assoc\", \"iated tasks. \\n\\nYou can use these templates and tasks to construct your CI/CD artifacts to Build / Te\", \"st and Deploy in \\nAzure Service Fabric, Azure Kubernetes Service, and similar offerings. \\n\\nWith thes\", \"e Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and \\nyour pre\", \"ferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any \\nother Dock\", \"er registry) you can assemble your Docker CI pipeline in a very consistent way. \\n\\nRequirements: \\n\\n\\u2022 \", \"\\n\\nAzure DevOps Services, or for on-premises installations, Team Foundation Server 2015 \\nUpdate 3 or \", \"later. \\n\\n\\u2022 \\n\\nAn Azure DevOps Services agent that has the Docker binaries. \\n\\nAn easy way to create on\", \"e of these agents is to use Docker to run a container based on the \\nAzure DevOps Services agent Dock\", \"er image. \\n\\nTip \\n\\nTo read more about assembling an Azure DevOps Services Docker CI pipeline and view\", \" the \\nwalkthroughs, visit these sites: \\n\\n\\u2022 \\n\\nRunning a Visual Studio Team Services (Now Azure DevOps\", \" Services) agent as a Docker \\ncontainer: \\nhttps://hub.docker.com/_/microsoft-azure-pipelines-vsts-ag\", \"ent \\n\\n79 \\n\\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n  \\n\\f\\u2022 \\n\\n\\u2022 \\n\\nB\", \"uilding .NET Linux Docker images with Azure DevOps Services: \\nhttps://learn.microsoft.com/archive/bl\", \"ogs/stevelasker/building-net-core-linux-docker-\\nimages-with-visual-studio-team-services \\n\\nBuilding a\", \" Linux-based Visual Studio Team Service build machine with Docker support: \\nhttps://www.donovanbrown\", \".com/post/Building-a-Linux-Based-Visual-Studio-Team-Service-\\nBuild-Machine-with-Docker-Support \\n\\nImp\", \"lement a CI pipeline with GitHub Actions \\n\\nGitHub Actions allow you to create automation scripts tha\", \"t can build Docker images, push Docker \\nimages to an authenticated Docker registry, run Docker image\", \"s, or run other operations offered by \\nthe Docker CLI. \\n\\nYou can use public Actions (such as Azure L\", \"ogin) and run (shell) commands to construct your CI/CD \\nartifacts to Build / Test and Deploy in Azur\", \"e Service Fabric, Azure Kubernetes Service, and similar \\nofferings. \\n\\nWith these Actions, a build Li\", \"nux-Docker Host/VM provisioned in Azure and your preferred Docker \\nregistry (Azure Container Registr\", \"y, Docker Hub, private Docker DTR, or any other Docker registry) you \\ncan assemble your Docker CI pi\", \"peline in a very consistent way. \\n\\nIntegrate, test, and validate multi-container Docker applications\", \" \\n\\nTypically, most Docker applications are composed of multiple containers rather than a single \\ncon\", \"tainer. A good example is a microservices-oriented application for which you would have one \\ncontain\", \"er per microservice. But, even without strictly following the microservices approach patterns, \\nit\\u2019s\", \" probable that your Docker application would be composed of multiple containers or services. \\n\\nThere\", \"fore, after building the application containers in the CI pipeline, you also need to deploy, \\nintegr\", \"ate, and test the application as a whole with all of its containers within an integration Docker \\nho\", \"st or even into a test cluster to which your containers are distributed. \\n\\nIf you\\u2019re using a single \", \"host, you can use Docker commands such as docker-compose to build and \\ndeploy related containers to \", \"test and validate the Docker environment in a single VM. But, if you\\u2019re \\nworking with an orchestrato\", \"r cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy \\nyour containers through a dif\", \"ferent mechanism or orchestrator, depending on your selected \\ncluster/scheduler. \\n\\nThe following are\", \" several types of tests that you can run against Docker containers: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nUnit tests for Doc\", \"ker containers \\n\\nTesting groups of interrelated applications or microservices \\n\\nTest in production a\", \"nd \\u201ccanary\\u201d releases \\n\\nThe important point is that when running integration and functional tests, yo\", \"u must run those tests \\nfrom outside of the containers. Tests are not contained or run in the contai\", \"ners you\\u2019re deploying, \\nbecause the containers are based on static images that should be exactly lik\", \"e the ones you\\u2019ll be \\ndeploying to production. \\n\\n80 \\n\\nCHAPTER 5 | Docker application DevOps workflow\", \" with Microsoft tools \\n\\n \\n \\n\\fA practical option when testing more advanced scenarios, like including\", \" several clusters (test cluster, \\nstaging cluster, and production cluster) is to publish the images \", \"to a registry, so it can be tested in \\nvarious clusters. \\n\\nPush the custom application Docker image \", \"into your global Docker Registry \\n\\nAfter the Docker images have been tested and validated, you\\u2019ll wa\", \"nt to tag and publish them to your \\nDocker registry. The Docker registry is a critical piece in the \", \"Docker application life cycle because it\\u2019s \\nthe central place where you store your custom test (also\", \" known as \\u201cblessed images\\u201d) to be deployed \\ninto QA and production environments. \\n\\nSimilar to how th\", \"e application code stored in your SCC repository (Git, etc.) is your \\u201csource of truth,\\u201d \\nthe Docker \", \"registry is your \\u201csource of truth\\u201d for your binary application or bits to be deployed to the \\nQA or \", \"production environments. \\n\\nTypically, you might want to have your private repositories for your cust\", \"om images either in a private \\nrepository in Azure Container Registry or in an on-premises registry \", \"like Docker Trusted Registry, or in \\na public-cloud registry with restricted access (like Docker Hub\", \"), although in this last case if your code \\nis not open source, you must trust the vendor\\u2019s security\", \". Either way, the method you use is similar and \\nis based on the docker push command, as shown in Fi\", \"gure 5-4. \\n\\n81 \\n\\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n\\n \\n \\n\\fFigure 5\", \"-4. Publishing custom images to Docker Registry \\n\\n82 \\n\\nCHAPTER 5 | Docker application DevOps workflo\", \"w with Microsoft tools \\n\\n \\n \\n \\n\\fIn step 3, for building integration and testing (CI) you might publi\", \"sh the resulting docker images to a \\nprivate or public registry. There are multiple offerings of Doc\", \"ker registries from cloud vendors like \\nAzure Container Registry, Amazon Web Services Container Regi\", \"stry, Google Container Registry, \\nGitHub Container Registry, Quay Registry, and so on. \\n\\nUsing the D\", \"ocker tasks, you can push a set of service images defined by a docker-compose.yml file, \\nwith multip\", \"le tags, to an authenticated Docker registry (like Azure Container Registry), as shown in \\nFigure 5-\", \"5. \\n\\nFigure 5-5. Using Azure DevOps Services to publishing custom images to a Docker Registry \\n\\nTip \", \"\\n\\nFor more information about Azure Container Registry, see https://aka.ms/azurecontainerregistry. \\n\\n\", \"Step 4: CD, Deploy \\n\\nThe immutability of Docker images ensures a repeatable deployment with what\\u2019s d\", \"eveloped, tested \\nthrough CI, and run in production. After you have the application Docker images pu\", \"blished in your \\nDocker registry (either private or public), you can deploy them to the several envi\", \"ronments that you \\nmight have (production, QA, staging, etc.) from your CD pipeline by using Azure D\", \"evOps Services \\npipeline tasks, Azure DevOps Services Release Management or GitHub Actions. \\n\\n83 \\n\\nC\", \"HAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n\\fHowever, at this point i\", \"t depends on what kind of Docker application you\\u2019re deploying. Deploying a \\nsimple application (from\", \" a composition and deployment point of view) like a monolithic application \\ncomprising a few contain\", \"ers or services and deployed to a few servers or VMs is different from \\ndeploying a more complex app\", \"lication like a microservices-oriented application with hyperscale \\ncapabilities. These two scenario\", \"s are explained in the following sections. \\n\\nDeploying composed Docker applications to multiple Dock\", \"er environments \\n\\nLet\\u2019s look first at the less-complex scenario: deploying to simple Docker hosts (V\", \"Ms or servers) in a \\nsingle environment or multiple environments (QA, staging, and production). In t\", \"his scenario, internally \\nyour CD pipeline can use docker-compose (from your Azure DevOps Services d\", \"eployment tasks) to \\ndeploy the Docker applications with its related set of containers or services, \", \"as illustrated in Figure 5-6. \\n\\nFigure 5-6. Deploying application containers to simple Docker host e\", \"nvironments registry \\n\\nFigure 5-7 highlights how you can connect your build CI to QA/test environmen\", \"ts via Azure DevOps \\nServices by clicking Docker Compose in the Add Task dialog box. However, when d\", \"eploying to staging \\nor production environments, you would usually use Release Management features h\", \"andling multiple \\nenvironments (like QA, staging, and production). If you\\u2019re deploying to single Doc\", \"ker hosts, it is using \\nthe Azure DevOps Services \\u201cDocker Compose\\u201d task (which is invoking the docke\", \"r-compose up \\ncommand under the hood). If you\\u2019re deploying to Azure Kubernetes Service (AKS), it use\", \"s the Docker \\n\\n84 \\n\\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n\\fDep\", \"loyment task, as explained in the section that follows. Similar steps can be built for deployment \\nu\", \"sing GitHub Actions. \\n\\nFigure 5-7. Adding a Docker Compose task in an Azure DevOps Services pipeline\", \" or GitHub workflow \\n\\nWhen you create a release in Azure DevOps Services, it takes a set of input ar\", \"tifacts. These artifacts are \\nintended to be immutable for the lifetime of the release, across all e\", \"nvironments. When you introduce \\ncontainers, the input artifacts identify images in a registry to de\", \"ploy. Depending on how these images \\nare identified, they are not guaranteed to remain the same thro\", \"ughout the duration of the release, the \\nmost obvious case being when you reference myimage:latest f\", \"rom a docker-compose file. \\n\\nThe Azure DevOps Services templates give you the ability to generate bu\", \"ild artifacts that contain \\nspecific registry image digests that are guaranteed to uniquely identify\", \" the same image binary. These \\nare what you really want to use as input to a release. You can invoke\", \" docker-compose in a run step \\ninside GitHub Actions to accomplish the same goal. \\n\\nManaging release\", \"s to Docker environments by using Azure DevOps Services \\nRelease Management or GitHub Actions \\n\\nThro\", \"ugh the Azure DevOps Services templates, you can build a new image, publish it to a Docker \\nregistry\", \", run it on Linux or Windows hosts, and use commands such as docker-compose to deploy \\nmultiple cont\", \"ainers as an entire application, all through the Azure DevOps Services Release \\nManagement capabilit\", \"ies intended for multiple environments, as shown in Figure 5-8. \\n\\n85 \\n\\nCHAPTER 5 | Docker applicatio\", \"n DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n\\fFigure 5-8. Configuring Azure DevOps Services Docker\", \" Compose tasks from Azure DevOps Services Release \\nManagement \\n\\nHowever, keep in mind that the scena\", \"rio shown in Figure 5-6 and implemented in Figure 5-8 is a \\nsimple one (it\\u2019s deploying to single Doc\", \"ker hosts and VMs, and there will be a single container or \\ninstance per image) and probably should \", \"be used only for development or test scenarios. In most \\nenterprise production scenarios, you would \", \"want to have High Availability (HA) and easy-to-manage \\nscalability by load balancing across multipl\", \"e nodes, servers, and VMs, plus \\u201cintelligent failovers\\u201d so if a \\nserver or node fails, its services \", \"and containers will be moved to another host server or VM. In that \\ncase, you need more advanced tec\", \"hnologies such as container clusters, orchestrators, and schedulers. \\nThus, the way to deploy to tho\", \"se clusters is by handling the advanced scenarios explained in the next \\nsection. \\n\\nGitHub Actions c\", \"an be used in the same manner, including the use of environments for approvals. \\n\\nDeploying Docker a\", \"pplications to Docker clusters \\n\\nThe nature of distributed applications requires compute resources t\", \"hat are also distributed. To have \\nproduction-scale capabilities, you need to have clustering capabi\", \"lities that provide high scalability and \\nhigh availability based on pooled resources. \\n\\nYou could d\", \"eploy containers manually to those clusters from a CLI tool or a web UI, but you should \\nreserve tha\", \"t kind of manual work to spot deployment testing or management purposes like scaling-\\nout or monitor\", \"ing. \\n\\nFrom a CD point of view, you can use Azure DevOps Services or GitHub Actions to run specially\", \" made \\ndeployment tasks from your environments that will deploy your containerized applications to \\n\", \"distributed clusters in Container Service, as illustrated in Figure 5-9. \\n\\n86 \\n\\nCHAPTER 5 | Docker a\", \"pplication DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n\\fFigure 5-9. Deploying distributed applicati\", \"ons to Container Service \\n\\nInitially, when deploying to certain clusters or orchestrators, you would\", \" traditionally use specific \\ndeployment scripts and mechanisms per each orchestrator (that is, Kuber\", \"netes and Service Fabric \\nhave different deployment mechanisms) instead of the simpler and easy-to-u\", \"se docker-compose tool \\nbased on the docker-compose.yml definition file. However, thanks to the Azur\", \"e DevOps Services \\nDocker Deploy task, shown in Figure 5-10, now you can also deploy to the supporte\", \"d orchestrators by \\njust using your familiar docker-compose.yml file because the tool performs that \", \"\\u201ctranslation\\u201d for you \\n(from your docker-compose.yml file to the format needed by the orchestrator).\", \" \\n\\n87 \\n\\nCHAPTER 5 | Docker application DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n\\fFigure 5-10. Ad\", \"ding the Deploy to Kubernetes task to your Environment \\n\\nFigure 5-11 demonstrates how you can edit t\", \"he Deploy to Kubernetes task with the sections available \\nfor configuration. This is the task that w\", \"ill retrieve your ready-to-use custom Docker images to be \\ndeployed as containers in the cluster. \\n\\n\", \"Figure 5-11. Docker Deploy task definition deploying to ACS DC/OS \\n\\n88 \\n\\nCHAPTER 5 | Docker applicat\", \"ion DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n \\n\\fTip \\n\\nTo read more about the CD pipeline with Az\", \"ure DevOps Services and Docker, visit \\nhttps://azure.microsoft.com/services/devops/pipelines \\n\\nTip \\n\", \"\\nTo see GitHub Actions workflows for CI, visit https://github.com/dotnet-\\narchitecture/eShopOnContai\", \"ners/wiki/GitHub-Actions. For a walkthrough of GitHub Actions \\nperforming deployment to an Azure Kub\", \"ernetes environment, visit https://github.com/dotnet-\\narchitecture/eShopOnContainers/wiki/Deployment\", \"-With-GitHub-Actions. \\n\\nStep 5: Run and manage \\n\\nBecause running and managing applications at enterp\", \"rise-production level is a major subject in and of \\nitself, and due to the type of operations and pe\", \"ople working at that level (IT operations) as well as the \\nlarge scope of this area, the entire next\", \" chapter is devoted to explaining it. \\n\\nStep 6: Monitor and diagnose \\n\\nThis topic also is covered in\", \" the next chapter as part of the tasks that IT performs in production \\nsystems; however, is importan\", \"t to highlight that the insights obtained in this step must feed back to \\nthe development team so th\", \"at the application is constantly improved. From that point of view, it\\u2019s also \\npart of DevOps, altho\", \"ugh the tasks and operations are commonly performed by IT. \\n\\nOnly when monitoring and diagnostics ar\", \"e 100% within the realm of DevOps are the monitoring \\nprocesses and analytics performed by the devel\", \"opment team against testing or beta environments. \\nThis is done either by performing load testing or\", \" by monitoring beta or QA environments, where beta \\ntesters are trying the new versions. \\n\\nCreate CI\", \"/CD pipelines in Azure DevOps Services for \\na .NET application on Containers and deploying to a \\nKub\", \"ernetes cluster \\n\\nIn Figure 5-12 you can see the end-to-end DevOps scenario covering the code manage\", \"ment, code \\ncompilation, Docker images build, Docker images push to a Docker registry and finally th\", \"e \\ndeployment to a Kubernetes cluster in Azure. \\n\\n89 \\n\\nCHAPTER 5 | Docker application DevOps workflo\", \"w with Microsoft tools \\n\\n \\n \\n \\n \\n\\fFigure 5-12. CI/CD scenario creating Docker images and deploying t\", \"o a Kubernetes cluster in Azure \\n\\nIt is important to highlight that the two pipelines, build/CI, and\", \" release/CD, are connected through the \\nDocker Registry (such as Docker Hub or Azure Container Regis\", \"try). The Docker registry is one of the \\nmain differences compared to a traditional CI/CD process wi\", \"thout Docker. \\n\\nAs shown in Figure 5-13, the first phase is the build/CI pipeline. In Azure DevOps S\", \"ervices you can \\ncreate build/CI pipelines that will compile the code, create the Docker images, and\", \" push them to a \\nDocker Registry like Docker Hub or Azure Container Registry. \\n\\n90 \\n\\nCHAPTER 5 | Doc\", \"ker application DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n\\fFigure 5-13. Build/CI pipeline in Azur\", \"e DevOps building Docker images and pushing images to a Docker registry \\n\\nThe second phase is to cre\", \"ate a deployment/release pipeline. In Azure DevOps Services, you can easily \\ncreate a deployment pip\", \"eline targeting a Kubernetes cluster by using the Kubernetes tasks for Azure \\nDevOps Services, as sh\", \"own in Figure 5-14. \\n\\nFigure 5-14. Release/CD pipeline in Azure DevOps Services deploying to a Kuber\", \"netes cluster \\n\\n[!Walkthrough] Deploying eShopModernized to Kubernetes: \\n\\n91 \\n\\nCHAPTER 5 | Docker ap\", \"plication DevOps workflow with Microsoft tools \\n\\n \\n \\n \\n \\n\\fFor a detailed walkthrough of Azure DevOps\", \" CI/CD pipelines deploying to Kubernetes, see this post: \\nhttps://github.com/dotnet-architecture/eSh\", \"opModernizing/wiki/04.-How-to-deploy-your-Windows-\\nContainers-based-apps-into-Kubernetes-in-Azure-Co\", \"ntainer-Service-(Including-CI-CD) \\n\\n92 \\n\\nCHAPTER 5 | Docker application DevOps workflow with Microso\", \"ft tools \\n\\n \\n \\n\\fCHAPTER  6 \\n\\nRun, manage, and monitor \\nDocker production \\nenvironments \\n\\nVision: Ent\", \"erprise applications need to run with high availability and high scalability; IT operations \\nneed to\", \" be able to manage and monitor the environments and the applications themselves. \\n\\nThis last pillar \", \"in the containerized Docker applications life cycle is centered on how you can run, \\nmanage, and mon\", \"itor your applications in scalable, high availability (HA) production environments. \\n\\nThe way you ru\", \"n your containerized applications in production (infrastructure architecture and \\nplatform technolog\", \"ies) is very much related and based on the chosen architecture and development \\nplatforms discussed \", \"in Chapter 1 of this e-book. \\n\\nThis chapter examines specific products and technologies from Microso\", \"ft and other vendors that you \\ncan use to effectively run scalable, HA distributed applications plus\", \" how you can manage and monitor \\nthem from the IT perspective. \\n\\nRun composed and microservices-base\", \"d \\napplications in production environments \\n\\nApplications composed by multiple microservices do need\", \" to be deployed into orchestrator clusters in \\norder to simplify the complexity of deployment and ma\", \"ke it viable from an IT point of view. Without \\nan orchestrator cluster, it would be difficult to de\", \"ploy and scale out a complex microservices \\napplication. \\n\\nIntroduction to orchestrators, schedulers\", \", and container clusters \\n\\nEarlier in this e-book, clusters and schedulers were introduced as part o\", \"f the discussion on software \\narchitecture and development. Kubernetes and Service Fabric are exampl\", \"es of Docker clusters. Both of \\nthese orchestrators can run as a part of the infrastructure provided\", \" by Microsoft Azure Kubernetes \\nService. \\n\\n93 \\n\\nCHAPTER 6 | Run, manage, and monitor Docker producti\", \"on environments \\n\\n \\n \\n\\fWhen applications are scaled-out across multiple host systems, the ability to\", \" manage each host \\nsystem and abstract away the complexity of the underlying platform becomes attrac\", \"tive. That\\u2019s \\nprecisely what orchestrators and schedulers provide. Let\\u2019s take a brief look at them h\", \"ere: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nSchedulers.  \\u201cScheduling\\u201d refers to the ability for an administrator to load a servic\", \"e file onto \\na host system that establishes how to run a specific container. Launching containers in\", \" a \\nDocker cluster tends to be known as scheduling. Although scheduling refers to the specific act \\n\", \"of loading the service definition, in a more general sense, schedulers are responsible for \\nhooking \", \"into a host\\u2019s init system to manage services in whatever capacity needed. \\n\\nA cluster scheduler has \", \"multiple goals: using the cluster\\u2019s resources efficiently, working with \\nuser-supplied placement con\", \"straints, scheduling applications rapidly to not leave them in a \\npending state, having a degree of \", \"\\u201cfairness,\\u201d being robust to errors, and always be available. \\n\\nOrchestrators.  Platforms extend life\", \"-cycle management capabilities to complex, multi-\\ncontainer workloads deployed on a cluster of hosts\", \". By abstracting the host infrastructure, \\norchestration tools give users a way to treat the entire \", \"cluster as a single deployment target. \\n\\nThe process of orchestration involves tooling and a platfor\", \"m that can automate all aspects of \\napplication management from initial placement or deployment per \", \"container; moving \\ncontainers to different hosts depending on its host\\u2019s health or performance; vers\", \"ioning and \\nrolling updates and health monitoring functions that support scaling and failover; and m\", \"any \\nmore. \\n\\nOrchestration is a broad term that refers to container scheduling, cluster management, \", \"and \\npossibly the provisioning of additional hosts. \\n\\nThe capabilities provided by orchestrators and\", \" schedulers are complex to develop and create from \\nscratch, therefore you usually would want to use\", \" orchestration solutions offered by vendors. \\n\\nManage production Docker environments \\n\\nCluster manag\", \"ement and orchestration is the process of controlling a group of hosts. This can involve \\nadding and\", \" removing hosts from a cluster, getting information about the current state of hosts and \\ncontainers\", \", and starting and stopping processes. Cluster management and orchestration are closely \\ntied to sch\", \"eduling because the scheduler must have access to each host in the cluster in order to \\nschedule ser\", \"vices. For this reason, the same tool is often used for both purposes. \\n\\nContainer Service and manag\", \"ement tools \\n\\nContainer Service provides rapid deployment of popular open-source container clusterin\", \"g and \\norchestration solutions. It uses Docker images to ensure that your application containers are\", \" fully \\nportable. By using Container Service, you can deploy DC/OS (powered by Mesosphere and Apache\", \" \\nMesos) and Docker Swarm clusters with Azure Resource Manager templates or the Azure portal to \\nens\", \"ure that you can scale these applications to thousands\\u2014even tens of thousands\\u2014of containers. \\n\\nYou d\", \"eploy these clusters by using Azure Virtual Machine Scale Sets, and the clusters take advantage \\nof \", \"Azure networking and storage offerings. To access Container Service, you need an Azure \\n\\n94 \\n\\nCHAPTE\", \"R 6 | Run, manage, and monitor Docker production environments \\n\\n \\n \\n  \\n  \\n  \\n\\fsubscription. With Con\", \"tainer Service, you can take advantage of the enterprise-grade features of \\nAzure while still mainta\", \"ining application portability, including at the orchestration layers. \\n\\nTable 6-1 lists common manag\", \"ement tools related to their orchestrators, schedulers, and clustering \\nplatform. \\n\\nTable 6-1. Docke\", \"r management tools \\n\\nManagement tools \\n\\nDescription \\n\\nRelated orchestrators \\n\\nAzure Monitor for Cont\", \"ainers \\n\\nKubernetes Web UI \\n(dashboard) \\n\\nAzure portal for Service Fabric \\nAzure Service Fabric Expl\", \"orer \\n\\nContainer Monitoring (Azure \\nMonitor) \\n\\nAzure Kubernetes Services (AKS) \\n\\nAzure Kubernetes Se\", \"rvice (AKS) \\nLocal Kubernetes \\n\\nAzure Service Fabric \\n\\nAzure Service Fabric \\nAzure Kubernetes Servic\", \"e (AKS) \\nMesosphere DC/OS and others. \\n\\nAzure dedicated \\nKubernetes \\nmanagement tool \\n\\nKubernetes \\nm\", \"anagement tool, \\ncan monitor and \\nmanage local \\nKubernetes cluster \\n\\nOnline and desktop \\nversion for\", \" managing \\nService Fabric \\nclusters, on Azure, on \\npremises, local \\ndevelopment, and \\nother clouds \\n\", \"\\nGeneral container \\nmanagement y \\nmonitoring solution. \\nCan manage \\nKubernetes clusters \\nthrough Azu\", \"re \\nMonitor for \\nContainers. \\n\\nAzure Service Fabric \\n\\nAnother choice for cluster-deployment and mana\", \"gement is Azure Service Fabric. Service Fabric is a \\nMicrosoft microservices platform that includes \", \"container orchestration as well as developer \\nprogramming models to build highly scalable microservi\", \"ces applications. Service Fabric supports \\nDocker in Linux and Windows Containers and can run in Win\", \"dows and Linux servers. \\n\\nThe following are Service Fabric management tools: \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nAzure portal \", \"for Service Fabric cluster-related operations (create/update/delete) a cluster or \\nconfigure its inf\", \"rastructure (VMs, load balancer, networking, etc.) \\n\\nAzure Service Fabric Explorer is a specialized \", \"web UI and desktop multi-platform tool that \\nprovides insights and certain operations on the Service\", \" Fabric cluster, from the nodes/VMs \\npoint of view and from the application and services point of vi\", \"ew. \\n\\n95 \\n\\nCHAPTER 6 | Run, manage, and monitor Docker production environments \\n\\n \\n \\n\\fMonitor contai\", \"nerized application services \\n\\nIt\\u2019s critical for applications split into multiple containers and mic\", \"roservices to have a way to monitor \\nand analyze the behavior of the whole application. \\n\\nAzure Moni\", \"tor \\n\\nAzure Monitor is an extensible analytics service that monitors your live application. It helps\", \" you to \\ndetect and diagnose performance issues and to understand what users actually do with your a\", \"pp. It\\u2019s \\ndesigned for developers, with the intent of helping you to continuously improve the perfor\", \"mance and \\nusability of your services or applications. Azure Monitor works with both web/services an\", \"d standalone \\napps on a wide variety of platforms like .NET, Java, Node.js and many other platforms,\", \" hosted on-\\npremises or in the cloud. \\n\\nAdditional resources \\n\\n\\u2022 \\n\\nOverview of Azure Monitor \\nhttps:\", \"//learn.microsoft.com/azure/azure-monitor/overview \\n\\n\\u2022  What is Application Insights? \\n\\nhttps://lear\", \"n.microsoft.com/azure/azure-monitor/app/app-insights-overview \\n\\n\\u2022  What is Azure Monitor Metrics? \\n\\n\", \"https://learn.microsoft.com/azure/azure-monitor/platform/data-platform-metrics \\n\\n\\u2022 \\n\\nContainer Monit\", \"oring solution in Azure Monitor \\nhttps://learn.microsoft.com/azure/azure-monitor/insights/containers\", \" \\n\\nSecurity and backup services \\n\\nThere are many support chores with lots of details that you have t\", \"o handle to ensure your applications \\nand infrastructure are in top notch condition to support busin\", \"ess needs, and the situation becomes \\nmore complicated in the microservices realm, so you need a way\", \" to have both high-level and detailed \\nviews when you need to take action. \\n\\nAzure has the tools to \", \"manage and provide a unified view of four critical aspects of both your cloud \\nand on-premises resou\", \"rces: \\n\\n\\u2022 \\n\\nSecurity. With Azure Security Center. \\n\\n\\u2013 \\n\\n\\u2013 \\n\\n\\u2013 \\n\\nGet full visibility and control over\", \" the security of your virtual machines, apps, and \\nworkloads. \\n\\nCentralize the management of your se\", \"curity policies and integrate existing processes \\nand tools. \\n\\nDetect real threats with advanced ana\", \"lytics. \\n\\n\\u2022 \\n\\nBackup. With Azure Backup. \\n\\n\\u2013 \\n\\n\\u2013 \\n\\nAvoid costly business disruptions, meet complianc\", \"e goals, and protect your data \\nagainst ransomware and human errors. \\n\\nKeep your backup data encrypt\", \"ed in transit and at rest. \\n\\n96 \\n\\nCHAPTER 6 | Run, manage, and monitor Docker production environment\", \"s \\n\\n \\n \\n\\f\\u2013 \\n\\nEnsure access based on multifactor authentication to prevent unauthorized use. \\n\\n\\u2022 \\n\\nOn\", \"-premises resources. With hybrid cloud solutions. \\n\\n97 \\n\\nCHAPTER 6 | Run, manage, and monitor Docker\", \" production environments \\n\\n \\n \\n\\fCHAPTER  7 \\n\\nContainerized Docker \\nApplication Lifecycle key \\ntakeaw\", \"ays \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\n\\u2022 \\n\\nContainer-based solutions provide important cost-saving benefits becau\", \"se containers solve \\ndeployment problems caused by dependency failures in production environments, t\", \"hereby \\nimproving DevOps and production operations significantly. \\n\\nDocker has become the de facto s\", \"tandard in the container industry and is supported by the \\nmost significant vendors in the Linux and\", \" Windows ecosystems, including Microsoft. In the \\nfuture, Docker will be ubiquitous in any datacente\", \"r in the cloud or on-premises. \\n\\nA Docker container is becoming the standard unit of deployment for \", \"any server-based \\napplication or service. \\n\\nDocker orchestrators like the ones provided in Azure Kub\", \"ernetes Service (AKS) and Azure \\nService Fabric are fundamental and indispensable for any microservi\", \"ces-based or multi-\\ncontainer applications that have significant complexity and scalability needs. \\n\", \"\\nAn end-to-end DevOps environment that supports Continuous Integration/Continuous \\nDeployment (CI/CD\", \") and connects to the production Docker environments can provide agility \\nand ultimately improve the\", \" time to market of your applications. \\n\\nAzure DevOps Services greatly simplifies your DevOps environ\", \"ment by deploying to Docker \\nenvironments from your CI/CD pipelines. This statement applies to simpl\", \"e Docker \\nenvironments as well as to advanced microservice and container orchestrators based on \\nAzu\", \"re. \\n\\n98 \\n\\nCHAPTER 7 | Containerized Docker Application Lifecycle key takeaways \\n\\n \\n \\n\\f\"]"