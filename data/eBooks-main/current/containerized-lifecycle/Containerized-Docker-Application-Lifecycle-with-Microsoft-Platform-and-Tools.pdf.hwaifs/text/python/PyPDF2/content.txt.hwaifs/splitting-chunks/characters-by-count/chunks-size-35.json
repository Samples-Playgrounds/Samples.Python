"[\" \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\nEDITION v6.0.0  - Updated to ASP.NET Core \", \"6.0  \\nRefer changelog  for the book updates and community contributions.  \\nThis guide is a general o\", \"verview for developing and deploying containerized ASP.NET Core \\napplications with Docker, using the\", \" Microsoft platform and tools. The guide includes a high -level \\nintroduction to Azure DevOps, for i\", \"mplementing CI/CD pipelines, as we ll as Azure Container Registry \\n(ACR) and Azure Kubernetes Servic\", \"es AKS for deployment.  \\nFor low -level, development -related details you can see the .NET Microserv\", \"ices: Architecture for \\nContainerized .NET Applications  guide and it related reference application \", \"eShopOnContainers . \\nCredits  \\nAuthor:  \\nCesar de la Torre , Sr. PM, .NET product team, Microsoft Co\", \"rp.  \\nAcquisitions Editor:  \\nJanine Patrick  \\nDevelopmental Editor:  \\nBob Russell , Solutions Profes\", \"sional at Microsoft  \\nOctal Publishing, Inc.  \\nEditorial Production:  \\nDianne Russell  \\nOctal Publis\", \"hing, Inc.  \\nCopyeditor:  \\nBob Russell , Solutions Professional at Microsoft  \\nParticipants and revi\", \"ewers:  \\nNish Anil , Sr. Program Manager, .NET team, Microsoft  \\nMiguel Veloso , Software Developmen\", \"t Engineer at Plain Concepts  \\nSumit Ghosh , Principal Consultant at Neudesic  \\nColin Dembovsky , De\", \"vOps Practice Lead, Cognizant Microsoft Business Group  \\nCopyright  \\nPUBLISHED BY  \\nMicrosoft Develo\", \"per Division, .NET and Visual Studio product teams  \\nA division of Microsoft Corporation  One Micros\", \"oft Way  \\nRedmond, Washington 98052 -6399  \\nCopyright \\u00a9 2022 by Microsoft Corporation  \\nAll rights r\", \"eserved. No part of the contents of this book may be reproduced or transmitted in any \\nform or by an\", \"y means without the written permission of the publisher.  \\nThis book is provided \\u201cas -is\\u201d and expres\", \"ses the author\\u2019s views and opinions. The views, opinions, and \\ninformation expressed in this book, i\", \"ncluding URL and other Internet website references, may change \\nwithout notice.  \\nSome examples depi\", \"cted herein are provided for illustration only and are fictitious. No real association \\nor connectio\", \"n is intended or should be inferred.  \\nMicrosoft and the trademarks listed at https://www.microsoft.\", \"com  on the \\u201cTrademarks\\u201d webpage are \\ntrademarks of the Microsoft group of companies.  \\nMac and macO\", \"S are trademarks of Apple Inc.  \\nThe Docker whale logo is a registered trademark of Docker, Inc.  Us\", \"ed by permission.  \\nAll other marks and logos are property of their respective owners.   \\ni Contents\", \"   \\nContents  \\nOverview of Containers and Docker  ................................ .................\", \"............... ......................  1 \\nLearn Docker  ................................ ..........\", \"...................... ................................ ................................ ...........\", \"..................... ..............  2 \\nComparing Docker containers with virtual machines  ........\", \"........................ ................................ ...........................  3 \\nA simple a\", \"nalogy  ................................ ................................ ..........................\", \"...... ................................ ................................ . 4 \\nLearn Docker specific \", \"terminologies  ................................ ................................ ...................\", \"............. ................................  4 \\nLearn docker containers, images, and registries  \", \"................................ ................................ ................................ .\", \"........ 6 \\nRoad to modern applications based on containers  ................................ ......\", \".......................... ................................ ... 8 \\nIntroduction to  the Docker appli\", \"cation life cycle  ................................ ................................  9 \\nContainers \", \"as the foundation for DevOps collaboration  ................................ .......................\", \"......... .........................  9 \\nChallenges in the application life cycle when using Docker. \", \" ................................ ................................ ..........  10 \\nIntroduction to a\", \" generic end -to-end Docker application life cycle workflow  ................................ ......\", \". 11 \\nBenefits of DevOps for containerized applications  ................................ ..........\", \"...................... ............................  12 \\nIntroduction to the Microsoft platform and \", \" tools for containerized apps  .....................  13 \\nDesigning and developing containerized app\", \"s using Docker and Microsoft Azure  ...... 17 \\nDesign Docker applications  .........................\", \"....... ................................ ................................ ..........................\", \"...... ..............  17 \\nCommon container design principles  ................................ ....\", \"............................ ................................ ...........................  18 \\nConta\", \"iner equals a process  ................................ ................................ ...........\", \"..................... ................................ ..........  18 \\nMonolithic applications  ....\", \"............................ ................................ ................................ .....\", \"........................... ......................  18 \\nMonolithic application deployed as a contain\", \"er  ................................ ................................ ..............................\", \".. . 21 \\nPublish a single Docker container app to Azure App Service  ...............................\", \". ................................ ........ 21 \\nState and data in Docker applications ..............\", \".................. ................................ ................................ ...............\", \"...........  22 \\nService -oriented applications  ................................ ..................\", \".............. ................................ ................................ ..........  25 \\nOrc\", \"hestrating microservices and multi -container applications for high scalability and availability ...\", \". 25 \\nSoftware platforms for container clustering, orchestration, and scheduling  ..................\", \".............. ...........  27 \\nUsing container -based orchestrators in Azure  .....................\", \"........... ................................ ................................ ..... 28 \\nUsing Azure \", \"Kubernetes Service  ................................ ................................ ..............\", \".................. ................................  29 \\nDevelopment environment for Kubernetes  ...\", \"............................. ................................ ................................ ....\", \".......  30 \\nGet started with Azure Kubernetes Service (AKS)  ................................ .....\", \"........................... ...............................  31  \\nii Contents  \\nDeploy with Helm cha\", \"rts into Kubernetes clusters  ................................ ................................ ....\", \".........................  31 \\nAdditional resources  ................................ ..............\", \".................. ................................ ................................ ...............\", \"........  32 \\nUsing Azure Service Fabric  ................................ .........................\", \"....... ................................ ................................ ...........  32 \\nStateless\", \" versus stateful microservices  ................................ ................................ ..\", \".............................. ....................  35 \\nUsing Azure Service Fabric Mesh  ..........\", \"...................... ................................ ................................ ...........\", \"....................  36 \\nChoosing orchestrators in Azure  ................................ ........\", \"........................ ................................ ...............................  37 \\nDeplo\", \"y to Azure Kubernetes Service (AKS)  ................................ ..............................\", \".. ................................ ................  38 \\nCreate the AKS environment in Azure  .....\", \"........................... ................................ ................................ ......\", \"...............  38 \\nCreate the AKS cluster  ................................ ......................\", \".......... ................................ ................................ ....................  3\", \"8 \\nDevelopment environment for Docker apps  ................................ .......................\", \"......... ................................ .............  40 \\nDevelopment tools choices: IDE or edit\", \"or  ................................ ................................ ..............................\", \".. ..............  40 \\nLanguage and framework choices  ................................ ............\", \".................... ................................ ............................  41 \\nInner -loop \", \"development workflow for Docker apps  ................................ .............................\", \"... ..............................  41 \\nBuilding a single app within a Docker container using Visual\", \" Studio Code and Docker CLI .............  42 \\nUse Docker Tools in Visual Studio on Windows  .......\", \"......................... ................................ ................................ ....... \", \"52 \\nConfigure your local environment  ................................ .............................\", \"... ................................ ............................  52 \\nDocker support in Visual Stud\", \"io  ................................ ................................ ..............................\", \".. ................................  52 \\nConfigure Docker tools  ................................ ..\", \".............................. ................................ ................................ ...\", \"...............  55 \\nUsing Windows PowerShell commands in a DockerFile to set up Windows Containers \", \"(Docker \\nstandard based)  ................................ ................................ ........\", \"........................ ................................ ................................ ..... 56 \", \"\\nBuild ASP.NET Core applications deployed as Linux containers into an AKS/Kubernetes orchestrator\\n .\", \"............................... ................................ ................................ ..\", \".............................. ................................ ................................ ...\", \"... 57 \\nCreating the ASP.NET Core Project using Visual Studio 2022 ................................ \", \"................................ ........ 57 \\nRegister the Solution in an Azure Container Registry (\", \"ACR)  ................................ ................................ ..........  66 \\nDocker appli\", \"cation DevOps workflow with Microsoft tools  ................................ .............  74 \\nSte\", \"ps in the outer -loop DevOps workflow for a Docker application  ................................ ...\", \"............................  75 \\nStep 1: Inner -loop development workflow  ........................\", \"........ ................................ ................................ ............  76 \\nStep 2:\", \" Source -Code Control integration and management with Azure DevOps Services and Git  76 \\nStep 3: Bui\", \"ld, CI, Integrate, and Test with Azure DevOps Services/GitHub and Docker  ......................  76\", \" \\nStep 4: CD, Deploy  ................................ ................................ ............\", \".................... ................................ ...........................  83 \\nStep 5: Run a\", \"nd manage  ................................ ................................ .......................\", \"......... ................................ ...............  89 \\nStep 6: Monitor and diagnose  ......\", \".......................... ................................ ................................ .......\", \"......................... .... 89  \\niii Contents  \\nCreate CI/CD pipelines in Azure DevOps Services f\", \"or a .NET application on Containers and \\ndeploying to a Kubernetes cluster  ........................\", \"........ ................................ ................................ .........................\", \"....... . 89 \\nRun, manage, and monitor Docker production environments  .............................\", \"... ........  93 \\nRun composed and microservices -based applications in production environments  ...\", \"............................  93 \\nIntroduction to orchestrators, schedulers, and container clusters \", \" ................................ ...............................  93 \\nManage production Docker envi\", \"ronments  ................................ ................................ ........................\", \"........ ................  94 \\nContainer Service and management tools  .............................\", \"... ................................ ................................ .............  94 \\nAzure Servi\", \"ce Fabric  ................................ ................................ .......................\", \"......... ................................ ........................  95 \\nMonitor containerized appli\", \"cation services  ................................ ................................ .................\", \"............... ...............  96 \\nAzure Monitor  ................................ ...............\", \"................. ................................ ................................ ................\", \"................ ... 96 \\nSecurity and backup services ................................ .............\", \"................... ................................ ................................ ....... 96 \\nCo\", \"ntainerized Docker Application Lifecycle key takeaways  ................................ ...........\", \"..  98  \\n1 CHAPTER 1 | Overview of Containers and Docker  \\n CHAPTER  1 \\nOverview of Containers \\nand \", \"Docker  \\nContainerization is an approach to software development in which an application or service,\", \" its \\ndependencies, and its configuration (abstracted as deployment manifest files) are packaged tog\", \"ether as \\na container image. You then can test the containerized application as a unit and  deploy i\", \"t as a container \\nimage instance to the host operating system (OS).  \\nJust as shipping containers al\", \"low goods to be transported by ship, train, or truck regardless of the \\ncargo inside, software conta\", \"iners act as a standard unit of software deployment that can contain \\ndifferent code and dependencie\", \"s. Containerizing software t his way enables developers and IT \\nprofessionals to deploy them across \", \"environments with little or no modification.  \\nContainers also isolate applications from each other \", \"on a shared OS. Containerized applications run \\non top of a container host that in turn runs on the \", \"OS (Linux or Windows). Containers therefore have a \\nmuch smaller footprint than virtual machine (VM)\", \" imag es. \\nEach container can run a whole web application or a service, as shown in Figure 1 -1. In \", \"this example, \\nDocker host is a container host, and App1, App2, Svc1, and Svc2 are containerized app\", \"lications or \\nservices.  \\n \\nFigure 1 -1. Multiple containers running on a container host  \\nAnother b\", \"enefit you can derive from containerization is scalability. You can scale out quickly by \\ncreating n\", \"ew containers for short -term tasks. From an application point of view, instantiating an \\nimage (cre\", \"ating a container) is similar to instantiating a p rocess like a service or web app. For \\nreliabilit\", \"y, however, when you run multiple instances of the same image across multiple host servers, \\nyou typ\", \"ically want each container (image instance) to run in a different host server or VM in different \\nfa\", \"ult domain s. \\nIn short, containers offer the benefits of isolation, portability, agility, scalabili\", \"ty, and control across the \\nentire application lifecycle workflow. The most important benefit is the\", \" environment isolation \\nprovided between Dev and Ops.  \\n \\n2 CHAPTER 1 | Overview of Containers and D\", \"ocker  \\n Learn Docker  \\nDocker  is an open -source project  for automating the deployment of applica\", \"tions as portable, self -\\nsufficient containers that can run on the cloud or on -premises. Docker is\", \" also a company  that \\npromotes and evolves this technology, working in collaboration with cloud, Li\", \"nux, and Windows \\nvendors, including Microsoft.  \\n \\nFigure 1 -2. Docker deploys containers at all la\", \"yers of the hybrid cloud  \\nAs shown in the above diagram, Docker containers can run anywhere, on -pr\", \"emises in the customer \\ndatacenter, in an external service provider or in the cloud, on Azure. Docke\", \"r image containers can also \\nrun natively on Linux and Windows. However, Windows image s can run onl\", \"y on Windows hosts and \\nLinux images can run on Linux hosts and Windows hosts (using a Hyper -V Linu\", \"x VM, so far), where \\nhost means a server or a VM.  \\nDevelopers can use development environments on \", \"Windows, Linux, or macOS. On the development \\ncomputer, the developer runs a Docker host where Docke\", \"r images are deployed, including the app \\nand its dependencies. Developers who work on Linux or on t\", \"he Mac, use  a Docker host that\\u2019s Linux -\\nbased, and they can only create images for Linux container\", \"s. (Developers working on the Mac can edit \\ncode or run the Docker command -line interface (CLI) fro\", \"m macOS, but as of this writing, containers \\ndon\\u2019t run directly on macOS. ) Developers who work on W\", \"indows can create images for either Linux or \\nWindows Containers.  \\nTo host containers in developmen\", \"t environments and provide additional developer tools, Docker \\nships Docker Desktop for Windows  or \", \"for macOS . These products install the necessary VM (the Docker \\nhost) to host the containers.  \\nTo \", \"run Windows Containers , there are two types of runtimes:  \\n\\u2022 Windows Server Containers  provide app\", \"lication isolation through process and namespace \\nisolation technology. A Windows Server Container s\", \"hares a kernel with the container host and \\nwith all containers running on the host.  \\n\\u2022 Hyper -V Co\", \"ntainers  expand on the isolation provided by Windows Server Containers by \\nrunning each container i\", \"n a highly optimized virtual machine. In this configuration, the kernel \\nof the container host isn\\u2019t\", \" shared with the Hyper -V Containers, providing better isolation.  \\n \\n3 CHAPTER 1 | Overview of Cont\", \"ainers and Docker  \\n The images for these containers are created and work just the same way. The dif\", \"ference is in how the \\ncontainer is created from the image \\u2014running a Hyper -V Container requires an\", \" extra parameter. For \\ndetails, see Hyper -V Containers . \\nComparing Docker containers with virtual \", \"machines  \\nFigure 1 -3 shows a comparison between VMs and Docker containers.  \\n \\nFigure 1 -3. Compar\", \"ison of traditional virtual machines to Docker containers  \\nAs shown in the above diagram, for VMs, \", \"there are three base layers in the host server. From the \\nbottom -up: Infrastructure, Host Operating\", \" System, and a Hypervisor. On top of all that, each VM has \\nits own OS and all necessary libraries. \", \"On the other hand, for Docker, the host server only has the  \\nInfrastructure and the OS. On top of t\", \"hat, the container engine keeps containers isolated, but lets \\nthem share the single base OS\\u2019s servi\", \"ces.  \\nBecause containers require far fewer resources (for example, they don\\u2019t need a full OS), they\", \"\\u2019re easy to \\ndeploy and they start fast. This allows you to have higher density, meaning that it all\", \"ows you to run \\nmore services on the same hardware unit, thereby reducing costs.  \\nAs a side effect \", \"of running on the same kernel, you get less isolation than VMs.  \\nThe main goal of an image is to en\", \"sure the same environment (dependencies) across different \\ndeployments. This means that you can debu\", \"g it on your machine and then deploy it to another \\nmachine, the same environment guaranteed.  \\nA co\", \"ntainer image is a way to package an app or service and deploy it in a reliable and reproducible \\nwa\", \"y. You could say that Docker isn\\u2019t only a technology but also a philosophy and a process.  \\n \\n4 CHAP\", \"TER 1 | Overview of Containers and Docker  \\n When using Docker, you won\\u2019t hear developers say, \\u201cIt w\", \"orks on my machine, why not in production?\\u201d \\nThey can just say, \\u201cIt runs on Docker\\u201d, because the pac\", \"kaged Docker application can be executed on \\nany supported Docker environment, and it runs the way i\", \"t w as intended to on all deployment targets \\n(such as Dev, QA, staging, and production).  \\nA simple\", \" analogy  \\nPerhaps a simple analogy can help getting the grasp of the core concept of Docker.  \\nLet\\u2019\", \"s go back in time to the 1950s for a moment. There were no word processors, and the \\nphotocopiers we\", \"re used everywhere (well, kind of).  \\nImagine you\\u2019re responsible for quickly issuing batches of lett\", \"ers as required, to mail them to \\ncustomers, using real paper and envelopes, to be delivered physica\", \"lly to each customer\\u2019s address \\n(there was no email back then).  \\nAt some point, you realize the let\", \"ters are just a composition of a large set of paragraphs, which are \\npicked and arranged as needed, \", \"according to the purpose of the letter, so you devise a system to \\nissue letters quickly, expecting \", \"to get a hefty raise.  \\nThe system is simple:  \\n1. You begin with a deck of transparent sheets conta\", \"ining one paragraph each.  \\n2. To issue a set of letters, you pick the sheets with the paragraphs yo\", \"u need, then you stack and \\nalign them so they look and read fine.  \\n3. Finally, you place the set i\", \"n the photocopier and press start to produce as many letters as \\nrequired.  \\nSo, simplifying, that\\u2019s\", \" the core idea of Docker.  \\nIn Docker, each layer is the resulting set of changes that happen to the\", \" filesystem after executing a \\ncommand, such as, installing a program.  \\nSo, when you \\u201clook\\u201d at the \", \"filesystem after the layer has been copied, you see all the files, included the \\nlayer when the prog\", \"ram was installed.  \\nYou can think of an image as an auxiliary read -only hard disk ready to be inst\", \"alled in a \\u201ccomputer\\u201d \\nwhere the operating system is already installed.  \\nSimilarly, you can think o\", \"f a container as the \\u201ccomputer\\u201d with the image hard disk installed. The \\ncontainer, just like a comp\", \"uter, can be powered on or off.  \\nLearn Docker specific terminologies  \\nThis section lists terms and\", \" definitions you should be familiar with before getting deeper into Docker. \\nFor further definitions\", \", see the extensive glossary  provided by Docker.  \\nContainer image : A package with all the depende\", \"ncies and information needed to create a container. \\nAn image includes all the dependencies (such as\", \" frameworks) plus deployment and execution  \\n5 CHAPTER 1 | Overview of Containers and Docker  \\n conf\", \"iguration to be used by a container runtime. Usually, an image derives from multiple base images \\nth\", \"at are layers stacked on top of each other to form the container\\u2019s filesystem. An image is immutable\", \" \\nonce it has been created.  \\nDockerfile : A text file that contains instructions for building a Doc\", \"ker image. It\\u2019s like a batch script, \\nthe first line states the base image to begin with and then fo\", \"llow the instructions to install required \\nprograms, copy files, and so on, until you get the worki \", \"ng environment you need.  \\nBuild : The action of building a container image based on the information\", \" and context provided by its \\nDockerfile, plus additional files in the folder where the image is bui\", \"lt. You can build images with the \\nfollowing Docker command:  \\ndocker build \\nContainer : An instance\", \" of a Docker image. A container represents the execution of a single \\napplication, process, or servi\", \"ce. It consists of the contents of a Docker image, an execution \\nenvironment, and a standard set of \", \"instructions. When scaling a service, you cre ate multiple instances \\nof a container from the same i\", \"mage. Or a batch job can create multiple containers from the same \\nimage, passing different paramete\", \"rs to each instance.  \\nVolumes : Offer a writable filesystem that the container can use. Since image\", \"s are read -only but most \\nprograms need to write to the filesystem, volumes add a writable layer, o\", \"n top of the container image, \\nso the programs have access to a writable filesystem. The p rogram do\", \"esn\\u2019t know it\\u2019s accessing a \\nlayered filesystem, it\\u2019s just the filesystem as usual. Volumes live in \", \"the host system and are managed \\nby Docker.  \\nTag: A mark or label you can apply to images so that d\", \"ifferent images or versions of the same image \\n(depending on the version number or the target enviro\", \"nment) can be identified.  \\nMulti -stage Build : Is a feature, since Docker 17.05 or higher, that he\", \"lps to reduce the size of the final \\nimages. For example, a large base image, containing the SDK can\", \" be used for compiling and \\npublishing and then a small runtime -only base image can be used to host\", \" the a pplication.  \\nRepository (repo) : A collection of related Docker images, labeled with a tag t\", \"hat indicates the image \\nversion. Some repos contain multiple variants of a specific image, such as \", \"an image containing SDKs \\n(heavier), an image containing only runtimes (lighter), etc. Those vari an\", \"ts can be marked with tags. A \\nsingle repo can contain platform variants, such as a Linux image and \", \"a Windows image.  \\nRegistry : A service that provides access to repositories. The default registry f\", \"or most public images is \\nDocker Hub  (owned by Docker as an organization). A registry usually conta\", \"ins repositories from \\nmultiple teams. Companies often have private registries to store and manage i\", \"mages they\\u2019ve created. \\nAzure Container Registry is another example.  \\nMulti -arch image : For multi\", \" -architecture, it\\u2019s a feature that simplifies the selection of the appropriate \\nimage, according to\", \" the platform where Docker is running. For example, when a Dockerfile requests a \\nbase image FROM mc\", \"r.microsoft.com/dotnet/sdk:6.0  from the registry, it actually gets 6.0-\\nnanoserver -20H2 , 6.0-nano\", \"server -1809  or 6.0-bullseye -slim, depending on the operating system \\nand version where Docker is \", \"running.   \\n6 CHAPTER 1 | Overview of Containers and Docker  \\n Docker Hub : A public registry to upl\", \"oad images and work with them. Docker Hub provides Docker \\nimage hosting, public or private registri\", \"es, build triggers and web hooks, and integration with GitHub \\nand Bitbucket.  \\nAzure Container Regi\", \"stry : A public resource for working with Docker images and its components in \\nAzure. This provides \", \"a registry that\\u2019s close to your deployments in Azure and that gives you control \\nover access, making\", \" it possible to use your Azure Active Directory groups and perm issions.  \\nDocker Trusted Registry (\", \"DTR) : A Docker registry service (from Docker) that can be installed on -\\npremises so it lives withi\", \"n the organization\\u2019s datacenter and network. It\\u2019s convenient for private \\nimages that should be mana\", \"ged within the enterprise. Docker Trusted Registry is included a s part of \\nthe Docker Datacenter pr\", \"oduct.  \\nDocker Desktop : Development tools for Windows and macOS for building, running, and testing\", \" \\ncontainers locally. Docker Desktop for Windows provides development environments for both Linux \\na\", \"nd Windows Containers. The Linux Docker host on Windows is based on a Hyper -V virtual machine. \\nThe\", \" host for Windows Containers is directly based on Windows. Docker Desktop for Mac is based on \\nthe A\", \"pple Hypervisor framework and the xhyve hypervisor , which provides a Linux Docker host virtual \\nmac\", \"hine on macOS. Docker Desktop for Windows and for Mac replaces Docker Toolbox, which was \\nbased on O\", \"racle VirtualBox.  \\nCompose : A command -line tool and YAML file format with metadata for defining a\", \"nd running multi -\\ncontainer applications. You define a single application based on multiple images \", \"with one or more \\n.yml files that can override values depending on the environment. After you\\u2019ve cre\", \"ated the definitions, \\nyou can deploy the whole multi -container application with a single command (\", \"docker -compose up) \\nthat creates a container per image on the Docker host.  \\nCluster : A collection\", \" of Docker hosts exposed as if it were a single virtual Docker host, so that the \\napplication can sc\", \"ale to multiple instances of the services spread across multiple hosts within the \\ncluster. Docker c\", \"lusters can be created with Kubernetes, Azur e Service Fabric, Docker Swarm and \\nMesosphere DC/OS.  \", \"\\nOrchestrator : A tool that simplifies the management of clusters and Docker hosts. Orchestrators \\ne\", \"nable you to manage their images, containers, and hosts through a command -line interface (CLI) or a\", \" \\ngraphical UI. You can manage container networking, configurations, load  balancing, service discov\", \"ery, \\nhigh availability, Docker host configuration, and more. An orchestrator is responsible for run\", \"ning, \\ndistributing, scaling, and healing workloads across a collection of nodes. Typically, orchest\", \"rator \\nproducts are t he same products that provide cluster infrastructure, like Kubernetes and Azur\", \"e Service \\nFabric, among other offerings in the market.  \\nLearn docker containers, images, and regis\", \"tries  \\nWhen using Docker, you create an app or service and package it and its dependencies into a \\n\", \"container image. An image is a static representation of the app or service and its configuration and\", \" \\ndependencies.  \\nTo run the app or service, the app\\u2019s image is instantiated to create a container, \", \"which will be running \\non the Docker host. Containers are initially tested in a development environm\", \"ent or PC.   \\n7 CHAPTER 1 | Overview of Containers and Docker  \\n You store images in a registry that\", \" acts as a library of images. You need a registry when deploying to \\nproduction orchestrators. Docke\", \"r maintains a public registry via Docker Hub ; other vendors provide \\nregistries for different colle\", \"ctions of images, including Azure Container Registry . Alternatively, \\nenterprises can have a privat\", \"e registry on -premises for their own Docker images.  \\nFigure 1 -4 shows how images and registries i\", \"n Docker relate to other components. It also shows the \\nmultiple registry offerings from vendors.  \\n\", \" \\nFigure 1 -4. Taxonomy of Docker terms and concepts  \\nThe registry is like a bookshelf where images\", \" are stored and available to be pulled for building \\ncontainers to run services or web apps. There a\", \"re private Docker registries on-premises and on the \\npublic cloud. Docker Hub is a public registry m\", \"aintained by Docker, along the Docker Trusted Registry \\nan enterprise -grade solution, Azure offers \", \"the Azure Container Registry. AWS, Google and others also \\nhave container registries.  \\nBy putting i\", \"mages in a registry, you can store static and immutable application bits, including all \\nof their de\", \"pendencies, at a framework level. You then can version and deploy images in multiple \\nenvironments a\", \"nd thus provide a consistent deployment unit.  \\n \\n8 CHAPTER 1 | Overview of Containers and Docker  \\n\", \" Private image registries, either hosted on -premises or in the cloud, are recommended when:  \\n\\u2022 You\", \"r images must not be shared publicly due to confidentiality.  \\n\\u2022 You want to have minimum network la\", \"tency between your images and your chosen \\ndeployment environment. For example, if your production e\", \"nvironment is Azure, you probably \\nwant to store your images in Azure Container Registry  so that ne\", \"twork latency is minimal. In a \\nsimilar way, if your production environment is on -premises, you mig\", \"ht want to have an on -\\npremises Docker Trusted Registry available within the same local network.  \\n\", \"Road to modern applications based on containers  \\nYou\\u2019re probably reading this book because you\\u2019re p\", \"lanning the development of new applications or \\nyou\\u2019re assessing the impact of using Docker, Contain\", \"ers, and new approaches like Microservices in \\nyour company.  \\nThe adoption of new development parad\", \"igms must be taken with caution before starting a project, to \\nassess the impact on your dev teams, \", \"your budget, or your infrastructure.  \\nMicrosoft has been working on rich guidance, sample applicati\", \"ons, and a suite of e -books that can \\nhelp you make an informed decision and guide your team throug\", \"h a successful development, \\ndeployment, and operations of your new applications.  \\nThis book belong\", \"s to a Microsoft suite of guides that cover many of the needs and challenges you\\u2019ll \\nface during the\", \" process of developing new modern applications based on containers.  \\nYou can find additional Micros\", \"oft e -books related to Docker containers in the list below:  \\n\\u2022 .NET Microservices: Architecture fo\", \"r Containerized .NET Applications  \\nhttps://learn.microsoft.com/dotnet/architecture/microservices/  \", \"\\n\\u2022 Modernize existing .NET applications with Azure cloud and Windows Containers  \\nhttps://learn.micr\", \"osoft.com/dotnet/architecture/modernize -with-azure -containers/   \\n9 CHAPTER 2 | Introduction to  t\", \"he Docker application life cycle  \\n CHAPTER  2 \\nIntroduction to  the Docker \\napplication life cycle \", \" \\nThe life cycle of containerized applications is a journey that begins with the developer. The deve\", \"loper \\nchooses to implement containers and Docker because it eliminates frictions in deployments and\", \" IT \\noperations, which ultimately helps everyone to be more agile, more productive end -to-end, and \", \"faster.  \\nContainers as the foundation for DevOps \\ncollaboration  \\nBy the very nature of the contain\", \"ers and Docker technology, developers can share their software and \\ndependencies easily with IT oper\", \"ations and production environments while eliminating the typical \\u201cit \\nworks on my machine\\u201d excuse. C\", \"ontainers solve applicati on conflicts between different environments. \\nIndirectly, containers and D\", \"ocker bring developers and IT operations closer together, making it easier \\nfor them to collaborate \", \"effectively. Adopting the container workflow provides many customers \\nwith the DevOps  continuity th\", \"ey\\u2019ve sought but previously had to implement via more complex \\nconfiguration for release and build p\", \"ipelines. Containers simplify the build/test/deploy pipelines \\nin DevOps.  \\n \\nFigure 2 -1. Main work\", \"loads per \\u201cpersonas\\u201d in the life cycle for containerized Docker applications  \\nWith Docker container\", \"s, developers own what\\u2019s within the container (application and service, and \\ndependencies to framewo\", \"rks and components) and how the containers and services behave together \\nas an application composed \", \"by a collection of services. The inte rdependencies of the multiple \\ncontainers are defined in a doc\", \"ker -compose.yml file, or what could be called a deployment manifest . \\nMeanwhile, IT operations tea\", \"ms (IT professionals and management) can focus on the management \\n \\n10 CHAPTER 2 | Introduction to  \", \"the Docker application life cycle  \\n of production environments; infrastructure; scalability; monito\", \"ring; and, ultimately, ensuring that the \\napplications are delivering properly for the end users, wi\", \"thout having to know the contents of the \\nvarious containers. Hence, the name \\u201ccontainer,\\u201d reca llin\", \"g the analogy to real -world shipping \\ncontainers. Thus, the owners of a container\\u2019s content need no\", \"t concern themselves with how the \\ncontainer will be shipped, and the shipping company transports a \", \"container from its point of origin \\nto its destination w ithout knowing or caring about the contents\", \". In a similar manner, developers can \\ncreate and own the contents within a Docker container without\", \" the need to concern themselves with \\nthe \\u201ctransport\\u201d mechanisms.  \\nIn the pillar on the left side o\", \"f Figure 2 -1, developers write and run code locally in Docker containers \\nby using Docker for Windo\", \"ws or Mac. They define the operating environment for the code by using a \\nDockerfile that specifies \", \"the base operating system t o run as well as the build steps for building their \\ncode into a Docker \", \"image. The developers define how one or more images will interoperate using the \\naforementioned dock\", \"er -compose.yml file deployment manifest. As they complete their local \\ndevelopment, the y push thei\", \"r application code plus the Docker configuration files to the code \\nrepository of their choice (that\", \" is, Git repository).  \\nThe DevOps pillar defines the build \\u2013Continuous Integration (CI) pipelines u\", \"sing the Dockerfile \\nprovided in the code repository. The CI system pulls the base container images \", \"from the selected \\nDocker registry and builds the custom Docker images for the appl ication. The ima\", \"ges then are \\nvalidated and pushed to the Docker registry used for the deployments to multiple envir\", \"onments.  \\nIn the pillar on the right, operations teams manage deployed applications and infrastruct\", \"ure in \\nproduction while monitoring the environment and applications so that they can provide feedba\", \"ck and \\ninsights to the development team about how the application mi ght be improved. Container app\", \"s are \\ntypically run in production using container orchestrators like Kubernetes , where usually Hel\", \"m charts  \\nare used to configure deployment units, instead of docker -compose files.  \\nThe two teams\", \" are collaborating through a foundational platform (Docker containers) that provides \\na separation o\", \"f concerns as a contract, while greatly improving the two teams\\u2019 collaboration in the \\napplication l\", \"ife cycle. The developers own the container c ontents, its operating environment, and the \\ncontainer\", \" interdependencies, whereas the operations teams take the built images along with the \\nmanifest and \", \"runs them in their orchestration system.  \\nChallenges in the application life cycle when using Docke\", \"r.  \\nThere are many reasons that will increase the number of containerized applications in the upcom\", \"ing \\nyears, and one of these reasons is the creation of applications based on microservices.  \\nDurin\", \"g the last 15 years, the use of web services has been the base of thousands of applications, and \\npr\", \"obably, after a few years, you\\u2019ll find the same situation with microservice -based applications \\nrun\", \"ning on Docker containers.  \\nIt is also worth to mention that you can also use Docker containers for\", \" monolithic applications and \\nyou still get most of the benefits of Docker. Containers are not targe\", \"ting only microservices.  \\nThe use of Docker containerization and microservices causes new challenge\", \"s in the development \\nprocess of your organizations and therefore, you need a solid strategy to main\", \"tain many containers  \\n11 CHAPTER 2 | Introduction to  the Docker application life cycle  \\n and micr\", \"oservices running on production systems. Eventually, enterprise applications will have \\nhundreds or \", \"thousands of containers/instances running in production.  \\nThese challenges create new demands when \", \"using DevOps tools, so you\\u2019ll have to define new \\nprocesses in your DevOps activities, and find answ\", \"ers for the following type of questions:  \\n\\u2022 Which tools can I use for development, CI/CD, managemen\", \"t and operations??  \\n\\u2022 How can my company manage errors in containers when running in production?  \\n\", \"\\u2022 How can we change pieces of our software in production with minimum downtime?  \\n\\u2022 How can we scale\", \" and monitor our production system?  \\n\\u2022 How can we include the testing and deployment of containers \", \"in our release pipeline?  \\n\\u2022 How can we use Open Source tools/platforms for containers in Microsoft \", \"Azure?  \\nIf you can answer all those questions, you\\u2019ll be better prepared to move your applications \", \"(existing or \\nnew apps) to Docker containers.  \\nIntroduction to a generic end -to-end Docker applica\", \"tion life cycle \\nworkflow  \\nFigure 2 -2 presents a more detailed workflow for a Docker application l\", \"ife cycle, focusing in this \\ninstance on specific DevOps activities and assets.  \\n \\nFigure 2 -2. Hig\", \"h-level workflow for the Docker containerized application life cycle  \\nEverything begins with the de\", \"veloper, who starts writing code in the inner -loop workflow. The inner -\\nloop stage is where develo\", \"pers define everything that happens before pushing code into the code \\nrepository (for example, a so\", \"urce control system such as Git ). After it\\u2019s committed, the repository \\ntriggers Continuous Integra\", \"tion (CI) and the rest of the workflow.  \\n \\n12 CHAPTER 2 | Introduction to  the Docker application l\", \"ife cycle  \\n The inner loop consists of typical steps like \\u201ccode,\\u201d \\u201crun,\\u201d \\u201ctest,\\u201d and \\u201cdebug,\\u201d plus \", \"the additional steps \\nneeded right before running the app locally. This is the developer\\u2019s process t\", \"o run and test the app as \\na Docker container. The inner -loop workflow will be explained in the sec\", \"tions that follow.  \\nTaking a step back to look at the end -to-end workflow, the DevOps workflow is \", \"more than a \\ntechnology or a tool set, it\\u2019s a mindset that requires cultural evolution. It\\u2019s people,\", \" processes, and the \\nappropriate tools to make your application life cycle faste r and more predicta\", \"ble. Enterprises that \\nadopt a containerized workflow typically restructure their organizations to r\", \"epresent people and \\nprocesses that match the containerized workflow.  \\nPracticing DevOps can help t\", \"eams respond faster together to competitive pressures by replacing \\nerror -prone manual processes wi\", \"th automation, which results in improved traceability and repeatable \\nworkflows. Organizations also \", \"can manage environments more ef ficiently and realize cost savings with \\na combination of on -premis\", \"es and cloud resources as well as tightly integrated tooling.  \\nWhen implementing your DevOps workfl\", \"ow for Docker applications, you\\u2019ll see that Docker \\ntechnologies are present in almost every stage o\", \"f the workflow, from your development box while \\nworking in the inner loop (code, run, debug), the b\", \"uild -test-CI phase, an d, finally, the deployment of \\nthose containers to the staging and productio\", \"n environments.  \\nImprovement of quality practices helps to identify defects early in the developmen\", \"t cycle, which \\nreduces the cost of fixing them. By including the environment and dependencies in th\", \"e image and \\nadopting a philosophy of deploying the same image across multip le environments, you pr\", \"omote a \\ndiscipline of extracting the environment -specific configurations making deployments more r\", \"eliable.  \\nRich data obtained through effective instrumentation (monitoring and diagnostics) provide\", \"s insight \\ninto performance issues and user behavior to guide future priorities and investments.  \\nD\", \"evOps should be considered a journey, not a destination. It should be implemented incrementally \\nthr\", \"ough appropriately scoped projects from which you can demonstrate success, learn, and evolve.  \\nBene\", \"fits of DevOps for containerized applications  \\nHere are some of the most important benefits provide\", \"d by a solid DevOps workflow:  \\n\\u2022 Deliver better -quality software, faster and with better complianc\", \"e.  \\n\\u2022 Drive continuous improvement and adjustments earlier and more economically.  \\n\\u2022 Increase tran\", \"sparency and collaboration among stakeholders involved in delivering and \\noperating software.  \\n\\u2022 Co\", \"ntrol costs and utilize provisioned resources more effectively while minimizing security \\nrisks.  \\n\\u2022\", \" Plug and play well with many of your existing DevOps investments, including investments in \\nopen -s\", \"ource.   \\n13 CHAPTER 3 | Introduction to the Microsoft platform and  tools for containerized apps  \\n\", \" CHAPTER  3 \\nIntroduction to the \\nMicrosoft platform \\nand tools for containerized \\napps \\nVision: Cre\", \"ate an adaptable, enterprise -grade, containerized application life cycle that spans your \\ndevelopme\", \"nt, IT operations, and production management.  \\nFigure 3 -1 shows the main pillars in the life cycle\", \" of Docker apps classified by the type of work \\ndelivered by multiple teams (app -development, DevOp\", \"s infrastructure processes, and IT management \\nand operations). Usually, in the enterprise, the prof\", \"iles of \\u201cthe persona\\u201d responsible for each area are \\ndifferent. So are their skills.   \\n14 CHAPTER 3\", \" | Introduction to the Microsoft platform and  tools for containerized apps  \\n  \\nFigure 3 -1. Main p\", \"illars in the life cycle for containerized Docker applications with Microsoft platform and tools  \\nA\", \" containerized Docker life -cycle workflow can be initially prescriptive based on \\u201cby -default produ\", \"ct \\nchoices,\\u201d making it easier for developers to get started faster, but it\\u2019s fundamental that under\", \" the \\nhood there must be an open framework so that it will be a flexible workflow capable of adjusti\", \"ng to \\nthe different contexts from each organization or enterprise. The workflow infrastructure (com\", \"ponents \\nand products) must be flexible enough to cover the environment that each company will have \", \"in the \\nfuture, ev en being capable of swapping development or DevOps products to others. This flexi\", \"bility, \\nopenness, and the broad choice of technologies in the platform and infrastructure are preci\", \"sely the \\nMicrosoft priorities for containerized Docker applications, as expl ained in the chapters \", \"that follow.  \\nTable 3 -1 demonstrates that the intention of the Azure DevOps for containerized Dock\", \"er applications \\nis to provide an open DevOps workflow so that you can choose what products to use f\", \"or each phase \\n(Microsoft or third -party) while providing a simplified wor kflow that provides \\u201cby \", \"-default -products\\u201d \\nalready connected; thus, you can quickly get started with your enterprise -leve\", \"l DevOps workflow for \\nDocker apps.  \\nTable 3 -1. DevOps workflows, open to any technology  \\nHost  M\", \"icrosoft technologies  Third -party (Azure pluggable)  \\nPlatform for \\nDocker apps  \\u2022 Microsoft Visua\", \"l Studio and \\nVisual Studio Code  \\n\\u2022 .NET  \\n\\u2022 Microsoft Azure Kubernetes \\nService (AKS)  \\n\\u2022 Azure Co\", \"ntainer Registry \\\\ \\u2022 Any code editor (for example, Sublime)  \\n\\u2022 Any language (Node.js, Java, Go, etc\", \".)  \\n\\u2022 Any orchestrator and scheduler  \\n\\u2022 Any Docker registry \\\\ \\n \\n15 CHAPTER 3 | Introduction to th\", \"e Microsoft platform and  tools for containerized apps  \\n Host  Microsoft technologies  Third -party\", \" (Azure pluggable)  \\nDevOps for \\nDocker apps  \\u2022 Azure DevOps Services  \\n\\u2022 Microsoft Team Foundation \", \"\\nServer  \\n\\u2022 GitHub  \\n\\u2022 Azure Kubernetes Service \\n(AKS) \\\\ \\u2022 GitHub, Git, Subversion, etc.  \\n\\u2022 Jenkins\", \", Chef, Puppet, Velocity, CircleCI, \\nTravisCI, etc.  \\n\\u2022 On-premises Docker Datacenter, Kubernetes, \\n\", \"Mesos DC/OS, etc. \\\\ \\nManagement \\nand \\nmonitoring  \\u2022 Azure Monitor  \\u2022 Marathon, Chronos, etc. \\\\ \\nThe \", \"Microsoft platform and tools for containerized Docker apps, as defined in Table 3 -1, comprise the \\n\", \"following components:  \\n\\u2022 Platform for Docker Apps development  The development of a service, or col\", \"lection of \\nservices that make up an \\u201capp.\\u201d The development platform provides all the work developer\", \"s \\nrequires prior to pushing their code to a shared code repository. Developing services, \\ndeployed \", \"as containers, are sim ilar to the development of the same apps or services without \\nDocker. You con\", \"tinue to use your preferred language (.NET, Node.js, Go, etc.) and preferred \\neditor or IDE like  Vi\", \"sual Studio or Visual Studio Code. However, ra ther than consider Docker a \\ndeployment destination, \", \"you develop your services in the Docker environment. You build, run, \\ntest, and debug your code in c\", \"ontainers locally, providing the destination environment at \\ndevelopment time. By providing the dest\", \"inatio n environment locally, Docker containers set up \\nwhat will drastically help you improve your \", \"DevOps life cycle. Visual Studio and Visual Studio \\nCode have extensions to integrate Docker contain\", \"ers within your development process.  \\n\\u2022 DevOps for Docker Apps  Developers creating Docker applicat\", \"ions can use Azure DevOps , \\nGitHub or any other third -party product, like Jenkins, to build out a \", \"comprehensive \\nautomated application life -cycle management (ALM).  \\n  With Azure DevOps and/or GitH\", \"ub, developers can create container -focused DevOps for a \\nfast, iterative process that covers sourc\", \"e -code control from anywhere (Azure DevOps -Git, \\nGitHub, any remote Git repository, or Subversion)\", \", Continuous Integration (CI), i nternal unit \\ntests, inter -container/service integration tests, Co\", \"ntinuous Delivery (CD), and release \\nmanagement (RM). Developers also can automate their Docker appl\", \"ication releases into Azure \\nKubernetes Service (AKS), from development to staging and produc tion e\", \"nvironments.  \\n\\u2022 Management and Monitoring  IT can manage and monitor production applications and \\ns\", \"ervices in several ways, integrating both perspectives in a consolidated experience.  \\n\\u2013 Azure porta\", \"l  Azure Kubernetes Service (AKS) helps you to set up and maintain your \\nDocker environments. You ca\", \"n also use other orchestrators to visualize and configure \\nyour cluster.  \\n\\u2013 Docker tools  You can m\", \"anage your container applications using familiar tools. \\nThere\\u2019s no need to change your existing Doc\", \"ker management practices to move \\ncontainer workloads to the cloud. Use the application management t\", \"ools you\\u2019re  \\n16 CHAPTER 3 | Introduction to the Microsoft platform and  tools for containerized app\", \"s  \\n already familiar with and connect via the standard API endpoints for the orchestrator \\nof your \", \"choice. You also can use other third -party tools to manage your Docker \\napplications or even CLI Do\", \"cker tools.  \\n  Even if you\\u2019re familiar with Linux commands, you can manage your container \\napplicat\", \"ions using Microsoft Windows and PowerShell with a Linux Subsystem \\ncommand line and the products (D\", \"ocker, Kubernetes\\u2026) clients running on this Linux \\nSubsystem capability. Yo u\\u2019ll learn more about us\", \"ing these tools under Linux \\nSubsystem using your favorite Microsoft Windows OS later in this book. \", \" \\n\\u2013 Open -source tools  Because AKS exposes the standard API endpoints for the \\norchestration engine\", \", the most popular tools are compatible with AKS and, in most \\ncases, will work out of the box \\u2014incl\", \"uding visualizers, monitoring, command -line \\ntools, and even future tools as they be come available\", \".  \\n\\u2013 GitHub Advanced Security  GitHub Advanced Security  offers a suite of tools for \\nsecuring the \", \"software supply chain that can seamlessly integrate security into the \\ndaily workflow of teams devel\", \"oping containerized applications.  \\n\\u2013 Azure Monitor  Is Azure\\u2019s solution to monitor every angle of y\", \"our production \\nenvironment. You can monitor production Docker applications by just setting up its \\n\", \"SDK into your services so that you can get system -generated log data from the \\napplications.  \\nThus\", \", Microsoft offers a complete foundation for an end -to-end containerized Docker application life \\nc\", \"ycle. However, it\\u2019s a collection of products and technologies that allow you to optionally select an\", \"d \\nintegrate with existing tools and processes . The flexibility in a broad approach along with the \", \"strength \\nin the depth of capabilities place Microsoft in a strong position for containerized Docker\", \" application \\ndevelopment.   \\n17 CHAPTER 4 | Designing and developing containerized apps using Docke\", \"r and Microsoft Azure  \\n CHAPTER  4 \\nDesigning and developing \\ncontainerized apps using \\nDocker and \", \"Microsoft \\nAzure  \\nVision: Design and develop scalable solutions with Docker in mind.  \\nThere are ma\", \"ny great -fit use cases for containers, not just for microservices -oriented architectures, but \\nals\", \"o when you simply have regular services or web applications to run and you want to reduce frictions \", \"\\nbetween development and production environment deployments.  \\nDesign Docker applications  \\nChapter \", \"1 introduced the fundamental concepts regarding containers and Docker. That information is \\nthe basi\", \"c level of information you need to get started. But, enterprise applications can be complex and \\ncom\", \"posed of multiple services instead of a single ser vice or container. For those optional use cases, \", \"\\nyou need to know additional approaches to design, such as Service -Oriented Architecture (SOA) and \", \"\\nthe more advanced microservices concepts and container orchestration concepts. The scope of this \\nd\", \"ocument is not limited to microservices but to any Docker application life cycle, therefore, it does\", \" \\nnot explore microservices architecture in depth because you can also use containers and Docker wit\", \"h \\nregular SOA, background tasks or jobs, or even with monolithic app lication deployment approaches\", \".  \\nMore info  To learn more about enterprise applications and microservices architecture in depth, \", \"read \\nthe guide NET Microservices: Architecture for Containerized .NET Applications  that you can al\", \"so \\ndownload from https://aka.ms/MicroservicesEbook . \\nHowever, before you get into the application \", \"life cycle and DevOps, it\\u2019s important to know how you\\u2019re \\ngoing to design and construct your applica\", \"tion and what are your design choices.   \\n18 CHAPTER 4 | Designing and developing containerized apps\", \" using Docker and Microsoft Azure  \\n Common container design principles  \\nAhead of getting into the \", \"development process there are a few basic concepts worth mentioning with \\nregard to how you use cont\", \"ainers.  \\nContainer equals a process  \\nIn the container model, a container represents a single proce\", \"ss. By defining a container as a process \\nboundary, you begin to create the primitives used to scale\", \", or batch -off, processes. When you run a \\nDocker container, you\\u2019ll see an ENTRYPOINT  definition. \", \"This defines the process and the lifetime of \\nthe container. When the process completes, the contain\", \"er life -cycle ends. There are long -running \\nprocesses, such as web servers, and short -lived proce\", \"sses, such as batch jobs, which might have \\nbeen  implemented as Microsoft Azure WebJobs . If the pr\", \"ocess fails, the container ends, and the \\norchestrator takes over. If the orchestrator was instructe\", \"d to keep five instances running and one fails, \\nthe orchestrator will create another container to r\", \"eplace the failed process. In a batch job, the process \\nis started with parameters. When the process\", \" completes, the work is complete.  \\nYou might find a scenario in which you want multiple processes r\", \"unning in a single container. In any \\narchitecture document, there\\u2019s never a \\u201cnever,\\u201d nor is there a\", \"lways an \\u201calways.\\u201d For scenarios requiring \\nmultiple processes, a common pattern is to use Superviso\", \"r . \\nMonolithic applications  \\nIn this scenario, you\\u2019re building a single and monolithic web applica\", \"tion or service and deploying it as \\na container. Within the application, the structure might not be\", \" monolithic; it might comprise several \\nlibraries, components, or even layers (applicatio n layer, d\", \"omain layer, data access layer, etc.). \\nExternally, it\\u2019s a single container, like a single process, \", \"single web application, or single service.  \\nTo manage this model, you deploy a single container to \", \"represent the application. To scale it, just add \\na few more copies with a load balancer in front. T\", \"he simplicity comes from managing a single \\ndeployment in a single container or virtual machine (VM)\", \".  \\nFollowing the principal that a container does one thing only, and does it in one process, the \\nm\", \"onolithic pattern is in conflict. You can include multiple components/libraries or internal layers \\n\", \"within each container, as illustrated in Figure 4 -1.  \\n19 CHAPTER 4 | Designing and developing cont\", \"ainerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -1. An example of monolithic applicati\", \"on architecture  \\nA monolithic app has all or most of its functionality within a single process or c\", \"ontainer and it\\u2019s \\ncomponentized in internal layers or libraries. The downside to this approach come\", \"s if or when the \\napplication grows, requiring it to scale. If the entire ap plication scaled, it\\u2019s \", \"not really a problem. \\nHowever, in most cases, a few parts of the application are the choke points t\", \"hat require scaling, \\nwhereas other components are used less.  \\nUsing the typical e -commerce exampl\", \"e, what you likely need is to scale the product information \\ncomponent. Many more customers browse p\", \"roducts than purchase them. More customers use their \\nbasket than use the payment pipeline. Fewer cu\", \"stomers add comments or  view their purchase history. \\nAnd you likely have only a handful of employe\", \"es, in a single region, that need to manage the content \\nand marketing campaigns. By scaling the mon\", \"olithic design, all of the code is deployed multiple times.  \\nIn addition to the \\u201cscale -everything\\u201d\", \" problem, changes to a single component require complete \\nretesting of the entire application as wel\", \"l as a complete redeployment of all the instances.  \\nThe monolithic approach is common, and many org\", \"anizations are developing with this architectural \\nmethod. Many enjoy good enough results, whereas o\", \"thers encounter limits. Many designed their \\napplications in this model because the tools and infras\", \"tructure we re too difficult to build SOAs, and \\nthey didn\\u2019t see the need \\u2014until the app grew.  \\nFro\", \"m an infrastructure perspective, each server can run many applications within the same host and \\nhav\", \"e an acceptable ratio of efficiency in your resources usage, as shown in Figure 4 -2. \\n \\n20 CHAPTER \", \"4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -2. A\", \" host running multiple apps/containers  \\nFinally, from an availability perspective, monolithic appli\", \"cations must be deployed as a whole; that \\nmeans that in case you must stop and start , all function\", \"ality and all users will be affected during the \\ndeployment window. In certain situations, the use o\", \"f Azure and containers can minimize these \\nsituations and reduce the probability of downtime of your\", \" application, as you can see in Figure 4 -3. \\nYou can deploy monolithic applications in Azure by usi\", \"ng dedicated VMs for each instance. Using \\nAzure VM Scale Sets , you can scale the VMs easily.  \\nYou\", \" can also use Azure App Services  to run monolithic applications and easily scale instances without \", \"\\nhaving to manage the VMs. Azure App Services can run single instances of Docker containers, as well\", \", \\nsimplifying the deployment.  \\nYou can deploy multiple VMs as Docker hosts and run any number of c\", \"ontainers per VM. Then, by \\nusing an Azure Load Balancer, as illustrated in the Figure 4 -3, you can\", \" manage scaling.  \\n \\nFigure 4 -3. Multiple hosts scaling out a single Docker application  \\nYou can m\", \"anage the deployment of the hosts themselves via traditional deployment techniques.  \\nYou can manage\", \" Docker containers from the command line by using commands like docker run and \\ndocker -compose up, \", \"and you can also automate it in Continuous Delivery (CD) pipelines and deploy \\nto Docker hosts from \", \"Azure DevOps Services, for instance.  \\n \\n21 CHAPTER 4 | Designing and developing containerized apps \", \"using Docker and Microsoft Azure  \\n Monolithic application deployed as a container  \\nThere are benef\", \"its to using containers to manage monolithic deployments. Scaling the instances of \\ncontainers is fa\", \"r faster and easier than deploying additional VMs.  \\nDeploying updates as Docker images is far faste\", \"r and network efficient. Docker containers typically \\nstart in seconds, speeding rollouts. Tearing d\", \"own a Docker container is as easy as invoking the docker \\nstop command, typically completing in less\", \" than a sec ond. \\nBecause containers are inherently immutable, by design, you never need to worry ab\", \"out corrupted \\nVMs because an update script forgot to account for some specific configuration or fil\", \"e left on disk.  \\nAlthough monolithic apps can benefit from Docker, we\\u2019re touching on only the tips \", \"of the benefits. \\nThe larger benefits of managing containers come from deploying with container orch\", \"estrators that \\nmanage the various instances and life cycle of each containe r instance. Breaking up\", \" the monolithic \\napplication into subsystems that can be scaled, developed, and deployed individuall\", \"y is your entry \\npoint into the realm of microservices.  \\nTo learn about how to \\u201clift and shift\\u201d mon\", \"olithic applications with containers and how you can \\nmodernize your applications, you can read this\", \" additional Microsoft guide, Modernize existing .NET \\napplications with Azure cloud and Windows Cont\", \"ainers , which you can also download as PDF from \\nhttps://aka.ms/LiftAndShiftWithContainersEbook . \\n\", \"Publish a single Docker container app to Azure App Service  \\nEither because you want to get a quick \", \"validation of a container deployed to Azure or because the \\napp is simply a single -container app, A\", \"zure App Services provides a great way to provide scalable \\nsingle -container services.  \\nUsing Azur\", \"e App Service is intuitive and you can get up and running quickly because it provides great \\nGit int\", \"egration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure. \\nB\", \"ut, traditionally (with no Docker), if you neede d other capabilities, frameworks, or dependencies t\", \"hat \\naren\\u2019t supported in App Services, you needed to wait for it until the Azure team updates those \", \"\\ndependencies in App Service or switched to other services like Service Fabric, Cloud Services, or e\", \"ven \\nplain VMs, for which you have further control and can install a required component or framework\", \" for \\nyour application.  \\nNow, as shown in Figure  4-4, when using Visual Studio 2022, container sup\", \"port in Azure App Service \\ngives you the ability to include whatever you want in your app environmen\", \"t. If you added a \\ndependency to your app, because you\\u2019re running it in a container, you get the cap\", \"ability of including \\nthose dependencies in your Dockerfile or Docker image.   \\n22 CHAPTER 4 | Desig\", \"ning and developing containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -4. Publishing\", \" a container to Azure App Service from Visual Studio apps/containers  \\nFigure 4 -4 also shows that t\", \"he publish flow pushes an image through a Container Registry, which can \\nbe the Azure Container Regi\", \"stry (a registry near to your deployments in Azure and secured by Azure \\nActive Directory groups and\", \" accounts) or any other Docker  Registry like Docker Hub or on -premises \\nregistries.  \\nState and da\", \"ta in Docker applications  \\nIn most cases, you can think of a container as an instance of a process.\", \" A process does not maintain \\npersistent state. While a container can write to its local storage, as\", \"suming that an instance will be \\naround indefinitely is like assuming that a single lo cation in mem\", \"ory will be durable. Container \\nimages, like processes, should be assumed to have multiple instances\", \" and that they will eventually be \\nkilled; if they\\u2019re managed with a container orchestrator, it shou\", \"ld be assumed that they might get \\nmoved from one node or VM to another.  \\nThe following solutions a\", \"re used to manage persistent data in Docker applications:  \\nFrom the Docker host, as Docker Volumes \", \": \\n\\u2022 Volumes  are stored in an area of the host filesystem that\\u2019s managed by Docker.  \\n\\u2022 Bind mounts\", \"  can map to any folder in the host filesystem, so access can\\u2019t be controlled from \\na Docker process\", \" and can pose a security risk as a container could access sensitive OS folders.  \\n \\n23 CHAPTER 4 | D\", \"esigning and developing containerized apps using Docker and Microsoft Azure  \\n \\u2022 tmpfs mounts  are l\", \"ike virtual folders that only exist in the host\\u2019s memory and are never \\nwritten to the filesystem.  \", \"\\nFrom remote storage:  \\n\\u2022 Azure Storage  provides geo -distributable storage, providing a good long \", \"-term persistence \\nsolution for containers.  \\n\\u2022 Remote relational databases like Azure SQL Database \", \", NoSQL databases like Azure Cosmos \\nDB, or cache services like Redis . \\nFrom the Docker container: \", \" \\n\\u2022 Docker provides a feature named the overlay file system . This feature implements a copy -on-\\nwr\", \"ite task that stores updated information to the root file system of the container. That \\ninformation\", \" \\u201clays on top of\\u201d the original image on which the container is based. If the \\ncontainer is deleted f\", \"rom the system, thos e changes are lost. Therefore, while it\\u2019s possible to \\nsave the state of a cont\", \"ainer within its local storage, designing a system based on this feature \\nwould conflict with the pr\", \"emise of container desig n, which by default is stateless.  \\n\\u2022 However, Docker Volumes is now the pr\", \"eferred way to handle local data in Docker. If you \\nneed more information about storage in container\", \"s, check on Docker storage drivers  and \\nAbout images, containers, and storage drivers . \\nThe follow\", \"ing provides additional detail about these options.  \\nVolumes  are directories mapped from the host \", \"OS to directories in containers. When code in the \\ncontainer has access to the directory, that acces\", \"s is actually to a directory on the host OS. This \\ndirectory is not tied to the lifetime of the cont\", \"ainer itself, and th e directory is managed by Docker and \\nisolated from the core functionality of t\", \"he host machine. Thus, data volumes are designed to persist \\ndata independently of the life of the c\", \"ontainer. If you delete a container or an image from the Docker \\nhost, th e data persisted in the da\", \"ta volume is not deleted.  \\nVolumes can be named or anonymous (the default). Named volumes are the e\", \"volution of Data \\nVolume Containers  and make it easy to share data between containers. Volumes also\", \" support \\nvolume drivers that allow you to store data on remote hosts, among other options.  \\nBind m\", \"ounts  have been available for a long time and allow the mapping of any folder to a mount \\npoint in \", \"a container. Bind mounts have more limitations than volumes and some important security \\nissues, so \", \"volumes are the recommended option.  \\ntmpfs mounts  are virtual folders that live only in the host\\u2019s\", \" memory and are never written to the \\nfilesystem. They are fast and secure but use memory and are on\", \"ly meant for non -persistent data.  \\nAs shown in Figure 4 -5, regular Docker volumes can be stored o\", \"utside of the containers themselves \\nbut within the physical boundaries of the host server or VM. Ho\", \"wever, Docker containers cannot \\naccess a volume from one host server or VM to another. In other  wo\", \"rds, with these volumes, it isn\\u2019t \\npossible to manage data shared between containers that run on dif\", \"ferent Docker hosts, although it \\ncould be achieved with a volume driver that supports remote hosts.\", \"   \\n24 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n  \", \"\\nFigure 4 -5. Volumes and external data sources for container -based applications  \\nIn addition, whe\", \"n Docker containers are managed by an orchestrator, containers might \\u201cmove\\u201d \\nbetween hosts, dependin\", \"g on the optimizations performed by the cluster. Therefore, it isn\\u2019t \\nrecommended that you use data \", \"volumes for business data. But they are a good mechanism to work \\nwith trace files, temporal file s,\", \" or similar, that will not impact business data consistency.  \\nRemote data sources and cache  tools \", \"like Azure SQL Database, Azure Cosmos DB, or a remote cache \\nlike Redis can be used in containerized\", \" applications the same way they are used when developing \\nwithout containers. This is a proven way t\", \"o store business application data.  \\nAzure Storage.  Business data usually needs to be placed in ext\", \"ernal resources or databases, like \\nAzure Storage. Azure Storage provides the following services in \", \"the cloud:  \\n\\u2022 Blob storage stores unstructured object data. A blob can be any type of text or binar\", \"y data, \\nsuch as document or media files (images, audio, and video files). Blob storage is also refe\", \"rred \\nto as Object storage.  \\n\\u2022 File storage offers shared storage for legacy applications using the\", \" standard SMB protocol. \\nAzure virtual machines and cloud services can share file data across applic\", \"ation components \\nvia mounted shares. On -premises applications can access file data in a s hare via\", \" the File \\nService REST API.  \\n\\u2022 Table storage stores structured datasets. Table storage is a NoSQL \", \"key -attribute data store, \\nwhich allows rapid development and fast access to large quantities of da\", \"ta.  \\nRelational databases and NoSQL databases.  There are many choices for external databases, from\", \" \\nrelational databases like SQL Server, PostgreSQL, Oracle, or NoSQL databases like Azure Cosmos DB,\", \" \\nMongoDB, etc. These databases are not going to be explained as part of this guide since they are a\", \" \\ndifferent topic altogether.  \\n \\n25 CHAPTER 4 | Designing and developing containerized apps using D\", \"ocker and Microsoft Azure  \\n Service -oriented applications  \\nService -Oriented Architecture (SOA) w\", \"as an overused term that meant many different things to \\ndifferent people. But as a common denominat\", \"or, SOA means that you structure the architecture of \\nyour application by decomposing it into severa\", \"l services (most comm only as HTTP services) that can \\nbe classified in different types like subsyst\", \"ems or, in other cases, as tiers.  \\nToday, you can deploy those services as Docker containers, which\", \" solve deployment -related issues \\nbecause all of the dependencies are included in the container ima\", \"ge. However, when you need to \\nscale out SOAs, you might encounter challenges if you\\u2019re deployi ng b\", \"ased on single instances. This \\nchallenge can be handled using Docker clustering software or an orch\", \"estrator. You\\u2019ll get to look at \\norchestrators in greater detail in the next section, when you explo\", \"re microservices approaches.  \\nDocker containers are useful (but not required) for both traditional \", \"service -oriented architectures and \\nthe more advanced microservices architectures.  \\nAt the end of \", \"the day, the container clustering solutions are useful for both a traditional SOA \\narchitecture and \", \"for a more advanced microservices architecture in which each microservice owns its \\ndata model. And \", \"thanks to multiple databases, you can also s cale out the data tier instead of working \\nwith monolit\", \"hic databases shared by the SOA services. However, the discussion about splitting the \\ndata is purel\", \"y about architecture and design.  \\nOrchestrating microservices and multi -container \\napplications fo\", \"r high scalability and availability  \\nUsing orchestrators for production -ready applications is esse\", \"ntial if your application is based on \\nmicroservices or split across multiple containers. As introdu\", \"ced previously, in a microservice -based \\napproach, each microservice owns its model and data so t h\", \"at it will be autonomous from a \\ndevelopment and deployment point of view. But even if you have a mo\", \"re traditional application that\\u2019s \\ncomposed of multiple services (like SOA), you\\u2019ll also have multip\", \"le containers or services comprising a \\nsingle business ap plication that need to be deployed as a d\", \"istributed system. These kinds of systems \\nare complex to scale out and manage; therefore, you absol\", \"utely need an orchestrator if you want to \\nhave a production -ready and scalable multi -container ap\", \"plication.  \\nFigure 4 -6 illustrates deployment into a cluster of an application composed of multipl\", \"e microservices \\n(containers).   \\n26 CHAPTER 4 | Designing and developing containerized apps using D\", \"ocker and Microsoft Azure  \\n  \\nFigure 4 -6. A cluster of containers  \\nIt looks like a logical approa\", \"ch. But how are you handling load balancing, routing, and orchestrating \\nthese composed applications\", \"?  \\nThe Docker CLI meets the needs of managing one container on one host, but it falls short when it\", \" \\ncomes to managing multiple containers deployed on multiple hosts for more complex distributed \\napp\", \"lications. In most cases, you need a management platform that will automatically start containers, \\n\", \"scale out containers with multiple instances per image, suspend them, or shut them down when \\nneeded\", \", and ideally also control how they access resources like the network and data storage.  \\nTo go beyo\", \"nd the management of individual containers or simple composed apps and move toward \\nlarger enterpris\", \"e applications with microservices, you must turn to orchestration and clustering \\nplatforms.  \\nFrom \", \"an architecture and development point of view, if you\\u2019re building large, enterprise, \\nmicroservices \", \"-based, applications, it\\u2019s important to understand the following platforms and products \\nthat suppor\", \"t advanced scenarios:  \\n\\u2022 Clusters and orchestrators.  When you need to scale out applications acros\", \"s many Docker \\nhosts, such as with a large microservices -based application, it\\u2019s critical to be abl\", \"e to manage \\nall of  those hosts as a single cluster by abstracting the complexity of the underlying\", \" platform. \\nThat\\u2019s what the container clusters and orchestrators provide. Examples of orchestrators \", \"are \\nAzure Service Fabric and Kubernetes. Kubernetes is available in Azure through Azure \\nKubernetes\", \" Service.  \\n \\n27 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft \", \"Azure  \\n \\u2022 Schedulers.  Scheduling  means to have the capability for an administrator to launch cont\", \"ainers \\nin a cluster, so schedulers also provide a user interface for doing so. A cluster scheduler \", \"has \\nseveral responsibilities: to use the cluster\\u2019s resources efficiently, to set the constra ints \\n\", \"provided by the user, to efficiently load -balance containers across nodes or hosts, and to be \\nrobu\", \"st against errors while providing high availability.  \\nThe concepts of a cluster and a scheduler are\", \" closely related, so the products provided by different \\nvendors often provide both sets of capabili\", \"ties. The section below shows the most important platform \\nand software choices you have for cluster\", \"s and schedul ers. These orchestrators are widely offered in \\npublic clouds like Azure.  \\nSoftware p\", \"latforms for container clustering, orchestration, and \\nscheduling  \\nPlatform  Comments  \\nKubernetes \", \" \\n Kubernetes  is an open -source product that \\nprovides functionality that ranges from \\ncluster inf\", \"rastructure and container \\nscheduling to orchestrating capabilities. It \\nlets you automate deploymen\", \"t, scaling, \\nand operations of application containers \\nacross clusters of hos ts. \\n \\nKubernetes  pro\", \"vides a container -centric \\ninfrastructure that groups application \\ncontainers into logical units fo\", \"r easy \\nmanagement and discovery.  \\n \\nKubernetes  is mature in Linux, less mature \\nin Windows.  \\nAzu\", \"re Kubernetes Service (AKS)  \\n Azure Kubernetes Service (AKS)  is a \\nmanaged Kubernetes container \\no\", \"rchestration service in Azure that \\nsimplifies Kubernetes cluster\\u2019s \\nmanagement, deployment, and \\nop\", \"erations.  \\n \\n28 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft \", \"Azure  \\n Platform  Comments  \\nAzure Service Fabric  \\n Service Fabric  is a Microsoft microservices \\n\", \"platform for building applications. It\\u2019s an \\norchestrator  of services and creates \\nclusters of mach\", \"ines. Service Fabric can \\ndeploy services as containers or as plain \\nprocesses. It can even mix serv\", \"ices in \\nprocesses with services in containers \\nwithin the same application and cluster.  \\n \\nService\", \" Fabric  clusters can be deployed in \\nAzure, on -premises or in any cloud. \\nHowever, deployment in A\", \"zure is \\nsimplified with a managed approach.  \\n \\nService Fabric  provides additional and \\noptional p\", \"rescriptive Service Fabric \\nprogramming models  like stateful services  \\nand Reliable Actors . \\n \\nSe\", \"rvice Fabric  is mature in Windows (years \\nevolving in Windows), less mature in Linux.  \\n \\nBoth Linu\", \"x and Windows containers are \\nsupported in Service Fabric since 2017.  \\nAzure Service Fabric Mesh   \", \" | Azure Service Fabric Mesh  offers the same reliability, mission -\\ncritical performance and scale \", \"as Service Fabric, but also offers a fully managed and serverless \\nplatform. You don\\u2019t need to manag\", \"e a cluster, VMs, storage or networking configuration. You just \\nfocus on your applicatio n\\u2019s develo\", \"pment.   Service Fabric Mesh  supports both Windows and Linux \\ncontainers, allowing you to develop w\", \"ith any programming language and framework of your choice.  \\nAzure Container Apps    | Azure Contain\", \"er Apps  is a \\nmanaged serverless container service for building and deploying modern apps at scale.\", \" |  \\nUsing container -based orchestrators in Azure  \\nSeveral cloud vendors offer Docker containers s\", \"upport plus Docker clusters and orchestration support, \\nincluding Azure, Amazon EC2 Container Servic\", \"e, and Google Container Engine. Azure provides Docker \\n \\n29 CHAPTER 4 | Designing and developing con\", \"tainerized apps using Docker and Microsoft Azure  \\n cluster and orchestrator support through Azure K\", \"ubernetes Service (AKS), Azure Service Fabric, and \\nAzure Service Fabric Mesh.  \\nUsing Azure Kuberne\", \"tes Service  \\nA Kubernetes cluster pools several Docker hosts and exposes them as a single virtual D\", \"ocker host, so \\nyou can deploy multiple containers into the cluster and scale -out with any number o\", \"f container \\ninstances. The cluster will handle all the complex managemen t plumbing, like scalabili\", \"ty, health, and \\nso forth.  \\nAKS provides a way to simplify the creation, configuration, and managem\", \"ent of a cluster of virtual \\nmachines in Azure that are preconfigured to run containerized applicati\", \"ons. Using an optimized \\nconfiguration of popular open -source scheduling and orchestrat ion tools, \", \"AKS enables you to use \\nyour existing skills or draw on a large and growing body of community expert\", \"ise to deploy and \\nmanage container -based applications on Microsoft Azure.  \\nAzure Kubernetes Servi\", \"ce optimizes the configuration of popular Docker clustering open -source tools \\nand technologies spe\", \"cifically for Azure. You get an open solution that offers portability for both your \\ncontainers and \", \"your application configuration. You s elect the size, the number of hosts, and the \\norchestrator too\", \"ls, and AKS handles everything else.   \\n30 CHAPTER 4 | Designing and developing containerized apps u\", \"sing Docker and Microsoft Azure  \\n  \\nFigure 4 -7. Kubernetes cluster\\u2019s simplified structure and topo\", \"logy  \\nFigure 4 -7 shows the structure of a Kubernetes cluster where a master node (VM) controls mos\", \"t of the \\ncoordination of the cluster, and you can deploy containers to the rest of the nodes that a\", \"re managed \\nas a single pool from an application point of view. Th is allows you to scale to thousan\", \"ds or even tens \\nof thousands of containers.  \\nDevelopment environment for Kubernetes  \\nIn the devel\", \"opment environment that Docker announced in July 2018, Kubernetes can also run in a \\nsingle developm\", \"ent machine (Windows 10 or macOS) by just installing Docker Desktop . You can later \\ndeploy to the c\", \"loud (AKS) for further integration tests, as shown in figure 4 -8. \\n \\n31 CHAPTER 4 | Designing and d\", \"eveloping containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -8. Running Kubernetes i\", \"n dev machine and the cloud  \\nGet started with Azure Kubernetes Service (AKS)  \\nTo begin using AKS, \", \"you deploy an AKS cluster from the Azure portal or by using the CLI. For more \\ninformation on deploy\", \"ing a Kubernetes cluster to Azure, see Deploy an Azure Kubernetes Service \\n(AKS) cluster . \\nThere ar\", \"e no fees for any of the software installed by default as part of AKS. All default options are \\nimpl\", \"emented with open -source software. AKS is available for multiple virtual machines in Azure. \\nYou\\u2019re\", \" charged only for the compute instances you choose,  as well as the other underlying \\ninfrastructure\", \" resources consumed, such as storage and networking. There are no incremental charges \\nfor AKS itsel\", \"f.  \\nFor further implementation information on deployment to Kubernetes based on kubectl and origina\", \"l \\n.yaml files, see Deploy to Azure Kubernetes Service (AKS) . \\nDeploy with Helm charts into Kuberne\", \"tes clusters  \\nWhen deploying an application to a Kubernetes cluster, you can use the original kubec\", \"tl.exe CLI tool \\nusing deployment files based on the native format (.yaml files), as already mention\", \"ed in the previous \\nsection. However, for more complex Kubernetes applica tions such as when deployi\", \"ng complex \\nmicroservice -based applications, it\\u2019s recommended to use Helm . \\nHelm Charts helps you \", \"define, version, install, share, upgrade, or rollback even the most complex \\nKubernetes application.\", \" Helm is maintained by the Cloud Native Computing Foundation (CNCF)  in \\ncollaboration with Microsof\", \"t, Google, Bitnami, and the Helm contributor community.  \\nFor further implementation information on \", \"Helm charts and Kubernetes, see the section called Install \\neShopOnContainers using Helm . \\n \\n32 CHA\", \"PTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n Additional \", \"resources  \\n\\u2022 Getting started with Azure Kubernetes Service (AKS)  \\nhttps://learn.microsoft.com/azur\", \"e/aks/kubernetes -walkthrough -portal  \\n\\u2022 Kubernetes.  The official site.  \\nhttps://kubernetes.io/  \", \"\\nUsing Azure Service Fabric  \\nAzure Service Fabric arose from Microsoft\\u2019s transition from delivering\", \" \\u201cbox\\u201d products, which were \\ntypically monolithic in style, to delivering services. The experience o\", \"f building and operating large \\nservices at scale, such as Azure SQL Database, Azure Cos mos DB, Azu\", \"re Service Bus, or Cortana\\u2019s \\nBackend, shaped Service Fabric. The platform evolved over time as more\", \" and more services adopted \\nit. Importantly, Service Fabric had to run not only in Azure but also in\", \" standalone Windows Server \\ndeployments.  \\nThe aim of Service Fabric is to solve the hard problems o\", \"f building and running a service and utilizing \\ninfrastructure resources efficiently, so that teams \", \"can solve business problems using a microservices \\napproach.  \\nService Fabric provides two broad are\", \"as to help you build applications that use a microservices \\napproach:  \\n\\u2022 A platform that provides s\", \"ystem services to deploy, scale, upgrade, detect, and restart failed \\nservices, discover service loc\", \"ation, manage state, and monitor health. These system services in \\neffect enable many of the charact\", \"eristics of microservices descri bed previously.  \\n\\u2022 Programming APIs, or frameworks, to help you bu\", \"ild applications as microservices: reliable \\nactors and reliable services . You can choose any code \", \"to build your microservice, but these \\nAPIs make the job more straightforward, and they integrate wi\", \"th the platform at a deeper \\nlevel. This way you can get health and diagnostics information, or you \", \"can take advantage of \\nreliable s tate management.  \\nService Fabric is agnostic with respect to how \", \"you build your service, and you can use any technology. \\nHowever, it provides built -in programming \", \"APIs that make it easier to build microservices.  \\nAs shown in Figure 4 -10, you can create and run \", \"microservices in Service Fabric either as simple \\nprocesses or as Docker containers. It\\u2019s also possi\", \"ble to mix container -based microservices with \\nprocess -based microservices within the same Service\", \" Fabric clus ter.  \\n33 CHAPTER 4 | Designing and developing containerized apps using Docker and Micr\", \"osoft Azure  \\n  \\nFigure 4 -10. Deploying microservices as processes or as containers in Azure Servic\", \"e Fabric  \\nIn the first image, you see microservices as processes, where each node runs one process \", \"for each \\nmicroservice. In the second image, you see microservices as containers, where each node ru\", \"ns Docker \\nwith several containers, one container per microservice. S ervice Fabric clusters based o\", \"n Linux and \\nWindows hosts can run Docker Linux containers and Windows Containers, respectively.  \\nF\", \"or up -to-date information about containers support in Azure Service Fabric, see Service Fabric and \", \"\\ncontainers . \\nService Fabric is a good example of a platform where you can define a different logic\", \"al architecture \\n(business microservices or Bounded Contexts) than the physical implementation. For \", \"example, if you \\nimplement Stateful Reliable Services  in Azure Service Fabric , which are introduce\", \"d in the next section, \\n\\u201cStateless versus stateful microservices ,\\u201d you have a business microservice\", \" concept with multiple \\nphysical services.  \\nAs shown in Figure 4 -10, and thinking from a logical/b\", \"usiness microservice perspective, when \\nimplementing a Service Fabric Stateful Reliable Service, you\", \" usually will need to implement two tiers \\nof services. The first is the back -end stateful reliable\", \" serv ice, which handles multiple partitions (each \\npartition is a stateful service). The second is \", \"the front -end service, or Gateway service, in charge of \\nrouting and data aggregation across multip\", \"le partitions or stateful service instances. That Gateway \\nservice  also handles client -side commun\", \"ication with retry loops accessing the back -end service. It\\u2019s \\ncalled a Gateway service if you impl\", \"ement your custom service, or alternatively you can also use the \\nout-of-the-box Service Fabric reve\", \"rse proxy . \\n \\n34 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft\", \" Azure  \\n  \\nFigure 4 -11. Business microservice with several stateful service instances and a custom\", \" gateway front end  \\nIn any case, when you use Service Fabric Stateful Reliable Services, you also h\", \"ave a logical or business \\nmicroservice (Bounded Context) that\\u2019s composed of multiple physical servi\", \"ces. Each of them, the \\nGateway service, and Partition service could be impleme nted as ASP.NET Web \", \"API services, as shown \\nin Figure 4 -11. Service Fabric has prescription to support several stateful\", \" reliable services in containers.  \\nIn Service Fabric, you can group and deploy groups of services a\", \"s a Service Fabric Application , which is \\nthe unit of packaging and deployment for the orchestrator\", \" or cluster. Therefore, the Service Fabric \\nApplication could be mapped to this autonomous business \", \"and logical microservice boundary or \\nBounded Context, as well, so you could deploy these services a\", \"utonomously.  \\nService Fabric and containers  \\nWith regard to containers in Service Fabric, you can \", \"also deploy services in container images within a \\nService Fabric cluster. As Figure 4 -12 shows, mo\", \"st of the time there will only be one container per \\nservice.  \\n \\nFigure 4 -12. Business microservic\", \"e with several services (containers) in Service Fabric  \\n \\n35 CHAPTER 4 | Designing and developing c\", \"ontainerized apps using Docker and Microsoft Azure  \\n A Service Fabric application can run several c\", \"ontainers accessing an external database and the whole \\nset would be the logical boundary of a Busin\", \"ess Microservice. However, so -called \\u201csidecar\\u201d containers \\n(two containers that must be deployed to\", \"gether as part of a logical service) are also possible in \\nService Fab ric. The important thing is t\", \"hat a business microservice is the logical boundary around \\nseveral cohesive elements. In many cases\", \", it might be a single service with a single data model, but in \\nsome other cases you might have sev\", \"eral physical services as wel l. \\nNote that you can mix services in processes, and services in conta\", \"iners, in the same Service Fabric \\napplication, as shown in Figure 4 -13. \\n \\nFigure 4 -13. Business \", \"microservice mapped to a Service Fabric application with containers and stateful services  \\nFor more\", \" information about container support in Azure Service Fabric, see Service Fabric and \\ncontainers . \\n\", \"Stateless versus stateful microservices  \\nAs mentioned earlier, each microservice (logical Bounded C\", \"ontext) must own its domain model (data \\nand logic). In the case of stateless microservices, the dat\", \"abases will be external, employing relational \\noptions like SQL Server, or NoSQL options like Azure \", \"Cosmos DB or MongoDB.  \\nBut the services themselves can also be stateful in Service Fabric, which me\", \"ans that the data resides \\nwithin the microservice. This data might exist not just on the same serve\", \"r, but within the microservice \\nprocess, in memory and persisted on hard drives an d replicated to o\", \"ther nodes. Figure 4 -14 shows the \\ndifferent approaches.  \\n \\n36 CHAPTER 4 | Designing and developin\", \"g containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -14. Stateless versus stateful m\", \"icroservices  \\nIn stateless services, the state (persistence, database) is kept out of the microserv\", \"ice. In stateful \\nservices, state is kept inside the microservice. A stateless approach is perfectly\", \" valid and is easier to \\nimplement than stateful microservices, since the  approach is similar to tr\", \"aditional and well -known \\npatterns. But stateless microservices impose latency between the process \", \"and data sources. They also \\ninvolve more moving pieces when you\\u2019re trying to improve performance wi\", \"th additional cache and \\nqueues. T he result is that you can end up with complex architectures that \", \"have too many tiers.  \\nIn contrast, stateful microservices  can excel in advanced scenarios, because\", \" there\\u2019s no latency between \\nthe domain logic and data. Heavy data processing, gaming back ends, dat\", \"abases as a service, and \\nother low -latency scenarios all benefit from stateful services, which ena\", \"ble local state fo r faster access.  \\nStateless and stateful services are complementary. For instanc\", \"e, as you can see in the right diagram in \\nFigure 4 -14, a stateful service can be split into multip\", \"le partitions. To access those partitions, you \\nmight need a stateless service acting as a gatewa y \", \"service that knows how to address each partition \\nbased on partition keys.  \\nStateful services do ha\", \"ve drawbacks. They impose a high complexity level to be scaled out. \\nFunctionality that would usuall\", \"y be implemented by external database systems must be addressed for \\ntasks such as data replication \", \"across stateful microservices and d ata partitioning. However, this is one \\nof the areas where an or\", \"chestrator like Azure Service Fabric  with its stateful reliable services  can help \\nthe most \\u2014by si\", \"mplifying the development and lifecycle of stateful microservices using the Reliable \\nServices API  \", \"and Reliable Actors . \\nOther microservice frameworks that allow stateful services, support the Actor\", \" pattern, and improve \\nfault tolerance and latency between business logic and data are Microsoft Orl\", \"eans , from Microsoft \\nResearch, and Akka.NET . Both frameworks are currently improving their suppor\", \"t for Docker.  \\nRemember that Docker containers are themselves stateless. If you want to implement a\", \" stateful \\nservice, you need one of the additional prescriptive and higher -level frameworks noted e\", \"arlier.  \\nUsing Azure Service Fabric Mesh  \\nAzure Service Fabric Mesh is a fully managed service tha\", \"t enables developers to build and deploy \\nmission critical applications without managing any infrast\", \"ructure. Use Service Fabric Mesh to build \\nand run secure, distributed microservices applications th\", \"at  scale on demand.  \\n \\n37 CHAPTER 4 | Designing and developing containerized apps using Docker and\", \" Microsoft Azure  \\n As shown in figure 4 -15, applications hosted on Service Fabric Mesh run and sca\", \"le without you \\nworrying about the infrastructure powering it.  \\n \\nFigure 4 -15. Deploying a microse\", \"rvice/containers application to Service Fabric Mesh  \\nUnder the covers, Service Fabric Mesh consists\", \" of clusters of thousands of machines. All cluster \\noperations are hidden from the developer. You si\", \"mply need to upload your containers and specify \\nresources you need, availability requirements, and \", \"resource lim its. Service Fabric Mesh automatically \\nallocates the infrastructure requested by your \", \"application deployment and also handles infrastructure \\nfailures, making sure your applications are \", \"highly available. You only need to care about the health \\nand responsive ness of your application, n\", \"ot the infrastructure.  \\nFor further information, see the Service Fabric Mesh documentation . \\nChoos\", \"ing orchestrators in Azure  \\nThe following table provides guidance on what orchestrator to use depen\", \"ding on workloads and OS \\nfocus.  \\n \\nFigure 4 -16. Orchestrator selection in Azure guidance  \\n \\n38 C\", \"HAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n Deploy to\", \" Azure Kubernetes Service (AKS)  \\nYou can interact with AKS using your preferred client operating sy\", \"stem (Windows, macOS, or Linux) \\nwith Azure command -line interface (Azure CLI) installed. For more \", \"details, refer Azure CLI \\ndocumentation  and Installation guide  for the available environments.  \\nC\", \"reate the AKS environment in Azure  \\nThere are several ways to create the AKS Environment. It can be\", \" done by using Azure CLI commands \\nor by using the Azure portal.  \\nHere you can explore some example\", \"s using the Azure CLI to create the cluster and the Azure portal to \\nreview the results. You also ne\", \"ed to have Kubectl and Docker in your development machine.  \\nCreate the AKS cluster  \\nCreate the AKS\", \" cluster using this command (the resource group must exist):  \\naz aks create --resource -group explo\", \"re -docker-aks-rg --name explore -docker-aks --node-\\nvm-size Standard_B2s --node-count 1 --generate \", \"-ssh-keys --location westeurope  \\n \\n \\nNote  \\nThe --node -vm-size and --node -count parameter values \", \"are good enough for a sample/dev \\napplication.  \\nAfter the creation job finishes, you can see:  \\n\\u2022 T\", \"he AKS cluster created in the initial resource group  \\n\\u2022 A new, related resource group, containing t\", \"he resources related to the AKS cluster, as show in \\nthe following images.  \\nThe initial resource gr\", \"oup, with the AKS cluster:   \\n39 CHAPTER 4 | Designing and developing containerized apps using Docke\", \"r and Microsoft Azure  \\n  \\nFigure 4 -17. AKS Resource Group view from Azure.  \\nThe AKS cluster resou\", \"rce group:  \\n \\nFigure 4 -18. AKS view from Azure.  \\nImportant  \\nIn general, you shouldn\\u2019t need to mo\", \"dify the resources in the AKS cluster resource group. For \\nexample, the resource group is deleted wh\", \"en you delete the AKS cluster.  \\nYou can also view the node created using Azure CLI and Kubectl.  \\nF\", \"irst, getting the credentials:  \\naz aks get-credentials --resource -group explore -docker-aks-rg --n\", \"ame explore -docker-\\naks \\n \\n40 CHAPTER 4 | Designing and developing containerized apps using Docker \", \"and Microsoft Azure  \\n  \\nFigure 4 -19. aks get -credentials command result.  \\nAnd then, getting node\", \"s from Kubectl:  \\nkubectl get nodes  \\n \\nFigure 4 -20. kubectl get nodes command result.  \\nDevelopmen\", \"t environment for Docker apps  \\nDevelopment tools choices: IDE or editor  \\nNo matter if you prefer a\", \" full and powerful IDE or a lightweight and agile editor, Microsoft has you \\ncovered when it comes t\", \"o developing Docker applications.  \\nVisual Studio Code and Docker CLI (cross -platform tools for Mac\", \", Linux, and \\nWindows)  \\nIf you prefer a lightweight, cross -platform editor supporting any developm\", \"ent language, you can use \\nVisual Studio Code and Docker CLI. These products provide a simple yet ro\", \"bust experience, which is \\ncritical for streamlining the developer workflow. By inst alling \\u201cDocker \", \"for Mac\\u201d or \\u201cDocker for \\nWindows\\u201d (development environment), Docker developers can use a single Dock\", \"er CLI to build apps \\nfor both Windows or Linux (runtime environment). Plus, Visual Studio Code supp\", \"orts extensions for \\nDocker with IntelliSens e for Dockerfiles and shortcut -tasks to run Docker com\", \"mands from the editor.  \\nNote  \\nTo download Visual Studio Code, go to https://code.visualstudio.com/\", \"download . \\nTo download Docker for Mac and Windows, go to https://www.docker.com/products/docker . \\n\", \"Visual Studio with Docker Tools (Windows development machine)  \\nIt\\u2019s recommended that you use Visual\", \" Studio 2022 or later with the built -in Docker Tools enabled. \\nWith Visual Studio, you can develop,\", \" run, and validate your applications directly in the chosen Docker \\nenvironment. Press F5 to debug y\", \"our application (single  container or multiple containers) directly in a \\nDocker host, or press Ctrl\", \"+F5 to edit and refresh your app without having to rebuild the container. It\\u2019s \\nthe simplest and mos\", \"t powerful choice for Windows developers to create Docker containers for Linux \\nor Windows.  \\n \\n41 C\", \"HAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n Visual St\", \"udio for Mac (Mac development machine)  \\nYou can use Visual Studio for Mac  when developing Docker -\", \"based applications. Visual Studio for Mac \\noffers a richer IDE when compared to Visual Studio Code f\", \"or Mac.  \\nLanguage and framework choices  \\nYou can develop Docker applications using Microsoft tools\", \" with most modern languages. The \\nfollowing is an initial list, but you\\u2019re not limited to it:  \\n\\u2022 .N\", \"ET and ASP.NET Core  \\n\\u2022 Node.js  \\n\\u2022 Go \\n\\u2022 Java \\n\\u2022 Ruby  \\n\\u2022 Python  \\nBasically, you can use any moder\", \"n language supported by Docker in Linux or Windows.  \\nInner -loop development workflow for Docker ap\", \"ps  \\nBefore triggering the outer -loop workflow spanning the entire DevOps cycle, it all begins on e\", \"ach \\ndeveloper\\u2019s machine, coding the app itself, using their preferred languages or platforms, and t\", \"esting it \\nlocally (Figure 4 -21). But in every case, you\\u2019ll have  an important point in common, no \", \"matter what \\nlanguage, framework, or platforms you choose. In this specific workflow, you\\u2019re always \", \"developing and \\ntesting Docker containers in no other environments, but locally.  \\n \\nFigure 4 -21. I\", \"nner -loop development context  \\nThe container or instance of a Docker image will contain these comp\", \"onents:  \\n\\u2022 An operating system selection (for example, a Linux distribution or Windows)  \\n\\u2022 Files a\", \"dded by the developer (for example, app binaries)  \\n\\u2022 Configuration (for example, environment settin\", \"gs and dependencies)  \\n\\u2022 Instructions for what processes to run by Docker  \\nYou can set up the inner\", \" -loop development workflow that utilizes Docker as the process (described in \\nthe next section). Co\", \"nsider that the initial steps to set up the environment are not included, because \\nyou only need to \", \"do it once.  \\n \\n42 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsof\", \"t Azure  \\n Building a single app within a Docker container using Visual Studio \\nCode and Docker CLI \", \" \\nApps are made up from your own services plus additional libraries (dependencies).  \\nFigure 4 -22 s\", \"hows the basic steps that you usually need to carry out when building a Docker app, \\nfollowed by det\", \"ailed descriptions of each step.  \\n \\nFigure 4 -22. High -level workflow for the life cycle for Docke\", \"r containerized applications using Docker CLI  \\nStep 1: Start coding in Visual Studio Code and creat\", \"e your initial app/service \\nbaseline  \\nThe way you develop your application is similar to the way yo\", \"u do it without Docker. The difference is \\nthat while developing, you\\u2019re deploying and testing your \", \"application or services running within Docker \\ncontainers placed in your local environment (like a L\", \"inux VM or Windows).  \\nSetting up your local environment  \\nWith the latest versions of Docker Deskto\", \"p for Mac and Windows, it\\u2019s easier than ever to develop \\nDocker applications, and the setup is strai\", \"ghtforward.  \\nTip \\nFor instructions on setting up Docker Desktop for Windows, go to https://docs.doc\", \"ker.com/docker -\\nfor-windows/ . \\nFor instructions on setting up Docker Desktop for Mac, go to https:\", \"//docs.docker.com/docker -for-\\nmac/ . \\nIn addition, you\\u2019ll need a code editor so that you can actual\", \"ly develop your application while using \\nDocker CLI.  \\n \\n43 CHAPTER 4 | Designing and developing con\", \"tainerized apps using Docker and Microsoft Azure  \\n Microsoft provides Visual Studio Code, which is \", \"a lightweight code editor that\\u2019s supported on \\nWindows, Linux, and macOS, and provides IntelliSense \", \"with support for many languages  (JavaScript, \\n.NET, Go, Java, Ruby, Python, and most modern languag\", \"es), debugging , integration with Git  and \\nextensions support . This editor is a great fit for macO\", \"S and Linux developers. In Windows, you also \\ncan use Visual Studio.  \\nTip \\nFor instructions on inst\", \"alling Visual Studio Code for Windows, Linux, or macOS, go to \\nhttps://code.visualstudio.com/docs/se\", \"tup/setup -overview/ . \\nFor instructions on setting up Docker for Mac, go to https://docs.docker.com\", \"/docker -for-mac/ . \\nYou can work with Docker CLI and write your code using any code editor, but usi\", \"ng Visual Studio \\nCode with the Docker extension makes it easy to author Dockerfile and docker -comp\", \"ose.yml files in \\nyour workspace. You can also run tasks and scripts from the Vi sual Studio Code ID\", \"E to execute Docker \\ncommands using the Docker CLI underneath.  \\nThe Docker extension for VS Code pr\", \"ovides the following features:  \\n\\u2022 Automatic Dockerfile and docker -compose.yml file generation  \\n\\u2022 \", \"Syntax highlighting and hover tips for docker -compose.yml and Dockerfile files  \\n\\u2022 IntelliSense (co\", \"mpletions) for Dockerfile and docker -compose.yml files  \\n\\u2022 Linting (errors and warnings) for Docker\", \"file files  \\n\\u2022 Command Palette (F1) integration for the most common Docker commands  \\n\\u2022 Explorer int\", \"egration for managing Images and Containers  \\n\\u2022 Deploy images from DockerHub and Azure Container Reg\", \"istries to Azure App Service  \\nTo install the Docker extension, press Ctrl+Shift+P, type ext install\", \", and then run the Install Extension \\ncommand to bring up  the Marketplace extension list. Next, typ\", \"e docker  to filter the results, and then \\nselect the Docker Support extension, as depicted in Figur\", \"e 4 -23. \\n \\nFigure 4 -23. Installing the Docker Extension in Visual Studio Code  \\n \\n44 CHAPTER 4 | D\", \"esigning and developing containerized apps using Docker and Microsoft Azure  \\n Step 2: Create a Dock\", \"erFile related to an existing image (plain OS or dev \\nenvironments like .NET, Node.js, and Ruby)  \\nY\", \"ou\\u2019ll need a DockerFile per custom image to be built and per container to be deployed. If your app i\", \"s \\nmade up of single custom service, you\\u2019ll need a single DockerFile. But if your app is composed of\", \" \\nmultiple services (as in a microservices architecture),  you\\u2019ll need one Dockerfile per service.  \", \"\\nThe DockerFile is commonly placed in the root folder of your app or service and contains the requir\", \"ed \\ncommands so that Docker knows how to set up and run that app or service. You can create your \\nDo\", \"ckerFile and add it to your project along with your code (n ode.js, .NET, etc.), or, if you\\u2019re new t\", \"o the \\nenvironment, take a look at the following Tip.  \\nTip \\nYou can use the Docker extension to gui\", \"de you when using the Dockerfile and docker -compose.yml \\nfiles related to your Docker containers. E\", \"ventually, you\\u2019ll probably write these kinds of files without \\nthis tool, but using the Docker exten\", \"sion is a good start ing point that will accelerate your learning \\ncurve.  \\nIn Figure 4 -24, you can\", \" see the steps to add the docker files to a project by using the Docker \\nExtension for VS Code:  \\n1.\", \" Open the command palette, type \\u201c docker \\u201d and select \\u201c Add Docker Files to Workspace \\u201d. \\n2. Select \", \"Application Platform (ASP.NET Core)  \\n3. Select Operating System (Linux)  \\n4. Include optional Docke\", \"r Compose files  \\n5. Enter ports to publish (80, 443)  \\n6. Select the project   \\n45 CHAPTER 4 | Desi\", \"gning and developing containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -24. Docker f\", \"iles added using the Add Docker files to Workspace  command  \\nWhen you add a DockerFile, you specify\", \" what base Docker image you\\u2019ll be using (like using FROM \\nmcr.microsoft.com/dotnet/aspnet). You\\u2019ll u\", \"sually build your custom image on top of a base image \\nthat you get from any official repository at \", \"the Docker Hub registry  (like an image for .NET  or the one \\nfor Node.js ). \\nTip \\nYou\\u2019ll have to re\", \"peat this procedure for every project in your application. However, the extension will \\nask to overw\", \"rite the generated docker -compose file after the first time. You should reply to not \\noverwrite it,\", \" so the extension creates separate docker -compose files, that you can then merge by \\nhand, prior to\", \" running docker -compose.  \\nUse an existing official Docker image  \\nUsing an official repository of \", \"a language stack with a version number ensures that the same language \\nfeatures are available on all\", \" machines (including development, testing, and production).  \\nThe following is a sample DockerFile f\", \"or a .NET container:  \\n \\n46 CHAPTER 4 | Designing and developing containerized apps using Docker and\", \" Microsoft Azure  \\n FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS base \\nWORKDIR /app \\nEXPOSE 80 \\nEXPOS\", \"E 443 \\n \\nFROM mcr.microsoft.com/dotnet/sdk:6.0 AS build \\nWORKDIR /src \\nCOPY [\\\"src/WebApi/WebApi.cspr\", \"oj\\\" , \\\"src/WebApi/\\\" ] \\nRUN dotnet restore \\\"src/WebApi/WebApi.csproj\\\"  \\nCOPY . . \\nWORKDIR \\\"/src/src/W\", \"ebApi\\\"  \\nRUN dotnet build \\\"WebApi.csproj\\\"  -c Release -o /app/build  \\n \\nFROM build AS publish \\nRUN d\", \"otnet publish \\\"WebApi.csproj\\\"  -c Release -o /app/publish  \\n \\nFROM base AS final \\nWORKDIR /app \\nCOPY\", \" --from=publish  /app/publish .  \\nENTRYPOINT  [\\\"dotnet\\\" , \\\"WebApi.dll\\\" ] \\nIn this case, the image is\", \" based on version 6.0 of the official ASP.NET Core Docker image (multi -arch \\nfor Linux and Windows)\", \", as per the line FROM mcr.microsoft.com/dotnet/aspnet:6.0. (For more \\ninformation about this topic,\", \" see the ASP.NET Core Docker Image  page and the .NET Docker Image  \\npage).  \\nIn the DockerFile, you\", \" can also instruct Docker to listen to the TCP port that you\\u2019ll use at run time \\n(such as port 80 or\", \" 443).  \\nYou can specify additional configuration settings in the Dockerfile, depending on the langu\", \"age and \\nframework you\\u2019re using. For instance, the ENTRYPOINT line with [\\\"dotnet\\\", \\\"WebMvcApplicatio\", \"n.dll\\\"] \\ntells Docker to run a .NET application. If you\\u2019re using th e SDK and the .NET CLI (dotnet C\", \"LI) to build \\nand run the .NET application, this setting would be different. The key point here is t\", \"hat the \\nENTRYPOINT line and other settings depend on the language and platform you choose for your \", \"\\napplication.  \\nTip \\nFor more information about building Docker images for .NET applications, see \\nh\", \"ttps://learn.microsoft.com/dotnet/core/docker/build -container . \\nTo learn more about building your \", \"own images, go to \\nhttps://docs.docker.com/engine/tutorials/dockerimages/ . \\nUse multi -arch image r\", \"epositories  \\nA single image name in a repo can contain platform variants, such as a Linux image and\", \" a Windows \\nimage. This feature allows vendors like Microsoft (base image creators) to create a sing\", \"le repo to \\ncover multiple platforms (that is, Linux and Windows). For e xample, the dotnet/aspnet  \", \"repository \\navailable in the Docker Hub registry provides support for Linux and Windows Nano Server \", \"by using \\nthe same image name.  \\nPulling the dotnet/aspnet  image from a Windows host pulls the Wind\", \"ows variant, whereas pulling the \\nsame image name from a Linux host pulls the Linux variant.   \\n47 C\", \"HAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n Create yo\", \"ur base image from scratch  \\nYou can create your own Docker base image from scratch as explained in \", \"this article  from Docker. This \\nscenario is probably not the best for you if you\\u2019re just starting w\", \"ith Docker, but if you want to set the \\nspecific bits of your own base image, you can do it.  \\nStep \", \"3: Create your custom Docker images embedding your service in it  \\nFor each custom service that comp\", \"rises your app, you\\u2019ll need to create a related image. If your app is \\nmade up of a single service o\", \"r web app, you\\u2019ll need just a single image.  \\nNote  \\nWhen taking into account the \\u201couter -loop DevOp\", \"s workflow\\u201d, the images will be created by an \\nautomated build process whenever you push your source\", \" code to a Git repository (Continuous \\nIntegration), so the images will be created in that global en\", \"vironment fr om your source code.  \\nBut before you consider going to that outer -loop route, you nee\", \"d to ensure that the Docker \\napplication is actually working properly so that they don\\u2019t push code t\", \"hat might not work properly to \\nthe source control system (Git, etc.).  \\nTherefore, each developer f\", \"irst needs to do the entire inner -loop process to test locally and continue \\ndeveloping until they \", \"want to push a complete feature or change to the source control system.  \\nTo create an image in your\", \" local environment and using the DockerFile, you can use the docker build \\ncommand, as shown in Figu\", \"re 4 -25, because it already tags the image for you and builds the images \\nfor all services in the a\", \"pplication with a simple command.  \\n \\nFigure 4 -25. Running docker build  \\nOptionally, instead of di\", \"rectly running docker build from the project folder, you first can generate a \\ndeployable folder wit\", \"h the .NET libraries needed by using the run dotnet publish command, and then \\nrun docker build.  \\nT\", \"his example creates a Docker image with the name webapi:latest (:latest is a tag, like a specific \\nv\", \"ersion). You can take this step for each custom image you need to create for your composed Docker \\n \", \"\\n48 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n appl\", \"ication with several containers. However, we\\u2019ll see in the next section that it\\u2019s easier to do this \", \"\\nusing docker -compose.  \\nYou can find the existing images in your local repository (your developmen\", \"t machine) by using the \\ndocker images command, as illustrated in Figure 4 -26. \\n \\nFigure 4 -26. Vie\", \"wing existing images using docker images  \\nStep 4: Define your services in docker -compose.yml when \", \"building a composed \\nDocker app with multiple services  \\nWith the docker -compose.yml file, you can \", \"define a set of related services to be deployed as a \\ncomposed application with the deployment comma\", \"nds explained in the next step section.  \\nCreate that file in your main or root solution folder; it \", \"should have content similar to that shown in this \\ndocker -compose.yml file:  \\nversion : \\\"3.4\\\" \\n \\nse\", \"rvices : \\n  webapi : \\n    image : webapi \\n    build : \\n      context : . \\n      dockerfile : src/Web\", \"Api/Dockerfile  \\n    ports : \\n      - 51080:80  \\n    depends_on : \\n      - redis \\n    environment : \", \"\\n      - ASPNETCORE_ENVIRONMENT=Development  \\n      - ASPNETCORE_URLS=http://+:80  \\n \\n  webapp : \\n  \", \"  image : webapp \\n    build : \\n      context : . \\n      dockerfile : src/WebApp/Dockerfile  \\n    por\", \"ts : \\n      - 50080:80  \\n    environment : \\n      - ASPNETCORE_ENVIRONMENT=Development  \\n      - ASP\", \"NETCORE_URLS=http://+:80  \\n      - WebApiBaseAddress=http://webapi  \\n \\n  redis : \\n    image : redis \", \"\\nIn this particular case, this file defines three services: the web API service (your custom service\", \"), a web \\napplication, and the Redis service (a popular cache service). Each service will be deploye\", \"d as a \\ncontainer, so you need to use a concrete Docker image for each. For this par ticular applica\", \"tion:  \\n \\n49 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azur\", \"e  \\n \\u2022 The web API service is built from the DockerFile in the src/WebApi/Dockerfile directory.  \\n\\u2022 \", \"The host port 51080 is forwarded to the exposed port 80 on the webapi container.  \\n\\u2022 The web API ser\", \"vice depends on the Redis service  \\n\\u2022 The web application accesses the web API service using the int\", \"ernal address: http://webapi.  \\n\\u2022 The Redis service uses the latest public redis image  pulled from \", \"the Docker Hub registry. \\nRedis  is a popular cache system for server -side applications.  \\nStep 5: \", \"Build and run your Docker app  \\nIf your app has only a single container, you just need to run it by \", \"deploying it to your Docker Host \\n(VM or physical server). However, if your app is made up of multip\", \"le services, you need to compose it , \\ntoo. Let\\u2019s see the different options.  \\nOption A: Run a singl\", \"e container or service  \\nYou can run the Docker image by using the docker run command, as shown here\", \":  \\ndocker run -t -d -p 50080:80 webapp:latest  \\nFor this particular deployment, we\\u2019ll be redirectin\", \"g requests sent to port 50080 on the host to the \\ninternal port 80.  \\nOption B: Compose and run a mu\", \"ltiple -container application  \\nIn most enterprise scenarios, a Docker application will be composed \", \"of multiple services. For these \\ncases, you can run the docker -compose up command (Figure 4 -27), w\", \"hich will use the docker -\\ncompose.yml file that you created previously. Running this command  build\", \"s all custom images and \\ndeploys the composed application with all of its related containers.   \\n50 \", \"CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n  \\nFigure\", \" 4 -27. Results of running the \\u201cdocker -compose up\\u201d command  \\nAfter you run docker -compose up, you \", \"deploy your application and its related container(s) into your \\nDocker Host, as illustrated in Figur\", \"e 4 -28, in the VM representation.  \\n \\nFigure 4 -28. VM with Docker containers deployed  \\nStep 6: Te\", \"st your Docker application (locally, in your local CD VM)  \\nThis step will vary depending on what yo\", \"ur app is doing.  \\nIn a simple .NET Web API \\u201cHello World\\u201d deployed as a single container or service,\", \" you\\u2019d just need to \\naccess the service by providing the TCP port specified in the DockerFile.  \\nOn \", \"the Docker host, open a browser and navigate to that site; you should see your app/service \\nrunning,\", \" as demonstrated in Figure 4 -29. \\n \\n51 CHAPTER 4 | Designing and developing containerized apps usin\", \"g Docker and Microsoft Azure  \\n  \\nFigure 4 -29. Testing your Docker application locally by using the\", \" browser  \\nNote that it\\u2019s using port 50080, but internally it\\u2019s being redirected to port 80, because\", \" that\\u2019s how it \\nwas deployed with docker compose, as explained earlier.  \\nYou can test this by using\", \" the browser using CURL from the terminal, as depicted in Figure 4 -30. \\n \\nFigure 4 -30. Testing a D\", \"ocker application locally by using CURL  \\nDebugging a container running on Docker  \\nVisual Studio Co\", \"de supports debugging Docker if you\\u2019re using Node.js and other platforms like .NET \\ncontainers.  \\n \\n\", \"52 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n You a\", \"lso can debug .NET or .NET Framework containers in Docker when using Visual Studio for \\nWindows or M\", \"ac, as described in the next section.  \\nTip \\nTo learn more about debugging Node.js Docker containers\", \", see \\nhttps://learn.microsoft.com/archive/blogs/user_ed/visual -studio -code -new-features -13-big-\", \"\\ndebugging -updates -rich-object -hover -conditional -breakpoints -node -js-mono -more . \\nUse Docker\", \" Tools in Visual Studio on Windows  \\nThe developer workflow when using the Docker Tools included in \", \"Visual Studio 2022 version 17.0 and \\nlater, is similar to using Visual Studio Code and Docker CLI (i\", \"n fact, it\\u2019s based on the same Docker CLI), \\nbut it\\u2019s easier to get started, simplifies the pro cess\", \", and provides greater productivity for the build, \\nrun, and compose tasks. It can also run and debu\", \"g your containers via the usual F5 and Ctrl+F5keys \\nfrom Visual Studio. You can even debug a whole s\", \"olution if its containers are defined in the same \\ndock er-compose.yml file at the solution level.  \", \"\\nConfigure your local environment  \\nWith the latest versions of Docker for Windows, it\\u2019s easier than\", \" ever to develop Docker applications \\nbecause the setup is straightforward, as explained in the foll\", \"owing references.  \\nTip \\nTo learn more about installing Docker for Windows, go to ( https://docs.doc\", \"ker.com/docker -for-\\nwindows/ ). \\nDocker support in Visual Studio  \\nThere are two levels of Docker s\", \"upport you can add to a project. In ASP.NET Core projects, you can \\njust add a Dockerfile file to th\", \"e project by enabling Docker support. The next level is container \\norchestration support, which adds\", \" a Dockerfile to the proje ct (if it doesn\\u2019t already exist) and a docker -\\ncompose.yml file at the s\", \"olution level. Container orchestration support, via Docker Compose, is \\navailable in Visual Studio 2\", \"022 versions 17.0. Container orchestration support is an opt -in feature in \\nVisual Stud io 2022 ver\", \"sions 17.0 or later. Visual Studio 2022 also supports Kubernetes/Helm  \\ndeployment.  \\nThe Add > Dock\", \"er Support  and Add > Container Orchestrator Support  commands are located on \\nthe right -click menu\", \" (or context menu) of the project node for an ASP.NET Core project in Solution \\nExplorer , as shown \", \"in Figure 4 -31:  \\n53 CHAPTER 4 | Designing and developing containerized apps using Docker and Micro\", \"soft Azure  \\n  \\nFigure 4 -31. Adding Docker support to a Visual Studio project  \\nAdd Docker support \", \" \\nBesides the option to add Docker support to an existing application, as shown in the previous sect\", \"ion, \\nyou can also enable Docker support during project creation by selecting Enable Docker Support \", \" in \\nthe New ASP.NET Core Web Application  dialog box that opens after you click OK in the New \\nProj\", \"ect  dialog box, as shown in Figure 4 -32. \\n \\n54 CHAPTER 4 | Designing and developing containerized \", \"apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -32. Enable Docker support during project creati\", \"on in Visual Studio  \\nWhen you add or enable Docker support, Visual Studio adds a Dockerfile  file t\", \"o the project, that \\nincludes references to all required project from the solution.  \\nAdd container \", \"orchestration support  \\nWhen you want to compose a multi -container solution, add container orchestr\", \"ation support to your \\nprojects. This lets you run and debug a group of containers (a whole solution\", \") at the same time if \\nthey\\u2019re defined in the same docker -compose.yml  file. \\nTo add container orch\", \"estration support, right -click on the project node in Solution Explorer , and \\nchoose Add > Contain\", \"er Orchestration Support . Then choose Docker Compose  to manage the \\ncontainers.  \\nAfter you add co\", \"ntainer orchestration support to your project, you see a Dockerfile added to the \\nproject and a dock\", \"er -compose  folder added to the solution in Solution Explorer , as shown in Figure \\n4-33: \\n \\n55 CHA\", \"PTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 \", \"-33. Docker files in Solution Explorer in Visual Studio  \\nIf docker -compose.yml  already exists, Vi\", \"sual Studio just adds the required lines of configuration code \\nto it. \\nConfigure Docker tools  \\nFro\", \"m the main menu, choose Tools > Options , and expand Container Tools > Settings . The \\ncontainer too\", \"ls settings appear.  \\n \\n56 CHAPTER 4 | Designing and developing containerized apps using Docker and \", \"Microsoft Azure  \\n  \\nFigure 4 -34. Docker Tools Options  \\nFor more detailed configurations refer to \", \"Container Tools settings  \\nTip \\nFor further details on the services implementation and use of Visual\", \" Studio Tools for Docker, read the \\nfollowing articles:  \\nUse the Containers tool window to view con\", \"tainer details such as the filesystem, logs, environment, \\nports, and more: https://learn.microsoft.\", \"com/visualstudio/containers/view -and-diagnose -containers  \\nDebug apps in a local Docker container:\", \" https://learn.microsoft.com/visualstudio/containers/edit -and-\\nrefresh  \\nDeploy an ASP.NET containe\", \"r to a container registry using Visual Studio: \\nhttps://learn.microsoft.com/visualstudio/containers/\", \"hosting -web-apps -in-docker  \\nUsing Windows PowerShell commands in a \\nDockerFile to set up Windows \", \"Containers (Docker \\nstandard based)  \\nWith Windows Containers , you can convert your existing Window\", \"s applications to Docker images and \\ndeploy them with the same tools as the rest of the Docker ecosy\", \"stem.  \\n \\n57 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azur\", \"e  \\n To use Windows Containers, you just need to write Windows PowerShell commands in the DockerFile\", \", \\nas demonstrated in the following example:  \\nFROM mcr.microsoft.com/windows/servercore:ltsc2019  \\n\", \"LABEL Description= \\\"IIS\\\" Vendor=\\\"Microsoft\\\"  Version= \\\"10\\\" \\nRUN powershell  Get-WindowsFeature web -\", \"server \\nRUN powershell  Install-windowsfeature web -server \\nRUN powershell  add-windowsfeature web -\", \"asp-net45 \\nCMD [ \\\"ping\\\", \\\"localhost\\\" , \\\"-t\\\" ] \\nIn this case, we\\u2019re using Windows PowerShell to insta\", \"ll a Windows Server Core base image as well \\nas IIS. \\nIn a similar way, you also could use Windows P\", \"owerShell commands to set up additional components \\nlike the traditional ASP.NET 4.x and .NET Framew\", \"ork 4.6 or any other Windows software, as shown \\nhere:  \\nRUN powershell  add-windowsfeature web -asp\", \"-net45 \\nBuild ASP.NET Core applications deployed as Linux \\ncontainers into an AKS/Kubernetes orchest\", \"rator  \\nAzure Kubernetes Services (AKS) is Azure\\u2019s managed Kubernetes orchestrations services that s\", \"implify \\ncontainer deployment and management.  \\nThe main features of AKS are:  \\n\\u2022 An Azure -hosted c\", \"ontrol plane.  \\n\\u2022 Automated upgrades.  \\n\\u2022 Self-healing.  \\n\\u2022 User-configurable scaling.  \\n\\u2022 Simpler u\", \"ser experience for both developers and cluster operators.  \\nThe following examples explore the creat\", \"ion of an ASP.NET Core 6.0 application that runs on Linux \\nand deploys to an AKS Cluster in Azure. D\", \"evelopment is done using Visual Studio 2022 version 17.0.  \\nCreating the ASP.NET Core Project using \", \"Visual Studio 2022  \\nASP.NET Core is a general -purpose development platform maintained by Microsoft\", \" and the .NET \\ncommunity on GitHub. It\\u2019s cross -platform, supporting Windows, macOS and Linux, and c\", \"an be used in \\ndevice, cloud, and embedded/IoT scenarios.  \\nThis example uses a couple of simple pro\", \"jects based on Visual Studio templates, so you don\\u2019t need \\nmuch additional knowledge to create the s\", \"ample. You only have to create the project using a \\nstandard template that includes all the elements\", \" to run a small pr oject with a REST API and a Web \\nApp with Razor pages, using ASP.NET Core 6.0 tec\", \"hnology.  \\nFor reference, you can download the sample from .NET Application Architecture\\u2019s repo expl\", \"ore -\\ndocker .  \\n58 CHAPTER 4 | Designing and developing containerized apps using Docker and Microso\", \"ft Azure  \\n  \\nFigure 4 -35. Creating an ASP.NET Core Web Application in Visual Studio 2022.  \\nTo cre\", \"ate the sample project in Visual Studio, select File > New  > Project , select the Web  project \\ntyp\", \"e and then the ASP.NET Core Web Api  template. You can also search for the template if you need \\nit.\", \" \\nThen enter the application name and location as shown in the next image.  \\n \\n59 CHAPTER 4 | Design\", \"ing and developing containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -36. Enter the \", \"project name and location in Visual Studio 2022.  \\nVerify that you\\u2019ve selected ASP.NET Core 6.0 as t\", \"he framework. .NET 6 is included in the latest release \\nof Visual Studio 2022 and is automatically i\", \"nstalled and configured for you when you install Visual \\nStudio.  \\n \\n60 CHAPTER 4 | Designing and de\", \"veloping containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -37. Selecting ASP.NET CO\", \"RE 6.0 and Web API project type  \\nNotice Docker support is not enabled now. You\\u2019ll do that in the ne\", \"xt step after the project creation. \\nYou\\u2019ll also notice that by default controller option is checked\", \". You can uncheck that if you want to \\nCreate a minimal web API with ASP.NET Core . \\nTo show you can\", \" \\u201cDockerize\\u201d your project at any time, you\\u2019ll add Docker support now. So right -click \\non the projec\", \"t node in Solution Explorer and select Add > Docker support  on the context menu.  \\n \\n61 CHAPTER 4 |\", \" Designing and developing containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -38. Add\", \"ing Docker support to an existing project  \\nTo complete adding Docker support, you can choose Window\", \"s or Linux. In this case, select Linux . \\n \\nFigure 4 -39. Selecting Linux containers.  \\n \\n62 CHAPTER\", \" 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n With these simp\", \"le steps, you have your ASP.NET Core 6.0 application running on a Linux container.  \\nIn a similar wa\", \"y, you can also add a very simple WebApp  project (Figure 4 -40) to consume the web \\nAPI endpoint, a\", \"lthough the details can be seen in the code repo. \\nAfter that, you add orchestrator support for your\", \" WebApi  project as shown next, in image 4 -40. \\n \\nFigure 4 -40. Adding orchestrator support to WebA\", \"pi  project.  \\nWhen you choose the Docker Compose option, which is fine for local development, Visua\", \"l Studio \\nadds the docker -compose project, with the docker -compose files as shown in image 4 -41. \", \"\\n \\n63 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n  \\n\", \"Figure 4 -41. Adding orchestrator support to WebApi  project.  \\nThe initial files added are similar \", \"to these ones:  \\ndocker -compose.yml  \\nversion : \\\"3.4\\\" \\n \\nservices : \\n  webapi : \\n    image : ${DOCK\", \"ER_REGISTRY -}webapi \\n    build : \\n      context : . \\n      dockerfile : WebApi/Dockerfile  \\n \\n  web\", \"app : \\n    image : ${DOCKER_REGISTRY -}webapp \\n    build : \\n      context : . \\n      dockerfile : We\", \"bApp/Dockerfile  \\ndocker -compose.override.yml  \\nversion : \\\"3.4\\\" \\n \\nservices : \\n  webapi : \\n    envi\", \"ronment : \\n      - ASPNETCORE_ENVIRONMENT=Development  \\n      - ASPNETCORE_URLS=https://+:443;http:/\", \"/+:80  \\n    ports : \\n      - \\\"80\\\" \\n      - \\\"443\\\" \\n    volumes : \\n      - ${APPDATA}/Microsoft/UserSe\", \"crets:/root/.microsoft/usersecrets:ro  \\n      - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro  \\n  \", \"webapp : \\n    environment : \\n      - ASPNETCORE_ENVIRONMENT=Development  \\n      - ASPNETCORE_URLS=ht\", \"tps://+:443;http://+:80  \\n    ports : \\n      - \\\"80\\\" \\n      - \\\"443\\\" \\n \\n64 CHAPTER 4 | Designing and d\", \"eveloping containerized apps using Docker and Microsoft Azure  \\n     volumes : \\n      - ${APPDATA}/M\", \"icrosoft/UserSecrets:/root/.microsoft/usersecrets:ro  \\n      - ${APPDATA}/ASP.NET/Https:/root/.aspne\", \"t/https:ro  \\nTo run your app with Docker Compose, you just have to make a few tweaks to docker -\\ncom\", \"pose.override.yml.  \\nservices : \\n  webapi : \\n    #... \\n    ports : \\n      - \\\"51080:80\\\"  \\n      - \\\"51\", \"443:443\\\"  \\n    #... \\n  webapp : \\n    environment : \\n      #... \\n      - WebApiBaseAddress=http://web\", \"api  \\n    ports : \\n      - \\\"50080:80\\\"  \\n      - \\\"50443:443\\\"  \\n    #... \\nNow you can run your applica\", \"tion with the F5 key, or by using the Play button, or the Ctrl+F5 key, \\nselecting the docker -compos\", \"e project, as shown in image 4 -42. \\n \\nFigure 4 -42. Adding orchestrator support to WebApi  project.\", \"  \\nWhen running the docker -compose application as explained, you get:  \\n1. The images built and con\", \"tainers created as per the docker -compose file.  \\n2. The browser open in the address configured in \", \"the \\u201cProperties\\u201d dialog for the docker -\\ncompose project.  \\n3. The Container  window open (in Visual\", \" Studio 2022 version 17.0 and later).  \\n4. Debugger support for all projects in the solution, as sho\", \"wn in the following images.  \\nBrowser opened:  \\n \\n65 CHAPTER 4 | Designing and developing containeri\", \"zed apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -43. Browser window with an application runn\", \"ing on multiple containers.  \\nContainers window:  \\n \\nFigure 4 -44. Visual Studio \\u201cContainers\\u201d window\", \"  \\nThe Containers  window lets you view running containers, browse available images, view environmen\", \"t \\nvariables, logs, and port mappings, inspect the filesystem, attach a debugger, or open a terminal\", \" \\nwindow inside the container environment.  \\nAs you can see, the integration between Visual Studio 2\", \"022 and Docker is completely oriented to the \\ndeveloper\\u2019s productivity.  \\nOf course, you can also li\", \"st the images using the docker images command. You should see the webapi \\nand webapp images with the\", \" dev tags created by the automatic deployment of our project with Visual \\nStudio 2022.  \\ndocker imag\", \"es  \\n \\n66 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \", \"\\n  \\nFigure 4 -45. View of Docker images  \\nRegister the Solution in an Azure Container Registry (ACR)\", \"  \\nYou can upload the images to the Azure Container Registry (ACR) , but you could also use Docker H\", \"ub \\nor any other registry, so the images can be deployed to the AKS cluster from that registry.  \\nCr\", \"eate an ACR instance  \\nRun the following command from the az cli : \\naz acr create --name exploredock\", \"er --resource -group explore -docker-aks-rg --sku basic \\n--admin-enabled \\n \\n \\nNote  \\nThe container r\", \"egistry name (for example, exploredocker) must be unique within Azure and contain 5 -\\n50 alphanumeri\", \"c characters. For more details, see Create a container registry . \\nCreate the image in Release mode \", \" \\nYou\\u2019ll now create the image in Release  mode (ready for production) by changing to Release , as \\ns\", \"hown in Figure 4 -46, and running the application as you did before.  \\n \\nFigure 4 -46. Selecting Rel\", \"ease Mode  \\nIf you execute the docker images command, you\\u2019ll see both images created, one for debug \", \"( dev) and \\nthe other for release ( latest ) mode.  \\nCreate a new Tag for the Image  \\nEach container\", \" image needs to be tagged with the loginServer name of the registry. This tag is used \\nfor routing w\", \"hen pushing container images to an image registry.  \\nYou can view the loginServer name from the Azur\", \"e portal, taking the information from the Azure \\nContainer Registry  \\n \\n67 CHAPTER 4 | Designing and\", \" developing containerized apps using Docker and Microsoft Azure  \\n  \\nFigure 4 -47. View of the name \", \"of the Registry  \\nOr by running the following command:  \\naz acr list --resource -group <resource -gr\", \"oup-name> --query \\n\\\"[].{acrLoginServer:loginServer}\\\" --output table  \\n \\nFigure 4 -48. Get the name o\", \"f the registry using az cli  \\nIn both cases, you\\u2019ll obtain the name. In our example, exploredocker.a\", \"zurecr.io.  \\nNow you can tag the image, taking the latest image (the Release image), with the comman\", \"d:  \\ndocker tag <image -name>:latest <login -server-name>/<image -name>:v1  \\nAfter running the docke\", \"r tag command, list the images with the docker images command, and you \\nshould see the image with th\", \"e new tag.  \\n \\nFigure 4 -49. View of tagged images  \\nPush the image into the Azure ACR  \\nLog in to t\", \"he Azure Container Registry  \\naz acr login --name exploredocker  \\nPush the image into the Azure ACR,\", \" using the following command:  \\ndocker push <login -server-name>/<image -name>:v1  \\n \\n68 CHAPTER 4 |\", \" Designing and developing containerized apps using Docker and Microsoft Azure  \\n This command takes \", \"a while uploading the images but gives you feedback in the process. In the \\nfollowing image, you can\", \" see the output from one image completed and another in progress.  \\n \\nFigure 4 -50. Console output f\", \"rom the push command.  \\nTo deploy your multi -container app into your AKS cluster you need some mani\", \"fest .yaml files that \\nhave, most of the properties taken from the docker -compose.yml and docker -c\", \"ompose.override.yml \\nfiles. \\ndeploy -webapi.yml  \\napiVersion : apps/v1 \\nkind : Deployment  \\nmetadata\", \" : \\n  name : webapi \\n  labels : \\n    app: weather-forecast  \\nspec : \\n  replicas : 1 \\n  selector : \\n \", \"   matchLabels : \\n      service : webapi \\n  template : \\n    metadata : \\n      labels : \\n        app:\", \" weather-forecast  \\n        service : webapi \\n    spec : \\n      containers : \\n        - name : webap\", \"i \\n          image : exploredocker.azurecr.io/webapi:v1  \\n          imagePullPolicy : IfNotPresent  \", \"\\n          ports : \\n            - containerPort : 80 \\n              protocol : TCP \\n          env: \\n\", \"            - name : ASPNETCORE_URLS  \\n              value : http://+:80  \\n \\n69 CHAPTER 4 | Designin\", \"g and developing containerized apps using Docker and Microsoft Azure  \\n --- \\napiVersion : v1 \\nkind :\", \" Service \\nmetadata : \\n  name : webapi \\n  labels : \\n    app: weather-forecast  \\n    service : webapi \", \"\\nspec : \\n  ports : \\n    - port : 80 \\n      targetPort : 80 \\n      protocol : TCP \\n  selector : \\n    \", \"service : webapi \\ndeploy-webapp.yml  \\napiVersion : apps/v1 \\nkind : Deployment  \\nmetadata : \\n  name :\", \" webapp \\n  labels : \\n    app: weather-forecast  \\nspec : \\n  replicas : 1 \\n  selector : \\n    matchLabe\", \"ls : \\n      service : webapp \\n  template : \\n    metadata : \\n      labels : \\n        app: weather-for\", \"ecast  \\n        service : webapp \\n    spec : \\n      containers : \\n        - name : webapp \\n         \", \" image : exploredocker.azurecr.io/webapp:v1  \\n          imagePullPolicy : IfNotPresent  \\n          p\", \"orts : \\n            - containerPort : 80 \\n              protocol : TCP \\n          env: \\n            \", \"- name : ASPNETCORE_URLS  \\n              value : http://+:80  \\n            - name : WebApiBaseAddres\", \"s  \\n              value : http://webapi  \\n--- \\napiVersion : v1 \\nkind : Service \\nmetadata : \\n  name :\", \" webapp \\n  labels : \\n    app: weather-forecast  \\n    service : webapp \\nspec : \\n  type : LoadBalancer\", \"  \\n  ports : \\n    - port : 80 \\n      targetPort : 80 \\n      protocol : TCP \\n  selector : \\n    servic\", \"e : webapp  \\n70 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft A\", \"zure  \\n  \\n \\nNote  \\nThe previous .yml files only enable the HTTP ports, using the ASPNETCORE_URLS par\", \"ameter, to avoid \\nissues with the missing certificate in the sample app.  \\n \\n \\nTip \\nYou can see how \", \"to create the AKS Cluster for this sample in section Deploy to Azure Kubernetes \\nService (AKS)  on t\", \"his guide.  \\nNow you\\u2019re almost ready to deploy using kubectl , but first you must get the credential\", \"s from the AKS \\nCluster with this command:  \\naz aks get -credentials --resource -group explore -dock\", \"er-aks-rg --name explore -docker-aks \\n \\nFigure 4 -51. Getting credentials from AKS into the kubectl \", \"environment.  \\nYou also have to allow the AKS cluster to pull images from the ACR, using this comman\", \"d:  \\naz aks update --name explore -docker-aks --resource -group explore -docker-aks-rg --attach-acr \", \"\\nexploredocker  \\nThe previous command might take a couple of minutes to complete. Then, use the kube\", \"ctl apply \\ncommand to launch the deployments, and then kubectl get all to list the cluster objects. \", \" \\nkubectl apply -f deploy -webapi.yml  \\nkubectl apply -f deploy -webapp.yml  \\n \\nkubectl get all  \\n \\n\", \"71 CHAPTER 4 | Designing and developing containerized apps using Docker and Microsoft Azure  \\n  \\nFig\", \"ure 4 -52. Deployment to Kubernetes  \\nYou\\u2019ll have to wait a while until the load balancer gets the e\", \"xternal IP, checking with kubectl get \\nservices, and then the application should be available at tha\", \"t address, as shown in the next image:  \\n \\n72 CHAPTER 4 | Designing and developing containerized app\", \"s using Docker and Microsoft Azure  \\n  \\nFigure 4 -53. Deployment to Kubernetes  \\nWhen the deployment\", \" completes, you can access the Kubernetes Web UI  with a local proxy, using an \\nssh tunnel.  \\nFirst \", \"you must create a ClusterRoleBinding with the following command:  \\nkubectl create clusterrolebinding\", \" kubernetes -dashboard --clusterrole=cluster -admin --\\nserviceaccount=kube -system:kubernetes -dashb\", \"oard  \\nAnd then this command to start the proxy:  \\naz aks browse --resource -group exploredocker -ak\", \"s-rg --name explore -docker-aks \\nA browser window should open at http://127.0.0.1:8001 with a view s\", \"imilar to this one:  \\n \\n73 CHAPTER 4 | Designing and developing containerized apps using Docker and \", \"Microsoft Azure  \\n  \\nFigure 4 -54. View Kubernetes cluster information  \\nNow you have your ASP.NET C\", \"ore application, running in Linux containers, and deployed to an AKS \\ncluster on Azure.  \\nNote  \\nFor\", \" more information on deployment with Kubernetes see: \\nhttps://kubernetes.io/docs/reference/kubectl/c\", \"heatsheet/  \\n \\n74 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n CHAPTER  5 \", \"\\nDocker application \\nDevOps workflow with \\nMicrosoft tools  \\nMicrosoft Visual Studio, Azure DevOps S\", \"ervices and/or GitHub, Team Foundation Server, and Azure \\nMonitor provide a comprehensive ecosystem \", \"for development and IT operations that give your team the \\ntools to manage projects and rapidly buil\", \"d, test, and deploy  containerized applications.  \\nTeams can choose which tools and platforms they w\", \"ant to use for end to end DevOps. With Visual \\nStudio and Azure DevOps Services in the cloud, along \", \"with Team Foundation Server on -premises, \\ndevelopment teams can productively build, test, and relea\", \"se contain erized applications that target \\neither Windows or Linux. Alternatively, teams can also u\", \"se Visual Studio Code and GitHub. Teams can \\neven use combinations: for example, storing source code\", \" in GitHub and using Azure Boards for work \\nitem tracking and Azure Pi pelines for CI/CD.  \\nMicrosof\", \"t tools can automate the pipeline for specific implementations of containerized \\napplications \\u2014Docke\", \"r, .NET, or any combination with other platforms \\u2014from global builds and \\nContinuous Integration (CI\", \") and tests with Azure DevOps Services, Team Foundat ion Server or GitHub, \\nto Continuous Deployment\", \" (CD) to Docker environments (Development, Staging, Production), and to \\ntransmit analytics informat\", \"ion about the services to the development team through Azure Monitor. \\nEvery code commit can initiat\", \"e a build (C I) and automatically deploy the services to specific \\ncontainerized environments (CD). \", \" \\nDevelopers and testers can easily and quickly provision production -like development and test \\nenv\", \"ironments based on Docker by using templates in Microsoft Azure.  \\nThe complexity of containerized a\", \"pplication development increases steadily depending on the \\nbusiness complexity and scalability need\", \"s. A good example of this complexity are applications based \\non microservices architectures. To succ\", \"eed in such an environmen t, your project must automate the \\nentire life cycle \\u2014not only the build a\", \"nd deployment, but it also must manage versions along with \\nthe collection of telemetry. Azure DevOp\", \"s Services, GitHub and Azure offer the following capabilities:  \\n\\u2022 Azure DevOps Services/Team Founda\", \"tion Server source code management (based on Git or \\nTeam Foundation Version Control), Agile plannin\", \"g (Agile, Scrum, and CMMI are supported), \\nCI, release management, and other tools for Agile teams. \", \"  \\n75 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n \\u2022 Azure DevOps Services\", \" and Team Foundation Server include a powerful and growing \\necosystem of first and third -party exte\", \"nsions with which you easily can construct a CI, build, \\ntest, delivery, and release management pipe\", \"line for microservices.  \\n\\u2022 GitHub or GitHub Enterprise Server offer similar capabilities, with sour\", \"ce control based on Git, \\nProjects and Issues for project tracking, GitHub Actions for automating wo\", \"rkflows including \\nCI/CD, and GitHub Advanced Security for dependency, secret and vuln erability sca\", \"nning.  \\n\\u2022 Run automated tests as part of your build pipeline in Azure DevOps Services or through \\nG\", \"itHub Actions  \\n\\u2022 Azure DevOps Services/GitHub can tighten the DevOps life cycle with delivery to mu\", \"ltiple \\nenvironments, not just for production environments, but also for testing, including A/B \\nexp\", \"erimentation, canary releases , and so on.  \\n\\u2022 Organizations easily can provision Docker containers \", \"from private images stored in Azure \\nContainer Registry along with any dependency on Azure component\", \"s (Data, PaaS, etc.) using \\nAzure Resource Manager templates with tools they\\u2019re already comfortable \", \"with.  \\nSteps in the outer -loop DevOps workflow for a \\nDocker application  \\nFigure 5 -1 presents an\", \" end -to-end depiction of the steps comprising the DevOps outer -loop \\nworkflow. It shows the \\u201couter\", \" loop\\u201d of DevOps. When code is pushed to the repo, a CI pipeline is \\nstarted, then begins the CD pip\", \"eline, where the application gets depl oyed. Metrics collected from \\ndeployed applications are fed b\", \"ack into the development workload, where the \\u201cinner loop\\u201d occurs, so \\ndevelopment teams have actual \", \"data to respond to user and business needs.  \\n \\nFigure 5 -1. DevOps outer -loop workflow for Docker \", \"applications with Microsoft tools  \\nNow, let\\u2019s examine each of these steps in greater detail.  \\n \\n76\", \" CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n Step 1: Inner -loop developm\", \"ent workflow  \\nThis step is explained in detail in Chapter 4, but, to recap, here is where the outer\", \" -loop begins, the \\nmoment at which a developer pushes code to the source control management system \", \"(like Git) \\ninitiating CI pipeline actions.  \\nStep 2: Source -Code Control integration and managemen\", \"t with Azure \\nDevOps Services and Git  \\nAt this step, you need to have a version -control system to \", \"gather a consolidated version of all the \\ncode coming from the different developers in the team.  \\nE\", \"ven though source -code control (SCC) and source -code management might seem second -nature to \\nmost\", \" developers, when creating Docker applications in a DevOps life cycle, it\\u2019s critical to emphasize \\nt\", \"hat you must not submit the Docker images with the applicati on directly to the global Docker \\nRegis\", \"try (like Azure Container Registry or Docker Hub) from the developer\\u2019s machine. On the contrary, \\nth\", \"e Docker images to be released and deployed to production environments must be created solely \\non th\", \"e source code that\\u2019s  being integrated in your global build or CI pipeline based on your source -\\nco\", \"de repository (like Git).  \\nThe local images, generated by developers, should just be used by them w\", \"hen testing within their \\nown machines. That\\u2019s why it\\u2019s critical to have the DevOps pipeline activat\", \"ed from the SCC code.  \\nAzure DevOps Services and Team Foundation Server support Git and Team Founda\", \"tion Version \\nControl. You can choose between them and use it for an end -to-end Microsoft experienc\", \"e. However, \\nyou can also manage your code in external repositories (like GitHub, o n-premises Git r\", \"epositories, or \\nSubversion) and still be able to connect to it and get the code as the starting poi\", \"nt for your DevOps CI \\npipeline. You can also use GitHub Actions for CI/CD pipelines.  \\nStep 3: Buil\", \"d, CI, Integrate, and Test with Azure DevOps \\nServices/GitHub and Docker  \\nCI has emerged as a stand\", \"ard for modern software testing and delivery. The Docker solution \\nmaintains a clear separation of c\", \"oncerns between the development and operations teams. The \\nimmutability of Docker images ensures a r\", \"epeatable deployment between what \\u2019s developed, tested \\nthrough CI, and run in production. Docker En\", \"gine deployed across the developer laptops and test \\ninfrastructure makes the containers portable ac\", \"ross environments.  \\nAt this point, after you have a version -control system with the correct code s\", \"ubmitted, you need a \\nbuild service  to pick up the code and run the global build and tests.  \\nThe i\", \"nternal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisti\", \"ng \\nof your code repository (Git, etc.), your build server (Azure DevOps Services/GitHub), Docker En\", \"gine, \\nand a Docker Registry.  \\nYou can use Azure DevOps Services as the foundation for building you\", \"r applications and setting your \\nCI pipeline, and for publishing the built \\u201cartifacts\\u201d to an \\u201cartifa\", \"cts repository,\\u201d which is explained in the \\nnext step. Alternatively, you can use GitHub t o impleme\", \"nt the same workflow.   \\n77 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n W\", \"hen using Docker for the deployment, the \\u201cfinal artifacts\\u201d to be deployed are Docker images with \\nyo\", \"ur application or services embedded within them. Those images are pushed or published to a \\nDocker R\", \"egistry  (a private repository like the ones you can have in Azure Container Registry, or a \\npublic \", \"one like Docker Hub Registry or GitHub Container Registry, which is commonly used for official \\nbase\", \" images).  \\nHere is the basic concept: The CI pipeline will be kicked -off by a commit to an SCC rep\", \"ository like Git. \\nThe commit will cause Azure DevOps Services/GitHub to run a build job within a Do\", \"cker container \\nand, upon successful completion of that job, push a Doc ker image to the Docker Regi\", \"stry, as \\nillustrated in Figure 5 -2. The first part of the outer loop involves steps 1 to 3, from c\", \"ode, run, debug \\nand validate, then the code repo up to the build and test CI step.  \\n \\nFigure 5 -2.\", \" The steps involved in CI  \\nHere are the basic CI workflow steps with Docker and Azure DevOps Servic\", \"es:  \\n \\n78 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n 1. The developer p\", \"ushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, \\netc.).  \\n2. If you\\u2019re using\", \" Azure DevOps Services or Git, CI is built in, which means that it\\u2019s as simple as \\nselecting a check\", \" box in Azure DevOps Services. If you\\u2019re using an external SCC (like GitHub), \\na webhook will notify\", \" Azure DevOps Services of the update or pus h to Git/GitHub.  \\n3. Azure DevOps Services pulls the SC\", \"C repository, including the Dockerfile describing the \\nimage, as well as the application and test co\", \"de.  \\n4. Azure DevOps Services builds a Docker image and labels it with a build number.  \\n5. Azure D\", \"evOps Services instantiates the Docker container within the provisioned Docker Host, \\nand runs the a\", \"ppropriate tests.  \\n6. If the tests are successful, the image is first relabeled to a meaningful nam\", \"e so that you know \\nit\\u2019s a \\u201cblessed build\\u201d (like \\u201c/1.0.0\\u201d or any other label), and then pushed up to\", \" your Docker \\nRegistry (Docker Hub, Azure Container Registry, DTR, etc.)  \\nHere are the basic CI wor\", \"kflow steps with Docker and GitHub:  \\n1. The developer pushes a commit to a GitHub repo.  \\n2. CI is \", \"built in, so Actions will trigger base on the event filters.  \\n3. GitHub pulls the SCC repository, i\", \"ncluding the Dockerfile  describing the image, as well as the \\napplication and test code.  \\n4. GitHu\", \"b builds a Docker image and labels it with a build number.  \\n5. GitHub instantiates the Docker conta\", \"iner within the provisioned Docker Host, and runs the \\nappropriate tests.  \\n6. If the tests are succ\", \"essful, the image is first relabeled to a meaningful name so that you know \\nit\\u2019s a \\u201cblessed build\\u201d (\", \"like \\u201c/1.0.0\\u201d or any other label), and then pushed up to your Docker \\nRegistry (Docker Hub, Azure Co\", \"ntainer Registry, DTR, etc.)  \\nImplement a CI pipeline with Azure DevOps Services and the Docker ext\", \"ension for \\nAzure DevOps Services  \\nVisual Studio Azure DevOps Services contains Build & Release Tem\", \"plates that you can use in your \\nCI/CD pipeline with which you can build Docker images, push Docker \", \"images to an authenticated \\nDocker registry, run Docker images, or run other operations offere d by \", \"the Docker CLI. It also adds a \\nDocker Compose task that you can use to build, push, and run multi -\", \"container Docker applications, or \\nrun other operations offered by the Docker Compose CLI, as shown \", \"in Figure 5 -3.  \\n79 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n  \\nFigure\", \" 5 -3. The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and assoc\", \"iated tasks.  \\nYou can use these templates and tasks to construct your CI/CD artifacts to Build / Te\", \"st and Deploy in \\nAzure Service Fabric, Azure Kubernetes Service, and similar offerings.  \\nWith thes\", \"e Visual Studio Team Services tasks, a build Linux -Docker Host/VM provisioned in Azure and \\nyour pr\", \"eferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any \\nother Doc\", \"ker registry) you can assemble your Docker CI pipe line in a very consistent way.  \\nRequirements:  \\n\", \"\\u2022 Azure DevOps Services, or for on -premises installations, Team Foundation Server 2015 \\nUpdate 3 or\", \" later.  \\n\\u2022 An Azure DevOps Services agent that has the Docker binaries.  \\n  An easy way to create o\", \"ne of these agents is to use Docker to run a container based on the \\nAzure DevOps Services agent Doc\", \"ker image.  \\nTip \\nTo read more about assembling an Azure DevOps Services Docker CI pipeline and view\", \" the \\nwalkthroughs, visit these sites:  \\n\\u2022 Running a Visual Studio Team Services (Now Azure DevOps S\", \"ervices) agent as a Docker \\ncontainer:  \\nhttps://hub.docker.com/_/microsoft -azure -pipelines -vsts-\", \"agent  \\n \\n80 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n \\u2022 Building .NET \", \"Linux Docker images with Azure DevOps Services:  \\nhttps://learn.microsoft.com/archive/blogs/stevelas\", \"ker/building -net-core-linux -docker -\\nimages -with-visual -studio -team -services  \\n\\u2022 Building a Li\", \"nux -based Visual Studio Team Service build machine with Docker support:  \\nhttps://www.donovanbrown.\", \"com/post/Building -a-Linux -Based -Visual -Studio -Team -Service -\\nBuild -Machine -with-Docker -Supp\", \"ort  \\nImplement a CI pipeline with GitHub Actions  \\nGitHub Actions allow you to create automation sc\", \"ripts that can build Docker images, push Docker \\nimages to an authenticated Docker registry, run Doc\", \"ker images, or run other operations offered by \\nthe Docker CLI.  \\nYou can use public Actions (such a\", \"s Azure Login ) and run (shell) commands to construct your CI/CD \\nartifacts to Build / Test and Depl\", \"oy in Azure Service Fabric, Azure Kubernetes Service, and similar \\nofferings.  \\nWith these Actions, \", \"a build Linux -Docker Host/VM provisioned in Azure and your preferred Docker \\nregistry (Azure Contai\", \"ner Registry, Docker Hub, private Docker DTR, or any other Docker registry) you \\ncan assemble your D\", \"ocker CI pipeline in a very consistent way. \\nIntegrate, test, and validate multi -container Docker a\", \"pplications  \\nTypically, most Docker applications are composed of multiple containers rather than a \", \"single \\ncontainer. A good example is a microservices -oriented application for which you would have \", \"one \\ncontainer per microservice. But, even without strictly following the  microservices approach pa\", \"tterns, \\nit\\u2019s probable that your Docker application would be composed of multiple containers or serv\", \"ices.  \\nTherefore, after building the application containers in the CI pipeline, you also need to de\", \"ploy, \\nintegrate, and test the application as a whole with all of its containers within an integrati\", \"on Docker \\nhost or even into a test cluster to which your containers are distributed.  \\nIf you\\u2019re us\", \"ing a single host, you can use Docker commands such as docker -compose to build and \\ndeploy related \", \"containers to test and validate the Docker environment in a single VM. But, if you\\u2019re \\nworking with \", \"an orchestrator cluster like DC/OS, Kubernetes,  or Docker Swarm, you need to deploy \\nyour container\", \"s through a different mechanism or orchestrator, depending on your selected \\ncluster/scheduler.  \\nTh\", \"e following are several types of tests that you can run against Docker containers:  \\n\\u2022 Unit tests fo\", \"r Docker containers  \\n\\u2022 Testing groups of interrelated applications or microservices  \\n\\u2022 Test in pro\", \"duction and \\u201ccanary\\u201d releases  \\nThe important point is that when running integration and functional \", \"tests, you must run those tests \\nfrom outside of the containers. Tests are not contained or run in t\", \"he containers you\\u2019re deploying, \\nbecause the containers are based on static images that sh ould be e\", \"xactly like the ones you\\u2019ll be \\ndeploying to production.   \\n81 CHAPTER 5 | Docker application DevOps\", \" workflow with Microsoft tools  \\n A practical option when testing more advanced scenarios, like incl\", \"uding several clusters (test cluster, \\nstaging cluster, and production cluster) is to publish the im\", \"ages to a registry, so it can be tested in \\nvarious clusters.  \\nPush the custom application Docker i\", \"mage into your global Docker Registry  \\nAfter the Docker images have been tested and validated, you\\u2019\", \"ll want to tag and publish them to your \\nDocker registry. The Docker registry is a critical piece in\", \" the Docker application life cycle because it\\u2019s \\nthe central place where you store your custom tes t\", \" (also known as \\u201cblessed images\\u201d) to be deployed \\ninto QA and production environments.  \\nSimilar to \", \"how the application code stored in your SCC repository (Git, etc.) is your \\u201csource of truth,\\u201d \\nthe D\", \"ocker registry is your \\u201csource of truth\\u201d for your binary application or bits to be deployed to the \\n\", \"QA or production environments.  \\nTypically, you might want to have your private repositories for you\", \"r custom images either in a private \\nrepository in Azure Container Registry or in an on -premises re\", \"gistry like Docker Trusted Registry, or in \\na public -cloud registry with restricted access ( like D\", \"ocker Hub), although in this last case if your code \\nis not open source, you must trust the vendor\\u2019s\", \" security. Either way, the method you use is similar and \\nis based on the docker push command, as sh\", \"own in Figure 5 -4.  \\n82 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n  \\nFi\", \"gure 5 -4. Publishing custom images to Docker Registry  \\n \\n83 CHAPTER 5 | Docker application DevOps \", \"workflow with Microsoft tools  \\n In step 3, for building integration and testing (CI) you might publ\", \"ish the resulting docker images to a \\nprivate or public registry. There are multiple offerings of Do\", \"cker registries from cloud vendors like \\nAzure Container Registry, Amazon Web Services Cont ainer Re\", \"gistry, Google Container Registry, \\nGitHub Container Registry, Quay Registry, and so on.  \\nUsing the\", \" Docker tasks, you can push a set of service images defined by a docker -compose.yml file, \\nwith mul\", \"tiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in \\nFigure\", \" 5 -5. \\n \\nFigure 5 -5. Using Azure DevOps Services to publishing custom images to a Docker Registry \", \" \\nTip \\nFor more information about Azure Container Registry, see https://aka.ms/azurecontainerregistr\", \"y . \\nStep 4: CD, Deploy  \\nThe immutability of Docker images ensures a repeatable deployment with wha\", \"t\\u2019s developed, tested \\nthrough CI, and run in production. After you have the application Docker imag\", \"es published in your \\nDocker registry (either private or public), you can deploy them to the several\", \" environments that  you \\nmight have (production, QA, staging, etc.) from your CD pipeline by using A\", \"zure DevOps Services \\npipeline tasks, Azure DevOps Services Release Management or GitHub Actions.  \\n\", \" \\n84 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n However, at this point i\", \"t depends on what kind of Docker application you\\u2019re deploying. Deploying a \\nsimple application (from\", \" a composition and deployment point of view) like a monolithic application \\ncomprising a few contain\", \"ers or services and deployed to a few servers or VMs is different from \\ndeploying a more complex app\", \"lication like a microservices -oriented application with hyperscale \\ncapabilities. These two scenari\", \"os are explained in the following sections.  \\nDeploying composed Docker applications to multiple Doc\", \"ker environments  \\nLet\\u2019s look first at the less -complex scenario: deploying to simple Docker hosts \", \"(VMs or servers) in a \\nsingle environment or multiple environments (QA, staging, and production). In\", \" this scenario, internally \\nyour CD pipeline can use docker -compose (from your  Azure DevOps Servic\", \"es deployment tasks) to \\ndeploy the Docker applications with its related set of containers or servic\", \"es, as illustrated in Figure  5-6. \\n \\nFigure 5 -6. Deploying application containers to simple Docker\", \" host environments registry  \\nFigure 5 -7 highlights how you can connect your build CI to QA/test en\", \"vironments via Azure DevOps \\nServices by clicking Docker Compose in the Add Task dialog box. However\", \", when deploying to staging \\nor production environments, you would usually use Release Ma nagement f\", \"eatures handling multiple \\nenvironments (like QA, staging, and production). If you\\u2019re deploying to s\", \"ingle Docker hosts, it  is using \\nthe Azure DevOps Services \\u201cDocker Compose\\u201d task (which is invoking\", \" the docker -compose up \\ncommand under the hood). I f you\\u2019re deploying to Azure Kubernetes Service (\", \"AKS), it uses the Docker \\n \\n85 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \", \"\\n Deployment task, as explained in the section that follows. Similar steps can be built for deployme\", \"nt \\nusing GitHub Actions.  \\n \\nFigure 5 -7. Adding a Docker Compose task in an Azure DevOps Services \", \"pipeline or GitHub workflow  \\nWhen you create a release in Azure DevOps Services, it takes a set of \", \"input artifacts. These artifacts are \\nintended to be immutable for the lifetime of the release, acro\", \"ss all environments. When you introduce \\ncontainers, the input artifacts identify images  in a regis\", \"try to deploy. Depending on how these images \\nare identified, they are not guaranteed to remain the \", \"same throughout the duration of the release, the \\nmost obvious case being when you reference myimage\", \":latest from a docker -compose file.  \\nThe Azure DevOps Services templates give you the ability to g\", \"enerate build artifacts that contain \\nspecific registry image digests that are guaranteed to uniquel\", \"y identify the same image binary. These \\nare what you really want to use as input to a release. Y ou\", \" can invoke docker -compose in a run step \\ninside GitHub Actions to accomplish the same goal.  \\nMana\", \"ging releases to Docker environments by using Azure DevOps Services \\nRelease Management or GitHub Ac\", \"tions  \\nThrough the Azure DevOps Services templates, you can build a new image, publish it to a Dock\", \"er \\nregistry, run it on Linux or Windows hosts, and use commands such as docker -compose to  deploy \", \"\\nmultiple containers as an entire application, all through the Azure  DevOps Services Release \\nManag\", \"ement capabilities intended for multiple environments, as shown in Figure 5 -8. \\n \\n86 CHAPTER 5 | Do\", \"cker application DevOps workflow with Microsoft tools  \\n  \\nFigure 5 -8. Configuring Azure DevOps Ser\", \"vices Docker Compose tasks from Azure DevOps Services Release \\nManagement  \\nHowever, keep in mind th\", \"at the scenario shown in Figure 5 -6 and implemented in Figure 5 -8 is a \\nsimple one (it\\u2019s deploying\", \" to single Docker hosts and VMs, and there will be a single container or \\ninstance per image) and pr\", \"obably should be used only for development or test scenarios. In most \\nenterprise production scenari\", \"os, you would want to have High Availability (HA)  and easy -to-manage \\nscalability by load balancin\", \"g across multiple nodes, servers, and VMs, plus \\u201cintelligent failovers\\u201d so if a \\nserver or node fail\", \"s, its services and containers will be moved to another host server or VM. In that \\ncase, you need m\", \"ore advanc ed technologies such as container clusters, orchestrators, and schedulers. \\nThus, the way\", \" to deploy to those clusters is by handling the advanced scenarios explained in the  next \\nsection. \", \" \\nGitHub Actions can be used in the same manner, including the use of environments  for approvals.  \", \"\\nDeploying Docker applications to Docker clusters  \\nThe nature of distributed applications requires \", \"compute resources that are also distributed. To have \\nproduction -scale capabilities, you need to ha\", \"ve clustering capabilities that provide high scalability and \\nhigh availability based on pooled reso\", \"urces.  \\nYou could deploy containers manually to those clusters from a CLI tool or a web UI, but you\", \" should \\nreserve that kind of manual work to spot deployment testing or management purposes like sca\", \"ling -\\nout or monitoring.  \\nFrom a CD point of view, you can use Azure DevOps Services or GitHub Act\", \"ions to run specially made \\ndeployment tasks from your environments that will deploy your containeri\", \"zed applications to \\ndistributed clusters in Container Service, as illustrated in Figu re 5-9. \\n \\n87\", \" CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n  \\nFigure 5 -9. Deploying dis\", \"tributed applications to Container Service  \\nInitially, when deploying to certain clusters or orches\", \"trators, you would traditionally use specific \\ndeployment scripts and mechanisms per each orchestrat\", \"or (that is, Kubernetes and Service Fabric \\nhave different deployment mechanisms) instead of the sim\", \"ple r and easy -to-use docker -compose tool \\nbased on the docker -compose.yml definition file. Howev\", \"er, thanks to the Azure DevOps Services \\nDocker Deploy task, shown in Figure 5 -10, now you can also\", \" deploy to the supported orchestrators by \\njust using your familiar  docker -compose.yml file becaus\", \"e the tool performs that \\u201ctranslation\\u201d for you \\n(from your docker -compose.yml file to the format ne\", \"eded by the orchestrator).  \\n \\n88 CHAPTER 5 | Docker application DevOps workflow with Microsoft tool\", \"s  \\n  \\nFigure 5 -10. Adding the Deploy to Kubernetes task to your Environment  \\nFigure 5 -11 demonst\", \"rates how you can edit the Deploy to Kubernetes task with the sections available \\nfor configuration.\", \" This is the task that will retrieve your ready -to-use custom Docker images to be \\ndeployed as cont\", \"ainers in the cluster.  \\n \\nFigure 5 -11. Docker Deploy task definition deploying to ACS DC/OS  \\n \\n89\", \" CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n Tip \\nTo read more about the \", \"CD pipeline with Azure DevOps Services and Docker, visit \\nhttps://azure.microsoft.com/services/devop\", \"s/pipelines  \\n \\n \\nTip \\nTo see GitHub Actions workflows for CI, visit https://github.com/dotnet -\\narc\", \"hitecture/eShopOnContainers/wiki/GitHub -Actions . For a walkthrough of GitHub Actions \\nperforming d\", \"eployment to an Azure Kubernetes environment, visit https://github.com/dotnet -\\narchitecture/eShopOn\", \"Containers/wiki/Deployment -With -GitHub -Actions . \\nStep 5: Run and manage  \\nBecause running and ma\", \"naging applications at enterprise -production level is a major subject in and of \\nitself, and due to\", \" the type of operations and people working at that level (IT operations) as well as the \\nlarge scope\", \" of this area, the entire next chapte r is devoted to explaining it.  \\nStep 6: Monitor and diagnose \", \" \\nThis topic also is covered in the next chapter as part of the tasks that IT performs in production\", \" \\nsystems; however, is important to highlight that the insights obtained in this step must feed back\", \" to \\nthe development team so that the application is constantly improved. From that point of  view, \", \"it\\u2019s also \\npart of DevOps, although the tasks and operations are commonly performed by IT.  \\nOnly wh\", \"en monitoring and diagnostics are 100% within the realm of DevOps are the monitoring \\nprocesses and \", \"analytics performed by the development team against testing or beta environments. \\nThis is done eith\", \"er by performing load testing or by monitoring beta  or QA  environments, where beta \\ntesters are tr\", \"ying the new versions.  \\nCreate CI/CD pipelines in Azure DevOps Services for \\na .NET application on \", \"Containers and deploying to a \\nKubernetes cluster  \\nIn Figure 5 -12 you can see the end -to-end DevO\", \"ps scenario covering the code management, code \\ncompilation, Docker images build, Docker images push\", \" to a Docker registry and finally the \\ndeployment to a Kubernetes cluster in Azure.   \\n90 CHAPTER 5 \", \"| Docker application DevOps workflow with Microsoft tools  \\n  \\nFigure 5 -12. CI/CD scenario creating\", \" Docker images and deploying to a Kubernetes cluster in Azure  \\nIt is important to highlight that th\", \"e two pipelines, build/CI, and release/CD, are connected through the \\nDocker Registry (such as Docke\", \"r Hub or Azure Container Registry). The Docker registry is one of the \\nmain differences compared to \", \"a traditional CI/CD pr ocess without Docker.  \\nAs shown in Figure 5 -13, the first phase is the buil\", \"d/CI pipeline. In Azure DevOps Services you can \\ncreate build/CI pipelines that will compile the cod\", \"e, create the Docker images, and push them to a \\nDocker Registry like Docker Hub or Azure Container \", \"Regist ry. \\n \\n91 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n  \\nFigure 5 -\", \"13. Build/CI pipeline in Azure DevOps building Docker images and pushing images to a Docker registry\", \"  \\nThe second phase is to create a deployment/release pipeline. In Azure DevOps Services, you can ea\", \"sily \\ncreate a deployment pipeline targeting a Kubernetes cluster by using the Kubernetes tasks for \", \"Azure \\nDevOps Services, as shown in Figure 5 -14. \\n \\nFigure 5 -14. Release/CD pipeline in Azure DevO\", \"ps Services deploying to a Kubernetes cluster  \\n[!Walkthrough] Deploying eShopModernized to Kubernet\", \"es:  \\n \\n92 CHAPTER 5 | Docker application DevOps workflow with Microsoft tools  \\n For a detailed wal\", \"kthrough of Azure DevOps CI/CD pipelines deploying to Kubernetes, see this post:  \\nhttps://github.co\", \"m/dotnet -architecture/eShopModernizing/wiki/04. -How-to-deploy -your-Windows -\\nContainers -based -a\", \"pps -into-Kubernetes -in-Azure -Container -Service -(Including -CI-CD)  \\n93 CHAPTER 6 | Run, manage,\", \" and monitor Docker production environments  \\n CHAPTER  6 \\nRun, manage, and monitor \\nDocker producti\", \"on \\nenvironments  \\nVision: Enterprise applications need to run with high availability and high scala\", \"bility; IT operations \\nneed to be able to manage and monitor the environments and the applications t\", \"hemselves.  \\nThis last pillar in the containerized Docker applications life cycle is centered on how\", \" you can run, \\nmanage, and monitor your applications in scalable, high availability (HA) production \", \"environments.  \\nThe way you run your containerized applications in production (infrastructure archit\", \"ecture and \\nplatform technologies) is very much related and based on the chosen architecture and dev\", \"elopment \\nplatforms discussed in Chapter 1 of this e -book.  \\nThis chapter examines specific product\", \"s and technologies from Microsoft and other vendors that you \\ncan use to effectively run scalable, H\", \"A distributed applications plus how you can manage and monitor \\nthem from the IT perspective.  \\nRun \", \"composed and microservices -based \\napplications in production environments  \\nApplications composed b\", \"y multiple microservices do need to be deployed into orchestrator clusters in \\norder to simplify the\", \" complexity of deployment and make it viable from an IT point of view. Without \\nan orchestrator clus\", \"ter, it would be difficult to deplo y and scale out a complex microservices \\napplication.  \\nIntroduc\", \"tion to orchestrators, schedulers, and container clusters  \\nEarlier in this e -book, clusters  and s\", \"chedulers  were introduced as part of the discussion on software \\narchitecture and development. Kube\", \"rnetes and Service Fabric are examples of Docker clusters. Both of \\nthese orchestrators can run as a\", \" part of the infrastructure provided by Microsoft Azure Kubernetes \\nService.   \\n94 CHAPTER 6 | Run, \", \"manage, and monitor Docker production environments  \\n When applications are scaled -out across multi\", \"ple host systems, the ability to manage each host \\nsystem and abstract away the complexity of the un\", \"derlying platform becomes attractive. That\\u2019s \\nprecisely what orchestrators and schedulers provide. L\", \"et\\u2019s take a brief look at them here:  \\n\\u2022 Schedulers . \\u201cScheduling\\u201d refers to the ability for an admi\", \"nistrator to load a service file onto \\na host system that establishes how to run a specific containe\", \"r. Launching containers in a \\nDocker cluster tends to be known as scheduling. Although scheduling re\", \"fers to th e specific act \\nof loading the service definition, in a more general sense, schedulers ar\", \"e responsible for \\nhooking into a host\\u2019s init system to manage services in whatever capacity needed.\", \"  \\n  A cluster scheduler has multiple goals: using the cluster\\u2019s resources efficiently, working with\", \" \\nuser-supplied placement constraints, scheduling applications rapidly to not leave them in a \\npendi\", \"ng state, having a degree of \\u201cfairness,\\u201d being robust to errors , and always be available.  \\n\\u2022 Orche\", \"strators . Platforms extend life -cycle management capabilities to complex, multi -\\ncontainer worklo\", \"ads deployed on a cluster of hosts. By abstracting the host infrastructure, \\norchestration tools giv\", \"e users a way to treat the entire cluster as a single deployment targ et. \\n  The process of orchestr\", \"ation involves tooling and a platform that can automate all aspects of \\napplication management from \", \"initial placement or deployment per container; moving \\ncontainers to different hosts depending on it\", \"s host\\u2019s health or performance; ver sioning and \\nrolling updates and health monitoring functions tha\", \"t support scaling and failover; and many \\nmore.  \\n  Orchestration is a broad term that refers to con\", \"tainer scheduling, cluster management, and \\npossibly the provisioning of additional hosts.  \\nThe cap\", \"abilities provided by orchestrators and schedulers are complex to develop and create from \\nscratch, \", \"therefore you usually would want to use orchestration solutions offered by vendors.  \\nManage product\", \"ion Docker environments  \\nCluster management and orchestration is the process of controlling a group\", \" of hosts. This can involve \\nadding and removing hosts from a cluster, getting information about the\", \" current state of hosts and \\ncontainers, and starting and stopping processes. Cluste r management an\", \"d orchestration are closely \\ntied to scheduling because the scheduler must have access to each host \", \"in the cluster in order to \\nschedule services. For this reason, the same tool is often used for both\", \" purposes.  \\nContainer Service and management tools  \\nContainer Service provides rapid deployment of\", \" popular open -source container clustering and \\norchestration solutions. It uses Docker images to en\", \"sure that your application containers are fully \\nportable. By using Container Service, you can deplo\", \"y DC/OS (powe red by Mesosphere and Apache \\nMesos) and Docker Swarm clusters with Azure Resource Man\", \"ager templates or the Azure portal to \\nensure that you can scale these applications to thousands \\u2014ev\", \"en tens of thousands \\u2014of containers.  \\nYou deploy these clusters by using Azure Virtual Machine Scal\", \"e Sets, and the clusters take advantage \\nof Azure networking and storage offerings. To access Contai\", \"ner Service, you need an Azure  \\n95 CHAPTER 6 | Run, manage, and monitor Docker production environme\", \"nts  \\n subscription. With Container Service, you can take advantage of the enterprise -grade feature\", \"s of \\nAzure while still maintaining application portability, including at the orchestration layers. \", \" \\nTable 6 -1 lists common management tools related to their orchestrators, schedulers, and clusterin\", \"g \\nplatform.  \\nTable 6 -1. Docker management tools  \\nManagement tools  Description  Related orchestr\", \"ators  \\nAzure Monitor for Containers  Azure dedicated \\nKubernetes \\nmanagement tool  Azure Kubernetes\", \" Services (AKS)  \\nKubernetes Web UI \\n(dashboard)  Kubernetes \\nmanagement tool, \\ncan monitor and \\nman\", \"age local \\nKubernetes cluster  Azure Kubernetes Service (AKS)  \\nLocal Kubernetes  \\nAzure portal for \", \"Service Fabric  \\nAzure Service Fabric Explorer  Online and desktop \\nversion for managing \\nService Fa\", \"bric \\nclusters, on Azure, on \\npremises, local \\ndevelopment, and \\nother clouds  Azure Service Fabric \", \" \\nContainer Monitoring (Azure \\nMonitor)  General container \\nmanagement y \\nmonitoring solution. \\nCan \", \"manage \\nKubernetes clusters \\nthrough Azure \\nMonitor for \\nContainers . Azure Service Fabric  \\nAzure K\", \"ubernetes Service (AKS)  \\nMesosphere DC/OS and others.  \\nAzure Service Fabric  \\nAnother choice for c\", \"luster -deployment and management is Azure Service Fabric. Service Fabric  is a \\nMicrosoft microserv\", \"ices platform that includes container orchestration as well as developer \\nprogramming models to buil\", \"d highly scalable microservices applications. Service Fabric supports \\nDocker in Linux and Windows C\", \"ontainers and can run in Windows and Linux servers.  \\nThe following are Service Fabric management to\", \"ols:  \\n\\u2022 Azure portal for Service Fabric  cluster -related operations (create/update/delete) a clust\", \"er or \\nconfigure its infrastructure (VMs, load balancer, networking, etc.)  \\n\\u2022 Azure Service Fabric \", \"Explorer  is a specialized web UI and desktop multi -platform tool that \\nprovides insights and certa\", \"in operations on the Service Fabric cluster, from the nodes/VMs \\npoint of view and from the applicat\", \"ion and services point of view.   \\n96 CHAPTER 6 | Run, manage, and monitor Docker production environ\", \"ments  \\n Monitor containerized application services  \\nIt\\u2019s critical for applications split into mult\", \"iple containers and microservices to have a way to monitor \\nand analyze the behavior of the whole ap\", \"plication.  \\nAzure Monitor  \\nAzure Monitor  is an extensible analytics service that monitors your li\", \"ve application. It helps you to \\ndetect and diagnose performance issues and to understand what users\", \" actually do with your app. It\\u2019s \\ndesigned for developers, with the intent of helping you to continu\", \"o usly improve the performance and \\nusability of your services or applications. Azure Monitor works \", \"with both web/services and standalone \\napps on a wide variety of platforms like .NET, Java, Node.js \", \"and many other platforms, hosted on -\\npremises or in the cloud . \\nAdditional resources  \\n\\u2022 Overview \", \"of Azure Monitor  \\nhttps://learn.microsoft.com/azure/azure -monitor/overview  \\n\\u2022 What is Application\", \" Insights?  \\nhttps://learn.microsoft.com/azure/azure -monitor/app/app -insights -overview  \\n\\u2022 What i\", \"s Azure Monitor Metrics?  \\nhttps://learn.microsoft.com/azure/azure -monitor/platform/data -platform \", \"-metrics  \\n\\u2022 Container Monitoring solution in Azure Monitor  \\nhttps://learn.microsoft.com/azure/azur\", \"e -monitor/insights/containers  \\nSecurity and backup services  \\nThere are many support chores with l\", \"ots of details that you have to handle to ensure your applications \\nand infrastructure are in top no\", \"tch condition to support business needs, and the situation becomes \\nmore complicated in the microser\", \"vices realm, so you ne ed a way to have both high -level and detailed \\nviews when you need to take a\", \"ction.  \\nAzure has the tools to manage and provide a unified view of four critical aspects of both y\", \"our cloud \\nand on -premises resources:  \\n\\u2022 Security . With Azure Security Center . \\n\\u2013 Get full visib\", \"ility and control over the security of your virtual machines, apps, and \\nworkloads.  \\n\\u2013 Centralize t\", \"he management of your security policies and integrate existing processes \\nand tools.  \\n\\u2013 Detect real\", \" threats with advanced analytics.  \\n\\u2022 Backup . With Azure Backup . \\n\\u2013 Avoid costly business disrupti\", \"ons, meet compliance goals, and protect your data \\nagainst ransomware and human errors.  \\n\\u2013 Keep you\", \"r backup data encrypted in transit and at rest.   \\n97 CHAPTER 6 | Run, manage, and monitor Docker pr\", \"oduction environments  \\n \\u2013 Ensure access based on multifactor authentication to prevent unauthorized\", \" use.  \\n\\u2022 On-premises resources . With hybrid cloud solutions .  \\n98 CHAPTER 7 | Containerized Docke\", \"r Application Lifecycle key takeaways  \\n CHAPTER  7 \\nContainerized Docker \\nApplication Lifecycle key\", \" \\ntakeaways  \\n\\u2022 Container -based solutions provide important cost -saving benefits because container\", \"s solve \\ndeployment problems caused by dependency failures in production environments, thereby \\nimpr\", \"oving DevOps and production operations significantly.  \\n\\u2022 Docker has become the de facto standard in\", \" the container industry and is supported by the \\nmost significant vendors in the Linux and Windows e\", \"cosystems, including Microsoft. In the \\nfuture, Docker will be ubiquitous in any datacenter in the c\", \"loud or on -premi ses. \\n\\u2022 A Docker container is becoming the standard unit of deployment for any ser\", \"ver -based \\napplication or service.  \\n\\u2022 Docker orchestrators like the ones provided in Azure Kuberne\", \"tes Service (AKS) and Azure \\nService Fabric are fundamental and indispensable for any microservices \", \"-based or multi -\\ncontainer applications that have significant complexity and scalability needs.  \\n\\u2022\", \" An end -to-end DevOps environment that supports Continuous Integration/Continuous \\nDeployment (CI/C\", \"D) and connects to the production Docker environments can provide agility \\nand ultimately improve th\", \"e time to market of your applications.  \\n\\u2022 Azure DevOps Services greatly simplifies your DevOps envi\", \"ronment by deploying to Docker \\nenvironments from your CI/CD pipelines. This statement applies to si\", \"mple Docker \\nenvironments as well as to advanced microservice and container orchestrators based on \\n\", \"Azure. \"]"