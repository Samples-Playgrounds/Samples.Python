<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>the domain that you want other parts of the same domain (in-process) to be aware of. The parts usually react somehow to the events.</td>
      <td>notified</td>
    </tr>
    <tr>
      <th>1</th>
      <td>An important benefit of domain events is that side effects can be expressed explicitly.</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>For example, if you’re just using Entity Framework and there has to be a reaction to some would probably code whatever you need close to what triggers the event. So the rule gets implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</td>
      <td>event, you coupled,</td>
    </tr>
    <tr>
      <th>3</th>
      <td>On the other hand, using domain events makes the concept explicit, because there’s a and at least one DomainEventHandler involved.</td>
      <td>DomainEvent</td>
    </tr>
    <tr>
      <th>4</th>
      <td>For example, in the eShopOnContainers application, when an order is created, the user buyer, so an OrderStartedDomainEvent is raised and handled in the ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler, so the underlying evident.</td>
      <td>becomes a concept is</td>
    </tr>
    <tr>
      <th>5</th>
      <td>In short, domain events help you to express, explicitly, the domain rules, based in the language provided by the domain experts. Domain events also enable a better separation of among classes within the same domain.</td>
      <td>ubiquitous concerns</td>
    </tr>
    <tr>
      <th>6</th>
      <td>It’s important to ensure that, just like a database transaction, either all the operations related domain event finish successfully or none of them do.</td>
      <td>to a</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Domain events are similar to messaging-style events, with one important difference. With real messaging, message queuing, message brokers, or a service bus using AMQP, a message is sent asynchronously and communicated across processes and machines. This is useful for multiple Bounded Contexts, microservices, or even different applications. However, with events, you want to raise an event from the domain operation you’re currently running, but any side effects to occur within the same domain.</td>
      <td>always integrating domain you want</td>
    </tr>
    <tr>
      <th>8</th>
      <td>The domain events and their side effects (the actions triggered afterwards that are managed handlers) should occur almost immediately, usually in-process, and within the same domain. domain events could be synchronous or asynchronous. Integration events, however, should</td>
      <td>by event Thus, always be</td>
    </tr>
  </tbody>
</table>