{'Unordered list': [[{'text': '[This e-book is also available in a PDF format (English version only) Download](https://aka.ms/microservicesebook)', 'task_item': False}, {'text': '[Clone/Fork the reference application eShopOnContainers on GitHub](https://github.com/dotnet-architecture/eShopOnContainers)', 'task_item': False}, {'text': '[Watch the introductory video](https://aka.ms/microservices-video)', 'task_item': False}, {'text': '[Get to know the Microservices Architecture right away](https://aka.ms/MicroservicesArchitecture)', 'task_item': False}], [{'text': 'Containerized Docker Application Lifecycle with Microsoft Platform and Tools (downloadable\ne-book)\n[https://aka.ms/dockerlifecycleebook](https://aka.ms/dockerlifecycleebook)', 'task_item': False}], [{'text': 'Windows Server Containers provide application isolation through process and namespace\nisolation technology. A Windows Server Container shares a kernel with the container host and\nwith all containers running on the host.', 'task_item': False}, {'text': 'Hyper-V Containers expand on the isolation provided by Windows Server Containers by\nrunning each container in a highly optimized virtual machine. In this configuration, the kernel\nof the container host isn’t shared with the Hyper-V Containers, providing better isolation.', 'task_item': False}, {'text': 'The images for these containers are created the same way and function the same. The difference is in\nhow the container is created from the image running a Hyper-V Container requires an extra\n[parameter. For details, see Hyper-V Containers.](https://docs.microsoft.com/virtualization/windowscontainers/manage-containers/hyperv-container)', 'task_item': False}], [{'text': 'Your images must not be shared publicly due to confidentiality.', 'task_item': False}, {'text': 'You want to have minimum network latency between your images and your chosen\ndeployment environment. For example, if your production environment is Azure cloud, you\n[probably want to store your images in Azure Container Registry](https://azure.microsoft.com/services/container-registry/) so that network latency will\nbe minimal. In a similar way, if your production environment is on-premises, you might want\nto have an on-premises Docker Trusted Registry available within the same local network.', 'task_item': False}, {'text': '8 CHAPTER 1 | Introduction to Containers and Docker', 'task_item': False}, {'text': '**CHAPTER**', 'task_item': False}], [{'text': 'You have cross-platform needs. For example, you want to use both Linux and Windows\nContainers.', 'task_item': False}, {'text': 'Your application architecture is based on microservices.', 'task_item': False}, {'text': 'You need to start containers fast and want a small footprint per container to achieve better\ndensity or more containers per hardware unit in order to lower your costs.', 'task_item': False}, {'text': 'In short, when you create new containerized .NET applications, you should consider .NET 7 as the\ndefault choice. It has many benefits and fits best with the containers philosophy and style of working.', 'task_item': False}, {'text': 'An extra benefit of using .NET 7 is that you can run side-by-side .NET versions for applications within\nthe same machine. This benefit is more important for servers or VMs that do not use containers,\nbecause containers isolate the versions of .NET that the app needs. (As long as they are compatible\nwith the underlying OS.)', 'task_item': False}, {'text': 'Use .NET Framework for your containerized Docker server application when:', 'task_item': False}, {'text': 'Your application currently uses .NET Framework and has strong dependencies on Windows.', 'task_item': False}, {'text': '9 CHAPTER 2 | Choosing Between .NET and .NET Framework for Docker Containers', 'task_item': False}, {'text': 'You need to use Windows APIs that are not supported by .NET 7.', 'task_item': False}, {'text': 'You need to use third-party .NET libraries or NuGet packages that are not available for .NET 7.', 'task_item': False}, {'text': 'Using .NET Framework on Docker can improve your deployment experiences by minimizing\n[deployment issues. This “lift and shift” scenario is important for containerizing legacy applications that](https://aka.ms/liftandshiftwithcontainersebook)\nwere originally developed with the traditional .NET Framework, like ASP.NET WebForms, MVC web\napps, or WCF (Windows Communication Foundation) services.', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**E-book: Modernize existing .NET Framework applications with Azure and Windows**\n**Containers**\n[https://aka.ms/liftandshiftwithcontainersebook](https://aka.ms/liftandshiftwithcontainersebook)', 'task_item': False}, {'text': '**Sample apps: Modernization of legacy ASP.NET web apps by using Windows Containers**\n[https://aka.ms/eshopmodernizing](https://aka.ms/eshopmodernizing)', 'task_item': False}], [{'text': 'ASP.NET Web Forms. This technology is only available on .NET Framework. Currently there are\nno plans to bring ASP.NET Web Forms to .NET or later.', 'task_item': False}, {'text': 'Workflow-related services. Windows Workflow Foundation (WF), Workflow Services (WCF +\nWF in a single service), and WCF Data Services (formerly known as ADO.NET Data Services)\nare only available on .NET Framework. There are currently no plans to bring them to .NET 7.', 'task_item': False}, {'text': '[In addition to the technologies listed in the official .NET roadmap, other features might be ported to](https://github.com/dotnet/core/blob/main/roadmap.md)\n[the new unified .NET platform. You might consider participating in the discussions on GitHub so that](https://devblogs.microsoft.com/dotnet/introducing-net-5/)\n[your voice can be heard. And if you think something is missing, file a new issue in the dotnet/runtime](https://github.com/dotnet/runtime/issues/new)\nGitHub repository.', 'task_item': False}], [{'text': '**.NET fundamentals**\n[https://learn.microsoft.com/dotnet/fundamentals](https://docs.microsoft.com/dotnet/fundamentals/index.yml)', 'task_item': False}, {'text': '**Porting Projects to .NET 5**\n[https://learn.microsoft.com/events/dotnetconf-2020/porting-projects-to-net-5](https://docs.microsoft.com/Events/dotnetConf/2020/Porting-Projects-to-NET-5)', 'task_item': False}, {'text': '**.NET on Docker Guide**\n[https://learn.microsoft.com/dotnet/core/docker/introduction](https://docs.microsoft.com/dotnet/core/docker/introduction)', 'task_item': False}], [{'text': 'Images used to _develop_ and build .NET apps.', 'task_item': False}, {'text': 'Images used to _run_ .NET apps.', 'task_item': False}, {'text': 'Why multiple images? When developing, building, and running containerized applications, you usually\nhave different priorities. By providing different images for these separate tasks, Microsoft helps\noptimize the separate processes of developing, building, and deploying apps.', 'task_item': False}, {'text': '**During development and build**', 'task_item': False}, {'text': 'During development, what is important is how fast you can iterate changes, and the ability to debug\nthe changes. The size of the image isn’t as important as the ability to make changes to your code and\nsee the changes quickly. Some tools and “build-agent containers”, use the development .NET image\n( _mcr.microsoft.com/dotnet/sdk:7.0_ ) during development and build process. When building inside a\nDocker container, the important aspects are the elements that are needed to compile your app. This\nincludes the compiler and any other .NET dependencies.', 'task_item': False}, {'text': 'Why is this type of build image important? You don’t deploy this image to production. Instead, it’s an\nimage that you use to build the content you place into a production image. This image would be used\nin your continuous integration (CI) environment or build environment when using Docker multi-stage\nbuilds.', 'task_item': False}, {'text': '**In production**', 'task_item': False}, {'text': 'What is important in production is how fast you can deploy and start your containers based on a\nproduction .NET image. Therefore, the runtime-only image based on\n_mcr.microsoft.com/dotnet/aspnet:7.0_ is small so that it can travel quickly across the network from your\nDocker registry to your Docker hosts. The contents are ready to run, enabling the fastest time from\nstarting the container to processing results. In the Docker model, there is no need for compilation\nfrom C# code, as there’s when you run dotnet build or dotnet publish when using the build container.', 'task_item': False}, {'text': '16 CHAPTER 2 | Choosing Between .NET and .NET Framework for Docker Containers', 'task_item': False}, {'text': 'In this optimized image, you put only the binaries and other content needed to run the application.\nFor example, the content created by dotnet publish contains only the compiled .NET binaries, images,\n.js, and .css files. Over time, you’ll see images that contain pre-jitted (the compilation from IL to native\nthat occurs at run time) packages.', 'task_item': False}, {'text': 'Although there are multiple versions of the .NET and ASP.NET Core images, they all share one or more\nlayers, including the base layer. Therefore, the amount of disk space needed to store an image is\nsmall; it consists only of the delta between your custom image and its base image. The result is that\nit’s quick to pull the image from your registry.', 'task_item': False}, {'text': 'When you explore the .NET image repositories at Microsoft Artifact Registry, you’ll find multiple image\nversions classified or marked with tags. These tags help to decide which one to use, depending on the\nversion you need, like those in the following table:', 'task_item': False}, {'text': '|Image|Comments|\n|---|---|\n|mcr.microsoft.com/dotnet/aspnet:**7.0**|ASP.NET Core, with runtime only and ASP.NET Core<br>optimizations, on Linux and Windows (multi-arch)|\n|mcr.microsoft.com/dotnet/sdk:**7.0**|.NET 7, with SDKs included, on Linux and Windows<br>(multi-arch)|', 'task_item': False}, {'text': '[You can find all the available docker images in dotnet-docker](https://github.com/dotnet/dotnet-docker) and also refer to the latest preview\nreleases by using nightly build mcr.microsoft.com/dotnet/nightly/*', 'task_item': False}, {'text': '17 CHAPTER 2 | Choosing Between .NET and .NET Framework for Docker Containers', 'task_item': False}, {'text': '**CHAPTER**', 'task_item': False}], [{'text': '**Volumes** are stored in an area of the host filesystem that’s managed by Docker.', 'task_item': False}, {'text': '**Bind mounts** can map to any folder in the host filesystem, so access can’t be controlled from\nDocker process and can pose a security risk as a container could access sensitive OS folders.', 'task_item': False}, {'text': '**tmpfs mounts** are like virtual folders that only exist in the host’s memory and are never\nwritten to the filesystem.', 'task_item': False}, {'text': 'From remote storage:', 'task_item': False}, {'text': '[Azure Storage, which provides geo-distributable storage, providing a good long-term](https://azure.microsoft.com/documentation/services/storage/)\npersistence solution for containers.', 'task_item': False}, {'text': '[Remote relational databases like Azure SQL Database](https://azure.microsoft.com/services/sql-database/) [or NoSQL databases like Azure Cosmos](https://docs.microsoft.com/azure/cosmos-db/introduction)\n[DB, or cache services like Redis.](https://redis.io/)', 'task_item': False}, {'text': 'From the Docker container:', 'task_item': False}, {'text': '**Overlay File System** . This Docker feature implements a copy-on-write task that stores\nupdated information to the root file system of the container. That information is “on top” of\nthe original image on which the container is based. If the container is deleted from the\nsystem, those changes are lost. Therefore, while it’s possible to save the state of a container\nwithin its local storage, designing a system around this would conflict with the premise of\ncontainer design, which by default is stateless.', 'task_item': False}, {'text': 'However, using Docker Volumes is now the preferred way to handle local data in Docker. If you need\n[more information about storage in containers check on Docker storage drivers and About storage](https://docs.docker.com/storage/storagedriver/select-storage-driver/)\n[drivers.](https://docs.docker.com/storage/storagedriver/)', 'task_item': False}, {'text': 'The following provides more detail about these options:', 'task_item': False}, {'text': '**Volumes** are directories mapped from the host OS to directories in containers. When code in the\ncontainer has access to the directory, that access is actually to a directory on the host OS. This\ndirectory is not tied to the lifetime of the container itself, and the directory is managed by Docker and\nisolated from the core functionality of the host machine. Thus, data volumes are designed to persist\ndata independently of the life of the container. If you delete a container or an image from the Docker\nhost, the data persisted in the data volume isn’t deleted.', 'task_item': False}, {'text': 'Volumes can be named or anonymous (the default). Named volumes are the evolution of **Data**\n**Volume Containers** and make it easy to share data between containers. Volumes also support\nvolume drivers that allow you to store data on remote hosts, among other options.', 'task_item': False}, {'text': '**Bind mounts** are available since a long time ago and allow the mapping of any folder to a mount\npoint in a container. Bind mounts have more limitations than volumes and some important security\nissues, so volumes are the recommended option.', 'task_item': False}, {'text': '23 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': '**tmpfs mounts** are basically virtual folders that live only in the host’s memory and are never written to\nthe filesystem. They are fast and secure but use memory and are only meant for temporary, nonpersistent data.', 'task_item': False}, {'text': 'As shown in Figure 4-5, regular Docker volumes can be stored outside of the containers themselves\nbut within the physical boundaries of the host server or VM. However, Docker containers can’t access\na volume from one host server or VM to another. In other words, with these volumes, it isn’t possible\nto manage data shared between containers that run on different Docker hosts, although it could be\nachieved with a volume driver that supports remote hosts.', 'task_item': False}, {'text': '_Figure 4-5. Volumes and external data sources for container-based applications_', 'task_item': False}, {'text': 'Volumes can be shared between containers, but only in the same host, unless you use a remote driver\nthat supports remote hosts. In addition, when Docker containers are managed by an orchestrator,\ncontainers might “move” between hosts, depending on the optimizations performed by the cluster.\nTherefore, it isn’t recommended that you use data volumes for business data. But they’re a good\nmechanism to work with trace files, temporal files, or similar that will not impact business data\nconsistency.', 'task_item': False}, {'text': '**Remote data sources and cache** tools like Azure SQL Database, Azure Cosmos DB, or a remote cache\nlike Redis can be used in containerized applications the same way they are used when developing\nwithout containers. This is a proven way to store business application data.', 'task_item': False}, {'text': '**Azure Storage.** Business data usually will need to be placed in external resources or databases, like\nAzure Storage. Azure Storage, in concrete, provides the following services in the cloud:', 'task_item': False}, {'text': 'Blob storage stores unstructured object data. A blob can be any type of text or binary data,\nsuch as document or media files (images, audio, and video files). Blob storage is also referred\nto as Object storage.', 'task_item': False}, {'text': '24 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': 'File storage offers shared storage for legacy applications using standard SMB protocol. Azure\nvirtual machines and cloud services can share file data across application components via\nmounted shares. On-premises applications can access file data in a share via the File service\nREST API.', 'task_item': False}, {'text': 'Table storage stores structured datasets. Table storage is a NoSQL key-attribute data store,\nwhich allows rapid development and fast access to large quantities of data.', 'task_item': False}, {'text': '**Relational databases and NoSQL databases.** There are many choices for external databases, from\nrelational databases like SQL Server, PostgreSQL, Oracle, or NoSQL databases like Azure Cosmos DB,\nMongoDB, etc. These databases are not going to be explained as part of this guide since they are in a\ncompletely different subject.', 'task_item': False}], [{'text': 'Monitoring and health checks of the services and infrastructure.', 'task_item': False}, {'text': 'Scalable infrastructure for the services (that is, cloud and orchestrators).', 'task_item': False}, {'text': 'Security design and implementation at multiple levels: authentication, authorization, secrets\nmanagement, secure communication, etc.', 'task_item': False}, {'text': 'Rapid application delivery, usually with different teams focusing on different microservices.', 'task_item': False}, {'text': 'DevOps and CI/CD practices and infrastructure.', 'task_item': False}, {'text': 'Of these, only the first three are covered or introduced in this guide. The last two points, which are\n[related to application lifecycle, are covered in the additional Containerized Docker Application](https://aka.ms/dockerlifecycleebook)\n[Lifecycle with Microsoft Platform and Tools e-book.](https://aka.ms/dockerlifecycleebook)', 'task_item': False}], [{'text': '**Mark Russinovich. Microservices: An application revolution powered by the cloud**\n[https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)\ncloud/', 'task_item': False}, {'text': '**Martin Fowler. Microservices**\n[https://www.martinfowler.com/articles/microservices.html](https://www.martinfowler.com/articles/microservices.html)', 'task_item': False}, {'text': '**Martin Fowler. Microservice Prerequisites**\n[https://martinfowler.com/bliki/MicroservicePrerequisites.html](https://martinfowler.com/bliki/MicroservicePrerequisites.html)', 'task_item': False}, {'text': '**Jimmy Nilsson. Chunk Cloud Computing**\n[https://www.infoq.com/articles/CCC-Jimmy-Nilsson](https://www.infoq.com/articles/CCC-Jimmy-Nilsson)', 'task_item': False}, {'text': '**Cesar de la Torre. Containerized Docker Application Lifecycle with Microsoft Platform**\n**and Tools** (downloadable e-book)\n[https://aka.ms/dockerlifecycleebook](https://aka.ms/dockerlifecycleebook)', 'task_item': False}], [{'text': '**Chris Richardson. Pattern: Database per service**\n[https://microservices.io/patterns/data/database-per-service.html](https://microservices.io/patterns/data/database-per-service.html)', 'task_item': False}, {'text': '**Martin Fowler. BoundedContext**\n[https://martinfowler.com/bliki/BoundedContext.html](https://martinfowler.com/bliki/BoundedContext.html)', 'task_item': False}, {'text': '**Martin Fowler. PolyglotPersistence**\n[https://martinfowler.com/bliki/PolyglotPersistence.html](https://martinfowler.com/bliki/PolyglotPersistence.html)', 'task_item': False}, {'text': '**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping**\n[https://www.infoq.com/articles/ddd-contextmapping](https://www.infoq.com/articles/ddd-contextmapping)', 'task_item': False}], [{'text': 'Blocking and low performance. Due to the synchronous nature of HTTP, the original request\ndoesn’t get a response until all the internal HTTP calls are finished. Imagine if the number of\nthese calls increases significantly and at the same time one of the intermediate HTTP calls to a\nmicroservice is blocked. The result is that performance is impacted, and the overall scalability\nwill be exponentially affected as additional HTTP requests increase.', 'task_item': False}, {'text': 'Coupling microservices with HTTP. Business microservices shouldn’t be coupled with other\nbusiness microservices. Ideally, they shouldn’t “know” about the existence of other\nmicroservices. If your application relies on coupling microservices as in the example, achieving\nautonomy per microservice will be almost impossible.', 'task_item': False}, {'text': 'Failure in any one microservice. If you implemented a chain of microservices linked by HTTP\ncalls, when any of the microservices fails (and eventually they will fail) the whole chain of\nmicroservices will fail. A microservice-based system should be designed to continue to work\nas well as possible during partial failures. Even if you implement client logic that uses retries\nwith exponential backoff or circuit breaker mechanisms, the more complex the HTTP call\nchains are, the more complex it is to implement a failure strategy based on HTTP.', 'task_item': False}, {'text': 'In fact, if your internal microservices are communicating by creating chains of HTTP requests as\ndescribed, it could be argued that you have a monolithic application, but one based on HTTP between\nprocesses instead of intra-process communication mechanisms.', 'task_item': False}, {'text': '35 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': 'Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize\nthe use of chains of request/response communication across microservices. It’s recommended that\nyou use only asynchronous interaction for inter-microservice communication, either by using\nasynchronous message- and event-based communication, or by using (asynchronous) HTTP polling\nindependently of the original HTTP request/response cycle.', 'task_item': False}, {'text': 'The use of asynchronous communication is explained with additional details later in this guide in the\nsections Asynchronous microservice integration enforces microservice’s autonomy and Asynchronous\nmessage-based communication.', 'task_item': False}], [{'text': '**CAP theorem**\n[https://en.wikipedia.org/wiki/CAP_theorem](https://en.wikipedia.org/wiki/CAP_theorem)', 'task_item': False}, {'text': '**Eventual consistency**\n[https://en.wikipedia.org/wiki/Eventual_consistency](https://en.wikipedia.org/wiki/Eventual_consistency)', 'task_item': False}, {'text': '**Data Consistency Primer**\n[https://learn.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)](https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10))', 'task_item': False}, {'text': '**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**\n[https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html)', 'task_item': False}, {'text': '**Materialized View**\n[https://learn.microsoft.com/azure/architecture/patterns/materialized-view](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)', 'task_item': False}, {'text': '**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**\n[https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-](https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)\n[processing/](https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)', 'task_item': False}, {'text': '**Compensating Transaction**\n[https://learn.microsoft.com/azure/architecture/patterns/compensating-transaction](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)', 'task_item': False}, {'text': '**Udi Dahan. Service Oriented Composition**\n[https://udidahan.com/2014/07/30/service-oriented-composition-with-video/](https://udidahan.com/2014/07/30/service-oriented-composition-with-video/)', 'task_item': False}], [{'text': '_How can client apps minimize the number of requests to the back end and reduce chatty_\n_communication to multiple microservices?_', 'task_item': False}, {'text': 'Interacting with multiple microservices to build a single UI screen increases the number of round trips\nacross the Internet. This approach increases latency and complexity on the UI side. Ideally, responses\nshould be efficiently aggregated in the server side. This approach reduces latency, since multiple\npieces of data come back in parallel and some UI can show data as soon as it’s ready.', 'task_item': False}, {'text': '_How can you handle cross-cutting concerns such as authorization, data transformations, and_\n_dynamic request dispatching?_', 'task_item': False}, {'text': 'Implementing security and cross-cutting concerns like security and authorization on every\nmicroservice can require significant development effort. A possible approach is to have those services\nwithin the Docker host or internal cluster to restrict direct access to them from the outside, and to\nimplement those cross-cutting concerns in a centralized place, like an API Gateway.', 'task_item': False}, {'text': '_How can client apps communicate with services that use non-Internet-friendly protocols?_', 'task_item': False}, {'text': 'Protocols used on the server side (like AMQP or binary protocols) are not supported in client apps.\nTherefore, requests must be performed through protocols like HTTP/HTTPS and translated to the\nother protocols afterwards. A _man-in-the-middle_ approach can help in this situation.', 'task_item': False}, {'text': '_How can you shape a facade especially made for mobile apps?_', 'task_item': False}, {'text': 'The API of multiple microservices might not be well designed for the needs of different client\napplications. For instance, the needs of a mobile app might be different than the needs of a web app.\nFor mobile apps, you might need to optimize even further so that data responses can be more\nefficient. You might do this functionality by aggregating data from multiple microservices and\nreturning a single set of data, and sometimes eliminating any data in the response that isn’t needed\nby the mobile app. And, of course, you might compress that data. Again, a facade or API in between\nthe mobile app and the microservices can be convenient for this scenario.', 'task_item': False}], [{'text': '**Coupling** : Without the API Gateway pattern, the client apps are coupled to the internal\nmicroservices. The client apps need to know how the multiple areas of the application are\ndecomposed in microservices. When evolving and refactoring the internal microservices,\nthose actions impact maintenance because they cause breaking changes to the client apps\ndue to the direct reference to the internal microservices from the client apps. Client apps need\nto be updated frequently, making the solution harder to evolve.', 'task_item': False}, {'text': '**Too many round trips** : A single page/screen in the client app might require several calls to\nmultiple services. That approach can result in multiple network round trips between the client\nand the server, adding significant latency. Aggregation handled in an intermediate level could\nimprove the performance and user experience for the client app.', 'task_item': False}, {'text': '**Security issues** : Without a gateway, all the microservices must be exposed to the “external\nworld”, making the attack surface larger than if you hide internal microservices that aren’t\ndirectly used by the client apps. The smaller the attack surface is, the more secure your\napplication can be.', 'task_item': False}, {'text': '**Cross-cutting concerns** : Each publicly published microservice must handle concerns such as\nauthorization and SSL. In many situations, those concerns could be handled in a single tier so\nthe internal microservices are simplified.', 'task_item': False}], [{'text': 'Authentication and authorization', 'task_item': False}, {'text': 'Service discovery integration', 'task_item': False}, {'text': 'Response caching', 'task_item': False}, {'text': 'Retry policies, circuit breaker, and QoS', 'task_item': False}, {'text': 'Rate limiting and throttling', 'task_item': False}, {'text': 'Load balancing', 'task_item': False}, {'text': 'Logging, tracing, correlation', 'task_item': False}, {'text': 'Headers, query strings, and claims transformation', 'task_item': False}, {'text': 'IP allowlisting', 'task_item': False}, {'text': '[For more information, see Gateway offloading pattern.](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading)', 'task_item': False}], [{'text': '[Azure API Management](https://azure.microsoft.com/services/api-management/)', 'task_item': False}, {'text': '[Ocelot](https://github.com/ThreeMammals/Ocelot)', 'task_item': False}, {'text': '45 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': '**Azure API Management**', 'task_item': False}, {'text': '[Azure API Management](https://azure.microsoft.com/services/api-management/) (as shown in Figure 4-14) not only solves your API Gateway needs but\nprovides features like gathering insights from your APIs. If you’re using an API management solution,\nan API Gateway is only a component within that full API management solution.', 'task_item': False}, {'text': '_Figure 4-14. Using Azure API Management for your API Gateway_', 'task_item': False}, {'text': 'Azure API Management solves both your API Gateway and Management needs like logging, security,\nmetering, etc. In this case, when using a product like Azure API Management, the fact that you might\nhave a single API Gateway is not so risky because these kinds of API Gateways are “thinner”, meaning\nthat you don’t implement custom C# code that could evolve towards a monolithic component.', 'task_item': False}, {'text': 'The API Gateway products usually act like a reverse proxy for ingress communication, where you can\nalso filter the APIs from the internal microservices plus apply authorization to the published APIs in\nthis single tier.', 'task_item': False}, {'text': 'The insights available from an API Management system help you get an understanding of how your\nAPIs are being used and how they are performing. They do this activity by letting you view near realtime analytics reports and identifying trends that might impact your business. Plus, you can have logs\nabout request and response activity for further online and offline analysis.', 'task_item': False}, {'text': 'With Azure API Management, you can secure your APIs using a key, a token, and IP filtering. These\nfeatures let you enforce flexible and fine-grained quotas and rate limits, modify the shape and\nbehavior of your APIs using policies, and improve performance with response caching.', 'task_item': False}, {'text': 'In this guide and the reference sample application (eShopOnContainers), the architecture is limited to\na simpler and custom-made containerized architecture in order to focus on plain containers without', 'task_item': False}, {'text': '46 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': 'using PaaS products like Azure API Management. But for large microservice-based applications that\nare deployed into Microsoft Azure, we encourage you to evaluate Azure API Management as the base\nfor your API Gateways in production.', 'task_item': False}, {'text': '**Ocelot**', 'task_item': False}, {'text': '[Ocelot](https://github.com/ThreeMammals/Ocelot) is a lightweight API Gateway, recommended for simpler approaches. Ocelot is an Open Source\n.NET Core-based API Gateway especially made for microservices architectures that need unified points\nof entry into their systems. It’s lightweight, fast, and scalable and provides routing and authentication\namong many other features.', 'task_item': False}, {'text': '[The main reason to choose Ocelot for the eShopOnContainers reference application 2.0](https://github.com/dotnet-architecture/eShopOnContainers/releases/tag/2.0) is because\nOcelot is a .NET Core lightweight API Gateway that you can deploy into the same application\ndeployment environment where you’re deploying your microservices/containers, such as a Docker\nHost, Kubernetes, etc. And since it’s based on .NET Core, it’s cross-platform allowing you to deploy on\nLinux or Windows.', 'task_item': False}, {'text': 'The previous diagrams showing custom API Gateways running in containers are precisely how you can\nalso run Ocelot in a container and microservice-based application.', 'task_item': False}, {'text': 'In addition, there are many other products in the market offering API Gateways features, such as\nApigee, Kong, MuleSoft, WSO2, and other products like Linkerd and Istio for service mesh ingress\ncontroller features.', 'task_item': False}, {'text': 'After the initial architecture and patterns explanation sections, the next sections explain how to\n[implement API Gateways with Ocelot.](https://github.com/ThreeMammals/Ocelot)', 'task_item': False}], [{'text': 'The most important drawback is that when you implement an API Gateway, you’re coupling\nthat tier with the internal microservices. Coupling like this might introduce serious difficulties\nfor your application. Clemens Vaster, architect at the Azure Service Bus team, refers to this\n[potential difficulty as “the new ESB” in the “Messaging and Microservices” session at GOTO](https://www.youtube.com/watch?v=rXi5CLjIQ9k)\n2016.', 'task_item': False}, {'text': 'Using a microservices API Gateway creates an additional possible single point of failure.', 'task_item': False}, {'text': 'An API Gateway can introduce increased response time due to the additional network call.\nHowever, this extra call usually has less impact than having a client interface that’s too chatty\ndirectly calling the internal microservices.', 'task_item': False}, {'text': 'If not scaled out properly, the API Gateway can become a bottleneck.', 'task_item': False}, {'text': 'An API Gateway requires additional development cost and future maintenance if it includes\ncustom logic and data aggregation. Developers must update the API Gateway in order to\nexpose each microservice’s endpoints. Moreover, implementation changes in the internal\nmicroservices might cause code changes at the API Gateway level. However, if the API\nGateway is just applying security, logging, and versioning (as when using Azure API\nManagement), this additional development cost might not apply.', 'task_item': False}, {'text': '47 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': 'If the API Gateway is developed by a single team, there can be a development bottleneck. This\naspect is another reason why a better approach is to have several fined-grained API Gateways\nthat respond to different client needs. You could also segregate the API Gateway internally\ninto multiple areas or layers that are owned by the different teams working on the internal\nmicroservices.', 'task_item': False}], [{'text': '**Chris Richardson. Pattern: API Gateway / Backend for Front-End**\n[https://microservices.io/patterns/apigateway.html](https://microservices.io/patterns/apigateway.html)', 'task_item': False}, {'text': '**API Gateway pattern**\n[https://learn.microsoft.com/azure/architecture/microservices/gateway](https://docs.microsoft.com/azure/architecture/microservices/gateway)', 'task_item': False}, {'text': '**Aggregation and composition pattern**\n[https://microservices.io/patterns/data/api-composition.html](https://microservices.io/patterns/data/api-composition.html)', 'task_item': False}, {'text': '**Azure API Management**\n[https://azure.microsoft.com/services/api-management/](https://azure.microsoft.com/services/api-management/)', 'task_item': False}, {'text': '**Udi Dahan. Service Oriented Composition**\n[https://udidahan.com/2014/07/30/service-oriented-composition-with-video/](https://udidahan.com/2014/07/30/service-oriented-composition-with-video/)', 'task_item': False}, {'text': '**Clemens Vasters. Messaging and Microservices at GOTO 2016 (video)**\n[https://www.youtube.com/watch?v=rXi5CLjIQ9k](https://www.youtube.com/watch?v=rXi5CLjIQ9k)', 'task_item': False}, {'text': '**API Gateway in a Nutshell** (ASP.NET Core API Gateway Tutorial Series)\n[https://www.pogsdotnet.com/2018/08/api-gateway-in-nutshell.html](https://www.pogsdotnet.com/2018/08/api-gateway-in-nutshell.html)', 'task_item': False}], [{'text': 'Synchronous protocol. HTTP is a synchronous protocol. The client sends a request and waits\nfor a response from the service. That’s independent of the client code execution that could be\nsynchronous (thread is blocked) or asynchronous (thread isn’t blocked, and the response will\nreach a callback eventually). The important point here is that the protocol (HTTP/HTTPS) is\nsynchronous and the client code can only continue its task when it receives the HTTP server\nresponse.', 'task_item': False}, {'text': 'Asynchronous protocol. Other protocols like AMQP (a protocol supported by many operating\nsystems and cloud environments) use asynchronous messages. The client code or message\nsender usually doesn’t wait for a response. It just sends the message as when sending a\nmessage to a RabbitMQ queue or any other message broker.', 'task_item': False}, {'text': 'The second axis defines if the communication has a single receiver or multiple receivers:', 'task_item': False}, {'text': 'Single receiver. Each request must be processed by exactly one receiver or service. An\n[example of this communication is the Command pattern.](https://en.wikipedia.org/wiki/Command_pattern)', 'task_item': False}, {'text': 'Multiple receivers. Each request can be processed by zero to multiple receivers. This type of\n[communication must be asynchronous. An example is the publish/subscribe mechanism used](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)\n[in patterns like Event-driven architecture. This is based on an event-bus interface or message](https://microservices.io/patterns/data/event-driven-architecture.html)\nbroker when propagating data updates between multiple microservices through events; it’s\n[usually implemented through a service bus or similar artifact like Azure Service Bus by using](https://azure.microsoft.com/services/service-bus/)\n[topics and subscriptions.](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)', 'task_item': False}, {'text': '49 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': 'A microservice-based application will often use a combination of these communication styles. The\nmost common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS\nwhen invoking a regular Web API HTTP service. Microservices also typically use messaging protocols\nfor asynchronous communication between microservices.', 'task_item': False}, {'text': 'These axes are good to know so you have clarity on the possible communication mechanisms, but\nthey’re not the important concerns when building microservices. Neither the asynchronous nature of\nclient thread execution nor the asynchronous nature of the selected protocol are the important points\nwhen integrating microservices. What _is_ important is being able to integrate your microservices\nasynchronously while maintaining the independence of microservices, as explained in the following\nsection.', 'task_item': False}], [{'text': '**Martin Fowler. Richardson Maturity Model** A description of the REST model.\n[https://martinfowler.com/articles/richardsonMaturityModel.html](https://martinfowler.com/articles/richardsonMaturityModel.html)', 'task_item': False}, {'text': '**Swagger** The official site.\n[https://swagger.io/](https://swagger.io/)', 'task_item': False}, {'text': '**Push and real-time communication based on HTTP**', 'task_item': False}, {'text': 'Another possibility (usually for different purposes than REST) is a real-time and one-to-many\n[communication with higher-level frameworks such as ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as\n[WebSockets.](https://en.wikipedia.org/wiki/WebSocket)', 'task_item': False}, {'text': 'As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing\ncontent to connected clients as the data becomes available, rather than having the server wait for a\nclient to request new data.', 'task_item': False}, {'text': '53 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': '_Figure 4-17. One-to-many real-time asynchronous message communication_', 'task_item': False}, {'text': 'SignalR is a good way to achieve real-time communication for pushing content to the clients from a\nback-end server. Since communication is in real time, client apps show the changes almost instantly.\nThis is usually handled by a protocol such as WebSockets, using many WebSockets connections (one\nper client). A typical example is when a service communicates a change in the score of a sports game\nto many client web apps simultaneously.', 'task_item': False}], [{'text': 'Using a transactional (DTC-based) queue like MSMQ. (However, this is a legacy approach.)', 'task_item': False}, {'text': 'Using transaction log mining.', 'task_item': False}, {'text': '[Using full Event Sourcing pattern.](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)', 'task_item': False}, {'text': '[Using the Outbox pattern: a transactional database table as a message queue that will be the](https://www.kamilgrzybek.com/design/the-outbox-pattern/)\nbase for an event-creator component that would create the event and publish it.', 'task_item': False}, {'text': 'For a more complete description of the challenges in this space, including how messages with\n[potentially incorrect data can end up being published, see Data platform for mission-critical](https://docs.microsoft.com/azure/architecture/reference-architectures/containers/aks-mission-critical/mission-critical-data-platform#every-message-must-be-processed)\n[workloads on Azure: Every message must be processed.](https://docs.microsoft.com/azure/architecture/reference-architectures/containers/aks-mission-critical/mission-critical-data-platform#every-message-must-be-processed)', 'task_item': False}, {'text': 'Additional topics to consider when using asynchronous communication are message idempotence\nand message deduplication. These topics are covered in the section Implementing event-based\ncommunication between microservices (integration events) later in this guide.', 'task_item': False}], [{'text': '**Event Driven Messaging**\n[https://patterns.arcitura.com/soa-patterns/design_patterns/event_driven_messaging](https://patterns.arcitura.com/soa-patterns/design_patterns/event_driven_messaging)', 'task_item': False}, {'text': '**Publish/Subscribe Channel**\n[https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.](https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)\nhtml', 'task_item': False}, {'text': '**Udi Dahan. Clarified CQRS**\n[https://udidahan.com/2009/12/09/clarified-cqrs/](https://udidahan.com/2009/12/09/clarified-cqrs/)', 'task_item': False}, {'text': '**Command and Query Responsibility Segregation (CQRS)**\n[https://learn.microsoft.com/azure/architecture/patterns/cqrs](https://docs.microsoft.com/azure/architecture/patterns/cqrs)', 'task_item': False}, {'text': '**Communicating Between Bounded Contexts**\n[https://learn.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)](https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10))', 'task_item': False}, {'text': '**Eventual consistency**\n[https://en.wikipedia.org/wiki/Eventual_consistency](https://en.wikipedia.org/wiki/Eventual_consistency)', 'task_item': False}, {'text': '**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling**\n[https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)', 'task_item': False}, {'text': '58 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}], [{'text': '**Scott Hanselman. ASP.NET Core RESTful Web API versioning made easy**\n[https://www.hanselman.com/blog/ASPNETCoreRESTfulWebAPIVersioningMadeEasy.aspx](https://www.hanselman.com/blog/ASPNETCoreRESTfulWebAPIVersioningMadeEasy.aspx)', 'task_item': False}, {'text': '**Versioning a RESTful web API**\n[https://learn.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-](https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api)\n[restful-web-api](https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api)', 'task_item': False}, {'text': '**Roy Fielding. Versioning, Hypermedia, and REST**\n[https://www.infoq.com/articles/roy-fielding-on-versioning](https://www.infoq.com/articles/roy-fielding-on-versioning)', 'task_item': False}, {'text': '59 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}], [{'text': '**Chris Richardson. Pattern: Service registry**\n[https://microservices.io/patterns/service-registry.html](https://microservices.io/patterns/service-registry.html)', 'task_item': False}, {'text': '**Auth0. The Service Registry**\n[https://auth0.com/blog/an-introduction-to-microservices-part-3-the-service-registry/](https://auth0.com/blog/an-introduction-to-microservices-part-3-the-service-registry/)', 'task_item': False}, {'text': '**Gabriel Schenker. Service discovery**\n[https://lostechies.com/gabrielschenker/2016/01/27/service-discovery/](https://lostechies.com/gabrielschenker/2016/01/27/service-discovery/)', 'task_item': False}], [{'text': '**Micro Frontends (Martin Fowler’s blog)**\n[https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html)', 'task_item': False}, {'text': '**Micro Frontends (Michael Geers site)**\n[https://micro-frontends.org/](https://micro-frontends.org/)', 'task_item': False}, {'text': '**Composite UI using ASP.NET (Particular’s Workshop)**\n[https://github.com/Particular/Workshop/tree/master/demos/asp-net-core](https://github.com/Particular/Workshop/tree/master/demos/asp-net-core)', 'task_item': False}, {'text': '**Ruben Oostinga. The Monolithic Frontend in the Microservices Architecture**\n[https://xebia.com/blog/the-monolithic-frontend-in-the-microservices-architecture/](https://xebia.com/blog/the-monolithic-frontend-in-the-microservices-architecture/)', 'task_item': False}, {'text': '62 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': '**Mauro Servienti. The secret of better UI composition**\n[https://particular.net/blog/secret-of-better-ui-composition](https://particular.net/blog/secret-of-better-ui-composition)', 'task_item': False}, {'text': '**Viktor Farcic. Including Front-End Web Components Into Microservices**\n[https://technologyconversations.com/2015/08/09/including-front-end-web-components-](https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/)\n[into-microservices/](https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/)', 'task_item': False}, {'text': '**Managing Frontend in the Microservices Architecture**\n[https://allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html](https://allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html)', 'task_item': False}], [{'text': '**Liveness** : Checks if the microservice is alive, that is, if it’s able to accept requests and respond.', 'task_item': False}, {'text': '**Readiness** : Checks if the microservice’s dependencies (Database, queue services, etc.) are\nthemselves ready, so the microservice can do what it’s supposed to do.', 'task_item': False}, {'text': '**Using diagnostics and logs event streams**', 'task_item': False}, {'text': 'Logs provide information about how an application or service is running, including exceptions,\nwarnings, and simple informational messages. Usually, each log is in a text format with one line per\nevent, although exceptions also often show the stack trace across multiple lines.', 'task_item': False}, {'text': 'In monolithic server-based applications, you can write logs to a file on disk (a logfile) and then analyze\nit with any tool. Since application execution is limited to a fixed server or VM, it generally isn’t too\ncomplex to analyze the flow of events. However, in a distributed application where multiple services\nare executed across many nodes in an orchestrator cluster, being able to correlate distributed events\nis a challenge.', 'task_item': False}, {'text': 'A microservice-based application should not try to store the output stream of events or logfiles by\nitself, and not even try to manage the routing of the events to a central place. It should be\ntransparent, meaning that each process should just write its event stream to a standard output that\nunderneath will be collected by the execution environment infrastructure where it’s running. An\n[example of these event stream routers is Microsoft.Diagnostic.EventFlow, which collects event streams](https://github.com/Azure/diagnostics-eventflow)\nfrom multiple sources and publishes it to output systems. These can include simple standard output\n[for a development environment or cloud systems like Azure Monitor](https://azure.microsoft.com/services/monitor/) [and Azure Diagnostics. There are](https://docs.microsoft.com/azure/azure-monitor/platform/diagnostics-extension-overview)\nalso good third-party log analysis platforms and tools that can search, alert, report, and monitor logs,\n[even in real time, like Splunk.](https://www.splunk.com/goto/Splunk_Log_Management?ac=ga_usa_log_analysis_phrase_Mar17&_kk=logs%20analysis&gclid=CNzkzIrex9MCFYGHfgodW5YOtA)', 'task_item': False}, {'text': '64 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': '**Orchestrators managing health and diagnostics information**', 'task_item': False}, {'text': 'When you create a microservice-based application, you need to deal with complexity. Of course, a\nsingle microservice is simple to deal with, but dozens or hundreds of types and thousands of\ninstances of microservices is a complex problem. It isn’t just about building your microservice\narchitecture—you also need high availability, addressability, resiliency, health, and diagnostics if you\nintend to have a stable and cohesive system.', 'task_item': False}, {'text': '_Figure 4-22. A Microservice Platform is fundamental for an application’s health management_', 'task_item': False}, {'text': 'The complex problems shown in Figure 4-22 are hard to solve by yourself. Development teams should\nfocus on solving business problems and building custom applications with microservice-based\napproaches. They should not focus on solving complex infrastructure problems; if they did, the cost of\nany microservice-based application would be huge. Therefore, there are microservice-oriented\nplatforms, referred to as orchestrators or microservice clusters, that try to solve the hard problems of\nbuilding and running a service and using infrastructure resources efficiently. This approach reduces\nthe complexities of building applications that use a microservices approach.', 'task_item': False}, {'text': 'Different orchestrators might sound similar, but the diagnostics and health checks offered by each of\nthem differ in features and state of maturity, sometimes depending on the OS platform, as explained\nin the next section.', 'task_item': False}], [{'text': '**The Twelve-Factor App. XI. Logs: Treat logs as event streams**\n[https://12factor.net/logs](https://12factor.net/logs)', 'task_item': False}, {'text': '**Microsoft Diagnostic EventFlow Library** GitHub repo.\n[https://github.com/Azure/diagnostics-eventflow](https://github.com/Azure/diagnostics-eventflow)', 'task_item': False}, {'text': '**What is Azure Diagnostics**\n[https://learn.microsoft.com/azure/azure-diagnostics](https://docs.microsoft.com/azure/azure-diagnostics)', 'task_item': False}, {'text': '65 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': '**Connect Windows computers to the Azure Monitor service**\n[https://learn.microsoft.com/azure/azure-monitor/platform/agent-windows](https://docs.microsoft.com/azure/azure-monitor/platform/agent-windows)', 'task_item': False}, {'text': '**Logging What You Mean: Using the Semantic Logging Application Block**\n[https://learn.microsoft.com/previous-versions/msp-n-p/dn440729(v=pandp.60)](https://docs.microsoft.com/previous-versions/msp-n-p/dn440729(v=pandp.60))', 'task_item': False}, {'text': '**Splunk** Official site.\n[https://www.splunk.com/](https://www.splunk.com/)', 'task_item': False}, {'text': '**EventSource Class** API for events tracing for Windows (ETW)\n[https://learn.microsoft.com/dotnet/api/system.diagnostics.tracing.eventsource](https://docs.microsoft.com/dotnet/api/system.diagnostics.tracing.eventsource)', 'task_item': False}], [{'text': '**Getting started with Azure Kubernetes Service (AKS)**\n[https://learn.microsoft.com/azure/aks/kubernetes-walkthrough-portal](https://docs.microsoft.com/azure/aks/kubernetes-walkthrough-portal)', 'task_item': False}, {'text': '**Azure Dev Spaces**\n[https://learn.microsoft.com/azure/dev-spaces/azure-dev-spaces](https://docs.microsoft.com/azure/dev-spaces/azure-dev-spaces)', 'task_item': False}, {'text': '**Kubernetes** The official site.\n[https://kubernetes.io/](https://kubernetes.io/)', 'task_item': False}, {'text': '71 CHAPTER 3 | Architecting container and microservice-based applications', 'task_item': False}, {'text': '**CHAPTER**', 'task_item': False}], [{'text': '**Visual Studio** . Official site.\n[https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/?utm_medium=microsoft&utm_source=learn.microsoft.com&utm_campaign=inline+link)', 'task_item': False}, {'text': '**Visual Studio Code** . Official site.\n[https://code.visualstudio.com/download](https://code.visualstudio.com/download)', 'task_item': False}, {'text': '**Docker Desktop for Windows**\n[https://hub.docker.com/editions/community/docker-ce-desktop-windows](https://hub.docker.com/editions/community/docker-ce-desktop-windows)', 'task_item': False}, {'text': '**Docker Desktop for Mac**\n[https://hub.docker.com/editions/community/docker-ce-desktop-mac](https://hub.docker.com/editions/community/docker-ce-desktop-mac)', 'task_item': False}], [{'text': 'An operating system selection, for example, a Linux distribution, Windows Nano Server, or\nWindows Server Core.', 'task_item': False}, {'text': 'Files added during development, for example, source code and application binaries.', 'task_item': False}, {'text': 'Configuration information, such as environment settings and dependencies.', 'task_item': False}], [{'text': '**Get started with Docker Desktop for Windows**\n[https://docs.docker.com/docker-for-windows/](https://docs.docker.com/docker-for-windows/)', 'task_item': False}, {'text': '**Visual Studio 2022**\n[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)', 'task_item': False}], [{'text': '**Building Docker Images for ASP.NET Core Applications**\n[https://learn.microsoft.com/dotnet/core/docker/building-net-docker-images](https://docs.microsoft.com/aspnet/core/host-and-deploy/docker/building-net-docker-images)', 'task_item': False}, {'text': '78 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}, {'text': '**Build your own image** . In the official Docker documentation.\n[https://docs.docker.com/engine/tutorials/dockerimages/](https://docs.docker.com/engine/tutorials/dockerimages/)', 'task_item': False}, {'text': '**Staying up-to-date with .NET Container Images**\n[https://devblogs.microsoft.com/dotnet/staying-up-to-date-with-net-container-images/](https://devblogs.microsoft.com/dotnet/staying-up-to-date-with-net-container-images/)', 'task_item': False}, {'text': '**Using .NET and Docker Together - DockerCon 2018 Update**\n[https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2018-](https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2018-update/)\nupdate/', 'task_item': False}, {'text': '**Using multi-arch image repositories**', 'task_item': False}, {'text': 'A single repo can contain platform variants, such as a Linux image and a Windows image. This feature\nallows vendors like Microsoft (base image creators) to create a single repo to cover multiple platforms\n[(that is Linux and Windows). For example, the .NET](https://hub.docker.com/_/microsoft-dotnet/) repository available in the Docker Hub registry\nprovides support for Linux and Windows Nano Server by using the same repo name.', 'task_item': False}, {'text': 'If you specify a tag, targeting a platform that is explicit like in the following cases:', 'task_item': False}, {'text': 'mcr.microsoft.com/dotnet/aspnet:7.0-bullseye-slim\nTargets: .NET 7 runtime-only on Linux', 'task_item': False}, {'text': 'mcr.microsoft.com/dotnet/aspnet:7.0-nanoserver-ltsc2022\nTargets: .NET 7 runtime-only on Windows Nano Server', 'task_item': False}, {'text': 'But, if you specify the same image name, even with the same tag, the multi-arch images (like the\naspnet image) will use the Linux or Windows version depending on the Docker host OS you’re\ndeploying, as shown in the following example:', 'task_item': False}, {'text': 'mcr.microsoft.com/dotnet/aspnet:7.0\nMulti-arch: .NET 7 runtime-only on Linux or Windows Nano Server depending on the Docker\nhost OS', 'task_item': False}, {'text': 'This way, when you pull an image from a Windows host, it will pull the Windows variant, and pulling\nthe same image name from a Linux host will pull the Linux variant.', 'task_item': False}, {'text': '**Multi-stage builds in Dockerfile**', 'task_item': False}, {'text': 'The Dockerfile is similar to a batch script. Similar to what you would do if you had to set up the\nmachine from the command line.', 'task_item': False}, {'text': 'It starts with a base image that sets up the initial context, it’s like the startup filesystem, that sits on\ntop of the host OS. It’s not an OS, but you can think of it like “the” OS inside the container.', 'task_item': False}, {'text': 'The execution of every command line creates a new layer on the filesystem with the changes from the\nprevious one, so that, when combined, produce the resulting filesystem.', 'task_item': False}, {'text': 'Since every new layer “rests” on top of the previous one and the resulting image size increases with\nevery command, images can get very large if they have to include, for example, the SDK needed to\nbuild and publish an application.', 'task_item': False}, {'text': 'This is where multi-stage builds get into the plot (from Docker 17.05 and higher) to do their magic.', 'task_item': False}, {'text': '79 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}, {'text': 'The core idea is that you can separate the Dockerfile execution process in stages, where a stage is an\ninitial image followed by one or more commands, and the last stage determines the final image size.', 'task_item': False}, {'text': 'In short, multi-stage builds allow splitting the creation in different “phases” and then assemble the\nfinal image taking only the relevant directories from the intermediate stages. The general strategy to\nuse this feature is:', 'task_item': False}, {'text': '1. Use a base SDK image (doesn’t matter how large), with everything needed to build and\npublish the application to a folder and then', 'task_item': False}, {'text': '2. Use a base, small, runtime-only image and copy the publishing folder from the previous stage\nto produce a small final image.', 'task_item': False}, {'text': 'Probably the best way to understand multi-stage is going through a Dockerfile in detail, line by line,\nso let’s begin with the initial Dockerfile created by Visual Studio when adding Docker support to a\nproject and will get into some optimizations later.', 'task_item': False}, {'text': 'The initial Dockerfile might look something like this:', 'task_item': False}, {'text': 'And these are the details, line by line:', 'task_item': False}, {'text': '**Line #1:** Begin a stage with a “small” runtime-only base image, call it **base** for reference.', 'task_item': False}, {'text': '**Line #2:** Create the **/app** directory in the image.', 'task_item': False}, {'text': '**Line #3:** Expose port **80** .', 'task_item': False}, {'text': '80 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}, {'text': '**Line #5:** Begin a new stage with the “large” image for building/publishing. Call it **build** for\nreference.', 'task_item': False}, {'text': '**Line #6:** Create directory **/src** in the image.', 'task_item': False}, {'text': '**Line #7:** Up to line 16, copy referenced **.csproj** project files to be able to restore packages\nlater.', 'task_item': False}, {'text': '**Line #17:** Restore packages for the **Catalog.API** project and the referenced projects.', 'task_item': False}, {'text': '**Line #18:** Copy **all directory tree for the solution** (except the files/directories included in the\n**.dockerignore** file) to the **/src** directory in the image.', 'task_item': False}, {'text': '**Line #19:** Change the current folder to the **Catalog.API** project.', 'task_item': False}, {'text': '**Line #20:** Build the project (and other project dependencies) and output to the **/app**\ndirectory in the image.', 'task_item': False}, {'text': '**Line #22:** Begin a new stage continuing from the build. Call it **publish** for reference.', 'task_item': False}, {'text': '**Line #23:** Publish the project (and dependencies) and output to the **/app** directory in the\nimage.', 'task_item': False}, {'text': '**Line #25:** Begin a new stage continuing from **base** and call it **final** .', 'task_item': False}, {'text': '**Line #26:** Change the current directory to **/app** .', 'task_item': False}, {'text': '**Line #27:** Copy the **/app** directory from stage **publish** to the current directory.', 'task_item': False}, {'text': '**Line #28:** Define the command to run when the container is started.', 'task_item': False}, {'text': 'Now let’s explore some optimizations to improve the whole process performance that, in the case of\neShopOnContainers, means about 22 minutes or more to build the complete solution in Linux\ncontainers.', 'task_item': False}, {'text': 'You’ll take advantage of Docker’s layer cache feature, which is quite simple: if the base image and the\ncommands are the same as some previously executed, it can just use the resulting layer without the\nneed to execute the commands, thus saving some time.', 'task_item': False}, {'text': 'So, let’s focus on the **build** stage, lines 5-6 are mostly the same, but lines 7-17 are different for every\nservice from eShopOnContainers, so they have to execute every single time, however if you changed\nlines 7-16 to:', 'task_item': False}], [{'text': 'Uses a pre-built eshop/web:latest image. However, you could also configure the image to be\nbuilt as part of the docker-compose execution with an additional configuration based on a\nbuild: section in the docker-compose file.', 'task_item': False}, {'text': 'Initializes two environment variables (CatalogUrl and OrderingUrl).', 'task_item': False}, {'text': 'Forwards the exposed port 80 on the container to the external port 80 on the host machine.', 'task_item': False}, {'text': 'Links the web app to the catalog and ordering service with the depends_on setting. This\ncauses the service to wait until those services are started.', 'task_item': False}, {'text': 'We will revisit the docker-compose.yml file in a later section when we cover how to implement\nmicroservices and multi-container apps.', 'task_item': False}, {'text': '**Working with docker-compose.yml in Visual Studio 2022**', 'task_item': False}, {'text': 'Besides adding a Dockerfile to a project, as we mentioned before, Visual Studio 2017 (from version\n15.8 on) can add orchestrator support for Docker Compose to a solution.', 'task_item': False}, {'text': 'When you add container orchestrator support, as shown in Figure 5-7, for the first time, Visual Studio\ncreates the Dockerfile for the project and creates a new (service section) project in your solution with', 'task_item': False}, {'text': '85 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}, {'text': 'several global docker-compose*.yml files, and then adds the project to those files. You can then open\nthe docker-compose.yml files and update them with additional features.', 'task_item': False}, {'text': 'Repeat this operation for every project you want to include in the docker-compose.yml file.', 'task_item': False}, {'text': 'At the time of this writing, Visual Studio supports **Docker Compose** orchestrators.', 'task_item': False}, {'text': '_Figure 5-7. Adding Docker support in Visual Studio 2022 by right-clicking an ASP.NET Core project_', 'task_item': False}, {'text': 'After you add orchestrator support to your solution in Visual Studio, you will also see a new node (in\nthe docker-compose.dcproj project file) in Solution Explorer that contains the added dockercompose.yml files, as shown in Figure 5-8.', 'task_item': False}, {'text': '_Figure 5-8. The docker-compose tree node added in Visual Studio 2022 Solution Explorer_', 'task_item': False}, {'text': 'You could deploy a multi-container application with a single docker-compose.yml file by using the\ndocker-compose up command. However, Visual Studio adds a group of them so you can override\nvalues depending on the environment (development or production) and execution type (release or\ndebug). This capability will be explained in later sections.', 'task_item': False}, {'text': '86 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}], [{'text': '**Deploy an ASP.NET container to a remote Docker host**\n[https://learn.microsoft.com/visualstudio/containers/hosting-web-apps-in-docker](https://docs.microsoft.com/visualstudio/containers/hosting-web-apps-in-docker)', 'task_item': False}, {'text': '**A note about testing and deploying with orchestrators**', 'task_item': False}, {'text': 'The docker-compose up and docker run commands (or running and debugging the containers in\nVisual Studio) are adequate for testing containers in your development environment. But you should\nnot use this approach for production deployments, where you should target orchestrators like\n[Kubernetes](https://kubernetes.io/) [or Service Fabric. If you’re using Kubernetes, you have to use pods](https://azure.microsoft.com/services/service-fabric/) to organize containers\n[and services](https://kubernetes.io/docs/concepts/services-networking/service/) [to network them. You also use deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) to organize pod creation and modification.', 'task_item': False}], [{'text': '**Quickstart: Docker in Visual Studio.**\n[https://learn.microsoft.com/visualstudio/containers/container-tools](https://docs.microsoft.com/visualstudio/containers/container-tools)', 'task_item': False}, {'text': '**Debugging apps in a local Docker container**\n[https://learn.microsoft.com/visualstudio/containers/edit-and-refresh](https://docs.microsoft.com/visualstudio/containers/edit-and-refresh)', 'task_item': False}], [{'text': '**aspnet-docker/Dockerfile.** Example PowerShell commands to run from dockerfiles to\ninclude Windows features.', 'task_item': False}, {'text': '91 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}, {'text': '[https://github.com/Microsoft/aspnet-docker/blob/master/4.7.1-windowsservercore-](https://github.com/Microsoft/aspnet-docker/blob/master/4.7.1-windowsservercore-ltsc2016/runtime/Dockerfile)\n[ltsc2016/runtime/Dockerfile](https://github.com/Microsoft/aspnet-docker/blob/master/4.7.1-windowsservercore-ltsc2016/runtime/Dockerfile)', 'task_item': False}, {'text': '92 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}, {'text': '**CHAPTER**', 'task_item': False}], [{'text': 'Presentation components. These components are responsible for handling the UI and\nconsuming remote services.', 'task_item': False}, {'text': 'Domain or business logic. This component is the application’s domain logic.', 'task_item': False}, {'text': 'Database access logic. This component consists of data access components responsible for\naccessing databases (SQL or NoSQL).', 'task_item': False}, {'text': 'Application integration logic. This component includes a messaging channel, based on\nmessage brokers.', 'task_item': False}, {'text': 'The application will require high scalability, while allowing its vertical subsystems to scale out\nautonomously, because certain subsystems will require more scalability than others.', 'task_item': False}, {'text': 'The application must be able to be deployed in multiple infrastructure environments (multiple public\nclouds and on-premises) and ideally should be cross-platform, able to move from Linux to Windows\n(or vice versa) easily.', 'task_item': False}], [{'text': 'You have multiple dev teams focusing on different business areas of the application.', 'task_item': False}, {'text': 'New team members must become productive quickly, and the application must be easy to\nunderstand and modify.', 'task_item': False}, {'text': 'The application will have a long-term evolution and ever-changing business rules.', 'task_item': False}, {'text': 'You need good long-term maintainability, which means having agility when implementing\nnew changes in the future while being able to update multiple subsystems with minimum\nimpact on the other subsystems.', 'task_item': False}, {'text': 'You want to practice continuous integration and continuous deployment of the application.', 'task_item': False}, {'text': 'You want to take advantage of emerging technologies (frameworks, programming languages,\netc.) while evolving the application. You do not want to make full migrations of the\napplication when moving to new technologies, because that would result in high costs and\nimpact the predictability and stability of the application.', 'task_item': False}], [{'text': 'Http client-to-microservice communication through API Gateways. This approach is used for\nqueries and when accepting update or transactional commands from the client apps. The\napproach using API Gateways is explained in detail in later sections.', 'task_item': False}, {'text': 'Asynchronous event-based communication. This communication occurs through an event bus\nto propagate updates across microservices or to integrate with external applications. The\nevent bus can be implemented with any messaging-broker infrastructure technology like\nRabbitMQ, or using higher-level (abstraction-level) service buses like Azure Service Bus,\nNServiceBus, MassTransit, or Brighter.', 'task_item': False}, {'text': 'The application is deployed as a set of microservices in the form of containers. Client apps can\ncommunicate with those microservices running as containers through the public URLs published by\nthe API Gateways.', 'task_item': False}, {'text': '96 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '**Data sovereignty per microservice**', 'task_item': False}, {'text': 'In the sample application, each microservice owns its own database or data source, although all SQL\nServer databases are deployed as a single container. This design decision was made only to make it\neasy for a developer to get the code from GitHub, clone it, and open it in Visual Studio or Visual\nStudio Code. Or alternatively, it makes it easy to compile the custom Docker images using the .NET\nCLI and the Docker CLI, and then deploy and run them in a Docker development environment. Either\nway, using containers for data sources lets developers build and deploy in a matter of minutes without\nhaving to provision an external database or any other data source with hard dependencies on\ninfrastructure (cloud or on-premises).', 'task_item': False}, {'text': 'In a real production environment, for high availability and for scalability, the databases should be\nbased on database servers in the cloud or on-premises, but not in containers.', 'task_item': False}, {'text': 'Therefore, the units of deployment for microservices (and even for databases in this application) are\nDocker containers, and the reference application is a multi-container application that embraces\nmicroservices principles.', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**eShopOnContainers GitHub repo. Source code for the reference application**\n[https://aka.ms/eShopOnContainers/](https://aka.ms/eShopOnContainers/)', 'task_item': False}], [{'text': 'It is easy for a developer to understand and get started quickly with good productivity.', 'task_item': False}, {'text': 'Containers start fast, which makes developers more productive.', 'task_item': False}, {'text': 'An IDE like Visual Studio can load smaller projects fast, making developers productive.', 'task_item': False}, {'text': 'Each microservice can be designed, developed, and deployed independently of other\nmicroservices, which provide agility because it is easier to deploy new versions of\nmicroservices frequently.', 'task_item': False}, {'text': '**It is possible to scale out individual areas of the application** . For instance, the catalog service or\nthe basket service might need to be scaled out, but not the ordering process. A microservices\ninfrastructure will be much more efficient with regard to the resources used when scaling out than a\nmonolithic architecture would be.', 'task_item': False}, {'text': '**You can divide the development work between multiple teams** . Each service can be owned by a\nsingle development team. Each team can manage, develop, deploy, and scale their service\nindependently of the rest of the teams.', 'task_item': False}, {'text': '**Issues are more isolated** . If there is an issue in one service, only that service is initially impacted\n(except when the wrong design is used, with direct dependencies between microservices), and other\nservices can continue to handle requests. In contrast, one malfunctioning component in a monolithic', 'task_item': False}, {'text': '97 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'deployment architecture can bring down the entire system, especially when it involves resources, such\nas a memory leak. Additionally, when an issue in a microservice is resolved, you can deploy just the\naffected microservice without impacting the rest of the application.', 'task_item': False}, {'text': '**You can use the latest technologies** . Because you can start developing services independently and\nrun them side by side (thanks to containers and .NET), you can start using the latest technologies and\nframeworks expediently instead of being stuck on an older stack or framework for the whole\napplication.', 'task_item': False}], [{'text': 'Simple CRUD, single-tier, single-layer.', 'task_item': False}, {'text': '100 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '[Traditional N-Layered.](https://docs.microsoft.com/previous-versions/msp-n-p/ee658109(v=pandp.10))', 'task_item': False}, {'text': '[Domain-Driven Design N-layered.](https://devblogs.microsoft.com/cesardelatorre/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/)', 'task_item': False}, {'text': '[Clean Architecture (as used with eShopOnWeb)](https://docs.microsoft.com/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures#clean-architecture)', 'task_item': False}, {'text': '[Command and Query Responsibility Segregation](https://martinfowler.com/bliki/CQRS.html) (CQRS).', 'task_item': False}, {'text': '[Event-Driven Architecture (EDA).](https://en.wikipedia.org/wiki/Event-driven_architecture)', 'task_item': False}, {'text': 'You can also build microservices with many technologies and languages, such as ASP.NET Core Web\nAPIs, NancyFx, ASP.NET Core SignalR (available with .NET Core 2 or later), F#, Node.js, Python, Java,\nC++, GoLang, and more.', 'task_item': False}, {'text': 'The important point is that no particular architecture pattern or style, nor any particular technology, is\nright for all situations. Figure 6-3 shows some approaches and technologies (although not in any\nparticular order) that could be used in different microservices.', 'task_item': False}, {'text': '_Figure 6-3. Multi-architectural patterns and the polyglot microservices world_', 'task_item': False}, {'text': 'Multi-architectural pattern and polyglot microservices means you can mix and match languages and\ntechnologies to the needs of each microservice and still have them talking to each other. As shown in\nFigure 6-3, in applications composed of many microservices (Bounded Contexts in domain-driven\ndesign terminology, or simply “subsystems” as autonomous microservices), you might implement\neach microservice in a different way. Each might have a different architecture pattern and use different\nlanguages and databases depending on the application’s nature, business requirements, and\npriorities. In some cases, the microservices might be similar. But that is not usually the case, because\neach subsystem’s context boundary and requirements are usually different.', 'task_item': False}, {'text': '101 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'For instance, for a simple CRUD maintenance application, it might not make sense to design and\nimplement DDD patterns. But for your core domain or core business, you might need to apply more\nadvanced patterns to tackle business complexity with ever-changing business rules.', 'task_item': False}, {'text': 'Especially when you deal with large applications composed by multiple subsystems, you should not\napply a single top-level architecture based on a single architecture pattern. For instance, CQRS should\nnot be applied as a top-level architecture for a whole application, but might be useful for a specific set\nof services.', 'task_item': False}, {'text': 'There is no silver bullet or a right architecture pattern for every given case. You cannot have “one\narchitecture pattern to rule them all.” Depending on the priorities of each microservice, you must\nchoose a different approach for each, as explained in the following sections.', 'task_item': False}], [{'text': '**Querying Data**\n[https://learn.microsoft.com/ef/core/querying/index](https://docs.microsoft.com/ef/core/querying/index)', 'task_item': False}, {'text': '**Saving Data**\n[https://learn.microsoft.com/ef/core/saving/index](https://docs.microsoft.com/ef/core/saving/index)', 'task_item': False}], [{'text': 'URI versioning', 'task_item': False}, {'text': 'Query string versioning', 'task_item': False}, {'text': 'Header versioning', 'task_item': False}, {'text': 'Query string and URI versioning are the simplest to implement. Header versioning is a good\napproach. However, header versioning is not as explicit and straightforward as URI versioning.\nBecause URL versioning is the simplest and most explicit, the eShopOnContainers sample application\nuses URI versioning.', 'task_item': False}, {'text': '110 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'With URI versioning, as in the eShopOnContainers sample application, each time you modify the Web\nAPI or change the schema of resources, you add a version number to the URI for each resource.\nExisting URIs should continue to operate as before, returning resources that conform to the schema\nthat matches the requested version.', 'task_item': False}, {'text': 'As shown in the following code example, the version can be set by using the Route attribute in the\nWeb API controller, which makes the version explicit in the URI (v1 in this case).', 'task_item': False}, {'text': 'This versioning mechanism is simple and depends on the server routing the request to the\nappropriate endpoint. However, for a more sophisticated versioning and the best method when using\n[REST, you should use hypermedia and implement HATEOAS (Hypertext as the Engine of Application](https://docs.microsoft.com/azure/architecture/best-practices/api-design#use-hateoas-to-enable-navigation-to-related-resources)\n[State).](https://docs.microsoft.com/azure/architecture/best-practices/api-design#use-hateoas-to-enable-navigation-to-related-resources)', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**ASP.NET API Versioning** [https://github.com/dotnet/aspnet-api-versioning](https://github.com/dotnet/aspnet-api-versioning)', 'task_item': False}, {'text': '**Scott Hanselman. ASP.NET Core RESTful Web API versioning made easy**\n[https://www.hanselman.com/blog/ASPNETCoreRESTfulWebAPIVersioningMadeEasy.aspx](https://www.hanselman.com/blog/ASPNETCoreRESTfulWebAPIVersioningMadeEasy.aspx)', 'task_item': False}, {'text': '**Versioning a RESTful web API**\n[https://learn.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-](https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api)\n[restful-web-api](https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api)', 'task_item': False}, {'text': '**Roy Fielding. Versioning, Hypermedia, and REST**\n[https://www.infoq.com/articles/roy-fielding-on-versioning](https://www.infoq.com/articles/roy-fielding-on-versioning)', 'task_item': False}], [{'text': '[AutoRest. You can automatically generate .NET client classes for calling Swagger. This tool can](https://github.com/Azure/AutoRest)\nbe used from the CLI and it also integrates with Visual Studio for easy use through the GUI.', 'task_item': False}, {'text': '[Microsoft Flow. You can automatically use and integrate your API](https://flow.microsoft.com/) into a high-level Microsoft\nFlow workflow, with no programming skills required.', 'task_item': False}, {'text': '[Microsoft PowerApps. You can automatically consume your API from PowerApps mobile apps](https://powerapps.microsoft.com/)\n[built with PowerApps Studio, with no programming skills required.](https://powerapps.microsoft.com/build-powerapps/)', 'task_item': False}, {'text': '[Azure App Service Logic Apps. You can automatically use and integrate your API into an Azure](https://docs.microsoft.com/azure/app-service-logic/app-service-logic-what-are-logic-apps)\n[App Service Logic App, with no programming skills required.](https://docs.microsoft.com/azure/app-service-logic/app-service-logic-custom-hosted-api)', 'task_item': False}, {'text': '**Ability to automatically generate API documentation** . When you create large-scale RESTful APIs,\nsuch as complex microservice-based applications, you need to handle many endpoints with different\ndata models used in the request and response payloads. Having proper documentation and having a\nsolid API explorer, as you get with Swagger, is key for the success of your API and adoption by\ndevelopers.', 'task_item': False}, {'text': 'Swagger’s metadata is what Microsoft Flow, PowerApps, and Azure Logic Apps use to understand how\nto use APIs and connect to them.', 'task_item': False}, {'text': 'There are several options to automate Swagger metadata generation for ASP.NET Core REST API\napplications, in the form of functional API help pages, based on _swagger-ui_ .', 'task_item': False}, {'text': '[Probably the best know is Swashbuckle, which is currently used in eShopOnContainers and we’ll cover](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)\n[in some detail in this guide but there’s also the option to use NSwag, which can generate Typescript](https://github.com/RSuter/NSwag)\nand C# API clients, as well as C# controllers, from a Swagger or OpenAPI specification and even by\n[scanning the .dll that contains the controllers, using NSwagStudio.](https://github.com/RSuter/NSwag/wiki/NSwagStudio)', 'task_item': False}, {'text': '**How to automate API Swagger metadata generation with the Swashbuckle NuGet**\n**package**', 'task_item': False}, {'text': 'Generating Swagger metadata manually (in a JSON or YAML file) can be tedious work. However, you\n[can automate API discovery of ASP.NET Web API services by using the Swashbuckle NuGet package to](https://aka.ms/swashbuckledotnetcore)\ndynamically generate Swagger API metadata.', 'task_item': False}, {'text': 'Swashbuckle automatically generates Swagger metadata for your ASP.NET Web API projects. It\nsupports ASP.NET Core Web API projects and the traditional ASP.NET Web API and any other flavor,', 'task_item': False}, {'text': '112 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'such as Azure API App, Azure Mobile App, Azure Service Fabric microservices based on ASP.NET. It\nalso supports plain Web API deployed on containers, as in for the reference application.', 'task_item': False}, {'text': '[Swashbuckle combines API Explorer and Swagger or swagger-ui](https://github.com/swagger-api/swagger-ui) to provide a rich discovery and\ndocumentation experience for your API consumers. In addition to its Swagger metadata generator\nengine, Swashbuckle also contains an embedded version of swagger-ui, which it will automatically\nserve up once Swashbuckle is installed.', 'task_item': False}, {'text': 'This means you can complement your API with a nice discovery UI to help developers to use your API.\nIt requires a small amount of code and maintenance because it is automatically generated, allowing\nyou to focus on building your API. The result for the API Explorer looks like Figure 6-8.', 'task_item': False}, {'text': '_Figure 6-8. Swashbuckle API Explorer based on Swagger metadata—eShopOnContainers catalog microservice_', 'task_item': False}, {'text': 'The Swashbuckle generated Swagger UI API documentation includes all published actions. The API\nexplorer is not the most important thing here. Once you have a Web API that can describe itself in\nSwagger metadata, your API can be used seamlessly from Swagger-based tools, including client\n[proxy-class code generators that can target many platforms. For example, as mentioned, AutoRest](https://github.com/Azure/AutoRest)\n[automatically generates .NET client classes. But additional tools like swagger-codegen are also](https://github.com/swagger-api/swagger-codegen)\navailable, which allow code generation of API client libraries, server stubs, and documentation\nautomatically.', 'task_item': False}, {'text': 'Currently, Swashbuckle consists of five internal NuGet packages under the high-level metapackage\n[Swashbuckle.AspNetCore for ASP.NET Core applications.](https://www.nuget.org/packages/Swashbuckle.AspNetCore)', 'task_item': False}, {'text': 'After you have installed these NuGet packages in your Web API project, you need to configure\nSwagger in the _Program.cs_ class, as in the following **simplified** code:', 'task_item': False}, {'text': '113 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'You previously saw the generated UI created by Swashbuckle for a URL like http://<your-rooturl>/swagger. In Figure 6-9, you can also see how you can test any API method.', 'task_item': False}, {'text': '114 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '_Figure 6-9. Swashbuckle UI testing the Catalog/Items API method_', 'task_item': False}, {'text': 'The Swagger UI API detail shows a sample of the response and can be used to execute the real API,\nwhich is great for developer discovery. Figure 6-10 shows the Swagger JSON metadata generated\nfrom the eShopOnContainers microservice (which is what the tools use underneath) when you request\n[http://<your-root-url>/swagger/v1/swagger.json using Postman.](https://www.getpostman.com/)', 'task_item': False}, {'text': '115 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '_Figure 6-10. Swagger JSON metadata_', 'task_item': False}, {'text': 'It is that simple. And because it is automatically generated, the Swagger metadata will grow when you\nadd more functionality to your API.', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**ASP.NET Web API Help Pages using Swagger**\n[https://learn.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-swagger)', 'task_item': False}, {'text': '**Get started with Swashbuckle and ASP.NET Core**\n[https://learn.microsoft.com/aspnet/core/tutorials/getting-started-with-swashbuckle](https://docs.microsoft.com/aspnet/core/tutorials/getting-started-with-swashbuckle)', 'task_item': False}, {'text': '**Get started with NSwag and ASP.NET Core**\n[https://learn.microsoft.com/aspnet/core/tutorials/getting-started-with-nswag](https://docs.microsoft.com/aspnet/core/tutorials/getting-started-with-nswag)', 'task_item': False}], [{'text': 'It is based on the custom **eshop/catalog-api** image. For simplicity’s sake, there is no\nbuild: key setting in the file. This means that the image must have been previously built (with\ndocker build) or have been downloaded (with the docker pull command) from any Docker\nregistry.', 'task_item': False}, {'text': 'It defines an environment variable named ConnectionString with the connection string to be\nused by Entity Framework to access the SQL Server instance that contains the catalog data\nmodel. In this case, the same SQL Server container is holding multiple databases. Therefore,\nyou need less memory in your development machine for Docker. However, you could also\ndeploy one SQL Server container for each microservice database.', 'task_item': False}, {'text': 'The SQL Server name is **sqldata**, which is the same name used for the container that is\nrunning the SQL Server instance for Linux. This is convenient; being able to use this name\nresolution (internal to the Docker host) will resolve the network address so you don’t need to\nknow the internal IP for the containers you are accessing from other containers.', 'task_item': False}, {'text': 'Because the connection string is defined by an environment variable, you could set that variable\nthrough a different mechanism and at a different time. For example, you could set a different\nconnection string when deploying to production in the final hosts, or by doing it from your CI/CD\npipelines in Azure DevOps Services or your preferred DevOps system.', 'task_item': False}, {'text': 'It exposes port 80 for internal access to the **catalog-api** service within the Docker host. The\nhost is currently a Linux VM because it is based on a Docker image for Linux, but you could\nconfigure the container to run on a Windows image instead.', 'task_item': False}, {'text': 'It forwards the exposed port 80 on the container to port 5101 on the Docker host machine\n(the Linux VM).', 'task_item': False}, {'text': 'It links the web service to the **sqldata** service (the SQL Server instance for Linux database\nrunning in a container). When you specify this dependency, the catalog-api container will not\nstart until the sqldata container has already started; this aspect is important because catalogapi needs to have the SQL Server database up and running first. However, this kind of\ncontainer dependency is not enough in many cases, because Docker checks only at the\ncontainer level. Sometimes the service (in this case SQL Server) might still not be ready, so it is\nadvisable to implement retry logic with exponential backoff in your client microservices. That\nway, if a dependency container is not ready for a short time, the application will still be\nresilient.', 'task_item': False}, {'text': 'It is configured to allow access to external servers: the extra_hosts setting allows you to access\nexternal servers or machines outside of the Docker host (that is, outside the default Linux VM,', 'task_item': False}, {'text': '119 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'which is a development Docker host), such as a local SQL Server instance on your\ndevelopment PC.', 'task_item': False}, {'text': 'There are also other, more advanced docker-compose.yml settings that we’ll discuss in the following\nsections.', 'task_item': False}, {'text': '**Using docker-compose files to target multiple environments**', 'task_item': False}, {'text': 'The docker-compose.*.yml files are definition files and can be used by multiple infrastructures that\nunderstand that format. The most straightforward tool is the docker-compose command.', 'task_item': False}, {'text': 'Therefore, by using the docker-compose command you can target the following main scenarios.', 'task_item': False}, {'text': '**Development environments**', 'task_item': False}, {'text': 'When you develop applications, it is important to be able to run an application in an isolated\ndevelopment environment. You can use the docker-compose CLI command to create that\nenvironment or Visual Studio, which uses docker-compose under the covers.', 'task_item': False}, {'text': 'The docker-compose.yml file allows you to configure and document all your application’s service\ndependencies (other services, cache, databases, queues, etc.). Using the docker-compose CLI\ncommand, you can create and start one or more containers for each dependency with a single\ncommand (docker-compose up).', 'task_item': False}, {'text': 'The docker-compose.yml files are configuration files interpreted by Docker engine but also serve as\nconvenient documentation files about the composition of your multi-container application.', 'task_item': False}, {'text': '**Testing environments**', 'task_item': False}, {'text': 'An important part of any continuous deployment (CD) or continuous integration (CI) process are the\nunit tests and integration tests. These automated tests require an isolated environment so they are\nnot impacted by the users or any other change in the application’s data.', 'task_item': False}, {'text': 'With Docker Compose, you can create and destroy that isolated environment very easily in a few\ncommands from your command prompt or scripts, like the following commands:', 'task_item': False}], [{'text': '_.dockerignore_  - used to ignore files', 'task_item': False}, {'text': '_docker-compose.yml_  - used to compose microservices', 'task_item': False}, {'text': '_docker-compose.override.yml_  - used to configure microservices environment', 'task_item': False}, {'text': 'You can edit the docker-compose files with any editor, like Visual Studio Code or Sublime, and run the\napplication with the docker-compose up command.', 'task_item': False}, {'text': 'By convention, the docker-compose.yml file contains your base configuration and other static\nsettings. That means that the service configuration should not change depending on the deployment\nenvironment you are targeting.', 'task_item': False}, {'text': 'The docker-compose.override.yml file, as its name suggests, contains configuration settings that\noverride the base configuration, such as configuration that depends on the deployment environment.\nYou can have multiple override files with different names also. The override files usually contain\nadditional information needed by the application but specific to an environment or to a deployment.', 'task_item': False}, {'text': '**Targeting multiple environments**', 'task_item': False}, {'text': 'A typical use case is when you define multiple compose files so you can target multiple environments,\nlike production, staging, CI, or development. To support these differences, you can split your\nCompose configuration into multiple files, as shown in Figure 6-12.', 'task_item': False}, {'text': '121 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '_Figure 6-12. Multiple docker-compose files overriding values in the base docker-compose.yml file_', 'task_item': False}, {'text': 'You can combine multiple docker-compose*.yml files to handle different environments. You start with\nthe base docker-compose.yml file. This base file contains the base or static configuration settings that\ndo not change depending on the environment. For example, the eShopOnContainers app has the\nfollowing docker-compose.yml file (simplified with fewer services) as the base file.', 'task_item': False}, {'text': '122 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'The values in the base docker-compose.yml file should not change because of different target\ndeployment environments.', 'task_item': False}, {'text': 'If you focus on the webmvc service definition, for instance, you can see how that information is much\nthe same no matter what environment you might be targeting. You have the following information:', 'task_item': False}, {'text': 'The service name: webmvc.', 'task_item': False}, {'text': 'The container’s custom image: eshop/webmvc.', 'task_item': False}, {'text': 'The command to build the custom Docker image, indicating which Dockerfile to use.', 'task_item': False}, {'text': 'Dependencies on other services, so this container does not start until the other dependency\ncontainers have started.', 'task_item': False}, {'text': 'You can have additional configuration, but the important point is that in the base dockercompose.yml file, you just want to set the information that is common across environments. Then in\nthe docker-compose.override.yml or similar files for production or staging, you should place\nconfiguration that is specific for each environment.', 'task_item': False}, {'text': 'Usually, the docker-compose.override.yml is used for your development environment, as in the\nfollowing example from eShopOnContainers:', 'task_item': False}, {'text': '123 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '124 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'In this example, the development override configuration exposes some ports to the host, defines\nenvironment variables with redirect URLs, and specifies connection strings for the development\nenvironment. These settings are all just for the development environment.', 'task_item': False}, {'text': 'When you run docker-compose up (or launch it from Visual Studio), the command reads the overrides\nautomatically as if it were merging both files.', 'task_item': False}, {'text': 'Suppose that you want another Compose file for the production environment, with different\nconfiguration values, ports, or connection strings. You can create another override file, like file named\ndocker-compose.prod.yml with different settings and environment variables. That file might be stored\nin a different Git repo or managed and secured by a different team.', 'task_item': False}, {'text': '**How to deploy with a specific override file**', 'task_item': False}, {'text': 'To use multiple override files, or an override file with a different name, you can use the -f option with\nthe docker-compose command and specify the files. Compose merges files in the order they are\nspecified on the command line. The following example shows how to deploy with override files.', 'task_item': False}], [{'text': '**Overview of Docker Compose**\n[https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)', 'task_item': False}, {'text': '**Multiple Compose files**\n[https://docs.docker.com/compose/multiple-compose-files/](https://docs.docker.com/compose/multiple-compose-files/)', 'task_item': False}, {'text': '**Building optimized ASP.NET Core Docker images**', 'task_item': False}, {'text': 'If you are exploring Docker and .NET on sources on the Internet, you will find Dockerfiles that\ndemonstrate the simplicity of building a Docker image by copying your source into a container. These\nexamples suggest that by using a simple configuration, you can have a Docker image with the\nenvironment packaged with your application. The following example shows a simple Dockerfile in this\nvein.', 'task_item': False}, {'text': '126 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'A Dockerfile like this will work. However, you can substantially optimize your images, especially your\nproduction images.', 'task_item': False}, {'text': 'In the container and microservices model, you are constantly starting containers. The typical way of\nusing containers does not restart a sleeping container, because the container is disposable.\nOrchestrators (like Kubernetes and Azure Service Fabric) create new instances of images. What this\nmeans is that you would need to optimize by precompiling the application when it is built so the\ninstantiation process will be faster. When the container is started, it should be ready to run. Don’t\nrestore and compile at run time using the dotnet restore and dotnet build CLI commands as you may\nsee in blog posts about .NET and Docker.', 'task_item': False}, {'text': 'The .NET team has been doing important work to make .NET and ASP.NET Core a container-optimized\nframework. Not only is .NET a lightweight framework with a small memory footprint; the team has\nfocused on optimized Docker images for three main scenarios and published them in the Docker Hub\nregistry at _dotnet/_, beginning with version 2.1:', 'task_item': False}, {'text': '1. **Development** : The priority is the ability to quickly iterate and debug changes, and where size\nis secondary.', 'task_item': False}, {'text': '2. **Build** : The priority is compiling the application, and the image includes binaries and other\ndependencies to optimize binaries.', 'task_item': False}, {'text': '3. **Production** : The focus is fast deploying and starting of containers, so these images are\nlimited to the binaries and content needed to run the application.', 'task_item': False}, {'text': '[The .NET team provides four basic variants in dotnet/ (at Docker Hub):](https://hub.docker.com/_/microsoft-dotnet/)', 'task_item': False}, {'text': '1. **sdk** : for development and build scenarios', 'task_item': False}, {'text': '2. **aspnet** : for ASP.NET production scenarios', 'task_item': False}, {'text': '3. **runtime** : for .NET production scenarios', 'task_item': False}, {'text': '4. **runtime-deps** [: for production scenarios of self-contained applications](https://docs.microsoft.com/dotnet/core/deploying/index#publish-self-contained)', 'task_item': False}, {'text': 'For faster startup, runtime images also automatically set aspnetcore_urls to port 80 and use Ngen to\ncreate a native image cache of assemblies.', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**Building Optimized Docker Images with ASP.NET Core**\n[https://learn.microsoft.com/archive/blogs/stevelasker/building-optimized-docker-images-](https://docs.microsoft.com/archive/blogs/stevelasker/building-optimized-docker-images-with-asp-net-core)\n[with-asp-net-core](https://docs.microsoft.com/archive/blogs/stevelasker/building-optimized-docker-images-with-asp-net-core)', 'task_item': False}, {'text': '**Building Docker Images for .NET Applications**\n[https://learn.microsoft.com/dotnet/core/docker/building-net-docker-images](https://docs.microsoft.com/aspnet/core/host-and-deploy/docker/building-net-docker-images)', 'task_item': False}], [{'text': '**Run the SQL Server Docker image on Linux, Mac, or Windows**\n[https://learn.microsoft.com/sql/linux/sql-server-linux-setup-docker](https://docs.microsoft.com/sql/linux/sql-server-linux-setup-docker)', 'task_item': False}, {'text': '**Connect and query SQL Server on Linux with sqlcmd**\n[https://learn.microsoft.com/sql/linux/sql-server-linux-connect-and-query-sqlcmd](https://docs.microsoft.com/sql/linux/sql-server-linux-connect-and-query-sqlcmd)', 'task_item': False}], [{'text': 'The abstraction or interface.', 'task_item': False}, {'text': 'One or more implementations.', 'task_item': False}, {'text': '136 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'In Figure 6-19 you can see how, from an application point of view, the event bus is nothing more than\na Pub/Sub channel. The way you implement this asynchronous communication can vary. It can have\nmultiple implementations so that you can swap between them, depending on the environment\nrequirements (for example, production versus development environments).', 'task_item': False}, {'text': 'In Figure 6-20, you can see an abstraction of an event bus with multiple implementations based on\ninfrastructure messaging technologies like RabbitMQ, Azure Service Bus, or another event/message\nbroker.', 'task_item': False}, {'text': '_Figure 6- 20. Multiple implementations of an event bus_', 'task_item': False}, {'text': 'It’s good to have the event bus defined through an interface so it can be implemented with several\ntechnologies, like RabbitMQ, Azure Service bus or others. However, and as mentioned previously,\nusing your own abstractions (the event bus interface) is good only if you need basic event bus\nfeatures supported by your abstractions. If you need richer service bus features, you should probably\nuse the API and abstractions provided by your preferred commercial service bus instead of your own\nabstractions.', 'task_item': False}, {'text': '**Defining an event bus interface**', 'task_item': False}, {'text': 'Let’s start with some implementation code for the event bus interface and possible implementations\nfor exploration purposes. The interface should be generic and straightforward, as in the following\ninterface.', 'task_item': False}, {'text': '137 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'The Publish method is straightforward. The event bus will broadcast the integration event passed to it\nto any microservice, or even an external application, subscribed to that event. This method is used by\nthe microservice that is publishing the event.', 'task_item': False}, {'text': 'The Subscribe methods (you can have several implementations depending on the arguments) are\nused by the microservices that want to receive events. This method has two arguments. The first is the\nintegration event to subscribe to (IntegrationEvent). The second argument is the integration event\nhandler (or callback method), named IIntegrationEventHandler<T>, to be executed when the receiver\nmicroservice gets that integration event message.', 'task_item': False}], [{'text': '**Azure Service Bus**\n[https://learn.microsoft.com/azure/service-bus-messaging/](https://docs.microsoft.com/azure/service-bus-messaging/)', 'task_item': False}, {'text': '**NServiceBus**\n[https://particular.net/nservicebus](https://particular.net/nservicebus)', 'task_item': False}, {'text': '**MassTransit**\n[https://masstransit-project.com/](https://masstransit-project.com/)', 'task_item': False}], [{'text': '**NServiceBus**  - Fully-supported commercial service bus with advanced management and\nmonitoring tooling for .NET\n[https://particular.net/](https://particular.net/)', 'task_item': False}, {'text': '**EasyNetQ**  - Open Source .NET API client for RabbitMQ\n[https://easynetq.com/](https://easynetq.com/)', 'task_item': False}, {'text': '**MassTransit**  - Free, open-source distributed application framework for .NET\n[https://masstransit-project.com/](https://masstransit-project.com/)', 'task_item': False}, {'text': '**Rebus**  - Open source .NET Service Bus\n[https://github.com/rebus-org/Rebus](https://github.com/rebus-org/Rebus)', 'task_item': False}], [{'text': '[Using the full Event Sourcing pattern.](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)', 'task_item': False}, {'text': 'Using transaction log mining.', 'task_item': False}, {'text': '[Using the Outbox pattern. This is a transactional table to store the integration events](https://www.kamilgrzybek.com/design/the-outbox-pattern/)\n(extending the local transaction).', 'task_item': False}, {'text': 'For this scenario, using the full Event Sourcing (ES) pattern is one of the best approaches, if not _the_\nbest. However, in many application scenarios, you might not be able to implement a full ES system. ES\nmeans storing only domain events in your transactional database, instead of storing current state', 'task_item': False}, {'text': '143 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'data. Storing only domain events can have great benefits, such as having the history of your system\navailable and being able to determine the state of your system at any moment in the past. However,\nimplementing a full ES system requires you to rearchitect most of your system and introduces many\nother complexities and requirements. For example, you would want to use a database specifically\n[made for event sourcing, such as Event Store, or a document-oriented database such as Azure](https://eventstore.org/)\nCosmos DB, MongoDB, Cassandra, CouchDB, or RavenDB. ES is a great approach for this problem, but\nnot the easiest solution unless you are already familiar with event sourcing.', 'task_item': False}, {'text': 'The option to use transaction log mining initially looks transparent. However, to use this approach,\nthe microservice has to be coupled to your RDBMS transaction log, such as the SQL Server transaction\nlog. This approach is probably not desirable. Another drawback is that the low-level updates recorded\nin the transaction log might not be at the same level as your high-level integration events. If so, the\nprocess of reverse-engineering those transaction log operations can be difficult.', 'task_item': False}, {'text': 'A balanced approach is a mix of a transactional database table and a simplified ES pattern. You can\nuse a state such as “ready to publish the event,” which you set in the original event when you commit\nit to the integration events table. You then try to publish the event to the event bus. If the publishevent action succeeds, you start another transaction in the origin service and move the state from\n“ready to publish the event” to “event already published.”', 'task_item': False}, {'text': 'If the publish-event action in the event bus fails, the data still will not be inconsistent within the origin\nmicroservice—it is still marked as “ready to publish the event,” and with respect to the rest of the\nservices, it will eventually be consistent. You can always have background jobs checking the state of\nthe transactions or integration events. If the job finds an event in the “ready to publish the event”\nstate, it can try to republish that event to the event bus.', 'task_item': False}, {'text': 'Notice that with this approach, you are persisting only the integration events for each origin\nmicroservice, and only the events that you want to communicate to other microservices or external\nsystems. In contrast, in a full ES system, you store all domain events as well.', 'task_item': False}, {'text': 'Therefore, this balanced approach is a simplified ES system. You need a list of integration events with\ntheir current state (“ready to publish” versus “published”). But you only need to implement these\nstates for the integration events. And in this approach, you do not need to store all your domain data\nas events in the transactional database, as you would in a full ES system.', 'task_item': False}, {'text': 'If you are already using a relational database, you can use a transactional table to store integration\nevents. To achieve atomicity in your application, you use a two-step process based on local\ntransactions. Basically, you have an IntegrationEvent table in the same database where you have your\ndomain entities. That table works as an insurance for achieving atomicity so that you include persisted\nintegration events into the same transactions that are committing your domain data.', 'task_item': False}, {'text': 'Step by step, the process goes like this:', 'task_item': False}, {'text': '1. The application begins a local database transaction.', 'task_item': False}, {'text': '2. It then updates the state of your domain entities and inserts an event into the integration\nevent table.', 'task_item': False}, {'text': '3. Finally, it commits the transaction, so you get the desired atomicity and then', 'task_item': False}, {'text': '144 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '4. You publish the event somehow (next).', 'task_item': False}, {'text': 'When implementing the steps of publishing the events, you have these choices:', 'task_item': False}, {'text': 'Publish the integration event right after committing the transaction and use another local\ntransaction to mark the events in the table as being published. Then, use the table just as an\nartifact to track the integration events in case of issues in the remote microservices, and\nperform compensatory actions based on the stored integration events.', 'task_item': False}, {'text': 'Use the table as a kind of queue. A separate application thread or process queries the\nintegration event table, publishes the events to the event bus, and then uses a local\ntransaction to mark the events as published.', 'task_item': False}, {'text': 'Figure 6-22 shows the architecture for the first of these approaches.', 'task_item': False}, {'text': '_Figure 6-22. Atomicity when publishing events to the event bus_', 'task_item': False}, {'text': 'The approach illustrated in Figure 6-22 is missing an additional worker microservice that is in charge\nof checking and confirming the success of the published integration events. In case of failure, that\nadditional checker worker microservice can read events from the table and republish them, that is,\nrepeat step number 2.', 'task_item': False}, {'text': 'About the second approach: you use the EventLog table as a queue and always use a worker\nmicroservice to publish the messages. In that case, the process is like that shown in Figure 6-23. This\nshows an additional microservice, and the table is the single source when publishing events.', 'task_item': False}, {'text': '145 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '_Figure 6-23. Atomicity when publishing events to the event bus with a worker microservice_', 'task_item': False}, {'text': 'For simplicity, the eShopOnContainers sample uses the first approach (with no additional processes or\nchecker microservices) plus the event bus. However, the eShopOnContainers sample is not handling\nall possible failure cases. In a real application deployed to the cloud, you must embrace the fact that\nissues will arise eventually, and you must implement that check and resend logic. Using the table as a\nqueue can be more effective than the first approach if you have that table as a single source of events\nwhen publishing them (with the worker) through the event bus.', 'task_item': False}, {'text': '**Implementing atomicity when publishing integration events through the event**\n**bus**', 'task_item': False}, {'text': 'The following code shows how you can create a single transaction involving multiple DbContext\nobjects—one context related to the original data being updated, and the second context related to\nthe IntegrationEventLog table.', 'task_item': False}, {'text': 'The transaction in the example code below will not be resilient if connections to the database have\nany issue at the time when the code is running. This can happen in cloud-based systems like Azure\nSQL DB, which might move databases across servers. For implementing resilient transactions across\nmultiple contexts, see the Implementing resilient Entity Framework Core SQL connections section later\nin this guide.', 'task_item': False}, {'text': 'For clarity, the following example shows the whole process in a single piece of code. However, the\neShopOnContainers implementation is refactored and splits this logic into multiple classes so it’s\neasier to maintain.', 'task_item': False}, {'text': '146 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'After the ProductPriceChangedIntegrationEvent integration event is created, the transaction that\nstores the original domain operation (update the catalog item) also includes the persistence of the\nevent in the EventLog table. This makes it a single transaction, and you will always be able to check\nwhether event messages were sent.', 'task_item': False}, {'text': 'The event log table is updated atomically with the original database operation, using a local\ntransaction against the same database. If any of the operations fail, an exception is thrown and the\ntransaction rolls back any completed operation, thus maintaining consistency between the domain\noperations and the event messages saved to the table.', 'task_item': False}, {'text': '147 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '**Receiving messages from subscriptions: event handlers in receiver microservices**', 'task_item': False}, {'text': 'In addition to the event subscription logic, you need to implement the internal code for the\nintegration event handlers (like a callback method). The event handler is where you specify where the\nevent messages of a certain type will be received and processed.', 'task_item': False}, {'text': 'An event handler first receives an event instance from the event bus. Then it locates the component to\nbe processed related to that integration event, propagating and persisting the event as a change in\nstate in the receiver microservice. For example, if a ProductPriceChanged event originates in the\ncatalog microservice, it is handled in the basket microservice and changes the state in this receiver\nbasket microservice as well, as shown in the following code.', 'task_item': False}, {'text': '148 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'The event handler needs to verify whether the product exists in any of the basket instances. It also\nupdates the item price for each related basket line item. Finally, it creates an alert to be displayed to\nthe user about the price change, as shown in Figure 6-24.', 'task_item': False}, {'text': '_Figure 6-24. Displaying an item price change in a basket, as communicated by integration events_', 'task_item': False}], [{'text': '**Honoring message idempotency**\n[https://learn.microsoft.com/previous-versions/msp-n-p/jj591565(v=pandp.10)#honoring-](https://docs.microsoft.com/previous-versions/msp-n-p/jj591565(v=pandp.10)#honoring-message-idempotency)\n[message-idempotency](https://docs.microsoft.com/previous-versions/msp-n-p/jj591565(v=pandp.10)#honoring-message-idempotency)', 'task_item': False}], [{'text': '**Forked eShopOnContainers using NServiceBus (Particular Software)**\n[https://go.particular.net/eShopOnContainers](https://go.particular.net/eShopOnContainers)', 'task_item': False}, {'text': '**Event Driven Messaging**\n[https://patterns.arcitura.com/soa-patterns/design_patterns/event_driven_messaging](https://patterns.arcitura.com/soa-patterns/design_patterns/event_driven_messaging)', 'task_item': False}, {'text': '**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling**\n[https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)', 'task_item': False}, {'text': '**Publish-Subscribe channel**\n[https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.](https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)\nhtml', 'task_item': False}, {'text': '**Communicating Between Bounded Contexts**\n[https://learn.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)](https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10))', 'task_item': False}, {'text': '**Eventual Consistency**\n[https://en.wikipedia.org/wiki/Eventual_consistency](https://en.wikipedia.org/wiki/Eventual_consistency)', 'task_item': False}, {'text': '**Philip Brown. Strategies for Integrating Bounded Contexts**\n[https://www.culttt.com/2014/11/26/strategies-integrating-bounded-contexts/](https://www.culttt.com/2014/11/26/strategies-integrating-bounded-contexts/)', 'task_item': False}, {'text': '**Chris Richardson. Developing Transactional Microservices Using Aggregates, Event**\n**Sourcing and CQRS - Part 2**\n[https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-2-richardson](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-2-richardson)', 'task_item': False}, {'text': '**Chris Richardson. Event Sourcing pattern**\n[https://microservices.io/patterns/data/event-sourcing.html](https://microservices.io/patterns/data/event-sourcing.html)', 'task_item': False}, {'text': '**Introducing Event Sourcing**\n[https://learn.microsoft.com/previous-versions/msp-n-p/jj591559(v=pandp.10)](https://docs.microsoft.com/previous-versions/msp-n-p/jj591559(v=pandp.10))', 'task_item': False}, {'text': '151 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '**Event Store database** . Official site.\n[https://geteventstore.com/](https://geteventstore.com/)', 'task_item': False}, {'text': '**Patrick Nommensen. Event-Driven Data Management for Microservices**\n[https://dzone.com/articles/event-driven-data-management-for-microservices-1](https://dzone.com/articles/event-driven-data-management-for-microservices-1)', 'task_item': False}, {'text': '**The CAP Theorem**\n[https://en.wikipedia.org/wiki/CAP_theorem](https://en.wikipedia.org/wiki/CAP_theorem)', 'task_item': False}, {'text': '**What is CAP Theorem?**\n[https://www.quora.com/What-Is-CAP-Theorem-1](https://www.quora.com/What-Is-CAP-Theorem-1)', 'task_item': False}, {'text': '**Data Consistency Primer**\n[https://learn.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)](https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10))', 'task_item': False}, {'text': '**Rick Saling. The CAP Theorem: Why “Everything is Different” with the Cloud and**\n**Internet**\n[https://learn.microsoft.com/archive/blogs/rickatmicrosoft/the-cap-theorem-why-everything-](https://docs.microsoft.com/archive/blogs/rickatmicrosoft/the-cap-theorem-why-everything-is-different-with-the-cloud-and-internet/)\n[is-different-with-the-cloud-and-internet/](https://docs.microsoft.com/archive/blogs/rickatmicrosoft/the-cap-theorem-why-everything-is-different-with-the-cloud-and-internet/)', 'task_item': False}, {'text': '**Eric Brewer. CAP Twelve Years Later: How the “Rules” Have Changed**\n[https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed)', 'task_item': False}, {'text': '**CAP, PACELC, and Microservices**\n[https://ardalis.com/cap-pacelc-and-microservices/](https://ardalis.com/cap-pacelc-and-microservices/)', 'task_item': False}, {'text': '**Azure Service Bus. Brokered Messaging: Duplicate Detection**\n[https://github.com/microsoftarchive/msdn-code-gallery-](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Windows%20Azure%20Product%20Team/Brokered%20Messaging%20Duplicate%20Detection)\n[microsoft/tree/master/Windows%20Azure%20Product%20Team/Brokered%20Messaging%20](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Windows%20Azure%20Product%20Team/Brokered%20Messaging%20Duplicate%20Detection)\n[Duplicate%20Detection](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Windows%20Azure%20Product%20Team/Brokered%20Messaging%20Duplicate%20Detection)', 'task_item': False}, {'text': '**Reliability Guide** (RabbitMQ documentation)\n[https://www.rabbitmq.com/reliability.html#consumer](https://www.rabbitmq.com/reliability.html#consumer)', 'task_item': False}], [{'text': 'Unit tests. These tests ensure that individual components of the application work as expected.\nAssertions test the component API.', 'task_item': False}, {'text': 'Integration tests. These tests ensure that component interactions work as expected against\nexternal artifacts like databases. Assertions can test component API, UI, or the side effects of\nactions like database I/O, logging, etc.', 'task_item': False}, {'text': '152 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': 'Functional tests for each microservice. These tests ensure that the application works as\nexpected from the user’s perspective.', 'task_item': False}, {'text': 'Service tests. These tests ensure that end-to-end service use cases, including testing multiple\nservices at the same time, are tested. For this type of testing, you need to prepare the\nenvironment first. In this case, it means starting the services (for example, by using dockercompose up).', 'task_item': False}, {'text': '**Implementing unit tests for ASP.NET Core Web APIs**', 'task_item': False}, {'text': 'Unit testing involves testing a part of an application in isolation from its infrastructure and\ndependencies. When you unit test controller logic, only the content of a single action or method is\ntested, not the behavior of its dependencies or of the framework itself. Unit tests do not detect issues\nin the interaction between components—that is the purpose of integration testing.', 'task_item': False}, {'text': 'As you unit test your controller actions, make sure you focus only on their behavior. A controller unit\ntest avoids things like filters, routing, or model binding (the mapping of request data to a ViewModel\nor DTO). Because they focus on testing just one thing, unit tests are generally simple to write and\nquick to run. A well-written set of unit tests can be run frequently without much overhead.', 'task_item': False}, {'text': 'Unit tests are implemented based on test frameworks like xUnit.net, MSTest, Moq, or NUnit. For the\neShopOnContainers sample application, we are using xUnit.', 'task_item': False}, {'text': 'When you write a unit test for a Web API controller, you instantiate the controller class directly using\nthe new keyword in C#, so that the test will run as fast as possible. The following example shows how\n[to do this when using xUnit as the Test framework.](https://xunit.net/)', 'task_item': False}, {'text': '153 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '**Implementing integration and functional tests for each microservice**', 'task_item': False}, {'text': 'As noted, integration tests and functional tests have different purposes and goals. However, the way\nyou implement both when testing ASP.NET Core controllers is similar, so in this section we\nconcentrate on integration tests.', 'task_item': False}, {'text': 'Integration testing ensures that an application’s components function correctly when assembled.\nASP.NET Core supports integration testing using unit test frameworks and a built-in test web host that\ncan be used to handle requests without network overhead.', 'task_item': False}, {'text': 'Unlike unit testing, integration tests frequently involve application infrastructure concerns, such as a\ndatabase, file system, network resources, or web requests and responses. Unit tests use fakes or mock\nobjects in place of these concerns. But the purpose of integration tests is to confirm that the system\nworks as expected with these systems, so for integration testing you do not use fakes or mock objects.\nInstead, you include the infrastructure, like database access or service invocation from other services.', 'task_item': False}, {'text': 'Because integration tests exercise larger segments of code than unit tests, and because integration\ntests rely on infrastructure elements, they tend to be orders of magnitude slower than unit tests. Thus,\nit is a good idea to limit how many integration tests you write and run.', 'task_item': False}, {'text': 'ASP.NET Core includes a built-in test web host that can be used to handle HTTP requests without\nnetwork overhead, meaning that you can run those tests faster than when using a real web host. The\ntest web host (TestServer) is available in a NuGet component as Microsoft.AspNetCore.TestHost. It can\nbe added to integration test projects and used to host ASP.NET Core applications.', 'task_item': False}, {'text': 'As you can see in the following code, when you create integration tests for ASP.NET Core controllers,\nyou instantiate the controllers through the test host. This functionality is comparable to an HTTP\nrequest, but it runs faster.', 'task_item': False}, {'text': '154 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**Steve Smith. Testing controllers** (ASP.NET Core)\n[https://learn.microsoft.com/aspnet/core/mvc/controllers/testing](https://docs.microsoft.com/aspnet/core/mvc/controllers/testing)', 'task_item': False}, {'text': '**Steve Smith. Integration testing** (ASP.NET Core)\n[https://learn.microsoft.com/aspnet/core/test/integration-tests](https://docs.microsoft.com/aspnet/core/test/integration-tests)', 'task_item': False}, {'text': '**Unit testing in .NET using dotnet test**\n[https://learn.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test](https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test)', 'task_item': False}, {'text': '**xUnit.net** . Official site.\n[https://xunit.net/](https://xunit.net/)', 'task_item': False}, {'text': '**Unit Test Basics.**\n[https://learn.microsoft.com/visualstudio/test/unit-test-basics](https://docs.microsoft.com/visualstudio/test/unit-test-basics)', 'task_item': False}, {'text': '**Moq** . GitHub repo.\n[https://github.com/moq/moq](https://github.com/moq/moq)', 'task_item': False}, {'text': '**NUnit** . Official site.\n[https://nunit.org/](https://nunit.org/)', 'task_item': False}, {'text': '**Implementing service tests on a multi-container application**', 'task_item': False}, {'text': 'As noted earlier, when you test multi-container applications, all the microservices need to be running\nwithin the Docker host or container cluster. End-to-end service tests that include multiple operations\ninvolving several microservices require you to deploy and start the whole application in the Docker\nhost by running docker-compose up (or a comparable mechanism if you are using an orchestrator).\nOnce the whole application and all its services is running, you can execute end-to-end integration and\nfunctional tests.', 'task_item': False}, {'text': 'There are a few approaches you can use. In the docker-compose.yml file that you use to deploy the\n[application at the solution level you can expand the entry point to use dotnet test. You can also use](https://docs.microsoft.com/dotnet/core/tools/dotnet-test)\nanother compose file that would run your tests in the image you are targeting. By using another\ncompose file for integration tests that includes your microservices and databases on containers, you\ncan make sure that the related data is always reset to its original state before running the tests.', 'task_item': False}, {'text': 'Once the compose application is up and running, you can take advantage of breakpoints and\nexceptions if you are running Visual Studio. Or you can run the integration tests automatically in your\nCI pipeline in Azure DevOps Services or any other CI/CD system that supports Docker containers.', 'task_item': False}], [{'text': '**Unit & Integration testing** on the eShopOnContainers\n[https://github.com/dotnet-architecture/eShopOnContainers/wiki/Unit-and-integration-](https://github.com/dotnet-architecture/eShopOnContainers/wiki/Unit-and-integration-testing)\ntesting', 'task_item': False}, {'text': '**Load testing** on the eShopOnContainers\n[https://github.com/dotnet-architecture/eShopOnContainers/wiki/Load-testing](https://github.com/dotnet-architecture/eShopOnContainers/wiki/Load-testing)', 'task_item': False}], [{'text': 'A background task polling a database looking for changes.', 'task_item': False}, {'text': 'A scheduled task updating some cache periodically.', 'task_item': False}, {'text': 'An implementation of QueueBackgroundWorkItem that allows a task to be executed on a\nbackground thread.', 'task_item': False}, {'text': 'Processing messages from a message queue in the background of a web app while sharing\ncommon services such as ILogger.', 'task_item': False}, {'text': 'A background task started with Task.Run().', 'task_item': False}, {'text': 'You can basically offload any of those actions to a background task that implements IHostedService.', 'task_item': False}, {'text': 'The way you add one or multiple IHostedServices into your WebHost or Host is by registering them\n[up through the AddHostedService extension method in an ASP.NET Core WebHost (or in a Host in](https://docs.microsoft.com/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionhostedserviceextensions.addhostedservice)\n.NET Core 2.1 and above). Basically, you have to register the hosted services within application startup\nin _Program.cs_ .', 'task_item': False}, {'text': 'In that code, the GracePeriodManagerService hosted service is real code from the Ordering business\nmicroservice in eShopOnContainers, while the other two are just two additional samples.', 'task_item': False}, {'text': 'The IHostedService background task execution is coordinated with the lifetime of the application (host\nor microservice, for that matter). You register tasks when the application starts and you have the\nopportunity to do some graceful action or clean-up when the application is shutting down.', 'task_item': False}, {'text': 'Without using IHostedService, you could always start a background thread to run any task. The\ndifference is precisely at the app’s shutdown time when that thread would simply be killed without\nhaving the opportunity to run graceful clean-up actions.', 'task_item': False}], [{'text': '**Building a scheduled task in ASP.NET Core/Standard 2.0**\n[https://blog.maartenballiauw.be/post/2017/08/01/building-a-scheduled-cache-updater-in-](https://blog.maartenballiauw.be/post/2017/08/01/building-a-scheduled-cache-updater-in-aspnet-core-2.html)\n[aspnet-core-2.html](https://blog.maartenballiauw.be/post/2017/08/01/building-a-scheduled-cache-updater-in-aspnet-core-2.html)', 'task_item': False}, {'text': '**Implementing IHostedService in ASP.NET Core 2.0**\n[https://www.stevejgordon.co.uk/asp-net-core-2-ihostedservice](https://www.stevejgordon.co.uk/asp-net-core-2-ihostedservice)', 'task_item': False}, {'text': '**GenericHost Sample using ASP.NET Core 2.1**\n[https://github.com/aspnet/Hosting/tree/release/2.1/samples/GenericHostSample](https://github.com/aspnet/Hosting/tree/release/2.1/samples/GenericHostSample)', 'task_item': False}], [{'text': '/ for the client SPA web application', 'task_item': False}, {'text': '/webmvc for the client MVC web application', 'task_item': False}, {'text': '/webstatus for the client web app showing the status/healthchecks', 'task_item': False}, {'text': '/webshoppingapigw for the web BFF and shopping business processes', 'task_item': False}, {'text': '/webmarketingapigw for the web BFF and marketing business processes', 'task_item': False}, {'text': '/mobileshoppingapigw for the mobile BFF and shopping business processes', 'task_item': False}, {'text': '/mobilemarketingapigw for the mobile BFF and marketing business processes', 'task_item': False}, {'text': 'When deploying to Kubernetes, each Ocelot API Gateway is using a different “configuration.json” file\nfor each _pod_ running the API Gateways. Those “configuration.json” files are provided by mounting\n(originally with the deploy.ps1 script) a volume created based on a Kubernetes _config map_ named\n‘ocelot’. Each container mounts its related configuration file in the container’s folder named\n/app/configuration.', 'task_item': False}, {'text': 'In the source code files of eShopOnContainers, the original “configuration.json” files can be found\nwithin the k8s/ocelot/ folder. There’s one file for each BFF/APIGateway.', 'task_item': False}], [{'text': '**Service discovery in the client side integrating Ocelot with Consul or Eureka**\n[https://ocelot.readthedocs.io/en/latest/features/servicediscovery.html](https://ocelot.readthedocs.io/en/latest/features/servicediscovery.html)', 'task_item': False}, {'text': '**Caching at the API Gateway tier**\n[https://ocelot.readthedocs.io/en/latest/features/caching.html](https://ocelot.readthedocs.io/en/latest/features/caching.html)', 'task_item': False}, {'text': '**Logging at the API Gateway tier**\n[https://ocelot.readthedocs.io/en/latest/features/logging.html](https://ocelot.readthedocs.io/en/latest/features/logging.html)', 'task_item': False}, {'text': '**Quality of Service (Retries and Circuit breakers) at the API Gateway tier**\n[https://ocelot.readthedocs.io/en/latest/features/qualityofservice.html](https://ocelot.readthedocs.io/en/latest/features/qualityofservice.html)', 'task_item': False}, {'text': '**Rate limiting**\n[https://ocelot.readthedocs.io/en/latest/features/ratelimiting.html](https://ocelot.readthedocs.io/en/latest/features/ratelimiting.html)', 'task_item': False}, {'text': '**Swagger for Ocelot**\n[https://github.com/Burgyn/MMLib.SwaggerForOcelot](https://github.com/Burgyn/MMLib.SwaggerForOcelot)', 'task_item': False}, {'text': '181 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '**CHAPTER**', 'task_item': False}], [{'text': '**Eric Evans. Domain Language**\n[https://domainlanguage.com/](https://domainlanguage.com/)', 'task_item': False}, {'text': '**Martin Fowler. Domain-Driven Design**\n[https://martinfowler.com/tags/domain%20driven%20design.html](https://martinfowler.com/tags/domain%20driven%20design.html)', 'task_item': False}, {'text': '**Jimmy Bogard. Strengthening your domain: a primer**\n[https://lostechies.com/jimmybogard/2010/02/04/strengthening-your-domain-a-primer/](https://lostechies.com/jimmybogard/2010/02/04/strengthening-your-domain-a-primer/)', 'task_item': False}, {'text': '183 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '**DDD books**', 'task_item': False}, {'text': '**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software**\n[https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)\n[Software/dp/0321125215/](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)', 'task_item': False}, {'text': '**Eric Evans. Domain-Driven Design Reference: Definitions and Pattern Summaries**\n[https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-2014-09-](https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-2014-09-22/dp/B01N8YB4ZO/)\n[22/dp/B01N8YB4ZO/](https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-2014-09-22/dp/B01N8YB4ZO/)', 'task_item': False}, {'text': '**Vaughn Vernon. Implementing Domain-Driven Design**\n[https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/)\n[Vernon/dp/0321834577/](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/)', 'task_item': False}, {'text': '**Vaughn Vernon. Domain-Driven Design Distilled**\n[https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420/](https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420/)', 'task_item': False}, {'text': '**Jimmy Nilsson. Applying Domain-Driven Design and Patterns**\n[https://www.amazon.com/Applying-Domain-Driven-Design-Patterns-](https://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202/)\n[Examples/dp/0321268202/](https://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202/)', 'task_item': False}, {'text': '**Cesar de la Torre. N-Layered Domain-Oriented Architecture Guide with .NET**\n[https://www.amazon.com/N-Layered-Domain-Oriented-Architecture-Guide-](https://www.amazon.com/N-Layered-Domain-Oriented-Architecture-Guide-NET/dp/8493903612/)\n[NET/dp/8493903612/](https://www.amazon.com/N-Layered-Domain-Oriented-Architecture-Guide-NET/dp/8493903612/)', 'task_item': False}, {'text': '**Abel Avram and Floyd Marinescu. Domain-Driven Design Quickly**\n[https://www.amazon.com/Domain-Driven-Design-Quickly-Abel-Avram/dp/1411609255/](https://www.amazon.com/Domain-Driven-Design-Quickly-Abel-Avram/dp/1411609255/)', 'task_item': False}, {'text': '**Scott Millett, Nick Tune - Patterns, Principles, and Practices of Domain-Driven Design**\n[https://www.wiley.com/Patterns%2C+Principles%2C+and+Practices+of+Domain+Driven+Des](https://www.wiley.com/Patterns%2C+Principles%2C+and+Practices+of+Domain+Driven+Design-p-9781118714706)\n[ign-p-9781118714706](https://www.wiley.com/Patterns%2C+Principles%2C+and+Practices+of+Domain+Driven+Design-p-9781118714706)', 'task_item': False}, {'text': '**DDD training**', 'task_item': False}, {'text': '**Julie Lerman and Steve Smith. Domain-Driven Design Fundamentals**\n[https://www.pluralsight.com/courses/fundamentals-domain-driven-design](https://www.pluralsight.com/courses/fundamentals-domain-driven-design)', 'task_item': False}], [{'text': 'Queries. These queries return a result and don’t change the state of the system, and they’re\nfree of side effects.', 'task_item': False}, {'text': 'Commands. These commands change the state of a system.', 'task_item': False}, {'text': '184 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': 'CQS is a simple concept: it is about methods within the same object being either queries or\ncommands. Each method either returns state or mutates state, but not both. Even a single repository\npattern object can comply with CQS. CQS can be considered a foundational principle for CQRS.', 'task_item': False}, {'text': '[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly\npromoted by Udi Dahan and others. It’s based on the CQS principle, although it’s more detailed. It can\nbe considered a pattern based on commands and events plus optionally on asynchronous messages.\nIn many cases, CQRS is related to more advanced scenarios, like having a different physical database\nfor reads (queries) than for writes (updates). Moreover, a more evolved CQRS system might\n[implement Event-Sourcing (ES) for your updates database, so you would only store events in the](https://martinfowler.com/eaaDev/EventSourcing.html)\ndomain model instead of storing the current-state data. However, this approach is not used in this\nguide. This guide uses the simplest CQRS approach, which consists of just separating the queries from\nthe commands.', 'task_item': False}, {'text': 'The separation aspect of CQRS is achieved by grouping query operations in one layer and commands\nin another layer. Each layer has its own data model (note that we say model, not necessarily a different\ndatabase) and is built using its own combination of patterns and technologies. More importantly, the\ntwo layers can be within the same tier or microservice, as in the example (ordering microservice) used\nfor this guide. Or they could be implemented on different microservices or processes so they can be\noptimized and scaled out separately without affecting one another.', 'task_item': False}, {'text': 'CQRS means having two objects for a read/write operation where in other contexts there’s one. There\nare reasons to have a denormalized reads database, which you can learn about in more advanced\nCQRS literature. But we aren’t using that approach here, where the goal is to have more flexibility in\nthe queries instead of limiting the queries with constraints from DDD patterns like aggregates.', 'task_item': False}, {'text': 'An example of this kind of service is the ordering microservice from the eShopOnContainers reference\napplication. This service implements a microservice based on a simplified CQRS approach. It uses a\nsingle data source or database, but two logical models plus DDD patterns for the transactional\ndomain, as shown in Figure 7-2.', 'task_item': False}, {'text': '185 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '_Figure 7-2. Simplified CQRS- and DDD-based microservice_', 'task_item': False}, {'text': 'The Logical “Ordering” Microservice includes its Ordering database, which can be, but doesn’t have to\nbe, the same Docker host. Having the database in the same Docker host is good for development, but\nnot for production.', 'task_item': False}, {'text': 'The application layer can be the Web API itself. The important design aspect here is that the\nmicroservice has split the queries and ViewModels (data models especially created for the client\napplications) from the commands, domain model, and transactions following the CQRS pattern. This\napproach keeps the queries independent from restrictions and constraints coming from DDD patterns\nthat only make sense for transactions and updates, as explained in later sections.', 'task_item': False}], [{'text': '**Greg Young. Versioning in an Event Sourced System** (Free to read online e-book)\n[https://leanpub.com/esversioning/read](https://leanpub.com/esversioning/read)', 'task_item': False}], [{'text': '**Martin Fowler. CQRS**\n[https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html)', 'task_item': False}, {'text': '**Greg Young. CQRS Documents**\n[https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf)', 'task_item': False}, {'text': '**Udi Dahan. Clarified CQRS**\n[https://udidahan.com/2009/12/09/clarified-cqrs/](https://udidahan.com/2009/12/09/clarified-cqrs/)', 'task_item': False}], [{'text': '**Dapper**\n[https://github.com/StackExchange/dapper-dot-net](https://github.com/StackExchange/dapper-dot-net)', 'task_item': False}, {'text': '**Julie Lerman. Data Points - Dapper, Entity Framework and Hybrid Apps (MSDN**\n**magazine article)**', 'task_item': False}, {'text': '193 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '[https://learn.microsoft.com/archive/msdn-magazine/2016/may/data-points-dapper-entity-](https://docs.microsoft.com/archive/msdn-magazine/2016/may/data-points-dapper-entity-framework-and-hybrid-apps)\n[framework-and-hybrid-apps](https://docs.microsoft.com/archive/msdn-magazine/2016/may/data-points-dapper-entity-framework-and-hybrid-apps)', 'task_item': False}, {'text': '**ASP.NET Core Web API Help Pages using Swagger**\n[https://learn.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-](https://docs.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio)\n[swagger?tabs=visual-studio](https://docs.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio)', 'task_item': False}, {'text': '**Create record types** [https://learn.microsoft.com/dotnet/csharp/whats-new/tutorials/records](https://docs.microsoft.com/dotnet/csharp/tutorials/records)', 'task_item': False}], [{'text': '**DevIQ. Persistence Ignorance principle**\n[https://deviq.com/persistence-ignorance/](https://deviq.com/persistence-ignorance/)', 'task_item': False}, {'text': '**Oren Eini. Infrastructure Ignorance**\n[https://ayende.com/blog/3137/infrastructure-ignorance](https://ayende.com/blog/3137/infrastructure-ignorance)', 'task_item': False}, {'text': '**Angel Lopez. Layered Architecture In Domain-Driven Design**\n[https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)', 'task_item': False}], [{'text': '**DevIQ. Domain Entity**\n[https://deviq.com/entity/](https://deviq.com/entity/)', 'task_item': False}, {'text': '**Martin Fowler. The Domain Model**\n[https://martinfowler.com/eaaCatalog/domainModel.html](https://martinfowler.com/eaaCatalog/domainModel.html)', 'task_item': False}, {'text': '**Martin Fowler. The Anemic Domain Model**\n[https://martinfowler.com/bliki/AnemicDomainModel.html](https://martinfowler.com/bliki/AnemicDomainModel.html)', 'task_item': False}, {'text': '**The Value Object pattern**', 'task_item': False}, {'text': 'As Eric Evans has noted, “Many objects do not have conceptual identity. These objects describe\ncertain characteristics of a thing.”', 'task_item': False}, {'text': 'An entity requires an identity, but there are many objects in a system that do not, like the Value\nObject pattern. A value object is an object with no conceptual identity that describes a domain aspect.\nThese are objects that you instantiate to represent design elements that only concern you temporarily.\nYou care about _what_ they are, not _who_ they are. Examples include numbers and strings, but can also\nbe higher-level concepts like groups of attributes.', 'task_item': False}, {'text': 'Something that is an entity in a microservice might not be an entity in another microservice, because\nin the second case, the Bounded Context might have a different meaning. For example, an address in\nan e-commerce application might not have an identity at all, since it might only represent a group of\nattributes of the customer’s profile for a person or company. In this case, the address should be\nclassified as a value object. However, in an application for an electric power utility company, the\ncustomer address could be important for the business domain. Therefore, the address must have an\nidentity so the billing system can be directly linked to the address. In that case, an address should be\nclassified as a domain entity.', 'task_item': False}, {'text': 'A person with a name and surname is usually an entity because a person has identity, even if the\nname and surname coincide with another set of values, such as if those names also refer to a different\nperson.', 'task_item': False}, {'text': 'Value objects are hard to manage in relational databases and ORMs like Entity Framework (EF),\nwhereas in document-oriented databases they are easier to implement and use.', 'task_item': False}, {'text': '201 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '[EF Core 2.0 and later versions include the Owned Entities](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) feature that makes it easier to handle value\nobjects, as we’ll see in detail later on.', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**Martin Fowler. Value Object pattern**\n[https://martinfowler.com/bliki/ValueObject.html](https://martinfowler.com/bliki/ValueObject.html)', 'task_item': False}, {'text': '**Value Object**\n[https://deviq.com/value-object/](https://deviq.com/value-object/)', 'task_item': False}, {'text': '**Value Objects in Test-Driven Development**\n[https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)', 'task_item': False}, {'text': '**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.** (Book;\nincludes a discussion of value objects)\n[https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)\n[Software/dp/0321125215/](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)', 'task_item': False}, {'text': '**The Aggregate pattern**', 'task_item': False}, {'text': 'A domain model contains clusters of different data entities and processes that can control a\nsignificant area of functionality, such as order fulfillment or inventory. A more fine-grained DDD unit is\nthe aggregate, which describes a cluster or group of entities and behaviors that can be treated as a\ncohesive unit.', 'task_item': False}, {'text': 'You usually define an aggregate based on the transactions that you need. A classic example is an\norder that also contains a list of order items. An order item will usually be an entity. But it will be a\nchild entity within the order aggregate, which will also contain the order entity as its root entity,\ntypically called an aggregate root.', 'task_item': False}, {'text': 'Identifying aggregates can be hard. An aggregate is a group of objects that must be consistent\ntogether, but you cannot just pick a group of objects and label them an aggregate. You must start\nwith a domain concept and think about the entities that are used in the most common transactions\nrelated to that concept. Those entities that need to be transactionally consistent are what forms an\naggregate. Thinking about transaction operations is probably the best way to identify aggregates.', 'task_item': False}, {'text': '**The Aggregate Root or Root Entity pattern**', 'task_item': False}, {'text': 'An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary\nentity. Additionally, it can have multiple child entities and value objects, with all entities and objects\nworking together to implement required behavior and transactions.', 'task_item': False}, {'text': 'The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only\nentry point for updates to the aggregate through methods or operations in the aggregate root class.\nYou should make changes to entities within the aggregate only via the aggregate root. It is the\naggregate’s consistency guardian, considering all the invariants and consistency rules you might need\nto comply with in your aggregate. If you change a child entity or value object independently, the', 'task_item': False}, {'text': '202 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': 'aggregate root cannot ensure that the aggregate is in a valid state. It would be like a table with a\nloose leg. Maintaining consistency is the main purpose of the aggregate root.', 'task_item': False}, {'text': 'In Figure 7-9, you can see sample aggregates like the buyer aggregate, which contains a single entity\n(the aggregate root Buyer). The order aggregate contains multiple entities and a value object.', 'task_item': False}, {'text': '_Figure 7-9. Example of aggregates with multiple or single entities_', 'task_item': False}, {'text': 'A DDD domain model is composed from aggregates, an aggregate can have just one entity or more,\nand can include value objects as well. Note that the Buyer aggregate could have additional child\nentities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers\nreference application. Figure 7-9 just illustrates a case in which the buyer has a single entity, as an\nexample of an aggregate that contains only an aggregate root.', 'task_item': False}, {'text': 'In order to maintain separation of aggregates and keep clear boundaries between them, it is a good\npractice in a DDD domain model to disallow direct navigation between aggregates and only having\n[the foreign key (FK) field, as implemented in the Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/main/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in\neShopOnContainers. The Order entity only has a foreign key field for the buyer, but not an EF Core\nnavigation property, as shown in the following code:', 'task_item': False}, {'text': '203 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': 'Identifying and working with aggregates requires research and experience. For more information, see\nthe following Additional resources list.', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate** (from\n[https://dddcommunity.org/)](https://dddcommunity.org/)\n[https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf)', 'task_item': False}, {'text': '**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work**\n**Together** [(from https://dddcommunity.org/)](https://dddcommunity.org/)\n[https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)', 'task_item': False}, {'text': '**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through**\n**Discovery** [(from https://dddcommunity.org/)](https://dddcommunity.org/)\n[https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf)', 'task_item': False}, {'text': '**Sergey Grybniak. DDD Tactical Design Patterns**\n[https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)\n[Patterns-Part](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)', 'task_item': False}, {'text': '**Chris Richardson. Developing Transactional Microservices Using Aggregates**\n[https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)', 'task_item': False}, {'text': '**DevIQ. The Aggregate pattern**\n[https://deviq.com/aggregate-pattern/](https://deviq.com/aggregate-pattern/)', 'task_item': False}], [{'text': '**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.** Note that this is\n_not_ Entity Framework Core.\n[https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/](https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/)', 'task_item': False}, {'text': '**Julie Lerman. Data Points - Coding for Domain-Driven Design: Tips for Data-Focused**\n**Devs**\n[https://learn.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-](https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs)\n[domain-driven-design-tips-for-data-focused-devs](https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs)', 'task_item': False}, {'text': '**Udi Dahan. How to create fully encapsulated Domain Models**\n[https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/](https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)', 'task_item': False}, {'text': '**Steve Smith. What is the difference between a DTO and a POCO?** [https://ardalis.com/dto-](https://ardalis.com/dto-or-poco/)\n[or-poco/](https://ardalis.com/dto-or-poco/)', 'task_item': False}], [{'text': '**Martin Fowler. Separated Interface.**\n[https://www.martinfowler.com/eaaCatalog/separatedInterface.html](https://www.martinfowler.com/eaaCatalog/separatedInterface.html)', 'task_item': False}], [{'text': 'They have no identity.', 'task_item': False}, {'text': 'They are immutable.', 'task_item': False}, {'text': 'The first characteristic was already discussed. Immutability is an important requirement. The values of\na value object must be immutable once the object is created. Therefore, when the object is', 'task_item': False}, {'text': '214 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': 'constructed, you must provide the required values, but you must not allow them to change during the\nobject’s lifetime.', 'task_item': False}, {'text': 'Value objects allow you to perform certain tricks for performance, thanks to their immutable nature.\nThis is especially true in systems where there may be thousands of value object instances, many of\nwhich have the same values. Their immutable nature allows them to be reused; they can be\ninterchangeable objects, since their values are the same and they have no identity. This type of\noptimization can sometimes make a difference between software that runs slowly and software with\ngood performance. Of course, all these cases depend on the application environment and deployment\ncontext.', 'task_item': False}], [{'text': 'The identity of the owner', 'task_item': False}, {'text': 'The navigation property pointing to them', 'task_item': False}, {'text': 'In the case of collections of owned types, an independent component (supported in EF Core\n2.2 and later).', 'task_item': False}, {'text': 'For example, in the Ordering domain model at eShopOnContainers, as part of the Order entity, the\nAddress value object is implemented as an owned entity type within the owner entity, which is the\nOrder entity. Address is a type with no identity property defined in the domain model. It is used as a\nproperty of the Order type to specify the shipping address for a particular order.', 'task_item': False}, {'text': 'By convention, a shadow primary key is created for the owned type and it will be mapped to the same\ntable as the owner by using table splitting. This allows to use owned types similarly to how complex\ntypes are used in EF6 in the traditional .NET Framework.', 'task_item': False}, {'text': 'It is important to note that owned types are never discovered by convention in EF Core, so you have\nto declare them explicitly.', 'task_item': False}, {'text': 'In eShopOnContainers, in the OrderingContext.cs file, within the OnModelCreating() method, multiple\ninfrastructure configurations are applied. One of them is related to the Order entity.', 'task_item': False}, {'text': '218 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': 'In the following code, the persistence infrastructure is defined for the Order entity:', 'task_item': False}, {'text': 'In the previous code, the orderConfiguration.OwnsOne(o => o.Address) method specifies that the\nAddress property is an owned entity of the Order type.', 'task_item': False}, {'text': 'By default, EF Core conventions name the database columns for the properties of the owned entity\ntype as EntityProperty_OwnedEntityProperty. Therefore, the internal properties of Address will appear\nin the Orders table with the names Address_Street, Address_City (and so on for State, Country, and\nZipCode).', 'task_item': False}, {'text': 'You can append the Property().HasColumnName() fluent method to rename those columns. In the\ncase where Address is a public property, the mappings would be like the following:', 'task_item': False}, {'text': 'It’s possible to chain the OwnsOne method in a fluent mapping. In the following hypothetical\nexample, OrderDetails owns BillingAddress and ShippingAddress, which are both Address types. Then\nOrderDetails is owned by the Order type.', 'task_item': False}, {'text': '219 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '**Additional details on owned entity types**', 'task_item': False}, {'text': 'Owned types are defined when you configure a navigation property to a particular type using\nthe OwnsOne fluent API.', 'task_item': False}, {'text': 'The definition of an owned type in our metadata model is a composite of: the owner type, the\nnavigation property, and the CLR type of the owned type.', 'task_item': False}, {'text': 'The identity (key) of an owned type instance in our stack is a composite of the identity of the\nowner type and the definition of the owned type.', 'task_item': False}, {'text': '**Owned entities capabilities**', 'task_item': False}, {'text': 'Owned types can reference other entities, either owned (nested owned types) or non-owned\n(regular reference navigation properties to other entities).', 'task_item': False}, {'text': 'You can map the same CLR type as different owned types in the same owner entity through\nseparate navigation properties.', 'task_item': False}, {'text': 'Table splitting is set up by convention, but you can opt out by mapping the owned type to a\ndifferent table using ToTable.', 'task_item': False}, {'text': 'Eager loading is performed automatically on owned types, that is, there’s no need to call\n.Include() on the query.', 'task_item': False}, {'text': 'Can be configured with attribute [Owned], using EF Core 2.1 and later.', 'task_item': False}, {'text': 'Can handle collections of owned types (using version 2.2 and later).', 'task_item': False}, {'text': '**Owned entities limitations**', 'task_item': False}, {'text': 'You can’t create a DbSet<T> of an owned type (by design).', 'task_item': False}, {'text': 'You can’t call ModelBuilder.Entity<T>() on owned types (currently by design).', 'task_item': False}, {'text': 'No support for optional (that is, nullable) owned types that are mapped with the owner in the\nsame table (that is, using table splitting). This is because mapping is done for each property,\nthere is no separate sentinel for the null complex value as a whole.', 'task_item': False}, {'text': 'No inheritance-mapping support for owned types, but you should be able to map two leaf\ntypes of the same inheritance hierarchies as different owned types. EF Core will not reason\nabout the fact that they are part of the same hierarchy.', 'task_item': False}, {'text': '220 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '**Main differences with EF6’s complex types**', 'task_item': False}, {'text': 'Table splitting is optional, that is, they can optionally be mapped to a separate table and still\nbe owned types.', 'task_item': False}], [{'text': '**Martin Fowler. ValueObject pattern**\n[https://martinfowler.com/bliki/ValueObject.html](https://martinfowler.com/bliki/ValueObject.html)', 'task_item': False}, {'text': '**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.** (Book;\nincludes a discussion of value objects)\n[https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)\n[Software/dp/0321125215/](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)', 'task_item': False}, {'text': '**Vaughn Vernon. Implementing Domain-Driven Design.** (Book; includes a discussion of\nvalue objects)\n[https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/)\n[Vernon/dp/0321834577/](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/)', 'task_item': False}, {'text': '**Owned Entity Types**\n[https://learn.microsoft.com/ef/core/modeling/owned-entities](https://docs.microsoft.com/ef/core/modeling/owned-entities)', 'task_item': False}, {'text': '**Shadow Properties**\n[https://learn.microsoft.com/ef/core/modeling/shadow-properties](https://docs.microsoft.com/ef/core/modeling/shadow-properties)', 'task_item': False}, {'text': '**Complex types and/or value objects** . Discussion in the EF Core GitHub repo (Issues tab)\n[https://github.com/dotnet/efcore/issues/246](https://github.com/dotnet/efcore/issues/246)', 'task_item': False}, {'text': '**ValueObject.cs.** Base value object class in eShopOnContainers.\nhttps://github.com/dotnet[architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWor](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWork/ValueObject.cs)\n[k/ValueObject.cs](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWork/ValueObject.cs)', 'task_item': False}, {'text': '**ValueObject.cs.** Base value object class in CSharpFunctionalExtensions.\n[https://github.com/vkhorikov/CSharpFunctionalExtensions/blob/master/CSharpFunctionalExte](https://github.com/vkhorikov/CSharpFunctionalExtensions/blob/master/CSharpFunctionalExtensions/ValueObject/ValueObject.cs)\n[nsions/ValueObject/ValueObject.cs](https://github.com/vkhorikov/CSharpFunctionalExtensions/blob/master/CSharpFunctionalExtensions/ValueObject/ValueObject.cs)', 'task_item': False}, {'text': '**Address class.** Sample value object class in eShopOnContainers.\nhttps://github.com/dotnet[architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/Aggregat](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Address.cs)\n[esModel/OrderAggregate/Address.cs](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Address.cs)', 'task_item': False}], [{'text': '**Jimmy Bogard. Enumeration classes**\n[https://lostechies.com/jimmybogard/2008/08/12/enumeration-classes/](https://lostechies.com/jimmybogard/2008/08/12/enumeration-classes/)', 'task_item': False}, {'text': '**Steve Smith. Enum Alternatives in C#**\n[https://ardalis.com/enum-alternatives-in-c](https://ardalis.com/enum-alternatives-in-c)', 'task_item': False}, {'text': '**Enumeration.cs.** Base Enumeration class in eShopOnContainers\nhttps://github.com/dotnet[architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWor](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWork/Enumeration.cs)\n[k/Enumeration.cs](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWork/Enumeration.cs)', 'task_item': False}, {'text': '**CardType.cs** . Sample Enumeration class in eShopOnContainers.\nhttps://github.com/dotnet[architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/Aggregat](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/BuyerAggregate/CardType.cs)\n[esModel/BuyerAggregate/CardType.cs](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/BuyerAggregate/CardType.cs)', 'task_item': False}, {'text': '**SmartEnum** . Ardalis - Classes to help produce strongly typed smarter enums in .NET.\n[https://www.nuget.org/packages/Ardalis.SmartEnum/](https://www.nuget.org/packages/Ardalis.SmartEnum/)', 'task_item': False}], [{'text': '**Rachel Appel. Introduction to model validation in ASP.NET Core MVC**\n[https://learn.microsoft.com/aspnet/core/mvc/models/validation](https://docs.microsoft.com/aspnet/core/mvc/models/validation)', 'task_item': False}, {'text': '**Rick Anderson. Adding validation**\n[https://learn.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation](https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation)', 'task_item': False}, {'text': '225 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations**\n[https://martinfowler.com/articles/replaceThrowWithNotification.html](https://martinfowler.com/articles/replaceThrowWithNotification.html)', 'task_item': False}, {'text': '**Specification and Notification Patterns**\n[https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns](https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns)', 'task_item': False}, {'text': '**Lev Gorodinski. Validation in Domain-Driven Design (DDD)**\n[http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/](http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/)', 'task_item': False}, {'text': '**Colin Jack. Domain Model Validation**\n[https://colinjack.blogspot.com/2008/03/domain-model-validation.html](https://colinjack.blogspot.com/2008/03/domain-model-validation.html)', 'task_item': False}, {'text': '**Jimmy Bogard. Validation in a DDD world**\n[https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/](https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/)', 'task_item': False}], [{'text': '**Validate Text Input and Show Errors**\n[https://developer.xamarin.com/recipes/ios/standard_controls/text_field/validate_input/](https://developer.xamarin.com/recipes/ios/standard_controls/text_field/validate_input/)', 'task_item': False}, {'text': '**Validation Callback**\n[https://developer.xamarin.com/samples/xamarin-forms/XAML/ValidationCallback/](https://developer.xamarin.com/samples/xamarin-forms/XAML/ValidationCallback/)', 'task_item': False}, {'text': '**Validation in ASP.NET Core apps**', 'task_item': False}, {'text': '**Rick Anderson. Adding validation**\n[https://learn.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation](https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation)', 'task_item': False}, {'text': '**Validation in SPA Web apps (Angular 2, TypeScript, JavaScript, Blazor**\n**WebAssembly)**', 'task_item': False}, {'text': '**Form Validation**\n[https://angular.io/guide/form-validation](https://angular.io/guide/form-validation)', 'task_item': False}, {'text': '**Validation.** Breeze documentation.\n[https://breeze.github.io/doc-js/validation.html](https://breeze.github.io/doc-js/validation.html)', 'task_item': False}, {'text': '**ASP.NET Core Blazor forms and input components**', 'task_item': False}, {'text': 'In summary, these are the most important concepts in regards to validation:', 'task_item': False}, {'text': 'Entities and aggregates should enforce their own consistency and be “always valid”.\nAggregate roots are responsible for multi-entity consistency within the same aggregate.', 'task_item': False}, {'text': 'If you think that an entity needs to enter an invalid state, consider using a different object\nmodel—for example, using a temporary DTO until you create the final domain entity.', 'task_item': False}, {'text': 'If you need to create several related objects, such as an aggregate, and they are only valid\nonce all of them have been created, consider using the Factory pattern.', 'task_item': False}, {'text': 'In most of the cases, having redundant validation in the client side is good, because the\napplication can be proactive.', 'task_item': False}], [{'text': '**Greg Young. What is a Domain Event?**\n[https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25)', 'task_item': False}, {'text': '**Jan Stenberg. Domain Events and Eventual Consistency**\n[https://www.infoq.com/news/2015/09/domain-events-consistency](https://www.infoq.com/news/2015/09/domain-events-consistency)', 'task_item': False}, {'text': '**Jimmy Bogard. A better domain events pattern**\n[https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)', 'task_item': False}, {'text': '**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**\n[https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)', 'task_item': False}, {'text': '**Jimmy Bogard. Strengthening your domain: Domain Events**\n[https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)\nevents/', 'task_item': False}, {'text': '**Udi Dahan. How to create fully encapsulated Domain Models**\n[https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/](https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)', 'task_item': False}, {'text': '**Udi Dahan. Domain Events – Take 2**\n[https://udidahan.com/2008/08/25/domain-events-take-2/](https://udidahan.com/2008/08/25/domain-events-take-2/)', 'task_item': False}, {'text': '**Udi Dahan. Domain Events – Salvation**\n[https://udidahan.com/2009/06/14/domain-events-salvation/](https://udidahan.com/2009/06/14/domain-events-salvation/)', 'task_item': False}, {'text': '**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices**\n**architectures**\n[https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-](https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)\n[domain-driven-design-and-microservices-architectures/](https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)', 'task_item': False}], [{'text': '**Edward Hieatt and Rob Mee. Repository pattern.**\n[https://martinfowler.com/eaaCatalog/repository.html](https://martinfowler.com/eaaCatalog/repository.html)', 'task_item': False}, {'text': '**The Repository pattern**\n[https://learn.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))', 'task_item': False}, {'text': '**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.** (Book;\nincludes a discussion of the Repository pattern)\n[https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)\n[Software/dp/0321125215/](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)', 'task_item': False}, {'text': '**Unit of Work pattern**', 'task_item': False}, {'text': '**Martin Fowler. Unit of Work pattern.**\n[https://martinfowler.com/eaaCatalog/unitOfWork.html](https://martinfowler.com/eaaCatalog/unitOfWork.html)', 'task_item': False}, {'text': '**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC**\n**Application**\n[https://learn.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)\n[using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)\n[application](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)', 'task_item': False}], [{'text': '**Entity Framework Core**\n[https://learn.microsoft.com/ef/core/](https://docs.microsoft.com/ef/core/)', 'task_item': False}, {'text': '**Getting started with ASP.NET Core and Entity Framework Core using Visual Studio**\n[https://learn.microsoft.com/aspnet/core/data/ef-mvc/](https://docs.microsoft.com/aspnet/core/data/ef-mvc/)', 'task_item': False}, {'text': '**DbContext Class**\n[https://learn.microsoft.com/dotnet/api/microsoft.entityframeworkcore.dbcontext](https://docs.microsoft.com/dotnet/api/microsoft.entityframeworkcore.dbcontext)', 'task_item': False}, {'text': '**Compare EF Core & EF6.x**\n[https://learn.microsoft.com/ef/efcore-and-ef6/index](https://docs.microsoft.com/ef/efcore-and-ef6/index)', 'task_item': False}], [{'text': '**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC**\n**Application**\n[https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)\n[4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)', 'task_item': False}, {'text': '**Jonathan Allen. Implementation Strategies for the Repository Pattern with Entity**\n**Framework, Dapper, and Chain**\n[https://www.infoq.com/articles/repository-implementation-strategies](https://www.infoq.com/articles/repository-implementation-strategies)', 'task_item': False}, {'text': '**Cesar de la Torre. Comparing ASP.NET Core IoC container service lifetimes with Autofac**\n**IoC container instance scopes**\n[https://devblogs.microsoft.com/cesardelatorre/comparing-asp-net-core-ioc-service-life-](https://devblogs.microsoft.com/cesardelatorre/comparing-asp-net-core-ioc-service-life-times-and-autofac-ioc-instance-scopes/)\n[times-and-autofac-ioc-instance-scopes/](https://devblogs.microsoft.com/cesardelatorre/comparing-asp-net-core-ioc-service-life-times-and-autofac-ioc-instance-scopes/)', 'task_item': False}, {'text': '249 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}], [{'text': 'It does not break the Unit of Work pattern.', 'task_item': False}, {'text': 'It gets sequence IDs in batches, to minimize round trips to the database.', 'task_item': False}, {'text': 'It generates a human readable identifier, unlike techniques that use GUIDs.', 'task_item': False}, {'text': '[EF Core supports HiLo](https://stackoverflow.com/questions/282099/whats-the-hi-lo-algorithm) with the UseHiLo method, as shown in the preceding example.', 'task_item': False}, {'text': '**Map fields instead of properties**', 'task_item': False}, {'text': 'With this feature, available since EF Core 1.1, you can directly map columns to fields. It is possible to\nnot use properties in the entity class, and just to map columns from a table to fields. A common use\nfor that would be private fields for any internal state that do not need to be accessed from outside the\nentity.', 'task_item': False}, {'text': 'You can do this with single fields or also with collections, like a List<> field. This point was mentioned\nearlier when we discussed modeling the domain model classes, but here you can see how that\nmapping is performed with the PropertyAccessMode.Field configuration highlighted in the previous\ncode.', 'task_item': False}, {'text': '**Use shadow properties in EF Core, hidden at the infrastructure level**', 'task_item': False}, {'text': 'Shadow properties in EF Core are properties that do not exist in your entity class model. The values\n[and states of these properties are maintained purely in the ChangeTracker](https://docs.microsoft.com/ef/core/api/microsoft.entityframeworkcore.changetracking.changetracker) class at the infrastructure\nlevel.', 'task_item': False}, {'text': '252 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}], [{'text': '**Table Mapping**\n[https://learn.microsoft.com/ef/core/modeling/relational/tables](https://docs.microsoft.com/ef/core/modeling/relational/tables)', 'task_item': False}, {'text': '**Use HiLo to generate keys with Entity Framework Core**\n[https://www.talkingdotnet.com/use-hilo-to-generate-keys-with-entity-framework-core/](https://www.talkingdotnet.com/use-hilo-to-generate-keys-with-entity-framework-core/)', 'task_item': False}, {'text': '**Backing Fields**\n[https://learn.microsoft.com/ef/core/modeling/backing-field](https://docs.microsoft.com/ef/core/modeling/backing-field)', 'task_item': False}, {'text': '**Steve Smith. Encapsulated Collections in Entity Framework Core**\n[https://ardalis.com/encapsulated-collections-in-entity-framework-core](https://ardalis.com/encapsulated-collections-in-entity-framework-core)', 'task_item': False}, {'text': '**Shadow Properties**\n[https://learn.microsoft.com/ef/core/modeling/shadow-properties](https://docs.microsoft.com/ef/core/modeling/shadow-properties)', 'task_item': False}, {'text': '**The Specification pattern**\n[https://deviq.com/specification-pattern/](https://deviq.com/specification-pattern/)', 'task_item': False}, {'text': '**Ardalis.Specification NuGet Package** Used by\n[eShopOnWeb. https://www.nuget.org/packages/Ardalis.Specification](https://www.nuget.org/packages/Ardalis.Specification)', 'task_item': False}], [{'text': '**Modeling document data for NoSQL databases**\n[https://learn.microsoft.com/azure/cosmos-db/modeling-data](https://docs.microsoft.com/azure/cosmos-db/modeling-data)', 'task_item': False}, {'text': '**Vaughn Vernon. The Ideal Domain-Driven Design Aggregate Store?**\n[https://kalele.io/blog-posts/the-ideal-domain-driven-design-aggregate-store/](https://kalele.io/blog-posts/the-ideal-domain-driven-design-aggregate-store/)', 'task_item': False}, {'text': '**Introduction to Azure Cosmos DB: API for MongoDB**\n[https://learn.microsoft.com/azure/cosmos-db/mongodb-introduction](https://docs.microsoft.com/azure/cosmos-db/mongodb-introduction)', 'task_item': False}, {'text': '**Azure Cosmos DB: Build a MongoDB API web app with .NET and the Azure portal**\n[https://learn.microsoft.com/azure/cosmos-db/create-mongodb-dotnet](https://docs.microsoft.com/azure/cosmos-db/create-mongodb-dotnet)', 'task_item': False}, {'text': '**Use the Azure Cosmos DB Emulator for local development and testing**\n[https://learn.microsoft.com/azure/cosmos-db/local-emulator](https://docs.microsoft.com/azure/cosmos-db/local-emulator)', 'task_item': False}, {'text': '**Connect a MongoDB application to Azure Cosmos DB**\n[https://learn.microsoft.com/azure/cosmos-db/connect-mongodb-account](https://docs.microsoft.com/azure/cosmos-db/connect-mongodb-account)', 'task_item': False}, {'text': '**The Cosmos DB Emulator Docker image (Windows Container)**\n[https://hub.docker.com/r/microsoft/azure-cosmosdb-emulator/](https://hub.docker.com/r/microsoft/azure-cosmosdb-emulator/)', 'task_item': False}, {'text': '**The MongoDB Docker image (Linux and Windows Container)**\n[https://hub.docker.com/_/mongo/](https://hub.docker.com/_/mongo/)', 'task_item': False}, {'text': '**Use MongoChef (Studio 3T) with an Azure Cosmos DB: API for MongoDB account**\n[https://learn.microsoft.com/azure/cosmos-db/mongodb-mongochef](https://docs.microsoft.com/azure/cosmos-db/mongodb-mongochef)', 'task_item': False}, {'text': '265 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}], [{'text': 'Single Responsibility principle', 'task_item': False}, {'text': 'Open/closed principle', 'task_item': False}, {'text': 'Liskov substitution principle', 'task_item': False}, {'text': 'Interface Segregation principle', 'task_item': False}, {'text': 'Dependency Inversion principle', 'task_item': False}, {'text': 'SOLID is more about how you design your application or microservice internal layers and about\ndecoupling dependencies between them. It is not related to the domain, but to the application’s\ntechnical design. The final principle, the Dependency Inversion principle, allows you to decouple the\ninfrastructure layer from the rest of the layers, which allows a better decoupled implementation of the\nDDD layers.', 'task_item': False}, {'text': 'Dependency Injection (DI) is one way to implement the Dependency Inversion principle. It is a\ntechnique for achieving loose coupling between objects and their dependencies. Rather than directly\ninstantiating collaborators, or using static references (that is, using new…), the objects that a class\nneeds in order to perform its actions are provided to (or “injected into”) the class. Most often, classes\nwill declare their dependencies via their constructor, allowing them to follow the Explicit\nDependencies principle. Dependency Injection is usually based on specific Inversion of Control (IoC)\ncontainers. ASP.NET Core provides a simple built-in IoC container, but you can also use your favorite\nIoC container, like Autofac or Ninject.', 'task_item': False}, {'text': 'By following the SOLID principles, your classes will tend naturally to be small, well-factored, and easily\ntested. But how can you know if too many dependencies are being injected into your classes? If you\nuse DI through the constructor, it will be easy to detect that by just looking at the number of\n[parameters for your constructor. If there are too many dependencies, this is generally a sign (a code](https://deviq.com/code-smells/)\n[smell) that your class is trying to do too much, and is probably violating the Single Responsibility](https://deviq.com/code-smells/)\nprinciple.', 'task_item': False}, {'text': 'It would take another guide to cover SOLID in detail. Therefore, this guide requires you to have only a\nminimum knowledge of these topics.', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**SOLID: Fundamental OOP Principles**\n[https://deviq.com/solid/](https://deviq.com/solid/)', 'task_item': False}, {'text': '266 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '**Inversion of Control Containers and the Dependency Injection pattern**\n[https://martinfowler.com/articles/injection.html](https://martinfowler.com/articles/injection.html)', 'task_item': False}, {'text': '**Steve Smith. New is Glue**\n[https://ardalis.com/new-is-glue](https://ardalis.com/new-is-glue)', 'task_item': False}], [{'text': '**Matthew King. Registering services with Scrutor**\n[https://www.mking.net/blog/registering-services-with-scrutor](https://www.mking.net/blog/registering-services-with-scrutor)', 'task_item': False}, {'text': '**Kristian Hellang. Scrutor.** GitHub repo.\n[https://github.com/khellang/Scrutor](https://github.com/khellang/Scrutor)', 'task_item': False}, {'text': '**Use Autofac as an IoC container**', 'task_item': False}, {'text': 'You can also use additional IoC containers and plug them into the ASP.NET Core pipeline, as in the\n[ordering microservice in eShopOnContainers, which uses Autofac. When using Autofac you typically](https://autofac.org/)\nregister the types via modules, which allow you to split the registration types between multiple files\ndepending on where your types are, just as you could have the application types distributed across\nmultiple class libraries.', 'task_item': False}, {'text': '[For example, the following is the Autofac application module](https://github.com/dotnet-architecture/eShopOnContainers/blob/main/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/ApplicationModule.cs) [for the Ordering.API Web API project](https://github.com/dotnet-architecture/eShopOnContainers/tree/main/src/Services/Ordering/Ordering.API)\nwith the types you will want to inject.', 'task_item': False}, {'text': '[Autofac also has a feature to scan assemblies and register types by name conventions.](https://autofac.readthedocs.io/en/latest/register/scanning.html)', 'task_item': False}, {'text': 'The registration process and concepts are very similar to the way you can register types with the builtin ASP.NET Core IoC container, but the syntax when using Autofac is a bit different.', 'task_item': False}, {'text': 'In the example code, the abstraction IOrderRepository is registered along with the implementation\nclass OrderRepository. This means that whenever a constructor is declaring a dependency through the', 'task_item': False}, {'text': '270 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': 'IOrderRepository abstraction or interface, the IoC container will inject an instance of the\nOrderRepository class.', 'task_item': False}, {'text': 'The instance scope type determines how an instance is shared between requests for the same service\nor dependency. When a request is made for a dependency, the IoC container can return the following:', 'task_item': False}, {'text': 'A single instance per lifetime scope (referred to in the ASP.NET Core IoC container as _scoped_ ).', 'task_item': False}, {'text': 'A new instance per dependency (referred to in the ASP.NET Core IoC container as _transient_ ).', 'task_item': False}, {'text': 'A single instance shared across all objects using the IoC container (referred to in the ASP.NET\nCore IoC container as _singleton_ ).', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**Introduction to Dependency Injection in ASP.NET Core**\n[https://learn.microsoft.com/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection)', 'task_item': False}, {'text': '**Autofac.** Official documentation.\n[https://docs.autofac.org/en/latest/](https://docs.autofac.org/en/latest/)', 'task_item': False}, {'text': '**Comparing ASP.NET Core IoC container service lifetimes with Autofac IoC container**\n**instance scopes - Cesar de la Torre.**\n[https://devblogs.microsoft.com/cesardelatorre/comparing-asp-net-core-ioc-service-life-](https://devblogs.microsoft.com/cesardelatorre/comparing-asp-net-core-ioc-service-life-times-and-autofac-ioc-instance-scopes/)\n[times-and-autofac-ioc-instance-scopes/](https://devblogs.microsoft.com/cesardelatorre/comparing-asp-net-core-ioc-service-life-times-and-autofac-ioc-instance-scopes/)', 'task_item': False}], [{'text': '[It receives the command object, like a DTO (from the mediator](https://en.wikipedia.org/wiki/Mediator_pattern) or other infrastructure object).', 'task_item': False}, {'text': 'It validates that the command is valid (if not validated by the mediator).', 'task_item': False}, {'text': 'It instantiates the aggregate root instance that is the target of the current command.', 'task_item': False}, {'text': 'It executes the method on the aggregate root instance, getting the required data from the\ncommand.', 'task_item': False}, {'text': 'It persists the new state of the aggregate to its related database. This last operation is the\nactual transaction.', 'task_item': False}, {'text': 'Typically, a command handler deals with a single aggregate driven by its aggregate root (root entity).\nIf multiple aggregates should be impacted by the reception of a single command, you could use\ndomain events to propagate states or actions across multiple aggregates.', 'task_item': False}, {'text': 'The important point here is that when a command is being processed, all the domain logic should be\ninside the domain model (the aggregates), fully encapsulated and ready for unit testing. The\ncommand handler just acts as a way to get the domain model from the database, and as the final\nstep, to tell the infrastructure layer (repositories) to persist the changes when the model is changed.\nThe advantage of this approach is that you can refactor the domain logic in an isolated, fully\nencapsulated, rich, behavioral domain model without changing code in the application or\ninfrastructure layers, which are the plumbing level (command handlers, Web API, repositories, etc.).', 'task_item': False}, {'text': 'When command handlers get complex, with too much logic, that can be a code smell. Review them,\nand if you find domain logic, refactor the code to move that domain behavior to the methods of the\ndomain objects (the aggregate root and child entity).', 'task_item': False}, {'text': 'As an example of a command handler class, the following code shows the same\nCreateOrderCommandHandler class that you saw at the beginning of this chapter. In this case, it also\nhighlights the Handle method and the operations with the domain model objects/aggregates.', 'task_item': False}, {'text': '276 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': 'These are additional steps a command handler should take:', 'task_item': False}, {'text': 'Use the command’s data to operate with the aggregate root’s methods and behavior.', 'task_item': False}, {'text': 'Internally within the domain objects, raise domain events while the transaction is executed,\nbut that is transparent from a command handler point of view.', 'task_item': False}, {'text': 'If the aggregate’s operation result is successful and after the transaction is finished, raise\nintegration events. (These might also be raised by infrastructure classes like repositories.)', 'task_item': False}, {'text': '277 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '**Mark Seemann. At the Boundaries, Applications are Not Object-Oriented**\n[https://blog.ploeh.dk/2011/05/31/AttheBoundaries,ApplicationsareNotObject-Oriented/](https://blog.ploeh.dk/2011/05/31/AttheBoundaries,ApplicationsareNotObject-Oriented/)', 'task_item': False}, {'text': '**Commands and events**\n[https://cqrs.nu/faq/Command%20and%20Events](https://cqrs.nu/faq/Command%20and%20Events)', 'task_item': False}, {'text': '**What does a command handler do?**\n[https://cqrs.nu/faq/Command%20Handlers](https://cqrs.nu/faq/Command%20Handlers)', 'task_item': False}, {'text': '**Jimmy Bogard. Domain Command Patterns – Handlers**\n[https://jimmybogard.com/domain-command-patterns-handlers/](https://jimmybogard.com/domain-command-patterns-handlers/)', 'task_item': False}, {'text': '**Jimmy Bogard. Domain Command Patterns – Validation**\n[https://jimmybogard.com/domain-command-patterns-validation/](https://jimmybogard.com/domain-command-patterns-validation/)', 'task_item': False}], [{'text': 'Through an in-memory Mediator pattern artifact.', 'task_item': False}, {'text': 'With an asynchronous message queue, in between controllers and handlers.', 'task_item': False}, {'text': '**Use the Mediator pattern (in-memory) in the command pipeline**', 'task_item': False}, {'text': 'As shown in Figure 7-25, in a CQRS approach you use an intelligent mediator, similar to an in-memory\nbus, which is smart enough to redirect to the right command handler based on the type of the\ncommand or DTO being received. The single black arrows between components represent the\ndependencies between objects (in many cases, injected through DI) with their related interactions.', 'task_item': False}, {'text': '278 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '_Figure 7-25. Using the Mediator pattern in process in a single CQRS microservice_', 'task_item': False}, {'text': 'The above diagram shows a zoom-in from image 7-24: the ASP.NET Core controller sends the\ncommand to MediatR’s command pipeline, so they get to the appropriate handler.', 'task_item': False}, {'text': 'The reason that using the Mediator pattern makes sense is that in enterprise applications, the\nprocessing requests can get complicated. You want to be able to add an open number of crosscutting concerns like logging, validations, audit, and security. In these cases, you can rely on a\n[mediator pipeline (see Mediator pattern) to provide a means for these extra behaviors or cross-](https://en.wikipedia.org/wiki/Mediator_pattern)\ncutting concerns.', 'task_item': False}, {'text': 'A mediator is an object that encapsulates the “how” of this process: it coordinates execution based on\nstate, the way a command handler is invoked, or the payload you provide to the handler. With a\nmediator component, you can apply cross-cutting concerns in a centralized and transparent way by\n[applying decorators (or pipeline behaviors since MediatR 3). For more information, see the Decorator](https://github.com/jbogard/MediatR/wiki/Behaviors)\n[pattern.](https://en.wikipedia.org/wiki/Decorator_pattern)', 'task_item': False}, {'text': '[Decorators and behaviors are similar to Aspect Oriented Programming (AOP), only applied to a](https://en.wikipedia.org/wiki/Aspect-oriented_programming)\nspecific process pipeline managed by the mediator component. Aspects in AOP that implement crosscutting concerns are applied based on _aspect weavers_ injected at compilation time or based on object\ncall interception. Both typical AOP approaches are sometimes said to work “like magic,” because it is\nnot easy to see how AOP does its work. When dealing with serious issues or bugs, AOP can be difficult\nto debug. On the other hand, these decorators/behaviors are explicit and applied only in the context\nof the mediator, so debugging is much more predictable and easy.', 'task_item': False}, {'text': 'For example, in the eShopOnContainers ordering microservice, has an implementation of two sample\n[behaviors, a LogBehavior class and a ValidatorBehavior](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/Behaviors/LoggingBehavior.cs) class. The implementation of the behaviors is\n[explained in the next section by showing how eShopOnContainers uses MediatR](https://www.nuget.org/packages/MediatR) [behaviors.](https://github.com/jbogard/MediatR/wiki/Behaviors)', 'task_item': False}, {'text': '279 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '**Use message queues (out-of-proc) in the command’s pipeline**', 'task_item': False}, {'text': 'Another choice is to use asynchronous messages based on brokers or message queues, as shown in\nFigure 7-26. That option could also be combined with the mediator component right before the\ncommand handler.', 'task_item': False}, {'text': '_Figure 7-26. Using message queues (out of the process and inter-process communication) with CQRS commands_', 'task_item': False}, {'text': 'Command’s pipeline can also be handled by a high availability message queue to deliver the\ncommands to the appropriate handler. Using message queues to accept the commands can further\ncomplicate your command’s pipeline, because you will probably need to split the pipeline into two\nprocesses connected through the external message queue. Still, it should be used if you need to have\nimproved scalability and performance based on asynchronous messaging. Consider that in the case of\nFigure 7-26, the controller just posts the command message into the queue and returns. Then the\ncommand handlers process the messages at their own pace. That is a great benefit of queues: the\nmessage queue can act as a buffer in cases when hyper scalability is needed, such as for stocks or any\nother scenario with a high volume of ingress data.', 'task_item': False}, {'text': 'However, because of the asynchronous nature of message queues, you need to figure out how to\ncommunicate with the client application about the success or failure of the command’s process. As a\nrule, you should never use “fire and forget” commands. Every business application needs to know if a\ncommand was processed successfully, or at least validated and accepted.', 'task_item': False}, {'text': 'Thus, being able to respond to the client after validating a command message that was submitted to\nan asynchronous queue adds complexity to your system, as compared to an in-process command\nprocess that returns the operation’s result after running the transaction. Using queues, you might\nneed to return the result of the command process through other operation result messages, which will\nrequire additional components and custom communication in your system.', 'task_item': False}, {'text': '280 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': 'Additionally, async commands are one-way commands, which in many cases might not be needed, as\nis explained in the following interesting exchange between Burtsev Alexey and Greg Young in an\n[online conversation:](https://groups.google.com/forum/#!msg/dddcqrs/xhJHVxDx2pM/WP9qP8ifYCwJ)', 'task_item': False}, {'text': '[Burtsev Alexey] I find lots of code where people use async command handling or one-way command\nmessaging without any reason to do so (they are not doing some long operation, they are not\nexecuting external async code, they do not even cross-application boundary to be using message\nbus). Why do they introduce this unnecessary complexity? And actually, I haven’t seen a CQRS code\nexample with blocking command handlers so far, though it will work just fine in most cases.', 'task_item': False}, {'text': '[Greg Young] […] an asynchronous command doesn’t exist; it’s actually another event. If I must accept\nwhat you send me and raise an event if I disagree, it’s no longer you telling me to do something [that\nis, it’s not a command]. It’s you telling me something has been done. This seems like a slight\ndifference at first, but it has many implications.', 'task_item': False}, {'text': 'Asynchronous commands greatly increase the complexity of a system, because there is no simple way\nto indicate failures. Therefore, asynchronous commands are not recommended other than when\nscaling requirements are needed or in special cases when communicating the internal microservices\nthrough messaging. In those cases, you must design a separate reporting and recovery system for\nfailures.', 'task_item': False}, {'text': 'In the initial version of eShopOnContainers, it was decided to use synchronous command processing,\nstarted from HTTP requests and driven by the Mediator pattern. That easily allows you to return the\n[success or failure of the process, as in the CreateOrderCommandHandler implementation.](https://github.com/dotnet-architecture/eShopOnContainers/blob/netcore1.1/src/Services/Ordering/Ordering.API/Application/Commands/CreateOrderCommandHandler.cs)', 'task_item': False}, {'text': 'In any case, this should be a decision based on your application’s or microservice’s business\nrequirements.', 'task_item': False}], [{'text': '**Mediator pattern**\n[https://en.wikipedia.org/wiki/Mediator_pattern](https://en.wikipedia.org/wiki/Mediator_pattern)', 'task_item': False}, {'text': 'The decorator pattern', 'task_item': False}, {'text': '**Decorator pattern**\n[https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern)', 'task_item': False}, {'text': 'MediatR (Jimmy Bogard)', 'task_item': False}, {'text': '**MediatR.** GitHub repo.\n[https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)', 'task_item': False}, {'text': '**CQRS with MediatR and AutoMapper**\n[https://lostechies.com/jimmybogard/2015/05/05/cqrs-with-mediatr-and-automapper/](https://lostechies.com/jimmybogard/2015/05/05/cqrs-with-mediatr-and-automapper/)', 'task_item': False}, {'text': '**Put your controllers on a diet: POSTs and commands.**\n[https://lostechies.com/jimmybogard/2013/12/19/put-your-controllers-on-a-diet-posts-and-](https://lostechies.com/jimmybogard/2013/12/19/put-your-controllers-on-a-diet-posts-and-commands/)\n[commands/](https://lostechies.com/jimmybogard/2013/12/19/put-your-controllers-on-a-diet-posts-and-commands/)', 'task_item': False}, {'text': '289 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '**Tackling cross-cutting concerns with a mediator pipeline**\n[https://lostechies.com/jimmybogard/2014/09/09/tackling-cross-cutting-concerns-with-a-](https://lostechies.com/jimmybogard/2014/09/09/tackling-cross-cutting-concerns-with-a-mediator-pipeline/)\n[mediator-pipeline/](https://lostechies.com/jimmybogard/2014/09/09/tackling-cross-cutting-concerns-with-a-mediator-pipeline/)', 'task_item': False}, {'text': '**CQRS and REST: the perfect match**\n[https://lostechies.com/jimmybogard/2016/06/01/cqrs-and-rest-the-perfect-match/](https://lostechies.com/jimmybogard/2016/06/01/cqrs-and-rest-the-perfect-match/)', 'task_item': False}, {'text': '**MediatR Pipeline Examples**\n[https://lostechies.com/jimmybogard/2016/10/13/mediatr-pipeline-examples/](https://lostechies.com/jimmybogard/2016/10/13/mediatr-pipeline-examples/)', 'task_item': False}, {'text': '**Vertical Slice Test Fixtures for MediatR and ASP.NET Core**\n[https://lostechies.com/jimmybogard/2016/10/24/vertical-slice-test-fixtures-for-mediatr-and-](https://lostechies.com/jimmybogard/2016/10/24/vertical-slice-test-fixtures-for-mediatr-and-asp-net-core/)\n[asp-net-core/](https://lostechies.com/jimmybogard/2016/10/24/vertical-slice-test-fixtures-for-mediatr-and-asp-net-core/)', 'task_item': False}, {'text': '**MediatR Extensions for Microsoft Dependency Injection Released**\n[https://lostechies.com/jimmybogard/2016/07/19/mediatr-extensions-for-microsoft-](https://lostechies.com/jimmybogard/2016/07/19/mediatr-extensions-for-microsoft-dependency-injection-released/)\n[dependency-injection-released/](https://lostechies.com/jimmybogard/2016/07/19/mediatr-extensions-for-microsoft-dependency-injection-released/)', 'task_item': False}, {'text': 'Fluent validation', 'task_item': False}, {'text': '**Jeremy Skinner. FluentValidation.** GitHub repo.\n[https://github.com/JeremySkinner/FluentValidation](https://github.com/JeremySkinner/FluentValidation)', 'task_item': False}, {'text': '290 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '_**CHAPTER**_', 'task_item': False}], [{'text': '**Resiliency patterns**\n[https://learn.microsoft.com/azure/architecture/framework/resiliency/reliability-patterns](https://docs.microsoft.com/azure/architecture/framework/resiliency/reliability-patterns)', 'task_item': False}, {'text': '**Adding Resilience and Optimizing Performance**\n[https://learn.microsoft.com/previous-versions/msp-n-p/jj591574(v=pandp.10)](https://docs.microsoft.com/previous-versions/msp-n-p/jj591574(v=pandp.10))', 'task_item': False}, {'text': '**Bulkhead.** GitHub repo. Implementation with Polly policy.\n[https://github.com/App-vNext/Polly/wiki/Bulkhead](https://github.com/App-vNext/Polly/wiki/Bulkhead)', 'task_item': False}, {'text': '**Designing resilient applications for Azure**\n[https://learn.microsoft.com/azure/architecture/framework/resiliency/app-design](https://docs.microsoft.com/azure/architecture/framework/resiliency/app-design)', 'task_item': False}, {'text': '**Transient fault handling**\n[https://learn.microsoft.com/azure/architecture/best-practices/transient-faults](https://docs.microsoft.com/azure/architecture/best-practices/transient-faults)', 'task_item': False}], [{'text': '**Connection Resiliency and Command Interception with EF in an ASP.NET MVC**\n**Application**\n[https://learn.microsoft.com/aspnet/mvc/overview/getting-started/getting-started-with-ef-](https://docs.microsoft.com/aspnet/mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application)\n[using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-](https://docs.microsoft.com/aspnet/mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application)\n[an-asp-net-mvc-application](https://docs.microsoft.com/aspnet/mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application)', 'task_item': False}, {'text': '**Cesar de la Torre. Using Resilient Entity Framework Core SQL Connections and**\n**Transactions**\n[https://devblogs.microsoft.com/cesardelatorre/using-resilient-entity-framework-core-sql-](https://devblogs.microsoft.com/cesardelatorre/using-resilient-entity-framework-core-sql-connections-and-transactions-retries-with-exponential-backoff/)\n[connections-and-transactions-retries-with-exponential-backoff/](https://devblogs.microsoft.com/cesardelatorre/using-resilient-entity-framework-core-sql-connections-and-transactions-retries-with-exponential-backoff/)', 'task_item': False}], [{'text': 'Provides a central location for naming and configuring logical HttpClient objects. For\nexample, you may configure a client (Service Agent) that’s pre-configured to access a specific\nmicroservice.', 'task_item': False}, {'text': 'Codify the concept of outgoing middleware via delegating handlers in HttpClient and\nimplementing Polly-based middleware to take advantage of Polly’s policies for resiliency.', 'task_item': False}, {'text': 'HttpClient already has the concept of delegating handlers that could be linked together for\noutgoing HTTP requests. You can register HTTP clients into the factory and you can use a\nPolly handler to use Polly policies for Retry, CircuitBreakers, and so on.', 'task_item': False}, {'text': '[Manage the lifetime of HttpMessageHandler](https://docs.microsoft.com/dotnet/api/system.net.http.httpmessagehandler) to avoid the mentioned problems/issues that\ncan occur when managing HttpClient lifetimes yourself.', 'task_item': False}, {'text': '299 CHAPTER 7 | Implement resilient applications', 'task_item': False}], [{'text': 'Basic usage', 'task_item': False}, {'text': 'Use Named Clients', 'task_item': False}, {'text': 'Use Typed Clients', 'task_item': False}, {'text': 'Use Generated Clients', 'task_item': False}, {'text': 'For the sake of brevity, this guidance shows the most structured way to use IHttpClientFactory, which\nis to use Typed Clients (Service Agent pattern). However, all options are documented and are currently\n[listed in this article covering the IHttpClientFactory usage.](https://docs.microsoft.com/aspnet/core/fundamentals/http-requests#consumption-patterns)', 'task_item': False}], [{'text': '**HttpClient guidelines for .NET**\n[https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-](https://docs.microsoft.com/dotnet/fundamentals/networking/http/httpclient-guidelines)\n[guidelines](https://docs.microsoft.com/dotnet/fundamentals/networking/http/httpclient-guidelines)', 'task_item': False}, {'text': '**Using HttpClientFactory in .NET**\n[https://learn.microsoft.com/en-us/dotnet/core/extensions/httpclient-factory](https://docs.microsoft.com/dotnet/core/extensions/httpclient-factory)', 'task_item': False}, {'text': '**Using HttpClientFactory in ASP.NET Core**\n[https://learn.microsoft.com/aspnet/core/fundamentals/http-requests](https://docs.microsoft.com/aspnet/core/fundamentals/http-requests)', 'task_item': False}, {'text': '**HttpClientFactory source code in the dotnet/runtime GitHub repository**\n[https://github.com/dotnet/runtime/tree/release/7.0/src/libraries/Microsoft.Extensions.Http/](https://github.com/dotnet/runtime/tree/release/7.0/src/libraries/Microsoft.Extensions.Http/)', 'task_item': False}, {'text': '**Polly (.NET resilience and transient-fault-handling library)**\n[https://thepollyproject.azurewebsites.net/](https://thepollyproject.azurewebsites.net/)', 'task_item': False}], [{'text': '[Install with Visual Studio](https://docs.microsoft.com/nuget/consume-packages/install-use-packages-visual-studio)', 'task_item': False}, {'text': '[Install with dotnet CLI](https://docs.microsoft.com/nuget/consume-packages/install-use-packages-dotnet-cli)', 'task_item': False}, {'text': '[Install with nuget.exe CLI](https://docs.microsoft.com/nuget/consume-packages/install-use-packages-nuget-cli)', 'task_item': False}, {'text': '[Install with Package Manager Console (PowerShell)](https://docs.microsoft.com/nuget/consume-packages/install-use-packages-powershell)', 'task_item': False}, {'text': '**Reference the .NET 7 packages**', 'task_item': False}, {'text': 'IHttpClientFactory is available since .NET Core 2.1, however, we recommend you use the latest .NET 7\npackages from NuGet in your project. You typically also need to reference the extension package\nMicrosoft.Extensions.Http.Polly.', 'task_item': False}, {'text': '**Configure a client with Polly’s Retry policy, in app startup**', 'task_item': False}, {'text': 'The **AddPolicyHandler()** method is what adds policies to the HttpClient objects you’ll use. In this\ncase, it’s adding a Polly’s policy for Http Retries with exponential backoff.', 'task_item': False}, {'text': 'To have a more modular approach, the Http Retry Policy can be defined in a separate method within\nthe _Program.cs_ file, as shown in the following code:', 'task_item': False}, {'text': 'As shown in previous sections, you need to define a named or typed client HttpClient configuration in\nyour standard _Program.cs_ app configuration. Now you add incremental code specifying the policy for\nthe Http retries with exponential backoff, as follows:', 'task_item': False}, {'text': 'With Polly, you can define a Retry policy with the number of retries, the exponential backoff\nconfiguration, and the actions to take when there’s an HTTP exception, such as logging the error. In\nthis case, the policy is configured to try six times with an exponential retry, starting at two seconds.', 'task_item': False}], [{'text': '**Retry pattern** [https://learn.microsoft.com/azure/architecture/patterns/retry](https://docs.microsoft.com/azure/architecture/patterns/retry)', 'task_item': False}, {'text': '**Polly and IHttpClientFactory** [https://github.com/App-vNext/Polly/wiki/Polly-and-](https://github.com/App-vNext/Polly/wiki/Polly-and-HttpClientFactory)\n[HttpClientFactory](https://github.com/App-vNext/Polly/wiki/Polly-and-HttpClientFactory)', 'task_item': False}, {'text': '**Polly (.NET resilience and transient-fault-handling library)** [https://github.com/App-](https://github.com/App-vNext/Polly)\n[vNext/Polly](https://github.com/App-vNext/Polly)', 'task_item': False}, {'text': '**Polly: Retry with Jitter** [https://github.com/App-vNext/Polly/wiki/Retry-with-jitter](https://github.com/App-vNext/Polly/wiki/Retry-with-jitter)', 'task_item': False}, {'text': '**Marc Brooker. Jitter: Making Things Better With Randomness**\n[https://brooker.co.za/blog/2015/03/21/backoff.html](https://brooker.co.za/blog/2015/03/21/backoff.html)', 'task_item': False}], [{'text': 'GET http://localhost:5103/failing\nThis request returns the current state of the middleware. If the middleware is enabled, the\nrequest return status code 500. If the middleware is disabled, there’s no response.', 'task_item': False}, {'text': 'GET http://localhost:5103/failing?enable\nThis request enables the middleware.', 'task_item': False}, {'text': '308 CHAPTER 7 | Implement resilient applications', 'task_item': False}, {'text': 'GET http://localhost:5103/failing?disable\nThis request disables the middleware.', 'task_item': False}, {'text': 'For instance, once the application is running, you can enable the middleware by making a request\nusing the following URI in any browser. Note that the ordering microservice uses port 5103.', 'task_item': False}, {'text': 'http://localhost:5103/failing?enable', 'task_item': False}, {'text': 'You can then check the status using the URI http://localhost:5103/failing, as shown in Figure 8-5.', 'task_item': False}, {'text': '_Figure 8-5. Checking the state of the “Failing” ASP.NET middleware – In this case, disabled._', 'task_item': False}, {'text': 'At this point, the Basket microservice responds with status code 500 whenever you call invoke it.', 'task_item': False}, {'text': 'Once the middleware is running, you can try making an order from the MVC web application. Because\nthe requests fail, the circuit will open.', 'task_item': False}, {'text': 'In the following example, you can see that the MVC web application has a catch block in the logic for\nplacing an order. If the code catches an open-circuit exception, it shows the user a friendly message\ntelling them to wait.', 'task_item': False}, {'text': 'Here’s a summary. The Retry policy tries several times to make the HTTP request and gets HTTP errors.\nWhen the number of retries reaches the maximum number set for the Circuit Breaker policy (in this\ncase, 5), the application throws a BrokenCircuitException. The result is a friendly message, as shown in\nFigure 8-6.', 'task_item': False}, {'text': '309 CHAPTER 7 | Implement resilient applications', 'task_item': False}, {'text': '_Figure 8-6. Circuit breaker returning an error to the UI_', 'task_item': False}, {'text': 'You can implement different logic for when to open/break the circuit. Or you can try an HTTP request\nagainst a different back-end microservice if there’s a fallback datacenter or redundant back-end\nsystem.', 'task_item': False}, {'text': 'Finally, another possibility for the CircuitBreakerPolicy is to use Isolate (which forces open and holds\nopen the circuit) and Reset (which closes it again). These could be used to build a utility HTTP\nendpoint that invokes Isolate and Reset directly on the policy. Such an HTTP endpoint could also be\nused, suitably secured, in production for temporarily isolating a downstream system, such as when\nyou want to upgrade it. Or it could trip the circuit manually to protect a downstream system you\nsuspect to be faulting.', 'task_item': False}], [{'text': '**Circuit Breaker pattern**\n[https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker)', 'task_item': False}], [{'text': '**HealthChecks and HealthChecks UI for ASP.NET Core**\n[https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks)', 'task_item': False}, {'text': '**Introduction to Service Fabric health monitoring**\n[https://learn.microsoft.com/azure/service-fabric/service-fabric-health-introduction](https://docs.microsoft.com/azure/service-fabric/service-fabric-health-introduction)', 'task_item': False}, {'text': '**Azure Monitor**\n[https://azure.microsoft.com/services/monitor/](https://azure.microsoft.com/services/monitor/)', 'task_item': False}, {'text': '318 CHAPTER 7 | Implement resilient applications', 'task_item': False}, {'text': '**CHAPTER**', 'task_item': False}], [{'text': 'Create new user information using the UserManager type (userManager.CreateAsync).', 'task_item': False}, {'text': 'Authenticate users using the SignInManager type. You can use signInManager.SignInAsync to\nsign in directly, or signInManager.PasswordSignInAsync to confirm the user’s password is\ncorrect and then sign them in.', 'task_item': False}, {'text': 'Identify a user based on information stored in a cookie (which is read by ASP.NET Core\nIdentity middleware) so that subsequent requests from a browser will include a signed-in\nuser’s identity and claims.', 'task_item': False}, {'text': '[ASP.NET Core Identity also supports two-factor authentication.](https://docs.microsoft.com/aspnet/core/security/authentication/2fa)', 'task_item': False}, {'text': 'For authentication scenarios that make use of a local user data store and that persist identity between\nrequests using cookies (as is typical for MVC web applications), ASP.NET Core Identity is a\nrecommended solution.', 'task_item': False}], [{'text': 'Audience represents the receiver of the incoming token or the resource that the token grants\naccess to. If the value specified in this parameter does not match the parameter in the token,\nthe token will be rejected.', 'task_item': False}, {'text': 'Authority is the address of the token-issuing authentication server. The JWT bearer\nauthentication middleware uses this URI to get the public key that can be used to validate the\ntoken’s signature. The middleware also confirms that the iss parameter in the token matches\nthis URI.', 'task_item': False}, {'text': 'Another parameter, RequireHttpsMetadata, is useful for testing purposes; you set this parameter to\nfalse so you can test in environments where you don’t have certificates. In real-world deployments,\nJWT bearer tokens should always be passed only over HTTPS.', 'task_item': False}, {'text': '326 CHAPTER 8 | Make secure .NET Microservices and Web Applications', 'task_item': False}, {'text': 'With this middleware in place, JWT tokens are automatically extracted from authorization headers.\nThey are then deserialized, validated (using the values in the Audience and Authority parameters), and\nstored as user information to be referenced later by MVC actions or authorization filters.', 'task_item': False}, {'text': 'The JWT bearer authentication middleware can also support more advanced scenarios, such as using a\nlocal certificate to validate a token if the authority is not available. For this scenario, you can specify a\nTokenValidationParameters object in the JwtBearerOptions object.', 'task_item': False}], [{'text': '**Sharing cookies between applications**\n[https://learn.microsoft.com/aspnet/core/security/cookie-sharing](https://docs.microsoft.com/aspnet/core/security/cookie-sharing)', 'task_item': False}, {'text': '**Introduction to Identity**\n[https://learn.microsoft.com/aspnet/core/security/authentication/identity](https://docs.microsoft.com/aspnet/core/security/authentication/identity)', 'task_item': False}, {'text': '**Rick Anderson. Two-factor authentication with SMS**\n[https://learn.microsoft.com/aspnet/core/security/authentication/2fa](https://docs.microsoft.com/aspnet/core/security/authentication/2fa)', 'task_item': False}, {'text': '**Enabling authentication using Facebook, Google and other external providers**\n[https://learn.microsoft.com/aspnet/core/security/authentication/social/](https://docs.microsoft.com/aspnet/core/security/authentication/social/)', 'task_item': False}, {'text': '**Michell Anicas. An Introduction to OAuth 2**\n[https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)', 'task_item': False}, {'text': '**AspNet.Security.OAuth.Providers** (GitHub repo for ASP.NET OAuth providers)\n[https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/src](https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/src)', 'task_item': False}, {'text': '**IdentityServer4. Official documentation**\n[https://identityserver4.readthedocs.io/en/latest/](https://identityserver4.readthedocs.io/en/latest/)', 'task_item': False}], [{'text': 'Be in the Administrator _or_ PowerUser role, _and_', 'task_item': False}, {'text': 'Be in the RemoteEmployee role, _and_', 'task_item': False}, {'text': '328 CHAPTER 8 | Make secure .NET Microservices and Web Applications', 'task_item': False}, {'text': 'Satisfy a custom handler for CustomPolicy authorization.', 'task_item': False}], [{'text': '[A Requirements type that derives from IAuthorizationRequirement](https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.iauthorizationrequirement) and that contains fields\nspecifying the details of the requirement. In the example, this is an age field for the sample\nMinimumAgeRequirement type.', 'task_item': False}, {'text': '[A handler that implements AuthorizationHandler, where T is the type of](https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationhandler-1)\n[IAuthorizationRequirement that the handler can satisfy. The handler must implement the](https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.iauthorizationrequirement)\n[HandleRequirementAsync method, which checks whether a specified context that contains](https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationhandler-1.handlerequirementasync)\ninformation about the user satisfies the requirement.', 'task_item': False}, {'text': '329 CHAPTER 8 | Make secure .NET Microservices and Web Applications', 'task_item': False}, {'text': 'If the user meets the requirement, a call to context.Succeed will indicate that the user is authorized. If\nthere are multiple ways that a user might satisfy an authorization requirement, multiple handlers can\nbe created.', 'task_item': False}, {'text': 'In addition to registering custom policy requirements with AddPolicy calls, you also need to register\ncustom requirement handlers via Dependency Injection (services.AddTransient<IAuthorizationHandler,\nMinimumAgeHandler>()).', 'task_item': False}, {'text': 'An example of a custom authorization requirement and handler for checking a user’s age (based on a\n[DateOfBirth claim) is available in the ASP.NET Core authorization documentation.](https://docs.asp.net/en/latest/security/authorization/policies.html)', 'task_item': False}], [{'text': '**ASP.NET Core Authentication**\n[https://learn.microsoft.com/aspnet/core/security/authentication/identity](https://docs.microsoft.com/aspnet/core/security/authentication/identity)', 'task_item': False}, {'text': '**ASP.NET Core Authorization**\n[https://learn.microsoft.com/aspnet/core/security/authorization/introduction](https://docs.microsoft.com/aspnet/core/security/authorization/introduction)', 'task_item': False}, {'text': '**Role-based Authorization**\n[https://learn.microsoft.com/aspnet/core/security/authorization/roles](https://docs.microsoft.com/aspnet/core/security/authorization/roles)', 'task_item': False}, {'text': '**Custom Policy-Based Authorization**\n[https://learn.microsoft.com/aspnet/core/security/authorization/policies](https://docs.microsoft.com/aspnet/core/security/authorization/policies)', 'task_item': False}, {'text': '**Authentication and authorization in minimal**\n**APIs** [https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis/security](https://docs.microsoft.com/aspnet/core/fundamentals/minimal-apis/security)', 'task_item': False}], [{'text': '**Using Azure Key Vault to protect application secrets**\n[https://learn.microsoft.com/azure/architecture/multitenant-identity](https://docs.microsoft.com/azure/architecture/multitenant-identity)', 'task_item': False}, {'text': '**Safe storage of app secrets during development**\n[https://learn.microsoft.com/aspnet/core/security/app-secrets](https://docs.microsoft.com/aspnet/core/security/app-secrets)', 'task_item': False}, {'text': '**Configuring data protection**\n[https://learn.microsoft.com/aspnet/core/security/data-protection/configuration/overview](https://docs.microsoft.com/aspnet/core/security/data-protection/configuration/overview)', 'task_item': False}, {'text': '**Data Protection key management and lifetime in ASP.NET Core**\n[https://learn.microsoft.com/aspnet/core/security/data-protection/configuration/default-](https://docs.microsoft.com/aspnet/core/security/data-protection/configuration/default-settings)\nsettings', 'task_item': False}, {'text': '333 CHAPTER 8 | Make secure .NET Microservices and Web Applications', 'task_item': False}, {'text': '**CHAPTER**', 'task_item': False}]], 'Ordered list': [[{'text': 'You begin with a deck of transparent sheets containing one paragraph each.', 'task_item': False}, {'text': '4 CHAPTER 1 | Introduction to Containers and Docker', 'task_item': False}, {'text': 'To issue a set of letters, you pick the sheets with the paragraphs you need, then you stack and\nalign them so they look and read fine.', 'task_item': False}, {'text': 'Finally, you place the set in the photocopier and press start to produce as many letters as\nrequired.', 'task_item': False}, {'text': 'So, simplifying, that’s the core idea of Docker.', 'task_item': False}, {'text': 'In Docker, each layer is the resulting set of changes that happen to the filesystem after executing a\ncommand, such as, installing a program.', 'task_item': False}, {'text': 'So, when you “look” at the filesystem after the layer has been copied, you see all the files, included in\nthe layer when the program was installed.', 'task_item': False}, {'text': 'You can think of an image as an auxiliary read-only hard disk ready to be installed in a “computer”\nwhere the operating system is already installed.', 'task_item': False}, {'text': 'Similarly, you can think of a container as the “computer” with the image hard disk installed. The\ncontainer, just like a computer, can be powered on or off.', 'task_item': False}], [{'text': 'The copy process would only be executed the first time (and when rebuilding if a file is\nchanged) and would use the cache for all other services and', 'task_item': False}, {'text': 'Since the larger image occurs in an intermediate stage, it doesn’t affect the final image size.', 'task_item': False}, {'text': '81 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}, {'text': 'The next significant optimization involves the restore command executed in line 17, which is also\ndifferent for every service of eShopOnContainers. If you change that line to just:', 'task_item': False}], [{'text': 'Add the following lines to **.dockerignore** :', 'task_item': False}, {'text': '- *.sln, to ignore all solution files in the main folder tree', 'task_item': False}, {'text': '- !eShopOnContainers-ServicesAndWebApps.sln, to include only this solution file.', 'task_item': False}, {'text': 'Include the /ignoreprojectextensions:.dcproj argument to dotnet restore, so it also ignores the\ndocker-compose project and only restores the packages for the eShopOnContainersServicesAndWebApps solution.', 'task_item': False}, {'text': 'For the final optimization, it just happens that line 20 is redundant, as line 23 also builds the\napplication and comes, in essence, right after line 20, so there goes another time-consuming\ncommand.', 'task_item': False}, {'text': 'The resulting file is then:', 'task_item': False}, {'text': '**Creating your base image from scratch**', 'task_item': False}, {'text': 'You can create your own Docker base image from scratch. This scenario is not recommended for\nsomeone who is starting with Docker, but if you want to set the specific bits of your own base image,\nyou can do so.', 'task_item': False}, {'text': '**Additional resources**', 'task_item': False}, {'text': '- **Multi-arch .NET Core images** .\n[https://github.com/dotnet/announcements/issues/14](https://github.com/dotnet/announcements/issues/14)', 'task_item': False}, {'text': '82 CHAPTER 4 | Development process for Docker-based applications', 'task_item': False}, {'text': '- **Create a base image** . Official Docker documentation.\n[https://docs.docker.com/develop/develop-images/baseimages/](https://docs.docker.com/develop/develop-images/baseimages/)', 'task_item': False}], [{'text': '**Unit** tests, just plain old regular unit tests, contained in the **{MicroserviceName}.UnitTests**\nprojects', 'task_item': False}, {'text': '155 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '**Microservice functional/integration tests**, with test cases involving the infrastructure for\neach microservice but isolated from the others and are contained in the\n**{MicroserviceName}.FunctionalTests** projects.', 'task_item': False}, {'text': '**Application functional/integration tests**, which focus on microservices integration, with test\ncases that exert several microservices. These tests are located in project\n**Application.FunctionalTests** .', 'task_item': False}, {'text': 'While unit and integration tests are organized in a test folder within the microservice project,\napplication and load tests are managed separately under the root folder, as shown in Figure 6-25.', 'task_item': False}, {'text': '_Figure 6-25. Test folder structure in eShopOnContainers_', 'task_item': False}, {'text': 'Microservice and Application functional/integration tests are run from Visual Studio, using the regular\ntests runner, but first you need to start the required infrastructure services, with a set of dockercompose files contained in the solution test folder:', 'task_item': False}, {'text': '**docker-compose-test.yml**', 'task_item': False}, {'text': '156 CHAPTER 5 | Designing and Developing Multi-Container and Microservice-Based .NET Applications', 'task_item': False}, {'text': '**docker-compose-test.override.yml**', 'task_item': False}, {'text': 'So, to run the functional/integration tests you must first run this command, from the solution test\nfolder:', 'task_item': False}], [{'text': 'Send a command (for example, CreateOrder).', 'task_item': False}, {'text': 'Receive the command in a command handler.', 'task_item': False}, {'text': '- Execute a single aggregate’s transaction.', 'task_item': False}, {'text': '- (Optional) Raise domain events for side effects (for example,\nOrderStartedDomainEvent).', 'task_item': False}, {'text': 'Handle domain events (within the current process) that will execute an open number of side\neffects in multiple aggregates or application actions. For example:', 'task_item': False}, {'text': '- Verify or create buyer and payment method.', 'task_item': False}, {'text': '- Create and send a related integration event to the event bus to propagate states\nacross microservices or trigger external actions like sending an email to the buyer.', 'task_item': False}, {'text': '- Handle other side effects.', 'task_item': False}, {'text': 'As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions\nrelated to other aggregates in the domain or additional application actions you need to perform\nacross microservices connecting with integration events and the event bus.', 'task_item': False}, {'text': '230 CHAPTER 6 | Tackle Business Complexity in a Microservice with DDD and CQRS Patterns', 'task_item': False}, {'text': '_Figure 7-15. Handling multiple actions per domain_', 'task_item': False}, {'text': 'There can be several handlers for the same domain event in the Application Layer, one handler can\nsolve consistency between aggregates and another handler can publish an integration event, so other\nmicroservices can do something with it. The event handlers are typically in the application layer,\nbecause you’ll use infrastructure objects like repositories or an application API for the microservice’s\nbehavior. In that sense, event handlers are similar to command handlers, so both are part of the\napplication layer. The important difference is that a command should be processed only once. A\ndomain event could be processed zero or _n_ times, because it can be received by multiple receivers or\nevent handlers with a different purpose for each handler.', 'task_item': False}, {'text': 'Having an open number of handlers per domain event allows you to add as many domain rules as\nneeded, without affecting current code. For instance, implementing the following business rule might\nbe as easy as adding a few event handlers (or even just one):', 'task_item': False}, {'text': 'When the total amount purchased by a customer in the store, across any number of orders, exceeds\n$6,000, apply a 10% off discount to every new order and notify the customer with an email about that\ndiscount for future orders.', 'task_item': False}], [{'text': 'Getting a Client Application ID.', 'task_item': False}, {'text': 'Getting a Client Application Secret.', 'task_item': False}, {'text': 'Configuring a redirection URL, that’s handled by the authorization middleware and the\nregistered provider', 'task_item': False}, {'text': 'Optionally, configuring a sign-out URL to properly handle sign out in a Single Sign On (SSO)\nscenario.', 'task_item': False}, {'text': '[For details on configuring your app for an external provider, see the External provider authentication](https://docs.microsoft.com/aspnet/core/security/authentication/social/)\n[in the ASP.NET Core documentation).](https://docs.microsoft.com/aspnet/core/security/authentication/social/)', 'task_item': False}, {'text': '322 CHAPTER 8 | Make secure .NET Microservices and Web Applications', 'task_item': False}, {'text': '_Figure 9-3. Selecting the Individual User Accounts option, for using external authentication, when creating a web_\n_application project in Visual Studio 2019._', 'task_item': False}, {'text': 'In addition to the external authentication providers listed previously, third-party packages are\navailable that provide middleware for using many more external authentication providers. For a list,\n[see the AspNet.Security.OAuth.Providers repository on GitHub.](https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/src)', 'task_item': False}, {'text': 'You can also create your own external authentication middleware to solve some special need.', 'task_item': False}], [{'text': 'You configure IdentityServer4 in _Program.cs_ by making a call to\nbuilder.Services.AddIdentityServer.', 'task_item': False}, {'text': 'You call app.UseIdentityServer in _Program.cs_ to add IdentityServer4 to the application’s HTTP\nrequest processing pipeline. This lets the library serve requests to OpenID Connect and\nOAuth2 endpoints like /connect/token.', 'task_item': False}, {'text': 'You configure identity server by setting the following data:', 'task_item': False}, {'text': '- [The credentials to use for signing.](https://identityserver4.readthedocs.io/en/latest/topics/crypto.html)', 'task_item': False}, {'text': '- [The Identity and API resources that users might request access to:](https://identityserver4.readthedocs.io/en/latest/topics/resources.html)', 'task_item': False}, {'text': '- API resources represent protected data or functionality that a user can access\nwith an access token. An example of an API resource would be a web API (or\nset of APIs) that requires authorization.', 'task_item': False}, {'text': '- Identity resources represent information (claims) that are given to a client to\nidentify a user. The claims might include the user name, email address, and so\non.', 'task_item': False}, {'text': '- [The clients that will be connecting in order to request tokens.](https://identityserver4.readthedocs.io/en/latest/topics/clients.html)', 'task_item': False}, {'text': '- [The storage mechanism for user information, such as ASP.NET Core Identity or an](https://identityserver4.readthedocs.io/en/latest/quickstarts/0_overview.html)\nalternative.', 'task_item': False}, {'text': '[When you specify clients and resources for IdentityServer4 to use, you can pass an IEnumerable](https://docs.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1)\ncollection of the appropriate type to methods that take in-memory client or resource stores. Or for\nmore complex scenarios, you can provide client or resource provider types via Dependency Injection.', 'task_item': False}, {'text': 'A sample configuration for IdentityServer4 to use in-memory resources and clients provided by a\ncustom IClientStore type might look like the following example:', 'task_item': False}, {'text': '325 CHAPTER 8 | Make secure .NET Microservices and Web Applications', 'task_item': False}], [{'text': 'Register your application as an Azure AD application. (Access to key vaults is managed by\nAzure AD.) This can be done through the Azure management portal.', 'task_item': False}, {'text': 'Alternatively, if you want your application to authenticate using a certificate instead of a\n[password or client secret, you can use the New-AzADApplication](https://docs.microsoft.com/powershell/module/az.resources/new-azadapplication) PowerShell cmdlet. The\ncertificate that you register with Azure Key Vault needs only your public key. Your application\nwill use the private key.', 'task_item': False}, {'text': 'Give the registered application access to the key vault by creating a new service principal. You\ncan do this using the following PowerShell commands:', 'task_item': False}, {'text': 'Include the key vault as a configuration source in your application by calling the\nAzureKeyVaultConfigurationExtensions.AddAzureKeyVault extension method when you create\n[an IConfigurationRoot instance.](https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfigurationroot)', 'task_item': False}, {'text': 'Note that calling AddAzureKeyVault requires the application ID that was registered and given access\nto the key vault in the previous steps. Or you can firstly running the Azure CLI command: az login,\nthen using an overload of AddAzureKeyVault that takes a DefaultAzureCredential in place of the\nclient.', 'task_item': False}, {'text': '332 CHAPTER 8 | Make secure .NET Microservices and Web Applications', 'task_item': False}]]}