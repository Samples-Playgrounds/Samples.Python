<h3>Performance Improvements in .NET 7</h3>
<h5>Stephen Toub</h5>
<h6>Partner Software Engineer, .NET Microsoft</h6>
<h4>Introduction</h4>
<p><a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6">A year ago, I published Performance Improvements in .NET 6, following on the heels of similar posts</a><br />
<a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5">for .NET 5,</a> <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0">.NET Core 3.0,</a> <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1">.NET Core 2.1, and .NET Core 2.0. I enjoy writing these posts and love</a><br />
reading developers’ responses to them. One comment in particular last year resonated with me. The<br />
commenter cited the Die Hard movie quote, “‘When Alexander saw the breadth of his domain, he<br />
wept for there were no more worlds to conquer’,” and questioned whether .NET performance<br />
improvements were similar. Has the well run dry? Are there no more “[performance] worlds to<br />
conquer”? I’m a bit giddy to say that, even with how fast .NET 6 is, .NET 7 definitively highlights how<br />
much more can be and has been done.</p>
<p>As with previous versions of .NET, performance is a key focus that pervades the entire stack, whether it<br />
be features created explicitly for performance or non-performance-related features that are still<br />
designed and implemented with performance keenly in mind. And now that a .NET 7 release<br />
candidate is just around the corner, it’s a good time to discuss much of it. Over the course of the last<br />
year, every time I’ve reviewed a PR that might positively impact performance, I’ve copied that link to a<br />
journal I maintain for the purposes of writing this post. When I sat down to write this a few weeks ago,<br />
I was faced with a list of almost 1000 performance-impacting PRs (out of more than 7000 PRs that<br />
went into the release), and I’m excited to share approximately 500 of them here with you.</p>
<p>One thought before we dive in. In past years, I’ve received the odd piece of negative feedback about<br />
the length of some of my performance-focused write-ups, and while I disagree with the criticism, I<br />
respect the opinion. So, this year, consider this a “choose your own adventure.” If you’re here just<br />
looking for a super short adventure, one that provides the top-level summary and a core message to<br />
take away from your time here, I’m happy to oblige:</p>
<p>TL;DR: .NET 7 is fast. Really fast. A thousand performance-impacting PRs went into runtime and core<br />
libraries this release, never mind all the improvements in ASP.NET Core and Windows Forms and<br />
Entity Framework and beyond. It’s the fastest .NET ever. If your manager asks you why your project<br />
should upgrade to .NET 7, you can say “in addition to all the new functionality in the release, .NET 7 is<br />
super fast.”</p>
<p>Or, if you prefer a slightly longer adventure, one filled with interesting nuggets of performancefocused data, consider skimming through the post, looking for the small code snippets and<br />
corresponding tables showing a wealth of measurable performance improvements. At that point, you,<br />
too, may walk away with your head held high and my thanks.</p>
<p>Both noted paths achieve one of my primary goals for spending the time to write these posts, to<br />
highlight the greatness of the next release and to encourage everyone to give it a try. But, I have other<br />
goals for these posts, too. I want everyone interested to walk away from this post with an upleveled<br />
understanding of how .NET is implemented, why various decisions were made, tradeoffs that were<br />
evaluated, techniques that were employed, algorithms that were considered, and valuable tools and<br />
approaches that were utilized to make .NET even faster than it was previously. I want developers to<br />
learn from our own learnings and find ways to apply this new-found knowledge to their own<br />
codebases, thereby further increasing the overall performance of code in the ecosystem. I want<br />
developers to take an extra beat, think about reaching for a profiler the next time they’re working on a</p>
<p>gnarly problem, think about looking at the source for the component they’re using in order to better<br />
understand how to work with it, and think about revisiting previous assumptions and decisions to<br />
determine whether they’re still accurate and appropriate. And I want developers to be excited at the<br />
prospect of submitting PRs to improve .NET not only for themselves but for every developer around<br />
the globe using .NET. If any of that sounds interesting, then I encourage you to choose the last<br />
adventure: prepare a carafe of your favorite hot beverage, get comfortable, and please enjoy.</p>
<h2>Contents</h2>
<p><strong>Setup ......................................................................................................................................... 1</strong></p>
<p><strong>JIT .............................................................................................................................................. 3</strong></p>
<p>On-Stack Replacement .................................................................................................................................................. 13</p>
<p>PGO ........................................................................................................................................................................................ 23</p>
<p>Bounds Check Elimination ............................................................................................................................................ 35</p>
<p>Loop Hoisting and Cloning .......................................................................................................................................... 45</p>
<p>Folding, propagation, and substitution ................................................................................................................... 50</p>
<p>Vectorization ...................................................................................................................................................................... 54</p>
<p>Inlining .................................................................................................................................................................................. 62</p>
<p>Arm64 ................................................................................................................................................................................... 64</p>
<p>JIT helpers ........................................................................................................................................................................... 65</p>
<p>Grab Bag .............................................................................................................................................................................. 67</p>
<p><strong>GC ............................................................................................................................................ 71</strong></p>
<p><strong>Native AOT ............................................................................................................................. 72</strong></p>
<p><strong>Mono ...................................................................................................................................... 75</strong></p>
<p><strong>Reflection ............................................................................................................................... 78</strong></p>
<p><strong>Interop .................................................................................................................................... 82</strong></p>
<p><strong>Threading ............................................................................................................................... 89</strong></p>
<p><strong>Primitive Types and Numerics ............................................................................................. 93</strong></p>
<p><strong>Arrays, Strings, and Spans .................................................................................................. 101</strong></p>
<p><strong>Regex .................................................................................................................................... 128</strong></p>
<p>RegexOptions.NonBacktracking............................................................................................................................... 128</p>
<p>New APIs ............................................................................................................................................................................ 133</p>
<p>TryFindNextPossibleStartingPosition ..................................................................................................................... 138</p>
<p>Loops and Backtracking .............................................................................................................................................. 143</p>
<p>Code generation ............................................................................................................................................................. 146</p>
<p><strong>Collections ............................................................................................................................ 150</strong></p>
<p><strong>LINQ ...................................................................................................................................... 153</strong></p>
<p>i Contents</p>
<p><strong>File I/O .................................................................................................................................. 159</strong></p>
<p><strong>Compression ........................................................................................................................ 168</strong></p>
<p><strong>Networking .......................................................................................................................... 173</strong></p>
<p><strong>JSON ..................................................................................................................................... 190</strong></p>
<p><strong>XML ....................................................................................................................................... 193</strong></p>
<p><strong>Cryptography ....................................................................................................................... 198</strong></p>
<p><strong>Diagnostics ........................................................................................................................... 203</strong></p>
<p><strong>Exceptions ............................................................................................................................ 208</strong></p>
<p><strong>Registry ................................................................................................................................ 211</strong></p>
<p><strong>Analyzers .............................................................................................................................. 213</strong></p>
<p><strong>What’s Next? ........................................................................................................................ 227</strong></p>
<p>ii Contents</p>
<p><strong>CHAPTER</strong></p>
<h1>1</h1>
<h2>Setup</h2>
<p><a href="https://github.com/dotnet/benchmarkdotnet">The microbenchmarks throughout this post utilize benchmarkdotnet. To make it easy for you to follow</a><br />
along with your own validation, I have a very simple setup for the benchmarks I use. Create a new C#<br />
project:</p>
<p>and the contents of <code>Program.cs</code> with this:</p>
<p>1 CHAPTER 1 | Setup</p>
<p>For each benchmark included in this write-up, you can then just copy and paste the code into this test<br />
class, and run the benchmarks. For example, to run a benchmark comparing performance on .NET 6<br />
and .NET 7, do:</p>
<pre><code>dotnet run -c Release -f net6.0 --filter '**' --runtimes net6.0 net7.0

</code></pre>
<p>This command says “build the benchmarks in release configuration targeting the .NET 6 surface area,<br />
and then run all of the benchmarks on both .NET 6 and .NET 7.” Or to run just on .NET 7:</p>
<pre><code>dotnet run -c Release -f net7.0 --filter '**' --runtimes net7.0

</code></pre>
<p>which instead builds targeting the .NET 7 surface area and then only runs once against .NET 7. You<br />
can do this on any of Windows, Linux, or macOS. Unless otherwise called out (e.g. where the<br />
improvements are specific to Unix and I run the benchmarks on Linux), the results I share were<br />
recorded on Windows 11 64-bit but aren’t Windows-specific and should show similar relative<br />
differences on the other operating systems as well.</p>
<p>The release of the first .NET 7 release candidate is right around the corner. All of the measurements in<br />
<a href="https://github.com/dotnet/installer/blob/main/README.md#installers-and-binaries">this post were gathered with a recent daily build</a> of .NET 7 RC1.</p>
<p>Also, my standard caveat: These are microbenchmarks. It is expected that different hardware, different<br />
versions of operating systems, and the way in which the wind is currently blowing can affect the<br />
numbers involved. Your mileage may vary.</p>
<p>2 CHAPTER 1 | Setup</p>
<p><strong>CHAPTER</strong></p>
<h1>2</h1>
<h2>JIT</h2>
<p>I’d like to kick off a discussion of performance improvements in the Just-In-Time (JIT) compiler by<br />
talking about something that itself isn’t actually a performance improvement. Being able to<br />
understand exactly what assembly code is generated by the JIT is critical when fine-tuning lower-level,<br />
performance-sensitive code. There are multiple ways to get at that assembly code. The online tool<br />
<a href="https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBDAzgWwB8ABAJgEYBYAKGIGYACMhgYRoG8aHuGAHKAJYA3bBhgMBAOwwMA+tgYBeBilJo5wJQwAcKANxce9CdIYBZKQAoAlEoB850QAsAdBcmX562cGsHqAL5AA">sharplab.io</a> is <em>incredibly useful</em> for this (thanks to <a href="https://github.com/ashmind">@ashmind</a> for this<br />
tool); however it currently only targets a single release, so as I write this I’m only able to see the<br />
<a href="https://godbolt.org/z/4v33asW6z">output for .NET 6, which makes it difficult to use for A/B comparisons. godbolt.org</a> is also valuable for<br />
<a href="https://github.com/compiler-explorer/compiler-explorer/pull/3168">this, with C# support added in compiler-explorer/compiler-explorer#3168</a> from</p>
<p><a href="https://github.com/hez2010">@hez2010</a>, with similar limitations. The most flexible solutions involve<br />
getting at that assembly code locally, as it enables comparing whatever versions or local builds you<br />
desire with whatever configurations and switches set that you need.</p>
<p>One common approach is to use the <code>[DisassemblyDiagnoser]</code> in benchmarkdotnet. Simply slap the</p>
<p><code>[DisassemblyDiagnoser]</code> attribute onto your test class: benchmarkdotnet will find the assembly code<br />
generated for your tests and some depth of functions they call, and dump out the found assembly<br />
code in a human-readable form. For example, if I run this test:</p>
<p>with:</p>
<pre><code>dotnet run -c Release -f net7.0 --filter '**'

</code></pre>
<p>in addition to doing all of its normal test execution and timing, benchmarkdotnet also outputs a</p>
<p><code>Program-asm.md</code> file that contains this:</p>
<p>3 CHAPTER 2 | JIT</p>
<p><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2072">Pretty neat. This support was recently improved further in dotnet/benchmarkdotnet#2072, which</a><br />
allows passing a filter list on the command-line to benchmarkdotnet to tell it exactly which methods’<br />
assembly code should be dumped.</p>
<p>If you can get your hands on a “debug” or “checked” build of the .NET runtime (“checked” is a build<br />
that has optimizations enabled but also still includes asserts), and specifically of clrjit.dll, another<br />
valuable approach is to set an environment variable that causes the JIT itself to spit out a humanreadable description of all of the assembly code it emits. This can be used with any kind of<br />
application, as it’s part of the JIT itself rather than part of any specific tool or other environment, it<br />
supports showing the code the JIT generates each time it generates code (e.g. if it first compiles a<br />
method without optimization and then later recompiles it with optimization), and overall it’s the most<br />
accurate picture of the assembly code as it comes “straight from the horses mouth,” as it were. The<br />
(big) downside of course is that it requires a non-release build of the runtime, which typically means<br />
<a href="https://github.com/dotnet/runtime">you need to build it yourself from the sources in the dotnet/runtime</a> repo.</p>
<p><a href="https://github.com/dotnet/runtime/pull/73365">… until .NET 7, that is. As of dotnet/runtime#73365, this assembly dumping support is now available in</a><br />
release builds as well, which means it’s simply part of .NET 7 and you don’t need anything special to<br />
use it. To see this, try creating a simple “hello world” app like:</p>
<p>and building it (e.g. <code>dotnet build -c Release</code> ). Then, set the <code>DOTNET_JitDisasm</code> environment<br />
variable to the name of the method we care about, in this case “Main” (the exact syntax allowed is<br />
more permissive and allows for some use of wildcards, optional namespace and class names, etc.). As<br />
I’m using PowerShell, that means:</p>
<pre><code>$env:DOTNET_JitDisasm=&quot;Main&quot;

</code></pre>
<p>and then running the app. You should see code like this output to the console:</p>
<p>4 CHAPTER 2 | JIT</p>
<p>This is immeasurably helpful for performance analysis and tuning, even for questions as simple as “did<br />
my function get inlined” or “is this code I expected to be optimized away actually getting optimized<br />
away.” Throughout the rest of this post, I’ll include assembly snippets generated by one of these two<br />
mechanisms, in order to help exemplify concepts.</p>
<p>Note that it can sometimes be a little confusing figuring out what name to specify as the value for</p>
<p><code>DOTNET_JitDisasm</code>, especially when the method you care about is one that the C# compiler names or<br />
name mangles (since the JIT only sees the IL and metadata, not the original C#), e.g. the name of the<br />
entry point method for a program with top-level statements, the names of local functions, etc. To<br />
both help with this and to provide a really valuable top-level view of the work the JIT is doing, .NET 7<br />
also supports the new <code>DOTNET_JitDisasmSummary</code> environment variable (introduced in<br />
<a href="https://github.com/dotnet/runtime/pull/74090">dotnet/runtime#74090). Set that to “1”, and it’ll result in the JIT emitting a line every time it compiles a</a><br />
method, including the name of that method which is copy/pasteable with <code>DOTNET_JitDisasm</code> . This<br />
feature is useful in-and-of-itself, however, as it can quickly highlight for you what’s being compiled,<br />
when, and with what settings. For example, if I set the environment variable and then run a “hello,<br />
world” console app, I get this output:</p>
<p>We can see for “hello, world” there’s only 5 methods that actually get JIT compiled. There are of<br />
course many more methods that get executed as part of a simple “hello, world,” but almost all of</p>
<p>because they explicitly opted-out of R2R via use of the</p>
<p><code>[MethodImpl(MethodImplOptions.AggressiveOptimization)]</code> attribute (despite the name, this<br />
attribute should almost never be used, and is only used for very specific reasons in a few very specific<br />
places in the core libraries). Then there’s our <code>Main</code> method. And lastly there’s the <code>NarrowUtf16ToAscii</code></p>
<p>5 CHAPTER 2 | JIT</p>
<p>method, which doesn’t have R2R code, either, due to using the variable-width <code>Vector&lt;T&gt;</code> (more on<br />
that later). Every other method that’s run doesn’t require JIT’ing. If we instead first set the</p>
<p><code>DOTNET_ReadyToRun</code> environment variable to <code>0</code>, the list is much longer, and gives you a very good<br />
sense of what the JIT needs to do on startup (and why technologies like R2R are important for startup<br />
time). Note how many methods get compiled before “hello, world” is output:</p>
<p>6 CHAPTER 2 | JIT</p>
<p>7 CHAPTER 2 | JIT</p>
<p>8 CHAPTER 2 | JIT</p>
<p>9 CHAPTER 2 | JIT</p>
<p>10 CHAPTER 2 | JIT</p>
<p>11 CHAPTER 2 | JIT</p>
<p>12 CHAPTER 2 | JIT</p>
<p>With that out of the way, let’s move on to actual performance improvements, starting with on-stack<br />
replacement.</p>
<p><strong>On-Stack Replacement</strong></p>
<p>On-stack replacement (OSR) is one of the coolest features to hit the JIT in .NET 7. But to really<br />
understand OSR, we first need to understand tiered compilation, so a quick recap…</p>
<p>One of the issues a managed environment with a JIT compiler has to deal with is tradeoffs between<br />
startup and throughput. Historically, the job of an optimizing compiler is to, well, optimize, in order to<br />
enable the best possible throughput of the application or service once running. But such optimization<br />
takes analysis, takes time, and performing all of that work then leads to increased startup time, as all<br />
of the code on the startup path (e.g. all of the code that needs to be run before a web server can<br />
serve the first request) needs to be compiled. So a JIT compiler needs to make tradeoffs: better<br />
throughput at the expense of longer startup time, or better startup time at the expense of decreased<br />
throughput. For some kinds of apps and services, the tradeoff is an easy call, e.g. if your service starts<br />
up once and then runs for days, several extra seconds of startup time doesn’t matter, or if you’re a<br />
console application that’s going to do a quick computation and exit, startup time is all that matters.<br />
But how can the JIT know which scenario it’s in, and do we really want every developer having to<br />
know about these kinds of settings and tradeoffs and configure every one of their applications<br />
accordingly? One answer to this has been ahead-of-time compilation, which has taken various forms<br />
in .NET. For example, all of the core libraries are “crossgen”’d, meaning they’ve been run through a<br />
tool that produces the previously mentioned R2R format, yielding binaries that contain assembly code<br />
that needs only minor tweaks to actually execute; not every method can have code generated for it,<br />
but enough that it significantly reduces startup time. Of course, such approaches have their own<br />
downsides, e.g. one of the promises of a JIT compiler is it can take advantage of knowledge of the<br />
current machine / process in order to best optimize, so for example the R2R images have to assume a</p>
<p>13 CHAPTER 2 | JIT</p>
<p>certain baseline instruction set (e.g. what vectorizing instructions are available) whereas the JIT can see<br />
what’s actually available and use the best. “Tiered compilation” provides another answer, one that’s<br />
usable with or without these other ahead-of-time (AOT) compilation solutions.</p>
<p>Tiered compilation enables the JIT to have its proverbial cake and eat it, too. The idea is simple: allow<br />
the JIT to compile the same code multiple times. The first time, the JIT can use as a few optimizations<br />
as make sense (a handful of optimizations can actually make the JIT’s own throughput faster, so those<br />
still make sense to apply), producing fairly unoptimized assembly code but doing so really quickly.<br />
And when it does so, it can add some instrumentation into the assembly to track how often the<br />
methods are called. As it turns out, many functions used on a startup path are invoked once or maybe<br />
only a handful of times, and it would take more time to optimize them than it does to just execute<br />
them unoptimized. Then, when the method’s instrumentation triggers some threshold, for example a<br />
method having been executed 30 times, a work item gets queued to recompile that method, but this<br />
time with all the optimizations the JIT can throw at it. This is lovingly referred to as “tiering up.” Once<br />
that recompilation has completed, call sites to the method are patched with the address of the newly<br />
highly optimized assembly code, and future invocations will then take the fast path. So, we get faster<br />
startup <em>and</em> faster sustained throughput. At least, that’s the hope.</p>
<p>A problem, however, is methods that don’t fit this mold. While it’s certainly the case that many<br />
performance-sensitive methods are relatively quick and executed many, many, many times, there’s<br />
also a large number of performance-sensitive methods that are executed just a handful of times, or<br />
maybe even only once, but that take a very long time to execute, maybe even the duration of the<br />
whole process: methods with loops. As a result, by default tiered compilation hasn’t applied to loops,<br />
though it can be enabled by setting the <code>DOTNET_TC_QuickJitForLoops</code> environment variable to <code>1</code> . We<br />
can see the effect of this by trying this simple console app with .NET 6. With the default settings, run<br />
this app:</p>
<p>I get numbers printed out like:</p>
<p>14 CHAPTER 2 | JIT</p>
<p>Now, try setting <code>DOTNET_TC_QuickJitForLoops</code> to <code>1</code> . When I then run it again, I get numbers like this:</p>
<p>In other words, with <code>DOTNET_TC_QuickJitForLoops</code> enabled, it’s taking 2.5x as long as without (the<br />
default in .NET 6). That’s because this main function never gets optimizations applied to it. By setting</p>
<p><code>DOTNET_TC_QuickJitForLoops</code> to <code>1</code>, we’re saying “JIT, please apply tiering to methods with loops as<br />
well,” but this method with a loop is only ever invoked once, so for the duration of the process it ends<br />
up remaining at “tier-0,” aka unoptimized. Now, let’s try the same thing with .NET 7. Regardless of<br />
whether that environment variable is set, I again get numbers like this:</p>
<p>but importantly, this method was still participating in tiering. In fact, we can get confirmation of that<br />
by using the aforementioned <code>DOTNET_JitDisasmSummary=1</code> environment variable. When I set that and<br />
run again, I see these lines in the output:</p>
<p>highlighting that <code>Main</code> was indeed compiled twice. How is that possible? On-stack replacement.</p>
<p>The idea behind on-stack replacement is a method can be replaced not just between invocations but<br />
even while it’s executing, while it’s “on the stack.” In addition to the tier-0 code being instrumented<br />
for call counts, loops are also instrumented for iteration counts. When the iterations surpass a certain<br />
limit, the JIT compiles a new highly optimized version of that method, transfers all the local/register<br />
state from the current invocation to the new invocation, and then jumps to the appropriate location in<br />
the new method. We can see this in action by using the previously discussed <code>DOTNET_JitDisasm</code><br />
environment variable. Set that to <code>Program:*</code> in order to see the assembly code generated for all of the<br />
methods in the <code>Program</code> class, and then run the app again. You should see output like the following:</p>
<p>15 CHAPTER 2 | JIT</p>
<p>16 CHAPTER 2 | JIT</p>
<p>A few relevant things to notice here. First, the comments at the top highlight how this code was<br />
compiled:</p>
<p>So, we know this is the initial version (“Tier-0”) of the method compiled with minimal optimization<br />
(“MinOpts”). Second, note this line of the assembly:</p>
<pre><code>FF152DD40B00     call   [Program:&lt;Main&gt;g__IsAsciiDigit|0_0(ushort):bool]

</code></pre>
<p>Our <code>IsAsciiDigit</code> helper method is trivially inlineable, but it’s not getting inlined; instead, the<br />
assembly has a call to it, and indeed we can see below the generated code (also “MinOpts”) for</p>
<p><code>IsAsciiDigit</code> . Why? Because inlining is an optimization (a really important one) that’s disabled as<br />
part of tier-0 (because the analysis for doing inlining well is also quite costly). Third, we can see the<br />
code the JIT is outputting to instrument this method. This is a bit more involved, but I’ll point out the<br />
relevant parts. First, we see:</p>
<p>17 CHAPTER 2 | JIT</p>
<pre><code>C745A8E8030000    mov   dword ptr [rbp-58H], 0x3E8

</code></pre>
<p>That <code>0x3E8</code> is the hex value for the decimal 1,000, which is the default number of iterations a loop<br />
needs to iterate before the JIT will generate the optimized version of the method (this is configurable<br />
via the <code>DOTNET_TC_OnStackReplacement_InitialCounter</code> environment variable). So we see 1,000<br />
being stored into this stack location. Then a bit later in the method we see this:</p>
<p>The generated code is loading that counter into the <code>ecx</code> register, decrementing it, storing it back, and<br />
then seeing whether the counter dropped to 0. If it didn’t, the code skips to <code>G_M000_IG05</code>, which is the<br />
label for the actual code in the rest of the loop. But if the counter did drop to 0, the JIT proceeds to<br />
store relevant state into the the <code>rcx</code> and <code>edx</code> registers and then calls the <code>CORINFO_HELP_PATCHPOINT</code><br />
helper method. That helper is responsible for triggering the creation of the optimized method if it<br />
doesn’t yet exist, fixing up all appropriate tracking state, and jumping to the new method. And indeed,<br />
if you look again at your console output from running the program, you’ll see yet another output for<br />
the <code>Main</code> method:</p>
<p>18 CHAPTER 2 | JIT</p>
<p>19 CHAPTER 2 | JIT</p>
<p>Here, again, we notice a few interesting things. First, in the header we see this:</p>
<p>so we know this is both optimized “tier-1” code and is the “OSR variant” for this method. Second,<br />
notice there’s no longer a call to the <code>IsAsciiDigit</code> helper. Instead, where that call would have been,<br />
we see this:</p>
<p>implementation ( <code>(uint)(c - '0') &lt;= 9</code> ), doesn’t it? That’s because it is. The helper was successfully<br />
inlined in this now-optimized code.</p>
<p>Great, so now in .NET 7, we can largely avoid the tradeoffs between startup and throughput, as OSR<br />
enables tiered compilation to apply to all methods, even those that are long-running. A multitude of<br />
PRs went into enabling this, including many over the last few years, but all of the functionality was<br />
<a href="https://github.com/dotnet/runtime/pull/62831">disabled in the shipping bits. Thanks to improvements like dotnet/runtime#62831</a> which implemented<br />
support for OSR on Arm64 (previously only x64 support was implemented), and<br />
<a href="https://github.com/dotnet/runtime/pull/63406">dotnet/runtime#63406</a> <a href="https://github.com/dotnet/runtime/pull/65609">and dotnet/runtime#65609</a> which revised how OSR imports and epilogs are<br />
<a href="https://github.com/dotnet/runtime/pull/65675">handled, dotnet/runtime#65675 enables OSR (and as a result</a> <code>DOTNET_TC_QuickJitForLoops</code> ) by<br />
default.</p>
<p>20 CHAPTER 2 | JIT</p>
<p>But, tiered compilation and OSR aren’t just about startup (though they’re of course very valuable<br />
there). They’re also about further improving throughput. Even though tiered compilation was<br />
originally envisioned as a way to optimize startup while not hurting throughput, it’s become much<br />
more than that. There are various things the JIT can learn about a method during tier-0 that it can</p>
<p>only have been initialized by the time the tier-1 code executes but their values won’t ever change. And<br />
that in turn means that any readonly statics of primitive types (e.g. <code>bool</code>, <code>int</code>, etc.) can be treated like</p>
<p>When I do so, I get this output:</p>
<p>21 CHAPTER 2 | JIT</p>
<p>the “Tier-1” code, where all of that overhead has vanished and is instead replaced simply by <code>mov eax,</code></p>
<p><code>1</code> . Since the “Tier-0” code had to have executed in order for it to tier up, the “Tier-1” code was</p>
<p>This is so useful that components are now written with tiering in mind. Consider the new <code>Regex</code> source<br />
generator, which is discussed later in this post (Roslyn source generators were introduced a couple of<br />
years ago; just as how Roslyn analyzers are able to plug into the compiler and surface additional<br />
diagnostics based on all of the data the compiler learns from the source code, Roslyn source<br />
generators are able to analyze that same data and then further augment the compilation unit with</p>
<p>instances that don’t explicitly set a timeout. That means, even though it’s super rare for such a<br />
process-wide timeout to be set, the <code>Regex</code> source generator still needs to output timeout-related code<br />
just in case it’s needed. It does so by outputting some helpers like this:</p>
<p>which it then uses at call sites like this:</p>
<p>In tier-0, these checks will still be emitted in the assembly code, but in tier-1 where throughput<br />
matters, if the relevant <code>AppContext</code> switch hasn’t been set, then <code>s_defaultTimeout</code> will be</p>
<p>22 CHAPTER 2 | JIT</p>
<p>assembly code entirely as dead code.</p>
<p>But, this is somewhat old news. The JIT has been able to do such an optimization since tiered<br />
compilation was introduced in .NET Core 3.0. Now in .NET 7, though, with OSR it’s also able to do so<br />
by default for methods with loops (and thus enable cases like the regex one). However, the real magic<br />
of OSR comes into play when combined with another exciting feature: dynamic PGO.</p>
<p><strong>PGO</strong></p>
<p><a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6">I wrote about profile-guided optimization (PGO) in my Performance Improvements in .NET 6 post, but</a><br />
I’ll cover it again here as it’s seen a multitude of improvements for .NET 7.</p>
<p>PGO has been around for a long time, in any number of languages and compilers. The basic idea is<br />
you compile your app, asking the compiler to inject instrumentation into the application to track<br />
various pieces of interesting information. You then put your app through its paces, running through<br />
various common scenarios, causing that instrumentation to “profile” what happens when the app is<br />
executed, and the results of that are then saved out. The app is then recompiled, feeding those<br />
instrumentation results back into the compiler, and allowing it to optimize the app for exactly how it’s<br />
expected to be used. This approach to PGO is referred to as “static PGO,” as the information is all<br />
gleaned ahead of actual deployment, and it’s something .NET has been doing in various forms for<br />
years. From my perspective, though, the really interesting development in .NET is “dynamic PGO,”<br />
which was introduced in .NET 6, but off by default.</p>
<p>Dynamic PGO takes advantage of tiered compilation. I noted that the JIT instruments the tier-0 code<br />
to track how many times the method is called, or in the case of loops, how many times the loop<br />
executes. It can instrument it for other things as well. For example, it can track exactly which concrete<br />
types are used as the target of an interface dispatch, and then in tier-1 specialize the code to expect<br />
the most common types (this is referred to as “guarded devirtualization,” or GDV). You can see this in<br />
this little example. Set the <code>DOTNET_TieredPGO</code> environment variable to <code>1</code>, and then run this on .NET 7:</p>
<p>23 CHAPTER 2 | JIT</p>
<p>The tier-0 code for <code>DoWork</code> ends up looking like this:</p>
<p>24 CHAPTER 2 | JIT</p>
<p>That first block is checking the concrete type of the <code>IPrinter</code> (stored in <code>rdi</code> ) and comparing it against<br />
the known type for <code>Printer</code> ( <code>0x7FFC3F1B2D98</code> ). If they’re different, it just jumps to the same interface<br />
dispatch it was doing in the unoptimized version. But if they’re the same, it then jumps directly to an<br />
inlined version of <code>Printer.PrintIfTrue</code> (you can see the call to <code>Console:WriteLine</code> right there in<br />
this method). Thus, the common case (the only case in this example) is super efficient at the expense<br />
of a single comparison and branch.</p>
<p>That all existed in .NET 6, so why are we talking about it now? Several things have improved. First,<br />
<a href="https://github.com/dotnet/runtime/pull/61453">PGO now works with OSR, thanks to improvements like dotnet/runtime#61453. That’s a big deal, as it</a><br />
means hot long-running methods that do this kind of interface dispatch (which are fairly common)<br />
can get these kinds of devirtualization/inlining optimizations. Second, while PGO isn’t currently</p>
<p>enabling dynamic PGO (note that it <em>doesn’t</em> disable use of R2R images, so if you want the entirety of<br />
the core libraries also employing dynamic PGO, you’ll also need to set <code>DOTNET_ReadyToRun=0</code> ). Third,<br />
however, is dynamic PGO has been taught how to instrument and optimize additional things.</p>
<p>PGO already knew how to instrument virtual dispatch. Now in .NET 7, thanks in large part to<br />
<a href="https://github.com/dotnet/runtime/pull/68703">dotnet/runtime#68703, it can do so for delegates as well (at least for delegates to instance methods).</a><br />
Consider this simple console app:</p>
<p>Without PGO enabled, I get generated optimized assembly like this:</p>
<p>25 CHAPTER 2 | JIT</p>
<p>Note the <code>call [rsi+18H]Func'2:Invoke(int):int:this</code> in there that’s invoking the delegate. Now<br />
with PGO enabled:</p>
<p>26 CHAPTER 2 | JIT</p>
<p>I chose the <code>42</code> constant in <code>i =&gt; i * 42</code> to make it easy to see in the assembly, and sure enough, there<br />
it is:</p>
<p>27 CHAPTER 2 | JIT</p>
<p>This is loading the target address from the delegate into <code>r8</code> and is loading the address of the<br />
expected target into <code>rax</code> . If they’re the same, it then simply performs the inlined operation ( <code>imul</code></p>
<p><code>r15d, edx, 42</code> ), and otherwise it jumps to G_M000_IG07 which calls to the function in <code>r8</code> . The effect<br />
of this is obvious if we run this as a benchmark:</p>
<p>With PGO disabled, we get the same performance throughput for .NET 6 and .NET 7:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>DelegatePGO</td>
<td>.NET 6.0</td>
<td>1.665 us</td>
<td>1.00</td>
</tr>
<tr>
<td>DelegatePGO</td>
<td>.NET 7.0</td>
<td>1.659 us</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<p>But the picture changes when we enable dynamic PGO ( <code>DOTNET_TieredPGO=1</code> ). .NET 6 gets ~14%<br />
faster, but .NET 7 gets ~3x faster!</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>DelegatePGO</td>
<td>.NET 6.0</td>
<td>1,427.7 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>DelegatePGO</td>
<td>.NET 7.0</td>
<td>539.0 ns</td>
<td>0.38</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/70377">dotnet/runtime#70377</a> is another valuable improvement with dynamic PGO, which enables PGO to<br />
play nicely with loop cloning and invariant hoisting. To understand this better, a brief digression into<br />
what those are. Loop cloning is a mechanism the JIT employs to avoid various overheads in the fast<br />
path of a loop. Consider the <code>Test</code> method in this example:</p>
<p>28 CHAPTER 2 | JIT</p>
<p>The JIT doesn’t know whether the passed in array is of sufficient length that all accesses to <code>array[i]</code><br />
inside the loop will be in bounds, and thus it would need to inject bounds checks for every access.<br />
While it’d be nice to simply do the length check up front and simply throw an exception early if it<br />
wasn’t long enough, doing so could also change behavior (imagine the method were writing into the<br />
array as it went, or otherwise mutating some shared state). Instead, the JIT employs “loop cloning.” It<br />
essentially rewrites this <code>Test</code> method to be more like this:</p>
<p>That way, at the expense of some code duplication, we get our fast loop without bounds checks and<br />
only pay for the bounds checks in the slow path. You can see this in the generated assembly (if you<br />
can’t already tell, <code>DOTNET_JitDisasm</code> is one of my favorite features in .NET 7):</p>
<p>29 CHAPTER 2 | JIT</p>
<p>That G_M000_IG02 section is doing the null check and the length check, jumping to the G_M000_IG05<br />
block if either fails. If both succeed, it’s then executing the loop (block G_M000_IG03) without bounds<br />
checks:</p>
<p>30 CHAPTER 2 | JIT</p>
<p>with the bounds checks only showing up in the slow-path block:</p>
<p>That’s “loop cloning.” What about “invariant hoisting”? Hoisting means pulling something out of a<br />
loop to be before the loop, and invariants are things that don’t change. Thus invariant hoisting is<br />
pulling something out of a loop to before the loop in order to avoid recomputing every iteration of<br />
the loop an answer that won’t change. Effectively, the previous example already showed invariant<br />
hoisting, in that the bounds check is moved to be before the loop rather than in the loop, but a more<br />
concrete example would be something like this:</p>
<p>Note that the value of <code>array.Length - 42</code> doesn’t change on each iteration of the loop, so it’s<br />
“invariant” to the loop iteration and can be lifted out, which the generated code does:</p>
<p>31 CHAPTER 2 | JIT</p>
<p><code>r8d</code>, we then see this up-front block subtracting 42 from the length ( <code>add r8d, -42</code> ), and that’s before<br />
we continue into the fast-path loop in the G_M000_IG03 block. This keeps that additional set of<br />
operations out of the loop, thereby avoiding the overhead of recomputing the value per iteration.</p>
<p>Ok, so how does this apply to dynamic PGO? Remember that with the interface/virtual dispatch<br />
avoidance PGO is able to do, it does so by doing a type check to see whether the type in use is the<br />
most common type; if it is, it uses a fast path that calls directly to that type’s method (and in doing so<br />
that call is then potentially inlined), and if it isn’t, it falls back to normal interface/virtual dispatch. That<br />
check can be invariant to a loop. So when a method is tiered up and PGO kicks in, the type check can<br />
now be hoisted out of the loop, making it even cheaper to handle the common case. Consider this<br />
variation of our original example:</p>
<p>When we look at the optimized assembly generated for this with dynamic PGO enabled, we see this:</p>
<p>32 CHAPTER 2 | JIT</p>
<p>33 CHAPTER 2 | JIT</p>
<p>Interestingly, improvements like this can bring with them their own challenges. PGO leads to a<br />
significant increase in the number of type checks, since call sites that specialize for a given type need<br />
to compare against that type. However, common subexpression elimination (CSE) hasn’t historically<br />
worked for such type handles (CSE is a compiler optimization where duplicate expressions are<br />
eliminated by computing the result once and then storing it for subsequent use rather than<br />
<a href="https://github.com/dotnet/runtime/pull/70580">recomputing it each time). dotnet/runtime#70580 fixes this by enabling CSE for such constant</a><br />
handles. For example, consider this method:</p>
<p>On .NET 6, the JIT produced this assembly code:</p>
<p>Note the C# has four tests for <code>string</code> and the assembly code has four loads with <code>mov rax,offset</code></p>
<p><code>MT_System.String</code> . Now on .NET 7, the load is performed just once:</p>
<p>34 CHAPTER 2 | JIT</p>
<p><strong>Bounds Check Elimination</strong></p>
<p>One of the things that makes .NET attractive is its safety. The runtime guards access to arrays, strings,<br />
and spans such that you can’t accidentally corrupt memory by walking off either end; if you do, rather<br />
than reading/writing arbitrary memory, you’ll get exceptions. Of course, that’s not magic; it’s done by<br />
the JIT inserting bounds checks every time one of these data structures is indexed. For example, this:</p>
<p>results in:</p>
<p>The array is passed into this method in the <code>rcx</code> register, pointing to the method table pointer in the<br />
object, and the length of an array is stored in the object just after that method table pointer (which is<br />
8 bytes in a 64-bit process). Thus the <code>cmp dword ptr [rcx+08H], 0</code> instruction is reading the length</p>
<p>35 CHAPTER 2 | JIT</p>
<p>of the array and comparing the length to 0; that makes sense, since the length can’t be negative, and<br />
we’re trying to access the 0th element, so as long as the length isn’t 0, the array has enough elements<br />
for us to access its 0th element. In the event that the length was 0, the code jumps to the end of the</p>
<p><code>ptr [rcx+10H]</code> ).</p>
<p>While these bounds checks in and of themselves aren’t super expensive, do a lot of them and their<br />
costs add up. So while the JIT needs to ensure that “safe” accesses don’t go out of bounds, it also tries<br />
to prove that certain accesses won’t, in which case it needn’t emit the bounds check that it knows will<br />
be superfluous. In every release of .NET, more and more cases have been added to find places these<br />
bounds checks can be eliminated, and .NET 7 is no exception.</p>
<p>[For example, dotnet/runtime#61662 from <a href="https://github.com/anthonycanino">@anthonycanino</a>](https://github.com/dotnet/runtime/pull/61662)<br />
enabled the JIT to understand various forms of binary operations as part of range checks. Consider<br />
this method:</p>
<p>It’s validating that the input span is 16 bytes long and then creating a <code>new ushort[8]</code> where each</p>
<p><code>ushort</code> in the array combines two of the input bytes. To do that, it’s looping over the output array,<br />
and indexing into the bytes array using <code>i * 2</code> and <code>i * 2 + 1</code> as the indices. On .NET 6, each of those<br />
indexing operations would result in a bounds check, with assembly like:</p>
<p>where that G_M000_IG04 is the <code>call CORINFO_HELP_RNGCHKFAIL</code> we’re now familiar with. But on .NET<br />
7, we get this assembly for the method:</p>
<p>36 CHAPTER 2 | JIT</p>
<p>No bounds checks, which is most easily seen by the lack of the telltale <code>call</code></p>
<p><code>CORINFO_HELP_RNGCHKFAIL</code> at the end of the method. With this PR, the JIT is able to understand the<br />
impact of certain multiplication and shift operations and their relationships to the bounds of the data<br />
structure. Since it can see that the result array’s length is 8 and the loop is iterating from 0 to that</p>
<p>to prove that the bounds checks aren’t needed.</p>
<p><a href="https://github.com/dotnet/runtime/pull/61569">dotnet/runtime#61569</a> <a href="https://github.com/dotnet/runtime/pull/62864">and dotnet/runtime#62864</a> also help to eliminate bounds checks when dealing<br />
with constant strings and spans initialized from RVA statics (“Relative Virtual Address” static fields,<br />
basically a static field that lives in a module’s data section). For example, consider this benchmark:</p>
<p>37 CHAPTER 2 | JIT</p>
<p>On .NET 6, we get this assembly:</p>
<p>The beginning of this makes sense: the JIT was obviously able to see that the length of <code>Text</code> is 5, so<br />
it’s implementing the <code>(uint)i &lt; Text.Length</code> check by doing <code>cmp rax,5</code>, and if <code>i</code> as an unsigned<br />
value is greater than or equal to 5, it’s then zero’ing out the return value (to return the <code>'\0'</code> ) and<br />
exiting. If the length is less than 5 (in which case it’s also at least 0 due to the unsigned comparison), it<br />
then jumps to M00_L00 to read the value from the string… but we then see another <code>cmp</code> against 5, this<br />
time as part of a range check. So even though the JIT knew the index was in bounds, it wasn’t able to<br />
remove the bounds check. Now it is; in .NET 7, we get this:</p>
<p>So much nicer.</p>
<p><a href="https://github.com/dotnet/runtime/pull/67141">dotnet/runtime#67141</a> is a great example of how evolving ecosystem needs drives specific<br />
optimizations into the JIT. The <code>Regex</code> compiler and source generator handle some cases of regular<br />
expression character classes by using a bitmap lookup stored in strings. For example, to determine<br />
whether a <code>char c</code> is in the character class <code>&quot;[A-Za-z0-9_]&quot;</code> (which will match an underscore or any<br />
ASCII letter or digit), the implementation ends up generating an expression like the body of the<br />
following method:</p>
<p>38 CHAPTER 2 | JIT</p>
<p>The implementation is treating an 8-character string as a 128-bit lookup table. If the character is<br />
known to be in range (such that it’s effectively a 7-bit value), it’s then using the top 3 bits of the value<br />
to index into the 8 elements of the string, and the bottom 4 bits to select one of the 16 bits in that<br />
element, giving us an answer as to whether this input character is in the set or not. In .NET 6, even<br />
though we know the character is in range of the string, the JIT couldn’t see through either the length<br />
comparison or the bit shift.</p>
<p>The previously mentioned PR takes care of the length check. And this PR takes care of the bit shift. So<br />
in .NET 7, we get this loveliness:</p>
<p>39 CHAPTER 2 | JIT</p>
<p>Note the distinct lack of a <code>call CORINFO_HELP_RNGCHKFAIL</code> . And as you might guess, this check can<br />
happen <em>a lot</em> in a <code>Regex</code>, making this a very useful addition.</p>
<p>Bounds checks are an obvious source of overhead when talking about array access, but they’re not the<br />
only ones. There’s also the need to use the cheapest instructions possible. In .NET 6, with a method<br />
like:</p>
<p>assembly code like the following would be generated:</p>
<p>This should look fairly familiar from our previous discussion; the JIT is loading the array’s length<br />
( <code>[rcx+8]</code> ) and comparing that with the value of <code>i</code> (in <code>edx</code> ), and then jumping to the end to throw an</p>
<p>of moving it, it’s sign-extending it; that’s the “sxd” part of the instruction name (sign-extending means<br />
the upper 32 bits of the new 64-bit value will be set to the value of the upper bit of the 32-bit value,</p>
<p>also know that <code>i</code> is non-negative. That makes such sign-extension useless, since the upper bit is<br />
guaranteed to be 0. Since the <code>mov</code> instruction that zero-extends is a tad cheaper than <code>movsxd</code>, we can<br />
<a href="https://github.com/dotnet/runtime/pull/57970">simply use that instead. And that’s exactly what dotnet/runtime#57970</a> from</p>
<p>[<a href="https://github.com/pentp">@pentp</a> does for both arrays and spans (dotnet/runtime#70884 also](https://github.com/dotnet/runtime/pull/70884)<br />
similarly avoids some signed casts in other situations). Now on .NET 7, we get this:</p>
<p>40 CHAPTER 2 | JIT</p>
<p>That’s not the only source of overhead with array access, though. In fact, there’s a very large category<br />
of array access overhead that’s been there forever, but that’s so well known there are even old FxCop<br />
rules and newer Roslyn analyzers that warn against it: multidimensional array accesses. The overhead<br />
in the case of a multidimensional array isn’t just an extra branch on every indexing operation, or<br />
additional math required to compute the location of the element, but rather that they currently pass<br />
<a href="https://github.com/dotnet/runtime/pull/70271">through the JIT’s optimization phases largely unmodified. dotnet/runtime#70271</a> improves the state<br />
of the world here by doing an expansion of a multidimensional array access early in the JIT’s pipeline,<br />
such that later optimization phases can improve multidimensional accesses as they would other code,<br />
including CSE and loop invariant hoisting. The impact of this is visible in a simple benchmark that<br />
sums all the elements of a multidimensional array.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>.NET 6.0</td>
<td>964.1 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Sum</td>
<td>.NET 7.0</td>
<td>674.7 us</td>
<td>0.70</td>
</tr>
</tbody>
</table>
<p>This previous example assumes you know the size of each dimension of the multidimensional array<br />
(it’s referring to the <code>Size</code> directly in the loops). That’s obviously not always (or maybe even rarely) the<br />
case. In such situations, you’d be more likely to use the <code>Array.GetUpperBound</code> method, and because</p>
<p>41 CHAPTER 2 | JIT</p>
<p>multidimensional arrays can have a non-zero lower bound, <code>Array.GetLowerBound</code> . That would lead to<br />
code like this:</p>
<p><a href="https://github.com/dotnet/runtime/pull/60816">In .NET 7, thanks to dotnet/runtime#60816, those</a> <code>GetLowerBound</code> and <code>GetUpperBound</code> calls become<br />
JIT intrinsics. An “intrinsic” to a compiler is something the compiler has intrinsic knowledge of, such<br />
that rather than relying solely on a method’s defined implementation (if it even has one), the compiler<br />
can substitute in something it considers to be better. There are literally thousands of methods in .NET</p>
<p>substitute the necessary assembly instructions to read directly from the memory location that houses<br />
the bounds. Here’s what the assembly code for this benchmark looked like with .NET 6; the main thing<br />
to see here are all of the <code>call</code> s out to <code>GetLowerBound</code> and <code>GetUpperBound</code> :</p>
<p>42 CHAPTER 2 | JIT</p>
<p>43 CHAPTER 2 | JIT</p>
<p>Now here’s what it is for .NET 7:</p>
<p>44 CHAPTER 2 | JIT</p>
<pre><code>call   System.Array.GetUpperBound(Int32)

</code></pre>
<p>we get:</p>
<p>and it ends up being much faster:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>.NET 6.0</td>
<td>2,657.5 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Sum</td>
<td>.NET 7.0</td>
<td>676.3 us</td>
<td>0.25</td>
</tr>
</tbody>
</table>
<p><strong>Loop Hoisting and Cloning</strong></p>
<p>We previously saw how PGO interacts with loop hoisting and cloning, and those optimizations have<br />
seen other improvements, as well.</p>
<p>Historically, the JIT’s support for hoisting has been limited to lifting an invariant out one level.<br />
Consider this example:</p>
<p>45 CHAPTER 2 | JIT</p>
<p>At first glance, you might look at this and say “what could be hoisted, the computation of <code>n</code> requires<br />
all of the loop inputs, and all of that computation is in <code>ComputeNumber</code> .” But from a compiler’s</p>
<p>different levels, e.g. the tens computation can be hoisted out one level, the hundreds out two levels,<br />
and the thousands out three levels. Here’s what <code>[DisassemblyDiagnoser]</code> outputs for .NET 6:</p>
<p>46 CHAPTER 2 | JIT</p>
<p>We can see that <em>some</em> hoisting has happened here. After all, the inner most loop (tagged M00_L03) is</p>
<p>all of the unnecessary computation out of the inner loop, being left only with adding the ones<br />
position to the rest of the number. Let’s go out a level. M00_L02 is the label for the tens loop. What</p>
<p>operations which could have been hoisted out further were left stuck in the next-to-innermost loop.<br />
<a href="https://github.com/dotnet/runtime/issues/68061">Now, here’s what we get for .NET 7, where this was improved in dotnet/runtime#68061:</a></p>
<p>47 CHAPTER 2 | JIT</p>
<p>Notice now where those <code>imul</code> instructions live. There are four labels, each one corresponding to one</p>
<p>highlighting that these computations were hoisted out to the appropriate level (the tens and ones<br />
computation are still in the right places).</p>
<p>More improvements have gone in on the cloning side. Previously, loop cloning would only apply for<br />
<a href="https://github.com/dotnet/runtime/pull/60148">loops iterating by 1 from a low to a high value. With dotnet/runtime#60148, the comparison against</a><br />
the upper value can be <code>&lt;=</code> rather than just <code>&lt;</code> <a href="https://github.com/dotnet/runtime/pull/67930">. And with dotnet/runtime#67930, loops that iterate</a><br />
downward can also be cloned, as can loops that have increments and decrements larger than 1.<br />
Consider this benchmark:</p>
<p>Without loop cloning, the JIT can’t assume that <code>offset</code> through <code>offset+count</code> are in range, and thus<br />
every access to the array needs to be bounds checked. With loop cloning, the JIT could generate one<br />
version of the loop without bounds checks and only use that when it knows all accesses will be valid.<br />
That’s exactly what happens now in .NET 7. Here’s what we got with .NET 6:</p>
<p>48 CHAPTER 2 | JIT</p>
<p>Notice how in the core loop, at label M00_L00, there’s a bounds check ( <code>cmp eax,r9d</code> and <code>jae short</code></p>
<p><code>M00_L03</code>, which jumps to a <code>call CORINFO_HELP_RNGCHKFAIL</code> ). And here’s what we get with .NET 7:</p>
<p>Notice how the code size is larger, and how there are now two variations of the loop: one at M00_L00<br />
and one at M00_L01. The second one, M00_L01, has a branch to that same <code>call</code></p>
<p>bounds.</p>
<p><a href="https://github.com/dotnet/runtime/pull/59886">Other changes also improved loop cloning. dotnet/runtime#59886</a> enables the JIT to choose different<br />
forms for how to emit the the conditions for choosing the fast or slow loop path, e.g. whether to emit</p>
<p>49 CHAPTER 2 | JIT</p>
<p><code>slowPath</code> <a href="https://github.com/dotnet/runtime/pull/66257">). dotnet/runtime#66257 enables loop cloning to kick in when the loop variable is initialized</a><br />
to more kinds of expressions (e.g. <code>for (int fromindex = lastIndex - lengthToClear; ...)</code> ). And<br />
<a href="https://github.com/dotnet/runtime/pull/70232">dotnet/runtime#70232</a> increases the JIT’s willingness to clone loops with bodies that do a broader set<br />
of operations.</p>
<p><strong>Folding, propagation, and substitution</strong></p>
<p>Constant folding is an optimization where a compiler computes the value of an expression involving<br />
only constants at compile-time rather than generating the code to compute the value at run-time.<br />
There are multiple levels of constant folding in .NET, with some constant folding performed by the C#<br />
compiler and some constant folding performed by the JIT compiler. For example, given the C# code:</p>
<p>the C# compiler will generate IL for these methods like the following:</p>
<p><code>2;</code>, highlighting that the constant folding performed by the C# compiler was intramethod only. Now<br />
here’s what the JIT generates:</p>
<p>50 CHAPTER 2 | JIT</p>
<p>The assembly for method <code>A</code> isn’t particularly interesting; it’s just returning that same value 23 (hex</p>
<p>0x2e). Constant propagation is intricately linked to constant folding and is essentially just the idea that<br />
you can substitute a constant value (typically one computed via constant folding) into further<br />
expressions, at which point they may also be able to be folded.</p>
<p>The JIT has long performed constant folding, but it improves further in .NET 7. One of the ways<br />
constant folding can improve is by exposing more values to be folded, which often means more</p>
<p>should consider being more aggressive about inlining, since exposing that constant to the body of the<br />
callee can potentially significantly reduce the amount of code required to implement the callee. The<br />
JIT might have previously inlined such a method anyway, but when it comes to inlining, the JIT is all<br />
about heuristics and generating enough evidence that it’s worthwhile to inline something; this<br />
contributes to that evidence. This pattern shows up, for example, in the various <code>FromXx</code> methods on</p>
<p><code>TimeSpan</code> . For example, <code>TimeSpan.FromSeconds</code> is implemented as:</p>
<p>and, eschewing argument validation for the purposes of this example, <code>Interval</code> is:</p>
<p>which if everything gets inlined means <code>FromSeconds</code> is essentially:</p>
<pre><code>return new TimeSpan(50_000_000);

</code></pre>
<p>I’ll spare you the .NET 6 assembly for this, but on .NET 7 with a benchmark like:</p>
<p>we now get the simple and clean:</p>
<p>51 CHAPTER 2 | JIT</p>
<p><a href="https://github.com/dotnet/runtime/pull/57726">Another change improving constant folding included dotnet/runtime#57726</a> from</p>
<p><a href="https://github.com/SingleAccretion">@SingleAccretion</a>, which unblocked constant folding in a<br />
particular scenario that sometimes manifests when doing field-by-field assignment of structs being<br />
returned from method calls. As a small example, consider this trivial property, which access the</p>
<p><code>Color.DarkOrange</code> property, which in turn does <code>new Color(KnownColor.DarkOrange)</code> :</p>
<p>In .NET 6, the JIT generated this:</p>
<p>with direct assignment of these constant values into their destination locations ( <code>mov word ptr</code></p>
<p><code>[rdx+12],1</code> and <code>mov word ptr [rdx+10],39</code> ). Other changes contributing to constant folding<br />
[included dotnet/runtime#58171 from <a href="https://github.com/SingleAccretion">@SingleAccretion</a> and](https://github.com/dotnet/runtime/pull/58171)<br />
<a href="https://github.com/dotnet/runtime/pull/57605">dotnet/runtime#57605</a> from <a href="https://github.com/SingleAccretion">@SingleAccretion</a>.</p>
<p>However, a large category of improvement came from an optimization related to propagation, that of<br />
forward substitution. Consider this silly benchmark:</p>
<p>52 CHAPTER 2 | JIT</p>
<p>If we look at the assembly code generated for <code>Compute1</code> on .NET 6, it looks like what we’d hope for.<br />
We’re adding <code>Value</code> 5 times, <code>Value</code> is trivially inlined and returns a constant value 16, and so we’d<br />
hope that the assembly code generated for <code>Compute1</code> would effectively just be returning the value 80<br />
(hex 0x50), which is exactly what happens:</p>
<p>with this assembly code:</p>
<p>Rather than a single <code>mov eax, 50</code> to put the value 0x50 into the return register, we have 5 separate</p>
<p><code>add eax, 10</code> to build up that same 0x50 (80) value. That’s… not ideal.</p>
<p>It turns out that many of the JIT’s optimizations operate on the tree data structures created as part of<br />
parsing the IL. In some cases, optimizations can do better when they’re exposed to more of the<br />
program, in other words when the tree they’re operating on is larger and contains more to be<br />
analyzed. However, various operations can break up these trees into smaller, individual ones, such as<br />
with temporary variables created as part of inlining, and in doing so can inhibit these operations.<br />
Something is needed in order to effectively stitch these trees back together, and that’s forward<br />
substitution. You can think of forward substitution almost like an inverse of CSE; rather than trying to<br />
find duplicate expressions and eliminate them by computing the value once and storing it into a<br />
temporary, forward substitution eliminates that temporary and effectively moves the expression tree<br />
into its use site. Obviously you don’t want to do this if it would then negate CSE and result in<br />
duplicate work, but for expressions that are defined once and used once, this kind of forward<br />
<a href="https://github.com/dotnet/runtime/pull/61023">propagation is valuable. dotnet/runtime#61023 added an initial limited version of forward</a><br />
<a href="https://github.com/dotnet/runtime/pull/63720">substitution, and then dotnet/runtime#63720 added a more robust generalized implementation.</a><br />
<a href="https://github.com/dotnet/runtime/pull/70587">Subsequently, dotnet/runtime#70587 expanded it to also cover some SIMD vectors, and then</a><br />
<a href="https://github.com/dotnet/runtime/pull/71161">dotnet/runtime#71161</a> improved it further to enable substitutions into more places (in this case into<br />
call arguments). And with those, our silly benchmark now produces the following on .NET 7:</p>
<p>53 CHAPTER 2 | JIT</p>
<p><strong>Vectorization</strong></p>
<p>SIMD, or Single Instruction Multiple Data, is a kind of processing in which one instruction applies to<br />
multiple pieces of data at the same time. You’ve got a list of numbers and you want to find the index<br />
of a particular value? You could walk the list comparing one element at a time, and that would be fine<br />
functionally. But what if in the same amount of time it takes you to read and compare one element,<br />
you could instead read and compare two elements, or four elements, or 32 elements? That’s SIMD,<br />
and the art of utilizing SIMD instructions is lovingly referred to as “vectorization,” where operations<br />
are applied to all of the elements in a “vector” at the same time.</p>
<p>.NET has long had support for vectorization in the form of <code>Vector&lt;T&gt;</code>, which is an easy-to-use type<br />
with first-class JIT support to enable a developer to write vectorized implementations. One of</p>
<p><code>Vector&lt;T&gt;</code> ’s greatest strengths is also one of its greatest weaknesses. The type is designed to adapt to<br />
whatever width vector instructions are available in your hardware. If the machine supports 256-bit</p>
<p>today; for example, the operations you can perform on a <code>Vector&lt;T&gt;</code> end up needing to be agnostic to<br />
the width of the vectors used, since the width is variable based on the hardware on which the code<br />
actually runs. And that means the operations that can be exposed on <code>Vector&lt;T&gt;</code> are limited, which in<br />
turn limits the kinds of operations that can be vectorized with it. Also, because it’s only ever a single<br />
size in a given process, some data set sizes that fall in between 128 bits and 256 bits might not be<br />
processed as well as you’d hope. You write your <code>Vector&lt;byte&gt;</code> -based algorithm, and you run it on a<br />
machine with support for 256-bit vectors, which means it can process 32 bytes at a time, but then you<br />
feed it an input with 31 bytes. Had <code>Vector&lt;T&gt;</code> mapped to 128-bit vectors, it could have been used to<br />
improve the processing of that input, but as its vector size is larger than the input data size, the<br />
implementation ends up falling back to one that’s not accelerated. There are also issues related to<br />
R2R and Native AOT, since ahead-of-time compilation needs to know in advance what instructions</p>
<p>methods that was JIT compiled in a “hello, world” console app, and that this was because it lacked R2R<br />
code due to its use of <code>Vector&lt;T&gt;</code> .</p>
<p>Starting in .NET Core 3.0, .NET gained literally thousands of new “hardware intrinsics” methods, most<br />
of which are .NET APIs that map down to one of these SIMD instructions. These intrinsics enable an<br />
expert to write an implementation tuned to a specific instruction set, and if done well, get the best<br />
possible performance, but it also requires the developer to understand each instruction set and to<br />
implement their algorithm for each instruction set that might be relevant, e.g. an AVX2<br />
implementation if it’s supported, or an SSE2 implementation if it’s supported, or an ArmBase<br />
implementation if it’s supported, and so on.</p>
<p>.NET 7 has introduced a middle ground. Previous releases saw the introduction of the <code>Vector128&lt;T&gt;</code><br />
and <code>Vector256&lt;T&gt;</code> types, but purely as the vehicle by which data moved in and out of the hardware<br />
intrinsics, since they’re all tied to specific width vectors. Now in .NET 7, exposed via</p>
<p>54 CHAPTER 2 | JIT</p>
<p><a href="https://github.com/dotnet/runtime/pull/53450">dotnet/runtime#53450,</a> <a href="https://github.com/dotnet/runtime/pull/63414">dotnet/runtime#63414, dotnet/runtime#60094, and dotnet/runtime#68559, a</a><br />
very large set of cross-platform operations is defined over these types as well, e.g.</p>
<p>target one or more of these two types. Typically this would amount to a developer writing one code<br />
path based on <code>Vector128&lt;T&gt;</code>, as that has the broadest reach and achieves a significant amount of the<br />
gains from vectorization, and then if is motivated to do so can add a second path for <code>Vector256&lt;T&gt;</code> in<br />
order to potentially double throughput further on platforms that have 256-bit width vectors. Think of<br />
these types and methods as a platform-abstraction layer: you code to these methods, and then the JIT<br />
translates them into the most appropriate instructions for the underlying platform. Consider this<br />
simple code as an example:</p>
<p>here’s what the optimized tier-1 code for these looks like on my x64 Windows machine:</p>
<p>55 CHAPTER 2 | JIT</p>
<p>Notice anything? The code for the two methods is identical, both resulting in a <code>vpmovmskb</code> (Move Byte<br />
Mask) instruction. Yet the former code will only work on a platform that supports SSE2 whereas the<br />
latter code will work on any platform with support for 128-bit vectors, including Arm64 and WASM<br />
(and any future platforms on-boarded that also support SIMD); it’ll just result in different instructions<br />
being emitted on those platforms.</p>
<p>To explore this a bit more, let’s take a simple example and vectorize it. We’ll implement a <code>Contains</code><br />
method, where we want to search a span of bytes for a specific value and return whether it was found:</p>
<p>How would we vectorize this with <code>Vector&lt;T&gt;</code> ? First things first, we need to check whether it’s even<br />
supported, and fall back to our existing implementation if it’s not ( <code>Vector.IsHardwareAccelerated</code> ).<br />
We also need to fall back if the length of the input is less than the size of a vector<br />
( <code>Vector&lt;byte&gt;.Count</code> ).</p>
<p>56 CHAPTER 2 | JIT</p>
<p>Now that we know we have enough data, we can get to coding our vectorized loop. In this loop, we’ll<br />
be searching for the <code>needle</code>, which means we need a vector that contains that value for every element;<br />
the <code>Vector&lt;T&gt;</code> ’s constructor provides that ( <code>new Vector&lt;byte&gt;(needle)</code> ). And we need to be able to<br />
slice off a vector’s width of data at a time; for a bit more efficiency, I’ll use pointers. We need a current<br />
iteration pointer, and we need to iterate until the point where we couldn’t form another vector<br />
because we’re too close to the end, and a straightforward way to do that is to get a pointer that’s<br />
exactly one vector’s width from the end; that way, we can just iterate until our current pointer is equal<br />
to or greater than that threshold. And finally, in our loop body, we need to compare our current<br />
vector with the target vector to see if any elements are the same ( <code>Vector.EqualsAny</code> ), if any is<br />
returning true, and if not bumping our current pointer to the next location. At this point we have:</p>
<p>And we’re almost done. The last issue to handle is we may still have a few elements at the end we<br />
haven’t searched. There are a couple of ways we could handle that. One would be to just continue<br />
with our fall back implementation and process each of the remaining elements one at a time. Another<br />
would be to employ a trick that’s common when vectorizing idempotent operations. Our operation<br />
isn’t mutating anything, which means it doesn’t matter if we compare the same element multiple<br />
times, which means we can just do one final vector compare for the last vector in the search space;</p>
<p>57 CHAPTER 2 | JIT</p>
<p>that might or might not overlap with elements we’ve already looked at, but it won’t hurt anything if it<br />
does. And with that, our implementation is complete:</p>
<p>Congratulations, we’ve vectorized this operation, and fairly decently at that. We can throw this into<br />
benchmarkdotnet and see really nice speedups:</p>
<p>58 CHAPTER 2 | JIT</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Find</td>
<td>484.05 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>FindVectorized</td>
<td>20.21 ns</td>
<td>0.04</td>
</tr>
</tbody>
</table>
<p>A 24x speedup! Woo hoo, victory, all your performance are belong to us!</p>
<p>You deploy this in your service, and you see <code>Contains</code> being called on your hot path, but you don’t<br />
see the improvements you were expecting. You dig in a little more, and you discover that while you<br />
tested this with an input array with 1000 elements, typical inputs had more like 30 elements. What<br />
happens if we change our benchmark to have just 30 elements? That’s not long enough to form a<br />
vector, so we fall back to the one-at-a-time path, and we don’t get any speedups at all.</p>
<p>One thing we can now do is switch from using <code>Vector&lt;T&gt;</code> to <code>Vector128&lt;T&gt;</code> . That will then lower the<br />
threshold from 32 bytes to 16 bytes, such that inputs in that range will still have some amount of<br />
vectorization applied. As these <code>Vector128&lt;T&gt;</code> and <code>Vector256&lt;T&gt;</code> types have been designed very<br />
recently, they also utilize all the cool new toys, and thus we can use <code>ref</code> s instead of pointers. Other</p>
<p>pointer arithmetic on the span we fixed.</p>
<p>59 CHAPTER 2 | JIT</p>
<p>With that in hand, we can now try it on our smaller 30 element data set:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Find</td>
<td>15.388 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>FindVectorized</td>
<td>1.747 ns</td>
<td>0.11</td>
</tr>
</tbody>
</table>
<p>Woo hoo, victory, all your performance are belong to us… again!</p>
<p>What about on the larger data set again? Previously with <code>Vector&lt;T&gt;</code> we had a 24x speedup, but now:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Find</td>
<td>484.25 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>FindVectorized</td>
<td>32.92 ns</td>
<td>0.07</td>
</tr>
</tbody>
</table>
<p>… closer to 15x. Nothing to sneeze at, but it’s not the 24x we previously saw. What if we want to have</p>
<p>are enough elements to utilize it.</p>
<p>60 CHAPTER 2 | JIT</p>
<p>And, boom, we’re back:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Find</td>
<td>484.53 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>FindVectorized</td>
<td>20.08 ns</td>
<td>0.04</td>
</tr>
</tbody>
</table>
<p>We now have an implementation that is vectorized on any platform with either 128-bit or 256-bit<br />
vector instructions (x86, x64, Arm64, WASM, etc.), that can use either based on the input length, and<br />
that can be included in an R2R image if that’s of interest.</p>
<p>There are many factors that impact which path you go down, and I expect we’ll have guidance<br />
forthcoming to help navigate all the factors and approaches. But the capabilities are all there, and<br />
whether you choose to use <code>Vector&lt;T&gt;</code>, <code>Vector128&lt;T&gt;</code> and/or <code>Vector256&lt;T&gt;</code>, or the hardware<br />
intrinsics directly, there are some amazing performance opportunities ready for the taking.</p>
<p>61 CHAPTER 2 | JIT</p>
<p>I already mentioned several PRs that exposed the new cross-platform vector support, but that only<br />
scratches the surface of the work done to actually enable these operations and to enable them to<br />
produce high-quality code. As just one example of a category of such work, a set of changes went in</p>
<p>that add first-class knowledge of vector constants to the JIT’s intermediate representation; and<br />
<a href="https://github.com/dotnet/runtime/pull/62933">dotnet/runtime#62933,</a> <a href="https://github.com/dotnet/runtime/pull/65632">dotnet/runtime#65632, dotnet/runtime#55875, dotnet/runtime#67502, and</a><br />
<a href="https://github.com/dotnet/runtime/pull/64783">dotnet/runtime#64783</a> that all improve the code quality of instructions generated for zero vector<br />
comparisons.</p>
<p><strong>Inlining</strong></p>
<p>Inlining is one of the most important optimizations the JIT can do. The concept is simple: instead of<br />
making a call to some method, take the code from that method and bake it into the call site. This has<br />
the obvious advantage of avoiding the overhead of a method call, but except for really small methods<br />
on really hot paths, that’s often on the smaller side of the wins inlining brings. The bigger wins are<br />
due to the callee’s code being exposed to the caller’s code, and vice versa. So, for example, if the<br />
caller is passing a constant as an argument to the callee, if the method isn’t inlined, the compilation of<br />
the callee has no knowledge of that constant, but if the callee is inlined, all of the code in the callee is<br />
then aware of its argument being a constant value, and can do all of the optimizations possible with<br />
such a constant, like dead code elimination, branch elimination, constant folding and propagation,<br />
and so on. Of course, if it were all rainbows and unicorns, everything possible to be inlined would be<br />
inlined, and that’s obviously not happening. Inlining brings with it the cost of potentially increased<br />
binary size. If the code being inlined would result in the same amount or less assembly code in the<br />
caller than it takes to call the callee (and if the JIT can quickly determine that), then inlining is a nobrainer. But if the code being inlined would increase the size of the callee non-trivially, now the JIT<br />
needs to weigh that increase in code size against the throughput benefits that could come from it.<br />
That code size increase can itself result in throughput regressions, due to increasing the number of<br />
distinct instructions to be executed and thereby putting more pressure on the instruction cache. As<br />
with any cache, the more times you need to read from memory to populate it, the less effective the<br />
cache will be. If you have a function that gets inlined into 100 different call sites, every one of those<br />
call sites’ copies of the callee’s instructions are unique, and calling each of those 100 functions could<br />
end up thrashing the instruction cache; in contrast, if all of those 100 functions “shared” the same<br />
instructions by simply calling the single instance of the callee, it’s likely the instruction cache would be<br />
much more effective and lead to fewer trips to memory.</p>
<p>All that is to say, inlining is <em>really</em> important, it’s important that the “right” things be inlined and that it<br />
not overinline, and as such every release of .NET in recent memory has seen nice improvements<br />
around inlining. .NET 7 is no exception.</p>
<p><a href="https://github.com/dotnet/runtime/pull/64521">One really interesting improvement around inlining is dotnet/runtime#64521, and it might be</a><br />
surprising. Consider the <code>Boolean.ToString</code> method; here’s its full implementation:</p>
<p>62 CHAPTER 2 | JIT</p>
<p>Pretty simple, right? You’d expect something this trivial to be inlined. Alas, on .NET 6, this benchmark:</p>
<p>produces this assembly code:</p>
<p>Note the <code>call System.Boolean.ToString()</code> . The reason for this is, historically, the JIT has been<br />
unable to inline methods across assembly boundaries if those methods contain string literals (like the</p>
<p><code>&quot;False&quot;</code> and <code>&quot;True&quot;</code> in that <code>Boolean.ToString</code> implementation). This restriction had to do with string<br />
interning and the possibility that such inlining could lead to visible behavioral differences. Those<br />
concerns are no longer valid, and so this PR removes the restriction. As a result, that same benchmark<br />
on .NET 7 now produces this:</p>
<p>No more <code>call System.Boolean.ToString()</code> .</p>
<p><a href="https://github.com/dotnet/runtime/pull/61408">dotnet/runtime#61408</a> made two changes related to inlining. First, it taught the inliner how to better<br />
see the what methods were being called in an inlining candidate, and in particular when tiered<br />
compilation is disabled or when a method would bypass tier-0 (such as a method with loops before<br />
OSR existed or with OSR disabled); by understanding what methods are being called, it can better<br />
understand the cost of the method, e.g. if those method calls are actually hardware intrinsics with a<br />
very low cost. Second, it enabled CSE in more cases with SIMD vectors.</p>
<p><a href="https://github.com/dotnet/runtime/pull/71778">dotnet/runtime#71778</a> also impacted inlining, and in particular in situations where a <code>typeof()</code> could<br />
be propagated to the callee (e.g. via a method argument). In previous releases of .NET, various</p>
<p>63 CHAPTER 2 | JIT</p>
<p>members on <code>Type</code> like <code>IsValueType</code> were turned into JIT intrinsics, such that the JIT could substitute a<br />
constant value for calls where it could compute the answer at compile time. For example, this:</p>
<p>results in this assembly code on .NET 6:</p>
<p>However, change the benchmark slightly:</p>
<p>and it’s no longer as simple:</p>
<p>Effectively, as part of inlining the JIT loses the notion that the argument is a constant and fails to<br />
propagate it. This PR fixes that, such that on .NET 7, we now get what we expect:</p>
<p><strong>Arm64</strong></p>
<p>A huge amount of effort in .NET 7 went into making code gen for Arm64 as good or better than its<br />
x64 counterpart. I’ve already discussed a bunch of PRs that are relevant regardless of architecture, and<br />
others that are specific to Arm, but there are plenty more. To rattle off some of them:</p>
<ul>
<li><strong>Addressing modes</strong> . “Addressing mode” is the term used to refer to how the operand of<br />
instructions are specified. It could be the actual value, it could be the address from where a value<br />
should be loaded, it could be the register containing the value, and so on. Arm supports a<br />
“scaled” addressing mode, typically used for indexing into an array, where the size of each<br />
element is supplied and the instruction “scales” the provided offset by the specified scale.<br />
<a href="https://github.com/dotnet/runtime/pull/60808">dotnet/runtime#60808 enables the JIT to utilize this addressing mode. More generally,</a><br />
<a href="https://github.com/dotnet/runtime/pull/70749">dotnet/runtime#70749 enables the JIT to use addressing modes when accessing elements of</a></li>
</ul>
<p>64 CHAPTER 2 | JIT</p>
<p><a href="https://github.com/dotnet/runtime/pull/67490">And dotnet/runtime#67490 implements addressing modes for SIMD vectors, specifically for</a><br />
loads with unscaled indices.</p>
<ul>
<li><strong>Better instruction selection</strong> . Various techniques go into ensuring that the best instructions are<br />
<a href="https://github.com/dotnet/runtime/pull/61037">selected to represent input code. dotnet/runtime#61037</a> teaches the JIT how to recognize the</li>
</ul>
<p>enables the JIT to recognize certain constant bit shift operations (either explicit in the code or<br />
implicit to various forms of managed array access) and emit <code>sbfiz</code> / <code>ubfiz</code> instructions.</p>
<p><a href="https://github.com/SeanWoo">@SeanWoo</a> removes an unnecessary <code>movi</code> emitted as part of<br />
<a href="https://github.com/dotnet/runtime/pull/57926">setting a dereferenced pointer to a constant value. dotnet/runtime#57926 from</a></p>
<p><a href="https://github.com/SingleAccretion">@SingleAccretion</a> enables computing a 64-bit result as the</p>
<p><code>uxtw</code> / <code>sxtw</code> / <code>lsl</code> <a href="https://github.com/dotnet/runtime/pull/62630">, while dotnet/runtime#62630</a> drops redundant zero extensions after a <code>ldr</code><br />
instruction.</p>
<ul>
<li>
<p><strong>Zeroing</strong> . Lots of operations require state to be set to zero, such as initializing all reference locals<br />
in a method to zero as part of the method’s prologue (so that the GC doesn’t see and try to<br />
follow garbage references). While such functionality was previously vectorized,<br />
<a href="https://github.com/dotnet/runtime/pull/63422">dotnet/runtime#63422 enables this to be implemented using 128-bit width vector instructions</a><br />
<a href="https://github.com/dotnet/runtime/pull/64481">on Arm. And dotnet/runtime#64481 changes the instruction sequences used for zeroing in order</a><br />
to avoid unnecessary zeroing, free up additional registers, and enable the CPU to recognize<br />
various instruction sequences and better optimize.</p>
</li>
<li>
<p><strong>Memory Model</strong> <a href="https://github.com/dotnet/runtime/pull/62895">. dotnet/runtime#62895 enables store barriers to be used wherever possible</a></p>
</li>
</ul>
<p><a href="https://github.com/dotnet/runtime/pull/64354">dotnet/runtime#64354 uses a cheaper instruction sequence to handle volatile indirections.</a><br />
<a href="https://github.com/dotnet/runtime/pull/70600">There’s dotnet/runtime#70600, which enables LSE Atomics to be used for</a> <code>Interlocked</code><br />
<a href="https://github.com/dotnet/runtime/pull/71512">operations; dotnet/runtime#71512, which enables using the</a> <code>atomics</code> instruction on Unix<br />
<a href="https://github.com/dotnet/runtime/pull/70921">machines; and dotnet/runtime#70921, which enables the same but on Windows.</a></p>
<p><strong>JIT helpers</strong></p>
<p>While logically part of the runtime, the JIT is actually isolated from the rest of the runtime, only<br />
interacting with it through an interface that enables communication between the JIT and the rest of<br />
the VM (Virtual Machine). There’s a large amount of VM functionality then that the JIT relies on for<br />
good performance.</p>
<p><a href="https://github.com/dotnet/runtime/pull/65738">dotnet/runtime#65738</a> rewrote various “stubs” to be more efficient. Stubs are tiny bits of code that<br />
serve to perform some check and then redirect execution somewhere else. For example, when an<br />
interface dispatch call site is expected to only ever be used with a single implementation of that<br />
interface, the JIT might employ a “dispatch stub” that compares the type of the object against the</p>
<p>65 CHAPTER 2 | JIT</p>
<p>single one it’s cached, and if they’re equal simply jumps to the right target. You know you’re in the<br />
corest of the core areas of the runtime when a PR contains lots of assembly code for every<br />
architecture the runtime targets. And it paid off; there’s a virtual group of folks from around .NET that<br />
review performance improvements and regressions in our automated performance test suites, and<br />
attribute these back to the PRs likely to be the cause (this is mostly automated but requires some<br />
human oversight). It’s always nice then when a few days after a PR is merged and performance<br />
information has stabilized that you see a rash of comments like there were on this PR:</p>
<p>For anyone familiar with generics and interested in performance, you may have heard the refrain that<br />
generic virtual methods are relatively expensive. They are, comparatively. For example on .NET 6, this<br />
code:</p>
<p>results in:</p>
<p>66 CHAPTER 2 | JIT</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>GenericNonVirtual</td>
<td>0.4866<br>ns</td>
<td>1.00</td>
</tr>
<tr>
<td>GenericVirtual</td>
<td>6.4552<br>ns</td>
<td>13.28</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/65926">dotnet/runtime#65926</a> eases the pain a tad. Some of the cost comes from looking up some cached<br />
information in a hash table in the runtime, and as is the case with many map implementations, this<br />
one involves computing a hash code and using a mod operation to map to the right bucket. Other<br />
<a href="https://github.com/dotnet/runtime">hash table implementations around dotnet/runtime, including</a> <code>Dictionary&lt;,&gt;</code>, <code>HashSet&lt;,&gt;</code>, and</p>
<table>
<thead>
<tr>
<th>employed:</th>
<th>Col2</th>
<th>Col3</th>
<th>Col4</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Method</strong></td>
<td><strong>Runtime</strong></td>
<td><strong>Mean</strong></td>
<td><strong>Ratio</strong></td>
</tr>
<tr>
<td>GenericVirtual</td>
<td>.NET 6.0</td>
<td>6.475 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>GenericVirtual</td>
<td>.NET 7.0</td>
<td>6.119 ns</td>
<td>0.95</td>
</tr>
</tbody>
</table>
<p>Not enough of an improvement for us to start recommending people use them, but a 5%<br />
improvement takes a bit of the edge off the sting.</p>
<p><strong>Grab Bag</strong></p>
<p>It’s near impossible to cover every performance change that goes into the JIT, and I’m not going to<br />
try. But there were so many more PRs, I couldn’t just leave them all unsung, so here’s a few more<br />
quickies:</p>
<ul>
<li>[dotnet/runtime#58196 from <a href="https://github.com/benjamin-hodgson">@benjamin-hodgson</a>.](https://github.com/dotnet/runtime/pull/58196)</li>
</ul>
<p>67 CHAPTER 2 | JIT</p>
<ul>
<li>[dotnet/runtime#69003 from <a href="https://github.com/SkiFoD">@SkiFoD</a>. The pattern](https://github.com/dotnet/runtime/pull/69003) <code>~x + 1</code> can be<br />
changed into a two’s-complement negation.</li>
</ul>
<p>actually expressible without a following <code>!= 0</code> in C#).</p>
<p>68 CHAPTER 2 | JIT</p>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/62394">dotnet/runtime#62394.</a> <code>/</code> and <code>%</code> by a vector’s <code>.Count</code> wasn’t recognizing that <code>Count</code> can be<br />
unsigned, but doing so leads to better code gen.</li>
</ul>
<p>69 CHAPTER 2 | JIT</p>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/60787">dotnet/runtime#60787. Loop alignment in .NET 6</a> provides a very nice exploration of why and<br />
how the JIT handles loop alignment. This PR extends that further by trying to “hide” an emitted<br />
<code>align</code> instruction behind an unconditional <code>jmp</code> that might already exist, in order to minimize the<br />
impact of the processor having to fetch and decode <code>nop</code> s.</li>
</ul>
<p>70 CHAPTER 2 | JIT</p>
<p><strong>CHAPTER</strong></p>
<h1>3</h1>
<h2>GC</h2>
<p>“Regions” is a feature of the garbage collector (GC) that’s been in the works for multiple years. It’s<br />
<a href="https://github.com/dotnet/runtime/pull/64688">enabled by default in 64-bit processes in .NET 7 as of dotnet/runtime#64688, but as with other multi-</a><br />
year features, a multitude of PRs went into making it a reality. At a 30,000 foot level, “regions” replaces<br />
the current “segments” approach to managing memory on the GC heap; rather than having a few<br />
gigantic segments of memory (e.g. each 1GB), often associated 1:1 with a generation, the GC instead<br />
maintains many, many smaller regions (e.g. each 4MB) as their own entity. This enables the GC to be<br />
more agile with regards to operations like repurposing regions of memory from one generation to<br />
<a href="https://devblogs.microsoft.com/dotnet/put-a-dpad-on-that-gc">another. For more information on regions, the blog post Put a DPAD on that GC!</a> from the primary<br />
developer on the GC is still the best resource.</p>
<p>71 CHAPTER 3 | GC</p>
<p><strong>CHAPTER</strong></p>
<h1>4</h1>
<h2>Native AOT</h2>
<p>To many people, the word “performance” in the context of software is about throughput. How fast<br />
does something execute? How much data per second can it process? How many requests per second<br />
can it process? And so on. But there are many other facets to performance. How much memory does<br />
it consume? How fast does it start up and get to the point of doing something useful? How much<br />
space does it consume on disk? How long would it take to download? And then there are related<br />
concerns. In order to achieve these goals, what dependencies are required? What kinds of operations<br />
does it need to perform to achieve these goals, and are all of those operations permitted in the target<br />
environment? If any of this paragraph resonates with you, you are the target audience for the Native<br />
AOT support now shipping in .NET 7.</p>
<p>.NET has long had support for AOT code generation. For example, .NET Framework had it in the form<br />
of <code>ngen</code>, and .NET Core has it in the form of <code>crossgen</code> . Both of those solutions involve a standard .NET<br />
executable that has some of its IL already compiled to assembly code, but not all methods will have<br />
assembly code generated for them, various things can invalidate the assembly code that was<br />
generated, external .NET assemblies without any native assembly code can be loaded, and so on, and<br />
in all of those cases, the runtime continues to utilize a JIT compiler. Native AOT is different. It’s an<br />
evolution of CoreRT, which itself was an evolution of .NET Native, and it’s entirely free of a JIT. The<br />
binary that results from publishing a build is a completely standalone executable in the target<br />
platform’s platform-specific file format (e.g. COFF on Windows, ELF on Linux, Mach-O on macOS) with<br />
no external dependencies other than ones standard to that platform (e.g. libc). And it’s entirely native:<br />
no IL in sight, no JIT, no nothing. All required code is compiled and/or linked in to the executable,<br />
including the same GC that’s used with standard .NET apps and services, and a minimal runtime that<br />
provides services around threading and the like. All of that brings great benefits: super fast startup<br />
time, small and entirely-self contained deployment, and ability to run in places JIT compilers aren’t<br />
allowed (e.g. because memory pages that were writable can’t then be executable). It also brings<br />
limitations: no JIT means no dynamic loading of arbitrary assemblies (e.g. <code>Assembly.LoadFile</code> ) and no<br />
reflection emit (e.g. <code>DynamicMethod</code> ), everything compiled and linked in to the app means the more<br />
functionality that’s used (or might be used) the larger is your deployment, etc. Even with those<br />
limitations, for a certain class of application, Native AOT is an incredibly exciting and welcome<br />
addition to .NET 7.</p>
<p>Too many PRs to mention have gone into bringing up the Native AOT stack, in part because it’s been<br />
<a href="https://github.com/dotnet/corert">in the works for years (as part of the archived dotnet/corert</a> project and then as part of<br />
<a href="https://github.com/dotnet/runtimelab/tree/feature/NativeAOT">dotnet/runtimelab/feature/NativeAOT) and in part because there have been over a hundred PRs just</a><br />
<a href="https://github.com/dotnet/runtime">in dotnet/runtime</a> that have gone into bringing Native AOT up to a shippable state since the code was<br />
<a href="https://github.com/dotnet/runtimelab">originally brought over from dotnet/runtimelab</a> <a href="https://github.com/dotnet/runtime/pull/62563">in dotnet/runtime#62563</a> <a href="https://github.com/dotnet/runtime/pull/62611">and dotnet/runtime#62563.</a><br />
Between that and there not being a previous version to compare its performance to, instead of<br />
focusing PR by PR on improvements, let’s just look at how to use it and the benefits it brings.</p>
<p>72 CHAPTER 4 | Native AOT</p>
<p>Today, Native AOT is focused on console applications, so let’s create a console app:</p>
<pre><code>dotnet new console -o nativeaotexample

&lt;PublishAot&gt;true&lt;/PublishAot&gt;

</code></pre>
<p>And then… actually, that’s it. Our app is now fully configured to be able to target Native AOT. All that’s<br />
left is to publish. As I’m currently writing this on my Windows x64 machine, I’ll target that:</p>
<pre><code>dotnet publish -r win-x64 -c Release

</code></pre>
<p>I now have my generated executable in the output publish directory:</p>
<p>so 2M instead of 3.5MB. Of course, for that significant reduction I’ve given up some things:</p>
<ul>
<li>Setting <code>InvariantGlobalization</code> to true means I’m now not respecting culture information and<br />
am instead using a set of invariant data for most globalization operations.</li>
</ul>
<p>should I need to debug an exception.</p>
<ul>
<li>
<p>Setting <code>DebuggerSupport</code> to false… good luck debugging things.</p>
</li>
<li>
<p>… you get the idea.</p>
</li>
</ul>
<p>One of the potentially mind-boggling aspects of Native AOT for a developer used to .NET is that, as it<br />
says on the tin, it really is native. After publishing the app, there is no IL involved, and there’s no JIT<br />
that could even process it. This makes some of the other investments in .NET 7 all the more valuable,<br />
for example everywhere investments are happening in source generators. Code that previously relied<br />
on reflection emit for good performance will need another scheme. We can see that, for example, with</p>
<p>implementation of the specified pattern. But if you look at the implementation of the <code>Regex</code><br />
constructor, you’ll find this nugget:</p>
<p>With the JIT, <code>IsDynamicCodeCompiled</code> is true. But with Native AOT, it’s false. Thus, with Native AOT</p>
<p><code>[GeneratedRegex(...)]</code>, which, along with the new regex source generator shipping in the .NET 7</p>
<p>73 CHAPTER 4 | Native AOT</p>
<p>SDK, emits C# code into the assembly using it. That C# code takes the place of the reflection emit that<br />
would have happened at run-time, and is thus able to work successfully with Native AOT.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Interpreter</td>
<td>9,036.7 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Compiled</td>
<td>9,064.8 us</td>
<td>1.00</td>
</tr>
<tr>
<td>SourceGenerator</td>
<td>426.1 us</td>
<td>0.05</td>
</tr>
</tbody>
</table>
<p>So, yes, there are some constraints associated with Native AOT, but there are also solutions for<br />
working with those constraints. And further, those constraints can actually bring further benefits.<br />
<a href="https://github.com/dotnet/runtime/pull/64497">Consider dotnet/runtime#64497. Remember how we talked about “guarded devirtualization” in</a><br />
dynamic PGO, where via instrumentation the JIT can determine the most likely type to be used at a<br />
given call site and special-case it? With Native AOT, the entirety of the program is known at compile<br />
time, with no support for <code>Assembly.LoadFrom</code> or the like. That means at compile time, the compiler<br />
can do whole-program analysis to determine what types implement what interfaces. If a given<br />
interface only has a single type that implements it, then every call site through that interface can be<br />
unconditionally devirtualized, without any type-check guards.</p>
<p>This is a really exciting space, one we expect to see flourish in coming releases.</p>
<p>74 CHAPTER 4 | Native AOT</p>
<p><strong>CHAPTER</strong></p>
<h1>5</h1>
<h2>Mono</h2>
<p>Up until now I’ve referred to “the JIT,” “the GC,” and “the runtime,” but in reality there are actually<br />
multiple runtimes in .NET. I’ve been talking about “coreclr,” which is the runtime that’s recommended<br />
for use on Linux, macOS, and Windows. However, there’s also “mono,” which powers Blazor wasm<br />
applications, Android apps, and iOS apps. It’s also seen significant improvements in .NET 7.</p>
<p>Just as with coreclr (which can JIT compile, AOT compile partially with JIT fallback, and fully Native<br />
AOT compile), mono has multiple ways of actually executing code. One of those ways is an interpreter,<br />
which enables mono to execute .NET code in environments that don’t permit JIT’ing and without<br />
requiring ahead-of-time compilation or incurring any limitations it may bring. Interestingly, though,<br />
the interpreter is itself almost a full-fledged compiler, parsing the IL, generating its own intermediate<br />
representation (IR) for it, and doing one or more optimization passes over that IR; it’s just that at the<br />
end of the pipeline when a compiler would normally emit code, the interpreter instead saves off that<br />
data for it to interpret when the time comes to run. As such, the interpreter has a very similar<br />
conundrum to the one we discussed with coreclr’s JIT: the time it takes to optimize vs the desire to<br />
start up quickly. And in .NET 7, the interpreter employs a similar solution: tiered compilation.<br />
<a href="https://github.com/dotnet/runtime/pull/68823">dotnet/runtime#68823</a> adds the ability for the interpreter to initially compile with minimal<br />
optimization of that IR, and then once a certain threshold of call counts has been hit, then take the<br />
time to do as much optimization on the IR as possible for all future invocations of that method. This<br />
yields the same benefits as it does for coreclr: improved startup time while also having efficient<br />
sustained throughput. When this merged, we saw improvements in Blazor wasm app startup time<br />
improve by 10-20%. Here’s one example from an app being tracked in our benchmarking system:</p>
<p>75 CHAPTER 5 | Mono</p>
<p>The interpreter isn’t just used for entire apps, though. Just as how coreclr can use the JIT when an R2R<br />
image doesn’t contain code for a method, mono can use the interpreter when there’s no AOT code<br />
for a method. Once such case that occurred on mono was with generic delegate invocation, where the<br />
presence of a generic delegate being invoked would trigger falling back to the interpreter; for .NET 7,<br />
<a href="https://github.com/dotnet/runtime/pull/70653">that gap was addressed with dotnet/runtime#70653. A more impactful case, however, is</a><br />
<a href="https://github.com/dotnet/runtime/pull/64867">dotnet/runtime#64867. Previously, any methods with</a> <code>catch</code> or <code>filter</code> exception handling clauses<br />
couldn’t be AOT compiled and would fall back to being interpreted. With this PR, the method is now<br />
able to be AOT compiled, and it only falls back to using the interpreter when an exception actually<br />
occurs, switching over to the interpreter for the remainder of that method call’s execution. Since many<br />
methods contain such clauses, this can make a big difference in throughput and CPU consumption. In</p>
<p>interpreted.</p>
<p>Beyond such backend improvements, another class of improvement came from further unification<br />
between coreclr and mono. Years ago, coreclr and mono had their own entire library stack built on<br />
top of them. Over time, as .NET was open sourced, portions of mono’s stack got replaced by shared<br />
components, bit by bit. Fast forward to today, all of the core .NET libraries above</p>
<p>(these statements means that the vast majority of the performance improvements discussed in the<br />
rest of this post apply equally whether running on mono and coreclr). Even so, every release now we<br />
try to chip away at that few remaining percent, for reasons of maintainability, but also because the<br />
source used for coreclr’s <code>CoreLib</code> has generally had more attention paid to it from a performance<br />
<a href="https://github.com/dotnet/runtime/pull/71325">perspective. dotnet/runtime#71325, for example, moves mono’s array and span sorting generic</a><br />
sorting utility class over to the more efficient implementation used by coreclr.</p>
<p>One of the biggest categories of improvements, however, is in vectorization. This comes in two pieces.<br />
First, <code>Vector&lt;T&gt;</code> and <code>Vector128&lt;T&gt;</code> are now fully accelerated on both x64 and Arm64, thanks to PRs<br />
<a href="https://github.com/dotnet/runtime/pull/64961">like dotnet/runtime#64961, dotnet/runtime#65086,</a> <a href="https://github.com/dotnet/runtime/pull/65128">dotnet/runtime#65128,</a> <a href="https://github.com/dotnet/runtime/pull/66317">dotnet/runtime#66317,</a></p>
<p>76 CHAPTER 5 | Mono</p>
<p><a href="https://github.com/dotnet/runtime/pull/66391">dotnet/runtime#66391,</a> <a href="https://github.com/dotnet/runtime/pull/66409">dotnet/runtime#66409, dotnet/runtime#66512, dotnet/runtime#66586,</a><br />
<a href="https://github.com/dotnet/runtime/pull/66589">dotnet/runtime#66589,</a> <a href="https://github.com/dotnet/runtime/pull/66597">dotnet/runtime#66597, dotnet/runtime#66476, and dotnet/runtime#67125;</a><br />
that significant amount of work means all that code that gets vectorized using these abstractions will<br />
<a href="https://github.com/dotnet/runtime/pull/70086">light-up on mono and coreclr alike. Second, thanks primarily to dotnet/runtime#70086, mono now</a></p>
<p>anywhere else WASM might be executed.</p>
<p>77 CHAPTER 5 | Mono</p>
<p><strong>CHAPTER</strong></p>
<h1>6</h1>
<h2>Reflection</h2>
<p>Reflection is one of those areas you either love or hate (I find it a bit humorous to be writing this<br />
section immediately after writing the Native AOT section). It’s immensely powerful, providing the<br />
ability to query all of the metadata for code in your process and for arbitrary assemblies you might<br />
encounter, to invoke arbitrary functionality dynamically, and even to emit dynamically-generated IL at<br />
run-time. It’s also difficult to handle well in the face of tooling like a linker or a solution like Native<br />
AOT that needs to be able to determine at build time exactly what code will be executed, and it’s<br />
generally quite expensive at run-time; thus it’s both something we strive to avoid when possible but<br />
also invest in reducing the costs of, as it’s so popular in so many different kinds of applications<br />
because it is incredibly useful. As with most releases, it’s seen some nice improvements in .NET 7.</p>
<p>One of the most impacted areas is reflection invoke. Available via <code>MethodBase.Invoke</code>, this<br />
functionality let’s you take a <code>MethodBase</code> (e.g. <code>MethodInfo</code> ) object that represents some method for<br />
which the caller previously queried, and call it, with arbitrary arguments that the runtime needs to<br />
marshal through to the callee, and with an arbitrary return value that needs to be marshaled back. If<br />
you know the signature of the method ahead of time, the best way to optimize invocation speed is to<br />
create a delegate from the <code>MethodBase</code> via <code>CreateDelegate&lt;T&gt;</code> and then use that delegate for all<br />
future invocations. But in some circumstances, you don’t know the signature at compile time, and thus<br />
can’t easily rely on delegates with known matching signatures. To address this, some libraries have<br />
taken to using reflection emit to generate code at run-time specific to the target method. This is<br />
extremely complicated and it’s not something we want apps to have to do. Instead, in .NET 7 via</p>
<p>gives developers most of the performance benefits of a custom reflection emit-based implementation<br />
but without having the complexity or challenges of such an implementation in their own code base.</p>
<p>78 CHAPTER 6 | Reflection</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>MethodInfoInvoke</td>
<td>.NET 6.0</td>
<td>43.846 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>MethodInfoInvoke</td>
<td>.NET 7.0</td>
<td>8.078 ns</td>
<td>0.18</td>
</tr>
</tbody>
</table>
<p>Reflection also involves lots of manipulation of objects that represent types, methods, properties, and<br />
so on, and tweaks here and there can add up to a measurable difference when using these APIs. For<br />
example, I’ve talked in past performance posts about how, potentially counterintuitively, one of the<br />
ways we’ve achieved performance boosts is by porting native code from the runtime back into<br />
managed C#. There are a variety of ways in which doing so can help performance, but one is that<br />
there is some overhead associated with calling from managed code into the runtime, and eliminating<br />
<a href="https://github.com/dotnet/runtime/pull/71873">such hops avoids that overhead. This can be seen in full effect in dotnet/runtime#71873, which moves</a><br />
several of these “FCalls” related to <code>Type</code>, <code>RuntimeType</code> (the <code>Type</code> -derived class used by the runtime to<br />
represent its types), and <code>Enum</code> out of native into managed.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetUnderlyingType</td>
<td>.NET 6.0</td>
<td>27.413 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>GetUnderlyingType</td>
<td>.NET 7.0</td>
<td>5.115 ns</td>
<td>0.19</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/62866">Another example of this phenomenon comes in dotnet/runtime#62866, which moved much of the</a><br />
underlying support for <code>AssemblyName</code> out of native runtime code into managed code in CoreLib. That<br />
in turn has an impact on anything that uses it, such as when using <code>Activator.CreateInstance</code><br />
overloads that take assembly names that need to be parsed.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>CreateInstance</td>
<td>.NET 6.0</td>
<td>3.827 us</td>
<td>1.00</td>
</tr>
<tr>
<td>CreateInstance</td>
<td>.NET 7.0</td>
<td>2.276 us</td>
<td>0.60</td>
</tr>
</tbody>
</table>
<p>Other changes contributed to <code>Activator.CreateInstance</code> improvements as well.</p>
<p>resulting in less allocation and faster throughput.</p>
<p>79 CHAPTER 6 | Reflection</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>CreateInstance</td>
<td>.NET 6.0</td>
<td>167.8 ns</td>
<td>1.00</td>
<td>320 B</td>
<td>1.00</td>
</tr>
<tr>
<td>CreateInstance</td>
<td>.NET 7.0</td>
<td>143.4 ns</td>
<td>0.85</td>
<td>200 B</td>
<td>0.62</td>
</tr>
</tbody>
</table>
<p>And since we were talking about <code>AssemblyName</code>, other PRs improved it in other ways as well.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Names</td>
<td>.NET 6.0</td>
<td>3.423 us</td>
<td>1.00</td>
<td>9.14 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>Names</td>
<td>.NET 7.0</td>
<td>2.010 us</td>
<td>0.59</td>
<td>2.43 KB</td>
<td>0.27</td>
</tr>
</tbody>
</table>
<p>More reflection-related operations have also been turned into JIT intrinsics, as discussed earlier<br />
enabling the JIT to compute answers to various questions at JIT compile time rather than at run-time.<br />
This was done, for example, for <code>Type.IsByRefLike</code> <a href="https://github.com/dotnet/runtime/pull/67852">in dotnet/runtime#67852.</a></p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>IsByRefLike</td>
<td>.NET 6.0</td>
<td>2.1322 ns</td>
<td>1.000</td>
<td>31 B</td>
</tr>
<tr>
<td>IsByRefLike</td>
<td>.NET 7.0</td>
<td>0.0000 ns</td>
<td>0.000</td>
<td>6 B</td>
</tr>
</tbody>
</table>
<p>That the .NET 7 version is so close to zero is called out in a warning by benchmarkdotnet:</p>
<p>and it’s so indistinguishable from an empty method because that’s effectively what it is, as we can see<br />
from the disassembly:</p>
<p>80 CHAPTER 6 | Reflection</p>
<p>There are also improvements that are hard to see but that remove overheads as part of populating<br />
reflection’s caches, which end up reducing the work done typically on startup paths, helping apps to<br />
<a href="https://github.com/dotnet/runtime/pull/66825">launch faster. dotnet/runtime#66825, dotnet/runtime#66912, and dotnet/runtime#67149 all fall into</a><br />
this category by removing unnecessary or duplicative array allocations as part of gathering data on<br />
parameters, properties, and events.</p>
<p>81 CHAPTER 6 | Reflection</p>
<p><strong>CHAPTER</strong></p>
<h1>7</h1>
<h2>Interop</h2>
<p>.NET has long had great support for interop, enabling .NET applications to consume huge amounts of<br />
functionality written in other languages and/or exposed by the underlying operating system. The<br />
bedrock of this support has been “Platform Invoke,” or “P/Invoke,” represented in code by</p>
<p><code>[DllImport(...)]</code> applied to methods. The <code>DllImportAttribute</code> enables declaring a method that<br />
can be called like any other .NET method but that actually represents some external method that the<br />
runtime should call when this managed method is invoked. The DllImport specifies details about in<br />
what library the function lives, what its actual name is in the exports from that library, high-level<br />
details about marshalling of input arguments and return values, and so on, and the runtime ensures<br />
all the right things happen. This mechanism works on all operating systems. For example, Windows<br />
has a method <code>CreatePipe</code> for creating an anonymous pipe:</p>
<p>If I want to call this function from C#, I can declare a <code>[DllImport(...)]</code> counterpart to it which I can<br />
then invoke as I can any other managed method:</p>
<p>There are several interesting things to note here. Several of the arguments are directly blittable with</p>
<p>calling this managed method can’t just directly invoke the native function somehow, as there needs to</p>
<p>it’s no longer being used). Some logic needs to take the output handles generated by the native</p>
<p>82 CHAPTER 7 | Interop</p>
<p>and some code somewhere needs to take any error produced by this method and ensure it’s available<br />
for consumption via a subsequent <code>GetLastPInvokeError()</code> .</p>
<p>If there’s no marshalling logic required, such that the managed signature and native signature are for<br />
all intents and purposes the same, all arguments blittable, all return values blittable, no additional<br />
logic required around the invocation of the method, etc., then a <code>[DllImport(...)]</code> ends up being a<br />
simple passthrough with the runtime needing to do very little work to implement it. If, however, the</p>
<p><code>[DllImport(...)]</code> involves any of this marshalling work, the runtime needs to generate a “stub,”<br />
creating a dedicated method that’s called when the <code>[DllImport(...)]</code> is called, that handles fixing<br />
up all inputs, that delegates to the actual native function, and that fixes up all of the outputs. That<br />
stub is generated at execution time, with the runtime effectively doing reflection emit, generating IL<br />
dynamically that’s then JIT’d.</p>
<p>There are a variety of downsides to this. First, it takes time to generate all that marshalling code, time<br />
which can then negatively impact user experience for things like startup. Second, the nature of its<br />
implementation inhibits various optimizations, such as inlining. Third, there are platforms that don’t<br />
allow for JIT’ing due to the security exposure of allowing for dynamically generated code to then be<br />
executed (or in the case of Native AOT, where there isn’t a JIT at all). And fourth, it’s all hidden away<br />
making it more challenging for a developer to really understand what’s going on.</p>
<p>But what if that logic could all be generated at build time rather than at run time? The cost of<br />
generating the code would be incurred only at build time and not on every execution. The code would<br />
effectively just end up being user code that has all of the C# compiler’s and runtime’s optimizations<br />
available to it. The code, which then would just be part of the app, would be able to be ahead-of-time<br />
compiled using whatever AOT system is desirable, whether it be crossgen or Native AOT or some<br />
other system. And the code would be inspectable, viewable by users to understand exactly what work<br />
is being done on their behalf. Sounds pretty desirable. Sounds magical. Sounds like a job for a Roslyn<br />
source generator, mentioned earlier.</p>
<p>.NET 6 included several source generators in the .NET SDK, and .NET 7 doubles down on this effort<br />
including several more. One of these is the brand new LibraryImport generator, which provides exactly<br />
the magical, desirable solution we were just discussing.</p>
<p>Now if you’re following along at home in Visual Studio, try right-clicking on CreatePipe and selecting<br />
Go to Definition. That might seem a little strange. “Go to Definition? Isn’t this the definition?” This is a<br />
partial method, which is a way of declaring something that another partial definition fills in, and in this<br />
case, a source generator in .NET 7 SDK has noticed this method with the <code>[LibraryImport]</code> attribute<br />
and fully generated the entire marshalling stub code in C# that’s built directly into the assembly.<br />
While by default that code isn’t persisted, Visual Studio still enables you to browse it (and you can</p>
<p>83 CHAPTER 7 | Interop</p>
<p>opt-in to having it persisted on disk by adding a</p>
<p><code>&lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;</code> property into your .csproj).<br />
Here’s what it currently looks like for that method:</p>
<p>84 CHAPTER 7 | Interop</p>
<p>With this, you can read exactly the marshalling work that’s being performed. Two <code>SafeHandle</code><br />
instances are being allocated and then later after the native function completes, the</p>
<p><code>Marshal.InitHandle</code> method is used to store the resulting handles into these instances (the<br />
allocations happen before the native function call, as performing them after the native handles have</p>
<p>any stub to be generated by the runtime, as all that work has been handled in this C# code.</p>
<p><a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/">A sheer ton of work went in to enabling this. I touched on some of it last year in Performance</a><br />
<a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/">Improvements in .NET 6, but a significant amount of additional effort has gone into .NET 7 to polish</a><br />
<a href="https://github.com/dotnet/runtime">the design and make the implementation robust, roll it out across all of dotnet/runtime and beyond,</a><br />
and expose the functionality for all C# developers to use:</p>
<ul>
<li>
<p><a href="https://github.com/dotnet/runtimelab">The LibraryImport generator started its life as an experiment in dotnet/runtimelab. When it was</a><br />
<a href="https://github.com/dotnet/runtime/pull/59579">ready, dotnet/runtime#59579 brought 180 commits spanning years of effort into the</a><br />
<a href="https://github.com/dotnet/runtime">dotnet/runtime</a> main branch.</p>
</li>
<li>
<p>In .NET 6, there were almost 3000 <code>[DllImport]</code> uses throughout the core .NET libraries. As of my<br />
writing this, in .NET 7 there are… let me search… wait for it… 7 (I was hoping I could say 0, but<br />
there are just a few stragglers, mostly related to COM interop, still remaining). That’s not a<br />
transformation that happens over night. A multitude of PRs went library by library converting<br />
<a href="https://github.com/dotnet/runtime/pull/62295">from the old to the new, such as dotnet/runtime#62295</a> <a href="https://github.com/dotnet/runtime/pull/61640">and dotnet/runtime#61640 for</a><br />
<a href="https://github.com/dotnet/runtime/pull/61742">System.Private.CoreLib, dotnet/runtime#61742</a> <a href="https://github.com/dotnet/runtime/pull/62309">and dotnet/runtime#62309 for the cryptography</a><br />
<a href="https://github.com/dotnet/runtime/pull/61765">libraries, dotnet/runtime#61765 for networking, dotnet/runtime#61996</a> and<br />
<a href="https://github.com/dotnet/runtime/pull/61638">dotnet/runtime#61638 for most of the other I/O-related libraries, and a long-tail of additional</a><br />
<a href="https://github.com/dotnet/runtime/pull/61975">porting in dotnet/runtime#61975, dotnet/runtime#61389,</a> <a href="https://github.com/dotnet/runtime/pull/62353">dotnet/runtime#62353,</a><br />
<a href="https://github.com/dotnet/runtime/pull/61990">dotnet/runtime#61990, dotnet/runtime#61949,</a> <a href="https://github.com/dotnet/runtime/pull/61805">dotnet/runtime#61805, dotnet/runtime#61741,</a><br />
<a href="https://github.com/dotnet/runtime/pull/61184">dotnet/runtime#61184, dotnet/runtime#54290,</a> <a href="https://github.com/dotnet/runtime/pull/62365">dotnet/runtime#62365, dotnet/runtime#61609,</a><br />
<a href="https://github.com/dotnet/runtime/pull/61532">dotnet/runtime#61532, and dotnet/runtime#54236.</a></p>
</li>
<li>
<p>Such porting is significantly easier when there’s a tool to help automate it.<br />
<a href="https://github.com/dotnet/runtime/pull/72819">dotnet/runtime#72819 enables the analyzer and fixer for performing these transformations.</a><br />
:::{custom-style=Figure}</p>
</li>
</ul>
<p>85 CHAPTER 7 | Interop</p>
<p>:::</p>
<p>There were plenty of other PRs that went into making the LibraryImport generator a reality for .NET 7.</p>
<p>the runtime’s built-in marshalling; at that point, the only marshalling performed as part of interop is<br />
the marshaling done in the user’s code, e.g. that which is generated by <code>[LibraryImport]</code> . Other PRs</p>
<p>marshaling is performed (the generator is pattern-based and allows for customization of marshalling<br />
by providing types that implement the right shape, which these types do in support of the most</p>
<p><a href="https://github.com/dotnet/runtime">signatures, just as arrays can be (examples in dotnet/runtime</a> <a href="https://github.com/dotnet/runtime/pull/73256">are available in dotnet/runtime#73256).</a></p>
<p>One more category of interop-related changes that I think are worth talking about are to do with</p>
<p><code>SafeHandle</code> cleanup. As a reminder, <code>SafeHandle</code> exists to mitigate various issues around managing<br />
native handles and file descriptors. A native handle or file descriptor is just a memory address or<br />
number that refers to some owned resource and which must be cleaned up / closed when done with<br />
it. A <code>SafeHandle</code> at its core is just a managed object that wraps such a value and provides a <code>Dispose</code></p>
<p>its finalizer eventually run. <code>SafeHandle</code> then also provides some synchronization around that closure,<br />
trying to minimize the possibility that the resource is closed while it’s still in use. It provides</p>
<p><code>SafeHandle</code> into a P/Invoke, the generated code for that P/Invoke handles calling <code>DangerousAddRef</code></p>
<p>86 CHAPTER 7 | Interop</p>
<p>and <code>DangerousRelease</code> (and due to the wonders of LibraryImport I’ve already extolled, you can easily<br />
see that being done, such as in the previous generated code example). Our code tries hard to clean<br />
up after <code>SafeHandle</code> s deterministically, but it’s quite easy to accidentally leave some for finalization.</p>
<p><a href="https://github.com/dotnet/runtime/pull/71991">dotnet/runtime#71854</a> added some debug-only tracking code to <code>SafeHandle</code> to make it easier for<br />
<a href="https://github.com/dotnet/runtime">developers working in dotnet/runtime (or more specifically, developers using a checked build of the</a><br />
runtime) to find such issues. When the <code>SafeHandle</code> is constructed, it captures the current stack trace,</p>
<p>ensure they’re being disposed of. As is probably evident from that PR touching over 150 files and<br />
almost 1000 lines of code, there were quite a few places that benefited from clean up. Now to be fair,<br />
many of these are on exceptional code paths. For example, consider a hypothetical P/Invoke like:</p>
<p>and code that uses it like:</p>
<p>Seems straightforward enough. Except this code will actually leave a <code>SafeHandle</code> for finalization on<br />
the failure path. It doesn’t matter that <code>SafeHandle</code> has an invalid handle in it, it’s still a finalizable<br />
object. To deal with that, this code would have been more robustly written as:</p>
<p>That way, this <code>SafeHandle</code> won’t create finalization pressure even in the case of failure. Note, as well,</p>
<p>close the resource, which typically involves making another P/Invoke. And if that P/Invoke has</p>
<p><code>SetLastError=true</code> on it, it can overwrite the very error code for which we’re about to throw. Hence,<br />
we access and store the last error immediately after the interop call once we know it failed, then clean<br />
up, and only then throw. All that said, there were a myriad of places in that PR where <code>SafeHandle</code> s<br />
were being left for finalization even on the success path. And that PR wasn’t alone.<br />
<a href="https://github.com/dotnet/runtime/pull/71991">dotnet/runtime#71991,</a> <a href="https://github.com/dotnet/runtime/pull/71854">dotnet/runtime#71854, dotnet/runtime#72116, dotnet/runtime#72189,</a></p>
<p>the earlier mentioned PR).</p>
<p>87 CHAPTER 7 | Interop</p>
<p><a href="https://github.com/dotnet/runtime/pull/70000">Other PRs also accrued to improved interop performance. dotnet/runtime#70000</a> from</p>
<p><a href="https://github.com/huoyaoyuan">@huoyaoyuan</a> rewrote several delegate-related “FCalls” from being<br />
implemented in native code to instead being managed, resulting in less overhead when invoking<br />
these operations that are commonly involved in scenarios involving</p>
<p><code>Marshal.GetDelegateForFunctionPointer</code> <a href="https://github.com/dotnet/runtime/pull/68694">. dotnet/runtime#68694</a> also moved some trivial<br />
functionality from native to managed, as part of relaxing argument validation on the use of pinning<br />
handles. This in turn measurably reduced the overhead involved with using <code>GCHandle.Alloc</code> for such<br />
pinning handles:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>PinUnpin</td>
<td>.NET 6.0</td>
<td>37.11 ns</td>
<td>1.00</td>
<td>353 B</td>
</tr>
<tr>
<td>PinUnpin</td>
<td>.NET 7.0</td>
<td>32.17 ns</td>
<td>0.87</td>
<td>232 B</td>
</tr>
</tbody>
</table>
<p>88 CHAPTER 7 | Interop</p>
<p><strong>CHAPTER</strong></p>
<h1>8</h1>
<h2>Threading</h2>
<p>Threading is one of those cross-cutting concerns that impacts every application, such that changes in<br />
the threading space can have a wide-spread impact. This release sees two very substantial changes to<br />
the <code>ThreadPool</code> <a href="https://github.com/dotnet/runtime/pull/64834">itself; dotnet/runtime#64834 switches the “IO pool” over to using an entirely</a><br />
managed implementation (whereas previously the IO pool was still in native code even though the<br />
<a href="https://github.com/dotnet/runtime/pull/71864">worker pool had been moved entirely to managed in previous releases), and dotnet/runtime#71864</a><br />
similarly switches the timer implementation from one based in native to one entirely in managed<br />
code. Those two changes can impact performance, and the former was demonstrated to on larger<br />
hardware, but for the most part that wasn’t their primary goal. Instead, other PRs have been focused<br />
on improving throughput.</p>
<p><a href="https://github.com/dotnet/runtime/pull/69386">One in particular is dotnet/runtime#69386. The</a> <code>ThreadPool</code> has a “global queue” that any thread can<br />
queue work into, and then each thread in the pool has its own “local queue” (which any thread can<br />
dequeue from but only the owning thread can enqueue into). When a worker needs another piece of<br />
work to process, it first checks its own local queue, then it checks the global queue, and then only if it<br />
couldn’t find work in either of those two places, it goes and checks all of the other threads’ local<br />
queues to see if it can help lighten their load. As machines scale up to have more and more cores, and<br />
more and more threads, there’s more and more contention on these shared queues, and in particular<br />
on the global queue. This PR addresses this for such larger machines by introducing additional global<br />
queues once the machine reaches a certain threshold (32 processors today). This helps to partition<br />
accesses across multiple queues, thereby decreasing contention.</p>
<p><a href="https://github.com/dotnet/runtime/pull/57885">Another is dotnet/runtime#57885. In order to coordinate threads, when work items were enqueued</a><br />
and dequeued, the pool was issuing requests to its threads to let them know that there was work<br />
available to do. This, however, often resulted in oversubscription, where more threads than necessary<br />
would race to try to get work items, especially when the system wasn’t at full load. That in turn would<br />
manifest as a throughput regression. This change overhauls how threads are requested, such that only<br />
one additional thread is requested at a time, and after that thread has dequeued its first work item, it<br />
can issue a request for an additional thread if there’s work remaining, and then that one can issue an<br />
additional request, and so on. Here’s one of our performance tests in our performance test suite (I’ve<br />
simplified it down to remove a bunch of configuration options from the test, but it’s still accurately<br />
one of those configurations). At first glance you might think, “hey, this is a performance test about</p>
<p><code>ArrayPool</code>, why is it showing up in a threading discussion?” And, you’d be right, this is a performance</p>
<p>doing “real work” that competes for CPU cycles with thread pool threads all racing to get their next<br />
task, it shows a measurable improvement when moving to .NET 7.</p>
<p>89 CHAPTER 8 | Threading</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>MultipleSerial</td>
<td>.NET 6.0</td>
<td>14.340 us</td>
<td>1.00</td>
</tr>
<tr>
<td>MultipleSerial</td>
<td>.NET 7.0</td>
<td>9.262 us</td>
<td>0.65</td>
</tr>
</tbody>
</table>
<p>returning whatever data it finds, or in the case of a setter, creating a new <code>ExecutionContext</code> with an<br />
updated dictionary and publishing that back. This dictionary thus needs to be very efficient for reads<br />
and writes, as developers expect <code>AsyncLocal&lt;T&gt;</code> access to be as fast as possible, often treating it as if<br />
it were any other local. So, to optimize these lookups, the representation of that dictionary changes<br />
based on how many <code>AsyncLocal&lt;T&gt;</code> s are represented in this context. For up to three items, dedicated<br />
implementations with fields for each of the three keys and values were used. Above that up to around</p>
<p>instances is really common, especially in ASP.NET where ASP.NET infrastructure itself uses a couple.</p>
<p>90 CHAPTER 8 | Threading</p>
<p>So, this PR took the complexity hit to add a dedicated type for four key/value pairs, in order to<br />
optimize from one to four of them rather than one to three. While this improves throughput a bit, its<br />
main intent was to improve allocation, which is does over .NET 6 by ~20%.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Update</td>
<td>.NET 6.0</td>
<td>61.96 ns</td>
<td>1.00</td>
<td>1,272 B</td>
<td>176 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Update</td>
<td>.NET 7.0</td>
<td>61.92 ns</td>
<td>1.00</td>
<td>1,832 B</td>
<td>144 B</td>
<td>0.82</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/70165">Another valuable fix comes for locking in dotnet/runtime#70165. This particular improvement is a bit</a><br />
harder to demonstrate with benchmarkdotnet, so just try running this program, first on .NET 6 and<br />
then on .NET 7:</p>
<p>91 CHAPTER 8 | Threading</p>
<p>This is simply spinning up 100 tasks, each of which enters and exits a read-write lock, waits for them<br />
all, and then does the process over again, for 10 seconds. It also times how long it takes to enter and<br />
exit the lock, and writes a warning if it had to wait for at least 15ms. When I run this on .NET 6, I get<br />
~100 occurrences of it taking &gt;= 10 ms to enter/exit the lock. On .NET 7, I get 0 occurrences. Why the<br />
difference? The implementation of <code>ReaderWriterLockSlim</code> has its own spin loop implementation, and<br />
that spin loop tries to mix together various things to do as it spins, ranging from calling</p>
<p><code>Thread.SpinWait</code> to <code>Thread.Sleep(0)</code> to <code>Thread.Sleep(1)</code> . The issue lies in the <code>Thread.Sleep(1)</code> .<br />
That’s saying “put this thread to sleep for 1 millisecond”; however, the operating system has the<br />
ultimate say on such timings, and on Windows, by default that sleep is going to be closer to 15<br />
milliseconds (on Linux it’s a bit lower but still quite high). Thus, every time there was enough<br />
contention on the lock to force it to call <code>Thread.Sleep(1)</code>, we’d incur a delay of at least 15<br />
milliseconds, if not more. The aforementioned PR fixed this by eliminating use of <code>Thread.Sleep(1)</code> .</p>
<p><a href="https://github.com/dotnet/runtime/pull/68639">One final threading-related change to call out: dotnet/runtime#68639. This one is Windows specific.</a><br />
Windows has the concept of processor groups, each of which can have up to 64 cores in it, and by<br />
default when a process runs, it’s assigned a specific processor group and can only use the cores in<br />
that group. With .NET 7, the runtime flips its default so that by default it will try to use all processor<br />
groups if possible.</p>
<p>92 CHAPTER 8 | Threading</p>
<p><strong>CHAPTER</strong></p>
<h1>9</h1>
<h2>Primitive Types and Numerics</h2>
<p>We’ve looked at code generation and GC, at threading and vectorization, at interop… let’s turn our<br />
attention to some of the fundamental types in the system. Primitives like <code>int</code> and <code>bool</code> and <code>double</code>,<br />
core types like <code>Guid</code> and <code>DateTime</code>, they form the backbone on which everything is built, and every<br />
release it’s exciting to see the improvements that find their way into these types.</p>
<p><a href="https://lemire.me/blog/2021/02/22/parsing-floating-point-numbers-really-fast-in-c">values. This is particularly neat because it’s based on some relatively recent research from</a></p>
<p><a href="https://github.com/lemire">@lemire</a> and <a href="https://github.com/CarlVerret">@CarlVerret</a>, who used C#<br />
with .NET 5 to implement a very fast implementation for parsing floating-point numbers, and that<br />
implementation how now found its way into .NET 7!</p>
<p>93 CHAPTER 9 | Primitive Types and Numerics</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ParseAll</td>
<td>.NET 6.0</td>
<td>26.84 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>ParseAll</td>
<td>.NET 7.0</td>
<td>12.63 ms</td>
<td>0.47</td>
</tr>
</tbody>
</table>
<p>of <code>TryFormat</code> writing out “True” by doing:</p>
<p>which requires four writes, it can instead implement the same operation in a single write by doing:</p>
<p>That <code>0x65007500720054</code> is the numerical value of the four characters in memory as a single <code>ulong</code> . You<br />
can see the impact of these changes with a microbenchmark:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ParseTrue</td>
<td>.NET 6.0</td>
<td>7.347 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>ParseTrue</td>
<td>.NET 7.0</td>
<td>2.327 ns</td>
<td>0.32</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>FormatTrue</td>
<td>.NET 6.0</td>
<td>3.030 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>FormatTrue</td>
<td>.NET 7.0</td>
<td>1.997 ns</td>
<td>0.66</td>
</tr>
</tbody>
</table>
<p>values defined on the enum. This cache includes the string name and the value for every defined<br />
enumeration in the <code>Enum</code> . It’s also sorted by value in an array, so when one of these operations is<br />
performed, the code uses <code>Array.BinarySearch</code> to find the index of the relevant entry. The issue with<br />
that is one of overheads. When it comes to algorithmic complexity, a binary search is faster than a<br />
linear search; after all, a binary search is <code>O(log N)</code> whereas a linear search is <code>O(N)</code> . However, there’s<br />
also less overhead for every step of the algorithm in a linear search, and so for smaller values of <code>N</code>, it<br />
<a href="https://github.com/dotnet/runtime/pull/57973">can be much faster to simply do the simple thing. That’s what dotnet/runtime#57973 does for enums.</a><br />
For enums with less than or equal to 32 defined values, the implementation now just does a linear<br />
search via the internal <code>SpanHelpers.IndexOf</code> (the worker routine behind <code>IndexOf</code> on spans, strings,</p>
<p>94 CHAPTER 9 | Primitive Types and Numerics</p>
<p>and arrays), and for enums with more than that, it does a <code>SpanHelpers.BinarySearch</code> (which is the<br />
implementation for <code>Array.BinarySearch</code> ).</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>AllDefined</td>
<td>.NET 6.0</td>
<td>159.28 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>AllDefined</td>
<td>.NET 7.0</td>
<td>94.86 ns</td>
<td>0.60</td>
</tr>
</tbody>
</table>
<p>implementation choosing from a multitude of different internal implementations, for example a</p>
<p>play nicely with enums. The results highlight just how much unnecessary overhead there was<br />
previously.</p>
<p>95 CHAPTER 9 | Primitive Types and Numerics</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>FindEnum</td>
<td>.NET 6.0</td>
<td>421.608 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>FindEnum</td>
<td>.NET 7.0</td>
<td>5.466 ns</td>
<td>0.01</td>
</tr>
</tbody>
</table>
<p>four 32-bit values and performed 4 <code>int</code> comparisons. With this change, if the current hardware has<br />
128-bit SIMD support, the implementation loads the data from the two guids as two vectors and<br />
simply does a single comparison.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>GuidEquals</td>
<td>.NET 6.0</td>
<td>2.119 ns</td>
<td>1.00</td>
<td>90 B</td>
</tr>
<tr>
<td>GuidEquals</td>
<td>.NET 7.0</td>
<td>1.354 ns</td>
<td>0.64</td>
<td>78 B</td>
</tr>
</tbody>
</table>
<p>of the bits store a ticks offset from 1/1/0001 12:00am and where each tick is 100 nanoseconds, and</p>
<p>difference in such tiny operations, but you can see it simply from the number of instructions involved,<br />
where on .NET 6 this produces:</p>
<p>and on .NET 7 this produces:</p>
<p>96 CHAPTER 9 | Primitive Types and Numerics</p>
<p>so instead of a <code>mov</code>, <code>and</code>, <code>and</code>, and <code>cmp</code>, we get just an <code>xor</code> and a <code>shl</code> .</p>
<p>Other operations on <code>DateTime</code> <a href="https://github.com/dotnet/runtime/pull/72712">also become more efficient, thanks to dotnet/runtime#72712 from</a></p>
<p>[<a href="https://github.com/SergeiPavlov">@SergeiPavlov</a> and dotnet/runtime#73277](https://github.com/dotnet/runtime/pull/73277) from</p>
<p><a href="https://github.com/SergeiPavlov">@SergeiPavlov</a>. In another case of .NET benefiting from recent<br />
advancements in research, these PRs implemented the algorithm from Neri and Schneider’s</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Day</td>
<td>.NET 6.0</td>
<td>5.2080 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Day</td>
<td>.NET 7.0</td>
<td>2.0549 ns</td>
<td>0.39</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Month</td>
<td>.NET 6.0</td>
<td>4.1186 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Month</td>
<td>.NET 7.0</td>
<td>2.0945 ns</td>
<td>0.51</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Year</td>
<td>.NET 6.0</td>
<td>3.1422 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Year</td>
<td>.NET 7.0</td>
<td>0.8200 ns</td>
<td>0.26</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TryFormat</td>
<td>.NET 6.0</td>
<td>27.6259 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>TryFormat</td>
<td>.NET 7.0</td>
<td>25.9848 ns</td>
<td>0.94</td>
</tr>
</tbody>
</table>
<p>So, we’ve touched on improvements to a few types, but the pièce de résistance around primitive types<br />
in this release is “generic math,” which impacts almost every primitive type in .NET. There are<br />
significant improvements here, some which have been in the making for literally over a decade.</p>
<p><a href="https://devblogs.microsoft.com/dotnet/dotnet-7-generic-math">There’s an excellent blog post from June dedicated just to generic math, so I won’t go into much</a><br />
depth here. At a high level, however, there are now over 30 new interfaces that utilize the new C# 11<br />
static abstract interface methods functionality, exposing wide-ranging operations from exponentiation<br />
functions to trigonometric functions to standard numerical operators, all available via generics, such<br />
that you can write one implementation that operates over these interfaces generically and have your</p>
<p>97 CHAPTER 9 | Primitive Types and Numerics</p>
<p>code applied to any types that implement the interfaces… which all of the numerical types in .NET 7<br />
do (including not just the primitives but also, for example, <code>BigInteger</code> and <code>Complex</code> ). A preview<br />
version of this feature, including necessary runtime support, language syntax, C# compiler support,<br />
generic interfaces, and interface implementations all shipped in .NET 6 and C# 10, but it wasn’t<br />
supported for production use, and you had to download an experimental reference assembly in order<br />
<a href="https://github.com/dotnet/runtime/pull/65731">to get access. With dotnet/runtime#65731, all of this support moved into .NET 7 as supported</a><br />
<a href="https://github.com/dotnet/runtime/pull/66748">functionality. dotnet/runtime#66748, dotnet/runtime#67453,</a> <a href="https://github.com/dotnet/runtime/pull/69391">dotnet/runtime#69391,</a><br />
<a href="https://github.com/dotnet/runtime/pull/69582">dotnet/runtime#69582,</a> <a href="https://github.com/dotnet/runtime/pull/69756">dotnet/runtime#69756, and dotnet/runtime#71800 all updated the design</a><br />
and implementation based on feedback from usage in .NET 6 and .NET 7 previews as well as a proper<br />
API review with our API review team (a process every new API in .NET goes through before it’s</p>
<p><a href="https://github.com/dotnet/runtime/pull/67939">dotnet/runtime#67939,</a> <a href="https://github.com/dotnet/runtime/pull/73274">dotnet/runtime#73274, dotnet/runtime#71033, dotnet/runtime#71010,</a><br />
<a href="https://github.com/dotnet/runtime/pull/68251">dotnet/runtime#68251,</a> <a href="https://github.com/dotnet/runtime/pull/68217">dotnet/runtime#68217, and dotnet/runtime#68094 all added large swaths of</a><br />
new public surface area for various operations, all with highly-efficient managed implementations, in<br />
<a href="https://github.com/amd/aocl-libm-ose">many cases based on the open source AMD Math Library.</a></p>
<p>While this support is all primarily intended for external consumers, the core libraries do consume<br />
some of it internally. You can see how these APIs clean up consuming code even while maintaining</p>
<p>diffs tells the story on how much code was able to be deleted:</p>
<p>Another simple example comes from the new <code>System.Formats.Tar</code> library in .NET 7, which as the<br />
<a href="https://en.wikipedia.org/wiki/Tar_(computing)#File_format">name suggests is used for reading and writing archives in any of multiple tar file formats. The tar file</a><br />
formats include integer values in octal representation, so the <code>TarReader</code> class needs to parse octal<br />
values. Some of these values are 32-bit integers, and some are 64-bit integers. Rather than have two</p>
<p><code>INumber&lt;T&gt;</code> . The implementation is then entirely in terms of <code>T</code> and can be used for either of these<br />
types (plus any other types meeting the constraints, should that ever be needed). What’s particularly</p>
<p>interface contains these methods:</p>
<p>98 CHAPTER 9 | Primitive Types and Numerics</p>
<p>and the compiler will pick the appropriate one based on the context.</p>
<p>In addition to all the existing types that get these interfaces, there are also new types.<br />
<a href="https://github.com/dotnet/runtime/pull/69204">dotnet/runtime#69204</a> adds the new <code>Int128</code> and <code>UInt128</code> types. As these types implement all of the<br />
relevant generic math interfaces, they come complete with a huge number of methods, over 100 each,<br />
all of which are implemented efficiently in managed code. In the future, the aim is that some set of<br />
these will be optimized further by the JIT and to take advantage of hardware acceleration.</p>
<p>Several PRs moved native implementations of these kinds of math operations to managed code.<br />
<a href="https://github.com/dotnet/runtime/pull/63881">dotnet/runtime#63881</a> from <a href="https://github.com/am11">@am11</a> did so for <code>Math.Abs</code> and <code>Math.AbsF</code><br />
<a href="https://github.com/dotnet/runtime/pull/56236">(absolute value), and dotnet/runtime#56236 from</a></p>
<p><a href="https://github.com/alexcovington">@alexcovington</a> did so for <code>Math.ILogB</code> and <code>MathF.ILogB</code> (base 2<br />
integer logarithm). The latter’s implementation is based on the MUSL libc implementation of the same<br />
algorithm, and in addition to improving performance (in part by avoiding the transition between<br />
managed and native code, in part by the actual algorithm employed), it also enabled deleting two<br />
distinct implementations from native code, one from the coreclr side and one from the mono side,<br />
which is always a nice win from a maintainability perspective.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>arg</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ILogB</td>
<td>.NET 6.0</td>
<td>12345.6789</td>
<td>4.056 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>ILogB</td>
<td>.NET 7.0</td>
<td>12345.6789</td>
<td>1.059 ns</td>
<td>0.26</td>
</tr>
</tbody>
</table>
<p>Other math operations were also improved in various ways. <code>Math{F}.Truncate</code> was improved in<br />
<a href="https://github.com/dotnet/runtime/pull/65014">dotnet/runtime#65014</a> from <a href="https://github.com/MichalPetryka">@MichalPetryka</a> by making it into a<br />
JIT intrinsic, such that on Arm64 the JIT could directly emit a <code>frintz</code> instruction.</p>
<p><a href="https://github.com/dotnet/runtime/pull/71567">dotnet/runtime#71567</a> in order to enable better code generation in some generic math scenarios.</p>
<p>while a larger algorithmic complexity than we’d normally like, it has a low constant overhead and so is<br />
still reasonable for reasonably-sized values. In contrast, an alternative algorithm is available that runs<br />
in <code>O(N * (log N)^2)</code> time, but with a much higher constant factor involved. That makes is so that it’s<br />
really only worth switching for really big numbers. Which is what this PR does. It implements the<br />
alternative algorithm and switches over to it when the input is at least 20,000 digits (so, yes, big). But<br />
for such large numbers, it makes a significant difference.</p>
<p>99 CHAPTER 9 | Primitive Types and Numerics</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parse</td>
<td>.NET 6.0</td>
<td>3.474 s</td>
<td>1.00</td>
</tr>
<tr>
<td>Parse</td>
<td>.NET 7.0</td>
<td>1.672 s</td>
<td>0.48</td>
</tr>
</tbody>
</table>
<p>spans rather than arrays. That in turn enabled a fair amount of use of stack allocation and slicing to<br />
avoid allocation overheads, while also improving reliability and safety by moving some code away<br />
from unsafe pointers to safe spans. The primary performance impact is visible in allocation numbers,<br />
and in particular for operations related to division.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ModPow</td>
<td>.NET 6.0</td>
<td>1.527 ms</td>
<td>1.00</td>
<td>706 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ModPow</td>
<td>.NET 7.0</td>
<td>1.589 ms</td>
<td>1.04</td>
<td>50 B</td>
<td>0.07</td>
</tr>
</tbody>
</table>
<p>100 CHAPTER 9 | Primitive Types and Numerics</p>
<p><strong>CHAPTER</strong></p>
<h1>10</h1>
<h2>Arrays, Strings, and Spans</h2>
<p>While there are many forms of computation that can consume resources in applications, some of the<br />
most common include processing of data stored in arrays, strings, and now spans. Thus you see a<br />
focus in every .NET release on removing as much overhead as possible from such scenarios, while also<br />
finding ways to further optimize the concrete operations developers are commonly performing.</p>
<p>Let’s start with some new APIs that can help make writing more efficient code easier. When examining<br />
string parsing/processing code, it’s very common to see characters examined for their inclusion in<br />
various sets. For example, you might see a loop looking for characters that are ASCII digits:</p>
<p>or that are ASCII letters:</p>
<p>or other such groups. Interestingly, there’s wide-spread variation in how such checks are coded, often<br />
depending on how much effort a developer put in to optimizing them, or in some cases likely not<br />
even recognizing that some amount of performance was being left on the table. For example, that<br />
same ASCII letter check could instead be written as:</p>
<p>which while more “intense” is also much more concise and more efficient. It’s taking advantage of a<br />
few tricks. First, rather than having two comparisons to determine whether the character is greater<br />
than or equal to the lower bound and less than or equal to the upper bound, it’s doing a single</p>
<p>101 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>than <code>'a'</code>, then <code>'c' - 'a'</code> will be negative, and casting it to <code>uint</code> will then cause it to wrap around to a<br />
massive number, also larger than 25, again causing the comparison to fail. Thus, we’re able to pay a<br />
single additional subtraction to avoid an entire additional comparison and branch, which is <em>almost</em></p>
<p>lowercase, such that for the low cost of a bit twiddle, we can achieve both the lowercase and<br />
uppercase range checks. Of course, those tricks aren’t something we want every developer to have to<br />
know and write on each use. Instead, .NET 7 exposes a bunch of new helpers on <code>System.Char</code> to<br />
encapsulate these common checks, done in an efficient manner. <code>char</code> already had methods like</p>
<p><code>IsDigit</code> and <code>IsLetter</code>, which provided the more comprehensive Unicode meaning of those monikers<br />
(e.g. there are ~320 Unicode characters categorized as “digits”). Now in .NET 7, there are also these<br />
helpers:</p>
<ul>
<li>
<p>IsAsciiDigit</p>
</li>
<li>
<p>IsAsciiHexDigit</p>
</li>
<li>
<p>IsAsciiHexDigitLower</p>
</li>
<li>
<p>IsAsciiHexDigitUpper</p>
</li>
<li>
<p>IsAsciiLetter</p>
</li>
<li>
<p>IsAsciiLetterLower</p>
</li>
<li>
<p>IsAsciiLetterUpper</p>
</li>
<li>
<p>IsAsciiLetterOrDigit</p>
</li>
</ul>
<p><a href="https://github.com/dotnet/runtime/pull/69318">These methods were added by dotnet/runtime#69318, which also employed them in dozens of</a><br />
<a href="https://github.com/dotnet/runtime">locations where such checks were being performed across dotnet/runtime</a> (many of them using lessefficient approaches).</p>
<p>Another new API focused on encapsulating a common pattern is the new</p>
<p>each input span. This is useful when you want to know the first place that two inputs differ.<br />
<a href="https://github.com/dotnet/runtime/pull/68210">dotnet/runtime#68210</a> from <a href="https://github.com/gfoidl">@gfoidl</a> then utilized the new <code>Vector128</code><br />
functionality to provide a basic vectorization of the implementation. As it’s comparing two sequences<br />
and looking for the first place they differ, this implementation uses a neat trick, which is to have a<br />
single method implemented to compare the sequences as bytes. If the <code>T</code> being compared is bitwiseequatable and no custom equality comparer is supplied, then it reinterpret-casts the refs from the<br />
spans as <code>byte</code> refs, and uses the single shared implementation.</p>
<p>Yet another new set of APIs are the <code>IndexOfAnyExcept</code> and <code>LastIndexOfAnyExcept</code> methods,<br />
<a href="https://github.com/dotnet/runtime/pull/67941">introduced by dotnet/runtime#67941 and used in a variety of additional call sites by</a><br />
<a href="https://github.com/dotnet/runtime/pull/71146">dotnet/runtime#71146</a> <a href="https://github.com/dotnet/runtime/pull/71278">and dotnet/runtime#71278. While somewhat of a mouthful, these methods</a><br />
are quite handy. They do what their name suggests: whereas <code>IndexOf(T value)</code> searches for the first</p>
<p>102 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>You can now write that as:</p>
<pre><code>bool allZero = array.AsSpan().IndexOfAnyExcept(0) &lt; 0;

</code></pre>
<p><a href="https://github.com/dotnet/runtime/pull/73488">dotnet/runtime#73488</a> vectorizes this overload, as well.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>OpenCoded</td>
<td>370.47 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>IndexOfAnyExcept</td>
<td>23.84 ns</td>
<td>0.06</td>
</tr>
</tbody>
</table>
<p>Of course, while new “index of” variations are helpful, we already have a bunch of such methods, and<br />
it’s important that they are as efficient as possible. These core <code>IndexOf{Any}</code> methods are used in<br />
huge numbers of places, many of which are performance-sensitive, and so every release they get<br />
<a href="https://github.com/dotnet/runtime/pull/67811">additional tender-loving care. While PRs like dotnet/runtime#67811</a> got gains by paying very close<br />
attention to the assembly code being generated (in this case, tweaking some of the checks used on<br />
Arm64 in <code>IndexOf</code> and <code>IndexOfAny</code> to achieve better utilization), the biggest improvements here come<br />
in places where either vectorization was added and none was previously employed, or where the</p>
<p>do the equivalent of repeatedly searching for the ‘h’, and when an ‘h’ was found, then performing a</p>
<p><code>SequenceEqual</code> to match the remainder. As you can imagine, however, it’s very easy to run into cases<br />
where the first character being searched for is very common, such that you frequently have to break<br />
out of the vectorized loop in order to do the full string comparison. Instead, the PR implements an<br />
<a href="http://0x80.pl/articles/simd-strfind.html#algorithm-1-generic-simd">algorithm based on SIMD-friendly algorithms for substring searching. Rather than just searching for</a><br />
the first character, it can instead vectorize a search for both the first and last character at appropriate<br />
distances from each other. In our “hello” example, in any given input, it’s much more likely to find an</p>
<p>103 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>‘h’ than it is to find an ‘h’ followed four characters later by an ‘o’, and thus this implementation is able<br />
to stay within the vectorized loop a lot longer, garnering many fewer false positives that force it down<br />
the <code>SequenceEqual</code> route. The implementation also handles cases where the two characters selected<br />
are equal, in which case it’ll quickly look for another character that’s not equal in order to maximize<br />
the efficiency of the search. We can see the impact of all of this with a couple of examples:</p>
<p>This is pulling down the text to “The Adventures of Sherlock Holmes” from Project Gutenberg and<br />
then benchmarking using <code>IndexOf</code> to count the occurrences of “Sherlock” and “elementary” in the<br />
text. On my machine, I get results like this:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>needle</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>Sherlock</td>
<td>43.68 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>Sherlock</td>
<td>48.33 us</td>
<td>1.11</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>elementary</td>
<td>1,063.67 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>elementary</td>
<td>56.04 us</td>
<td>0.05</td>
</tr>
</tbody>
</table>
<p>For “Sherlock”, the performance is actually a bit worse in .NET 7 than in .NET 6; not much, but a<br />
measurable 10%. That’s because there are very few capital <code>'S'</code> characters in the source text, 841 to be<br />
exact, out of 593,836 characters in the document. At only 0.1% density of the starting character, the<br />
new algorithm doesn’t bring much benefit, as the existing algorithm that searched for the first<br />
character alone captures pretty much all of the possible vectorization gains to be had, and we do pay</p>
<p>10% of the source. In that case, .NET 7 is 20x faster than .NET 6, taking 53us on .NET 7 to count all the</p>
<p><code>'e'</code> ’s vs 1084us on .NET 6. In this case, the new scheme yields immense gains, by vectorizing a search<br />
for both the <code>'e'</code> and a <code>'y'</code> at the specific distance away, a combination that is much, much less<br />
frequent. This is one of those situations where overall there are on average huge observed gains even<br />
though we can see small regressions for some specific inputs.</p>
<p>104 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p><code>StringComparison.OrdinalIgnoreCase)</code> . Previously, this operation was implemented with a fairly<br />
typical substring search, walking the input string and at every location doing an inner loop to<br />
compare the target string, except performing a <code>ToUpper</code> on every character in order to do it in a caseinsensitive manner. Now with this PR, which is based on approaches previously used by <code>Regex</code>, if the<br />
target string begins with an ASCII character, the implementation can use <code>IndexOf</code> (if the character isn’t<br />
an ASCII letter) or <code>IndexOfAny</code> (if the character is an ASCII letter) to quickly jump ahead to the first<br />
possible location of a match. Let’s take the exact same benchmark as we just looked at, but tweaked<br />
to use <code>OrdinalIgnoreCase</code> :</p>
<p>Here, both words are about 4x faster on .NET 7 than they were on .NET 6:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>needle</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>Sherlock</td>
<td>2,113.1 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>Sherlock</td>
<td>467.3 us</td>
<td>0.22</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>elementary</td>
<td>2,325.6 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>elementary</td>
<td>638.8 us</td>
<td>0.27</td>
</tr>
</tbody>
</table>
<p>as we’re now doing a vectorized <code>IndexOfAny('S', 's')</code> or <code>IndexOfAny('E', 'e')</code> rather than</p>
<p>leftover elements at the end of vectorized operation: process one last vector’s worth of data, even if it<br />
means duplicating some work already done. This particularly helps for smaller inputs where the<br />
processing time might otherwise be dominated by the serial handling of those leftovers.</p>
<p>105 CHAPTER 10 | Arrays, Strings, and Spans</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Contains</td>
<td>.NET 6.0</td>
<td>15.115 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Contains</td>
<td>.NET 7.0</td>
<td>2.557 ns</td>
<td>0.17</td>
</tr>
</tbody>
</table>
<p>types, but this PR extends it as well to four and eight-byte sized primitives. As with most of the other<br />
vectorized implementations, it checks whether the <code>T</code> is bitwise-equatable, which is important for the<br />
vectorization as it’s only looking at the bits in memory and not paying attention to any <code>Equals</code><br />
implementation that might be defined on the type. In practice today, that means this is limited to just<br />
a handful of types of which the runtime has intimate knowledge ( <code>Boolean</code>, <code>Byte</code>, <code>SByte</code>, <code>UInt16</code>, <code>Int16</code>,</p>
<p><code>Char</code>, <code>UInt32</code>, <code>Int32</code>, <code>UInt64</code>, <code>Int64</code>, <code>UIntPtr</code>, <code>IntPtr</code>, <code>Rune</code>, and enums), but in theory it could be<br />
extended in the future.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>IndexOf</td>
<td>.NET 6.0</td>
<td>252.17 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>IndexOf</td>
<td>.NET 7.0</td>
<td>78.82 ns</td>
<td>0.31</td>
</tr>
</tbody>
</table>
<p>added to provide extension methods for spans and friends, including such</p>
<p><a href="https://en.wikipedia.org/wiki/Bloom_filter">map,” essentially a Bloom filter. It creates a 256-bit table, and quickly sets bits in that table based on</a><br />
the values being searched for (essentially hashing them, but with a trivial hash function). Then it<br />
iterates through the input, and rather than checking every input character against every one of the<br />
target values, it instead first looks up the input character in the table. If the corresponding bit isn’t set,<br />
it knows the input character doesn’t match any of the target values. If the corresponding bit is set,<br />
then it proceeds to compare the input character against each of the target values, with a high</p>
<p>106 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p><a href="https://github.com/dotnet/runtime/pull/63817">dotnet/runtime#63817, all of these are now unified, such that both</a> <code>string</code> and <code>MemoryExtensions</code><br />
get the best of what the other had.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>LastIndexOfAny</td>
<td>.NET 6.0</td>
<td>443.29 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>LastIndexOfAny</td>
<td>.NET 7.0</td>
<td>31.79 ns</td>
<td>0.07</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CountLines</td>
<td>.NET 6.0</td>
<td>1,689.66 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>CountLines</td>
<td>.NET 7.0</td>
<td>1,461.64 ns</td>
<td>0.86</td>
</tr>
</tbody>
</table>
<p>That same PR also cleans up uses of the <code>IndexOf</code> family, and in particular around uses that are<br />
checking for containment rather than the actual index of a result. The <code>IndexOf</code> family of methods<br />
return a non-negative value when an element is found, and otherwise return -1. That means when</p>
<p>generated for comparisons against 0 is ever so slightly more efficient than comparisons generated<br />
against -1, and this isn’t something the JIT can itself substitute without the <code>IndexOf</code> methods being<br />
intrinsics such that the JIT can understand the semantics of the return value. Thus, for consistency and<br />
a small perf gain, all relevant call sites were switched to compare against 0 instead of against -1.</p>
<p>107 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>Speaking of call sites, one of the great things about having highly optimized <code>IndexOf</code> methods is<br />
using them in all the places that can benefit, removing the maintenance impact of open-coded<br />
<a href="https://github.com/dotnet/runtime/pull/63913">replacements while also reaping the perf wins. dotnet/runtime#63913</a> used <code>IndexOf</code> inside of</p>
<p><code>StringBuilder.Replace</code> to speed up the search for the next character to be replaced:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Replace</td>
<td>.NET 6.0</td>
<td>1,563.69 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Replace</td>
<td>.NET 7.0</td>
<td>70.84 ns</td>
<td>0.04</td>
</tr>
</tbody>
</table>
<p>substantial throughput gains even with the allocation and copy that is inherent to the method’s<br />
design:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReadAllLines</td>
<td>.NET 6.0</td>
<td>947.8 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>ReadAllLines</td>
<td>.NET 7.0</td>
<td>385.7 ns</td>
<td>0.41</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/70176">And dotnet/runtime#70176 cleaned up a plethora of additional uses.</a></p>
<p>Finally on the <code>IndexOf</code> front, as noted, a lot of time and energy over the years has gone into<br />
optimizing these methods. In previous releases, some of that energy has been in the form of using<br />
hardware intrinsics directly, e.g. having an SSE2 code path and an AVX2 code path and an AdvSimd<br />
code path. Now that we have <code>Vector128&lt;T&gt;</code> and <code>Vector256&lt;T&gt;</code>, many such uses can be simplified<br />
(e.g. avoiding the duplication between an SSE2 implementation and an AdvSimd implementation)<br />
while still maintaining as good or even better performance and while automatically supporting<br />
<a href="https://github.com/dotnet/runtime/pull/73481">vectorization on other platforms with their own intrinsics, like WebAssembly. dotnet/runtime#73481,</a><br />
<a href="https://github.com/dotnet/runtime/pull/73556">dotnet/runtime#73556,</a> <a href="https://github.com/dotnet/runtime/pull/73368">dotnet/runtime#73368, dotnet/runtime#73364, dotnet/runtime#73064, and</a><br />
<a href="https://github.com/dotnet/runtime/pull/73469">dotnet/runtime#73469</a> all contributed here, in some cases incurring meaningful throughput gains:</p>
<p>108 CHAPTER 10 | Arrays, Strings, and Spans</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>IndexOfAny</td>
<td>.NET 6.0</td>
<td>52.29 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>IndexOfAny</td>
<td>.NET 7.0</td>
<td>40.17 ns</td>
<td>0.77</td>
</tr>
</tbody>
</table>
<p>recognized by the JIT, which can now automatically unroll the comparison and compare more than<br />
one char at a time, e.g. doing a single read of four chars as a <code>long</code> and a single comparison of that</p>
<p><code>long</code> against the expected combination of those four chars. The result is beautiful. Making it even</p>
<p>employs the same trick as part of this unrolling, so if you do that same</p>
<p>and will OR in the appropriate mask on both the comparison constant and on the read data from the<br />
input in order to perform the comparison in a case-insensitive manner.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>IsHttps_Ordinal</td>
<td>.NET 6.0</td>
<td>4.5634 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>IsHttps_Ordinal</td>
<td>.NET 7.0</td>
<td>0.4873 ns</td>
<td>0.11</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IsHttps_OrdinalIgnoreCase</td>
<td>.NET 6.0</td>
<td>6.5654 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>IsHttps_OrdinalIgnoreCase</td>
<td>.NET 7.0</td>
<td>0.5577 ns</td>
<td>0.08</td>
</tr>
</tbody>
</table>
<p>Interestingly, since .NET 5 the code generated by <code>RegexOptions.Compiled</code> would perform similar<br />
unrolling when comparing sequences of multiple characters, and when the source generator was<br />
added in .NET 7, it also learned how to do this. However, the source generator has problems with such<br />
an optimization, due to endianness. The constants being compared against are subject to byte<br />
ordering issues, such that the source generator would need to emit code that could handle running<br />
on either little-endian or big-endian machines. The JIT has no such problem, as it’s generating the<br />
code on the same machine on which the code will execute (and in scenarios where it’s being used to<br />
generate code ahead of time, the entirety of that code is already tied to a particular architecture). By<br />
moving this optimization into the JIT, the corresponding code could be deleted from</p>
<p><code>RegexOptions.Compiled</code> and the regex source generator, which then also benefits from producing</p>
<p>109 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>regex being compiled.)</p>
<p><code>StartsWith</code> and <code>EndsWith</code> <a href="https://github.com/dotnet/runtime/pull/63734">have improved in other ways. dotnet/runtime#63734</a> (improved further by<br />
<a href="https://github.com/dotnet/runtime/pull/64530">dotnet/runtime#64530) added another really interesting JIT-based optimization, but to understand it,</a><br />
we need to understand <code>string</code> ’s internal layout. <code>string</code> is essentially represented in memory as an</p>
<p><code>_firstChar</code> indeed lines up with the first character of the string, or the null terminator if the string is<br />
empty. Internally in System.Private.CoreLib, and in particular in methods on <code>string</code> itself, code will</p>
<p>string’s length generally needn’t be consulted. Now, consider a method like <code>public bool</code></p>
<p><code>StartsWith(char value)</code> on <code>string</code> . In .NET 6, the implementation was:</p>
<pre><code>return Length != 0 &amp;&amp; _firstChar == value;

</code></pre>
<p>which given what I just described makes sense: if the <code>Length</code> is 0, then the string doesn’t begin with</p>
<p>fine… unless the target character is itself <code>'\0'</code>, in which case we could get false positives on the result.<br />
Now to this PR. The PR introduces an internal JIT intrinsinc <code>RuntimeHelpers.IsKnownConstant</code>, which<br />
the JIT will substitute with <code>true</code> if the containing method is inlined and the argument passed to</p>
<p><code>IsKnownConstant</code> is then seen to be a constant. In such cases, the implementation can rely on other<br />
JIT optimizations kicking in and optimizing various code in the method, effectively enabling a<br />
developer to write two different implementations, one when the argument is known to be a constant<br />
and one when not. With that in hand, the PR is able to optimize <code>StartsWith</code> as follows:</p>
<p>If the <code>value</code> parameter isn’t a constant, then <code>IsKnownConstant</code> will be substituted with <code>false</code>, the<br />
entire starting <code>if</code> block will be eliminated, and the method will be left exactly was it was before. But, if<br />
this method gets inlined and the <code>value</code> was actually a constant, then the <code>value != '\0'</code> condition will<br />
also be evaluatable at JIT-compile-time. If the <code>value</code> is in fact <code>'\0'</code>, well, again that whole <code>if</code> block will<br />
be eliminated and we’re no worse off. But in the common case where the <code>value</code> isn’t null, the entire<br />
method will end up being compiled as if it were:</p>
<pre><code>return _firstChar == ConstantValue;

</code></pre>
<p>110 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>and we’ve saved ourselves a read of the string’s length, a comparison, and a branch.<br />
<a href="https://github.com/dotnet/runtime/pull/69038">dotnet/runtime#69038</a> then employs a similar technique for <code>EndsWith</code> .</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>StartsWith</td>
<td>.NET 6.0</td>
<td>8.130 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>StartsWith</td>
<td>.NET 7.0</td>
<td>1.653 ns</td>
<td>0.20</td>
</tr>
</tbody>
</table>
<p>explicitly specify the enum value as a constant, which then allows the JIT to specialize the code<br />
generation for the method to the specific mode being used; that in turn, for example, enables a</p>
<p><code>Math.Round(..., MidpointRounding.AwayFromZero)</code> call on Arm64 to be lowered to a single <code>frinta</code><br />
instruction.)</p>
<p>helper method was used to implement this method, taking advantage of one that is sufficient for the<br />
needs of this method and that has lower overheads.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>EndsWith</td>
<td>.NET 6.0</td>
<td>10.861 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>EndsWith</td>
<td>.NET 7.0</td>
<td>5.385 ns</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>but here for <code>SequenceEqual</code> and <code>SequenceCompareTo</code>, respectively.</p>
<p>111 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>Another method that’s seem some attention in .NET 7 is <code>MemoryExtensions.Reverse</code> (and</p>
<p><code>Array.Reverse</code> as it shares the same implementation), which performs an in-place reversal of the<br />
[target span. dotnet/runtime#64412 from <a href="https://github.com/alexcovington">@alexcovington</a>](https://github.com/dotnet/runtime/pull/64412)<br />
provides a vectorized implementation via direct use of AVX2 and SSSE3 hardware intrinsics, with<br />
<a href="https://github.com/dotnet/runtime/pull/72780">dotnet/runtime#72780</a> from <a href="https://github.com/SwapnilGaikwad">@SwapnilGaikwad</a> following up to<br />
add an AdvSimd intrinsics implementation for Arm64. (There was an unintended regression<br />
<a href="https://github.com/dotnet/runtime/pull/70650">introduced by the original vectorization change, but that was fixed by dotnet/runtime#70650.)</a></p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reverse</td>
<td>.NET 6.0</td>
<td>21.352 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Reverse</td>
<td>.NET 7.0</td>
<td>9.536 ns</td>
<td>0.45</td>
</tr>
</tbody>
</table>
<p><code>String.Split</code> <a href="https://github.com/dotnet/runtime/pull/64899">also saw vectorization improvements in dotnet/runtime#64899</a> from</p>
<p><a href="https://github.com/yesmey">@yesmey</a>. As with some of the previously discussed PRs, it switched the<br />
existing usage of SSE2 and SSSE3 hardware intrinsics over to the new <code>Vector128&lt;T&gt;</code> helpers, which<br />
improved upon the existing implementation while also implicitly adding vectorization support for<br />
Arm64.</p>
<p>Converting various formats of strings is something many applications and services do, whether that’s<br />
converting from UTF8 bytes to and from <code>string</code> or formatting and parsing hex values. Such<br />
<a href="https://en.wikipedia.org/wiki/Base64">operations have also improved in a variety of ways in .NET 7. Base64-encoding, for example, is a way</a><br />
of representing arbitrary binary data (think <code>byte[]</code> ) across mediums that only support text, encoding<br />
bytes into one of 64 different ASCII characters. Multiple APIs in .NET implement this encoding. For</p>
<p><a href="https://github.com/dotnet/runtime/pull/70654">but they were further improved in .NET 7 via dotnet/runtime#70654 from</a></p>
<p><a href="https://github.com/a74nh">@a74nh</a>, which converted the SSSE3-based implementation to use</p>
<p><code>Vector128&lt;T&gt;</code> (which in turn implicitly enabled vectorization on Arm64). However, for converting</p>
<p>Then, then they “widen” those bytes into chars (remember, Base64-encoded data is a set of ASCII<br />
chars, so going from these bytes to chars entails adding just a <code>0</code> byte onto each element). That<br />
widening can itself easily be done in a vectorized manner. The other interesting thing about this<br />
layering is it doesn’t actually require separate intermediate storage for the encoded bytes. The<br />
implementation can perfectly compute the number of resulting characters for encoding X bytes into Y</p>
<p>112 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>Base64 characters (there’s a formula), and the implementation can either allocate that final space<br />
(e.g. in the case of ToBase64CharArray) or ensure the provided space is sufficient (e.g. in the case of<br />
TryToBase64Chars). And since we know the initial encoding will require exactly half as many bytes, we<br />
can encode into that same space (with the destination span reinterpreted as a <code>byte</code> span rather than</p>
<p><code>char</code> span), and then widen “in place”: walk from the end of the bytes and the end of the char space,<br />
copying the bytes into the destination.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>TryToBase64Chars</td>
<td>.NET 6.0</td>
<td>623.25 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>TryToBase64Chars</td>
<td>.NET 7.0</td>
<td>81.82 ns</td>
<td>0.13</td>
</tr>
</tbody>
</table>
<p>Just as widening can be used to go from bytes to chars, narrowing can be used to go from chars to<br />
bytes, in particular if the chars are actually ASCII and thus have a 0 upper byte. Such narrowing can be</p>
<p><a href="https://github.com/dotnet/runtime/pull/70080">fast-path utilized SSE2 and thus didn’t apply to Arm64; thanks to dotnet/runtime#70080 from</a></p>
<p><a href="https://github.com/SwapnilGaikwad">@SwapnilGaikwad</a>, that path was changed over to be based on<br />
the cross-platform <code>Vector128&lt;T&gt;</code>, enabling the same level of optimization across supported<br />
<a href="https://github.com/dotnet/runtime/pull/71637">platforms. Similarly, dotnet/runtime#71637 from</a></p>
<p><a href="https://github.com/SwapnilGaikwad">@SwapnilGaikwad</a> adds Arm64 vectorization to the</p>
<p>automatically providing an Arm64 implementation.)</p>
<p>calls.</p>
<p>113 CHAPTER 10 | Arrays, Strings, and Spans</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetMaxByteCount</td>
<td>.NET 6.0</td>
<td>1.7442 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>GetMaxByteCount</td>
<td>.NET 7.0</td>
<td>0.4746 ns</td>
<td>0.27</td>
</tr>
</tbody>
</table>
<p>Arguably the biggest improvement around UTF8 in .NET 7 is the new C# 11 support for UTF8 literals.<br />
<a href="https://github.com/dotnet/roslyn/pull/58991">Initially implemented in the C# compiler in dotnet/roslyn#58991, with follow-on work in</a><br />
<a href="https://github.com/dotnet/roslyn/pull/59390">dotnet/roslyn#59390,</a> <a href="https://github.com/dotnet/roslyn/pull/61532">dotnet/roslyn#61532, and dotnet/roslyn#62044, UTF8 literals enables the</a><br />
compiler to perform the UTF8 encoding into bytes at compile-time. Rather than writing a normal</p>
<pre><code>public static ReadOnlySpan&lt;byte&gt; Text =&gt; &quot;hello&quot;u8;

</code></pre>
<p>the C# compiler will compile that equivalent to if you wrote:</p>
<p>In other words, the compiler is doing the equivalent of <code>Encoding.UTF8.GetBytes</code> at compile-time and<br />
hardcoding the resulting bytes, saving the cost of performing that encoding at run-time. Of course, at<br />
first glance, that array allocation might look terribly inefficient. However, looks can be deceiving, and<br />
are in this case. For several releases now, when the C# compiler sees a <code>byte[]</code> (or <code>sbyte[]</code> or <code>bool[]</code> )<br />
being initialized with a constant length and constant values and immediately cast to or used to<br />
construct a <code>ReadOnlySpan&lt;byte&gt;</code>, it optimizes away the <code>byte[]</code> allocation. Instead, it blits the data for<br />
that span into the assembly’s data section, and then constructs a span that points directly to that data<br />
in the loaded assembly. This is the actual generated IL for the above property:</p>
<p>This means we not only save on the encoding costs at run-time, and we not only avoid whatever<br />
managed allocations might be required to store the resulting data, we also benefit from the JIT being<br />
able to see information about the encoded data, like it’s length, enabling knock-on optimizations. You<br />
can see this clearly by examining the assembly generated for a method like:</p>
<pre><code>public static int M() =&gt; Text.Length;

</code></pre>
<p>for which the JIT produces:</p>
<p>114 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>The JIT inlines the property access, sees that the span is being constructed with a length of <code>5</code>, and so<br />
rather than emitting any array allocations or span constructions or anything even resembling that, it<br />
simply outputs <code>mov eax, 5</code> to return the known length of the span.</p>
<p><a href="https://github.com/dotnet/runtime/pull/70568">Thanks primarily to dotnet/runtime#70568, dotnet/runtime#69995,</a> <a href="https://github.com/dotnet/runtime/pull/70894">dotnet/runtime#70894,</a><br />
<a href="https://github.com/dotnet/runtime/pull/71417">dotnet/runtime#71417</a> [from <a href="https://github.com/am11">@am11</a>, dotnet/runtime#71292,](https://github.com/dotnet/runtime/pull/71292)<br />
<a href="https://github.com/dotnet/runtime/pull/70513">dotnet/runtime#70513, and dotnet/runtime#71992,</a> <code>u8</code> is now used more than 2100 times throughout<br />
<a href="https://github.com/dotnet/runtime">dotnet/runtime. Hardly a fair comparison, but the following benchmark demonstrates how little work</a><br />
is actually being performed for <code>u8</code> at execution time:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithEncoding</td>
<td>17.3347 ns</td>
<td>1.000</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Withu8</td>
<td>0.0060 ns</td>
<td>0.000</td>
<td>-</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>Like I said, not fair, but it proves the point :)</p>
<p><code>Encoding</code> is of course just one mechanism for creating <code>string</code> instances. Others have also improved in<br />
.NET 7. Take the super common <code>long.ToString</code>, for example. Previous releases improved</p>
<p><code>int.ToString</code>, but there were enough differences between the 32-bit and 64-bit algorithms that <code>long</code><br />
<a href="https://github.com/dotnet/runtime/pull/68795">didn’t see all of the same gains. Now thanks to dotnet/runtime#68795, the 64-bit formatting code</a><br />
paths are made much more similar to the 32-bit, resulting in faster performance.</p>
<p>the next interpolation hole that needs to be filled in, and if the non-hole-character to hole ratio is high<br />
(e.g. long format string with few holes), it can be way faster than before.</p>
<p>115 CHAPTER 10 | Arrays, Strings, and Spans</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>AppendFormat</td>
<td>.NET 6.0</td>
<td>338.23 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>AppendFormat</td>
<td>.NET 7.0</td>
<td>49.15 ns</td>
<td>0.15</td>
</tr>
</tbody>
</table>
<p>things. The first was to remove pinning as part of formatting operations. As an example,</p>
<p><code>int count)</code> method was essentially implemented as:</p>
<p>That <code>fixed</code> statement translates into a “pinning pointer.” Normally the GC is free to move managed<br />
objects around on the heap, which it might do in order to compact the heap (to, for example, avoid<br />
small, unusuable fragments of memory between objects). But if the GC can move objects around, a<br />
normal native pointer into that memory would be terribly unsafe and unreliable, as without notice the<br />
data being pointed to could move and your pointer could now be pointing to garbage or to some<br />
other object that was shifted to this location. There are two ways for dealing with this. The first is a<br />
“managed pointer,” otherwise known as a “reference” or “ref,” as that’s exactly what you get when you<br />
have the “ref” keyword in C#; it’s a pointer that the runtime will update with the correct value when it<br />
moves the object being pointed into. The second is to prevent the pointed-to object from being<br />
moved, “pinning” it in place. And that’s what the “fixed” keyword does, pinning the referenced object<br />
for the duration of the <code>fixed</code> block, during which time it’s safe to use the supplied pointer. Thankfully,<br />
pinning is cheap when no GC occurs; when a GC does occur, however, pinned objects aren’t able to be<br />
moved around, and thus pinning can have a global impact on the performance of the application (and<br />
on GCs themselves). There are also various optimizations inhibited by pinning. With all of the advents<br />
in C# around being able to use <code>ref</code> in many more places (e.g. ref locals, ref returns, and now in C# 11,<br />
ref fields), and with all of the new APIs in .NET for manipulating refs (e.g. <code>Unsafe.Add</code>,</p>
<p><code>Unsafe.AreSame</code> ), it’s now possible to rewrite code that was using pinning pointers to instead use<br />
managed pointers, thereby avoiding the problems that come from pinning. Which is what this PR did.</p>
<p>now akin to</p>
<pre><code>Append( ref Unsafe.Add( ref value.GetRawStringData(), startIndex), count);

</code></pre>
<p>bounds checking and the like can continue to do so, but now also does so without pinning all of the<br />
inputs.</p>
<p>116 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>put in place to optimize for this input and specifically for the case where there’s already enough room</p>
<p>helper, such that it not only helps out <code>string</code> but any other type that also calls into the same helper.<br />
The effects of this are visible in a simple microbenchmark:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>AppendSpan</td>
<td>.NET 6.0</td>
<td>35.98 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>AppendSpan</td>
<td>.NET 7.0</td>
<td>17.59 ns</td>
<td>0.49</td>
</tr>
</tbody>
</table>
<p>One of the great things about improving things low in the stack is they have a multiplicative effect;<br />
they not only help improve the performance of user code that directly relies on the improved<br />
functionality, they can also help improve the performance of other code in the core libraries, which<br />
then further helps dependent apps and services. You can see this, for example, with</p>
<p><code>DateTimeOffset.ToString</code>, which depends on <code>StringBuilder</code> :</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>DateTimeOffsetToString</td>
<td>.NET 6.0</td>
<td>340.4 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>DateTimeOffsetToString</td>
<td>.NET 7.0</td>
<td>289.4 ns</td>
<td>0.85</td>
</tr>
</tbody>
</table>
<p>if there’s not enough room remaining do they then take the old path as a fallback. <code>Insert</code> wasn’t<br />
improved in this way at the time, because it can’t just format into the space at the end of the builder;<br />
the insert location could be anywhere in the builder. This PR addresses that by formatting into some<br />
temporary stack space, and then delegating to the existing internal ref-based helper from the</p>
<p>117 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>previously discussed PR to insert the resulting characters at the right location (it also falls back to</p>
<p><code>ToString</code> when there’s not enough stack space for the <code>ISpanFormattable.TryFormat</code>, but that only<br />
happens in incredibly corner cases, like a floating-point value that formats to hundreds of digits).</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>.NET 6.0</td>
<td>30.02 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Insert</td>
<td>.NET 7.0</td>
<td>25.53 ns</td>
<td>0.85</td>
<td>-</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>possible implementation for that operation (and if we ever found a better way, that method would be<br />
improved according). So we can just use that:</p>
<p>Note that I’ve expressed that concatenation via an interpolated string, but the C# compiler will “lower”<br />
this interpolated string to a call to <code>string.Concat</code>, so the IL for this is indistinguishable from if I’d<br />
instead written:</p>
<p>118 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>As an aside, the expanded <code>string.Concat</code> version highlights that this method could have been<br />
written to result in a bit less IL if it were instead written as:</p>
<p>but this doesn’t meaningfully affect performance and here clarity and maintainability was more<br />
important than shaving off a few bytes.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithStringBuilder</td>
<td>68.34 ns</td>
<td>1.00</td>
<td>272 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WithConcat</td>
<td>20.78 ns</td>
<td>0.31</td>
<td>64 B</td>
<td>0.24</td>
</tr>
</tbody>
</table>
<p>There are also places where <code>StringBuilder</code> was still applicable, but it was being used on hot-enough<br />
paths that previous releases of .NET saw the <code>StringBuilder</code> instance being cached. Several of the<br />
core libraries, including System.Private.CoreLib, have an internal <code>StringBuilderCache</code> type which<br />
caches a <code>StringBuilder</code> instance in a <code>[ThreadStatic]</code>, meaning every thread could end up having<br />
such an instance. There are several issues with this, including that the buffers employed by</p>
<p>cached; attempts to cache ones longer than that result in them being thrown away. It’d be better<br />
instead to use cached arrays that aren’t length-limited and that everyone has access to for sharing.<br />
Many of the core .NET libraries have an internal <code>ValueStringBuilder</code> type for this purpose, a <code>ref</code></p>
<p>119 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>In the same vein of not doing unnecessary work, there’s a fairly common pattern that shows up with<br />
methods like <code>string.Substring</code> and <code>span.Slice</code> :</p>
<pre><code>span = span.Slice(offset, str.Length - offset);

</code></pre>
<p>The relevant thing to recognize here is these methods have overloads that take just the starting offset.<br />
Since the length being specified is the remainder after the specified offset, the call could instead be<br />
simplified to:</p>
<pre><code>span = span.Slice(offset);

</code></pre>
<p>which is not only more readable and maintainable, it has some small efficiency benefits, e.g. on 64-bit</p>
<p><a href="https://github.com/dotnet/runtime/pull/68937">code maintenance and for performance to simplify these calls, which dotnet/runtime#68937 does for</a><br />
<a href="https://github.com/dotnet/runtime/pull/73882">all found occurrences of that pattern. This is then made more impactful by dotnet/runtime#73882,</a><br />
which streamlines <code>string.Substring</code> to remove unnecessary overheads, e.g. it condenses four<br />
argument validation checks down to a single fast-path comparison (in 64-bit processes).</p>
<p>discussed how they’re essentially managed pointers, i.e. pointers that the runtime can update at any<br />
time due to the object it references getting moved on the heap. These references can point to the<br />
beginning of an object, or they can point somewhere inside the object, in which case they’re referred<br />
to as “interior pointers.” <code>ref</code> has existed in C# since 1.0, but at that time it was primarily about passing<br />
by reference to method calls, e.g.</p>
<p>Later versions of C# added the ability to have local <code>ref</code> s, e.g.</p>
<p>and even to have <code>ref</code> returns, e.g.</p>
<p>120 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>These facilities are more advanced, but they’re used liberally throughout higher-performance code<br />
bases, and many of the optimizations in .NET in recent years are possible in large part due to these</p>
<p><code>ref</code> -related capabilities.</p>
<p><code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> themselves are heavily-based on <code>ref</code> s. For example, the indexer on<br />
many older collection types is implemented as a get/set property, e.g.</p>
<p>But not span. <code>Span&lt;T&gt;</code> ’s indexer looks more like this:</p>
<p>Note there’s only a getter and no setter; that’s because it returns a <code>ref T</code> to the actual storage<br />
location. It’s a writable ref, so you can assign to it, e.g. you can write:</p>
<pre><code>span[i] = value;

</code></pre>
<p>but rather than that being equivalent to calling some setter:</p>
<pre><code>span.set_Item(i, value);

</code></pre>
<p>it’s actually equivalent to using the getter to retrieve the <code>ref</code> and then writing a value through that</p>
<p><code>ref</code>, e.g.</p>
<p>That’s all well and good, but what’s that <code>_reference</code> in the getter definition? Well, <code>Span&lt;T&gt;</code> is really<br />
just a tuple of two fields: a reference (to the start of the memory being referred to) and a length (how<br />
many elements from that reference are included in the span). In the past, the runtime had to hack this</p>
<p>defined as follows:</p>
<p>121 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>The rollout of <code>ref</code> <a href="https://github.com/dotnet/runtime">fields throughout dotnet/runtime</a> <a href="https://github.com/dotnet/runtime/pull/71498">was done in dotnet/runtime#71498, following the</a><br />
<a href="https://github.com/dotnet/roslyn/pull/62155">C# language gaining this support primarily in dotnet/roslyn#62155, which itself was the culmination</a><br />
of many PRs first into a feature branch. <code>ref</code> fields alone doesn’t itself automatically improve<br />
performance, but it does simplify code significantly, and it allows for both new custom code that uses</p>
<p><code>ref</code> fields as well as new APIs that take advantage of them, both of which can help with performance<br />
(and specifically performance without sacrificing potential safety). One such example of a new API is<br />
new constructors on <code>ReadOnlySpan&lt;T&gt;</code> and <code>Span&lt;T&gt;</code> :</p>
<p><a href="https://github.com/dotnet/runtime/pull/67447">added in dotnet/runtime#67447 (and then made public and used more broadly in</a></p>
<p>equivalent to calling those methods with a length of 1. The answer is: safety.</p>
<p>Imagine if you could willy-nilly call this constructor. You’d be able to write code like this:</p>
<p>At this point the caller of this method is handed a span that refers to garbage; that’s bad in code<br />
that’s intended to be safe. You can already accomplish the same thing by using pointers:</p>
<p>but at that point you’ve taken on the risk of using unsafe code and pointers and any resulting<br />
problems are on you. With C# 11, if you now try to write the above code using the <code>ref</code> -based<br />
constructor, you’ll be greeted with an error like this:</p>
<p>122 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>of the method, which is bad. Hence how this relates to <code>ref</code> fields: because <code>ref</code> fields are now a thing,</p>
<p>As is often the case, addressing one issue kicks the can down the road a bit and exposes another. The</p>
<p><code>ref structs</code> ), but what if we don’t want that? What if we want to be able to say “this <code>ref</code> is not<br />
storable and should not escape the calling scope”? From a caller’s perspective, we want the compiler<br />
to allow passing in such <code>ref</code> s without it complaining about potential extension of lifetime, and from a<br />
callee’s perspective, we want the compiler to prevent the method from doing what it’s not supposed<br />
to do. Enter <code>scoped</code> . The new C# keyword does exactly what we just wished for: put it on a <code>ref</code> or <code>ref</code></p>
<p><code>struct</code> parameter, and the compiler both will guarantee (short of using unsafe code) that the method<br />
can’t stash away the argument and will then enable the caller to write code that relies on that<br />
guarantee. For example, consider this program:</p>
<p>We have a <code>ref struct SpanWriter</code> that takes a <code>Span&lt;char&gt;</code> to its constructor and allows for writing<br />
to it by copying in additional content and then updating the stored length. The <code>Write</code> method accepts</p>
<p>Straightforward. Except, this doesn’t compile:</p>
<p>123 CHAPTER 10 | Arrays, Strings, and Spans</p>
<pre><code>public void Write(scoped ReadOnlySpan&lt;char&gt; value)

</code></pre>
<p>If <code>Write</code> were then to try to store <code>value</code>, the compiler would balk:</p>
<p>But as it’s not trying to do so, everything now compiles successfully. You can see examples of how this<br />
<a href="https://github.com/dotnet/runtime/pull/71589">is utilized in the aforementioned dotnet/runtime#71589.</a></p>
<p>There’s also the other direction: there are some things that are implicitly <code>scoped</code>, like the <code>this</code><br />
reference on a struct. Consider this code:</p>
<p>This produces a compiler error:</p>
<pre><code>error CS8170: Struct members cannot return 'this' or other instance members by reference

</code></pre>
<p>Effectively, that’s because <code>this</code> is implicitly <code>scoped</code> (even though that keyword wasn’t previously<br />
available). What if we want to enable such an item to be returned? Enter <code>[UnscopedRef]</code> . This is rare<br />
enough in need that it doesn’t get its own C# language keyword, but the C# compiler does recognize<br />
the new <code>[UnscopedRef]</code> attribute. It can be put onto relevant parameters but also onto methods and<br />
properties, in which case it applies to the <code>this</code> reference for that member. As such, we can modify our<br />
previous code example to be:</p>
<p>and now the code will compile successfully. Of course, this also places demands on callers of this<br />
method. For a call site, the compiler sees the <code>[UnscopedRef]</code> on the member being invoked, and then<br />
knows that the returned <code>ref</code> might reference something from that struct, and thus assigns to the<br />
returned <code>ref</code> the same lifetime as that struct. So, if that struct were a local living on the stack, the <code>ref</code><br />
would also be limited to that same method.</p>
<p>124 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>implementation for producing high-quality hash codes. In its current incarnation, it incorporates a<br />
random process-wide seed and is an implementation of the xxHash32 non-cryptographic hash<br />
algorithm. In a previous release, <code>HashCode</code> saw the addition of an <code>AddBytes</code> methods, which accepts a</p>
<p>xxHash32 algorithm works by accumulating 4 32-bit unsigned integers and then combining them<br />
together into the hash code; thus if you call <code>HashCode.Add(int)</code>, the first three times you call it you’re<br />
just storing the values separately into the instance, and then the fourth time you call it all of those<br />
values are combined into the hash code (and there’s a separate process that incorporates any<br />
remaining values if the number of 32-bit values added wasn’t an exact multiple of 4). Thus, previously</p>
<p>to deal with the possibility that previous calls to <code>Add</code> may have left some state queued, which means<br />
(with the current implementation at least), if there are multiple pieces of state to include in the hash</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>AddBytes</td>
<td>.NET 6.0</td>
<td>159.11 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>AddBytes</td>
<td>.NET 7.0</td>
<td>42.11 ns</td>
<td>0.26</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/72727">Another span-related change, dotnet/runtime#72727</a> refactored a bunch of code paths to eliminate<br />
some cached arrays. Why avoid cached arrays? After all, isn’t it desirable to cache an array once and<br />
reuse it over and over again? It is, if that’s the best option, but sometimes there are better options. For<br />
example, one of the changes took code like:</p>
<p>and replaced it with code like:</p>
<pre><code>int index = value.AsSpan().IndexOfAny(@&quot;:\/?#&quot;);

</code></pre>
<p>125 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>This has a variety of benefits. There’s the usability benefit of keeping the tokens being searched close<br />
to the use site, and the usability benefit of the list being immutable such that some code somewhere<br />
won’t accidentally replace a value in the array. But there are also performance benefits. We don’t need<br />
an extra field to store the array. We don’t need to allocate the array as part of this type’s static<br />
constructor. And loading/using the string is slightly faster.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithArray</td>
<td>8.601 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>WithString</td>
<td>6.949 ns</td>
<td>0.81</td>
</tr>
</tbody>
</table>
<p>Another example from that PR took code along the lines of:</p>
<p>and replaced it with code like:</p>
<p>In this case, not only have we avoided the <code>char[]</code>, but if the text did require any trimming of<br />
whitespaces, the new version (which trims a span instead of the original string) will save an allocation<br />
for the trimmed string. This is taking advantage of the new C# 11 feature that supports switching on</p>
<p><code>ReadOnlySpan&lt;char&gt;</code> s just as you can switch on <code>string</code> <a href="https://github.com/dotnet/roslyn/pull/44388">s, added in dotnet/roslyn#44388 from</a></p>
<p>[<a href="https://github.com/YairHalberstadt">@YairHalberstadt</a>. dotnet/runtime#68831](https://github.com/dotnet/runtime/pull/68831) also took advantage<br />
of this in several additional places.</p>
<p>Of course, in some cases the arrays are entirely unnecessary. In that same PR, there were several cases<br />
like this:</p>
<p>126 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p>By switching to use spans, again, we can instead write it like this:</p>
<p><code>MemoryExtensions.IndexOfAny</code> has a dedicated overload for two and three arguments, at which<br />
point we don’t need the array at all (these overloads also happen to be faster; when passing an array<br />
of two chars, the implementation would extract the two chars from the array and pass them off to the<br />
same two-argument implementation). Multiple other PRs similarly removed array allocations.</p>
<p>[Finally, dotnet/runtime#59670 from <a href="https://github.com/NewellClark">@NewellClark</a> got rid of even](https://github.com/dotnet/runtime/pull/59670)</p>
<p><a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6">As I discussed in the .NET 6 post, this avoids even the one-time array allocation you’d get for a cached</a><br />
array, results in much more efficient access, and supplies to the JIT compiler more information that<br />
enables it to more heavily optimize… goodness all around. This PR removed even more arrays in this<br />
<a href="https://github.com/dotnet/runtime/pull/60411">manner, as did dotnet/runtime#60411, dotnet/runtime#72743,</a> <a href="https://github.com/dotnet/runtime/pull/73115">dotnet/runtime#73115 from</a></p>
<p>[<a href="https://github.com/vcsjones">@vcsjones</a>, and dotnet/runtime#70665.](https://github.com/dotnet/runtime/pull/70665)</p>
<p>127 CHAPTER 10 | Arrays, Strings, and Spans</p>
<p><strong>CHAPTER</strong></p>
<h1>11</h1>
<h2>Regex</h2>
<p><a href="https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7">Back in May, I shared a fairly detailed post about the improvements coming to Regular Expressions in</a><br />
<a href="https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7">.NET 7. As a recap, prior to .NET 5,</a> <code>Regex</code> ’s implementation had largely been untouched for quite<br />
some time. In .NET 5, we brought it back up to be on par with or better than multiple other industry<br />
implementations from a performance perspective. .NET 7 takes some significant leaps forward from<br />
that. If you haven’t read the post yet, please go ahead and do so now; I’ll wait…</p>
<p>Welcome back. With that context, I’ll avoid duplicating content here, and instead focus on how exactly<br />
these improvements came about and the PRs that did so.</p>
<p><strong>RegexOptions.NonBacktracking</strong></p>
<p>processing of <code>Regex</code> over to using a new engine based in finite automata. It has two primary modes of<br />
execution, one that relies on DFAs (deterministic finite automata) and one that relies on NFAs (nondeterministic finite automata). Both implementations provide a very valuable guarantee: processing<br />
time is linear in the length of the input. Whereas a backtracking engine (which is what <code>Regex</code> uses if</p>
<p><code>NonBacktracking</code> isn’t specified) can hit a situation known as “catastrophic backtracking,” where<br />
problematic expressions combined with problematic input can result in exponential processing in the<br />
length of the input, <code>NonBacktracking</code> guarantees it’ll only ever do an ammortized-constant amount<br />
of work per character in the input. In the case of a DFA, that constant is very small. With an NFA, that<br />
constant can be much larger, based on the complexity of the pattern, but for any given pattern the<br />
work is still linear in the length of the input.</p>
<p>A significant number of years of development went into the <code>NonBacktracking</code> implementation, which<br />
<a href="https://github.com/dotnet/runtime">was initially added into dotnet/runtime in dotnet/runtime#60607. However, the original research and</a><br />
implementation for it actually came from Microsoft Research (MSR), and was available as an<br />
experimental package in the form of the Symbolic Regex Matcher (SRM) library published by MSR.<br />
You can still see vestiges of this in the current code now in .NET 7, but it’s evolved significantly, in<br />
tight collaboration between developers on the .NET team and the researchers at MSR (prior to being<br />
<a href="https://github.com/dotnet/runtime">integrated in dotnet/runtime, it was incubated for over a year in dotnet/runtimelab, where the original</a><br />
<a href="https://github.com/dotnet/runtimelab/pull/588">SRM code was brought in via dotnet/runtimelab#588</a> from <a href="https://github.com/veanes">@veanes</a>).</p>
<p>This implementation is based on the notion of regular expression derivatives, a concept that’s been<br />
around for decades (the term was originally coined in a paper by Janusz Brzozowski in the 1960s) and<br />
which has been significantly advanced for this implementation. Regex derivatives form the basis for<br />
how the automata (think “graph”) used to process input are constructed. The idea at its core is fairly<br />
simple: take a regex and process a single character… what is the new regex you get to describe what<br />
remains after processing that one character? That’s the derivative. For example, given the regex <code>\w{3}</code></p>
<p>128 CHAPTER 11 | Regex</p>
<p>to match three word characters, if you apply this to the next input character ‘a’, well, that will strip off</p>
<p>derivative would be nothing, which we’ll express here as an empty character class, giving us</p>
<p><code>.*(the|he)|he|[]</code> . Of course, as part of an alternation, that “nothing” at the end is a nop, and so we<br />
can simplify the whole derivative to just <code>.*(the|he)|he</code> … done. That was all when applying the</p>
<p>or <code>h</code> ), and so we just end up with that same subexpression. But against the right side of the<br />
alternation, <code>e</code> matches <code>e</code>, leaving us with the empty string <code>()</code> : <code>.*(the|he)|()</code> . At the point where a<br />
pattern is “nullable” (it can match the empty string), that can be considered a match. We can visualize<br />
this whole thing as a graph, with transitions for every input character to the derivative that comes<br />
from applying it.</p>
<p>129 CHAPTER 11 | Regex</p>
<p>130 CHAPTER 11 | Regex</p>
<p>Looks an awful lot like a DFA, doesn’t it? It should. And that’s exactly how <code>NonBacktracking</code><br />
constructs the DFAs it uses to process input. For every regex construct (concatenations, alternations,<br />
loops, etc.) the engine knows how to derive the next regex based on the character being evaluated.<br />
This application is done lazily, so we have an initial starting state (the original pattern), and then when<br />
we evaluate the next character in the input, it looks to see whether there’s already a derivative<br />
available for that transition: if there is, it follows it, and if there isn’t, it dynamically/lazily derives the<br />
next node in the graph. At its core, that’s how it works.</p>
<p>Of course, the devil is in the details and there’s a ton of complication and engineering smarts that go<br />
into making the engine efficient. One such example is a tradeoff between memory consumption and<br />
throughput. Given the ability to have any <code>char</code> as input, you could have effectively ~65K transitions<br />
out of every node (e.g. every node could need a ~65K element table); that would significantly increase<br />
memory consumption. However, if you actually had that many transitions, it’s very likely a significant<br />
majority of them would point to the same target node. Thus, <code>NonBacktracking</code> maintains its own<br />
groupings of characters into what it calls “minterms.” If two characters will have exactly the same<br />
transition, they’re part of the same minterm. The transitions are then constructed in terms of<br />
minterms, with at most one transition per minterm out of a given node. When the next input character<br />
is read, it maps that to a minterm ID, and then finds the appropriate transition for that ID; one<br />
additional level of indirection in order to save a potentially huge amount of memory. That mapping is<br />
<a href="https://en.wikipedia.org/wiki/Binary_decision_diagram">handled via an array bitmap for ASCII and an efficient data structure known as a Binary Decision</a><br />
<a href="https://en.wikipedia.org/wiki/Binary_decision_diagram">Diagram (BDD)</a> for everything above 0x7F.</p>
<p>As noted, the non-backtracking engine is linear in the length of the input. But that doesn’t mean it<br />
always looks at each input character exactly once. If you call <code>Regex.IsMatch</code>, it does; after all, <code>IsMatch</code><br />
only needs to determine whether there is a match and doesn’t need to compute any additional<br />
information, such as where the match actual starts or ends, any information on captures, etc. Thus, the<br />
engine can simply employ its automata to walk along the input, transitioning from node to node in<br />
the graph until it comes to a final state or runs out of input. Other operations, however, do require it<br />
to gather more information. <code>Regex.Match</code> needs to compute everything, and that can actually entail<br />
multiple walks over the input. In the initial implementation, the equivalent of <code>Match</code> would always take<br />
three passes: match forwards to find the end of <em>a</em> match, then match a reversed-copy of the pattern in<br />
reverse from that ending location in order to find where the match actually starts, and then once more<br />
walk forwards from that known starting position to find the actual ending position. However, with<br />
<a href="https://github.com/dotnet/runtime/pull/68199">dotnet/runtime#68199</a> from <a href="https://github.com/olsaarik">@olsaarik</a>, unless captures are required, it<br />
can now be done in only two passes: once forward to find the guaranteed ending location of the<br />
<a href="https://github.com/dotnet/runtime/pull/65129">match, and then once in reverse to find its starting location. And dotnet/runtime#65129 from</a></p>
<p><a href="https://github.com/olsaarik">@olsaarik</a> added captures support, which the original implementation<br />
also didn’t have. This captures support adds back a third pass, such that once the bounds of the<br />
match are known, the engine runs the forward pass one more time, but this time with an NFA-based<br />
“simulation” that is able to record “capture effects” on transitions. All of this enables the nonbacktracking implementation to have the exact same semantics as the backtracking engines, always<br />
producing the same matches in the same order with the same capture information. The only<br />
difference in this regard is, whereas with the backtracking engines capture groups inside of loops will<br />
store all values captured in every iteration of the loop, only the last iteration is stored with the nonbacktracking implementation. On top of that, there are a few constructs the non-backtracking</p>
<p>131 CHAPTER 11 | Regex</p>
<p>implementation simply doesn’t support, such that attempting to use any of those will fail when trying<br />
to construct the <code>Regex</code>, e.g. backreferences and lookarounds.</p>
<p>Even after its progress as a standalone library from MSR, more than 100 PRs went into making</p>
<p><code>RegexOptions.NonBacktracking</code> what it is now in .NET 7, including optimizations like<br />
<a href="https://github.com/dotnet/runtime/pull/70217">dotnet/runtime#70217</a> from <a href="https://github.com/olsaarik">@olsaarik</a> that tries to streamline the tight<br />
inner matching loop at the heart of the DFA (e.g. read the next input character, find the appropriate<br />
transition to take, move to the next node, and check information about the node like whether it’s a<br />
<a href="https://github.com/dotnet/runtime/pull/65637">final state) and optimizations like dotnet/runtime#65637</a> from <a href="https://github.com/veanes">@veanes</a><br />
that optimized the NFA mode to avoid superfluous allocations, caching and reusing list and set<br />
objects to make the handling of the lists of states ammortized allocation-free.</p>
<p>There’s one more set of PRs of performance interest for <code>NonBacktracking</code> . The <code>Regex</code> implementation<br />
for taking patterns and turning them into something processable, regardless of which of the multiple<br />
engines is being used, is essentially a compiler, and as with many compilers, it naturally lends itself to<br />
recursive algorithms. In the case of <code>Regex</code>, those algorithms involve walking around trees of regular<br />
expression constructs. Recursion ends up being a very handy way of expressing these algorithms, but<br />
recursion also suffers from the possibility of stack overflow; essentially it’s using stack space as scratch<br />
space, and if it ends up using too much, things go badly. One common approach to dealing with this<br />
is turning the recursive algorithm into an iterative one, which typically involves using an explicit stack<br />
of state rather than the implicit one. The nice thing about this is the amount of state you can store is<br />
limited only by how much memory you have, as opposed to being limited by your thread’s stack<br />
space. The downsides, however, are that it’s typically much less natural to write the algorithms in this<br />
manner, and it typically requires allocating heap space for the stack, which then leads to additional<br />
complications if you want to avoid that allocation, such as various kinds of pooling.<br />
<a href="https://github.com/dotnet/runtime/pull/60385">dotnet/runtime#60385</a> introduces a different approach for <code>Regex</code>, which is then used by</p>
<p>the recursive algorithm as well as being able to use stack space and thus avoid additional allocation in<br />
the most common cases, but then to avoid stack overflows, it issues explicit checks to ensure we’re<br />
not too deep on the stack (.NET has long provided the helpers</p>
<p>on the stack, it forks off continued execution into another thread. Hitting this condition is expensive,<br />
but it’s very rarely if ever actually hit in practice (e.g. the only time it’s hit in our vast functional tests<br />
are in the tests explicitly written to stress it), it keeps the code simple, and it keeps the typical cases<br />
<a href="https://github.com/dotnet/runtime">fast. A similar approach is used in other areas of dotnet/runtime, such as in System.Linq.Expressions.</a></p>
<p>As was mentioned in my previous blog post about regular expressions, both the backtracking<br />
implementations and the non-backtracking implementation have their place. The main benefit of the<br />
non-backtracking implementation is predictability: because of the linear processing guarantee, once<br />
you’ve constructed the regex, you don’t need to worry about malicious inputs causing worst-case<br />
behavior in the processing of your potentially susceptible expressions. This doesn’t mean</p>
<p><code>RegexOptions.NonBacktracking</code> is always the fastest; in fact, it’s frequently not. In exchange for<br />
reduced best-case performance, it provides the best worst-case performance, and for some kinds of<br />
applications, that’s a really worthwhile and valuable tradeoff.</p>
<p>132 CHAPTER 11 | Regex</p>
<p><strong>New APIs</strong></p>
<p><code>Regex</code> gets several new methods in .NET 7, all of which enable improved performance. The simplicity<br />
of the new APIs likely also misrepresents how much work was necessary to enable them, in particular<br />
because the new APIs all support <code>ReadOnlySpan&lt;char&gt;</code> inputs into the regex engines.</p>
<p>relied on in .NET Framework ( <code>CompileToAssembly</code> is now obsoleted and has never been functional in<br />
.NET Core). One subtly that relies on the nature of <code>string</code> as the input is how match information is</p>
<p>challenge to support spans, but the problem is even more deeply rooted. All of the regex engines rely</p>
<p>functionally correct, but would have completely defeated the purpose of accepting spans, and worse,<br />
would have been so unexpected as to likely cause consuming apps to be worse performing than they<br />
would have without the APIs. Instead, we needed a new approach and new APIs.</p>
<p>First, we made <code>FindFirstChar</code> and <code>Go</code> virtual instead of abstract. The design that splits these methods<br />
is largely antiquated, and in particular the forced separation between a stage of processing where you<br />
find the next possible location of a match and then a stage where you actually perform the match at<br />
that location doesn’t align well with all engines, like the one used by <code>NonBacktracking</code> (which initially<br />
implemented <code>FindFirstChar</code> as a nop and had all its logic in <code>Go</code> ). Then we added a new virtual <code>Scan</code><br />
method which, importantly, takes a <code>ReadOnlySpan&lt;char&gt;</code> as a parameter; the span can’t be exposed<br />
from the base <code>RegexRunner</code> and must be passed in. We then implemented <code>FindFirstChar</code> and <code>Go</code> in<br />
terms of <code>Scan</code>, and made them “just work.” Then, all of the engines are implemented in terms of that</p>
<p>133 CHAPTER 11 | Regex</p>
<p>span; they no longer need to access the protected <code>RegexRunner.runtext</code>, <code>RegexRunner.runtextbeg</code>,<br />
and <code>RegexRunner.runtextend</code> members that surface the input; they’re just handed the span, already<br />
sliced to the input region, and process that. One of the neat things about this from a performance<br />
perspective is it enables the JIT to do a better job at shaving off various overheads, in particular<br />
around bounds checking. When the logic is implemented in terms of <code>string</code>, in addition to the input<br />
string itself the engine is also handed the beginning and end of the region of the input to process<br />
(since the developer could have called a method like <code>Regex.Match(string input, int beginning,</code></p>
<p><code>int length)</code> in order to only process a substring). Obviously the engine matching logic is way more<br />
complicated than this, but simplifying, imagine the entirety of the engine was just a loop over the<br />
input. With the input, beginning, and length, that would look like:</p>
<p>That will result in the JIT generating assembly code along the lines of this:</p>
<p>In contrast, if we’re dealing with a span, which already factors in the bounds, then we can write a more<br />
canonical loop like this:</p>
<p>134 CHAPTER 11 | Regex</p>
<p>And when it comes to compilers, something in a canonical form is really good, because the more<br />
common the shape of the code, the more likely it is to be heavily optimized:</p>
<p>So even without all the other benefits that come from operating in terms of span, we immediately get<br />
low-level code generation benefits from performing all the logic in terms of spans. While the above<br />
example was made up (obviously the matching logic does more than a simple for loop), here’s a real</p>
<p>current position is a word character and whether the character before it is a word character (factoring</p>
<p>and here’s what the span version looks like:</p>
<p>135 CHAPTER 11 | Regex</p>
<p>And here’s the resulting assembly:</p>
<p>136 CHAPTER 11 | Regex</p>
<p>The most interesting thing to notice here is the:</p>
<p>at the end of the first version that doesn’t exist at the end of the second. As we saw earlier, this is<br />
what the generated assembly looks like when the JIT is emitting the code to throw an index out of<br />
range exception for an array, string, or span. It’s at the end because it’s considered to be “cold,” rarely<br />
executed. It exists in the first because the JIT can’t prove based on local analysis of that function that</p>
<p>span accesses are always in bound. As such, it doesn’t need to emit any bounds checks in the method,<br />
and the method then lacks the tell-tale signature of the index out of range throw. You can see more<br />
examples of taking advantage of spans now being at the heart of the all of the engines in</p>
<p>137 CHAPTER 11 | Regex</p>
<p>Ok, so the engines are now able to be handed span inputs and process them, great, what can we do<br />
with that? Well, <code>Regex.IsMatch</code> is easy: it’s not encumbered by needing to perform multiple matches,<br />
and thus doesn’t need to worry about how to store that input <code>ReadOnlySpan&lt;char&gt;</code> for the next<br />
match. Similarly, the new <code>Regex.Count</code>, which provides an optimized implementation for counting</p>
<p>additional information into the engines to let them know how much information they actually need to<br />
compute. For example, I noted previously that <code>NonBacktracking</code> is fairly pay-for-play in how much<br />
work it needs to do relative to what information it needs to gather. It’s cheapest to just determine<br />
whether there is a match, as it can do that in a single forward pass through the input. If it also needs<br />
to compute the actual starting and ending bounds, that requires another reverse pass through some<br />
of the input. And if it then also needs to compute capture information, that requires yet another<br />
forward pass based on an NFA (even if the other two were DFA-based). <code>Count</code> needs the bounds<br />
information, as it needs to know where to start looking for the next match, but it doesn’t need the<br />
capture information, since none of that capture information is handed back to the caller.</p>
<p>So, <code>IsMatch</code> and <code>Count</code> can work with spans. But we still don’t have a method that lets you actually get</p>
<p>Being a <code>ref struct</code>, the enumerator is able to store a reference to the input span, and is thus able to<br />
iterate through matches, which are represented by the <code>ValueMatch</code> ref struct. Notably, today</p>
<p><code>ValueMatch</code> doesn’t provide capture information, which also enables it to partake in the optimizations<br />
previously mentioned for <code>Count</code> . Even if you have an input <code>string</code>, <code>EnumerateMatches</code> is thus a way to<br />
have ammortized allocation-free enumeration of all matches in the input. In .NET 7, though, there isn’t<br />
a way to have such allocation-free enumeration if you also need all the capture data. That’s something<br />
we’ll investigate designing in the future if/as needed.</p>
<p><strong>TryFindNextPossibleStartingPosition</strong></p>
<p>As noted earlier, the core of all of the engines is a <code>Scan(ReadOnlySpan&lt;char&gt;)</code> method that accepts<br />
the input text to match, combines that with positional information from the base instance, and exits</p>
<p>138 CHAPTER 11 | Regex</p>
<p>when it either finds the location of the next match or exhausts the input without finding another. For<br />
the backtracking engines, the implementation of that method is logically as follows:</p>
<p>We try to match the input at the current position, and if we’re successful in doing so, that’s it, we exit.<br />
If the current position doesn’t match, however, then if there’s any input remaining we “bump” the<br />
position and start the process over. In regex engine terminology, this is often referred to as a<br />
“bumpalong loop.” However, if we actually ran the full matching process at every input character, that<br />
could be unnecessarily slow. For many patterns, there’s something about the pattern that would<br />
enable us to be more thoughtful about where we perform full matches, quickly skipping past locations<br />
that couldn’t possibly match, and only spending our time and resources on locations that have a real<br />
chance of matching. To elevate that concept to a first-class one, the backtracking engines’<br />
“bumpalong loop” is typically more like the following (I say “typically” because in some cases the<br />
compiled and source generated regexes are able to generate something even better).</p>
<p>As with <code>FindFirstChar</code> previously, that <code>TryFindNextPossibleStartingPosition</code> has the<br />
responsibility of searching as quickly as possible for the next place to match (or determining that<br />
nothing else could possibly match, in which case it would return <code>false</code> and the loop would exit). As</p>
<p>be fast.</p>
<p>In .NET 6, the interpreter engine had effectively two ways of implementing</p>
<p><code>TryFindNextPossibleStartingPosition</code> : a Boyer-Moore substring search if the pattern began with a<br />
string (potentially case-insensitive) of at least two characters, and a linear scan for a character class<br />
known to be the set of all possible chars that could begin a match. For the latter case, the interpreter<br />
had eight different implementations for matching, based on a combination of whether</p>
<p><code>RegexOptions.RightToLeft</code> was set or not, whether the character class required case-insensitive<br />
comparison or not, and whether the character class contained only a single character or more than<br />
one character. Some of these were more optimized than others, e.g. a left-to-right, case-sensitive,<br />
single-char search would use an <code>IndexOf(char)</code> to search for the next location, an optimization<br />
added in .NET 5. However, every time this operation was performed, the engine would need to<br />
<a href="https://github.com/dotnet/runtime/pull/60822">recompute which case it would be. dotnet/runtime#60822 improved this, introducing an internal</a></p>
<p>139 CHAPTER 11 | Regex</p>
<p>and precomputing which strategy to use when the interpreter was constructed. This not only made<br />
the interpreter’s implementation at match time faster, it made it effectively free (in terms of runtime<br />
overhead at match time) to add additional strategies.</p>
<p>being significantly better than Boyer-Moore in all but the most corner of corner cases. So this PR<br />
enables a new <code>IndexOf(ReadOnlySpan&lt;char&gt;)</code> strategy to be used to search for a prefix string in the<br />
case where the string is case-sensitive.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>377.32 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>55.44 us</td>
<td>0.15</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/61490">dotnet/runtime#61490</a> then removed Boyer-Moore entirely. This wasn’t done in the previously<br />
mentioned PR because of lack of a good way to handle case-insensitive matches. However, this PR<br />
also special-cased ASCII letters to teach the optimizer how to turn an ASCII case-insensitive match<br />
into a set of both casings of that letter (excluding the few known to be a problem, like <code>i</code> and <code>k</code>, which<br />
can both be impacted by the employed culture and which might map case-insensitively to more than<br />
two values). With enough of the common cases covered, rather than use Boyer-Moore to perform a</p>
<p>implementation handily in real-world cases. This PR goes further than that, such that it doesn’t just<br />
discover the “starting set,” but is able to find all of the character classes that could match a pattern a<br />
fixed-offset from the beginning; that then gives the analyzer the ability to choose the set that’s<br />
expected to be least common and issue a search for it instead of whatever happens to be at the<br />
beginning. The PR goes even further, too, motivated in large part by the non-backtracking engine. The<br />
non-backtracking engine’s prototype implementation also used <code>IndexOfAny(char, char, ...)</code> when<br />
it arrived at a starting state and was thus able to quickly skip through input text that wouldn’t have a<br />
chance of pushing it to the next state. We wanted all of the engines to share as much logic as<br />
possible, in particular around this speed ahead, and so this PR unified the interpreter with the nonbacktracking engine to have them share the exact same <code>TryFindNextPossibleStartingPosition</code><br />
routine (which the non-backtracking engine just calls at an appropriate place in its graph traversal<br />
loop). Since the non-backtracking engine was already using <code>IndexOfAny</code> in this manner, initially not<br />
doing so popped as a significant regression on a variety of patterns we measure, and this caused us to<br />
invest in using it everywhere. This PR also introduced the first special-casing for case-insensitive<br />
comparisons into the compiled engine, e.g. if we found a set that was <code>[Ee]</code>, rather than emitting a</p>
<p>140 CHAPTER 11 | Regex</p>
<p>check akin to <code>c == 'E' || c == 'e'</code>, we’d instead emit a check akin to <code>(c | 0x20) == 'e'</code> (those<br />
fun ASCII tricks discussed earlier coming into play again).</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>499.3 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>177.7 us</td>
<td>0.35</td>
</tr>
</tbody>
</table>
<p>The previous PR started turning <code>IgnoreCase</code> pattern text into sets, in particular for ASCII, e.g. <code>(?i)a</code><br />
would become <code>[Aa]</code> . That PR hacked in the support for ASCII knowing that something more complete<br />
<a href="https://github.com/dotnet/runtime/pull/67184">would be coming along, as it did in dotnet/runtime#67184. Rather than hardcoding the case-</a><br />
insensitive sets that just the ASCII characters map to, this PR essentially hardcodes the sets for every<br />
possible char. Once that’s done, we no longer need to know about case-insensitivity at match time<br />
and can instead just double-down on efficiently matching sets, which we already need to be able to<br />
do well. Now, I said it encodes the sets for every possible char; that’s not entirely true. If it were true,<br />
that would take up a large amount of memory, and in fact, most of that memory would be wasted<br />
because the vast majority of characters don’t participate in case conversion… there are only ~2,000<br />
characters that we need to handle. As such, the implementation employs a three-tier table scheme.<br />
The first table has 64 elements, dividing the full range of <code>chars</code> into 64 groupings; of those 64 groups,<br />
54 of them have no characters that participate in case conversion, so if we hit one of those entries, we<br />
can immediately stop the search. For the remaining 10 that do have at least one character in their<br />
range participating, the character and the value from the first table are used to compute an index into<br />
the second table; there, too, the majority of entries say that nothing participates in case conversion.<br />
It’s only if we get a legitimate hit in the second table does that give us an index into the third table, at<br />
which location we can find all of the characters considered case-equivalent with the first.</p>
<p><a href="https://github.com/dotnet/runtime/pull/63477">dotnet/runtime#63477</a> <a href="https://github.com/dotnet/runtime/pull/66572">(and then later improved in dotnet/runtime#66572) proceeded to add another</a><br />
<a href="https://nitely.github.io/2020/11/30/regex-literals-optimization.html">searching strategy, this one inspired by nim-regex’s literal optimizations. There are a multitude of</a><br />
regexes we track from a performance perspective to ensure we’re not regressing in common cases<br />
<a href="https://github.com/mariomka/regex-benchmark">and to help guide investments. One is the set of patterns in mariomka/regex-benchmark languages</a></p>
<p>enabled strategies for finding a next good location, as it’s guaranteed to begin with a “word<br />
character” ( <code>\w</code> ), which includes ~50,000 of the ~65,000 possible characters; we don’t have a good way<br />
of vectorizing a search for such a character class. However, this pattern is interesting in that it begins<br />
with a loop, and not only that, it’s an upper-unbounded loop which our analysis will determine is<br />
atomic, because the character guaranteed to immediately follow the loop is a <code>':'</code>, which is itself not a<br />
word character, and thus there’s nothing the loop could match and give up as part of backtracking</p>
<p>141 CHAPTER 11 | Regex</p>
<p>find it, we can match backwards through as many <code>[\w]</code> s as we can find; in this case, the only<br />
constraint is we need to match at least one. This PR added that strategy, for a literal after an atomic<br />
loop, to all of the engines.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>IsMatch</td>
<td>.NET 6.0</td>
<td>4,291.77 us</td>
<td>1.000</td>
</tr>
<tr>
<td>IsMatch</td>
<td>.NET 7.0</td>
<td>42.40 us</td>
<td>0.010</td>
</tr>
</tbody>
</table>
<p>Of course, as has been talked about elsewhere, the best optimizations aren’t ones that make<br />
something faster but rather ones that make something entirely unnecessary. That’s what<br />
<a href="https://github.com/dotnet/runtime/pull/64177">dotnet/runtime#64177</a> does, in particular in relation to anchors. The .NET regex implementation has<br />
long had optimizations for patterns with a starting anchor: if the pattern begins with <code>^</code>, for example<br />
(and <code>RegexOptions.Multiline</code> wasn’t specified), the pattern is rooted to the beginning, meaning it<br />
can’t possibly match at any position other than <code>0</code> ; as such, with such an anchor,</p>
<p><code>TryFindNextPossibleStartingPosition</code> won’t do any searching at all. The key here, though, is being<br />
able to detect whether the pattern begins with such an anchor. In some cases, like <code>^abc$</code>, that’s trivial.</p>
<p>that a pattern has an ending anchor like <code>$</code> . If the analysis engine can determine a maximum number of<br />
characters for any possible match, and it has such an anchor, then it can simply jump to that distance<br />
from the end of the string, and bypass even looking at anything before then.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>IsMatch</td>
<td>.NET 6.0</td>
<td>867,890.56 ns</td>
<td>1.000</td>
</tr>
<tr>
<td>IsMatch</td>
<td>.NET 7.0</td>
<td>33.55 ns</td>
<td>0.000</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/67732">dotnet/runtime#67732</a> is another PR related to improving anchor handling. It’s always fun when a bug<br />
fix or code simplification refactoring turns into a performance improvement. The PR’s primary purpose<br />
was to simplify some complicated code that was computing the set of characters that could possibly<br />
start a match. It turns out that complication was hiding a logic bug which manifested in it missing<br />
some opportunities to report valid starting character classes, the impact of which is that some<br />
searches which could have been vectorized weren’t. By simplifying the implementation, the bug was<br />
fixed, exposing more performance opportunities.</p>
<p>142 CHAPTER 11 | Regex</p>
<p>By this point, the engines are able to use <code>IndexOf(ReadOnlySpan&lt;char&gt;)</code> to find a substring at the<br />
beginning of a pattern. But sometimes the most valuable substring isn’t at the beginning, but<br />
somewhere in the middle or even at the end. As long as it’s at a fixed-offset from the beginning of the<br />
pattern, we can search for it, and then just back-off by the offset to the position we should actually try<br />
<a href="https://github.com/dotnet/runtime/pull/67907">running the match. dotnet/runtime#67907 does exactly that.</a></p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>444.2 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>122.6 us</td>
<td>0.28</td>
</tr>
</tbody>
</table>
<p><strong>Loops and Backtracking</strong></p>
<p>Loop handling in the compiled and source generated engines has been significantly improved, both<br />
with respect to processing them faster and with respect to backtracking less.</p>
<p>With regular greedy loops (e.g. <code>c*</code> ), there are two directions to be concerned about: how quickly can<br />
we consume all the elements that match the loop, and how quickly can we give back elements that<br />
might be necessary as part of backtracking for the remainder of the expression to match. And with<br />
lazy loops, we’re primarily concerned with backtracking, which is the forward direction (since lazy<br />
loops consume as part of backtracking rather than giving back as part of backtracking). With PRs<br />
<a href="https://github.com/dotnet/runtime/pull/63428">dotnet/runtime#63428,</a> <a href="https://github.com/dotnet/runtime/pull/68400">dotnet/runtime#68400, dotnet/runtime#64254, and dotnet/runtime#73910, in</a><br />
both the compiler and source generator we now make full use of effectively all of the variants of</p>
<p>the forward direction of that loop entails consuming every character until the next newline, which we</p>
<p>possibly match the remainder of the pattern. Or for example, in a pattern like <code>[^a-c]*def</code>, the loop<br />
will initially greedily consume everything other than <code>'a'</code>, <code>'b'</code>, or <code>'c'</code>, so we can use</p>
<p><code>IndexOfAnyExcept('a', 'b', 'c')</code> to find the initial end of the loop. And so on. This can yield huge<br />
performance gains, and with the source generator, also makes the generated code more idiomatic<br />
and easier to understand.</p>
<p>143 CHAPTER 11 | Regex</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>3,369.5 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>430.2 us</td>
<td>0.13</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/63398">Sometimes optimizations are well-intended but slightly miss the mark. dotnet/runtime#63398 fixes</a><br />
such an issue with an optimization introduced in .NET 5; the optimization was valuable but only for a<br />
subset of the scenarios it was intended to cover. While <code>TryFindNextPossibleStartingPosition</code> ’s<br />
primary raison d’être is to update the bumpalong position, it’s also possible for</p>
<p><code>TryMatchAtCurrentPosition</code> to do so. One of the occasions in which it’ll do so is when the pattern<br />
begins with an upper-unbounded single-character greedy loop. Since processing starts with the loop<br />
having fully consumed everything it could possibly match, subsequent trips through the scan loop<br />
don’t need to reconsider any starting position within that loop; doing so would just be duplicating<br />
work done in a previous iteration of the scan loop. And as such, <code>TryMatchAtCurrentPosition</code> can<br />
update the bumpalong position to the end of the loop. The optimization added in .NET 5 was dutifully<br />
doing this, and it did so in a way that fully handled atomic loops. But with greedy loops, the updated<br />
position was getting updated every time we backtracked, meaning it started going backwards, when it<br />
should have remained at the end of the loop. This PR fixes that, yielding significant savings in the<br />
additional covered cases.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 6.0</td>
<td>103,962.8 us</td>
<td>1.000</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 7.0</td>
<td>336.9 us</td>
<td>0.003</td>
</tr>
</tbody>
</table>
<p>As mentioned elsewhere, the best optimizations are those that make work entirely vanish rather than<br />
<a href="https://github.com/dotnet/runtime/pull/68989">just making work faster. dotnet/runtime#68989, dotnet/runtime#63299, and dotnet/runtime#63518</a><br />
do exactly that by improving the pattern analyzers ability to find and eliminate more unnecessary<br />
backtracking, a process the analyzer refers to as “auto-atomicity” (automatically making loops atomic).</p>
<p>try to match <code>&quot;ab&quot;</code> . It won’t match so we’ll backtrack into the lazy loop and try to match <code>&quot;aab&quot;</code> . And so<br />
on, until we’ve consumed all the <code>'a'</code> s such that the rest of the pattern has a chance of matching the<br />
rest of the input. That’s exactly what an atomic greedy loop does, so we can transform the pattern</p>
<p><code>a*?b</code> into <code>(?&gt;a*)b</code>, which is much more efficiently processed. In fact, we can see exactly how it’s<br />
processed just by looking at the source-generated implementation of this pattern:</p>
<p>144 CHAPTER 11 | Regex</p>
<p>(Note that those comments aren’t ones I added for this blog post; the source generator itself is<br />
emitting commented code.)</p>
<p>When a regular expression is input, it’s parsed into a tree-based form. The “auto-atomicity” analysis<br />
discussed in the previous PR is one form of analysis that walks around this tree looking for<br />
opportunities to transform portions of the tree into a behaviorally equivalent alternative that will be<br />
more efficient to execute. Several PRs introduced additional such transformations.<br />
<a href="https://github.com/dotnet/runtime/pull/63695">dotnet/runtime#63695, for example, looks for “empty” and “nothing” nodes in the tree that can be</a><br />
removed. An “empty” node is something that matches the empty string, so for example in the<br />
alternation <code>abc|def||ghi</code>, the third branch of that alternation is empty. A “nothing” node is<br />
something that can’t match anything, so for example in the concatenation <code>abc(?!)def</code>, that <code>(?!)</code> in<br />
middle is a negative lookahead around an empty, which can’t possibly match anything, as it’s saying<br />
the expression won’t match if it’s followed by an empty string, which everything is. These constructs<br />
often arise as a result of other transformations rather than being something a developer typically<br />
writes by hand, just as there are optimizations in the JIT where you might look at them and say “why<br />
on earth is that something a developer would write” but it ends up being a valuable optimization<br />
anyways because inlining might transform perfectly reasonable code into something that matches the<br />
target pattern. Thus, for example, if you did have <code>abc(?!)def</code>, since that concatenation requires the</p>
<p><code>(?!)</code> to match in order to be successful, the concatenation itself can simply be replaced by a<br />
“nothing.” You can see this easily if you try this with the source generator:</p>
<pre><code>[GeneratedRegex(@&quot;abc(?!)def&quot;)]

</code></pre>
<p>145 CHAPTER 11 | Regex</p>
<p>as it will produce a <code>Scan</code> method like this (comment and all):</p>
<p><a href="https://github.com/dotnet/runtime/pull/59903">Another set of transformations was introduced in dotnet/runtime#59903, specifically around</a><br />
alternations (which beyond loops are the other source of backtracking). This introduced two main<br />
optimizations. First, it enables rewriting alternations into alternations of alternations, e.g. transforming</p>
<p><code>axy|axz|bxy|bxz</code> into <code>ax(?:y|z)|bx(?:y|z)</code>, which is then further reduced into <code>ax[yz]|bx[yz]</code> . This<br />
can enable the backtracking engines to more efficiently process alternations due to fewer branches<br />
and thus less potential backtracking. The PR also enabled limited reordering of branches in an<br />
alternation. Generally branches can’t be reordered, as the order can impact exactly what’s matched<br />
and what’s captured, but if the engine can prove there’s no effect on ordering, then it’s free to<br />
reorder. One key place that ordering isn’t a factor is if the alternation is atomic due to it being<br />
wrapped in an atomic group (and the auto-atomicity analysis will add such groups implicitly in some<br />
situations). Reordering the branches then enables other optimizations, like the one previously<br />
mentioned from this PR. And then once those optimizations have kicked in, if we’re left with an atomic<br />
alternation where every branch begins with a different letter, than can enable further optimizations in<br />
terms of how the alternation is lowered; this PR teaches the source generator how to emit a <code>switch</code><br />
statement, which leads to both more efficient and more readable code. (The detection of whether<br />
nodes in the tree are atomic, and other such properties such as performing captures or introducing<br />
<a href="https://github.com/dotnet/runtime/pull/65734">backtracking, turned out to be valuable enough that dotnet/runtime#65734</a> added dedicated support<br />
for this.)</p>
<p><strong>Code generation</strong></p>
<p>The .NET 7 regex implementation has no fewer than four engines: the interpreter (what you get if you</p>
<p>engine don’t require any kind of code generation; they’re both based on creating in-memory data<br />
structures that represent how to match input against the pattern. The other two, though, both<br />
generate code specific to the pattern; the generated code is code attempting to mimick what you<br />
might write if you weren’t using <code>Regex</code> at all and were instead writing code to perform a similar match<br />
directly. The source generator spits out C# that’s compiled directly into your assembly, and the<br />
compiler spits out IL at run-time via reflection emit. The fact that these are generating code specific to<br />
the pattern means there’s a ton of opportunity to optimize.</p>
<p><a href="https://github.com/dotnet/runtime/pull/59186">dotnet/runtime#59186</a> provided the initial implementation of the source generator. This was a direct<br />
port of the compiler, effectively a line-by-line translation of IL into C#; the result is C# akin to what<br />
<a href="https://github.com/icsharpcode/ILSpy">you’d get if you were to run the generated IL through a decompiler like ILSpy. A bunch of PRs then</a><br />
proceeded to iterate on and tweak the source generator, but the biggest improvements came from<br />
changes that changed the compiler and the source generator together. Prior to .NET 5, the compiler<br />
spit out IL that was very similar to what the interpreter would do. The interpreter is handed a series of<br />
instructions that it walks through one by one and interprets, and the compiler, handed that same</p>
<p>146 CHAPTER 11 | Regex</p>
<p>series of instructions, would just emit the IL for processing each. It had some opportunity for being<br />
more efficient, e.g. loop unrolling, but a lot of value was left on the table. In .NET 5, an alternate path<br />
was added in support of patterns without backtracking; this code path was based on being handed<br />
the parsed node tree rather than being based on the series of instructions, and that higher-level form<br />
enabled the compiler to derive more insights about the pattern that it could then use to generate<br />
more efficient code. In .NET 7, support for all regex features were incrementally added in, over the<br />
<a href="https://github.com/dotnet/runtime/pull/60385">course of multiple PRs, in particular dotnet/runtime#60385</a> for backtracking single char loops,<br />
<a href="https://github.com/dotnet/runtime/pull/61698">dotnet/runtime#61698</a> <a href="https://github.com/dotnet/runtime/pull/61784">for backtracking single char lazy loops, dotnet/runtime#61784 for other</a><br />
<a href="https://github.com/dotnet/runtime/pull/61906">backtracking lazy loops, and dotnet/runtime#61906</a> for other backtracking loops as well as back<br />
references and conditionals. At that point, the only features missing were support for</p>
<p><code>RegexOptions.RightToLeft</code> and lookbehinds (which are implemented in terms of right-to-left), and<br />
we decided based on relatively little use of these features that we needn’t keep around the old<br />
<a href="https://github.com/dotnet/runtime/pull/62318">compiler code just to enable them. So, dotnet/runtime#62318</a> deleted the old implementation. But,<br />
even though these features are relatively rare, it’s a lot easier to tell a story that “all patterns are<br />
<a href="https://github.com/dotnet/runtime/pull/66127">supported” than one that requires special callouts and exceptions, so dotnet/runtime#66127 and</a><br />
<a href="https://github.com/dotnet/runtime/pull/66280">dotnet/runtime#66280</a> added full lookbehind and <code>RightToLeft</code> support such that there were no<br />
takebacks. At this point, both the compiler and source generator now supported everything the<br />
compiler previously did, but now with the more modernized code generation. This code generation is<br />
in turn what enables many of the optimizations previously discussed, e.g. it provides the opportunity<br />
to use APIs like <code>LastIndexOf</code> as part of backtracking, which would have been near impossible with the<br />
previous approach.</p>
<p>One of the great things about the source generator emitting idiomatic C# is it makes it easy to iterate.<br />
Every time you put in a pattern and see what the generator emits, it’s like being asked to do a code<br />
review of someone else’s code, and you very frequently see something “new” worthy of comment, or<br />
in this case, improving the generator to address the issue. And so a bunch of PRs were originated<br />
based on reviewing what the generator emitted and then tweaking the generator to do better (and<br />
since the compiler was effectively entirely rewritten along with the source generator, they maintain the<br />
same structure, and it’s easy to port improvements from one to the other). For example,<br />
<a href="https://github.com/dotnet/runtime/pull/68846">dotnet/runtime#68846</a> <a href="https://github.com/dotnet/runtime/pull/69198">and dotnet/runtime#69198</a> tweaked how some comparisons were being<br />
performed in order for them to convey enough information to the JIT that it can eliminate some<br />
<a href="https://github.com/dotnet/runtime/pull/68490">subsequent bounds checking, and dotnet/runtime#68490</a> recognized a variety of conditions being<br />
emitted that could never happen in some situations observable statically and was able to elide all that<br />
code gen. It also became obvious that some patterns didn’t need the full expressivity of the scan loop,<br />
and a more compact and customized <code>Scan</code> <a href="https://github.com/dotnet/runtime/pull/68560">implementation could be used. dotnet/runtime#68560</a><br />
does that, such that, for example, a simple pattern like <code>hello</code> won’t emit a loop at all and will instead<br />
have a simpler <code>Scan</code> implementation like:</p>
<p>147 CHAPTER 11 | Regex</p>
<p>The compiler and source generator were also updated to take advantage of newer features.<br />
<a href="https://github.com/dotnet/runtime/pull/63277">dotnet/runtime#63277, for example, teaches the source generator how to determine if</a> <code>unsafe</code> code is</p>
<p>zero’ing being necessary. Then there’s the issue of where the code is generated; we want helper<br />
functions (like the <code>\w</code> <code>IsWordChar</code> <a href="https://github.com/dotnet/runtime/pull/62620">helper introduced in dotnet/runtime#62620) that can be shared</a><br />
amongst multiple generated regexes, and we want to be able to share the exact same regex<br />
implementation if the same pattern/options/timeout combination are used in multiple places in the<br />
<a href="https://github.com/dotnet/runtime/pull/66747">same assembly (dotnet/runtime#66747), but doing so then exposes this implementation detail to user</a><br />
code in the same assembly. To still be able to get the perf benefits of such code sharing while</p>
<p>One last and interesting code generation aspect is in optimizations around character class matching.<br />
Matching character classes, whether ones explicitly written by the developer or ones implicitly created<br />
by the engine (e.g. as part of finding the set of all characters that can begin the expression), can be<br />
one of the more time-consuming aspects of matching; if you imagine having to evaluate this logic for<br />
every character in the input, then how many instructions needs to be executed as part of matching a<br />
character class directly correlates to how long it takes to perform the overall match. We thus spend<br />
some time trying to ensure we generate optimal matching code for as many categories of character<br />
<a href="https://github.com/dotnet/runtime/pull/67365">classes as possible. dotnet/runtime#67365, for example, improved a bunch of cases found to be</a></p>
<p>optimizations around the handling of “match anything” can kick in.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Match</td>
<td>.NET 6.0</td>
<td>1,934,393.69 ns</td>
<td>1.000</td>
</tr>
<tr>
<td>Match</td>
<td>.NET 7.0</td>
<td>91.80 ns</td>
<td>0.000</td>
</tr>
</tbody>
</table>
<p>about, in the generated output; for example this:</p>
<p>now produces this in the core matching logic emitted by the source generator:</p>
<p>148 CHAPTER 11 | Regex</p>
<p><a href="https://github.com/dotnet/runtime/pull/72328">Other changes impacting character class code generation included dotnet/runtime#72328, which</a><br />
improved the handling of character classes that involve character class subtraction;<br />
<a href="https://github.com/dotnet/runtime/pull/72317">dotnet/runtime#72317</a> from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a>, which enabled<br />
<a href="https://github.com/dotnet/runtime/pull/67133">additional cases where the generator could avoid emitting a bitmap lookup; dotnet/runtime#67133,</a><br />
which added a tighter bounds check when it does emit such a lookup table; and<br />
<a href="https://github.com/dotnet/runtime/pull/61562">dotnet/runtime#61562, which enables better normalization of character classes in the engine’s</a><br />
internal representation, thus leading to downstream optimizations better recognizing more character<br />
classes.</p>
<p>Finally, with all of these improvements to <code>Regex</code>, a multitude of PRs fixed up regexes being used<br />
<a href="https://github.com/dotnet/runtime">across dotnet/runtime, in various ways. dotnet/runtime#66142,</a> <a href="https://github.com/dotnet/runtime/pull/66179">dotnet/runtime#66179 from</a></p>
<p>expensive phases in the non-backtracking engine to compute exact bounds and capture information.<br />
The PR also replaced some <code>Match</code> / <code>Match.MoveNext</code> usage with <code>EnumerateMatches</code>, in order to avoid<br />
needing <code>Match</code> object allocations. The PR also entirely removed at least one regex usage that was just</p>
<p>in a way as to try to make it as trimmmer friendly as possible. If you only ever do <code>new</code></p>
<p><code>Regex(pattern)</code>, we’d really like to be able to statically determine that the compiler and nonbacktracking implementations aren’t needed such that the trimmer can remove it without having a<br />
visible and meaningful negative impact. However, the trimmer analysis isn’t yet sophisticated enough<br />
to see exactly which options are used and only keep the additional engines linked in if</p>
<p>options, we increase the chances that no code in the app is using this constructor, which would in turn<br />
enable this constructor, the compiler, and the non-backtracking implementation to be trimmed away.</p>
<p>149 CHAPTER 11 | Regex</p>
<p><strong>CHAPTER</strong></p>
<h1>12</h1>
<h2>Collections</h2>
<p><code>System.Collections</code> hasn’t seen as much investment in .NET 7 as it has in previous releases, though<br />
many of the lower-level improvements have a trickle-up effect into collections as well. For example,</p>
<p><code>Dictionary&lt;,&gt;</code> ’s code hasn’t changed between .NET 6 and .NET 7, but even so, this benchmark<br />
focused on dictionary lookups:</p>
<p>shows a measurable improvement in throughput between .NET 6 and .NET 7:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>.NET 6.0</td>
<td>51.18 us</td>
<td>1.00</td>
<td>431 B</td>
</tr>
<tr>
<td>Sum</td>
<td>.NET 7.0</td>
<td>43.44 us</td>
<td>0.85</td>
<td>413 B</td>
</tr>
</tbody>
</table>
<p>that array can’t be mutated, but if there are mutable reference types stored in the array, those<br />
instances themselves may still have their data mutated). As a result, <code>ImmutableArray&lt;T&gt;</code> also has an<br />
associated “builder” type, which does support mutation: you create the builder, populate it, and then<br />
transfer that contents to an <code>ImmutableArray&lt;T&gt;</code> which is frozen forevermore. In</p>
<p>150 CHAPTER 12 | Collections</p>
<p>allocation, while also speeding up the sort itself by removing several layers of indirection from every<br />
comparison.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sort</td>
<td>.NET 6.0</td>
<td>86.28 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Sort</td>
<td>.NET 7.0</td>
<td>67.17 us</td>
<td>0.78</td>
</tr>
</tbody>
</table>
<p>perspective because it means if you have your data in a span, you can get it into an</p>
<p><code>ImmutableArray&lt;T&gt;</code> without incurring additional allocations beyond the one the <code>ImmutableArray&lt;T&gt;</code><br />
[itself will create. dotnet/runtime#66550 from <a href="https://github.com/RaymondHuy">@RaymondHuy</a> also](https://github.com/dotnet/runtime/pull/66550)<br />
adds a bunch of new methods to the immutable collection builders, which provide efficient<br />
implementations for operations like replacing elements and adding, inserting, and removing ranges.</p>
<p><code>SortedSet&lt;T&gt;</code> also saw some improvements in .NET 7. For example, <code>SortedSet&lt;T&gt;</code> internally uses a<br />
<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red/black tree</a> as its internal data structure, and it uses a <code>Log2</code> operation to determine the maximum<br />
depth the tree could be for a given node count. Previously, that operation was implemented as a loop.<br />
[But thanks to dotnet/runtime#58793 from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a> that](https://github.com/dotnet/runtime/pull/58793)<br />
implementation is now simply a call to <code>BitOperations.Log2</code>, which is in turn implemented trivially in<br />
terms of one of multiple hardware intrinsics if they’re supported (e.g. <code>Lzcnt.LeadingZeroCount</code>,</p>
<p>streamlining how the iteration through the nodes in the tree is handled.</p>
<p>151 CHAPTER 12 | Collections</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>SortedSetCopy</td>
<td>.NET 6.0</td>
<td>2.397 us</td>
<td>1.00</td>
</tr>
<tr>
<td>SortedSetCopy</td>
<td>.NET 7.0</td>
<td>2.090 us</td>
<td>0.87</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/67923">One last PR to look at in collections: dotnet/runtime#67923.</a> <code>ConditionalWeakTable&lt;TKey, TValue&gt;</code><br />
is a collection most developers haven’t used, but when you need it, you need it. It’s used primarily for<br />
two purposes: to associate additional state with some object, and to maintain a weak collection of<br />
objects. Essentially, it’s a thread-safe dictionary that doesn’t maintain strong references to anything it<br />
stores but ensures that the value associated with a key will remain rooted as long as the associated<br />
key is rooted. It exposes many of the same APIs as <code>ConcurrentDictionary&lt;,&gt;</code>, but for adding items<br />
to the collection, it’s historically only had an <code>Add</code> method. That means if the design of the consuming<br />
code entailed trying to use the collection as a set, where duplicates were common, it would also be<br />
common to experience exceptions when trying to <code>Add</code> an item that already existed in the collection.<br />
Now in .NET 7, it has a <code>TryAdd</code> method, which enables such usage without potentially incurring the<br />
costs of such exceptions (and without needing to add <code>try/catch</code> blocks to defend against them).</p>
<p>152 CHAPTER 12 | Collections</p>
<p><strong>CHAPTER</strong></p>
<h1>13</h1>
<h2>LINQ</h2>
<p>Let’s move on to Language-Integrated Query (LINQ). LINQ is a productivity feature that practically<br />
every .NET developer uses. It enables otherwise complicated operations to be trivially expressed,<br />
whether via language-integrated query comprehension syntax or via direct use of methods on</p>
<p><code>System.Linq.Enumerable</code> . That productivity and expressivity, however, comes at a bit of an overhead<br />
cost. In the vast majority of situations, those costs (such as delegate and closure allocations, delegate<br />
invocations, use of interface methods on arbitrary enumerables vs direct access to indexers and</p>
<p><code>Length</code> / <code>Count</code> properties, etc.) don’t have a significant impact, but for really hot paths, they can and<br />
do show up in a meaningful way. This leads some folks to declare LINQ as being broadly off-limits in<br />
their codebases. From my perspective, that’s misguided; LINQ is extremely useful and has its place. In<br />
.NET itself, we use LINQ, we’re just practical and thoughtful about where, avoiding it in code paths<br />
we’ve optimized to be lightweight and fast due to expectations that such code paths could matter to<br />
consumers. And as such, while LINQ itself may not perform as fast as a hand-rolled solution, we still<br />
care a lot about the performance of LINQ’s implementation, so that it can be used in more and more<br />
places, and so that where it’s used there’s as little overhead as possible. There are also differences<br />
between operations in LINQ; with over 200 overloads providing various kinds of functionality, some of<br />
these overloads benefit from more performance tuning than do others, based on their expected<br />
usage.</p>
<p>arrays, but still improved performance even for short arrays (because the implementation is now able<br />
to access the array directly rather than going through the enumerable, leading to less allocation and<br />
interface dispatch and more applicable optimizations like inlining).</p>
<p>153 CHAPTER 13 | LINQ</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Length</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Min</td>
<td>.NET 6.0</td>
<td>4</td>
<td>26.167 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Min</td>
<td>.NET 7.0</td>
<td>4</td>
<td>4.788 ns</td>
<td>0.18</td>
<td>-</td>
<td>0.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Max</td>
<td>.NET 6.0</td>
<td>4</td>
<td>25.236 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Max</td>
<td>.NET 7.0</td>
<td>4</td>
<td>4.234 ns</td>
<td>0.17</td>
<td>-</td>
<td>0.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Min</td>
<td>.NET 6.0</td>
<td>1024</td>
<td>3,987.102 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Min</td>
<td>.NET 7.0</td>
<td>1024</td>
<td>101.830 ns</td>
<td>0.03</td>
<td>-</td>
<td>0.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Max</td>
<td>.NET 6.0</td>
<td>1024</td>
<td>3,798.069 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Max</td>
<td>.NET 7.0</td>
<td>1024</td>
<td>100.279 ns</td>
<td>0.03</td>
<td>-</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>One of the more interesting aspects of the PR, however, is one line that’s meant to help with the nonarray cases. In performance optimization, and in particular when adding “fast paths” to better handle<br />
certain cases, there’s almost always a winner and a loser: the winner is the case the optimization is<br />
intended to help, and the loser is every other case that’s penalized by whatever checks are necessary<br />
to determine whether to take the improved path. An optimization that special-cases arrays might<br />
normally look like:</p>
<p>However, if you look at the PR, you’ll see the <code>if</code> condition is actually:</p>
<pre><code>if (source.GetType() == typeof (int[]))

</code></pre>
<p>How come? Well at this point in the code flow, we know that source isn’t null, so we don’t need the<br />
extra null check that <code>is</code> will bring. However, that’s minor compared to the real impact here, that of</p>
<p>language disagree on aspects of the type system. If you change that</p>
<p>work as part of the type check than just a simple comparison against the known type identity of</p>
<p>154 CHAPTER 13 | LINQ</p>
<p><code>int[]</code> . We can see this by looking at the assembly generated for these two methods (the latter<br />
assumes we’ve already null-checked the input, which is the case in these LINQ methods):</p>
<p>This results in:</p>
<p>Note the former involves a method call to the JIT’s <code>CastHelpers.IsInstanceOfAny</code> helper method,<br />
and that it’s not inlined. That in turn impacts performance:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithIs</td>
<td>1.9246 ns</td>
<td>1.000</td>
<td>215 B</td>
</tr>
<tr>
<td>WithTypeCheck</td>
<td>0.0013 ns</td>
<td>0.001</td>
<td>24 B</td>
</tr>
</tbody>
</table>
<p>Of course, these two operations aren’t semantically equivalent, so if this was for something that<br />
required the semantics of the former, we couldn’t use the latter. But in the case of this LINQ<br />
performance optimization, we can choose to only optimize the <code>int[]</code> case, forego the super rare case</p>
<p>155 CHAPTER 13 | LINQ</p>
<p><a href="https://github.com/dotnet/runtime/pull/64624">This improvement was built upon further in dotnet/runtime#64624, which expands the input types</a><br />
supported and the operations that take advantage. First, it introduced a private helper for extracting a</p>
<p>form to avoid significantly penalizing other inputs. Both of these types enable extracting a</p>
<p>can do a few interesting things. This PR:</p>
<p>The effect of that is evident in microbenchmarks, e.g.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>.NET 6.0</td>
<td>39.067 us</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Sum</td>
<td>.NET 7.0</td>
<td>14.349 us</td>
<td>0.37</td>
<td>-</td>
<td>0.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Average</td>
<td>.NET 6.0</td>
<td>41.232 us</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<p>156 CHAPTER 13 | LINQ</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Average</td>
<td>.NET 7.0</td>
<td>14.378 us</td>
<td>0.35</td>
<td>-</td>
<td>0.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Min</td>
<td>.NET 6.0</td>
<td>45.522 us</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Min</td>
<td>.NET 7.0</td>
<td>9.668 us</td>
<td>0.21</td>
<td>-</td>
<td>0.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Max</td>
<td>.NET 6.0</td>
<td>41.178 us</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Max</td>
<td>.NET 7.0</td>
<td>9.210 us</td>
<td>0.22</td>
<td>-</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>The previous LINQ PRs were examples from making existing operations faster. But sometimes<br />
performance improvements come about from new APIs that can be used in place of previous ones in<br />
certain situations to further improve performance. One such example of that comes from new APIs<br />
[introduced in dotnet/runtime#70525 from <a href="https://github.com/deeprobin">@deeprobin</a> which were](https://github.com/dotnet/runtime/pull/70525)</p>
<p>spirit of pairs like <code>Distinct</code> and <code>DistinctBy</code>, perform that same sorting operation, just with an implicit</p>
<p><code>x =&gt; x</code> done on behalf of the caller. But beyond performance, a nice benefit of this is the<br />
implementation then knows that the keys will all be the same as the inputs, and it no longer needs to<br />
invoke the callback for each item to retrieve its key nor allocate a new array to store those keys. Thus<br />
if you find yourself using LINQ and reaching for <code>OrderBy(x =&gt; x)</code>, consider instead using <code>Order()</code><br />
and reaping the (primarily allocation) benefits:</p>
<p>157 CHAPTER 13 | LINQ</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Length</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>OrderBy</td>
<td>1024</td>
<td>68.74 us</td>
<td>1.00</td>
<td>12.3 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>Order</td>
<td>1024</td>
<td>66.24 us</td>
<td>0.96</td>
<td>8.28 KB</td>
<td>0.67</td>
</tr>
</tbody>
</table>
<p>158 CHAPTER 13 | LINQ</p>
<p><strong>CHAPTER</strong></p>
<h1>14</h1>
<h2>File I/O</h2>
<p>.NET 6 saw some huge file I/O improvements, in particular a complete rewrite of <code>FileStream</code> . While<br />
.NET 7 doesn’t have any single changes on that scale, it does have a significant number of<br />
improvements that measurably “move the needle,” and in variety of ways.</p>
<p>One form of performance improvement that also masquerades as a reliability improvement is<br />
increasing responsiveness to cancellation requests. The faster something can be canceled, the sooner<br />
the system is able to give back valuable resources in use, and the sooner things waiting for that<br />
operation to complete are able to be unblocked. There have been several improvements of this ilk in<br />
.NET 7.</p>
<p>In some cases, it comes from adding cancelable overloads where things weren’t previously cancelable</p>
<p><a href="https://github.com/dotnet/runtime/pull/66492">satisfies the required types of both). You can see this put to good use in dotnet/runtime#66492 from</a></p>
<p><a href="https://github.com/lateapexearlyspeed">@lateapexearlyspeed</a>, which adds a new</p>
<p>fully cancelable.</p>
<p>From my perspective, though, a more interesting form of this is when an existing overload is</p>
<p>up-front check for cancellation, such that if cancellation was requested prior to the call being made, it<br />
will be immediately canceled, but after that check the supplied <code>CancellationToken</code> is effectively<br />
ignored. Over time we’ve tried to stamp out all remaining such cases, but a few stragglers have<br />
remained. One pernicious case has been with pipes. For this discussion, there are two relevant kinds of<br />
pipes, anonymous and named, which are represented in .NET as pairs of streams:</p>
<p>between handles opened for synchronous I/O from handles opened for overlapped I/O (aka<br />
asynchronous I/O), and this is reflected in the .NET API: you can open a named pipe for synchronous<br />
or overlapped I/O based on the <code>PipeOptions.Asynchronous</code> option specified at construction. And, on</p>
<p>159 CHAPTER 14 | File I/O</p>
<p>Unix, named pipes, contrary to their naming, are actually implemented on top of Unix domain sockets.<br />
Now some history:</p>
<ul>
<li>
<p>.NET Framework 4.8: No cancellation support. The pipe <code>Stream</code> -derived types didn’t even<br />
override <code>ReadAsync</code> or <code>WriteAsync</code>, so all they got was the default up-front check for<br />
cancellation and then the token was ignored.</p>
</li>
<li>
<p>.NET Core 1.0: On Windows, with a named pipe opened for asynchronous I/O, cancellation was</p>
</li>
</ul>
<p>asynchronous operation. On Unix, with named pipes implemented in terms of sockets, if the pipe</p>
<p>token, and then looping around to do it again until either the <code>Poll</code> indicated the operation<br />
would succeed or cancellation was requested. On both Windows and Unix, other than a named<br />
pipe opened with <code>Asynchronous</code>, after the operation was initated, cancellation was a nop.</p>
<ul>
<li>.NET Core 2.1: On Unix, the implementation was improved to avoid the polling loop, but it still<br />
lacked a truly cancelable <code>Socket.ReceiveAsync</code> / <code>Socket.SendAsync</code> . Instead, by this point</li>
</ul>
<p>actually consuming it. The Unix implementation for asynchronous named pipe streams then<br />
changed to issue zero-byte reads, and would <code>await</code> a <code>Task.WhenAny</code> of both that operation’s<br />
task and a task that would be completed when cancellation was requested. Better, but still far<br />
from ideal.</p>
<ul>
<li>.NET Core 3.0: On Unix, <code>Socket</code> got truly cancelable <code>ReceiveAsync</code> and <code>SendAsync</code> methods,<br />
which asynchronous named pipes were updated to utilize. At this point, the Windows and Unix<br />
implementations were effectively on par with regards to cancellation; both good for<br />
asynchronous named pipes, and just posing for everything else.</li>
</ul>
<p>anonymous and named pipes, regardless of how they were opened.</p>
<p>So by .NET 5, the problem was addressed on Unix, but still an issue on Windows. Until now. In .NET 7,<br />
we’ve made the rest of the operations fully cancelable on Windows as well, thanks to<br />
<a href="https://github.com/dotnet/runtime/pull/72503">dotnet/runtime#72503</a> <a href="https://github.com/dotnet/runtime/pull/72612">(and a subsequent tweak in dotnet/runtime#72612). Windows doesn’t support</a><br />
overlapped I/O for anonymous pipes today, so for anonymous pipes and for named pipes opened for<br />
synchronous I/O, the Windows implementation would just delegate to the base <code>Stream</code><br />
implementation, which would queue a work item to the <code>ThreadPool</code> to invoke the synchronous<br />
counterpart, just on another thread. Instead, the implementations now queue that work item, but<br />
instead of just calling the synchronous method, it does some pre- and post- work that registers for<br />
cancellation, passing in the thread ID of the thread that’s about to perform the I/O. If cancellation is<br />
requested, the implementation then uses <code>CancelSynchronousIo</code> to interrupt it. There’s a race<br />
condition here, in that the moment the thread registers for cancellation, cancellation could be<br />
requested, such that <code>CancelSynchronousIo</code> could be called before the operation is actually initiated.</p>
<p>160 CHAPTER 14 | File I/O</p>
<p>So, there’s a small spin loop employed, where if cancellation is requested between the time<br />
registration occurs and the time the synchronous I/O is actually performed, the cancellation thread<br />
will spin until the I/O is initiated, but this condition is expected to be exceedingly rare. There’s also a<br />
race condition on the other side, that of <code>CancelSynchronousIo</code> being requested after the I/O has<br />
already completed; to address that race, the implementation relies on the guarantees made by</p>
<p><code>CancellationTokenRegistration.Dispose</code>, which promises that the associated callback will either<br />
never be invoked or will already have fully completed executing by the time <code>Dispose</code> returns. Not only<br />
does this implementation complete the puzzle such that all asynchronous read/write operations on<br />
both anonymous and named pipes on both Windows and Unix are cancelable, it also actually<br />
improves normal throughput.</p>
<p>161 CHAPTER 14 | File I/O</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Cancelable</th>
<th>Named</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 6.0</td>
<td>False</td>
<td>False</td>
<td>22.08 us</td>
<td>1.00</td>
<td>400 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 7.0</td>
<td>False</td>
<td>False</td>
<td>12.61 us</td>
<td>0.76</td>
<td>192 B</td>
<td>0.48</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 6.0</td>
<td>False</td>
<td>True</td>
<td>38.45 us</td>
<td>1.00</td>
<td>400 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 7.0</td>
<td>False</td>
<td>True</td>
<td>32.16 us</td>
<td>0.84</td>
<td>220 B</td>
<td>0.55</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 6.0</td>
<td>True</td>
<td>False</td>
<td>27.11 us</td>
<td>1.00</td>
<td>400 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 7.0</td>
<td>True</td>
<td>False</td>
<td>13.29 us</td>
<td>0.52</td>
<td>193 B</td>
<td>0.48</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 6.0</td>
<td>True</td>
<td>True</td>
<td>38.57 us</td>
<td>1.00</td>
<td>400 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 7.0</td>
<td>True</td>
<td>True</td>
<td>33.07 us</td>
<td>0.86</td>
<td>214 B</td>
<td>0.54</td>
</tr>
</tbody>
</table>
<p>The rest of the performance-focused changes around I/O in .NET 7 were primarily focused on one of<br />
two things: reducing syscalls, and reducing allocation.</p>
<p>Several PRs went into reducing syscalls on Unix as part of copying files, e.g. <code>File.Copy</code> and</p>
<p><code>FileInfo.CopyTo</code> [. dotnet/runtime#59695 from <a href="https://github.com/tmds">@tmds</a> reduced overheads](https://github.com/dotnet/runtime/pull/59695)<br />
in several ways. The code had been performing a <code>stat</code> call in order to determine up front whether the<br />
source was actually a directory, in which case the operation would error out. Instead, the PR simply<br />
tries to open the source file, which it would need to do anyway for the copy operation, and then it</p>
<p>now also extracts from the results of that single <code>fstat</code> the source file size, which it then threads<br />
through to the core copy routine, which itself is then able to avoid an <code>fstat</code> syscall it had been<br />
performing in order to get the size. Saving those syscalls is great, in particular for very small files<br />
where the overhead of setting up the copy can actually be more expensive than the actual copy of the<br />
bytes. But the biggest benefit of this PR is that it takes advantage of <code>IOCTL-FICLONERANGE</code> on Linux.<br />
Some Linux file systems, like XFS and Btrfs, support “copy-on-write,” which means that rather than<br />
copying all of the data to a new file, the file system simply notes that there are two different files<br />
pointing to the same data, sharing the underlying storage. This makes the “copy” super fast, since<br />
nothing actually needs to be copied and instead the file system just needs to update some<br />
bookkeeping; plus, less space is consumed on disk, since there’s just a single store of the data. The file<br />
system then only needs to actually copy data that’s overwritten in one of the files. This PR uses <code>ioctl</code><br />
and <code>FICLONE</code> to perform the copy as copy-on-write if the source and destination file system are the</p>
<p><code>copy_file_range</code> on Linux if it’s supported (and only if it’s a new enough kernel that it addresses</p>
<p>162 CHAPTER 14 | File I/O</p>
<p>some issues the function had in previous releases). Unlike a typical read/write loop that reads the data<br />
from the source and then writes it to the destination, <code>copy_file_range</code> is implemented to stay<br />
entirely in kernel mode, without having to transition to user space for each read and write.</p>
<p>data from a file, and hints to OS caching to expect data to be read from the file sequentially rather<br />
than randomly. However, these write/append methods don’t read, they only write, and the</p>
<p>benefiting from it. This situation is akin to the famous Henny Youngman joke: “The patient says,<br />
‘Doctor, it hurts when I do this’; the doctor says, ‘Then don’t do that!’.” Here, too, the answer is “don’t</p>
<p>Directory handling has seen reduced syscalls across the directory lifecycle, especially on Unix.<br />
<a href="https://github.com/dotnet/runtime/pull/58799">dotnet/runtime#58799</a> from <a href="https://github.com/tmds">@tmds</a> speeds up directory creation on Unix.<br />
Previously, the implementation of directory creation would first check to see if the directory already<br />
existed, which involves a syscall. In the expected minority case where it already existed the code could<br />
early exit out. But in the expected more common case where the directory didn’t exist, it would then<br />
parse the file path to find all of the directories in it, walk up the directory list until it found one that<br />
did exist, and then try to create all of the subdirectories back down through the target one. However,<br />
the expected most common case is the parent directories already exist and the child directory doesn’t,<br />
in which case we’re still paying for all that parsing when we could have just created the target<br />
directory. This PR addresses that by changing the up-front existence check to instead simply try to</p>
<p><code>mkdir</code> the target directory; if it succeeds, great, we’re done, and if it fails, the error code from the<br />
failure can be used instead of the existence check to know whether <code>mkdir</code> failed because it had no<br />
<a href="https://github.com/dotnet/runtime/pull/61777">work to do. dotnet/runtime#61777 then takes this a step further and avoids string allocations while</a><br />
creating directories by using stack memory for the paths temporarily needed to pass to <code>mkdir</code> .</p>
<p><a href="https://github.com/dotnet/runtime/pull/63675">dotnet/runtime#63675</a> then improves the performance of moving directories, on both Unix and<br />
Windows, removing several syscalls. The shared code for <code>Directory.Move</code> and <code>DirectorInfo.MoveTo</code><br />
was doing explicit directory existence checks for the source and destination locations, but on<br />
Windows the Win32 API called to perform the move does such checks itself, so they’re not needed<br />
preemptively. On Unix, we can similarly avoid the existence check for the source directory, as the</p>
<p><code>rename</code> function called will similarly simply fail if the source doesn’t exist (with an appropriate error<br />
that let’s us deduce what went wrong so the right exception can be thrown), and for the destination,<br />
the code had been issuing separate existence checks for whether the destination existed as a directory<br />
or as a file, but a single <code>stat</code> call suffices for both.</p>
<p>163 CHAPTER 14 | File I/O</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Move</td>
<td>.NET 6.0</td>
<td>31.70 us</td>
<td>1.00</td>
<td>256 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Move</td>
<td>.NET 7.0</td>
<td>26.31 us</td>
<td>0.83</td>
<td>-</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>[And then also on Unix, dotnet/runtime#59520 from <a href="https://github.com/tmds">@tmds</a> improves](https://github.com/dotnet/runtime/pull/59520)<br />
directory deletion, and in particular recursive deletion (deleting a directory and everything it contains<br />
and everything they contain and so on), by utilizing the information already provided by the file<br />
system enumeration to avoid a secondary existence check.</p>
<p>to determine whether the specified file already exists; that’s because later in the method as part of<br />
dealing with errors and exceptions, the implementation needs to know whether to delete the file that</p>
<p>than <code>Open</code> or <code>CreateNew</code>, which means we can trivially avoid the extra system call in the majority case.<br />
<a href="https://github.com/dotnet/runtime/pull/63790">dotnet/runtime#63790</a> also helps here, in two ways. First, throughout the <code>CreateFromFile</code> operation,<br />
the implementation might access the <code>FileStream</code> ’s <code>Length</code> multiple times, but each call results in a<br />
syscall to read the underlying length of the file. We can instead read it once and use that one value for</p>
<p>the superfluous <code>FileStream</code> and its supporting state. This helps to reduce allocations.</p>
<p>but the practical implication of this is that closing either needn’t bother flushing, since that view<br />
couldn’t have changed any data in the implementation, and flushing a view can be relatively<br />
expensive, especially for larger views. Thus, a simple change to avoid flushing if the view isn’t writable<br />
can yield a measurable improvement to <code>MemoryMappedViewAccessor</code> / <code>MemoryMappedviewStream</code> ’s</p>
<p><code>Dispose</code> .</p>
<p>164 CHAPTER 14 | File I/O</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>MMF</td>
<td>.NET 6.0</td>
<td>315.7 us</td>
<td>1.00</td>
<td>488 B</td>
<td>1.00</td>
</tr>
<tr>
<td>MMF</td>
<td>.NET 7.0</td>
<td>227.1 us</td>
<td>0.68</td>
<td>336 B</td>
<td>0.69</td>
</tr>
</tbody>
</table>
<p>Beyond system calls, there have also been a plethora of improvements around reducing allocation.</p>
<p>things: one, that these operations are common enough that it’s worth avoiding the small-butmeasurable overhead of going through a <code>FileStream</code> and instead just going directly to the<br />
underlying <code>SafeFileHandle</code>, and, two, that since the methods are passed the entirety of the payload<br />
to output, the implementation can use that knowledge (in particular for length) to do better than the</p>
<p><code>StreamWriter</code> that was previously employed. In doing so, the implementation avoids the overheads<br />
(primarily in allocation) of the streams and writers and temporary buffers.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WriteAllText</td>
<td>.NET 6.0</td>
<td>488.5 us</td>
<td>1.00</td>
<td>9944 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WriteAllText</td>
<td>.NET 7.0</td>
<td>482.9 us</td>
<td>0.99</td>
<td>392 B</td>
<td>0.04</td>
</tr>
</tbody>
</table>
<p>165 CHAPTER 14 | File I/O</p>
<p>additional syscall can measure up to 10% of the total cost (and for larger files, modern kernels are<br />
pretty good about caching even without a sequentiality hint, so there’s little downside measured<br />
there).</p>
<p>wrapped each string in a span and delegated to the span-based overloads. However, in the event that<br />
the join operation is a nop (e.g. there are two path segments and the second is empty so the join<br />
should just return the first), the span-based implementation still needs to create a new string (there’s<br />
no way for the <code>ReadOnlySpan&lt;char&gt;</code> -based overloads to extract a string from the span). As such, the</p>
<p><code>string</code> -based overloads can do a little bit better in the case of one of them being null or empty; they<br />
can do the same thing the <code>Path.Combine</code> overloads do, which is to have the M argument overload<br />
delegate to the M-1 argument overload, filtering out a null or empty, and in the base case of the<br />
overload with two arguments, if a segment is null or empty, the other (or empty) can just be returned<br />
directly.</p>
<p><a href="https://github.com/dotnet/runtime/pull/69335">Beyond that, there are a multitude of allocation-focused PRs, such as dotnet/runtime#69335 from</a></p>
<p><a href="https://github.com/pedrobsaila">@pedrobsaila</a> which adds a fast-path based on stack allocation to<br />
the internal <code>ReadLink</code> helper that’s used on Unix anywhere we need to follow symlinks, or</p>
<p><a href="https://github.com/dotnet/runtime/pull/69272">But my personal favorite improvement in this area come from dotnet/runtime#69272, which adds a</a><br />
few new helpers to <code>Stream</code> :</p>
<p>In fairness, these are more about usability than they are about performance, but in this case there’s a<br />
tight correlation between the two. It’s very common to write these helpers one’s self (the<br />
aforementioned PR deleted many open-coded loops for this functionality from across the core<br />
libraries) as the functionality is greatly needed, and it’s unfortunately easy to get them wrong in ways</p>
<p>166 CHAPTER 14 | File I/O</p>
<p>that negatively impact performance, such as by using a <code>Stream.ReadAsync</code> overload that needs to<br />
allocate a returned <code>Task&lt;int&gt;</code> or reading fewer bytes than is allowed as part of a read call. These<br />
implementations are correct and efficient.</p>
<p>167 CHAPTER 14 | File I/O</p>
<p><strong>CHAPTER</strong></p>
<h1>15</h1>
<h2>Compression</h2>
<p>on top of. For the most part, these types just provide wrappers around a native C implementation<br />
<a href="https://github.com/google/brotli">from google/brotli, and so while the .NET layer has the opportunity to improve how data is moved</a><br />
around, managed allocation, and so on, the speed and quality of the compression itself are largely at<br />
the mercy of the C implementation and the intricacies of the Brotli algorithm.</p>
<p>As with many compression algorithms, Brotli provides a knob that allows for a quintessential tradeoff<br />
to be made between compression speed (how fast data can be compressed) and compression<br />
quality/ratio (how small can the compressed output be made). The hand-wavy idea is the more time<br />
the algorithm spends looking for opportunity, the more space can be saved. Many algorithms expose<br />
this as a numerical dial, in Brotli’s case going from 0 (fastest speed, least compression) to 11 (spend as<br />
much time as is needed to minimize the output size). But while <code>BrotliEncoder</code> surfaces that same</p>
<p>value when one is.</p>
<p>For better or worse (and I’m about to argue “much worse”), the native C implementation itself defines</p>
<p>value is poorly named. It’s intended to represent a good default that’s a balanced tradeoff between<br />
speed and quality; that’s exactly what it means for <code>DeflateStream</code>, <code>GZipStream</code>, and <code>ZLibStream</code> . But<br />
for <code>BrotliStream</code>, as the default it similarly got translated to mean the underlying native library’s</p>
<p>default, you’re getting the dial turned all the way up to 11.</p>
<p>Is that so bad? Maybe compression quality is the most important thing? For example, reducing the<br />
size of data can make it faster to then transmit it over a wire, and with a slow connection, size then<br />
meaningfully translates into end-to-end throughput.</p>
<p>The problem is just how much this extra effort costs. Compression speed and ratio are highly<br />
dependent on the data being compressed, so take this example with a small grain of salt as it’s not<br />
entirely representative of all use, but it’s good enough for our purposes. Consider this code, which</p>
<p>168 CHAPTER 15 | Compression</p>
<p>uses <code>BrotliEncoder</code> <a href="https://www.gutenberg.org/cache/epub/100/pg100.txt">to compress the The Complete Works of William Shakespeare from Project</a><br />
<a href="https://www.gutenberg.org/cache/epub/100/pg100.txt">Gutenberg</a> at varying levels of compression:</p>
<p>169 CHAPTER 15 | Compression</p>
<p>The code is measuring how long it takes to compress the input data at each of the levels (doing a<br />
warmup and then averaging several iterations), timing how long it takes and capturing the resulting<br />
compressed data size. For the size, I get values like this:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Size (bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2,512,855.00</td>
</tr>
<tr>
<td>1</td>
<td>2,315,466.00</td>
</tr>
<tr>
<td>2</td>
<td>2,224,638.00</td>
</tr>
<tr>
<td>3</td>
<td>2,218,328.00</td>
</tr>
<tr>
<td>4</td>
<td>2,027,153.00</td>
</tr>
<tr>
<td>5</td>
<td>1,964,810.00</td>
</tr>
<tr>
<td>6</td>
<td>1,923,456.00</td>
</tr>
<tr>
<td>7</td>
<td>1,889,927.00</td>
</tr>
<tr>
<td>8</td>
<td>1,863,988.00</td>
</tr>
<tr>
<td>9</td>
<td>1,846,685.00</td>
</tr>
<tr>
<td>10</td>
<td>1,741,561.00</td>
</tr>
<tr>
<td>11</td>
<td>1,702,214.00</td>
</tr>
</tbody>
</table>
<p>That’s a fairly liner progression from least to most compression. That’s not the problem. This is the<br />
problem:</p>
<p>170 CHAPTER 15 | Compression</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Time<br>(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>24.11</td>
</tr>
<tr>
<td>1</td>
<td>36.67</td>
</tr>
<tr>
<td>2</td>
<td>64.13</td>
</tr>
<tr>
<td>3</td>
<td>73.72</td>
</tr>
<tr>
<td>4</td>
<td>146.41</td>
</tr>
<tr>
<td>5</td>
<td>257.12</td>
</tr>
<tr>
<td>6</td>
<td>328.54</td>
</tr>
<tr>
<td>7</td>
<td>492.81</td>
</tr>
<tr>
<td>8</td>
<td>702.38</td>
</tr>
<tr>
<td>9</td>
<td>892.08</td>
</tr>
<tr>
<td>10</td>
<td>4,830.32</td>
</tr>
<tr>
<td>11</td>
<td>10,634.88</td>
</tr>
</tbody>
</table>
<p>This chart shows an almost exponential increase in processing time as we near the upper end of the<br />
dial, with quality level 11 compressing ~33% better than quality level 0 but taking ~440x as long to</p>
<p>represent a fairly balanced trade-off between size and speed.</p>
<p>171 CHAPTER 15 | Compression</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Compress</td>
<td>.NET 6.0</td>
<td>9,807.0 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>Compress</td>
<td>.NET 7.0</td>
<td>133.1 ms</td>
<td>0.01</td>
</tr>
</tbody>
</table>
<p><code>System.IO.Packaging</code> <a href="https://github.com/dotnet/runtime/pull/73082">, and dotnet/runtime#73082 updating the zlib implementations shipped as part</a><br />
of .NET from v1.2.11 (which was released in January 2017) to v1.2.12 (which was released in March<br />
2022).</p>
<p>172 CHAPTER 15 | Compression</p>
<p><strong>CHAPTER</strong></p>
<h1>16</h1>
<h2>Networking</h2>
<p>Networking is the life-blood of almost every service, with performance being critical to success. In<br />
previous releases, a lot of effort was focused on the lower layers of the networking stack, e.g. .NET 5<br />
saw a significant investment in improving the performance of sockets on Linux. In .NET 7, much of the<br />
effort is above sockets.</p>
<p>That said, there were some interesting performance improvements in sockets itself for .NET 7. One of</p>
<p>complicated to use well, it’s relatively inefficient, resulting in allocation for every single operation<br />
performed (at a minimum for the <code>IAsyncResult</code> object that’s returned from the <code>BeginXx</code> method). To<br />
help make networking operations more efficient, <code>SocketsAsyncEventArgs</code> was introduced.</p>
<p><code>SocketsAsyncEventArgs</code> is a reusable class you allocate to hold all of the state associated with<br />
asynchronous operations: allocate one, pass it to various async methods (e.g. <code>ReceiveAsync</code> ), and<br />
then completion events are raised on the <code>SocketAsyncEventArgs</code> instance when the operation<br />
completes. It can be quite efficient when used correctly, but it’s also complicated to use correctly. In</p>
<p>covers, and so while most code these days isn’t written to use <code>SocketAsyncEventArgs</code> directly, it’s still<br />
very relevant from a performance perspective.</p>
<p><code>SocketAsyncEventArgs</code> on Windows is implemented to use winsock and overlapped I/O. When you</p>
<p>was introduced in earlier releases of .NET Core, and it enables a significant number of socket<br />
operations, in particular sends and receives, to complete synchronously, which in turn saves<br />
unnecessary trips through the thread pool, unnecessary unwinding of async state machines, and so<br />
on. But it also causes a condundrum. There are some operations we want to perform associated with<br />
asynchronous operation but that have additional overhead, such as registering for the cancellation of<br />
those operations, and we don’t want to pay the cost of doing them if the operation is going to<br />
complete synchronously. That means we really want to delay performing such registration until after<br />
we’ve made the native call and discovered the operation didn’t complete synchronously… but at that<br />
point we’ve already initiated the operation, so if it <em>doesn’t</em> complete synchronously, then we’re now in</p>
<p>173 CHAPTER 16 | Networking</p>
<p>a potential race condition, where our code that’s still setting up the asynchronous operation is racing<br />
with it potentially completing in a callback on another thread. Fun. <code>SocketAsyncEventArgs</code> handled<br />
this race condition with a spin lock; the theory was that contention would be incredibly rare, as the<br />
vast majority cases would either be the operation completing synchronously (in which case there’s no<br />
other thread involved) or asynchronously with enough of a delay that the small amount of additional<br />
work performed by the initiating thread would have long ago completed by the time the<br />
asynchronous operation completed. And for the most part, that was true. However, it turns out that<br />
it’s actually much more common than expected for certain kinds of operations, like Accepts. Accepts<br />
end up almost always completing asynchronously, but if there’s already a pending connection,<br />
completing asynchronously almost immediately, which then induces this race condition to happen<br />
more frequently and results in more contention on the spin locks. Contention on a spin lock is<br />
something you really want to avoid. And in fact, for a particular benchmark, this spin lock showed up<br />
as the cause for an almost 300% slowdown in requests-per-second (RPS) for a benchmark that used a<br />
dedicated connection per request (e.g. with every response setting “Connection: close”).<br />
<a href="https://github.com/dotnet/runtime/pull/64770">dotnet/runtime#64770</a> changed the synchronization mechanism to no longer involve a spin lock;<br />
instead, it maintains a simple gate implemented as an <code>Interlocked.CompareExchange</code> . If the initiating<br />
thread gets to the gate first, from that point on the operation is considered asynchronous and any<br />
additional work is handled by the completing callback. Conversely, if the callback gets to the gate first,<br />
the initiating thread treats the operation as if it completed synchronously. This not only avoids one of<br />
the threads spinning while waiting for the other to make forward progress, it also increases the<br />
number of operations that end up being handled as synchronous, which in turn reduces other costs<br />
(e.g. the code <code>await</code> ing the task returned from this operation doesn’t need to hook up a callback and<br />
exit, and can instead itself continue executing synchronously). The impact of this is difficult to come<br />
up with a microbenchmark for, but it can have meaningful impact for loaded Windows servers that<br />
end up accepting significant numbers of connections in steady state.</p>
<p>comparing spans, doing it byte-by-byte is also much less efficient than the vectorized implementation</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Equals_Same</td>
<td>.NET 6.0</td>
<td>57.659 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Equals_Same</td>
<td>.NET 7.0</td>
<td>4.435 ns</td>
<td>0.08</td>
</tr>
</tbody>
</table>
<p>174 CHAPTER 16 | Networking</p>
<p>Let’s move up to some more interesting changes in the layers above <code>Sockets</code>, starting with</p>
<p><code>SslStream</code> .</p>
<p>One of the more impactful changes to <code>SslStream</code> on .NET 7 is in support for TLS resumption on Linux.<br />
When a TLS connection is established, the client and server engage in a handshake protocol where<br />
they collaborate to decide on a TLS version and cipher suites to use, authenticate and validate each<br />
other’s identity, and create symmetric encryption keys for use after the handshake. This represents a<br />
significant portion of the time required to establish a new connection. For a client that might<br />
disconnect from a server and then reconnect later, as is fairly common in distributed applications, TLS<br />
resumption allows a client and server to essentially pick up where they left off, with the client and/or<br />
server storing some amount of information about recent connections and using that information to<br />
resume. Windows SChannel provides default support for TLS resumption, and thus the Windows<br />
implementation of <code>SslStream</code> (which is built on SChannel) has long had support for TLS resumption.<br />
But OpenSSL’s model requires additional code to enable TLS resumption, and such code wasn’t<br />
present in the Linux implementation of <code>SslStream</code> <a href="https://github.com/dotnet/runtime/pull/57079">. With dotnet/runtime#57079</a> and<br />
<a href="https://github.com/dotnet/runtime/pull/63030">dotnet/runtime#63030, .NET 7 adds server-side support for TLS resumption (using the variant that</a><br />
<em>doesn’t</em> <a href="https://github.com/dotnet/runtime/pull/64369">require storing recent connection state on the server), and with dotnet/runtime#64369, .NET 7</a><br />
adds client-side support (which <em>does</em> require storing additional state). The effect of this is significant, in<br />
particular for a benchmark that opens and closes lots of connections between clients.</p>
<p>175 CHAPTER 16 | Networking</p>
<p>176 CHAPTER 16 | Networking</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Handshake</td>
<td>.NET 6.0</td>
<td>4.647 ms</td>
<td>1.00</td>
<td>19.27 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>Handshake</td>
<td>.NET 7.0</td>
<td>2.314 ms</td>
<td>0.50</td>
<td>9.56 KB</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>Another significant improvement for <code>SslStream</code> in .NET 7 is support for OCSP stapling. When a client<br />
handshakes with the server and the server shares its certificate, a client that cares about validating it’s<br />
talking to exactly who it intended to talk to needs to validate that certificate. In the days of yore, such<br />
validation was done with certificate revocation lists (CRL), where periodically the client would<br />
download a giant list of certificates known to be revoked. Online Certificate Status Protocol (OCSP) is<br />
a newer protocol and mechanism that enables a client to get real-time information about a certificate;<br />
while the client handshakes with the server and the server sends the client its certificate, the client<br />
then connects to an “OCSP responder” and sends it a request to determine whether the certificate is<br />
considered good. OCSP has multiple issues of its own, however. In particular, it places a significant<br />
load on these OCSP responder servers, with every client making a real-time request to it about every<br />
certificate encountered, and also potentially significantly increasing the time it takes the client to<br />
establish a connection. OCSP stapling offers a solution to this. Rather than a client issuing a request to</p>
<p>177 CHAPTER 16 | Networking</p>
<p>the OCSP responder, the server itself contacts the OCSP responder and gets a signed ticket from the<br />
OCSP responder stating that the server’s certificate is good and will be for some period of time. When<br />
a client handshakes with the server, the server can then “staple” (include) this signed ticket as part of<br />
its response to the client, giving the validation to the client directly rather than the client needing to<br />
make a separate roundtrip to the OCSP responder. This reduces overheads for everyone involved.<br />
<a href="https://github.com/dotnet/runtime/pull/67011">dotnet/runtime#67011</a> adds support for OCSP stapling to <code>SslStream</code> client usage on Linux, with<br />
<a href="https://github.com/dotnet/runtime/pull/69833">dotnet/runtime#69833</a> <a href="https://github.com/dotnet/runtime/pull/71570">adding the Linux server-side counterpart, and dotnet/runtime#71570 adds</a><br />
client-side support for Windows.</p>
<p>The aforementioned changes are primarily about the performance of opening a connection.<br />
<a href="https://github.com/dotnet/runtime/pull/69527">Additional work has been done to improve that further in other ways. dotnet/runtime#69527 gets rid</a><br />
of allocations associated with several <code>SafeHandle</code> instances that were being created unnecessarily on<br />
Linux as part of establishing a TLS connection. This highlights the benefits of doing profiling on<br />
multiple platforms, as while these <code>SafeHandle</code> s were necessary in the Windows implementation, they<br />
were fairly meaningless in the Linux implementation (due to differences between SChannel and<br />
OpenSSL), and were only brought along for the ride because of how the platform-abstraction layer<br />
(PAL) was defined to reuse most of the <code>SslStream</code> <a href="https://github.com/dotnet/runtime/pull/68188">code across platforms. And dotnet/runtime#68188</a><br />
avoids several collections allocated as part of the TLS handshake. This one is particularly interesting as<br />
it’s come up multiple times in the past in various libraries. Imagine you have a lazily initialized<br />
property like this:</p>
<p>And then some code in the same implementation comes along and wants to read the contents of<br />
these items. That code might look like:</p>
<pre><code>if (Items.Count &gt; 0) { ... }

</code></pre>
<p>but the very act of accessing <code>Items</code> just to check its count forces the collection into existence (with a 0</p>
<p><code>Count</code> ). If the code instead checks:</p>
<pre><code>if (_items is List&lt;T&gt; items &amp;&amp; items.Count &gt; 0) { ... }

</code></pre>
<p>It can save that unnecessary collection allocation. The approach is made even simpler with C# pattern<br />
matching:</p>
<pre><code>if (_items is { Count: &gt; 0 }) items) { ... }

</code></pre>
<p>This is one of those things that’s incredibly obvious once you “see” it and realize what’s happening,<br />
but you often miss until it jumps out at you in a profiler.</p>
<p><a href="https://github.com/dotnet/runtime/pull/69098">dotnet/runtime#69098</a> is another good example of how profiling can lead to insights about<br />
allocations that can be removed. Application-Layer Protocol Negotation (ALPN) allows code<br />
establishing a TLS connection to piggy-back on the roundtrips that are being used for the TLS<br />
handshake anyway to negotiate some higher-level protocol that will end up being used as well. A very<br />
common use-case, for example, is for an HTTPS client/server to negotiate which version of HTTP</p>
<p>178 CHAPTER 16 | Networking</p>
<p>by far the most common byte sequences are equivalent to “http/1.1” for HTTP/1.1, “h2” for HTTP/2,<br />
and “h3” for HTTP/3. Thus, it makes sense to special-case those values and use a reusable cached</p>
<p><code>byte[]</code> singleton when one of those values is needed. If <code>SslApplicationProtocol</code> exposed the<br />
underlying <code>byte[]</code> directly to consumers, we’d be hesitant to use such singletons, as doing so would<br />
mean that if code wrote into the <code>byte[]</code> it would potentially be changing the value for other<br />
consumers in the same process. However, <code>SslApplicationProtocol</code> exposes it as a</p>
<p><code>SslStream</code> . It uses stack memory instead of an array allocation for protocols up to 256 bytes in length,<br />
which is way larger than any in known use, and thus doesn’t bother to do anything fancy for the<br />
<a href="https://github.com/dotnet/runtime/pull/69103">fallback path, which will never be used in practice. And dotnet/runtime#69103</a> further avoids ALPNrelated allocations and work on Windows by entirely skipping some unnecessary code paths: various<br />
methods can be invoked multiple times during a TLS handshake, but even though the ALPN-related<br />
work only needed to happen once the first time, the code wasn’t special-casing it and was instead<br />
repeating the work over and over.</p>
<p>Everything discussed thus far was about establishing connections. What about the performance of<br />
reading and writing on that connection? Improvements have been made there, too, in particular<br />
around memory management and asynchrony. But first we need some context.</p>
<p>When <code>async/await</code> were first introduced, <code>Task</code> and <code>Task&lt;TResult&gt;</code> were the only game in town; while<br />
the pattern-based mechanism the compiler supports for arbitrary “task-like” types enabled <code>async</code><br />
methods to return other types, in practice it was only tasks (which also followed our guidance). We<br />
soon realized, however, that a significant number of calls to a significant number of commonly-used<br />
async APIs would actually complete synchronously. Consider, for example, a method like</p>
<p><code>MemoryStream.ReadAsync</code> : <code>MemoryStream</code> is backed entirely by an in-memory buffer, so even though<br />
the operation is “async,” every call to it completes synchronously, as the operation can be performed</p>
<p>actual native call with its own much larger buffer, which by default is 4K. The first time you issue your<br />
16-byte read, actual I/O will be required and the operation is likely to complete asynchronously. But<br />
the next 255 calls you make could simply end up draining the remainder of the data read into that 4K<br />
buffer, in which case 255 of the 256 “async” operations actually complete synchronously. If the</p>
<p>devised to minimize this, e.g. if the <code>int</code> is one of a few well-known values (e.g. -1 through 8), then the<br />
async method infrastructure will hand back a pre-allocated and cached <code>Task&lt;int&gt;</code> instance for that<br />
value, and various stream implementations (including <code>FileStream</code> ) would cache the previouslyreturned <code>Task&lt;int&gt;</code> and hand it back for the next call as well if the next call yielded exactly the same<br />
number of bytes. But those optimizations don’t fully mitigate the issue. Instead, we introduced the</p>
<p><code>ValueTask&lt;TResult&gt;</code> struct and provided the necessary “builder” to allow <code>async</code> methods to return</p>
<p>179 CHAPTER 16 | Networking</p>
<p>them. <code>ValueTask&lt;TResult&gt;</code> was simply a discrimated union between a <code>TResult</code> and <code>Task&lt;TResult&gt;</code> . If<br />
an async method completed asynchronously (or if it failed synchronously), well, it would simply</p>
<p>allocation overhead for the synchronously-completing case. Yay, everyone’s happy. Well, almost<br />
everyone. For really hot paths, especially those lower down in the stack that many other code paths<br />
build on top of, it can also be beneficial to avoid the allocations even for the asynchronously<br />
completing case. To address that, .NET Core 2.1 saw the introduction of the</p>
<p>can implement this interface with whatever behaviors they want, although we codified the typical<br />
implementation of the core async logic into the <code>ManualResetValueTaskSourceCore</code> helper struct,<br />
which is typically embedded into some object, with the interface methods delegating to<br />
corresponding helpers on the struct. Why would someone want to do this? Most commonly, it’s to be<br />
able to reuse the same instance implementing this interface over and over and over. So, for example,</p>
<p>allocation-free (there is another instance used for <code>SendAsync</code>, such that you can have a concurrent<br />
read and write on the socket and still avoid allocations). However, implementing this support is still<br />
non-trivial, and can be super hard when dealing with an operation that’s composed of multiple<br />
suboperations, which is exactly where <code>async/await</code> shine. Thus, C# 10 added support for overriding<br />
the default builder that’s used on an individual async method (e.g. such that someone could provide<br />
their own builder for a <code>ValueTask&lt;int&gt;</code> -returning method instead of the one that allocates <code>Task&lt;int&gt;</code><br />
instances for asynchronous completion) and .NET 6 included the new</p>
<pre><code>public async ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer) { ... }

</code></pre>
<p>can be changed to be:</p>
<p>which will cause the C# compiler to emit the implementation of this method using</p>
<p><em>most</em> of the allocation asynchronous completion would otherwise experience (I say “most” because<br />
the pooling by design tries to balance all the various costs involved and may still sometimes allocate),<br />
and makes it easy for methods implemented with <code>async</code> / <code>await</code> to reap those benefits. So, if this was<br />
all introduced in the last release, why am I talking about it now? Pooling isn’t free. There are various</p>
<p>180 CHAPTER 16 | Networking</p>
<p>tradeoffs involved in its usage, and while it can make microbenchmarks look really good, it can also<br />
negatively impact real-world usage, e.g. by increasing the cost of garbage collections that do occur by<br />
increasing the number of Gen2 to Gen0 references that exist. As such, while the functionality is<br />
valuable, we’ve been methodical in where and how we use it, choosing to do so more slowly and only<br />
employing it after sufficient analysis deems it’s worthwhile.</p>
<p>Such is the case with <code>SslStream</code> <a href="https://github.com/dotnet/runtime/pull/69418">. With dotnet/runtime#69418, two core and hot</a> <code>async</code> methods on</p>
<p><code>SslStream</code> ’s read path were annotated to use pooling. A microbenchmark shows what I mean when I<br />
wrote this can make microbenchmarks look really good (focus on the allocation columns). This<br />
benchmark is repeatedly issuing a read (that will be forced to complete asynchronously because<br />
there’s no available data to satisfy it), then issuing a write to enable that read to complete, and then</p>
<p><code>await</code> ing the read’s completion; every read thus completes asynchronously.</p>
<p>181 CHAPTER 16 | Networking</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 6.0</td>
<td>68.34 ms</td>
<td>1.00</td>
<td>510 B</td>
<td>336404 B</td>
<td>1.000</td>
</tr>
<tr>
<td>ReadWriteAsync</td>
<td>.NET 7.0</td>
<td>69.60 ms</td>
<td>1.02</td>
<td>514 B</td>
<td>995 B</td>
<td>0.003</td>
</tr>
</tbody>
</table>
<p>One final change related to reading and writing performance on an <code>SslStream</code> . I find this one<br />
particularly interesting, as it highlights a new and powerful C# 11 and .NET 7 feature: static abstract<br />
members in interfaces. <code>SslStream</code>, as with every <code>Stream</code>, exposes both synchronous and asynchronous<br />
methods for reading and writing. And as you may be aware, the code within <code>SslStream</code> for<br />
implementing reads and writes is not particularly small. Thus, we really want to avoid having to<br />
duplicate all of the code paths, once for synchronous work and once for asynchronous work, when in<br />
reality the only place that bifurcation is needed is at the leaves where calls into the underlying <code>Stream</code><br />
are made to perform the actual I/O. Historically, we’ve had two different mechanisms we’ve employed</p>
<p>at the leaves, e.g.</p>
<p>This way most of the logic and code is shared, and when useAsync is false, everything completes<br />
synchronously and so we don’t pay for allocation that might otherwise be associated with the <code>async</code> ness. The other approach is similar in spirit, but instead of a <code>bool</code> parameter, taking advantage of<br />
generic specialization and interface-implementing structs. Consider an interface like:</p>
<p>182 CHAPTER 16 | Networking</p>
<p>We can then declare two implementations of this interface:</p>
<p>Then we can redeclare our earlier example as:</p>
<p>Note that the generic constraint on the <code>TReader</code> parameter here allows the implementation to invoke<br />
the interface methods, and passing the structs as a generic avoids boxing. One code path supporting<br />
both sync and async implementations.</p>
<p>This latter generic approach is how <code>SslStream</code> has historically handled the unification of its sync and<br />
async implementations. It gets better in .NET 7 with C# 11 now that we have static abstract methods<br />
in interfaces. We can instead declare our interface as (note the <code>static abstract</code> addition):</p>
<p>our types as (note the <code>static</code> addition):</p>
<p>183 CHAPTER 16 | Networking</p>
<p>and our consuming methods as (note the removal of the parameter and the switch to calling static<br />
methods on the type parameter):</p>
<p>Not only is this cleaner, but from a performance perspective we no longer need to pass around the<br />
dummy generic parameter, which is general goodness, but for an async method it’s particularly<br />
beneficial because the state machine type ends up storing all parameters as fields, which means every<br />
parameter can increase the amount of allocation incurred by an async method if the method ends up<br />
<a href="https://github.com/dotnet/runtime/pull/65239">completing asynchronously. dotnet/runtime#65239</a> flipped <code>SslStream</code> (and <code>NegotiateStream</code> ) to<br />
follow this approach. It’s also used in multiple other places now throughout dotnet/runtime.</p>
<p>way to abstract over DFA and NFA-based operations using the same code (this technique was since<br />
further utilized in <code>NonBacktracking</code> <a href="https://github.com/dotnet/runtime/pull/71234">, such as by dotnet/runtime#71234</a> from</p>
<p>functionality: searching forward or backwards, and with equality or inequality. While more challenging<br />
to try to unify the directional aspect, this PR utilized this same kind of generic specialization to hide<br />
behind an interface the ability to negate the comparison; the core implementations of these methods</p>
<p>optimizations of the non- <code>Except</code> varieties, but also the goal of trying to make everything consistent<br />
resulted in finding places where we were missing optimization opportunities in existing methods<br />
(gaps that the PR also rectified).</p>
<p>184 CHAPTER 16 | Networking</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>LastIndexOfAny</td>
<td>.NET 6.0</td>
<td>9.977 us</td>
<td>1.00</td>
</tr>
<tr>
<td>LastIndexOfAny</td>
<td>.NET 7.0</td>
<td>1.172 us</td>
<td>0.12</td>
</tr>
</tbody>
</table>
<p>Let’s move up the stack to HTTP. Most of the folks focusing on networking in .NET 7 were focused on<br />
taking the preview support for HTTP/3 that shipped in .NET 6 and making it a first-class supported<br />
feature in .NET 7. That included functional improvements, reliability and correctness fixes, and<br />
performance improvements, such that HTTP/3 can now be used via <code>HttpClient</code> on both Windows<br />
and Linux (it depends on an underlying QUIC implementation in the msquic component, which isn’t<br />
currently available for macOS). However, there were significant improvements throughout the HTTP<br />
stack, beyond HTTP/3.</p>
<p>One aspect of <code>HttpClient</code> that cuts across all versions of HTTP is support for handling and<br />
representing headers. While significant improvements went into previous releases to trim down the<br />
size of the data structures used to store header information, further work on this front was done for</p>
<p>that can be sent with an HTTP request or response (though in order to mitigate possible denial of<br />
service attacks, the implementation has a configurable limit for how many bytes of headers are<br />
accepted from the server), and thus it needs to be able to handle an arbitrary number of them and to<br />
do so with efficient access. As such, for the longest time <code>HttpHeaders</code> has used a <code>Dictionary&lt;,&gt;</code> to<br />
provide <code>O(1)</code> lookup into these headers. However, while it’s valid to have large numbers of headers,<br />
it’s most common to only have a handful, and for only a few items, the overheads involved in a hash<br />
table like <code>Dictionary&lt;&gt;</code> can be more than just storing the elements in an array and doing an <code>O(N)</code><br />
lookup by doing a linear search through all the elements (algorithmic complexity ignores the<br />
“constants” involved, so for a small <code>N</code>, an <code>O(N)</code> algorithm might be much faster and lighterweight than<br />
an <code>O(1)</code> ). This PR takes advantage of that and teaches <code>HttpHeaders</code> how to use either an array or a<br />
dictionary; for common numbers of headers (the current threshold is 64), it just uses an array, and in<br />
the rare case where that threshold is exceeded, it graduates into a dictionary. This reduces the<br />
allocation in <code>HttpHeader</code> in all but the most niche cases while also making it faster for lookups.</p>
<p><a href="https://github.com/dotnet/runtime/pull/64105">Another header-related size reduction comes in dotnet/runtime#64105. The internal representation of</a><br />
headers involves a <code>HeaderDescriptor</code> that enables “known headers” (headers defined in the HTTP<br />
specifications or that we’re otherwise aware of and want to optimize) to share common data, e.g. if a<br />
response header matches one of these known headers, we can just use the header name string<br />
singleton rather than allocating a new string for that header each time we receive it. This</p>
<p><code>HeaderDescriptor</code> accomodated both known headers and custom headers by having two fields, one<br />
for known header data (which would be null for custom headers) and one for the header name.<br />
Instead, this PR employs a relatively-common technique of having a single <code>object</code> field that then<br />
stores either the known header information or the name, since the known header information itself<br />
includes the name, and thus we don’t need the duplication. At the expense of a type check when we</p>
<p>185 CHAPTER 16 | Networking</p>
<p>need to look up information from that field, we cut the number of fields in half. And while this</p>
<p><code>HeaderDescriptor</code> is itself a struct, it’s stored in header collections, and thus by cutting the size of the</p>
<p><code>HeaderDescriptor</code> in half, we can significantly reduce the size of those collections, especially when<br />
many custom headers are involved.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetHeaders</td>
<td>.NET 6.0</td>
<td>334.4 ns</td>
<td>1.00</td>
<td>664 B</td>
<td>1.00</td>
</tr>
<tr>
<td>GetHeaders</td>
<td>.NET 7.0</td>
<td>213.9 ns</td>
<td>0.64</td>
<td>360 B</td>
<td>0.54</td>
</tr>
</tbody>
</table>
<p>implementation of this type were overly flexible, with a mechanism for custom validation of values,<br />
which entailed multiple fields for storing things like an <code>Action&lt;&gt;</code> callback to use for validation. But as<br />
it turns out in practice, that validation was only used for one specific consumer, and so rather than<br />
making everyone pay for the extra space that wasn’t typically used, the validation was instead<br />
extracted out to just the call sites it was required.</p>
<p>parsed host information, but only some of the callers needed this. Rather than making everyone pay<br />
for something that not everyone needed, this logic was moved into only the call sites that needed it.</p>
<p>Other small allocation improvements were also made outside of headers. For example, when new<br />
HTTP/1 and HTTP/2 connections are created, the implementation queues a work item to the thread<br />
pool to handle the actual creation, primarily to escape locks that might be held higher in the call</p>
<p>just be eaten, and the lambda being passed to <code>Task.Run</code> was closing over <code>this</code> and a local, which<br />
means the C# compiler will have generated code to allocate both a “display class” (an object to store<br />
the state being passed in) for the closure and then also a delegate to a method on that display class.</p>
<p>both superfluous allocations.</p>
<p>186 CHAPTER 16 | Networking</p>
<p>Folks using HTTP often need to go through a proxy server, and in .NET the ability to go through an<br />
HTTP proxy is represented via the <code>IWebProxy</code> interface; it has three members, <code>GetProxy</code> for getting the</p>
<p>bypassed is determined by two things (assuming a non-null proxy <code>Uri</code> was provided): did the<br />
constructor of the <code>WebProxy</code> specify that “local” destinations should be bypassed (and if so, is this<br />
destination local), or does this destination address match any of any number of regular expressions<br />
provided. As it turns out, this latter aspect has been relatively slow and allocation-heavy in all previous<br />
releases of .NET, for two reasons: every call to check whether an address was bypassed was recreating<br />
a <code>Regex</code> instance for every supplied regular expression, and every call to check whether an address<br />
was bypassed was deriving a new <code>string</code> from the <code>Uri</code> to use to match against the <code>Regex</code> . In .NET 7,<br />
both of those issues have been fixed, yielding significant improvements if you rely on this regular<br />
<a href="https://github.com/dotnet/runtime/pull/73803">expression functionality. dotnet/runtime#73803 from</a></p>
<p><a href="https://github.com/onehourlate">@onehourlate</a> changed the handling of the collection of these</p>
<p><code>Regex</code> instances. The problem was that <code>WebProxy</code> exposes an <code>ArrayList</code> (this type goes back to the<br />
beginning of .NET and was created pre-generics), which the consumer could modify, and so <code>WebProxy</code><br />
had to assume the collection was modified between uses and addressed that by simply creating new</p>
<p><code>Regex</code> instances on every use; not good. Instead, this PR creates a custom <code>ArrayList</code> -derived type<br />
that can track all relevant mutations, and then only if the collection is changed (which is incredibly<br />
rare, bordering on never) do the <code>Regex</code> <a href="https://github.com/dotnet/runtime/pull/73807">instances need to be recreated. And dotnet/runtime#73807</a><br />
takes advantage of stack allocation and the <code>MemoryExtensions.TryWrite</code> method with string<br />
interpolation to format the text into stack memory, avoiding the string allocation. This, combined with</p>
<p>improvements:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>IsBypassed</td>
<td>.NET 6.0</td>
<td>5,343.2 ns</td>
<td>1.00</td>
<td>7528 B</td>
<td>1.00</td>
</tr>
<tr>
<td>IsBypassed</td>
<td>.NET 7.0</td>
<td>205.5 ns</td>
<td>0.04</td>
<td>-</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>Also related to HTTP, <code>WebUtility</code> ’s <code>HtmlDecode</code> method has improved for .NET 7. The implementation<br />
had been manually iterating through each character in the input looking for a <code>'&amp;'</code> to be unescaped.<br />
Any time you see such an open-coded loop looking for one or more specific characters, it’s a red flag<br />
that <code>IndexOf</code> <a href="https://github.com/dotnet/runtime/pull/70700">should be strongly considered. dotnet/runtime#70700</a> deletes the entire searching</p>
<p>187 CHAPTER 16 | Networking</p>
<p><code>IndexOfAny</code> in <code>HttpListener</code> ’s <code>HandleAuthentication</code> to search a header for certain kinds of<br />
whitespace):</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>HtmlDecode</td>
<td>.NET 6.0</td>
<td>245.54 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>HtmlDecode</td>
<td>.NET 7.0</td>
<td>19.66 ns</td>
<td>0.08</td>
</tr>
</tbody>
</table>
<p>There have been a myriad of other performance-related improvements in networking as well, such as<br />
<a href="https://github.com/dotnet/runtime/pull/67881">dotnet/runtime#67881</a> which removed the use of <code>TcpClient</code> from <code>FtpWebRequest</code> ;<br />
<a href="https://github.com/dotnet/runtime/pull/68745">dotnet/runtime#68745</a> in <code>WebSocket</code> which removed a parameter from one of the core async methods<br />
(and since parameters end up on the state machine, if the async method yields this results in fewer</p>
<p>used and the runtime needs to be involved in the conversion, it’s also much more heavyweight than<br />
just casting, which can be done when the native and managed layouts are bit-for-bit compatible. As<br />
with the <code>u8</code> example earlier, this comparison is hardly fair, but that’s exactly the point:</p>
<p>188 CHAPTER 16 | Networking</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>PtrToStructure</td>
<td>26.6593 ns</td>
<td>1.000</td>
</tr>
<tr>
<td>Cast</td>
<td>0.0736 ns</td>
<td>0.003</td>
</tr>
</tbody>
</table>
<p>For folks using <code>NegotiateStream</code> <a href="https://github.com/dotnet/runtime/pull/71280">, dotnet/runtime#71280</a> from</p>
<p><a href="https://github.com/filipnavara">@filipnavara</a> will also be very welcome (this comes as part of a larger<br />
[effort, primarily in dotnet/runtime#71777 from <a href="https://github.com/filipnavara">@filipnavara</a> and](https://github.com/dotnet/runtime/pull/71777)</p>
<p>handshake by reusing a buffer rather than reallocating a new buffer for each of multiple phases of the<br />
handshake:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Handshake</td>
<td>.NET 6.0</td>
<td>1.905 ms</td>
<td>1.00</td>
<td>240.5 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>Handshake</td>
<td>.NET 7.0</td>
<td>1.913 ms</td>
<td>1.00</td>
<td>99.28 KB</td>
<td>0.41</td>
</tr>
</tbody>
</table>
<p>189 CHAPTER 16 | Networking</p>
<p><strong>CHAPTER</strong></p>
<h1>17</h1>
<h2>JSON</h2>
<p><code>System.Text.Json</code> was introduced in .NET Core 3.0, and has seen a significant amount of investment<br />
<a href="https://github.com/dotnet/runtime/issues/63686">in each release since. .NET 7 is no exception. New features in .NET 7 include support for customizing</a><br />
<a href="https://github.com/dotnet/runtime/issues/63686">contracts,</a> <a href="https://github.com/dotnet/runtime/pull/67961">polymorphic serialization, support for required members,</a> <a href="https://github.com/dotnet/runtime/pull/69160">support for DateOnly / TimeOnly,</a><br />
<a href="https://github.com/dotnet/runtime/pull/68985">support for IAsyncEnumerable<T> and JsonDocument</a> <a href="https://github.com/dotnet/runtime/issues/44947">in source generation, and support for</a><br />
<a href="https://github.com/dotnet/runtime/issues/44947">configuring MaxDepth in JsonWriterOptions. However, there have also been new features specifically</a><br />
focused on performance, and other changes about improving performance of JSON handling in a<br />
variety of scenarios.</p>
<p>One of the biggest performance pitfalls we’ve seen developers face with <code>System.Text.Json</code> has to do<br />
with how the library caches data. In order to achieve good serialization and deserialization<br />
performance when the source generator isn’t used, <code>System.Text.Json</code> uses reflection emit to<br />
generate custom code for reading/writing members of the types being processed. Instead of then<br />
having to pay reflection invoke costs on every access, the library incurs a much larger one-time cost<br />
per type to perform this code generation, but then all subsequent handling of these types is very<br />
fast… assuming the generated code is available for use. These generated handlers need to be stored<br />
somewhere, and the location that’s used for storing them is them is <code>JsonSerializerOptions</code> . The<br />
idea was intended to be that developers would instantiate an options instance once and pass it<br />
around to all of their serialization/deserialization calls; thus, state like these generated handlers could<br />
be cached on them. And that works well when developers follow the recommended model. But when<br />
they don’t, performance falls off a cliff, and hard. Instead of “just” paying for the reflection invoke<br />
costs, each use of a new <code>JsonSerializerOptions</code> ends up re-generating via reflection emit those<br />
handlers, skyrocketing the cost of serialization and deserialization. A super simple benchmark makes<br />
this obvious:</p>
<p>190 CHAPTER 17 | JSON</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ImplicitOptions</td>
<td>.NET 6.0</td>
<td>170.3 ns</td>
<td>1.00</td>
<td>200 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WithCached</td>
<td>.NET 6.0</td>
<td>163.8 ns</td>
<td>0.96</td>
<td>200 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WithoutCached</td>
<td>.NET 6.0</td>
<td>100,440.6 ns</td>
<td>592.48</td>
<td>7393 B</td>
<td>36.97</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/64646">In .NET 7, this was fixed in dotnet/runtime#64646</a> (and subsequently tweaked in</p>
<p>reflection emit, those are also cached at the global level (with appropriate removal when no longer<br />
used in order to avoid unbounded leaks).</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ImplicitOptions</td>
<td>.NET 6.0</td>
<td>170.3 ns</td>
<td>1.00</td>
<td>200 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ImplicitOptions</td>
<td>.NET 7.0</td>
<td>166.8 ns</td>
<td>0.98</td>
<td>48 B</td>
<td>0.24</td>
</tr>
<tr>
<td>WithCached</td>
<td>.NET 6.0</td>
<td>163.8 ns</td>
<td>0.96</td>
<td>200 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WithCached</td>
<td>.NET 7.0</td>
<td>168.3 ns</td>
<td>0.99</td>
<td>48 B</td>
<td>0.24</td>
</tr>
<tr>
<td>WithoutCached</td>
<td>.NET 6.0</td>
<td>100,440.6 ns</td>
<td>592.48</td>
<td>7393 B</td>
<td>36.97</td>
</tr>
<tr>
<td>WithoutCached</td>
<td>.NET 7.0</td>
<td>590.1 ns</td>
<td>3.47</td>
<td>337 B</td>
<td>1.69</td>
</tr>
</tbody>
</table>
<p>As can be seen here, it’s still more expensive to create a new <code>JsonSerializerOptions</code> instance on<br />
each call, and the recommended approach is “don’t do that.” But if someone does do it, in this<br />
example they’re only paying 3.6x the cost rather than 621x the cost, a huge improvement.<br />
<a href="https://github.com/dotnet/runtime/pull/61434">dotnet/runtime#61434</a> also now exposes the <code>JsonSerializerOptions.Default</code> instance that’s used<br />
by default if no options are explicitly provided.</p>
<p>Another change to <code>JsonSerializer</code> <a href="https://github.com/dotnet/runtime/issues/72510">came in dotnet/runtime#72510, which slightly improved the</a><br />
performance of serialization when using the source generator. The source generator emits helpers for<br />
performing the serialization/deserialization work, and these are then invoked by <code>JsonSerializer</code> via<br />
delegates (as part of abstracting away all the different implementation strategies for how to get and<br />
set members on the types being serialized and deserialized). Previously, these helpers were being<br />
emitted as static methods, which in turn meant that the delegates were being created to static<br />
methods. Delegates to instance methods are a bit faster to invoke than delegates to static methods,<br />
so this PR made a simple few-line change for the source generator to emit these as instance methods<br />
instead.</p>
<p>few extra objects and an extra couple of hundred bytes just for these helper data structures. To<br />
address that, this PR takes advantage of <code>[ThreadStatic]</code>, which can be put onto static fields to make<br />
them per-thread rather than per-process. From whatever thread is performing the (synchronous)</p>
<p>191 CHAPTER 17 | JSON</p>
<p><code>Serialize</code> operation, it then ensures the current thread has a <code>Utf8JsonWriter</code> and <code>IBufferWriter</code><br />
instance it can use, and uses them; for the most part this is straightforward, but it needs to ensure that<br />
the serialization operation itself doesn’t try to recursively serialize, in which case these objects could<br />
end up being used erroneously while already in use. It also needs to make sure that the pooled</p>
<p>making use of the pool, not sequestered off in this cached <code>IBufferWriter</code> implementation. This<br />
optimization is also only really meaningful for small object graphs being serialized, and only applies to<br />
the synchronous operations (asynchronous operations would require a more complicated pooling<br />
mechanism, since the operation isn’t tied to a specific thread, and the overhead of such complication<br />
would likely outweigh the modest gain this optimization provides).</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>SerializeToString</td>
<td>.NET 6.0</td>
<td>146.4 ns</td>
<td>1.00</td>
<td>200 B</td>
<td>1.00</td>
</tr>
<tr>
<td>SerializeToString</td>
<td>.NET 7.0</td>
<td>137.5 ns</td>
<td>0.94</td>
<td>48 B</td>
<td>0.24</td>
</tr>
</tbody>
</table>
<p><code>Utf8JsonWriter</code> and <code>Utf8JsonReader</code> <a href="https://github.com/dotnet/runtime/pull/69580">also saw several improvements directly. dotnet/runtime#69580</a><br />
adds a few new performance-focused members, the <code>ValueIsEscaped</code> property (which exposes already<br />
tracked information and enables consumers to avoid the expense of re-checking) and the <code>CopyString</code><br />
method (which provides a non-allocating mechanism to get access to a string value from the reader).<br />
It then also uses the added support internally to speed up certain operations on <code>Utf8JsonReader</code> . And<br />
<a href="https://github.com/dotnet/runtime/pull/63863">dotnet/runtime#63863,</a> <a href="https://github.com/dotnet/runtime/pull/71534">dotnet/runtime#71534, and dotnet/runtime#61746 fix how some exception</a><br />
checks and throws were being handled so as to not slow down the non-exceptional fast paths.</p>
<p>192 CHAPTER 17 | JSON</p>
<p><strong>CHAPTER</strong></p>
<h1>18</h1>
<h2>XML</h2>
<p>System.Xml is used by a huge number of applications and services, but ever since JSON hit the scene<br />
and has been all the rage, XML has taken a back seat and thus hasn’t seen a lot of investment from<br />
either a functionality or performance perspective. Thankfully, System.Xml gets a bit of performance<br />
love in .NET 7, in particular around reducing allocation on some commonly used code paths.</p>
<p>Sometimes a performance fix is as easy as changing a single number. That’s the case with<br />
<a href="https://github.com/dotnet/runtime/pull/63459">dotnet/runtime#63459</a> from <a href="https://github.com/chrisdcmoore">@chrisdcmoore</a>, which addresses a<br />
long-standing issue with the asynchronous methods on the popular <code>XmlReader</code> . When <code>XmlReader</code> was<br />
originally written, whoever developed it chose a fairly common buffer size to be used for read<br />
operations, namely 4K or 8K <code>char</code> s depending on various conditions. When <code>XmlReader</code> later gained<br />
asynchronous reading functionality, for whatever reason a much, much larger buffer size of 64K <code>char</code> s<br />
was selected (presumably in hopes of minimizing the number of asynchronous operations that would<br />
need to be employed, but the actual rationale is lost to history). A key problem with such a buffer size,<br />
beyond it leading to a lot of allocation, is the allocation it produces typically ends up on the Large<br />
Object Heap (LOH). By default, under the expectation that really large objects are long-lived, objects<br />
greater than 85K bytes are allocated into the LOH, which is treated as part of Gen 2, and that makes<br />
such allocation if <em>not</em> long-lived even more expensive in terms of overall impact on the system. Well,</p>
<p>much memory needs to be zero’d, etc). While it’s still a very large allocation, and in the future we<br />
could look at pooling the buffer or employing a smaller one (e.g. no different from what’s done for<br />
the synchronous APIs), this simple one-number change alone makes a substantial difference for<br />
shorter input documents (while not perceivably negatively impacting larger ones).</p>
<p>193 CHAPTER 18 | XML</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>ItemCount</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc<br>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>XmlReader_ReadAsync</td>
<td>.NET 6.0</td>
<td>10</td>
<td>42.344 us</td>
<td>1.00</td>
<td>195.94 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>XmlReader_ReadAsync</td>
<td>.NET 7.0</td>
<td>10</td>
<td>9.992 us</td>
<td>0.23</td>
<td>99.94 KB</td>
<td>0.51</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>XmlReader_ReadAsync</td>
<td>.NET 6.0</td>
<td>1000000</td>
<td>340,382.953<br>us</td>
<td>1.00</td>
<td>101790.34<br>KB</td>
<td>1.00</td>
</tr>
<tr>
<td>XmlReader_ReadAsync</td>
<td>.NET 7.0</td>
<td>1000000</td>
<td>333,417.347<br>us</td>
<td>0.98</td>
<td>101804.45<br>KB</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<p>these cases were stylistic, converting something like <code>string1 + &quot;:&quot; + string2</code> into</p>
<p><code>$&quot;{string1}:{string2}&quot;</code> ; I say stylistic here because the C# compiler will generate the exact same<br />
code for both of those, a call to <code>string.Concat(string1, &quot;:&quot;, string2)</code>, given that there’s a</p>
<p><code>Concat</code> overload that accepts three strings. However, some of the changes do impact allocation. For<br />
example, the private <code>XmlTextWriter.GeneratePrefix</code> method had the code:</p>
<p>where <code>_top</code> and <code>temp</code> are both <code>int</code> s. This will result in allocating two temporary strings and then<br />
concatenating those with the two constant strings. Instead, the PR changed it to:</p>
<pre><code>return string.Create(CultureInfo.InvariantCulture, $&quot;d{_top:d}p{temp:d}&quot;);

</code></pre>
<p>which while shorter is also more efficient, avoiding the intermediate string allocations, as the custom<br />
interpolated string handler used by <code>string.Create</code> will format those into a pooled buffer rather than<br />
allocating intermediate temporaries.</p>
<p>using reflection emit to dynamically generate IL at run-time that are tuned to the specific shape of the<br />
<a href="https://docs.microsoft.com/dotnet/standard/serialization/xml-serializer-generator-tool-sgen-exe">types being serialized/deserialized, and the XML Serializer Generator Tool</a> (sgen), which generates a<br />
.dll containing the same support, just ahead-of-time (a sort-of precursor to the Roslyn source</p>
<p>194 CHAPTER 18 | XML</p>
<p>generators we love today). In both cases, when deserializing, the generated code wants to track which<br />
properties of the object being deserialized have already been set, and to do that, it uses a <code>bool[]</code> as a<br />
bit array. Every time an object is deserialized, it allocates a <code>bool[]</code> with enough elements to track<br />
every member of the type. But in common usage, the vast majority of types being deserialized only<br />
have a relatively small number of properties, which means we can easily use stack memory to track</p>
<p>into a <code>Span&lt;bool&gt;</code> so that the subsequent code paths simply use a span instead of an array). You can<br />
see this quite easily in the .NET Object Allocation Tracking tool in Visual Studio. For this console app<br />
(which, as an aside, shows how lovely the new raw string literals feature in C# is for working with<br />
XML):</p>
<p>Here’s what I see when I run this under .NET 6:</p>
<p>195 CHAPTER 18 | XML</p>
<p>We’re running a thousand deserializations, each of which will deserialize 10 <code>Release</code> instances, and so<br />
we expect to see 10,000 <code>Release</code> objects being allocated, which we do… but we also see 10,000</p>
<p><code>bool[]</code> being allocated. Now with .NET 7 (note the distinct lack of the per-object <code>bool[]</code> ):</p>
<p>Other allocation reduction went into the creation of the serializer/deserializer itself, such as with<br />
<a href="https://github.com/dotnet/runtime/pull/68738">dotnet/runtime#68738</a> avoiding allocating strings to escape text that didn’t actually need escaping,</p>
<p><a href="https://github.com/dotnet/runtime/pull/67001">cache of serializers previously created, dotnet/runtime#67001</a> from</p>
<p><a href="https://github.com/TrayanZapryanov">@TrayanZapryanov</a> caching an array used with <code>string.Split</code>,<br />
[and dotnet/runtime#67002 from <a href="https://github.com/TrayanZapryanov">@TrayanZapryanov</a> that](https://github.com/dotnet/runtime/pull/67002)<br />
changed some parsing code to avoid a <code>string.ToCharArray</code> invocation.</p>
<p>this is a fairly common performance-focused replacement to do, but you need to be careful as</p>
<p><code>Hashtable</code> has a few behavioral differences from <code>Dictionary&lt;,&gt;</code> ; beyond the obvious difference of</p>
<p><a href="https://github.com/TrayanZapryanov">@TrayanZapryanov</a> uses stack-based memory and pooling to</p>
<p>196 CHAPTER 18 | XML</p>
<p>avoid temporary string allocation in the implementation of the internal <code>XsdDateTime</code> and</p>
<p><code>XsdDuration</code> types, which are used by the public <code>XmlConvert</code> .</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>XmlConvertToString</td>
<td>.NET 6.0</td>
<td>90.70 ns</td>
<td>1.00</td>
<td>184 B</td>
<td>1.00</td>
</tr>
<tr>
<td>XmlConvertToString</td>
<td>.NET 7.0</td>
<td>59.21 ns</td>
<td>0.65</td>
<td>40 B</td>
<td>0.22</td>
</tr>
</tbody>
</table>
<p>XML pops up in other areas as well, as in the <code>XmlWriterTraceListener</code> type. While the</p>
<p><code>System.Diagnostics.Trace</code> type isn’t the recommended tracing mechanism for new code, it’s widely<br />
used in existing applications, and <code>XmlWriterTraceListener</code> let’s you plug in to that mechanism to<br />
<a href="https://github.com/dotnet/runtime/pull/66762">write out XML logs for traced information. dotnet/runtime#66762</a> avoids a bunch of string allocation<br />
occurring as part of this tracing, by formatting much of the header information into a span and then<br />
writing that out rather than <code>ToString()</code> ’ing each individual piece of data.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>TraceWrite</td>
<td>.NET 6.0</td>
<td>961.9 ns</td>
<td>1.00</td>
<td>288 B</td>
<td>1.00</td>
</tr>
<tr>
<td>TraceWrite</td>
<td>.NET 7.0</td>
<td>772.2 ns</td>
<td>0.80</td>
<td>64 B</td>
<td>0.22</td>
</tr>
</tbody>
</table>
<p>197 CHAPTER 18 | XML</p>
<p><strong>CHAPTER</strong></p>
<h1>19</h1>
<h2>Cryptography</h2>
<p>Some fairly significant new features came to <code>System.Security.Cryptography</code> in .NET 7, including the<br />
<a href="https://github.com/dotnet/runtime/pull/72708">support necessary to enable the previously discussed OCSP stapling and support for building</a><br />
<a href="https://github.com/dotnet/runtime/pull/72708">certificate revocation lists, but there was also a fair amount of effort put into making existing support</a><br />
faster and more lightweight.</p>
<p><a href="https://github.com/dotnet/runtime/pull/61025">One fairly substantial change in .NET 7 is split across dotnet/runtime#61025,</a> <a href="https://github.com/dotnet/runtime/pull/61137">dotnet/runtime#61137,</a><br />
<a href="https://github.com/dotnet/runtime/pull/64307">and dotnet/runtime#64307. These PRs don’t change any code materially, but instead consolidate all of</a><br />
the various cryptography-related assemblies in the core libraries into a single</p>
<p><code>System.Security.Cryptography</code> assembly. When .NET Core was first envisioned, a goal was to make<br />
it extremely modular, and large swaths of code were teased apart to create many smaller assemblies.<br />
For example, cryptographic functionality was split between</p>
<p>shared framework folder for a previous release, e.g. here’s mine for .NET 6:</p>
<p>These PRs move all of that code into a single <code>System.Security.Cryptography.dll</code> assembly. This has<br />
several benefits. First, crypto is used in a huge number of applications, and most apps would end up</p>
<p>198 CHAPTER 19 | Cryptography</p>
<p>requiring multiple (or even most) of these assemblies. Every assembly that’s loaded adds overhead.<br />
Second, a variety of helper files had to be compiled into each assembly, leading to overall larger<br />
amount of compiled code to be distributed. And third, we weren’t able to implement everything as<br />
optimal as we’d have otherwise liked due to functionality in one assembly not exposed to another<br />
(and we avoid using <code>InternalsVisibleTo</code> as it hampers maintainability and impedes other analysis<br />
and optimizations). Now in .NET 7, the shared framework looks more like this:</p>
<p>Interesting, you still see a bunch of assemblies there, but all except for</p>
<p><code>System.Security.Cryptography.dll</code> are tiny; that’s because these are simple facades. Because we<br />
need to support binaries built for .NET 6 and earlier running on .NET 7, we need to be able to handle<br />
binaries that refer to types in these assemblies, but in .NET 7, those types actually live in</p>
<p><a href="https://github.com/icsharpcode/ILSpy">X, it now lives over there.” And if you crack open one of these assemblies in a tool like ILSpy, you can</a><br />
see they’re essentially empty except for a bunch of these attributes:</p>
<p>199 CHAPTER 19 | Cryptography</p>
<p>In addition to the startup and maintenance wins this provides, this has also enabled further<br />
subsequent optimization. For example, there’s a lot of object cloning that goes on in the innards of<br />
this library. Various objects are used to wrap native handles to OS cryptographic resources, and to<br />
handle lifetime semantics and ownership appropriately, there are many cases where a native handle is<br />
duplicated and then wrapped in one or more new managed objects. In some cases, however, the<br />
original resource is then destroyed because it’s no longer needed, and the whole operation could<br />
have been made more efficient if the original resource just had its ownership transferred to the new<br />
objects rather than being duplicated and destroyed. This kind of ownership transfer typically is hard to<br />
do between assemblies as it generally requires public API that’s not focused on such usage patterns,</p>
<p>public types.</p>
<p>In terms of actual code improvements, there are many. One category of improvements is around<br />
“one-shot” operations. With many forms of data processing, all of the data needn’t be processed in<br />
one operation. A block of data can be processed, then another, then another, until finally there’s no<br />
more data to be processed. In such usage, there’s often some kind of state carried over from the<br />
processing of one block to the processing of the next, and then the processing of the last block is<br />
special as it needn’t carry over anything and instead needs to perform whatever work is required to<br />
end the whole operation, e.g. outputting any final footer or checksum that might be required as part<br />
of the format. Thus, APIs that are able to handle arbitrary number of blocks of data are often a bit<br />
more expensive in one way, shape, or form than APIs that only support a single input; this latter<br />
category is known as “one shot” operations, because they do everything in “one shot.” In some cases,<br />
one-shot operations can be significantly cheaper, and in other cases they merely avoid some<br />
allocations that would have been necessary to transfer state from the processing of one block of data<br />
[to the next. dotnet/runtime#58270 from <a href="https://github.com/vcsjones">@vcsjones</a> and](https://github.com/dotnet/runtime/pull/58270)<br />
<a href="https://github.com/dotnet/runtime/pull/65725">dotnet/runtime#65725</a> from <a href="https://github.com/vcsjones">@vcsjones</a> both improved the<br />
performance of various one-shot operations on “symmetric” cryptograhic algorithms (algorithms that<br />
use the same key information to both encrypt and decrypt), like AES. The former does so by<br />
refactoring the implementations to avoid some reset work that’s not necessary in the case of oneshots because the relevant state is about to go away, anyway, and that in turns also allows the<br />
implementation to store less of certain kinds of state. The latter does so for decryption one-shots by<br />
decrypting directly into the destination buffer whenever possible, using stack space if possible when<br />
going directly into the user’s buffer isn’t feasible, etc.</p>
<p>200 CHAPTER 19 | Cryptography</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>OneShot</td>
<td>.NET 6.0</td>
<td>1.828 us</td>
<td>1.00</td>
<td>336 B</td>
<td>1.00</td>
</tr>
<tr>
<td>OneShot</td>
<td>.NET 7.0</td>
<td>1.770 us</td>
<td>0.97</td>
<td>184 B</td>
<td>0.55</td>
</tr>
</tbody>
</table>
<p>In addition to making one-shots lighterweight, other PRs have then used these one-shot operations in<br />
more places in order to simplify their code and benefit from the increased performance, e.g.<br />
<a href="https://github.com/dotnet/runtime/pull/70639">dotnet/runtime#70639</a> [from <a href="https://github.com/vcsjones">@vcsjones</a>, dotnet/runtime#70857 from](https://github.com/dotnet/runtime/pull/70857)</p>
<p>[<a href="https://github.com/vcsjones">@vcsjones</a>, dotnet/runtime#64005](https://github.com/dotnet/runtime/pull/64005) from</p>
<p>[<a href="https://github.com/vcsjones">@vcsjones</a>, and dotnet/runtime#64174 from](https://github.com/dotnet/runtime/pull/64174)</p>
<p><a href="https://github.com/vcsjones">@vcsjones</a>.</p>
<p>There’s also a large number of PRs that have focused on removing allocations from around the crypto<br />
stack:</p>
<ul>
<li><strong>Stack allocation</strong> . As has been seen in many other PRs referenced throughout this post, using<br />
<code>stackalloc</code> is a very effective way to get rid of array allocations in many situations. It’s used<br />
effectively in multiple crypto PRs to avoid either temporary or pooled array allocations, such as<br />
[in dotnet/runtime#64584 from <a href="https://github.com/vcsjones">@vcsjones</a>, dotnet/runtime#69831](https://github.com/dotnet/runtime/pull/64584)<br />
[from <a href="https://github.com/vcsjones">@vcsjones</a>, dotnet/runtime#70173 from](https://github.com/dotnet/runtime/pull/70173)</li>
</ul>
<p>[<a href="https://github.com/vcsjones">@vcsjones</a>, dotnet/runtime#69812](https://github.com/dotnet/runtime/pull/69812) from</p>
<p>[<a href="https://github.com/vcsjones">@vcsjones</a>, and dotnet/runtime#69448 from](https://github.com/dotnet/runtime/pull/69448)</p>
<p><a href="https://github.com/vcsjones">@vcsjones</a>. Sometimes this is used when calling an API that has<br />
multiple overloads, including one taking an array and one taking a span. Othertimes it’s used<br />
with P/Invokes that often just pass out a small amount of data. Sometimes it’s used to avoid<br />
temporary array allocations, and sometimes it’s used in places where pooling was used<br />
previously, but the data is often small enough to avoid even the overheads of pooling.</p>
<ul>
<li><strong>Avoiding double copies</strong> . Most of the crypto APIs that accept <code>byte[]</code> s and store them end up<br />
making defensive copies of those arrays rather than storing the original. This is fairly common<br />
throughout .NET, but it’s especially common in the crypto stack, where the ability to trust the<br />
data is as you expect it (and validate it) is paramount. In some cases, though, code ends up<br />
allocating a temporary <code>byte[]</code> just to pass data into one of these APIs that copies and re[allocates, anyway. dotnet/runtime#71102 from <a href="https://github.com/vcsjones">@vcsjones</a>,](https://github.com/dotnet/runtime/pull/71102)<br />
[dotnet/runtime#69024 from <a href="https://github.com/vcsjones">@vcsjones</a>, dotnet/runtime#71015](https://github.com/dotnet/runtime/pull/69024)<br />
[from <a href="https://github.com/vcsjones">@vcsjones</a>, and dotnet/runtime#69534 from](https://github.com/dotnet/runtime/pull/69534)</li>
</ul>
<p><a href="https://github.com/vcsjones">@vcsjones</a> deal with that duplication in some cases by extracting<br />
a span to the original data instead of creating a temporary <code>byte[]</code> ; when that span is passed into<br />
the target API, the target API still makes a copy, but we’ve avoided the first one and thus cut the<br />
<a href="https://github.com/dotnet/runtime/pull/71888">array allocation for these operations effectively in half. dotnet/runtime#71888</a> from</p>
<p><a href="https://github.com/vcsjones">@vcsjones</a> is a variation on this theme, improving the internals of</p>
<p>201 CHAPTER 19 | Cryptography</p>
<p><code>Rfc2898DeriveBytes</code> to supports spans such that its constructors that accept spans can then do<br />
the more efficient thing.</p>
<p>complexity is misleading. Yes, these provide very efficient searching, but there’s still overhead<br />
associated with computing a hash code, mapping that hash code to a location in the data</p>
<p>structure may not even be needed at all: the search can just be open-coded as a waterfall of<br />
<a href="https://github.com/dotnet/runtime/pull/71341">if/elseif/else constructs. That’s the case in a PR like dotnet/runtime#71341</a> from</p>
<p><a href="https://github.com/vcsjones">@vcsjones</a>, where the 99.999% case involves just five strings<br />
(names of hash algorithms); it’s cheaper to just compare against each than it is do a<br />
<code>HashSet&lt;&gt;.Contains</code>, especially since the JIT now unrolls and vectorizes the comparison against<br />
the constant string names.</p>
<ul>
<li><strong>Simply avoiding unnecessary work</strong> . The best optimizations are ones where you simply stop<br />
<a href="https://github.com/dotnet/runtime/pull/68553">doing work you don’t have to do. dotnet/runtime#68553</a> from</li>
</ul>
<p><a href="https://github.com/vcsjones">@vcsjones</a> is a good example of this. This code was performing a<br />
hash of some data in order to determine the length of resulting hashes for that particular<br />
configuration, but we actually know ahead of time exactly how long a hash for a given algorithm<br />
is going to be, and we already have in this code a cascading if/elseif/else that’s checking for each<br />
<a href="https://github.com/dotnet/runtime/pull/70589">known algorithm, so we can instead just hardcode the length for each. dotnet/runtime#70589</a><br />
from <a href="https://github.com/vcsjones">@vcsjones</a> is another good example, in the same spirit of<br />
the ownership transfer example mentioned earlier (but this one didn’t previously span assembly<br />
boundaries). Rather than in several places taking an <code>X509Extension</code>, serializing it to a <code>byte[]</code>,<br />
and passing that temporary <code>byte[]</code> to something else that in turn makes a defensive copy, we<br />
can instead provide an internal pathway for ownership transfer, bypassing all of the middle<br />
<a href="https://github.com/dotnet/runtime/pull/70618">stages. Another good one is dotnet/runtime#70618</a> from</p>
<p><a href="https://github.com/vcsjones">@vcsjones</a>, as it’s an example of how it pays to really understand<br />
your dependencies. The implementation of symmetric encryption on macOS uses the<br />
CommonCrypto library. One of the functions it exposes is <code>CCCryptorFinal</code>, which is used at the<br />
end of the encryption/decryption process. However, there are several cases called out in the<br />
docs where it’s unnecessary (“superfluous,” according to the docs), and so our dutifully calling it<br />
even in those situations is wasteful. The fix? Stop doing unnecessary work.</p>
<ul>
<li><strong>New APIs</strong> . A bunch of new APIs were introduced for cryptography in .NET 7. Most are focused</li>
</ul>
<p><a href="https://github.com/dotnet/runtime/pull/57835">some are focused squarely on performance. dotnet/runtime#57835</a> from</p>
<p>call (again a defensive copy to avoid having to deal with the possiblity that the consumer</p>
<p>enables accessing this data freely without additional allocation.</p>
<p>202 CHAPTER 19 | Cryptography</p>
<p><strong>CHAPTER</strong></p>
<h1>20</h1>
<h2>Diagnostics</h2>
<p>Let’s turn our attention to System.Diagnostics, which encompasses types ranging from process<br />
management to tracing.</p>
<p>The <code>Process</code> class is used for a variety of purposes, including querying information about running<br />
processes, interacting with other processes (e.g. being notified of their exiting), and launching<br />
processes. The performance of querying for information in particular had some notable improvements</p>
<p>for each. It turns out that previous releases of .NET were loading the full information (e.g. all of its<br />
threads) about every <code>Process</code> on the machine in order to filter down to just those with the target<br />
<a href="https://github.com/dotnet/runtime/pull/68705">name. dotnet/runtime#68705 fixes that by only loading the name for a process rather than all of the</a><br />
information for it. While this helps a bit with throughput, it helps a ton with allocation:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetProcessesByName</td>
<td>.NET 6.0</td>
<td>2.287 ms</td>
<td>1.00</td>
<td>447.86 KB</td>
<td>1.000</td>
</tr>
<tr>
<td>GetProcessesByName</td>
<td>.NET 7.0</td>
<td>2.086 ms</td>
<td>0.90</td>
<td>2.14 KB</td>
<td>0.005</td>
</tr>
</tbody>
</table>
<p>a single member of one of those lazy-loaded <code>Process</code> instances triggers loading all of the data for it,<br />
as the information is all available as part of the same native operation, e.g. on Windows using</p>
<p><code>NtQuerySystemInformation</code> and on Linux reading from <code>/proc/pid/stat</code> and <code>/proc/pid/status</code> . But<br />
in some cases we can be more fine-grained about it, using APIs that serve up a subset of the data</p>
<p>203 CHAPTER 20 | Diagnostics</p>
<p>process’ name, it’s a huge boost in throughput, and even if you subsequently go on to read additional<br />
state from the <code>Process</code> and force it to load everything else, accessing the process name is so fast that<br />
it doesn’t add meaningful overhead to the all-up operation. This is visible in this benchmark:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetCurrentProcessName</td>
<td>.NET 6.0</td>
<td>3,070.54 us</td>
<td>1.00</td>
<td>3954 B</td>
<td>1.00</td>
</tr>
<tr>
<td>GetCurrentProcessName</td>
<td>.NET 7.0</td>
<td>32.30 us</td>
<td>0.01</td>
<td>456 B</td>
<td>0.12</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GetCurrentProcessNameAndWorkingSet</td>
<td>.NET 6.0</td>
<td>3,055.70 us</td>
<td>1.00</td>
<td>4010 B</td>
<td>1.00</td>
</tr>
<tr>
<td>GetCurrentProcessNameAndWorkingSet</td>
<td>.NET 7.0</td>
<td>3,149.92 us</td>
<td>1.03</td>
<td>4186 B</td>
<td>1.04</td>
</tr>
</tbody>
</table>
<p>Interestingly, this PR had a small deficiency we didn’t initially catch, which is that the</p>
<p><code>QueryFullProcessImageName</code> API we switched to didn’t work in the case of elevated/privileged<br />
<a href="https://github.com/dotnet/runtime/pull/70073">processes. To accomodate those, dotnet/runtime#70073 from</a></p>
<p><a href="https://github.com/schuettecarsten">@schuettecarsten</a> updated the code to keep both the new and<br />
old implementations, starting with the new one and then only falling back to the old if operating on<br />
an incompatible process.</p>
<p><a href="https://github.com/dotnet/runtime/pull/71136">directly into the native memory already being allocated. dotnet/runtime#71136 simplifies and</a><br />
streamlines the code involved in getting the “short name” of a process on Windows for use in<br />
<a href="https://github.com/dotnet/runtime/pull/45690">comparing process names. And dotnet/runtime#45690</a> replaces a custom cache with use of</p>
<p><code>ArrayPool</code> in the Windows implementation of getting all process information, enabling effective reuse<br />
of the array that ends up being used rather than having it sequestered off in the <code>Process</code><br />
implementation forever.</p>
<p>Another area of performance investment has been in <code>DiagnosticSource</code>, and in particular around<br />
enumerating through data from <code>Activity</code> instances. This work translates into faster integration and<br />
<a href="https://devblogs.microsoft.com/dotnet/opentelemetry-net-reaches-v1-0">interoperability via OpenTelemetry, in order to be able to export data from .NET</a> <code>Activity</code> information<br />
[faster. dotnet/runtime#67012 from <a href="https://github.com/CodeBlanch">@CodeBlanch</a>, for example,](https://github.com/dotnet/runtime/pull/67012)<br />
improved the performance of the internal <code>DiagLinkedList&lt;T&gt;.DiagEnumerator</code> type that’s the</p>
<p>204 CHAPTER 20 | Diagnostics</p>
<p>enumerator returned when enumerating <code>Activity.Links</code> and <code>Activity.Events</code> by avoiding a copy<br />
of each <code>T</code> value:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>EnumerateActivityLinks</td>
<td>.NET 6.0</td>
<td>19.62 us</td>
<td>1.00</td>
<td>64 B</td>
<td>1.00</td>
</tr>
<tr>
<td>EnumerateActivityLinks</td>
<td>.NET 7.0</td>
<td>13.72 us</td>
<td>0.70</td>
<td>32 B</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>[Then dotnet/runtime#67920 from <a href="https://github.com/CodeBlanch">@CodeBlanch</a> and](https://github.com/dotnet/runtime/pull/67920)</p>
<p>205 CHAPTER 20 | Diagnostics</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>EnumerateActivityLinks_Old</td>
<td>13.655 us</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>EnumerateActivityLinks_New</td>
<td>2.380 us</td>
<td>0.17</td>
<td>-</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>Of course, when it comes to diagnostics, anyone who’s ever done anything with regards to timing and<br />
measurements is likely familiar with good ol’ <code>Stopwatch</code> . <code>Stopwatch</code> is a simple type that’s very handy<br />
for getting precise measurements and is thus used all over the place. But for folks that are really costsensitive, the fact that <code>Stopwatch</code> is a class can be prohibitive, e.g. writing:</p>
<p>is easy, but allocates a new object just to measure. To address this, <code>Stopwatch</code> has for years exposed</p>
<p>that last mile of performance can write:</p>
<p>which avoids the allocation and saves a few cycles:</p>
<p>206 CHAPTER 20 | Diagnostics</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Old</td>
<td>32.90 ns</td>
<td>1.00</td>
<td>40 B</td>
<td>1.00</td>
</tr>
<tr>
<td>New</td>
<td>26.30 ns</td>
<td>0.80</td>
<td>-</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>207 CHAPTER 20 | Diagnostics</p>
<p><strong>CHAPTER</strong></p>
<h1>21</h1>
<h2>Exceptions</h2>
<p>It might be odd to see the subject of “exceptions” in a post on performance improvements. After all,<br />
exceptions are by their very nature meant to be “exceptional” (in the “rare” sense), and thus wouldn’t<br />
typically contribute to fast-path performance. Which is a good thing, because fast-paths that throw<br />
exceptions in the common case are no longer fast: throwing exceptions is quite expensive.</p>
<p>Instead, one of the things we <em>do</em> concern ourselves with is how to minimize the impact of checking for<br />
exceptional conditions: the actual exception throwing may be unexpected and slow, but it’s super<br />
common to need to check for those unexpected conditions, and that checking should be very fast. We<br />
also want such checking to minimally impact binary size, especially if we’re going to have many such<br />
checks all over the place, in generic code for which we end up with many copies due to generic<br />
specialization, in functions that might be inlined, and so on. Further, we don’t want such checks to<br />
impede other optimizations; for example, if I have a small function that wants to do some argument<br />
validation and would otherwise be inlineable, I likely don’t want the presence of exception throwing to<br />
invalidate the possibility of inlining.</p>
<p>Because of all of that, high-performance libraries often come up with custom “throw helpers” they use<br />
to achieve their goals. There are a variety of patterns for this. Sometimes a library will just define its<br />
own static method that handles constructing and throwing an exception, and then call sites do the<br />
condition check and delegate to the method if throwing is needed:</p>
<p>This keeps the IL associated with the throwing out of the calling function, minimizing the impact of<br />
the throw. That’s particularly valuable when additional work is needed to construct the exception, e.g.</p>
<p>Other times, libraries will encapsulate both the checking and throwing. This is exactly what the<br />
ArgumentNullException.ThrowIfNull method that was added in .NET 6 does:</p>
<p>208 CHAPTER 21 | Exceptions</p>
<p>With that, callers benefit from the concise call site:</p>
<p>the IL remains concise, and the assembly generated for the JIT will include the streamlined condition<br />
check from the inlined <code>ThrowIfNull</code> but won’t inline the <code>Throw</code> helper, resulting in effectively the same<br />
code as if you’d written the previously shown manual version with <code>ThrowArgumentNullException</code><br />
yourself. Nice.</p>
<p>Whenever we introduce new public APIs in .NET, I’m particularly keen on seeing them used as widely<br />
as possible. Doing so serves multiple purposes, including helping to validate that the new API is<br />
usable and fully addresses the intended scenarios, and including the rest of the codebase benefiting<br />
from whatever that API is meant to provide, whether it be a performance improvement or just a<br />
reduction in routinely written code. In the case of <code>ArgumentNullException.ThrowIfNull</code>, however, I<br />
purposefully put on the brakes. We used it in .NET 6 in several dozen call sites, but primarily just in<br />
place of custom <code>ThrowIfNull</code> -like helpers that had sprung up in various libraries around the runtime,<br />
effectively deduplicating them. What we didn’t do, however, was replace the literally thousands of null<br />
checks we have with calls to <code>ArgumentNullException.ThrowIfNull</code> . Why? Because the new <code>!!</code> C#<br />
feature was right around the corner, destined for C# 11.</p>
<p>For those unaware, the <code>!!</code> feature enabled putting <code>!!</code> onto parameter names in member signatures,<br />
e.g.</p>
<p>The C# compiler then compiled that as equivalent to:</p>
<p>(albeit using its own <code>ThrowIfNull</code> helper injected as internal into the assembly). Armed with the new</p>
<p>from Kung Fu Panda, “One often meets his destiny on the road he takes to avoid it”? The presence of<br />
that initial PR kicked off an unprecedented debate about the <code>!!</code> feature, with many folks liking the<br />
concept but a myriad of different opinions about exactly how it should be exposed, and in the end,</p>
<p>209 CHAPTER 21 | Exceptions</p>
<p>APIs internally. Interestingly, while we expected a peanut-buttery effect of slight perf improvements in<br />
many places, our performance auto-analysis system flagged several performance improvements (e.g.<br />
<a href="https://github.com/dotnet/perf-autofiling-issues/issues/3531">dotnet/perf-autofiling-issues#3531) as stemming from these changes, in particular because it enabled</a><br />
the JIT’s inlining heuristics to flag more methods for inlining.</p>
<p>With the success of <code>ArgumentNullException.ThrowIfNull</code> and along with its significant roll-out in<br />
<a href="https://github.com/dotnet/runtime/pull/61633">.NET 7, .NET 7 also sees the introduction of several more such throw helpers. dotnet/runtime#61633,</a></p>
<p><a href="https://github.com/dotnet/runtime/pull/71544">(tweaked by dotnet/runtime#71544 to help ensure it’s inlineable), which is then used at over a</a><br />
<a href="https://github.com/dotnet/runtime/pull/71546">hundred additional call sites by dotnet/runtime#71546.</a></p>
<p>210 CHAPTER 21 | Exceptions</p>
<p><strong>CHAPTER</strong></p>
<h1>22</h1>
<h2>Registry</h2>
<p>On Windows, the Registry is a database provided by the OS for applications and the system itself to<br />
load and store configuration settings. Practically every application accesses the registry. I just tried a<br />
simple console app:</p>
<pre><code>Console.WriteLine(&quot;Hello, world&quot;);

</code></pre>
<p>built it as release, and then ran the resulting .exe. That execution alone triggered 64 <code>RegQueryValue</code><br />
<a href="https://docs.microsoft.com/sysinternals/downloads/procmon">operations (as visible via SysInternals’ Process Monitor</a> tool). The core .NET libraries even access the<br />
registry for a variety of purposes, such as for gathering data for <code>TimeZoneInfo</code>, gathering data for</p>
<p>It’s thus beneficial to streamline access to registry data on Windows, in particular for reducing</p>
<p>required in order to store the value for the key. The implementation would then allocate a buffer of<br />
the appropriate size and call <code>RegQueryValueEx</code> again, and for values that are to be returned as strings,<br />
would then allocate a string based on the data in that buffer. This PR instead recognizes that the vast</p>
<p>was sufficiently large, we no longer have to make a second system call to retrieve the actual data: we<br />
already got it. If the buffer was too small, we rent an <code>ArrayPool</code> buffer of sufficient size and use that<br />
pooled buffer for the subsequent <code>RegQueryValueEx</code> call. Except in situations where we actually need</p>
<p>the resulting string.</p>
<p>211 CHAPTER 22 | Registry</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>RegSz</td>
<td>.NET 6.0</td>
<td>6.266 us</td>
<td>1.00</td>
<td>200 B</td>
<td>1.00</td>
</tr>
<tr>
<td>RegSz</td>
<td>.NET 7.0</td>
<td>3.182 us</td>
<td>0.51</td>
<td>96 B</td>
<td>0.48</td>
</tr>
</tbody>
</table>
<p>212 CHAPTER 22 | Registry</p>
<p><strong>CHAPTER</strong></p>
<h1>23</h1>
<h2>Analyzers</h2>
<p>The ability to easily plug custom code, whether for analyzers or source generators, into the Roslyn<br />
compiler is one of my favorite features in all of C#. It means the developers working on C# don’t need<br />
to be solely responsible for highlighting every possible thing you might want to diagnose in your<br />
code. Instead, library authors can write their own analyzers, ship them either in dedicated nuget<br />
packages or as side-by-side in nuget packages with APIs, and those analyzers augment the compiler’s<br />
own analysis to help developers write better code. We ship a large number of analyzer rules in the<br />
.NET SDK, many of which are focused on performance, and we augment that set with more and more<br />
analyzers every release. We also work to apply more and more of those rules against our own<br />
codebases in every release. .NET 7 is no exception.</p>
<p><a href="https://github.com/dotnet/roslyn-analyzers/pull/5594">One of my favorite new analyzers was added in dotnet/roslyn-analyzers#5594</a> from</p>
<p>[<a href="https://github.com/NewellClark">@NewellClark</a> (and tweaked in dotnet/roslyn-analyzers#5972). In](https://github.com/dotnet/roslyn-analyzers/pull/5972)<br />
<a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6">my .NET 6 performance</a> post, I talked about some of the overheads possible when types aren’t sealed:</p>
<ul>
<li>Virtual calls are more expensive than regular non-virtual invocation and generally can’t be<br />
inlined, since the JIT doesn’t know what is the actual type of the instance and thus the actual<br />
target of the invocation (at least not without assistance from PGO). But if the JIT can see that a<br />
virtual method is being invoked on a sealed type, it can devirtualize the call and potentially even<br />
inline it.</li>
</ul>
<p>helper method in Corelib that not only checks for null and for direct equality with the specified<br />
type, but also linearly walks the parent hierarchy of the type of the object being tested to see if it<br />
might derive from the specified type.</p>
<p>additional validation may need to be performed to ensure the reference being written is<br />
compatible with the concrete type of the array in question. But, if <code>A</code> in this example were sealed,<br />
nothing could derive from it, so storing objects into it doesn’t require such covariance checks.</p>
<ul>
<li>Spans shift this covariance check to their constructor; rather than performing the covariance<br />
check on every write into the array, the check is performed when a span is being constructed<br />
from an array, such that if you try to create a <code>new Span&lt;A&gt;(bArray)</code>, the ctor will throw an<br />
exception. If <code>A</code> is sealed, the JIT is able to elide such a check as well.</li>
</ul>
<p>213 CHAPTER 23 | Analyzers</p>
<p>It effectively would be impossible for an analyzer to be able to safely recommend sealing public types.<br />
After all, it has no knowledge of the type’s purpose, how it’s intended to be used, and whether anyone<br />
outside of the assembly containing the type actually derives from it. But internal and private types are<br />
another story. An analyzer <em>can</em> actually see every possible type that could be deriving from a private<br />
type, since the analyzer has access to the whole compilation unit containing that type, and it needn’t<br />
worry about compatibility because anything that could derive from such a type necessarily must also<br />
be non-public and would be recompiled right along with the base type. Further, with the exception of<br />
assemblies annotated as InternalsVisibleTo, an analyzer can have the same insight into internal types.<br />
Thus, this PR adds CA1852, an analyzer that flags in non-InternalsVisibleTo assemblies all private and<br />
internal types that aren’t sealed and that have no types deriving from them and recommends they be<br />
sealed. (Due to some current limitations in the infrastructure around fixers and how this analyzer had<br />
to be written in order to be able to see all of the types in the assembly, the analyzer for CA1852<br />
doesn’t show up in Visual Studio. It can, however, be applied using the <code>dotnet format</code> tool. And if<br />
you bump up the level of the rule from info to warning or error, it’ll show up as part of builds as well.)</p>
<p>In .NET 6, we sealed over 2300 types, but even with that, this analyzer ended up finding more to seal.<br />
<a href="https://github.com/dotnet/runtime/pull/59941">dotnet/runtime#59941</a> from <a href="https://github.com/NewellClark">@NewellClark</a> sealed another ~70<br />
<a href="https://github.com/dotnet/runtime/pull/68268">types, and dotnet/runtime#68268 which enabled the rule as an warning in dotnet/runtime (which</a><br />
builds with warnings-as-errors) sealed another ~100 types. As a larger example of the rule in use,<br />
ASP.NET hadn’t done much in the way of sealing types in previous releases, but with CA1852 now in<br />
<a href="https://github.com/dotnet/aspnetcore/pull/41457">the .NET SDK, dotnet/aspnetcore#41457 enabled the analyzer and sealed more than ~1100 types.</a></p>
<p><a href="https://github.com/dotnet/roslyn-analyzers/pull/4851">Another new analyzer, CA1854, was added in dotnet/roslyn-analyzers#4851</a> from</p>
<p><code>ContainsKey</code> is used to determine whether a dictionary contains a particular entry, and then if it does,<br />
the dictionary’s indexer is used to retrieve the value associated with the key, e.g.</p>
<p>Dictionary’s <code>TryGetValue</code> method already combines both of these operations, both looking up the<br />
key and retrieving its value if it exists, doing so as a single operation:</p>
<p>A benefit of this, in addition to arguably being simpler, is that it’s also faster. While <code>Dictionary&lt;TKey,</code></p>
<p><code>TValue&gt;</code> provides very fast lookups, and while the performance of those lookups has gotten faster<br />
over time, doing fast work is still more expensive than doing no work, and if we can do one lookup<br />
instead of two, that can result in a meaningful performance boost, in particular if it’s being performed<br />
on a fast path. And we can see from this simple benchmark that looks up a word in a dictionary that,<br />
for this operation, making distinct calls to <code>ContainsKey</code> and the indexer does indeed double the cost<br />
of using the dictionary, almost exactly:</p>
<p>214 CHAPTER 23 | Analyzers</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lookup1</td>
<td>28.20 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Lookup2</td>
<td>14.12 ns</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>Somewhat ironically, even as I write this example, the analyzer and its auto-fixer are helpfully trying to<br />
get me to change my benchmark code:</p>
<p>215 CHAPTER 23 | Analyzers</p>
<p>it’s fairly natural for developers to only call <code>Remove</code> on a dictionary once they’re sure the dictionary<br />
contains the thing being removed; maybe they think <code>Remove</code> will throw an exception if the specified<br />
key doesn’t exist. However, <code>Remove</code> actually allows this as a first-class scenario, with its return <code>Boolean</code><br />
value indicating whether the key was in the dictionary (and thus successfully removed) or not. An</p>
<p>which the analyzer flagged and which it’s auto-fixer replaced with just:</p>
<pre><code>m_subscriptions.Remove(listener);

</code></pre>
<p>Nice and simple. And faster, since as with the TryGetValue case, this is now doing a single dictionary<br />
lookup rather than two. :::{custom-style=Figure}</p>
<p>216 CHAPTER 23 | Analyzers</p>
<p>:::</p>
<p><a href="https://github.com/dotnet/roslyn-analyzers/pull/5907">Another nice analyzer added in dotnet/roslyn-analyzers#5907</a> <a href="https://github.com/dotnet/roslyn-analyzers/pull/5910">and dotnet/roslyn-analyzers#5910 is</a><br />
CA1851, which looks for code that iterates through some kinds of enumerables multiple times.<br />
Enumerating an enumerator, whether directly or via helper methods like those in LINQ, can have nontrivial cost. Calling GetEnumerator typically allocates an enumerator object, and every item yielded<br />
typically involves two interface calls, one to MoveNext and one to Current. If something can be done<br />
via a single pass over the enumerable rather than multiple passes, that can save such costs. In some<br />
cases, seeing places this analyzer fires can also inspire changes that avoid any use of enumerators. For<br />
<a href="https://github.com/dotnet/runtime/pull/67292">example, dotnet/runtime#67292 enabled CA1851 for dotnet/runtime, and in doing so, it fixed several</a><br />
diagnostics issued by the analyzer (even in a code base that’s already fairly stringent about<br />
enumerator and LINQ usage). As an example, this is a function in<br />
System.ComponentModel.Composition that was flagged by the analyzer:</p>
<p>The method’s purpose is to convert the enumerable into an array to be stored, but also to validate<br />
that the contents are all non-null and non-“ReflectionOnly.” To achieve that, the method is first using<br />
a foreach to iterate through the enumerable, validating each element along the way, and then once<br />
it’s done so, it calls ToArray() to convert the enumerable into an array. There are multiple problems</p>
<p>217 CHAPTER 23 | Analyzers</p>
<p>with this. First, it’s incurring the expense of interating through the enumerable twice, once for the</p>
<p>actually ensuring there aren’t nulls in the resulting array, for example. Since the expectation of the<br />
method is that all inputs are valid and we don’t need to optimize for the failure cases, the better<br />
approach is to <em>first</em> call <code>ToArray()</code> and then validate the contents of that array, which is exactly what<br />
that PR fixes it to do:</p>
<p>With that, we only ever iterate it once (and possibly 0 times if <code>ToArray</code> can special-case it, and bonus,<br />
we validate on the copy rather than on the mutable original.</p>
<p><a href="https://github.com/dotnet/roslyn-analyzers/pull/4797">Yet another helpful analyzer is the new CA1850 introduced in dotnet/roslyn-analyzers#4797 from</a></p>
<p><a href="https://github.com/wzchua">@wzchua</a>. It used to be that if you wanted to cryptographically hash<br />
some data in .NET, you would create an instance of a hash algorithm and call its ComputeHash<br />
method, e.g.</p>
<p>However, .NET 5 introduced new “one-shot” hashing methods, which obviates the need to create a<br />
new <code>HashAlgorithm</code> instance, providing a static method that performs the whole operation.</p>
<p>CA1850 finds occurrences of the former pattern and recommends changing them to the latter.</p>
<p>218 CHAPTER 23 | Analyzers</p>
<p>The result is not only simpler, it’s also faster:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hash1</td>
<td>1,212.9 ns</td>
<td>1.00</td>
<td>240 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Hash2</td>
<td>950.8 ns</td>
<td>0.78</td>
<td>56 B</td>
<td>0.23</td>
</tr>
</tbody>
</table>
<p>The .NET 7 SDK also includes new analyzers around <code>[GeneratedRegex(...)]</code> <a href="https://github.com/dotnet/runtime/pull/68976">(dotnet/runtime#68976)</a><br />
and the already mentioned ones for LibraryImport, all of which help to move your code forwards to<br />
more modern patterns that have better performance characteristics.</p>
<p>219 CHAPTER 23 | Analyzers</p>
<p><a href="https://github.com/dotnet/runtime">This release also saw dotnet/runtime turn on a bunch of additional IDEXXXX code style rules and</a><br />
make a huge number of code changes in response. Most of the resulting changes are purely about<br />
simplifying the code, but in almost every case some portion of the changes also have a functional and<br />
performance impact.</p>
<p>Let’s start with IDE0200, which is about removing unnecessary lambdas. Consider a setup like this:</p>
<p>passes it off to some static functionality. For this code, the C# compiler is going to generate<br />
something along the lines of this:</p>
<p>the lambda and store it into that field. For all subsequent invocations, however, it’ll find the field is</p>
<p>220 CHAPTER 23 | Analyzers</p>
<p>non-null and will just reuse the same delegate. Thus, this lambda only ever results in a single<br />
allocation for the whole process (ignoring any race conditions on the initial lazy initialization such that<br />
multiple threads all racing to initialize the field might end up producing a few additional unnecessary<br />
allocations). It’s important to recognize this caching only happens because the lambda doesn’t access<br />
any instance state and doesn’t close over any locals; if it did either of those things, such caching<br />
wouldn’t happen. Secondarily, it’s interesting to note the pattern the compiler uses for the lambda<br />
itself. Note that generated <code>&lt;CallSite&gt;b__0_0</code> method is generated as an instance method, and the<br />
call site refers to that method of a singleton instance that’s used to initialize a <code>&lt;&gt;9</code> field. That’s done<br />
because delegates to static methods use something called a “shuffle thunk” to move arguments into<br />
the right place for the target method invocation, making delegates to statics ever so slightly more<br />
expensive to invoke than delegates to instance methods.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>InvokeInstance</td>
<td>0.8858 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>InvokeStatic</td>
<td>1.3979 ns</td>
<td>1.58</td>
</tr>
</tbody>
</table>
<p>So, the compiler is able to cache references to lambdas, great. What about method groups, i.e. where<br />
you just name the method directly? Previously, if changed my code to:</p>
<p>the compiler would generate the equivalent of:</p>
<p>221 CHAPTER 23 | Analyzers</p>
<p>which has the unfortunate effect of allocating a new delegate on every invocation, even though we’re<br />
<a href="https://github.com/dotnet/roslyn/pull/58288">still dealing with the exact same static method. Thanks to dotnet/roslyn#58288</a> from</p>
<p><a href="https://github.com/pawchen">@pawchen</a>, the compiler will now generate the equivalent of:</p>
<p>Note we again have a caching field that’s used to enable allocating the delegate once and caching it.<br />
That means that places where code was using a lambda to enable this caching can now switch back to<br />
the cleaner and simpler method group way of expressing the desired functionality. There is the<br />
interesting difference to be cognizant of that since we don’t have a lambda which required the<br />
compiler emitting a new method for, we’re still creating a delegate directly to the static method.<br />
However, the minor difference in thunk overhead is typically made up for by the fact that we don’t<br />
have a second method to invoke; in the common case where the static helper being invoked isn’t<br />
inlinable (because it’s not super tiny, because it has exception handling, etc.), we previously would<br />
have incurred the cost of the delegate invocation plus the non-inlinable method call, and now we just<br />
have the cost of an ever-so-slightly more expensive delegate invocation; on the whole, it’s typically a<br />
wash.</p>
<p>And that brings us to IDE0200, which recognizes lambda expressions that can be removed.<br />
<a href="https://github.com/dotnet/runtime/pull/71011">dotnet/runtime#71011</a> <a href="https://github.com/dotnet/runtime">enabled the analyzer for dotnet/runtime, resulting in more than 100 call sites</a><br />
changing accordingly. However, IDE0200 does more than just this mostly stylistic change. It also<br />
recognizes some patterns that can make a more substantial impact. Consider this code that was<br />
changed as part of that PR:</p>
<p>That delegate closes over the <code>disposable</code> local, which means this method needs to allocate a display<br />
class. But IDE0200 recognizes that instead of closing over <code>disposable</code>, we can create the delegate<br />
directly to the Dispose method:</p>
<p>222 CHAPTER 23 | Analyzers</p>
<p>We still get a delegate allocation, but we avoid the display class allocation, and as a bonus we save on<br />
the additional metadata required for the synthesized display class and method generated for the<br />
lambda.</p>
<p>IDE0020 is another good example of an analyzer that is primarily focused on making code cleaner,<br />
more maintainable, more modern, but that can also lead to removing overhead from many different<br />
places. The analyzer looks for code performing unnecessary duplicative casts and recommends using<br />
<a href="https://github.com/dotnet/runtime/pull/70523">C# pattern matching syntax instead. For example, dotnet/runtime#70523 enabled the analyzer and</a><br />
switched more than 250 locations from code like:</p>
<p>to instead be like:</p>
<p>In addition to being cleaner, this ends up saving a cast operation, which can add measurable<br />
overhead if the JIT is unable to remove it:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithCast</td>
<td>2.602 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>WithPattern</td>
<td>1.886 ns</td>
<td>0.73</td>
</tr>
</tbody>
</table>
<p>Then there’s IDE0031, which promotes using null propagation features of C#. This analyzer typically<br />
manifests as recommending changing snippets like:</p>
<pre><code>return _value != null ? _value.Property : null ;

</code></pre>
<p>into code that’s instead like:</p>
<p>223 CHAPTER 23 | Analyzers</p>
<pre><code>return _value?.Property;

</code></pre>
<p>Nice, concise, and primarily about cleaning up the code and making it simpler and more maintainable<br />
by utilizing newer C# syntax. However, there is also a small performance advantage in some situations<br />
as well. For example, consider this snippet:</p>
<p>The C# compiler lowers these expressions to the equivalent of this:</p>
<p>for which the JIT then generates:</p>
<p>224 CHAPTER 23 | Analyzers</p>
<p>the local means the JIT doesn’t need to add an additional null check on the second use of the local,<br />
<a href="https://github.com/dotnet/runtime/pull/70965">since nothing could have changed it. dotnet/runtime#70965</a> rolled out additional use of the null<br />
propagation operator via auto-fixing IDE0031, resulting in ~120 uses being improved.</p>
<p>Another interesting example is IDE0060, which finds unused parameters and recommends removing<br />
<a href="https://github.com/dotnet/runtime/pull/63015">them. This was done for non-public members in System.Private.CoreLib in dotnet/runtime#63015. As</a><br />
with some of the other mentioned rules, it’s primarily about good hygiene. There can be some small<br />
additional cost associated with passing additional parameters (the overhead of reading the values at<br />
the call site, putting them into the right register or stack location, etc., and also the metadata size<br />
associated with the additional parameter information), but the larger benefit comes from auditing all<br />
of the cited violations and finding places where work is simply being performed unnecessarily. For<br />
example, that PR made some updates to the <code>TimeZoneInfo</code> type’s implementation for Unix. In that<br />
implementation is a <code>TZif_ParseRaw</code> method, which is used to extract some information from a time<br />
zone data file. Amongst many input and output parameters, it had <code>out bool[] StandardTime, out</code></p>
<p><code>bool[] GmtTime</code>, which the implementation was dutifully filling in by allocating and populating new</p>
<p><code>TZif_ParseRaw</code> to no longer need to allocate and populate those arrays at all, which obviously yields<br />
a much larger gain.</p>
<p>One final example of peanut-buttery performance improvements from applying an analyzer comes<br />
<a href="https://github.com/dotnet/runtime/pull/70896">from dotnet/runtime#70896 and dotnet/runtime#71361, which applied IDE0029 across</a><br />
dotnet/runtime. IDE0029 flags cases where null coalescing can be used, e.g. flagging:</p>
<pre><code>return message != null ? message : string.Empty;

</code></pre>
<p>and recommending it be converted to:</p>
<pre><code>return message ?? string.Empty;

</code></pre>
<p>As with some of the previous rules discussed, that in and of itself doesn’t make a meaningful<br />
performance improvement, and rather is about clarity and simplicity. However, in various cases it can.<br />
For example, the aforementioned PRs contained an example like:</p>
<pre><code>null != foundColumns[i] ? foundColumns[i] : DBNull.Value;

</code></pre>
<p>which is rewritten to:</p>
<pre><code>foundColumns[i] ?? DBNull.Value

</code></pre>
<p>This avoids an unnecessary re-access to an array. Or again from those PRs the expression:</p>
<p>225 CHAPTER 23 | Analyzers</p>
<pre><code>entry.GetKey(_thisCollection) != null ? entry.GetKey(_thisCollection) : &quot;key&quot;

</code></pre>
<p>being changed to:</p>
<pre><code>entry.GetKey(_thisCollection) ?? &quot;key&quot;

</code></pre>
<p>and avoiding an unnecessary table lookup.</p>
<p>226 CHAPTER 23 | Analyzers</p>
<p><strong>CHAPTER</strong></p>
<h1>24</h1>
<h2>What’s Next?</h2>
<p>Whew! That was a lot. Congrats on getting through it all.</p>
<p>The next step is on you. Download the latest .NET 7 bits and take them for a spin. Upgrade your apps.<br />
Write and share your own benchmarks. Provide feedback, positive and critical. Find something you<br />
think can be better? Open an issue, or better yet, submit a PR with the fix. We’re excited to work with<br />
you to polish .NET 7 to be the best .NET release yet; meanwhile, we’re getting going on .NET 8 :)</p>
<p>Until next time…</p>
<p>Happy coding!</p>
<p>227 CHAPTER 24 | What’s Next?</p>
