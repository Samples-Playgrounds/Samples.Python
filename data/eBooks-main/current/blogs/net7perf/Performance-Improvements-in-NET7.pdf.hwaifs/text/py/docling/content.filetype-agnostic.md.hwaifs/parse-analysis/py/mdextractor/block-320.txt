using System.Buffers; using System.Diagnostics; using System.IO . Compression; using System.Text; using var hc = new HttpClient(); byte[] data = await hc.GetByteArrayAsync("https://www.gutenberg.org/ebooks/100.txt.utf-8"); Console.WriteLine(data.Length); var compressed = new MemoryStream(); var sw = new Stopwatch(); for (int level = 0; level <= 11; level++) { const int Trials = 10; compressed.Position = 0; Compress(level, data, compressed); sw.Restart(); for (int i = 0; i < Trials; i++) { compressed.Position = 0; Compress(level, data, compressed); } sw.Stop(); Console.WriteLine($"{level},{sw.Elapsed.TotalMilliseconds / Trials},{compressed.Position}"); static void Compress(int level, byte[] data, Stream destination) { var encoder = new BrotliEncoder(quality: level, window: 22); Write(ref encoder, data, destination, false); Write(ref encoder, Array.Empty<byte>(), destination, true); encoder.Dispose(); static void Write(ref BrotliEncoder encoder, byte[] data, Stream destination, bool isFinalBlock) { byte[] output = ArrayPool<byte>.Shared . Rent(4096); OperationStatus lastResult = OperationStatus.DestinationTooSmall; ReadOnlySpan<byte> buffer = data; while (lastResult == OperationStatus.DestinationTooSmall) { lastResult = encoder.Compress(buffer, output, out int bytesConsumed, out int bytesWritten, isFinalBlock); if (lastResult == OperationStatus.InvalidData) throw new InvalidOperationException(); if (bytesWritten > 0) destination.Write(output.AsSpan(0, bytesWritten)); if (bytesConsumed > 0) buffer = buffer.Slice(bytesConsumed); } ArrayPool<byte>.Shared . Return(output); }