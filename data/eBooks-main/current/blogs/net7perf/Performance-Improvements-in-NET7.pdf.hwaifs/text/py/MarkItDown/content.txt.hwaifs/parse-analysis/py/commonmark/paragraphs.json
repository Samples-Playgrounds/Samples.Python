[
    "Performance Improvements",
    "Performance Improvements",
    "Stephen Toub",
    "Stephen Toub",
    "Partner Software Engineer, .NET",
    "Partner Software Engineer, .NET",
    "Microsoft",
    "Microsoft",
    "Introduction",
    "Introduction",
    "A year ago, I published Performance Improvements in .NET 6, following on the heels of similar posts",
    "A year ago, I published Performance Improvements in .NET 6, following on the heels of similar posts",
    "As with previous versions of .NET, performance is a key focus that pervades the entire stack, whether it",
    "As with previous versions of .NET, performance is a key focus that pervades the entire stack, whether it",
    "One thought before we dive in. In past years, I\u2019ve received the odd piece of negative feedback about",
    "One thought before we dive in. In past years, I\u2019ve received the odd piece of negative feedback about",
    "TL;DR: .NET 7 is fast. Really fast. A thousand performance-impacting PRs went into runtime and core",
    "TL;DR: .NET 7 is fast. Really fast. A thousand performance-impacting PRs went into runtime and core",
    "Or, if you prefer a slightly longer adventure, one filled with interesting nuggets of performance-",
    "Or, if you prefer a slightly longer adventure, one filled with interesting nuggets of performance-",
    "Both noted paths achieve one of my primary goals for spending the time to write these posts, to",
    "Both noted paths achieve one of my primary goals for spending the time to write these posts, to",
    "gnarly problem, think about looking at the source for the component they\u2019re using in order to better",
    "gnarly problem, think about looking at the source for the component they\u2019re using in order to better",
    "Contents",
    "Contents",
    "Setup ......................................................................................................................................... 1",
    "Setup ......................................................................................................................................... 1",
    "JIT .............................................................................................................................................. 3",
    "JIT .............................................................................................................................................. 3",
    "On-Stack Replacement .................................................................................................................................................. 13",
    "On-Stack Replacement .................................................................................................................................................. 13",
    "PGO ........................................................................................................................................................................................ 23",
    "PGO ........................................................................................................................................................................................ 23",
    "Bounds Check Elimination ............................................................................................................................................ 35",
    "Bounds Check Elimination ............................................................................................................................................ 35",
    "Loop Hoisting and Cloning .......................................................................................................................................... 45",
    "Loop Hoisting and Cloning .......................................................................................................................................... 45",
    "Folding, propagation, and substitution ................................................................................................................... 50",
    "Folding, propagation, and substitution ................................................................................................................... 50",
    "Vectorization ...................................................................................................................................................................... 54",
    "Vectorization ...................................................................................................................................................................... 54",
    "Inlining .................................................................................................................................................................................. 62",
    "Inlining .................................................................................................................................................................................. 62",
    "Arm64 ................................................................................................................................................................................... 64",
    "Arm64 ................................................................................................................................................................................... 64",
    "JIT helpers ........................................................................................................................................................................... 65",
    "JIT helpers ........................................................................................................................................................................... 65",
    "Grab Bag .............................................................................................................................................................................. 67",
    "Grab Bag .............................................................................................................................................................................. 67",
    "GC ............................................................................................................................................ 71",
    "GC ............................................................................................................................................ 71",
    "Native AOT ............................................................................................................................. 72",
    "Native AOT ............................................................................................................................. 72",
    "Mono ...................................................................................................................................... 75",
    "Mono ...................................................................................................................................... 75",
    "Reflection ............................................................................................................................... 78",
    "Reflection ............................................................................................................................... 78",
    "Interop .................................................................................................................................... 82",
    "Interop .................................................................................................................................... 82",
    "Threading ............................................................................................................................... 89",
    "Threading ............................................................................................................................... 89",
    "Primitive Types and Numerics ............................................................................................. 93",
    "Primitive Types and Numerics ............................................................................................. 93",
    "Arrays, Strings, and Spans .................................................................................................. 101",
    "Arrays, Strings, and Spans .................................................................................................. 101",
    "Regex .................................................................................................................................... 128",
    "Regex .................................................................................................................................... 128",
    "RegexOptions.NonBacktracking............................................................................................................................... 128",
    "RegexOptions.NonBacktracking............................................................................................................................... 128",
    "New APIs ............................................................................................................................................................................ 133",
    "New APIs ............................................................................................................................................................................ 133",
    "TryFindNextPossibleStartingPosition ..................................................................................................................... 138",
    "TryFindNextPossibleStartingPosition ..................................................................................................................... 138",
    "Loops and Backtracking .............................................................................................................................................. 143",
    "Loops and Backtracking .............................................................................................................................................. 143",
    "Code generation ............................................................................................................................................................. 146",
    "Code generation ............................................................................................................................................................. 146",
    "Collections ............................................................................................................................ 150",
    "Collections ............................................................................................................................ 150",
    "LINQ ...................................................................................................................................... 153",
    "LINQ ...................................................................................................................................... 153",
    "i",
    "i",
    "Contents",
    "Contents",
    "File I/O .................................................................................................................................. 159",
    "File I/O .................................................................................................................................. 159",
    "Compression ........................................................................................................................ 168",
    "Compression ........................................................................................................................ 168",
    "Networking .......................................................................................................................... 173",
    "Networking .......................................................................................................................... 173",
    "JSON ..................................................................................................................................... 190",
    "JSON ..................................................................................................................................... 190",
    "XML ....................................................................................................................................... 193",
    "XML ....................................................................................................................................... 193",
    "Cryptography ....................................................................................................................... 198",
    "Cryptography ....................................................................................................................... 198",
    "Diagnostics ........................................................................................................................... 203",
    "Diagnostics ........................................................................................................................... 203",
    "Exceptions ............................................................................................................................ 208",
    "Exceptions ............................................................................................................................ 208",
    "Registry ................................................................................................................................ 211",
    "Registry ................................................................................................................................ 211",
    "Analyzers .............................................................................................................................. 213",
    "Analyzers .............................................................................................................................. 213",
    "What\u2019s Next? ........................................................................................................................ 227",
    "What\u2019s Next? ........................................................................................................................ 227",
    "ii",
    "ii",
    "Contents",
    "Contents",
    "CHAPTER  1",
    "CHAPTER  1",
    "Setup",
    "Setup",
    "The microbenchmarks throughout this post utilize benchmarkdotnet. To make it easy for you to follow",
    "The microbenchmarks throughout this post utilize benchmarkdotnet. To make it easy for you to follow",
    "dotnet new console -o benchmarks",
    "dotnet new console -o benchmarks",
    "Your new benchmarks directory will contain a benchmarks.csproj file and a Program.cs file. Replace",
    "Your new benchmarks directory will contain a benchmarks.csproj file and a Program.cs file. Replace",
    "and the contents of Program.cs with this:",
    "and the contents of Program.cs with this:",
    "using BenchmarkDotNet.Attributes;",
    "using BenchmarkDotNet.Attributes;",
    "1",
    "1",
    "CHAPTER 1 | Setup",
    "CHAPTER 1 | Setup",
    "using System.Reflection;",
    "using System.Reflection;",
    "[",
    "[",
    "}",
    "}",
    "For each benchmark included in this write-up, you can then just copy and paste the code into this test",
    "For each benchmark included in this write-up, you can then just copy and paste the code into this test",
    "dotnet run -c Release -f net6.0 --filter ",
    "dotnet run -c Release -f net6.0 --filter ",
    "This command says \u201cbuild the benchmarks in release configuration targeting the .NET 6 surface area,",
    "This command says \u201cbuild the benchmarks in release configuration targeting the .NET 6 surface area,",
    "dotnet run -c Release -f net7.0 --filter ",
    "dotnet run -c Release -f net7.0 --filter ",
    "which instead builds targeting the .NET 7 surface area and then only runs once against .NET 7. You",
    "which instead builds targeting the .NET 7 surface area and then only runs once against .NET 7. You",
    "The release of the first .NET 7 release candidate is right around the corner. All of the measurements in",
    "The release of the first .NET 7 release candidate is right around the corner. All of the measurements in",
    "Also, my standard caveat: These are microbenchmarks. It is expected that different hardware, different",
    "Also, my standard caveat: These are microbenchmarks. It is expected that different hardware, different",
    "2",
    "2",
    "CHAPTER 1 | Setup",
    "CHAPTER 1 | Setup",
    "CHAPTER  2",
    "CHAPTER  2",
    "JIT",
    "JIT",
    "I\u2019d like to kick off a discussion of performance improvements in the Just-In-Time (JIT) compiler by",
    "I\u2019d like to kick off a discussion of performance improvements in the Just-In-Time (JIT) compiler by",
    "One common approach is to use the ",
    "One common approach is to use the ",
    "using BenchmarkDotNet.Attributes;",
    "using BenchmarkDotNet.Attributes;",
    "[",
    "[",
    "}",
    "}",
    "with:",
    "with:",
    "dotnet run -c Release -f net7.0 --filter ",
    "dotnet run -c Release -f net7.0 --filter ",
    "in addition to doing all of its normal test execution and timing, benchmarkdotnet also outputs a",
    "in addition to doing all of its normal test execution and timing, benchmarkdotnet also outputs a",
    "; Program.Min()",
    "; Program.Min()",
    "3",
    "3",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "jg        short M00",
    "jg        short M00",
    "Pretty neat. This support was recently improved further in dotnet/benchmarkdotnet#2072, which",
    "Pretty neat. This support was recently improved further in dotnet/benchmarkdotnet#2072, which",
    "If you can get your hands on a \u201cdebug\u201d or \u201cchecked\u201d build of the .NET runtime (\u201cchecked\u201d is a build",
    "If you can get your hands on a \u201cdebug\u201d or \u201cchecked\u201d build of the .NET runtime (\u201cchecked\u201d is a build",
    "\u2026 until .NET 7, that is. As of dotnet/runtime#73365, this assembly dumping support is now available in",
    "\u2026 until .NET 7, that is. As of dotnet/runtime#73365, this assembly dumping support is now available in",
    "using System;",
    "using System;",
    "class Program",
    "class Program",
    "and building it (e.g. dotnet build -c Release). Then, set the DOTNET",
    "and building it (e.g. dotnet build -c Release). Then, set the DOTNET",
    "$env:DOTNET",
    "$env:DOTNET",
    "and then running the app. You should see code like this output to the console:",
    "and then running the app. You should see code like this output to the console:",
    "; Assembly listing for method Program:Main()",
    "; Assembly listing for method Program:Main()",
    "G",
    "G",
    "4",
    "4",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "488D6C2420           lea      rbp, ",
    "488D6C2420           lea      rbp, ",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 36",
    "; Total bytes of code 36",
    "Hello, world",
    "Hello, world",
    "This is immeasurably helpful for performance analysis and tuning, even for questions as simple as \u201cdid",
    "This is immeasurably helpful for performance analysis and tuning, even for questions as simple as \u201cdid",
    "Note that it can sometimes be a little confusing figuring out what name to specify as the value for",
    "Note that it can sometimes be a little confusing figuring out what name to specify as the value for",
    "1: JIT compiled CastHelpers:StelemRef(Array,long,Object) ",
    "1: JIT compiled CastHelpers:StelemRef(Array,long,Object) ",
    "We can see for \u201chello, world\u201d there\u2019s only 5 methods that actually get JIT compiled. There are of",
    "We can see for \u201chello, world\u201d there\u2019s only 5 methods that actually get JIT compiled. There are of",
    "5",
    "5",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "method, which doesn\u2019t have R2R code, either, due to using the variable-width Vector",
    "method, which doesn\u2019t have R2R code, either, due to using the variable-width Vector",
    "1: JIT compiled CastHelpers:StelemRef(Array,long,Object) ",
    "1: JIT compiled CastHelpers:StelemRef(Array,long,Object) ",
    "6",
    "6",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "size=8, code size=39",
    "size=8, code size=39",
    "7",
    "7",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "77: JIT compiled Dictionary",
    "77: JIT compiled Dictionary",
    "8",
    "8",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "116: JIT compiled",
    "116: JIT compiled",
    "9",
    "9",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "152: JIT compiled Encoding:.cctor() ",
    "152: JIT compiled Encoding:.cctor() ",
    "10",
    "10",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "196: JIT compiled StreamWriter:.ctor(Stream,Encoding,int,bool):this ",
    "196: JIT compiled StreamWriter:.ctor(Stream,Encoding,int,bool):this ",
    "11",
    "11",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "240: JIT compiled EncoderNLS:GetBytes(long,int,long,int,bool):int:this ",
    "240: JIT compiled EncoderNLS:GetBytes(long,int,long,int,bool):int:this ",
    "12",
    "12",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "282: JIT compiled Enumerator:get",
    "282: JIT compiled Enumerator:get",
    "With that out of the way, let\u2019s move on to actual performance improvements, starting with on-stack",
    "With that out of the way, let\u2019s move on to actual performance improvements, starting with on-stack",
    "On-Stack Replacement",
    "On-Stack Replacement",
    "On-stack replacement (OSR) is one of the coolest features to hit the JIT in .NET 7. But to really",
    "On-stack replacement (OSR) is one of the coolest features to hit the JIT in .NET 7. But to really",
    "One of the issues a managed environment with a JIT compiler has to deal with is tradeoffs between",
    "One of the issues a managed environment with a JIT compiler has to deal with is tradeoffs between",
    "13",
    "13",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "certain baseline instruction set (e.g. what vectorizing instructions are available) whereas the JIT can see",
    "certain baseline instruction set (e.g. what vectorizing instructions are available) whereas the JIT can see",
    "Tiered compilation enables the JIT to have its proverbial cake and eat it, too. The idea is simple: allow",
    "Tiered compilation enables the JIT to have its proverbial cake and eat it, too. The idea is simple: allow",
    "A problem, however, is methods that don\u2019t fit this mold. While it\u2019s certainly the case that many",
    "A problem, however, is methods that don\u2019t fit this mold. While it\u2019s certainly the case that many",
    "class Program",
    "class Program",
    "}",
    "}",
    "I get numbers printed out like:",
    "I get numbers printed out like:",
    "14",
    "14",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "00:00:00.5734352",
    "00:00:00.5734352",
    "Now, try setting DOTNET",
    "Now, try setting DOTNET",
    "00:00:01.2841397",
    "00:00:01.2841397",
    "In other words, with DOTNET",
    "In other words, with DOTNET",
    "00:00:00.5528889",
    "00:00:00.5528889",
    "but importantly, this method was still participating in tiering. In fact, we can get confirmation of that",
    "but importantly, this method was still participating in tiering. In fact, we can get confirmation of that",
    "4: JIT compiled Program:Main() ",
    "4: JIT compiled Program:Main() ",
    "highlighting that Main was indeed compiled twice. How is that possible? On-stack replacement.",
    "highlighting that Main was indeed compiled twice. How is that possible? On-stack replacement.",
    "The idea behind on-stack replacement is a method can be replaced not just between invocations but",
    "The idea behind on-stack replacement is a method can be replaced not just between invocations but",
    "; Assembly listing for method Program:Main()",
    "; Assembly listing for method Program:Main()",
    "G",
    "G",
    "15",
    "15",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "4881EC80000000       sub      rsp, 128",
    "4881EC80000000       sub      rsp, 128",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "16",
    "16",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 222",
    "; Total bytes of code 222",
    "; Assembly listing for method Program:",
    "; Assembly listing for method Program:",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "A few relevant things to notice here. First, the comments at the top highlight how this code was",
    "A few relevant things to notice here. First, the comments at the top highlight how this code was",
    "; Tier-0 compilation",
    "; Tier-0 compilation",
    "So, we know this is the initial version (\u201cTier-0\u201d) of the method compiled with minimal optimization",
    "So, we know this is the initial version (\u201cTier-0\u201d) of the method compiled with minimal optimization",
    "FF152DD40B00         call     ",
    "FF152DD40B00         call     ",
    "Our IsAsciiDigit helper method is trivially inlineable, but it\u2019s not getting inlined; instead, the",
    "Our IsAsciiDigit helper method is trivially inlineable, but it\u2019s not getting inlined; instead, the",
    "17",
    "17",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "C745A8E8030000       mov      dword ptr ",
    "C745A8E8030000       mov      dword ptr ",
    "That 0x3E8 is the hex value for the decimal 1,000, which is the default number of iterations a loop",
    "That 0x3E8 is the hex value for the decimal 1,000, which is the default number of iterations a loop",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "The generated code is loading that counter into the ecx register, decrementing it, storing it back, and",
    "The generated code is loading that counter into the ecx register, decrementing it, storing it back, and",
    "; Assembly listing for method Program:Main()",
    "; Assembly listing for method Program:Main()",
    "G",
    "G",
    "G",
    "G",
    "18",
    "18",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "19",
    "19",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "48B9F04BF24FFC7F0000 mov      rcx, 0x7FFC4FF24BF0",
    "48B9F04BF24FFC7F0000 mov      rcx, 0x7FFC4FF24BF0",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 351",
    "; Total bytes of code 351",
    "Here, again, we notice a few interesting things. First, in the header we see this:",
    "Here, again, we notice a few interesting things. First, in the header we see this:",
    "; Tier-1 compilation",
    "; Tier-1 compilation",
    "so we know this is both optimized \u201ctier-1\u201d code and is the \u201cOSR variant\u201d for this method. Second,",
    "so we know this is both optimized \u201ctier-1\u201d code and is the \u201cOSR variant\u201d for this method. Second,",
    "G",
    "G",
    "This is loading a value into rcx, subtracting 48 from it (48 is the decimal ASCII value of the ",
    "This is loading a value into rcx, subtracting 48 from it (48 is the decimal ASCII value of the ",
    "Great, so now in .NET 7, we can largely avoid the tradeoffs between startup and throughput, as OSR",
    "Great, so now in .NET 7, we can largely avoid the tradeoffs between startup and throughput, as OSR",
    "20",
    "20",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "But, tiered compilation and OSR aren\u2019t just about startup (though they\u2019re of course very valuable",
    "But, tiered compilation and OSR aren\u2019t just about startup (though they\u2019re of course very valuable",
    "using System.Runtime.CompilerServices;",
    "using System.Runtime.CompilerServices;",
    "class Program",
    "class Program",
    "}",
    "}",
    "When I do so, I get this output:",
    "When I do so, I get this output:",
    "; Assembly listing for method Program:Test():bool",
    "; Assembly listing for method Program:Test():bool",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 43",
    "; Total bytes of code 43",
    "21",
    "21",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "; Assembly listing for method Program:Test():bool",
    "; Assembly listing for method Program:Test():bool",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 6",
    "; Total bytes of code 6",
    "Note, again, we see two outputs for Program:Test. First, we see the \u201cTier-0\u201d code, which is accessing a",
    "Note, again, we see two outputs for Program:Test. First, we see the \u201cTier-0\u201d code, which is accessing a",
    "Since the \u201cTier-0\u201d code had to have executed in order for it to tier up, the \u201cTier-1\u201d code was",
    "Since the \u201cTier-0\u201d code had to have executed in order for it to tier up, the \u201cTier-1\u201d code was",
    "This is so useful that components are now written with tiering in mind. Consider the new Regex source",
    "This is so useful that components are now written with tiering in mind. Consider the new Regex source",
    "static class Utilities",
    "static class Utilities",
    "which it then uses at call sites like this:",
    "which it then uses at call sites like this:",
    "if (Utilities.s",
    "if (Utilities.s",
    "In tier-0, these checks will still be emitted in the assembly code, but in tier-1 where throughput",
    "In tier-0, these checks will still be emitted in the assembly code, but in tier-1 where throughput",
    "22",
    "22",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "Timeout.InfiniteTimeSpan, at which point s",
    "Timeout.InfiniteTimeSpan, at which point s",
    "But, this is somewhat old news. The JIT has been able to do such an optimization since tiered",
    "But, this is somewhat old news. The JIT has been able to do such an optimization since tiered",
    "PGO",
    "PGO",
    "I wrote about profile-guided optimization (PGO) in my Performance Improvements in .NET 6 post, but",
    "I wrote about profile-guided optimization (PGO) in my Performance Improvements in .NET 6 post, but",
    "PGO has been around for a long time, in any number of languages and compilers. The basic idea is",
    "PGO has been around for a long time, in any number of languages and compilers. The basic idea is",
    "Dynamic PGO takes advantage of tiered compilation. I noted that the JIT instruments the tier-0 code",
    "Dynamic PGO takes advantage of tiered compilation. I noted that the JIT instruments the tier-0 code",
    "class Program",
    "class Program",
    "23",
    "23",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "}",
    "}",
    "}",
    "}",
    "The tier-0 code for DoWork ends up looking like this:",
    "The tier-0 code for DoWork ends up looking like this:",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "and most notably, you can see the call ",
    "and most notably, you can see the call ",
    "G",
    "G",
    "G",
    "G",
    "24",
    "24",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "G",
    "G",
    "That first block is checking the concrete type of the IPrinter (stored in rdi) and comparing it against",
    "That first block is checking the concrete type of the IPrinter (stored in rdi) and comparing it against",
    "That all existed in .NET 6, so why are we talking about it now? Several things have improved. First,",
    "That all existed in .NET 6, so why are we talking about it now? Several things have improved. First,",
    "PGO already knew how to instrument virtual dispatch. Now in .NET 7, thanks in large part to",
    "PGO already knew how to instrument virtual dispatch. Now in .NET 7, thanks in large part to",
    "using System.Runtime.CompilerServices;",
    "using System.Runtime.CompilerServices;",
    "class Program",
    "class Program",
    "}",
    "}",
    "Without PGO enabled, I get generated optimized assembly like this:",
    "Without PGO enabled, I get generated optimized assembly like this:",
    "; Assembly listing for method Program:Sum(ref,Func",
    "; Assembly listing for method Program:Sum(ref,Func",
    "25",
    "25",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "; optimized code",
    "; optimized code",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 64",
    "; Total bytes of code 64",
    "Note the call ",
    "Note the call ",
    "; Assembly listing for method Program:Sum(ref,Func",
    "; Assembly listing for method Program:Sum(ref,Func",
    "G",
    "G",
    "26",
    "26",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "4157                 push     r15",
    "4157                 push     r15",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "I chose the 42 constant in i => i ",
    "I chose the 42 constant in i => i ",
    "G",
    "G",
    "27",
    "27",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "751D                 jne      SHORT G",
    "751D                 jne      SHORT G",
    "This is loading the target address from the delegate into r8 and is loading the address of the",
    "This is loading the target address from the delegate into r8 and is loading the address of the",
    "static int",
    "static int",
    "[",
    "[",
    "static int Sum(int",
    "static int Sum(int",
    "With PGO disabled, we get the same performance throughput for .NET 6 and .NET 7:",
    "With PGO disabled, we get the same performance throughput for .NET 6 and .NET 7:",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "DelegatePGO",
    "DelegatePGO",
    ".NET 6.0",
    ".NET 6.0",
    "1.665 us",
    "1.665 us",
    "1.00",
    "1.00",
    "DelegatePGO",
    "DelegatePGO",
    ".NET 7.0",
    ".NET 7.0",
    "1.659 us",
    "1.659 us",
    "1.00",
    "1.00",
    "But the picture changes when we enable dynamic PGO (DOTNET",
    "But the picture changes when we enable dynamic PGO (DOTNET",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "DelegatePGO",
    "DelegatePGO",
    ".NET 6.0",
    ".NET 6.0",
    "1,427.7 ns",
    "1,427.7 ns",
    "1.00",
    "1.00",
    "DelegatePGO",
    "DelegatePGO",
    ".NET 7.0",
    ".NET 7.0",
    "539.0 ns",
    "539.0 ns",
    "0.38",
    "0.38",
    "dotnet/runtime#70377 is another valuable improvement with dynamic PGO, which enables PGO to",
    "dotnet/runtime#70377 is another valuable improvement with dynamic PGO, which enables PGO to",
    "using System.Runtime.CompilerServices;",
    "using System.Runtime.CompilerServices;",
    "class Program",
    "class Program",
    "28",
    "28",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "[",
    "[",
    "}",
    "}",
    "The JIT doesn\u2019t know whether the passed in array is of sufficient length that all accesses to array",
    "The JIT doesn\u2019t know whether the passed in array is of sufficient length that all accesses to array",
    "if (array is not null ",
    "if (array is not null ",
    "That way, at the expense of some code duplication, we get our fast loop without bounds checks and",
    "That way, at the expense of some code duplication, we get our fast loop without bounds checks and",
    "; Assembly listing for method Program:Test(ref):bool",
    "; Assembly listing for method Program:Test(ref):bool",
    "G",
    "G",
    "29",
    "29",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 98",
    "; Total bytes of code 98",
    "That G",
    "That G",
    "G",
    "G",
    "30",
    "30",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "3D45230100           cmp      eax, 0x12345",
    "3D45230100           cmp      eax, 0x12345",
    "with the bounds checks only showing up in the slow-path block:",
    "with the bounds checks only showing up in the slow-path block:",
    "G",
    "G",
    "That\u2019s \u201cloop cloning.\u201d What about \u201cinvariant hoisting\u201d? Hoisting means pulling something out of a",
    "That\u2019s \u201cloop cloning.\u201d What about \u201cinvariant hoisting\u201d? Hoisting means pulling something out of a",
    "[",
    "[",
    "}",
    "}",
    "Note that the value of array.Length - 42 doesn\u2019t change on each iteration of the loop, so it\u2019s",
    "Note that the value of array.Length - 42 doesn\u2019t change on each iteration of the loop, so it\u2019s",
    "G",
    "G",
    "G",
    "G",
    "31",
    "31",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "Here again we see the array being tested for null (test rcx, rcx) and the array\u2019s length being",
    "Here again we see the array being tested for null (test rcx, rcx) and the array\u2019s length being",
    "Ok, so how does this apply to dynamic PGO? Remember that with the interface/virtual dispatch",
    "Ok, so how does this apply to dynamic PGO? Remember that with the interface/virtual dispatch",
    "using System.Runtime.CompilerServices;",
    "using System.Runtime.CompilerServices;",
    "class Program",
    "class Program",
    "}",
    "}",
    "When we look at the optimized assembly generated for this with dynamic PGO enabled, we see this:",
    "When we look at the optimized assembly generated for this with dynamic PGO enabled, we see this:",
    "; Assembly listing for method Program:DoWork(IPrinter)",
    "; Assembly listing for method Program:DoWork(IPrinter)",
    "32",
    "32",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "; rsp based frame",
    "; rsp based frame",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 127",
    "; Total bytes of code 127",
    "We can see in the G",
    "We can see in the G",
    "33",
    "33",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "jne SHORT G",
    "jne SHORT G",
    "Interestingly, improvements like this can bring with them their own challenges. PGO leads to a",
    "Interestingly, improvements like this can bring with them their own challenges. PGO leads to a",
    "[",
    "[",
    "On .NET 6, the JIT produced this assembly code:",
    "On .NET 6, the JIT produced this assembly code:",
    "; Program.AllAreStrings(System.Object, System.Object, System.Object, System.Object)",
    "; Program.AllAreStrings(System.Object, System.Object, System.Object, System.Object)",
    "Note the C# has four tests for string and the assembly code has four loads with mov rax,offset",
    "Note the C# has four tests for string and the assembly code has four loads with mov rax,offset",
    "; Program.AllAreStrings(System.Object, System.Object, System.Object, System.Object)",
    "; Program.AllAreStrings(System.Object, System.Object, System.Object, System.Object)",
    "34",
    "34",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "mov       rax,offset MT",
    "mov       rax,offset MT",
    "Bounds Check Elimination",
    "Bounds Check Elimination",
    "One of the things that makes .NET attractive is its safety. The runtime guards access to arrays, strings,",
    "One of the things that makes .NET attractive is its safety. The runtime guards access to arrays, strings,",
    "[",
    "[",
    "results in:",
    "results in:",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "The array is passed into this method in the rcx register, pointing to the method table pointer in the",
    "The array is passed into this method in the rcx register, pointing to the method table pointer in the",
    "35",
    "35",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "of the array and comparing the length to 0; that makes sense, since the length can\u2019t be negative, and",
    "of the array and comparing the length to 0; that makes sense, since the length can\u2019t be negative, and",
    "While these bounds checks in and of themselves aren\u2019t super expensive, do a lot of them and their",
    "While these bounds checks in and of themselves aren\u2019t super expensive, do a lot of them and their",
    "For example, dotnet/runtime#61662 from ",
    "For example, dotnet/runtime#61662 from ",
    "[",
    "[",
    "}",
    "}",
    "It\u2019s validating that the input span is 16 bytes long and then creating a new ushort",
    "It\u2019s validating that the input span is 16 bytes long and then creating a new ushort",
    "cmp       r8d,10",
    "cmp       r8d,10",
    "where that G",
    "where that G",
    "G",
    "G",
    "G",
    "G",
    "36",
    "36",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "83F910               cmp      ecx, 16",
    "83F910               cmp      ecx, 16",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 100",
    "; Total bytes of code 100",
    "No bounds checks, which is most easily seen by the lack of the telltale call",
    "No bounds checks, which is most easily seen by the lack of the telltale call",
    "dotnet/runtime#61569 and dotnet/runtime#62864 also help to eliminate bounds checks when dealing",
    "dotnet/runtime#61569 and dotnet/runtime#62864 also help to eliminate bounds checks when dealing",
    "[",
    "[",
    "37",
    "37",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "return (uint)i ",
    "return (uint)i ",
    "On .NET 6, we get this assembly:",
    "On .NET 6, we get this assembly:",
    "; Program.GetChar(Int32)",
    "; Program.GetChar(Int32)",
    "The beginning of this makes sense: the JIT was obviously able to see that the length of Text is 5, so",
    "The beginning of this makes sense: the JIT was obviously able to see that the length of Text is 5, so",
    "; Program.GetChar(Int32)",
    "; Program.GetChar(Int32)",
    "So much nicer.",
    "So much nicer.",
    "dotnet/runtime#67141 is a great example of how evolving ecosystem needs drives specific",
    "dotnet/runtime#67141 is a great example of how evolving ecosystem needs drives specific",
    "38",
    "38",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "[",
    "[",
    "The implementation is treating an 8-character string as a 128-bit lookup table. If the character is",
    "The implementation is treating an 8-character string as a 128-bit lookup table. If the character is",
    "; Program.IsInSet(Char)",
    "; Program.IsInSet(Char)",
    "The previously mentioned PR takes care of the length check. And this PR takes care of the bit shift. So",
    "The previously mentioned PR takes care of the length check. And this PR takes care of the bit shift. So",
    "; Program.IsInSet(Char)",
    "; Program.IsInSet(Char)",
    "39",
    "39",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "M00",
    "M00",
    "Note the distinct lack of a call CORINFO",
    "Note the distinct lack of a call CORINFO",
    "Bounds checks are an obvious source of overhead when talking about array access, but they\u2019re not the",
    "Bounds checks are an obvious source of overhead when talking about array access, but they\u2019re not the",
    "[",
    "[",
    "assembly code like the following would be generated:",
    "assembly code like the following would be generated:",
    "; Program.Get(Int32",
    "; Program.Get(Int32",
    "This should look fairly familiar from our previous discussion; the JIT is loading the array\u2019s length",
    "This should look fairly familiar from our previous discussion; the JIT is loading the array\u2019s length",
    "; Program.Get(Int32",
    "; Program.Get(Int32",
    "40",
    "40",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "int       3",
    "int       3",
    "That\u2019s not the only source of overhead with array access, though. In fact, there\u2019s a very large category",
    "That\u2019s not the only source of overhead with array access, though. In fact, there\u2019s a very large category",
    "private int",
    "private int",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio",
    "Method  Runtime  Mean  Ratio",
    "Sum",
    "Sum",
    "Sum",
    "Sum",
    ".NET 6.0",
    ".NET 6.0",
    "964.1 us",
    "964.1 us",
    "1.00",
    "1.00",
    ".NET 7.0",
    ".NET 7.0",
    "674.7 us",
    "674.7 us",
    "0.70",
    "0.70",
    "This previous example assumes you know the size of each dimension of the multidimensional array",
    "This previous example assumes you know the size of each dimension of the multidimensional array",
    "41",
    "41",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "multidimensional arrays can have a non-zero lower bound, Array.GetLowerBound. That would lead to",
    "multidimensional arrays can have a non-zero lower bound, Array.GetLowerBound. That would lead to",
    "private int",
    "private int",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "In .NET 7, thanks to dotnet/runtime#60816, those GetLowerBound and GetUpperBound calls become",
    "In .NET 7, thanks to dotnet/runtime#60816, those GetLowerBound and GetUpperBound calls become",
    "; Program.Sum()",
    "; Program.Sum()",
    "42",
    "42",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "cmp       ",
    "cmp       ",
    "43",
    "43",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "M00",
    "M00",
    "Now here\u2019s what it is for .NET 7:",
    "Now here\u2019s what it is for .NET 7:",
    "; Program.Sum()",
    "; Program.Sum()",
    "44",
    "44",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "add       rsp,20",
    "add       rsp,20",
    "Importantly, note there are no more calls (other than for the bounds check exception at the end). For",
    "Importantly, note there are no more calls (other than for the bounds check exception at the end). For",
    "call      System.Array.GetUpperBound(Int32)",
    "call      System.Array.GetUpperBound(Int32)",
    "we get:",
    "we get:",
    "mov       r9d,",
    "mov       r9d,",
    "and it ends up being much faster:",
    "and it ends up being much faster:",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Sum",
    "Sum",
    "Sum",
    "Sum",
    ".NET 6.0",
    ".NET 6.0",
    "2,657.5 us",
    "2,657.5 us",
    "1.00",
    "1.00",
    ".NET 7.0",
    ".NET 7.0",
    "676.3 us",
    "676.3 us",
    "0.25",
    "0.25",
    "Loop Hoisting and Cloning",
    "Loop Hoisting and Cloning",
    "We previously saw how PGO interacts with loop hoisting and cloning, and those optimizations have",
    "We previously saw how PGO interacts with loop hoisting and cloning, and those optimizations have",
    "Historically, the JIT\u2019s support for hoisting has been limited to lifting an invariant out one level.",
    "Historically, the JIT\u2019s support for hoisting has been limited to lifting an invariant out one level.",
    "[",
    "[",
    "45",
    "45",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "static int ComputeNumber(int thousands, int hundreds, int tens, int ones) =>",
    "static int ComputeNumber(int thousands, int hundreds, int tens, int ones) =>",
    "[",
    "[",
    "At first glance, you might look at this and say \u201cwhat could be hoisted, the computation of n requires",
    "At first glance, you might look at this and say \u201cwhat could be hoisted, the computation of n requires",
    "; Program.Compute()",
    "; Program.Compute()",
    "46",
    "46",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "We can see that some hoisting has happened here. After all, the inner most loop (tagged M00",
    "We can see that some hoisting has happened here. After all, the inner most loop (tagged M00",
    "; Program.Compute()",
    "; Program.Compute()",
    "47",
    "47",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "Notice now where those imul instructions live. There are four labels, each one corresponding to one",
    "Notice now where those imul instructions live. There are four labels, each one corresponding to one",
    "More improvements have gone in on the cloning side. Previously, loop cloning would only apply for",
    "More improvements have gone in on the cloning side. Previously, loop cloning would only apply for",
    "private int",
    "private int",
    "[",
    "[",
    "Without loop cloning, the JIT can\u2019t assume that offset through offset+count are in range, and thus",
    "Without loop cloning, the JIT can\u2019t assume that offset through offset+count are in range, and thus",
    "; Program.LastIndexOf(Int32, Int32, Int32)",
    "; Program.LastIndexOf(Int32, Int32, Int32)",
    "48",
    "48",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "int       3",
    "int       3",
    "Notice how in the core loop, at label M00",
    "Notice how in the core loop, at label M00",
    "; Program.LastIndexOf(Int32, Int32, Int32)",
    "; Program.LastIndexOf(Int32, Int32, Int32)",
    "Notice how the code size is larger, and how there are now two variations of the loop: one at M00",
    "Notice how the code size is larger, and how there are now two variations of the loop: one at M00",
    "Other changes also improved loop cloning. dotnet/runtime#59886 enables the JIT to choose different",
    "Other changes also improved loop cloning. dotnet/runtime#59886 enables the JIT to choose different",
    "49",
    "49",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "all the conditions, ",
    "all the conditions, ",
    "Folding, propagation, and substitution",
    "Folding, propagation, and substitution",
    "Constant folding is an optimization where a compiler computes the value of an expression involving",
    "Constant folding is an optimization where a compiler computes the value of an expression involving",
    "[",
    "[",
    "[",
    "[",
    "the C# compiler will generate IL for these methods like the following:",
    "the C# compiler will generate IL for these methods like the following:",
    ".method public hidebysig instance int32 A () cil managed",
    ".method public hidebysig instance int32 A () cil managed",
    ".method public hidebysig instance int32 B () cil managed",
    ".method public hidebysig instance int32 B () cil managed",
    "You can see that the C# compiler has computed the value of 3 + (4",
    "You can see that the C# compiler has computed the value of 3 + (4",
    "; Program.A()",
    "; Program.A()",
    "; Program.B()",
    "; Program.B()",
    "50",
    "50",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "The assembly for method A isn\u2019t particularly interesting; it\u2019s just returning that same value 23 (hex",
    "The assembly for method A isn\u2019t particularly interesting; it\u2019s just returning that same value 23 (hex",
    "The JIT has long performed constant folding, but it improves further in .NET 7. One of the ways",
    "The JIT has long performed constant folding, but it improves further in .NET 7. One of the ways",
    "public static TimeSpan FromSeconds(double value) => Interval(value, TicksPerSecond); //",
    "public static TimeSpan FromSeconds(double value) => Interval(value, TicksPerSecond); //",
    "and, eschewing argument validation for the purposes of this example, Interval is:",
    "and, eschewing argument validation for the purposes of this example, Interval is:",
    "private static TimeSpan Interval(double value, double scale) =>",
    "private static TimeSpan Interval(double value, double scale) =>",
    "which if everything gets inlined means FromSeconds is essentially:",
    "which if everything gets inlined means FromSeconds is essentially:",
    "public static TimeSpan FromSeconds(double value)",
    "public static TimeSpan FromSeconds(double value)",
    "and if value is a constant, let\u2019s say 5, that whole thing can be constant folded (with dead code",
    "and if value is a constant, let\u2019s say 5, that whole thing can be constant folded (with dead code",
    "return new TimeSpan(50",
    "return new TimeSpan(50",
    "I\u2019ll spare you the .NET 6 assembly for this, but on .NET 7 with a benchmark like:",
    "I\u2019ll spare you the .NET 6 assembly for this, but on .NET 7 with a benchmark like:",
    "[",
    "[",
    "we now get the simple and clean:",
    "we now get the simple and clean:",
    "; Program.FromSeconds()",
    "; Program.FromSeconds()",
    "51",
    "51",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "ret",
    "ret",
    "Another change improving constant folding included dotnet/runtime#57726 from",
    "Another change improving constant folding included dotnet/runtime#57726 from",
    "[",
    "[",
    "In .NET 6, the JIT generated this:",
    "In .NET 6, the JIT generated this:",
    "; Program.DarkOrange()",
    "; Program.DarkOrange()",
    "The interesting thing here is that some constants (39, which is the value of KnownColor.DarkOrange,",
    "The interesting thing here is that some constants (39, which is the value of KnownColor.DarkOrange,",
    "; Program.DarkOrange()",
    "; Program.DarkOrange()",
    "with direct assignment of these constant values into their destination locations (mov word ptr",
    "with direct assignment of these constant values into their destination locations (mov word ptr",
    "However, a large category of improvement came from an optimization related to propagation, that of",
    "However, a large category of improvement came from an optimization related to propagation, that of",
    "[",
    "[",
    "[",
    "[",
    "private static int Value => 16;",
    "private static int Value => 16;",
    "52",
    "52",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "[",
    "[",
    "If we look at the assembly code generated for Compute1 on .NET 6, it looks like what we\u2019d hope for.",
    "If we look at the assembly code generated for Compute1 on .NET 6, it looks like what we\u2019d hope for.",
    "; Program.Compute1()",
    "; Program.Compute1()",
    "But Compute2 is a bit different. The structure of the code is such that the additional call to",
    "But Compute2 is a bit different. The structure of the code is such that the additional call to",
    "; Program.Compute2()",
    "; Program.Compute2()",
    "Rather than a single mov eax, 50 to put the value 0x50 into the return register, we have 5 separate",
    "Rather than a single mov eax, 50 to put the value 0x50 into the return register, we have 5 separate",
    "It turns out that many of the JIT\u2019s optimizations operate on the tree data structures created as part of",
    "It turns out that many of the JIT\u2019s optimizations operate on the tree data structures created as part of",
    "; Program.Compute2()",
    "; Program.Compute2()",
    "53",
    "53",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "add       eax,50",
    "add       eax,50",
    "Vectorization",
    "Vectorization",
    "SIMD, or Single Instruction Multiple Data, is a kind of processing in which one instruction applies to",
    "SIMD, or Single Instruction Multiple Data, is a kind of processing in which one instruction applies to",
    ".NET has long had support for vectorization in the form of Vector",
    ".NET has long had support for vectorization in the form of Vector",
    "Starting in .NET Core 3.0, .NET gained literally thousands of new \u201chardware intrinsics\u201d methods, most",
    "Starting in .NET Core 3.0, .NET gained literally thousands of new \u201chardware intrinsics\u201d methods, most",
    ".NET 7 has introduced a middle ground. Previous releases saw the introduction of the Vector128",
    ".NET 7 has introduced a middle ground. Previous releases saw the introduction of the Vector128",
    "54",
    "54",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "dotnet/runtime#53450, dotnet/runtime#63414, dotnet/runtime#60094, and dotnet/runtime#68559, a",
    "dotnet/runtime#53450, dotnet/runtime#63414, dotnet/runtime#60094, and dotnet/runtime#68559, a",
    "using System.Runtime.CompilerServices;",
    "using System.Runtime.CompilerServices;",
    "internal class Program",
    "internal class Program",
    "}",
    "}",
    "I have two functions: one that directly uses the Sse2.MoveMask hardware intrinsic and one that uses",
    "I have two functions: one that directly uses the Sse2.MoveMask hardware intrinsic and one that uses",
    "; Assembly listing for method Program:WithIntrinsics(Vector128",
    "; Assembly listing for method Program:WithIntrinsics(Vector128",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 12",
    "; Total bytes of code 12",
    "; Assembly listing for method Program:WithVector(Vector128",
    "; Assembly listing for method Program:WithVector(Vector128",
    "55",
    "55",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "G",
    "G",
    "G",
    "G",
    "; Total bytes of code 12",
    "; Total bytes of code 12",
    "Notice anything? The code for the two methods is identical, both resulting in a vpmovmskb (Move Byte",
    "Notice anything? The code for the two methods is identical, both resulting in a vpmovmskb (Move Byte",
    "To explore this a bit more, let\u2019s take a simple example and vectorize it. We\u2019ll implement a Contains",
    "To explore this a bit more, let\u2019s take a simple example and vectorize it. We\u2019ll implement a Contains",
    "static bool Contains(ReadOnlySpan",
    "static bool Contains(ReadOnlySpan",
    "}",
    "}",
    "How would we vectorize this with Vector",
    "How would we vectorize this with Vector",
    "static bool Contains(ReadOnlySpan",
    "static bool Contains(ReadOnlySpan",
    "}",
    "}",
    "56",
    "56",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "Now that we know we have enough data, we can get to coding our vectorized loop. In this loop, we\u2019ll",
    "Now that we know we have enough data, we can get to coding our vectorized loop. In this loop, we\u2019ll",
    "static unsafe bool Contains(ReadOnlySpan",
    "static unsafe bool Contains(ReadOnlySpan",
    "}",
    "}",
    "And we\u2019re almost done. The last issue to handle is we may still have a few elements at the end we",
    "And we\u2019re almost done. The last issue to handle is we may still have a few elements at the end we",
    "57",
    "57",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "that might or might not overlap with elements we\u2019ve already looked at, but it won\u2019t hurt anything if it",
    "that might or might not overlap with elements we\u2019ve already looked at, but it won\u2019t hurt anything if it",
    "static unsafe bool Contains(ReadOnlySpan",
    "static unsafe bool Contains(ReadOnlySpan",
    "}",
    "}",
    "Congratulations, we\u2019ve vectorized this operation, and fairly decently at that. We can throw this into",
    "Congratulations, we\u2019ve vectorized this operation, and fairly decently at that. We can throw this into",
    "private byte",
    "private byte",
    "[",
    "[",
    "[",
    "[",
    "58",
    "58",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "Find",
    "Find",
    "484.05 ns",
    "484.05 ns",
    "1.00",
    "1.00",
    "FindVectorized",
    "FindVectorized",
    "20.21 ns",
    "20.21 ns",
    "0.04",
    "0.04",
    "A 24x speedup",
    "A 24x speedup",
    "You deploy this in your service, and you see Contains being called on your hot path, but you don\u2019t",
    "You deploy this in your service, and you see Contains being called on your hot path, but you don\u2019t",
    "One thing we can now do is switch from using Vector",
    "One thing we can now do is switch from using Vector",
    "static unsafe bool Contains(ReadOnlySpan",
    "static unsafe bool Contains(ReadOnlySpan",
    "Vector128",
    "Vector128",
    "59",
    "59",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "return false;",
    "return false;",
    "With that in hand, we can now try it on our smaller 30 element data set:",
    "With that in hand, we can now try it on our smaller 30 element data set:",
    "private byte",
    "private byte",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "Find",
    "Find",
    "15.388 ns",
    "15.388 ns",
    "1.00",
    "1.00",
    "FindVectorized",
    "FindVectorized",
    "1.747 ns",
    "1.747 ns",
    "0.11",
    "0.11",
    "Woo hoo, victory, all your performance are belong to us\u2026 again",
    "Woo hoo, victory, all your performance are belong to us\u2026 again",
    "What about on the larger data set again? Previously with Vector",
    "What about on the larger data set again? Previously with Vector",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "Find",
    "Find",
    "484.25 ns",
    "484.25 ns",
    "1.00",
    "1.00",
    "FindVectorized",
    "FindVectorized",
    "32.92 ns",
    "32.92 ns",
    "0.07",
    "0.07",
    "\u2026 closer to 15x. Nothing to sneeze at, but it\u2019s not the 24x we previously saw. What if we want to have",
    "\u2026 closer to 15x. Nothing to sneeze at, but it\u2019s not the 24x we previously saw. What if we want to have",
    "static unsafe bool Contains(ReadOnlySpan",
    "static unsafe bool Contains(ReadOnlySpan",
    "Vector256",
    "Vector256",
    "60",
    "60",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "if (Vector256.EqualsAny(target, Vector256.LoadUnsafe(ref endMinusOneVector)))",
    "if (Vector256.EqualsAny(target, Vector256.LoadUnsafe(ref endMinusOneVector)))",
    "}",
    "}",
    "And, boom, we\u2019re back:",
    "And, boom, we\u2019re back:",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "Find",
    "Find",
    "484.53 ns",
    "484.53 ns",
    "1.00",
    "1.00",
    "FindVectorized",
    "FindVectorized",
    "20.08 ns",
    "20.08 ns",
    "0.04",
    "0.04",
    "We now have an implementation that is vectorized on any platform with either 128-bit or 256-bit",
    "We now have an implementation that is vectorized on any platform with either 128-bit or 256-bit",
    "There are many factors that impact which path you go down, and I expect we\u2019ll have guidance",
    "There are many factors that impact which path you go down, and I expect we\u2019ll have guidance",
    "61",
    "61",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "I already mentioned several PRs that exposed the new cross-platform vector support, but that only",
    "I already mentioned several PRs that exposed the new cross-platform vector support, but that only",
    "Inlining",
    "Inlining",
    "Inlining is one of the most important optimizations the JIT can do. The concept is simple: instead of",
    "Inlining is one of the most important optimizations the JIT can do. The concept is simple: instead of",
    "All that is to say, inlining is really important, it\u2019s important that the \u201cright\u201d things be inlined and that it",
    "All that is to say, inlining is really important, it\u2019s important that the \u201cright\u201d things be inlined and that it",
    "One really interesting improvement around inlining is dotnet/runtime#64521, and it might be",
    "One really interesting improvement around inlining is dotnet/runtime#64521, and it might be",
    "public override string ToString()",
    "public override string ToString()",
    "62",
    "62",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "if (",
    "if (",
    "Pretty simple, right? You\u2019d expect something this trivial to be inlined. Alas, on .NET 6, this benchmark:",
    "Pretty simple, right? You\u2019d expect something this trivial to be inlined. Alas, on .NET 6, this benchmark:",
    "private bool ",
    "private bool ",
    "[",
    "[",
    "produces this assembly code:",
    "produces this assembly code:",
    "; Program.BoolStringLength()",
    "; Program.BoolStringLength()",
    "Note the call System.Boolean.ToString(). The reason for this is, historically, the JIT has been",
    "Note the call System.Boolean.ToString(). The reason for this is, historically, the JIT has been",
    "; Program.BoolStringLength()",
    "; Program.BoolStringLength()",
    "No more call System.Boolean.ToString().",
    "No more call System.Boolean.ToString().",
    "dotnet/runtime#61408 made two changes related to inlining. First, it taught the inliner how to better",
    "dotnet/runtime#61408 made two changes related to inlining. First, it taught the inliner how to better",
    "dotnet/runtime#71778 also impacted inlining, and in particular in situations where a typeof() could",
    "dotnet/runtime#71778 also impacted inlining, and in particular in situations where a typeof() could",
    "63",
    "63",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "members on Type like IsValueType were turned into JIT intrinsics, such that the JIT could substitute a",
    "members on Type like IsValueType were turned into JIT intrinsics, such that the JIT could substitute a",
    "[",
    "[",
    "private static bool IsValueType",
    "private static bool IsValueType",
    "results in this assembly code on .NET 6:",
    "results in this assembly code on .NET 6:",
    "; Program.IsValueType()",
    "; Program.IsValueType()",
    "However, change the benchmark slightly:",
    "However, change the benchmark slightly:",
    "[",
    "[",
    "private static bool IsValueType(Type t) => t.IsValueType;",
    "private static bool IsValueType(Type t) => t.IsValueType;",
    "and it\u2019s no longer as simple:",
    "and it\u2019s no longer as simple:",
    "; Program.IsValueType()",
    "; Program.IsValueType()",
    "Effectively, as part of inlining the JIT loses the notion that the argument is a constant and fails to",
    "Effectively, as part of inlining the JIT loses the notion that the argument is a constant and fails to",
    "; Program.IsValueType()",
    "; Program.IsValueType()",
    "Arm64",
    "Arm64",
    "A huge amount of effort in .NET 7 went into making code gen for Arm64 as good or better than its",
    "A huge amount of effort in .NET 7 went into making code gen for Arm64 as good or better than its",
    "\u2022",
    "\u2022",
    "64",
    "64",
    "Addressing modes. \u201cAddressing mode\u201d is the term used to refer to how the operand of",
    "Addressing modes. \u201cAddressing mode\u201d is the term used to refer to how the operand of",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "managed arrays. dotnet/runtime#66902 improves the use of addressing modes when the",
    "managed arrays. dotnet/runtime#66902 improves the use of addressing modes when the",
    "Better instruction selection. Various techniques go into ensuring that the best instructions are",
    "Better instruction selection. Various techniques go into ensuring that the best instructions are",
    "Vectorization. dotnet/runtime#64864 adds new",
    "Vectorization. dotnet/runtime#64864 adds new",
    "Zeroing. Lots of operations require state to be set to zero, such as initializing all reference locals",
    "Zeroing. Lots of operations require state to be set to zero, such as initializing all reference locals",
    "\u2022  Memory Model. dotnet/runtime#62895 enables store barriers to be used wherever possible",
    "\u2022  Memory Model. dotnet/runtime#62895 enables store barriers to be used wherever possible",
    "instead of full barriers, and uses one-way barriers for volatile variables. dotnet/runtime#67384",
    "instead of full barriers, and uses one-way barriers for volatile variables. dotnet/runtime#67384",
    "JIT helpers",
    "JIT helpers",
    "While logically part of the runtime, the JIT is actually isolated from the rest of the runtime, only",
    "While logically part of the runtime, the JIT is actually isolated from the rest of the runtime, only",
    "dotnet/runtime#65738 rewrote various \u201cstubs\u201d to be more efficient. Stubs are tiny bits of code that",
    "dotnet/runtime#65738 rewrote various \u201cstubs\u201d to be more efficient. Stubs are tiny bits of code that",
    "65",
    "65",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "single one it\u2019s cached, and if they\u2019re equal simply jumps to the right target. You know you\u2019re in the",
    "single one it\u2019s cached, and if they\u2019re equal simply jumps to the right target. You know you\u2019re in the",
    "For anyone familiar with generics and interested in performance, you may have heard the refrain that",
    "For anyone familiar with generics and interested in performance, you may have heard the refrain that",
    "private Example ",
    "private Example ",
    "[",
    "[",
    "class Example",
    "class Example",
    "}",
    "}",
    "results in:",
    "results in:",
    "66",
    "66",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "GenericNonVirtual",
    "GenericNonVirtual",
    "GenericVirtual",
    "GenericVirtual",
    "0.4866",
    "0.4866",
    "6.4552",
    "6.4552",
    "1.00",
    "1.00",
    "13.28",
    "13.28",
    "dotnet/runtime#65926 eases the pain a tad. Some of the cost comes from looking up some cached",
    "dotnet/runtime#65926 eases the pain a tad. Some of the cost comes from looking up some cached",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "GenericVirtual",
    "GenericVirtual",
    ".NET 6.0",
    ".NET 6.0",
    "6.475 ns",
    "6.475 ns",
    "1.00",
    "1.00",
    "GenericVirtual",
    "GenericVirtual",
    ".NET 7.0",
    ".NET 7.0",
    "6.119 ns",
    "6.119 ns",
    "0.95",
    "0.95",
    "Not enough of an improvement for us to start recommending people use them, but a 5%",
    "Not enough of an improvement for us to start recommending people use them, but a 5%",
    "Grab Bag",
    "Grab Bag",
    "It\u2019s near impossible to cover every performance change that goes into the JIT, and I\u2019m not going to",
    "It\u2019s near impossible to cover every performance change that goes into the JIT, and I\u2019m not going to",
    "\u2022",
    "\u2022",
    "dotnet/runtime#58196 from ",
    "dotnet/runtime#58196 from ",
    "private int ",
    "private int ",
    "[",
    "[",
    "; ",
    "; ",
    "; ",
    "; ",
    "67",
    "67",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "\u2022",
    "\u2022",
    "dotnet/runtime#67182. On a machine with support for BMI2, 64-bit shifts can be performed with",
    "dotnet/runtime#67182. On a machine with support for BMI2, 64-bit shifts can be performed with",
    "[",
    "[",
    "; ",
    "; ",
    "; ",
    "; ",
    "\u2022",
    "\u2022",
    "dotnet/runtime#69003 from ",
    "dotnet/runtime#69003 from ",
    "[",
    "[",
    "; ",
    "; ",
    "; ",
    "; ",
    "\u2022",
    "\u2022",
    "dotnet/runtime#61412 from ",
    "dotnet/runtime#61412 from ",
    "[",
    "[",
    "; ",
    "; ",
    "68",
    "68",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "movzx     eax,al",
    "movzx     eax,al",
    "; ",
    "; ",
    "\u2022",
    "\u2022",
    "dotnet/runtime#63545 from ",
    "dotnet/runtime#63545 from ",
    "can be lowered to the blsr instruction.",
    "can be lowered to the blsr instruction.",
    "[",
    "[",
    "; ",
    "; ",
    "; ",
    "; ",
    "\u2022",
    "\u2022",
    "dotnet/runtime#62394. / and % by a vector\u2019s .Count wasn\u2019t recognizing that Count can be",
    "dotnet/runtime#62394. / and % by a vector\u2019s .Count wasn\u2019t recognizing that Count can be",
    "[",
    "[",
    "; ",
    "; ",
    "; ",
    "; ",
    "69",
    "69",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "\u2022",
    "\u2022",
    "dotnet/runtime#60787. Loop alignment in .NET 6 provides a very nice exploration of why and",
    "dotnet/runtime#60787. Loop alignment in .NET 6 provides a very nice exploration of why and",
    "70",
    "70",
    "CHAPTER 2 | JIT",
    "CHAPTER 2 | JIT",
    "CHAPTER  3",
    "CHAPTER  3",
    "GC",
    "GC",
    "\u201cRegions\u201d is a feature of the garbage collector (GC) that\u2019s been in the works for multiple years. It\u2019s",
    "\u201cRegions\u201d is a feature of the garbage collector (GC) that\u2019s been in the works for multiple years. It\u2019s",
    "71",
    "71",
    "CHAPTER 3 | GC",
    "CHAPTER 3 | GC",
    "CHAPTER  4",
    "CHAPTER  4",
    "Native AOT",
    "Native AOT",
    "To many people, the word \u201cperformance\u201d in the context of software is about throughput. How fast",
    "To many people, the word \u201cperformance\u201d in the context of software is about throughput. How fast",
    ".NET has long had support for AOT code generation. For example, .NET Framework had it in the form",
    ".NET has long had support for AOT code generation. For example, .NET Framework had it in the form",
    "Too many PRs to mention have gone into bringing up the Native AOT stack, in part because it\u2019s been",
    "Too many PRs to mention have gone into bringing up the Native AOT stack, in part because it\u2019s been",
    "72",
    "72",
    "CHAPTER 4 | Native AOT",
    "CHAPTER 4 | Native AOT",
    "Today, Native AOT is focused on console applications, so let\u2019s create a console app:",
    "Today, Native AOT is focused on console applications, so let\u2019s create a console app:",
    "dotnet new console -o nativeaotexample",
    "dotnet new console -o nativeaotexample",
    "We now have our nativeaotexample directory containing a nativeaotexample.csproj and a \u201chello,",
    "We now have our nativeaotexample directory containing a nativeaotexample.csproj and a \u201chello,",
    "<PublishAot>",
    "<PublishAot>",
    "And then\u2026 actually, that\u2019s it. Our app is now fully configured to be able to target Native AOT. All that\u2019s",
    "And then\u2026 actually, that\u2019s it. Our app is now fully configured to be able to target Native AOT. All that\u2019s",
    "dotnet publish -r win-x64 -c Release",
    "dotnet publish -r win-x64 -c Release",
    "I now have my generated executable in the output publish directory:",
    "I now have my generated executable in the output publish directory:",
    "Mode                 LastWriteTime         Length Name",
    "Mode                 LastWriteTime         Length Name",
    "so 2M instead of 3.5MB. Of course, for that significant reduction I\u2019ve given up some things:",
    "so 2M instead of 3.5MB. Of course, for that significant reduction I\u2019ve given up some things:",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "Setting InvariantGlobalization to true means I\u2019m now not respecting culture information and",
    "Setting InvariantGlobalization to true means I\u2019m now not respecting culture information and",
    "Setting UseSystemResourceKeys to true means nice exception messages are stripped away.",
    "Setting UseSystemResourceKeys to true means nice exception messages are stripped away.",
    "Setting IlcGenerateStackTraceData to false means I\u2019m going to get fairly poor stack traces",
    "Setting IlcGenerateStackTraceData to false means I\u2019m going to get fairly poor stack traces",
    "Setting DebuggerSupport to false\u2026 good luck debugging things.",
    "Setting DebuggerSupport to false\u2026 good luck debugging things.",
    "\u2026 you get the idea.",
    "\u2026 you get the idea.",
    "One of the potentially mind-boggling aspects of Native AOT for a developer used to .NET is that, as it",
    "One of the potentially mind-boggling aspects of Native AOT for a developer used to .NET is that, as it",
    "if (RuntimeFeature.IsDynamicCodeCompiled)",
    "if (RuntimeFeature.IsDynamicCodeCompiled)",
    "With the JIT, IsDynamicCodeCompiled is true. But with Native AOT, it\u2019s false. Thus, with Native AOT",
    "With the JIT, IsDynamicCodeCompiled is true. But with Native AOT, it\u2019s false. Thus, with Native AOT",
    "73",
    "73",
    "CHAPTER 4 | Native AOT",
    "CHAPTER 4 | Native AOT",
    "SDK, emits C# code into the assembly using it. That C# code takes the place of the reflection emit that",
    "SDK, emits C# code into the assembly using it. That C# code takes the place of the reflection emit that",
    "private static readonly string s",
    "private static readonly string s",
    "private Regex ",
    "private Regex ",
    "private Regex ",
    "private Regex ",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "Interpreter",
    "Interpreter",
    "9,036.7 us",
    "9,036.7 us",
    "1.00",
    "1.00",
    "Compiled",
    "Compiled",
    "9,064.8 us",
    "9,064.8 us",
    "1.00",
    "1.00",
    "SourceGenerator",
    "SourceGenerator",
    "426.1 us",
    "426.1 us",
    "0.05",
    "0.05",
    "So, yes, there are some constraints associated with Native AOT, but there are also solutions for",
    "So, yes, there are some constraints associated with Native AOT, but there are also solutions for",
    "This is a really exciting space, one we expect to see flourish in coming releases.",
    "This is a really exciting space, one we expect to see flourish in coming releases.",
    "74",
    "74",
    "CHAPTER 4 | Native AOT",
    "CHAPTER 4 | Native AOT",
    "CHAPTER  5",
    "CHAPTER  5",
    "Mono",
    "Mono",
    "Up until now I\u2019ve referred to \u201cthe JIT,\u201d \u201cthe GC,\u201d and \u201cthe runtime,\u201d but in reality there are actually",
    "Up until now I\u2019ve referred to \u201cthe JIT,\u201d \u201cthe GC,\u201d and \u201cthe runtime,\u201d but in reality there are actually",
    "Just as with coreclr (which can JIT compile, AOT compile partially with JIT fallback, and fully Native",
    "Just as with coreclr (which can JIT compile, AOT compile partially with JIT fallback, and fully Native",
    "75",
    "75",
    "CHAPTER 5 | Mono",
    "CHAPTER 5 | Mono",
    "The interpreter isn\u2019t just used for entire apps, though. Just as how coreclr can use the JIT when an R2R",
    "The interpreter isn\u2019t just used for entire apps, though. Just as how coreclr can use the JIT when an R2R",
    "Beyond such backend improvements, another class of improvement came from further unification",
    "Beyond such backend improvements, another class of improvement came from further unification",
    "One of the biggest categories of improvements, however, is in vectorization. This comes in two pieces.",
    "One of the biggest categories of improvements, however, is in vectorization. This comes in two pieces.",
    "76",
    "76",
    "CHAPTER 5 | Mono",
    "CHAPTER 5 | Mono",
    "dotnet/runtime#66391, dotnet/runtime#66409, dotnet/runtime#66512, dotnet/runtime#66586,",
    "dotnet/runtime#66391, dotnet/runtime#66409, dotnet/runtime#66512, dotnet/runtime#66586,",
    "77",
    "77",
    "CHAPTER 5 | Mono",
    "CHAPTER 5 | Mono",
    "CHAPTER  6",
    "CHAPTER  6",
    "Reflection",
    "Reflection",
    "Reflection is one of those areas you either love or hate (I find it a bit humorous to be writing this",
    "Reflection is one of those areas you either love or hate (I find it a bit humorous to be writing this",
    "One of the most impacted areas is reflection invoke. Available via MethodBase.Invoke, this",
    "One of the most impacted areas is reflection invoke. Available via MethodBase.Invoke, this",
    "private MethodInfo ",
    "private MethodInfo ",
    "[",
    "[",
    "[",
    "[",
    "private static void MyMethod() { }",
    "private static void MyMethod() { }",
    "78",
    "78",
    "CHAPTER 6 | Reflection",
    "CHAPTER 6 | Reflection",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "MethodInfoInvoke",
    "MethodInfoInvoke",
    ".NET 6.0",
    ".NET 6.0",
    "43.846 ns",
    "43.846 ns",
    "1.00",
    "1.00",
    "MethodInfoInvoke",
    "MethodInfoInvoke",
    ".NET 7.0",
    ".NET 7.0",
    "8.078 ns",
    "8.078 ns",
    "0.18",
    "0.18",
    "Reflection also involves lots of manipulation of objects that represent types, methods, properties, and",
    "Reflection also involves lots of manipulation of objects that represent types, methods, properties, and",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "GetUnderlyingType",
    "GetUnderlyingType",
    ".NET 6.0",
    ".NET 6.0",
    "27.413 ns",
    "27.413 ns",
    "1.00",
    "1.00",
    "GetUnderlyingType",
    "GetUnderlyingType",
    ".NET 7.0",
    ".NET 7.0",
    "5.115 ns",
    "5.115 ns",
    "0.19",
    "0.19",
    "Another example of this phenomenon comes in dotnet/runtime#62866, which moved much of the",
    "Another example of this phenomenon comes in dotnet/runtime#62866, which moved much of the",
    "private readonly string ",
    "private readonly string ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "CreateInstance",
    "CreateInstance",
    ".NET 6.0",
    ".NET 6.0",
    "3.827 us",
    "3.827 us",
    "1.00",
    "1.00",
    "CreateInstance",
    "CreateInstance",
    ".NET 7.0",
    ".NET 7.0",
    "2.276 us",
    "2.276 us",
    "0.60",
    "0.60",
    "Other changes contributed to Activator.CreateInstance improvements as well.",
    "Other changes contributed to Activator.CreateInstance improvements as well.",
    "[",
    "[",
    "internal class MyClass",
    "internal class MyClass",
    "79",
    "79",
    "CHAPTER 6 | Reflection",
    "CHAPTER 6 | Reflection",
    "internal MyClass() { }",
    "internal MyClass() { }",
    "Method",
    "Method",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "CreateInstance",
    "CreateInstance",
    ".NET 6.0",
    ".NET 6.0",
    "167.8 ns",
    "167.8 ns",
    "1.00",
    "1.00",
    "CreateInstance",
    "CreateInstance",
    ".NET 7.0",
    ".NET 7.0",
    "143.4 ns",
    "143.4 ns",
    "0.85",
    "0.85",
    "320 B",
    "320 B",
    "200 B",
    "200 B",
    "1.00",
    "1.00",
    "0.62",
    "0.62",
    "And since we were talking about AssemblyName, other PRs improved it in other ways as well.",
    "And since we were talking about AssemblyName, other PRs improved it in other ways as well.",
    "private AssemblyName",
    "private AssemblyName",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Names",
    "Names",
    ".NET 6.0",
    ".NET 6.0",
    "3.423 us",
    "3.423 us",
    "1.00",
    "1.00",
    "9.14 KB",
    "9.14 KB",
    "Names",
    "Names",
    ".NET 7.0",
    ".NET 7.0",
    "2.010 us",
    "2.010 us",
    "0.59",
    "0.59",
    "2.43 KB",
    "2.43 KB",
    "1.00",
    "1.00",
    "0.27",
    "0.27",
    "More reflection-related operations have also been turned into JIT intrinsics, as discussed earlier",
    "More reflection-related operations have also been turned into JIT intrinsics, as discussed earlier",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Code Size",
    "Mean  Ratio  Code Size",
    "IsByRefLike",
    "IsByRefLike",
    ".NET 6.0",
    ".NET 6.0",
    "2.1322 ns  1.000",
    "2.1322 ns  1.000",
    "IsByRefLike",
    "IsByRefLike",
    ".NET 7.0",
    ".NET 7.0",
    "0.0000 ns  0.000",
    "0.0000 ns  0.000",
    "31 B",
    "31 B",
    "6 B",
    "6 B",
    "That the .NET 7 version is so close to zero is called out in a warning by benchmarkdotnet:",
    "That the .NET 7 version is so close to zero is called out in a warning by benchmarkdotnet:",
    "// ",
    "// ",
    "and it\u2019s so indistinguishable from an empty method because that\u2019s effectively what it is, as we can see",
    "and it\u2019s so indistinguishable from an empty method because that\u2019s effectively what it is, as we can see",
    "80",
    "80",
    "CHAPTER 6 | Reflection",
    "CHAPTER 6 | Reflection",
    "; Program.IsByRefLike()",
    "; Program.IsByRefLike()",
    "There are also improvements that are hard to see but that remove overheads as part of populating",
    "There are also improvements that are hard to see but that remove overheads as part of populating",
    "81",
    "81",
    "CHAPTER 6 | Reflection",
    "CHAPTER 6 | Reflection",
    "CHAPTER  7",
    "CHAPTER  7",
    "Interop",
    "Interop",
    ".NET has long had great support for interop, enabling .NET applications to consume huge amounts of",
    ".NET has long had great support for interop, enabling .NET applications to consume huge amounts of",
    "BOOL CreatePipe(",
    "BOOL CreatePipe(",
    "If I want to call this function from C#, I can declare a ",
    "If I want to call this function from C#, I can declare a ",
    "[",
    "[",
    "There are several interesting things to note here. Several of the arguments are directly blittable with",
    "There are several interesting things to note here. Several of the arguments are directly blittable with",
    "82",
    "82",
    "CHAPTER 7 | Interop",
    "CHAPTER 7 | Interop",
    "and some code somewhere needs to take any error produced by this method and ensure it\u2019s available",
    "and some code somewhere needs to take any error produced by this method and ensure it\u2019s available",
    "If there\u2019s no marshalling logic required, such that the managed signature and native signature are for",
    "If there\u2019s no marshalling logic required, such that the managed signature and native signature are for",
    "There are a variety of downsides to this. First, it takes time to generate all that marshalling code, time",
    "There are a variety of downsides to this. First, it takes time to generate all that marshalling code, time",
    "But what if that logic could all be generated at build time rather than at run time? The cost of",
    "But what if that logic could all be generated at build time rather than at run time? The cost of",
    ".NET 6 included several source generators in the .NET SDK, and .NET 7 doubles down on this effort",
    ".NET 6 included several source generators in the .NET SDK, and .NET 7 doubles down on this effort",
    "Let\u2019s return to our previous CreatePipe example. We\u2019ll make two small tweaks. We change the",
    "Let\u2019s return to our previous CreatePipe example. We\u2019ll make two small tweaks. We change the",
    "[",
    "[",
    "Now if you\u2019re following along at home in Visual Studio, try right-clicking on CreatePipe and selecting",
    "Now if you\u2019re following along at home in Visual Studio, try right-clicking on CreatePipe and selecting",
    "83",
    "83",
    "CHAPTER 7 | Interop",
    "CHAPTER 7 | Interop",
    "opt-in to having it persisted on disk by adding a",
    "opt-in to having it persisted on disk by adding a",
    "[",
    "[",
    "global::Microsoft.Win32.SafeHandles.SafeFileHandle();",
    "global::Microsoft.Win32.SafeHandles.SafeFileHandle();",
    "of an exception during the non-cleanup phases.",
    "of an exception during the non-cleanup phases.",
    "84",
    "84",
    "CHAPTER 7 | Interop",
    "CHAPTER 7 | Interop",
    "\"",
    "\"",
    "With this, you can read exactly the marshalling work that\u2019s being performed. Two SafeHandle",
    "With this, you can read exactly the marshalling work that\u2019s being performed. Two SafeHandle",
    "A sheer ton of work went in to enabling this. I touched on some of it last year in Performance",
    "A sheer ton of work went in to enabling this. I touched on some of it last year in Performance",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "The LibraryImport generator started its life as an experiment in dotnet/runtimelab. When it was",
    "The LibraryImport generator started its life as an experiment in dotnet/runtimelab. When it was",
    "In .NET 6, there were almost 3000 ",
    "In .NET 6, there were almost 3000 ",
    "\u2022",
    "\u2022",
    "Such porting is significantly easier when there\u2019s a tool to help automate it.",
    "Such porting is significantly easier when there\u2019s a tool to help automate it.",
    "85",
    "85",
    "CHAPTER 7 | Interop",
    "CHAPTER 7 | Interop",
    ":::",
    ":::",
    "There were plenty of other PRs that went into making the LibraryImport generator a reality for .NET 7.",
    "There were plenty of other PRs that went into making the LibraryImport generator a reality for .NET 7.",
    "One more category of interop-related changes that I think are worth talking about are to do with",
    "One more category of interop-related changes that I think are worth talking about are to do with",
    "86",
    "86",
    "CHAPTER 7 | Interop",
    "CHAPTER 7 | Interop",
    "and DangerousRelease (and due to the wonders of LibraryImport I\u2019ve already extolled, you can easily",
    "and DangerousRelease (and due to the wonders of LibraryImport I\u2019ve already extolled, you can easily",
    "dotnet/runtime#71854 added some debug-only tracking code to SafeHandle to make it easier for",
    "dotnet/runtime#71854 added some debug-only tracking code to SafeHandle to make it easier for",
    "[",
    "[",
    "and code that uses it like:",
    "and code that uses it like:",
    "SafeFileHandle handle = Interop.CreateFile();",
    "SafeFileHandle handle = Interop.CreateFile();",
    "Seems straightforward enough. Except this code will actually leave a SafeHandle for finalization on",
    "Seems straightforward enough. Except this code will actually leave a SafeHandle for finalization on",
    "SafeFileHandle handle = Interop.CreateFile();",
    "SafeFileHandle handle = Interop.CreateFile();",
    "That way, this SafeHandle won\u2019t create finalization pressure even in the case of failure. Note, as well,",
    "That way, this SafeHandle won\u2019t create finalization pressure even in the case of failure. Note, as well,",
    "87",
    "87",
    "CHAPTER 7 | Interop",
    "CHAPTER 7 | Interop",
    "Other PRs also accrued to improved interop performance. dotnet/runtime#70000 from",
    "Other PRs also accrued to improved interop performance. dotnet/runtime#70000 from",
    "private byte",
    "private byte",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio  Code Size",
    "Method  Runtime  Mean  Ratio  Code Size",
    "PinUnpin",
    "PinUnpin",
    ".NET 6.0",
    ".NET 6.0",
    "37.11 ns",
    "37.11 ns",
    "1.00",
    "1.00",
    "PinUnpin",
    "PinUnpin",
    ".NET 7.0",
    ".NET 7.0",
    "32.17 ns",
    "32.17 ns",
    "0.87",
    "0.87",
    "353 B",
    "353 B",
    "232 B",
    "232 B",
    "88",
    "88",
    "CHAPTER 7 | Interop",
    "CHAPTER 7 | Interop",
    "CHAPTER  8",
    "CHAPTER  8",
    "Threading",
    "Threading",
    "Threading is one of those cross-cutting concerns that impacts every application, such that changes in",
    "Threading is one of those cross-cutting concerns that impacts every application, such that changes in",
    "One in particular is dotnet/runtime#69386. The ThreadPool has a \u201cglobal queue\u201d that any thread can",
    "One in particular is dotnet/runtime#69386. The ThreadPool has a \u201cglobal queue\u201d that any thread can",
    "Another is dotnet/runtime#57885. In order to coordinate threads, when work items were enqueued",
    "Another is dotnet/runtime#57885. In order to coordinate threads, when work items were enqueued",
    "89",
    "89",
    "CHAPTER 8 | Threading",
    "CHAPTER 8 | Threading",
    "private readonly byte",
    "private readonly byte",
    "private static byte IterateAll(byte",
    "private static byte IterateAll(byte",
    "[",
    "[",
    "}",
    "}",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "MultipleSerial",
    "MultipleSerial",
    ".NET 6.0",
    ".NET 6.0",
    "14.340 us",
    "14.340 us",
    "1.00",
    "1.00",
    "MultipleSerial",
    "MultipleSerial",
    ".NET 7.0",
    ".NET 7.0",
    "9.262 us",
    "9.262 us",
    "0.65",
    "0.65",
    "There have been improvements outside of ThreadPool, as well. One notable change is in the handling",
    "There have been improvements outside of ThreadPool, as well. One notable change is in the handling",
    "90",
    "90",
    "CHAPTER 8 | Threading",
    "CHAPTER 8 | Threading",
    "So, this PR took the complexity hit to add a dedicated type for four key/value pairs, in order to",
    "So, this PR took the complexity hit to add a dedicated type for four key/value pairs, in order to",
    "private AsyncLocal",
    "private AsyncLocal",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio  Code Size  Allocated  Alloc Ratio",
    "Method  Runtime  Mean  Ratio  Code Size  Allocated  Alloc Ratio",
    "Update",
    "Update",
    ".NET 6.0",
    ".NET 6.0",
    "61.96 ns",
    "61.96 ns",
    "1.00",
    "1.00",
    "1,272 B",
    "1,272 B",
    "Update",
    "Update",
    ".NET 7.0",
    ".NET 7.0",
    "61.92 ns",
    "61.92 ns",
    "1.00",
    "1.00",
    "1,832 B",
    "1,832 B",
    "176 B",
    "176 B",
    "144 B",
    "144 B",
    "1.00",
    "1.00",
    "0.82",
    "0.82",
    "Another valuable fix comes for locking in dotnet/runtime#70165. This particular improvement is a bit",
    "Another valuable fix comes for locking in dotnet/runtime#70165. This particular improvement is a bit",
    "using System.Diagnostics;",
    "using System.Diagnostics;",
    "var rwl = new ReaderWriterLockSlim();",
    "var rwl = new ReaderWriterLockSlim();",
    "DateTime end = DateTime.UtcNow + TimeSpan.FromSeconds(10);",
    "DateTime end = DateTime.UtcNow + TimeSpan.FromSeconds(10);",
    "}",
    "}",
    "91",
    "91",
    "CHAPTER 8 | Threading",
    "CHAPTER 8 | Threading",
    "This is simply spinning up 100 tasks, each of which enters and exits a read-write lock, waits for them",
    "This is simply spinning up 100 tasks, each of which enters and exits a read-write lock, waits for them",
    "One final threading-related change to call out: dotnet/runtime#68639. This one is Windows specific.",
    "One final threading-related change to call out: dotnet/runtime#68639. This one is Windows specific.",
    "92",
    "92",
    "CHAPTER 8 | Threading",
    "CHAPTER 8 | Threading",
    "CHAPTER  9",
    "CHAPTER  9",
    "Primitive Types and",
    "Primitive Types and",
    "We\u2019ve looked at code generation and GC, at threading and vectorization, at interop\u2026 let\u2019s turn our",
    "We\u2019ve looked at code generation and GC, at threading and vectorization, at interop\u2026 let\u2019s turn our",
    "float and double got a very nice boost in their implementation of parsing (e.g. double.Parse,",
    "float and double got a very nice boost in their implementation of parsing (e.g. double.Parse,",
    "private string",
    "private string",
    "[",
    "[",
    "[",
    "[",
    "93",
    "93",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER 9 | Primitive Types and Numerics",
    "}",
    "}",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "ParseAll",
    "ParseAll",
    ".NET 6.0",
    ".NET 6.0",
    "26.84 ms",
    "26.84 ms",
    "1.00",
    "1.00",
    "ParseAll",
    "ParseAll",
    ".NET 7.0",
    ".NET 7.0",
    "12.63 ms",
    "12.63 ms",
    "0.47",
    "0.47",
    "bool.TryParse and bool.TryFormat were also improved. dotnet/runtime#64782 streamlined these",
    "bool.TryParse and bool.TryFormat were also improved. dotnet/runtime#64782 streamlined these",
    "destination",
    "destination",
    "which requires four writes, it can instead implement the same operation in a single write by doing:",
    "which requires four writes, it can instead implement the same operation in a single write by doing:",
    "BinaryPrimitives.WriteUInt64LittleEndian(MemoryMarshal.AsBytes(destination),",
    "BinaryPrimitives.WriteUInt64LittleEndian(MemoryMarshal.AsBytes(destination),",
    "That 0x65007500720054 is the numerical value of the four characters in memory as a single ulong. You",
    "That 0x65007500720054 is the numerical value of the four characters in memory as a single ulong. You",
    "private bool ",
    "private bool ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "ParseTrue",
    "ParseTrue",
    ".NET 6.0",
    ".NET 6.0",
    "7.347 ns",
    "7.347 ns",
    "1.00",
    "1.00",
    "ParseTrue",
    "ParseTrue",
    ".NET 7.0",
    ".NET 7.0",
    "2.327 ns",
    "2.327 ns",
    "0.32",
    "0.32",
    "FormatTrue",
    "FormatTrue",
    ".NET 6.0",
    ".NET 6.0",
    "3.030 ns",
    "3.030 ns",
    "1.00",
    "1.00",
    "FormatTrue",
    "FormatTrue",
    ".NET 7.0",
    ".NET 7.0",
    "1.997 ns",
    "1.997 ns",
    "0.66",
    "0.66",
    "Enum gets several performance boosts, as well. For example, when performing an operation like",
    "Enum gets several performance boosts, as well. For example, when performing an operation like",
    "94",
    "94",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER 9 | Primitive Types and Numerics",
    "and arrays), and for enums with more than that, it does a SpanHelpers.BinarySearch (which is the",
    "and arrays), and for enums with more than that, it does a SpanHelpers.BinarySearch (which is the",
    "private DayOfWeek",
    "private DayOfWeek",
    "[",
    "[",
    "}",
    "}",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "AllDefined",
    "AllDefined",
    ".NET 6.0",
    ".NET 6.0",
    "159.28 ns",
    "159.28 ns",
    "1.00",
    "1.00",
    "AllDefined",
    "AllDefined",
    ".NET 7.0",
    ".NET 7.0",
    "94.86 ns",
    "94.86 ns",
    "0.60",
    "0.60",
    "Enums also get a boost in conjunction with Nullable",
    "Enums also get a boost in conjunction with Nullable",
    "private DayOfWeek?",
    "private DayOfWeek?",
    "[",
    "[",
    "private static int IndexOf",
    "private static int IndexOf",
    "}",
    "}",
    "95",
    "95",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER 9 | Primitive Types and Numerics",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "FindEnum",
    "FindEnum",
    ".NET 6.0",
    ".NET 6.0",
    "421.608 ns",
    "421.608 ns",
    "1.00",
    "1.00",
    "FindEnum",
    "FindEnum",
    ".NET 7.0",
    ".NET 7.0",
    "5.466 ns",
    "5.466 ns",
    "0.01",
    "0.01",
    "Not to be left out, Guid\u2019s equality operations also get faster, thanks to dotnet/runtime#66889 from",
    "Not to be left out, Guid\u2019s equality operations also get faster, thanks to dotnet/runtime#66889 from",
    "private Guid ",
    "private Guid ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio  Code Size",
    "Runtime  Mean  Ratio  Code Size",
    "GuidEquals",
    "GuidEquals",
    ".NET 6.0",
    ".NET 6.0",
    "2.119 ns",
    "2.119 ns",
    "1.00",
    "1.00",
    "GuidEquals",
    "GuidEquals",
    ".NET 7.0",
    ".NET 7.0",
    "1.354 ns",
    "1.354 ns",
    "0.64",
    "0.64",
    "90 B",
    "90 B",
    "78 B",
    "78 B",
    "DateTime equality is also improved. dotnet/runtime#59857 shaves some overhead off of",
    "DateTime equality is also improved. dotnet/runtime#59857 shaves some overhead off of",
    "; Program.DateTimeEquals()",
    "; Program.DateTimeEquals()",
    "and on .NET 7 this produces:",
    "and on .NET 7 this produces:",
    "; Program.DateTimeEquals()",
    "; Program.DateTimeEquals()",
    "96",
    "96",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER 9 | Primitive Types and Numerics",
    "sete      al",
    "sete      al",
    "so instead of a mov, and, and, and cmp, we get just an xor and a shl.",
    "so instead of a mov, and, and, and cmp, we get just an xor and a shl.",
    "Other operations on DateTime also become more efficient, thanks to dotnet/runtime#72712 from",
    "Other operations on DateTime also become more efficient, thanks to dotnet/runtime#72712 from",
    "private DateTime ",
    "private DateTime ",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Day",
    "Day",
    "Day",
    "Day",
    ".NET 6.0",
    ".NET 6.0",
    "5.2080 ns",
    "5.2080 ns",
    "1.00",
    "1.00",
    ".NET 7.0",
    ".NET 7.0",
    "2.0549 ns",
    "2.0549 ns",
    "0.39",
    "0.39",
    "Month",
    "Month",
    ".NET 6.0",
    ".NET 6.0",
    "4.1186 ns",
    "4.1186 ns",
    "1.00",
    "1.00",
    "Month",
    "Month",
    ".NET 7.0",
    ".NET 7.0",
    "2.0945 ns",
    "2.0945 ns",
    "0.51",
    "0.51",
    "Year",
    "Year",
    "Year",
    "Year",
    ".NET 6.0",
    ".NET 6.0",
    "3.1422 ns",
    "3.1422 ns",
    "1.00",
    "1.00",
    ".NET 7.0",
    ".NET 7.0",
    "0.8200 ns",
    "0.8200 ns",
    "0.26",
    "0.26",
    "TryFormat",
    "TryFormat",
    ".NET 6.0",
    ".NET 6.0",
    "27.6259 ns",
    "27.6259 ns",
    "1.00",
    "1.00",
    "TryFormat",
    "TryFormat",
    ".NET 7.0",
    ".NET 7.0",
    "25.9848 ns",
    "25.9848 ns",
    "0.94",
    "0.94",
    "So, we\u2019ve touched on improvements to a few types, but the pi\u00e8ce de r\u00e9sistance around primitive types",
    "So, we\u2019ve touched on improvements to a few types, but the pi\u00e8ce de r\u00e9sistance around primitive types",
    "There\u2019s an excellent blog post from June dedicated just to generic math, so I won\u2019t go into much",
    "There\u2019s an excellent blog post from June dedicated just to generic math, so I won\u2019t go into much",
    "97",
    "97",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER 9 | Primitive Types and Numerics",
    "code applied to any types that implement the interfaces\u2026 which all of the numerical types in .NET 7",
    "code applied to any types that implement the interfaces\u2026 which all of the numerical types in .NET 7",
    "While this support is all primarily intended for external consumers, the core libraries do consume",
    "While this support is all primarily intended for external consumers, the core libraries do consume",
    "Another simple example comes from the new System.Formats.Tar library in .NET 7, which as the",
    "Another simple example comes from the new System.Formats.Tar library in .NET 7, which as the",
    "98",
    "98",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER 9 | Primitive Types and Numerics",
    "static abstract TResult operator ",
    "static abstract TResult operator ",
    "and the compiler will pick the appropriate one based on the context.",
    "and the compiler will pick the appropriate one based on the context.",
    "In addition to all the existing types that get these interfaces, there are also new types.",
    "In addition to all the existing types that get these interfaces, there are also new types.",
    "Several PRs moved native implementations of these kinds of math operations to managed code.",
    "Several PRs moved native implementations of these kinds of math operations to managed code.",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "arg",
    "arg",
    "Mean  Ratio",
    "Mean  Ratio",
    "ILogB",
    "ILogB",
    ".NET 6.0",
    ".NET 6.0",
    "12345.6789  4.056 ns",
    "12345.6789  4.056 ns",
    "1.00",
    "1.00",
    "ILogB",
    "ILogB",
    ".NET 7.0",
    ".NET 7.0",
    "12345.6789  1.059 ns",
    "12345.6789  1.059 ns",
    "0.26",
    "0.26",
    "Other math operations were also improved in various ways. Math{F}.Truncate was improved in",
    "Other math operations were also improved in various ways. Math{F}.Truncate was improved in",
    "dotnet/runtime#55121 from ",
    "dotnet/runtime#55121 from ",
    "99",
    "99",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER 9 | Primitive Types and Numerics",
    "private string ",
    "private string ",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio",
    "Method  Runtime  Mean  Ratio",
    "Parse",
    "Parse",
    ".NET 6.0",
    ".NET 6.0",
    "3.474 s",
    "3.474 s",
    "1.00",
    "1.00",
    "Parse",
    "Parse",
    ".NET 7.0",
    ".NET 7.0",
    "1.672 s",
    "1.672 s",
    "0.48",
    "0.48",
    "Also related to BigInteger (and not just for really big ones), dotnet/runtime#35565 from",
    "Also related to BigInteger (and not just for really big ones), dotnet/runtime#35565 from",
    "private BigInteger ",
    "private BigInteger ",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "ModPow",
    "ModPow",
    ".NET 6.0",
    ".NET 6.0",
    "1.527 ms",
    "1.527 ms",
    "1.00",
    "1.00",
    "706 B",
    "706 B",
    "ModPow",
    "ModPow",
    ".NET 7.0",
    ".NET 7.0",
    "1.589 ms",
    "1.589 ms",
    "1.04",
    "1.04",
    "50 B",
    "50 B",
    "1.00",
    "1.00",
    "0.07",
    "0.07",
    "100",
    "100",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER 9 | Primitive Types and Numerics",
    "CHAPTER  10",
    "CHAPTER  10",
    "Arrays, Strings, and Spans",
    "Arrays, Strings, and Spans",
    "While there are many forms of computation that can consume resources in applications, some of the",
    "While there are many forms of computation that can consume resources in applications, some of the",
    "Let\u2019s start with some new APIs that can help make writing more efficient code easier. When examining",
    "Let\u2019s start with some new APIs that can help make writing more efficient code easier. When examining",
    "while (i ",
    "while (i ",
    "or that are ASCII letters:",
    "or that are ASCII letters:",
    "while (i ",
    "while (i ",
    "or other such groups. Interestingly, there\u2019s wide-spread variation in how such checks are coded, often",
    "or other such groups. Interestingly, there\u2019s wide-spread variation in how such checks are coded, often",
    "while (i ",
    "while (i ",
    "which while more \u201cintense\u201d is also much more concise and more efficient. It\u2019s taking advantage of a",
    "which while more \u201cintense\u201d is also much more concise and more efficient. It\u2019s taking advantage of a",
    "101",
    "101",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "than ",
    "than ",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "IsAsciiDigit",
    "IsAsciiDigit",
    "IsAsciiHexDigit",
    "IsAsciiHexDigit",
    "IsAsciiHexDigitLower",
    "IsAsciiHexDigitLower",
    "IsAsciiHexDigitUpper",
    "IsAsciiHexDigitUpper",
    "IsAsciiLetter",
    "IsAsciiLetter",
    "IsAsciiLetterLower",
    "IsAsciiLetterLower",
    "IsAsciiLetterUpper",
    "IsAsciiLetterUpper",
    "IsAsciiLetterOrDigit",
    "IsAsciiLetterOrDigit",
    "These methods were added by dotnet/runtime#69318, which also employed them in dozens of",
    "These methods were added by dotnet/runtime#69318, which also employed them in dozens of",
    "Another new API focused on encapsulating a common pattern is the new",
    "Another new API focused on encapsulating a common pattern is the new",
    "Yet another new set of APIs are the IndexOfAnyExcept and LastIndexOfAnyExcept methods,",
    "Yet another new set of APIs are the IndexOfAnyExcept and LastIndexOfAnyExcept methods,",
    "102",
    "102",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "occurrence of value in the input, and whereas IndexOfAny(T value0, T value1, ...) searches for",
    "occurrence of value in the input, and whereas IndexOfAny(T value0, T value1, ...) searches for",
    "bool allZero = array.AsSpan().IndexOfAnyExcept(0) ",
    "bool allZero = array.AsSpan().IndexOfAnyExcept(0) ",
    "dotnet/runtime#73488 vectorizes this overload, as well.",
    "dotnet/runtime#73488 vectorizes this overload, as well.",
    "private byte",
    "private byte",
    "[",
    "[",
    "}",
    "}",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "OpenCoded",
    "OpenCoded",
    "370.47 ns",
    "370.47 ns",
    "1.00",
    "1.00",
    "IndexOfAnyExcept",
    "IndexOfAnyExcept",
    "23.84 ns",
    "23.84 ns",
    "0.06",
    "0.06",
    "Of course, while new \u201cindex of\u201d variations are helpful, we already have a bunch of such methods, and",
    "Of course, while new \u201cindex of\u201d variations are helpful, we already have a bunch of such methods, and",
    "103",
    "103",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "\u2018h\u2019 than it is to find an \u2018h\u2019 followed four characters later by an \u2018o\u2019, and thus this implementation is able",
    "\u2018h\u2019 than it is to find an \u2018h\u2019 followed four characters later by an \u2018o\u2019, and thus this implementation is able",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "}",
    "}",
    "This is pulling down the text to \u201cThe Adventures of Sherlock Holmes\u201d from Project Gutenberg and",
    "This is pulling down the text to \u201cThe Adventures of Sherlock Holmes\u201d from Project Gutenberg and",
    "Method  Runtime",
    "Method  Runtime",
    "needle",
    "needle",
    "Mean  Ratio",
    "Mean  Ratio",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "Sherlock",
    "Sherlock",
    "43.68 us",
    "43.68 us",
    "1.00",
    "1.00",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "Sherlock",
    "Sherlock",
    "48.33 us",
    "48.33 us",
    "1.11",
    "1.11",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "elementary  1,063.67 us",
    "elementary  1,063.67 us",
    "1.00",
    "1.00",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "elementary",
    "elementary",
    "56.04 us",
    "56.04 us",
    "0.05",
    "0.05",
    "For \u201cSherlock\u201d, the performance is actually a bit worse in .NET 7 than in .NET 6; not much, but a",
    "For \u201cSherlock\u201d, the performance is actually a bit worse in .NET 7 than in .NET 6; not much, but a",
    "104",
    "104",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "Another example of significantly changing the algorithm employed is dotnet/runtime#67758, which",
    "Another example of significantly changing the algorithm employed is dotnet/runtime#67758, which",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "}",
    "}",
    "Here, both words are about 4x faster on .NET 7 than they were on .NET 6:",
    "Here, both words are about 4x faster on .NET 7 than they were on .NET 6:",
    "Method  Runtime",
    "Method  Runtime",
    "needle",
    "needle",
    "Mean  Ratio",
    "Mean  Ratio",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "Sherlock",
    "Sherlock",
    "2,113.1 us",
    "2,113.1 us",
    "1.00",
    "1.00",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "Sherlock",
    "Sherlock",
    "467.3 us",
    "467.3 us",
    "0.22",
    "0.22",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "elementary  2,325.6 us",
    "elementary  2,325.6 us",
    "1.00",
    "1.00",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "elementary",
    "elementary",
    "638.8 us",
    "638.8 us",
    "0.27",
    "0.27",
    "as we\u2019re now doing a vectorized IndexOfAny(",
    "as we\u2019re now doing a vectorized IndexOfAny(",
    "Another example comes from dotnet/runtime#67492 from ",
    "Another example comes from dotnet/runtime#67492 from ",
    "private byte",
    "private byte",
    "105",
    "105",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Contains",
    "Contains",
    ".NET 6.0",
    ".NET 6.0",
    "15.115 ns",
    "15.115 ns",
    "1.00",
    "1.00",
    "Contains",
    "Contains",
    ".NET 7.0",
    ".NET 7.0",
    "2.557 ns",
    "2.557 ns",
    "0.17",
    "0.17",
    "dotnet/runtime#60974 from ",
    "dotnet/runtime#60974 from ",
    "private int",
    "private int",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "IndexOf",
    "IndexOf",
    ".NET 6.0",
    ".NET 6.0",
    "252.17 ns",
    "252.17 ns",
    "1.00",
    "1.00",
    "IndexOf",
    "IndexOf",
    ".NET 7.0",
    ".NET 7.0",
    "78.82 ns",
    "78.82 ns",
    "0.31",
    "0.31",
    "One final interesting IndexOf-related optimization. string has long had",
    "One final interesting IndexOf-related optimization. string has long had",
    "106",
    "106",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "dotnet/runtime#63817, all of these are now unified, such that both string and MemoryExtensions",
    "dotnet/runtime#63817, all of these are now unified, such that both string and MemoryExtensions",
    "private readonly char",
    "private readonly char",
    "[",
    "[",
    "[",
    "[",
    "}",
    "}",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "LastIndexOfAny",
    "LastIndexOfAny",
    ".NET 6.0",
    ".NET 6.0",
    "443.29 ns",
    "443.29 ns",
    "1.00",
    "1.00",
    "LastIndexOfAny",
    "LastIndexOfAny",
    ".NET 7.0",
    ".NET 7.0",
    "31.79 ns",
    "31.79 ns",
    "0.07",
    "0.07",
    "CountLines",
    "CountLines",
    ".NET 6.0",
    ".NET 6.0",
    "1,689.66 ns",
    "1,689.66 ns",
    "1.00",
    "1.00",
    "CountLines",
    "CountLines",
    ".NET 7.0",
    ".NET 7.0",
    "1,461.64 ns",
    "1,461.64 ns",
    "0.86",
    "0.86",
    "That same PR also cleans up uses of the IndexOf family, and in particular around uses that are",
    "That same PR also cleans up uses of the IndexOf family, and in particular around uses that are",
    "107",
    "107",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "Speaking of call sites, one of the great things about having highly optimized IndexOf methods is",
    "Speaking of call sites, one of the great things about having highly optimized IndexOf methods is",
    "private StringBuilder ",
    "private StringBuilder ",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Replace",
    "Replace",
    ".NET 6.0",
    ".NET 6.0",
    "1,563.69 ns",
    "1,563.69 ns",
    "1.00",
    "1.00",
    "Replace",
    "Replace",
    ".NET 7.0",
    ".NET 7.0",
    "70.84 ns",
    "70.84 ns",
    "0.04",
    "0.04",
    "dotnet/runtime#60463 from ",
    "dotnet/runtime#60463 from ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "ReadAllLines",
    "ReadAllLines",
    ".NET 6.0",
    ".NET 6.0",
    "947.8 ns",
    "947.8 ns",
    "1.00",
    "1.00",
    "ReadAllLines",
    "ReadAllLines",
    ".NET 7.0",
    ".NET 7.0",
    "385.7 ns",
    "385.7 ns",
    "0.41",
    "0.41",
    "And dotnet/runtime#70176 cleaned up a plethora of additional uses.",
    "And dotnet/runtime#70176 cleaned up a plethora of additional uses.",
    "Finally on the IndexOf front, as noted, a lot of time and energy over the years has gone into",
    "Finally on the IndexOf front, as noted, a lot of time and energy over the years has gone into",
    "[",
    "[",
    "108",
    "108",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "IndexOfAny",
    "IndexOfAny",
    ".NET 6.0",
    ".NET 6.0",
    "52.29 ns",
    "52.29 ns",
    "1.00",
    "1.00",
    "IndexOfAny",
    "IndexOfAny",
    ".NET 7.0",
    ".NET 7.0",
    "40.17 ns",
    "40.17 ns",
    "0.77",
    "0.77",
    "The IndexOf family is just one of many on string/MemoryExtensions that has seen dramatic",
    "The IndexOf family is just one of many on string/MemoryExtensions that has seen dramatic",
    "private string ",
    "private string ",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "IsHttps",
    "IsHttps",
    ".NET 6.0",
    ".NET 6.0",
    "4.5634 ns",
    "4.5634 ns",
    "1.00",
    "1.00",
    "IsHttps",
    "IsHttps",
    ".NET 7.0",
    ".NET 7.0",
    "0.4873 ns",
    "0.4873 ns",
    "0.11",
    "0.11",
    "IsHttps",
    "IsHttps",
    ".NET 6.0",
    ".NET 6.0",
    "6.5654 ns",
    "6.5654 ns",
    "1.00",
    "1.00",
    "IsHttps",
    "IsHttps",
    ".NET 7.0",
    ".NET 7.0",
    "0.5577 ns",
    "0.5577 ns",
    "0.08",
    "0.08",
    "Interestingly, since .NET 5 the code generated by RegexOptions.Compiled would perform similar",
    "Interestingly, since .NET 5 the code generated by RegexOptions.Compiled would perform similar",
    "109",
    "109",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "much easier to read code utilizing StartsWith that\u2019s just as fast (dotnet/runtime#65222 and",
    "much easier to read code utilizing StartsWith that\u2019s just as fast (dotnet/runtime#65222 and",
    "StartsWith and EndsWith have improved in other ways. dotnet/runtime#63734 (improved further by",
    "StartsWith and EndsWith have improved in other ways. dotnet/runtime#63734 (improved further by",
    "return Length ",
    "return Length ",
    "which given what I just described makes sense: if the Length is 0, then the string doesn\u2019t begin with",
    "which given what I just described makes sense: if the Length is 0, then the string doesn\u2019t begin with",
    "public bool StartsWith(char value)",
    "public bool StartsWith(char value)",
    "}",
    "}",
    "If the value parameter isn\u2019t a constant, then IsKnownConstant will be substituted with false, the",
    "If the value parameter isn\u2019t a constant, then IsKnownConstant will be substituted with false, the",
    "return ",
    "return ",
    "110",
    "110",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "and we\u2019ve saved ourselves a read of the string\u2019s length, a comparison, and a branch.",
    "and we\u2019ve saved ourselves a read of the string\u2019s length, a comparison, and a branch.",
    "private string ",
    "private string ",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio",
    "Method  Runtime  Mean  Ratio",
    "StartsWith",
    "StartsWith",
    ".NET 6.0",
    ".NET 6.0",
    "8.130 ns",
    "8.130 ns",
    "1.00",
    "1.00",
    "StartsWith",
    "StartsWith",
    ".NET 7.0",
    ".NET 7.0",
    "1.653 ns",
    "1.653 ns",
    "0.20",
    "0.20",
    "(Another example of IsKnownConstant being used comes from dotnet/runtime#64016, which uses it",
    "(Another example of IsKnownConstant being used comes from dotnet/runtime#64016, which uses it",
    "EndsWith was also improved in dotnet/runtime#72750, and specifically for when",
    "EndsWith was also improved in dotnet/runtime#72750, and specifically for when",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "EndsWith",
    "EndsWith",
    ".NET 6.0",
    ".NET 6.0",
    "10.861 ns",
    "10.861 ns",
    "1.00",
    "1.00",
    "EndsWith",
    "EndsWith",
    ".NET 7.0",
    ".NET 7.0",
    "5.385 ns",
    "5.385 ns",
    "0.50",
    "0.50",
    "Finally, dotnet/runtime#67202 and dotnet/runtime#73475 employ Vector128",
    "Finally, dotnet/runtime#67202 and dotnet/runtime#73475 employ Vector128",
    "111",
    "111",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "Another method that\u2019s seem some attention in .NET 7 is MemoryExtensions.Reverse (and",
    "Another method that\u2019s seem some attention in .NET 7 is MemoryExtensions.Reverse (and",
    "private char",
    "private char",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Reverse",
    "Reverse",
    ".NET 6.0",
    ".NET 6.0",
    "21.352 ns",
    "21.352 ns",
    "1.00",
    "1.00",
    "Reverse",
    "Reverse",
    ".NET 7.0",
    ".NET 7.0",
    "9.536 ns",
    "9.536 ns",
    "0.45",
    "0.45",
    "String.Split also saw vectorization improvements in dotnet/runtime#64899 from",
    "String.Split also saw vectorization improvements in dotnet/runtime#64899 from",
    "Converting various formats of strings is something many applications and services do, whether that\u2019s",
    "Converting various formats of strings is something many applications and services do, whether that\u2019s",
    "112",
    "112",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "Base64 characters (there\u2019s a formula), and the implementation can either allocate that final space",
    "Base64 characters (there\u2019s a formula), and the implementation can either allocate that final space",
    "private byte",
    "private byte",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "TryToBase64Chars",
    "TryToBase64Chars",
    ".NET 6.0",
    ".NET 6.0",
    "623.25 ns",
    "623.25 ns",
    "1.00",
    "1.00",
    "TryToBase64Chars",
    "TryToBase64Chars",
    ".NET 7.0",
    ".NET 7.0",
    "81.82 ns",
    "81.82 ns",
    "0.13",
    "0.13",
    "Just as widening can be used to go from bytes to chars, narrowing can be used to go from chars to",
    "Just as widening can be used to go from bytes to chars, narrowing can be used to go from chars to",
    "Encoding.UTF8 was also improved a bit. In particular, dotnet/runtime#69910 streamlined the",
    "Encoding.UTF8 was also improved a bit. In particular, dotnet/runtime#69910 streamlined the",
    "113",
    "113",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "GetMaxByteCount",
    "GetMaxByteCount",
    ".NET 6.0",
    ".NET 6.0",
    "1.7442 ns",
    "1.7442 ns",
    "1.00",
    "1.00",
    "GetMaxByteCount",
    "GetMaxByteCount",
    ".NET 7.0",
    ".NET 7.0",
    "0.4746 ns",
    "0.4746 ns",
    "0.27",
    "0.27",
    "Arguably the biggest improvement around UTF8 in .NET 7 is the new C# 11 support for UTF8 literals.",
    "Arguably the biggest improvement around UTF8 in .NET 7 is the new C# 11 support for UTF8 literals.",
    "public static ReadOnlySpan",
    "public static ReadOnlySpan",
    "the C# compiler will compile that equivalent to if you wrote:",
    "the C# compiler will compile that equivalent to if you wrote:",
    "public static ReadOnlySpan",
    "public static ReadOnlySpan",
    "In other words, the compiler is doing the equivalent of Encoding.UTF8.GetBytes at compile-time and",
    "In other words, the compiler is doing the equivalent of Encoding.UTF8.GetBytes at compile-time and",
    "IL",
    "IL",
    "This means we not only save on the encoding costs at run-time, and we not only avoid whatever",
    "This means we not only save on the encoding costs at run-time, and we not only avoid whatever",
    "public static int M() => Text.Length;",
    "public static int M() => Text.Length;",
    "for which the JIT produces:",
    "for which the JIT produces:",
    "; Program.M()",
    "; Program.M()",
    "114",
    "114",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "ret",
    "ret",
    "The JIT inlines the property access, sees that the span is being constructed with a length of 5, and so",
    "The JIT inlines the property access, sees that the span is being constructed with a length of 5, and so",
    "Thanks primarily to dotnet/runtime#70568, dotnet/runtime#69995, dotnet/runtime#70894,",
    "Thanks primarily to dotnet/runtime#70568, dotnet/runtime#69995, dotnet/runtime#70894,",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "WithEncoding  17.3347 ns  1.000",
    "WithEncoding  17.3347 ns  1.000",
    "32 B",
    "32 B",
    "Withu8",
    "Withu8",
    "0.0060 ns  0.000",
    "0.0060 ns  0.000",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "Like I said, not fair, but it proves the point :)",
    "Like I said, not fair, but it proves the point :)",
    "Encoding is of course just one mechanism for creating string instances. Others have also improved in",
    "Encoding is of course just one mechanism for creating string instances. Others have also improved in",
    "You can also see improvements in string.Format and StringBuilder.AppendFormat, as well as",
    "You can also see improvements in string.Format and StringBuilder.AppendFormat, as well as",
    "private StringBuilder ",
    "private StringBuilder ",
    "[",
    "[",
    "115",
    "115",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "AppendFormat",
    "AppendFormat",
    ".NET 6.0",
    ".NET 6.0",
    "338.23 ns",
    "338.23 ns",
    "1.00",
    "1.00",
    "AppendFormat",
    "AppendFormat",
    ".NET 7.0",
    ".NET 7.0",
    "49.15 ns",
    "49.15 ns",
    "0.15",
    "0.15",
    "Speaking of StringBuilder, it\u2019s seen additional improvements beyond the aforementioned changes",
    "Speaking of StringBuilder, it\u2019s seen additional improvements beyond the aforementioned changes",
    "fixed (char",
    "fixed (char",
    "That fixed statement translates into a \u201cpinning pointer.\u201d Normally the GC is free to move managed",
    "That fixed statement translates into a \u201cpinning pointer.\u201d Normally the GC is free to move managed",
    "Append(ref Unsafe.Add(ref value.GetRawStringData(), startIndex), count);",
    "Append(ref Unsafe.Add(ref value.GetRawStringData(), startIndex), count);",
    "where that string.GetRawStringData method is just an internal version of the public",
    "where that string.GetRawStringData method is just an internal version of the public",
    "116",
    "116",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "The second thing this StringBuilder change did was unify an optimization that was present for",
    "The second thing this StringBuilder change did was unify an optimization that was present for",
    "private StringBuilder ",
    "private StringBuilder ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "AppendSpan",
    "AppendSpan",
    ".NET 6.0",
    ".NET 6.0",
    "35.98 ns",
    "35.98 ns",
    "1.00",
    "1.00",
    "AppendSpan",
    "AppendSpan",
    ".NET 7.0",
    ".NET 7.0",
    "17.59 ns",
    "17.59 ns",
    "0.49",
    "0.49",
    "One of the great things about improving things low in the stack is they have a multiplicative effect;",
    "One of the great things about improving things low in the stack is they have a multiplicative effect;",
    "private DateTimeOffset ",
    "private DateTimeOffset ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "DateTimeOffsetToString",
    "DateTimeOffsetToString",
    ".NET 6.0",
    ".NET 6.0",
    "340.4 ns",
    "340.4 ns",
    "1.00",
    "1.00",
    "DateTimeOffsetToString",
    "DateTimeOffsetToString",
    ".NET 7.0",
    ".NET 7.0",
    "289.4 ns",
    "289.4 ns",
    "0.85",
    "0.85",
    "StringBuilder itself was then further updated by dotnet/runtime#64922 from ",
    "StringBuilder itself was then further updated by dotnet/runtime#64922 from ",
    "117",
    "117",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "previously discussed PR to insert the resulting characters at the right location (it also falls back to",
    "previously discussed PR to insert the resulting characters at the right location (it also falls back to",
    "private StringBuilder ",
    "private StringBuilder ",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Insert",
    "Insert",
    ".NET 6.0",
    ".NET 6.0",
    "30.02 ns",
    "30.02 ns",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    "Insert",
    "Insert",
    ".NET 7.0",
    ".NET 7.0",
    "25.53 ns",
    "25.53 ns",
    "0.85",
    "0.85",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "Other minor improvements to StringBuilder have also been made, like dotnet/runtime#60406 which",
    "Other minor improvements to StringBuilder have also been made, like dotnet/runtime#60406 which",
    "private static string CreateSortString(PropertyDescriptor property, ListSortDirection",
    "private static string CreateSortString(PropertyDescriptor property, ListSortDirection",
    "We don\u2019t actually need the StringBuilder here, as in the worst-case we\u2019re just concatenating three",
    "We don\u2019t actually need the StringBuilder here, as in the worst-case we\u2019re just concatenating three",
    "private static string CreateSortString(PropertyDescriptor property, ListSortDirection",
    "private static string CreateSortString(PropertyDescriptor property, ListSortDirection",
    "Note that I\u2019ve expressed that concatenation via an interpolated string, but the C# compiler will \u201clower\u201d",
    "Note that I\u2019ve expressed that concatenation via an interpolated string, but the C# compiler will \u201clower\u201d",
    "private static string CreateSortString(PropertyDescriptor property, ListSortDirection",
    "private static string CreateSortString(PropertyDescriptor property, ListSortDirection",
    "118",
    "118",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "direction == ListSortDirection.Descending ?",
    "direction == ListSortDirection.Descending ?",
    "As an aside, the expanded string.Concat version highlights that this method could have been",
    "As an aside, the expanded string.Concat version highlights that this method could have been",
    "private static string CreateSortString(PropertyDescriptor property, ListSortDirection",
    "private static string CreateSortString(PropertyDescriptor property, ListSortDirection",
    "but this doesn\u2019t meaningfully affect performance and here clarity and maintainability was more",
    "but this doesn\u2019t meaningfully affect performance and here clarity and maintainability was more",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "WithStringBuilder  68.34 ns",
    "WithStringBuilder  68.34 ns",
    "1.00",
    "1.00",
    "272 B",
    "272 B",
    "WithConcat",
    "WithConcat",
    "20.78 ns",
    "20.78 ns",
    "0.31",
    "0.31",
    "64 B",
    "64 B",
    "1.00",
    "1.00",
    "0.24",
    "0.24",
    "There are also places where StringBuilder was still applicable, but it was being used on hot-enough",
    "There are also places where StringBuilder was still applicable, but it was being used on hot-enough",
    "119",
    "119",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "remaining uses of StringBuilderCache have been replaced. I\u2019m hopeful we can entirely remove",
    "remaining uses of StringBuilderCache have been replaced. I\u2019m hopeful we can entirely remove",
    "In the same vein of not doing unnecessary work, there\u2019s a fairly common pattern that shows up with",
    "In the same vein of not doing unnecessary work, there\u2019s a fairly common pattern that shows up with",
    "span = span.Slice(offset, str.Length - offset);",
    "span = span.Slice(offset, str.Length - offset);",
    "The relevant thing to recognize here is these methods have overloads that take just the starting offset.",
    "The relevant thing to recognize here is these methods have overloads that take just the starting offset.",
    "span = span.Slice(offset);",
    "span = span.Slice(offset);",
    "which is not only more readable and maintainable, it has some small efficiency benefits, e.g. on 64-bit",
    "which is not only more readable and maintainable, it has some small efficiency benefits, e.g. on 64-bit",
    "Ok, enough about string. What about spans? One of the coolest features in C# 11 is the new support",
    "Ok, enough about string. What about spans? One of the coolest features in C# 11 is the new support",
    "class Data",
    "class Data",
    "Later versions of C# added the ability to have local refs, e.g.",
    "Later versions of C# added the ability to have local refs, e.g.",
    "void Add(ref int i)",
    "void Add(ref int i)",
    "and even to have ref returns, e.g.",
    "and even to have ref returns, e.g.",
    "120",
    "120",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "ref int Add(ref int i)",
    "ref int Add(ref int i)",
    "These facilities are more advanced, but they\u2019re used liberally throughout higher-performance code",
    "These facilities are more advanced, but they\u2019re used liberally throughout higher-performance code",
    "Span",
    "Span",
    "private T",
    "private T",
    "But not span. Span",
    "But not span. Span",
    "public ref T this",
    "public ref T this",
    "}",
    "}",
    "Note there\u2019s only a getter and no setter; that\u2019s because it returns a ref T to the actual storage",
    "Note there\u2019s only a getter and no setter; that\u2019s because it returns a ref T to the actual storage",
    "span",
    "span",
    "but rather than that being equivalent to calling some setter:",
    "but rather than that being equivalent to calling some setter:",
    "span.set",
    "span.set",
    "it\u2019s actually equivalent to using the getter to retrieve the ref and then writing a value through that",
    "it\u2019s actually equivalent to using the getter to retrieve the ref and then writing a value through that",
    "ref T item = ref span.get",
    "ref T item = ref span.get",
    "That\u2019s all well and good, but what\u2019s that ",
    "That\u2019s all well and good, but what\u2019s that ",
    "121",
    "121",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "public readonly ref struct Span",
    "public readonly ref struct Span",
    "The rollout of ref fields throughout dotnet/runtime was done in dotnet/runtime#71498, following the",
    "The rollout of ref fields throughout dotnet/runtime was done in dotnet/runtime#71498, following the",
    "public Span(ref T reference);",
    "public Span(ref T reference);",
    "added in dotnet/runtime#67447 (and then made public and used more broadly in",
    "added in dotnet/runtime#67447 (and then made public and used more broadly in",
    "Imagine if you could willy-nilly call this constructor. You\u2019d be able to write code like this:",
    "Imagine if you could willy-nilly call this constructor. You\u2019d be able to write code like this:",
    "public Span",
    "public Span",
    "At this point the caller of this method is handed a span that refers to garbage; that\u2019s bad in code",
    "At this point the caller of this method is handed a span that refers to garbage; that\u2019s bad in code",
    "public Span",
    "public Span",
    "but at that point you\u2019ve taken on the risk of using unsafe code and pointers and any resulting",
    "but at that point you\u2019ve taken on the risk of using unsafe code and pointers and any resulting",
    "error CS8347: Cannot use a result of ",
    "error CS8347: Cannot use a result of ",
    "In other words, the compiler now understands that Span",
    "In other words, the compiler now understands that Span",
    "122",
    "122",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "of the method, which is bad. Hence how this relates to ref fields: because ref fields are now a thing,",
    "of the method, which is bad. Hence how this relates to ref fields: because ref fields are now a thing,",
    "As is often the case, addressing one issue kicks the can down the road a bit and exposes another. The",
    "As is often the case, addressing one issue kicks the can down the road a bit and exposes another. The",
    "var writer = new SpanWriter(stackalloc char",
    "var writer = new SpanWriter(stackalloc char",
    "static void Append(ref SpanWriter builder, byte value)",
    "static void Append(ref SpanWriter builder, byte value)",
    "ref struct SpanWriter",
    "ref struct SpanWriter",
    "}",
    "}",
    "We have a ref struct SpanWriter that takes a Span",
    "We have a ref struct SpanWriter that takes a Span",
    "123",
    "123",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "error CS8350: This combination of arguments to ",
    "error CS8350: This combination of arguments to ",
    "What do we do? The Write method doesn\u2019t actually store the value parameter and won\u2019t ever need",
    "What do we do? The Write method doesn\u2019t actually store the value parameter and won\u2019t ever need",
    "public void Write(scoped ReadOnlySpan",
    "public void Write(scoped ReadOnlySpan",
    "If Write were then to try to store value, the compiler would balk:",
    "If Write were then to try to store value, the compiler would balk:",
    "error CS8352: Cannot use variable ",
    "error CS8352: Cannot use variable ",
    "But as it\u2019s not trying to do so, everything now compiles successfully. You can see examples of how this",
    "But as it\u2019s not trying to do so, everything now compiles successfully. You can see examples of how this",
    "There\u2019s also the other direction: there are some things that are implicitly scoped, like the this",
    "There\u2019s also the other direction: there are some things that are implicitly scoped, like the this",
    "public struct SingleItemList",
    "public struct SingleItemList",
    "}",
    "}",
    "This produces a compiler error:",
    "This produces a compiler error:",
    "error CS8170: Struct members cannot return ",
    "error CS8170: Struct members cannot return ",
    "Effectively, that\u2019s because this is implicitly scoped (even though that keyword wasn\u2019t previously",
    "Effectively, that\u2019s because this is implicitly scoped (even though that keyword wasn\u2019t previously",
    "[",
    "[",
    "and now the code will compile successfully. Of course, this also places demands on callers of this",
    "and now the code will compile successfully. Of course, this also places demands on callers of this",
    "124",
    "124",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "Another impactful span-related change comes in dotnet/runtime#70095 from ",
    "Another impactful span-related change comes in dotnet/runtime#70095 from ",
    "private byte",
    "private byte",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "AddBytes",
    "AddBytes",
    ".NET 6.0",
    ".NET 6.0",
    "159.11 ns",
    "159.11 ns",
    "1.00",
    "1.00",
    "AddBytes",
    "AddBytes",
    ".NET 7.0",
    ".NET 7.0",
    "42.11 ns",
    "42.11 ns",
    "0.26",
    "0.26",
    "Another span-related change, dotnet/runtime#72727 refactored a bunch of code paths to eliminate",
    "Another span-related change, dotnet/runtime#72727 refactored a bunch of code paths to eliminate",
    "private static readonly char",
    "private static readonly char",
    "and replaced it with code like:",
    "and replaced it with code like:",
    "int index = value.AsSpan().IndexOfAny(@",
    "int index = value.AsSpan().IndexOfAny(@",
    "125",
    "125",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "This has a variety of benefits. There\u2019s the usability benefit of keeping the tokens being searched close",
    "This has a variety of benefits. There\u2019s the usability benefit of keeping the tokens being searched close",
    "private static readonly char",
    "private static readonly char",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "WithArray",
    "WithArray",
    "8.601 ns",
    "8.601 ns",
    "1.00",
    "1.00",
    "WithString  6.949 ns",
    "WithString  6.949 ns",
    "0.81",
    "0.81",
    "Another example from that PR took code along the lines of:",
    "Another example from that PR took code along the lines of:",
    "private static readonly char",
    "private static readonly char",
    "and replaced it with code like:",
    "and replaced it with code like:",
    "switch (attr.Value.AsSpan().Trim(",
    "switch (attr.Value.AsSpan().Trim(",
    "In this case, not only have we avoided the char",
    "In this case, not only have we avoided the char",
    "Of course, in some cases the arrays are entirely unnecessary. In that same PR, there were several cases",
    "Of course, in some cases the arrays are entirely unnecessary. In that same PR, there were several cases",
    "private static readonly char",
    "private static readonly char",
    "126",
    "126",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "By switching to use spans, again, we can instead write it like this:",
    "By switching to use spans, again, we can instead write it like this:",
    "int wsIndex = target.AsSpan(targetPosition).IndexOfAny(",
    "int wsIndex = target.AsSpan(targetPosition).IndexOfAny(",
    "MemoryExtensions.IndexOfAny has a dedicated overload for two and three arguments, at which",
    "MemoryExtensions.IndexOfAny has a dedicated overload for two and three arguments, at which",
    "Finally, dotnet/runtime#59670 from ",
    "Finally, dotnet/runtime#59670 from ",
    "127",
    "127",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER 10 | Arrays, Strings, and Spans",
    "CHAPTER  11",
    "CHAPTER  11",
    "Regex",
    "Regex",
    "Back in May, I shared a fairly detailed post about the improvements coming to Regular Expressions in",
    "Back in May, I shared a fairly detailed post about the improvements coming to Regular Expressions in",
    "Welcome back. With that context, I\u2019ll avoid duplicating content here, and instead focus on how exactly",
    "Welcome back. With that context, I\u2019ll avoid duplicating content here, and instead focus on how exactly",
    "RegexOptions.NonBacktracking",
    "RegexOptions.NonBacktracking",
    "Let\u2019s start with one of the larger new features in Regex, the new RegexOptions.NonBacktracking",
    "Let\u2019s start with one of the larger new features in Regex, the new RegexOptions.NonBacktracking",
    "A significant number of years of development went into the NonBacktracking implementation, which",
    "A significant number of years of development went into the NonBacktracking implementation, which",
    "This implementation is based on the notion of regular expression derivatives, a concept that\u2019s been",
    "This implementation is based on the notion of regular expression derivatives, a concept that\u2019s been",
    "128",
    "128",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "to match three word characters, if you apply this to the next input character \u2018a\u2019, well, that will strip off",
    "to match three word characters, if you apply this to the next input character \u2018a\u2019, well, that will strip off",
    "129",
    "129",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "130",
    "130",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "Looks an awful lot like a DFA, doesn\u2019t it? It should. And that\u2019s exactly how NonBacktracking",
    "Looks an awful lot like a DFA, doesn\u2019t it? It should. And that\u2019s exactly how NonBacktracking",
    "Of course, the devil is in the details and there\u2019s a ton of complication and engineering smarts that go",
    "Of course, the devil is in the details and there\u2019s a ton of complication and engineering smarts that go",
    "As noted, the non-backtracking engine is linear in the length of the input. But that doesn\u2019t mean it",
    "As noted, the non-backtracking engine is linear in the length of the input. But that doesn\u2019t mean it",
    "131",
    "131",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "implementation simply doesn\u2019t support, such that attempting to use any of those will fail when trying",
    "implementation simply doesn\u2019t support, such that attempting to use any of those will fail when trying",
    "Even after its progress as a standalone library from MSR, more than 100 PRs went into making",
    "Even after its progress as a standalone library from MSR, more than 100 PRs went into making",
    "There\u2019s one more set of PRs of performance interest for NonBacktracking. The Regex implementation",
    "There\u2019s one more set of PRs of performance interest for NonBacktracking. The Regex implementation",
    "As was mentioned in my previous blog post about regular expressions, both the backtracking",
    "As was mentioned in my previous blog post about regular expressions, both the backtracking",
    "132",
    "132",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "New APIs",
    "New APIs",
    "Regex gets several new methods in .NET 7, all of which enable improved performance. The simplicity",
    "Regex gets several new methods in .NET 7, all of which enable improved performance. The simplicity",
    "dotnet/runtime#65473 brings Regex into the span-based era of .NET, overcoming a significant",
    "dotnet/runtime#65473 brings Regex into the span-based era of .NET, overcoming a significant",
    "First, we made FindFirstChar and Go virtual instead of abstract. The design that splits these methods",
    "First, we made FindFirstChar and Go virtual instead of abstract. The design that splits these methods",
    "133",
    "133",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "span; they no longer need to access the protected RegexRunner.runtext, RegexRunner.runtextbeg,",
    "span; they no longer need to access the protected RegexRunner.runtext, RegexRunner.runtextbeg,",
    "[",
    "[",
    "[",
    "[",
    "That will result in the JIT generating assembly code along the lines of this:",
    "That will result in the JIT generating assembly code along the lines of this:",
    "; Program.Scan(System.String, Int32, Int32)",
    "; Program.Scan(System.String, Int32, Int32)",
    "In contrast, if we\u2019re dealing with a span, which already factors in the bounds, then we can write a more",
    "In contrast, if we\u2019re dealing with a span, which already factors in the bounds, then we can write a more",
    "[",
    "[",
    "134",
    "134",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "[",
    "[",
    "And when it comes to compilers, something in a canonical form is really good, because the more",
    "And when it comes to compilers, something in a canonical form is really good, because the more",
    "; Program.Scan(System.ReadOnlySpan",
    "; Program.Scan(System.ReadOnlySpan",
    "So even without all the other benefits that come from operating in terms of span, we immediately get",
    "So even without all the other benefits that come from operating in terms of span, we immediately get",
    "[",
    "[",
    "[",
    "[",
    "and here\u2019s what the span version looks like:",
    "and here\u2019s what the span version looks like:",
    "[",
    "[",
    "[",
    "[",
    "135",
    "135",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "And here\u2019s the resulting assembly:",
    "And here\u2019s the resulting assembly:",
    "; Program.IsBoundary(Int32, Int32, Int32)",
    "; Program.IsBoundary(Int32, Int32, Int32)",
    "; Program.IsBoundary(System.ReadOnlySpan",
    "; Program.IsBoundary(System.ReadOnlySpan",
    "136",
    "136",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "push      rbx",
    "push      rbx",
    "The most interesting thing to notice here is the:",
    "The most interesting thing to notice here is the:",
    "call      CORINFO",
    "call      CORINFO",
    "at the end of the first version that doesn\u2019t exist at the end of the second. As we saw earlier, this is",
    "at the end of the first version that doesn\u2019t exist at the end of the second. As we saw earlier, this is",
    "137",
    "137",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "dotnet/runtime#66129, dotnet/runtime#66178, and dotnet/runtime#72728, all of which clean up",
    "dotnet/runtime#66129, dotnet/runtime#66178, and dotnet/runtime#72728, all of which clean up",
    "Ok, so the engines are now able to be handed span inputs and process them, great, what can we do",
    "Ok, so the engines are now able to be handed span inputs and process them, great, what can we do",
    "So, IsMatch and Count can work with spans. But we still don\u2019t have a method that lets you actually get",
    "So, IsMatch and Count can work with spans. But we still don\u2019t have a method that lets you actually get",
    "public ref struct ValueMatchEnumerator",
    "public ref struct ValueMatchEnumerator",
    "Being a ref struct, the enumerator is able to store a reference to the input span, and is thus able to",
    "Being a ref struct, the enumerator is able to store a reference to the input span, and is thus able to",
    "TryFindNextPossibleStartingPosition",
    "TryFindNextPossibleStartingPosition",
    "As noted earlier, the core of all of the engines is a Scan(ReadOnlySpan",
    "As noted earlier, the core of all of the engines is a Scan(ReadOnlySpan",
    "138",
    "138",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "when it either finds the location of the next match or exhausts the input without finding another. For",
    "when it either finds the location of the next match or exhausts the input without finding another. For",
    "protected override void Scan(ReadOnlySpan",
    "protected override void Scan(ReadOnlySpan",
    "We try to match the input at the current position, and if we\u2019re successful in doing so, that\u2019s it, we exit.",
    "We try to match the input at the current position, and if we\u2019re successful in doing so, that\u2019s it, we exit.",
    "protected override void Scan(ReadOnlySpan",
    "protected override void Scan(ReadOnlySpan",
    "As with FindFirstChar previously, that TryFindNextPossibleStartingPosition has the",
    "As with FindFirstChar previously, that TryFindNextPossibleStartingPosition has the",
    "In .NET 6, the interpreter engine had effectively two ways of implementing",
    "In .NET 6, the interpreter engine had effectively two ways of implementing",
    "139",
    "139",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "enum of the strategies used by TryFindNextPossibleStartingPosition to find the next opportunity,",
    "enum of the strategies used by TryFindNextPossibleStartingPosition to find the next opportunity,",
    "dotnet/runtime#60888 then added the first additional strategy. The implementation was already",
    "dotnet/runtime#60888 then added the first additional strategy. The implementation was already",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "377.32 us",
    "377.32 us",
    "1.00",
    "1.00",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "55.44 us",
    "55.44 us",
    "0.15",
    "0.15",
    "dotnet/runtime#61490 then removed Boyer-Moore entirely. This wasn\u2019t done in the previously",
    "dotnet/runtime#61490 then removed Boyer-Moore entirely. This wasn\u2019t done in the previously",
    "140",
    "140",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "check akin to c == ",
    "check akin to c == ",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio",
    "Method  Runtime  Mean  Ratio",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "499.3 us",
    "499.3 us",
    "1.00",
    "1.00",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "177.7 us",
    "177.7 us",
    "0.35",
    "0.35",
    "The previous PR started turning IgnoreCase pattern text into sets, in particular for ASCII, e.g. (?i)a",
    "The previous PR started turning IgnoreCase pattern text into sets, in particular for ASCII, e.g. (?i)a",
    "dotnet/runtime#63477 (and then later improved in dotnet/runtime#66572) proceeded to add another",
    "dotnet/runtime#63477 (and then later improved in dotnet/runtime#66572) proceeded to add another",
    "141",
    "141",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "find it, we can match backwards through as many ",
    "find it, we can match backwards through as many ",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "IsMatch",
    "IsMatch",
    ".NET 6.0",
    ".NET 6.0",
    "4,291.77 us  1.000",
    "4,291.77 us  1.000",
    "IsMatch",
    "IsMatch",
    ".NET 7.0",
    ".NET 7.0",
    "42.40 us  0.010",
    "42.40 us  0.010",
    "Of course, as has been talked about elsewhere, the best optimizations aren\u2019t ones that make",
    "Of course, as has been talked about elsewhere, the best optimizations aren\u2019t ones that make",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "IsMatch",
    "IsMatch",
    ".NET 6.0",
    ".NET 6.0",
    "867,890.56 ns  1.000",
    "867,890.56 ns  1.000",
    "IsMatch",
    "IsMatch",
    ".NET 7.0",
    ".NET 7.0",
    "33.55 ns  0.000",
    "33.55 ns  0.000",
    "dotnet/runtime#67732 is another PR related to improving anchor handling. It\u2019s always fun when a bug",
    "dotnet/runtime#67732 is another PR related to improving anchor handling. It\u2019s always fun when a bug",
    "142",
    "142",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "By this point, the engines are able to use IndexOf(ReadOnlySpan",
    "By this point, the engines are able to use IndexOf(ReadOnlySpan",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio",
    "Method  Runtime  Mean  Ratio",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "444.2 us",
    "444.2 us",
    "1.00",
    "1.00",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "122.6 us",
    "122.6 us",
    "0.28",
    "0.28",
    "Loops and Backtracking",
    "Loops and Backtracking",
    "Loop handling in the compiled and source generated engines has been significantly improved, both",
    "Loop handling in the compiled and source generated engines has been significantly improved, both",
    "With regular greedy loops (e.g. c",
    "With regular greedy loops (e.g. c",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "143",
    "143",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "3,369.5 us",
    "3,369.5 us",
    "1.00",
    "1.00",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "430.2 us",
    "430.2 us",
    "0.13",
    "0.13",
    "Sometimes optimizations are well-intended but slightly miss the mark. dotnet/runtime#63398 fixes",
    "Sometimes optimizations are well-intended but slightly miss the mark. dotnet/runtime#63398 fixes",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Count",
    "Count",
    ".NET 6.0",
    ".NET 6.0",
    "103,962.8 us  1.000",
    "103,962.8 us  1.000",
    "Count",
    "Count",
    ".NET 7.0",
    ".NET 7.0",
    "336.9 us  0.003",
    "336.9 us  0.003",
    "As mentioned elsewhere, the best optimizations are those that make work entirely vanish rather than",
    "As mentioned elsewhere, the best optimizations are those that make work entirely vanish rather than",
    "private bool TryMatchAtCurrentPosition(ReadOnlySpan",
    "private bool TryMatchAtCurrentPosition(ReadOnlySpan",
    "144",
    "144",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "// Match ",
    "// Match ",
    "}",
    "}",
    "(Note that those comments aren\u2019t ones I added for this blog post; the source generator itself is",
    "(Note that those comments aren\u2019t ones I added for this blog post; the source generator itself is",
    "When a regular expression is input, it\u2019s parsed into a tree-based form. The \u201cauto-atomicity\u201d analysis",
    "When a regular expression is input, it\u2019s parsed into a tree-based form. The \u201cauto-atomicity\u201d analysis",
    "[",
    "[",
    "145",
    "145",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "as it will produce a Scan method like this (comment and all):",
    "as it will produce a Scan method like this (comment and all):",
    "protected override void Scan(ReadOnlySpan",
    "protected override void Scan(ReadOnlySpan",
    "Another set of transformations was introduced in dotnet/runtime#59903, specifically around",
    "Another set of transformations was introduced in dotnet/runtime#59903, specifically around",
    "Code generation",
    "Code generation",
    "The .NET 7 regex implementation has no fewer than four engines: the interpreter (what you get if you",
    "The .NET 7 regex implementation has no fewer than four engines: the interpreter (what you get if you",
    "dotnet/runtime#59186 provided the initial implementation of the source generator. This was a direct",
    "dotnet/runtime#59186 provided the initial implementation of the source generator. This was a direct",
    "146",
    "146",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "series of instructions, would just emit the IL for processing each. It had some opportunity for being",
    "series of instructions, would just emit the IL for processing each. It had some opportunity for being",
    "One of the great things about the source generator emitting idiomatic C# is it makes it easy to iterate.",
    "One of the great things about the source generator emitting idiomatic C# is it makes it easy to iterate.",
    "protected override void Scan(ReadOnlySpan",
    "protected override void Scan(ReadOnlySpan",
    "147",
    "147",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "The compiler and source generator were also updated to take advantage of newer features.",
    "The compiler and source generator were also updated to take advantage of newer features.",
    "One last and interesting code generation aspect is in optimizations around character class matching.",
    "One last and interesting code generation aspect is in optimizations around character class matching.",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Match",
    "Match",
    ".NET 6.0",
    ".NET 6.0",
    "1,934,393.69 ns  1.000",
    "1,934,393.69 ns  1.000",
    "Match",
    "Match",
    ".NET 7.0",
    ".NET 7.0",
    "91.80 ns  0.000",
    "91.80 ns  0.000",
    "Or dotnet/runtime#68924, which taught the source generator how to use all of the new char ASCII",
    "Or dotnet/runtime#68924, which taught the source generator how to use all of the new char ASCII",
    "[",
    "[",
    "now produces this in the core matching logic emitted by the source generator:",
    "now produces this in the core matching logic emitted by the source generator:",
    "if ((uint)slice.Length ",
    "if ((uint)slice.Length ",
    "148",
    "148",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "!",
    "!",
    "Other changes impacting character class code generation included dotnet/runtime#72328, which",
    "Other changes impacting character class code generation included dotnet/runtime#72328, which",
    "Finally, with all of these improvements to Regex, a multitude of PRs fixed up regexes being used",
    "Finally, with all of these improvements to Regex, a multitude of PRs fixed up regexes being used",
    "149",
    "149",
    "CHAPTER 11 | Regex",
    "CHAPTER 11 | Regex",
    "CHAPTER  12",
    "CHAPTER  12",
    "Collections",
    "Collections",
    "System.Collections hasn\u2019t seen as much investment in .NET 7 as it has in previous releases, though",
    "System.Collections hasn\u2019t seen as much investment in .NET 7 as it has in previous releases, though",
    "private Dictionary",
    "private Dictionary",
    "[",
    "[",
    "}",
    "}",
    "shows a measurable improvement in throughput between .NET 6 and .NET 7:",
    "shows a measurable improvement in throughput between .NET 6 and .NET 7:",
    "Method  Runtime  Mean  Ratio  Code Size",
    "Method  Runtime  Mean  Ratio  Code Size",
    "Sum",
    "Sum",
    "Sum",
    "Sum",
    ".NET 6.0",
    ".NET 6.0",
    "51.18 us",
    "51.18 us",
    "1.00",
    "1.00",
    ".NET 7.0",
    ".NET 7.0",
    "43.44 us",
    "43.44 us",
    "0.85",
    "0.85",
    "431 B",
    "431 B",
    "413 B",
    "413 B",
    "Beyond that, there have been explicit improvements elsewhere in collections. ImmutableArray",
    "Beyond that, there have been explicit improvements elsewhere in collections. ImmutableArray",
    "150",
    "150",
    "CHAPTER 12 | Collections",
    "CHAPTER 12 | Collections",
    "allocation, while also speeding up the sort itself by removing several layers of indirection from every",
    "allocation, while also speeding up the sort itself by removing several layers of indirection from every",
    "private ImmutableArray",
    "private ImmutableArray",
    "[",
    "[",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio",
    "Method  Runtime  Mean  Ratio",
    "Sort",
    "Sort",
    "Sort",
    "Sort",
    ".NET 6.0",
    ".NET 6.0",
    "86.28 us",
    "86.28 us",
    "1.00",
    "1.00",
    ".NET 7.0",
    ".NET 7.0",
    "67.17 us",
    "67.17 us",
    "0.78",
    "0.78",
    "dotnet/runtime#61196 from ",
    "dotnet/runtime#61196 from ",
    "SortedSet",
    "SortedSet",
    "[",
    "[",
    "private static SortedSet",
    "private static SortedSet",
    "[",
    "[",
    "151",
    "151",
    "CHAPTER 12 | Collections",
    "CHAPTER 12 | Collections",
    "}",
    "}",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "SortedSetCopy",
    "SortedSetCopy",
    ".NET 6.0",
    ".NET 6.0",
    "2.397 us",
    "2.397 us",
    "1.00",
    "1.00",
    "SortedSetCopy",
    "SortedSetCopy",
    ".NET 7.0",
    ".NET 7.0",
    "2.090 us",
    "2.090 us",
    "0.87",
    "0.87",
    "One last PR to look at in collections: dotnet/runtime#67923. ConditionalWeakTable",
    "One last PR to look at in collections: dotnet/runtime#67923. ConditionalWeakTable",
    "152",
    "152",
    "CHAPTER 12 | Collections",
    "CHAPTER 12 | Collections",
    "CHAPTER  13",
    "CHAPTER  13",
    "LINQ",
    "LINQ",
    "Let\u2019s move on to Language-Integrated Query (LINQ). LINQ is a productivity feature that practically",
    "Let\u2019s move on to Language-Integrated Query (LINQ). LINQ is a productivity feature that practically",
    "dotnet/runtime#64470 is the result of analyzing various real-world code bases for use of",
    "dotnet/runtime#64470 is the result of analyzing various real-world code bases for use of",
    "[",
    "[",
    "private IEnumerable",
    "private IEnumerable",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "153",
    "153",
    "CHAPTER 13 | LINQ",
    "CHAPTER 13 | LINQ",
    "Method  Runtime  Length",
    "Method  Runtime  Length",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Min",
    "Min",
    "Min",
    "Min",
    "Max",
    "Max",
    "Max",
    "Max",
    "Min",
    "Min",
    "Min",
    "Min",
    "Max",
    "Max",
    "Max",
    "Max",
    ".NET 6.0",
    ".NET 6.0",
    ".NET 7.0",
    ".NET 7.0",
    ".NET 6.0",
    ".NET 6.0",
    ".NET 7.0",
    ".NET 7.0",
    "4",
    "4",
    "4",
    "4",
    "4",
    "4",
    "4",
    "4",
    "26.167 ns",
    "26.167 ns",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    "4.788 ns",
    "4.788 ns",
    "0.18",
    "0.18",
    "25.236 ns",
    "25.236 ns",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    "4.234 ns",
    "4.234 ns",
    "0.17",
    "0.17",
    ".NET 6.0",
    ".NET 6.0",
    "1024",
    "1024",
    "3,987.102 ns",
    "3,987.102 ns",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    ".NET 7.0",
    ".NET 7.0",
    "1024",
    "1024",
    "101.830 ns",
    "101.830 ns",
    "0.03",
    "0.03",
    ".NET 6.0",
    ".NET 6.0",
    "1024",
    "1024",
    "3,798.069 ns",
    "3,798.069 ns",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    ".NET 7.0",
    ".NET 7.0",
    "1024",
    "1024",
    "100.279 ns",
    "100.279 ns",
    "0.03",
    "0.03",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "One of the more interesting aspects of the PR, however, is one line that\u2019s meant to help with the non-",
    "One of the more interesting aspects of the PR, however, is one line that\u2019s meant to help with the non-",
    "if (source is int",
    "if (source is int",
    "However, if you look at the PR, you\u2019ll see the if condition is actually:",
    "However, if you look at the PR, you\u2019ll see the if condition is actually:",
    "if (source.GetType() == typeof(int",
    "if (source.GetType() == typeof(int",
    "How come? Well at this point in the code flow, we know that source isn\u2019t null, so we don\u2019t need the",
    "How come? Well at this point in the code flow, we know that source isn\u2019t null, so we don\u2019t need the",
    "154",
    "154",
    "CHAPTER 13 | LINQ",
    "CHAPTER 13 | LINQ",
    "int",
    "int",
    "public IEnumerable",
    "public IEnumerable",
    "[",
    "[",
    "[",
    "[",
    "This results in:",
    "This results in:",
    "; Program.M1(System.Object)",
    "; Program.M1(System.Object)",
    "; Program.M2(System.Object)",
    "; Program.M2(System.Object)",
    "Note the former involves a method call to the JIT\u2019s CastHelpers.IsInstanceOfAny helper method,",
    "Note the former involves a method call to the JIT\u2019s CastHelpers.IsInstanceOfAny helper method,",
    "private IEnumerable",
    "private IEnumerable",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio  Code Size",
    "Mean  Ratio  Code Size",
    "WithIs",
    "WithIs",
    "1.9246 ns  1.000",
    "1.9246 ns  1.000",
    "215 B",
    "215 B",
    "WithTypeCheck  0.0013 ns  0.001",
    "WithTypeCheck  0.0013 ns  0.001",
    "24 B",
    "24 B",
    "Of course, these two operations aren\u2019t semantically equivalent, so if this was for something that",
    "Of course, these two operations aren\u2019t semantically equivalent, so if this was for something that",
    "155",
    "155",
    "CHAPTER 13 | LINQ",
    "CHAPTER 13 | LINQ",
    "of the int",
    "of the int",
    "This improvement was built upon further in dotnet/runtime#64624, which expands the input types",
    "This improvement was built upon further in dotnet/runtime#64624, which expands the input types",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "Expands the previous Min",
    "Expands the previous Min",
    "Uses direct span access for Average",
    "Uses direct span access for Average",
    "Similarly uses direct span access for Min",
    "Similarly uses direct span access for Min",
    "Vectorizes Average",
    "Vectorizes Average",
    "The effect of that is evident in microbenchmarks, e.g.",
    "The effect of that is evident in microbenchmarks, e.g.",
    "private static float",
    "private static float",
    "private IEnumerable",
    "private IEnumerable",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Sum",
    "Sum",
    "Sum",
    "Sum",
    ".NET 6.0",
    ".NET 6.0",
    "39.067 us",
    "39.067 us",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    ".NET 7.0",
    ".NET 7.0",
    "14.349 us",
    "14.349 us",
    "0.37",
    "0.37",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "Average",
    "Average",
    ".NET 6.0",
    ".NET 6.0",
    "41.232 us",
    "41.232 us",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    "1.00",
    "1.00",
    "156",
    "156",
    "CHAPTER 13 | LINQ",
    "CHAPTER 13 | LINQ",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Average",
    "Average",
    ".NET 7.0",
    ".NET 7.0",
    "14.378 us",
    "14.378 us",
    "0.35",
    "0.35",
    "0.00",
    "0.00",
    "Min",
    "Min",
    "Min",
    "Min",
    "Max",
    "Max",
    "Max",
    "Max",
    ".NET 6.0",
    ".NET 6.0",
    "45.522 us",
    "45.522 us",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    ".NET 7.0",
    ".NET 7.0",
    "9.668 us",
    "9.668 us",
    "0.21",
    "0.21",
    ".NET 6.0",
    ".NET 6.0",
    "41.178 us",
    "41.178 us",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    ".NET 7.0",
    ".NET 7.0",
    "9.210 us",
    "9.210 us",
    "0.22",
    "0.22",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "The previous LINQ PRs were examples from making existing operations faster. But sometimes",
    "The previous LINQ PRs were examples from making existing operations faster. But sometimes",
    "[",
    "[",
    "private int",
    "private int",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "157",
    "157",
    "CHAPTER 13 | LINQ",
    "CHAPTER 13 | LINQ",
    "Method  Length  Mean  Ratio  Allocated  Alloc Ratio",
    "Method  Length  Mean  Ratio  Allocated  Alloc Ratio",
    "OrderBy  1024",
    "OrderBy  1024",
    "68.74 us",
    "68.74 us",
    "1.00",
    "1.00",
    "12.3 KB",
    "12.3 KB",
    "Order",
    "Order",
    "1024",
    "1024",
    "66.24 us",
    "66.24 us",
    "0.96",
    "0.96",
    "8.28 KB",
    "8.28 KB",
    "1.00",
    "1.00",
    "0.67",
    "0.67",
    "158",
    "158",
    "CHAPTER 13 | LINQ",
    "CHAPTER 13 | LINQ",
    "CHAPTER  14",
    "CHAPTER  14",
    "File I/O",
    "File I/O",
    ".NET 6 saw some huge file I/O improvements, in particular a complete rewrite of FileStream. While",
    ".NET 6 saw some huge file I/O improvements, in particular a complete rewrite of FileStream. While",
    "One form of performance improvement that also masquerades as a reliability improvement is",
    "One form of performance improvement that also masquerades as a reliability improvement is",
    "In some cases, it comes from adding cancelable overloads where things weren\u2019t previously cancelable",
    "In some cases, it comes from adding cancelable overloads where things weren\u2019t previously cancelable",
    "From my perspective, though, a more interesting form of this is when an existing overload is",
    "From my perspective, though, a more interesting form of this is when an existing overload is",
    "159",
    "159",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "Unix, named pipes, contrary to their naming, are actually implemented on top of Unix domain sockets.",
    "Unix, named pipes, contrary to their naming, are actually implemented on top of Unix domain sockets.",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    ".NET Framework 4.8: No cancellation support. The pipe Stream-derived types didn\u2019t even",
    ".NET Framework 4.8: No cancellation support. The pipe Stream-derived types didn\u2019t even",
    ".NET Core 1.0: On Windows, with a named pipe opened for asynchronous I/O, cancellation was",
    ".NET Core 1.0: On Windows, with a named pipe opened for asynchronous I/O, cancellation was",
    ".NET Core 2.1: On Unix, the implementation was improved to avoid the polling loop, but it still",
    ".NET Core 2.1: On Unix, the implementation was improved to avoid the polling loop, but it still",
    ".NET Core 3.0: On Unix, Socket got truly cancelable ReceiveAsync and SendAsync methods,",
    ".NET Core 3.0: On Unix, Socket got truly cancelable ReceiveAsync and SendAsync methods,",
    ".NET 5: On Unix, SafeSocketHandle was exposed and it became possible to create a Socket for",
    ".NET 5: On Unix, SafeSocketHandle was exposed and it became possible to create a Socket for",
    "So by .NET 5, the problem was addressed on Unix, but still an issue on Windows. Until now. In .NET 7,",
    "So by .NET 5, the problem was addressed on Unix, but still an issue on Windows. Until now. In .NET 7,",
    "160",
    "160",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "So, there\u2019s a small spin loop employed, where if cancellation is requested between the time",
    "So, there\u2019s a small spin loop employed, where if cancellation is requested between the time",
    "private Stream ",
    "private Stream ",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "161",
    "161",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "ValueTask",
    "ValueTask",
    "Method",
    "Method",
    "Runtime  Cancelable  Named  Mean  Ratio  Allocated  Alloc Ratio",
    "Runtime  Cancelable  Named  Mean  Ratio  Allocated  Alloc Ratio",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 6.0",
    ".NET 6.0",
    "False",
    "False",
    "False",
    "False",
    "22.08 us",
    "22.08 us",
    "1.00",
    "1.00",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 7.0",
    ".NET 7.0",
    "False",
    "False",
    "False",
    "False",
    "12.61 us",
    "12.61 us",
    "0.76",
    "0.76",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 6.0",
    ".NET 6.0",
    "False",
    "False",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 7.0",
    ".NET 7.0",
    "False",
    "False",
    "True",
    "True",
    "True",
    "True",
    "38.45 us",
    "38.45 us",
    "1.00",
    "1.00",
    "32.16 us",
    "32.16 us",
    "0.84",
    "0.84",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 6.0",
    ".NET 6.0",
    "True",
    "True",
    "False",
    "False",
    "27.11 us",
    "27.11 us",
    "1.00",
    "1.00",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 7.0",
    ".NET 7.0",
    "True",
    "True",
    "False",
    "False",
    "13.29 us",
    "13.29 us",
    "0.52",
    "0.52",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 6.0",
    ".NET 6.0",
    "True",
    "True",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 7.0",
    ".NET 7.0",
    "True",
    "True",
    "True",
    "True",
    "True",
    "True",
    "38.57 us",
    "38.57 us",
    "1.00",
    "1.00",
    "33.07 us",
    "33.07 us",
    "0.86",
    "0.86",
    "400 B",
    "400 B",
    "192 B",
    "192 B",
    "400 B",
    "400 B",
    "220 B",
    "220 B",
    "400 B",
    "400 B",
    "193 B",
    "193 B",
    "400 B",
    "400 B",
    "214 B",
    "214 B",
    "1.00",
    "1.00",
    "0.48",
    "0.48",
    "1.00",
    "1.00",
    "0.55",
    "0.55",
    "1.00",
    "1.00",
    "0.48",
    "0.48",
    "1.00",
    "1.00",
    "0.54",
    "0.54",
    "The rest of the performance-focused changes around I/O in .NET 7 were primarily focused on one of",
    "The rest of the performance-focused changes around I/O in .NET 7 were primarily focused on one of",
    "Several PRs went into reducing syscalls on Unix as part of copying files, e.g. File.Copy and",
    "Several PRs went into reducing syscalls on Unix as part of copying files, e.g. File.Copy and",
    "162",
    "162",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "some issues the function had in previous releases). Unlike a typical read/write loop that reads the data",
    "some issues the function had in previous releases). Unlike a typical read/write loop that reads the data",
    "Another example of avoiding syscalls comes for the File.WriteXx and File.AppendXx methods when",
    "Another example of avoiding syscalls comes for the File.WriteXx and File.AppendXx methods when",
    "Directory handling has seen reduced syscalls across the directory lifecycle, especially on Unix.",
    "Directory handling has seen reduced syscalls across the directory lifecycle, especially on Unix.",
    "dotnet/runtime#63675 then improves the performance of moving directories, on both Unix and",
    "dotnet/runtime#63675 then improves the performance of moving directories, on both Unix and",
    "private string ",
    "private string ",
    "[",
    "[",
    "163",
    "163",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "File.Delete(",
    "File.Delete(",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Move",
    "Move",
    ".NET 6.0",
    ".NET 6.0",
    "31.70 us",
    "31.70 us",
    "1.00",
    "1.00",
    "256 B",
    "256 B",
    "Move",
    "Move",
    ".NET 7.0",
    ".NET 7.0",
    "26.31 us",
    "26.31 us",
    "0.83",
    "0.83",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "And then also on Unix, dotnet/runtime#59520 from ",
    "And then also on Unix, dotnet/runtime#59520 from ",
    "Syscalls were also reduced as part of support for memory-mapped files. dotnet/runtime#63754 takes",
    "Syscalls were also reduced as part of support for memory-mapped files. dotnet/runtime#63754 takes",
    "Finally, there\u2019s dotnet/runtime#63794, which recognizes that a MemoryMappedViewAccessor or",
    "Finally, there\u2019s dotnet/runtime#63794, which recognizes that a MemoryMappedViewAccessor or",
    "164",
    "164",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "private string ",
    "private string ",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "MMF",
    "MMF",
    ".NET 6.0",
    ".NET 6.0",
    "315.7 us",
    "315.7 us",
    "1.00",
    "1.00",
    "MMF",
    "MMF",
    ".NET 7.0",
    ".NET 7.0",
    "227.1 us",
    "227.1 us",
    "0.68",
    "0.68",
    "488 B",
    "488 B",
    "336 B",
    "336 B",
    "1.00",
    "1.00",
    "0.69",
    "0.69",
    "Beyond system calls, there have also been a plethora of improvements around reducing allocation.",
    "Beyond system calls, there have also been a plethora of improvements around reducing allocation.",
    "private string ",
    "private string ",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "WriteAllText",
    "WriteAllText",
    ".NET 6.0",
    ".NET 6.0",
    "488.5 us",
    "488.5 us",
    "1.00",
    "1.00",
    "9944 B",
    "9944 B",
    "WriteAllText",
    "WriteAllText",
    ".NET 7.0",
    ".NET 7.0",
    "482.9 us",
    "482.9 us",
    "0.99",
    "0.99",
    "392 B",
    "392 B",
    "1.00",
    "1.00",
    "0.04",
    "0.04",
    "165",
    "165",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "dotnet/runtime#61519 similarly updates File.ReadAllBytes{Async} to use SafeFileHandle (and",
    "dotnet/runtime#61519 similarly updates File.ReadAllBytes{Async} to use SafeFileHandle (and",
    "Another such change is dotnet/runtime#68662, which improved Path.Join\u2019s handling of null or",
    "Another such change is dotnet/runtime#68662, which improved Path.Join\u2019s handling of null or",
    "Beyond that, there are a multitude of allocation-focused PRs, such as dotnet/runtime#69335 from",
    "Beyond that, there are a multitude of allocation-focused PRs, such as dotnet/runtime#69335 from",
    "But my personal favorite improvement in this area come from dotnet/runtime#69272, which adds a",
    "But my personal favorite improvement in this area come from dotnet/runtime#69272, which adds a",
    "public void ReadExactly(byte",
    "public void ReadExactly(byte",
    "public ValueTask ReadExactlyAsync(byte",
    "public ValueTask ReadExactlyAsync(byte",
    "public int ReadAtLeast(Span",
    "public int ReadAtLeast(Span",
    "In fairness, these are more about usability than they are about performance, but in this case there\u2019s a",
    "In fairness, these are more about usability than they are about performance, but in this case there\u2019s a",
    "166",
    "166",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "that negatively impact performance, such as by using a Stream.ReadAsync overload that needs to",
    "that negatively impact performance, such as by using a Stream.ReadAsync overload that needs to",
    "167",
    "167",
    "CHAPTER 14 | File I/O",
    "CHAPTER 14 | File I/O",
    "CHAPTER  15",
    "CHAPTER  15",
    "Compression",
    "Compression",
    ".NET Core 2.1 added support for the Brotli compression algorithm, surfacing it in two ways:",
    ".NET Core 2.1 added support for the Brotli compression algorithm, surfacing it in two ways:",
    "As with many compression algorithms, Brotli provides a knob that allows for a quintessential tradeoff",
    "As with many compression algorithms, Brotli provides a knob that allows for a quintessential tradeoff",
    "For better or worse (and I\u2019m about to argue \u201cmuch worse\u201d), the native C implementation itself defines",
    "For better or worse (and I\u2019m about to argue \u201cmuch worse\u201d), the native C implementation itself defines",
    "Is that so bad? Maybe compression quality is the most important thing? For example, reducing the",
    "Is that so bad? Maybe compression quality is the most important thing? For example, reducing the",
    "The problem is just how much this extra effort costs. Compression speed and ratio are highly",
    "The problem is just how much this extra effort costs. Compression speed and ratio are highly",
    "168",
    "168",
    "CHAPTER 15 | Compression",
    "CHAPTER 15 | Compression",
    "uses BrotliEncoder to compress the The Complete Works of William Shakespeare from Project",
    "uses BrotliEncoder to compress the The Complete Works of William Shakespeare from Project",
    "using System.Buffers;",
    "using System.Buffers;",
    "using var hc = new HttpClient();",
    "using var hc = new HttpClient();",
    "var compressed = new MemoryStream();",
    "var compressed = new MemoryStream();",
    "for (int level = 0; level ",
    "for (int level = 0; level ",
    "Trials},{compressed.Position}",
    "Trials},{compressed.Position}",
    "isFinalBlock)",
    "isFinalBlock)",
    "int bytesWritten, isFinalBlock);",
    "int bytesWritten, isFinalBlock);",
    "169",
    "169",
    "CHAPTER 15 | Compression",
    "CHAPTER 15 | Compression",
    "}",
    "}",
    "The code is measuring how long it takes to compress the input data at each of the levels (doing a",
    "The code is measuring how long it takes to compress the input data at each of the levels (doing a",
    "Level  Size (bytes)",
    "Level  Size (bytes)",
    "0",
    "0",
    "1",
    "1",
    "2",
    "2",
    "3",
    "3",
    "4",
    "4",
    "5",
    "5",
    "6",
    "6",
    "7",
    "7",
    "8",
    "8",
    "9",
    "9",
    "10",
    "10",
    "11",
    "11",
    "2,512,855.00",
    "2,512,855.00",
    "2,315,466.00",
    "2,315,466.00",
    "2,224,638.00",
    "2,224,638.00",
    "2,218,328.00",
    "2,218,328.00",
    "2,027,153.00",
    "2,027,153.00",
    "1,964,810.00",
    "1,964,810.00",
    "1,923,456.00",
    "1,923,456.00",
    "1,889,927.00",
    "1,889,927.00",
    "1,863,988.00",
    "1,863,988.00",
    "1,846,685.00",
    "1,846,685.00",
    "1,741,561.00",
    "1,741,561.00",
    "1,702,214.00",
    "1,702,214.00",
    "That\u2019s a fairly liner progression from least to most compression. That\u2019s not the problem. This is the",
    "That\u2019s a fairly liner progression from least to most compression. That\u2019s not the problem. This is the",
    "170",
    "170",
    "CHAPTER 15 | Compression",
    "CHAPTER 15 | Compression",
    "Level",
    "Level",
    "Time",
    "Time",
    "0",
    "0",
    "1",
    "1",
    "2",
    "2",
    "3",
    "3",
    "4",
    "4",
    "5",
    "5",
    "6",
    "6",
    "7",
    "7",
    "8",
    "8",
    "9",
    "9",
    "24.11",
    "24.11",
    "36.67",
    "36.67",
    "64.13",
    "64.13",
    "73.72",
    "73.72",
    "146.41",
    "146.41",
    "257.12",
    "257.12",
    "328.54",
    "328.54",
    "492.81",
    "492.81",
    "702.38",
    "702.38",
    "892.08",
    "892.08",
    "10",
    "10",
    "11",
    "11",
    "4,830.32",
    "4,830.32",
    "10,634.88",
    "10,634.88",
    "This chart shows an almost exponential increase in processing time as we near the upper end of the",
    "This chart shows an almost exponential increase in processing time as we near the upper end of the",
    "dotnet/runtime#72266 fixes that. A very small change, it simply makes CompressMode.Compress and",
    "dotnet/runtime#72266 fixes that. A very small change, it simply makes CompressMode.Compress and",
    "171",
    "171",
    "CHAPTER 15 | Compression",
    "CHAPTER 15 | Compression",
    "private byte",
    "private byte",
    "[",
    "[",
    "Method  Runtime",
    "Method  Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Compress",
    "Compress",
    ".NET 6.0",
    ".NET 6.0",
    "9,807.0 ms",
    "9,807.0 ms",
    "1.00",
    "1.00",
    "Compress",
    "Compress",
    ".NET 7.0",
    ".NET 7.0",
    "133.1 ms",
    "133.1 ms",
    "0.01",
    "0.01",
    "Other improvements have gone into compression, such as dotnet/runtime#69439 which updates the",
    "Other improvements have gone into compression, such as dotnet/runtime#69439 which updates the",
    "172",
    "172",
    "CHAPTER 15 | Compression",
    "CHAPTER 15 | Compression",
    "CHAPTER  16",
    "CHAPTER  16",
    "Networking",
    "Networking",
    "Networking is the life-blood of almost every service, with performance being critical to success. In",
    "Networking is the life-blood of almost every service, with performance being critical to success. In",
    "That said, there were some interesting performance improvements in sockets itself for .NET 7. One of",
    "That said, there were some interesting performance improvements in sockets itself for .NET 7. One of",
    "SocketAsyncEventArgs on Windows is implemented to use winsock and overlapped I/O. When you",
    "SocketAsyncEventArgs on Windows is implemented to use winsock and overlapped I/O. When you",
    "173",
    "173",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "a potential race condition, where our code that\u2019s still setting up the asynchronous operation is racing",
    "a potential race condition, where our code that\u2019s still setting up the asynchronous operation is racing",
    "A more-easily quantifiable change around sockets is dotnet/runtime#71090, which improves the",
    "A more-easily quantifiable change around sockets is dotnet/runtime#71090, which improves the",
    "private SocketAddress ",
    "private SocketAddress ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "Equals",
    "Equals",
    ".NET 6.0",
    ".NET 6.0",
    "57.659 ns",
    "57.659 ns",
    "1.00",
    "1.00",
    "Equals",
    "Equals",
    ".NET 7.0",
    ".NET 7.0",
    "4.435 ns",
    "4.435 ns",
    "0.08",
    "0.08",
    "174",
    "174",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "Let\u2019s move up to some more interesting changes in the layers above Sockets, starting with",
    "Let\u2019s move up to some more interesting changes in the layers above Sockets, starting with",
    "One of the more impactful changes to SslStream on .NET 7 is in support for TLS resumption on Linux.",
    "One of the more impactful changes to SslStream on .NET 7 is in support for TLS resumption on Linux.",
    "private NetworkStream ",
    "private NetworkStream ",
    "[",
    "[",
    "ProtocolType.Tcp);",
    "ProtocolType.Tcp);",
    "}",
    "}",
    "[",
    "[",
    "[",
    "[",
    "175",
    "175",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "true; });",
    "true; });",
    "checkCertificateRevocation: false),",
    "checkCertificateRevocation: false),",
    "}",
    "}",
    "private static X509Certificate2 GetCertificate() =>",
    "private static X509Certificate2 GetCertificate() =>",
    "Convert.FromBase64String(",
    "Convert.FromBase64String(",
    "176",
    "176",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "0YTk5jjYUMNRbvBP1VPq9ASIh8pJnt/Kq1nqfj7EPatXJJUZAH35E6bSbLBnP0+5+xim1l4HsB8066c4B3aTUXnLepP",
    "0YTk5jjYUMNRbvBP1VPq9ASIh8pJnt/Kq1nqfj7EPatXJJUZAH35E6bSbLBnP0+5+xim1l4HsB8066c4B3aTUXnLepP",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Handshake",
    "Handshake",
    ".NET 6.0",
    ".NET 6.0",
    "4.647 ms",
    "4.647 ms",
    "1.00",
    "1.00",
    "19.27 KB",
    "19.27 KB",
    "Handshake",
    "Handshake",
    ".NET 7.0",
    ".NET 7.0",
    "2.314 ms",
    "2.314 ms",
    "0.50",
    "0.50",
    "9.56 KB",
    "9.56 KB",
    "1.00",
    "1.00",
    "0.50",
    "0.50",
    "Another significant improvement for SslStream in .NET 7 is support for OCSP stapling. When a client",
    "Another significant improvement for SslStream in .NET 7 is support for OCSP stapling. When a client",
    "177",
    "177",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "the OCSP responder, the server itself contacts the OCSP responder and gets a signed ticket from the",
    "the OCSP responder, the server itself contacts the OCSP responder and gets a signed ticket from the",
    "The aforementioned changes are primarily about the performance of opening a connection.",
    "The aforementioned changes are primarily about the performance of opening a connection.",
    "private List",
    "private List",
    "And then some code in the same implementation comes along and wants to read the contents of",
    "And then some code in the same implementation comes along and wants to read the contents of",
    "if (Items.Count > 0) { ... }",
    "if (Items.Count > 0) { ... }",
    "but the very act of accessing Items just to check its count forces the collection into existence (with a 0",
    "but the very act of accessing Items just to check its count forces the collection into existence (with a 0",
    "if (",
    "if (",
    "It can save that unnecessary collection allocation. The approach is made even simpler with C# pattern",
    "It can save that unnecessary collection allocation. The approach is made even simpler with C# pattern",
    "if (",
    "if (",
    "This is one of those things that\u2019s incredibly obvious once you \u201csee\u201d it and realize what\u2019s happening,",
    "This is one of those things that\u2019s incredibly obvious once you \u201csee\u201d it and realize what\u2019s happening,",
    "dotnet/runtime#69098 is another good example of how profiling can lead to insights about",
    "dotnet/runtime#69098 is another good example of how profiling can lead to insights about",
    "178",
    "178",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "dutifully allocating a byte",
    "dutifully allocating a byte",
    "Everything discussed thus far was about establishing connections. What about the performance of",
    "Everything discussed thus far was about establishing connections. What about the performance of",
    "When async/await were first introduced, Task and Task",
    "When async/await were first introduced, Task and Task",
    "179",
    "179",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "them. ValueTask",
    "them. ValueTask",
    "public async ValueTask",
    "public async ValueTask",
    "can be changed to be:",
    "can be changed to be:",
    "[",
    "[",
    "which will cause the C# compiler to emit the implementation of this method using",
    "which will cause the C# compiler to emit the implementation of this method using",
    "180",
    "180",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "tradeoffs involved in its usage, and while it can make microbenchmarks look really good, it can also",
    "tradeoffs involved in its usage, and while it can make microbenchmarks look really good, it can also",
    "Such is the case with SslStream. With dotnet/runtime#69418, two core and hot async methods on",
    "Such is the case with SslStream. With dotnet/runtime#69418, two core and hot async methods on",
    "private SslStream ",
    "private SslStream ",
    "[",
    "[",
    "ProtocolType.Tcp);",
    "ProtocolType.Tcp);",
    "leaveInnerStreamOpen: true, delegate { return true; });",
    "leaveInnerStreamOpen: true, delegate { return true; });",
    "checkCertificateRevocation: false),",
    "checkCertificateRevocation: false),",
    "[",
    "[",
    "[",
    "[",
    "181",
    "181",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "await ",
    "await ",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Code Size  Allocated  Alloc Ratio",
    "Mean  Ratio  Code Size  Allocated  Alloc Ratio",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 6.0",
    ".NET 6.0",
    "68.34 ms",
    "68.34 ms",
    "1.00",
    "1.00",
    "510 B",
    "510 B",
    "336404 B",
    "336404 B",
    "ReadWriteAsync",
    "ReadWriteAsync",
    ".NET 7.0",
    ".NET 7.0",
    "69.60 ms",
    "69.60 ms",
    "1.02",
    "1.02",
    "514 B",
    "514 B",
    "995 B",
    "995 B",
    "1.000",
    "1.000",
    "0.003",
    "0.003",
    "One final change related to reading and writing performance on an SslStream. I find this one",
    "One final change related to reading and writing performance on an SslStream. I find this one",
    "public static void Work(Stream s) =>",
    "public static void Work(Stream s) =>",
    "public static Task WorkAsync(Stream S) =>",
    "public static Task WorkAsync(Stream S) =>",
    "internal static async Task A(Stream s, bool useAsync)",
    "internal static async Task A(Stream s, bool useAsync)",
    "private static async Task B(Stream s, bool useAsync)",
    "private static async Task B(Stream s, bool useAsync)",
    "This way most of the logic and code is shared, and when useAsync is false, everything completes",
    "This way most of the logic and code is shared, and when useAsync is false, everything completes",
    "interface IReader",
    "interface IReader",
    "182",
    "182",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "We can then declare two implementations of this interface:",
    "We can then declare two implementations of this interface:",
    "struct SyncReader : IReader",
    "struct SyncReader : IReader",
    "struct AsyncReader : IReader",
    "struct AsyncReader : IReader",
    "Then we can redeclare our earlier example as:",
    "Then we can redeclare our earlier example as:",
    "public static void Work(Stream s) =>",
    "public static void Work(Stream s) =>",
    "public static Task WorkAsync(Stream S) =>",
    "public static Task WorkAsync(Stream S) =>",
    "internal static async Task A",
    "internal static async Task A",
    "private static async Task B",
    "private static async Task B",
    "Note that the generic constraint on the TReader parameter here allows the implementation to invoke",
    "Note that the generic constraint on the TReader parameter here allows the implementation to invoke",
    "This latter generic approach is how SslStream has historically handled the unification of its sync and",
    "This latter generic approach is how SslStream has historically handled the unification of its sync and",
    "interface IReader",
    "interface IReader",
    "our types as (note the static addition):",
    "our types as (note the static addition):",
    "struct SyncReader : IReader",
    "struct SyncReader : IReader",
    "struct AsyncReader : IReader",
    "struct AsyncReader : IReader",
    "183",
    "183",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "{",
    "{",
    "and our consuming methods as (note the removal of the parameter and the switch to calling static",
    "and our consuming methods as (note the removal of the parameter and the switch to calling static",
    "public static void Work(Stream s) =>",
    "public static void Work(Stream s) =>",
    "public static Task WorkAsync(Stream S) =>",
    "public static Task WorkAsync(Stream S) =>",
    "internal static async Task A",
    "internal static async Task A",
    "private static async Task B",
    "private static async Task B",
    "Not only is this cleaner, but from a performance perspective we no longer need to pass around the",
    "Not only is this cleaner, but from a performance perspective we no longer need to pass around the",
    "184",
    "184",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "private static readonly string s",
    "private static readonly string s",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio",
    "Runtime  Mean  Ratio",
    "LastIndexOfAny",
    "LastIndexOfAny",
    ".NET 6.0",
    ".NET 6.0",
    "9.977 us",
    "9.977 us",
    "1.00",
    "1.00",
    "LastIndexOfAny",
    "LastIndexOfAny",
    ".NET 7.0",
    ".NET 7.0",
    "1.172 us",
    "1.172 us",
    "0.12",
    "0.12",
    "Let\u2019s move up the stack to HTTP. Most of the folks focusing on networking in .NET 7 were focused on",
    "Let\u2019s move up the stack to HTTP. Most of the folks focusing on networking in .NET 7 were focused on",
    "One aspect of HttpClient that cuts across all versions of HTTP is support for handling and",
    "One aspect of HttpClient that cuts across all versions of HTTP is support for handling and",
    "Another header-related size reduction comes in dotnet/runtime#64105. The internal representation of",
    "Another header-related size reduction comes in dotnet/runtime#64105. The internal representation of",
    "185",
    "185",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "need to look up information from that field, we cut the number of fields in half. And while this",
    "need to look up information from that field, we cut the number of fields in half. And while this",
    "private readonly string",
    "private readonly string",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "GetHeaders",
    "GetHeaders",
    ".NET 6.0",
    ".NET 6.0",
    "334.4 ns",
    "334.4 ns",
    "1.00",
    "1.00",
    "GetHeaders",
    "GetHeaders",
    ".NET 7.0",
    ".NET 7.0",
    "213.9 ns",
    "213.9 ns",
    "0.64",
    "0.64",
    "664 B",
    "664 B",
    "360 B",
    "360 B",
    "1.00",
    "1.00",
    "0.54",
    "0.54",
    "Similarly focused on allocation, dotnet/runtime#63057 removes two fields from the",
    "Similarly focused on allocation, dotnet/runtime#63057 removes two fields from the",
    "A more focused allocation reduction comes in dotnet/runtime#63641. The shared internal utility",
    "A more focused allocation reduction comes in dotnet/runtime#63641. The shared internal utility",
    "Other small allocation improvements were also made outside of headers. For example, when new",
    "Other small allocation improvements were also made outside of headers. For example, when new",
    "186",
    "186",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "Folks using HTTP often need to go through a proxy server, and in .NET the ability to go through an",
    "Folks using HTTP often need to go through a proxy server, and in .NET the ability to go through an",
    "private WebProxy ",
    "private WebProxy ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "IsBypassed",
    "IsBypassed",
    ".NET 6.0",
    ".NET 6.0",
    "5,343.2 ns",
    "5,343.2 ns",
    "1.00",
    "1.00",
    "7528 B",
    "7528 B",
    "IsBypassed",
    "IsBypassed",
    ".NET 7.0",
    ".NET 7.0",
    "205.5 ns",
    "205.5 ns",
    "0.04",
    "0.04",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "Also related to HTTP, WebUtility\u2019s HtmlDecode method has improved for .NET 7. The implementation",
    "Also related to HTTP, WebUtility\u2019s HtmlDecode method has improved for .NET 7. The implementation",
    "187",
    "187",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "IndexOfAny in HttpListener\u2019s HandleAuthentication to search a header for certain kinds of",
    "IndexOfAny in HttpListener\u2019s HandleAuthentication to search a header for certain kinds of",
    "private string ",
    "private string ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio",
    "Mean  Ratio",
    "HtmlDecode",
    "HtmlDecode",
    ".NET 6.0",
    ".NET 6.0",
    "245.54 ns",
    "245.54 ns",
    "1.00",
    "1.00",
    "HtmlDecode",
    "HtmlDecode",
    ".NET 7.0",
    ".NET 7.0",
    "19.66 ns",
    "19.66 ns",
    "0.08",
    "0.08",
    "There have been a myriad of other performance-related improvements in networking as well, such as",
    "There have been a myriad of other performance-related improvements in networking as well, such as",
    "private IntPtr ",
    "private IntPtr ",
    "[",
    "[",
    "[",
    "[",
    "public struct SimpleType",
    "public struct SimpleType",
    "[",
    "[",
    "[",
    "[",
    "188",
    "188",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "PtrToStructure  26.6593 ns  1.000",
    "PtrToStructure  26.6593 ns  1.000",
    "Cast",
    "Cast",
    "0.0736 ns  0.003",
    "0.0736 ns  0.003",
    "For folks using NegotiateStream, dotnet/runtime#71280 from",
    "For folks using NegotiateStream, dotnet/runtime#71280 from",
    "private NetworkStream ",
    "private NetworkStream ",
    "[",
    "[",
    "ProtocolType.Tcp);",
    "ProtocolType.Tcp);",
    "}",
    "}",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Handshake",
    "Handshake",
    ".NET 6.0",
    ".NET 6.0",
    "1.905 ms",
    "1.905 ms",
    "1.00",
    "1.00",
    "240.5 KB",
    "240.5 KB",
    "Handshake",
    "Handshake",
    ".NET 7.0",
    ".NET 7.0",
    "1.913 ms",
    "1.913 ms",
    "1.00",
    "1.00",
    "99.28 KB",
    "99.28 KB",
    "1.00",
    "1.00",
    "0.41",
    "0.41",
    "189",
    "189",
    "CHAPTER 16 | Networking",
    "CHAPTER 16 | Networking",
    "CHAPTER  17",
    "CHAPTER  17",
    "JSON",
    "JSON",
    "System.Text.Json was introduced in .NET Core 3.0, and has seen a significant amount of investment",
    "System.Text.Json was introduced in .NET Core 3.0, and has seen a significant amount of investment",
    "One of the biggest performance pitfalls we\u2019ve seen developers face with System.Text.Json has to do",
    "One of the biggest performance pitfalls we\u2019ve seen developers face with System.Text.Json has to do",
    "private JsonSerializerOptions ",
    "private JsonSerializerOptions ",
    "[",
    "[",
    "[",
    "[",
    "[",
    "[",
    "public class MyAmazingClass",
    "public class MyAmazingClass",
    "190",
    "190",
    "CHAPTER 17 | JSON",
    "CHAPTER 17 | JSON",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "ImplicitOptions",
    "ImplicitOptions",
    ".NET 6.0",
    ".NET 6.0",
    "170.3 ns",
    "170.3 ns",
    "1.00",
    "1.00",
    "WithCached",
    "WithCached",
    ".NET 6.0",
    ".NET 6.0",
    "163.8 ns",
    "163.8 ns",
    "0.96",
    "0.96",
    "200 B",
    "200 B",
    "200 B",
    "200 B",
    "1.00",
    "1.00",
    "1.00",
    "1.00",
    "WithoutCached",
    "WithoutCached",
    ".NET 6.0",
    ".NET 6.0",
    "100,440.6 ns  592.48",
    "100,440.6 ns  592.48",
    "7393 B",
    "7393 B",
    "36.97",
    "36.97",
    "In .NET 7, this was fixed in dotnet/runtime#64646 (and subsequently tweaked in",
    "In .NET 7, this was fixed in dotnet/runtime#64646 (and subsequently tweaked in",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "ImplicitOptions",
    "ImplicitOptions",
    ".NET 6.0",
    ".NET 6.0",
    "170.3 ns",
    "170.3 ns",
    "1.00",
    "1.00",
    "200 B",
    "200 B",
    "ImplicitOptions",
    "ImplicitOptions",
    ".NET 7.0",
    ".NET 7.0",
    "166.8 ns",
    "166.8 ns",
    "0.98",
    "0.98",
    "48 B",
    "48 B",
    "WithCached",
    "WithCached",
    ".NET 6.0",
    ".NET 6.0",
    "163.8 ns",
    "163.8 ns",
    "0.96",
    "0.96",
    "200 B",
    "200 B",
    "WithCached",
    "WithCached",
    ".NET 7.0",
    ".NET 7.0",
    "168.3 ns",
    "168.3 ns",
    "0.99",
    "0.99",
    "48 B",
    "48 B",
    "WithoutCached",
    "WithoutCached",
    ".NET 6.0",
    ".NET 6.0",
    "100,440.6 ns  592.48",
    "100,440.6 ns  592.48",
    "7393 B",
    "7393 B",
    "WithoutCached",
    "WithoutCached",
    ".NET 7.0",
    ".NET 7.0",
    "590.1 ns",
    "590.1 ns",
    "3.47",
    "3.47",
    "337 B",
    "337 B",
    "1.00",
    "1.00",
    "0.24",
    "0.24",
    "1.00",
    "1.00",
    "0.24",
    "0.24",
    "36.97",
    "36.97",
    "1.69",
    "1.69",
    "As can be seen here, it\u2019s still more expensive to create a new JsonSerializerOptions instance on",
    "As can be seen here, it\u2019s still more expensive to create a new JsonSerializerOptions instance on",
    "Another change to JsonSerializer came in dotnet/runtime#72510, which slightly improved the",
    "Another change to JsonSerializer came in dotnet/runtime#72510, which slightly improved the",
    "Yet another for JsonSerializer comes in dotnet/runtime#73338, which improves allocation with how",
    "Yet another for JsonSerializer comes in dotnet/runtime#73338, which improves allocation with how",
    "191",
    "191",
    "CHAPTER 17 | JSON",
    "CHAPTER 17 | JSON",
    "Serialize operation, it then ensures the current thread has a Utf8JsonWriter and IBufferWriter",
    "Serialize operation, it then ensures the current thread has a Utf8JsonWriter and IBufferWriter",
    "private byte",
    "private byte",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "SerializeToString",
    "SerializeToString",
    ".NET 6.0",
    ".NET 6.0",
    "146.4 ns",
    "146.4 ns",
    "1.00",
    "1.00",
    "200 B",
    "200 B",
    "SerializeToString",
    "SerializeToString",
    ".NET 7.0",
    ".NET 7.0",
    "137.5 ns",
    "137.5 ns",
    "0.94",
    "0.94",
    "48 B",
    "48 B",
    "1.00",
    "1.00",
    "0.24",
    "0.24",
    "Utf8JsonWriter and Utf8JsonReader also saw several improvements directly. dotnet/runtime#69580",
    "Utf8JsonWriter and Utf8JsonReader also saw several improvements directly. dotnet/runtime#69580",
    "192",
    "192",
    "CHAPTER 17 | JSON",
    "CHAPTER 17 | JSON",
    "CHAPTER  18",
    "CHAPTER  18",
    "XML",
    "XML",
    "System.Xml is used by a huge number of applications and services, but ever since JSON hit the scene",
    "System.Xml is used by a huge number of applications and services, but ever since JSON hit the scene",
    "Sometimes a performance fix is as easy as changing a single number. That\u2019s the case with",
    "Sometimes a performance fix is as easy as changing a single number. That\u2019s the case with",
    "private readonly XmlReaderSettings ",
    "private readonly XmlReaderSettings ",
    "[",
    "[",
    "[",
    "[",
    "193",
    "193",
    "CHAPTER 18 | XML",
    "CHAPTER 18 | XML",
    "}",
    "}",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "ItemCount",
    "ItemCount",
    "Mean  Ratio",
    "Mean  Ratio",
    "Allocated",
    "Allocated",
    "XmlReader",
    "XmlReader",
    ".NET 6.0",
    ".NET 6.0",
    "XmlReader",
    "XmlReader",
    ".NET 7.0",
    ".NET 7.0",
    "10",
    "10",
    "10",
    "10",
    "42.344 us",
    "42.344 us",
    "1.00",
    "1.00",
    "195.94 KB",
    "195.94 KB",
    "9.992 us",
    "9.992 us",
    "0.23",
    "0.23",
    "99.94 KB",
    "99.94 KB",
    "XmlReader",
    "XmlReader",
    ".NET 6.0",
    ".NET 6.0",
    "1000000",
    "1000000",
    "XmlReader",
    "XmlReader",
    ".NET 7.0",
    ".NET 7.0",
    "1000000",
    "1000000",
    "340,382.953",
    "340,382.953",
    "333,417.347",
    "333,417.347",
    "1.00",
    "1.00",
    "0.98",
    "0.98",
    "101790.34",
    "101790.34",
    "101804.45",
    "101804.45",
    "Alloc",
    "Alloc",
    "1.00",
    "1.00",
    "0.51",
    "0.51",
    "1.00",
    "1.00",
    "1.00",
    "1.00",
    "XmlReader and XmlWriter saw other allocation-related improvements as well. dotnet/runtime#60076",
    "XmlReader and XmlWriter saw other allocation-related improvements as well. dotnet/runtime#60076",
    "return ",
    "return ",
    "where ",
    "where ",
    "return string.Create(CultureInfo.InvariantCulture, $",
    "return string.Create(CultureInfo.InvariantCulture, $",
    "which while shorter is also more efficient, avoiding the intermediate string allocations, as the custom",
    "which while shorter is also more efficient, avoiding the intermediate string allocations, as the custom",
    "XmlSerializer is also quite popular and also gets a (small) allocation reduction, in particular for",
    "XmlSerializer is also quite popular and also gets a (small) allocation reduction, in particular for",
    "194",
    "194",
    "CHAPTER 18 | XML",
    "CHAPTER 18 | XML",
    "generators we love today). In both cases, when deserializing, the generated code wants to track which",
    "generators we love today). In both cases, when deserializing, the generated code wants to track which",
    "using System.Text;",
    "using System.Text;",
    "var serializer = new XmlSerializer(typeof(Release",
    "var serializer = new XmlSerializer(typeof(Release",
    "for (int i = 0; i ",
    "for (int i = 0; i ",
    "public class Release",
    "public class Release",
    "Here\u2019s what I see when I run this under .NET 6:",
    "Here\u2019s what I see when I run this under .NET 6:",
    "195",
    "195",
    "CHAPTER 18 | XML",
    "CHAPTER 18 | XML",
    "We\u2019re running a thousand deserializations, each of which will deserialize 10 Release instances, and so",
    "We\u2019re running a thousand deserializations, each of which will deserialize 10 Release instances, and so",
    "Other allocation reduction went into the creation of the serializer/deserializer itself, such as with",
    "Other allocation reduction went into the creation of the serializer/deserializer itself, such as with",
    "For folks using XML schema, dotnet/runtime#66908 replaces some Hashtables in the implementation",
    "For folks using XML schema, dotnet/runtime#66908 replaces some Hashtables in the implementation",
    "196",
    "196",
    "CHAPTER 18 | XML",
    "CHAPTER 18 | XML",
    "avoid temporary string allocation in the implementation of the internal XsdDateTime and",
    "avoid temporary string allocation in the implementation of the internal XsdDateTime and",
    "private TimeSpan ",
    "private TimeSpan ",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "XmlConvertToString",
    "XmlConvertToString",
    ".NET 6.0",
    ".NET 6.0",
    "90.70 ns",
    "90.70 ns",
    "1.00",
    "1.00",
    "184 B",
    "184 B",
    "XmlConvertToString",
    "XmlConvertToString",
    ".NET 7.0",
    ".NET 7.0",
    "59.21 ns",
    "59.21 ns",
    "0.65",
    "0.65",
    "40 B",
    "40 B",
    "1.00",
    "1.00",
    "0.22",
    "0.22",
    "XML pops up in other areas as well, as in the XmlWriterTraceListener type. While the",
    "XML pops up in other areas as well, as in the XmlWriterTraceListener type. While the",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "TraceWrite",
    "TraceWrite",
    ".NET 6.0",
    ".NET 6.0",
    "961.9 ns",
    "961.9 ns",
    "1.00",
    "1.00",
    "288 B",
    "288 B",
    "TraceWrite",
    "TraceWrite",
    ".NET 7.0",
    ".NET 7.0",
    "772.2 ns",
    "772.2 ns",
    "0.80",
    "0.80",
    "64 B",
    "64 B",
    "1.00",
    "1.00",
    "0.22",
    "0.22",
    "197",
    "197",
    "CHAPTER 18 | XML",
    "CHAPTER 18 | XML",
    "CHAPTER  19",
    "CHAPTER  19",
    "Cryptography",
    "Cryptography",
    "Some fairly significant new features came to System.Security.Cryptography in .NET 7, including the",
    "Some fairly significant new features came to System.Security.Cryptography in .NET 7, including the",
    "One fairly substantial change in .NET 7 is split across dotnet/runtime#61025, dotnet/runtime#61137,",
    "One fairly substantial change in .NET 7 is split across dotnet/runtime#61025, dotnet/runtime#61137,",
    "These PRs move all of that code into a single System.Security.Cryptography.dll assembly. This has",
    "These PRs move all of that code into a single System.Security.Cryptography.dll assembly. This has",
    "198",
    "198",
    "CHAPTER 19 | Cryptography",
    "CHAPTER 19 | Cryptography",
    "requiring multiple (or even most) of these assemblies. Every assembly that\u2019s loaded adds overhead.",
    "requiring multiple (or even most) of these assemblies. Every assembly that\u2019s loaded adds overhead.",
    "Interesting, you still see a bunch of assemblies there, but all except for",
    "Interesting, you still see a bunch of assemblies there, but all except for",
    "199",
    "199",
    "CHAPTER 19 | Cryptography",
    "CHAPTER 19 | Cryptography",
    "In addition to the startup and maintenance wins this provides, this has also enabled further",
    "In addition to the startup and maintenance wins this provides, this has also enabled further",
    "In terms of actual code improvements, there are many. One category of improvements is around",
    "In terms of actual code improvements, there are many. One category of improvements is around",
    "200",
    "200",
    "CHAPTER 19 | Cryptography",
    "CHAPTER 19 | Cryptography",
    "private byte",
    "private byte",
    "[",
    "[",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "OneShot",
    "OneShot",
    ".NET 6.0",
    ".NET 6.0",
    "1.828 us",
    "1.828 us",
    "1.00",
    "1.00",
    "OneShot",
    "OneShot",
    ".NET 7.0",
    ".NET 7.0",
    "1.770 us",
    "1.770 us",
    "0.97",
    "0.97",
    "336 B",
    "336 B",
    "184 B",
    "184 B",
    "1.00",
    "1.00",
    "0.55",
    "0.55",
    "In addition to making one-shots lighterweight, other PRs have then used these one-shot operations in",
    "In addition to making one-shots lighterweight, other PRs have then used these one-shot operations in",
    "There\u2019s also a large number of PRs that have focused on removing allocations from around the crypto",
    "There\u2019s also a large number of PRs that have focused on removing allocations from around the crypto",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "Stack allocation. As has been seen in many other PRs referenced throughout this post, using",
    "Stack allocation. As has been seen in many other PRs referenced throughout this post, using",
    "Avoiding double copies. Most of the crypto APIs that accept byte",
    "Avoiding double copies. Most of the crypto APIs that accept byte",
    "201",
    "201",
    "CHAPTER 19 | Cryptography",
    "CHAPTER 19 | Cryptography",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "Rfc2898DeriveBytes to supports spans such that its constructors that accept spans can then do",
    "Rfc2898DeriveBytes to supports spans such that its constructors that accept spans can then do",
    "Replacing O(1) data structures. O(1) lookup data structures like Dictionary",
    "Replacing O(1) data structures. O(1) lookup data structures like Dictionary",
    "Simply avoiding unnecessary work. The best optimizations are ones where you simply stop",
    "Simply avoiding unnecessary work. The best optimizations are ones where you simply stop",
    "New APIs. A bunch of new APIs were introduced for cryptography in .NET 7. Most are focused",
    "New APIs. A bunch of new APIs were introduced for cryptography in .NET 7. Most are focused",
    "202",
    "202",
    "CHAPTER 19 | Cryptography",
    "CHAPTER 19 | Cryptography",
    "CHAPTER  20",
    "CHAPTER  20",
    "Diagnostics",
    "Diagnostics",
    "Let\u2019s turn our attention to System.Diagnostics, which encompasses types ranging from process",
    "Let\u2019s turn our attention to System.Diagnostics, which encompasses types ranging from process",
    "The Process class is used for a variety of purposes, including querying information about running",
    "The Process class is used for a variety of purposes, including querying information about running",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "GetProcessesByName",
    "GetProcessesByName",
    ".NET 6.0",
    ".NET 6.0",
    "2.287 ms",
    "2.287 ms",
    "1.00  447.86 KB",
    "1.00  447.86 KB",
    "GetProcessesByName",
    "GetProcessesByName",
    ".NET 7.0",
    ".NET 7.0",
    "2.086 ms",
    "2.086 ms",
    "0.90",
    "0.90",
    "2.14 KB",
    "2.14 KB",
    "1.000",
    "1.000",
    "0.005",
    "0.005",
    "Accessing various pieces of information from a Process has also improved. If you load a Process",
    "Accessing various pieces of information from a Process has also improved. If you load a Process",
    "203",
    "203",
    "CHAPTER 20 | Diagnostics",
    "CHAPTER 20 | Diagnostics",
    "process\u2019 name, it\u2019s a huge boost in throughput, and even if you subsequently go on to read additional",
    "process\u2019 name, it\u2019s a huge boost in throughput, and even if you subsequently go on to read additional",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime",
    "Runtime",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "GetCurrentProcessName",
    "GetCurrentProcessName",
    ".NET 6.0",
    ".NET 6.0",
    "3,070.54 us",
    "3,070.54 us",
    "1.00",
    "1.00",
    "3954 B",
    "3954 B",
    "GetCurrentProcessName",
    "GetCurrentProcessName",
    ".NET 7.0",
    ".NET 7.0",
    "32.30 us",
    "32.30 us",
    "0.01",
    "0.01",
    "456 B",
    "456 B",
    "GetCurrentProcessNameAndWorkingSet",
    "GetCurrentProcessNameAndWorkingSet",
    ".NET 6.0",
    ".NET 6.0",
    "3,055.70 us",
    "3,055.70 us",
    "1.00",
    "1.00",
    "4010 B",
    "4010 B",
    "GetCurrentProcessNameAndWorkingSet",
    "GetCurrentProcessNameAndWorkingSet",
    ".NET 7.0",
    ".NET 7.0",
    "3,149.92 us",
    "3,149.92 us",
    "1.03",
    "1.03",
    "4186 B",
    "4186 B",
    "1.00",
    "1.00",
    "0.12",
    "0.12",
    "1.00",
    "1.00",
    "1.04",
    "1.04",
    "Interestingly, this PR had a small deficiency we didn\u2019t initially catch, which is that the",
    "Interestingly, this PR had a small deficiency we didn\u2019t initially catch, which is that the",
    "Several additional PRs helped out the Process class. When launching processes with Process.Start",
    "Several additional PRs helped out the Process class. When launching processes with Process.Start",
    "Another area of performance investment has been in DiagnosticSource, and in particular around",
    "Another area of performance investment has been in DiagnosticSource, and in particular around",
    "204",
    "204",
    "CHAPTER 20 | Diagnostics",
    "CHAPTER 20 | Diagnostics",
    "enumerator returned when enumerating Activity.Links and Activity.Events by avoiding a copy",
    "enumerator returned when enumerating Activity.Links and Activity.Events by avoiding a copy",
    "private readonly Activity ",
    "private readonly Activity ",
    "public Program()",
    "public Program()",
    "}",
    "}",
    "[",
    "[",
    "Method",
    "Method",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "EnumerateActivityLinks",
    "EnumerateActivityLinks",
    ".NET 6.0",
    ".NET 6.0",
    "19.62 us",
    "19.62 us",
    "1.00",
    "1.00",
    "EnumerateActivityLinks",
    "EnumerateActivityLinks",
    ".NET 7.0",
    ".NET 7.0",
    "13.72 us",
    "13.72 us",
    "0.70",
    "0.70",
    "64 B",
    "64 B",
    "32 B",
    "32 B",
    "1.00",
    "1.00",
    "0.50",
    "0.50",
    "Then dotnet/runtime#67920 from ",
    "Then dotnet/runtime#67920 from ",
    "private readonly Activity ",
    "private readonly Activity ",
    "public Program()",
    "public Program()",
    "205",
    "205",
    "CHAPTER 20 | Diagnostics",
    "CHAPTER 20 | Diagnostics",
    "_",
    "_",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "EnumerateActivityLinks",
    "EnumerateActivityLinks",
    "13.655 us",
    "13.655 us",
    "1.00",
    "1.00",
    "32 B",
    "32 B",
    "EnumerateActivityLinks",
    "EnumerateActivityLinks",
    "2.380 us",
    "2.380 us",
    "0.17",
    "0.17",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "Of course, when it comes to diagnostics, anyone who\u2019s ever done anything with regards to timing and",
    "Of course, when it comes to diagnostics, anyone who\u2019s ever done anything with regards to timing and",
    "Stopwatch sw = Stopwatch.StartNew();",
    "Stopwatch sw = Stopwatch.StartNew();",
    "is easy, but allocates a new object just to measure. To address this, Stopwatch has for years exposed",
    "is easy, but allocates a new object just to measure. To address this, Stopwatch has for years exposed",
    "long timestamp = Stopwatch.GetTimestamp();",
    "long timestamp = Stopwatch.GetTimestamp();",
    "which avoids the allocation and saves a few cycles:",
    "which avoids the allocation and saves a few cycles:",
    "[",
    "[",
    "[",
    "[",
    "206",
    "206",
    "CHAPTER 20 | Diagnostics",
    "CHAPTER 20 | Diagnostics",
    "long timestamp = Stopwatch.GetTimestamp();",
    "long timestamp = Stopwatch.GetTimestamp();",
    "Method  Mean  Ratio  Allocated  Alloc Ratio",
    "Method  Mean  Ratio  Allocated  Alloc Ratio",
    "Old",
    "Old",
    "New",
    "New",
    "32.90 ns",
    "32.90 ns",
    "1.00",
    "1.00",
    "40 B",
    "40 B",
    "26.30 ns",
    "26.30 ns",
    "0.80",
    "0.80",
    "1.00",
    "1.00",
    "0.00",
    "0.00",
    "207",
    "207",
    "CHAPTER 20 | Diagnostics",
    "CHAPTER 20 | Diagnostics",
    "CHAPTER  21",
    "CHAPTER  21",
    "Exceptions",
    "Exceptions",
    "It might be odd to see the subject of \u201cexceptions\u201d in a post on performance improvements. After all,",
    "It might be odd to see the subject of \u201cexceptions\u201d in a post on performance improvements. After all,",
    "Instead, one of the things we do concern ourselves with is how to minimize the impact of checking for",
    "Instead, one of the things we do concern ourselves with is how to minimize the impact of checking for",
    "Because of all of that, high-performance libraries often come up with custom \u201cthrow helpers\u201d they use",
    "Because of all of that, high-performance libraries often come up with custom \u201cthrow helpers\u201d they use",
    "if (arg is null)",
    "if (arg is null)",
    "This keeps the IL associated with the throwing out of the calling function, minimizing the impact of",
    "This keeps the IL associated with the throwing out of the calling function, minimizing the impact of",
    "private static void ThrowArgumentNullException(string arg) =>",
    "private static void ThrowArgumentNullException(string arg) =>",
    "Other times, libraries will encapsulate both the checking and throwing. This is exactly what the",
    "Other times, libraries will encapsulate both the checking and throwing. This is exactly what the",
    "public static void ThrowIfNull(",
    "public static void ThrowIfNull(",
    "208",
    "208",
    "CHAPTER 21 | Exceptions",
    "CHAPTER 21 | Exceptions",
    "[",
    "[",
    "With that, callers benefit from the concise call site:",
    "With that, callers benefit from the concise call site:",
    "public void M(string arg)",
    "public void M(string arg)",
    "the IL remains concise, and the assembly generated for the JIT will include the streamlined condition",
    "the IL remains concise, and the assembly generated for the JIT will include the streamlined condition",
    "Whenever we introduce new public APIs in .NET, I\u2019m particularly keen on seeing them used as widely",
    "Whenever we introduce new public APIs in .NET, I\u2019m particularly keen on seeing them used as widely",
    "For those unaware, the ",
    "For those unaware, the ",
    "public void Process(string name",
    "public void Process(string name",
    "The C# compiler then compiled that as equivalent to:",
    "The C# compiler then compiled that as equivalent to:",
    "public void Process(string name)",
    "public void Process(string name)",
    "(albeit using its own ThrowIfNull helper injected as internal into the assembly). Armed with the new",
    "(albeit using its own ThrowIfNull helper injected as internal into the assembly). Armed with the new",
    "209",
    "209",
    "CHAPTER 21 | Exceptions",
    "CHAPTER 21 | Exceptions",
    "APIs internally. Interestingly, while we expected a peanut-buttery effect of slight perf improvements in",
    "APIs internally. Interestingly, while we expected a peanut-buttery effect of slight perf improvements in",
    "With the success of ArgumentNullException.ThrowIfNull and along with its significant roll-out in",
    "With the success of ArgumentNullException.ThrowIfNull and along with its significant roll-out in",
    "210",
    "210",
    "CHAPTER 21 | Exceptions",
    "CHAPTER 21 | Exceptions",
    "CHAPTER  22",
    "CHAPTER  22",
    "Registry",
    "Registry",
    "On Windows, the Registry is a database provided by the OS for applications and the system itself to",
    "On Windows, the Registry is a database provided by the OS for applications and the system itself to",
    "Console.WriteLine(",
    "Console.WriteLine(",
    "built it as release, and then ran the resulting .exe. That execution alone triggered 64 RegQueryValue",
    "built it as release, and then ran the resulting .exe. That execution alone triggered 64 RegQueryValue",
    "It\u2019s thus beneficial to streamline access to registry data on Windows, in particular for reducing",
    "It\u2019s thus beneficial to streamline access to registry data on Windows, in particular for reducing",
    "private static readonly RegistryKey s",
    "private static readonly RegistryKey s",
    "[",
    "[",
    "211",
    "211",
    "CHAPTER 22 | Registry",
    "CHAPTER 22 | Registry",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "Method  Runtime  Mean  Ratio  Allocated  Alloc Ratio",
    "RegSz",
    "RegSz",
    ".NET 6.0",
    ".NET 6.0",
    "6.266 us",
    "6.266 us",
    "1.00",
    "1.00",
    "200 B",
    "200 B",
    "RegSz",
    "RegSz",
    ".NET 7.0",
    ".NET 7.0",
    "3.182 us",
    "3.182 us",
    "0.51",
    "0.51",
    "96 B",
    "96 B",
    "1.00",
    "1.00",
    "0.48",
    "0.48",
    "212",
    "212",
    "CHAPTER 22 | Registry",
    "CHAPTER 22 | Registry",
    "CHAPTER  23",
    "CHAPTER  23",
    "Analyzers",
    "Analyzers",
    "The ability to easily plug custom code, whether for analyzers or source generators, into the Roslyn",
    "The ability to easily plug custom code, whether for analyzers or source generators, into the Roslyn",
    "One of my favorite new analyzers was added in dotnet/roslyn-analyzers#5594 from",
    "One of my favorite new analyzers was added in dotnet/roslyn-analyzers#5594 from",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "\u2022",
    "Virtual calls are more expensive than regular non-virtual invocation and generally can\u2019t be",
    "Virtual calls are more expensive than regular non-virtual invocation and generally can\u2019t be",
    "If a type check (e.g. something is typeof(SomeType)) is performed where SomeType is sealed,",
    "If a type check (e.g. something is typeof(SomeType)) is performed where SomeType is sealed,",
    "Arrays in .NET are covariant, which means if types B and C both derive from type A, you can have",
    "Arrays in .NET are covariant, which means if types B and C both derive from type A, you can have",
    "Spans shift this covariance check to their constructor; rather than performing the covariance",
    "Spans shift this covariance check to their constructor; rather than performing the covariance",
    "213",
    "213",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "It effectively would be impossible for an analyzer to be able to safely recommend sealing public types.",
    "It effectively would be impossible for an analyzer to be able to safely recommend sealing public types.",
    "In .NET 6, we sealed over 2300 types, but even with that, this analyzer ended up finding more to seal.",
    "In .NET 6, we sealed over 2300 types, but even with that, this analyzer ended up finding more to seal.",
    "Another new analyzer, CA1854, was added in dotnet/roslyn-analyzers#4851 from",
    "Another new analyzer, CA1854, was added in dotnet/roslyn-analyzers#4851 from",
    "if (",
    "if (",
    "Dictionary\u2019s TryGetValue method already combines both of these operations, both looking up the",
    "Dictionary\u2019s TryGetValue method already combines both of these operations, both looking up the",
    "if (",
    "if (",
    "A benefit of this, in addition to arguably being simpler, is that it\u2019s also faster. While Dictionary",
    "A benefit of this, in addition to arguably being simpler, is that it\u2019s also faster. While Dictionary",
    "214",
    "214",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "private readonly Dictionary",
    "private readonly Dictionary",
    "private string ",
    "private string ",
    "[",
    "[",
    "}",
    "}",
    "[",
    "[",
    "}",
    "}",
    "Method  Mean  Ratio",
    "Method  Mean  Ratio",
    "Lookup1  28.20 ns",
    "Lookup1  28.20 ns",
    "1.00",
    "1.00",
    "Lookup2  14.12 ns",
    "Lookup2  14.12 ns",
    "0.50",
    "0.50",
    "Somewhat ironically, even as I write this example, the analyzer and its auto-fixer are helpfully trying to",
    "Somewhat ironically, even as I write this example, the analyzer and its auto-fixer are helpfully trying to",
    "215",
    "215",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "Similarly, dotnet/roslyn-analyzers#4836 from ",
    "Similarly, dotnet/roslyn-analyzers#4836 from ",
    "if (m",
    "if (m",
    "which the analyzer flagged and which it\u2019s auto-fixer replaced with just:",
    "which the analyzer flagged and which it\u2019s auto-fixer replaced with just:",
    "m",
    "m",
    "Nice and simple. And faster, since as with the TryGetValue case, this is now doing a single dictionary",
    "Nice and simple. And faster, since as with the TryGetValue case, this is now doing a single dictionary",
    "216",
    "216",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    ":::",
    ":::",
    "Another nice analyzer added in dotnet/roslyn-analyzers#5907 and dotnet/roslyn-analyzers#5910 is",
    "Another nice analyzer added in dotnet/roslyn-analyzers#5907 and dotnet/roslyn-analyzers#5910 is",
    "private void InitializeTypeCatalog(IEnumerable",
    "private void InitializeTypeCatalog(IEnumerable",
    "}",
    "}",
    "The method\u2019s purpose is to convert the enumerable into an array to be stored, but also to validate",
    "The method\u2019s purpose is to convert the enumerable into an array to be stored, but also to validate",
    "217",
    "217",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "with this. First, it\u2019s incurring the expense of interating through the enumerable twice, once for the",
    "with this. First, it\u2019s incurring the expense of interating through the enumerable twice, once for the",
    "private void InitializeTypeCatalog(IEnumerable",
    "private void InitializeTypeCatalog(IEnumerable",
    "nameof(types)), nameof(types));",
    "nameof(types)), nameof(types));",
    "}",
    "}",
    "With that, we only ever iterate it once (and possibly 0 times if ToArray can special-case it, and bonus,",
    "With that, we only ever iterate it once (and possibly 0 times if ToArray can special-case it, and bonus,",
    "Yet another helpful analyzer is the new CA1850 introduced in dotnet/roslyn-analyzers#4797 from",
    "Yet another helpful analyzer is the new CA1850 introduced in dotnet/roslyn-analyzers#4797 from",
    "public byte",
    "public byte",
    "However, .NET 5 introduced new \u201cone-shot\u201d hashing methods, which obviates the need to create a",
    "However, .NET 5 introduced new \u201cone-shot\u201d hashing methods, which obviates the need to create a",
    "public byte",
    "public byte",
    "CA1850 finds occurrences of the former pattern and recommends changing them to the latter.",
    "CA1850 finds occurrences of the former pattern and recommends changing them to the latter.",
    "218",
    "218",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "The result is not only simpler, it\u2019s also faster:",
    "The result is not only simpler, it\u2019s also faster:",
    "private readonly byte",
    "private readonly byte",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Mean  Ratio  Allocated  Alloc Ratio",
    "Hash1",
    "Hash1",
    "1,212.9 ns",
    "1,212.9 ns",
    "1.00",
    "1.00",
    "240 B",
    "240 B",
    "Hash2",
    "Hash2",
    "950.8 ns",
    "950.8 ns",
    "0.78",
    "0.78",
    "56 B",
    "56 B",
    "1.00",
    "1.00",
    "0.23",
    "0.23",
    "The .NET 7 SDK also includes new analyzers around ",
    "The .NET 7 SDK also includes new analyzers around ",
    "219",
    "219",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "This release also saw dotnet/runtime turn on a bunch of additional IDEXXXX code style rules and",
    "This release also saw dotnet/runtime turn on a bunch of additional IDEXXXX code style rules and",
    "Let\u2019s start with IDE0200, which is about removing unnecessary lambdas. Consider a setup like this:",
    "Let\u2019s start with IDE0200, which is about removing unnecessary lambdas. Consider a setup like this:",
    "public class C",
    "public class C",
    "}",
    "}",
    "Here we have a method CallSite that\u2019s invoking a method M and passing a lambda to it. Method M",
    "Here we have a method CallSite that\u2019s invoking a method M and passing a lambda to it. Method M",
    "public class C",
    "public class C",
    "Action",
    "Action",
    "}",
    "}",
    "The most important aspect of this is that ",
    "The most important aspect of this is that ",
    "220",
    "220",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "non-null and will just reuse the same delegate. Thus, this lambda only ever results in a single",
    "non-null and will just reuse the same delegate. Thus, this lambda only ever results in a single",
    "private Action ",
    "private Action ",
    "[",
    "[",
    "[",
    "[",
    "private sealed class C",
    "private sealed class C",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "InvokeInstance  0.8858 ns",
    "InvokeInstance  0.8858 ns",
    "1.00",
    "1.00",
    "InvokeStatic",
    "InvokeStatic",
    "1.3979 ns",
    "1.3979 ns",
    "1.58",
    "1.58",
    "So, the compiler is able to cache references to lambdas, great. What about method groups, i.e. where",
    "So, the compiler is able to cache references to lambdas, great. What about method groups, i.e. where",
    "public class C",
    "public class C",
    "}",
    "}",
    "the compiler would generate the equivalent of:",
    "the compiler would generate the equivalent of:",
    "public class C",
    "public class C",
    "}",
    "}",
    "221",
    "221",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "which has the unfortunate effect of allocating a new delegate on every invocation, even though we\u2019re",
    "which has the unfortunate effect of allocating a new delegate on every invocation, even though we\u2019re",
    "public class C",
    "public class C",
    "}",
    "}",
    "Note we again have a caching field that\u2019s used to enable allocating the delegate once and caching it.",
    "Note we again have a caching field that\u2019s used to enable allocating the delegate once and caching it.",
    "And that brings us to IDE0200, which recognizes lambda expressions that can be removed.",
    "And that brings us to IDE0200, which recognizes lambda expressions that can be removed.",
    "Action disposeAction;",
    "Action disposeAction;",
    "That delegate closes over the disposable local, which means this method needs to allocate a display",
    "That delegate closes over the disposable local, which means this method needs to allocate a display",
    "Action disposeAction;",
    "Action disposeAction;",
    "222",
    "222",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "disposeAction = disposable.Dispose;",
    "disposeAction = disposable.Dispose;",
    "We still get a delegate allocation, but we avoid the display class allocation, and as a bonus we save on",
    "We still get a delegate allocation, but we avoid the display class allocation, and as a bonus we save on",
    "IDE0020 is another good example of an analyzer that is primarily focused on making code cleaner,",
    "IDE0020 is another good example of an analyzer that is primarily focused on making code cleaner,",
    "if (value is SqlDouble)",
    "if (value is SqlDouble)",
    "to instead be like:",
    "to instead be like:",
    "if (value is SqlDouble i)",
    "if (value is SqlDouble i)",
    "In addition to being cleaner, this ends up saving a cast operation, which can add measurable",
    "In addition to being cleaner, this ends up saving a cast operation, which can add measurable",
    "private object ",
    "private object ",
    "[",
    "[",
    "[",
    "[",
    "Method",
    "Method",
    "Mean  Ratio",
    "Mean  Ratio",
    "WithCast",
    "WithCast",
    "2.602 ns",
    "2.602 ns",
    "1.00",
    "1.00",
    "WithPattern  1.886 ns",
    "WithPattern  1.886 ns",
    "0.73",
    "0.73",
    "Then there\u2019s IDE0031, which promotes using null propagation features of C#. This analyzer typically",
    "Then there\u2019s IDE0031, which promotes using null propagation features of C#. This analyzer typically",
    "return ",
    "return ",
    "into code that\u2019s instead like:",
    "into code that\u2019s instead like:",
    "223",
    "223",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "return ",
    "return ",
    "Nice, concise, and primarily about cleaning up the code and making it simpler and more maintainable",
    "Nice, concise, and primarily about cleaning up the code and making it simpler and more maintainable",
    "public class C",
    "public class C",
    "}",
    "}",
    "The C# compiler lowers these expressions to the equivalent of this:",
    "The C# compiler lowers these expressions to the equivalent of this:",
    "public Nullable",
    "public Nullable",
    "public Nullable",
    "public Nullable",
    "for which the JIT then generates:",
    "for which the JIT then generates:",
    "; Program.Get1()",
    "; Program.Get1()",
    "; Program.Get2()",
    "; Program.Get2()",
    "224",
    "224",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "mov       dword ptr ",
    "mov       dword ptr ",
    "Note how the Get1 variant has an extra cmp instruction (cmp ",
    "Note how the Get1 variant has an extra cmp instruction (cmp ",
    "Another interesting example is IDE0060, which finds unused parameters and recommends removing",
    "Another interesting example is IDE0060, which finds unused parameters and recommends removing",
    "One final example of peanut-buttery performance improvements from applying an analyzer comes",
    "One final example of peanut-buttery performance improvements from applying an analyzer comes",
    "return message ",
    "return message ",
    "and recommending it be converted to:",
    "and recommending it be converted to:",
    "return message ?? string.Empty;",
    "return message ?? string.Empty;",
    "As with some of the previous rules discussed, that in and of itself doesn\u2019t make a meaningful",
    "As with some of the previous rules discussed, that in and of itself doesn\u2019t make a meaningful",
    "null ",
    "null ",
    "which is rewritten to:",
    "which is rewritten to:",
    "foundColumns",
    "foundColumns",
    "This avoids an unnecessary re-access to an array. Or again from those PRs the expression:",
    "This avoids an unnecessary re-access to an array. Or again from those PRs the expression:",
    "225",
    "225",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "entry.GetKey(",
    "entry.GetKey(",
    "being changed to:",
    "being changed to:",
    "entry.GetKey(",
    "entry.GetKey(",
    "and avoiding an unnecessary table lookup.",
    "and avoiding an unnecessary table lookup.",
    "226",
    "226",
    "CHAPTER 23 | Analyzers",
    "CHAPTER 23 | Analyzers",
    "CHAPTER  24",
    "CHAPTER  24",
    "What\u2019s Next?",
    "What\u2019s Next?",
    "Whew",
    "Whew",
    "The next step is on you. Download the latest .NET 7 bits and take them for a spin. Upgrade your apps.",
    "The next step is on you. Download the latest .NET 7 bits and take them for a spin. Upgrade your apps.",
    "Until next time\u2026",
    "Until next time\u2026",
    "Happy coding",
    "Happy coding",
    "227",
    "227",
    "CHAPTER 24 | What\u2019s Next?",
    "CHAPTER 24 | What\u2019s Next?"
]