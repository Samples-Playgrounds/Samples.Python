{".NET for Java Developers": {"Contents": "| Introduction                                           | 1  |\n|--------------------------------------------------------|----|\n| History                                                | 3  |\n| Of components, managed environments, and code          | 3  |\n| Hello, .NET                                            | 5  |\n| Hello, strange new world                               | 9  |\n| Getting Started: Tooling                               | 10 |\n| Hello, web?                                            | 10 |\n| Docker all the things!                                 | 10 |\n| Linux .NET?                                            | 10 |\n| Visual Studio Code                                     | 11 |\n| Mac .NET?                                              | 12 |\n| Windows: Visual Studio                                 | 14 |\n| Hello, dotnet: CLI style                               | 15 |\n| Hello, .NET: IDE style                                 | 16 |\n| Solutions and projects                                 | 18 |\n| Goodbye, HelloWorld                                    | 19 |\n| C#, Succinctly                                         | 20 |\n| C# Basics                                              | 20 |\n| Starting exploration: classes, properties, and methods | 21 |\n| Lambdas, type inference, and extension classes         | 25 |\n| Language-INtegrated Query (LINQ)                       | 27 |\n| Asynchronous programming with Async/Await              | 28 |\n| Frameworks, for the Win!                               | 29 |\n| ASP.NET Core Web API                                   | 30 |\n| ASP.NET Core MVC                                       | 33 |\n| Entity Framework Core                                  | 35 |\n| Wrapping Up                                            | 39 |\n\n![](_page_3_Picture_0.jpeg)", "<span id=\"page-3-0\"></span>Introduction": "When I was about eight years old, my parents took my sister and me to Paris, France. It was our first trip out of the country, and aside from the ridiculously long flight\u2014eight hours on an airplane feels like forever to somebody who hasn't yet finished their first decade of life\u2014I really had no idea of what to expect. In fact, in an amusing anecdote my father has yet to tire of telling, I remember having to sit down with my parents in front of a globe so that they could explain to me that \"the United States\" was not, in fact, synonymous with \"the world.\"\n\nIt was entirely a trip of firsts: my first experience wandering around in a world where I couldn't understand any of the written signs, my first experience eating food I couldn't recognize, and my first experience feeling completely lost in the world around me. I found, to my eight-year-old horror, that I couldn't even figure out which bathroom to use\u2014which, considering I had just the year before managed to convince my mother I didn't need to be escorted to the bathroom and back, was of particular concern. I didn't want her to start thinking I actually needed adult supervision. This was clearly not my home, and I was more than a little terrified of it.\n\nVisiting a foreign land, particularly to someone who has cocooned themselves entirely in the concepts and cultures of \"home,\" can be intimidating and overwhelming without a guide. On that trip to France I had my parents, and despite neither of them speaking anything close to fluent French, they managed to guide us through the tricky parts. (French-English guidebooks are a wonderful thing.)\n\nFor the typical Java developer, finding a guide to exploring the .NET ecosystem can be tricky, since the average Java developer can still hearken back to a time when expressing an interest in looking at .NET was tantamount to declaring a desire to betray everything good and right in the world (or so it seemed, at least at the time).\n\nIn this paper, I will serve as your guide to the .NET world. I've been a part of the .NET ecosystem almost as long as I've been a part of Java's. I started with Java in 1996; I started with what would become .NET in 2000, even before it was announced. I've built applications in both, written books for both, and explored the source for both. They're closer to one another than you might think, but each has been fundamentally influenced by the people using them. In fact, it's not a bad analogy to think of them as twin brothers, separated at birth, raised by different sets of parents. Same DNA, but shaped by their experiences and events to be different in a number of interesting places.\n\nIf you're a Java developer, looking to get started exploring the .NET ecosystem, then suspend what you think you know, take my hand, and let's take a trip to a foreign land. Doing so will require a little history to understand how things came to be, then a quick set of instructions on how to get the tooling set up (and which tooling you want, depending on your preferences). Once the environment is set up, we can pick up the critical differences between C# and Java, and start diving into some of the central frameworks in this world\u2014ASP.NET, Entity Framework, and a few others. When we\n\n![](_page_4_Picture_0.jpeg)\n\nfinish up, if you're following along, you'll have everything you need to start your own exploration of the .NET community, and from there you'll get to draw your own conclusions and make your own opinions.\n\nMost importantly, you'll know how to order off the menu and tell the bathrooms apart.\n\nReady?\n\n![](_page_5_Picture_0.jpeg)", "<span id=\"page-5-0\"></span>History": {"Of components, managed environments, and code": {"Hello, .NET": "Divorces are never a pretty sight, and recounting the history of one is always fraught with opinion, revisionist history, and bad feeling. Suffice it to say that by 1997/1998, two facts were becoming clear: one, Sun didn't care for Microsoft's work increasing interoperability between their JVM and native COM components in Windows1 , and two, Microsoft and Java were going to part ways, one way or another. (Who got custody of the dog is still hotly debated.)\n\nEither certain groups within Microsoft could see the writing on the wall or they had come to find issues (real or perceived) with the Java Virtual Machine; either way, by 1998, a new effort came to life inside of Microsoft, designed to bring a new managed platform and managed language into the world. Originally intended as the successor to COM, it went through a variety of names, including\n\n<sup>1</sup> For the curious, Microsoft offered additional platform-specific APIs that permitted interoperation with native COM components. The irony of this is deep, considering that Sun had actually allowed for COM-specific native interfaces in their JNI specification\u2014the first three methods in the interface table for a JNIEnv (\"JNI environment\") object were specifically left \"reserved\" for the necessary three methods (AddRef, Release, and QueryInterface) of every COM interface object. Those three slots are still reserved to this day.\n\n![](_page_8_Picture_0.jpeg)\n\n\"COM+,\" the \"Component Object Runtime\" (COR), the \"Universal RunTime\" (URT), and \"Next-Generation Windows Services\" (NGWS) before finally being introduced to the world as \".NET\" at that October 2000 PDC. Along with it would come a new language, code-named \"COOL\" (supposedly to stand for the \"Component-Oriented Object Language,\" although opinions vary now) and later renamed \"C#.\"\n\nWhile most observers considered C# and the CLR (the Common Language Runtime, the virtual machine executing the bytecode) to be direct competitors of Java, Microsoft took careful steps to ensure that it was \"open\" in ways that Java was not: where the JVM was designed from the beginning to be a virtual machine for a single language, the CLR embraced a more polyglot approach, with Microsoft even going so far as to recruit several universities and companies to create new languages for this platform and/or adapt existing ones. This project, nicknamed \"Project 7\" (for the 7 groups that participated), debuted several of these languages during .NET's introduction, and included CLR flavors of Eiffel, Perl, and even COBOL(!). Few of these languages gained any traction after the first few years of existence, and most no longer exist, but their presence had the effect on Microsoft of \"keeping them honest\" with respect to other languages beyond C# and Visual Basic as the platform grew and evolved. (Microsoft itself would later go on to introduce a number of new CLR-based languages, including a compiled-to-binary version of ECMAScript, two different efforts at bringing managed coding to C++, a hybrid object/functional language called F#, and several more research languages.)\n\nHowever, Microsoft also sought to make sure that .NET was not a proprietary effort by investing thousands of man-hours into the creation of a series of international specifications\u2014through the European Computer Manufacturer's Association (ECMA2 )\u2014to ensure that C# and the underlying platform were both open industry standards. C# was accepted and ratified as ECMA-334, and the underlying runtime was given the name the \"Common Language Infrastructure\" (CLI), and accepted and ratified as ECMA-335. Intel, HP, and several other industry participants joined Microsoft in keeping these specifications up to date with changes to the language and the platform, the most recent updates3 coming in 2012 for the CLI and 2017 for C#.\n\nWith the introduction of these specifications in 2001 came an unexpected side-effect: members of the open-source community began to examine building a \"clean-room\" implementation of them. While the CLI Specification didn't include any of the Windows-specific features (such as a deep COM integration) Microsoft wanted for backwards-compatibility and forwards-evolution for their existing developer base, the CLI Specification itself provided enough integration points to make it interesting to implement on other platforms. Miguel de Icaza, of GNOME fame, began one such project, calling it Mono.\n\nThe specification also gave Microsoft some room to do what some within the company had been looking to do for quite a while: provide a research and experimentation vehicle for the academic and research communities to explore. In 2002, Microsoft released a stripped-down version of the CLR source code, code-named \"Rotor,\" distributed under an open-source license they created, called the\n\n<sup>2</sup> ECMA, it should be noted, also owns the specification for the language commonly known as \"JavaScript,\" but is more rightly called \"ECMAScript,\" governed as ECMA-262.\n\n<sup>3</sup> CLI:<https://www.iso.org/standard/58046.html> and [http://www.ecma-international.org/publications/standards/](http://www.ecma-international.org/publications/standards/Ecma-335.htm) [Ecma-335.htm](http://www.ecma-international.org/publications/standards/Ecma-335.htm); C#: <http://www.ecma-international.org/publications/standards/Ecma-334.htm>\n\n![](_page_9_Picture_0.jpeg)\n\n\"Shared Source\" license, giving it the formal name \"Shared Source CLI\" or \"SSCLI.\" While Mono would remain the subject of only fleeting interest to some for many years, and Rotor of even less interest to those outside the .NET universe, the seeds of an open-source mindset were sown. Over time, Mono would be purchased by Novell, then spun out into its own company, Xamarin, which would faithfully parallel the work described by the specifications and periodically try out new ideas for the opensource community to consider.\n\nMicrosoft officially released the first version of C# and the CLR in 2002, and new versions came roughly three years apart after that: C# 2.0 in 2005, and C# 3.0 in 2008. Each was contained in a product release of Visual Studio, such that C# 2.0 and version 2.0 of the CLR runtime was released with Visual Studio 2005, and C# 3.0 and CLR 3.5 came with Visual Studio 2008. Microsoft then shifted to a two-year release cycle, with Visual Studio 2010, Visual Studio 2012, Visual Studio 2015, and most recently, Visual Studio 2017. However, the versions of C# and the CLR started falling out of lockstep with Visual Studio, deliberately, for a couple of reasons.\n\nThe first was that Microsoft had again seen the writing on the wall, so to speak, and was starting to unbundle its various parts of the .NET ecosystem into constituent, and independent, parts. F#, which first shipped \"out of the box\" in Visual Studio 2010, was the first of these to start down the opensource path, largely because having started life as a Microsoft Research project, it had never really embraced being commercialized (and therefore closed-source) in the first place. Microsoft started working shortly thereafter on an open-source rewrite of its entire compiler toolchain, code-named \"Roslyn.\" By the time of Visual Studio 2015, many parts of the core ecosystem were starting to ship independently, with Visual Studio releases serving only as a vehicle for developers to gather the parts of the ecosystem they desired more easily. Open-source package management (called NuGet), which began life well outside of the Visual Studio organization, was incorporated into Visual Studio so that NuGet came \"out of the box,\" much as support for Maven and Ant do in Java IDEs.\n\nMono, meanwhile, had started to gain some traction in an unusual place: gaming. In particular, the gaming toolkit Unity had expressed interest in Mono, and soon had the Mono framework running inside the Unity toolkit. Unity-based games could now be written in JavaScript (a distant fork of the JavaScript-on-.NET implementation that Microsoft had done back in 2001), C#, or even a Pythoninspired .NET language called Boo. Additionally, the open-source community produced another .NET implementation, the .NET Micro Framework, specifically aimed at embedded software systems and small-scale hardware such as the Arduino platform.\n\nAll of this, however, was the calm before the storm. In 2008, Microsoft announced that the source for ASP.NET (the servlet/JSP equivalent) would be accessible to anyone who wanted to look at it. It wasn't full open-source yet, though, in that they weren't accepting pull requests. It was, however, an important step, and in 2014 Microsoft took that final step: It announced that it would completely open-source all of .NET, hosting it on GitHub, and thus making it available to any platform and accept pull requests from any developer so inclined. A new .NET implementation would be completely open-source and hosted on GitHub, called .NET Core. It also announced the creation of the .NET Foundation, an industry consortium of groups dedicated to the growth of the .NET platform, in\n\n![](_page_10_Picture_0.jpeg)\n\nmuch the same fashion that the Java Community Process governs the continued growth of the Java platform4 .\n\nTo be sure, Microsoft made some missteps along the way, and definitely learned a few hard lessons about its relationship with the open-source community, but by late 2017, Microsoft was statistically the biggest contributor on GitHub (measured in terms of total numbers of contributors5 ), and all of its key components\u2014language, runtime, libraries, and many of its tools\u2014were available for download on GitHub.\n\nMicrosoft also started to get more serious about the cross-platform/portability aspects of the .NET ecosystem. Xamarin, which by 2009 had started producing tools that could cross-compile .NET bytecode into native applications for iOS and Android platforms (the catchy-named \"MonoDroid\" and less-catchy \"Mono for iOS\" toolkits), was flourishing, and Microsoft realized that a practical story for being able to share non-UI portions of code across multiple platforms was necessary if they wanted to avoid developer confusion.\n\nWhile the ECMA Specifications had discussed different \"profiles\" for levels of .NET standardization, these profiles were in many ways similar to their \"Java Standard Edition,\" \"Java Micro Edition,\" and \"Java Enterprise Edition\" cousins\u2014a little unwieldy in a number of ways, but most notably in that there wasn't really a good way to guarantee compatibility across platforms and implementation versions\u2014if code is compiled by the Java6 compiler, it is safe to assume that it will continue to run on the Java6 virtual machine from whence it was compiled, but the Java APIs do change from release to release, and this has tripped up the unwary Java developer from time to time.\n\nThus, in 2016, Microsoft announced the \".NET Standard 1.0\" profile, a collection not of relatively vague implementation documents, but an actual API standard, such that a developer who sought to build a library that could be used by a variety of different platforms (across a certain number of versions of that platform, even) could know that anything that implemented .NET Standard 1.0 would be able to consume that library, regardless of where that code is running\u2014on a web server, on a mobile device, or even on somebody's VR helmet (running a 3D interactive application written with Unity).\n\nWhich brings us, now, to the current day.\n\n<sup>4</sup> Ironically, Microsoft's move to the .NET Foundation comes at the same time Oracle is looking to move away from the JCP; both companies have experience with standards organizations, and neither wants to see innovation stifled in committee.\n\n<sup>5</sup> <http://www.businessinsider.com/microsoft-github-open-source-2016-9>\n\n![](_page_11_Picture_0.jpeg)", "<span id=\"page-11-0\"></span>Hello, strange new world": "To the Java developer, this is a strange, strange world compared to the one they glimpsed into back in 2000.\n\nFor starters, the Java world looks wildly different than it once did. Sun no longer exists, acquired by Oracle. Oracle and Google squabble in the courtroom over the legal implications of Java on Android devices. Spring was acquired, then spun out into its own company, Pivotal. JBoss absorbed into Red Hat. IBM no longer really even tries to push Java much anymore. Does anybody even remember EJB? Or that it was once \"a thing\"? Who would've guessed any of this back in 2001?\n\nBut meanwhile, over in the Microsoft world, a new CEO runs the firm, and he has made it clear that Microsoft is an open-source player. A new player, to be sure, and still finding its feet in a variety of ways, but one committed to the open-source community. In addition to the strides it has made with .NET, Microsoft has opened Azure up to almost every mainstream language and platform\u2014including Java. (Yes, you can run Tomcat and MySQL in an Azure cloud cluster.) SQL Server has been ported to Linux. Windows Server can be loaded into a Docker container, and Microsoft works with the Docker community to bring Docker-on-Windows up to the same level of sublime that it has on other platforms.\n\nWithin the .NET ecosystem, the .NET Standard, now at a 2.0 release, provides an umbrella of guaranteed compatibility across three major platforms of this writing: the Windows-based .NET Framework (which contains the necessary libraries for building Windows client applications, for example), .NET Core (intended for the cross-platform server world, including Docker containers and cloud-native targets), and Xamarin (principally aimed at the iOS and Android world, but also providing bindings for building macOS applications). Unity has joined the .NET Foundation and expects to be aligned with the various versions of .NET Standard by mid-2018.\n\nAll of which means that it's not a bad time to start exploring this world in more depth.\n\n![](_page_12_Picture_0.jpeg)"}}, "<span id=\"page-12-1\"></span><span id=\"page-12-0\"></span>Getting Started: Tooling": {"Hello, .NET: IDE style": {"Solutions and projects": "Within the Visual Studio ecosystem, code is arranged into \"projects,\" which are in turn collected into \"solutions.\" A project is language-specific, and sports an XML file whose extension reflects that language\u2014C# projects are stored in \".csproj\" files, for example. Each project produces one artifact an assembly, which we'll discuss in more detail later. Solutions, then, are made up of any number of projects listed in a solution file (.sln), making it quite common for a solution to have some toplevel \"executable\" (whether that is a website project, Web API project, or some form of GUI project) with one or more \"library\" projects to support it. It's extremely common, in fact, to see projects in separate subdirectories under the directory in which the solution file lives. This arrangement won't seem strange to the working Java developer; in many respects, this is no different from what we would see in a Java codebase, where some collection of code (project) produces a JAR file, and a Maven or Gradle build (solution) brings it all together into a bundle of some form.\n\nMicrosoft is working to keep all these file types in sync across all versions of Visual Studio, so that a project that builds on Visual Studio for Mac should also build on Windows, using an underlying build system called \"MSBuild.\" Heavily Ant-inspired, MSBuild has been the build system for .NET since\n\n![](_page_21_Picture_0.jpeg)\n\n<span id=\"page-21-0\"></span>Visual Studio 2005, and Xamarin was quick to adopt it for their project file system when they started building out their toolchain.", "Goodbye, HelloWorld": "Tooling is now installed. The Gods of Computer Science have been appeased by the creation of a successful HelloWorld application. It's time to take a pass across the C# language.\n\n.NET for Java Developers 19\n\n![](_page_22_Picture_0.jpeg)"}}, "<span id=\"page-22-0\"></span>C#, Succinctly": {"C# Basics": {"Starting exploration: classes, properties, and methods": "C# 1.0 was, in large measure, a near-direct clone of Java, with some keyword changes and some new features that Java has debated for years: explicit properties and delegates (an early form of lambda expressions). Thus, we can write the traditional \"Person\" type in C# like so:\n\n```\nclass Person\n{\n public string FirstName\n {\n get { return this.firstName; }\n set { this.firstName = value; }\n }\n private string firstName;\n public string LastName\n {\n get { return this.lastName; }\n set { this.lastName = value; }\n }\n private string lastName;\n public int Age\n {\n get { return this.age; }\n set { this.age = value; }\n```\n\n```\n }\n private int age;\n public Person(string fn, string ln, int a)\n {\n this.FirstName = fn;\n this.LastName = ln;\n this.Age = a;\n }\n}\n```\n\nProperties can be read-only by eliminating the \"set\" clause, and write-only (if that makes sense, which it rarely does) by eliminating the \"get\" clause. The implicit parameter to a \"set\" clause is always called \"value,\" and there are no restrictions to what a property-get or property-set clause can do within its body, although 95% of the time they simply read and write a field within the class.\n\nSo far, if anything, it seems more verbose than Java. However, that was the C# language as of 15 years ago\u2014they've made a few changes along the way.\n\nOne very common change is to the requirement to actually provide a body to the property-get and property-set clauses; as is the case in Java, 95% of the time these clauses simply wrap around a field and provide encapsulated access and nothing else. Which means, frankly, that the time spent writing the implementation for these is pretty much a waste of time (and something that IDEA or other IDEs can generate for us). The C# language designers agreed, and in C# 3.0 added the concept of \"autoimplemented properties,\" which asks the C# compiler to not only generate the property method implementations, but also synthesize the field used for the backing store. This simplifies the Person class down to:\n\n```\nclass Person\n{\n public string FirstName { get; set; }\n public string LastName { get; set; }\n public int Age { get; set; }\n public Person(string fn, string ln, int a)\n {\n this.FirstName = fn;\n this.LastName = ln;\n this.Age = a;\n }\n}\n```\n\n![](_page_25_Picture_0.jpeg)\n\nThat's\u2026awfully terse. But what about those scenarios where we want to have the property available to be read by anyone (public access), but only accessible for mutation from within the class (private access)? The get and set clauses can have different levels of access, the most common idiom being:\n\n```\nclass Person\n{\n public string FirstName { get; private set; }\n public string LastName { get; private set; }\n public int Age { get; private set; }\n public Person(string fn, string ln, int a)\n {\n this.FirstName = fn;\n this.LastName = ln;\n this.Age = a;\n }\n}\n```\n\nThis will effectively make the fields immutable from the outside yet still something we can change from the interior of the class. The field itself is synthesized by the compiler (usually with a straightforward name such as \"\\_\\_\\$<Person>\\$<FirstName>@5417,\" or something equally nonobvious), and won't be directly accessible by code. (Granted, one can always use System.Reflection the .NET direct equivalent to Java's java.lang.reflect package\u2014to access the field at runtime, but that's an awful lot of work to work around something that can be discarded at any time.) For those rare situations where the auto-generated properties don't do the right thing, C# developers can always \"drop back\" to writing the property clauses out longhand and wrapping a declared field.\n\nMethods, meanwhile, work pretty much the same way they do in Java, in terms of their declaration and syntax. Methods can be instance methods or static (although static method invocations must always go through the class name, whereas Java will allow calling a static method through an instance variable\u2014seriously, try it, it's weird), and parameters are declared in order with a type and a name:\n\n```\npublic class Person\n{\n public string FirstName { get; set; }\n public string LastName { get; set; }\n public int Age { get; set; }\n public Person(string fn, string ln, int a)\n {\n```\n\n```\n this.FirstName = fn;\n this.LastName = ln;\n this.Age = a;\n }\n public void SayHello(string recipient)\n {\n Console.WriteLine(\"Hello, {0}, I, {1}, say hello.\",\n recipient, FirstName);\n }\n}\nclass Program\n{\n static void Main(string[] args)\n {\n Person p = new Person(\"Ted\", \"Neward\", 46);\n p.SayHello(\"Fred\");\n }\n}\n```\n\nAs you can see, C# follows pretty much exactly the same rules that Java does for method declaration and invocation. But, again, C# allows for some interesting variations on this theme.\n\nFor starters, C# has had the concept of \"method literals\" since 1.0, though the syntax has changed over each successive revision of the language. The first step was \"delegates,\" essentially the ability to declare a method signature and then assign methods-on-object-instances to a given delegate instance, like so:\n\n```\nclass Person\n{\n // . . .\n public delegate void HelloProc(string recipient);\n public HelloProc IndirectSayHello;\n}\nclass Program\n{\n static void Main(string[] args)\n {\n Person p = new Person(\"Ted\", \"Neward\", 46);\n p.SayHello(\"Fred\");\n p.IndirectSayHello = p.SayHello;\n p.IndirectSayHello(\"Fred\");\n }\n}\n```\n\n![](_page_27_Picture_0.jpeg)\n\n<span id=\"page-27-0\"></span>This was a pretty verbose way of doing method-reference-capture, and with successive versions of C#, they simplified it, particularly once the .NET platform introduced generics. (Yes, C# has generics, yes they look syntactically almost identical to Java generics, but no, they don't work the same way when compiled\u2014where Java uses \"type erasure,\" C# uses \"reified generics\" and persists the generic definition all the way into the compiled bytecode.) The \"delegate\" keyword here introduces a new type\u2014a function pointer, if you will\u2014and we can declare an instance of the delegate on the Person class, assign a method to it, and invoke the assigned method through that delegate."}, "Lambdas, type inference, and extension classes": {"<span id=\"page-29-0\"></span>Language-INtegrated Query (LINQ)": "All of this led up to one of the signature moments for the C# compiler with the 3.0 release: Language-INtegrated Query, or LINQ, for short. To many in the Java community, LINQ represented everything that was wrong with Microsoft, accusing them of \"embedding SQL into the C# language\" and turning C# into a 4GL that was proprietarily bound to SQL Server. As the Jedi Master put it, \"Amazing\u2014every single part of that sentence is entirely incorrect.\" LINQ wasn't integrating SQL, it isn't about SQL Server, and it's actually built up around core language principles that had nothing to do with relational databases, much less integrated with SQL Server.\n\nLet's start by examining a simple collection of Person objects in a list:\n\n```\n var people = new List<Person>() {\n new Person(\"Ted\", \"Neward\", 45),\n new Person(\"Charlotte\", \"Neward\", 39),\n new Person(\"Michael\", \"Neward\", 24),\n new Person(\"Matthew\", \"Neward\", 18),\n new Person(\"Beth\", \"Massi\", 39),\n new Person(\"Dustin\", \"Campbell\", 43)\n };\n```\n\nSuppose I want to give everybody within this list a beer. Sharp readers will notice, of course, that my youngest son is not yet eligible to receive a beer, and this is a family-friendly article, so we don't want to get into trouble with the local authorities.\n\nWere this a discussion of Java8 lambdas, we would talk about using lambdas and streams to filter the collection before applying a higher-order function across each to give each individual a beer. (If that's new to you, Venkat Subramaniam has some great conference lectures online that describe Java8 lambdas in more detail.) As far back as C# 3.0, Microsoft saw the need, and chose not only to layer functional principles into the language, but to put a syntax in place that would actually hide the fact that this was ever functional programming in the first place:\n\n```\n var drinkers =\n from p in people\n where p.Age > 21\n select p;\n```\n\nThis is a LINQ query expression, and despite the fact that it looks similar to SQL, it's actually invoking several functional methods in sequence using a fluent interface; translated out of the SQL-like syntax, it looks more like:\n\n```\n drinkers = people.Where((p) => p.Age > 21);\n```\n\nAll of the traditional functional operations are present here\u2014map, filter, and the rest\u2014but they \"hide\" behind this query expression syntax. We'll talk more about the interesting features and implications of LINQ when we get to Entity Framework in the last section, but for now, just think of\n\n![](_page_30_Picture_0.jpeg)\n\n<span id=\"page-30-0\"></span>LINQ as a syntax that is designed to deliberately bring some of the set-oriented nature of SQL and the functional-oriented nature of languages such as Haskell into the C# language as a first-class citizen.\n\n(For anybody who really wants to see LINQ taken to an absolute extreme, it can be instructional to look at Luke Hoban's \"single-LINQ-expression-ray-tracer\" blog post from 10 years ago, available at [https://aka.ms/linqraytracer.](https://aka.ms/linqraytracer) It will send chills down your back, one way or another.)", "Asynchronous programming with Async/Await": "C# 4.0 introduced a number of interesting features, but C# 5.0 truly bucked the status quo by introducing language support for a form of asynchronous programming via the \"async\" and \"await\" keywords. While not a general-purpose, all-around concurrency feature, async/await added the ability to easily add \"little concurrency\" into common programming tasks such as issuing a request for a database query or executing a Web API request without having to manually manage the threads necessary to do so without blocking. Leveraging some work done elsewhere on the .NET platform (the Task Parallel Library, or TPL), C# essentially now allows developers to start some work and return a Task<T> object, which represents that additional work. At the source code level, \"async\" can decorate either a method signature or an anonymous method literal to indicate it should run asynchronously, and \"await\" tells the compiler to generate the code necessary to hold things in place until the asynchronous code completes. (Essentially, these are language-level implementations of \"promises,\" which are permeating the JavaScript world and slowly starting to gather steam in the Java world as well, under the name \"CompletableFuture\" out of the java.util.concurrent package in Java8.)\n\n```\nasync Task PlaySongsAsync(int[] ids)\n{\n foreach (var id in ids)\n {\n try\n {\n var data = await service.GetEncodedDataAsync(id);\n var song = await Task.Run(() => Decode(data));\n await PlayAsync(song);\n }\n catch (Exception e) { /* just skip the song */ }\n }\n}\n```\n\nThere is much, much more we can discuss with respect to C#, but then we'd have no time to talk about anything else, and there is much, much more to go over on our tour. Fortunately, Microsoft has a great collection of web resources on the language, starting with a page that lists an overall history of the language, available at [https://aka.ms/csharpwhatsnew,](https://aka.ms/csharpwhatsnew) and a general (if abbreviated) overview of the language available at [https://aka.ms/csharptour.](https://aka.ms/csharptour) And, of course, there're books. Lots and lots of books.\n\nBut once you know how to write code in this language, what can you do with it?\n\n![](_page_31_Picture_0.jpeg)"}}, "<span id=\"page-31-0\"></span>Frameworks, for the Win!": "By far and away, the most popular thing to do with C# and the .NET runtime is to build a web application of some form, just as it is with the Java language and runtime. To be sure, the .NET ecosystem supports more than this\u2014one can build desktop applications, mobile applications, and even games (using the aforementioned Unity framework, among others), but the lion's share of code written in C# is web applications.\n\nLike its twin, .NET offers a comprehensive framework of web functionality, ranging all the way from drag-and-drop-built user interface, to MVC-based server-side rendering, to the construction of HTTP-based APIs for invocation by single-page applications written in JavaScript or mobile applications. Somewhat confusingly, however, all three are referred to by the name \"ASP.NET.\"\n\n(Note to those who recognize the \"ASP\" moniker from the early days of the Sun/Microsoft rivalry: In the COM days, Microsoft's web technology was called \"Active Server Pages,\" ASP for short, named after ActiveX, one of the marketing names for COM. When Microsoft started working on the CLR internally, one of its most important consumers was the ASP team, who sought to create a system similar to JSP to replace ASP. Since the effort was to redo ASP in .NET, the name \"ASP.NET\" was coined. However, aside from the basic notion that \"this is for the web,\" there's little to no relationship between ASP.NET and its predecessor.)\n\nThe ASP.NET \"family\" is fundamentally broken into three parts, two of which we'll examine here (in brief):\n\n['ASP.NET WebForms, the first flavor of ASP.NET, released with .NET 1.0, featuring drag-and-drop user interface construction. It was designed to try to bring a VisualBasic-style design philosophy to the web, but by .NET 3.0, the Microsoft community had come to understand the design advantages of an MVC-style design approach, and all work on WebForms essentially ceased. Ironically, about the time that interest in WebForms was ending, the Java community was building up JSF, the equivalent to WebForms in Java.', 'ASP.NET MVC: Based on the classic \"Model-View-Controller\" principles that the Sun \"Model 2\" design for servlets and JSP first laid out, Microsoft created ASP.NET MVC, released the source code for it shortly after its initial release, and has considered this to be its first-class server-side web framework ever since. ASP.NET MVC was rebranded (and refactored) to be \"ASP.NET Core MVC\" in 2015, in keeping with the \".NET Core\" naming for the cross-platform runtime, and has made some conceptual shifts as new frameworks\u2014such as Ruby-on-Rails\u2014gained popularity and created some new patterns (such as routing tables).']\n\n![](_page_32_Picture_0.jpeg)\n\n<span id=\"page-32-0\"></span>\u2022 ASP.NET MVC Web API: While the name certainly gets no points for brevity, it does accurately reflect the idea that this framework is built off of the same concepts that underlie the ASP.NET MVC library, but with the intent of producing JSON data instead of HTML. When ASP.NET MVC was tagged with the \"Core\" moniker, the \"MVC\" was formally dropped from Web API projects, so that now they are simply \"ASP.NET Core Web API,\" or more informally, \"Web API\" projects.\n\nLet's have a look at a quick ASP.NET Core Web API application\u2014the ubiquitous TODO list\u2014and then we'll have a quick look at an MVC application before we look at Microsoft's data-storage framework, Entity Framework.\n\nASP.NET Core Web API\n\nTo get started with Core Web API, we first need to scaffold out the Web API template; this can be done either via \"File|New\" in one of the Visual Studio IDEs, or from the command-line using the .NET Core CLI tools by executing \"dotnet new webapi -o todoapi.\" This will create a subdirectory called \"todoapi\" and install the .NET Core Web API project inside of it. Out of the box, it scaffolds out a simple API that has one controller to hand back arbitrary \"value\" objects, accessible at [http://localhost:5000/api/values.](http://localhost:5000/api/values) Before we make any changes to the code, it's always good to make sure the scaffold is working, so execute a \"dotnet run\" from within the \"todoapi\" directory, and navigate to the given URL; the response should be a dirt-simple JSON array containing two strings.\n\nA Web API project, like its cousin the MVC application, is broken into models and controllers, with the \"view\" assumed to be an automated conversion from a model object into JSON. Thus, in a Web API project, the goal will be to accept incoming requests, perform the necessary business logic, and return the appropriate model type, usually corresponding to the resource type in the URL, to be converted to JSON.\n\nThe Controllers directory contains the code for the ValuesController, which is the default-scaffolded code. It doesn't use any model objects, which means it's clearly inferior. Let's delete it, and replace it with something that's a little more \"MV\"-like. That means, first of all, that we need a model object to represent a TODO item, which is a pretty simple domain object:\n\n```\npublic class Todo\n{\n public long ID { get; set; }\n public string Description { get; set; }\n public bool Completed { get; set; }\n public Todo()\n {\n Completed = false;\n }\n}\n```\n\n![](_page_33_Picture_0.jpeg)\n\n(Note that it would be a bit irregular to call this a POJO, since it's not a Java object, but that's basically exactly what this is. These are sometimes referred to as Plain Old C# Objects, POCOs, or, less often, Plain Old DotNet Objects or PODNOs. Definitely doesn't roll off the tongue like POJOs, but we do what we can.)\n\nHaving a domain object, it now remains to build a controller that will respond to the appropriate URL (which, by convention, will be prefixed by \"/api,\" but is of course configurable). The Web API expectation is that a controller will be a class that has a number of public methods that obey some conventions, in terms of both method names and parameter sets, like Java has done with later versions of the Servlet and EJB specifications.\n\n```\n [Route(\"api/[controller]\")]\n public class TodosController : Controller\n {\n private List<Todo> todos = new List<Todo>() {\n new Todo() { ID=0, Description=\"Get milk\", Completed=true },\n new Todo() { ID=1, Description=\"Get pet food\" },\n new Todo() { ID=2, Description=\"Learn .NET Core\" },\n new Todo() { ID=3, Description=\"Write billion-dollar app\" }\n };\n // GET api/todos\n [HttpGet]\n public IEnumerable<Todo> Get()\n {\n return todos;\n }\n // GET api/todos/5\n [HttpGet(\"{id}\")]\n public Todo Get(int id)\n {\n return todos.First((t) => t.ID == id);\n }\n // POST api/todos\n [HttpPost]\n public void Post([FromBody]Todo value)\n {\n todos.Add(value);\n }\n```\n\n![](_page_34_Picture_0.jpeg)\n\n```\n // PUT api/todos/5\n [HttpPut(\"{id}\")]\n public void Put(int id, [FromBody]Todo value)\n {\n var todo = todos.First((t) => t.ID == id);\n todo.Description = value.Description;\n todo.Completed = value.Completed;\n }\n // DELETE api/todos/5\n [HttpDelete(\"{id}\")]\n public void Delete(int id)\n {\n }\n }\n```\n\nTo understand this class, it's important to understand a few things: First, the square-bracketed declarations outside each method are what .NET calls \"custom attributes,\" which, true story, figured prominently in the design for JSR-175 annotations. The attributes provide information (via reflection, same way annotations do) about how HTTP verbs should match against the methods\u2014so, for example, the ASP.NET runtime can know that the two Get() methods should both be invoked when an incoming GET request is made.\n\nThe other half of that binding, of course, is knowing the partial URL pattern that should trigger the method. Notice that the controller class itself has an attribute, \"Routing,\" which contains the string \"api/[controller].\" The square-bracketed \"controller\" is to tell the ASP.NET runtime to use the name of the class, minus its \"-Controller\" suffix, so the URL pattern for all of these API endpoints is \"api/ todos.\" From here, standard REST conventions kick in\u2014a GET to \"api/todos\" should return all of the TODO items, so the Get() method taking no parameters and returning an IEnumerable<Todo> (think of it as a high-level iterator interface) is the right one to invoke here. If, on the other hand, a caller wants a single TODO, they'll issue a request with a URL pattern of \"api/todos/\" plus the ID of the TODO requested. The second Get() method indicates that the URL pattern includes \"{id},\" so \"api/ todos/3\" will extract \"3\" and pass it for the value of \"id\" to the method. Ditto for the Put and Delete methods.\n\nThe full details of routing are in the ASP.NET documentation, but this should be sufficient to understand what's happening here. To see the new controller in action, just do a \"dotnet run\" from the \"todoapi\" directory, and point an HTTP client (curl or Postman) at <http://localhost:5000/api/todos> to see the JSON representations handed back.\n\n![](_page_35_Picture_0.jpeg)\n\n<span id=\"page-35-0\"></span>ASP.NET Core MVC\n\nHTTP-based APIs are nice, but when we need a traditional server-side rendered application, ASP.NET provides a traditional MVC framework called (not surprisingly) ASP.NET Core MVC. It's the same MVC we find in most modern web frameworks; views are rendered using a particular template syntax, called \"Razor\" (or \"Razor pages\") that is designed to be expressive yet terse. It's a syntax inspired from other similar frameworks, particularly JSP and Ruby-on-Rails, but also tried to be reasonably familiar to generations of ASP and ASP.NET WebForms developers. Controllers look almost the same as they do in the API scenario, and models, of course, are just C# classes representing the domain.\n\nRazor templates use a .cshtml extension, and like JSP, they use different syntax to indicate which parts of the page are to be interpreted in a code-aware manner, as opposed to being taken literally as output format. Razor syntax uses the \"@\" symbol to set off code blocks or other processing statements in several different ways; for example, to do a simple \"for\" loop within a page, Razor uses an \"@for\" to set off the loop. Unlike JSP, however, the Razor syntax is clear enough that there isn't a need to require explicit symbols to set off between code and HTML output:\n\n```\n<h2>Welcome</h2>\n<ul>\n @for (int i = 0; i < 3; i++)\n {\n <li>Beetlejuice</li>\n }\n</ul>\n```\n\nViews, of course, can make use of objects and data provided by a controller, often by making use of a predefined key-value map called ViewData. If we want the message and the number of times it should be printed to be set up by a controller (perhaps the controller is obtaining it from HTML query parameters or a database), then the controller can set those by using the keys \"Message\" and \"NumTimes\" in the ViewData dictionary, respectively. The view can then display them like this:\n\n```\n<h2>Welcome</h2>\n<ul>\n @for (int i = 0; i < (int)ViewData[\"NumTimes\"]; i++)\n {\n <li>@ViewData[\"Message\"]</li>\n }\n</ul>\n```\n\nIn essence, ViewData is the ASP.NET equivalent to Servlet \"request\" scope.\n\n![](_page_36_Picture_0.jpeg)\n\nThe controller perspective that drives this looks remarkably similar to what a servlet controller would do, with a few differences:\n\n```\nusing Microsoft.AspNetCore.Mvc;\nusing System.Text.Encodings.Web;\nnamespace MvcMovie.Controllers\n{\n public class HelloWorldController : Controller\n {\n public IActionResult Welcome(string name, int numTimes = 1)\n {\n ViewData[\"Message\"] = \"Hello \" + name;\n ViewData[\"NumTimes\"] = numTimes;\n return View();\n }\n }\n}\n```\n\nNotice that the Welcome method takes two parameters, which will be filled in from HTML query parameters, fills in the ViewData dictionary, and then calls \"View,\" which then looks for a Razor page file whose name matches that of the method\u2014in this case, it will be looking for \"Welcome.cshtml.\" ASP.NET Core MVC has a number of ways to adjust and change these conventions, but out of the box, the convention-based approach makes it simpler and easier than the configuration descriptor approach of older Servlet versions.\n\nASP.NET Core MVC obviously consists of a great deal more than just what we've discussed here, but the underlying message should be clear: ASP.NET Core (both the MVC and the Web API versions) learned a great deal from its contemporaries, including those in the Servlet world (JSP, the Play framework, and more), and as such, it will be very straightforward for a Java developer to pick up and explore.\n\nFor those interested in a deeper dive into the code above, consider having a look into this tutorial: <https://aka.ms/first-web-api>.\n\n![](_page_37_Picture_0.jpeg)\n\n<span id=\"page-37-0\"></span>Entity Framework Core\n\nOf course, being able to access the server and pass JSON back and forth is only half the story; the other half is taking that data and storing it. Or rather, storing it, indexing it, searching it, collating it, sorting it, drawing pretty graphs with it, and more. When working with a relational database, the technology Microsoft offers its .NET constituents is called Entity Framework, or EF, and in many respects it works like any other object/relational mapping framework does. Thanks to some of the language features in C#, however, in many cases working with EF is actually easier than working with JPA or Hibernate.\n\nLike much in the .NET universe, Entity Framework is undergoing a bit of a reshuffle; what used to be a closed, proprietary source base is now open, and as EF was opened to the world, the project owners thought a (slight) rebrand seemed appropriate. As a result, the open-source version of EF is called \"Entity Framework Core,\" and to begin using it, we need to install it into the project via NuGet, either by using the Package Manager in Visual Studio, or by using the command-line for .NET Core by entering:\n\ndotnet add package Microsoft.EntityFrameworkCore.SqlServer\n\nThis is, of course, assuming we are using SQLServer\u2014since not everybody uses SQL Server, however, a number of different EF database providers are available, including MySQL, Postgres, SQLite, Firebase, and a few more. (Third-party vendors are constantly introducing new ones, in a manner similar to the JDBC driver ecosystem, so bear in mind that Microsoft may not even know all the EF providers in the world.)\n\nThere're a few \"management\" tasks that will be easier to do from the command-line, and EF has a command-line package that installs \"inside\" the standard .NET Core command-line tool, but as of this writing, making use of it requires adding a line by hand to the project's .csproj file:\n\n```\n<ItemGroup>\n <DotNetCliToolReference \n Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\"\n Version=\"2.0.0\" />\n</ItemGroup>\n```\n\nIn addition, the EF Core command-ling tooling requires another dependent package:\n\n```\ndotnet add package Microsoft.EntityFrameworkCore.Design\n```\n\nAt this point, EF should be installed and ready to go. More detailed instructions can be found on the Microsoft docs site at<https://aka.ms/ef-install>.\n\nFundamentally, the most critical element to using EF from a project is the DbContext. This is a class from which a project will create a derived class that represents the \"context\" for this project against the database\u2014it will be a repository, session, and gateway, all rolled into one. Like many object/ relational tools, it also provides some core behavior, including some migration capabilities (database versioning).\n\n![](_page_38_Picture_0.jpeg)\n\nLike Hibernate or JPA, EF uses classes to represent entities in the database, and these classes are often referred to as \"model\" objects, since they typically serve that purpose in an MVC and/or Web API application. These will usually look like \"plain old C# objects,\" with the odd custom attribute to help give EF some additional hints about how to map to the database table they represent.\n\nFor example, if the application is a blog, then we will want classes representing a blog, and blog post, representing a single blog entry. But there's also some blog metadata we might want to track that wouldn't be appropriate to store in the database (such as whether the blog was stored in the database), which we will want Entity Framework to ignore entirely. One way to do this is to use a custom attribute, or the EF Fluent API can indicate that the blog metadata class should be ignored using the \"OnModelCreating\" method, invoked when the database schema is created.\n\n```\npublic class BloggingContext : DbContext\n{\n public DbSet<Blog> Blogs { get; set; }\n protected override void OnModelCreating(ModelBuilder modelBuilder)\n {\n modelBuilder.Ignore<BlogMetadata>();\n }\n}\npublic class Blog\n{\n public int BlogId { get; set; }\n public string Url { get; set; }\n public List<Post> Posts { get; set; }\n public BlogMetadata Metadata { get; set; }\n}\npublic class Post\n{\n public int PostId { get; set; }\n public string Title { get; set; }\n public string Content { get; set; }\n public Blog Blog { get; set; }\n}\npublic class BlogMetadata\n{\n public DateTime LoadedFromDatabase { get; set; }\n}\n```\n\n![](_page_39_Picture_0.jpeg)\n\nThe \"Id\" fields, of course, are typically primary key integer columns in the database, and the List of Posts is a classic one-to-many relationship. All of this will be eminently familiar to any user of Hibernate, JPA, or other object-relational modeling system. What will be different will be the way in which queries and modifiers are run; thanks to LINQ, Entity Framework uses an entirely new style of query starting from the DbSet fields modeled on the DbContext-inheriting class. To do a query to fetch all the blogs from the system, we simply create an instance of the context inside of a \"using\" block (which is the inspiration for the try-with-resources block in Java7), and use that instance to obtain the set of Blog instances and iterate through them:\n\n```\nusing (var context = new BloggingContext())\n{\n foreach (var blog in context.Blogs) {\n // do something with the blog\n }\n}\n```\n\nContrary to what we experienced during the heyday of EJB Entity Beans, however, this isn't a case of early loading or late loading; under the hood, Entity Framework is making use of \"enumerator objects\" (very similar to Java8 streams and the Java Iterable<T> interface) to fetch objects in batches, just as a typical database cursor would do.\n\nIn the Java world, however, filtering that list of blogs to include only those that have \"dotnet\" in the URL presented problems\u2014either the filtering happens on the database side, in which case the query has to be translated to SQL, or the filtering happens on the client side, which means the entire collection has to be brought over the network. With LINQ, however, this looks like this:\n\n```\nusing (var context = new BloggingContext())\n{\n foreach (var blog in context.Blogs\n .Where(b => b.Url.Contains(\"dotnet\"))) {\n // do something with the blog\n }\n}\n```\n\nBut this has the same drawbacks as before; instead, we can use an \"expression tree,\" a feature of LINQ that compiles into a runtime structure that reflects the compiled code:\n\n```\nusing (var context = new BloggingContext())\n{\n var allDotnetBlogUrls = from blog in context.Blogs\n where blog.Url.Contains(\"dotnet\")\n select blog.Url;\n```\n\n![](_page_40_Picture_0.jpeg)\n\n```\n foreach (var url in allDotnetBlogUrls) {\n // do something with the blog URL\n // note we don't have the entire Blog, just the Url\n }\n}\n```\n\nThis \"from-where-select\" syntax that looks so much like SQL isn't; it's a syntax that's designed to look similar to SQL and offer many of the same kinds of operators and options. However, this isn't an SQL query\u2014it will not be sent to the database. Instead, the expression tree is analyzed\u2014and optimized by the EF plumbing to generate an efficient SQL statement, on a driver-by-driver basis. This means that the query filters and restrictions are analyzed on the client side, but sent to the database to be executed\u2014for example, the above turns into a \"SELECT url FROM blog WHERE\u2026\" using whatever primitives to do a string-containment check that the database and EF provider offers. This is really the best-of-both-worlds scenario. Couple that with the compile-time type checking that the C# compiler provides against the model objects, and you have a solution that is entirely new to the Java world. (Not impossible to provide, mind you, but still something the Java world currently lacks.)\n\nUpdates and modifications entail making modifications on the model object, and those changes will be sent to the database when the context object goes out of the using block's scope. To add a new blog, construct the object and add it to the DbSet on the context object; to remove it, use the context's DbSet again. And should you really, really want to write raw SQL, the context object provides that capacity.\n\nThere is, of course, much more to discuss about Entity Framework\u2014it's every bit as rich and powerful as JPA, and as such, definitely larger than just what we can cover in a single paper. For more examples of LINQ syntax, check out [https://aka.ms/101LinqSamples.](https://aka.ms/101LinqSamples) For 101 LINQ samples, and for more information on Entity Framework itself, head over to the EF documentation home at [https://docs.](https://docs.microsoft.com/ef/core/) [microsoft.com/ef/core/](https://docs.microsoft.com/ef/core/).\n\n![](_page_41_Picture_0.jpeg)", "<span id=\"page-41-0\"></span>Wrapping Up": "To suggest that this is somehow the end of the story is ludicrous. The .NET ecosystem holds a rich tapestry of open-source projects and commercial tools and frameworks, and that means that a developer could, if they wished, spend their entire career just discovering the boundaries there. We haven't even begun to discuss the alternative languages for the .NET platform, either from Microsoft (F#, an object/functional hybrid that fills the same role as Scala, or good old Visual Basic, one of the original dynamic languages) or from the community (check out Boo, a Python-inspired dynamic language). We haven't begun to explore the different open-source frameworks that do dependency injection. We haven't begun to explore the different frameworks for doing unit testing, or the online tooling from Microsoft to provide agile project support. We haven't even mentioned Azure.\n\nThis is a brave new land, intrepid adventurer, but rest easy: Much of what you know from your time in the world of Java will serve you well here. The concepts are similar, but different enough to be interesting. The platforms are powerful, and the communities open and inviting. The tools are easily obtained, and the tutorials plenty. You might even recognize a few familiar names, those who have come before you across the pond and gone on this adventure before you. Be the tourist, if you like, but know that there's plenty of room to build your own home and settle down here, even if it's only a summer home. Come in, and be welcome.\n\nAnd, unlike a certain young boy on his first trip to France, you won't have to worry about somebody's father trying to convince you that \"escargot\" is French for \"tater tots.\"\n\n.NET for Java Developers 39"}}