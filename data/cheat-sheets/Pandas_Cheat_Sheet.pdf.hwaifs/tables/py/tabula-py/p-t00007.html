<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>Plotting</th>
      <th>Frequently Used</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>df.plot()</td>
      <td>df.plot.scatter(x='w', y='h') df.plot.hist() df.plot.pie()</td>
      <td>Options</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Plot a line graph for the DataFrame.</td>
      <td>Plot a scatter graph of the DataFrame. Plot a histogram of the DataFrame. Plot a pie chart of the DataFrame.</td>
      <td></td>
    </tr>
    <tr>
      <th>2</th>
      <td></td>
      <td></td>
      <td>Pandas offers some ‘options’ to globally</td>
    </tr>
    <tr>
      <th>3</th>
      <td></td>
      <td></td>
      <td>control how Pandas behaves, display etc.</td>
    </tr>
    <tr>
      <th>4</th>
      <td></td>
      <td></td>
      <td>Options can be queried and set via:</td>
    </tr>
    <tr>
      <th>5</th>
      <td>df.plot.bar()</td>
      <td>df.plot.boxplot() df.plot.area() df.plot.hexbin()</td>
      <td>pd.options.option_name (where</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Plot a line graph for the DataFrame.</td>
      <td>Plot a scatter graph of the DataFrame. Plot an area graph of the DataFrame. Plot a hexbin graph of the DataFrame.</td>
      <td>option_name is the name of an option). For</td>
    </tr>
    <tr>
      <th>7</th>
      <td></td>
      <td></td>
      <td>example:</td>
    </tr>
    <tr>
      <th>8</th>
      <td></td>
      <td></td>
      <td>pd.options.display.max_rows = 20</td>
    </tr>
    <tr>
      <th>9</th>
      <td></td>
      <td></td>
      <td>Set the display.max_rows option to 20</td>
    </tr>
    <tr>
      <th>10</th>
      <td>df.plot(subplots=True)</td>
      <td>df.plot(cumulative=True) df.plot(stacked=True)</td>
      <td>Functions</td>
    </tr>
    <tr>
      <th>11</th>
      <td>Separate into different graphs for each column in</td>
      <td>Creates a cumulative plot Stacks the data for the columns on top of each</td>
      <td>get_option(option)</td>
    </tr>
    <tr>
      <th>12</th>
      <td>the DataFrame.</td>
      <td>df.plot(bins=30) other. (bar, barh and area only)</td>
      <td>Fetch the value of the given option.</td>
    </tr>
    <tr>
      <th>13</th>
      <td>df.plot(title=“Graph of A against B”)</td>
      <td>Set the number of bins into which data is grouped df.plot(alpha=0.5)</td>
      <td>set_option(option)</td>
    </tr>
    <tr>
      <th>14</th>
      <td>Sets the title of the graph.</td>
      <td>(histograms) Sets the transparency of the plot to 50%.</td>
      <td>Set the value of the given option.</td>
    </tr>
    <tr>
      <th>15</th>
      <td></td>
      <td></td>
      <td>reset_option(options)</td>
    </tr>
    <tr>
      <th>16</th>
      <td>df.plot(subplots=True, title=['col1', 'col2', 'col3'])</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>17</th>
      <td></td>
      <td></td>
      <td>Reset the values of all given options to</td>
    </tr>
    <tr>
      <th>18</th>
      <td>Arguments can be combined for more flexibility when graphing, this would plot a separate line graph for of column of a 3 -columned DataFrame. The first string in the</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>19</th>
      <td></td>
      <td></td>
      <td>default settings.</td>
    </tr>
    <tr>
      <th>20</th>
      <td>list of titles applies to the graph of the left-most column.</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>21</th>
      <td></td>
      <td></td>
      <td>describe_option(options)</td>
    </tr>
    <tr>
      <th>22</th>
      <td></td>
      <td></td>
      <td>Print descriptions of given options.</td>
    </tr>
    <tr>
      <th>23</th>
      <td>Changing Type</td>
      <td>Series String Operations</td>
      <td>option_context(options)</td>
    </tr>
    <tr>
      <th>24</th>
      <td></td>
      <td></td>
      <td>Execute code with temporary option</td>
    </tr>
    <tr>
      <th>25</th>
      <td></td>
      <td>Similar to python string operations, except these are vectorized to apply to the</td>
      <td></td>
    </tr>
    <tr>
      <th>26</th>
      <td>pd.to_numeric(data)</td>
      <td>df.astype(type)</td>
      <td>settings that revert to prior settings after</td>
    </tr>
    <tr>
      <th>27</th>
      <td></td>
      <td>entire Series efficiently.</td>
      <td></td>
    </tr>
    <tr>
      <th>28</th>
      <td>Convert non-numeric types to</td>
      <td>Convert data to (almost) any given s.str.count(pattern) s.str.cat()</td>
      <td>execution.</td>
    </tr>
    <tr>
      <th>29</th>
      <td>numeric.</td>
      <td>type including categorical Returns a series with the integer Concatenate elements into a single</td>
      <td>Display options</td>
    </tr>
    <tr>
      <th>30</th>
      <td>pd.to_datetime(data)</td>
      <td>df.infer_objects() counts in each element. string</td>
      <td>display.max_rows</td>
    </tr>
    <tr>
      <th>31</th>
      <td>Convert non-datetime types to</td>
      <td>Attempts to infer a better type for s.str.get(index) s.str.partition(sep)</td>
      <td>The maximum number of rows displayed</td>
    </tr>
    <tr>
      <th>32</th>
      <td>datetime type</td>
      <td>object type data. Returns a series with the data at the Splits the string on the first instance</td>
      <td>in pretty-print.</td>
    </tr>
    <tr>
      <th>33</th>
      <td>pd.to_timedelta(data)</td>
      <td>df.convert_dtypes() given index for each element. of the separator</td>
      <td>display.max_columns</td>
    </tr>
    <tr>
      <th>34</th>
      <td>Convert non- timedelta types to</td>
      <td>Convert columns to best possible s.str.join(sep) s.str.slice(start, stop,</td>
      <td>The maximum number of columns</td>
    </tr>
    <tr>
      <th>35</th>
      <td>timedelta</td>
      <td>dtypes Returns a series where each element step)</td>
      <td>displayed in pretty-print.</td>
    </tr>
    <tr>
      <th>36</th>
      <td></td>
      <td>has been concatenated. Slices each string</td>
      <td>display.expand_frame_repr</td>
    </tr>
    <tr>
      <th>37</th>
      <td>Datetime</td>
      <td>s.str.title() s.dt.day Converts the first character of each s.str.replace(pat, rep) Use regex to replace patterns in each</td>
      <td>Controls whether the DataFrame representation stretches across pages.</td>
    </tr>
    <tr>
      <th>38</th>
      <td></td>
      <td>Extract the day (int) from the date.</td>
      <td></td>
    </tr>
    <tr>
      <th>39</th>
      <td>display.large_reprWith a Series containing data of type</td>
      <td>word to be a capital. s.dt.quarterstring.</td>
      <td></td>
    </tr>
    <tr>
      <th>40</th>
      <td>datetime, the dt accessor is used to get</td>
      <td>s.str.len() s.str.isalnum()</td>
      <td>Controls whether a DataFrame that</td>
    </tr>
    <tr>
      <th>41</th>
      <td></td>
      <td>Find which quarter the date lies in.</td>
      <td></td>
    </tr>
    <tr>
      <th>42</th>
      <td>various components of the datetime</td>
      <td>Returns a series with the lengths of Checks whether each element is</td>
      <td>exceeds maximum rows/columns is</td>
    </tr>
    <tr>
      <th>43</th>
      <td></td>
      <td>s.dt.hour</td>
      <td></td>
    </tr>
    <tr>
      <th>44</th>
      <td>values:</td>
      <td>each element. alpha-numeric</td>
      <td>truncated or summarized</td>
    </tr>
    <tr>
      <th>45</th>
      <td></td>
      <td>Extract the hour.</td>
      <td></td>
    </tr>
    <tr>
      <th>46</th>
      <td>s.dt.year</td>
      <td>s.dt.minute</td>
      <td>display.precision</td>
    </tr>
    <tr>
      <th>47</th>
      <td>Extract the year</td>
      <td>Extract the minute.Input/Output</td>
      <td>The output display precision in decimal</td>
    </tr>
    <tr>
      <th>48</th>
      <td>s.dt.month</td>
      <td></td>
      <td>places.</td>
    </tr>
    <tr>
      <th>49</th>
      <td></td>
      <td>s.dt.second</td>
      <td></td>
    </tr>
    <tr>
      <th>50</th>
      <td>Extract the month as an integer.</td>
      <td>Common file types for data input include CSV, JSON, HTML which are human- Extract the second.</td>
      <td>display.max_colwidth</td>
    </tr>
    <tr>
      <th>51</th>
      <td></td>
      <td>readable, while the common output types are usually more optimized for</td>
      <td>The maximum width of columns, longer</td>
    </tr>
    <tr>
      <th>52</th>
      <td></td>
      <td>performance and scalability such as feather, parquet and HDF.</td>
      <td>cells will be truncated.</td>
    </tr>
    <tr>
      <th>53</th>
      <td>Mapping</td>
      <td>df = pd.read_csv(filepath) df.to_parquet(filepath)</td>
      <td>display.max_info_columns</td>
    </tr>
    <tr>
      <th>54</th>
      <td></td>
      <td>Read data from csv file Write data to parquet file</td>
      <td>The maximum number of columns</td>
    </tr>
    <tr>
      <th>55</th>
      <td>Apply a mapping to every element in a DataFrame or Series, useful for</td>
      <td>df = pd.read_html(filepath) df.to_feather(filepath)</td>
      <td>displayed after calling info().</td>
    </tr>
    <tr>
      <th>56</th>
      <td>recategorizing or transforming data.</td>
      <td>Read data from html file Write data to feather file</td>
      <td>display.chop_threshold</td>
    </tr>
    <tr>
      <th>57</th>
      <td></td>
      <td>df = pd.read_excel(filepath) df.to_hdf(filepath)</td>
      <td>Sets the rounding threshold to zero when</td>
    </tr>
  </tbody>
</table>