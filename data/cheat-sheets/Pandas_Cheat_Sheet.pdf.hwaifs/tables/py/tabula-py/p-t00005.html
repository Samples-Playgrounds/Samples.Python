<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Group Data</th>
      <th>Unnamed: 0</th>
      <th>Combine Data Sets</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>df.groupby(by="col")</td>
      <td>The examples below can also be applied to groups. In this case, the</td>
      <td></td>
    </tr>
    <tr>
      <th>1</th>
      <td>Return a GroupBy object, grouped</td>
      <td>function is applied on a per-group basis, and the returned vectors</td>
      <td>adf bdf</td>
    </tr>
    <tr>
      <th>2</th>
      <td></td>
      <td></td>
      <td>x1 x2 x1 x3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>by values in column named "col".</td>
      <td>are of the length of the original DataFrame.</td>
      <td></td>
    </tr>
    <tr>
      <th>4</th>
      <td></td>
      <td></td>
      <td>A 1 A T</td>
    </tr>
    <tr>
      <th>5</th>
      <td></td>
      <td>shift(1) shift(-1)</td>
      <td>B 2 B F</td>
    </tr>
    <tr>
      <th>6</th>
      <td>df.groupby(level="ind")</td>
      <td>Copy with values shifted by 1. Copy with values lagged by 1.</td>
      <td>C 3 D T</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Return a GroupBy object, grouped</td>
      <td>rank(method='dense') cumsum()</td>
      <td></td>
    </tr>
    <tr>
      <th>8</th>
      <td>by values in index level named</td>
      <td>Standard JoinsRanks with no gaps. Cumulative sum.</td>
      <td></td>
    </tr>
    <tr>
      <th>9</th>
      <td>"ind".</td>
      <td>rank(method='min') cummax()</td>
      <td>x1 x2 x3 pd.merge(adf, bdf,</td>
    </tr>
    <tr>
      <th>10</th>
      <td></td>
      <td>Ranks. Ties get min rank. Cumulative max.</td>
      <td>A 1 T how='left', on='x1')</td>
    </tr>
    <tr>
      <th>11</th>
      <td>All of the summary functions listed above can be applied to a group.</td>
      <td>rank(pct=True) cummin()</td>
      <td>B 2 F Join matching rows from bdf to adf.</td>
    </tr>
    <tr>
      <th>12</th>
      <td>Additional GroupBy functions:</td>
      <td>Ranks rescaled to interval [0, 1]. Cumulative min.</td>
      <td>C 3 NaN</td>
    </tr>
    <tr>
      <th>13</th>
      <td>size() agg(function)</td>
      <td>rank(method='first') cumprod()</td>
      <td></td>
    </tr>
    <tr>
      <th>14</th>
      <td>Size of each group. Aggregate group using function.</td>
      <td>Ranks. Ties go to first value. Cumulative product.</td>
      <td>x1 x2 x3 pd.merge(adf, bdf,</td>
    </tr>
    <tr>
      <th>15</th>
      <td></td>
      <td></td>
      <td>A 1.0 T how='right', on='x1')</td>
    </tr>
    <tr>
      <th>16</th>
      <td>Summarize Data</td>
      <td>Handling Missing Data</td>
      <td>B D NaN 2.0 TF Join matching rows from adf to bdf.</td>
    </tr>
    <tr>
      <th>17</th>
      <td>df['w'].value_counts()</td>
      <td>df.dropna()</td>
      <td></td>
    </tr>
    <tr>
      <th>18</th>
      <td>Count number of rows with each unique value of variable</td>
      <td>Drop rows with any column having NA/null data.</td>
      <td>x1 x2 x3pd.merge(adf, bdf,</td>
    </tr>
    <tr>
      <th>19</th>
      <td>len(df)</td>
      <td>df.fillna(value)</td>
      <td>A 1 Thow='inner', on='x1')</td>
    </tr>
    <tr>
      <th>20</th>
      <td># of rows in DataFrame.</td>
      <td>Replace all NA/null data with value.</td>
      <td>B 2 FJoin data. Retain only rows in both sets.</td>
    </tr>
    <tr>
      <th>21</th>
      <td>df.shape</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>22</th>
      <td>Tuple of # of rows, # of columns in DataFrame.</td>
      <td>Make New Columns</td>
      <td>x1 x2 x3 pd.merge(adf, bdf,</td>
    </tr>
    <tr>
      <th>23</th>
      <td>df['w'].nunique()</td>
      <td></td>
      <td>A 1 T how='outer', on='x1')</td>
    </tr>
    <tr>
      <th>24</th>
      <td># of distinct values in a column.</td>
      <td></td>
      <td>B 2 F Join data. Retain all values, all rows.</td>
    </tr>
    <tr>
      <th>25</th>
      <td>df.describe()</td>
      <td></td>
      <td>C 3 NaN</td>
    </tr>
    <tr>
      <th>26</th>
      <td>Basic descriptive and statistics for each column (or GroupBy).</td>
      <td></td>
      <td>D NaN T</td>
    </tr>
    <tr>
      <th>27</th>
      <td>df.info()</td>
      <td></td>
      <td>Filtering Joins</td>
    </tr>
    <tr>
      <th>28</th>
      <td>Prints a concise summary of the DataFrame.</td>
      <td>df.assign(Area=lambda df: df.Length*df.Height)</td>
      <td>x1 x2 adf[adf.x1.isin(bdf.x1)]</td>
    </tr>
    <tr>
      <th>29</th>
      <td>df.memory_usage()</td>
      <td>Compute and append one or more new columns.</td>
      <td>A 1 All rows in adf that have a match in bdf.</td>
    </tr>
    <tr>
      <th>30</th>
      <td>Prints the memory usage of each column in the DataFrame.</td>
      <td>df['Volume'] = df.Length*df.Height*df.Depth</td>
      <td>B 2</td>
    </tr>
    <tr>
      <th>31</th>
      <td>df.dtypes()</td>
      <td>Add single column.</td>
      <td></td>
    </tr>
    <tr>
      <th>32</th>
      <td>Prints a Series with the dtype of each column in the DataFrame.</td>
      <td>pd.qcut(df.col, n, labels=False)</td>
      <td>x1 x2 adf[~adf.x1.isin(bdf.x1)]</td>
    </tr>
    <tr>
      <th>33</th>
      <td></td>
      <td>Bin column into n buckets.</td>
      <td>C 3 All rows in adf that do not have a match in bdf.</td>
    </tr>
  </tbody>
</table>