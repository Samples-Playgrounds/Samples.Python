<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>[c | c [minBound .. maxBound]</th>
      <th>Unnamed: 0</th>
      <th>Unnamed: 1</th>
      <th>Of course,</th>
      <th>full</th>
      <th>pattern</th>
      <th>matching,</th>
      <th>guards,</th>
      <th>etc.</th>
      <th>are</th>
      <th>Unnamed: 2</th>
      <th>in xl 7 `mult1`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>, isUpper c]</td>
      <td></td>
      <td></td>
      <td>available in this form. Type signatures are a bit dif-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>mult1 a b = a * b</td>
    </tr>
    <tr>
      <th>1</th>
      <td></td>
      <td></td>
      <td></td>
      <td>ferent, though.</td>
      <td></td>
      <td>The operator “name” must appear</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>2</th>
      <td>Or, to find all occurrences of a particular</td>
      <td>break</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>3</th>
      <td></td>
      <td></td>
      <td></td>
      <td>in parentheses:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>The results are surprisi</td>
    </tr>
    <tr>
      <th>4</th>
      <td>value br in a list word (indexing from 0):</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>5</th>
      <td></td>
      <td></td>
      <td></td>
      <td>(##) :: String</td>
      <td></td>
      <td>String</td>
      <td>String</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>&gt; 2 + 3 * 5</td>
    </tr>
    <tr>
      <th>6</th>
      <td>idxs word br =</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>17</td>
    </tr>
    <tr>
      <th>7</th>
      <td>[i | (i, c) zip [0..] word</td>
      <td></td>
      <td></td>
      <td>Allowable symbols which can be used to define op-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>&gt; 2 `plus1` 3 `mult1` 5</td>
    </tr>
    <tr>
      <th>8</th>
      <td>, c br]</td>
      <td></td>
      <td></td>
      <td>erators are:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>25</td>
    </tr>
    <tr>
      <th>9</th>
      <td>A unique feature of list comprehensions is that pat-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>10</th>
      <td></td>
      <td></td>
      <td></td>
      <td># $ % &amp; * +</td>
      <td></td>
      <td>/ &lt; = &gt; ? @</td>
      <td>^ | - ~</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Reversing associativity</td>
    </tr>
    <tr>
      <th>11</th>
      <td>tern matching failures do not cause an error;</td>
      <td>they</td>
      <td></td>
      <td>However, there are several “operators” which can-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Redefining division as r</td>
    </tr>
    <tr>
      <th>12</th>
      <td>are just excluded from the resulting list.</td>
      <td></td>
      <td></td>
      <td>not be redefined.</td>
      <td></td>
      <td>They are: &lt;-, -&gt; and =.</td>
      <td></td>
      <td></td>
      <td>The last,</td>
      <td></td>
      <td></td>
      <td>in xr 7 `div1`</td>
    </tr>
    <tr>
      <th>13</th>
      <td></td>
      <td></td>
      <td></td>
      <td>=, cannot be redefined by itself, but can be used as</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>div1 a b = a / b</td>
    </tr>
    <tr>
      <th>14</th>
      <td>Operators</td>
      <td></td>
      <td></td>
      <td>part of multi-character operator.</td>
      <td></td>
      <td></td>
      <td>The “bind” func-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>15</th>
      <td></td>
      <td></td>
      <td></td>
      <td>tion, &gt;&gt;=, is one example.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>We get interesting resul</td>
    </tr>
    <tr>
      <th>16</th>
      <td>There are very few predefined “operators”</td>
      <td>in</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>17</th>
      <td>Haskell—most that appear predefined are actually</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>&gt; 20 / 2 / 2</td>
    </tr>
    <tr>
      <th>18</th>
      <td></td>
      <td></td>
      <td></td>
      <td>Precedence</td>
      <td>&amp;</td>
      <td>Associativity</td>
      <td></td>
      <td>The precedence</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>19</th>
      <td>syntax (e.g., “=”). Instead, operators are simply</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>20</th>
      <td></td>
      <td></td>
      <td></td>
      <td>and associativity,</td>
      <td></td>
      <td>collectively</td>
      <td>called</td>
      <td>fixity,</td>
      <td>of</td>
      <td>any</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>21</th>
      <td>functions that take two arguments and have</td>
      <td>spe-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>&gt; 20 `div1` 2 `div1` 2</td>
    </tr>
    <tr>
      <th>22</th>
      <td></td>
      <td></td>
      <td></td>
      <td>operator can be set through the infix, infixr and</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>23</th>
      <td>cial syntactic support. Any so-called operator can</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>20.0</td>
    </tr>
  </tbody>
</table>