<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>creates synonyms, newtype falls</th>
      <th>somewhere</th>
      <th>be-</th>
      <th>Unnamed: 0</th>
      <th>Unnamed: 1</th>
      <th>Unnamed: 2</th>
      <th>Unnamed: 3</th>
      <th>Unnamed: 4</th>
      <th>Unnamed: 5</th>
      <th>Unnamed: 6</th>
      <th>Because type is</th>
      <th>just</th>
      <th>a</th>
      <th>synonym,</th>
      <th>it</th>
      <th>cannot declare</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>tween. The syntax for newtype is quite restricted—</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>multiple constructors the way data can.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Type vari-</td>
    </tr>
    <tr>
      <th>1</th>
      <td>only one constructor can be defined, and that con-</td>
      <td></td>
      <td></td>
      <td></td>
      <td>Return</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>ables can be used,</td>
      <td>but</td>
      <td></td>
      <td>there cannot</td>
      <td></td>
      <td>be more than</td>
    </tr>
    <tr>
      <th>2</th>
      <td>structor can only take one argument.</td>
      <td>Continuing</td>
      <td></td>
      <td></td>
      <td>See do on page 4.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>the type variables declared with the original</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>type.</td>
    </tr>
    <tr>
      <th>3</th>
      <td>the above example, we can define a Phone</td>
      <td>type as</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>That means a synonym like the following is possi-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>4</th>
      <td>follows:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>ble:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>5</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Type</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>6</th>
      <td>newtype Home = H String</td>
      <td></td>
      <td></td>
      <td></td>
      <td>This keyword defines a</td>
      <td>type</td>
      <td>synonym</td>
      <td>(i.e.,</td>
      <td>alias).</td>
      <td></td>
      <td>type NotSure a = Maybe a</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>7</th>
      <td>newtype Work = W String</td>
      <td></td>
      <td></td>
      <td></td>
      <td>This keyword does not define a new type, like data</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>8</th>
      <td>data Phone = Phone Home Work</td>
      <td></td>
      <td></td>
      <td></td>
      <td>or newtype. It is useful for documenting code but</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>but this not:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>9</th>
      <td>type NotSure a b = Maybe aAs opposed to type, the H and W</td>
      <td>“values”</td>
      <td>on</td>
      <td></td>
      <td>otherwise has no effect on the actual type of a given</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>10</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>function or value. For example, a Person data type</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>11</th>
      <td>Phone are not just String values.</td>
      <td>The typechecker</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>12</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>could be defined as:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Note that fewer</td>
      <td>type</td>
      <td>variables</td>
      <td>can</td>
      <td>be</td>
      <td>used, which</td>
    </tr>
    <tr>
      <th>13</th>
      <td>treats them as entirely new types.</td>
      <td>That means our</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>useful in certain instances.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>14</th>
      <td>lowerName function from above would not compile.</td>
      <td></td>
      <td></td>
      <td></td>
      <td>data Person = Person String String</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>15</th>
      <td>The following produces a type error:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>16</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Wherewhere the first constructor</td>
      <td></td>
      <td>argument</td>
      <td>represents</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>17</th>
      <td>lPhone (Phone hm wk) =</td>
      <td></td>
      <td></td>
      <td></td>
      <td>their first name and the</td>
      <td>second</td>
      <td>their</td>
      <td>last.</td>
      <td>How-</td>
      <td></td>
      <td>Similar to let, where</td>
      <td></td>
      <td></td>
      <td>defines local</td>
      <td></td>
      <td>functions and</td>
    </tr>
    <tr>
      <th>18</th>
      <td>Phone (lower hm) (lower wk)</td>
      <td></td>
      <td></td>
      <td></td>
      <td>ever, the order and meaning of the two arguments</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>constants. The</td>
      <td>scope</td>
      <td></td>
      <td>of a where definition</td>
      <td></td>
      <td>is the</td>
    </tr>
    <tr>
      <th>19</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>is not very clear. A type declaration can help:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>current function.</td>
      <td>If a function is broken into multi-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>20</th>
      <td>Instead, we must use pattern-matching to get to the</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>21</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>ple definitions through pattern-matching, then the</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>22</th>
      <td>“values” to which we apply lower:</td>
      <td></td>
      <td></td>
      <td></td>
      <td>type FirstName = String</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>23</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>scope of a particular where</td>
      <td></td>
      <td></td>
      <td>clause</td>
      <td></td>
      <td>only applies to</td>
    </tr>
    <tr>
      <th>24</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>type LastName = String</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>25</th>
      <td>lPhone (Phone (H hm) (W wk)) =</td>
      <td></td>
      <td></td>
      <td></td>
      <td>data Person = Person FirstName LastName</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>that definition.</td>
      <td>For</td>
      <td>example,</td>
      <td>the</td>
      <td>function result</td>
      <td></td>
    </tr>
    <tr>
      <th>26</th>
      <td>Phone (H (lower hm)) (W (lower wk))</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>below has a different</td>
      <td></td>
      <td></td>
      <td>meaning depending</td>
      <td></td>
      <td>on the</td>
    </tr>
    <tr>
      <th>27</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Because type introduces a synonym, type checking</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>arguments given to the function strlen:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>28</th>
      <td>The key observation is that this keyword does not</td>
      <td></td>
      <td></td>
      <td></td>
      <td>is not affected in any way.</td>
      <td>The function lower, de-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>29</th>
      <td>introduce a new value; instead it introduces a new</td>
      <td></td>
      <td></td>
      <td></td>
      <td>fined as:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>strlen [] = result</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>30</th>
      <td>type. This gives us two very useful properties:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>where result = "No string given!"</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>31</th>
      <td>• No runtime cost is associated</td>
      <td>with the new</td>
      <td></td>
      <td></td>
      <td>lower s = map toLower s</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>strlen f = result ++ " characters long!"</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>32</th>
      <td>type, since it does not actually produce new</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>where result = show (length f)</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>33</th>
      <td>which has the typevalues. In other words, newtypes</td>
      <td>are abso-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>34</th>
      <td>lutely free!</td>
      <td></td>
      <td></td>
      <td></td>
      <td>lower :: String String</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Where vs. Let</td>
      <td>A where clause can only be de-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>35</th>
      <td>• The type-checker is able to enforce that com-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>fined at the level of a function definition.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>Usually,</td>
    </tr>
    <tr>
      <th>36</th>
      <td>mon types such as Int or String are used in</td>
      <td></td>
      <td></td>
      <td></td>
      <td>can be used on values with the type FirstName or</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>that is identical to the scope of let definition.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>The</td>
    </tr>
  </tbody>
</table>