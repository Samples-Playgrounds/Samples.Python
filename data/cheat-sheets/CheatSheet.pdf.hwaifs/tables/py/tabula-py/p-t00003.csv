,"creates synonyms, newtype falls",somewhere,be-,Unnamed: 0,Unnamed: 1,Unnamed: 2,Unnamed: 3,Unnamed: 4,Unnamed: 5,Unnamed: 6,Because type is,just,a,"synonym,",it,cannot declare
0,tween. The syntax for newtype is quite restricted—,,,,,,,,,,multiple constructors the way data can.,,,,,Type vari-
1,"only one constructor can be defined, and that con-",,,,Return,,,,,,"ables can be used,",but,,there cannot,,be more than
2,structor can only take one argument.,Continuing,,,See do on page 4.,,,,,,the type variables declared with the original,,,,,type.
3,"the above example, we can define a Phone",type as,,,,,,,,,That means a synonym like the following is possi-,,,,,
4,follows:,,,,,,,,,,ble:,,,,,
5,,,,,Type,,,,,,,,,,,
6,newtype Home = H String,,,,This keyword defines a,type,synonym,"(i.e.,",alias).,,type NotSure a = Maybe a,,,,,
7,newtype Work = W String,,,,"This keyword does not define a new type, like data",,,,,,,,,,,
8,data Phone = Phone Home Work,,,,or newtype. It is useful for documenting code but,,,,,,but this not:,,,,,
9,"type NotSure a b = Maybe aAs opposed to type, the H and W",“values”,on,,otherwise has no effect on the actual type of a given,,,,,,,,,,,
10,,,,,"function or value. For example, a Person data type",,,,,,,,,,,
11,Phone are not just String values.,The typechecker,,,,,,,,,,,,,,
12,,,,,could be defined as:,,,,,,Note that fewer,type,variables,can,be,"used, which"
13,treats them as entirely new types.,That means our,,,,,,,,,useful in certain instances.,,,,,
14,lowerName function from above would not compile.,,,,data Person = Person String String,,,,,,,,,,,
15,The following produces a type error:,,,,,,,,,,,,,,,
16,,,,,Wherewhere the first constructor,,argument,represents,,,,,,,,
17,lPhone (Phone hm wk) =,,,,their first name and the,second,their,last.,How-,,"Similar to let, where",,,defines local,,functions and
18,Phone (lower hm) (lower wk),,,,"ever, the order and meaning of the two arguments",,,,,,constants. The,scope,,of a where definition,,is the
19,,,,,is not very clear. A type declaration can help:,,,,,,current function.,If a function is broken into multi-,,,,
20,"Instead, we must use pattern-matching to get to the",,,,,,,,,,,,,,,
21,,,,,,,,,,,"ple definitions through pattern-matching, then the",,,,,
22,“values” to which we apply lower:,,,,type FirstName = String,,,,,,,,,,,
23,,,,,,,,,,,scope of a particular where,,,clause,,only applies to
24,,,,,type LastName = String,,,,,,,,,,,
25,lPhone (Phone (H hm) (W wk)) =,,,,data Person = Person FirstName LastName,,,,,,that definition.,For,"example,",the,function result,
26,Phone (H (lower hm)) (W (lower wk)),,,,,,,,,,below has a different,,,meaning depending,,on the
27,,,,,"Because type introduces a synonym, type checking",,,,,,arguments given to the function strlen:,,,,,
28,The key observation is that this keyword does not,,,,is not affected in any way.,"The function lower, de-",,,,,,,,,,
29,introduce a new value; instead it introduces a new,,,,fined as:,,,,,,strlen [] = result,,,,,
30,type. This gives us two very useful properties:,,,,,,,,,,"where result = ""No string given!""",,,,,
31,• No runtime cost is associated,with the new,,,lower s = map toLower s,,,,,,"strlen f = result ++ "" characters long!""",,,,,
32,"type, since it does not actually produce new",,,,,,,,,,where result = show (length f),,,,,
33,"which has the typevalues. In other words, newtypes",are abso-,,,,,,,,,,,,,,
34,lutely free!,,,,lower :: String String,,,,,,Where vs. Let,A where clause can only be de-,,,,
35,• The type-checker is able to enforce that com-,,,,,,,,,,fined at the level of a function definition.,,,,,"Usually,"
36,mon types such as Int or String are used in,,,,can be used on values with the type FirstName or,,,,,,that is identical to the scope of let definition.,,,,,The
