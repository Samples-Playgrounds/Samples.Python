<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Of course, this prevents our module from pattern-</th>
      <th>Instance Declarations</th>
      <th>It</th>
      <th>must</th>
      <th>be</th>
      <th>noted</th>
      <th>that</th>
      <th>Unnamed: 0</th>
      <th>Exports If an export list is not provided, then all</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>matching on the values of type Lexeme. We can</td>
      <td>instance declarations cannot be excluded from im-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>functions, types, constructors, etc. will be available</td>
    </tr>
    <tr>
      <th>1</th>
      <td>import one or more constructors explicitly:</td>
      <td>port: all instance declarations in a module will be</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>to anyone importing the module. Note that any im-</td>
    </tr>
    <tr>
      <th>2</th>
      <td></td>
      <td>imported when the module is imported.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>ported modules are not exported in this case. Limit-</td>
    </tr>
    <tr>
      <th>3</th>
      <td>import Text.Read (Lexeme(Ident, Symbol))</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>ing the names exported is accomplished by adding</td>
    </tr>
    <tr>
      <th>4</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>a parenthesized list of names before the where key-</td>
    </tr>
    <tr>
      <th>5</th>
      <td>All constructors for a given type can also be im-</td>
      <td>Qualified Imports The</td>
      <td>names</td>
      <td></td>
      <td>exported</td>
      <td>by</td>
      <td>a</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>6</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>word:</td>
    </tr>
    <tr>
      <th>7</th>
      <td>ported:</td>
      <td>module (i.e., functions,</td>
      <td>types,</td>
      <td>operators,</td>
      <td></td>
      <td>etc.)</td>
      <td>can</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>8</th>
      <td></td>
      <td>have a prefix attached through</td>
      <td></td>
      <td>qualified</td>
      <td></td>
      <td>imports.</td>
      <td></td>
      <td></td>
      <td>module MyModule (MyType</td>
    </tr>
    <tr>
      <th>9</th>
      <td>import Text.Read (Lexeme(..))</td>
      <td>This is particularly useful for modules which have</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>, MyClass</td>
    </tr>
    <tr>
      <th>10</th>
      <td></td>
      <td>a large number of functions having the same name</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>, myFunc1</td>
    </tr>
    <tr>
      <th>11</th>
      <td>We can also import types and classes defined in the</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>12</th>
      <td></td>
      <td>as Prelude functions. Data.Set is a good example:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>...)</td>
    </tr>
    <tr>
      <th>13</th>
      <td>module:</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>14</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>where</td>
    </tr>
    <tr>
      <th>15</th>
      <td>import Text.Read (Read, ReadS)</td>
      <td>import quali ed Data.Set as Set</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>16</th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>The same syntax as used for importing can be used</td>
    </tr>
    <tr>
      <th>17</th>
      <td>In the case of classes, we can import the functions</td>
      <td>This form requires any function,</td>
      <td></td>
      <td>type, constructor</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>here to specify which functions, types, construc-</td>
    </tr>
    <tr>
      <th>18</th>
      <td>defined for a class using syntax similar to import-</td>
      <td>or other name exported by Data.Set to now be pre-</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>tors, and classes are exported, with a few differ-</td>
    </tr>
  </tbody>
</table>